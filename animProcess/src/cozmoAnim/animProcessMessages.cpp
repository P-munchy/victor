/**
 * File: animProcessMessages.cpp
 *
 * Author: Kevin Yoon
 * Created: 6/30/2017
 *
 * Description: Shuttles messages between engine and robot processes.
 *              Responds to engine messages pertaining to animations
 *              and inserts messages as appropriate into robot-bound stream.
 *
 * Copyright: Anki, Inc. 2017
 **/

#include "cozmoAnim/animProcessMessages.h"
#include "cozmoAnim/cozmoAnimComms.h"

#include "cozmoAnim/animation/animationStreamer.h"
#include "cozmoAnim/audio/engineRobotAudioInput.h"
#include "cozmoAnim/cozmoAnimContext.h"
#include "cozmoAnim/faceDisplay/faceDisplay.h"
#include "cozmoAnim/faceDisplay/faceDebugDraw.h"
#include "cozmoAnim/micDataProcessor.h"
#include "audioEngine/multiplexer/audioMultiplexer.h"

#include "coretech/common/engine/utils/timer.h"

#include "clad/robotInterface/messageRobotToEngine.h"
#include "clad/robotInterface/messageEngineToRobot.h"
#include "clad/robotInterface/messageRobotToEngine_sendAnimToEngine_helper.h"
#include "clad/robotInterface/messageEngineToRobot_sendAnimToRobot_helper.h"

#include "anki/cozmo/shared/cozmoConfig.h"

#include "osState/osState.h"

#include "util/console/consoleInterface.h"
#include "util/console/consoleSystem.h"
#include "util/fileUtils/fileUtils.h"
#include "util/logging/logging.h"

// Log options
#define LOG_CHANNEL    "AnimProcessMessages"

// Trace options
// #define LOG_TRACE(name, format, ...) PRINT_CH_DEBUG(LOG_CHANNEL, name, format, ##__VA_ARGS__)
#define LOG_TRACE(name, format, ...) {}

// Anonymous namespace for private declarations
namespace {

  // For comms with engine
  constexpr int MAX_PACKET_BUFFER_SIZE = 2048;
  u8 pktBuffer_[MAX_PACKET_BUFFER_SIZE];

  Anki::Cozmo::AnimationStreamer*            _animStreamer = nullptr;
  Anki::Cozmo::Audio::EngineRobotAudioInput* _audioInput = nullptr;
  const Anki::Cozmo::CozmoAnimContext*       _context = nullptr;

  #ifndef SIMULATOR
  const u8 kNumTicksToCheckForBC = 60; // ~2seconds
  u8 _bcCheckCount = 0;
  #endif

  CONSOLE_VAR(bool, kDebugFaceDraw_CycleWithButton, "DebugFaceDraw", true);   

}

namespace Anki {
namespace Cozmo {

// ========== START OF PROCESSING MESSAGES FROM ENGINE ==========  
// #pragma mark "EngineToRobot Handlers"

void Process_lockAnimTracks(const Anki::Cozmo::RobotInterface::LockAnimTracks& msg)
{
  //LOG_DEBUG("AnimProcessMessages.Process_lockAnimTracks", "0x%x", msg.whichTracks);
  _animStreamer->SetLockedTracks(msg.whichTracks);
}
    
void Process_playAnim(const Anki::Cozmo::RobotInterface::PlayAnim& msg)
{
  const std::string animName(msg.animName, msg.animName_length);

  LOG_INFO("AnimProcessMessages.Process_playAnim",
           "Anim: %s, Tag: %d",
           animName.c_str(), msg.tag);
    
  _animStreamer->SetStreamingAnimation(animName, msg.tag, msg.numLoops);
}

void Process_abortAnimation(const Anki::Cozmo::RobotInterface::AbortAnimation& msg)
{
  LOG_INFO("AnimProcessMessages.Process_abortAnimation", "Abort animation");
  _animStreamer->Abort();
}
  
void Process_displayProceduralFace(const Anki::Cozmo::RobotInterface::DisplayProceduralFace& msg)
{
  ProceduralFace procFace;
  procFace.SetFromMessage(msg.faceParams);
  _animStreamer->SetProceduralFace(procFace, msg.duration_ms);
}
  
void Process_setFaceHue(const Anki::Cozmo::RobotInterface::SetFaceHue& msg)
{
  ProceduralFace::SetHue(msg.hue);
}

void Process_displayFaceImageBinaryChunk(const Anki::Cozmo::RobotInterface::DisplayFaceImageBinaryChunk& msg)
{
  _animStreamer->Process_displayFaceImageChunk(msg);
}

void Process_displayFaceImageRGBChunk(const Anki::Cozmo::RobotInterface::DisplayFaceImageRGBChunk& msg)
{
  _animStreamer->Process_displayFaceImageChunk(msg);
}

void Process_postAudioEvent(const Anki::AudioEngine::Multiplexer::PostAudioEvent& msg)
{
  _audioInput->HandleMessage(msg);
}

void Process_stopAllAudioEvents(const Anki::AudioEngine::Multiplexer::StopAllAudioEvents& msg)
{
  _audioInput->HandleMessage(msg);
}

void Process_postAudioGameState(const Anki::AudioEngine::Multiplexer::PostAudioGameState& msg)
{
  _audioInput->HandleMessage(msg);
}

void Process_postAudioSwitchState(const Anki::AudioEngine::Multiplexer::PostAudioSwitchState& msg)
{
  _audioInput->HandleMessage(msg);
}

void Process_postAudioParameter(const Anki::AudioEngine::Multiplexer::PostAudioParameter& msg)
{
  _audioInput->HandleMessage(msg);
}
  
void Process_setDebugConsoleVarMessage(const Anki::Cozmo::RobotInterface::SetDebugConsoleVarMessage& msg)
{
  // We are using messages generated by the CppLite emitter here, which does not support
  // variable length arrays. CLAD also doesn't have a char, so the "strings" in this message
  // are actually arrays of uint8's. Thus we need to do this reinterpret cast here.
  // In some future world, ideally we avoid all this and use, for example, a web interface to
  // set/access console vars, instead of passing around via CLAD messages.
  const char* varName  = reinterpret_cast<const char *>(msg.varName);
  const char* tryValue = reinterpret_cast<const char *>(msg.tryValue);

  // TODO: Ideally, we'd send back a verify message that we (failed to) set this

  Anki::Util::IConsoleVariable* consoleVar = Anki::Util::ConsoleSystem::Instance().FindVariable(varName);
  if (consoleVar && consoleVar->ParseText(tryValue))
  {
    //SendVerifyDebugConsoleVarMessage(_externalInterface, varName, consoleVar->ToString().c_str(), consoleVar, true);
    LOG_INFO("AnimProcessMessages.Process_setDebugConsoleVarMessage.Success", "'%s' set to '%s'", varName, tryValue);
  }
  else
  {
    LOG_WARNING("AnimProcessMessages.Process_setDebugConsoleVarMessage.Fail", "Error setting '%s' to '%s'",
                varName, tryValue);
    //      SendVerifyDebugConsoleVarMessage(_externalInterface, msg.varName.c_str(),
    //                                       consoleVar ? "Error: Failed to Parse" : "Error: No such variable",
    //                                       consoleVar, false);
  }
}

void Process_startRecordingMics(const Anki::Cozmo::RobotInterface::StartRecordingMics& msg)
{
  auto* micDataProcessor = _context->GetMicDataProcessor();
  if (micDataProcessor == nullptr)
  {
    return;
  }

  micDataProcessor->RecordRawAudio(msg.duration_ms,
                                   std::string(msg.path,
                                               msg.path_length),
                                   msg.runFFT);
}

void Process_drawTextOnScreen(const Anki::Cozmo::RobotInterface::DrawTextOnScreen& msg)
{
  FaceDisplay::GetDebugDraw()->SetCustomText(msg);
}
  
void Process_runDebugConsoleFuncMessage(const Anki::Cozmo::RobotInterface::RunDebugConsoleFuncMessage& msg)
{
  // We are using messages generated by the CppLite emitter here, which does not support
  // variable length arrays. CLAD also doesn't have a char, so the "strings" in this message
  // are actually arrays of uint8's. Thus we need to do this reinterpret cast here.
  // In some future world, ideally we avoid all this and use, for example, a web interface to
  // set/access console vars, instead of passing around via CLAD messages.
  const char* funcName  = reinterpret_cast<const char *>(msg.funcName);
  const char* funcArgs = reinterpret_cast<const char *>(msg.funcArgs);

  // TODO: Ideally, we'd send back a verify message that we (failed to) set this
  Anki::Util::IConsoleFunction* consoleFunc = Anki::Util::ConsoleSystem::Instance().FindFunction(funcName);
  if (consoleFunc) {
    enum { kBufferSize = 512 };
    char buffer[kBufferSize];
    const uint32_t res = NativeAnkiUtilConsoleCallFunction(funcName, funcArgs, kBufferSize, buffer);
    LOG_INFO("AnimProcessMessages.Process_runDebugConsoleFuncMessage", "%s '%s' set to '%s'",
                     (res != 0) ? "Success" : "Failure", funcName, funcArgs);
  }
  else
  {
    LOG_WARNING("AnimProcessMessages.Process_runDebugConsoleFuncMessage.NoConsoleFunc", "No Func named '%s'",funcName);
  }
}

void AnimProcessMessages::ProcessMessageFromEngine(const RobotInterface::EngineToRobot& msg)
{
  //LOG_WARNING("AnimProcessMessages.ProcessMessageFromEngine", "%d", msg.tag);
  bool forwardToRobot = false;
  switch (msg.tag)
  {

#include "clad/robotInterface/messageEngineToRobot_switch_from_0x50_to_0xAF.def"

    default:
      forwardToRobot = true;
      break;
  }

  if (forwardToRobot) {
    // Send message along to robot if it wasn't handled here
    CozmoAnimComms::SendPacketToRobot((char*)msg.GetBuffer(), msg.Size());
  }

} // ProcessMessageFromEngine()


// ========== END OF PROCESSING MESSAGES FROM ENGINE ==========


// ========== START OF PROCESSING MESSAGES FROM ROBOT ==========
// #pragma mark "RobotToEngine handlers"

static void ProcessMicDataMessage(const RobotInterface::MicData& payload)
{
  FaceDisplay::GetDebugDraw()->DrawMicInfo(payload);

  auto * micDataProcessor = _context->GetMicDataProcessor();
  if (micDataProcessor != nullptr)
  {
    micDataProcessor->ProcessMicDataPayload(payload);
  }
}

static void HandleRobotStateUpdate(const Anki::Cozmo::RobotState& robotState)
{
  FaceDisplay::GetDebugDraw()->DrawStateInfo(robotState);

  static bool buttonWasPressed = false;
  const auto buttonIsPressed = static_cast<bool>(robotState.status & (uint16_t)RobotStatusFlag::IS_BUTTON_PRESSED);
  const auto buttonReleased = buttonWasPressed && !buttonIsPressed;
  buttonWasPressed = buttonIsPressed;

  if (buttonReleased)
  {
    if(kDebugFaceDraw_CycleWithButton)
    {
      FaceDisplay::GetDebugDraw()->ChangeDrawState();
    }
  }

#if ANKI_DEV_CHEATS
  auto * micDataProcessor = _context->GetMicDataProcessor();
  if (micDataProcessor != nullptr)
  {
    const auto liftHeight_mm = ConvertLiftAngleToLiftHeightMM(robotState.liftAngle);
    if (LIFT_HEIGHT_CARRY-1.f <= liftHeight_mm)
    {
      micDataProcessor->SetForceRecordClip(true);
    }
  }
#endif
}

void AnimProcessMessages::ProcessMessageFromRobot(const RobotInterface::RobotToEngine& msg)
{
  const auto tag = msg.tag;
  switch (tag)
  {
    case RobotInterface::RobotToEngine::Tag_micData:
    {
      const auto& payload = msg.micData;
      ProcessMicDataMessage(payload);
      return;
    }
    break;
    case RobotInterface::RobotToEngine::Tag_state:
    {
      HandleRobotStateUpdate(msg.state);
    }
    break;
    default:
    {

    }
    break;
  }

  // Forward to engine
  SendAnimToEngine(msg);

} // ProcessMessageFromRobot()

// ========== END OF PROCESSING MESSAGES FROM ROBOT ==========

// ========== START OF CLASS METHODS ==========
// #pragma mark "Class methods"

Result AnimProcessMessages::Init(AnimationStreamer* animStreamer,
                                 Audio::EngineRobotAudioInput* audioInput,
                                 const CozmoAnimContext* context)
{
  // Setup robot and engine sockets
  CozmoAnimComms::InitComms();

  _animStreamer = animStreamer;
  _audioInput   = audioInput;
  _context      = context;

  DEV_ASSERT(_animStreamer != nullptr, "AnimProcessMessages.Init.NullAnimStreamer");
  DEV_ASSERT(_audioInput != nullptr, "AnimProcessMessages.Init.NullAudioInput");
  DEV_ASSERT(_context != nullptr, "AnimProcessMessages.Init.NullContext");

  #ifdef SIMULATOR
  const bool haveBC = true;
  #else
  const bool haveBC = Util::FileUtils::FileExists("/data/persist/factory/80000000.nvdata");
  #endif

  FaceDisplay::GetDebugDraw()->SetShouldDrawFAC(!haveBC);

  return RESULT_OK;
}


Result AnimProcessMessages::MonitorConnectionState(void)
{
  // Send block connection state when engine connects
  static bool wasConnected = false;
  if (!wasConnected && CozmoAnimComms::IsConnectedToEngine()) {
    LOG_INFO("AnimProcessMessages.MonitorConnectionState", "Robot now available");
    RobotInterface::RobotAvailable idMsg;
    idMsg.hwRevision = 0;
    idMsg.serialNumber = OSState::getInstance()->GetSerialNumber();
    RobotInterface::SendAnimToEngine(idMsg);

    // send firmware info indicating simulated or physical robot type
    {
#ifdef SIMULATOR
      std::string firmwareJson{"{\"version\":0,\"time\":0,\"sim\":0}"};
#else
      std::string firmwareJson{"{\"version\":0,\"time\":0}"};
#endif
      RobotInterface::FirmwareVersion msg;
      msg.RESRVED = 0;
      msg.json_length = firmwareJson.size() + 1;
      std::memcpy(msg.json, firmwareJson.c_str(), firmwareJson.size() + 1);
      RobotInterface::SendAnimToEngine(msg);
    }

    wasConnected = true;
  }
  else if (wasConnected && !CozmoAnimComms::IsConnectedToEngine()) {
    wasConnected = false;
  }

  return RESULT_OK;

}

void AnimProcessMessages::Update(BaseStationTime_t currTime_nanosec)
{
  if (!CozmoAnimComms::IsConnectedToRobot()) {
    CozmoAnimComms::InitRobotComms();
  }

  MonitorConnectionState();

  _context->GetMicDataProcessor()->Update(currTime_nanosec);

  // Process incoming messages from engine
  u32 dataLen;

  // Process messages from engine
  while((dataLen = CozmoAnimComms::GetNextPacketFromEngine(pktBuffer_, MAX_PACKET_BUFFER_SIZE)) > 0)
  {
    Anki::Cozmo::RobotInterface::EngineToRobot msg;
    memcpy(msg.GetBuffer(), pktBuffer_, dataLen);
    if (msg.Size() != dataLen) {
      LOG_WARNING("AnimProcessMessages.Update.EngineToRobot.InvalidSize",
                  "Invalid message size from engine (%d != %d)",
                  msg.Size(), dataLen);
      continue;
    }
    if (!msg.IsValid()) {
      LOG_WARNING("AnimProcessMessages.Update.EngineToRobot.InvalidData", "Invalid message from engine");
      continue;
    }
    ProcessMessageFromEngine(msg);
  }

  // Process messages from robot
  while ((dataLen = CozmoAnimComms::GetNextPacketFromRobot(pktBuffer_, MAX_PACKET_BUFFER_SIZE)) > 0)
  {
    Anki::Cozmo::RobotInterface::RobotToEngine msg;
    memcpy(msg.GetBuffer(), pktBuffer_, dataLen);
    if (msg.Size() != dataLen) {
      LOG_WARNING("AnimProcessMessages.Update.RobotToEngine.InvalidSize",
                  "Invalid message size from robot (%d != %d)",
                  msg.Size(), dataLen);
      continue;
    }
    if (!msg.IsValid()) {
      LOG_WARNING("AnimProcessMessages.Update.RobotToEngine.InvalidData", "Invalid message from robot");
      continue;
    }
    ProcessMessageFromRobot(msg);
  }

  #ifndef SIMULATOR
  if(++_bcCheckCount >= kNumTicksToCheckForBC)
  {
    _bcCheckCount = 0;
    const bool haveBC = Util::FileUtils::FileExists("/data/persist/factory/80000000.nvdata");
    FaceDisplay::GetDebugDraw()->SetShouldDrawFAC(!haveBC);
  }
  #endif
}

bool AnimProcessMessages::SendAnimToRobot(const RobotInterface::EngineToRobot& msg)
{
  LOG_TRACE("AnimProcessMessages.SendAnimToRobot", "Send tag %d size %u", msg.tag, msg.Size());
  return CozmoAnimComms::SendPacketToRobot(msg.GetBuffer(), msg.Size());
}
  
bool AnimProcessMessages::SendAnimToEngine(const RobotInterface::RobotToEngine & msg)
{
  LOG_TRACE("AnimProcessMessages.SendAnimToEngine", "Send tag %d size %u", msg.tag, msg.Size());
  return CozmoAnimComms::SendPacketToEngine(msg.GetBuffer(), msg.Size());
}

} // namespace Cozmo
} // namespace Anki

