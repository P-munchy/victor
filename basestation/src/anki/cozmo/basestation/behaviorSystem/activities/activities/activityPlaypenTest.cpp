/**
 * File: activityPlaypenTest.cpp
 *
 * Author: Al Chaussee
 * Created: 07/25/17
 *
 * Description:
 *
 * Copyright: Anki, Inc. 2017
 *
 **/

#include "anki/cozmo/basestation/behaviorSystem/activities/activities/activityPlaypenTest.h"

#include "anki/cozmo/basestation/behaviorSystem/behaviorManager.h"
#include "anki/cozmo/basestation/behaviorSystem/behaviors/devBehaviors/playpen/iBehaviorPlaypen.h"
#include "anki/cozmo/basestation/behaviorSystem/behaviorPreReqs/behaviorPreReqPlaypen.h"
#include "anki/cozmo/basestation/blockWorld/blockWorld.h"
#include "anki/cozmo/basestation/components/nvStorageComponent.h"
#include "anki/cozmo/basestation/cozmoContext.h"
#include "anki/cozmo/basestation/robot.h"
#include "anki/cozmo/basestation/robotManager.h"


namespace Anki {
namespace Cozmo {

namespace {

}

ActivityPlaypenTest::ActivityPlaypenTest(Robot& robot, const Json::Value& config)
: IActivity(robot, config)
{
  const auto& BM = robot.GetBehaviorManager();
  
  IBehaviorPtr motorCalibBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenMotorCalibration);
  DEV_ASSERT(motorCalibBehavior != nullptr &&
             motorCalibBehavior->GetClass() == BehaviorClass::PlaypenMotorCalibration,
             "ActivityPlaypenTest.ImproperClassRetrievedForName");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(motorCalibBehavior));
  
  IBehaviorPtr driftCheckBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenDriftCheck);
  DEV_ASSERT(driftCheckBehavior != nullptr &&
             driftCheckBehavior->GetClass() == BehaviorClass::PlaypenDriftCheck,
             "ActivityPlaypenTest.ImproperClassRetrievedForName");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(driftCheckBehavior));
  
  IBehaviorPtr cameraCalibBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenCameraCalibration);
  DEV_ASSERT(cameraCalibBehavior != nullptr &&
             cameraCalibBehavior->GetClass() == BehaviorClass::PlaypenCameraCalibration,
             "ActivityPlaypenTest.ImproperClassRetrievedForName");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(cameraCalibBehavior));

  IBehaviorPtr driveFowardsBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenDriveForwards);
  DEV_ASSERT(driveFowardsBehavior != nullptr &&
             driveFowardsBehavior->GetClass() == BehaviorClass::PlaypenDriveForwards,
             "ActivityPlaypenTest.ImproperClassRetrievedForName");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(driveFowardsBehavior));


  _currentPlaypenBehaviorIter = _playpenBehaviors.begin();
  _currentBehavior = *_currentPlaypenBehaviorIter;
}

void ActivityPlaypenTest::OnSelectedInternal(Robot& robot)
{
  // Disable all reactions, we will handle them ourselves
  SmartDisableReactionsWithLock(robot, GetIDStr(), ReactionTriggerHelpers::kAffectAllArray);
  
  // Start the factory log
  std::stringstream serialNumString;
  serialNumString << std::hex << robot.GetHeadSerialNumber();
  _factoryTestLogger.StartLog( serialNumString.str(), true, robot.GetContextDataPlatform());
  PRINT_NAMED_INFO("BehaviorFactoryTest.WillLogToDevice",
                   "Log name: %s",
                   _factoryTestLogger.GetLogName().c_str());
}

void ActivityPlaypenTest::OnDeselectedInternal(Robot& robot)
{
  for(auto& behavior : _playpenBehaviors)
  {
    behavior->Reset();
  }
  
  _currentPlaypenBehaviorIter = _playpenBehaviors.begin();
  
  _currentBehavior = *_currentPlaypenBehaviorIter;
}

Result ActivityPlaypenTest::Update(Robot& robot)
{
  if(_currentBehavior != nullptr)
  {
    const FactoryTestResultCode result = _currentBehavior->GetResults();
    if(result != FactoryTestResultCode::UNKNOWN &&
       result != FactoryTestResultCode::SUCCESS)
    {
      _currentBehavior->Stop();
      
      PRINT_NAMED_WARNING("", "Behavior %s failed with %s", _currentBehavior->GetIDStr().c_str(),
                          EnumToString(_currentBehavior->GetResults()));
      HandleFailure(robot, result);
      return RESULT_FAIL;
    }
  }
  return RESULT_OK;
}

IBehaviorPtr ActivityPlaypenTest::ChooseNextBehaviorInternal(Robot& robot, IBehaviorPtr currentRunningBehavior)
{
  // If the current behavior has completed
  if(_currentBehavior->GetResults() == FactoryTestResultCode::SUCCESS)
  {
    // Stop it if it is still running
    if(_currentBehavior->IsRunning())
    {
      _currentBehavior->Stop();
    }
    
    _currentPlaypenBehaviorIter++;
    
    // If we still have behaviors to run
    if(_currentPlaypenBehaviorIter != _playpenBehaviors.end())
    {
      // Update current behavior and increment iterator
      _currentBehavior = *_currentPlaypenBehaviorIter;
      
      // Pass the factory test logger to the behavior
      BehaviorPreReqPlaypen preReq(_factoryTestLogger);
      
      if(!_currentBehavior->IsRunnable(preReq))
      {
        PRINT_NAMED_ERROR("ActivityPlaypenTest.ChooseNextBehaviorInternal.BehaviorNotRunnable",
                          "Current behavior %s is not runnable",
                          _currentBehavior->GetIDStr().c_str());
        HandleFailure(robot, FactoryTestResultCode::BEHAVIOR_NOT_RUNNABLE);
        return nullptr;
      }
      
      return _currentBehavior;
    }
    // All playpen behaviors have run so success!
    else
    {
      HandleSuccess(robot, FactoryTestResultCode::SUCCESS);
      return nullptr;
    }
  }
  else
  {
    // Current behavior hasn't completed yet
    return _currentBehavior;
  }
}

void ActivityPlaypenTest::HandleSuccess(Robot& robot, FactoryTestResultCode result)
{
  PRINT_NAMED_WARNING("", "success");
  HandleResultInternal(robot, result);
}

void ActivityPlaypenTest::HandleFailure(Robot& robot, FactoryTestResultCode result)
{
  PRINT_NAMED_WARNING("", "failure");
  HandleResultInternal(robot, result);
}

void ActivityPlaypenTest::HandleResultInternal(Robot& robot, FactoryTestResultCode result)
{
  FactoryTestResultEntry resultEntry;
  resultEntry.result = result;
  //TODO: populate rest of result entry
  
  if(!_factoryTestLogger.Append(resultEntry))
  {
    PRINT_NAMED_ERROR("", "failed to write result entry to log");
  }
  
  u8 buf[resultEntry.Size()];
  size_t numBytes = resultEntry.Pack(buf, sizeof(buf));
  if(!robot.GetNVStorageComponent().Write(NVStorage::NVEntryTag::NVEntry_PlaypenTestResults,
                                          buf,
                                          numBytes))
  {
    PRINT_NAMED_ERROR("", "failed to write results to robot");
  }

  _factoryTestLogger.CloseLog();
  
  robot.GetBehaviorManager().SetCurrentActivity(HighLevelActivity::Selection);
  
  //TODO: Disconnect, turn off robot, send log and images to fixture, and display result code
}

}
}

