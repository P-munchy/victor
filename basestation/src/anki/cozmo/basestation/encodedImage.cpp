/**
 * File: encodedImage.cpp
 *
 * Author: Andrew Stein
 * Date:   6/9/2016
 *
 * Description: Implements a container for encoded images on the basestation.
 *
 * Copyright: Anki, Inc. 2016
 **/

#include "anki/cozmo/basestation/encodedImage.h"

#include "anki/vision/basestation/image.h"

#include "util/fileUtils/fileUtils.h"

#if ANKICORETECH_USE_OPENCV
#include "opencv2/core.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/imgcodecs.hpp"
#endif

namespace Anki {
namespace Cozmo {
  
  EncodedImage::EncodedImage()
  : _timestamp(0)
  , _imgWidth(0)
  , _imgHeight(0)
  , _imgID(std::numeric_limits<u32>::max())
  , _encoding(ImageEncoding::NoneImageEncoding)
  , _expectedChunkId(0)
  , _isImgValid(false)
  {
    
  }

  bool EncodedImage::AddChunk(const ImageChunk &chunk)
  {
    if(chunk.data.size() > static_cast<u32>(ImageConstants::IMAGE_CHUNK_SIZE)) {
      PRINT_NAMED_WARNING("ImageDeChunker.AppendChunk",
                          "Expecting chunks of size no more than %d, got %zu.",
                          ImageConstants::IMAGE_CHUNK_SIZE, chunk.data.size());
      return false;
    }
    
    // If image ID has changed, then start over.
    if (chunk.imageId != _imgID)
    {
      _imgID           = chunk.imageId;
      const Vision::ImageDims& imageDims = Vision::CameraResInfo[(int)chunk.resolution];
      _imgWidth        = imageDims.width;;
      _imgHeight       = imageDims.height;
      _isImgValid      = (chunk.chunkId == 0);
      _expectedChunkId = 0;
      _encoding        = chunk.imageEncoding;
      
      _buffer.clear();
      _buffer.reserve(_imgWidth*_imgHeight*sizeof(Vision::PixelRGB));

    }
    
    // Check if a chunk was received out of order
    if (chunk.chunkId != _expectedChunkId) {
      PRINT_NAMED_INFO("EncodedImage.AddChunk.ChunkDropped",
                       "Expected chunk %d, got %d", _expectedChunkId, chunk.chunkId);
      _isImgValid = false;
    }
    
    _expectedChunkId = chunk.chunkId + 1;
    
    // We've received all data when the msg chunkSize is less than the max
    const bool isLastChunk =  chunk.chunkId == chunk.imageChunkCount-1;
    if(isLastChunk) {
      _timestamp = chunk.frameTimeStamp;
    }
    
    if (!_isImgValid) {
      if (isLastChunk) {
        PRINT_NAMED_INFO("EncodedImage.AddChunk.IncompleteImage",
                         "Received last chunk of invalidated image");
      }
      return false;
    }
    
    // Image chunks are assumed/guaranteed to be received in order so  we just
    // blindly append data to array
    _buffer.insert(_buffer.end(), chunk.data.begin(), chunk.data.end());
    
    return isLastChunk;
  }
  
  Vision::ImageRGB EncodedImage::DecodeImageRGB() const
  {
    cv::Mat cvImg;
    
    switch(_encoding)
    {
      case ImageEncoding::JPEGColor:
      {
        cvImg = cv::imdecode(_buffer, cv::IMREAD_COLOR);
        cvtColor(cvImg, cvImg, CV_BGR2RGB);
        break;
      }
        
      case ImageEncoding::JPEGMinimizedGray:
      {
        std::vector<u8> tempBuffer;
        MiniGrayToJpeg(_buffer, _imgHeight, _imgWidth, tempBuffer);
        cvImg = cv::imdecode(tempBuffer, cv::IMREAD_GRAYSCALE);
        break;
      }
        
      case ImageEncoding::JPEGGray:
      {
        cvImg = cv::imdecode(_buffer, cv::IMREAD_GRAYSCALE);
        break;
      }
        
      case ImageEncoding::RawGray:
      {
        // Already decompressed.
        // Raw image bytes is the same as total received bytes.
        cvImg = cv::Mat_<u8>(_imgHeight, _imgWidth, const_cast<u8*>(&(_buffer[0])));
        break;
      }
        
      case ImageEncoding::RawRGB:
        // Already decompressed.
        // Raw image bytes is the same as total received bytes.
        cvImg = cv::Mat(_imgHeight, _imgWidth, CV_8UC3, const_cast<u8*>(&(_buffer[0])));
        break;
        
      case ImageEncoding::JPEGColorHalfWidth:
      {
        cvImg = cv::imdecode(_buffer, cv::IMREAD_COLOR);
        cvtColor(cvImg, cvImg, CV_BGR2RGB);
        cv::copyMakeBorder(cvImg, cvImg, 0, 0, 160, 160, cv::BORDER_CONSTANT, 0);
        break;
      }
        
      default:
        PRINT_NAMED_ERROR("EncodedImage.DecodeImageRGB.UnsupportedEncoding",
                          "Encoding %s not yet supported for decoding image chunks",
                          EnumToString(_encoding));
        
        // Return empty image
        return Vision::ImageRGB();
        
    } // switch(encoding)
    
    
    if(cvImg.rows != _imgHeight || cvImg.cols != _imgWidth)
    {
      PRINT_NAMED_WARNING("EncodedImage.DecodeImageRGB.BadDecode",
                          "Failed to decode %dx%d image from buffer. Got %dx%d",
                          _imgWidth, _imgHeight, cvImg.cols, cvImg.rows);
      
      return Vision::ImageRGB();
    }
    
    if(cvImg.channels() == 1) {
      cv::cvtColor(cvImg, cvImg, CV_GRAY2RGB);
    }
    
    Vision::ImageRGB image(_imgHeight, _imgWidth, cvImg.data);
    image.SetTimestamp(_timestamp);
    
    return image;
  }
  
  Result EncodedImage::Save(const std::string& filename) const
  {
    const std::vector<u8>* bufferPtr = &_buffer;
    std::vector<u8> tempBuffer;
    
    if(_encoding == ImageEncoding::JPEGMinimizedGray)
    {
      // If this buffer is encoded as our homebrew "MinimzedGray" JPEG,
      // we need to convert it for storage so it can be read by normal
      // JPEG decoders
      MiniGrayToJpeg(_buffer, _imgHeight, _imgWidth, tempBuffer);
      bufferPtr = &tempBuffer;
    }
    
    const bool success = Util::FileUtils::WriteFile(filename, *bufferPtr);
    
    if(success) {
      return RESULT_OK;
    } else {
      PRINT_NAMED_WARNING("EncodedImage.Save.WriteFail", "Filename: %s",
                          filename.c_str());
      return RESULT_FAIL;
    }
  }
  
  
  // Turn a fully assembled MINIPEG_GRAY image into a JPEG with header and footer
  // This is a port of C# code from Nathan.
  void EncodedImage::MiniGrayToJpeg(const std::vector<u8>& bufferIn, const u16 height, const u16 width,
                                    std::vector<u8>& bufferOut)
  {
    // Fetch quality to decide which header to use
    //const int quality = bufferIn[0];
    const int quality = 50;
    
    // Pre-baked JPEG header for grayscale, Q50
    static const u8 header50[] = {
      0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01,
      0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x10, 0x0B, 0x0C, 0x0E, 0x0C, 0x0A, 0x10, // 0x19 = QTable
      0x0E, 0x0D, 0x0E, 0x12, 0x11, 0x10, 0x13, 0x18, 0x28, 0x1A, 0x18, 0x16, 0x16, 0x18, 0x31, 0x23,
      0x25, 0x1D, 0x28, 0x3A, 0x33, 0x3D, 0x3C, 0x39, 0x33, 0x38, 0x37, 0x40, 0x48, 0x5C, 0x4E, 0x40,
      0x44, 0x57, 0x45, 0x37, 0x38, 0x50, 0x6D, 0x51, 0x57, 0x5F, 0x62, 0x67, 0x68, 0x67, 0x3E, 0x4D,
      
      //0x71, 0x79, 0x70, 0x64, 0x78, 0x5C, 0x65, 0x67, 0x63, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0xF0, // 0x5E = Height x Width
      0x71, 0x79, 0x70, 0x64, 0x78, 0x5C, 0x65, 0x67, 0x63, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x01, 0x28, // 0x5E = Height x Width
      
      //0x01, 0x40, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0xD2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01,
      0x01, 0x90, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0xD2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01,
      
      0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,
      0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03,
      0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
      0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08,
      0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16,
      0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
      0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
      0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
      0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
      0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
      0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4,
      0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA,
      0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01,
      0x00, 0x00, 0x3F, 0x00
    };
    
    // Pre-baked JPEG header for grayscale, Q80
    static const u8 header80[] = {
      0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01,
      0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x06, 0x04, 0x05, 0x06, 0x05, 0x04, 0x06,
      0x06, 0x05, 0x06, 0x07, 0x07, 0x06, 0x08, 0x0A, 0x10, 0x0A, 0x0A, 0x09, 0x09, 0x0A, 0x14, 0x0E,
      0x0F, 0x0C, 0x10, 0x17, 0x14, 0x18, 0x18, 0x17, 0x14, 0x16, 0x16, 0x1A, 0x1D, 0x25, 0x1F, 0x1A,
      0x1B, 0x23, 0x1C, 0x16, 0x16, 0x20, 0x2C, 0x20, 0x23, 0x26, 0x27, 0x29, 0x2A, 0x29, 0x19, 0x1F,
      0x2D, 0x30, 0x2D, 0x28, 0x30, 0x25, 0x28, 0x29, 0x28, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0xF0,
      0x01, 0x40, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0xD2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01,
      0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,
      0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03,
      0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
      0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08,
      0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16,
      0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
      0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
      0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
      0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
      0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
      0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4,
      0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA,
      0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01,
      0x00, 0x00, 0x3F, 0x00
    };
    
    const u8* header = nullptr;
    int headerLength = 0;
    switch(quality)
    {
      case 50:
        header = header50;
        headerLength = sizeof(header50);
        break;
      case 80:
        header = header80;
        headerLength = sizeof(header80);
        break;
      default:
        PRINT_NAMED_ERROR("miniGrayToJpeg", "No header for quality of %d", quality);
        return;
    }
    
    assert(header != nullptr);
    assert(headerLength > 0);
    
    // Allocate enough space for worst case expansion
    size_t bufferLength = bufferIn.size();
    bufferOut.resize(bufferLength*2 + headerLength);
    
    std::copy(header, header+headerLength, bufferOut.begin());
    // Adjust header size information
    bufferOut[0x5e] = height >> 8;
    bufferOut[0x5f] = height & 0xff;
    bufferOut[0x60] = width  >> 8;
    bufferOut[0x61] = width  & 0xff;
    
    while (bufferIn[bufferLength-1] == 0xff) {
      bufferLength--; // Remove trailing 0xFF padding
    }
    
    // Add byte stuffing - one 0 after each 0xff
    int off = headerLength;
    for (int i = 1; i < bufferLength; i++)
    {
      bufferOut[off++] = bufferIn[i];
      if (bufferIn[i] == 0xff) {
        bufferOut[off++] = 0;
      }
    }
    
    bufferOut[off++] = 0xFF;
    bufferOut[off++] = 0xD9;
    
    bufferOut.resize(off);
    
  } // MiniGrayToJpeg()
  
} // namespace Cozmo
} // namespace Anki
