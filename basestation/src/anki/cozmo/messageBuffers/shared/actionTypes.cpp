// Autogenerated C++ message buffer code.
// Source: anki/cozmo/messageBuffers/shared/actionTypes.clad
// Full command line: ../tools/message-buffers/emitters/CPP_emitter.py -C src -r ../basestation/include -o ../basestation/src --header-output-extension .def anki/cozmo/messageBuffers/shared/actionTypes.clad

#include "anki/cozmo/messageBuffers/shared/actionTypes.def"

namespace Anki {

namespace Cozmo {

const char* RobotActionTypeToString(const RobotActionType m)
{
	switch(m) {
		case RobotActionType::COMPOUND: return "COMPOUND"; break;
		case RobotActionType::UNKNOWN: return "UNKNOWN"; break;
		case RobotActionType::DRIVE_TO_POSE: return "DRIVE_TO_POSE"; break;
		case RobotActionType::DRIVE_TO_OBJECT: return "DRIVE_TO_OBJECT"; break;
		case RobotActionType::DRIVE_TO_PLACE_CARRIED_OBJECT: return "DRIVE_TO_PLACE_CARRIED_OBJECT"; break;
		case RobotActionType::TURN_IN_PLACE: return "TURN_IN_PLACE"; break;
		case RobotActionType::MOVE_HEAD_TO_ANGLE: return "MOVE_HEAD_TO_ANGLE"; break;
		case RobotActionType::PICKUP_OBJECT_LOW: return "PICKUP_OBJECT_LOW"; break;
		case RobotActionType::PICKUP_OBJECT_HIGH: return "PICKUP_OBJECT_HIGH"; break;
		case RobotActionType::PLACE_OBJECT_LOW: return "PLACE_OBJECT_LOW"; break;
		case RobotActionType::PLACE_OBJECT_HIGH: return "PLACE_OBJECT_HIGH"; break;
		case RobotActionType::PICK_AND_PLACE_INCOMPLETE: return "PICK_AND_PLACE_INCOMPLETE"; break;
		case RobotActionType::CROSS_BRIDGE: return "CROSS_BRIDGE"; break;
		case RobotActionType::ASCEND_OR_DESCEND_RAMP: return "ASCEND_OR_DESCEND_RAMP"; break;
		case RobotActionType::TRAVERSE_OBJECT: return "TRAVERSE_OBJECT"; break;
		case RobotActionType::DRIVE_TO_AND_TRAVERSE_OBJECT: return "DRIVE_TO_AND_TRAVERSE_OBJECT"; break;
		case RobotActionType::FACE_OBJECT: return "FACE_OBJECT"; break;
		case RobotActionType::VISUALLY_VERIFY_OBJECT: return "VISUALLY_VERIFY_OBJECT"; break;
		case RobotActionType::PLAY_ANIMATION: return "PLAY_ANIMATION"; break;
		case RobotActionType::PLAY_SOUND: return "PLAY_SOUND"; break;
		case RobotActionType::WAIT: return "WAIT"; break;
		case RobotActionType::MOVE_LIFT_TO_HEIGHT: return "MOVE_LIFT_TO_HEIGHT"; break;
		default: return nullptr;
	}
	return nullptr;
}
const char* ActionResultToString(const ActionResult m)
{
	switch(m) {
		case ActionResult::SUCCESS: return "SUCCESS"; break;
		case ActionResult::RUNNING: return "RUNNING"; break;
		case ActionResult::FAILURE_TIMEOUT: return "FAILURE_TIMEOUT"; break;
		case ActionResult::FAILURE_PROCEED: return "FAILURE_PROCEED"; break;
		case ActionResult::FAILURE_RETRY: return "FAILURE_RETRY"; break;
		case ActionResult::FAILURE_ABORT: return "FAILURE_ABORT"; break;
		case ActionResult::CANCELLED: return "CANCELLED"; break;
		default: return nullptr;
	}
	return nullptr;
}
} // namespace Cozmo

} // namespace Anki

