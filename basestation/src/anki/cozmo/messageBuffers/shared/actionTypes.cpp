// Autogenerated C++ message buffer code.
// Source: anki/cozmo/messageBuffers/shared/actionTypes.clad
// Full command line: ../tools/anki-util/tools/message-buffers/emitters/CPP_emitter.py -C src -r ../basestation/include -o ../basestation/src --header-output-extension .def anki/cozmo/messageBuffers/shared/actionTypes.clad

#include "anki/cozmo/messageBuffers/shared/actionTypes.def"

namespace Anki {

namespace Cozmo {

const char* RobotActionTypeToString(const RobotActionType m)
{
	switch(m) {
		case RobotActionType::COMPOUND: return "COMPOUND"; break;
		case RobotActionType::UNKNOWN: return "UNKNOWN"; break;
		case RobotActionType::DRIVE_TO_POSE: return "DRIVE_TO_POSE"; break;
		case RobotActionType::DRIVE_TO_OBJECT: return "DRIVE_TO_OBJECT"; break;
		case RobotActionType::DRIVE_TO_PLACE_CARRIED_OBJECT: return "DRIVE_TO_PLACE_CARRIED_OBJECT"; break;
		case RobotActionType::TURN_IN_PLACE: return "TURN_IN_PLACE"; break;
		case RobotActionType::MOVE_HEAD_TO_ANGLE: return "MOVE_HEAD_TO_ANGLE"; break;
		case RobotActionType::PICKUP_OBJECT_LOW: return "PICKUP_OBJECT_LOW"; break;
		case RobotActionType::PICKUP_OBJECT_HIGH: return "PICKUP_OBJECT_HIGH"; break;
		case RobotActionType::PLACE_OBJECT_LOW: return "PLACE_OBJECT_LOW"; break;
		case RobotActionType::PLACE_OBJECT_HIGH: return "PLACE_OBJECT_HIGH"; break;
		case RobotActionType::ROLL_OBJECT_LOW: return "ROLL_OBJECT_LOW"; break;
		case RobotActionType::PICK_AND_PLACE_INCOMPLETE: return "PICK_AND_PLACE_INCOMPLETE"; break;
		case RobotActionType::CROSS_BRIDGE: return "CROSS_BRIDGE"; break;
		case RobotActionType::ASCEND_OR_DESCEND_RAMP: return "ASCEND_OR_DESCEND_RAMP"; break;
		case RobotActionType::MOUNT_CHARGER: return "MOUNT_CHARGER"; break;
		case RobotActionType::TRAVERSE_OBJECT: return "TRAVERSE_OBJECT"; break;
		case RobotActionType::DRIVE_TO_AND_TRAVERSE_OBJECT: return "DRIVE_TO_AND_TRAVERSE_OBJECT"; break;
		case RobotActionType::FACE_OBJECT: return "FACE_OBJECT"; break;
		case RobotActionType::VISUALLY_VERIFY_OBJECT: return "VISUALLY_VERIFY_OBJECT"; break;
		case RobotActionType::PLAY_ANIMATION: return "PLAY_ANIMATION"; break;
		case RobotActionType::PLAY_SOUND: return "PLAY_SOUND"; break;
		case RobotActionType::WAIT: return "WAIT"; break;
		case RobotActionType::MOVE_LIFT_TO_HEIGHT: return "MOVE_LIFT_TO_HEIGHT"; break;
		default: return nullptr;
	}
	return nullptr;
}
const char* ActionResultToString(const ActionResult m)
{
	switch(m) {
		case ActionResult::SUCCESS: return "SUCCESS"; break;
		case ActionResult::RUNNING: return "RUNNING"; break;
		case ActionResult::FAILURE_TIMEOUT: return "FAILURE_TIMEOUT"; break;
		case ActionResult::FAILURE_PROCEED: return "FAILURE_PROCEED"; break;
		case ActionResult::FAILURE_RETRY: return "FAILURE_RETRY"; break;
		case ActionResult::FAILURE_ABORT: return "FAILURE_ABORT"; break;
		case ActionResult::CANCELLED: return "CANCELLED"; break;
		default: return nullptr;
	}
	return nullptr;
}
// STRUCTURE ActionCompletedStruct

ActionCompletedStruct::ActionCompletedStruct(const uint8_t* buff, size_t len)
{
	const CLAD::SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	Unpack(buffer);
}

ActionCompletedStruct::ActionCompletedStruct(const CLAD::SafeMessageBuffer& buffer)
{
	Unpack(buffer);
}

size_t ActionCompletedStruct::Pack(uint8_t* buff, size_t len) const
{
	CLAD::SafeMessageBuffer buffer(buff, len, false);
	return Pack(buffer);
}

size_t ActionCompletedStruct::Pack(CLAD::SafeMessageBuffer& buffer) const
{
	buffer.WriteFArray<int32_t, 5>(this->objectIDs);
	buffer.Write(this->numObjects);
	buffer.WritePString<uint8_t>(this->animName);
	const size_t bytesWritten {buffer.GetBytesWritten()};
	return bytesWritten;
}

size_t ActionCompletedStruct::Unpack(const uint8_t* buff, const size_t len)
{
	const CLAD::SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
	return Unpack(buffer);
}

size_t ActionCompletedStruct::Unpack(const CLAD::SafeMessageBuffer& buffer)
{
	buffer.ReadFArray<int32_t, 5>(this->objectIDs);
	buffer.Read(this->numObjects);
	buffer.ReadPString<uint8_t>(this->animName);
	return buffer.GetBytesRead();
}

size_t ActionCompletedStruct::Size() const
{
	size_t result = 0;
	//objectIDs
	result += 4 * 5; // = int_32 * 5
	//numObjects
	result += 1; // = uint_8
	//animName
	result += 1; // length = uint_8
	result += 1 * animName.size(); //string
	return result;
}

bool ActionCompletedStruct::operator==(const ActionCompletedStruct& other) const
{
	if (objectIDs != other.objectIDs
	|| numObjects != other.numObjects
	|| animName != other.animName) {
		return false;
	}
	return true;
}

bool ActionCompletedStruct::operator!=(const ActionCompletedStruct& other) const
{
	return !(operator==(other));
}


} // namespace Cozmo

} // namespace Anki

