
// TODO: this include is shared b/w BS and Robot.  Move up a level.
#include "anki/cozmo/robot/cozmoConfig.h"

#include "anki/common/shared/utilities_shared.h"

#include "anki/common/basestation/general.h"
#include "anki/common/basestation/math/rect.h"

#include "anki/cozmo/basestation/blockWorld.h"
#include "anki/cozmo/basestation/block.h"
#include "anki/cozmo/basestation/mat.h"
#include "anki/cozmo/basestation/messages.h"
#include "anki/cozmo/basestation/robot.h"

#include "messageHandler.h"
#include "vizManager.h"

namespace Anki
{
  namespace Cozmo
  {
    //BlockWorld* BlockWorld::singletonInstance_ = 0;
    const std::map<ObjectID_t, Vision::ObservableObject*> BlockWorld::EmptyObjectMap;
    
    /*
    BlockWorld::BlockWorld( MessagingInterface* msgInterfaceIn )
    : msgInterface(msgInterfaceIn), blocks(MaxBlockTypes), zAxisPointsUp(true)
    {
      
    }
     */
    
    //bool BlockWorld::ZAxisPointsUp = true;
    
    
    BlockWorld::BlockWorld( )
    : robotMgr_(NULL)
//    : robotMgr_(RobotManager::getInstance()),
//      msgHandler_(MessageHandler::getInstance())
    {
      // TODO: Create each known block / matpiece from a configuration/definitions file
      
      //
      // 1x1 Cubes
      //
      blockLibrary_.AddObject(new Block_Cube1x1(Block::FUEL_BLOCK_TYPE));
      
      blockLibrary_.AddObject(new Block_Cube1x1(Block::ANGRYFACE_BLOCK_TYPE));

      blockLibrary_.AddObject(new Block_Cube1x1(Block::BULLSEYE_BLOCK_TYPE));
      
      blockLibrary_.AddObject(new Block_Cube1x1(Block::SQTARGET_BLOCK_TYPE));
      
      blockLibrary_.AddObject(new Block_Cube1x1(Block::FIRE_BLOCK_TYPE));
      
      blockLibrary_.AddObject(new Block_Cube1x1(Block::ANKILOGO_BLOCK_TYPE));

      
      //
      // 2x1
      //
      
      // "TEMP2x1"
      {/*
        Block_2x1* block = new Block_2x1(++blockID);
        block->AddFace(Block::FRONT_FACE,
                       {115, 117, 167, 238, 206, 221, 156, 168,  58, 114, 118},
                       32.f);
        block->AddFace(Block::LEFT_FACE,
                       {32, 115, 117, 167, 238, 206, 221, 156, 168,  58, 114, 118},
                       32.f);
        block->SetColor(0, 0, 0xff);
        block->SetSize(120.f, 60.f, 60.f);
        block->SetName("TEMP2x1");
        blockLibrary_.AddObject(block);
        */
      }
      
      //
      //
      //
      ObjectType_t matType=0;
      
      // Webots mat:
      {
        MatPiece* mat = new MatPiece(++matType);
        
        // NOTE: These marker definitions were generated by running the code in
        // makeMatVisionMarkers.m, in order to match the webots mat proto also
        // generated by that script.
        
        mat->AddMarker(Vision::MARKER_A,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {-200.000000,-200.000000,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_E,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {-66.666667,-200.000000,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_K,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {66.666667,-200.000000,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_P,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {200.000000,-200.000000,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_B,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {-200.000000,-66.666667,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_F,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {-66.666667,-66.666667,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_L,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {66.666667,-66.666667,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_R,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {200.000000,-66.666667,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_C,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {-200.000000,66.666667,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_G,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {-66.666667,66.666667,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_M,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {66.666667,66.666667,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_T,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {200.000000,66.666667,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_D,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {-200.000000,200.000000,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_J,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {-66.666667,200.000000,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_N,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {66.666667,200.000000,0.000000}),
                       65.000000);
        mat->AddMarker(Vision::MARKER_Y,
                       Pose3d(1.570796, {-1.000000,0.000000,0.000000}, {200.000000,200.000000,0.000000}),
                       65.000000);
        
        matLibrary_.AddObject(mat);
      }

    } // BlockWorld() Constructor
    
    BlockWorld::~BlockWorld()
    {
      for(auto blockTypes : existingBlocks_) {
        for(auto blockIDs : blockTypes.second) {
          delete blockIDs.second;
        }
      }
        
    } // ~BlockWorld() Destructor
    
    
    void BlockWorld::Init(RobotManager* robotMgr)
    {
      robotMgr_ = robotMgr;
    }
    
    
    //template<class ObjectType>
    void BlockWorld::FindOverlappingObjects(const Vision::ObservableObject* objectSeen,
                                            const ObjectsMap_t& objectsExisting,
                                            std::vector<Vision::ObservableObject*>& overlappingExistingObjects) const
    {
      // TODO: We should really be taking uncertainty/distance into account
      //const float distThresholdFraction = 0.05f;
      const float   distThresh_mm = 20.f; // large to handle higher error at a distance
      const Radians angleThresh( DEG_TO_RAD(15.f) );
      
      // TODO: make angle threshold also vary with distance?
      // TODO: make these parameters/arguments
      
      auto objectsExistingIter = objectsExisting.find(objectSeen->GetType());
      if(objectsExistingIter != objectsExisting.end())
      {
        for(auto objExist : objectsExistingIter->second)
        {
          // TODO: smarter block pose comparison
          //const float minDist = 5.f; // TODO: make parameter ... 0.5f*std::min(minDimSeen, objExist->GetMinDim());
          
          //const float distToExist_mm = (objExist.second->GetPose().get_translation() -
          //                              <robotThatSawMe???>->GetPose().get_translation()).length();
          
          //const float distThresh_mm = distThresholdFraction * distToExist_mm;
          
          Pose3d P_diff;
          if( objExist.second->IsSameAs(*objectSeen, distThresh_mm, angleThresh, P_diff) ) {
            overlappingExistingObjects.push_back(objExist.second);
          } /*else {
            fprintf(stdout, "Not merging: Tdiff = %.1fmm, Angle_diff=%.1fdeg\n",
                    P_diff.get_translation().length(), P_diff.get_rotationAngle().getDegrees());
            objExist.second->IsSameAs(*objectSeen, distThresh_mm, angleThresh, P_diff);
          }*/
          
        } // for each existing object of this type
      }
      
    } // FindOverlappingObjects()
    
    
    
    void ClearAllOcclusionMaps(RobotManager* robotMgr)
    {
      for(auto robotID : robotMgr->GetRobotIDList()) {
        Robot* robot = robotMgr->GetRobotByID(robotID);
        CORETECH_ASSERT(robot != NULL);
        Vision::Camera& camera = robot->get_camHead();
        camera.ClearOccluders();
      }
    } // ClearAllOcclusionMaps()

    void AddToOcclusionMaps(const Vision::ObservableObject* object,
                            RobotManager* robotMgr)
    {

      for(auto robotID : robotMgr->GetRobotIDList()) {
        Robot* robot = robotMgr->GetRobotByID(robotID);
        CORETECH_ASSERT(robot != NULL);
        
        Vision::Camera& camera = robot->get_camHead();
        
        camera.AddOccluder(object);
      }
      
    } // AddToOcclusionMaps()
    
    
    
    void BlockWorld::AddAndUpdateObjects(const std::vector<Vision::ObservableObject*> objectsSeen,
                                         ObjectsMap_t& objectsExisting)
    {
      
      ClearAllOcclusionMaps(robotMgr_);
      
      // First, mark all existing blocks as unseen
      for(auto & objectTypes : objectsExisting) {
        /* Using a lambda construction:
        ObjectIdMap_t objectIdMap = objectTypes.second;
        
        std::for_each(objectIdMap.begin(), objectIdMap.end(),
                      [](std::pair<ObjectID_t, Vision::ObservableObject*>& objectIdPair){objectIdPair.second->SetWhetherObserved(false);});
         */
        
        
        for(auto & objectID : objectTypes.second) {
          objectID.second->SetWhetherObserved(false);
        }
        
      }
      
      
    
      for(auto objSeen : objectsSeen) {
        
        //const float minDimSeen = objSeen->GetMinDim();
        
        // Store pointers to any existing blocks that overlap with this one
        std::vector<Vision::ObservableObject*> overlappingObjects;
        FindOverlappingObjects(objSeen, objectsExisting, overlappingObjects);
        
        if(overlappingObjects.empty()) {
          // no existing blocks overlapped with the block we saw, so add it
          // as a new block (and mark it as seen)
          objSeen->SetID(objectsExisting[objSeen->GetType()].size());
          objSeen->SetWhetherObserved(true);
          objectsExisting[objSeen->GetType()][objSeen->GetID()] = objSeen;
          
          fprintf(stdout, "Adding new block with type=%hu and ID=%hu at (%.1f, %.1f, %.1f)\n",
                  objSeen->GetType(), objSeen->GetID(),
                  objSeen->GetPose().get_translation().x(),
                  objSeen->GetPose().get_translation().y(),
                  objSeen->GetPose().get_translation().z());
          
          // Project this new block into each camera
          AddToOcclusionMaps(objSeen, robotMgr_);
          
        }
        else {
          if(overlappingObjects.size() > 1) {
            fprintf(stdout, "More than one overlapping block found -- will use first.\n");
            // TODO: do something smarter here?
          }
          
          fprintf(stdout, "Merging observation of block type=%hu, ID=%hu at (%.1f, %.1f, %.1f)\n",
                  objSeen->GetType(), objSeen->GetID(),
                  objSeen->GetPose().get_translation().x(),
                  objSeen->GetPose().get_translation().y(),
                  objSeen->GetPose().get_translation().z());
          
          // TODO: better way of merging existing/observed block pose
          overlappingObjects[0]->SetPose( objSeen->GetPose() );
          
          // Mark the existing object as seen
          overlappingObjects[0]->SetWhetherObserved(true);
          
          // Project this existing block into each camera, using its new pose
          AddToOcclusionMaps(overlappingObjects[0], robotMgr_);

          // Now that we've merged in objSeen, we can delete it because we
          // will no longer be using it.  Otherwise, we'd leak.
          delete objSeen;
          
        } // if/else overlapping existing blocks found
     
      } // for each block seen
      
      // Project any unobserved existing blocks into each camera, using
      // their old poses.  Note that this is conservative: these objects may
      // in fact be gone, but we will still not worry about not having
      // seen objects that they would have occluded.
      // Meanwhile, create a list of unobserved objects for further
      // consideration below.
      std::vector<std::pair<ObjectsMap_t::iterator, ObjectIdMap_t::iterator> > unobservedObjects;
      //for(auto & objectTypes : objectsExisting) {
      for(auto objectTypeIter = objectsExisting.begin();
          objectTypeIter != objectsExisting.end(); ++objectTypeIter)
      {
        ObjectIdMap_t& objectIdMap = objectTypeIter->second;
        for(auto objectIter = objectIdMap.begin();
            objectIter != objectIdMap.end(); ++objectIter)
        {
          Vision::ObservableObject* object = objectIter->second;;
          if(object->GetWhetherObserved() == false) {
            AddToOcclusionMaps(object, robotMgr_);
            unobservedObjects.emplace_back(objectTypeIter, objectIter);
          } // if object was not observed
        } // for object IDs of this type
      } // for each object type
      
      // Now that the occlusion maps are complete, check each unobserved object's
      // visibility in each camera
      for(auto unobserved : unobservedObjects) {
        Vision::ObservableObject* object = unobserved.second->second;
        
        for(auto robotID : robotMgr_->GetRobotIDList()) {
          
          Robot* robot = robotMgr_->GetRobotByID(robotID);
          CORETECH_ASSERT(robot != NULL);
          
          // TODO: expose these angle/distance parameters 
          if(object->IsVisibleFrom(robot->get_camHead(), DEG_TO_RAD(45), 20.f))
          {
            // We "should" have seen the object! Delete it or mark it somehow
            CORETECH_PRINT("Removing object %d, which should have been seen, "
                           "but wasn't.\n", object->GetID());
            
            unobserved.first->second.erase(unobserved.second);
          }
        } // for each camera
      } // for each unobserved object

      
    } // AddAndUpdateObjects()
    
    
    bool BlockWorld::UpdateRobotPose(Robot* robot)
    {
      bool wasPoseUpdated = false;
      
      // Get all mat objects *seen by this robot's camera*
      std::vector<Vision::ObservableObject*> matsSeen;
      matLibrary_.CreateObjectsFromMarkers(obsMarkers_, matsSeen,
                                           &robot->get_camHead());
      
      // TODO: what to do when a robot sees multiple mat pieces at the same time
      if(not matsSeen.empty()) {
        if(matsSeen.size() > 1) {
          PRINT_NAMED_WARNING("MultipleMatPiecesObserved",
                              "Robot %d observed more than one mat pieces at "
                              "the same time; will only use first for now.",
                              robot->get_ID());
        }
       /*
        // At this point the mat's pose should be relative to the robot's
        // camera's pose
        const Pose3d* matWrtCamera = &(matsSeen[0]->GetPose());
        CORETECH_ASSERT(matWrtCamera->get_parent() ==
                        &(robot->get_camHead().get_pose())); // MatPose's parent is camera
        */
        
        /*
         PRINT_INFO("Observed mat w.r.t. camera is (%f,%f,%f)\n",
         matWrtCamera->get_translation().x(),
         matWrtCamera->get_translation().y(),
         matWrtCamera->get_translation().z());
         */
        
        /*
        // Now get the pose of the robot relative to the mat, using the pose
        // tree
        CORETECH_ASSERT(matWrtCamera->get_parent()->get_parent()->get_parent() ==
                        &(robot->get_pose())); // Robot pose is just a couple more up the pose chain
        
        Pose3d newPose( robot->get_pose().getWithRespectTo(matWrtCamera) );
        */
        
        const Pose3d* matPose = &(matsSeen[0]->GetPose());
        Pose3d newPose( robot->get_pose().getWithRespectTo(matPose) );
        
        /*
        Pose3d P_diff;
        CORETECH_ASSERT( newPose.IsSameAs((*(robot->get_camHead().get_pose().get_parent()) *
                                           robot->get_camHead().get_pose() *
                                           (*matPose)).getInverse(),
                                          5.f, 5*M_PI/180.f, P_diff) );
        */
        
        /*
         Pose3d newPose( (*(robot->get_camHead().get_pose().get_parent()) *
         robot->get_camHead().get_pose() *
         (*matWrtCamera)).getInverse() );
         */
        newPose.set_parent(Pose3d::World); // robot->get_pose().get_parent() );
        robot->set_pose(newPose);
        wasPoseUpdated = true;
        
        PRINT_INFO("Using mat %d to localize robot %d at (%.3f,%.3f,%.3f), %.1fdeg@(%.2f,%.2f,%.2f)\n",
                   matsSeen[0]->GetID(), robot->get_ID(),
                   robot->get_pose().get_translation().x(),
                   robot->get_pose().get_translation().y(),
                   robot->get_pose().get_translation().z(),
                   robot->get_pose().get_rotationAngle().getDegrees(),
                   robot->get_pose().get_rotationAxis().x(),
                   robot->get_pose().get_rotationAxis().y(),
                   robot->get_pose().get_rotationAxis().z());
        
        robot->SendAbsLocalizationUpdate();
        
      } // IF any mat piece was seen

      return wasPoseUpdated;
      
    } // UpdateRobotPose()
    
    
    uint32_t BlockWorld::UpdateBlockPoses()
    {
      std::vector<Vision::ObservableObject*> blocksSeen;
      blockLibrary_.CreateObjectsFromMarkers(obsMarkers_, blocksSeen);
      
      // Use them to add or update existing blocks in our world
      AddAndUpdateObjects(blocksSeen, existingBlocks_);

      return blocksSeen.size();
      
    } // UpdateBlockPoses()
    
    void BlockWorld::Update(void)
    {
      robotMgr_->UpdateAllRobots();
      
      //
      // Localize robots using mat observations
      //
      for(auto robotID : robotMgr_->GetRobotIDList())
      {
        Robot* robot = robotMgr_->GetRobotByID(robotID);
        
        CORETECH_ASSERT(robot != NULL);
        
        UpdateRobotPose(robot);
        
      } // FOR each robotID
      
      
      //
      // Find any observed blocks from the remaining markers
      //
      UpdateBlockPoses();
      
      
      // TODO: Deal with unknown markers?
      
      // Toss any remaining markers?
      uint32_t numUnused = ClearObservedMarkers();
      if(numUnused > 0) {
        PRINT_INFO("%u messages did not match any known objects and went unused.\n",
                   numUnused);
      }

      
      //
      // Update visualization:
      //
      
      // Draw all blocks we know about (and their pre-dock poses)
      VizManager::getInstance()->EraseAllVizObjects();
      VizManager::getInstance()->EraseAllQuads();
      for(auto blocksByType : existingBlocks_) {
        for(auto blocksByID : blocksByType.second) {
          
          const Block* block = dynamic_cast<Block*>(blocksByID.second);
          VizManager::getInstance()->DrawCuboid(block->GetID(),
                                                //block->GetType(),
                                                block->GetSize(),
                                                block->GetPose());
          
          std::vector<Pose3d> poses;
          //block->GetPreDockPoses(PREDOCK_DISTANCE_MM, poses);
          block->GetPreDockPoses(Vision::MARKER_BATTERIES, PREDOCK_DISTANCE_MM, poses);
          u32 poseID = 0;
          for(auto pose : poses) {
            VizManager::getInstance()->DrawPreDockPose(6*block->GetID()+poseID++, pose, VIZ_COLOR_PREDOCKPOSE);
            ++poseID;
          }
          
          {
            using namespace Quad;
            Quad2f quadOnGround2d = block->GetBoundingQuadXY();
            
            Quad3f quadOnGround3d(Point3f(quadOnGround2d[TopLeft].x(),     quadOnGround2d[TopLeft].y(),     0.5f),
                                  Point3f(quadOnGround2d[BottomLeft].x(),  quadOnGround2d[BottomLeft].y(),  0.5f),
                                  Point3f(quadOnGround2d[TopRight].x(),    quadOnGround2d[TopRight].y(),    0.5f),
                                  Point3f(quadOnGround2d[BottomRight].x(), quadOnGround2d[BottomRight].y(), 0.5f));
            
            VizManager::getInstance()->DrawQuad(block->GetID(), quadOnGround3d, VIZ_COLOR_BLOCK_BOUNDING_QUAD);
          }

        } // FOR each ID of this type
      } // FOR each type
      
      
      // Draw all robot poses
      // TODO: Only send when pose has changed?
      for(auto robotID : robotMgr_->GetRobotIDList())
      {
        Robot* robot = robotMgr_->GetRobotByID(robotID);
        
        // Triangle pose marker
        VizManager::getInstance()->DrawRobot(robotID, robot->get_pose());
        
        // Full Webots CozmoBot model
        VizManager::getInstance()->DrawRobot(robotID, robot->get_pose(), robot->get_headAngle(), robot->get_liftAngle());
      }
      
    } // Update()
    
    
    void BlockWorld::QueueObservedMarker(const Vision::ObservedMarker& marker)
    {
      obsMarkers_.emplace_back(marker);
      //obsMarkersByRobot_[seenByRobot].push_back(&obsMarkers_.back());
    }
    
    uint32_t BlockWorld::ClearObservedMarkers()
    {
      uint32_t numCleared = obsMarkers_.size();
      obsMarkers_.clear();
      return numCleared;
    }
    
    void BlockWorld::CommandRobotToDock(const RobotID_t whichRobot,
                                        const Block&    whichBlock)
    {
      Robot* robot = robotMgr_->GetRobotByID(whichRobot);
      if(robot != 0)
      {
        robot->dockWithBlock(whichBlock);
        
      } else {
        fprintf(stdout, "Invalid robot commanded to Dock.\n");
      }
    } // commandRobotToDock()

    
    void BlockWorld::GetBlockBoundingBoxesXY(const f32 minHeight, const f32 maxHeight,
                                             const f32 padding,
                                             std::vector<Quad2f>& rectangles) const
    {
      for(auto & blocksByType : existingBlocks_) {
        for(auto & blocksByID : blocksByType.second) {
          const Block * block = dynamic_cast<const Block*>(blocksByID.second);
          
          const Pose3d& blockPose = block->GetPose();
          const f32 blockHeight = blockPose.get_translation().z();
          
          if(blockHeight >= minHeight && blockHeight <= maxHeight) {
            rectangles.emplace_back(block->GetBoundingQuadXY(padding));
          } // if block is within specified height range
        } // for each block of the current type
      } // for each block type
      
    } // ProjectBlockOutlinessOntoPlane()
    
  } // namespace Cozmo
} // namespace Anki
