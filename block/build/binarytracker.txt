; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\binarytracker.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\binarytracker.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\binarytracker.crf ..\coretech\vision\robot\src\binaryTracker.cpp]
                          THUMB

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker11DeserializeEPcPPvRiRNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker11DeserializeEPcPPvRiRNS0_11MemoryStackE PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::Deserialize(char*, void**, int&, Anki::Embedded::MemoryStack&)
;;;466    
;;;467          Result BinaryTracker::Deserialize(char *objectName, void** buffer, s32 &bufferLength, MemoryStack &memory)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;468          {
000004  b0c8              SUB      sp,sp,#0x120
000006  4604              MOV      r4,r0
000008  461e              MOV      r6,r3
00000a  4617              MOV      r7,r2
00000c  4688              MOV      r8,r1
;;;469            // TODO: check if the name is correct
;;;470            if(SerializedBuffer::DeserializeDescriptionStrings(NULL, objectName, buffer, bufferLength) != RESULT_OK)
00000e  2000              MOVS     r0,#0
000010  9d50              LDR      r5,[sp,#0x140]
000012  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi ; Anki::Embedded::SerializedBuffer::DeserializeDescriptionStrings(char*, char*, void**, int&)
000016  2800              CMP      r0,#0
;;;471              return RESULT_FAIL;
000018  bf1e              ITTT     NE
00001a  2001              MOVNE    r0,#1
;;;472    
;;;473            this->isValid = SerializedBuffer::DeserializeRawBasicType<bool>(NULL, buffer, bufferLength);
;;;474    
;;;475            // First, deserialize the transformation
;;;476            //this->transformation = Transformations::PlanarTransformation_f32(Transformations::TRANSFORM_PROJECTIVE, memory);
;;;477            this->transformation.Deserialize(objectName, buffer, bufferLength, memory);
;;;478    
;;;479            // Next, deserialize the template lists
;;;480            this->templateEdges.imageHeight = SerializedBuffer::DeserializeRawBasicType<s32>(NULL, buffer, bufferLength);
;;;481            this->templateEdges.imageWidth  = SerializedBuffer::DeserializeRawBasicType<s32>(NULL, buffer, bufferLength);
;;;482            this->templateEdges.xDecreasing = SerializedBuffer::DeserializeRawFixedLengthList<Point<s16> >(NULL, buffer, bufferLength, memory);
;;;483            this->templateEdges.xIncreasing = SerializedBuffer::DeserializeRawFixedLengthList<Point<s16> >(NULL, buffer, bufferLength, memory);
;;;484            this->templateEdges.yDecreasing = SerializedBuffer::DeserializeRawFixedLengthList<Point<s16> >(NULL, buffer, bufferLength, memory);
;;;485            this->templateEdges.yIncreasing = SerializedBuffer::DeserializeRawFixedLengthList<Point<s16> >(NULL, buffer, bufferLength, memory);
;;;486    
;;;487            this->templateImageHeight = this->templateEdges.imageHeight;
;;;488            this->templateImageWidth = this->templateEdges.imageWidth;
;;;489    
;;;490            this->isValid = true;
;;;491    
;;;492            return RESULT_OK;
;;;493          }
00001c  b048              ADDNE    sp,sp,#0x120
00001e  e8bd87f0          POPNE    {r4-r10,pc}
000022  2100              MOVS     r1,#0                 ;473
000024  4633              MOV      r3,r6                 ;473
000026  463a              MOV      r2,r7                 ;473
000028  4608              MOV      r0,r1                 ;473
00002a  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi ; Anki::Embedded::SerializedBuffer::DeserializeDescriptionStrings(char*, char*, void**, int&)
00002e  a83b              ADD      r0,sp,#0xec           ;473
000030  a940              ADD      r1,sp,#0x100          ;473
000032  e9cd1002          STRD     r1,r0,[sp,#8]         ;473
000036  a83f              ADD      r0,sp,#0xfc           ;473
000038  a93e              ADD      r1,sp,#0xf8           ;473
00003a  e9cd1000          STRD     r1,r0,[sp,#0]         ;473
00003e  e9cd7604          STRD     r7,r6,[sp,#0x10]      ;473
000042  ab3d              ADD      r3,sp,#0xf4           ;473
000044  aa3c              ADD      r2,sp,#0xf0           ;473
000046  a93a              ADD      r1,sp,#0xe8           ;473
000048  2001              MOVS     r0,#1                 ;473
00004a  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer22EncodedBasicTypeBuffer11DeserializeEbRtRbS4_S4_S4_S4_RiPPvS5_ ; Anki::Embedded::SerializedBuffer::EncodedBasicTypeBuffer::Deserialize(bool, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
00004e  6839              LDR      r1,[r7,#0]            ;473
000050  f8bd20e8          LDRH     r2,[sp,#0xe8]         ;473
000054  f2427010          MOV      r0,#0x2710            ;473
000058  780b              LDRB     r3,[r1,#0]            ;473
00005a  4282              CMP      r2,r0                 ;473
00005c  d206              BCS      |L1.108|
00005e  983b              LDR      r0,[sp,#0xec]         ;473
000060  2800              CMP      r0,#0                 ;473
000062  bfc4              ITT      GT                    ;473
000064  f8dfc158          LDRGT    r12,|L1.448|
000068  4584              CMPGT    r12,r0                ;473
00006a  dc0c              BGT      |L1.134|
                  |L1.108|
00006c  f2401107          MOV      r1,#0x107             ;473
000070  4854              LDR      r0,|L1.452|
000072  e9cd0100          STRD     r0,r1,[sp,#0]         ;473
000076  a354              ADR      r3,|L1.456|
000078  a262              ADR      r2,|L1.516|
00007a  a16b              ADR      r1,|L1.552|
00007c  2005              MOVS     r0,#5                 ;473
00007e  f7fffffe          BL       _Anki_Log
000082  2300              MOVS     r3,#0                 ;473
000084  e007              B        |L1.150|
                  |L1.134|
000086  fb021c00          MLA      r12,r2,r0,r1          ;473
00008a  f8c7c000          STR      r12,[r7,#0]           ;473
00008e  6831              LDR      r1,[r6,#0]            ;473
000090  fb021110          MLS      r1,r2,r0,r1           ;473
000094  6031              STR      r1,[r6,#0]            ;473
                  |L1.150|
000096  f8843196          STRB     r3,[r4,#0x196]        ;473
00009a  4633              MOV      r3,r6                 ;477
00009c  463a              MOV      r2,r7                 ;477
00009e  4641              MOV      r1,r8                 ;477
0000a0  f50470a8          ADD      r0,r4,#0x150          ;477
0000a4  9500              STR      r5,[sp,#0]            ;477
0000a6  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3211DeserializeEPcPPvRiRNS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::Deserialize(char*, void**, int&, Anki::Embedded::MemoryStack&)
0000aa  4632              MOV      r2,r6                 ;480
0000ac  4639              MOV      r1,r7                 ;480
0000ae  2000              MOVS     r0,#0                 ;480
0000b0  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRi ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<int>(char*, void**, int&)
0000b4  f8c40144          STR      r0,[r4,#0x144]        ;481
0000b8  4632              MOV      r2,r6                 ;481
0000ba  4639              MOV      r1,r7                 ;481
0000bc  2000              MOVS     r0,#0                 ;481
0000be  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRi ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<int>(char*, void**, int&)
0000c2  f8c40148          STR      r0,[r4,#0x148]        ;482
0000c6  4633              MOV      r3,r6                 ;482
0000c8  463a              MOV      r2,r7                 ;482
0000ca  2100              MOVS     r1,#0                 ;482
0000cc  a83a              ADD      r0,sp,#0xe8           ;482
0000ce  9500              STR      r5,[sp,#0]            ;482
0000d0  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeRawFixedLengthListINS0_5PointIsEEEENS0_15FixedLengthListIT_EEPcPPvRiRNS0_11MemoryStackE ; Anki::Embedded::SerializedBuffer::DeserializeRawFixedLengthList<Anki::Embedded::Point<short>>(char*, void**, int&, Anki::Embedded::MemoryStack&)
0000d4  f10d0ee8          ADD      lr,sp,#0xe8           ;482
0000d8  e8be170f          LDM      lr!,{r0-r3,r8-r10,r12};482
0000dc  f10d0e18          ADD      lr,sp,#0x18           ;482
0000e0  e8ae170f          STM      lr!,{r0-r3,r8-r10,r12};482
0000e4  f50d7984          ADD      r9,sp,#0x108          ;482
0000e8  e8b9100f          LDM      r9!,{r0-r3,r12}       ;482
0000ec  f10d0938          ADD      r9,sp,#0x38           ;482
0000f0  e8a9100f          STM      r9!,{r0-r3,r12}       ;482
0000f4  a906              ADD      r1,sp,#0x18           ;482
0000f6  f1040074          ADD      r0,r4,#0x74           ;482
0000fa  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
0000fe  4633              MOV      r3,r6                 ;483
000100  463a              MOV      r2,r7                 ;483
000102  2100              MOVS     r1,#0                 ;483
000104  a83a              ADD      r0,sp,#0xe8           ;483
000106  9500              STR      r5,[sp,#0]            ;483
000108  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeRawFixedLengthListINS0_5PointIsEEEENS0_15FixedLengthListIT_EEPcPPvRiRNS0_11MemoryStackE ; Anki::Embedded::SerializedBuffer::DeserializeRawFixedLengthList<Anki::Embedded::Point<short>>(char*, void**, int&, Anki::Embedded::MemoryStack&)
00010c  f10d0ee8          ADD      lr,sp,#0xe8           ;483
000110  e8be170f          LDM      lr!,{r0-r3,r8-r10,r12};483
000114  f10d0e4c          ADD      lr,sp,#0x4c           ;483
000118  e8ae170f          STM      lr!,{r0-r3,r8-r10,r12};483
00011c  f50d7984          ADD      r9,sp,#0x108          ;483
000120  e8b9100f          LDM      r9!,{r0-r3,r12}       ;483
000124  f10d096c          ADD      r9,sp,#0x6c           ;483
000128  e8a9100f          STM      r9!,{r0-r3,r12}       ;483
00012c  a913              ADD      r1,sp,#0x4c           ;483
00012e  f10400a8          ADD      r0,r4,#0xa8           ;483
000132  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
000136  4633              MOV      r3,r6                 ;484
000138  463a              MOV      r2,r7                 ;484
00013a  2100              MOVS     r1,#0                 ;484
00013c  a83a              ADD      r0,sp,#0xe8           ;484
00013e  9500              STR      r5,[sp,#0]            ;484
000140  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeRawFixedLengthListINS0_5PointIsEEEENS0_15FixedLengthListIT_EEPcPPvRiRNS0_11MemoryStackE ; Anki::Embedded::SerializedBuffer::DeserializeRawFixedLengthList<Anki::Embedded::Point<short>>(char*, void**, int&, Anki::Embedded::MemoryStack&)
000144  f10d0ee8          ADD      lr,sp,#0xe8           ;484
000148  e8be170f          LDM      lr!,{r0-r3,r8-r10,r12};484
00014c  f10d0e80          ADD      lr,sp,#0x80           ;484
000150  e8ae170f          STM      lr!,{r0-r3,r8-r10,r12};484
000154  f50d7984          ADD      r9,sp,#0x108          ;484
000158  e8b9100f          LDM      r9!,{r0-r3,r12}       ;484
00015c  f10d09a0          ADD      r9,sp,#0xa0           ;484
000160  e8a9100f          STM      r9!,{r0-r3,r12}       ;484
000164  a920              ADD      r1,sp,#0x80           ;484
000166  f10400dc          ADD      r0,r4,#0xdc           ;484
00016a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
00016e  4633              MOV      r3,r6                 ;485
000170  463a              MOV      r2,r7                 ;485
000172  2100              MOVS     r1,#0                 ;485
000174  a83a              ADD      r0,sp,#0xe8           ;485
000176  9500              STR      r5,[sp,#0]            ;485
000178  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeRawFixedLengthListINS0_5PointIsEEEENS0_15FixedLengthListIT_EEPcPPvRiRNS0_11MemoryStackE ; Anki::Embedded::SerializedBuffer::DeserializeRawFixedLengthList<Anki::Embedded::Point<short>>(char*, void**, int&, Anki::Embedded::MemoryStack&)
00017c  f10d09e8          ADD      r9,sp,#0xe8           ;485
000180  e8b910ef          LDM      r9!,{r0-r3,r5-r7,r12} ;485
000184  f10d09b4          ADD      r9,sp,#0xb4           ;485
000188  e8a910ef          STM      r9!,{r0-r3,r5-r7,r12} ;485
00018c  f50d7984          ADD      r9,sp,#0x108          ;485
000190  e8b9100f          LDM      r9!,{r0-r3,r12}       ;485
000194  f10d09d4          ADD      r9,sp,#0xd4           ;485
000198  e8a9100f          STM      r9!,{r0-r3,r12}       ;485
00019c  a92d              ADD      r1,sp,#0xb4           ;485
00019e  f5047088          ADD      r0,r4,#0x110          ;485
0001a2  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
0001a6  f8d40144          LDR      r0,[r4,#0x144]        ;487
0001aa  6160              STR      r0,[r4,#0x14]         ;488
0001ac  f8d40148          LDR      r0,[r4,#0x148]        ;488
0001b0  61a0              STR      r0,[r4,#0x18]         ;490
0001b2  2001              MOVS     r0,#1                 ;490
0001b4  f8840196          STRB     r0,[r4,#0x196]        ;490
0001b8  b048              ADD      sp,sp,#0x120
0001ba  2000              MOVS     r0,#0                 ;492
0001bc  e8bd87f0          POP      {r4-r10,pc}
;;;494    
                          ENDP

                  |L1.448|
                          DCD      0x000f4240
                  |L1.452|
                          DCD      _ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<bool>(char*, void**, int&)::__PRETTY_FUNCTION__
                  |L1.456|
0001c8  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/serial"
0001cc  6f726574
0001d0  6563685c
0001d4  636f6d6d
0001d8  6f6e5c69
0001dc  6e636c75
0001e0  64655c61
0001e4  6e6b692f
0001e8  636f6d6d
0001ec  6f6e2f72
0001f0  6f626f74
0001f4  2f736572
0001f8  69616c  
0001fb  697a652e          DCB      "ize.h",0
0001ff  6800    
000201  00                DCB      0
000202  00                DCB      0
000203  00                DCB      0
                  |L1.516|
000204  556e7265          DCB      "Unreasonable deserialized values",0
000208  61736f6e
00020c  61626c65
000210  20646573
000214  65726961
000218  6c697a65
00021c  64207661
000220  6c756573
000224  00      
000225  00                DCB      0
000226  00                DCB      0
000227  00                DCB      0
                  |L1.552|
000228  53657269          DCB      "SerializedBuffer::DeserializeRawBasicType",0
00022c  616c697a
000230  65644275
000234  66666572
000238  3a3a4465
00023c  73657269
000240  616c697a
000244  65526177
000248  42617369
00024c  63547970
000250  6500    
000252  00                DCB      0
000253  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker11VerifyTrackERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiRi||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker11VerifyTrackERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiRi PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::VerifyTrack(const Anki::Embedded::EdgeLists&, const Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, int, int&)
;;;2363   
;;;2364         Result BinaryTracker::VerifyTrack(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2365           const EdgeLists &nextImageEdges,
;;;2366           const AllIndexLimits &allLimits,
;;;2367           const s32 matching_maxDistance,
;;;2368           s32 &numTemplatePixelsMatched)
;;;2369         {
000004  b088              SUB      sp,sp,#0x20
000006  460c              MOV      r4,r1
;;;2370           Result lastResult;
;;;2371   
;;;2372           s32 numTemplatePixelsMatched_xDecreasing;
;;;2373           s32 numTemplatePixelsMatched_xIncreasing;
;;;2374           s32 numTemplatePixelsMatched_yDecreasing;
;;;2375           s32 numTemplatePixelsMatched_yIncreasing;
;;;2376   
;;;2377           numTemplatePixelsMatched = 0;
000008  9f10              LDR      r7,[sp,#0x40]
00000a  4605              MOV      r5,r0                 ;2369
00000c  2000              MOVS     r0,#0
;;;2378   
;;;2379           lastResult = BinaryTracker::FindHorizontalCorrespondences_Verify(
00000e  6038              STR      r0,[r7,#0]
000010  e9d40134          LDRD     r0,r1,[r4,#0xd0]
000014  4616              MOV      r6,r2                 ;2369
000016  aa04              ADD      r2,sp,#0x10
000018  e9cd6202          STRD     r6,r2,[sp,#8]
00001c  469a              MOV      r10,r3                ;2369
00001e  e9cd0100          STRD     r0,r1,[sp,#0]
000022  4623              MOV      r3,r4
000024  f1050274          ADD      r2,r5,#0x74
000028  f50571a8          ADD      r1,r5,#0x150
00002c  4650              MOV      r0,r10
00002e  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker36FindHorizontalCorrespondences_VerifyEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERi ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_Verify(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, int&)
;;;2380             matching_maxDistance,
;;;2381             this->transformation,
;;;2382             this->templateEdges.xDecreasing,
;;;2383             nextImageEdges.xDecreasing,
;;;2384             nextImageEdges.imageHeight,
;;;2385             nextImageEdges.imageWidth,
;;;2386             allLimits.xDecreasing_yStartIndexes,
;;;2387             numTemplatePixelsMatched_xDecreasing);
;;;2388   
;;;2389           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
000032  f8df8100          LDR      r8,|L2.308|
000036  ea5f0900          MOVS     r9,r0                 ;2379
00003a  d00d              BEQ      |L2.88|
00003c  f6401055          MOV      r0,#0x955
000040  e9cd8000          STRD     r8,r0,[sp,#0]
000044  a33c              ADR      r3,|L2.312|
000046  a248              ADR      r2,|L2.360|
000048  a151              ADR      r1,|L2.400|
00004a  2005              MOVS     r0,#5
00004c  f7fffffe          BL       _Anki_Log
;;;2390             lastResult, "BinaryTracker::VerifyTrack", "FindHorizontalCorrespondences 1 failed");
;;;2391   
;;;2392           lastResult = BinaryTracker::FindHorizontalCorrespondences_Verify(
;;;2393             matching_maxDistance,
;;;2394             this->transformation,
;;;2395             this->templateEdges.xIncreasing,
;;;2396             nextImageEdges.xIncreasing,
;;;2397             nextImageEdges.imageHeight,
;;;2398             nextImageEdges.imageWidth,
;;;2399             allLimits.xIncreasing_yStartIndexes,
;;;2400             numTemplatePixelsMatched_xIncreasing);
;;;2401   
;;;2402           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2403             lastResult, "BinaryTracker::VerifyTrack", "FindHorizontalCorrespondences 2 failed");
;;;2404   
;;;2405           lastResult = BinaryTracker::FindVerticalCorrespondences_Verify(
;;;2406             matching_maxDistance,
;;;2407             this->transformation,
;;;2408             this->templateEdges.yDecreasing,
;;;2409             nextImageEdges.yDecreasing,
;;;2410             nextImageEdges.imageHeight,
;;;2411             nextImageEdges.imageWidth,
;;;2412             allLimits.yDecreasing_xStartIndexes,
;;;2413             numTemplatePixelsMatched_yDecreasing);
;;;2414   
;;;2415           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2416             lastResult, "BinaryTracker::VerifyTrack", "FindVerticalCorrespondences 1 failed");
;;;2417   
;;;2418           lastResult = BinaryTracker::FindVerticalCorrespondences_Verify(
;;;2419             matching_maxDistance,
;;;2420             this->transformation,
;;;2421             this->templateEdges.yIncreasing,
;;;2422             nextImageEdges.yIncreasing,
;;;2423             nextImageEdges.imageHeight,
;;;2424             nextImageEdges.imageWidth,
;;;2425             allLimits.yIncreasing_xStartIndexes,
;;;2426             numTemplatePixelsMatched_yIncreasing);
;;;2427   
;;;2428           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2429             lastResult, "BinaryTracker::VerifyTrack", "FindVerticalCorrespondences 2 failed");
;;;2430   
;;;2431           // Compute the overall sum
;;;2432           numTemplatePixelsMatched = numTemplatePixelsMatched_xDecreasing + numTemplatePixelsMatched_xIncreasing + numTemplatePixelsMatched_yDecreasing + numTemplatePixelsMatched_yIncreasing;
;;;2433   
;;;2434           return RESULT_OK;
;;;2435         }
000050  b008              ADD      sp,sp,#0x20
000052  4648              MOV      r0,r9                 ;2389
000054  e8bd87f0          POP      {r4-r10,pc}
                  |L2.88|
000058  e9d40134          LDRD     r0,r1,[r4,#0xd0]      ;2392
00005c  ab05              ADD      r3,sp,#0x14           ;2392
00005e  f1060214          ADD      r2,r6,#0x14           ;2392
000062  e88d000f          STM      sp,{r0-r3}            ;2392
000066  f1040334          ADD      r3,r4,#0x34           ;2392
00006a  f10502a8          ADD      r2,r5,#0xa8           ;2392
00006e  f50571a8          ADD      r1,r5,#0x150          ;2392
000072  4650              MOV      r0,r10                ;2392
000074  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker36FindHorizontalCorrespondences_VerifyEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERi ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_Verify(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, int&)
000078  ea5f0900          MOVS     r9,r0                 ;2392
00007c  d00d              BEQ      |L2.154|
00007e  f6401062          MOV      r0,#0x962             ;2402
000082  e9cd8000          STRD     r8,r0,[sp,#0]         ;2402
000086  a32c              ADR      r3,|L2.312|
000088  a248              ADR      r2,|L2.428|
00008a  a141              ADR      r1,|L2.400|
00008c  2005              MOVS     r0,#5                 ;2402
00008e  f7fffffe          BL       _Anki_Log
000092  b008              ADD      sp,sp,#0x20
000094  4648              MOV      r0,r9                 ;2402
000096  e8bd87f0          POP      {r4-r10,pc}
                  |L2.154|
00009a  e9d40134          LDRD     r0,r1,[r4,#0xd0]      ;2405
00009e  ab06              ADD      r3,sp,#0x18           ;2405
0000a0  f1060228          ADD      r2,r6,#0x28           ;2405
0000a4  e88d000f          STM      sp,{r0-r3}            ;2405
0000a8  f1040368          ADD      r3,r4,#0x68           ;2405
0000ac  f10502dc          ADD      r2,r5,#0xdc           ;2405
0000b0  f50571a8          ADD      r1,r5,#0x150          ;2405
0000b4  4650              MOV      r0,r10                ;2405
0000b6  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindVerticalCorrespondences_VerifyEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERi ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_Verify(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, int&)
0000ba  ea5f0900          MOVS     r9,r0                 ;2405
0000be  d00d              BEQ      |L2.220|
0000c0  f640106f          MOV      r0,#0x96f             ;2415
0000c4  e9cd8000          STRD     r8,r0,[sp,#0]         ;2415
0000c8  a31b              ADR      r3,|L2.312|
0000ca  a242              ADR      r2,|L2.468|
0000cc  a130              ADR      r1,|L2.400|
0000ce  2005              MOVS     r0,#5                 ;2415
0000d0  f7fffffe          BL       _Anki_Log
0000d4  b008              ADD      sp,sp,#0x20
0000d6  4648              MOV      r0,r9                 ;2415
0000d8  e8bd87f0          POP      {r4-r10,pc}
                  |L2.220|
0000dc  e9d40134          LDRD     r0,r1,[r4,#0xd0]      ;2418
0000e0  ab07              ADD      r3,sp,#0x1c           ;2418
0000e2  f106023c          ADD      r2,r6,#0x3c           ;2418
0000e6  e88d000f          STM      sp,{r0-r3}            ;2418
0000ea  f104039c          ADD      r3,r4,#0x9c           ;2418
0000ee  f5057288          ADD      r2,r5,#0x110          ;2418
0000f2  f50571a8          ADD      r1,r5,#0x150          ;2418
0000f6  4650              MOV      r0,r10                ;2418
0000f8  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindVerticalCorrespondences_VerifyEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERi ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_Verify(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, int&)
0000fc  0004              MOVS     r4,r0                 ;2418
0000fe  d00d              BEQ      |L2.284|
000100  f640107c          MOV      r0,#0x97c             ;2428
000104  e9cd8000          STRD     r8,r0,[sp,#0]         ;2428
000108  a30b              ADR      r3,|L2.312|
00010a  a23c              ADR      r2,|L2.508|
00010c  a120              ADR      r1,|L2.400|
00010e  2005              MOVS     r0,#5                 ;2428
000110  f7fffffe          BL       _Anki_Log
000114  b008              ADD      sp,sp,#0x20
000116  4620              MOV      r0,r4                 ;2428
000118  e8bd87f0          POP      {r4-r10,pc}
                  |L2.284|
00011c  e9dd0104          LDRD     r0,r1,[sp,#0x10]
000120  4408              ADD      r0,r0,r1              ;2432
000122  9906              LDR      r1,[sp,#0x18]         ;2432
000124  4408              ADD      r0,r0,r1              ;2432
000126  9907              LDR      r1,[sp,#0x1c]         ;2432
000128  4408              ADD      r0,r0,r1              ;2432
00012a  6038              STR      r0,[r7,#0]            ;2434
00012c  b008              ADD      sp,sp,#0x20
00012e  2000              MOVS     r0,#0                 ;2434
000130  e8bd87f0          POP      {r4-r10,pc}
;;;2436   
                          ENDP

                  |L2.308|
                          DCD      ||.constdata||+0x7ae
                  |L2.312|
000138  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\binaryTracker.cpp",0
00013c  6f726574
000140  6563685c
000144  76697369
000148  6f6e5c72
00014c  6f626f74
000150  5c737263
000154  5c62696e
000158  61727954
00015c  7261636b
000160  65722e63
000164  707000  
000167  00                DCB      0
                  |L2.360|
000168  46696e64          DCB      "FindHorizontalCorrespondences 1 failed",0
00016c  486f7269
000170  7a6f6e74
000174  616c436f
000178  72726573
00017c  706f6e64
000180  656e6365
000184  73203120
000188  6661696c
00018c  656400  
00018f  00                DCB      0
                  |L2.400|
000190  42696e61          DCB      "BinaryTracker::VerifyTrack",0
000194  72795472
000198  61636b65
00019c  723a3a56
0001a0  65726966
0001a4  79547261
0001a8  636b00  
0001ab  00                DCB      0
                  |L2.428|
0001ac  46696e64          DCB      "FindHorizontalCorrespondences 2 failed",0
0001b0  486f7269
0001b4  7a6f6e74
0001b8  616c436f
0001bc  72726573
0001c0  706f6e64
0001c4  656e6365
0001c8  73203220
0001cc  6661696c
0001d0  656400  
0001d3  00                DCB      0
                  |L2.468|
0001d4  46696e64          DCB      "FindVerticalCorrespondences 1 failed",0
0001d8  56657274
0001dc  6963616c
0001e0  436f7272
0001e4  6573706f
0001e8  6e64656e
0001ec  63657320
0001f0  31206661
0001f4  696c6564
0001f8  00      
0001f9  00                DCB      0
0001fa  00                DCB      0
0001fb  00                DCB      0
                  |L2.508|
0001fc  46696e64          DCB      "FindVerticalCorrespondences 2 failed",0
000200  56657274
000204  6963616c
000208  436f7272
00020c  6573706f
000210  6e64656e
000214  63657320
000218  32206661
00021c  696c6564
000220  00      
000221  00                DCB      0
000222  00                DCB      0
000223  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker16UpdateTrack_ListERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiRiSA_SA_SA_NS0_11MemoryStackESB_||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker16UpdateTrack_ListERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiRiSA_SA_SA_NS0_11MemoryStackESB_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::UpdateTrack_List(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters&, int, int, int, unsigned char, int, int&, int&, int&, int&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
;;;560          // WARNING: using a list is liable to be slower than normal, and not be more accurate
;;;561          Result BinaryTracker::UpdateTrack_List(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;562            const Array<u8> &nextImage,
;;;563            const EdgeDetectionParameters &edgeDetectionParams,
;;;564            const s32 matching_maxTranslationDistance, const s32 matching_maxProjectiveDistance,
;;;565            const s32 verify_maxTranslationDistance, const u8 verify_maxPixelDifference, const s32 verify_coordinateIncrement,
;;;566            s32 &numMatches,
;;;567            s32 &verify_meanAbsoluteDifference, //< For all pixels in the template, compute the mean difference between the template and the final warped template
;;;568            s32 &verify_numInBounds, //< How many template pixels are in the image, after the template is warped?
;;;569            s32 &verify_numSimilarPixels, //< For all pixels in the template, how many are within verifyMaxPixelDifference grayvalues? Use in conjunction with get_numTemplatePixels() or numInBounds for a percentage.
;;;570            MemoryStack fastScratch,
;;;571            MemoryStack slowScratch)
;;;572          {
000004  b09d              SUB      sp,sp,#0x74
;;;573            return UpdateTrack_Generic(
000006  a815              ADD      r0,sp,#0x54
000008  e9dd5430          LDRD     r5,r4,[sp,#0xc0]      ;572
00000c  e9dd762e          LDRD     r7,r6,[sp,#0xb8]      ;572
000010  e9dd982c          LDRD     r9,r8,[sp,#0xb0]      ;572
000014  e9ddba2a          LDRD     r11,r10,[sp,#0xa8]    ;572
000018  9933              LDR      r1,[sp,#0xcc]
00001a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00001e  9000              STR      r0,[sp,#0]
000020  a80e              ADD      r0,sp,#0x38
000022  9932              LDR      r1,[sp,#0xc8]
000024  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000028  4601              MOV      r1,r0
00002a  9800              LDR      r0,[sp,#0]
00002c  9609              STR      r6,[sp,#0x24]
00002e  e9cd100c          STRD     r1,r0,[sp,#0x30]
000032  2000              MOVS     r0,#0
000034  9006              STR      r0,[sp,#0x18]
000036  e9cd0707          STRD     r0,r7,[sp,#0x1c]
00003a  e9cd8004          STRD     r8,r0,[sp,#0x10]
00003e  e9cda902          STRD     r10,r9,[sp,#8]
000042  e9cd540a          STRD     r5,r4,[sp,#0x28]
000046  9820              LDR      r0,[sp,#0x80]
000048  e9cd0b00          STRD     r0,r11,[sp,#0]
00004c  e9dd021d          LDRD     r0,r2,[sp,#0x74]
000050  2102              MOVS     r1,#2
000052  9b1f              LDR      r3,[sp,#0x7c]
000054  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker19UpdateTrack_GenericENS2_13UpdateVersionERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiiiiRiSB_SB_SB_NS0_11MemoryStackESC_ ; Anki::Embedded::TemplateTracker::BinaryTracker::UpdateTrack_Generic(Anki::Embedded::TemplateTracker::BinaryTracker::UpdateVersion, const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters&, int, int, int, unsigned char, int, int, int, int, int&, int&, int&, int&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
;;;574              UPDATE_VERSION_LIST,
;;;575              nextImage,
;;;576              edgeDetectionParams,
;;;577              matching_maxTranslationDistance, matching_maxProjectiveDistance,
;;;578              verify_maxTranslationDistance, verify_maxPixelDifference, verify_coordinateIncrement,
;;;579              0, 0, 0,
;;;580              numMatches,
;;;581              verify_meanAbsoluteDifference, verify_numInBounds, verify_numSimilarPixels,
;;;582              fastScratch,
;;;583              slowScratch);
;;;584          }
000058  b021              ADD      sp,sp,#0x84
00005a  e8bd8ff0          POP      {r4-r11,pc}
;;;585    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker18UpdateTrack_NormalERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiRiSA_SA_SA_NS0_11MemoryStackESB_||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker18UpdateTrack_NormalERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiRiSA_SA_SA_NS0_11MemoryStackESB_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::UpdateTrack_Normal(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters&, int, int, int, unsigned char, int, int&, int&, int&, int&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
;;;534    
;;;535          Result BinaryTracker::UpdateTrack_Normal(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;536            const Array<u8> &nextImage,
;;;537            const EdgeDetectionParameters &edgeDetectionParams,
;;;538            const s32 matching_maxTranslationDistance, const s32 matching_maxProjectiveDistance,
;;;539            const s32 verify_maxTranslationDistance, const u8 verify_maxPixelDifference, const s32 verify_coordinateIncrement,
;;;540            s32 &numMatches,
;;;541            s32 &verify_meanAbsoluteDifference, //< For all pixels in the template, compute the mean difference between the template and the final warped template
;;;542            s32 &verify_numInBounds, //< How many template pixels are in the image, after the template is warped?
;;;543            s32 &verify_numSimilarPixels, //< For all pixels in the template, how many are within verifyMaxPixelDifference grayvalues? Use in conjunction with get_numTemplatePixels() or numInBounds for a percentage.
;;;544            MemoryStack fastScratch,
;;;545            MemoryStack slowScratch)
;;;546          {
000004  b09d              SUB      sp,sp,#0x74
;;;547            return UpdateTrack_Generic(
000006  a815              ADD      r0,sp,#0x54
000008  e9dd5430          LDRD     r5,r4,[sp,#0xc0]      ;546
00000c  e9dd762e          LDRD     r7,r6,[sp,#0xb8]      ;546
000010  e9dd982c          LDRD     r9,r8,[sp,#0xb0]      ;546
000014  e9ddba2a          LDRD     r11,r10,[sp,#0xa8]    ;546
000018  9933              LDR      r1,[sp,#0xcc]
00001a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00001e  9000              STR      r0,[sp,#0]
000020  a80e              ADD      r0,sp,#0x38
000022  9932              LDR      r1,[sp,#0xc8]
000024  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000028  4601              MOV      r1,r0
00002a  9800              LDR      r0,[sp,#0]
00002c  9609              STR      r6,[sp,#0x24]
00002e  e9cd100c          STRD     r1,r0,[sp,#0x30]
000032  2000              MOVS     r0,#0
000034  9006              STR      r0,[sp,#0x18]
000036  e9cd0707          STRD     r0,r7,[sp,#0x1c]
00003a  e9cd8004          STRD     r8,r0,[sp,#0x10]
00003e  e9cda902          STRD     r10,r9,[sp,#8]
000042  e9cd540a          STRD     r5,r4,[sp,#0x28]
000046  9820              LDR      r0,[sp,#0x80]
000048  e9cd0b00          STRD     r0,r11,[sp,#0]
00004c  e9dd021d          LDRD     r0,r2,[sp,#0x74]
000050  2101              MOVS     r1,#1
000052  9b1f              LDR      r3,[sp,#0x7c]
000054  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker19UpdateTrack_GenericENS2_13UpdateVersionERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiiiiRiSB_SB_SB_NS0_11MemoryStackESC_ ; Anki::Embedded::TemplateTracker::BinaryTracker::UpdateTrack_Generic(Anki::Embedded::TemplateTracker::BinaryTracker::UpdateVersion, const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters&, int, int, int, unsigned char, int, int, int, int, int&, int&, int&, int&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
;;;548              UPDATE_VERSION_NORMAL,
;;;549              nextImage,
;;;550              edgeDetectionParams,
;;;551              matching_maxTranslationDistance, matching_maxProjectiveDistance,
;;;552              verify_maxTranslationDistance, verify_maxPixelDifference, verify_coordinateIncrement,
;;;553              0, 0, 0,
;;;554              numMatches,
;;;555              verify_meanAbsoluteDifference, verify_numInBounds, verify_numSimilarPixels,
;;;556              fastScratch,
;;;557              slowScratch);
;;;558          }
000058  b021              ADD      sp,sp,#0x84
00005a  e8bd8ff0          POP      {r4-r11,pc}
;;;559    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker18UpdateTrack_RansacERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiihiiiiRiSA_SA_SA_NS0_11MemoryStackESB_||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker18UpdateTrack_RansacERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiihiiiiRiSA_SA_SA_NS0_11MemoryStackESB_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::UpdateTrack_Ransac(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters&, int, int, unsigned char, int, int, int, int, int&, int&, int&, int&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
;;;585    
;;;586          Result BinaryTracker::UpdateTrack_Ransac(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;587            const Array<u8> &nextImage,
;;;588            const EdgeDetectionParameters &edgeDetectionParams,
;;;589            const s32 matching_maxProjectiveDistance,
;;;590            const s32 verify_maxTranslationDistance, const u8 verify_maxPixelDifference, const s32 verify_coordinateIncrement,
;;;591            const s32 ransac_maxIterations,
;;;592            const s32 ransac_numSamplesPerType, //< for four types
;;;593            const s32 ransac_inlinerDistance,
;;;594            s32 &numMatches,
;;;595            s32 &verify_meanAbsoluteDifference, //< For all pixels in the template, compute the mean difference between the template and the final warped template
;;;596            s32 &verify_numInBounds, //< How many template pixels are in the image, after the template is warped?
;;;597            s32 &verify_numSimilarPixels, //< For all pixels in the template, how many are within verifyMaxPixelDifference grayvalues? Use in conjunction with get_numTemplatePixels() or numInBounds for a percentage.
;;;598            MemoryStack fastScratch,
;;;599            MemoryStack slowScratch)
;;;600          {
000004  b09d              SUB      sp,sp,#0x74
;;;601            return UpdateTrack_Generic(
000006  a815              ADD      r0,sp,#0x54
000008  e9dd5432          LDRD     r5,r4,[sp,#0xc8]      ;600
00000c  e9dd7630          LDRD     r7,r6,[sp,#0xc0]      ;600
000010  e9dd982e          LDRD     r9,r8,[sp,#0xb8]      ;600
000014  e9ddba2c          LDRD     r11,r10,[sp,#0xb0]    ;600
000018  9935              LDR      r1,[sp,#0xd4]
00001a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00001e  9000              STR      r0,[sp,#0]
000020  a80e              ADD      r0,sp,#0x38
000022  9934              LDR      r1,[sp,#0xd0]
000024  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000028  9900              LDR      r1,[sp,#0]
00002a  e9cd540a          STRD     r5,r4,[sp,#0x28]
00002e  e9cd010c          STRD     r0,r1,[sp,#0x30]
000032  e9cd7608          STRD     r7,r6,[sp,#0x20]
000036  e9cd9806          STRD     r9,r8,[sp,#0x18]
00003a  e9dd012a          LDRD     r0,r1,[sp,#0xa8]
00003e  e9cd0102          STRD     r0,r1,[sp,#8]
000042  e9cdba04          STRD     r11,r10,[sp,#0x10]
000046  9920              LDR      r1,[sp,#0x80]
000048  2000              MOVS     r0,#0
00004a  e9cd0100          STRD     r0,r1,[sp,#0]
00004e  e9dd021d          LDRD     r0,r2,[sp,#0x74]
000052  2103              MOVS     r1,#3
000054  9b1f              LDR      r3,[sp,#0x7c]
000056  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker19UpdateTrack_GenericENS2_13UpdateVersionERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiiiiRiSB_SB_SB_NS0_11MemoryStackESC_ ; Anki::Embedded::TemplateTracker::BinaryTracker::UpdateTrack_Generic(Anki::Embedded::TemplateTracker::BinaryTracker::UpdateVersion, const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters&, int, int, int, unsigned char, int, int, int, int, int&, int&, int&, int&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
;;;602              UPDATE_VERSION_RANSAC,
;;;603              nextImage,
;;;604              edgeDetectionParams,
;;;605              0, matching_maxProjectiveDistance,
;;;606              verify_maxTranslationDistance, verify_maxPixelDifference, verify_coordinateIncrement,
;;;607              ransac_maxIterations, ransac_numSamplesPerType, ransac_inlinerDistance,
;;;608              numMatches,
;;;609              verify_meanAbsoluteDifference, verify_numInBounds, verify_numSimilarPixels,
;;;610              fastScratch,
;;;611              slowScratch);
;;;612          }
00005a  b021              ADD      sp,sp,#0x84
00005c  e8bd8ff0          POP      {r4-r11,pc}
;;;613    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker18set_transformationERKNS0_15Transformations24PlanarTransformation_f32E||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker18set_transformationERKNS0_15Transformations24PlanarTransformation_f32E PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::set_transformation(const Anki::Embedded::Transformations::PlanarTransformation_f32&)
;;;502    
;;;503          Result BinaryTracker::set_transformation(const Transformations::PlanarTransformation_f32 &transformation)
000000  f50070a8          ADD      r0,r0,#0x150
;;;504          {
;;;505            return this->transformation.Set(transformation);
000004  f7ffbffe          B.W      _ZN4Anki8Embedded15Transformations24PlanarTransformation_f323SetERKS2_ ; Anki::Embedded::Transformations::PlanarTransformation_f32::Set(const Anki::Embedded::Transformations::PlanarTransformation_f32&)
;;;506          }
;;;507    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker19UpdateTrack_GenericENS2_13UpdateVersionERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiiiiRiSB_SB_SB_NS0_11MemoryStackESC_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker19UpdateTrack_GenericENS2_13UpdateVersionERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiiiiRiSB_SB_SB_NS0_11MemoryStackESC_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::UpdateTrack_Generic(Anki::Embedded::TemplateTracker::BinaryTracker::UpdateVersion, const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters&, int, int, int, unsigned char, int, int, int, int, int&, int&, int&, int&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
;;;613    
;;;614          Result BinaryTracker::UpdateTrack_Generic(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;615            const UpdateVersion version,
;;;616            const Array<u8> &nextImage,
;;;617            const EdgeDetectionParameters &edgeDetectionParams,
;;;618            const s32 matching_maxTranslationDistance, const s32 matching_maxProjectiveDistance,
;;;619            const s32 verify_maxTranslationDistance, const u8 verify_maxPixelDifference, const s32 verify_coordinateIncrement,
;;;620            const s32 ransac_maxIterations,
;;;621            const s32 ransac_numSamplesPerType, //< for four types
;;;622            const s32 ransac_inlinerDistance,
;;;623            s32 &numMatches,
;;;624            s32 &verify_meanAbsoluteDifference, //< For all pixels in the template, compute the mean difference between the template and the final warped template
;;;625            s32 &verify_numInBounds, //< How many template pixels are in the image, after the template is warped?
;;;626            s32 &verify_numSimilarPixels, //< For all pixels in the template, how many are within verifyMaxPixelDifference grayvalues? Use in conjunction with get_numTemplatePixels() or numInBounds for a percentage.
;;;627            MemoryStack fastScratch,
;;;628            MemoryStack slowScratch)
;;;629          {
000004  4605              MOV      r5,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  f5ad7d31          SUB      sp,sp,#0x2c4
00000e  461c              MOV      r4,r3
000010  460f              MOV      r7,r1
;;;630            Result lastResult = RESULT_FAIL;
000012  2601              MOVS     r6,#1
;;;631    
;;;632            EdgeLists nextImageEdges;
000014  a808              ADD      r0,sp,#0x20
000016  f8dda330          LDR      r10,[sp,#0x330]
00001a  f8dd8320          LDR      r8,[sp,#0x320]
00001e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
000022  3034              ADDS     r0,r0,#0x34
000024  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
000028  3034              ADDS     r0,r0,#0x34
00002a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
00002e  3034              ADDS     r0,r0,#0x34
000030  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
;;;633    
;;;634            nextImageEdges.xDecreasing = FixedLengthList<Point<s16> >(edgeDetectionParams.maxDetectionsPerType, fastScratch);
000034  2300              MOVS     r3,#0
000036  461a              MOV      r2,r3
000038  2101              MOVS     r1,#1
00003a  a85f              ADD      r0,sp,#0x17c
00003c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000040  6803              LDR      r3,[r0,#0]
000042  69e1              LDR      r1,[r4,#0x1c]
000044  4652              MOV      r2,r10
000046  a852              ADD      r0,sp,#0x148
000048  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00004c  4601              MOV      r1,r0
00004e  a808              ADD      r0,sp,#0x20
000050  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
;;;635            nextImageEdges.xIncreasing = FixedLengthList<Point<s16> >(edgeDetectionParams.maxDetectionsPerType, fastScratch);
000054  2300              MOVS     r3,#0
000056  461a              MOV      r2,r3
000058  2101              MOVS     r1,#1
00005a  a85f              ADD      r0,sp,#0x17c
00005c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000060  6803              LDR      r3,[r0,#0]
000062  69e1              LDR      r1,[r4,#0x1c]
000064  4652              MOV      r2,r10
000066  a852              ADD      r0,sp,#0x148
000068  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00006c  4601              MOV      r1,r0
00006e  f10d0b20          ADD      r11,sp,#0x20
000072  a815              ADD      r0,sp,#0x54
000074  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
;;;636            nextImageEdges.yDecreasing = FixedLengthList<Point<s16> >(edgeDetectionParams.maxDetectionsPerType, fastScratch);
000078  2300              MOVS     r3,#0
00007a  461a              MOV      r2,r3
00007c  2101              MOVS     r1,#1
00007e  a85f              ADD      r0,sp,#0x17c
000080  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000084  6803              LDR      r3,[r0,#0]
000086  69e1              LDR      r1,[r4,#0x1c]
000088  4652              MOV      r2,r10
00008a  a852              ADD      r0,sp,#0x148
00008c  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000090  4601              MOV      r1,r0
000092  f10b0068          ADD      r0,r11,#0x68
000096  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
;;;637            nextImageEdges.yIncreasing = FixedLengthList<Point<s16> >(edgeDetectionParams.maxDetectionsPerType, fastScratch);
00009a  2300              MOVS     r3,#0
00009c  461a              MOV      r2,r3
00009e  2101              MOVS     r1,#1
0000a0  a85f              ADD      r0,sp,#0x17c
0000a2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000a6  6803              LDR      r3,[r0,#0]
0000a8  69e1              LDR      r1,[r4,#0x1c]
0000aa  4652              MOV      r2,r10
0000ac  a852              ADD      r0,sp,#0x148
0000ae  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0000b2  4601              MOV      r1,r0
0000b4  f10b009c          ADD      r0,r11,#0x9c
0000b8  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
;;;638    
;;;639            AnkiConditionalErrorAndReturnValue(AreValid(nextImageEdges.xDecreasing, nextImageEdges.xIncreasing, nextImageEdges.yDecreasing, nextImageEdges.yIncreasing),
0000bc  f10b0134          ADD      r1,r11,#0x34
0000c0  9102              STR      r1,[sp,#8]
0000c2  3134              ADDS     r1,r1,#0x34
0000c4  9101              STR      r1,[sp,#4]
0000c6  3134              ADDS     r1,r1,#0x34
0000c8  a808              ADD      r0,sp,#0x20
0000ca  9100              STR      r1,[sp,#0]
0000cc  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
0000d0  f8df93b4          LDR      r9,|L7.1160|
0000d4  b1a0              CBZ      r0,|L7.256|
0000d6  9802              LDR      r0,[sp,#8]
0000d8  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
0000dc  b180              CBZ      r0,|L7.256|
0000de  9801              LDR      r0,[sp,#4]
0000e0  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
0000e4  b160              CBZ      r0,|L7.256|
0000e6  9800              LDR      r0,[sp,#0]
0000e8  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
0000ec  b140              CBZ      r0,|L7.256|
;;;640              RESULT_FAIL_OUT_OF_MEMORY, "BinaryTracker::UpdateTrack", "Could not allocate local scratch");
;;;641    
;;;642            BeginBenchmark("ut_DetectEdges");
0000ee  a0e7              ADR      r0,|L7.1164|
0000f0  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
;;;643    
;;;644            if(edgeDetectionParams.type == TemplateTracker::BinaryTracker::EDGE_TYPE_GRAYVALUE) {
0000f4  7820              LDRB     r0,[r4,#0]
0000f6  2800              CMP      r0,#0
0000f8  d014              BEQ      |L7.292|
;;;645              lastResult = DetectBlurredEdges_GrayvalueThreshold(nextImage, this->lastGrayvalueThreshold, edgeDetectionParams.minComponentWidth, edgeDetectionParams.everyNLines, nextImageEdges);
;;;646            } else if(edgeDetectionParams.type == TemplateTracker::BinaryTracker::EDGE_TYPE_DERIVATIVE) {
0000fa  2801              CMP      r0,#1
0000fc  d01c              BEQ      |L7.312|
0000fe  e024              B        |L7.330|
                  |L7.256|
000100  f240207f          MOV      r0,#0x27f             ;639
000104  e9cd9000          STRD     r9,r0,[sp,#0]         ;639
000108  a3e4              ADR      r3,|L7.1180|
00010a  a2f0              ADR      r2,|L7.1228|
00010c  a1f8              ADR      r1,|L7.1264|
00010e  2005              MOVS     r0,#5                 ;639
000110  f7fffffe          BL       _Anki_Log
000114  48fd              LDR      r0,|L7.1292|
                  |L7.278|
;;;647              lastResult = DetectBlurredEdges_DerivativeThreshold(nextImage, edgeDetectionParams.combHalfWidth, edgeDetectionParams.combResponseThreshold, edgeDetectionParams.everyNLines, nextImageEdges);
;;;648            }
;;;649    
;;;650            this->lastUsedGrayvalueThreshold = this->lastGrayvalueThreshold;
;;;651    
;;;652            EndBenchmark("ut_DetectEdges");
;;;653    
;;;654            AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;655              lastResult, "BinaryTracker::UpdateTrack", "DetectBlurredEdge failed");
;;;656    
;;;657            // First, to speed up the correspondence search, find the min and max of x or y points
;;;658            AllIndexLimits allLimits;
;;;659    
;;;660            BeginBenchmark("ut_IndexLimits");
;;;661    
;;;662            if((lastResult = BinaryTracker::ComputeAllIndexLimits(nextImageEdges, allLimits, fastScratch)) != RESULT_OK)
;;;663              return lastResult;
;;;664    
;;;665            EndBenchmark("ut_IndexLimits");
;;;666    
;;;667            // Second, compute the actual correspondence and refine the homography
;;;668    
;;;669            const s32 maxMatchesPerType = 4000;
;;;670    
;;;671            // The ransac version is different because:
;;;672            // 1. It doesn't do a translation step
;;;673            // 2. It does a verify step automatically, but the others need to do one after running
;;;674            if(version == UPDATE_VERSION_RANSAC) {
;;;675              BeginBenchmark("ut_projective_ransac");
;;;676              lastResult = IterativelyRefineTrack_Projective_Ransac(nextImageEdges, allLimits, matching_maxProjectiveDistance, maxMatchesPerType, ransac_maxIterations, ransac_numSamplesPerType, ransac_inlinerDistance, numMatches, fastScratch, slowScratch);
;;;677              EndBenchmark("ut_projective_ransac");
;;;678    
;;;679              AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;680                lastResult, "BinaryTracker::UpdateTrack", "IterativelyRefineTrack_Projective failed");
;;;681            } else { // if(version == UPDATE_VERSION_RANSAC) {
;;;682              BeginBenchmark("ut_translation");
;;;683    
;;;684              lastResult = IterativelyRefineTrack_Translation(nextImageEdges, allLimits, matching_maxTranslationDistance, fastScratch);
;;;685    
;;;686              EndBenchmark("ut_translation");
;;;687    
;;;688              AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;689                lastResult, "BinaryTracker::UpdateTrack", "IterativelyRefineTrack_Translation failed");
;;;690    
;;;691              if(version == UPDATE_VERSION_NORMAL) {
;;;692                BeginBenchmark("ut_projective_normal");
;;;693                lastResult = IterativelyRefineTrack_Projective(nextImageEdges, allLimits, matching_maxProjectiveDistance, fastScratch);
;;;694                EndBenchmark("ut_projective_normal");
;;;695              } else if(version == UPDATE_VERSION_LIST) {
;;;696                BeginBenchmark("ut_projective_list");
;;;697                lastResult = IterativelyRefineTrack_Projective_List(nextImageEdges, allLimits, matching_maxProjectiveDistance, maxMatchesPerType, fastScratch, slowScratch);
;;;698                EndBenchmark("ut_projective_list");
;;;699              } else {
;;;700                return RESULT_FAIL;
;;;701              }
;;;702    
;;;703              AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;704                lastResult, "BinaryTracker::UpdateTrack", "IterativelyRefineTrack_Projective failed");
;;;705    
;;;706              BeginBenchmark("ut_verify");
;;;707    
;;;708              lastResult = VerifyTrack(nextImageEdges, allLimits, verify_maxTranslationDistance, numMatches);
;;;709    
;;;710              EndBenchmark("ut_verify");
;;;711    
;;;712              AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;713                lastResult, "BinaryTracker::UpdateTrack", "VerifyTrack failed");
;;;714            } // if(version == UPDATE_VERSION_RANSAC) ... else
;;;715    
;;;716            BeginBenchmark("ut_grayvalueThreshold");
;;;717    
;;;718            const Quadrilateral<f32> curWarpedCorners = this->get_transformation().get_transformedCorners(fastScratch);
;;;719    
;;;720            const Rectangle<s32> edgeDetection_imageRegionOfInterest = curWarpedCorners.ComputeBoundingRectangle<s32>().ComputeScaledRectangle<s32>(edgeDetectionParams.threshold_scaleRegionPercent);
;;;721    
;;;722            IntegerCounts lastImageIntegerCounts(
;;;723              nextImage,
;;;724              edgeDetection_imageRegionOfInterest,
;;;725              edgeDetectionParams.threshold_yIncrement,
;;;726              edgeDetectionParams.threshold_xIncrement,
;;;727              fastScratch);
;;;728    
;;;729            this->lastGrayvalueThreshold = ComputeGrayvalueThreshold(lastImageIntegerCounts, edgeDetectionParams.threshold_blackPercentile, edgeDetectionParams.threshold_whitePercentile);
;;;730    
;;;731            EndBenchmark("ut_grayvalueThreshold");
;;;732    
;;;733            BeginBenchmark("ut_verifyTransformation");
;;;734    
;;;735            {
;;;736              const f32 templateRegionHeight = static_cast<f32>(templateImageHeight);
;;;737              const f32 templateRegionWidth = static_cast<f32>(templateImageWidth);
;;;738    
;;;739              //lastResult = this->transformation.VerifyTransformation_Projective_LinearInterpolate(
;;;740              lastResult = this->transformation.VerifyTransformation_Projective_NearestNeighbor(
;;;741                templateImage, this->templateIntegerCounts, this->templateQuad.ComputeBoundingRectangle<f32>(),
;;;742                nextImage, lastImageIntegerCounts,
;;;743                templateRegionHeight, templateRegionWidth, verify_coordinateIncrement,
;;;744                verify_maxPixelDifference, verify_meanAbsoluteDifference, verify_numInBounds, verify_numSimilarPixels,
;;;745                fastScratch);
;;;746    
;;;747              //Array<u8> downsampledTemplate(templateImageHeight/8, templateImageWidth/8, fastScratch);
;;;748              //Array<u8> downsampledNext(templateImageHeight/8, templateImageWidth/8, fastScratch);
;;;749    
;;;750              //Rectangle<f32> boundingRect = this->templateQuad.ComputeBoundingRectangle();
;;;751              //Rectangle<f32> downsampledRect(boundingRect.left/8, boundingRect.right/8, boundingRect.top/8, boundingRect.bottom/8);
;;;752    
;;;753              //ImageProcessing::DownsampleByPowerOfTwo<u8,u32,u8>(templateImage, 3, downsampledTemplate, fastScratch);
;;;754              //ImageProcessing::DownsampleByPowerOfTwo<u8,u32,u8>(nextImage, 3, downsampledNext, fastScratch);
;;;755    
;;;756              //const f32 templateRegionHeight = static_cast<f32>(templateImageHeight/8);
;;;757              //const f32 templateRegionWidth = static_cast<f32>(templateImageWidth/8);
;;;758    
;;;759              //lastResult = this->transformation.VerifyTransformation_Projective_LinearInterpolate(
;;;760              //  downsampledTemplate, downsampledRect,
;;;761              //  downsampledNext,
;;;762              //  templateRegionHeight, templateRegionWidth,
;;;763              //  verify_maxPixelDifference, verify_meanAbsoluteDifference, verify_numInBounds, verify_numSimilarPixels,
;;;764              //  fastScratch);
;;;765            }
;;;766            EndBenchmark("ut_verifyTransformation");
;;;767    
;;;768            return lastResult;
;;;769          } // Result BinaryTracker::UpdateTrack()
000116  f50d7d31          ADD      sp,sp,#0x2c4
00011a  ecbd8b02          VPOP     {d8}
00011e  b004              ADD      sp,sp,#0x10
000120  e8bd8ff0          POP      {r4-r11,pc}
                  |L7.292|
000124  f8cdb000          STR      r11,[sp,#0]           ;645
000128  f8951195          LDRB     r1,[r5,#0x195]        ;645
00012c  6aa3              LDR      r3,[r4,#0x28]         ;645
00012e  69a2              LDR      r2,[r4,#0x18]         ;645
000130  98b5              LDR      r0,[sp,#0x2d4]        ;645
000132  f7fffffe          BL       _ZN4Anki8Embedded37DetectBlurredEdges_GrayvalueThresholdERKNS0_5ArrayIhEEhiiRNS0_9EdgeListsE ; Anki::Embedded::DetectBlurredEdges_GrayvalueThreshold(const Anki::Embedded::Array<unsigned char>&, unsigned char, int, int, Anki::Embedded::EdgeLists&)
000136  e007              B        |L7.328|
                  |L7.312|
000138  f8cdb000          STR      r11,[sp,#0]           ;647
00013c  e9d41208          LDRD     r1,r2,[r4,#0x20]      ;647
000140  6aa3              LDR      r3,[r4,#0x28]         ;647
000142  98b5              LDR      r0,[sp,#0x2d4]        ;647
000144  f7fffffe          BL       _ZN4Anki8Embedded38DetectBlurredEdges_DerivativeThresholdERKNS0_5ArrayIhEEiiiRNS0_9EdgeListsE ; Anki::Embedded::DetectBlurredEdges_DerivativeThreshold(const Anki::Embedded::Array<unsigned char>&, int, int, int, Anki::Embedded::EdgeLists&)
                  |L7.328|
000148  4606              MOV      r6,r0                 ;647
                  |L7.330|
00014a  f8950195          LDRB     r0,[r5,#0x195]        ;650
00014e  f8850194          STRB     r0,[r5,#0x194]        ;650
000152  a0ce              ADR      r0,|L7.1164|
000154  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
000158  b15e              CBZ      r6,|L7.370|
00015a  f240208e          MOV      r0,#0x28e             ;654
00015e  e9cd9000          STRD     r9,r0,[sp,#0]         ;654
000162  a3ce              ADR      r3,|L7.1180|
000164  a2ea              ADR      r2,|L7.1296|
000166  a1e2              ADR      r1,|L7.1264|
000168  2005              MOVS     r0,#5                 ;654
00016a  f7fffffe          BL       _Anki_Log
00016e  4630              MOV      r0,r6                 ;654
000170  e7d1              B        |L7.278|
                  |L7.370|
000172  a841              ADD      r0,sp,#0x104          ;654
000174  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000178  f04f36ff          MOV      r6,#0xffffffff        ;654
00017c  f8406d0c          STR      r6,[r0,#-0xc]!        ;654
000180  f04f0b00          MOV      r11,#0                ;654
000184  6046              STR      r6,[r0,#4]            ;654
000186  f8c0b010          STR      r11,[r0,#0x10]        ;654
00018a  6086              STR      r6,[r0,#8]            ;654
00018c  3020              ADDS     r0,r0,#0x20           ;654
00018e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000192  f8406d0c          STR      r6,[r0,#-0xc]!        ;654
000196  6046              STR      r6,[r0,#4]            ;654
000198  f8c0b010          STR      r11,[r0,#0x10]        ;654
00019c  6086              STR      r6,[r0,#8]            ;654
00019e  3020              ADDS     r0,r0,#0x20           ;654
0001a0  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
0001a4  f8406d0c          STR      r6,[r0,#-0xc]!        ;654
0001a8  6046              STR      r6,[r0,#4]            ;654
0001aa  f8c0b010          STR      r11,[r0,#0x10]        ;654
0001ae  6086              STR      r6,[r0,#8]            ;654
0001b0  3020              ADDS     r0,r0,#0x20           ;654
0001b2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
0001b6  f8406d0c          STR      r6,[r0,#-0xc]!        ;654
0001ba  6046              STR      r6,[r0,#4]            ;654
0001bc  f8c0b010          STR      r11,[r0,#0x10]        ;660
0001c0  6086              STR      r6,[r0,#8]            ;660
0001c2  a0da              ADR      r0,|L7.1324|
0001c4  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
0001c8  4652              MOV      r2,r10                ;662
0001ca  a93e              ADD      r1,sp,#0xf8           ;662
0001cc  a808              ADD      r0,sp,#0x20           ;662
0001ce  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker21ComputeAllIndexLimitsERKNS0_9EdgeListsERNS2_14AllIndexLimitsERNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::BinaryTracker::ComputeAllIndexLimits(const Anki::Embedded::EdgeLists&, Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, Anki::Embedded::MemoryStack&)
0001d2  2800              CMP      r0,#0                 ;662
0001d4  d19f              BNE      |L7.278|
0001d6  a0d5              ADR      r0,|L7.1324|
0001d8  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
0001dc  f44f667a          MOV      r6,#0xfa0             ;669
0001e0  2f03              CMP      r7,#3                 ;674
0001e2  d020              BEQ      |L7.550|
0001e4  a0d5              ADR      r0,|L7.1340|
0001e6  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
0001ea  4651              MOV      r1,r10                ;684
0001ec  a89b              ADD      r0,sp,#0x26c          ;684
0001ee  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0001f2  9000              STR      r0,[sp,#0]            ;684
0001f4  aa3e              ADD      r2,sp,#0xf8           ;684
0001f6  a908              ADD      r1,sp,#0x20           ;684
0001f8  4628              MOV      r0,r5                 ;684
0001fa  9bc0              LDR      r3,[sp,#0x300]        ;684
0001fc  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker34IterativelyRefineTrack_TranslationERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::BinaryTracker::IterativelyRefineTrack_Translation(const Anki::Embedded::EdgeLists&, const Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, int, Anki::Embedded::MemoryStack)
000200  4683              MOV      r11,r0                ;684
000202  a0ce              ADR      r0,|L7.1340|
000204  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
000208  f1bb0f00          CMP      r11,#0                ;688
00020c  d03a              BEQ      |L7.644|
00020e  f44f702c          MOV      r0,#0x2b0             ;688
000212  e9cd9000          STRD     r9,r0,[sp,#0]         ;688
000216  a3a1              ADR      r3,|L7.1180|
000218  a2cc              ADR      r2,|L7.1356|
00021a  a1b5              ADR      r1,|L7.1264|
00021c  2005              MOVS     r0,#5                 ;688
00021e  f7fffffe          BL       _Anki_Log
000222  4658              MOV      r0,r11                ;688
000224  e777              B        |L7.278|
                  |L7.550|
000226  a0d4              ADR      r0,|L7.1400|
000228  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
00022c  a8a2              ADD      r0,sp,#0x288          ;676
00022e  99cd              LDR      r1,[sp,#0x334]        ;676
000230  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000234  4607              MOV      r7,r0                 ;676
000236  4651              MOV      r1,r10                ;676
000238  a89b              ADD      r0,sp,#0x26c          ;676
00023a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00023e  99c7              LDR      r1,[sp,#0x31c]        ;676
000240  e9cd0705          STRD     r0,r7,[sp,#0x14]      ;676
000244  e9cd1803          STRD     r1,r8,[sp,#0xc]       ;676
000248  e9dd01c5          LDRD     r0,r1,[sp,#0x314]     ;676
00024c  9600              STR      r6,[sp,#0]            ;676
00024e  e9cd0101          STRD     r0,r1,[sp,#4]         ;676
000252  aa3e              ADD      r2,sp,#0xf8           ;676
000254  a908              ADD      r1,sp,#0x20           ;676
000256  4628              MOV      r0,r5                 ;676
000258  9bc1              LDR      r3,[sp,#0x304]        ;676
00025a  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker40IterativelyRefineTrack_Projective_RansacERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiiiiiRiNS0_11MemoryStackESA_ ; Anki::Embedded::TemplateTracker::BinaryTracker::IterativelyRefineTrack_Projective_Ransac(const Anki::Embedded::EdgeLists&, const Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, int, int, int, int, int, int&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
00025e  4606              MOV      r6,r0                 ;676
000260  a0c5              ADR      r0,|L7.1400|
000262  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
000266  2e00              CMP      r6,#0                 ;679
000268  f0008067          BEQ.W    |L7.826|
00026c  f24020a7          MOV      r0,#0x2a7             ;679
000270  e9cd9000          STRD     r9,r0,[sp,#0]         ;679
000274  a389              ADR      r3,|L7.1180|
000276  a2c6              ADR      r2,|L7.1424|
000278  a19d              ADR      r1,|L7.1264|
00027a  2005              MOVS     r0,#5                 ;679
00027c  f7fffffe          BL       _Anki_Log
000280  4630              MOV      r0,r6                 ;679
000282  e748              B        |L7.278|
                  |L7.644|
000284  2f01              CMP      r7,#1                 ;691
000286  d02b              BEQ      |L7.736|
000288  2f02              CMP      r7,#2                 ;695
00028a  bf18              IT       NE                    ;700
00028c  2001              MOVNE    r0,#1                 ;700
00028e  f47faf42          BNE      |L7.278|
000292  a0ca              ADR      r0,|L7.1468|
000294  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
000298  a8a9              ADD      r0,sp,#0x2a4          ;697
00029a  99cd              LDR      r1,[sp,#0x334]        ;697
00029c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0002a0  4607              MOV      r7,r0                 ;697
0002a2  4651              MOV      r1,r10                ;697
0002a4  a8a2              ADD      r0,sp,#0x288          ;697
0002a6  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0002aa  e9cd6000          STRD     r6,r0,[sp,#0]         ;697
0002ae  9702              STR      r7,[sp,#8]            ;697
0002b0  aa3e              ADD      r2,sp,#0xf8           ;697
0002b2  a908              ADD      r1,sp,#0x20           ;697
0002b4  4628              MOV      r0,r5                 ;697
0002b6  9bc1              LDR      r3,[sp,#0x304]        ;697
0002b8  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker38IterativelyRefineTrack_Projective_ListERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiiNS0_11MemoryStackES9_ ; Anki::Embedded::TemplateTracker::BinaryTracker::IterativelyRefineTrack_Projective_List(const Anki::Embedded::EdgeLists&, const Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, int, int, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
0002bc  4606              MOV      r6,r0                 ;697
0002be  a0bf              ADR      r0,|L7.1468|
                  |L7.704|
0002c0  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
0002c4  2e00              CMP      r6,#0                 ;703
0002c6  d01c              BEQ      |L7.770|
0002c8  f24020bf          MOV      r0,#0x2bf             ;703
0002cc  e9cd9000          STRD     r9,r0,[sp,#0]         ;703
0002d0  a372              ADR      r3,|L7.1180|
0002d2  a2af              ADR      r2,|L7.1424|
0002d4  a186              ADR      r1,|L7.1264|
0002d6  2005              MOVS     r0,#5                 ;703
0002d8  f7fffffe          BL       _Anki_Log
0002dc  4630              MOV      r0,r6                 ;703
0002de  e71a              B        |L7.278|
                  |L7.736|
0002e0  a0bb              ADR      r0,|L7.1488|
0002e2  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
0002e6  4651              MOV      r1,r10                ;693
0002e8  a801              ADD      r0,sp,#4              ;693
0002ea  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0002ee  9000              STR      r0,[sp,#0]            ;693
0002f0  aa3e              ADD      r2,sp,#0xf8           ;693
0002f2  a908              ADD      r1,sp,#0x20           ;693
0002f4  4628              MOV      r0,r5                 ;693
0002f6  9bc1              LDR      r3,[sp,#0x304]        ;693
0002f8  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker33IterativelyRefineTrack_ProjectiveERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::BinaryTracker::IterativelyRefineTrack_Projective(const Anki::Embedded::EdgeLists&, const Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, int, Anki::Embedded::MemoryStack)
0002fc  4606              MOV      r6,r0                 ;693
0002fe  a0b4              ADR      r0,|L7.1488|
000300  e7de              B        |L7.704|
                  |L7.770|
000302  a0b9              ADR      r0,|L7.1512|
000304  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
000308  f8cd8000          STR      r8,[sp,#0]            ;708
00030c  aa3e              ADD      r2,sp,#0xf8           ;708
00030e  a908              ADD      r1,sp,#0x20           ;708
000310  4628              MOV      r0,r5                 ;708
000312  9bc2              LDR      r3,[sp,#0x308]        ;708
000314  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker11VerifyTrackERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiRi ; Anki::Embedded::TemplateTracker::BinaryTracker::VerifyTrack(const Anki::Embedded::EdgeLists&, const Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, int, int&)
000318  4606              MOV      r6,r0                 ;708
00031a  a0b3              ADR      r0,|L7.1512|
00031c  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
000320  b15e              CBZ      r6,|L7.826|
000322  f44f7032          MOV      r0,#0x2c8             ;712
000326  e9cd9000          STRD     r9,r0,[sp,#0]         ;712
00032a  a35c              ADR      r3,|L7.1180|
00032c  a2b1              ADR      r2,|L7.1524|
00032e  a170              ADR      r1,|L7.1264|
000330  2005              MOVS     r0,#5                 ;712
000332  f7fffffe          BL       _Anki_Log
000336  4630              MOV      r0,r6                 ;712
000338  e6ed              B        |L7.278|
                  |L7.826|
00033a  a0b3              ADR      r0,|L7.1544|
00033c  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
000340  4651              MOV      r1,r10                ;718
000342  a894              ADD      r0,sp,#0x250          ;718
000344  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000348  4606              MOV      r6,r0                 ;718
00034a  4629              MOV      r1,r5                 ;718
00034c  a86e              ADD      r0,sp,#0x1b8          ;718
00034e  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker13BinaryTracker18get_transformationEv ; Anki::Embedded::TemplateTracker::BinaryTracker::get_transformation() const
000352  4632              MOV      r2,r6                 ;718
000354  a96e              ADD      r1,sp,#0x1b8          ;718
000356  a880              ADD      r0,sp,#0x200          ;718
000358  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3222get_transformedCornersENS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_transformedCorners(Anki::Embedded::MemoryStack) const
00035c  a980              ADD      r1,sp,#0x200          ;720
00035e  a88c              ADD      r0,sp,#0x230          ;720
000360  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE24ComputeBoundingRectangleIiEENS0_9RectangleIT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeBoundingRectangle<int>() const
000364  ed940a05          VLDR     s0,[r4,#0x14]         ;720
000368  a98c              ADD      r1,sp,#0x230          ;720
00036a  a890              ADD      r0,sp,#0x240          ;720
00036c  f7fffffe          BL       _ZNK4Anki8Embedded9RectangleIiE22ComputeScaledRectangleIiEENS1_IT_EEf ; Anki::Embedded::Rectangle<int>::ComputeScaledRectangle<int>(float) const
000370  68a0              LDR      r0,[r4,#8]            ;722
000372  e9cd0a00          STRD     r0,r10,[sp,#0]        ;722
000376  aa90              ADD      r2,sp,#0x240          ;722
000378  6863              LDR      r3,[r4,#4]            ;722
00037a  a860              ADD      r0,sp,#0x180          ;722
00037c  99b5              LDR      r1,[sp,#0x2d4]        ;722
00037e  f7fffffe          BL       _ZN4Anki8Embedded13IntegerCountsC1ERKNS0_5ArrayIhEERKNS0_9RectangleIiEEiiRNS0_11MemoryStackE ; Anki::Embedded::IntegerCounts::IntegerCounts(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Rectangle<int>&, int, int, Anki::Embedded::MemoryStack&)
000382  edd40a04          VLDR     s1,[r4,#0x10]         ;729
000386  ed940a03          VLDR     s0,[r4,#0xc]          ;729
00038a  a860              ADD      r0,sp,#0x180          ;729
00038c  f7fffffe          BL       _ZN4Anki8Embedded25ComputeGrayvalueThresholdERKNS0_13IntegerCountsEff ; Anki::Embedded::ComputeGrayvalueThreshold(const Anki::Embedded::IntegerCounts&, float, float)
000390  f8850195          STRB     r0,[r5,#0x195]        ;729
000394  a09c              ADR      r0,|L7.1544|
000396  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
00039a  a0a1              ADR      r0,|L7.1568|
00039c  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
0003a0  ed950a05          VLDR     s0,[r5,#0x14]         ;736
0003a4  4651              MOV      r1,r10                ;740
0003a6  a89b              ADD      r0,sp,#0x26c          ;740
0003a8  eef88ac0          VCVT.F32.S32 s17,s0                ;736
0003ac  ed950a06          VLDR     s0,[r5,#0x18]         ;737
0003b0  eeb88ac0          VCVT.F32.S32 s16,s0                ;737
0003b4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0003b8  ed950a07          VLDR     s0,[r5,#0x1c]         ;740
0003bc  edd50a08          VLDR     s1,[r5,#0x20]         ;740
0003c0  ed8d0a88          VSTR     s0,[sp,#0x220]        ;740
0003c4  ed8d0a89          VSTR     s0,[sp,#0x224]        ;740
0003c8  4684              MOV      r12,r0                ;740
0003ca  edcd0a8a          VSTR     s1,[sp,#0x228]        ;740
0003ce  a888              ADD      r0,sp,#0x220          ;740
0003d0  f105031c          ADD      r3,r5,#0x1c           ;740
0003d4  edcd0a8b          VSTR     s1,[sp,#0x22c]        ;740
0003d8  2101              MOVS     r1,#1                 ;740
                  |L7.986|
0003da  eb0302c1          ADD      r2,r3,r1,LSL #3       ;740
0003de  ed901a00          VLDR     s2,[r0,#0]            ;740
0003e2  edd21a00          VLDR     s3,[r2,#0]            ;740
0003e6  eeb41ae1          VCMPE.F32 s2,s3                 ;740
0003ea  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;740
0003ee  bf28              IT       CS                    ;740
0003f0  eeb01a61          VMOVCS.F32 s2,s3                 ;740
0003f4  ed801a00          VSTR     s2,[r0,#0]            ;740
0003f8  ed901a01          VLDR     s2,[r0,#4]            ;740
0003fc  edd21a00          VLDR     s3,[r2,#0]            ;740
000400  eeb41ae1          VCMPE.F32 s2,s3                 ;740
000404  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;740
000408  bfd8              IT       LE                    ;740
00040a  eeb01a61          VMOVLE.F32 s2,s3                 ;740
00040e  ed801a01          VSTR     s2,[r0,#4]            ;740
000412  ed901a02          VLDR     s2,[r0,#8]            ;740
000416  edd21a01          VLDR     s3,[r2,#4]            ;740
00041a  eeb41ae1          VCMPE.F32 s2,s3                 ;740
00041e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;740
000422  bf28              IT       CS                    ;740
000424  eeb01a61          VMOVCS.F32 s2,s3                 ;740
000428  ed801a02          VSTR     s2,[r0,#8]            ;740
00042c  ed901a03          VLDR     s2,[r0,#0xc]          ;740
000430  edd21a01          VLDR     s3,[r2,#4]            ;740
000434  eeb41ae1          VCMPE.F32 s2,s3                 ;740
000438  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;740
00043c  bfd8              IT       LE                    ;740
00043e  eeb01a61          VMOVLE.F32 s2,s3                 ;740
000442  ed801a03          VSTR     s2,[r0,#0xc]          ;740
000446  1c49              ADDS     r1,r1,#1              ;740
000448  2904              CMP      r1,#4                 ;740
00044a  dbc6              BLT      |L7.986|
00044c  e9dd01c9          LDRD     r0,r1,[sp,#0x324]     ;740
000450  ab04              ADD      r3,sp,#0x10           ;740
000452  9acb              LDR      r2,[sp,#0x32c]        ;740
000454  e8a31007          STM      r3!,{r0-r2,r12}       ;740
000458  e9dd32c3          LDRD     r3,r2,[sp,#0x30c]     ;740
00045c  98b5              LDR      r0,[sp,#0x2d4]        ;740
00045e  a960              ADD      r1,sp,#0x180          ;740
000460  e88d000f          STM      sp,{r0-r3}            ;740
000464  eef00a48          VMOV.F32 s1,s16                ;740
000468  eeb00a68          VMOV.F32 s0,s17                ;740
00046c  ab88              ADD      r3,sp,#0x220          ;741
00046e  f105023c          ADD      r2,r5,#0x3c           ;741
000472  4629              MOV      r1,r5                 ;741
000474  f50570a8          ADD      r0,r5,#0x150          ;741
000478  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3247VerifyTransformation_Projective_NearestNeighborERKNS0_5ArrayIhEERKNS0_13IntegerCountsERKNS0_9RectangleIfEES6_S9_ffihRiSE_SE_NS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::VerifyTransformation_Projective_NearestNeighbor(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::IntegerCounts&, const Anki::Embedded::Rectangle<float>&, const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::IntegerCounts&, float, float, int, unsigned char, int&, int&, int&, Anki::Embedded::MemoryStack) const
00047c  4604              MOV      r4,r0                 ;741
00047e  a068              ADR      r0,|L7.1568|
000480  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
000484  4620              MOV      r0,r4                 ;768
000486  e646              B        |L7.278|
                  |L7.1160|
                          DCD      ||.constdata||+0x87c
                  |L7.1164|
00048c  75745f44          DCB      "ut_DetectEdges",0
000490  65746563
000494  74456467
000498  657300  
00049b  00                DCB      0
                  |L7.1180|
00049c  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\binaryTracker.cpp",0
0004a0  6f726574
0004a4  6563685c
0004a8  76697369
0004ac  6f6e5c72
0004b0  6f626f74
0004b4  5c737263
0004b8  5c62696e
0004bc  61727954
0004c0  7261636b
0004c4  65722e63
0004c8  707000  
0004cb  00                DCB      0
                  |L7.1228|
0004cc  436f756c          DCB      "Could not allocate local scratch",0
0004d0  64206e6f
0004d4  7420616c
0004d8  6c6f6361
0004dc  7465206c
0004e0  6f63616c
0004e4  20736372
0004e8  61746368
0004ec  00      
0004ed  00                DCB      0
0004ee  00                DCB      0
0004ef  00                DCB      0
                  |L7.1264|
0004f0  42696e61          DCB      "BinaryTracker::UpdateTrack",0
0004f4  72795472
0004f8  61636b65
0004fc  723a3a55
000500  70646174
000504  65547261
000508  636b00  
00050b  00                DCB      0
                  |L7.1292|
                          DCD      0x01000001
                  |L7.1296|
000510  44657465          DCB      "DetectBlurredEdge failed",0
000514  6374426c
000518  75727265
00051c  64456467
000520  65206661
000524  696c6564
000528  00      
000529  00                DCB      0
00052a  00                DCB      0
00052b  00                DCB      0
                  |L7.1324|
00052c  75745f49          DCB      "ut_IndexLimits",0
000530  6e646578
000534  4c696d69
000538  747300  
00053b  00                DCB      0
                  |L7.1340|
00053c  75745f74          DCB      "ut_translation",0
000540  72616e73
000544  6c617469
000548  6f6e00  
00054b  00                DCB      0
                  |L7.1356|
00054c  49746572          DCB      "IterativelyRefineTrack_Translation failed",0
000550  61746976
000554  656c7952
000558  6566696e
00055c  65547261
000560  636b5f54
000564  72616e73
000568  6c617469
00056c  6f6e2066
000570  61696c65
000574  6400    
000576  00                DCB      0
000577  00                DCB      0
                  |L7.1400|
000578  75745f70          DCB      "ut_projective_ransac",0
00057c  726f6a65
000580  63746976
000584  655f7261
000588  6e736163
00058c  00      
00058d  00                DCB      0
00058e  00                DCB      0
00058f  00                DCB      0
                  |L7.1424|
000590  49746572          DCB      "IterativelyRefineTrack_Projective failed",0
000594  61746976
000598  656c7952
00059c  6566696e
0005a0  65547261
0005a4  636b5f50
0005a8  726f6a65
0005ac  63746976
0005b0  65206661
0005b4  696c6564
0005b8  00      
0005b9  00                DCB      0
0005ba  00                DCB      0
0005bb  00                DCB      0
                  |L7.1468|
0005bc  75745f70          DCB      "ut_projective_list",0
0005c0  726f6a65
0005c4  63746976
0005c8  655f6c69
0005cc  737400  
0005cf  00                DCB      0
                  |L7.1488|
0005d0  75745f70          DCB      "ut_projective_normal",0
0005d4  726f6a65
0005d8  63746976
0005dc  655f6e6f
0005e0  726d616c
0005e4  00      
0005e5  00                DCB      0
0005e6  00                DCB      0
0005e7  00                DCB      0
                  |L7.1512|
0005e8  75745f76          DCB      "ut_verify",0
0005ec  65726966
0005f0  7900    
0005f2  00                DCB      0
0005f3  00                DCB      0
                  |L7.1524|
0005f4  56657269          DCB      "VerifyTrack failed",0
0005f8  66795472
0005fc  61636b20
000600  6661696c
000604  656400  
000607  00                DCB      0
                  |L7.1544|
000608  75745f67          DCB      "ut_grayvalueThreshold",0
00060c  72617976
000610  616c7565
000614  54687265
000618  73686f6c
00061c  6400    
00061e  00                DCB      0
00061f  00                DCB      0
                  |L7.1568|
000620  75745f76          DCB      "ut_verifyTransformation",0
000624  65726966
000628  79547261
00062c  6e73666f
000630  726d6174
000634  696f6e00
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker20UpdateTransformationERKNS0_5ArrayIfEEfNS0_11MemoryStackENS0_15Transformations13TransformTypeE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker20UpdateTransformationERKNS0_5ArrayIfEEfNS0_11MemoryStackENS0_15Transformations13TransformTypeE PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::UpdateTransformation(const Anki::Embedded::Array<float>&, float, Anki::Embedded::MemoryStack, Anki::Embedded::Transformations::TransformType)
;;;419    
;;;420          Result BinaryTracker::UpdateTransformation(const Array<f32> &update, const f32 scale, MemoryStack scratch, Transformations::TransformType updateType)
000000  b570              PUSH     {r4-r6,lr}
;;;421          {
000002  460e              MOV      r6,r1
000004  ed2d8b02          VPUSH    {d8}
000008  b088              SUB      sp,sp,#0x20
00000a  4604              MOV      r4,r0
00000c  461d              MOV      r5,r3
00000e  eeb08a40          VMOV.F32 s16,s0
;;;422            return this->transformation.Update(update, scale, scratch, updateType);
000012  4611              MOV      r1,r2
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00001a  4602              MOV      r2,r0
00001c  462b              MOV      r3,r5
00001e  eeb00a48          VMOV.F32 s0,s16
000022  4631              MOV      r1,r6
000024  f50470a8          ADD      r0,r4,#0x150
000028  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f326UpdateERKNS0_5ArrayIfEEfNS0_11MemoryStackENS1_13TransformTypeE ; Anki::Embedded::Transformations::PlanarTransformation_f32::Update(const Anki::Embedded::Array<float>&, float, Anki::Embedded::MemoryStack, Anki::Embedded::Transformations::TransformType)
;;;423          }
00002c  b008              ADD      sp,sp,#0x20
00002e  ecbd8b02          VPOP     {d8}
000032  bd70              POP      {r4-r6,pc}
;;;424    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker21ComputeAllIndexLimitsERKNS0_9EdgeListsERNS2_14AllIndexLimitsERNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker21ComputeAllIndexLimitsERKNS0_9EdgeListsERNS2_14AllIndexLimitsERNS0_11MemoryStackE PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::ComputeAllIndexLimits(const Anki::Embedded::EdgeLists&, Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, Anki::Embedded::MemoryStack&)
;;;512    
;;;513          Result BinaryTracker::ComputeAllIndexLimits(const EdgeLists &imageEdges, AllIndexLimits &allLimits, MemoryStack &memory)
000000  b5f0              PUSH     {r4-r7,lr}
;;;514          {
;;;515            allLimits.xDecreasing_yStartIndexes = Array<s32>(1, imageEdges.imageHeight+1, memory, Flags::Buffer(false,false,false));
000002  2300              MOVS     r3,#0
000004  b089              SUB      sp,sp,#0x24           ;514
000006  4617              MOV      r7,r2                 ;514
000008  460c              MOV      r4,r1                 ;514
00000a  4605              MOV      r5,r0                 ;514
00000c  461a              MOV      r2,r3
00000e  4619              MOV      r1,r3
000010  a807              ADD      r0,sp,#0x1c
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000016  6800              LDR      r0,[r0,#0]
000018  9000              STR      r0,[sp,#0]
00001a  f8d500d0          LDR      r0,[r5,#0xd0]
00001e  463b              MOV      r3,r7
000020  1c42              ADDS     r2,r0,#1
000022  2101              MOVS     r1,#1
000024  a802              ADD      r0,sp,#8
000026  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00002a  6801              LDR      r1,[r0,#0]
00002c  6021              STR      r1,[r4,#0]
00002e  6841              LDR      r1,[r0,#4]
000030  6061              STR      r1,[r4,#4]
000032  6881              LDR      r1,[r0,#8]
000034  60a1              STR      r1,[r4,#8]
000036  68c1              LDR      r1,[r0,#0xc]
000038  60e1              STR      r1,[r4,#0xc]
00003a  6900              LDR      r0,[r0,#0x10]
;;;516            allLimits.xIncreasing_yStartIndexes = Array<s32>(1, imageEdges.imageHeight+1, memory, Flags::Buffer(false,false,false));
00003c  2300              MOVS     r3,#0
00003e  6120              STR      r0,[r4,#0x10]
000040  f1040614          ADD      r6,r4,#0x14
000044  461a              MOV      r2,r3
000046  4619              MOV      r1,r3
000048  a807              ADD      r0,sp,#0x1c
00004a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00004e  6800              LDR      r0,[r0,#0]
000050  9000              STR      r0,[sp,#0]
000052  f8d500d0          LDR      r0,[r5,#0xd0]
000056  463b              MOV      r3,r7
000058  1c42              ADDS     r2,r0,#1
00005a  2101              MOVS     r1,#1
00005c  a802              ADD      r0,sp,#8
00005e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000062  6801              LDR      r1,[r0,#0]
000064  6031              STR      r1,[r6,#0]
000066  6841              LDR      r1,[r0,#4]
000068  6071              STR      r1,[r6,#4]
00006a  6881              LDR      r1,[r0,#8]
00006c  60b1              STR      r1,[r6,#8]
00006e  68c1              LDR      r1,[r0,#0xc]
000070  60f1              STR      r1,[r6,#0xc]
000072  6900              LDR      r0,[r0,#0x10]
;;;517            allLimits.yDecreasing_xStartIndexes = Array<s32>(1, imageEdges.imageWidth+1, memory, Flags::Buffer(false,false,false));
000074  6130              STR      r0,[r6,#0x10]
000076  2300              MOVS     r3,#0
000078  3614              ADDS     r6,r6,#0x14
00007a  461a              MOV      r2,r3
00007c  4619              MOV      r1,r3
00007e  a807              ADD      r0,sp,#0x1c
000080  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000084  6800              LDR      r0,[r0,#0]
000086  9000              STR      r0,[sp,#0]
000088  f8d500d4          LDR      r0,[r5,#0xd4]
00008c  463b              MOV      r3,r7
00008e  1c42              ADDS     r2,r0,#1
000090  2101              MOVS     r1,#1
000092  a802              ADD      r0,sp,#8
000094  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000098  6801              LDR      r1,[r0,#0]
00009a  6031              STR      r1,[r6,#0]
00009c  6841              LDR      r1,[r0,#4]
00009e  6071              STR      r1,[r6,#4]
0000a0  6881              LDR      r1,[r0,#8]
0000a2  60b1              STR      r1,[r6,#8]
0000a4  68c1              LDR      r1,[r0,#0xc]
0000a6  60f1              STR      r1,[r6,#0xc]
0000a8  6900              LDR      r0,[r0,#0x10]
;;;518            allLimits.yIncreasing_xStartIndexes = Array<s32>(1, imageEdges.imageWidth+1, memory, Flags::Buffer(false,false,false));
0000aa  6130              STR      r0,[r6,#0x10]
0000ac  2300              MOVS     r3,#0
0000ae  3614              ADDS     r6,r6,#0x14
0000b0  461a              MOV      r2,r3
0000b2  4619              MOV      r1,r3
0000b4  a807              ADD      r0,sp,#0x1c
0000b6  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000ba  6800              LDR      r0,[r0,#0]
0000bc  9000              STR      r0,[sp,#0]
0000be  f8d500d4          LDR      r0,[r5,#0xd4]
0000c2  463b              MOV      r3,r7
0000c4  1c42              ADDS     r2,r0,#1
0000c6  2101              MOVS     r1,#1
0000c8  a802              ADD      r0,sp,#8
0000ca  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0000ce  6801              LDR      r1,[r0,#0]
0000d0  6031              STR      r1,[r6,#0]
0000d2  6841              LDR      r1,[r0,#4]
0000d4  6071              STR      r1,[r6,#4]
0000d6  6881              LDR      r1,[r0,#8]
0000d8  60b1              STR      r1,[r6,#8]
0000da  68c1              LDR      r1,[r0,#0xc]
0000dc  60f1              STR      r1,[r6,#0xc]
0000de  6900              LDR      r0,[r0,#0x10]
0000e0  6130              STR      r0,[r6,#0x10]
0000e2  6921              LDR      r1,[r4,#0x10]
0000e4  2900              CMP      r1,#0
0000e6  d035              BEQ      |L9.340|
0000e8  6821              LDR      r1,[r4,#0]
0000ea  2900              CMP      r1,#0
0000ec  bfa4              ITT      GE
0000ee  6861              LDRGE    r1,[r4,#4]
0000f0  2900              CMPGE    r1,#0
0000f2  db2f              BLT      |L9.340|
0000f4  6a61              LDR      r1,[r4,#0x24]
0000f6  b369              CBZ      r1,|L9.340|
0000f8  6961              LDR      r1,[r4,#0x14]
0000fa  2900              CMP      r1,#0
0000fc  bfa4              ITT      GE
0000fe  69a1              LDRGE    r1,[r4,#0x18]
000100  2900              CMPGE    r1,#0
000102  db27              BLT      |L9.340|
000104  6ba1              LDR      r1,[r4,#0x38]
000106  b329              CBZ      r1,|L9.340|
000108  6aa1              LDR      r1,[r4,#0x28]
00010a  2900              CMP      r1,#0
00010c  bfa4              ITT      GE
00010e  6ae1              LDRGE    r1,[r4,#0x2c]
000110  2900              CMPGE    r1,#0
000112  db1f              BLT      |L9.340|
000114  b1f0              CBZ      r0,|L9.340|
000116  6be0              LDR      r0,[r4,#0x3c]
000118  2800              CMP      r0,#0
00011a  bfa4              ITT      GE
00011c  6c20              LDRGE    r0,[r4,#0x40]
00011e  2800              CMPGE    r0,#0
000120  db18              BLT      |L9.340|
;;;519    
;;;520            AnkiConditionalErrorAndReturnValue(
;;;521              AreValid(allLimits.xDecreasing_yStartIndexes, allLimits.xIncreasing_yStartIndexes, allLimits.yDecreasing_xStartIndexes, allLimits.yIncreasing_xStartIndexes),
;;;522              RESULT_FAIL_OUT_OF_MEMORY, "BinaryTracker::ComputeAllIndexLimits", "Could not allocate local memory");
;;;523    
;;;524            ComputeIndexLimitsVertical(imageEdges.xDecreasing, allLimits.xDecreasing_yStartIndexes);
000122  4621              MOV      r1,r4
000124  4628              MOV      r0,r5
000126  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker26ComputeIndexLimitsVerticalERKNS0_15FixedLengthListINS0_5PointIsEEEERNS0_5ArrayIiEE ; Anki::Embedded::TemplateTracker::BinaryTracker::ComputeIndexLimitsVertical(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::Array<int>&)
;;;525    
;;;526            ComputeIndexLimitsVertical(imageEdges.xIncreasing, allLimits.xIncreasing_yStartIndexes);
00012a  f1040114          ADD      r1,r4,#0x14
00012e  f1050034          ADD      r0,r5,#0x34
000132  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker26ComputeIndexLimitsVerticalERKNS0_15FixedLengthListINS0_5PointIsEEEERNS0_5ArrayIiEE ; Anki::Embedded::TemplateTracker::BinaryTracker::ComputeIndexLimitsVertical(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::Array<int>&)
;;;527    
;;;528            ComputeIndexLimitsHorizontal(imageEdges.yDecreasing, allLimits.yDecreasing_xStartIndexes);
000136  f1040128          ADD      r1,r4,#0x28
00013a  f1050068          ADD      r0,r5,#0x68
00013e  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker28ComputeIndexLimitsHorizontalERKNS0_15FixedLengthListINS0_5PointIsEEEERNS0_5ArrayIiEE ; Anki::Embedded::TemplateTracker::BinaryTracker::ComputeIndexLimitsHorizontal(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::Array<int>&)
;;;529    
;;;530            ComputeIndexLimitsHorizontal(imageEdges.yIncreasing, allLimits.yIncreasing_xStartIndexes);
000142  f104013c          ADD      r1,r4,#0x3c
000146  f105009c          ADD      r0,r5,#0x9c
00014a  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker28ComputeIndexLimitsHorizontalERKNS0_15FixedLengthListINS0_5PointIsEEEERNS0_5ArrayIiEE ; Anki::Embedded::TemplateTracker::BinaryTracker::ComputeIndexLimitsHorizontal(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::Array<int>&)
;;;531    
;;;532            return RESULT_OK;
;;;533          } // BinaryTracker::ComputeAllIndexLimits()
00014e  b009              ADD      sp,sp,#0x24
000150  2000              MOVS     r0,#0                 ;532
000152  bdf0              POP      {r4-r7,pc}
                  |L9.340|
000154  f44f7102          MOV      r1,#0x208             ;520
000158  4805              LDR      r0,|L9.368|
00015a  e9cd0100          STRD     r0,r1,[sp,#0]         ;520
00015e  a305              ADR      r3,|L9.372|
000160  a210              ADR      r2,|L9.420|
000162  a118              ADR      r1,|L9.452|
000164  2005              MOVS     r0,#5                 ;520
000166  f7fffffe          BL       _Anki_Log
00016a  b009              ADD      sp,sp,#0x24
00016c  481f              LDR      r0,|L9.492|
00016e  bdf0              POP      {r4-r7,pc}
;;;534    
                          ENDP

                  |L9.368|
                          DCD      ||.constdata||+0x27a
                  |L9.372|
000174  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\binaryTracker.cpp",0
000178  6f726574
00017c  6563685c
000180  76697369
000184  6f6e5c72
000188  6f626f74
00018c  5c737263
000190  5c62696e
000194  61727954
000198  7261636b
00019c  65722e63
0001a0  707000  
0001a3  00                DCB      0
                  |L9.420|
0001a4  436f756c          DCB      "Could not allocate local memory",0
0001a8  64206e6f
0001ac  7420616c
0001b0  6c6f6361
0001b4  7465206c
0001b8  6f63616c
0001bc  206d656d
0001c0  6f727900
                  |L9.452|
0001c4  42696e61          DCB      "BinaryTracker::ComputeAllIndexLimits",0
0001c8  72795472
0001cc  61636b65
0001d0  723a3a43
0001d4  6f6d7075
0001d8  7465416c
0001dc  6c496e64
0001e0  65784c69
0001e4  6d697473
0001e8  00      
0001e9  00                DCB      0
0001ea  00                DCB      0
0001eb  00                DCB      0
                  |L9.492|
                          DCD      0x01000001

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker23EdgeDetectionParametersC1ENS2_17EdgeDetectionTypeEiifffiiiii||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker23EdgeDetectionParametersC2ENS2_17EdgeDetectionTypeEiifffiiiii                  ; Alternate entry point ; Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters::EdgeDetectionParameters__sub_object(Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionType, int, int, float, float, float, int, int, int, int, int)
                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker23EdgeDetectionParametersC1ENS2_17EdgeDetectionTypeEiifffiiiii PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters::EdgeDetectionParameters(Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionType, int, int, float, float, float, int, int, int, int, int)
;;;64     
;;;65           BinaryTracker::EdgeDetectionParameters::EdgeDetectionParameters(EdgeDetectionType type, s32 threshold_yIncrement, s32 threshold_xIncrement, f32 threshold_blackPercentile, f32 threshold_whitePercentile, f32 threshold_scaleRegionPercent, s32 minComponentWidth, s32 maxDetectionsPerType, s32 combHalfWidth, s32 combResponseThreshold, s32 everyNLines)
;;;66             : type(type), threshold_yIncrement(threshold_yIncrement), threshold_xIncrement(threshold_xIncrement), threshold_blackPercentile(threshold_blackPercentile), threshold_whitePercentile(threshold_whitePercentile), threshold_scaleRegionPercent(threshold_scaleRegionPercent), minComponentWidth(minComponentWidth), maxDetectionsPerType(maxDetectionsPerType), combHalfWidth(combHalfWidth), combResponseThreshold(combResponseThreshold), everyNLines(everyNLines)
;;;67           {
;;;68           }
;;;69     
000000  b4f0              PUSH     {r4-r7}
000002  e9dd4504          LDRD     r4,r5,[sp,#0x10]
000006  e9dd6706          LDRD     r6,r7,[sp,#0x18]
00000a  f8ddc020          LDR      r12,[sp,#0x20]
00000e  7001              STRB     r1,[r0,#0]
000010  e9c02301          STRD     r2,r3,[r0,#4]
000014  ed800a03          VSTR     s0,[r0,#0xc]
000018  edc00a04          VSTR     s1,[r0,#0x10]
00001c  ed801a05          VSTR     s2,[r0,#0x14]
000020  f8c0c028          STR      r12,[r0,#0x28]
000024  e9c04506          STRD     r4,r5,[r0,#0x18]
000028  e9c06708          STRD     r6,r7,[r0,#0x20]
00002c  bcf0              POP      {r4-r7}
00002e  4770              BX       lr
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker23EdgeDetectionParametersC1Ev||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker23EdgeDetectionParametersC2Ev                  ; Alternate entry point ; Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters::EdgeDetectionParameters__sub_object()
                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker23EdgeDetectionParametersC1Ev PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters::EdgeDetectionParameters()
;;;59     
;;;60           BinaryTracker::EdgeDetectionParameters::EdgeDetectionParameters()
;;;61             : type(EDGE_TYPE_GRAYVALUE), threshold_yIncrement(-1), threshold_xIncrement(-1), threshold_blackPercentile(-1), threshold_whitePercentile(-1), threshold_scaleRegionPercent(-1), minComponentWidth(-1), maxDetectionsPerType(-1), combHalfWidth(-1), combResponseThreshold(-1), everyNLines(-1)
;;;62           {
;;;63           }
;;;64     
000000  2100              MOVS     r1,#0
000002  7001              STRB     r1,[r0,#0]
000004  1e49              SUBS     r1,r1,#1
000006  6041              STR      r1,[r0,#4]
000008  eebf0a00          VMOV.F32 s0,#-1.00000000
00000c  6081              STR      r1,[r0,#8]
00000e  ed800a03          VSTR     s0,[r0,#0xc]
000012  ed800a04          VSTR     s0,[r0,#0x10]
000016  ed800a05          VSTR     s0,[r0,#0x14]
00001a  6181              STR      r1,[r0,#0x18]
00001c  61c1              STR      r1,[r0,#0x1c]
00001e  6201              STR      r1,[r0,#0x20]
000020  6241              STR      r1,[r0,#0x24]
000022  6281              STR      r1,[r0,#0x28]
000024  4770              BX       lr
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker26ComputeIndexLimitsVerticalERKNS0_15FixedLengthListINS0_5PointIsEEEERNS0_5ArrayIiEE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker26ComputeIndexLimitsVerticalERKNS0_15FixedLengthListINS0_5PointIsEEEERNS0_5ArrayIiEE PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::ComputeIndexLimitsVertical(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::Array<int>&)
;;;770    
;;;771          Result BinaryTracker::ComputeIndexLimitsVertical(const FixedLengthList<Point<s16> > &points, Array<s32> &yStartIndexes)
000000  b430              PUSH     {r4,r5}
000002  f8d1c008          LDR      r12,[r1,#8]
000006  690b              LDR      r3,[r1,#0x10]
;;;772          {
;;;773            const Point<s16> * restrict pPoints = points.Pointer(0);
;;;774            s32 * restrict pIndexes = yStartIndexes.Pointer(0,0);
000008  2200              MOVS     r2,#0
00000a  6849              LDR      r1,[r1,#4]
00000c  fb023c0c          MLA      r12,r2,r12,r3
;;;775    
;;;776            const s32 maxY = yStartIndexes.get_size(1) - 1;
000010  1e4d              SUBS     r5,r1,#1
;;;777            const s32 numPoints = points.get_size();
;;;778    
;;;779            s32 iPoint = 0;
000012  2100              MOVS     r1,#0
;;;780            s32 lastY = -1;
;;;781    
;;;782            while(iPoint < numPoints) {
000014  68c2              LDR      r2,[r0,#0xc]
000016  6b04              LDR      r4,[r0,#0x30]
000018  1e4b              SUBS     r3,r1,#1              ;780
00001a  2a00              CMP      r2,#0
00001c  dd17              BLE      |L12.78|
                  |L12.30|
;;;783              while((iPoint < numPoints) && (pPoints[iPoint].y == lastY)) {
00001e  4291              CMP      r1,r2
000020  da07              BGE      |L12.50|
000022  eb040081          ADD      r0,r4,r1,LSL #2
000026  f9b00002          LDRSH    r0,[r0,#2]
00002a  4298              CMP      r0,r3
;;;784                iPoint++;
00002c  bf08              IT       EQ
00002e  1c49              ADDEQ    r1,r1,#1
000030  d0f5              BEQ      |L12.30|
                  |L12.50|
;;;785              }
;;;786    
;;;787              for(s32 y=lastY+1; y<=pPoints[iPoint].y; y++) {
000032  1c58              ADDS     r0,r3,#1
000034  eb040381          ADD      r3,r4,r1,LSL #2
000038  f9b33002          LDRSH    r3,[r3,#2]
00003c  4283              CMP      r3,r0
00003e  db04              BLT      |L12.74|
                  |L12.64|
;;;788                pIndexes[y] = iPoint;
000040  f84c1020          STR      r1,[r12,r0,LSL #2]
000044  1c40              ADDS     r0,r0,#1              ;787
000046  4283              CMP      r3,r0                 ;787
000048  dafa              BGE      |L12.64|
                  |L12.74|
00004a  4291              CMP      r1,r2                 ;782
00004c  dbe7              BLT      |L12.30|
                  |L12.78|
;;;789              }
;;;790    
;;;791              lastY = pPoints[iPoint].y;
;;;792            }
;;;793    
;;;794            lastY = pPoints[numPoints-1].y;
00004e  eb040082          ADD      r0,r4,r2,LSL #2
000052  f9300c02          LDRSH    r0,[r0,#-2]
;;;795    
;;;796            for(s32 y=lastY+1; y<=maxY; y++) {
000056  1c40              ADDS     r0,r0,#1
000058  4285              CMP      r5,r0
00005a  db04              BLT      |L12.102|
                  |L12.92|
;;;797              pIndexes[y] = numPoints;
00005c  f84c2020          STR      r2,[r12,r0,LSL #2]
000060  1c40              ADDS     r0,r0,#1              ;796
000062  4285              CMP      r5,r0                 ;796
000064  dafa              BGE      |L12.92|
                  |L12.102|
;;;798            }
;;;799    
;;;800            return RESULT_OK;
;;;801          } // BinaryTracker::ComputeIndexLimitsVertical()
000066  bc30              POP      {r4,r5}
000068  2000              MOVS     r0,#0                 ;800
00006a  4770              BX       lr
;;;802    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker28ComputeIndexLimitsHorizontalERKNS0_15FixedLengthListINS0_5PointIsEEEERNS0_5ArrayIiEE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker28ComputeIndexLimitsHorizontalERKNS0_15FixedLengthListINS0_5PointIsEEEERNS0_5ArrayIiEE PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::ComputeIndexLimitsHorizontal(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::Array<int>&)
;;;802    
;;;803          Result BinaryTracker::ComputeIndexLimitsHorizontal(const FixedLengthList<Point<s16> > &points, Array<s32> &xStartIndexes)
000000  b430              PUSH     {r4,r5}
000002  f8d1c008          LDR      r12,[r1,#8]
000006  690b              LDR      r3,[r1,#0x10]
;;;804          {
;;;805            const Point<s16> * restrict pPoints = points.Pointer(0);
;;;806            s32 * restrict pIndexes = xStartIndexes.Pointer(0,0);
000008  2200              MOVS     r2,#0
00000a  6849              LDR      r1,[r1,#4]
00000c  fb023c0c          MLA      r12,r2,r12,r3
;;;807    
;;;808            const s32 maxX = xStartIndexes.get_size(1) - 1;
000010  1e4d              SUBS     r5,r1,#1
;;;809            const s32 numPoints = points.get_size();
;;;810    
;;;811            s32 iPoint = 0;
000012  2100              MOVS     r1,#0
;;;812            s32 lastX = -1;
;;;813    
;;;814            while(iPoint < numPoints) {
000014  68c2              LDR      r2,[r0,#0xc]
000016  6b04              LDR      r4,[r0,#0x30]
000018  1e4b              SUBS     r3,r1,#1              ;812
00001a  2a00              CMP      r2,#0
00001c  dd13              BLE      |L13.70|
                  |L13.30|
;;;815              while((iPoint < numPoints) && (pPoints[iPoint].x == lastX)) {
00001e  4291              CMP      r1,r2
000020  da05              BGE      |L13.46|
000022  f9340021          LDRSH    r0,[r4,r1,LSL #2]
000026  4298              CMP      r0,r3
;;;816                iPoint++;
000028  bf08              IT       EQ
00002a  1c49              ADDEQ    r1,r1,#1
00002c  d0f7              BEQ      |L13.30|
                  |L13.46|
;;;817              }
;;;818    
;;;819              for(s32 x=lastX+1; x<=pPoints[iPoint].x; x++) {
00002e  1c58              ADDS     r0,r3,#1
000030  f9343021          LDRSH    r3,[r4,r1,LSL #2]
000034  4283              CMP      r3,r0
000036  db04              BLT      |L13.66|
                  |L13.56|
;;;820                pIndexes[x] = iPoint;
000038  f84c1020          STR      r1,[r12,r0,LSL #2]
00003c  1c40              ADDS     r0,r0,#1              ;819
00003e  4283              CMP      r3,r0                 ;819
000040  dafa              BGE      |L13.56|
                  |L13.66|
000042  4291              CMP      r1,r2                 ;814
000044  dbeb              BLT      |L13.30|
                  |L13.70|
;;;821              }
;;;822    
;;;823              lastX = pPoints[iPoint].x;
;;;824            }
;;;825    
;;;826            lastX = pPoints[numPoints-1].x;
000046  eb040082          ADD      r0,r4,r2,LSL #2
00004a  f9300c04          LDRSH    r0,[r0,#-4]
;;;827    
;;;828            for(s32 x=lastX+1; x<=maxX; x++) {
00004e  1c40              ADDS     r0,r0,#1
000050  4285              CMP      r5,r0
000052  db04              BLT      |L13.94|
                  |L13.84|
;;;829              pIndexes[x] = numPoints;
000054  f84c2020          STR      r2,[r12,r0,LSL #2]
000058  1c40              ADDS     r0,r0,#1              ;828
00005a  4285              CMP      r5,r0                 ;828
00005c  dafa              BGE      |L13.84|
                  |L13.94|
;;;830            }
;;;831    
;;;832            return RESULT_OK;
;;;833          } // BinaryTracker::ComputeIndexLimitsHorizontal()
00005e  bc30              POP      {r4,r5}
000060  2000              MOVS     r0,#0                 ;832
000062  4770              BX       lr
;;;834    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker32FindVerticalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker32FindVerticalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_List(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&)
                  ||__tagsym$$noinline||
;;;1449   
;;;1450         NO_INLINE Result BinaryTracker::FindVerticalCorrespondences_List(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1451           const s32 maxMatchingDistance,
;;;1452           const Transformations::PlanarTransformation_f32 &transformation,
;;;1453           const FixedLengthList<Point<s16> > &templatePoints,
;;;1454           const FixedLengthList<Point<s16> > &newPoints,
;;;1455           const s32 imageHeight,
;;;1456           const s32 imageWidth,
;;;1457           const Array<s32> &xStartIndexes, //< Computed by ComputeIndexLimitsHorizontal
;;;1458           FixedLengthList<IndexCorrespondence> &matchingIndexes)
;;;1459         {
000004  4617              MOV      r7,r2
000006  ed2d8b0e          VPUSH    {d8-d14}
00000a  b085              SUB      sp,sp,#0x14
00000c  461e              MOV      r6,r3
00000e  4688              MOV      r8,r1
;;;1460           const s32 numTemplatePoints = templatePoints.get_size();
;;;1461           //const s32 numNewPoints = newPoints.get_size();
;;;1462   
;;;1463           const Array<f32> &homography = transformation.get_homography();
000010  4608              MOV      r0,r1
000012  68d2              LDR      r2,[r2,#0xc]
000014  9d22              LDR      r5,[sp,#0x88]
000016  9202              STR      r2,[sp,#8]
000018  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
00001c  4604              MOV      r4,r0
;;;1464           const Point<f32> &centerOffset = transformation.get_centerOffset(1.0f);
00001e  eeb70a00          VMOV.F32 s0,#1.00000000
000022  4641              MOV      r1,r8
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
00002a  68a2              LDR      r2,[r4,#8]
00002c  6921              LDR      r1,[r4,#0x10]
;;;1465   
;;;1466           // TODO: if the homography is just translation, we can do this faster (just slightly, as most of the cost is the search)
;;;1467           const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2];
00002e  2000              MOVS     r0,#0
000030  fb001002          MLA      r0,r0,r2,r1
000034  46e8              MOV      r8,sp                 ;1464
000036  edd0da00          VLDR     s27,[r0,#0]
00003a  ed90da01          VLDR     s26,[r0,#4]
00003e  edd0ca02          VLDR     s25,[r0,#8]
;;;1468           const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2];
000042  2001              MOVS     r0,#1
000044  fb001002          MLA      r0,r0,r2,r1
;;;1469           const f32 h20 = homography[2][0]; const f32 h21 = homography[2][1]; const f32 h22 = 1.0f;
000048  eeb7ea00          VMOV.F32 s28,#1.00000000
00004c  ed90ca00          VLDR     s24,[r0,#0]           ;1468
000050  edd0ba01          VLDR     s23,[r0,#4]           ;1468
000054  ed90ba02          VLDR     s22,[r0,#8]           ;1468
000058  2002              MOVS     r0,#2
00005a  fb001002          MLA      r0,r0,r2,r1
;;;1470   
;;;1471           AnkiAssert(FLT_NEAR(homography[2][2], 1.0f));
;;;1472   
;;;1473           IndexCorrespondence * restrict pMatchingIndexes = matchingIndexes.Pointer(0);
;;;1474           s32 numMatchingIndexes = 0;
00005e  2400              MOVS     r4,#0
000060  edd0aa00          VLDR     s21,[r0,#0]           ;1469
000064  ed90aa01          VLDR     s20,[r0,#4]           ;1469
000068  9823              LDR      r0,[sp,#0x8c]         ;1469
;;;1475           const s32 maxMatchingIndexes = matchingIndexes.get_maximumSize();
00006a  f8d0b030          LDR      r11,[r0,#0x30]
00006e  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::get_maximumSize() const
000072  68ab              LDR      r3,[r5,#8]
000074  692a              LDR      r2,[r5,#0x10]
;;;1476   
;;;1477           const Point<s16> * restrict pTemplatePoints = templatePoints.Pointer(0);
;;;1478           const Point<s16> * restrict pNewPoints = newPoints.Pointer(0);
;;;1479           const s32 * restrict pXStartIndexes = xStartIndexes.Pointer(0,0);
000076  2100              MOVS     r1,#0
000078  fb012903          MLA      r9,r1,r3,r2
;;;1480   
;;;1481           for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++) {
00007c  9a02              LDR      r2,[sp,#8]
00007e  f8d7a030          LDR      r10,[r7,#0x30]
000082  6b36              LDR      r6,[r6,#0x30]
000084  460d              MOV      r5,r1
000086  2a00              CMP      r2,#0
;;;1482             const f32 xr = static_cast<f32>(pTemplatePoints[iPoint].x);
;;;1483             const f32 yr = static_cast<f32>(pTemplatePoints[iPoint].y);
;;;1484   
;;;1485             //
;;;1486             // Warp x and y based on the current homography
;;;1487             //
;;;1488   
;;;1489             // Subtract the center offset
;;;1490             const f32 xc = xr - centerOffset.x;
;;;1491             const f32 yc = yr - centerOffset.y;
;;;1492   
;;;1493             // Projective warp
;;;1494             const f32 wpi = 1.0f / (h20*xc + h21*yc + h22);
;;;1495             const f32 warpedX = (h00*xc + h01*yc + h02) * wpi;
;;;1496             const f32 warpedY = (h10*xc + h11*yc + h12) * wpi;
;;;1497   
;;;1498             // TODO: verify the -0.5f is correct
;;;1499             const s32 warpedXrounded = RoundS32_minusPointFive(warpedX + centerOffset.x);
;;;1500             const s32 warpedYrounded = RoundS32_minusPointFive(warpedY + centerOffset.y);
;;;1501   
;;;1502             if(warpedXrounded >= 0 && warpedXrounded < imageWidth) {
;;;1503               const s32 minY = warpedYrounded - maxMatchingDistance;
;;;1504               const s32 maxY = warpedYrounded + maxMatchingDistance;
;;;1505   
;;;1506               s32 curIndex = pXStartIndexes[warpedXrounded];
;;;1507               const s32 endIndex = pXStartIndexes[warpedXrounded+1];
;;;1508   
;;;1509               // Find the start of the valid matches
;;;1510               while( (curIndex<endIndex) && (pNewPoints[curIndex].y<minY) ) {
;;;1511                 curIndex++;
;;;1512               }
;;;1513   
;;;1514               // For every valid match, increment the sum and counter
;;;1515               while( (curIndex<endIndex) && (pNewPoints[curIndex].y<=maxY) ) {
;;;1516                 if(numMatchingIndexes < (maxMatchingIndexes-1)) {
000088  bfc4              ITT      GT
00008a  1e40              SUBGT    r0,r0,#1
00008c  9003              STRGT    r0,[sp,#0xc]
00008e  dd74              BLE      |L14.378|
                  |L14.144|
000090  f93a0025          LDRSH    r0,[r10,r5,LSL #2]    ;1482
000094  edd80a00          VLDR     s1,[r8,#0]            ;1490
000098  ee000a10          VMOV     s0,r0                 ;1482
00009c  eb0a0085          ADD      r0,r10,r5,LSL #2      ;1483
0000a0  eeb81ac0          VCVT.F32.S32 s2,s0                 ;1482
0000a4  f9b00002          LDRSH    r0,[r0,#2]            ;1483
0000a8  ee000a10          VMOV     s0,r0                 ;1483
0000ac  ee718a60          VSUB.F32 s17,s2,s1             ;1490
0000b0  ed981a01          VLDR     s2,[r8,#4]            ;1491
0000b4  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1483
0000b8  ee308a41          VSUB.F32 s16,s0,s2             ;1491
0000bc  ee2a0aa8          VMUL.F32 s0,s21,s17            ;1494
0000c0  ee0a0a08          VMLA.F32 s0,s20,s16            ;1494
0000c4  ee301a0e          VADD.F32 s2,s0,s28             ;1494
0000c8  ee8e0a01          VDIV.F32 s0,s28,s2             ;1494
0000cc  ee2d1aa8          VMUL.F32 s2,s27,s17            ;1495
0000d0  ee0d1a08          VMLA.F32 s2,s26,s16            ;1495
0000d4  ee311a2c          VADD.F32 s2,s2,s25             ;1495
0000d8  ee619a00          VMUL.F32 s19,s2,s0             ;1495
0000dc  ee2c1a28          VMUL.F32 s2,s24,s17            ;1496
0000e0  ee0b1a88          VMLA.F32 s2,s23,s16            ;1496
0000e4  ee311a0b          VADD.F32 s2,s2,s22             ;1496
0000e8  ee219a00          VMUL.F32 s18,s2,s0             ;1496
0000ec  ee300aa9          VADD.F32 s0,s1,s19             ;1499
0000f0  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
0000f4  ed980a01          VLDR     s0,[r8,#4]            ;1500
0000f8  4607              MOV      r7,r0                 ;1499
0000fa  ee300a09          VADD.F32 s0,s0,s18             ;1500
0000fe  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
000102  4602              MOV      r2,r0                 ;1500
000104  2f00              CMP      r7,#0                 ;1502
000106  bfa4              ITT      GE                    ;1502
000108  9821              LDRGE    r0,[sp,#0x84]         ;1502
00010a  42b8              CMPGE    r0,r7                 ;1502
00010c  dd31              BLE      |L14.370|
00010e  9813              LDR      r0,[sp,#0x4c]         ;1503
000110  eb090c87          ADD      r12,r9,r7,LSL #2      ;1507
000114  1a11              SUBS     r1,r2,r0              ;1503
000116  1813              ADDS     r3,r2,r0              ;1504
000118  f8590027          LDR      r0,[r9,r7,LSL #2]     ;1506
00011c  f8dcc004          LDR      r12,[r12,#4]          ;1507
                  |L14.288|
000120  4560              CMP      r0,r12                ;1510
000122  da1e              BGE      |L14.354|
000124  eb060780          ADD      r7,r6,r0,LSL #2       ;1510
000128  f9b77002          LDRSH    r7,[r7,#2]            ;1510
00012c  428f              CMP      r7,r1                 ;1510
00012e  bfb8              IT       LT                    ;1511
000130  1c40              ADDLT    r0,r0,#1              ;1511
000132  dbf5              BLT      |L14.288|
000134  e015              B        |L14.354|
                  |L14.310|
000136  9f03              LDR      r7,[sp,#0xc]
000138  42a7              CMP      r7,r4
00013a  dd11              BLE      |L14.352|
;;;1517                   const s32 offset = pNewPoints[curIndex].y - warpedYrounded;
00013c  1a89              SUBS     r1,r1,r2
;;;1518                   const f32 yp = warpedY + static_cast<f32>(offset);
00013e  ee001a10          VMOV     s0,r1
;;;1519   
;;;1520                   //pMatchingIndexes[numMatchingIndexes].templateIndex = iPoint;
;;;1521                   //pMatchingIndexes[numMatchingIndexes].matchedIndex = curIndex;
;;;1522   
;;;1523                   pMatchingIndexes[numMatchingIndexes].templatePoint.x = xc;
000142  eb0b1104          ADD      r1,r11,r4,LSL #4
;;;1524                   pMatchingIndexes[numMatchingIndexes].templatePoint.y = yc;
;;;1525                   pMatchingIndexes[numMatchingIndexes].matchedPoint.x = warpedX;
;;;1526                   pMatchingIndexes[numMatchingIndexes].matchedPoint.y = yp;
;;;1527                   numMatchingIndexes++;
000146  1c64              ADDS     r4,r4,#1
000148  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1518
00014c  edc18a00          VSTR     s17,[r1,#0]           ;1523
000150  ed818a01          VSTR     s16,[r1,#4]           ;1524
000154  edc19a02          VSTR     s19,[r1,#8]           ;1525
000158  ee390a00          VADD.F32 s0,s18,s0             ;1518
00015c  ed810a03          VSTR     s0,[r1,#0xc]          ;1526
                  |L14.352|
;;;1528                 }
;;;1529   
;;;1530                 curIndex++;
000160  1c40              ADDS     r0,r0,#1
                  |L14.354|
000162  4560              CMP      r0,r12                ;1515
000164  da05              BGE      |L14.370|
000166  eb060180          ADD      r1,r6,r0,LSL #2       ;1515
00016a  f9b11002          LDRSH    r1,[r1,#2]            ;1515
00016e  428b              CMP      r3,r1                 ;1515
000170  dae1              BGE      |L14.310|
                  |L14.370|
000172  9802              LDR      r0,[sp,#8]            ;1481
000174  1c6d              ADDS     r5,r5,#1              ;1481
000176  4285              CMP      r5,r0                 ;1481
000178  db8a              BLT      |L14.144|
                  |L14.378|
;;;1531               }
;;;1532             } // if(warpedXrounded >= 0 && warpedXrounded < imageWidth)
;;;1533           } // for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++)
;;;1534   
;;;1535           matchingIndexes.set_size(numMatchingIndexes);
00017a  4621              MOV      r1,r4
00017c  9823              LDR      r0,[sp,#0x8c]
00017e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::set_size(int)
;;;1536   
;;;1537           return RESULT_OK;
;;;1538         }
000182  b005              ADD      sp,sp,#0x14
000184  2000              MOVS     r0,#0                 ;1537
000186  ecbd8b0e          VPOP     {d8-d14}
00018a  b004              ADD      sp,sp,#0x10
00018c  e8bd8ff0          POP      {r4-r11,pc}
;;;1539   
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker33IterativelyRefineTrack_ProjectiveERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker33IterativelyRefineTrack_ProjectiveERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiNS0_11MemoryStackE PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::IterativelyRefineTrack_Projective(const Anki::Embedded::EdgeLists&, const Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, int, Anki::Embedded::MemoryStack)
;;;1923   
;;;1924         Result BinaryTracker::IterativelyRefineTrack_Projective(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1925           const EdgeLists &nextImageEdges,
;;;1926           const AllIndexLimits &allLimits,
;;;1927           const s32 matching_maxDistance,
;;;1928           MemoryStack scratch)
;;;1929         {
000004  b0c6              SUB      sp,sp,#0x118
000006  469a              MOV      r10,r3
000008  4617              MOV      r7,r2
00000a  460c              MOV      r4,r1
00000c  4605              MOV      r5,r0
;;;1930           Result lastResult;
;;;1931   
;;;1932           Array<f32> AtA_xDecreasing(8,8,scratch);
00000e  2300              MOVS     r3,#0
000010  461a              MOV      r2,r3
000012  2101              MOVS     r1,#1
000014  a83a              ADD      r0,sp,#0xe8
000016  f8dd9138          LDR      r9,[sp,#0x138]
00001a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00001e  6800              LDR      r0,[r0,#0]
000020  2208              MOVS     r2,#8
000022  9000              STR      r0,[sp,#0]
000024  464b              MOV      r3,r9
000026  4611              MOV      r1,r2
000028  a811              ADD      r0,sp,#0x44
00002a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1933           Array<f32> AtA_xIncreasing(8,8,scratch);
00002e  2300              MOVS     r3,#0
000030  461a              MOV      r2,r3
000032  2101              MOVS     r1,#1
000034  a83b              ADD      r0,sp,#0xec
000036  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00003a  6800              LDR      r0,[r0,#0]
00003c  2208              MOVS     r2,#8
00003e  9000              STR      r0,[sp,#0]
000040  464b              MOV      r3,r9
000042  4611              MOV      r1,r2
000044  a816              ADD      r0,sp,#0x58
000046  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1934           Array<f32> AtA_yDecreasing(8,8,scratch);
00004a  2300              MOVS     r3,#0
00004c  461a              MOV      r2,r3
00004e  2101              MOVS     r1,#1
000050  a83c              ADD      r0,sp,#0xf0
000052  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000056  6800              LDR      r0,[r0,#0]
000058  2208              MOVS     r2,#8
00005a  9000              STR      r0,[sp,#0]
00005c  464b              MOV      r3,r9
00005e  4611              MOV      r1,r2
000060  a81b              ADD      r0,sp,#0x6c
000062  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1935           Array<f32> AtA_yIncreasing(8,8,scratch);
000066  2300              MOVS     r3,#0
000068  461a              MOV      r2,r3
00006a  2101              MOVS     r1,#1
00006c  a83d              ADD      r0,sp,#0xf4
00006e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000072  6800              LDR      r0,[r0,#0]
000074  2208              MOVS     r2,#8
000076  9000              STR      r0,[sp,#0]
000078  464b              MOV      r3,r9
00007a  4611              MOV      r1,r2
00007c  a820              ADD      r0,sp,#0x80
00007e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1936   
;;;1937           Array<f32> Atb_t_xDecreasing(1,8,scratch);
000082  2300              MOVS     r3,#0
000084  461a              MOV      r2,r3
000086  2101              MOVS     r1,#1
000088  a83e              ADD      r0,sp,#0xf8
00008a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00008e  6800              LDR      r0,[r0,#0]
000090  9000              STR      r0,[sp,#0]
000092  464b              MOV      r3,r9
000094  2208              MOVS     r2,#8
000096  2101              MOVS     r1,#1
000098  a825              ADD      r0,sp,#0x94
00009a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1938           Array<f32> Atb_t_xIncreasing(1,8,scratch);
00009e  2300              MOVS     r3,#0
0000a0  461a              MOV      r2,r3
0000a2  2101              MOVS     r1,#1
0000a4  a83f              ADD      r0,sp,#0xfc
0000a6  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000aa  6800              LDR      r0,[r0,#0]
0000ac  9000              STR      r0,[sp,#0]
0000ae  464b              MOV      r3,r9
0000b0  2208              MOVS     r2,#8
0000b2  2101              MOVS     r1,#1
0000b4  a82a              ADD      r0,sp,#0xa8
0000b6  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1939           Array<f32> Atb_t_yDecreasing(1,8,scratch);
0000ba  2300              MOVS     r3,#0
0000bc  461a              MOV      r2,r3
0000be  2101              MOVS     r1,#1
0000c0  a840              ADD      r0,sp,#0x100
0000c2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000c6  6800              LDR      r0,[r0,#0]
0000c8  9000              STR      r0,[sp,#0]
0000ca  464b              MOV      r3,r9
0000cc  2208              MOVS     r2,#8
0000ce  2101              MOVS     r1,#1
0000d0  a82f              ADD      r0,sp,#0xbc
0000d2  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1940           Array<f32> Atb_t_yIncreasing(1,8,scratch);
0000d6  2300              MOVS     r3,#0
0000d8  461a              MOV      r2,r3
0000da  2101              MOVS     r1,#1
0000dc  a841              ADD      r0,sp,#0x104
0000de  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000e2  6800              LDR      r0,[r0,#0]
0000e4  9000              STR      r0,[sp,#0]
0000e6  464b              MOV      r3,r9
0000e8  2208              MOVS     r2,#8
0000ea  2101              MOVS     r1,#1
0000ec  a834              ADD      r0,sp,#0xd0
0000ee  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1941   
;;;1942           lastResult = BinaryTracker::FindHorizontalCorrespondences_Projective(
0000f2  f8d400d4          LDR      r0,[r4,#0xd4]
0000f6  e9cd0701          STRD     r0,r7,[sp,#4]
0000fa  a925              ADD      r1,sp,#0x94
0000fc  aa11              ADD      r2,sp,#0x44
0000fe  e9cd2103          STRD     r2,r1,[sp,#0xc]
000102  f8d400d0          LDR      r0,[r4,#0xd0]
000106  9000              STR      r0,[sp,#0]
000108  4623              MOV      r3,r4
00010a  f1050274          ADD      r2,r5,#0x74
00010e  f50571a8          ADD      r1,r5,#0x150
000112  4650              MOV      r0,r10
000114  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker40FindHorizontalCorrespondences_ProjectiveEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNSD_IfEESI_ ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_Projective(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
;;;1943             matching_maxDistance, this->transformation,
;;;1944             this->templateEdges.xDecreasing, nextImageEdges.xDecreasing,
;;;1945             nextImageEdges.imageHeight, nextImageEdges.imageWidth,
;;;1946             allLimits.xDecreasing_yStartIndexes, AtA_xDecreasing, Atb_t_xDecreasing);
;;;1947   
;;;1948           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
000118  4ecc              LDR      r6,|L15.1100|
00011a  ea5f0800          MOVS     r8,r0                 ;1942
00011e  d00d              BEQ      |L15.316|
000120  f240709c          MOV      r0,#0x79c
000124  e9cd6000          STRD     r6,r0,[sp,#0]
000128  a3c9              ADR      r3,|L15.1104|
00012a  a2d5              ADR      r2,|L15.1152|
00012c  a1de              ADR      r1,|L15.1192|
00012e  2005              MOVS     r0,#5
000130  f7fffffe          BL       _Anki_Log
;;;1949             lastResult, "BinaryTracker::IterativelyRefineTrack_Projective", "FindHorizontalCorrespondences 1 failed");
;;;1950   
;;;1951           lastResult = BinaryTracker::FindHorizontalCorrespondences_Projective(
;;;1952             matching_maxDistance, this->transformation,
;;;1953             this->templateEdges.xIncreasing, nextImageEdges.xIncreasing,
;;;1954             nextImageEdges.imageHeight, nextImageEdges.imageWidth,
;;;1955             allLimits.xIncreasing_yStartIndexes, AtA_xIncreasing, Atb_t_xIncreasing);
;;;1956   
;;;1957           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;1958             lastResult, "BinaryTracker::IterativelyRefineTrack_Projective", "FindHorizontalCorrespondences 2 failed");
;;;1959   
;;;1960           lastResult = BinaryTracker::FindVerticalCorrespondences_Projective(
;;;1961             matching_maxDistance, this->transformation,
;;;1962             this->templateEdges.yDecreasing, nextImageEdges.yDecreasing,
;;;1963             nextImageEdges.imageHeight, nextImageEdges.imageWidth,
;;;1964             allLimits.yDecreasing_xStartIndexes, AtA_yDecreasing, Atb_t_yDecreasing);
;;;1965   
;;;1966           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;1967             lastResult, "BinaryTracker::IterativelyRefineTrack_Projective", "FindVerticalCorrespondences 1 failed");
;;;1968   
;;;1969           lastResult = BinaryTracker::FindVerticalCorrespondences_Projective(
;;;1970             matching_maxDistance, this->transformation,
;;;1971             this->templateEdges.yIncreasing, nextImageEdges.yIncreasing,
;;;1972             nextImageEdges.imageHeight, nextImageEdges.imageWidth,
;;;1973             allLimits.yIncreasing_xStartIndexes, AtA_yIncreasing, Atb_t_yIncreasing);
;;;1974   
;;;1975           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;1976             lastResult, "BinaryTracker::IterativelyRefineTrack_Projective", "FindVerticalCorrespondences 2 failed");
;;;1977   
;;;1978           // Update the transformation
;;;1979           {
;;;1980             Array<f32> newHomography(3, 3, scratch);
;;;1981   
;;;1982             Array<f32> AtA(8,8,scratch);
;;;1983             Array<f32> Atb_t(1,8,scratch);
;;;1984   
;;;1985             // The total AtA and Atb matrices are just the elementwise sums of their partial versions
;;;1986             for(s32 y=0; y<8; y++) {
;;;1987               for(s32 x=0; x<8; x++) {
;;;1988                 AtA[y][x] = AtA_xDecreasing[y][x] + AtA_xIncreasing[y][x] + AtA_yDecreasing[y][x] + AtA_yIncreasing[y][x];
;;;1989               }
;;;1990   
;;;1991               Atb_t[0][y] = Atb_t_xDecreasing[0][y] + Atb_t_xIncreasing[0][y] + Atb_t_yDecreasing[0][y] + Atb_t_yIncreasing[0][y];
;;;1992             }
;;;1993   
;;;1994             Matrix::MakeSymmetric(AtA, false);
;;;1995   
;;;1996             //AtA.Print("AtA");
;;;1997             //Atb_t.Print("Atb_t");
;;;1998             bool numericalFailure;
;;;1999             lastResult = Matrix::SolveLeastSquaresWithCholesky<f32>(AtA, Atb_t, false, numericalFailure);
;;;2000   
;;;2001             //Atb_t.Print("result");
;;;2002   
;;;2003             AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2004               lastResult, "BinaryTracker::IterativelyRefineTrack_Projective", "SolveLeastSquaresWithCholesky failed");
;;;2005   
;;;2006             if(numericalFailure){
;;;2007               AnkiWarn("BinaryTracker::IterativelyRefineTrack_Projective", "numericalFailure");
;;;2008               return RESULT_OK;
;;;2009             }
;;;2010   
;;;2011             const f32 * restrict pAtb_t = Atb_t.Pointer(0,0);
;;;2012   
;;;2013             newHomography[0][0] = pAtb_t[0]; newHomography[0][1] = pAtb_t[1]; newHomography[0][2] = pAtb_t[2];
;;;2014             newHomography[1][0] = pAtb_t[3]; newHomography[1][1] = pAtb_t[4]; newHomography[1][2] = pAtb_t[5];
;;;2015             newHomography[2][0] = pAtb_t[6]; newHomography[2][1] = pAtb_t[7]; newHomography[2][2] = 1.0f;
;;;2016   
;;;2017             //newHomography.Print("newHomography");
;;;2018   
;;;2019             this->transformation.set_homography(newHomography);
;;;2020           }
;;;2021   
;;;2022           return RESULT_OK;
;;;2023         } // Result BinaryTracker::IterativelyRefineTrack_Projective()
000134  b046              ADD      sp,sp,#0x118
000136  4640              MOV      r0,r8                 ;1948
000138  e8bd87f0          POP      {r4-r10,pc}
                  |L15.316|
00013c  f10d0804          ADD      r8,sp,#4              ;1951
000140  f8d400d4          LDR      r0,[r4,#0xd4]         ;1951
000144  ab2a              ADD      r3,sp,#0xa8           ;1951
000146  aa16              ADD      r2,sp,#0x58           ;1951
000148  f1070114          ADD      r1,r7,#0x14           ;1951
00014c  e8a8000f          STM      r8!,{r0-r3}           ;1951
000150  f8d400d0          LDR      r0,[r4,#0xd0]         ;1951
000154  9000              STR      r0,[sp,#0]            ;1951
000156  f1040334          ADD      r3,r4,#0x34           ;1951
00015a  f10502a8          ADD      r2,r5,#0xa8           ;1951
00015e  f50571a8          ADD      r1,r5,#0x150          ;1951
000162  4650              MOV      r0,r10                ;1951
000164  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker40FindHorizontalCorrespondences_ProjectiveEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNSD_IfEESI_ ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_Projective(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
000168  ea5f0800          MOVS     r8,r0                 ;1951
00016c  d00d              BEQ      |L15.394|
00016e  f24070a5          MOV      r0,#0x7a5             ;1957
000172  e9cd6000          STRD     r6,r0,[sp,#0]         ;1957
000176  a3b6              ADR      r3,|L15.1104|
000178  a2d8              ADR      r2,|L15.1244|
00017a  a1cb              ADR      r1,|L15.1192|
00017c  2005              MOVS     r0,#5                 ;1957
00017e  f7fffffe          BL       _Anki_Log
000182  b046              ADD      sp,sp,#0x118
000184  4640              MOV      r0,r8                 ;1957
000186  e8bd87f0          POP      {r4-r10,pc}
                  |L15.394|
00018a  f10d0804          ADD      r8,sp,#4              ;1960
00018e  f8d400d4          LDR      r0,[r4,#0xd4]         ;1960
000192  ab2f              ADD      r3,sp,#0xbc           ;1960
000194  aa1b              ADD      r2,sp,#0x6c           ;1960
000196  f1070128          ADD      r1,r7,#0x28           ;1960
00019a  e8a8000f          STM      r8!,{r0-r3}           ;1960
00019e  f8d400d0          LDR      r0,[r4,#0xd0]         ;1960
0001a2  9000              STR      r0,[sp,#0]            ;1960
0001a4  f1040368          ADD      r3,r4,#0x68           ;1960
0001a8  f10502dc          ADD      r2,r5,#0xdc           ;1960
0001ac  f50571a8          ADD      r1,r5,#0x150          ;1960
0001b0  4650              MOV      r0,r10                ;1960
0001b2  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker38FindVerticalCorrespondences_ProjectiveEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNSD_IfEESI_ ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_Projective(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
0001b6  ea5f0800          MOVS     r8,r0                 ;1960
0001ba  d00d              BEQ      |L15.472|
0001bc  f24070ae          MOV      r0,#0x7ae             ;1966
0001c0  e9cd6000          STRD     r6,r0,[sp,#0]         ;1966
0001c4  a3a2              ADR      r3,|L15.1104|
0001c6  a2cf              ADR      r2,|L15.1284|
0001c8  a1b7              ADR      r1,|L15.1192|
0001ca  2005              MOVS     r0,#5                 ;1966
0001cc  f7fffffe          BL       _Anki_Log
0001d0  b046              ADD      sp,sp,#0x118
0001d2  4640              MOV      r0,r8                 ;1966
0001d4  e8bd87f0          POP      {r4-r10,pc}
                  |L15.472|
0001d8  f10d0804          ADD      r8,sp,#4              ;1969
0001dc  f8d400d4          LDR      r0,[r4,#0xd4]         ;1969
0001e0  ab34              ADD      r3,sp,#0xd0           ;1969
0001e2  aa20              ADD      r2,sp,#0x80           ;1969
0001e4  f107013c          ADD      r1,r7,#0x3c           ;1969
0001e8  e8a8000f          STM      r8!,{r0-r3}           ;1969
0001ec  f8d400d0          LDR      r0,[r4,#0xd0]         ;1969
0001f0  9000              STR      r0,[sp,#0]            ;1969
0001f2  f104039c          ADD      r3,r4,#0x9c           ;1969
0001f6  f5057288          ADD      r2,r5,#0x110          ;1969
0001fa  f50571a8          ADD      r1,r5,#0x150          ;1969
0001fe  4650              MOV      r0,r10                ;1969
000200  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker38FindVerticalCorrespondences_ProjectiveEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNSD_IfEESI_ ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_Projective(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
000204  0004              MOVS     r4,r0                 ;1969
000206  d00d              BEQ      |L15.548|
000208  f24070b7          MOV      r0,#0x7b7             ;1975
00020c  e9cd6000          STRD     r6,r0,[sp,#0]         ;1975
000210  a38f              ADR      r3,|L15.1104|
000212  a2c6              ADR      r2,|L15.1324|
000214  a1a4              ADR      r1,|L15.1192|
000216  2005              MOVS     r0,#5                 ;1975
000218  f7fffffe          BL       _Anki_Log
00021c  b046              ADD      sp,sp,#0x118
00021e  4620              MOV      r0,r4                 ;1975
000220  e8bd87f0          POP      {r4-r10,pc}
                  |L15.548|
000224  2300              MOVS     r3,#0                 ;1980
000226  461a              MOV      r2,r3                 ;1980
000228  2101              MOVS     r1,#1                 ;1980
00022a  a842              ADD      r0,sp,#0x108          ;1980
00022c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000230  6800              LDR      r0,[r0,#0]            ;1980
000232  2203              MOVS     r2,#3                 ;1980
000234  9000              STR      r0,[sp,#0]            ;1980
000236  464b              MOV      r3,r9                 ;1980
000238  4611              MOV      r1,r2                 ;1980
00023a  a802              ADD      r0,sp,#8              ;1980
00023c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000240  2300              MOVS     r3,#0                 ;1982
000242  461a              MOV      r2,r3                 ;1982
000244  2101              MOVS     r1,#1                 ;1982
000246  a843              ADD      r0,sp,#0x10c          ;1982
000248  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00024c  6800              LDR      r0,[r0,#0]            ;1982
00024e  2208              MOVS     r2,#8                 ;1982
000250  9000              STR      r0,[sp,#0]            ;1982
000252  464b              MOV      r3,r9                 ;1982
000254  4611              MOV      r1,r2                 ;1982
000256  a807              ADD      r0,sp,#0x1c           ;1982
000258  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00025c  2300              MOVS     r3,#0                 ;1983
00025e  461a              MOV      r2,r3                 ;1983
000260  2101              MOVS     r1,#1                 ;1983
000262  a844              ADD      r0,sp,#0x110          ;1983
000264  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000268  6800              LDR      r0,[r0,#0]            ;1983
00026a  9000              STR      r0,[sp,#0]            ;1983
00026c  464b              MOV      r3,r9                 ;1983
00026e  2208              MOVS     r2,#8                 ;1983
000270  2101              MOVS     r1,#1                 ;1983
000272  a80c              ADD      r0,sp,#0x30           ;1983
000274  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000278  2000              MOVS     r0,#0                 ;1986
                  |L15.634|
00027a  2100              MOVS     r1,#0                 ;1987
                  |L15.636|
00027c  9b13              LDR      r3,[sp,#0x4c]         ;1987
00027e  9a15              LDR      r2,[sp,#0x54]         ;1987
000280  fb002203          MLA      r2,r0,r3,r2           ;1987
000284  eb020281          ADD      r2,r2,r1,LSL #2       ;1988
000288  9b18              LDR      r3,[sp,#0x60]         ;1988
00028a  ed920a00          VLDR     s0,[r2,#0]            ;1988
00028e  9a1a              LDR      r2,[sp,#0x68]         ;1988
000290  fb002203          MLA      r2,r0,r3,r2           ;1988
000294  eb020281          ADD      r2,r2,r1,LSL #2       ;1988
000298  9b1d              LDR      r3,[sp,#0x74]         ;1988
00029a  edd20a00          VLDR     s1,[r2,#0]            ;1988
00029e  9a1f              LDR      r2,[sp,#0x7c]         ;1988
0002a0  fb002203          MLA      r2,r0,r3,r2           ;1988
0002a4  eb020281          ADD      r2,r2,r1,LSL #2       ;1988
0002a8  ee300a20          VADD.F32 s0,s0,s1              ;1988
0002ac  edd20a00          VLDR     s1,[r2,#0]            ;1988
0002b0  9b22              LDR      r3,[sp,#0x88]         ;1988
0002b2  9a24              LDR      r2,[sp,#0x90]         ;1988
0002b4  ee300a20          VADD.F32 s0,s0,s1              ;1988
0002b8  fb002203          MLA      r2,r0,r3,r2           ;1988
0002bc  eb020281          ADD      r2,r2,r1,LSL #2       ;1988
0002c0  9b09              LDR      r3,[sp,#0x24]         ;1988
0002c2  edd20a00          VLDR     s1,[r2,#0]            ;1988
0002c6  9a0b              LDR      r2,[sp,#0x2c]         ;1988
0002c8  fb002203          MLA      r2,r0,r3,r2           ;1988
0002cc  ee300a20          VADD.F32 s0,s0,s1              ;1988
0002d0  eb020281          ADD      r2,r2,r1,LSL #2       ;1988
0002d4  1c49              ADDS     r1,r1,#1              ;1987
0002d6  ed820a00          VSTR     s0,[r2,#0]            ;1988
0002da  2908              CMP      r1,#8                 ;1987
0002dc  dbce              BLT      |L15.636|
0002de  9b27              LDR      r3,[sp,#0x9c]         ;1987
0002e0  9a29              LDR      r2,[sp,#0xa4]         ;1987
0002e2  2100              MOVS     r1,#0                 ;1991
0002e4  fb012103          MLA      r1,r1,r3,r2           ;1991
0002e8  eb010180          ADD      r1,r1,r0,LSL #2       ;1991
0002ec  9b2c              LDR      r3,[sp,#0xb0]         ;1991
0002ee  ed910a00          VLDR     s0,[r1,#0]            ;1991
0002f2  9a2e              LDR      r2,[sp,#0xb8]         ;1991
0002f4  2100              MOVS     r1,#0                 ;1991
0002f6  fb012103          MLA      r1,r1,r3,r2           ;1991
0002fa  eb010180          ADD      r1,r1,r0,LSL #2       ;1991
0002fe  9b31              LDR      r3,[sp,#0xc4]         ;1991
000300  edd10a00          VLDR     s1,[r1,#0]            ;1991
000304  9a33              LDR      r2,[sp,#0xcc]         ;1991
000306  2100              MOVS     r1,#0                 ;1991
000308  fb012103          MLA      r1,r1,r3,r2           ;1991
00030c  eb010180          ADD      r1,r1,r0,LSL #2       ;1991
000310  ee300a20          VADD.F32 s0,s0,s1              ;1991
000314  edd10a00          VLDR     s1,[r1,#0]            ;1991
000318  9b36              LDR      r3,[sp,#0xd8]         ;1991
00031a  9a38              LDR      r2,[sp,#0xe0]         ;1991
00031c  2100              MOVS     r1,#0                 ;1991
00031e  fb012103          MLA      r1,r1,r3,r2           ;1991
000322  eb010180          ADD      r1,r1,r0,LSL #2       ;1991
000326  ee300a20          VADD.F32 s0,s0,s1              ;1991
00032a  edd10a00          VLDR     s1,[r1,#0]            ;1991
00032e  9b0e              LDR      r3,[sp,#0x38]         ;1991
000330  9a10              LDR      r2,[sp,#0x40]         ;1991
000332  2100              MOVS     r1,#0                 ;1991
000334  fb012103          MLA      r1,r1,r3,r2           ;1991
000338  ee300a20          VADD.F32 s0,s0,s1              ;1991
00033c  eb010180          ADD      r1,r1,r0,LSL #2       ;1991
000340  1c40              ADDS     r0,r0,#1              ;1986
000342  ed810a00          VSTR     s0,[r1,#0]            ;1991
000346  2808              CMP      r0,#8                 ;1986
000348  db97              BLT      |L15.634|
00034a  2100              MOVS     r1,#0                 ;1994
00034c  a807              ADD      r0,sp,#0x1c           ;1994
00034e  f7fffffe          BL       _ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b ; Anki::Embedded::Matrix::MakeSymmetric<Anki::Embedded::Array<float>>(T1&, bool)
000352  ab39              ADD      r3,sp,#0xe4           ;1999
000354  2200              MOVS     r2,#0                 ;1999
000356  a90c              ADD      r1,sp,#0x30           ;1999
000358  a807              ADD      r0,sp,#0x1c           ;1999
00035a  f7fffffe          BL       _ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)
00035e  0004              MOVS     r4,r0                 ;1999
000360  d00d              BEQ      |L15.894|
000362  f24070d3          MOV      r0,#0x7d3             ;2003
000366  e9cd6000          STRD     r6,r0,[sp,#0]         ;2003
00036a  a339              ADR      r3,|L15.1104|
00036c  a279              ADR      r2,|L15.1364|
00036e  a14e              ADR      r1,|L15.1192|
000370  2005              MOVS     r0,#5                 ;2003
000372  f7fffffe          BL       _Anki_Log
000376  b046              ADD      sp,sp,#0x118
000378  4620              MOV      r0,r4                 ;2003
00037a  e8bd87f0          POP      {r4-r10,pc}
                  |L15.894|
00037e  f89d00e4          LDRB     r0,[sp,#0xe4]         ;2006
000382  2800              CMP      r0,#0                 ;2006
000384  f04f0000          MOV      r0,#0                 ;2011
000388  bf1c              ITT      NE
00038a  b046              ADDNE    sp,sp,#0x118
00038c  e8bd87f0          POPNE    {r4-r10,pc}
000390  9a0e              LDR      r2,[sp,#0x38]
000392  9910              LDR      r1,[sp,#0x40]
000394  9b04              LDR      r3,[sp,#0x10]
000396  fb001002          MLA      r0,r0,r2,r1
00039a  9a06              LDR      r2,[sp,#0x18]
00039c  2100              MOVS     r1,#0                 ;2013
00039e  fb012103          MLA      r1,r1,r3,r2           ;2013
0003a2  ed900a00          VLDR     s0,[r0,#0]            ;2013
0003a6  ed810a00          VSTR     s0,[r1,#0]            ;2013
0003aa  9b04              LDR      r3,[sp,#0x10]         ;2013
0003ac  9a06              LDR      r2,[sp,#0x18]         ;2013
0003ae  2100              MOVS     r1,#0                 ;2013
0003b0  fb012103          MLA      r1,r1,r3,r2           ;2013
0003b4  ed900a01          VLDR     s0,[r0,#4]            ;2013
0003b8  ed810a01          VSTR     s0,[r1,#4]            ;2013
0003bc  9b04              LDR      r3,[sp,#0x10]         ;2013
0003be  9a06              LDR      r2,[sp,#0x18]         ;2013
0003c0  2100              MOVS     r1,#0                 ;2013
0003c2  fb012103          MLA      r1,r1,r3,r2           ;2013
0003c6  ed900a02          VLDR     s0,[r0,#8]            ;2013
0003ca  ed810a02          VSTR     s0,[r1,#8]            ;2013
0003ce  9b04              LDR      r3,[sp,#0x10]         ;2013
0003d0  9a06              LDR      r2,[sp,#0x18]         ;2013
0003d2  2101              MOVS     r1,#1                 ;2014
0003d4  fb012103          MLA      r1,r1,r3,r2           ;2014
0003d8  ed900a03          VLDR     s0,[r0,#0xc]          ;2014
0003dc  ed810a00          VSTR     s0,[r1,#0]            ;2014
0003e0  9b04              LDR      r3,[sp,#0x10]         ;2014
0003e2  9a06              LDR      r2,[sp,#0x18]         ;2014
0003e4  2101              MOVS     r1,#1                 ;2014
0003e6  fb012103          MLA      r1,r1,r3,r2           ;2014
0003ea  ed900a04          VLDR     s0,[r0,#0x10]         ;2014
0003ee  ed810a01          VSTR     s0,[r1,#4]            ;2014
0003f2  9b04              LDR      r3,[sp,#0x10]         ;2014
0003f4  9a06              LDR      r2,[sp,#0x18]         ;2014
0003f6  2101              MOVS     r1,#1                 ;2014
0003f8  fb012103          MLA      r1,r1,r3,r2           ;2014
0003fc  ed900a05          VLDR     s0,[r0,#0x14]         ;2014
000400  ed810a02          VSTR     s0,[r1,#8]            ;2014
000404  9b04              LDR      r3,[sp,#0x10]         ;2014
000406  9a06              LDR      r2,[sp,#0x18]         ;2014
000408  2102              MOVS     r1,#2                 ;2015
00040a  fb012103          MLA      r1,r1,r3,r2           ;2015
00040e  ed900a06          VLDR     s0,[r0,#0x18]         ;2015
000412  ed810a00          VSTR     s0,[r1,#0]            ;2015
000416  9b04              LDR      r3,[sp,#0x10]         ;2015
000418  9a06              LDR      r2,[sp,#0x18]         ;2015
00041a  2102              MOVS     r1,#2                 ;2015
00041c  fb012103          MLA      r1,r1,r3,r2           ;2015
000420  ed900a07          VLDR     s0,[r0,#0x1c]         ;2015
000424  2002              MOVS     r0,#2                 ;2015
000426  ed810a01          VSTR     s0,[r1,#4]            ;2015
00042a  9a04              LDR      r2,[sp,#0x10]         ;2015
00042c  9906              LDR      r1,[sp,#0x18]         ;2015
00042e  eeb70a00          VMOV.F32 s0,#1.00000000        ;2015
000432  fb001002          MLA      r0,r0,r2,r1           ;2015
000436  a902              ADD      r1,sp,#8              ;2019
000438  ed800a02          VSTR     s0,[r0,#8]            ;2015
00043c  f50570a8          ADD      r0,r5,#0x150          ;2019
000440  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3214set_homographyERKNS0_5ArrayIfEE ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_homography(const Anki::Embedded::Array<float>&)
000444  b046              ADD      sp,sp,#0x118
000446  2000              MOVS     r0,#0                 ;2022
000448  e8bd87f0          POP      {r4-r10,pc}
;;;2024   
                          ENDP

                  |L15.1100|
                          DCD      ||.constdata||+0x445
                  |L15.1104|
000450  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\binaryTracker.cpp",0
000454  6f726574
000458  6563685c
00045c  76697369
000460  6f6e5c72
000464  6f626f74
000468  5c737263
00046c  5c62696e
000470  61727954
000474  7261636b
000478  65722e63
00047c  707000  
00047f  00                DCB      0
                  |L15.1152|
000480  46696e64          DCB      "FindHorizontalCorrespondences 1 failed",0
000484  486f7269
000488  7a6f6e74
00048c  616c436f
000490  72726573
000494  706f6e64
000498  656e6365
00049c  73203120
0004a0  6661696c
0004a4  656400  
0004a7  00                DCB      0
                  |L15.1192|
0004a8  42696e61          DCB      "BinaryTracker::IterativelyRefineTrack_Projective",0
0004ac  72795472
0004b0  61636b65
0004b4  723a3a49
0004b8  74657261
0004bc  74697665
0004c0  6c795265
0004c4  66696e65
0004c8  54726163
0004cc  6b5f5072
0004d0  6f6a6563
0004d4  74697665
0004d8  00      
0004d9  00                DCB      0
0004da  00                DCB      0
0004db  00                DCB      0
                  |L15.1244|
0004dc  46696e64          DCB      "FindHorizontalCorrespondences 2 failed",0
0004e0  486f7269
0004e4  7a6f6e74
0004e8  616c436f
0004ec  72726573
0004f0  706f6e64
0004f4  656e6365
0004f8  73203220
0004fc  6661696c
000500  656400  
000503  00                DCB      0
                  |L15.1284|
000504  46696e64          DCB      "FindVerticalCorrespondences 1 failed",0
000508  56657274
00050c  6963616c
000510  436f7272
000514  6573706f
000518  6e64656e
00051c  63657320
000520  31206661
000524  696c6564
000528  00      
000529  00                DCB      0
00052a  00                DCB      0
00052b  00                DCB      0
                  |L15.1324|
00052c  46696e64          DCB      "FindVerticalCorrespondences 2 failed",0
000530  56657274
000534  6963616c
000538  436f7272
00053c  6573706f
000540  6e64656e
000544  63657320
000548  32206661
00054c  696c6564
000550  00      
000551  00                DCB      0
000552  00                DCB      0
000553  00                DCB      0
                  |L15.1364|
000554  536f6c76          DCB      "SolveLeastSquaresWithCholesky failed",0
000558  654c6561
00055c  73745371
000560  75617265
000564  73576974
000568  6843686f
00056c  6c65736b
000570  79206661
000574  696c6564
000578  00      
000579  00                DCB      0
00057a  00                DCB      0
00057b  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindHorizontalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindHorizontalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_List(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&)
                  |symbol_number.439|
;;;1540         // Note: Clears the list matchingIndexes before starting
;;;1541         NO_INLINE Result BinaryTracker::FindHorizontalCorrespondences_List(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1542           const s32 maxMatchingDistance,
;;;1543           const Transformations::PlanarTransformation_f32 &transformation,
;;;1544           const FixedLengthList<Point<s16> > &templatePoints,
;;;1545           const FixedLengthList<Point<s16> > &newPoints,
;;;1546           const s32 imageHeight,
;;;1547           const s32 imageWidth,
;;;1548           const Array<s32> &yStartIndexes, //< Computed by ComputeIndexLimitsVertical
;;;1549           FixedLengthList<IndexCorrespondence> &matchingIndexes)
;;;1550         {
000004  4617              MOV      r7,r2
000006  ed2d8b0e          VPUSH    {d8-d14}
00000a  b085              SUB      sp,sp,#0x14
00000c  461e              MOV      r6,r3
00000e  4688              MOV      r8,r1
;;;1551           const s32 numTemplatePoints = templatePoints.get_size();
;;;1552           //const s32 numNewPoints = newPoints.get_size();
;;;1553   
;;;1554           const Array<f32> &homography = transformation.get_homography();
000010  4608              MOV      r0,r1
000012  68d2              LDR      r2,[r2,#0xc]
000014  9d22              LDR      r5,[sp,#0x88]
000016  9202              STR      r2,[sp,#8]
000018  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
00001c  4604              MOV      r4,r0
;;;1555           const Point<f32> &centerOffset = transformation.get_centerOffset(1.0f);
00001e  eeb70a00          VMOV.F32 s0,#1.00000000
000022  4641              MOV      r1,r8
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
00002a  68a2              LDR      r2,[r4,#8]
00002c  6921              LDR      r1,[r4,#0x10]
;;;1556   
;;;1557           const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2];
00002e  2000              MOVS     r0,#0
000030  fb001002          MLA      r0,r0,r2,r1
000034  46e8              MOV      r8,sp                 ;1555
000036  edd0da00          VLDR     s27,[r0,#0]
00003a  ed90da01          VLDR     s26,[r0,#4]
00003e  edd0ca02          VLDR     s25,[r0,#8]
;;;1558           const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2];
000042  2001              MOVS     r0,#1
000044  fb001002          MLA      r0,r0,r2,r1
;;;1559           const f32 h20 = homography[2][0]; const f32 h21 = homography[2][1]; const f32 h22 = 1.0f;
000048  eeb7ea00          VMOV.F32 s28,#1.00000000
00004c  ed90ca00          VLDR     s24,[r0,#0]           ;1558
000050  edd0ba01          VLDR     s23,[r0,#4]           ;1558
000054  ed90ba02          VLDR     s22,[r0,#8]           ;1558
000058  2002              MOVS     r0,#2
00005a  fb001002          MLA      r0,r0,r2,r1
;;;1560   
;;;1561           AnkiAssert(FLT_NEAR(homography[2][2], 1.0f));
;;;1562   
;;;1563           IndexCorrespondence * restrict pMatchingIndexes = matchingIndexes.Pointer(0);
;;;1564           s32 numMatchingIndexes = 0;
00005e  2400              MOVS     r4,#0
000060  edd0aa00          VLDR     s21,[r0,#0]           ;1559
000064  ed90aa01          VLDR     s20,[r0,#4]           ;1559
000068  9823              LDR      r0,[sp,#0x8c]         ;1559
;;;1565           const s32 maxMatchingIndexes = matchingIndexes.get_maximumSize();
00006a  f8d0b030          LDR      r11,[r0,#0x30]
00006e  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::get_maximumSize() const
000072  68ab              LDR      r3,[r5,#8]
000074  692a              LDR      r2,[r5,#0x10]
;;;1566   
;;;1567           const Point<s16> * restrict pTemplatePoints = templatePoints.Pointer(0);
;;;1568           const Point<s16> * restrict pNewPoints = newPoints.Pointer(0);
;;;1569           const s32 * restrict pYStartIndexes = yStartIndexes.Pointer(0,0);
000076  2100              MOVS     r1,#0
000078  fb012903          MLA      r9,r1,r3,r2
;;;1570   
;;;1571           for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++) {
00007c  9a02              LDR      r2,[sp,#8]
00007e  f8d7a030          LDR      r10,[r7,#0x30]
000082  6b36              LDR      r6,[r6,#0x30]
000084  460d              MOV      r5,r1
000086  2a00              CMP      r2,#0
;;;1572             const f32 xr = static_cast<f32>(pTemplatePoints[iPoint].x);
;;;1573             const f32 yr = static_cast<f32>(pTemplatePoints[iPoint].y);
;;;1574   
;;;1575             //
;;;1576             // Warp x and y based on the current homography
;;;1577             //
;;;1578   
;;;1579             // Subtract the center offset
;;;1580             const f32 xc = xr - centerOffset.x;
;;;1581             const f32 yc = yr - centerOffset.y;
;;;1582   
;;;1583             // Projective warp
;;;1584             const f32 wpi = 1.0f / (h20*xc + h21*yc + h22);
;;;1585             const f32 warpedX = (h00*xc + h01*yc + h02) * wpi;
;;;1586             const f32 warpedY = (h10*xc + h11*yc + h12) * wpi;
;;;1587   
;;;1588             // TODO: verify the -0.5f is correct
;;;1589             const s32 warpedXrounded = RoundS32_minusPointFive(warpedX + centerOffset.x);
;;;1590             const s32 warpedYrounded = RoundS32_minusPointFive(warpedY + centerOffset.y);
;;;1591   
;;;1592             if(warpedYrounded >= 0 && warpedYrounded < imageHeight) {
;;;1593               const s32 minX = warpedXrounded - maxMatchingDistance;
;;;1594               const s32 maxX = warpedXrounded + maxMatchingDistance;
;;;1595   
;;;1596               s32 curIndex = pYStartIndexes[warpedYrounded];
;;;1597               const s32 endIndex = pYStartIndexes[warpedYrounded+1];
;;;1598   
;;;1599               // Find the start of the valid matches
;;;1600               while( (curIndex<endIndex) && (pNewPoints[curIndex].x<minX) ) {
;;;1601                 curIndex++;
;;;1602               }
;;;1603   
;;;1604               // For every valid match, increment the sum and counter
;;;1605               while( (curIndex<endIndex) && (pNewPoints[curIndex].x<=maxX) ) {
;;;1606                 if(numMatchingIndexes < (maxMatchingIndexes-1)) {
000088  bfc4              ITT      GT
00008a  1e40              SUBGT    r0,r0,#1
00008c  9003              STRGT    r0,[sp,#0xc]
00008e  dd6f              BLE      |L16.368|
                  |L16.144|
000090  f93a0025          LDRSH    r0,[r10,r5,LSL #2]    ;1572
000094  edd80a00          VLDR     s1,[r8,#0]            ;1580
000098  ee000a10          VMOV     s0,r0                 ;1572
00009c  eb0a0085          ADD      r0,r10,r5,LSL #2      ;1573
0000a0  eeb81ac0          VCVT.F32.S32 s2,s0                 ;1572
0000a4  f9b00002          LDRSH    r0,[r0,#2]            ;1573
0000a8  ee000a10          VMOV     s0,r0                 ;1573
0000ac  ee718a60          VSUB.F32 s17,s2,s1             ;1580
0000b0  ed981a01          VLDR     s2,[r8,#4]            ;1581
0000b4  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1573
0000b8  ee308a41          VSUB.F32 s16,s0,s2             ;1581
0000bc  ee2a0aa8          VMUL.F32 s0,s21,s17            ;1584
0000c0  ee0a0a08          VMLA.F32 s0,s20,s16            ;1584
0000c4  ee301a0e          VADD.F32 s2,s0,s28             ;1584
0000c8  ee8e0a01          VDIV.F32 s0,s28,s2             ;1584
0000cc  ee2d1aa8          VMUL.F32 s2,s27,s17            ;1585
0000d0  ee0d1a08          VMLA.F32 s2,s26,s16            ;1585
0000d4  ee311a2c          VADD.F32 s2,s2,s25             ;1585
0000d8  ee619a00          VMUL.F32 s19,s2,s0             ;1585
0000dc  ee2c1a28          VMUL.F32 s2,s24,s17            ;1586
0000e0  ee0b1a88          VMLA.F32 s2,s23,s16            ;1586
0000e4  ee311a0b          VADD.F32 s2,s2,s22             ;1586
0000e8  ee219a00          VMUL.F32 s18,s2,s0             ;1586
0000ec  ee300aa9          VADD.F32 s0,s1,s19             ;1589
0000f0  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
0000f4  ed980a01          VLDR     s0,[r8,#4]            ;1590
0000f8  4607              MOV      r7,r0                 ;1589
0000fa  ee300a09          VADD.F32 s0,s0,s18             ;1590
0000fe  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
000102  1e01              SUBS     r1,r0,#0              ;1590
000104  bfa4              ITT      GE                    ;1592
000106  9820              LDRGE    r0,[sp,#0x80]         ;1592
000108  4288              CMPGE    r0,r1                 ;1592
00010a  dd2d              BLE      |L16.360|
00010c  9813              LDR      r0,[sp,#0x4c]         ;1593
00010e  eba70c00          SUB      r12,r7,r0             ;1593
000112  183b              ADDS     r3,r7,r0              ;1594
000114  f8590021          LDR      r0,[r9,r1,LSL #2]     ;1596
000118  eb090181          ADD      r1,r9,r1,LSL #2       ;1597
00011c  684a              LDR      r2,[r1,#4]            ;1597
                  |L16.286|
00011e  4290              CMP      r0,r2                 ;1600
000120  bfbe              ITTT     LT                    ;1600
000122  f9361020          LDRSHLT  r1,[r6,r0,LSL #2]     ;1600
000126  4561              CMPLT    r1,r12                ;1600
000128  1c40              ADDLT    r0,r0,#1              ;1601
00012a  dbf8              BLT      |L16.286|
00012c  e016              B        |L16.348|
                  |L16.302|
00012e  f8ddc00c          LDR      r12,[sp,#0xc]
000132  45a4              CMP      r12,r4
000134  dd11              BLE      |L16.346|
;;;1607                   const s32 offset = pNewPoints[curIndex].x - warpedXrounded;
000136  1bc9              SUBS     r1,r1,r7
;;;1608                   const f32 xp = warpedX + static_cast<f32>(offset);
000138  ee001a10          VMOV     s0,r1
;;;1609   
;;;1610                   //pMatchingIndexes[numMatchingIndexes].templateIndex = iPoint;
;;;1611                   //pMatchingIndexes[numMatchingIndexes].matchedIndex = curIndex;
;;;1612   
;;;1613                   pMatchingIndexes[numMatchingIndexes].templatePoint.x = xc;
00013c  eb0b1104          ADD      r1,r11,r4,LSL #4
;;;1614                   pMatchingIndexes[numMatchingIndexes].templatePoint.y = yc;
;;;1615                   pMatchingIndexes[numMatchingIndexes].matchedPoint.x = xp;
;;;1616                   pMatchingIndexes[numMatchingIndexes].matchedPoint.y = warpedY;
;;;1617   
;;;1618                   numMatchingIndexes++;
000140  1c64              ADDS     r4,r4,#1
000142  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1608
000146  edc18a00          VSTR     s17,[r1,#0]           ;1613
00014a  ed818a01          VSTR     s16,[r1,#4]           ;1614
00014e  ee390a80          VADD.F32 s0,s19,s0             ;1608
000152  ed810a02          VSTR     s0,[r1,#8]            ;1615
000156  ed819a03          VSTR     s18,[r1,#0xc]         ;1616
                  |L16.346|
;;;1619                 }
;;;1620   
;;;1621                 curIndex++;
00015a  1c40              ADDS     r0,r0,#1
                  |L16.348|
00015c  4290              CMP      r0,r2                 ;1605
00015e  da03              BGE      |L16.360|
000160  f9361020          LDRSH    r1,[r6,r0,LSL #2]     ;1605
000164  428b              CMP      r3,r1                 ;1605
000166  dae2              BGE      |L16.302|
                  |L16.360|
000168  9802              LDR      r0,[sp,#8]            ;1571
00016a  1c6d              ADDS     r5,r5,#1              ;1571
00016c  4285              CMP      r5,r0                 ;1571
00016e  db8f              BLT      |L16.144|
                  |L16.368|
;;;1622               }
;;;1623             } // if(warpedYrounded >= 0 && warpedYrounded < imageHeight)
;;;1624           } // for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++)
;;;1625   
;;;1626           matchingIndexes.set_size(numMatchingIndexes);
000170  4621              MOV      r1,r4
000172  9823              LDR      r0,[sp,#0x8c]
000174  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::set_size(int)
;;;1627   
;;;1628           return RESULT_OK;
;;;1629         }
000178  b005              ADD      sp,sp,#0x14
00017a  2000              MOVS     r0,#0                 ;1628
00017c  ecbd8b0e          VPOP     {d8-d14}
000180  b004              ADD      sp,sp,#0x10
000182  e8bd8ff0          POP      {r4-r11,pc}
;;;1630   
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindVerticalCorrespondences_VerifyEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERi||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindVerticalCorrespondences_VerifyEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERi PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_Verify(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, int&)
                  |symbol_number.440|
;;;1302   
;;;1303         NO_INLINE Result BinaryTracker::FindVerticalCorrespondences_Verify(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1304           const s32 maxMatchingDistance,
;;;1305           const Transformations::PlanarTransformation_f32 &transformation,
;;;1306           const FixedLengthList<Point<s16> > &templatePoints,
;;;1307           const FixedLengthList<Point<s16> > &newPoints,
;;;1308           const s32 imageHeight,
;;;1309           const s32 imageWidth,
;;;1310           const Array<s32> &xStartIndexes, //< Computed by ComputeIndexLimitsHorizontal
;;;1311           s32 &numTemplatePixelsMatched)
;;;1312         {
000004  4682              MOV      r10,r0
000006  ed2d8b0c          VPUSH    {d8-d13}
00000a  b083              SUB      sp,sp,#0xc
00000c  461d              MOV      r5,r3
00000e  4616              MOV      r6,r2
000010  460f              MOV      r7,r1
;;;1313           const s32 numTemplatePoints = templatePoints.get_size();
;;;1314           //const s32 numNewPoints = newPoints.get_size();
;;;1315   
;;;1316           const Array<f32> &homography = transformation.get_homography();
000012  4608              MOV      r0,r1
000014  9c1a              LDR      r4,[sp,#0x68]
000016  f8d2b00c          LDR      r11,[r2,#0xc]
00001a  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
00001e  4680              MOV      r8,r0
;;;1317           const Point<f32> &centerOffset = transformation.get_centerOffset(1.0f);
000020  eeb70a00          VMOV.F32 s0,#1.00000000
000024  4639              MOV      r1,r7
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
00002c  f8d82008          LDR      r2,[r8,#8]
000030  f8d81010          LDR      r1,[r8,#0x10]
;;;1318   
;;;1319           // TODO: if the homography is just translation, we can do this faster (just slightly, as most of the cost is the search)
;;;1320           const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2];
000034  2000              MOVS     r0,#0
000036  fb001002          MLA      r0,r0,r2,r1
00003a  466f              MOV      r7,sp                 ;1317
00003c  ed90da00          VLDR     s26,[r0,#0]
000040  edd0ca01          VLDR     s25,[r0,#4]
000044  ed90ca02          VLDR     s24,[r0,#8]
;;;1321           const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2];
000048  2001              MOVS     r0,#1
00004a  fb001002          MLA      r0,r0,r2,r1
;;;1322           const f32 h20 = homography[2][0]; const f32 h21 = homography[2][1]; const f32 h22 = 1.0f;
00004e  eeb79a00          VMOV.F32 s18,#1.00000000
000052  edd0ba00          VLDR     s23,[r0,#0]           ;1321
000056  ed90ba01          VLDR     s22,[r0,#4]           ;1321
00005a  edd0aa02          VLDR     s21,[r0,#8]           ;1321
00005e  2002              MOVS     r0,#2
000060  fb001002          MLA      r0,r0,r2,r1
000064  ed90aa00          VLDR     s20,[r0,#0]
000068  edd09a01          VLDR     s19,[r0,#4]
;;;1323   
;;;1324           AnkiAssert(FLT_NEAR(homography[2][2], 1.0f));
;;;1325   
;;;1326           f32 numTemplatePixelsMatchedF32 = 0.0f;
00006c  ed9f8a40          VLDR     s16,|L17.368|
;;;1327   
;;;1328           const Point<s16> * restrict pTemplatePoints = templatePoints.Pointer(0);
;;;1329           const Point<s16> * restrict pNewPoints = newPoints.Pointer(0);
;;;1330           const s32 * restrict pXStartIndexes = xStartIndexes.Pointer(0,0);
000070  2000              MOVS     r0,#0
000072  68a2              LDR      r2,[r4,#8]
000074  6921              LDR      r1,[r4,#0x10]
000076  f8d69030          LDR      r9,[r6,#0x30]
00007a  6b2e              LDR      r6,[r5,#0x30]
00007c  fb001802          MLA      r8,r0,r2,r1
;;;1331   
;;;1332           for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++) {
000080  4604              MOV      r4,r0
000082  f1bb0f00          CMP      r11,#0
000086  dd5d              BLE      |L17.324|
                  |L17.136|
;;;1333             const f32 xr = static_cast<f32>(pTemplatePoints[iPoint].x);
000088  f9390024          LDRSH    r0,[r9,r4,LSL #2]
;;;1334             const f32 yr = static_cast<f32>(pTemplatePoints[iPoint].y);
;;;1335   
;;;1336             //
;;;1337             // Warp x and y based on the current homography
;;;1338             //
;;;1339   
;;;1340             // Subtract the center offset
;;;1341             const f32 xc = xr - centerOffset.x;
00008c  edd71a00          VLDR     s3,[r7,#0]
000090  ee000a10          VMOV     s0,r0                 ;1333
000094  eb090084          ADD      r0,r9,r4,LSL #2       ;1334
;;;1342             const f32 yc = yr - centerOffset.y;
000098  ed971a01          VLDR     s2,[r7,#4]
00009c  f9b00002          LDRSH    r0,[r0,#2]            ;1334
0000a0  eef80ac0          VCVT.F32.S32 s1,s0                 ;1333
0000a4  ee000a10          VMOV     s0,r0                 ;1334
0000a8  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1334
0000ac  ee700ae1          VSUB.F32 s1,s1,s3              ;1341
0000b0  ee300a41          VSUB.F32 s0,s0,s2
;;;1343   
;;;1344             // Projective warp
;;;1345             const f32 wpi = 1.0f / (h20*xc + h21*yc + h22);
0000b4  ee2a1a20          VMUL.F32 s2,s20,s1
0000b8  ee091a80          VMLA.F32 s2,s19,s0
0000bc  ee312a09          VADD.F32 s4,s2,s18
0000c0  ee891a02          VDIV.F32 s2,s18,s4
;;;1346             const f32 warpedX = (h00*xc + h01*yc + h02) * wpi;
0000c4  ee2d2a20          VMUL.F32 s4,s26,s1
;;;1347             const f32 warpedY = (h10*xc + h11*yc + h12) * wpi;
0000c8  ee6b0aa0          VMUL.F32 s1,s23,s1
0000cc  ee0c2a80          VMLA.F32 s4,s25,s0             ;1346
0000d0  ee4b0a00          VMLA.F32 s1,s22,s0
0000d4  ee322a0c          VADD.F32 s4,s4,s24             ;1346
0000d8  ee300aaa          VADD.F32 s0,s1,s21
0000dc  ee222a01          VMUL.F32 s4,s4,s2              ;1346
0000e0  ee608a01          VMUL.F32 s17,s0,s2
;;;1348   
;;;1349             // TODO: verify the -0.5f is correct
;;;1350             const s32 warpedXrounded = RoundS32_minusPointFive(warpedX + centerOffset.x);
0000e4  ee310a82          VADD.F32 s0,s3,s4
0000e8  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
;;;1351             const s32 warpedYrounded = RoundS32_minusPointFive(warpedY + centerOffset.y);
0000ec  ed970a01          VLDR     s0,[r7,#4]
0000f0  4605              MOV      r5,r0                 ;1350
0000f2  ee300a28          VADD.F32 s0,s0,s17
0000f6  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
;;;1352   
;;;1353             if(warpedXrounded >= 0 && warpedXrounded < imageWidth) {
0000fa  2d00              CMP      r5,#0
0000fc  bfa4              ITT      GE
0000fe  9919              LDRGE    r1,[sp,#0x64]
000100  42a9              CMPGE    r1,r5
000102  dd1c              BLE      |L17.318|
;;;1354               const s32 minY = warpedYrounded - maxMatchingDistance;
;;;1355               const s32 maxY = warpedYrounded + maxMatchingDistance;
;;;1356   
;;;1357               s32 curIndex = pXStartIndexes[warpedXrounded];
;;;1358               const s32 endIndex = pXStartIndexes[warpedXrounded+1];
000104  eb080185          ADD      r1,r8,r5,LSL #2
000108  eba0020a          SUB      r2,r0,r10             ;1354
00010c  eb00030a          ADD      r3,r0,r10             ;1355
000110  f8580025          LDR      r0,[r8,r5,LSL #2]     ;1357
000114  6849              LDR      r1,[r1,#4]
                  |L17.278|
;;;1359   
;;;1360               // Find the start of the valid matches
;;;1361               while( (curIndex<endIndex) && (pNewPoints[curIndex].y<minY) ) {
000116  4288              CMP      r0,r1
000118  da07              BGE      |L17.298|
00011a  eb060c80          ADD      r12,r6,r0,LSL #2
00011e  f9bcc002          LDRSH    r12,[r12,#2]
000122  4594              CMP      r12,r2
;;;1362                 curIndex++;
000124  bfb8              IT       LT
000126  1c40              ADDLT    r0,r0,#1
000128  dbf5              BLT      |L17.278|
                  |L17.298|
;;;1363               }
;;;1364   
;;;1365               // If there is a valid match, increment numTemplatePixelsMatchedF32
;;;1366               if( (curIndex<endIndex) && (pNewPoints[curIndex].y<=maxY) ) {
00012a  4288              CMP      r0,r1
00012c  da07              BGE      |L17.318|
00012e  eb060080          ADD      r0,r6,r0,LSL #2
000132  f9b00002          LDRSH    r0,[r0,#2]
000136  4283              CMP      r3,r0
;;;1367                 numTemplatePixelsMatchedF32 += 1.0f;
000138  bfa8              IT       GE
00013a  ee388a09          VADDGE.F32 s16,s16,s18
                  |L17.318|
00013e  1c64              ADDS     r4,r4,#1              ;1332
000140  455c              CMP      r4,r11                ;1332
000142  dba1              BLT      |L17.136|
                  |L17.324|
000144  eeb58ac0          VCMPE.F32 s16,#0.0              ;1332
000148  eeb60a00          VMOV.F32 s0,#0.50000000        ;1332
00014c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1332
000150  bfcc              ITE      GT                    ;1332
000152  ee380a00          VADDGT.F32 s0,s16,s0             ;1332
000156  ee380a40          VSUBLE.F32 s0,s16,s0             ;1332
00015a  eebd0ac0          VCVT.S32.F32 s0,s0                 ;1332
;;;1368               }
;;;1369             } // if(warpedXrounded >= 0 && warpedXrounded < imageWidth)
;;;1370           } // for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++)
;;;1371   
;;;1372           numTemplatePixelsMatched = Round<s32>(numTemplatePixelsMatchedF32);
00015e  981b              LDR      r0,[sp,#0x6c]
000160  ed800a00          VSTR     s0,[r0,#0]
;;;1373   
;;;1374           return RESULT_OK;
;;;1375         }
000164  b003              ADD      sp,sp,#0xc
000166  2000              MOVS     r0,#0                 ;1374
000168  ecbd8b0c          VPOP     {d8-d13}
00016c  e8bd8ff0          POP      {r4-r11,pc}
;;;1376   
                          ENDP

                  |L17.368|
000170  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker34IterativelyRefineTrack_TranslationERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker34IterativelyRefineTrack_TranslationERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiNS0_11MemoryStackE PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::IterativelyRefineTrack_Translation(const Anki::Embedded::EdgeLists&, const Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, int, Anki::Embedded::MemoryStack)
;;;1829   
;;;1830         Result BinaryTracker::IterativelyRefineTrack_Translation(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1831           const EdgeLists &nextImageEdges,
;;;1832           const AllIndexLimits &allLimits,
;;;1833           const s32 matching_maxDistance,
;;;1834           MemoryStack scratch)
;;;1835         {
000004  b096              SUB      sp,sp,#0x58
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  4605              MOV      r5,r0
;;;1836           Result lastResult;
;;;1837   
;;;1838           s32 sumX_xDecreasing;
;;;1839           s32 sumX_xIncreasing;
;;;1840           s32 sumY_yDecreasing;
;;;1841           s32 sumY_yIncreasing;
;;;1842   
;;;1843           s32 numX_xDecreasing;
;;;1844           s32 numX_xIncreasing;
;;;1845           s32 numY_yDecreasing;
;;;1846           s32 numY_yIncreasing;
;;;1847   
;;;1848           lastResult = BinaryTracker::FindHorizontalCorrespondences_Translation(
00000c  f8dd9078          LDR      r9,[sp,#0x78]
000010  f8d400d4          LDR      r0,[r4,#0xd4]
000014  e9cd0601          STRD     r0,r6,[sp,#4]
000018  a911              ADD      r1,sp,#0x44
00001a  aa0e              ADD      r2,sp,#0x38
00001c  e9cd2103          STRD     r2,r1,[sp,#0xc]
000020  469a              MOV      r10,r3                ;1835
000022  f8d400d0          LDR      r0,[r4,#0xd0]
000026  9000              STR      r0,[sp,#0]
000028  4623              MOV      r3,r4
00002a  f1050274          ADD      r2,r5,#0x74
00002e  f50571a8          ADD      r1,r5,#0x150
000032  4650              MOV      r0,r10
000034  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker41FindHorizontalCorrespondences_TranslationEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERiSH_ ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_Translation(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, int&, int&)
;;;1849             matching_maxDistance,
;;;1850             this->transformation,
;;;1851             this->templateEdges.xDecreasing,
;;;1852             nextImageEdges.xDecreasing,
;;;1853             nextImageEdges.imageHeight,
;;;1854             nextImageEdges.imageWidth,
;;;1855             allLimits.xDecreasing_yStartIndexes,
;;;1856             sumX_xDecreasing, numX_xDecreasing);
;;;1857   
;;;1858           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
000038  4f6e              LDR      r7,|L18.500|
00003a  ea5f0800          MOVS     r8,r0                 ;1848
00003e  d00d              BEQ      |L18.92|
000040  f2407042          MOV      r0,#0x742
000044  e9cd7000          STRD     r7,r0,[sp,#0]
000048  a36b              ADR      r3,|L18.504|
00004a  a277              ADR      r2,|L18.552|
00004c  a180              ADR      r1,|L18.592|
00004e  2005              MOVS     r0,#5
000050  f7fffffe          BL       _Anki_Log
;;;1859             lastResult, "BinaryTracker::IterativelyRefineTrack_Translation", "FindHorizontalCorrespondences 1 failed");
;;;1860   
;;;1861           lastResult = BinaryTracker::FindHorizontalCorrespondences_Translation(
;;;1862             matching_maxDistance,
;;;1863             this->transformation,
;;;1864             this->templateEdges.xIncreasing,
;;;1865             nextImageEdges.xIncreasing,
;;;1866             nextImageEdges.imageHeight,
;;;1867             nextImageEdges.imageWidth,
;;;1868             allLimits.xIncreasing_yStartIndexes,
;;;1869             sumX_xIncreasing, numX_xIncreasing);
;;;1870   
;;;1871           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;1872             lastResult, "BinaryTracker::IterativelyRefineTrack_Translation", "FindHorizontalCorrespondences 2 failed");
;;;1873   
;;;1874           lastResult = BinaryTracker::FindVerticalCorrespondences_Translation(
;;;1875             matching_maxDistance,
;;;1876             this->transformation,
;;;1877             this->templateEdges.yDecreasing,
;;;1878             nextImageEdges.yDecreasing,
;;;1879             nextImageEdges.imageHeight,
;;;1880             nextImageEdges.imageWidth,
;;;1881             allLimits.yDecreasing_xStartIndexes,
;;;1882             sumY_yDecreasing, numY_yDecreasing);
;;;1883   
;;;1884           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;1885             lastResult, "BinaryTracker::IterativelyRefineTrack_Translation", "FindVerticalCorrespondences 1 failed");
;;;1886   
;;;1887           lastResult = BinaryTracker::FindVerticalCorrespondences_Translation(
;;;1888             matching_maxDistance,
;;;1889             this->transformation,
;;;1890             this->templateEdges.yIncreasing,
;;;1891             nextImageEdges.yIncreasing,
;;;1892             nextImageEdges.imageHeight,
;;;1893             nextImageEdges.imageWidth,
;;;1894             allLimits.yIncreasing_xStartIndexes,
;;;1895             sumY_yIncreasing, numY_yIncreasing);
;;;1896   
;;;1897           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;1898             lastResult, "BinaryTracker::IterativelyRefineTrack_Translation", "FindVerticalCorrespondences 2 failed");
;;;1899   
;;;1900           // Update the transformation
;;;1901           {
;;;1902             Array<f32> update(1,2,scratch);
;;;1903   
;;;1904             const s32 sumX = sumX_xDecreasing + sumX_xIncreasing;
;;;1905             const s32 numX = numX_xDecreasing + numX_xIncreasing;
;;;1906   
;;;1907             const s32 sumY = sumY_yDecreasing + sumY_yIncreasing;
;;;1908             const s32 numY = numY_yDecreasing + numY_yIncreasing;
;;;1909   
;;;1910             if(numX < 1 || numY < 1)
;;;1911               return RESULT_OK;
;;;1912   
;;;1913             update[0][0] = static_cast<f32>(-sumX) / static_cast<f32>(numX);
;;;1914             update[0][1] = static_cast<f32>(-sumY) / static_cast<f32>(numY);
;;;1915   
;;;1916             //update.Print("update");
;;;1917   
;;;1918             this->transformation.Update(update, 1.0f, scratch, Transformations::TRANSFORM_TRANSLATION);
;;;1919           }
;;;1920   
;;;1921           return RESULT_OK;
;;;1922         } // Result BinaryTracker::IterativelyRefineTrack_Translation()
000054  b016              ADD      sp,sp,#0x58
000056  4640              MOV      r0,r8                 ;1858
000058  e8bd87f0          POP      {r4-r10,pc}
                  |L18.92|
00005c  f10d0804          ADD      r8,sp,#4              ;1861
000060  f8d400d4          LDR      r0,[r4,#0xd4]         ;1861
000064  ab12              ADD      r3,sp,#0x48           ;1861
000066  aa0d              ADD      r2,sp,#0x34           ;1861
000068  f1060114          ADD      r1,r6,#0x14           ;1861
00006c  e8a8000f          STM      r8!,{r0-r3}           ;1861
000070  f8d400d0          LDR      r0,[r4,#0xd0]         ;1861
000074  9000              STR      r0,[sp,#0]            ;1861
000076  f1040334          ADD      r3,r4,#0x34           ;1861
00007a  f10502a8          ADD      r2,r5,#0xa8           ;1861
00007e  f50571a8          ADD      r1,r5,#0x150          ;1861
000082  4650              MOV      r0,r10                ;1861
000084  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker41FindHorizontalCorrespondences_TranslationEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERiSH_ ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_Translation(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, int&, int&)
000088  ea5f0800          MOVS     r8,r0                 ;1861
00008c  d00d              BEQ      |L18.170|
00008e  f240704f          MOV      r0,#0x74f             ;1871
000092  e9cd7000          STRD     r7,r0,[sp,#0]         ;1871
000096  a358              ADR      r3,|L18.504|
000098  a27a              ADR      r2,|L18.644|
00009a  a16d              ADR      r1,|L18.592|
00009c  2005              MOVS     r0,#5                 ;1871
00009e  f7fffffe          BL       _Anki_Log
0000a2  b016              ADD      sp,sp,#0x58
0000a4  4640              MOV      r0,r8                 ;1871
0000a6  e8bd87f0          POP      {r4-r10,pc}
                  |L18.170|
0000aa  f10d0804          ADD      r8,sp,#4              ;1874
0000ae  f8d400d4          LDR      r0,[r4,#0xd4]         ;1874
0000b2  ab13              ADD      r3,sp,#0x4c           ;1874
0000b4  aa0f              ADD      r2,sp,#0x3c           ;1874
0000b6  f1060128          ADD      r1,r6,#0x28           ;1874
0000ba  e8a8000f          STM      r8!,{r0-r3}           ;1874
0000be  f8d400d0          LDR      r0,[r4,#0xd0]         ;1874
0000c2  9000              STR      r0,[sp,#0]            ;1874
0000c4  f1040368          ADD      r3,r4,#0x68           ;1874
0000c8  f10502dc          ADD      r2,r5,#0xdc           ;1874
0000cc  f50571a8          ADD      r1,r5,#0x150          ;1874
0000d0  4650              MOV      r0,r10                ;1874
0000d2  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker39FindVerticalCorrespondences_TranslationEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERiSH_ ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_Translation(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, int&, int&)
0000d6  ea5f0800          MOVS     r8,r0                 ;1874
0000da  d00d              BEQ      |L18.248|
0000dc  f240705c          MOV      r0,#0x75c             ;1884
0000e0  e9cd7000          STRD     r7,r0,[sp,#0]         ;1884
0000e4  a344              ADR      r3,|L18.504|
0000e6  a271              ADR      r2,|L18.684|
0000e8  a159              ADR      r1,|L18.592|
0000ea  2005              MOVS     r0,#5                 ;1884
0000ec  f7fffffe          BL       _Anki_Log
0000f0  b016              ADD      sp,sp,#0x58
0000f2  4640              MOV      r0,r8                 ;1884
0000f4  e8bd87f0          POP      {r4-r10,pc}
                  |L18.248|
0000f8  f10d0804          ADD      r8,sp,#4              ;1887
0000fc  f8d400d4          LDR      r0,[r4,#0xd4]         ;1887
000100  ab14              ADD      r3,sp,#0x50           ;1887
000102  aa10              ADD      r2,sp,#0x40           ;1887
000104  f106013c          ADD      r1,r6,#0x3c           ;1887
000108  e8a8000f          STM      r8!,{r0-r3}           ;1887
00010c  f8d400d0          LDR      r0,[r4,#0xd0]         ;1887
000110  9000              STR      r0,[sp,#0]            ;1887
000112  f104039c          ADD      r3,r4,#0x9c           ;1887
000116  f5057288          ADD      r2,r5,#0x110          ;1887
00011a  f50571a8          ADD      r1,r5,#0x150          ;1887
00011e  4650              MOV      r0,r10                ;1887
000120  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker39FindVerticalCorrespondences_TranslationEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERiSH_ ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_Translation(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, int&, int&)
000124  0004              MOVS     r4,r0                 ;1887
000126  d00d              BEQ      |L18.324|
000128  f2407069          MOV      r0,#0x769             ;1897
00012c  e9cd7000          STRD     r7,r0,[sp,#0]         ;1897
000130  a331              ADR      r3,|L18.504|
000132  a268              ADR      r2,|L18.724|
000134  a146              ADR      r1,|L18.592|
000136  2005              MOVS     r0,#5                 ;1897
000138  f7fffffe          BL       _Anki_Log
00013c  b016              ADD      sp,sp,#0x58
00013e  4620              MOV      r0,r4                 ;1897
000140  e8bd87f0          POP      {r4-r10,pc}
                  |L18.324|
000144  2300              MOVS     r3,#0                 ;1902
000146  461a              MOV      r2,r3                 ;1902
000148  2101              MOVS     r1,#1                 ;1902
00014a  a815              ADD      r0,sp,#0x54           ;1902
00014c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000150  6800              LDR      r0,[r0,#0]            ;1902
000152  9000              STR      r0,[sp,#0]            ;1902
000154  464b              MOV      r3,r9                 ;1902
000156  2202              MOVS     r2,#2                 ;1902
000158  2101              MOVS     r1,#1                 ;1902
00015a  a801              ADD      r0,sp,#4              ;1902
00015c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000160  e9dd010d          LDRD     r0,r1,[sp,#0x34]      ;1902
000164  180b              ADDS     r3,r1,r0              ;1904
000166  e9dd0111          LDRD     r0,r1,[sp,#0x44]      ;1904
00016a  4401              ADD      r1,r1,r0              ;1905
00016c  e9dd020f          LDRD     r0,r2,[sp,#0x3c]      ;1905
000170  4402              ADD      r2,r2,r0              ;1907
000172  e9dd0c13          LDRD     r0,r12,[sp,#0x4c]     ;1907
000176  4460              ADD      r0,r0,r12             ;1908
000178  2901              CMP      r1,#1                 ;1910
00017a  bfaf              ITEEE    GE                    ;1910
00017c  2801              CMPGE    r0,#1                 ;1910
00017e  2000              MOVLT    r0,#0                 ;1911
000180  b016              ADDLT    sp,sp,#0x58
000182  e8bd87f0          POPLT    {r4-r10,pc}
000186  425b              RSBS     r3,r3,#0              ;1913
000188  ee003a10          VMOV     s0,r3                 ;1913
00018c  f8ddc00c          LDR      r12,[sp,#0xc]         ;1913
000190  9b05              LDR      r3,[sp,#0x14]         ;1913
000192  eef80ac0          VCVT.F32.S32 s1,s0                 ;1913
000196  ee001a10          VMOV     s0,r1                 ;1913
00019a  2100              MOVS     r1,#0                 ;1913
00019c  fb01310c          MLA      r1,r1,r12,r3          ;1913
0001a0  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1913
0001a4  ee801a80          VDIV.F32 s2,s1,s0              ;1913
0001a8  ed811a00          VSTR     s2,[r1,#0]            ;1913
0001ac  4251              RSBS     r1,r2,#0              ;1914
0001ae  ee001a10          VMOV     s0,r1                 ;1914
0001b2  9a03              LDR      r2,[sp,#0xc]          ;1914
0001b4  9905              LDR      r1,[sp,#0x14]         ;1914
0001b6  eef80ac0          VCVT.F32.S32 s1,s0                 ;1914
0001ba  ee000a10          VMOV     s0,r0                 ;1914
0001be  2000              MOVS     r0,#0                 ;1914
0001c0  fb001002          MLA      r0,r0,r2,r1           ;1914
0001c4  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1914
0001c8  4649              MOV      r1,r9                 ;1918
0001ca  ee801a80          VDIV.F32 s2,s1,s0              ;1914
0001ce  ed801a01          VSTR     s2,[r0,#4]            ;1914
0001d2  a806              ADD      r0,sp,#0x18           ;1918
0001d4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0001d8  4602              MOV      r2,r0                 ;1918
0001da  f44f7300          MOV      r3,#0x200             ;1918
0001de  eeb70a00          VMOV.F32 s0,#1.00000000        ;1918
0001e2  a901              ADD      r1,sp,#4              ;1918
0001e4  f50570a8          ADD      r0,r5,#0x150          ;1918
0001e8  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f326UpdateERKNS0_5ArrayIfEEfNS0_11MemoryStackENS1_13TransformTypeE ; Anki::Embedded::Transformations::PlanarTransformation_f32::Update(const Anki::Embedded::Array<float>&, float, Anki::Embedded::MemoryStack, Anki::Embedded::Transformations::TransformType)
0001ec  b016              ADD      sp,sp,#0x58
0001ee  2000              MOVS     r0,#0                 ;1921
0001f0  e8bd87f0          POP      {r4-r10,pc}
;;;1923   
                          ENDP

                  |L18.500|
                          DCD      ||.constdata||+0x351
                  |L18.504|
0001f8  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\binaryTracker.cpp",0
0001fc  6f726574
000200  6563685c
000204  76697369
000208  6f6e5c72
00020c  6f626f74
000210  5c737263
000214  5c62696e
000218  61727954
00021c  7261636b
000220  65722e63
000224  707000  
000227  00                DCB      0
                  |L18.552|
000228  46696e64          DCB      "FindHorizontalCorrespondences 1 failed",0
00022c  486f7269
000230  7a6f6e74
000234  616c436f
000238  72726573
00023c  706f6e64
000240  656e6365
000244  73203120
000248  6661696c
00024c  656400  
00024f  00                DCB      0
                  |L18.592|
000250  42696e61          DCB      "BinaryTracker::IterativelyRefineTrack_Translation",0
000254  72795472
000258  61636b65
00025c  723a3a49
000260  74657261
000264  74697665
000268  6c795265
00026c  66696e65
000270  54726163
000274  6b5f5472
000278  616e736c
00027c  6174696f
000280  6e00    
000282  00                DCB      0
000283  00                DCB      0
                  |L18.644|
000284  46696e64          DCB      "FindHorizontalCorrespondences 2 failed",0
000288  486f7269
00028c  7a6f6e74
000290  616c436f
000294  72726573
000298  706f6e64
00029c  656e6365
0002a0  73203220
0002a4  6661696c
0002a8  656400  
0002ab  00                DCB      0
                  |L18.684|
0002ac  46696e64          DCB      "FindVerticalCorrespondences 1 failed",0
0002b0  56657274
0002b4  6963616c
0002b8  436f7272
0002bc  6573706f
0002c0  6e64656e
0002c4  63657320
0002c8  31206661
0002cc  696c6564
0002d0  00      
0002d1  00                DCB      0
0002d2  00                DCB      0
0002d3  00                DCB      0
                  |L18.724|
0002d4  46696e64          DCB      "FindVerticalCorrespondences 2 failed",0
0002d8  56657274
0002dc  6963616c
0002e0  436f7272
0002e4  6573706f
0002e8  6e64656e
0002ec  63657320
0002f0  32206661
0002f4  696c6564
0002f8  00      
0002f9  00                DCB      0
0002fa  00                DCB      0
0002fb  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker36FindHorizontalCorrespondences_VerifyEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERi||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker36FindHorizontalCorrespondences_VerifyEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERi PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_Verify(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, int&)
                  |symbol_number.441|
;;;1376   
;;;1377         NO_INLINE Result BinaryTracker::FindHorizontalCorrespondences_Verify(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1378           const s32 maxMatchingDistance,
;;;1379           const Transformations::PlanarTransformation_f32 &transformation,
;;;1380           const FixedLengthList<Point<s16> > &templatePoints,
;;;1381           const FixedLengthList<Point<s16> > &newPoints,
;;;1382           const s32 imageHeight,
;;;1383           const s32 imageWidth,
;;;1384           const Array<s32> &yStartIndexes, //< Computed by ComputeIndexLimitsVertical
;;;1385           s32 &numTemplatePixelsMatched)
;;;1386         {
000004  4681              MOV      r9,r0
000006  ed2d8b0c          VPUSH    {d8-d13}
00000a  b083              SUB      sp,sp,#0xc
00000c  461d              MOV      r5,r3
00000e  4617              MOV      r7,r2
000010  460e              MOV      r6,r1
;;;1387           const s32 numTemplatePoints = templatePoints.get_size();
;;;1388           //const s32 numNewPoints = newPoints.get_size();
;;;1389   
;;;1390           const Array<f32> &homography = transformation.get_homography();
000012  4608              MOV      r0,r1
000014  9c1a              LDR      r4,[sp,#0x68]
000016  f8d2a00c          LDR      r10,[r2,#0xc]
00001a  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
00001e  4680              MOV      r8,r0
;;;1391           const Point<f32> &centerOffset = transformation.get_centerOffset(1.0f);
000020  eeb70a00          VMOV.F32 s0,#1.00000000
000024  4631              MOV      r1,r6
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
00002c  f8d82008          LDR      r2,[r8,#8]
000030  f8d81010          LDR      r1,[r8,#0x10]
;;;1392   
;;;1393           const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2];
000034  2000              MOVS     r0,#0
000036  fb001002          MLA      r0,r0,r2,r1
00003a  466e              MOV      r6,sp                 ;1391
00003c  ed90da00          VLDR     s26,[r0,#0]
000040  edd0ca01          VLDR     s25,[r0,#4]
000044  ed90ca02          VLDR     s24,[r0,#8]
;;;1394           const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2];
000048  2001              MOVS     r0,#1
00004a  fb001002          MLA      r0,r0,r2,r1
;;;1395           const f32 h20 = homography[2][0]; const f32 h21 = homography[2][1]; const f32 h22 = 1.0f;
00004e  eeb79a00          VMOV.F32 s18,#1.00000000
000052  edd0ba00          VLDR     s23,[r0,#0]           ;1394
000056  ed90ba01          VLDR     s22,[r0,#4]           ;1394
00005a  edd0aa02          VLDR     s21,[r0,#8]           ;1394
00005e  2002              MOVS     r0,#2
000060  fb001002          MLA      r0,r0,r2,r1
000064  ed90aa00          VLDR     s20,[r0,#0]
000068  edd09a01          VLDR     s19,[r0,#4]
;;;1396   
;;;1397           AnkiAssert(FLT_NEAR(homography[2][2], 1.0f));
;;;1398   
;;;1399           f32 numTemplatePixelsMatchedF32 = 0.0f;
00006c  ed9f8a3e          VLDR     s16,|L19.360|
;;;1400   
;;;1401           const Point<s16> * restrict pTemplatePoints = templatePoints.Pointer(0);
;;;1402           const Point<s16> * restrict pNewPoints = newPoints.Pointer(0);
;;;1403           const s32 * restrict pYStartIndexes = yStartIndexes.Pointer(0,0);
000070  2000              MOVS     r0,#0
000072  68a2              LDR      r2,[r4,#8]
000074  6921              LDR      r1,[r4,#0x10]
000076  f8d78030          LDR      r8,[r7,#0x30]
00007a  6b2d              LDR      r5,[r5,#0x30]
00007c  fb001702          MLA      r7,r0,r2,r1
;;;1404   
;;;1405           for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++) {
000080  4604              MOV      r4,r0
000082  f1ba0f00          CMP      r10,#0
000086  dd58              BLE      |L19.314|
                  |L19.136|
;;;1406             const f32 xr = static_cast<f32>(pTemplatePoints[iPoint].x);
000088  f9380024          LDRSH    r0,[r8,r4,LSL #2]
;;;1407             const f32 yr = static_cast<f32>(pTemplatePoints[iPoint].y);
;;;1408   
;;;1409             //
;;;1410             // Warp x and y based on the current homography
;;;1411             //
;;;1412   
;;;1413             // Subtract the center offset
;;;1414             const f32 xc = xr - centerOffset.x;
00008c  edd61a00          VLDR     s3,[r6,#0]
000090  ee000a10          VMOV     s0,r0                 ;1406
000094  eb080084          ADD      r0,r8,r4,LSL #2       ;1407
;;;1415             const f32 yc = yr - centerOffset.y;
000098  ed961a01          VLDR     s2,[r6,#4]
00009c  f9b00002          LDRSH    r0,[r0,#2]            ;1407
0000a0  eef80ac0          VCVT.F32.S32 s1,s0                 ;1406
0000a4  ee000a10          VMOV     s0,r0                 ;1407
0000a8  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1407
0000ac  ee700ae1          VSUB.F32 s1,s1,s3              ;1414
0000b0  ee300a41          VSUB.F32 s0,s0,s2
;;;1416   
;;;1417             // Projective warp
;;;1418             const f32 wpi = 1.0f / (h20*xc + h21*yc + h22);
0000b4  ee2a1a20          VMUL.F32 s2,s20,s1
0000b8  ee091a80          VMLA.F32 s2,s19,s0
0000bc  ee312a09          VADD.F32 s4,s2,s18
0000c0  ee891a02          VDIV.F32 s2,s18,s4
;;;1419             const f32 warpedX = (h00*xc + h01*yc + h02) * wpi;
0000c4  ee2d2a20          VMUL.F32 s4,s26,s1
;;;1420             const f32 warpedY = (h10*xc + h11*yc + h12) * wpi;
0000c8  ee6b0aa0          VMUL.F32 s1,s23,s1
0000cc  ee0c2a80          VMLA.F32 s4,s25,s0             ;1419
0000d0  ee4b0a00          VMLA.F32 s1,s22,s0
0000d4  ee322a0c          VADD.F32 s4,s4,s24             ;1419
0000d8  ee300aaa          VADD.F32 s0,s1,s21
0000dc  ee222a01          VMUL.F32 s4,s4,s2              ;1419
0000e0  ee608a01          VMUL.F32 s17,s0,s2
;;;1421   
;;;1422             // TODO: verify the -0.5f is correct
;;;1423             const s32 warpedXrounded = RoundS32_minusPointFive(warpedX + centerOffset.x);
0000e4  ee310a82          VADD.F32 s0,s3,s4
0000e8  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
;;;1424             const s32 warpedYrounded = RoundS32_minusPointFive(warpedY + centerOffset.y);
0000ec  ed960a01          VLDR     s0,[r6,#4]
0000f0  4683              MOV      r11,r0                ;1423
0000f2  ee300a28          VADD.F32 s0,s0,s17
0000f6  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
0000fa  1e01              SUBS     r1,r0,#0
;;;1425   
;;;1426             if(warpedYrounded >= 0 && warpedYrounded < imageHeight) {
0000fc  bfa4              ITT      GE
0000fe  9818              LDRGE    r0,[sp,#0x60]
000100  4288              CMPGE    r0,r1
000102  dd17              BLE      |L19.308|
;;;1427               const s32 minX = warpedXrounded - maxMatchingDistance;
;;;1428               const s32 maxX = warpedXrounded + maxMatchingDistance;
;;;1429   
;;;1430               s32 curIndex = pYStartIndexes[warpedYrounded];
000104  f8570021          LDR      r0,[r7,r1,LSL #2]
;;;1431               const s32 endIndex = pYStartIndexes[warpedYrounded+1];
000108  eb070181          ADD      r1,r7,r1,LSL #2
00010c  ebab0209          SUB      r2,r11,r9             ;1427
000110  6849              LDR      r1,[r1,#4]
000112  eb0b0309          ADD      r3,r11,r9             ;1428
                  |L19.278|
;;;1432   
;;;1433               // Find the start of the valid matches
;;;1434               while( (curIndex<endIndex) && (pNewPoints[curIndex].x<minX) ) {
000116  4288              CMP      r0,r1
000118  bfbe              ITTT     LT
00011a  f935c020          LDRSHLT  r12,[r5,r0,LSL #2]
00011e  4594              CMPLT    r12,r2
;;;1435                 curIndex++;
000120  1c40              ADDLT    r0,r0,#1
000122  dbf8              BLT      |L19.278|
;;;1436               }
;;;1437   
;;;1438               // If there is a valid match, increment numTemplatePixelsMatchedF32
;;;1439               if( (curIndex<endIndex) && (pNewPoints[curIndex].x<=maxX) ) {
000124  4281              CMP      r1,r0
000126  dd05              BLE      |L19.308|
000128  f9350020          LDRSH    r0,[r5,r0,LSL #2]
00012c  4283              CMP      r3,r0
;;;1440                 numTemplatePixelsMatchedF32 += 1.0f;
00012e  bfa8              IT       GE
000130  ee388a09          VADDGE.F32 s16,s16,s18
                  |L19.308|
000134  1c64              ADDS     r4,r4,#1              ;1405
000136  4554              CMP      r4,r10                ;1405
000138  dba6              BLT      |L19.136|
                  |L19.314|
00013a  eeb58ac0          VCMPE.F32 s16,#0.0              ;1405
00013e  eeb60a00          VMOV.F32 s0,#0.50000000        ;1405
000142  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1405
000146  bfcc              ITE      GT                    ;1405
000148  ee380a00          VADDGT.F32 s0,s16,s0             ;1405
00014c  ee380a40          VSUBLE.F32 s0,s16,s0             ;1405
000150  eebd0ac0          VCVT.S32.F32 s0,s0                 ;1405
;;;1441               }
;;;1442             } // if(warpedYrounded >= 0 && warpedYrounded < imageHeight)
;;;1443           } // for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++)
;;;1444   
;;;1445           numTemplatePixelsMatched = Round<s32>(numTemplatePixelsMatchedF32);
000154  981b              LDR      r0,[sp,#0x6c]
000156  ed800a00          VSTR     s0,[r0,#0]
;;;1446   
;;;1447           return RESULT_OK;
;;;1448         }
00015a  b003              ADD      sp,sp,#0xc
00015c  2000              MOVS     r0,#0                 ;1447
00015e  ecbd8b0c          VPOP     {d8-d13}
000162  e8bd8ff0          POP      {r4-r11,pc}
;;;1449   
                          ENDP

000166  0000              DCW      0x0000
                  |L19.360|
000168  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker38FindVerticalCorrespondences_ProjectiveEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNSD_IfEESI_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker38FindVerticalCorrespondences_ProjectiveEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNSD_IfEESI_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_Projective(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
                  |symbol_number.442|
;;;995    
;;;996          NO_INLINE Result BinaryTracker::FindVerticalCorrespondences_Projective(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;997            const s32 maxMatchingDistance,
;;;998            const Transformations::PlanarTransformation_f32 &transformation,
;;;999            const FixedLengthList<Point<s16> > &templatePoints,
;;;1000           const FixedLengthList<Point<s16> > &newPoints,
;;;1001           const s32 imageHeight,
;;;1002           const s32 imageWidth,
;;;1003           const Array<s32> &xStartIndexes,
;;;1004           Array<f32> &AtA,
;;;1005           Array<f32> &Atb_t)
;;;1006         {
000004  461f              MOV      r7,r3
000006  ed2d8b10          VPUSH    {d8-d15}
00000a  b093              SUB      sp,sp,#0x4c
00000c  4690              MOV      r8,r2
00000e  4689              MOV      r9,r1
000010  e9dd4533          LDRD     r4,r5,[sp,#0xcc]
;;;1007           const s32 numTemplatePoints = templatePoints.get_size();
000014  68d0              LDR      r0,[r2,#0xc]
;;;1008           //const s32 numNewPoints = newPoints.get_size();
;;;1009   
;;;1010           const Array<f32> &homography = transformation.get_homography();
000016  9009              STR      r0,[sp,#0x24]
000018  9e32              LDR      r6,[sp,#0xc8]
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
000020  4682              MOV      r10,r0
;;;1011           const Point<f32> &centerOffset = transformation.get_centerOffset(1.0f);
000022  eeb70a00          VMOV.F32 s0,#1.00000000
000026  4649              MOV      r1,r9
000028  a806              ADD      r0,sp,#0x18
00002a  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
00002e  f8da2008          LDR      r2,[r10,#8]
000032  f8da1010          LDR      r1,[r10,#0x10]
;;;1012   
;;;1013           const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2];
000036  2000              MOVS     r0,#0
000038  fb001002          MLA      r0,r0,r2,r1
00003c  f10d0918          ADD      r9,sp,#0x18           ;1011
000040  ed900a00          VLDR     s0,[r0,#0]
000044  ed8d0a11          VSTR     s0,[sp,#0x44]
000048  ed900a01          VLDR     s0,[r0,#4]
00004c  ed8d0a10          VSTR     s0,[sp,#0x40]
000050  ed900a02          VLDR     s0,[r0,#8]
;;;1014           const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2];
000054  2001              MOVS     r0,#1
000056  fb001002          MLA      r0,r0,r2,r1
00005a  ed8d0a0f          VSTR     s0,[sp,#0x3c]         ;1013
00005e  ed900a00          VLDR     s0,[r0,#0]
000062  ed8d0a0e          VSTR     s0,[sp,#0x38]
000066  ed900a01          VLDR     s0,[r0,#4]
00006a  ed8d0a0d          VSTR     s0,[sp,#0x34]
00006e  ed900a02          VLDR     s0,[r0,#8]
;;;1015           const f32 h20 = homography[2][0]; const f32 h21 = homography[2][1]; const f32 h22 = 1.0f;
000072  2002              MOVS     r0,#2
000074  fb001002          MLA      r0,r0,r2,r1
000078  ed8d0a0c          VSTR     s0,[sp,#0x30]         ;1014
00007c  ed900a00          VLDR     s0,[r0,#0]
000080  ed8d0a0b          VSTR     s0,[sp,#0x2c]
000084  ed900a01          VLDR     s0,[r0,#4]
000088  ed8d0a0a          VSTR     s0,[sp,#0x28]
;;;1016   
;;;1017           AnkiAssert(FLT_NEAR(homography[2][2], 1.0f));
;;;1018   
;;;1019           // These addresses should be known at compile time, so should be faster
;;;1020   #if !defined(USE_ARM_ACCELERATION) // natural C
;;;1021           f32 AtA_raw[8][8];
;;;1022           f32 Atb_t_raw[8];
;;;1023   
;;;1024           for(s32 ia=0; ia<8; ia++) {
;;;1025             for(s32 ja=0; ja<8; ja++) {
;;;1026               AtA_raw[ia][ja] = 0;
;;;1027             }
;;;1028             Atb_t_raw[ia] = 0;
;;;1029           }
;;;1030   #else // ARM optimized
;;;1031           f32 AtA_raw33 = 0, AtA_raw34 = 0, AtA_raw35 = 0, AtA_raw36 = 0, AtA_raw37 = 0;
00008c  ed9f9acd          VLDR     s18,|L20.964|
;;;1032           f32 AtA_raw44 = 0, AtA_raw45 = 0, AtA_raw46 = 0, AtA_raw47 = 0;
;;;1033           f32 AtA_raw55 = 0, AtA_raw56 = 0, AtA_raw57 = 0;
;;;1034           f32 AtA_raw66 = 0, AtA_raw67 = 0;
;;;1035           f32 AtA_raw77 = 0;
;;;1036   
;;;1037           f32 Atb_t_raw3 = 0, Atb_t_raw4 = 0, Atb_t_raw5 = 0, Atb_t_raw6 = 0, Atb_t_raw7 = 0;
;;;1038   #endif // #if !defined(USE_ARM_ACCELERATION) ... #else
;;;1039   
;;;1040           const Point<s16> * restrict pTemplatePoints = templatePoints.Pointer(0);
;;;1041           const Point<s16> * restrict pNewPoints = newPoints.Pointer(0);
;;;1042           const s32 * restrict pXStartIndexes = xStartIndexes.Pointer(0,0);
000090  2000              MOVS     r0,#0
000092  ed8d9a00          VSTR     s18,[sp,#0]           ;1031
000096  ed8d9a01          VSTR     s18,[sp,#4]           ;1031
00009a  ed8d9a02          VSTR     s18,[sp,#8]           ;1031
00009e  ed8d9a03          VSTR     s18,[sp,#0xc]         ;1031
0000a2  ed8d9a04          VSTR     s18,[sp,#0x10]        ;1031
0000a6  ed8d9a05          VSTR     s18,[sp,#0x14]        ;1032
0000aa  68b2              LDR      r2,[r6,#8]            ;1032
0000ac  6931              LDR      r1,[r6,#0x10]         ;1032
;;;1043   
;;;1044           for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++) {
0000ae  4606              MOV      r6,r0
0000b0  fb001a02          MLA      r10,r0,r2,r1
0000b4  9809              LDR      r0,[sp,#0x24]
0000b6  f8d8b030          LDR      r11,[r8,#0x30]
0000ba  6b3f              LDR      r7,[r7,#0x30]
0000bc  eef0fa49          VMOV.F32 s31,s18               ;1032
0000c0  eeb0fa49          VMOV.F32 s30,s18               ;1032
0000c4  eef0ea49          VMOV.F32 s29,s18               ;1032
0000c8  eeb0ea49          VMOV.F32 s28,s18               ;1033
0000cc  eef0da49          VMOV.F32 s27,s18               ;1033
0000d0  eeb0da49          VMOV.F32 s26,s18               ;1033
0000d4  eef0ca49          VMOV.F32 s25,s18               ;1034
0000d8  eeb0ca49          VMOV.F32 s24,s18               ;1034
0000dc  eef0ba49          VMOV.F32 s23,s18               ;1035
0000e0  eeb0ba49          VMOV.F32 s22,s18               ;1037
0000e4  eef0aa49          VMOV.F32 s21,s18               ;1037
0000e8  eeb0aa49          VMOV.F32 s20,s18               ;1037
0000ec  eef09a49          VMOV.F32 s19,s18               ;1037
0000f0  2800              CMP      r0,#0
0000f2  dd7c              BLE      |L20.494|
                  |L20.244|
;;;1045             const f32 xr = static_cast<f32>(pTemplatePoints[iPoint].x);
0000f4  f93b0026          LDRSH    r0,[r11,r6,LSL #2]
;;;1046             const f32 yr = static_cast<f32>(pTemplatePoints[iPoint].y);
;;;1047   
;;;1048             //
;;;1049             // Warp x and y based on the current homography
;;;1050             //
;;;1051   
;;;1052             // Subtract the center offset
;;;1053             const f32 xc = xr - centerOffset.x;
0000f8  edd90a00          VLDR     s1,[r9,#0]
0000fc  ee000a10          VMOV     s0,r0                 ;1045
000100  eb0b0086          ADD      r0,r11,r6,LSL #2      ;1046
000104  eeb81ac0          VCVT.F32.S32 s2,s0                 ;1045
000108  f9b00002          LDRSH    r0,[r0,#2]            ;1046
00010c  ee000a10          VMOV     s0,r0                 ;1046
000110  ee718a60          VSUB.F32 s17,s2,s1
;;;1054             const f32 yc = yr - centerOffset.y;
000114  ed991a01          VLDR     s2,[r9,#4]
000118  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1046
00011c  ee308a41          VSUB.F32 s16,s0,s2
;;;1055   
;;;1056             // Projective warp
;;;1057             const f32 wpi = 1.0f / (h20*xc + h21*yc + h22);
000120  ed9d0a0b          VLDR     s0,[sp,#0x2c]
000124  ed9d1a0a          VLDR     s2,[sp,#0x28]
000128  ee200a28          VMUL.F32 s0,s0,s17
00012c  ee010a08          VMLA.F32 s0,s2,s16
000130  eeb71a00          VMOV.F32 s2,#1.00000000
000134  ee701a01          VADD.F32 s3,s0,s2
000138  ee810a21          VDIV.F32 s0,s2,s3
;;;1058             const f32 warpedX = (h00*xc + h01*yc + h02) * wpi;
00013c  ed9d1a11          VLDR     s2,[sp,#0x44]
000140  ee611a28          VMUL.F32 s3,s2,s17
000144  ed9d1a10          VLDR     s2,[sp,#0x40]
000148  ee411a08          VMLA.F32 s3,s2,s16
00014c  ed9d1a0f          VLDR     s2,[sp,#0x3c]
000150  ee311a81          VADD.F32 s2,s3,s2
;;;1059             const f32 warpedY = (h10*xc + h11*yc + h12) * wpi;
000154  eddd1a0e          VLDR     s3,[sp,#0x38]
000158  ee212aa8          VMUL.F32 s4,s3,s17
00015c  eddd1a0d          VLDR     s3,[sp,#0x34]
000160  ee211a00          VMUL.F32 s2,s2,s0              ;1058
000164  ee012a88          VMLA.F32 s4,s3,s16
000168  eddd1a0c          VLDR     s3,[sp,#0x30]
00016c  ee721a21          VADD.F32 s3,s4,s3
000170  ee210a80          VMUL.F32 s0,s3,s0
000174  ed8d0a08          VSTR     s0,[sp,#0x20]
;;;1060   
;;;1061             // TODO: verify the -0.5f is correct
;;;1062             const s32 warpedXrounded = RoundS32_minusPointFive(warpedX + centerOffset.x);
000178  ee300a81          VADD.F32 s0,s1,s2
00017c  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
;;;1063             const s32 warpedYrounded = RoundS32_minusPointFive(warpedY + centerOffset.y);
000180  edd90a01          VLDR     s1,[r9,#4]
000184  ed9d0a08          VLDR     s0,[sp,#0x20]
000188  4680              MOV      r8,r0                 ;1062
00018a  ee300a80          VADD.F32 s0,s1,s0
00018e  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
000192  4603              MOV      r3,r0
;;;1064   
;;;1065             if(warpedXrounded >= 0 && warpedXrounded < imageWidth) {
000194  f1b80f00          CMP      r8,#0
000198  bfa4              ITT      GE
00019a  9831              LDRGE    r0,[sp,#0xc4]
00019c  4540              CMPGE    r0,r8
00019e  dd6d              BLE      |L20.636|
;;;1066               const s32 minY = warpedYrounded - maxMatchingDistance;
0001a0  9823              LDR      r0,[sp,#0x8c]
;;;1067               const s32 maxY = warpedYrounded + maxMatchingDistance;
;;;1068   
;;;1069               s32 curIndex = pXStartIndexes[warpedXrounded];
;;;1070               const s32 endIndex = pXStartIndexes[warpedXrounded+1];
0001a2  eb0a0288          ADD      r2,r10,r8,LSL #2
0001a6  1a19              SUBS     r1,r3,r0              ;1066
0001a8  eb030c00          ADD      r12,r3,r0             ;1067
0001ac  f85a0028          LDR      r0,[r10,r8,LSL #2]    ;1069
0001b0  6852              LDR      r2,[r2,#4]
                  |L20.434|
;;;1071   
;;;1072               // Find the start of the valid matches
;;;1073               while( (curIndex<endIndex) && (pNewPoints[curIndex].y<minY) ) {
0001b2  4290              CMP      r0,r2
0001b4  da07              BGE      |L20.454|
0001b6  eb070880          ADD      r8,r7,r0,LSL #2
0001ba  f9b88002          LDRSH    r8,[r8,#2]
0001be  4588              CMP      r8,r1
;;;1074                 curIndex++;
0001c0  bfb8              IT       LT
0001c2  1c40              ADDLT    r0,r0,#1
0001c4  dbf5              BLT      |L20.434|
                  |L20.454|
0001c6  eeb72a00          VMOV.F32 s4,#1.00000000        ;1011
                  |L20.458|
;;;1075               }
;;;1076   
;;;1077               // For every valid match, increment the sum and counter
;;;1078               while( (curIndex<endIndex) && (pNewPoints[curIndex].y<=maxY) ) {
0001ca  4290              CMP      r0,r2
0001cc  da56              BGE      |L20.636|
0001ce  eb070180          ADD      r1,r7,r0,LSL #2
0001d2  f9b11002          LDRSH    r1,[r1,#2]
0001d6  458c              CMP      r12,r1
0001d8  db50              BLT      |L20.636|
;;;1079                 const s32 offset = pNewPoints[curIndex].y - warpedYrounded;
0001da  1ac9              SUBS     r1,r1,r3
;;;1080                 const f32 yp = warpedY + static_cast<f32>(offset);
0001dc  ee001a10          VMOV     s0,r1
0001e0  eddd0a08          VLDR     s1,[sp,#0x20]
0001e4  eeb80ac0          VCVT.F32.S32 s0,s0
0001e8  ee301a80          VADD.F32 s2,s1,s0
;;;1081   
;;;1082   #if !defined(USE_ARM_ACCELERATION) // natural C
;;;1083                 const f32 aValues[8] = {0, 0, 0, -xc, -yc, -1, xc*yp, yc*yp};
;;;1084   
;;;1085                 const f32 bValue = -yp;
;;;1086   
;;;1087                 for(s32 ia=0; ia<8; ia++) {
;;;1088                   for(s32 ja=ia; ja<8; ja++) {
;;;1089                     AtA_raw[ia][ja] += aValues[ia] * aValues[ja];
;;;1090                   }
;;;1091                   Atb_t_raw[ia] += bValue * aValues[ia];
;;;1092                 }
;;;1093   #else // ARM optimized
;;;1094                 const f32 aValues6 = xc*yp;
0001ec  e000              B        |L20.496|
                  |L20.494|
0001ee  e04a              B        |L20.646|
                  |L20.496|
;;;1095                 const f32 aValues7 = yc*yp;
;;;1096   
;;;1097                 AtA_raw33 += xc * xc;
0001f0  eddd1a00          VLDR     s3,[sp,#0]
0001f4  ee680a81          VMUL.F32 s1,s17,s2             ;1094
0001f8  ee280a01          VMUL.F32 s0,s16,s2             ;1095
0001fc  ee481aa8          VMLA.F32 s3,s17,s17
;;;1098                 AtA_raw34 += xc * yc;
;;;1099                 AtA_raw35 += xc;
;;;1100                 AtA_raw36 -= xc * aValues6;
;;;1101                 AtA_raw37 -= xc * aValues7;
;;;1102   
;;;1103                 AtA_raw44 += yc * yc;
;;;1104                 AtA_raw45 += yc;
;;;1105                 AtA_raw46 -= yc * aValues6;
;;;1106                 AtA_raw47 -= yc * aValues7;
;;;1107   
;;;1108                 AtA_raw55 += 1;
;;;1109                 AtA_raw56 -= aValues6;
;;;1110                 AtA_raw57 -= aValues7;
;;;1111   
;;;1112                 AtA_raw66 += aValues6 * aValues6;
;;;1113                 AtA_raw67 += aValues6 * aValues7;
;;;1114   
;;;1115                 AtA_raw77 += aValues7 * aValues7;
;;;1116   
;;;1117                 Atb_t_raw3 += yp * xc;
000200  ee01ba28          VMLA.F32 s22,s2,s17
000204  ee08fa60          VMLS.F32 s30,s16,s1            ;1105
000208  ee48ea40          VMLS.F32 s29,s16,s0            ;1106
00020c  ee40caa0          VMLA.F32 s25,s1,s1             ;1112
000210  edcd1a00          VSTR     s3,[sp,#0]            ;1097
000214  eddd1a01          VLDR     s3,[sp,#4]            ;1098
000218  ee00ca80          VMLA.F32 s24,s1,s0             ;1113
00021c  ee40ba00          VMLA.F32 s23,s0,s0             ;1115
000220  ee481a88          VMLA.F32 s3,s17,s16            ;1098
;;;1118                 Atb_t_raw4 += yp * yc;
000224  ee41aa08          VMLA.F32 s21,s2,s16
;;;1119                 Atb_t_raw5 += yp;
;;;1120                 Atb_t_raw6 -= yp * aValues6;
000228  ee419a60          VMLS.F32 s19,s2,s1
;;;1121                 Atb_t_raw7 -= yp * aValues7;
00022c  ee019a40          VMLS.F32 s18,s2,s0
000230  ee7ffa88          VADD.F32 s31,s31,s16           ;1104
000234  edcd1a01          VSTR     s3,[sp,#4]            ;1098
000238  eddd1a02          VLDR     s3,[sp,#8]            ;1099
00023c  ee3eea02          VADD.F32 s28,s28,s4            ;1108
000240  ee7ddae0          VSUB.F32 s27,s27,s1            ;1109
000244  ee711aa8          VADD.F32 s3,s3,s17             ;1099
000248  ee3dda40          VSUB.F32 s26,s26,s0            ;1110
00024c  ee3aaa01          VADD.F32 s20,s20,s2            ;1119
000250  edcd1a02          VSTR     s3,[sp,#8]            ;1099
000254  eddd1a03          VLDR     s3,[sp,#0xc]          ;1100
;;;1122   #endif // #if !defined(USE_ARM_ACCELERATION) ... #else
;;;1123   
;;;1124                 curIndex++;
000258  1c40              ADDS     r0,r0,#1
00025a  ee481ae0          VMLS.F32 s3,s17,s1             ;1100
00025e  edcd1a03          VSTR     s3,[sp,#0xc]          ;1100
000262  eddd1a04          VLDR     s3,[sp,#0x10]         ;1101
000266  ee481ac0          VMLS.F32 s3,s17,s0             ;1101
00026a  edcd1a04          VSTR     s3,[sp,#0x10]         ;1101
00026e  eddd1a05          VLDR     s3,[sp,#0x14]         ;1103
000272  ee481a08          VMLA.F32 s3,s16,s16            ;1103
000276  edcd1a05          VSTR     s3,[sp,#0x14]         ;1103
;;;1125               }
00027a  e7a6              B        |L20.458|
                  |L20.636|
00027c  9809              LDR      r0,[sp,#0x24]         ;1044
00027e  1c76              ADDS     r6,r6,#1              ;1044
000280  4286              CMP      r6,r0                 ;1044
000282  f6ffaf37          BLT      |L20.244|
                  |L20.646|
000286  68a2              LDR      r2,[r4,#8]            ;1044
000288  6921              LDR      r1,[r4,#0x10]         ;1044
;;;1126             } // if(warpedXrounded >= 0 && warpedXrounded < imageWidth)
;;;1127           } // for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++)
;;;1128   
;;;1129   #if !defined(USE_ARM_ACCELERATION) // natural C
;;;1130           for(s32 ia=0; ia<8; ia++) {
;;;1131             for(s32 ja=ia; ja<8; ja++) {
;;;1132               AtA[ia][ja] = AtA_raw[ia][ja];
;;;1133             }
;;;1134             Atb_t[0][ia] = Atb_t_raw[ia];
;;;1135           }
;;;1136   #else // ARM optimized
;;;1137           AtA[3][3] = AtA_raw33; AtA[3][4] = AtA_raw34; AtA[3][5] = AtA_raw35; AtA[3][6] = AtA_raw36; AtA[3][7] = AtA_raw37;
00028a  2003              MOVS     r0,#3
00028c  fb001002          MLA      r0,r0,r2,r1
000290  ed9d0a00          VLDR     s0,[sp,#0]
000294  ed800a03          VSTR     s0,[r0,#0xc]
000298  68a2              LDR      r2,[r4,#8]
00029a  6921              LDR      r1,[r4,#0x10]
00029c  2003              MOVS     r0,#3
00029e  fb001002          MLA      r0,r0,r2,r1
0002a2  ed9d0a01          VLDR     s0,[sp,#4]
0002a6  ed800a04          VSTR     s0,[r0,#0x10]
0002aa  68a2              LDR      r2,[r4,#8]
0002ac  6921              LDR      r1,[r4,#0x10]
0002ae  2003              MOVS     r0,#3
0002b0  fb001002          MLA      r0,r0,r2,r1
0002b4  ed9d0a02          VLDR     s0,[sp,#8]
0002b8  ed800a05          VSTR     s0,[r0,#0x14]
0002bc  68a2              LDR      r2,[r4,#8]
0002be  6921              LDR      r1,[r4,#0x10]
0002c0  2003              MOVS     r0,#3
0002c2  fb001002          MLA      r0,r0,r2,r1
0002c6  ed9d0a03          VLDR     s0,[sp,#0xc]
0002ca  ed800a06          VSTR     s0,[r0,#0x18]
0002ce  68a2              LDR      r2,[r4,#8]
0002d0  6921              LDR      r1,[r4,#0x10]
0002d2  2003              MOVS     r0,#3
0002d4  fb001002          MLA      r0,r0,r2,r1
0002d8  ed9d0a04          VLDR     s0,[sp,#0x10]
0002dc  ed800a07          VSTR     s0,[r0,#0x1c]
0002e0  68a2              LDR      r2,[r4,#8]
0002e2  6921              LDR      r1,[r4,#0x10]
;;;1138           AtA[4][4] = AtA_raw44; AtA[4][5] = AtA_raw45; AtA[4][6] = AtA_raw46; AtA[4][7] = AtA_raw47;
0002e4  2004              MOVS     r0,#4
0002e6  fb001002          MLA      r0,r0,r2,r1
0002ea  ed9d0a05          VLDR     s0,[sp,#0x14]
0002ee  ed800a04          VSTR     s0,[r0,#0x10]
0002f2  68a2              LDR      r2,[r4,#8]
0002f4  6921              LDR      r1,[r4,#0x10]
0002f6  2004              MOVS     r0,#4
0002f8  fb001002          MLA      r0,r0,r2,r1
0002fc  edc0fa05          VSTR     s31,[r0,#0x14]
000300  68a2              LDR      r2,[r4,#8]
000302  6921              LDR      r1,[r4,#0x10]
000304  2004              MOVS     r0,#4
000306  fb001002          MLA      r0,r0,r2,r1
00030a  ed80fa06          VSTR     s30,[r0,#0x18]
00030e  68a2              LDR      r2,[r4,#8]
000310  6921              LDR      r1,[r4,#0x10]
000312  2004              MOVS     r0,#4
000314  fb001002          MLA      r0,r0,r2,r1
000318  edc0ea07          VSTR     s29,[r0,#0x1c]
00031c  68a2              LDR      r2,[r4,#8]
00031e  6921              LDR      r1,[r4,#0x10]
;;;1139           AtA[5][5] = AtA_raw55; AtA[5][6] = AtA_raw56; AtA[5][7] = AtA_raw57;
000320  2005              MOVS     r0,#5
000322  fb001002          MLA      r0,r0,r2,r1
000326  ed80ea05          VSTR     s28,[r0,#0x14]
00032a  68a2              LDR      r2,[r4,#8]
00032c  6921              LDR      r1,[r4,#0x10]
00032e  2005              MOVS     r0,#5
000330  fb001002          MLA      r0,r0,r2,r1
000334  edc0da06          VSTR     s27,[r0,#0x18]
000338  68a2              LDR      r2,[r4,#8]
00033a  6921              LDR      r1,[r4,#0x10]
00033c  2005              MOVS     r0,#5
00033e  fb001002          MLA      r0,r0,r2,r1
000342  ed80da07          VSTR     s26,[r0,#0x1c]
000346  68a2              LDR      r2,[r4,#8]
000348  6921              LDR      r1,[r4,#0x10]
;;;1140           AtA[6][6] = AtA_raw66; AtA[6][7] = AtA_raw67;
00034a  2006              MOVS     r0,#6
00034c  fb001002          MLA      r0,r0,r2,r1
000350  edc0ca06          VSTR     s25,[r0,#0x18]
000354  68a2              LDR      r2,[r4,#8]
000356  6921              LDR      r1,[r4,#0x10]
000358  2006              MOVS     r0,#6
00035a  fb001002          MLA      r0,r0,r2,r1
00035e  ed80ca07          VSTR     s24,[r0,#0x1c]
000362  68a2              LDR      r2,[r4,#8]
000364  6921              LDR      r1,[r4,#0x10]
;;;1141           AtA[7][7] = AtA_raw77;
000366  2007              MOVS     r0,#7
000368  fb001002          MLA      r0,r0,r2,r1
00036c  edc0ba07          VSTR     s23,[r0,#0x1c]
000370  68aa              LDR      r2,[r5,#8]
000372  6929              LDR      r1,[r5,#0x10]
;;;1142   
;;;1143           Atb_t[0][3] = Atb_t_raw3; Atb_t[0][4] = Atb_t_raw4; Atb_t[0][5] = Atb_t_raw5; Atb_t[0][6] = Atb_t_raw6; Atb_t[0][7] = Atb_t_raw7;
000374  2000              MOVS     r0,#0
000376  fb001002          MLA      r0,r0,r2,r1
00037a  ed80ba03          VSTR     s22,[r0,#0xc]
00037e  68aa              LDR      r2,[r5,#8]
000380  6929              LDR      r1,[r5,#0x10]
000382  2000              MOVS     r0,#0
000384  fb001002          MLA      r0,r0,r2,r1
000388  edc0aa04          VSTR     s21,[r0,#0x10]
00038c  68aa              LDR      r2,[r5,#8]
00038e  6929              LDR      r1,[r5,#0x10]
000390  2000              MOVS     r0,#0
000392  fb001002          MLA      r0,r0,r2,r1
000396  ed80aa05          VSTR     s20,[r0,#0x14]
00039a  68aa              LDR      r2,[r5,#8]
00039c  6929              LDR      r1,[r5,#0x10]
00039e  2000              MOVS     r0,#0
0003a0  fb001002          MLA      r0,r0,r2,r1
0003a4  edc09a06          VSTR     s19,[r0,#0x18]
0003a8  68aa              LDR      r2,[r5,#8]
0003aa  6929              LDR      r1,[r5,#0x10]
0003ac  2000              MOVS     r0,#0
0003ae  fb001002          MLA      r0,r0,r2,r1
0003b2  ed809a07          VSTR     s18,[r0,#0x1c]
;;;1144   #endif // #if !defined(USE_ARM_ACCELERATION) ... #else
;;;1145   
;;;1146           return RESULT_OK;
;;;1147         } // NO_INLINE Result BinaryTracker::FindVerticalCorrespondences_Projective()
0003b6  b013              ADD      sp,sp,#0x4c
0003b8  2000              MOVS     r0,#0                 ;1146
0003ba  ecbd8b10          VPOP     {d8-d15}
0003be  b004              ADD      sp,sp,#0x10
0003c0  e8bd8ff0          POP      {r4-r11,pc}
;;;1148   
                          ENDP

                  |L20.964|
0003c4  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker38IterativelyRefineTrack_Projective_ListERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiiNS0_11MemoryStackES9_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker38IterativelyRefineTrack_Projective_ListERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiiNS0_11MemoryStackES9_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::IterativelyRefineTrack_Projective_List(const Anki::Embedded::EdgeLists&, const Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, int, int, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
;;;2024   
;;;2025         Result BinaryTracker::IterativelyRefineTrack_Projective_List(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2026           const EdgeLists &nextImageEdges,
;;;2027           const AllIndexLimits &allLimits,
;;;2028           const s32 matching_maxDistance,
;;;2029           const s32 maxMatchesPerType,
;;;2030           MemoryStack fastScratch,
;;;2031           MemoryStack slowScratch)
;;;2032         {
000004  b0fe              SUB      sp,sp,#0x1f8
000006  469a              MOV      r10,r3
000008  e9dd9687          LDRD     r9,r6,[sp,#0x21c]
00000c  4617              MOV      r7,r2
00000e  460c              MOV      r4,r1
000010  4605              MOV      r5,r0
;;;2033           Result lastResult;
;;;2034   
;;;2035           Array<f32> AtA_xDecreasing(8,8,fastScratch);
000012  2300              MOVS     r3,#0
000014  461a              MOV      r2,r3
000016  2101              MOVS     r1,#1
000018  a86e              ADD      r0,sp,#0x1b8
00001a  f8dd8218          LDR      r8,[sp,#0x218]
00001e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000022  6800              LDR      r0,[r0,#0]
000024  2208              MOVS     r2,#8
000026  9000              STR      r0,[sp,#0]
000028  464b              MOV      r3,r9
00002a  4611              MOV      r1,r2
00002c  a845              ADD      r0,sp,#0x114
00002e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2036           Array<f32> AtA_xIncreasing(8,8,fastScratch);
000032  2300              MOVS     r3,#0
000034  461a              MOV      r2,r3
000036  2101              MOVS     r1,#1
000038  a86f              ADD      r0,sp,#0x1bc
00003a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00003e  6800              LDR      r0,[r0,#0]
000040  2208              MOVS     r2,#8
000042  9000              STR      r0,[sp,#0]
000044  464b              MOV      r3,r9
000046  4611              MOV      r1,r2
000048  a84a              ADD      r0,sp,#0x128
00004a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2037           Array<f32> AtA_yDecreasing(8,8,fastScratch);
00004e  2300              MOVS     r3,#0
000050  461a              MOV      r2,r3
000052  2101              MOVS     r1,#1
000054  a870              ADD      r0,sp,#0x1c0
000056  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00005a  6800              LDR      r0,[r0,#0]
00005c  2208              MOVS     r2,#8
00005e  9000              STR      r0,[sp,#0]
000060  464b              MOV      r3,r9
000062  4611              MOV      r1,r2
000064  a84f              ADD      r0,sp,#0x13c
000066  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2038           Array<f32> AtA_yIncreasing(8,8,fastScratch);
00006a  2300              MOVS     r3,#0
00006c  461a              MOV      r2,r3
00006e  2101              MOVS     r1,#1
000070  a871              ADD      r0,sp,#0x1c4
000072  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000076  6800              LDR      r0,[r0,#0]
000078  2208              MOVS     r2,#8
00007a  9000              STR      r0,[sp,#0]
00007c  464b              MOV      r3,r9
00007e  4611              MOV      r1,r2
000080  a854              ADD      r0,sp,#0x150
000082  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2039   
;;;2040           Array<f32> Atb_t_xDecreasing(1,8,fastScratch);
000086  2300              MOVS     r3,#0
000088  461a              MOV      r2,r3
00008a  2101              MOVS     r1,#1
00008c  a872              ADD      r0,sp,#0x1c8
00008e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000092  6800              LDR      r0,[r0,#0]
000094  9000              STR      r0,[sp,#0]
000096  464b              MOV      r3,r9
000098  2208              MOVS     r2,#8
00009a  2101              MOVS     r1,#1
00009c  a859              ADD      r0,sp,#0x164
00009e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2041           Array<f32> Atb_t_xIncreasing(1,8,fastScratch);
0000a2  2300              MOVS     r3,#0
0000a4  461a              MOV      r2,r3
0000a6  2101              MOVS     r1,#1
0000a8  a873              ADD      r0,sp,#0x1cc
0000aa  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000ae  6800              LDR      r0,[r0,#0]
0000b0  9000              STR      r0,[sp,#0]
0000b2  464b              MOV      r3,r9
0000b4  2208              MOVS     r2,#8
0000b6  2101              MOVS     r1,#1
0000b8  a85e              ADD      r0,sp,#0x178
0000ba  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2042           Array<f32> Atb_t_yDecreasing(1,8,fastScratch);
0000be  2300              MOVS     r3,#0
0000c0  461a              MOV      r2,r3
0000c2  2101              MOVS     r1,#1
0000c4  a874              ADD      r0,sp,#0x1d0
0000c6  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000ca  6800              LDR      r0,[r0,#0]
0000cc  9000              STR      r0,[sp,#0]
0000ce  464b              MOV      r3,r9
0000d0  2208              MOVS     r2,#8
0000d2  2101              MOVS     r1,#1
0000d4  a863              ADD      r0,sp,#0x18c
0000d6  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2043           Array<f32> Atb_t_yIncreasing(1,8,fastScratch);
0000da  2300              MOVS     r3,#0
0000dc  461a              MOV      r2,r3
0000de  2101              MOVS     r1,#1
0000e0  a875              ADD      r0,sp,#0x1d4
0000e2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000e6  6800              LDR      r0,[r0,#0]
0000e8  9000              STR      r0,[sp,#0]
0000ea  464b              MOV      r3,r9
0000ec  2208              MOVS     r2,#8
0000ee  2101              MOVS     r1,#1
0000f0  a868              ADD      r0,sp,#0x1a0
0000f2  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2044   
;;;2045           FixedLengthList<IndexCorrespondence> matchingIndexes_xDecreasing(maxMatchesPerType, slowScratch);
0000f6  2300              MOVS     r3,#0
0000f8  461a              MOV      r2,r3
0000fa  2101              MOVS     r1,#1
0000fc  a876              ADD      r0,sp,#0x1d8
0000fe  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000102  6803              LDR      r3,[r0,#0]
000104  4632              MOV      r2,r6
000106  4641              MOV      r1,r8
000108  a807              ADD      r0,sp,#0x1c
00010a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2046           FixedLengthList<IndexCorrespondence> matchingIndexes_xIncreasing(maxMatchesPerType, slowScratch);
00010e  2300              MOVS     r3,#0
000110  461a              MOV      r2,r3
000112  2101              MOVS     r1,#1
000114  a877              ADD      r0,sp,#0x1dc
000116  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00011a  6803              LDR      r3,[r0,#0]
00011c  4632              MOV      r2,r6
00011e  4641              MOV      r1,r8
000120  a814              ADD      r0,sp,#0x50
000122  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2047           FixedLengthList<IndexCorrespondence> matchingIndexes_yDecreasing(maxMatchesPerType, slowScratch);
000126  2300              MOVS     r3,#0
000128  461a              MOV      r2,r3
00012a  2101              MOVS     r1,#1
00012c  a878              ADD      r0,sp,#0x1e0
00012e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000132  6803              LDR      r3,[r0,#0]
000134  4632              MOV      r2,r6
000136  4641              MOV      r1,r8
000138  a821              ADD      r0,sp,#0x84
00013a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2048           FixedLengthList<IndexCorrespondence> matchingIndexes_yIncreasing(maxMatchesPerType, slowScratch);
00013e  2300              MOVS     r3,#0
000140  461a              MOV      r2,r3
000142  2101              MOVS     r1,#1
000144  a879              ADD      r0,sp,#0x1e4
000146  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00014a  6803              LDR      r3,[r0,#0]
00014c  4632              MOV      r2,r6
00014e  4641              MOV      r1,r8
000150  a82e              ADD      r0,sp,#0xb8
000152  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2049   
;;;2050           lastResult = BinaryTracker::FindHorizontalCorrespondences_List(
000156  e9d40134          LDRD     r0,r1,[r4,#0xd0]
00015a  aa07              ADD      r2,sp,#0x1c
00015c  e9cd7202          STRD     r7,r2,[sp,#8]
000160  e9cd0100          STRD     r0,r1,[sp,#0]
000164  4623              MOV      r3,r4
000166  f1050274          ADD      r2,r5,#0x74
00016a  f50571a8          ADD      r1,r5,#0x150
00016e  4650              MOV      r0,r10
000170  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindHorizontalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_List(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&)
;;;2051             matching_maxDistance, this->transformation,
;;;2052             this->templateEdges.xDecreasing, nextImageEdges.xDecreasing,
;;;2053             nextImageEdges.imageHeight, nextImageEdges.imageWidth,
;;;2054             allLimits.xDecreasing_yStartIndexes, matchingIndexes_xDecreasing);
;;;2055   
;;;2056           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
000174  4ee6              LDR      r6,|L21.1296|
000176  ea5f0800          MOVS     r8,r0                 ;2050
00017a  d00d              BEQ      |L21.408|
00017c  f6400008          MOV      r0,#0x808
000180  e9cd6000          STRD     r6,r0,[sp,#0]
000184  a3e3              ADR      r3,|L21.1300|
000186  a2ef              ADR      r2,|L21.1348|
000188  a1f9              ADR      r1,|L21.1392|
00018a  2005              MOVS     r0,#5
00018c  f7fffffe          BL       _Anki_Log
;;;2057             lastResult, "BinaryTracker::IterativelyRefineTrack_List_Projective", "FindHorizontalCorrespondences_List 1 failed");
;;;2058   
;;;2059           lastResult = BinaryTracker::ApplyHorizontalCorrespondenceList_Projective(matchingIndexes_xDecreasing, AtA_xDecreasing, Atb_t_xDecreasing);
;;;2060   
;;;2061           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2062             lastResult, "BinaryTracker::IterativelyRefineTrack_List_Projective", "ApplyHorizontalCorrespondenceList_Projective 1 failed");
;;;2063   
;;;2064           lastResult = BinaryTracker::FindHorizontalCorrespondences_List(
;;;2065             matching_maxDistance, this->transformation,
;;;2066             this->templateEdges.xIncreasing, nextImageEdges.xIncreasing,
;;;2067             nextImageEdges.imageHeight, nextImageEdges.imageWidth,
;;;2068             allLimits.xIncreasing_yStartIndexes, matchingIndexes_xIncreasing);
;;;2069   
;;;2070           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2071             lastResult, "BinaryTracker::IterativelyRefineTrack_List_Projective", "FindHorizontalCorrespondences_List 2 failed");
;;;2072   
;;;2073           lastResult = BinaryTracker::ApplyHorizontalCorrespondenceList_Projective(matchingIndexes_xIncreasing, AtA_xIncreasing, Atb_t_xIncreasing);
;;;2074   
;;;2075           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2076             lastResult, "BinaryTracker::IterativelyRefineTrack_List_Projective", "ApplyHorizontalCorrespondenceList_Projective 2 failed");
;;;2077   
;;;2078           lastResult = BinaryTracker::FindVerticalCorrespondences_List(
;;;2079             matching_maxDistance, this->transformation,
;;;2080             this->templateEdges.yDecreasing, nextImageEdges.yDecreasing,
;;;2081             nextImageEdges.imageHeight, nextImageEdges.imageWidth,
;;;2082             allLimits.yDecreasing_xStartIndexes, matchingIndexes_yDecreasing);
;;;2083   
;;;2084           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2085             lastResult, "BinaryTracker::IterativelyRefineTrack_List_Projective", "FindVerticalCorrespondences_List 1 failed");
;;;2086   
;;;2087           lastResult = BinaryTracker::ApplyVerticalCorrespondenceList_Projective(matchingIndexes_yDecreasing, AtA_yDecreasing, Atb_t_yDecreasing);
;;;2088   
;;;2089           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2090             lastResult, "BinaryTracker::IterativelyRefineTrack_List_Projective", "ApplyVerticalCorrespondenceList_Projective 1 failed");
;;;2091   
;;;2092           lastResult = BinaryTracker::FindVerticalCorrespondences_List(
;;;2093             matching_maxDistance, this->transformation,
;;;2094             this->templateEdges.yIncreasing, nextImageEdges.yIncreasing,
;;;2095             nextImageEdges.imageHeight, nextImageEdges.imageWidth,
;;;2096             allLimits.yIncreasing_xStartIndexes, matchingIndexes_yIncreasing);
;;;2097   
;;;2098           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2099             lastResult, "BinaryTracker::IterativelyRefineTrack_List_Projective", "FindVerticalCorrespondences_List 2 failed");
;;;2100   
;;;2101           lastResult = BinaryTracker::ApplyVerticalCorrespondenceList_Projective(matchingIndexes_yIncreasing, AtA_yIncreasing, Atb_t_yIncreasing);
;;;2102   
;;;2103           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2104             lastResult, "BinaryTracker::IterativelyRefineTrack_List_Projective", "ApplyVerticalCorrespondenceList_Projective 2 failed");
;;;2105   
;;;2106           // Update the transformation
;;;2107           {
;;;2108             Array<f32> newHomography(3, 3, fastScratch);
;;;2109   
;;;2110             Array<f32> AtA(8,8,fastScratch);
;;;2111             Array<f32> Atb_t(1,8,fastScratch);
;;;2112   
;;;2113             // The total AtA and Atb matrices are just the elementwise sums of their partial versions
;;;2114             for(s32 y=0; y<8; y++) {
;;;2115               for(s32 x=0; x<8; x++) {
;;;2116                 AtA[y][x] = AtA_xDecreasing[y][x] + AtA_xIncreasing[y][x] + AtA_yDecreasing[y][x] + AtA_yIncreasing[y][x];
;;;2117               }
;;;2118   
;;;2119               Atb_t[0][y] = Atb_t_xDecreasing[0][y] + Atb_t_xIncreasing[0][y] + Atb_t_yDecreasing[0][y] + Atb_t_yIncreasing[0][y];
;;;2120             }
;;;2121   
;;;2122             Matrix::MakeSymmetric(AtA, false);
;;;2123   
;;;2124             //AtA.Print("AtA");
;;;2125             //Atb_t.Print("Atb_t");
;;;2126             bool numericalFailure;
;;;2127             lastResult = Matrix::SolveLeastSquaresWithCholesky<f32>(AtA, Atb_t, false, numericalFailure);
;;;2128   
;;;2129             //Atb_t.Print("result");
;;;2130   
;;;2131             AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2132               lastResult, "BinaryTracker::IterativelyRefineTrack_List_Projective", "SolveLeastSquaresWithCholesky failed");
;;;2133   
;;;2134             if(numericalFailure){
;;;2135               AnkiWarn("BinaryTracker::IterativelyRefineTrack_List_Projective", "numericalFailure");
;;;2136               return RESULT_OK;
;;;2137             }
;;;2138   
;;;2139             const f32 * restrict pAtb_t = Atb_t.Pointer(0,0);
;;;2140   
;;;2141             newHomography[0][0] = pAtb_t[0]; newHomography[0][1] = pAtb_t[1]; newHomography[0][2] = pAtb_t[2];
;;;2142             newHomography[1][0] = pAtb_t[3]; newHomography[1][1] = pAtb_t[4]; newHomography[1][2] = pAtb_t[5];
;;;2143             newHomography[2][0] = pAtb_t[6]; newHomography[2][1] = pAtb_t[7]; newHomography[2][2] = 1.0f;
;;;2144   
;;;2145             //newHomography.Print("newHomography");
;;;2146   
;;;2147             this->transformation.set_homography(newHomography);
;;;2148           }
;;;2149   
;;;2150           return RESULT_OK;
;;;2151         }
000190  b07e              ADD      sp,sp,#0x1f8
000192  4640              MOV      r0,r8                 ;2056
000194  e8bd87f0          POP      {r4-r10,pc}
                  |L21.408|
000198  aa59              ADD      r2,sp,#0x164          ;2059
00019a  a945              ADD      r1,sp,#0x114          ;2059
00019c  a807              ADD      r0,sp,#0x1c           ;2059
00019e  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker44ApplyHorizontalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_ ; Anki::Embedded::TemplateTracker::BinaryTracker::ApplyHorizontalCorrespondenceList_Projective(const Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
0001a2  ea5f0800          MOVS     r8,r0                 ;2059
0001a6  d00d              BEQ      |L21.452|
0001a8  f640000d          MOV      r0,#0x80d             ;2061
0001ac  e9cd6000          STRD     r6,r0,[sp,#0]         ;2061
0001b0  a3d8              ADR      r3,|L21.1300|
0001b2  a2fd              ADR      r2,|L21.1448|
0001b4  a1ee              ADR      r1,|L21.1392|
0001b6  2005              MOVS     r0,#5                 ;2061
0001b8  f7fffffe          BL       _Anki_Log
0001bc  b07e              ADD      sp,sp,#0x1f8
0001be  4640              MOV      r0,r8                 ;2061
0001c0  e8bd87f0          POP      {r4-r10,pc}
                  |L21.452|
0001c4  e9d40134          LDRD     r0,r1,[r4,#0xd0]      ;2064
0001c8  ab14              ADD      r3,sp,#0x50           ;2064
0001ca  f1070214          ADD      r2,r7,#0x14           ;2064
0001ce  e88d000f          STM      sp,{r0-r3}            ;2064
0001d2  f1040334          ADD      r3,r4,#0x34           ;2064
0001d6  f10502a8          ADD      r2,r5,#0xa8           ;2064
0001da  f50571a8          ADD      r1,r5,#0x150          ;2064
0001de  4650              MOV      r0,r10                ;2064
0001e0  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindHorizontalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_List(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&)
0001e4  ea5f0800          MOVS     r8,r0                 ;2064
0001e8  d00d              BEQ      |L21.518|
0001ea  f6400016          MOV      r0,#0x816             ;2070
0001ee  e9cd6000          STRD     r6,r0,[sp,#0]         ;2070
0001f2  a3c8              ADR      r3,|L21.1300|
0001f4  a2fa              ADR      r2,|L21.1504|
0001f6  a1de              ADR      r1,|L21.1392|
0001f8  2005              MOVS     r0,#5                 ;2070
0001fa  f7fffffe          BL       _Anki_Log
0001fe  b07e              ADD      sp,sp,#0x1f8
000200  4640              MOV      r0,r8                 ;2070
000202  e8bd87f0          POP      {r4-r10,pc}
                  |L21.518|
000206  aa5e              ADD      r2,sp,#0x178          ;2073
000208  a94a              ADD      r1,sp,#0x128          ;2073
00020a  a814              ADD      r0,sp,#0x50           ;2073
00020c  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker44ApplyHorizontalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_ ; Anki::Embedded::TemplateTracker::BinaryTracker::ApplyHorizontalCorrespondenceList_Projective(const Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
000210  ea5f0800          MOVS     r8,r0                 ;2073
000214  d00d              BEQ      |L21.562|
000216  f640001b          MOV      r0,#0x81b             ;2075
00021a  e9cd6000          STRD     r6,r0,[sp,#0]         ;2075
00021e  a3bd              ADR      r3,|L21.1300|
000220  a2fa              ADR      r2,|L21.1548|
000222  a1d3              ADR      r1,|L21.1392|
000224  2005              MOVS     r0,#5                 ;2075
000226  f7fffffe          BL       _Anki_Log
00022a  b07e              ADD      sp,sp,#0x1f8
00022c  4640              MOV      r0,r8                 ;2075
00022e  e8bd87f0          POP      {r4-r10,pc}
                  |L21.562|
000232  e9d40134          LDRD     r0,r1,[r4,#0xd0]      ;2078
000236  ab21              ADD      r3,sp,#0x84           ;2078
000238  f1070228          ADD      r2,r7,#0x28           ;2078
00023c  e88d000f          STM      sp,{r0-r3}            ;2078
000240  f1040368          ADD      r3,r4,#0x68           ;2078
000244  f10502dc          ADD      r2,r5,#0xdc           ;2078
000248  f50571a8          ADD      r1,r5,#0x150          ;2078
00024c  4650              MOV      r0,r10                ;2078
00024e  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker32FindVerticalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_List(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&)
000252  ea5f0800          MOVS     r8,r0                 ;2078
000256  d00d              BEQ      |L21.628|
000258  f6400024          MOV      r0,#0x824             ;2084
00025c  e9cd6000          STRD     r6,r0,[sp,#0]         ;2084
000260  a3ac              ADR      r3,|L21.1300|
000262  a2f8              ADR      r2,|L21.1604|
000264  a1c2              ADR      r1,|L21.1392|
000266  2005              MOVS     r0,#5                 ;2084
000268  f7fffffe          BL       _Anki_Log
00026c  b07e              ADD      sp,sp,#0x1f8
00026e  4640              MOV      r0,r8                 ;2084
000270  e8bd87f0          POP      {r4-r10,pc}
                  |L21.628|
000274  aa63              ADD      r2,sp,#0x18c          ;2087
000276  a94f              ADD      r1,sp,#0x13c          ;2087
000278  a821              ADD      r0,sp,#0x84           ;2087
00027a  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker42ApplyVerticalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_ ; Anki::Embedded::TemplateTracker::BinaryTracker::ApplyVerticalCorrespondenceList_Projective(const Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
00027e  ea5f0800          MOVS     r8,r0                 ;2087
000282  d00d              BEQ      |L21.672|
000284  f6400029          MOV      r0,#0x829             ;2089
000288  e9cd6000          STRD     r6,r0,[sp,#0]         ;2089
00028c  a3a1              ADR      r3,|L21.1300|
00028e  a2f8              ADR      r2,|L21.1648|
000290  a1b7              ADR      r1,|L21.1392|
000292  2005              MOVS     r0,#5                 ;2089
000294  f7fffffe          BL       _Anki_Log
000298  b07e              ADD      sp,sp,#0x1f8
00029a  4640              MOV      r0,r8                 ;2089
00029c  e8bd87f0          POP      {r4-r10,pc}
                  |L21.672|
0002a0  e9d40134          LDRD     r0,r1,[r4,#0xd0]      ;2092
0002a4  ab2e              ADD      r3,sp,#0xb8           ;2092
0002a6  f107023c          ADD      r2,r7,#0x3c           ;2092
0002aa  e88d000f          STM      sp,{r0-r3}            ;2092
0002ae  f104039c          ADD      r3,r4,#0x9c           ;2092
0002b2  f5057288          ADD      r2,r5,#0x110          ;2092
0002b6  f50571a8          ADD      r1,r5,#0x150          ;2092
0002ba  4650              MOV      r0,r10                ;2092
0002bc  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker32FindVerticalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_List(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&)
0002c0  0004              MOVS     r4,r0                 ;2092
0002c2  d00d              BEQ      |L21.736|
0002c4  f6400032          MOV      r0,#0x832             ;2098
0002c8  e9cd6000          STRD     r6,r0,[sp,#0]         ;2098
0002cc  a391              ADR      r3,|L21.1300|
0002ce  a2f5              ADR      r2,|L21.1700|
0002d0  a1a7              ADR      r1,|L21.1392|
0002d2  2005              MOVS     r0,#5                 ;2098
0002d4  f7fffffe          BL       _Anki_Log
0002d8  b07e              ADD      sp,sp,#0x1f8
0002da  4620              MOV      r0,r4                 ;2098
0002dc  e8bd87f0          POP      {r4-r10,pc}
                  |L21.736|
0002e0  aa68              ADD      r2,sp,#0x1a0          ;2101
0002e2  a954              ADD      r1,sp,#0x150          ;2101
0002e4  a82e              ADD      r0,sp,#0xb8           ;2101
0002e6  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker42ApplyVerticalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_ ; Anki::Embedded::TemplateTracker::BinaryTracker::ApplyVerticalCorrespondenceList_Projective(const Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
0002ea  0004              MOVS     r4,r0                 ;2101
0002ec  d00d              BEQ      |L21.778|
0002ee  f6400037          MOV      r0,#0x837             ;2103
0002f2  e9cd6000          STRD     r6,r0,[sp,#0]         ;2103
0002f6  a387              ADR      r3,|L21.1300|
0002f8  a2f5              ADR      r2,|L21.1744|
0002fa  a19d              ADR      r1,|L21.1392|
0002fc  2005              MOVS     r0,#5                 ;2103
0002fe  f7fffffe          BL       _Anki_Log
000302  b07e              ADD      sp,sp,#0x1f8
000304  4620              MOV      r0,r4                 ;2103
000306  e8bd87f0          POP      {r4-r10,pc}
                  |L21.778|
00030a  2300              MOVS     r3,#0                 ;2108
00030c  461a              MOV      r2,r3                 ;2108
00030e  2101              MOVS     r1,#1                 ;2108
000310  a87a              ADD      r0,sp,#0x1e8          ;2108
000312  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000316  6800              LDR      r0,[r0,#0]            ;2108
000318  2203              MOVS     r2,#3                 ;2108
00031a  9000              STR      r0,[sp,#0]            ;2108
00031c  464b              MOV      r3,r9                 ;2108
00031e  4611              MOV      r1,r2                 ;2108
000320  a802              ADD      r0,sp,#8              ;2108
000322  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000326  2300              MOVS     r3,#0                 ;2110
000328  461a              MOV      r2,r3                 ;2110
00032a  2101              MOVS     r1,#1                 ;2110
00032c  a87b              ADD      r0,sp,#0x1ec          ;2110
00032e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000332  6800              LDR      r0,[r0,#0]            ;2110
000334  2208              MOVS     r2,#8                 ;2110
000336  9000              STR      r0,[sp,#0]            ;2110
000338  464b              MOV      r3,r9                 ;2110
00033a  4611              MOV      r1,r2                 ;2110
00033c  a83b              ADD      r0,sp,#0xec           ;2110
00033e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000342  2300              MOVS     r3,#0                 ;2111
000344  461a              MOV      r2,r3                 ;2111
000346  2101              MOVS     r1,#1                 ;2111
000348  a87c              ADD      r0,sp,#0x1f0          ;2111
00034a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00034e  6800              LDR      r0,[r0,#0]            ;2111
000350  9000              STR      r0,[sp,#0]            ;2111
000352  464b              MOV      r3,r9                 ;2111
000354  2208              MOVS     r2,#8                 ;2111
000356  2101              MOVS     r1,#1                 ;2111
000358  a840              ADD      r0,sp,#0x100          ;2111
00035a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00035e  2000              MOVS     r0,#0                 ;2114
                  |L21.864|
000360  2100              MOVS     r1,#0                 ;2115
                  |L21.866|
000362  9b47              LDR      r3,[sp,#0x11c]        ;2115
000364  9a49              LDR      r2,[sp,#0x124]        ;2115
000366  fb002203          MLA      r2,r0,r3,r2           ;2115
00036a  eb020281          ADD      r2,r2,r1,LSL #2       ;2116
00036e  9b4c              LDR      r3,[sp,#0x130]        ;2116
000370  ed920a00          VLDR     s0,[r2,#0]            ;2116
000374  9a4e              LDR      r2,[sp,#0x138]        ;2116
000376  fb002203          MLA      r2,r0,r3,r2           ;2116
00037a  eb020281          ADD      r2,r2,r1,LSL #2       ;2116
00037e  9b51              LDR      r3,[sp,#0x144]        ;2116
000380  edd20a00          VLDR     s1,[r2,#0]            ;2116
000384  9a53              LDR      r2,[sp,#0x14c]        ;2116
000386  fb002203          MLA      r2,r0,r3,r2           ;2116
00038a  eb020281          ADD      r2,r2,r1,LSL #2       ;2116
00038e  ee300a20          VADD.F32 s0,s0,s1              ;2116
000392  edd20a00          VLDR     s1,[r2,#0]            ;2116
000396  9b56              LDR      r3,[sp,#0x158]        ;2116
000398  9a58              LDR      r2,[sp,#0x160]        ;2116
00039a  ee300a20          VADD.F32 s0,s0,s1              ;2116
00039e  fb002203          MLA      r2,r0,r3,r2           ;2116
0003a2  eb020281          ADD      r2,r2,r1,LSL #2       ;2116
0003a6  9b3d              LDR      r3,[sp,#0xf4]         ;2116
0003a8  edd20a00          VLDR     s1,[r2,#0]            ;2116
0003ac  9a3f              LDR      r2,[sp,#0xfc]         ;2116
0003ae  fb002203          MLA      r2,r0,r3,r2           ;2116
0003b2  ee300a20          VADD.F32 s0,s0,s1              ;2116
0003b6  eb020281          ADD      r2,r2,r1,LSL #2       ;2116
0003ba  1c49              ADDS     r1,r1,#1              ;2115
0003bc  ed820a00          VSTR     s0,[r2,#0]            ;2116
0003c0  2908              CMP      r1,#8                 ;2115
0003c2  dbce              BLT      |L21.866|
0003c4  9b5b              LDR      r3,[sp,#0x16c]        ;2115
0003c6  9a5d              LDR      r2,[sp,#0x174]        ;2115
0003c8  2100              MOVS     r1,#0                 ;2119
0003ca  fb012103          MLA      r1,r1,r3,r2           ;2119
0003ce  eb010180          ADD      r1,r1,r0,LSL #2       ;2119
0003d2  9b60              LDR      r3,[sp,#0x180]        ;2119
0003d4  ed910a00          VLDR     s0,[r1,#0]            ;2119
0003d8  9a62              LDR      r2,[sp,#0x188]        ;2119
0003da  2100              MOVS     r1,#0                 ;2119
0003dc  fb012103          MLA      r1,r1,r3,r2           ;2119
0003e0  eb010180          ADD      r1,r1,r0,LSL #2       ;2119
0003e4  9b65              LDR      r3,[sp,#0x194]        ;2119
0003e6  edd10a00          VLDR     s1,[r1,#0]            ;2119
0003ea  9a67              LDR      r2,[sp,#0x19c]        ;2119
0003ec  2100              MOVS     r1,#0                 ;2119
0003ee  fb012103          MLA      r1,r1,r3,r2           ;2119
0003f2  eb010180          ADD      r1,r1,r0,LSL #2       ;2119
0003f6  ee300a20          VADD.F32 s0,s0,s1              ;2119
0003fa  edd10a00          VLDR     s1,[r1,#0]            ;2119
0003fe  9b6a              LDR      r3,[sp,#0x1a8]        ;2119
000400  9a6c              LDR      r2,[sp,#0x1b0]        ;2119
000402  2100              MOVS     r1,#0                 ;2119
000404  fb012103          MLA      r1,r1,r3,r2           ;2119
000408  eb010180          ADD      r1,r1,r0,LSL #2       ;2119
00040c  ee300a20          VADD.F32 s0,s0,s1              ;2119
000410  edd10a00          VLDR     s1,[r1,#0]            ;2119
000414  9b42              LDR      r3,[sp,#0x108]        ;2119
000416  9a44              LDR      r2,[sp,#0x110]        ;2119
000418  2100              MOVS     r1,#0                 ;2119
00041a  fb012103          MLA      r1,r1,r3,r2           ;2119
00041e  ee300a20          VADD.F32 s0,s0,s1              ;2119
000422  eb010180          ADD      r1,r1,r0,LSL #2       ;2119
000426  1c40              ADDS     r0,r0,#1              ;2114
000428  ed810a00          VSTR     s0,[r1,#0]            ;2119
00042c  2808              CMP      r0,#8                 ;2114
00042e  db97              BLT      |L21.864|
000430  2100              MOVS     r1,#0                 ;2122
000432  a83b              ADD      r0,sp,#0xec           ;2122
000434  f7fffffe          BL       _ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b ; Anki::Embedded::Matrix::MakeSymmetric<Anki::Embedded::Array<float>>(T1&, bool)
000438  ab6d              ADD      r3,sp,#0x1b4          ;2127
00043a  2200              MOVS     r2,#0                 ;2127
00043c  a940              ADD      r1,sp,#0x100          ;2127
00043e  a83b              ADD      r0,sp,#0xec           ;2127
000440  f7fffffe          BL       _ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)
000444  0004              MOVS     r4,r0                 ;2127
000446  d00d              BEQ      |L21.1124|
000448  f6400053          MOV      r0,#0x853             ;2131
00044c  e9cd6000          STRD     r6,r0,[sp,#0]         ;2131
000450  a330              ADR      r3,|L21.1300|
000452  a2ac              ADR      r2,|L21.1796|
000454  a146              ADR      r1,|L21.1392|
000456  2005              MOVS     r0,#5                 ;2131
000458  f7fffffe          BL       _Anki_Log
00045c  b07e              ADD      sp,sp,#0x1f8
00045e  4620              MOV      r0,r4                 ;2131
000460  e8bd87f0          POP      {r4-r10,pc}
                  |L21.1124|
000464  f89d01b4          LDRB     r0,[sp,#0x1b4]        ;2134
000468  2800              CMP      r0,#0                 ;2134
00046a  f04f0000          MOV      r0,#0                 ;2139
00046e  bf1c              ITT      NE
000470  b07e              ADDNE    sp,sp,#0x1f8
000472  e8bd87f0          POPNE    {r4-r10,pc}
000476  9a42              LDR      r2,[sp,#0x108]
000478  9944              LDR      r1,[sp,#0x110]
00047a  9b04              LDR      r3,[sp,#0x10]
00047c  fb001002          MLA      r0,r0,r2,r1
000480  9a06              LDR      r2,[sp,#0x18]
000482  2100              MOVS     r1,#0                 ;2141
000484  fb012103          MLA      r1,r1,r3,r2           ;2141
000488  ed900a00          VLDR     s0,[r0,#0]            ;2141
00048c  ed810a00          VSTR     s0,[r1,#0]            ;2141
000490  9b04              LDR      r3,[sp,#0x10]         ;2141
000492  9a06              LDR      r2,[sp,#0x18]         ;2141
000494  2100              MOVS     r1,#0                 ;2141
000496  fb012103          MLA      r1,r1,r3,r2           ;2141
00049a  ed900a01          VLDR     s0,[r0,#4]            ;2141
00049e  ed810a01          VSTR     s0,[r1,#4]            ;2141
0004a2  9b04              LDR      r3,[sp,#0x10]         ;2141
0004a4  9a06              LDR      r2,[sp,#0x18]         ;2141
0004a6  2100              MOVS     r1,#0                 ;2141
0004a8  fb012103          MLA      r1,r1,r3,r2           ;2141
0004ac  ed900a02          VLDR     s0,[r0,#8]            ;2141
0004b0  ed810a02          VSTR     s0,[r1,#8]            ;2141
0004b4  9b04              LDR      r3,[sp,#0x10]         ;2141
0004b6  9a06              LDR      r2,[sp,#0x18]         ;2141
0004b8  2101              MOVS     r1,#1                 ;2142
0004ba  fb012103          MLA      r1,r1,r3,r2           ;2142
0004be  ed900a03          VLDR     s0,[r0,#0xc]          ;2142
0004c2  ed810a00          VSTR     s0,[r1,#0]            ;2142
0004c6  9b04              LDR      r3,[sp,#0x10]         ;2142
0004c8  9a06              LDR      r2,[sp,#0x18]         ;2142
0004ca  2101              MOVS     r1,#1                 ;2142
0004cc  fb012103          MLA      r1,r1,r3,r2           ;2142
0004d0  ed900a04          VLDR     s0,[r0,#0x10]         ;2142
0004d4  ed810a01          VSTR     s0,[r1,#4]            ;2142
0004d8  9b04              LDR      r3,[sp,#0x10]         ;2142
0004da  9a06              LDR      r2,[sp,#0x18]         ;2142
0004dc  2101              MOVS     r1,#1                 ;2142
0004de  fb012103          MLA      r1,r1,r3,r2           ;2142
0004e2  ed900a05          VLDR     s0,[r0,#0x14]         ;2142
0004e6  ed810a02          VSTR     s0,[r1,#8]            ;2142
0004ea  9b04              LDR      r3,[sp,#0x10]         ;2142
0004ec  9a06              LDR      r2,[sp,#0x18]         ;2142
0004ee  2102              MOVS     r1,#2                 ;2143
0004f0  fb012103          MLA      r1,r1,r3,r2           ;2143
0004f4  ed900a06          VLDR     s0,[r0,#0x18]         ;2143
0004f8  ed810a00          VSTR     s0,[r1,#0]            ;2143
0004fc  9b04              LDR      r3,[sp,#0x10]         ;2143
0004fe  9a06              LDR      r2,[sp,#0x18]         ;2143
000500  2102              MOVS     r1,#2                 ;2143
000502  fb012103          MLA      r1,r1,r3,r2           ;2143
000506  ed900a07          VLDR     s0,[r0,#0x1c]         ;2143
00050a  ed810a01          VSTR     s0,[r1,#4]            ;2143
00050e  e10d              B        |L21.1836|
                  |L21.1296|
                          DCD      ||.constdata||+0x538
                  |L21.1300|
000514  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\binaryTracker.cpp",0
000518  6f726574
00051c  6563685c
000520  76697369
000524  6f6e5c72
000528  6f626f74
00052c  5c737263
000530  5c62696e
000534  61727954
000538  7261636b
00053c  65722e63
000540  707000  
000543  00                DCB      0
                  |L21.1348|
000544  46696e64          DCB      "FindHorizontalCorrespondences_List 1 failed",0
000548  486f7269
00054c  7a6f6e74
000550  616c436f
000554  72726573
000558  706f6e64
00055c  656e6365
000560  735f4c69
000564  73742031
000568  20666169
00056c  6c656400
                  |L21.1392|
000570  42696e61          DCB      "BinaryTracker::IterativelyRefineTrack_List_Projective",0
000574  72795472
000578  61636b65
00057c  723a3a49
000580  74657261
000584  74697665
000588  6c795265
00058c  66696e65
000590  54726163
000594  6b5f4c69
000598  73745f50
00059c  726f6a65
0005a0  63746976
0005a4  6500    
0005a6  00                DCB      0
0005a7  00                DCB      0
                  |L21.1448|
0005a8  4170706c          DCB      "ApplyHorizontalCorrespondenceList_Projective 1 failed",0
0005ac  79486f72
0005b0  697a6f6e
0005b4  74616c43
0005b8  6f727265
0005bc  73706f6e
0005c0  64656e63
0005c4  654c6973
0005c8  745f5072
0005cc  6f6a6563
0005d0  74697665
0005d4  20312066
0005d8  61696c65
0005dc  6400    
0005de  00                DCB      0
0005df  00                DCB      0
                  |L21.1504|
0005e0  46696e64          DCB      "FindHorizontalCorrespondences_List 2 failed",0
0005e4  486f7269
0005e8  7a6f6e74
0005ec  616c436f
0005f0  72726573
0005f4  706f6e64
0005f8  656e6365
0005fc  735f4c69
000600  73742032
000604  20666169
000608  6c656400
                  |L21.1548|
00060c  4170706c          DCB      "ApplyHorizontalCorrespondenceList_Projective 2 failed",0
000610  79486f72
000614  697a6f6e
000618  74616c43
00061c  6f727265
000620  73706f6e
000624  64656e63
000628  654c6973
00062c  745f5072
000630  6f6a6563
000634  74697665
000638  20322066
00063c  61696c65
000640  6400    
000642  00                DCB      0
000643  00                DCB      0
                  |L21.1604|
000644  46696e64          DCB      "FindVerticalCorrespondences_List 1 failed",0
000648  56657274
00064c  6963616c
000650  436f7272
000654  6573706f
000658  6e64656e
00065c  6365735f
000660  4c697374
000664  20312066
000668  61696c65
00066c  6400    
00066e  00                DCB      0
00066f  00                DCB      0
                  |L21.1648|
000670  4170706c          DCB      "ApplyVerticalCorrespondenceList_Projective 1 failed",0
000674  79566572
000678  74696361
00067c  6c436f72
000680  72657370
000684  6f6e6465
000688  6e63654c
00068c  6973745f
000690  50726f6a
000694  65637469
000698  76652031
00069c  20666169
0006a0  6c656400
                  |L21.1700|
0006a4  46696e64          DCB      "FindVerticalCorrespondences_List 2 failed",0
0006a8  56657274
0006ac  6963616c
0006b0  436f7272
0006b4  6573706f
0006b8  6e64656e
0006bc  6365735f
0006c0  4c697374
0006c4  20322066
0006c8  61696c65
0006cc  6400    
0006ce  00                DCB      0
0006cf  00                DCB      0
                  |L21.1744|
0006d0  4170706c          DCB      "ApplyVerticalCorrespondenceList_Projective 2 failed",0
0006d4  79566572
0006d8  74696361
0006dc  6c436f72
0006e0  72657370
0006e4  6f6e6465
0006e8  6e63654c
0006ec  6973745f
0006f0  50726f6a
0006f4  65637469
0006f8  76652032
0006fc  20666169
000700  6c656400
                  |L21.1796|
000704  536f6c76          DCB      "SolveLeastSquaresWithCholesky failed",0
000708  654c6561
00070c  73745371
000710  75617265
000714  73576974
000718  6843686f
00071c  6c65736b
000720  79206661
000724  696c6564
000728  00      
000729  00                DCB      0
00072a  00                DCB      0
00072b  00                DCB      0
                  |L21.1836|
00072c  9a04              LDR      r2,[sp,#0x10]         ;2143
00072e  9906              LDR      r1,[sp,#0x18]         ;2143
000730  2002              MOVS     r0,#2                 ;2143
000732  fb001002          MLA      r0,r0,r2,r1           ;2143
000736  eeb70a00          VMOV.F32 s0,#1.00000000        ;2143
00073a  ed800a02          VSTR     s0,[r0,#8]            ;2143
00073e  a902              ADD      r1,sp,#8              ;2147
000740  f50570a8          ADD      r0,r5,#0x150          ;2147
000744  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3214set_homographyERKNS0_5ArrayIfEE ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_homography(const Anki::Embedded::Array<float>&)
000748  b07e              ADD      sp,sp,#0x1f8
00074a  2000              MOVS     r0,#0                 ;2150
00074c  e8bd87f0          POP      {r4-r10,pc}
;;;2152   
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker39FindVerticalCorrespondences_TranslationEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERiSH_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker39FindVerticalCorrespondences_TranslationEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERiSH_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_Translation(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, int&, int&)
                  |symbol_number.443|
;;;834    
;;;835          Result BinaryTracker::FindVerticalCorrespondences_Translation(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;836            const s32 maxMatchingDistance,
;;;837            const Transformations::PlanarTransformation_f32 &transformation,
;;;838            const FixedLengthList<Point<s16> > &templatePoints,
;;;839            const FixedLengthList<Point<s16> > &newPoints,
;;;840            const s32 imageHeight,
;;;841            const s32 imageWidth,
;;;842            const Array<s32> &xStartIndexes,
;;;843            s32 &sumY,
;;;844            s32 &numCorrespondences)
;;;845          {
000004  4683              MOV      r11,r0
000006  ed2d8b0c          VPUSH    {d8-d13}
00000a  b083              SUB      sp,sp,#0xc
00000c  461e              MOV      r6,r3
00000e  4617              MOV      r7,r2
000010  4688              MOV      r8,r1
000012  e9dd451a          LDRD     r4,r5,[sp,#0x68]
;;;846            const s32 numTemplatePoints = templatePoints.get_size();
000016  68d0              LDR      r0,[r2,#0xc]
;;;847            //const s32 numNewPoints = newPoints.get_size();
;;;848    
;;;849            const Array<f32> &homography = transformation.get_homography();
000018  9002              STR      r0,[sp,#8]
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
000020  4681              MOV      r9,r0
;;;850            const Point<f32> &centerOffset = transformation.get_centerOffset(1.0f);
000022  eeb70a00          VMOV.F32 s0,#1.00000000
000026  4641              MOV      r1,r8
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
00002e  f8d92008          LDR      r2,[r9,#8]
000032  f8d91010          LDR      r1,[r9,#0x10]
;;;851    
;;;852            // TODO: if the homography is just translation, we can do this faster (just slightly, as most of the cost is the search)
;;;853            const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2];
000036  2000              MOVS     r0,#0
000038  fb001002          MLA      r0,r0,r2,r1
00003c  46e8              MOV      r8,sp                 ;850
00003e  edd0ca00          VLDR     s25,[r0,#0]
000042  ed90ca01          VLDR     s24,[r0,#4]
000046  edd0ba02          VLDR     s23,[r0,#8]
;;;854            const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2];
00004a  2001              MOVS     r0,#1
00004c  fb001002          MLA      r0,r0,r2,r1
;;;855            const f32 h20 = homography[2][0]; const f32 h21 = homography[2][1]; const f32 h22 = 1.0f;
000050  eef78a00          VMOV.F32 s17,#1.00000000
000054  ed90ba00          VLDR     s22,[r0,#0]           ;854
000058  edd0aa01          VLDR     s21,[r0,#4]           ;854
00005c  ed90aa02          VLDR     s20,[r0,#8]           ;854
000060  2002              MOVS     r0,#2
000062  fb001002          MLA      r0,r0,r2,r1
000066  edd09a00          VLDR     s19,[r0,#0]
00006a  ed909a01          VLDR     s18,[r0,#4]
;;;856    
;;;857            AnkiAssert(FLT_NEAR(homography[2][2], 1.0f));
;;;858    
;;;859            sumY = 0;
00006e  2000              MOVS     r0,#0
;;;860            f32 numCorrespondencesF32 = 0.0f;
000070  ed9f8a44          VLDR     s16,|L22.388|
000074  6028              STR      r0,[r5,#0]
000076  68a2              LDR      r2,[r4,#8]
000078  6921              LDR      r1,[r4,#0x10]
;;;861    
;;;862            const Point<s16> * restrict pTemplatePoints = templatePoints.Pointer(0);
;;;863            const Point<s16> * restrict pNewPoints = newPoints.Pointer(0);
;;;864            const s32 * restrict pXStartIndexes = xStartIndexes.Pointer(0,0);
;;;865    
;;;866            for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++) {
00007a  4604              MOV      r4,r0
00007c  fb001902          MLA      r9,r0,r2,r1
000080  9802              LDR      r0,[sp,#8]
000082  f8d7a030          LDR      r10,[r7,#0x30]
000086  6b36              LDR      r6,[r6,#0x30]
000088  2800              CMP      r0,#0
00008a  dd65              BLE      |L22.344|
                  |L22.140|
;;;867              const f32 xr = static_cast<f32>(pTemplatePoints[iPoint].x);
00008c  f93a0024          LDRSH    r0,[r10,r4,LSL #2]
;;;868              const f32 yr = static_cast<f32>(pTemplatePoints[iPoint].y);
;;;869    
;;;870              //
;;;871              // Warp x and y based on the current homography
;;;872              //
;;;873    
;;;874              // Subtract the center offset
;;;875              const f32 xc = xr - centerOffset.x;
000090  edd81a00          VLDR     s3,[r8,#0]
000094  ee000a10          VMOV     s0,r0                 ;867
000098  eb0a0084          ADD      r0,r10,r4,LSL #2      ;868
;;;876              const f32 yc = yr - centerOffset.y;
00009c  ed981a01          VLDR     s2,[r8,#4]
0000a0  f9b00002          LDRSH    r0,[r0,#2]            ;868
0000a4  eef80ac0          VCVT.F32.S32 s1,s0                 ;867
0000a8  ee000a10          VMOV     s0,r0                 ;868
0000ac  eeb80ac0          VCVT.F32.S32 s0,s0                 ;868
0000b0  ee700ae1          VSUB.F32 s1,s1,s3              ;875
0000b4  ee300a41          VSUB.F32 s0,s0,s2
;;;877    
;;;878              // Projective warp
;;;879              const f32 wpi = 1.0f / (h20*xc + h21*yc + h22);
0000b8  ee291aa0          VMUL.F32 s2,s19,s1
0000bc  ee091a00          VMLA.F32 s2,s18,s0
0000c0  ee312a28          VADD.F32 s4,s2,s17
0000c4  ee881a82          VDIV.F32 s2,s17,s4
;;;880              const f32 warpedX = (h00*xc + h01*yc + h02) * wpi;
0000c8  ee2c2aa0          VMUL.F32 s4,s25,s1
;;;881              const f32 warpedY = (h10*xc + h11*yc + h12) * wpi;
0000cc  ee6b0a20          VMUL.F32 s1,s22,s1
0000d0  ee0c2a00          VMLA.F32 s4,s24,s0             ;880
0000d4  ee4a0a80          VMLA.F32 s1,s21,s0
0000d8  ee322a2b          VADD.F32 s4,s4,s23             ;880
0000dc  ee300a8a          VADD.F32 s0,s1,s20
0000e0  ee222a01          VMUL.F32 s4,s4,s2              ;880
0000e4  ee20da01          VMUL.F32 s26,s0,s2
;;;882    
;;;883              // TODO: verify the -0.5f is correct
;;;884              const s32 warpedXrounded = RoundS32_minusPointFive(warpedX + centerOffset.x);
0000e8  ee310a82          VADD.F32 s0,s3,s4
0000ec  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
;;;885              const s32 warpedYrounded = RoundS32_minusPointFive(warpedY + centerOffset.y);
0000f0  ed980a01          VLDR     s0,[r8,#4]
0000f4  4607              MOV      r7,r0                 ;884
0000f6  ee300a0d          VADD.F32 s0,s0,s26
0000fa  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
0000fe  4603              MOV      r3,r0
;;;886    
;;;887              if(warpedXrounded >= 0 && warpedXrounded < imageWidth) {
000100  2f00              CMP      r7,#0
000102  bfa4              ITT      GE
000104  9819              LDRGE    r0,[sp,#0x64]
000106  42b8              CMPGE    r0,r7
000108  dd22              BLE      |L22.336|
;;;888                const s32 minY = warpedYrounded - maxMatchingDistance;
;;;889                const s32 maxY = warpedYrounded + maxMatchingDistance;
;;;890    
;;;891                s32 curIndex = pXStartIndexes[warpedXrounded];
;;;892                const s32 endIndex = pXStartIndexes[warpedXrounded+1];
00010a  eb090287          ADD      r2,r9,r7,LSL #2
00010e  f8590027          LDR      r0,[r9,r7,LSL #2]     ;891
000112  6852              LDR      r2,[r2,#4]
000114  eba3010b          SUB      r1,r3,r11             ;888
000118  eb030c0b          ADD      r12,r3,r11            ;889
                  |L22.284|
;;;893    
;;;894                // Find the start of the valid matches
;;;895                while( (curIndex<endIndex) && (pNewPoints[curIndex].y<minY) ) {
00011c  4290              CMP      r0,r2
00011e  da0f              BGE      |L22.320|
000120  eb060780          ADD      r7,r6,r0,LSL #2
000124  f9b77002          LDRSH    r7,[r7,#2]
000128  428f              CMP      r7,r1
;;;896                  curIndex++;
00012a  bfb8              IT       LT
00012c  1c40              ADDLT    r0,r0,#1
00012e  dbf5              BLT      |L22.284|
000130  e006              B        |L22.320|
                  |L22.306|
;;;897                }
;;;898    
;;;899                // For every valid match, increment the sum and counter
;;;900                while( (curIndex<endIndex) && (pNewPoints[curIndex].y<=maxY) ) {
;;;901                  const s32 offset = pNewPoints[curIndex].y - warpedYrounded;
000132  1ac9              SUBS     r1,r1,r3
;;;902    
;;;903                  sumY += offset;
000134  682f              LDR      r7,[r5,#0]
;;;904                  numCorrespondencesF32 += 1.0f;
000136  ee388a28          VADD.F32 s16,s16,s17
00013a  4439              ADD      r1,r1,r7              ;903
;;;905    
;;;906                  curIndex++;
00013c  1c40              ADDS     r0,r0,#1
00013e  6029              STR      r1,[r5,#0]
                  |L22.320|
000140  4290              CMP      r0,r2                 ;900
000142  da05              BGE      |L22.336|
000144  eb060180          ADD      r1,r6,r0,LSL #2       ;900
000148  f9b11002          LDRSH    r1,[r1,#2]            ;900
00014c  458c              CMP      r12,r1                ;900
00014e  daf0              BGE      |L22.306|
                  |L22.336|
000150  9802              LDR      r0,[sp,#8]            ;866
000152  1c64              ADDS     r4,r4,#1              ;866
000154  4284              CMP      r4,r0                 ;866
000156  db99              BLT      |L22.140|
                  |L22.344|
000158  eeb58ac0          VCMPE.F32 s16,#0.0              ;866
00015c  eeb60a00          VMOV.F32 s0,#0.50000000        ;866
000160  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;866
000164  bfcc              ITE      GT                    ;866
000166  ee380a00          VADDGT.F32 s0,s16,s0             ;866
00016a  ee380a40          VSUBLE.F32 s0,s16,s0             ;866
00016e  eebd0ac0          VCVT.S32.F32 s0,s0                 ;866
;;;907                }
;;;908              } // if(warpedXrounded >= 0 && warpedXrounded < imageWidth)
;;;909            } // for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++)
;;;910    
;;;911            numCorrespondences = Round<s32>(numCorrespondencesF32);
000172  981c              LDR      r0,[sp,#0x70]
000174  ed800a00          VSTR     s0,[r0,#0]
;;;912    
;;;913            return RESULT_OK;
;;;914          } // Result BinaryTracker::FindVerticalCorrespondences_Translation()
000178  b003              ADD      sp,sp,#0xc
00017a  2000              MOVS     r0,#0                 ;913
00017c  ecbd8b0c          VPOP     {d8-d13}
000180  e8bd8ff0          POP      {r4-r11,pc}
;;;915    
                          ENDP

                  |L22.388|
000184  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker40FindHorizontalCorrespondences_ProjectiveEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNSD_IfEESI_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker40FindHorizontalCorrespondences_ProjectiveEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNSD_IfEESI_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_Projective(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
                  |symbol_number.444|
;;;1148   
;;;1149         NO_INLINE Result BinaryTracker::FindHorizontalCorrespondences_Projective(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1150           const s32 maxMatchingDistance,
;;;1151           const Transformations::PlanarTransformation_f32 &transformation,
;;;1152           const FixedLengthList<Point<s16> > &templatePoints,
;;;1153           const FixedLengthList<Point<s16> > &newPoints,
;;;1154           const s32 imageHeight,
;;;1155           const s32 imageWidth,
;;;1156           const Array<s32> &yStartIndexes,
;;;1157           Array<f32> &AtA,
;;;1158           Array<f32> &Atb_t)
;;;1159         {
000004  461f              MOV      r7,r3
000006  ed2d8b10          VPUSH    {d8-d15}
00000a  b093              SUB      sp,sp,#0x4c
00000c  4690              MOV      r8,r2
00000e  4689              MOV      r9,r1
000010  e9dd4533          LDRD     r4,r5,[sp,#0xcc]
;;;1160           const s32 numTemplatePoints = templatePoints.get_size();
000014  68d0              LDR      r0,[r2,#0xc]
;;;1161           //const s32 numNewPoints = newPoints.get_size();
;;;1162   
;;;1163           const Array<f32> &homography = transformation.get_homography();
000016  9009              STR      r0,[sp,#0x24]
000018  9e32              LDR      r6,[sp,#0xc8]
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
000020  4682              MOV      r10,r0
;;;1164           const Point<f32> &centerOffset = transformation.get_centerOffset(1.0f);
000022  eeb70a00          VMOV.F32 s0,#1.00000000
000026  4649              MOV      r1,r9
000028  a806              ADD      r0,sp,#0x18
00002a  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
00002e  f8da2008          LDR      r2,[r10,#8]
000032  f8da1010          LDR      r1,[r10,#0x10]
;;;1165   
;;;1166           const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2];
000036  2000              MOVS     r0,#0
000038  fb001002          MLA      r0,r0,r2,r1
00003c  f10d0918          ADD      r9,sp,#0x18           ;1164
000040  ed900a00          VLDR     s0,[r0,#0]
000044  ed8d0a12          VSTR     s0,[sp,#0x48]
000048  ed900a01          VLDR     s0,[r0,#4]
00004c  ed8d0a11          VSTR     s0,[sp,#0x44]
000050  ed900a02          VLDR     s0,[r0,#8]
;;;1167           const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2];
000054  2001              MOVS     r0,#1
000056  fb001002          MLA      r0,r0,r2,r1
00005a  ed8d0a10          VSTR     s0,[sp,#0x40]         ;1166
00005e  ed900a00          VLDR     s0,[r0,#0]
000062  ed8d0a0f          VSTR     s0,[sp,#0x3c]
000066  ed900a01          VLDR     s0,[r0,#4]
00006a  ed8d0a0e          VSTR     s0,[sp,#0x38]
00006e  ed900a02          VLDR     s0,[r0,#8]
;;;1168           const f32 h20 = homography[2][0]; const f32 h21 = homography[2][1]; const f32 h22 = 1.0f;
000072  2002              MOVS     r0,#2
000074  fb001002          MLA      r0,r0,r2,r1
000078  ed8d0a0d          VSTR     s0,[sp,#0x34]         ;1167
00007c  ed900a00          VLDR     s0,[r0,#0]
000080  ed8d0a0c          VSTR     s0,[sp,#0x30]
000084  ed900a01          VLDR     s0,[r0,#4]
000088  ed8d0a0b          VSTR     s0,[sp,#0x2c]
;;;1169   
;;;1170           AnkiAssert(FLT_NEAR(homography[2][2], 1.0f));
;;;1171   
;;;1172           // These addresses should be known at compile time, so should be faster
;;;1173   #if !defined(USE_ARM_ACCELERATION) // natural C
;;;1174           f32 AtA_raw[8][8];
;;;1175           f32 Atb_t_raw[8];
;;;1176   
;;;1177           for(s32 ia=0; ia<8; ia++) {
;;;1178             for(s32 ja=0; ja<8; ja++) {
;;;1179               AtA_raw[ia][ja] = 0;
;;;1180             }
;;;1181             Atb_t_raw[ia] = 0;
;;;1182           }
;;;1183   #else // ARM optimized
;;;1184           f32 AtA_raw00 = 0, AtA_raw01 = 0, AtA_raw02 = 0, AtA_raw06 = 0, AtA_raw07 = 0;
00008c  ed9f9acd          VLDR     s18,|L23.964|
;;;1185           f32 AtA_raw11 = 0, AtA_raw12 = 0, AtA_raw16 = 0, AtA_raw17 = 0;
;;;1186           f32 AtA_raw22 = 0, AtA_raw26 = 0, AtA_raw27 = 0;
;;;1187           f32 AtA_raw66 = 0, AtA_raw67 = 0;
;;;1188           f32 AtA_raw77 = 0;
;;;1189   
;;;1190           f32 Atb_t_raw0 = 0, Atb_t_raw1 = 0, Atb_t_raw2 = 0, Atb_t_raw6 = 0, Atb_t_raw7 = 0;
;;;1191   #endif // #if !defined(USE_ARM_ACCELERATION) ... #else
;;;1192   
;;;1193           const Point<s16> * restrict pTemplatePoints = templatePoints.Pointer(0);
;;;1194           const Point<s16> * restrict pNewPoints = newPoints.Pointer(0);
;;;1195           const s32 * restrict pYStartIndexes = yStartIndexes.Pointer(0,0);
000090  2000              MOVS     r0,#0
000092  ed8d9a00          VSTR     s18,[sp,#0]           ;1184
000096  ed8d9a01          VSTR     s18,[sp,#4]           ;1184
00009a  ed8d9a02          VSTR     s18,[sp,#8]           ;1184
00009e  ed8d9a03          VSTR     s18,[sp,#0xc]         ;1184
0000a2  ed8d9a04          VSTR     s18,[sp,#0x10]        ;1184
0000a6  ed8d9a05          VSTR     s18,[sp,#0x14]        ;1185
0000aa  68b2              LDR      r2,[r6,#8]            ;1185
0000ac  6931              LDR      r1,[r6,#0x10]         ;1185
;;;1196   
;;;1197           for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++) {
0000ae  4606              MOV      r6,r0
0000b0  fb001a02          MLA      r10,r0,r2,r1
0000b4  9809              LDR      r0,[sp,#0x24]
0000b6  f8d8b030          LDR      r11,[r8,#0x30]
0000ba  6b3f              LDR      r7,[r7,#0x30]
0000bc  eef0fa49          VMOV.F32 s31,s18               ;1185
0000c0  eeb0fa49          VMOV.F32 s30,s18               ;1185
0000c4  eef0ea49          VMOV.F32 s29,s18               ;1185
0000c8  eeb0ea49          VMOV.F32 s28,s18               ;1186
0000cc  eef0da49          VMOV.F32 s27,s18               ;1186
0000d0  eeb0da49          VMOV.F32 s26,s18               ;1186
0000d4  eef0ca49          VMOV.F32 s25,s18               ;1187
0000d8  eeb0ca49          VMOV.F32 s24,s18               ;1187
0000dc  eef0ba49          VMOV.F32 s23,s18               ;1188
0000e0  eeb0ba49          VMOV.F32 s22,s18               ;1190
0000e4  eef0aa49          VMOV.F32 s21,s18               ;1190
0000e8  eeb0aa49          VMOV.F32 s20,s18               ;1190
0000ec  eef09a49          VMOV.F32 s19,s18               ;1190
0000f0  2800              CMP      r0,#0
0000f2  dd7d              BLE      |L23.496|
                  |L23.244|
;;;1198             const f32 xr = static_cast<f32>(pTemplatePoints[iPoint].x);
0000f4  f93b0026          LDRSH    r0,[r11,r6,LSL #2]
;;;1199             const f32 yr = static_cast<f32>(pTemplatePoints[iPoint].y);
;;;1200   
;;;1201             //
;;;1202             // Warp x and y based on the current homography
;;;1203             //
;;;1204   
;;;1205             // Subtract the center offset
;;;1206             const f32 xc = xr - centerOffset.x;
0000f8  edd90a00          VLDR     s1,[r9,#0]
0000fc  ee000a10          VMOV     s0,r0                 ;1198
000100  eb0b0086          ADD      r0,r11,r6,LSL #2      ;1199
000104  eeb81ac0          VCVT.F32.S32 s2,s0                 ;1198
000108  f9b00002          LDRSH    r0,[r0,#2]            ;1199
00010c  ee000a10          VMOV     s0,r0                 ;1199
000110  ee718a60          VSUB.F32 s17,s2,s1
;;;1207             const f32 yc = yr - centerOffset.y;
000114  ed991a01          VLDR     s2,[r9,#4]
000118  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1199
00011c  ee308a41          VSUB.F32 s16,s0,s2
;;;1208   
;;;1209             // Projective warp
;;;1210             const f32 wpi = 1.0f / (h20*xc + h21*yc + h22);
000120  ed9d0a0c          VLDR     s0,[sp,#0x30]
000124  ed9d1a0b          VLDR     s2,[sp,#0x2c]
000128  ee200a28          VMUL.F32 s0,s0,s17
00012c  ee010a08          VMLA.F32 s0,s2,s16
000130  eeb71a00          VMOV.F32 s2,#1.00000000
000134  ee701a01          VADD.F32 s3,s0,s2
000138  ee810a21          VDIV.F32 s0,s2,s3
;;;1211             const f32 warpedX = (h00*xc + h01*yc + h02) * wpi;
00013c  ed9d1a12          VLDR     s2,[sp,#0x48]
000140  ee611a28          VMUL.F32 s3,s2,s17
000144  ed9d1a11          VLDR     s2,[sp,#0x44]
000148  ee411a08          VMLA.F32 s3,s2,s16
00014c  ed9d1a10          VLDR     s2,[sp,#0x40]
000150  ee311a81          VADD.F32 s2,s3,s2
000154  ee211a00          VMUL.F32 s2,s2,s0
000158  ed8d1a08          VSTR     s2,[sp,#0x20]
;;;1212             const f32 warpedY = (h10*xc + h11*yc + h12) * wpi;
00015c  ed9d1a0f          VLDR     s2,[sp,#0x3c]
000160  ee611a28          VMUL.F32 s3,s2,s17
000164  ed9d1a0e          VLDR     s2,[sp,#0x38]
000168  ee411a08          VMLA.F32 s3,s2,s16
00016c  ed9d1a0d          VLDR     s2,[sp,#0x34]
000170  ee311a81          VADD.F32 s2,s3,s2
000174  ee210a00          VMUL.F32 s0,s2,s0
000178  ed8d0a0a          VSTR     s0,[sp,#0x28]
;;;1213   
;;;1214             // TODO: verify the -0.5f is correct
;;;1215             const s32 warpedXrounded = RoundS32_minusPointFive(warpedX + centerOffset.x);
00017c  ed9d1a08          VLDR     s2,[sp,#0x20]
000180  ee300a81          VADD.F32 s0,s1,s2
000184  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
;;;1216             const s32 warpedYrounded = RoundS32_minusPointFive(warpedY + centerOffset.y);
000188  edd90a01          VLDR     s1,[r9,#4]
00018c  ed9d0a0a          VLDR     s0,[sp,#0x28]
000190  4680              MOV      r8,r0                 ;1215
000192  ee300a80          VADD.F32 s0,s1,s0
000196  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
00019a  1e01              SUBS     r1,r0,#0
;;;1217   
;;;1218             if(warpedYrounded >= 0 && warpedYrounded < imageHeight) {
00019c  bfa4              ITT      GE
00019e  9830              LDRGE    r0,[sp,#0xc0]
0001a0  4288              CMPGE    r0,r1
0001a2  dd6a              BLE      |L23.634|
;;;1219               const s32 minX = warpedXrounded - maxMatchingDistance;
0001a4  9823              LDR      r0,[sp,#0x8c]
0001a6  eba80c00          SUB      r12,r8,r0
;;;1220               const s32 maxX = warpedXrounded + maxMatchingDistance;
0001aa  eb080300          ADD      r3,r8,r0
;;;1221   
;;;1222               s32 curIndex = pYStartIndexes[warpedYrounded];
0001ae  f85a0021          LDR      r0,[r10,r1,LSL #2]
;;;1223               const s32 endIndex = pYStartIndexes[warpedYrounded+1];
0001b2  eb0a0181          ADD      r1,r10,r1,LSL #2
0001b6  684a              LDR      r2,[r1,#4]
                  |L23.440|
;;;1224   
;;;1225               // Find the start of the valid matches
;;;1226               while( (curIndex<endIndex) && (pNewPoints[curIndex].x<minX) ) {
0001b8  4290              CMP      r0,r2
0001ba  bfbe              ITTT     LT
0001bc  f9371020          LDRSHLT  r1,[r7,r0,LSL #2]
0001c0  4561              CMPLT    r1,r12
;;;1227                 curIndex++;
0001c2  1c40              ADDLT    r0,r0,#1
0001c4  dbf8              BLT      |L23.440|
0001c6  eeb72a00          VMOV.F32 s4,#1.00000000        ;1164
                  |L23.458|
;;;1228               }
;;;1229   
;;;1230               // For every valid match, increment the sum and counter
;;;1231               while( (curIndex<endIndex) && (pNewPoints[curIndex].x<=maxX) ) {
0001ca  4290              CMP      r0,r2
0001cc  da55              BGE      |L23.634|
0001ce  f9371020          LDRSH    r1,[r7,r0,LSL #2]
0001d2  428b              CMP      r3,r1
0001d4  db51              BLT      |L23.634|
;;;1232                 const s32 offset = pNewPoints[curIndex].x - warpedXrounded;
0001d6  eba10108          SUB      r1,r1,r8
;;;1233                 const f32 xp = warpedX + static_cast<f32>(offset);
0001da  ee001a10          VMOV     s0,r1
0001de  eddd0a08          VLDR     s1,[sp,#0x20]
0001e2  eeb80ac0          VCVT.F32.S32 s0,s0
0001e6  ee301a80          VADD.F32 s2,s1,s0
;;;1234   
;;;1235   #if !defined(USE_ARM_ACCELERATION) // natural C
;;;1236                 const f32 aValues[8] = {xc, yc, 1, 0, 0, 0, -xc*xp, -yc*xp};
;;;1237   
;;;1238                 const f32 bValue = xp;
;;;1239   
;;;1240                 for(s32 ia=0; ia<8; ia++) {
;;;1241                   for(s32 ja=ia; ja<8; ja++) {
;;;1242                     AtA_raw[ia][ja] += aValues[ia] * aValues[ja];
;;;1243                   }
;;;1244   
;;;1245                   Atb_t_raw[ia] += aValues[ia] * bValue;
;;;1246                 }
;;;1247   #else // ARM optimized
;;;1248                 const f32 aValues6 = -xc*xp;
0001ea  ee680ac1          VNMUL.F32 s1,s17,s2
;;;1249                 const f32 aValues7 = -yc*xp;
0001ee  e000              B        |L23.498|
                  |L23.496|
0001f0  e048              B        |L23.644|
                  |L23.498|
;;;1250   
;;;1251                 AtA_raw00 += xc * xc;
0001f2  eddd1a00          VLDR     s3,[sp,#0]
0001f6  ee280a41          VNMUL.F32 s0,s16,s2             ;1249
;;;1252                 AtA_raw01 += xc * yc;
;;;1253                 AtA_raw02 += xc;
;;;1254                 AtA_raw06 += xc * aValues6;
;;;1255                 AtA_raw07 += xc * aValues7;
;;;1256   
;;;1257                 AtA_raw11 += yc * yc;
;;;1258                 AtA_raw12 += yc;
;;;1259                 AtA_raw16 += yc * aValues6;
0001fa  ee08fa20          VMLA.F32 s30,s16,s1
0001fe  ee481aa8          VMLA.F32 s3,s17,s17            ;1251
;;;1260                 AtA_raw17 += yc * aValues7;
;;;1261   
;;;1262                 AtA_raw22 += 1;
;;;1263                 AtA_raw26 += aValues6;
;;;1264                 AtA_raw27 += aValues7;
;;;1265   
;;;1266                 AtA_raw66 += aValues6 * aValues6;
000202  ee40caa0          VMLA.F32 s25,s1,s1
000206  ee48ea00          VMLA.F32 s29,s16,s0            ;1260
;;;1267                 AtA_raw67 += aValues6 * aValues7;
00020a  ee00ca80          VMLA.F32 s24,s1,s0
;;;1268   
;;;1269                 AtA_raw77 += aValues7 * aValues7;
00020e  ee40ba00          VMLA.F32 s23,s0,s0
000212  edcd1a00          VSTR     s3,[sp,#0]            ;1251
000216  eddd1a01          VLDR     s3,[sp,#4]            ;1252
;;;1270   
;;;1271                 Atb_t_raw0 += xc * xp;
00021a  ee08ba81          VMLA.F32 s22,s17,s2
;;;1272                 Atb_t_raw1 += yc * xp;
00021e  ee48aa01          VMLA.F32 s21,s16,s2
000222  ee481a88          VMLA.F32 s3,s17,s16            ;1252
;;;1273                 Atb_t_raw2 += xp;
;;;1274                 Atb_t_raw6 += aValues6 * xp;
000226  ee409a81          VMLA.F32 s19,s1,s2
;;;1275                 Atb_t_raw7 += aValues7 * xp;
00022a  ee009a01          VMLA.F32 s18,s0,s2
00022e  ee7ffa88          VADD.F32 s31,s31,s16           ;1258
000232  ee3eea02          VADD.F32 s28,s28,s4            ;1262
000236  edcd1a01          VSTR     s3,[sp,#4]            ;1252
00023a  eddd1a02          VLDR     s3,[sp,#8]            ;1253
00023e  ee7ddaa0          VADD.F32 s27,s27,s1            ;1263
000242  ee3dda00          VADD.F32 s26,s26,s0            ;1264
000246  ee711aa8          VADD.F32 s3,s3,s17             ;1253
00024a  ee3aaa01          VADD.F32 s20,s20,s2            ;1273
;;;1276   #endif // #if !defined(USE_ARM_ACCELERATION) ... #else
;;;1277   
;;;1278                 curIndex++;
00024e  1c40              ADDS     r0,r0,#1
000250  edcd1a02          VSTR     s3,[sp,#8]            ;1253
000254  eddd1a03          VLDR     s3,[sp,#0xc]          ;1254
000258  ee481aa0          VMLA.F32 s3,s17,s1             ;1254
00025c  edcd1a03          VSTR     s3,[sp,#0xc]          ;1254
000260  eddd1a04          VLDR     s3,[sp,#0x10]         ;1255
000264  ee481a80          VMLA.F32 s3,s17,s0             ;1255
000268  edcd1a04          VSTR     s3,[sp,#0x10]         ;1255
00026c  eddd1a05          VLDR     s3,[sp,#0x14]         ;1257
000270  ee481a08          VMLA.F32 s3,s16,s16            ;1257
000274  edcd1a05          VSTR     s3,[sp,#0x14]         ;1257
;;;1279               }
000278  e7a7              B        |L23.458|
                  |L23.634|
00027a  9809              LDR      r0,[sp,#0x24]         ;1197
00027c  1c76              ADDS     r6,r6,#1              ;1197
00027e  4286              CMP      r6,r0                 ;1197
000280  f6ffaf38          BLT      |L23.244|
                  |L23.644|
000284  68a2              LDR      r2,[r4,#8]            ;1197
000286  6921              LDR      r1,[r4,#0x10]         ;1197
;;;1280             } // if(warpedYrounded >= 0 && warpedYrounded < imageHeight)
;;;1281           } // for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++)
;;;1282   
;;;1283   #if !defined(USE_ARM_ACCELERATION) // natural C
;;;1284           for(s32 ia=0; ia<8; ia++) {
;;;1285             for(s32 ja=ia; ja<8; ja++) {
;;;1286               AtA[ia][ja] = AtA_raw[ia][ja];
;;;1287             }
;;;1288             Atb_t[0][ia] = Atb_t_raw[ia];
;;;1289           }
;;;1290   #else // ARM optimized
;;;1291           AtA[0][0] = AtA_raw00; AtA[0][1] = AtA_raw01; AtA[0][2] = AtA_raw02; AtA[0][6] = AtA_raw06; AtA[0][7] = AtA_raw07;
000288  2000              MOVS     r0,#0
00028a  fb001002          MLA      r0,r0,r2,r1
00028e  ed9d0a00          VLDR     s0,[sp,#0]
000292  ed800a00          VSTR     s0,[r0,#0]
000296  68a2              LDR      r2,[r4,#8]
000298  6921              LDR      r1,[r4,#0x10]
00029a  2000              MOVS     r0,#0
00029c  fb001002          MLA      r0,r0,r2,r1
0002a0  ed9d0a01          VLDR     s0,[sp,#4]
0002a4  ed800a01          VSTR     s0,[r0,#4]
0002a8  68a2              LDR      r2,[r4,#8]
0002aa  6921              LDR      r1,[r4,#0x10]
0002ac  2000              MOVS     r0,#0
0002ae  fb001002          MLA      r0,r0,r2,r1
0002b2  ed9d0a02          VLDR     s0,[sp,#8]
0002b6  ed800a02          VSTR     s0,[r0,#8]
0002ba  68a2              LDR      r2,[r4,#8]
0002bc  6921              LDR      r1,[r4,#0x10]
0002be  2000              MOVS     r0,#0
0002c0  fb001002          MLA      r0,r0,r2,r1
0002c4  ed9d0a03          VLDR     s0,[sp,#0xc]
0002c8  ed800a06          VSTR     s0,[r0,#0x18]
0002cc  68a2              LDR      r2,[r4,#8]
0002ce  6921              LDR      r1,[r4,#0x10]
0002d0  2000              MOVS     r0,#0
0002d2  fb001002          MLA      r0,r0,r2,r1
0002d6  ed9d0a04          VLDR     s0,[sp,#0x10]
0002da  ed800a07          VSTR     s0,[r0,#0x1c]
0002de  68a2              LDR      r2,[r4,#8]
0002e0  6921              LDR      r1,[r4,#0x10]
;;;1292           AtA[1][1] = AtA_raw11; AtA[1][2] = AtA_raw12; AtA[1][6] = AtA_raw16; AtA[1][7] = AtA_raw17;
0002e2  2001              MOVS     r0,#1
0002e4  fb001002          MLA      r0,r0,r2,r1
0002e8  ed9d0a05          VLDR     s0,[sp,#0x14]
0002ec  ed800a01          VSTR     s0,[r0,#4]
0002f0  68a2              LDR      r2,[r4,#8]
0002f2  6921              LDR      r1,[r4,#0x10]
0002f4  2001              MOVS     r0,#1
0002f6  fb001002          MLA      r0,r0,r2,r1
0002fa  edc0fa02          VSTR     s31,[r0,#8]
0002fe  68a2              LDR      r2,[r4,#8]
000300  6921              LDR      r1,[r4,#0x10]
000302  2001              MOVS     r0,#1
000304  fb001002          MLA      r0,r0,r2,r1
000308  ed80fa06          VSTR     s30,[r0,#0x18]
00030c  68a2              LDR      r2,[r4,#8]
00030e  6921              LDR      r1,[r4,#0x10]
000310  2001              MOVS     r0,#1
000312  fb001002          MLA      r0,r0,r2,r1
000316  edc0ea07          VSTR     s29,[r0,#0x1c]
00031a  68a2              LDR      r2,[r4,#8]
00031c  6921              LDR      r1,[r4,#0x10]
;;;1293           AtA[2][2] = AtA_raw22; AtA[2][6] = AtA_raw26; AtA[2][7] = AtA_raw27;
00031e  2002              MOVS     r0,#2
000320  fb001002          MLA      r0,r0,r2,r1
000324  ed80ea02          VSTR     s28,[r0,#8]
000328  68a2              LDR      r2,[r4,#8]
00032a  6921              LDR      r1,[r4,#0x10]
00032c  2002              MOVS     r0,#2
00032e  fb001002          MLA      r0,r0,r2,r1
000332  edc0da06          VSTR     s27,[r0,#0x18]
000336  68a2              LDR      r2,[r4,#8]
000338  6921              LDR      r1,[r4,#0x10]
00033a  2002              MOVS     r0,#2
00033c  fb001002          MLA      r0,r0,r2,r1
000340  ed80da07          VSTR     s26,[r0,#0x1c]
000344  68a2              LDR      r2,[r4,#8]
000346  6921              LDR      r1,[r4,#0x10]
;;;1294           AtA[6][6] = AtA_raw66; AtA[6][7] = AtA_raw67;
000348  2006              MOVS     r0,#6
00034a  fb001002          MLA      r0,r0,r2,r1
00034e  edc0ca06          VSTR     s25,[r0,#0x18]
000352  68a2              LDR      r2,[r4,#8]
000354  6921              LDR      r1,[r4,#0x10]
000356  2006              MOVS     r0,#6
000358  fb001002          MLA      r0,r0,r2,r1
00035c  ed80ca07          VSTR     s24,[r0,#0x1c]
000360  68a2              LDR      r2,[r4,#8]
000362  6921              LDR      r1,[r4,#0x10]
;;;1295           AtA[7][7] = AtA_raw77;
000364  2007              MOVS     r0,#7
000366  fb001002          MLA      r0,r0,r2,r1
00036a  edc0ba07          VSTR     s23,[r0,#0x1c]
00036e  68aa              LDR      r2,[r5,#8]
000370  6929              LDR      r1,[r5,#0x10]
;;;1296   
;;;1297           Atb_t[0][0] = Atb_t_raw0; Atb_t[0][1] = Atb_t_raw1; Atb_t[0][2] = Atb_t_raw2; Atb_t[0][6] = Atb_t_raw6; Atb_t[0][7] = Atb_t_raw7;
000372  2000              MOVS     r0,#0
000374  fb001002          MLA      r0,r0,r2,r1
000378  ed80ba00          VSTR     s22,[r0,#0]
00037c  68aa              LDR      r2,[r5,#8]
00037e  6929              LDR      r1,[r5,#0x10]
000380  2000              MOVS     r0,#0
000382  fb001002          MLA      r0,r0,r2,r1
000386  edc0aa01          VSTR     s21,[r0,#4]
00038a  68aa              LDR      r2,[r5,#8]
00038c  6929              LDR      r1,[r5,#0x10]
00038e  2000              MOVS     r0,#0
000390  fb001002          MLA      r0,r0,r2,r1
000394  ed80aa02          VSTR     s20,[r0,#8]
000398  68aa              LDR      r2,[r5,#8]
00039a  6929              LDR      r1,[r5,#0x10]
00039c  2000              MOVS     r0,#0
00039e  fb001002          MLA      r0,r0,r2,r1
0003a2  edc09a06          VSTR     s19,[r0,#0x18]
0003a6  68aa              LDR      r2,[r5,#8]
0003a8  6929              LDR      r1,[r5,#0x10]
0003aa  2000              MOVS     r0,#0
0003ac  fb001002          MLA      r0,r0,r2,r1
0003b0  ed809a07          VSTR     s18,[r0,#0x1c]
;;;1298   #endif // #if !defined(USE_ARM_ACCELERATION) ... #else
;;;1299   
;;;1300           return RESULT_OK;
;;;1301         } // NO_INLINE Result BinaryTracker::FindHorizontalCorrespondences_Projective()
0003b4  b013              ADD      sp,sp,#0x4c
0003b6  2000              MOVS     r0,#0                 ;1300
0003b8  ecbd8b10          VPOP     {d8-d15}
0003bc  b004              ADD      sp,sp,#0x10
0003be  e8bd8ff0          POP      {r4-r11,pc}
;;;1302   
                          ENDP

0003c2  0000              DCW      0x0000
                  |L23.964|
0003c4  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker40IterativelyRefineTrack_Projective_RansacERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiiiiiRiNS0_11MemoryStackESA_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker40IterativelyRefineTrack_Projective_RansacERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiiiiiRiNS0_11MemoryStackESA_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::IterativelyRefineTrack_Projective_Ransac(const Anki::Embedded::EdgeLists&, const Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, int, int, int, int, int, int&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
;;;2152   
;;;2153         Result BinaryTracker::IterativelyRefineTrack_Projective_Ransac(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2154           const EdgeLists &nextImageEdges,
;;;2155           const AllIndexLimits &allLimits,
;;;2156           const s32 matching_maxDistance,
;;;2157           const s32 maxMatchesPerType,
;;;2158           const s32 ransac_maxIterations,
;;;2159           const s32 ransac_numSamplesPerType,
;;;2160           const s32 ransac_inlinerDistance,
;;;2161           s32 &bestNumInliers,
;;;2162           MemoryStack fastScratch,
;;;2163           MemoryStack slowScratch)
;;;2164         {
000004  460e              MOV      r6,r1
000006  ed2d8b02          VPUSH    {d8}
00000a  f5ad7d51          SUB      sp,sp,#0x344
00000e  4605              MOV      r5,r0
;;;2165           Result lastResult;
;;;2166   
;;;2167           Array<f32> AtA_xDecreasing(8,8,fastScratch);
000010  2300              MOVS     r3,#0
000012  461a              MOV      r2,r3
000014  2101              MOVS     r1,#1
000016  a8c8              ADD      r0,sp,#0x320
000018  f8dda398          LDR      r10,[sp,#0x398]
00001c  f8dd9390          LDR      r9,[sp,#0x390]
000020  f8dd8388          LDR      r8,[sp,#0x388]
000024  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000028  6800              LDR      r0,[r0,#0]
00002a  9000              STR      r0,[sp,#0]
00002c  2208              MOVS     r2,#8
00002e  4611              MOV      r1,r2
000030  a876              ADD      r0,sp,#0x1d8
000032  9be5              LDR      r3,[sp,#0x394]
000034  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2168           Array<f32> AtA_xIncreasing(8,8,fastScratch);
000038  2300              MOVS     r3,#0
00003a  461a              MOV      r2,r3
00003c  2101              MOVS     r1,#1
00003e  a8c9              ADD      r0,sp,#0x324
000040  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000044  6800              LDR      r0,[r0,#0]
000046  9000              STR      r0,[sp,#0]
000048  2208              MOVS     r2,#8
00004a  4611              MOV      r1,r2
00004c  a87b              ADD      r0,sp,#0x1ec
00004e  9be5              LDR      r3,[sp,#0x394]
000050  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2169           Array<f32> AtA_yDecreasing(8,8,fastScratch);
000054  2300              MOVS     r3,#0
000056  461a              MOV      r2,r3
000058  2101              MOVS     r1,#1
00005a  a8ca              ADD      r0,sp,#0x328
00005c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000060  6800              LDR      r0,[r0,#0]
000062  9000              STR      r0,[sp,#0]
000064  2208              MOVS     r2,#8
000066  4611              MOV      r1,r2
000068  a880              ADD      r0,sp,#0x200
00006a  9be5              LDR      r3,[sp,#0x394]
00006c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2170           Array<f32> AtA_yIncreasing(8,8,fastScratch);
000070  2300              MOVS     r3,#0
000072  461a              MOV      r2,r3
000074  2101              MOVS     r1,#1
000076  a8cb              ADD      r0,sp,#0x32c
000078  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00007c  6800              LDR      r0,[r0,#0]
00007e  9000              STR      r0,[sp,#0]
000080  2208              MOVS     r2,#8
000082  4611              MOV      r1,r2
000084  a885              ADD      r0,sp,#0x214
000086  9be5              LDR      r3,[sp,#0x394]
000088  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2171   
;;;2172           Array<f32> Atb_t_xDecreasing(1,8,fastScratch);
00008c  2300              MOVS     r3,#0
00008e  461a              MOV      r2,r3
000090  2101              MOVS     r1,#1
000092  a8cc              ADD      r0,sp,#0x330
000094  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000098  6800              LDR      r0,[r0,#0]
00009a  9000              STR      r0,[sp,#0]
00009c  2208              MOVS     r2,#8
00009e  2101              MOVS     r1,#1
0000a0  a88a              ADD      r0,sp,#0x228
0000a2  9be5              LDR      r3,[sp,#0x394]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2173           Array<f32> Atb_t_xIncreasing(1,8,fastScratch);
0000a8  2300              MOVS     r3,#0
0000aa  461a              MOV      r2,r3
0000ac  2101              MOVS     r1,#1
0000ae  a8b9              ADD      r0,sp,#0x2e4
0000b0  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000b4  6800              LDR      r0,[r0,#0]
0000b6  9000              STR      r0,[sp,#0]
0000b8  2208              MOVS     r2,#8
0000ba  2101              MOVS     r1,#1
0000bc  a88f              ADD      r0,sp,#0x23c
0000be  9be5              LDR      r3,[sp,#0x394]
0000c0  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2174           Array<f32> Atb_t_yDecreasing(1,8,fastScratch);
0000c4  2300              MOVS     r3,#0
0000c6  461a              MOV      r2,r3
0000c8  2101              MOVS     r1,#1
0000ca  a8ba              ADD      r0,sp,#0x2e8
0000cc  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000d0  6800              LDR      r0,[r0,#0]
0000d2  9000              STR      r0,[sp,#0]
0000d4  2208              MOVS     r2,#8
0000d6  2101              MOVS     r1,#1
0000d8  a894              ADD      r0,sp,#0x250
0000da  9be5              LDR      r3,[sp,#0x394]
0000dc  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2175           Array<f32> Atb_t_yIncreasing(1,8,fastScratch);
0000e0  2300              MOVS     r3,#0
0000e2  461a              MOV      r2,r3
0000e4  2101              MOVS     r1,#1
0000e6  a8bb              ADD      r0,sp,#0x2ec
0000e8  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000ec  6800              LDR      r0,[r0,#0]
0000ee  9000              STR      r0,[sp,#0]
0000f0  2208              MOVS     r2,#8
0000f2  2101              MOVS     r1,#1
0000f4  a899              ADD      r0,sp,#0x264
0000f6  9be5              LDR      r3,[sp,#0x394]
0000f8  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2176   
;;;2177           Array<f32> originalHomography(3,3,slowScratch);
0000fc  2300              MOVS     r3,#0
0000fe  461a              MOV      r2,r3
000100  2101              MOVS     r1,#1
000102  a8bc              ADD      r0,sp,#0x2f0
000104  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000108  6800              LDR      r0,[r0,#0]
00010a  2203              MOVS     r2,#3
00010c  9000              STR      r0,[sp,#0]
00010e  4653              MOV      r3,r10
000110  4611              MOV      r1,r2
000112  a8a8              ADD      r0,sp,#0x2a0
000114  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2178           originalHomography.Set(this->transformation.get_homography());
000118  f50570a8          ADD      r0,r5,#0x150
00011c  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
000120  4601              MOV      r1,r0
000122  a8a8              ADD      r0,sp,#0x2a0
000124  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE3SetERKS2_ ; Anki::Embedded::Array<float>::Set(const Anki::Embedded::Array<float>&)
000128  2300              MOVS     r3,#0
;;;2179   
;;;2180           Array<f32> bestHomography = Eye<f32>(3,3,slowScratch);
00012a  2703              MOVS     r7,#3
00012c  f50d7b2d          ADD      r11,sp,#0x2b4
000130  463c              MOV      r4,r7
000132  461a              MOV      r2,r3
000134  4619              MOV      r1,r3
000136  a86f              ADD      r0,sp,#0x1bc
000138  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00013c  6800              LDR      r0,[r0,#0]
00013e  9000              STR      r0,[sp,#0]
000140  4653              MOV      r3,r10
000142  4622              MOV      r2,r4
000144  4639              MOV      r1,r7
000146  a802              ADD      r0,sp,#8
000148  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00014c  9806              LDR      r0,[sp,#0x18]
00014e  ac02              ADD      r4,sp,#8
000150  eeb78a00          VMOV.F32 s16,#1.00000000
000154  2800              CMP      r0,#0
000156  d078              BEQ      |L24.586|
000158  9802              LDR      r0,[sp,#8]
00015a  2800              CMP      r0,#0
00015c  bfa4              ITT      GE
00015e  9803              LDRGE    r0,[sp,#0xc]
000160  2800              CMPGE    r0,#0
000162  db72              BLT      |L24.586|
000164  2100              MOVS     r1,#0
000166  4620              MOV      r0,r4
000168  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00016c  4607              MOV      r7,r0
00016e  4620              MOV      r0,r4
000170  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
000174  2000              MOVS     r0,#0
000176  2f00              CMP      r7,#0
000178  dd0a              BLE      |L24.400|
                  |L24.378|
00017a  68a2              LDR      r2,[r4,#8]
00017c  6921              LDR      r1,[r4,#0x10]
00017e  fb001102          MLA      r1,r0,r2,r1
000182  eb010180          ADD      r1,r1,r0,LSL #2
000186  1c40              ADDS     r0,r0,#1
000188  ed818a00          VSTR     s16,[r1,#0]
00018c  4287              CMP      r7,r0
00018e  dcf4              BGT      |L24.378|
                  |L24.400|
000190  ac02              ADD      r4,sp,#8
000192  e8b4100f          LDM      r4!,{r0-r3,r12}
000196  e8ab100f          STM      r11!,{r0-r3,r12}
;;;2181           bestNumInliers = -1;
00019a  f04f30ff          MOV      r0,#0xffffffff
;;;2182   
;;;2183           FixedLengthList<IndexCorrespondence> matchingIndexes_xDecreasing(maxMatchesPerType, slowScratch);
00019e  2300              MOVS     r3,#0
0001a0  f8c90000          STR      r0,[r9,#0]
0001a4  461a              MOV      r2,r3
0001a6  2101              MOVS     r1,#1
0001a8  a8bc              ADD      r0,sp,#0x2f0
0001aa  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001ae  6803              LDR      r3,[r0,#0]
0001b0  4652              MOV      r2,r10
0001b2  a83b              ADD      r0,sp,#0xec
0001b4  99e0              LDR      r1,[sp,#0x380]
0001b6  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2184           FixedLengthList<IndexCorrespondence> matchingIndexes_xIncreasing(maxMatchesPerType, slowScratch);
0001ba  2300              MOVS     r3,#0
0001bc  461a              MOV      r2,r3
0001be  2101              MOVS     r1,#1
0001c0  a8bb              ADD      r0,sp,#0x2ec
0001c2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001c6  6803              LDR      r3,[r0,#0]
0001c8  4652              MOV      r2,r10
0001ca  a848              ADD      r0,sp,#0x120
0001cc  99e0              LDR      r1,[sp,#0x380]
0001ce  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2185           FixedLengthList<IndexCorrespondence> matchingIndexes_yDecreasing(maxMatchesPerType, slowScratch);
0001d2  2300              MOVS     r3,#0
0001d4  461a              MOV      r2,r3
0001d6  2101              MOVS     r1,#1
0001d8  a8ba              ADD      r0,sp,#0x2e8
0001da  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001de  6803              LDR      r3,[r0,#0]
0001e0  4652              MOV      r2,r10
0001e2  a855              ADD      r0,sp,#0x154
0001e4  99e0              LDR      r1,[sp,#0x380]
0001e6  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2186           FixedLengthList<IndexCorrespondence> matchingIndexes_yIncreasing(maxMatchesPerType, slowScratch);
0001ea  2300              MOVS     r3,#0
0001ec  461a              MOV      r2,r3
0001ee  2101              MOVS     r1,#1
0001f0  a8b9              ADD      r0,sp,#0x2e4
0001f2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001f6  6803              LDR      r3,[r0,#0]
0001f8  4652              MOV      r2,r10
0001fa  a862              ADD      r0,sp,#0x188
0001fc  99e0              LDR      r1,[sp,#0x380]
0001fe  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;2187   
;;;2188           lastResult = BinaryTracker::FindHorizontalCorrespondences_List(
000202  e9d60134          LDRD     r0,r1,[r6,#0xd0]
000206  ab3b              ADD      r3,sp,#0xec
000208  9ad5              LDR      r2,[sp,#0x354]
00020a  e88d000f          STM      sp,{r0-r3}
00020e  4633              MOV      r3,r6
000210  f1050274          ADD      r2,r5,#0x74
000214  f50571a8          ADD      r1,r5,#0x150
000218  98d6              LDR      r0,[sp,#0x358]
00021a  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindHorizontalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_List(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&)
00021e  0004              MOVS     r4,r0
;;;2189             matching_maxDistance, this->transformation,
;;;2190             this->templateEdges.xDecreasing, nextImageEdges.xDecreasing,
;;;2191             nextImageEdges.imageHeight, nextImageEdges.imageWidth,
;;;2192             allLimits.xDecreasing_yStartIndexes, matchingIndexes_xDecreasing);
;;;2193   
;;;2194           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
000220  d01e              BEQ      |L24.608|
000222  f6400192          MOV      r1,#0x892
000226  48bc              LDR      r0,|L24.1304|
000228  e9cd0100          STRD     r0,r1,[sp,#0]
00022c  a3bb              ADR      r3,|L24.1308|
00022e  a2c7              ADR      r2,|L24.1356|
000230  a1d1              ADR      r1,|L24.1400|
000232  2005              MOVS     r0,#5
000234  f7fffffe          BL       _Anki_Log
000238  4620              MOV      r0,r4
                  |L24.570|
;;;2195             lastResult, "BinaryTracker::IterativelyRefineTrack_Projective_Ransac", "FindHorizontalCorrespondences_List 1 failed");
;;;2196   
;;;2197           lastResult = BinaryTracker::FindHorizontalCorrespondences_List(
;;;2198             matching_maxDistance, this->transformation,
;;;2199             this->templateEdges.xIncreasing, nextImageEdges.xIncreasing,
;;;2200             nextImageEdges.imageHeight, nextImageEdges.imageWidth,
;;;2201             allLimits.xIncreasing_yStartIndexes, matchingIndexes_xIncreasing);
;;;2202   
;;;2203           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2204             lastResult, "BinaryTracker::IterativelyRefineTrack_Projective_Ransac", "FindHorizontalCorrespondences_List 2 failed");
;;;2205   
;;;2206           lastResult = BinaryTracker::FindVerticalCorrespondences_List(
;;;2207             matching_maxDistance, this->transformation,
;;;2208             this->templateEdges.yDecreasing, nextImageEdges.yDecreasing,
;;;2209             nextImageEdges.imageHeight, nextImageEdges.imageWidth,
;;;2210             allLimits.yDecreasing_xStartIndexes, matchingIndexes_yDecreasing);
;;;2211   
;;;2212           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2213             lastResult, "BinaryTracker::IterativelyRefineTrack_Projective_Ransac", "FindVerticalCorrespondences_List 1 failed");
;;;2214   
;;;2215           lastResult = BinaryTracker::FindVerticalCorrespondences_List(
;;;2216             matching_maxDistance, this->transformation,
;;;2217             this->templateEdges.yIncreasing, nextImageEdges.yIncreasing,
;;;2218             nextImageEdges.imageHeight, nextImageEdges.imageWidth,
;;;2219             allLimits.yIncreasing_xStartIndexes, matchingIndexes_yIncreasing);
;;;2220   
;;;2221           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2222             lastResult, "BinaryTracker::IterativelyRefineTrack_Projective_Ransac", "FindVerticalCorrespondences_List 2 failed");
;;;2223   
;;;2224           // First, try a match with all the data
;;;2225   
;;;2226           // TODO: implement this, perhaps with a different search distance. Or perhaps just call the normal function
;;;2227   
;;;2228           // Second, do ransac iterations to try to get a better match
;;;2229   
;;;2230           const s32 num_xDecreasing = matchingIndexes_xDecreasing.get_size();
;;;2231           const s32 num_xIncreasing = matchingIndexes_xIncreasing.get_size();
;;;2232           const s32 num_yDecreasing = matchingIndexes_yDecreasing.get_size();
;;;2233           const s32 num_yIncreasing = matchingIndexes_yIncreasing.get_size();
;;;2234   
;;;2235           FixedLengthList<IndexCorrespondence> sampledMatchingIndexes_xDecreasing(ransac_numSamplesPerType, fastScratch);
;;;2236           FixedLengthList<IndexCorrespondence> sampledMatchingIndexes_xIncreasing(ransac_numSamplesPerType, fastScratch);
;;;2237           FixedLengthList<IndexCorrespondence> sampledMatchingIndexes_yDecreasing(ransac_numSamplesPerType, fastScratch);
;;;2238           FixedLengthList<IndexCorrespondence> sampledMatchingIndexes_yIncreasing(ransac_numSamplesPerType, fastScratch);
;;;2239   
;;;2240           sampledMatchingIndexes_xDecreasing.set_size(ransac_numSamplesPerType);
;;;2241           sampledMatchingIndexes_xIncreasing.set_size(ransac_numSamplesPerType);
;;;2242           sampledMatchingIndexes_yDecreasing.set_size(ransac_numSamplesPerType);
;;;2243           sampledMatchingIndexes_yIncreasing.set_size(ransac_numSamplesPerType);
;;;2244   
;;;2245           const IndexCorrespondence * restrict pMatchingIndexes_xDecreasing = matchingIndexes_xDecreasing.Pointer(0);
;;;2246           const IndexCorrespondence * restrict pMatchingIndexes_xIncreasing = matchingIndexes_xIncreasing.Pointer(0);
;;;2247           const IndexCorrespondence * restrict pMatchingIndexes_yDecreasing = matchingIndexes_yDecreasing.Pointer(0);
;;;2248           const IndexCorrespondence * restrict pMatchingIndexes_yIncreasing = matchingIndexes_yIncreasing.Pointer(0);
;;;2249   
;;;2250           IndexCorrespondence * restrict pSampledMatchingIndexes_xDecreasing = sampledMatchingIndexes_xDecreasing.Pointer(0);
;;;2251           IndexCorrespondence * restrict pSampledMatchingIndexes_xIncreasing = sampledMatchingIndexes_xIncreasing.Pointer(0);
;;;2252           IndexCorrespondence * restrict pSampledMatchingIndexes_yDecreasing = sampledMatchingIndexes_yDecreasing.Pointer(0);
;;;2253           IndexCorrespondence * restrict pSampledMatchingIndexes_yIncreasing = sampledMatchingIndexes_yIncreasing.Pointer(0);
;;;2254   
;;;2255           for(s32 iteration=0; iteration<ransac_maxIterations; iteration++) {
;;;2256             for(s32 iSample=0; iSample<ransac_numSamplesPerType; iSample++) {
;;;2257               const s32 index_xDecreasing = RandS32(0, num_xDecreasing);
;;;2258               const s32 index_xIncreasing = RandS32(0, num_xIncreasing);
;;;2259               const s32 index_yDecreasing = RandS32(0, num_yDecreasing);
;;;2260               const s32 index_yIncreasing = RandS32(0, num_yIncreasing);
;;;2261   
;;;2262               //CoreTechPrint("Samples: %d %d %d %d\n", index_xDecreasing, index_xIncreasing, index_yDecreasing, index_yIncreasing);
;;;2263   
;;;2264               pSampledMatchingIndexes_xDecreasing[iSample] = pMatchingIndexes_xDecreasing[index_xDecreasing];
;;;2265               pSampledMatchingIndexes_xIncreasing[iSample] = pMatchingIndexes_xIncreasing[index_xIncreasing];
;;;2266               pSampledMatchingIndexes_yDecreasing[iSample] = pMatchingIndexes_yDecreasing[index_yDecreasing];
;;;2267               pSampledMatchingIndexes_yIncreasing[iSample] = pMatchingIndexes_yIncreasing[index_yIncreasing];
;;;2268             }
;;;2269   
;;;2270             AtA_xDecreasing.SetZero();
;;;2271             AtA_xIncreasing.SetZero();
;;;2272             AtA_yDecreasing.SetZero();
;;;2273             AtA_yIncreasing.SetZero();
;;;2274   
;;;2275             Atb_t_xDecreasing.SetZero();
;;;2276             Atb_t_xIncreasing.SetZero();
;;;2277             Atb_t_yDecreasing.SetZero();
;;;2278             Atb_t_yIncreasing.SetZero();
;;;2279   
;;;2280             lastResult = BinaryTracker::ApplyHorizontalCorrespondenceList_Projective(sampledMatchingIndexes_xDecreasing, AtA_xDecreasing, Atb_t_xDecreasing);
;;;2281   
;;;2282             AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2283               lastResult, "BinaryTracker::IterativelyRefineTrack_Projective_Ransac", "ApplyHorizontalCorrespondenceList_Projective 1 failed");
;;;2284   
;;;2285             lastResult = BinaryTracker::ApplyHorizontalCorrespondenceList_Projective(sampledMatchingIndexes_xIncreasing, AtA_xIncreasing, Atb_t_xIncreasing);
;;;2286   
;;;2287             AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2288               lastResult, "BinaryTracker::IterativelyRefineTrack_Projective_Ransac", "ApplyHorizontalCorrespondenceList_Projective 2 failed");
;;;2289   
;;;2290             lastResult = BinaryTracker::ApplyVerticalCorrespondenceList_Projective(sampledMatchingIndexes_yDecreasing, AtA_yDecreasing, Atb_t_yDecreasing);
;;;2291   
;;;2292             AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2293               lastResult, "BinaryTracker::IterativelyRefineTrack_Projective_Ransac", "ApplyVerticalCorrespondenceList_Projective 1 failed");
;;;2294   
;;;2295             lastResult = BinaryTracker::ApplyVerticalCorrespondenceList_Projective(sampledMatchingIndexes_yIncreasing, AtA_yIncreasing, Atb_t_yIncreasing);
;;;2296   
;;;2297             AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2298               lastResult, "BinaryTracker::IterativelyRefineTrack_Projective_Ransac", "ApplyVerticalCorrespondenceList_Projective 2 failed");
;;;2299   
;;;2300             // Update the transformation, and count the number of inliers
;;;2301             {
;;;2302               PUSH_MEMORY_STACK(fastScratch);
;;;2303   
;;;2304               Array<f32> newHomography(3, 3, fastScratch);
;;;2305   
;;;2306               Array<f32> AtA(8,8,fastScratch);
;;;2307               Array<f32> Atb_t(1,8,fastScratch);
;;;2308   
;;;2309               // The total AtA and Atb matrices are just the elementwise sums of their partial versions
;;;2310               for(s32 y=0; y<8; y++) {
;;;2311                 for(s32 x=0; x<8; x++) {
;;;2312                   AtA[y][x] = AtA_xDecreasing[y][x] + AtA_xIncreasing[y][x] + AtA_yDecreasing[y][x] + AtA_yIncreasing[y][x];
;;;2313                 }
;;;2314   
;;;2315                 Atb_t[0][y] = Atb_t_xDecreasing[0][y] + Atb_t_xIncreasing[0][y] + Atb_t_yDecreasing[0][y] + Atb_t_yIncreasing[0][y];
;;;2316               }
;;;2317   
;;;2318               Matrix::MakeSymmetric(AtA, false);
;;;2319   
;;;2320               //AtA.Print("AtA");
;;;2321               //Atb_t.Print("Atb_t");
;;;2322               bool numericalFailure;
;;;2323               lastResult = Matrix::SolveLeastSquaresWithCholesky<f32>(AtA, Atb_t, false, numericalFailure);
;;;2324   
;;;2325               //Atb_t.Print("result");
;;;2326   
;;;2327               AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2328                 lastResult, "BinaryTracker::IterativelyRefineTrack_Projective_Ransac", "SolveLeastSquaresWithCholesky failed");
;;;2329   
;;;2330               if(!numericalFailure) {
;;;2331                 const f32 * restrict pAtb_t = Atb_t.Pointer(0,0);
;;;2332   
;;;2333                 newHomography[0][0] = pAtb_t[0]; newHomography[0][1] = pAtb_t[1]; newHomography[0][2] = pAtb_t[2];
;;;2334                 newHomography[1][0] = pAtb_t[3]; newHomography[1][1] = pAtb_t[4]; newHomography[1][2] = pAtb_t[5];
;;;2335                 newHomography[2][0] = pAtb_t[6]; newHomography[2][1] = pAtb_t[7]; newHomography[2][2] = 1.0f;
;;;2336   
;;;2337                 //newHomography.Print("newHomography");
;;;2338   
;;;2339                 this->transformation.set_homography(newHomography);
;;;2340   
;;;2341                 s32 numInliers;
;;;2342                 lastResult = VerifyTrack(nextImageEdges, allLimits, ransac_inlinerDistance, numInliers);
;;;2343   
;;;2344                 AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK,
;;;2345                   lastResult, "BinaryTracker::IterativelyRefineTrack_Projective_Ransac", "VerifyTrack failed");
;;;2346   
;;;2347                 if(numInliers > bestNumInliers) {
;;;2348                   bestNumInliers = numInliers;
;;;2349                   bestHomography.Set(this->transformation.get_homography());
;;;2350                   //CoreTechPrint("inliers: %d\n", numInliers);
;;;2351                   //bestHomography.Print("bestHomography");
;;;2352                 }
;;;2353               } // if(!numericalFailure)
;;;2354   
;;;2355               this->transformation.set_homography(originalHomography);
;;;2356             } // Update the transformation, and count the number of inliers
;;;2357           } // for(s32 iteration=0; iteration<ransac_maxIterations; iteration++)
;;;2358   
;;;2359           this->transformation.set_homography(bestHomography);
;;;2360   
;;;2361           return RESULT_OK;
;;;2362         }
00023a  f50d7d51          ADD      sp,sp,#0x344
00023e  ecbd8b02          VPOP     {d8}
000242  b004              ADD      sp,sp,#0x10
000244  e8bd8ff0          POP      {r4-r11,pc}
000248  e7ff              B        |L24.586|
                  |L24.586|
00024a  213c              MOVS     r1,#0x3c
00024c  48d8              LDR      r0,|L24.1456|
00024e  e9cd0100          STRD     r0,r1,[sp,#0]
000252  a3d8              ADR      r3,|L24.1460|
000254  a2e7              ADR      r2,|L24.1524|
000256  a1eb              ADR      r1,|L24.1540|
000258  2005              MOVS     r0,#5
00025a  f7fffffe          BL       _Anki_Log
00025e  e797              B        |L24.400|
                  |L24.608|
000260  98d5              LDR      r0,[sp,#0x354]        ;2197
000262  aa48              ADD      r2,sp,#0x120          ;2197
000264  f1000314          ADD      r3,r0,#0x14           ;2197
000268  e9d60134          LDRD     r0,r1,[r6,#0xd0]      ;2197
00026c  9203              STR      r2,[sp,#0xc]          ;2197
00026e  9000              STR      r0,[sp,#0]            ;2197
000270  e9cd1301          STRD     r1,r3,[sp,#4]         ;2197
000274  f1060334          ADD      r3,r6,#0x34           ;2197
000278  f10502a8          ADD      r2,r5,#0xa8           ;2197
00027c  f50571a8          ADD      r1,r5,#0x150          ;2197
000280  98d6              LDR      r0,[sp,#0x358]        ;2197
000282  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindHorizontalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_List(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&)
000286  0004              MOVS     r4,r0                 ;2197
000288  d00c              BEQ      |L24.676|
00028a  f640019b          MOV      r1,#0x89b             ;2203
00028e  48a2              LDR      r0,|L24.1304|
000290  e9cd0100          STRD     r0,r1,[sp,#0]         ;2203
000294  a3a1              ADR      r3,|L24.1308|
000296  a2dc              ADR      r2,|L24.1544|
000298  a1b7              ADR      r1,|L24.1400|
00029a  2005              MOVS     r0,#5                 ;2203
00029c  f7fffffe          BL       _Anki_Log
0002a0  4620              MOV      r0,r4                 ;2203
0002a2  e7ca              B        |L24.570|
                  |L24.676|
0002a4  98d5              LDR      r0,[sp,#0x354]        ;2206
0002a6  aa55              ADD      r2,sp,#0x154          ;2206
0002a8  f1000328          ADD      r3,r0,#0x28           ;2206
0002ac  e9d60134          LDRD     r0,r1,[r6,#0xd0]      ;2206
0002b0  9203              STR      r2,[sp,#0xc]          ;2206
0002b2  9000              STR      r0,[sp,#0]            ;2206
0002b4  e9cd1301          STRD     r1,r3,[sp,#4]         ;2206
0002b8  f1060368          ADD      r3,r6,#0x68           ;2206
0002bc  f10502dc          ADD      r2,r5,#0xdc           ;2206
0002c0  f50571a8          ADD      r1,r5,#0x150          ;2206
0002c4  98d6              LDR      r0,[sp,#0x358]        ;2206
0002c6  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker32FindVerticalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_List(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&)
0002ca  0004              MOVS     r4,r0                 ;2206
0002cc  d00c              BEQ      |L24.744|
0002ce  f64001a4          MOV      r1,#0x8a4             ;2212
0002d2  4891              LDR      r0,|L24.1304|
0002d4  e9cd0100          STRD     r0,r1,[sp,#0]         ;2212
0002d8  a390              ADR      r3,|L24.1308|
0002da  a2d6              ADR      r2,|L24.1588|
0002dc  a1a6              ADR      r1,|L24.1400|
0002de  2005              MOVS     r0,#5                 ;2212
0002e0  f7fffffe          BL       _Anki_Log
0002e4  4620              MOV      r0,r4                 ;2212
0002e6  e7a8              B        |L24.570|
                  |L24.744|
0002e8  98d5              LDR      r0,[sp,#0x354]        ;2215
0002ea  aa62              ADD      r2,sp,#0x188          ;2215
0002ec  f100033c          ADD      r3,r0,#0x3c           ;2215
0002f0  e9d60134          LDRD     r0,r1,[r6,#0xd0]      ;2215
0002f4  9203              STR      r2,[sp,#0xc]          ;2215
0002f6  9000              STR      r0,[sp,#0]            ;2215
0002f8  e9cd1301          STRD     r1,r3,[sp,#4]         ;2215
0002fc  f106039c          ADD      r3,r6,#0x9c           ;2215
000300  f5057288          ADD      r2,r5,#0x110          ;2215
000304  f50571a8          ADD      r1,r5,#0x150          ;2215
000308  98d6              LDR      r0,[sp,#0x358]        ;2215
00030a  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker32FindVerticalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE ; Anki::Embedded::TemplateTracker::BinaryTracker::FindVerticalCorrespondences_List(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&)
00030e  0004              MOVS     r4,r0                 ;2215
000310  d00c              BEQ      |L24.812|
000312  f64001ad          MOV      r1,#0x8ad             ;2221
000316  4880              LDR      r0,|L24.1304|
000318  e9cd0100          STRD     r0,r1,[sp,#0]         ;2221
00031c  a37f              ADR      r3,|L24.1308|
00031e  a2d0              ADR      r2,|L24.1632|
000320  a195              ADR      r1,|L24.1400|
000322  2005              MOVS     r0,#5                 ;2221
000324  f7fffffe          BL       _Anki_Log
000328  4620              MOV      r0,r4                 ;2221
00032a  e786              B        |L24.570|
                  |L24.812|
00032c  983e              LDR      r0,[sp,#0xf8]         ;2230
00032e  90bf              STR      r0,[sp,#0x2fc]        ;2230
000330  984b              LDR      r0,[sp,#0x12c]        ;2231
000332  90c0              STR      r0,[sp,#0x300]        ;2231
000334  9858              LDR      r0,[sp,#0x160]        ;2232
000336  90c1              STR      r0,[sp,#0x304]        ;2232
000338  9865              LDR      r0,[sp,#0x194]        ;2233
00033a  2300              MOVS     r3,#0                 ;2235
00033c  90c2              STR      r0,[sp,#0x308]        ;2235
00033e  461a              MOV      r2,r3                 ;2235
000340  2101              MOVS     r1,#1                 ;2235
000342  a8bc              ADD      r0,sp,#0x2f0          ;2235
000344  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000348  6803              LDR      r3,[r0,#0]            ;2235
00034a  4641              MOV      r1,r8                 ;2235
00034c  a807              ADD      r0,sp,#0x1c           ;2235
00034e  9ae5              LDR      r2,[sp,#0x394]        ;2235
000350  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000354  2300              MOVS     r3,#0                 ;2236
000356  461a              MOV      r2,r3                 ;2236
000358  2101              MOVS     r1,#1                 ;2236
00035a  a8bb              ADD      r0,sp,#0x2ec          ;2236
00035c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000360  6803              LDR      r3,[r0,#0]            ;2236
000362  4641              MOV      r1,r8                 ;2236
000364  a814              ADD      r0,sp,#0x50           ;2236
000366  9ae5              LDR      r2,[sp,#0x394]        ;2236
000368  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00036c  2300              MOVS     r3,#0                 ;2237
00036e  461a              MOV      r2,r3                 ;2237
000370  2101              MOVS     r1,#1                 ;2237
000372  a8ba              ADD      r0,sp,#0x2e8          ;2237
000374  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000378  6803              LDR      r3,[r0,#0]            ;2237
00037a  4641              MOV      r1,r8                 ;2237
00037c  a821              ADD      r0,sp,#0x84           ;2237
00037e  9ae5              LDR      r2,[sp,#0x394]        ;2237
000380  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000384  2300              MOVS     r3,#0                 ;2238
000386  461a              MOV      r2,r3                 ;2238
000388  2101              MOVS     r1,#1                 ;2238
00038a  a8b9              ADD      r0,sp,#0x2e4          ;2238
00038c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000390  6803              LDR      r3,[r0,#0]            ;2238
000392  4641              MOV      r1,r8                 ;2238
000394  a82e              ADD      r0,sp,#0xb8           ;2238
000396  9ae5              LDR      r2,[sp,#0x394]        ;2238
000398  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00039c  4641              MOV      r1,r8                 ;2240
00039e  a807              ADD      r0,sp,#0x1c           ;2240
0003a0  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::set_size(int)
0003a4  4641              MOV      r1,r8                 ;2241
0003a6  a814              ADD      r0,sp,#0x50           ;2241
0003a8  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::set_size(int)
0003ac  4641              MOV      r1,r8                 ;2242
0003ae  a821              ADD      r0,sp,#0x84           ;2242
0003b0  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::set_size(int)
0003b4  4641              MOV      r1,r8                 ;2243
0003b6  a82e              ADD      r0,sp,#0xb8           ;2243
0003b8  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::set_size(int)
0003bc  9847              LDR      r0,[sp,#0x11c]        ;2245
0003be  90bd              STR      r0,[sp,#0x2f4]        ;2245
0003c0  9854              LDR      r0,[sp,#0x150]        ;2246
0003c2  90be              STR      r0,[sp,#0x2f8]        ;2246
0003c4  9861              LDR      r0,[sp,#0x184]        ;2247
0003c6  9001              STR      r0,[sp,#4]            ;2247
0003c8  986e              LDR      r0,[sp,#0x1b8]        ;2248
0003ca  90c3              STR      r0,[sp,#0x30c]        ;2248
0003cc  9813              LDR      r0,[sp,#0x4c]         ;2250
0003ce  90c4              STR      r0,[sp,#0x310]        ;2250
0003d0  9820              LDR      r0,[sp,#0x80]         ;2251
0003d2  90c5              STR      r0,[sp,#0x314]        ;2251
0003d4  98e1              LDR      r0,[sp,#0x384]        ;2255
0003d6  2700              MOVS     r7,#0                 ;2255
0003d8  f8ddb0b4          LDR      r11,[sp,#0xb4]        ;2255
0003dc  f8dda0e8          LDR      r10,[sp,#0xe8]        ;2255
0003e0  2800              CMP      r0,#0                 ;2255
0003e2  f34082e4          BLE.W    |L24.2478|
                  |L24.998|
0003e6  2400              MOVS     r4,#0                 ;2256
0003e8  f1b80f00          CMP      r8,#0                 ;2256
0003ec  dd6f              BLE      |L24.1230|
                  |L24.1006|
0003ee  2000              MOVS     r0,#0                 ;2257
0003f0  99bf              LDR      r1,[sp,#0x2fc]        ;2257
0003f2  f7fffffe          BL       _ZN4Anki8Embedded7RandS32Eii ; Anki::Embedded::RandS32(int, int)
0003f6  9004              STR      r0,[sp,#0x10]         ;2258
0003f8  2000              MOVS     r0,#0                 ;2258
0003fa  99c0              LDR      r1,[sp,#0x300]        ;2258
0003fc  f7fffffe          BL       _ZN4Anki8Embedded7RandS32Eii ; Anki::Embedded::RandS32(int, int)
000400  9006              STR      r0,[sp,#0x18]         ;2259
000402  2000              MOVS     r0,#0                 ;2259
000404  99c1              LDR      r1,[sp,#0x304]        ;2259
000406  f7fffffe          BL       _ZN4Anki8Embedded7RandS32Eii ; Anki::Embedded::RandS32(int, int)
00040a  9002              STR      r0,[sp,#8]            ;2260
00040c  2000              MOVS     r0,#0                 ;2260
00040e  99c2              LDR      r1,[sp,#0x308]        ;2260
000410  f7fffffe          BL       _ZN4Anki8Embedded7RandS32Eii ; Anki::Embedded::RandS32(int, int)
000414  4601              MOV      r1,r0                 ;2260
000416  98c4              LDR      r0,[sp,#0x310]        ;2264
000418  9abd              LDR      r2,[sp,#0x2f4]        ;2264
00041a  eb001304          ADD      r3,r0,r4,LSL #4       ;2264
00041e  9804              LDR      r0,[sp,#0x10]         ;2264
000420  eb021000          ADD      r0,r2,r0,LSL #4       ;2264
000424  ed900a00          VLDR     s0,[r0,#0]            ;2264
000428  ed830a00          VSTR     s0,[r3,#0]            ;2264
00042c  ed900a01          VLDR     s0,[r0,#4]            ;2264
000430  ed830a01          VSTR     s0,[r3,#4]            ;2264
000434  ed900a02          VLDR     s0,[r0,#8]            ;2264
000438  ed830a02          VSTR     s0,[r3,#8]            ;2264
00043c  ed900a03          VLDR     s0,[r0,#0xc]          ;2264
000440  ed830a03          VSTR     s0,[r3,#0xc]          ;2264
000444  98c5              LDR      r0,[sp,#0x314]        ;2265
000446  9abe              LDR      r2,[sp,#0x2f8]        ;2265
000448  eb001304          ADD      r3,r0,r4,LSL #4       ;2265
00044c  9806              LDR      r0,[sp,#0x18]         ;2265
00044e  eb021000          ADD      r0,r2,r0,LSL #4       ;2265
000452  ed900a00          VLDR     s0,[r0,#0]            ;2265
000456  ed830a00          VSTR     s0,[r3,#0]            ;2265
00045a  ed900a01          VLDR     s0,[r0,#4]            ;2265
00045e  ed830a01          VSTR     s0,[r3,#4]            ;2265
000462  ed900a02          VLDR     s0,[r0,#8]            ;2265
000466  ed830a02          VSTR     s0,[r3,#8]            ;2265
00046a  ed900a03          VLDR     s0,[r0,#0xc]          ;2265
00046e  ed830a03          VSTR     s0,[r3,#0xc]          ;2265
000472  e9dd2001          LDRD     r2,r0,[sp,#4]         ;2266
000476  eb021000          ADD      r0,r2,r0,LSL #4       ;2266
00047a  eb0b1304          ADD      r3,r11,r4,LSL #4      ;2266
00047e  ed900a00          VLDR     s0,[r0,#0]            ;2266
000482  ed830a00          VSTR     s0,[r3,#0]            ;2266
000486  ed900a01          VLDR     s0,[r0,#4]            ;2266
00048a  ed830a01          VSTR     s0,[r3,#4]            ;2266
00048e  ed900a02          VLDR     s0,[r0,#8]            ;2266
000492  ed830a02          VSTR     s0,[r3,#8]            ;2266
000496  ed900a03          VLDR     s0,[r0,#0xc]          ;2266
00049a  ed830a03          VSTR     s0,[r3,#0xc]          ;2266
00049e  98c3              LDR      r0,[sp,#0x30c]        ;2267
0004a0  eb0a1304          ADD      r3,r10,r4,LSL #4      ;2267
0004a4  eb001001          ADD      r0,r0,r1,LSL #4       ;2267
0004a8  1c64              ADDS     r4,r4,#1              ;2256
0004aa  ed900a00          VLDR     s0,[r0,#0]            ;2267
0004ae  45a0              CMP      r8,r4                 ;2256
0004b0  ed830a00          VSTR     s0,[r3,#0]            ;2267
0004b4  ed900a01          VLDR     s0,[r0,#4]            ;2267
0004b8  ed830a01          VSTR     s0,[r3,#4]            ;2267
0004bc  ed900a02          VLDR     s0,[r0,#8]            ;2267
0004c0  ed830a02          VSTR     s0,[r3,#8]            ;2267
0004c4  ed900a03          VLDR     s0,[r0,#0xc]          ;2267
0004c8  ed830a03          VSTR     s0,[r3,#0xc]          ;2267
0004cc  dc8f              BGT      |L24.1006|
                  |L24.1230|
0004ce  a876              ADD      r0,sp,#0x1d8          ;2270
0004d0  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
0004d4  a87b              ADD      r0,sp,#0x1ec          ;2271
0004d6  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
0004da  a880              ADD      r0,sp,#0x200          ;2272
0004dc  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
0004e0  a885              ADD      r0,sp,#0x214          ;2273
0004e2  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
0004e6  a88a              ADD      r0,sp,#0x228          ;2275
0004e8  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
0004ec  a88f              ADD      r0,sp,#0x23c          ;2276
0004ee  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
0004f2  a894              ADD      r0,sp,#0x250          ;2277
0004f4  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
0004f8  a899              ADD      r0,sp,#0x264          ;2278
0004fa  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
0004fe  aa8a              ADD      r2,sp,#0x228          ;2280
000500  a976              ADD      r1,sp,#0x1d8          ;2280
000502  a807              ADD      r0,sp,#0x1c           ;2280
000504  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker44ApplyHorizontalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_ ; Anki::Embedded::TemplateTracker::BinaryTracker::ApplyHorizontalCorrespondenceList_Projective(const Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
000508  0004              MOVS     r4,r0                 ;2280
00050a  d004              BEQ      |L24.1302|
00050c  f64001ea          MOV      r1,#0x8ea             ;2282
000510  4801              LDR      r0,|L24.1304|
000512  a302              ADR      r3,|L24.1308|
000514  e0ba              B        |L24.1676|
                  |L24.1302|
000516  e0c3              B        |L24.1696|
                  |L24.1304|
                          DCD      ||.constdata||+0x659
                  |L24.1308|
00051c  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\binaryTracker.cpp",0
000520  6f726574
000524  6563685c
000528  76697369
00052c  6f6e5c72
000530  6f626f74
000534  5c737263
000538  5c62696e
00053c  61727954
000540  7261636b
000544  65722e63
000548  707000  
00054b  00                DCB      0
                  |L24.1356|
00054c  46696e64          DCB      "FindHorizontalCorrespondences_List 1 failed",0
000550  486f7269
000554  7a6f6e74
000558  616c436f
00055c  72726573
000560  706f6e64
000564  656e6365
000568  735f4c69
00056c  73742031
000570  20666169
000574  6c656400
                  |L24.1400|
000578  42696e61          DCB      "BinaryTracker::IterativelyRefineTrack_Projective_Ransac"
00057c  72795472
000580  61636b65
000584  723a3a49
000588  74657261
00058c  74697665
000590  6c795265
000594  66696e65
000598  54726163
00059c  6b5f5072
0005a0  6f6a6563
0005a4  74697665
0005a8  5f52616e
0005ac  736163  
0005af  00                DCB      0
                  |L24.1456|
                          DCD      _ZZN4Anki8Embedded3EyeIfEENS_6ResultERNS0_5ArrayIT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Eye<float>(Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
                  |L24.1460|
0005b4  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/arrayP"
0005b8  6f726574
0005bc  6563685c
0005c0  636f6d6d
0005c4  6f6e5c69
0005c8  6e636c75
0005cc  64655c61
0005d0  6e6b692f
0005d4  636f6d6d
0005d8  6f6e2f72
0005dc  6f626f74
0005e0  2f617272
0005e4  617950  
0005e7  61747465          DCB      "atterns.h",0
0005eb  726e732e
0005ef  6800    
0005f1  00                DCB      0
0005f2  00                DCB      0
0005f3  00                DCB      0
                  |L24.1524|
0005f4  6f757420          DCB      "out is invalid",0
0005f8  69732069
0005fc  6e76616c
000600  696400  
000603  00                DCB      0
                  |L24.1540|
000604  45796500          DCB      "Eye",0
                  |L24.1544|
000608  46696e64          DCB      "FindHorizontalCorrespondences_List 2 failed",0
00060c  486f7269
000610  7a6f6e74
000614  616c436f
000618  72726573
00061c  706f6e64
000620  656e6365
000624  735f4c69
000628  73742032
00062c  20666169
000630  6c656400
                  |L24.1588|
000634  46696e64          DCB      "FindVerticalCorrespondences_List 1 failed",0
000638  56657274
00063c  6963616c
000640  436f7272
000644  6573706f
000648  6e64656e
00064c  6365735f
000650  4c697374
000654  20312066
000658  61696c65
00065c  6400    
00065e  00                DCB      0
00065f  00                DCB      0
                  |L24.1632|
000660  46696e64          DCB      "FindVerticalCorrespondences_List 2 failed",0
000664  56657274
000668  6963616c
00066c  436f7272
000670  6573706f
000674  6e64656e
000678  6365735f
00067c  4c697374
000680  20322066
000684  61696c65
000688  6400    
00068a  00                DCB      0
00068b  00                DCB      0
                  |L24.1676|
00068c  a2cb              ADR      r2,|L24.2492|
00068e  e9cd0100          STRD     r0,r1,[sp,#0]         ;2282
000692  f2af111c          ADR      r1,|L24.1400|
000696  2005              MOVS     r0,#5                 ;2282
000698  f7fffffe          BL       _Anki_Log
00069c  4620              MOV      r0,r4                 ;2282
00069e  e5cc              B        |L24.570|
                  |L24.1696|
0006a0  aa8f              ADD      r2,sp,#0x23c          ;2285
0006a2  a97b              ADD      r1,sp,#0x1ec          ;2285
0006a4  a814              ADD      r0,sp,#0x50           ;2285
0006a6  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker44ApplyHorizontalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_ ; Anki::Embedded::TemplateTracker::BinaryTracker::ApplyHorizontalCorrespondenceList_Projective(const Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
0006aa  0004              MOVS     r4,r0                 ;2285
0006ac  d00e              BEQ      |L24.1740|
0006ae  48d1              LDR      r0,|L24.2548|
0006b0  f64001ef          MOV      r1,#0x8ef             ;2287
0006b4  f2af139c          ADR      r3,|L24.1308|
0006b8  a2cf              ADR      r2,|L24.2552|
0006ba  e9cd0100          STRD     r0,r1,[sp,#0]         ;2287
0006be  f2af1148          ADR      r1,|L24.1400|
0006c2  2005              MOVS     r0,#5                 ;2287
0006c4  f7fffffe          BL       _Anki_Log
0006c8  4620              MOV      r0,r4                 ;2287
0006ca  e5b6              B        |L24.570|
                  |L24.1740|
0006cc  aa94              ADD      r2,sp,#0x250          ;2290
0006ce  a980              ADD      r1,sp,#0x200          ;2290
0006d0  a821              ADD      r0,sp,#0x84           ;2290
0006d2  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker42ApplyVerticalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_ ; Anki::Embedded::TemplateTracker::BinaryTracker::ApplyVerticalCorrespondenceList_Projective(const Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
0006d6  0004              MOVS     r4,r0                 ;2290
0006d8  d00e              BEQ      |L24.1784|
0006da  48c6              LDR      r0,|L24.2548|
0006dc  f64001f4          MOV      r1,#0x8f4             ;2292
0006e0  f2af13c8          ADR      r3,|L24.1308|
0006e4  a2d2              ADR      r2,|L24.2608|
0006e6  e9cd0100          STRD     r0,r1,[sp,#0]         ;2292
0006ea  f2af1174          ADR      r1,|L24.1400|
0006ee  2005              MOVS     r0,#5                 ;2292
0006f0  f7fffffe          BL       _Anki_Log
0006f4  4620              MOV      r0,r4                 ;2292
0006f6  e5a0              B        |L24.570|
                  |L24.1784|
0006f8  aa99              ADD      r2,sp,#0x264          ;2295
0006fa  a985              ADD      r1,sp,#0x214          ;2295
0006fc  a82e              ADD      r0,sp,#0xb8           ;2295
0006fe  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker42ApplyVerticalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_ ; Anki::Embedded::TemplateTracker::BinaryTracker::ApplyVerticalCorrespondenceList_Projective(const Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
000702  0004              MOVS     r4,r0                 ;2295
000704  d00e              BEQ      |L24.1828|
000706  48bb              LDR      r0,|L24.2548|
000708  f64001f9          MOV      r1,#0x8f9             ;2297
00070c  f2af13f4          ADR      r3,|L24.1308|
000710  a2d4              ADR      r2,|L24.2660|
000712  e9cd0100          STRD     r0,r1,[sp,#0]         ;2297
000716  f2af11a0          ADR      r1,|L24.1400|
00071a  2005              MOVS     r0,#5                 ;2297
00071c  f7fffffe          BL       _Anki_Log
000720  4620              MOV      r0,r4                 ;2297
000722  e58a              B        |L24.570|
                  |L24.1828|
000724  a8b2              ADD      r0,sp,#0x2c8          ;2302
000726  99e5              LDR      r1,[sp,#0x394]        ;2302
000728  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00072c  a9b2              ADD      r1,sp,#0x2c8          ;2302
00072e  a86f              ADD      r0,sp,#0x1bc          ;2302
000730  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000734  2300              MOVS     r3,#0                 ;2304
000736  461a              MOV      r2,r3                 ;2304
000738  2101              MOVS     r1,#1                 ;2304
00073a  a8cd              ADD      r0,sp,#0x334          ;2304
00073c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000740  6800              LDR      r0,[r0,#0]            ;2304
000742  2203              MOVS     r2,#3                 ;2304
000744  9000              STR      r0,[sp,#0]            ;2304
000746  ab6f              ADD      r3,sp,#0x1bc          ;2304
000748  4611              MOV      r1,r2                 ;2304
00074a  a802              ADD      r0,sp,#8              ;2304
00074c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000750  2300              MOVS     r3,#0                 ;2306
000752  461a              MOV      r2,r3                 ;2306
000754  2101              MOVS     r1,#1                 ;2306
000756  a8ce              ADD      r0,sp,#0x338          ;2306
000758  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00075c  6800              LDR      r0,[r0,#0]            ;2306
00075e  2208              MOVS     r2,#8                 ;2306
000760  9000              STR      r0,[sp,#0]            ;2306
000762  ab6f              ADD      r3,sp,#0x1bc          ;2306
000764  4611              MOV      r1,r2                 ;2306
000766  a89e              ADD      r0,sp,#0x278          ;2306
000768  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00076c  2300              MOVS     r3,#0                 ;2307
00076e  461a              MOV      r2,r3                 ;2307
000770  2101              MOVS     r1,#1                 ;2307
000772  a8cf              ADD      r0,sp,#0x33c          ;2307
000774  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000778  6800              LDR      r0,[r0,#0]            ;2307
00077a  9000              STR      r0,[sp,#0]            ;2307
00077c  ab6f              ADD      r3,sp,#0x1bc          ;2307
00077e  2208              MOVS     r2,#8                 ;2307
000780  2101              MOVS     r1,#1                 ;2307
000782  a8a3              ADD      r0,sp,#0x28c          ;2307
000784  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000788  2000              MOVS     r0,#0                 ;2310
                  |L24.1930|
00078a  2100              MOVS     r1,#0                 ;2311
                  |L24.1932|
00078c  9b78              LDR      r3,[sp,#0x1e0]        ;2311
00078e  9a7a              LDR      r2,[sp,#0x1e8]        ;2311
000790  fb002203          MLA      r2,r0,r3,r2           ;2311
000794  eb020281          ADD      r2,r2,r1,LSL #2       ;2312
000798  9b7d              LDR      r3,[sp,#0x1f4]        ;2312
00079a  ed920a00          VLDR     s0,[r2,#0]            ;2312
00079e  9a7f              LDR      r2,[sp,#0x1fc]        ;2312
0007a0  fb002203          MLA      r2,r0,r3,r2           ;2312
0007a4  eb020281          ADD      r2,r2,r1,LSL #2       ;2312
0007a8  9b82              LDR      r3,[sp,#0x208]        ;2312
0007aa  edd20a00          VLDR     s1,[r2,#0]            ;2312
0007ae  9a84              LDR      r2,[sp,#0x210]        ;2312
0007b0  fb002203          MLA      r2,r0,r3,r2           ;2312
0007b4  eb020281          ADD      r2,r2,r1,LSL #2       ;2312
0007b8  ee300a20          VADD.F32 s0,s0,s1              ;2312
0007bc  edd20a00          VLDR     s1,[r2,#0]            ;2312
0007c0  9b87              LDR      r3,[sp,#0x21c]        ;2312
0007c2  9a89              LDR      r2,[sp,#0x224]        ;2312
0007c4  ee300a20          VADD.F32 s0,s0,s1              ;2312
0007c8  fb002203          MLA      r2,r0,r3,r2           ;2312
0007cc  eb020281          ADD      r2,r2,r1,LSL #2       ;2312
0007d0  9ba0              LDR      r3,[sp,#0x280]        ;2312
0007d2  edd20a00          VLDR     s1,[r2,#0]            ;2312
0007d6  9aa2              LDR      r2,[sp,#0x288]        ;2312
0007d8  fb002203          MLA      r2,r0,r3,r2           ;2312
0007dc  ee300a20          VADD.F32 s0,s0,s1              ;2312
0007e0  eb020281          ADD      r2,r2,r1,LSL #2       ;2312
0007e4  1c49              ADDS     r1,r1,#1              ;2311
0007e6  ed820a00          VSTR     s0,[r2,#0]            ;2312
0007ea  2908              CMP      r1,#8                 ;2311
0007ec  dbce              BLT      |L24.1932|
0007ee  9b8c              LDR      r3,[sp,#0x230]        ;2311
0007f0  9a8e              LDR      r2,[sp,#0x238]        ;2311
0007f2  2100              MOVS     r1,#0                 ;2315
0007f4  fb012103          MLA      r1,r1,r3,r2           ;2315
0007f8  eb010180          ADD      r1,r1,r0,LSL #2       ;2315
0007fc  9b91              LDR      r3,[sp,#0x244]        ;2315
0007fe  ed910a00          VLDR     s0,[r1,#0]            ;2315
000802  9a93              LDR      r2,[sp,#0x24c]        ;2315
000804  2100              MOVS     r1,#0                 ;2315
000806  fb012103          MLA      r1,r1,r3,r2           ;2315
00080a  eb010180          ADD      r1,r1,r0,LSL #2       ;2315
00080e  9b96              LDR      r3,[sp,#0x258]        ;2315
000810  edd10a00          VLDR     s1,[r1,#0]            ;2315
000814  9a98              LDR      r2,[sp,#0x260]        ;2315
000816  2100              MOVS     r1,#0                 ;2315
000818  fb012103          MLA      r1,r1,r3,r2           ;2315
00081c  eb010180          ADD      r1,r1,r0,LSL #2       ;2315
000820  ee300a20          VADD.F32 s0,s0,s1              ;2315
000824  edd10a00          VLDR     s1,[r1,#0]            ;2315
000828  9b9b              LDR      r3,[sp,#0x26c]        ;2315
00082a  9a9d              LDR      r2,[sp,#0x274]        ;2315
00082c  2100              MOVS     r1,#0                 ;2315
00082e  fb012103          MLA      r1,r1,r3,r2           ;2315
000832  eb010180          ADD      r1,r1,r0,LSL #2       ;2315
000836  ee300a20          VADD.F32 s0,s0,s1              ;2315
00083a  edd10a00          VLDR     s1,[r1,#0]            ;2315
00083e  9ba5              LDR      r3,[sp,#0x294]        ;2315
000840  9aa7              LDR      r2,[sp,#0x29c]        ;2315
000842  2100              MOVS     r1,#0                 ;2315
000844  fb012103          MLA      r1,r1,r3,r2           ;2315
000848  ee300a20          VADD.F32 s0,s0,s1              ;2315
00084c  eb010180          ADD      r1,r1,r0,LSL #2       ;2315
000850  1c40              ADDS     r0,r0,#1              ;2310
000852  ed810a00          VSTR     s0,[r1,#0]            ;2315
000856  2808              CMP      r0,#8                 ;2310
000858  db97              BLT      |L24.1930|
00085a  2100              MOVS     r1,#0                 ;2318
00085c  a89e              ADD      r0,sp,#0x278          ;2318
00085e  f7fffffe          BL       _ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b ; Anki::Embedded::Matrix::MakeSymmetric<Anki::Embedded::Array<float>>(T1&, bool)
000862  abc6              ADD      r3,sp,#0x318          ;2323
000864  2200              MOVS     r2,#0                 ;2323
000866  a9a3              ADD      r1,sp,#0x28c          ;2323
000868  a89e              ADD      r0,sp,#0x278          ;2323
00086a  f7fffffe          BL       _ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)
00086e  0004              MOVS     r4,r0                 ;2323
000870  d00e              BEQ      |L24.2192|
000872  4860              LDR      r0,|L24.2548|
000874  f6401117          MOV      r1,#0x917             ;2327
000878  f2af3360          ADR      r3,|L24.1308|
00087c  a286              ADR      r2,|L24.2712|
00087e  e9cd0100          STRD     r0,r1,[sp,#0]         ;2327
000882  f2af310c          ADR      r1,|L24.1400|
000886  2005              MOVS     r0,#5                 ;2327
000888  f7fffffe          BL       _Anki_Log
00088c  4620              MOV      r0,r4                 ;2327
00088e  e4d4              B        |L24.570|
                  |L24.2192|
000890  f89d0318          LDRB     r0,[sp,#0x318]        ;2330
000894  2800              CMP      r0,#0                 ;2330
000896  d170              BNE      |L24.2426|
000898  9aa5              LDR      r2,[sp,#0x294]        ;2330
00089a  99a7              LDR      r1,[sp,#0x29c]        ;2330
00089c  9b04              LDR      r3,[sp,#0x10]         ;2330
00089e  fb001002          MLA      r0,r0,r2,r1           ;2330
0008a2  9a06              LDR      r2,[sp,#0x18]         ;2330
0008a4  2100              MOVS     r1,#0                 ;2333
0008a6  fb012103          MLA      r1,r1,r3,r2           ;2333
0008aa  ed900a00          VLDR     s0,[r0,#0]            ;2333
0008ae  ed810a00          VSTR     s0,[r1,#0]            ;2333
0008b2  9b04              LDR      r3,[sp,#0x10]         ;2333
0008b4  9a06              LDR      r2,[sp,#0x18]         ;2333
0008b6  2100              MOVS     r1,#0                 ;2333
0008b8  fb012103          MLA      r1,r1,r3,r2           ;2333
0008bc  ed900a01          VLDR     s0,[r0,#4]            ;2333
0008c0  ed810a01          VSTR     s0,[r1,#4]            ;2333
0008c4  9b04              LDR      r3,[sp,#0x10]         ;2333
0008c6  9a06              LDR      r2,[sp,#0x18]         ;2333
0008c8  2100              MOVS     r1,#0                 ;2333
0008ca  fb012103          MLA      r1,r1,r3,r2           ;2333
0008ce  ed900a02          VLDR     s0,[r0,#8]            ;2333
0008d2  ed810a02          VSTR     s0,[r1,#8]            ;2333
0008d6  9b04              LDR      r3,[sp,#0x10]         ;2333
0008d8  9a06              LDR      r2,[sp,#0x18]         ;2333
0008da  2101              MOVS     r1,#1                 ;2334
0008dc  fb012103          MLA      r1,r1,r3,r2           ;2334
0008e0  ed900a03          VLDR     s0,[r0,#0xc]          ;2334
0008e4  ed810a00          VSTR     s0,[r1,#0]            ;2334
0008e8  9b04              LDR      r3,[sp,#0x10]         ;2334
0008ea  9a06              LDR      r2,[sp,#0x18]         ;2334
0008ec  2101              MOVS     r1,#1                 ;2334
0008ee  fb012103          MLA      r1,r1,r3,r2           ;2334
0008f2  ed900a04          VLDR     s0,[r0,#0x10]         ;2334
0008f6  ed810a01          VSTR     s0,[r1,#4]            ;2334
0008fa  9b04              LDR      r3,[sp,#0x10]         ;2334
0008fc  9a06              LDR      r2,[sp,#0x18]         ;2334
0008fe  2101              MOVS     r1,#1                 ;2334
000900  fb012103          MLA      r1,r1,r3,r2           ;2334
000904  ed900a05          VLDR     s0,[r0,#0x14]         ;2334
000908  ed810a02          VSTR     s0,[r1,#8]            ;2334
00090c  9b04              LDR      r3,[sp,#0x10]         ;2334
00090e  9a06              LDR      r2,[sp,#0x18]         ;2334
000910  2102              MOVS     r1,#2                 ;2335
000912  fb012103          MLA      r1,r1,r3,r2           ;2335
000916  ed900a06          VLDR     s0,[r0,#0x18]         ;2335
00091a  ed810a00          VSTR     s0,[r1,#0]            ;2335
00091e  9b04              LDR      r3,[sp,#0x10]         ;2335
000920  9a06              LDR      r2,[sp,#0x18]         ;2335
000922  2102              MOVS     r1,#2                 ;2335
000924  fb012103          MLA      r1,r1,r3,r2           ;2335
000928  ed900a07          VLDR     s0,[r0,#0x1c]         ;2335
00092c  2002              MOVS     r0,#2                 ;2335
00092e  ed810a01          VSTR     s0,[r1,#4]            ;2335
000932  9a04              LDR      r2,[sp,#0x10]         ;2335
000934  9906              LDR      r1,[sp,#0x18]         ;2335
000936  fb001002          MLA      r0,r0,r2,r1           ;2335
00093a  a902              ADD      r1,sp,#8              ;2339
00093c  ed808a02          VSTR     s16,[r0,#8]           ;2335
000940  f50570a8          ADD      r0,r5,#0x150          ;2339
000944  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3214set_homographyERKNS0_5ArrayIfEE ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_homography(const Anki::Embedded::Array<float>&)
000948  a8c7              ADD      r0,sp,#0x31c          ;2342
00094a  9000              STR      r0,[sp,#0]            ;2342
00094c  4631              MOV      r1,r6                 ;2342
00094e  4628              MOV      r0,r5                 ;2342
000950  9be3              LDR      r3,[sp,#0x38c]        ;2342
000952  9ad5              LDR      r2,[sp,#0x354]        ;2342
000954  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker13BinaryTracker11VerifyTrackERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiRi ; Anki::Embedded::TemplateTracker::BinaryTracker::VerifyTrack(const Anki::Embedded::EdgeLists&, const Anki::Embedded::TemplateTracker::BinaryTracker::AllIndexLimits&, int, int&)
000958  0004              MOVS     r4,r0                 ;2342
00095a  d00f              BEQ      |L24.2428|
00095c  4825              LDR      r0,|L24.2548|
00095e  f6401128          MOV      r1,#0x928             ;2344
000962  f2af4348          ADR      r3,|L24.1308|
000966  a256              ADR      r2,|L24.2752|
000968  e9cd0100          STRD     r0,r1,[sp,#0]         ;2344
00096c  f2af31f8          ADR      r1,|L24.1400|
000970  2005              MOVS     r0,#5                 ;2344
000972  f7fffffe          BL       _Anki_Log
000976  4620              MOV      r0,r4                 ;2344
000978  e45f              B        |L24.570|
                  |L24.2426|
00097a  e00e              B        |L24.2458|
                  |L24.2428|
00097c  f8d91000          LDR      r1,[r9,#0]            ;2347
000980  98c7              LDR      r0,[sp,#0x31c]        ;2347
000982  4281              CMP      r1,r0                 ;2347
000984  da09              BGE      |L24.2458|
000986  f8c90000          STR      r0,[r9,#0]            ;2349
00098a  f50570a8          ADD      r0,r5,#0x150          ;2349
00098e  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
000992  4601              MOV      r1,r0                 ;2349
000994  a8ad              ADD      r0,sp,#0x2b4          ;2349
000996  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE3SetERKS2_ ; Anki::Embedded::Array<float>::Set(const Anki::Embedded::Array<float>&)
                  |L24.2458|
00099a  a9a8              ADD      r1,sp,#0x2a0          ;2355
00099c  f50570a8          ADD      r0,r5,#0x150          ;2355
0009a0  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3214set_homographyERKNS0_5ArrayIfEE ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_homography(const Anki::Embedded::Array<float>&)
0009a4  98e1              LDR      r0,[sp,#0x384]        ;2255
0009a6  1c7f              ADDS     r7,r7,#1              ;2255
0009a8  4287              CMP      r7,r0                 ;2255
0009aa  f6ffad1c          BLT      |L24.998|
                  |L24.2478|
0009ae  a9ad              ADD      r1,sp,#0x2b4          ;2359
0009b0  f50570a8          ADD      r0,r5,#0x150          ;2359
0009b4  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3214set_homographyERKNS0_5ArrayIfEE ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_homography(const Anki::Embedded::Array<float>&)
0009b8  2000              MOVS     r0,#0                 ;2361
0009ba  e43e              B        |L24.570|
;;;2363   
                          ENDP

                  |L24.2492|
0009bc  4170706c          DCB      "ApplyHorizontalCorrespondenceList_Projective 1 failed",0
0009c0  79486f72
0009c4  697a6f6e
0009c8  74616c43
0009cc  6f727265
0009d0  73706f6e
0009d4  64656e63
0009d8  654c6973
0009dc  745f5072
0009e0  6f6a6563
0009e4  74697665
0009e8  20312066
0009ec  61696c65
0009f0  6400    
0009f2  00                DCB      0
0009f3  00                DCB      0
                  |L24.2548|
                          DCD      ||.constdata||+0x659
                  |L24.2552|
0009f8  4170706c          DCB      "ApplyHorizontalCorrespondenceList_Projective 2 failed",0
0009fc  79486f72
000a00  697a6f6e
000a04  74616c43
000a08  6f727265
000a0c  73706f6e
000a10  64656e63
000a14  654c6973
000a18  745f5072
000a1c  6f6a6563
000a20  74697665
000a24  20322066
000a28  61696c65
000a2c  6400    
000a2e  00                DCB      0
000a2f  00                DCB      0
                  |L24.2608|
000a30  4170706c          DCB      "ApplyVerticalCorrespondenceList_Projective 1 failed",0
000a34  79566572
000a38  74696361
000a3c  6c436f72
000a40  72657370
000a44  6f6e6465
000a48  6e63654c
000a4c  6973745f
000a50  50726f6a
000a54  65637469
000a58  76652031
000a5c  20666169
000a60  6c656400
                  |L24.2660|
000a64  4170706c          DCB      "ApplyVerticalCorrespondenceList_Projective 2 failed",0
000a68  79566572
000a6c  74696361
000a70  6c436f72
000a74  72657370
000a78  6f6e6465
000a7c  6e63654c
000a80  6973745f
000a84  50726f6a
000a88  65637469
000a8c  76652032
000a90  20666169
000a94  6c656400
                  |L24.2712|
000a98  536f6c76          DCB      "SolveLeastSquaresWithCholesky failed",0
000a9c  654c6561
000aa0  73745371
000aa4  75617265
000aa8  73576974
000aac  6843686f
000ab0  6c65736b
000ab4  79206661
000ab8  696c6564
000abc  00      
000abd  00                DCB      0
000abe  00                DCB      0
000abf  00                DCB      0
                  |L24.2752|
000ac0  56657269          DCB      "VerifyTrack failed",0
000ac4  66795472
000ac8  61636b20
000acc  6661696c
000ad0  656400  
000ad3  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker41FindHorizontalCorrespondences_TranslationEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERiSH_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker41FindHorizontalCorrespondences_TranslationEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERiSH_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::FindHorizontalCorrespondences_Translation(int, const Anki::Embedded::Transformations::PlanarTransformation_f32&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, int, int, const Anki::Embedded::Array<int>&, int&, int&)
                  |symbol_number.445|
;;;915    
;;;916          Result BinaryTracker::FindHorizontalCorrespondences_Translation(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;917            const s32 maxMatchingDistance,
;;;918            const Transformations::PlanarTransformation_f32 &transformation,
;;;919            const FixedLengthList<Point<s16> > &templatePoints,
;;;920            const FixedLengthList<Point<s16> > &newPoints,
;;;921            const s32 imageHeight,
;;;922            const s32 imageWidth,
;;;923            const Array<s32> &yStartIndexes,
;;;924            s32 &sumX,
;;;925            s32 &numCorrespondences)
;;;926          {
000004  4683              MOV      r11,r0
000006  ed2d8b0c          VPUSH    {d8-d13}
00000a  b083              SUB      sp,sp,#0xc
00000c  461e              MOV      r6,r3
00000e  4617              MOV      r7,r2
000010  4688              MOV      r8,r1
000012  e9dd451a          LDRD     r4,r5,[sp,#0x68]
;;;927            const s32 numTemplatePoints = templatePoints.get_size();
000016  68d0              LDR      r0,[r2,#0xc]
;;;928            //const s32 numNewPoints = newPoints.get_size();
;;;929    
;;;930            const Array<f32> &homography = transformation.get_homography();
000018  9002              STR      r0,[sp,#8]
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
000020  4681              MOV      r9,r0
;;;931            const Point<f32> &centerOffset = transformation.get_centerOffset(1.0f);
000022  eeb70a00          VMOV.F32 s0,#1.00000000
000026  4641              MOV      r1,r8
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
00002e  f8d92008          LDR      r2,[r9,#8]
000032  f8d91010          LDR      r1,[r9,#0x10]
;;;932    
;;;933            const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2];
000036  2000              MOVS     r0,#0
000038  fb001002          MLA      r0,r0,r2,r1
00003c  46e8              MOV      r8,sp                 ;931
00003e  edd0ca00          VLDR     s25,[r0,#0]
000042  ed90ca01          VLDR     s24,[r0,#4]
000046  edd0ba02          VLDR     s23,[r0,#8]
;;;934            const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2];
00004a  2001              MOVS     r0,#1
00004c  fb001002          MLA      r0,r0,r2,r1
;;;935            const f32 h20 = homography[2][0]; const f32 h21 = homography[2][1]; const f32 h22 = 1.0f;
000050  eef78a00          VMOV.F32 s17,#1.00000000
000054  ed90ba00          VLDR     s22,[r0,#0]           ;934
000058  edd0aa01          VLDR     s21,[r0,#4]           ;934
00005c  ed90aa02          VLDR     s20,[r0,#8]           ;934
000060  2002              MOVS     r0,#2
000062  fb001002          MLA      r0,r0,r2,r1
000066  edd09a00          VLDR     s19,[r0,#0]
00006a  ed909a01          VLDR     s18,[r0,#4]
;;;936    
;;;937            AnkiAssert(FLT_NEAR(homography[2][2], 1.0f));
;;;938    
;;;939            sumX = 0;
00006e  2000              MOVS     r0,#0
;;;940            f32 numCorrespondencesF32 = 0.0f;
000070  ed9f8a42          VLDR     s16,|L25.380|
000074  6028              STR      r0,[r5,#0]
000076  68a2              LDR      r2,[r4,#8]
000078  6921              LDR      r1,[r4,#0x10]
;;;941    
;;;942            const Point<s16> * restrict pTemplatePoints = templatePoints.Pointer(0);
;;;943            const Point<s16> * restrict pNewPoints = newPoints.Pointer(0);
;;;944            const s32 * restrict pYStartIndexes = yStartIndexes.Pointer(0,0);
;;;945    
;;;946            for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++) {
00007a  4604              MOV      r4,r0
00007c  fb001902          MLA      r9,r0,r2,r1
000080  9802              LDR      r0,[sp,#8]
000082  f8d7a030          LDR      r10,[r7,#0x30]
000086  6b36              LDR      r6,[r6,#0x30]
000088  2800              CMP      r0,#0
00008a  dd60              BLE      |L25.334|
                  |L25.140|
;;;947              const f32 xr = static_cast<f32>(pTemplatePoints[iPoint].x);
00008c  f93a0024          LDRSH    r0,[r10,r4,LSL #2]
;;;948              const f32 yr = static_cast<f32>(pTemplatePoints[iPoint].y);
;;;949    
;;;950              //
;;;951              // Warp x and y based on the current homography
;;;952              //
;;;953    
;;;954              // Subtract the center offset
;;;955              const f32 xc = xr - centerOffset.x;
000090  edd81a00          VLDR     s3,[r8,#0]
000094  ee000a10          VMOV     s0,r0                 ;947
000098  eb0a0084          ADD      r0,r10,r4,LSL #2      ;948
;;;956              const f32 yc = yr - centerOffset.y;
00009c  ed981a01          VLDR     s2,[r8,#4]
0000a0  f9b00002          LDRSH    r0,[r0,#2]            ;948
0000a4  eef80ac0          VCVT.F32.S32 s1,s0                 ;947
0000a8  ee000a10          VMOV     s0,r0                 ;948
0000ac  eeb80ac0          VCVT.F32.S32 s0,s0                 ;948
0000b0  ee700ae1          VSUB.F32 s1,s1,s3              ;955
0000b4  ee300a41          VSUB.F32 s0,s0,s2
;;;957    
;;;958              // Projective warp
;;;959              const f32 wpi = 1.0f / (h20*xc + h21*yc + h22);
0000b8  ee291aa0          VMUL.F32 s2,s19,s1
0000bc  ee091a00          VMLA.F32 s2,s18,s0
0000c0  ee312a28          VADD.F32 s4,s2,s17
0000c4  ee881a82          VDIV.F32 s2,s17,s4
;;;960              const f32 warpedX = (h00*xc + h01*yc + h02) * wpi;
0000c8  ee2c2aa0          VMUL.F32 s4,s25,s1
;;;961              const f32 warpedY = (h10*xc + h11*yc + h12) * wpi;
0000cc  ee6b0a20          VMUL.F32 s1,s22,s1
0000d0  ee0c2a00          VMLA.F32 s4,s24,s0             ;960
0000d4  ee4a0a80          VMLA.F32 s1,s21,s0
0000d8  ee322a2b          VADD.F32 s4,s4,s23             ;960
0000dc  ee300a8a          VADD.F32 s0,s1,s20
0000e0  ee222a01          VMUL.F32 s4,s4,s2              ;960
0000e4  ee20da01          VMUL.F32 s26,s0,s2
;;;962    
;;;963              // TODO: verify the -0.5f is correct
;;;964              const s32 warpedXrounded = RoundS32_minusPointFive(warpedX + centerOffset.x);
0000e8  ee310a82          VADD.F32 s0,s3,s4
0000ec  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
;;;965              const s32 warpedYrounded = RoundS32_minusPointFive(warpedY + centerOffset.y);
0000f0  ed980a01          VLDR     s0,[r8,#4]
0000f4  4607              MOV      r7,r0                 ;964
0000f6  ee300a0d          VADD.F32 s0,s0,s26
0000fa  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
0000fe  1e01              SUBS     r1,r0,#0
;;;966    
;;;967              if(warpedYrounded >= 0 && warpedYrounded < imageHeight) {
000100  bfa4              ITT      GE
000102  9818              LDRGE    r0,[sp,#0x60]
000104  4288              CMPGE    r0,r1
000106  dd1e              BLE      |L25.326|
;;;968                const s32 minX = warpedXrounded - maxMatchingDistance;
;;;969                const s32 maxX = warpedXrounded + maxMatchingDistance;
;;;970    
;;;971                s32 curIndex = pYStartIndexes[warpedYrounded];
000108  f8590021          LDR      r0,[r9,r1,LSL #2]
;;;972                const s32 endIndex = pYStartIndexes[warpedYrounded+1];
00010c  eb090181          ADD      r1,r9,r1,LSL #2
000110  eba70c0b          SUB      r12,r7,r11            ;968
000114  684a              LDR      r2,[r1,#4]
000116  eb07030b          ADD      r3,r7,r11             ;969
                  |L25.282|
;;;973    
;;;974                // Find the start of the valid matches
;;;975                while( (curIndex<endIndex) && (pNewPoints[curIndex].x<minX) ) {
00011a  4290              CMP      r0,r2
00011c  bfbe              ITTT     LT
00011e  f9361020          LDRSHLT  r1,[r6,r0,LSL #2]
000122  4561              CMPLT    r1,r12
;;;976                  curIndex++;
000124  1c40              ADDLT    r0,r0,#1
000126  dbf8              BLT      |L25.282|
000128  e007              B        |L25.314|
                  |L25.298|
;;;977                }
;;;978    
;;;979                // For every valid match, increment the sum and counter
;;;980                while( (curIndex<endIndex) && (pNewPoints[curIndex].x<=maxX) ) {
;;;981                  const s32 offset = pNewPoints[curIndex].x - warpedXrounded;
00012a  1bc9              SUBS     r1,r1,r7
;;;982    
;;;983                  sumX += offset;
00012c  f8d5c000          LDR      r12,[r5,#0]
;;;984                  numCorrespondencesF32 += 1.0f;
000130  ee388a28          VADD.F32 s16,s16,s17
000134  4461              ADD      r1,r1,r12             ;983
;;;985    
;;;986                  curIndex++;
000136  1c40              ADDS     r0,r0,#1
000138  6029              STR      r1,[r5,#0]
                  |L25.314|
00013a  4290              CMP      r0,r2                 ;980
00013c  da03              BGE      |L25.326|
00013e  f9361020          LDRSH    r1,[r6,r0,LSL #2]     ;980
000142  428b              CMP      r3,r1                 ;980
000144  daf1              BGE      |L25.298|
                  |L25.326|
000146  9802              LDR      r0,[sp,#8]            ;946
000148  1c64              ADDS     r4,r4,#1              ;946
00014a  4284              CMP      r4,r0                 ;946
00014c  db9e              BLT      |L25.140|
                  |L25.334|
00014e  eeb58ac0          VCMPE.F32 s16,#0.0              ;946
000152  eeb60a00          VMOV.F32 s0,#0.50000000        ;946
000156  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;946
00015a  bfcc              ITE      GT                    ;946
00015c  ee380a00          VADDGT.F32 s0,s16,s0             ;946
000160  ee380a40          VSUBLE.F32 s0,s16,s0             ;946
000164  eebd0ac0          VCVT.S32.F32 s0,s0                 ;946
;;;987                }
;;;988              } // if(warpedYrounded >= 0 && warpedYrounded < imageHeight)
;;;989            } // for(s32 iPoint=0; iPoint<numTemplatePoints; iPoint++)
;;;990    
;;;991            numCorrespondences = Round<s32>(numCorrespondencesF32);
000168  981c              LDR      r0,[sp,#0x70]
00016a  ed800a00          VSTR     s0,[r0,#0]
;;;992    
;;;993            return RESULT_OK;
;;;994          } // Result BinaryTracker::FindHorizontalCorrespondences_Translation()
00016e  b003              ADD      sp,sp,#0xc
000170  2000              MOVS     r0,#0                 ;993
000172  ecbd8b0c          VPOP     {d8-d13}
000176  e8bd8ff0          POP      {r4-r11,pc}
;;;995    
                          ENDP

00017a  0000              DCW      0x0000
                  |L25.380|
00017c  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker42ApplyVerticalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker42ApplyVerticalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::ApplyVerticalCorrespondenceList_Projective(const Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
                  |symbol_number.446|
;;;1630   
;;;1631         NO_INLINE Result BinaryTracker::ApplyVerticalCorrespondenceList_Projective(
000000  b410              PUSH     {r4}
;;;1632           const FixedLengthList<IndexCorrespondence> &matchingIndexes,
;;;1633           Array<f32> &AtA,
;;;1634           Array<f32> &Atb_t)
;;;1635         {
000002  ed2d8b0a          VPUSH    {d8-d12}
;;;1636           const s32 numMatchingIndexes = matchingIndexes.get_size();
;;;1637           const IndexCorrespondence * restrict pMatchingIndexes = matchingIndexes.Pointer(0);
;;;1638   
;;;1639           // These addresses should be known at compile time, so should be faster
;;;1640   #if !defined(USE_ARM_ACCELERATION) // natural C
;;;1641           f32 AtA_raw[8][8];
;;;1642           f32 Atb_t_raw[8];
;;;1643   
;;;1644           for(s32 ia=0; ia<8; ia++) {
;;;1645             for(s32 ja=0; ja<8; ja++) {
;;;1646               AtA_raw[ia][ja] = 0;
;;;1647             }
;;;1648             Atb_t_raw[ia] = 0;
;;;1649           }
;;;1650   #else // ARM optimized
;;;1651           f32 AtA_raw33 = 0, AtA_raw34 = 0, AtA_raw35 = 0, AtA_raw36 = 0, AtA_raw37 = 0;
000006  eddf2a84          VLDR     s5,|L26.536|
;;;1652           f32 AtA_raw44 = 0, AtA_raw45 = 0, AtA_raw46 = 0, AtA_raw47 = 0;
;;;1653           f32 AtA_raw55 = 0, AtA_raw56 = 0, AtA_raw57 = 0;
;;;1654           f32 AtA_raw66 = 0, AtA_raw67 = 0;
;;;1655           f32 AtA_raw77 = 0;
;;;1656   
;;;1657           f32 Atb_t_raw3 = 0, Atb_t_raw4 = 0, Atb_t_raw5 = 0, Atb_t_raw6 = 0, Atb_t_raw7 = 0;
;;;1658   #endif // #if !defined(USE_ARM_ACCELERATION) ... #else
;;;1659   
;;;1660           for(s32 iMatch=0; iMatch<numMatchingIndexes; iMatch++) {
00000a  f8d0c00c          LDR      r12,[r0,#0xc]
00000e  6b04              LDR      r4,[r0,#0x30]
000010  2000              MOVS     r0,#0
000012  eeb0ca62          VMOV.F32 s24,s5                ;1651
000016  eef0ba62          VMOV.F32 s23,s5                ;1651
00001a  eeb0ba62          VMOV.F32 s22,s5                ;1651
00001e  eef0aa62          VMOV.F32 s21,s5                ;1651
000022  eeb0aa62          VMOV.F32 s20,s5                ;1651
000026  eef09a62          VMOV.F32 s19,s5                ;1652
00002a  eeb09a62          VMOV.F32 s18,s5                ;1652
00002e  eef08a62          VMOV.F32 s17,s5                ;1652
000032  eeb08a62          VMOV.F32 s16,s5                ;1652
000036  eef07a62          VMOV.F32 s15,s5                ;1653
00003a  eeb07a62          VMOV.F32 s14,s5                ;1653
00003e  eef06a62          VMOV.F32 s13,s5                ;1653
000042  eeb06a62          VMOV.F32 s12,s5                ;1654
000046  eef05a62          VMOV.F32 s11,s5                ;1654
00004a  eeb05a62          VMOV.F32 s10,s5                ;1655
00004e  eef04a62          VMOV.F32 s9,s5                 ;1657
000052  eeb04a62          VMOV.F32 s8,s5                 ;1657
000056  eef03a62          VMOV.F32 s7,s5                 ;1657
00005a  eeb03a62          VMOV.F32 s6,s5                 ;1657
00005e  f1bc0f00          CMP      r12,#0
;;;1661             const f32 xc = pMatchingIndexes[iMatch].templatePoint.x;
;;;1662             const f32 yc = pMatchingIndexes[iMatch].templatePoint.y;
;;;1663   
;;;1664             //const f32 xp = pMatchingIndexes[iMatch].matchedPoint.x;
;;;1665             const f32 yp = pMatchingIndexes[iMatch].matchedPoint.y;
;;;1666   
;;;1667   #if !defined(USE_ARM_ACCELERATION) // natural C
;;;1668             const f32 aValues[8] = {0, 0, 0, -xc, -yc, -1, xc*yp, yc*yp};
;;;1669   
;;;1670             const f32 bValue = -yp;
;;;1671   
;;;1672             for(s32 ia=0; ia<8; ia++) {
;;;1673               for(s32 ja=ia; ja<8; ja++) {
;;;1674                 AtA_raw[ia][ja] += aValues[ia] * aValues[ja];
;;;1675               }
;;;1676               Atb_t_raw[ia] += bValue * aValues[ia];
;;;1677             }
;;;1678   #else // ARM optimized
;;;1679             const f32 aValues6 = xc*yp;
;;;1680             const f32 aValues7 = yc*yp;
;;;1681   
;;;1682             AtA_raw33 += xc * xc;
;;;1683             AtA_raw34 += xc * yc;
;;;1684             AtA_raw35 += xc;
;;;1685             AtA_raw36 -= xc * aValues6;
;;;1686             AtA_raw37 -= xc * aValues7;
;;;1687   
;;;1688             AtA_raw44 += yc * yc;
;;;1689             AtA_raw45 += yc;
;;;1690             AtA_raw46 -= yc * aValues6;
;;;1691             AtA_raw47 -= yc * aValues7;
;;;1692   
;;;1693             AtA_raw55 += 1;
000062  bfc8              IT       GT
000064  eddfca6d          VLDRGT   s25,|L26.540|
000068  dd36              BLE      |L26.216|
                  |L26.106|
00006a  eb041300          ADD      r3,r4,r0,LSL #4       ;1661
00006e  ee777aac          VADD.F32 s15,s15,s25
000072  ed932a03          VLDR     s4,[r3,#0xc]          ;1665
000076  edd30a00          VLDR     s1,[r3,#0]            ;1661
00007a  ed930a01          VLDR     s0,[r3,#4]            ;1662
;;;1694             AtA_raw56 -= aValues6;
;;;1695             AtA_raw57 -= aValues7;
;;;1696   
;;;1697             AtA_raw66 += aValues6 * aValues6;
;;;1698             AtA_raw67 += aValues6 * aValues7;
;;;1699   
;;;1700             AtA_raw77 += aValues7 * aValues7;
;;;1701   
;;;1702             Atb_t_raw3 += yp * xc;
;;;1703             Atb_t_raw4 += yp * yc;
;;;1704             Atb_t_raw5 += yp;
00007e  ee733a82          VADD.F32 s7,s7,s4
000082  ee601a82          VMUL.F32 s3,s1,s4              ;1679
000086  ee201a02          VMUL.F32 s2,s0,s4              ;1680
00008a  ee00caa0          VMLA.F32 s24,s1,s1             ;1682
00008e  ee40ba80          VMLA.F32 s23,s1,s0             ;1683
000092  ee40aae1          VMLS.F32 s21,s1,s3             ;1685
000096  ee00aac1          VMLS.F32 s20,s1,s2             ;1686
00009a  ee409a00          VMLA.F32 s19,s0,s0             ;1688
00009e  ee408a61          VMLS.F32 s17,s0,s3             ;1690
0000a2  ee008a41          VMLS.F32 s16,s0,s2             ;1691
0000a6  ee016aa1          VMLA.F32 s12,s3,s3             ;1697
0000aa  ee415a81          VMLA.F32 s11,s3,s2             ;1698
0000ae  ee015a01          VMLA.F32 s10,s2,s2             ;1700
0000b2  ee424a20          VMLA.F32 s9,s4,s1              ;1702
0000b6  ee024a00          VMLA.F32 s8,s4,s0              ;1703
;;;1705             Atb_t_raw6 -= yp * aValues6;
0000ba  ee023a61          VMLS.F32 s6,s4,s3
;;;1706             Atb_t_raw7 -= yp * aValues7;
0000be  ee422a41          VMLS.F32 s5,s4,s2
0000c2  ee3bba20          VADD.F32 s22,s22,s1            ;1684
0000c6  ee399a00          VADD.F32 s18,s18,s0            ;1689
0000ca  ee377a61          VSUB.F32 s14,s14,s3            ;1694
0000ce  ee766ac1          VSUB.F32 s13,s13,s2            ;1695
0000d2  1c40              ADDS     r0,r0,#1              ;1660
0000d4  4584              CMP      r12,r0                ;1660
0000d6  dcc8              BGT      |L26.106|
                  |L26.216|
0000d8  f8d1c008          LDR      r12,[r1,#8]           ;1660
0000dc  690b              LDR      r3,[r1,#0x10]         ;1660
;;;1707   #endif // #if !defined(USE_ARM_ACCELERATION) ... #else
;;;1708           } // for(s32 iMatch=0; iMatch<numMatchingIndexes; iMatch++)
;;;1709   
;;;1710   #if !defined(USE_ARM_ACCELERATION) // natural C
;;;1711           for(s32 ia=0; ia<8; ia++) {
;;;1712             for(s32 ja=ia; ja<8; ja++) {
;;;1713               AtA[ia][ja] = AtA_raw[ia][ja];
;;;1714             }
;;;1715             Atb_t[0][ia] = Atb_t_raw[ia];
;;;1716           }
;;;1717   #else // ARM optimized
;;;1718           AtA[3][3] = AtA_raw33; AtA[3][4] = AtA_raw34; AtA[3][5] = AtA_raw35; AtA[3][6] = AtA_raw36; AtA[3][7] = AtA_raw37;
0000de  2003              MOVS     r0,#3
0000e0  fb00300c          MLA      r0,r0,r12,r3
0000e4  ed80ca03          VSTR     s24,[r0,#0xc]
0000e8  f8d1c008          LDR      r12,[r1,#8]
0000ec  690b              LDR      r3,[r1,#0x10]
0000ee  2003              MOVS     r0,#3
0000f0  fb00300c          MLA      r0,r0,r12,r3
0000f4  edc0ba04          VSTR     s23,[r0,#0x10]
0000f8  f8d1c008          LDR      r12,[r1,#8]
0000fc  690b              LDR      r3,[r1,#0x10]
0000fe  2003              MOVS     r0,#3
000100  fb00300c          MLA      r0,r0,r12,r3
000104  ed80ba05          VSTR     s22,[r0,#0x14]
000108  f8d1c008          LDR      r12,[r1,#8]
00010c  690b              LDR      r3,[r1,#0x10]
00010e  2003              MOVS     r0,#3
000110  fb00300c          MLA      r0,r0,r12,r3
000114  edc0aa06          VSTR     s21,[r0,#0x18]
000118  f8d1c008          LDR      r12,[r1,#8]
00011c  690b              LDR      r3,[r1,#0x10]
00011e  2003              MOVS     r0,#3
000120  fb00300c          MLA      r0,r0,r12,r3
000124  ed80aa07          VSTR     s20,[r0,#0x1c]
000128  f8d1c008          LDR      r12,[r1,#8]
00012c  690b              LDR      r3,[r1,#0x10]
;;;1719           AtA[4][4] = AtA_raw44; AtA[4][5] = AtA_raw45; AtA[4][6] = AtA_raw46; AtA[4][7] = AtA_raw47;
00012e  2004              MOVS     r0,#4
000130  fb00300c          MLA      r0,r0,r12,r3
000134  edc09a04          VSTR     s19,[r0,#0x10]
000138  f8d1c008          LDR      r12,[r1,#8]
00013c  690b              LDR      r3,[r1,#0x10]
00013e  2004              MOVS     r0,#4
000140  fb00300c          MLA      r0,r0,r12,r3
000144  ed809a05          VSTR     s18,[r0,#0x14]
000148  f8d1c008          LDR      r12,[r1,#8]
00014c  690b              LDR      r3,[r1,#0x10]
00014e  2004              MOVS     r0,#4
000150  fb00300c          MLA      r0,r0,r12,r3
000154  edc08a06          VSTR     s17,[r0,#0x18]
000158  f8d1c008          LDR      r12,[r1,#8]
00015c  690b              LDR      r3,[r1,#0x10]
00015e  2004              MOVS     r0,#4
000160  fb00300c          MLA      r0,r0,r12,r3
000164  ed808a07          VSTR     s16,[r0,#0x1c]
000168  f8d1c008          LDR      r12,[r1,#8]
00016c  690b              LDR      r3,[r1,#0x10]
;;;1720           AtA[5][5] = AtA_raw55; AtA[5][6] = AtA_raw56; AtA[5][7] = AtA_raw57;
00016e  2005              MOVS     r0,#5
000170  fb00300c          MLA      r0,r0,r12,r3
000174  edc07a05          VSTR     s15,[r0,#0x14]
000178  f8d1c008          LDR      r12,[r1,#8]
00017c  690b              LDR      r3,[r1,#0x10]
00017e  2005              MOVS     r0,#5
000180  fb00300c          MLA      r0,r0,r12,r3
000184  ed807a06          VSTR     s14,[r0,#0x18]
000188  f8d1c008          LDR      r12,[r1,#8]
00018c  690b              LDR      r3,[r1,#0x10]
00018e  2005              MOVS     r0,#5
000190  fb00300c          MLA      r0,r0,r12,r3
000194  edc06a07          VSTR     s13,[r0,#0x1c]
000198  f8d1c008          LDR      r12,[r1,#8]
00019c  690b              LDR      r3,[r1,#0x10]
;;;1721           AtA[6][6] = AtA_raw66; AtA[6][7] = AtA_raw67;
00019e  2006              MOVS     r0,#6
0001a0  fb00300c          MLA      r0,r0,r12,r3
0001a4  ed806a06          VSTR     s12,[r0,#0x18]
0001a8  f8d1c008          LDR      r12,[r1,#8]
0001ac  690b              LDR      r3,[r1,#0x10]
0001ae  2006              MOVS     r0,#6
0001b0  fb00300c          MLA      r0,r0,r12,r3
0001b4  edc05a07          VSTR     s11,[r0,#0x1c]
0001b8  690b              LDR      r3,[r1,#0x10]
0001ba  6889              LDR      r1,[r1,#8]
;;;1722           AtA[7][7] = AtA_raw77;
0001bc  2007              MOVS     r0,#7
0001be  fb003001          MLA      r0,r0,r1,r3
0001c2  ed805a07          VSTR     s10,[r0,#0x1c]
0001c6  6893              LDR      r3,[r2,#8]
0001c8  6911              LDR      r1,[r2,#0x10]
;;;1723   
;;;1724           Atb_t[0][3] = Atb_t_raw3; Atb_t[0][4] = Atb_t_raw4; Atb_t[0][5] = Atb_t_raw5; Atb_t[0][6] = Atb_t_raw6; Atb_t[0][7] = Atb_t_raw7;
0001ca  2000              MOVS     r0,#0
0001cc  fb001003          MLA      r0,r0,r3,r1
0001d0  edc04a03          VSTR     s9,[r0,#0xc]
0001d4  6893              LDR      r3,[r2,#8]
0001d6  6911              LDR      r1,[r2,#0x10]
0001d8  2000              MOVS     r0,#0
0001da  fb001003          MLA      r0,r0,r3,r1
0001de  ed804a04          VSTR     s8,[r0,#0x10]
0001e2  6893              LDR      r3,[r2,#8]
0001e4  6911              LDR      r1,[r2,#0x10]
0001e6  2000              MOVS     r0,#0
0001e8  fb001003          MLA      r0,r0,r3,r1
0001ec  edc03a05          VSTR     s7,[r0,#0x14]
0001f0  6893              LDR      r3,[r2,#8]
0001f2  6911              LDR      r1,[r2,#0x10]
0001f4  2000              MOVS     r0,#0
0001f6  fb001003          MLA      r0,r0,r3,r1
0001fa  ed803a06          VSTR     s6,[r0,#0x18]
0001fe  6911              LDR      r1,[r2,#0x10]
000200  6892              LDR      r2,[r2,#8]
000202  2000              MOVS     r0,#0
000204  fb001002          MLA      r0,r0,r2,r1
000208  edc02a07          VSTR     s5,[r0,#0x1c]
;;;1725   #endif // #if !defined(USE_ARM_ACCELERATION) ... #else
;;;1726   
;;;1727           return RESULT_OK;
00020c  2000              MOVS     r0,#0
;;;1728         }
00020e  ecbd8b0a          VPOP     {d8-d12}
000212  bc10              POP      {r4}
000214  4770              BX       lr
;;;1729   
                          ENDP

000216  0000              DCW      0x0000
                  |L26.536|
000218  00000000          DCFS     0x00000000 ; 0
                  |L26.540|
00021c  3f800000          DCFS     0x3f800000 ; 1

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker44ApplyHorizontalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTracker44ApplyHorizontalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::ApplyHorizontalCorrespondenceList_Projective(const Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>&, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
                  |symbol_number.447|
;;;1729   
;;;1730         NO_INLINE Result BinaryTracker::ApplyHorizontalCorrespondenceList_Projective(
000000  b410              PUSH     {r4}
;;;1731           const FixedLengthList<IndexCorrespondence> &matchingIndexes,
;;;1732           Array<f32> &AtA,
;;;1733           Array<f32> &Atb_t)
;;;1734         {
000002  ed2d8b0a          VPUSH    {d8-d12}
;;;1735           const s32 numMatchingIndexes = matchingIndexes.get_size();
;;;1736           const IndexCorrespondence * restrict pMatchingIndexes = matchingIndexes.Pointer(0);
;;;1737   
;;;1738           // These addresses should be known at compile time, so should be faster
;;;1739   #if !defined(USE_ARM_ACCELERATION) // natural C
;;;1740           f32 AtA_raw[8][8];
;;;1741           f32 Atb_t_raw[8];
;;;1742   
;;;1743           for(s32 ia=0; ia<8; ia++) {
;;;1744             for(s32 ja=0; ja<8; ja++) {
;;;1745               AtA_raw[ia][ja] = 0;
;;;1746             }
;;;1747             Atb_t_raw[ia] = 0;
;;;1748           }
;;;1749   #else // ARM optimized
;;;1750           f32 AtA_raw00 = 0, AtA_raw01 = 0, AtA_raw02 = 0, AtA_raw06 = 0, AtA_raw07 = 0;
000006  eddf2a84          VLDR     s5,|L27.536|
;;;1751           f32 AtA_raw11 = 0, AtA_raw12 = 0, AtA_raw16 = 0, AtA_raw17 = 0;
;;;1752           f32 AtA_raw22 = 0, AtA_raw26 = 0, AtA_raw27 = 0;
;;;1753           f32 AtA_raw66 = 0, AtA_raw67 = 0;
;;;1754           f32 AtA_raw77 = 0;
;;;1755   
;;;1756           f32 Atb_t_raw0 = 0, Atb_t_raw1 = 0, Atb_t_raw2 = 0, Atb_t_raw6 = 0, Atb_t_raw7 = 0;
;;;1757   #endif // #if !defined(USE_ARM_ACCELERATION) ... #else
;;;1758   
;;;1759           for(s32 iMatch=0; iMatch<numMatchingIndexes; iMatch++) {
00000a  f8d0c00c          LDR      r12,[r0,#0xc]
00000e  6b04              LDR      r4,[r0,#0x30]
000010  2000              MOVS     r0,#0
000012  eeb0ca62          VMOV.F32 s24,s5                ;1750
000016  eef0ba62          VMOV.F32 s23,s5                ;1750
00001a  eeb0ba62          VMOV.F32 s22,s5                ;1750
00001e  eef0aa62          VMOV.F32 s21,s5                ;1750
000022  eeb0aa62          VMOV.F32 s20,s5                ;1750
000026  eef09a62          VMOV.F32 s19,s5                ;1751
00002a  eeb09a62          VMOV.F32 s18,s5                ;1751
00002e  eef08a62          VMOV.F32 s17,s5                ;1751
000032  eeb08a62          VMOV.F32 s16,s5                ;1751
000036  eef07a62          VMOV.F32 s15,s5                ;1752
00003a  eeb07a62          VMOV.F32 s14,s5                ;1752
00003e  eef06a62          VMOV.F32 s13,s5                ;1752
000042  eeb06a62          VMOV.F32 s12,s5                ;1753
000046  eef05a62          VMOV.F32 s11,s5                ;1753
00004a  eeb05a62          VMOV.F32 s10,s5                ;1754
00004e  eef04a62          VMOV.F32 s9,s5                 ;1756
000052  eeb04a62          VMOV.F32 s8,s5                 ;1756
000056  eef03a62          VMOV.F32 s7,s5                 ;1756
00005a  eeb03a62          VMOV.F32 s6,s5                 ;1756
00005e  f1bc0f00          CMP      r12,#0
;;;1760             const f32 xc = pMatchingIndexes[iMatch].templatePoint.x;
;;;1761             const f32 yc = pMatchingIndexes[iMatch].templatePoint.y;
;;;1762   
;;;1763             const f32 xp = pMatchingIndexes[iMatch].matchedPoint.x;
;;;1764             //const f32 yp = pMatchingIndexes[iMatch].matchedPoint.y;
;;;1765   
;;;1766   #if !defined(USE_ARM_ACCELERATION) // natural C
;;;1767             const f32 aValues[8] = {xc, yc, 1, 0, 0, 0, -xc*xp, -yc*xp};
;;;1768   
;;;1769             const f32 bValue = xp;
;;;1770   
;;;1771             for(s32 ia=0; ia<8; ia++) {
;;;1772               for(s32 ja=ia; ja<8; ja++) {
;;;1773                 AtA_raw[ia][ja] += aValues[ia] * aValues[ja];
;;;1774               }
;;;1775   
;;;1776               Atb_t_raw[ia] += aValues[ia] * bValue;
;;;1777             }
;;;1778   #else // ARM optimized
;;;1779             const f32 aValues6 = -xc*xp;
;;;1780             const f32 aValues7 = -yc*xp;
;;;1781   
;;;1782             AtA_raw00 += xc * xc;
;;;1783             AtA_raw01 += xc * yc;
;;;1784             AtA_raw02 += xc;
;;;1785             AtA_raw06 += xc * aValues6;
;;;1786             AtA_raw07 += xc * aValues7;
;;;1787   
;;;1788             AtA_raw11 += yc * yc;
;;;1789             AtA_raw12 += yc;
;;;1790             AtA_raw16 += yc * aValues6;
;;;1791             AtA_raw17 += yc * aValues7;
;;;1792   
;;;1793             AtA_raw22 += 1;
000062  bfc8              IT       GT
000064  eddfca6d          VLDRGT   s25,|L27.540|
000068  dd36              BLE      |L27.216|
                  |L27.106|
00006a  eb041300          ADD      r3,r4,r0,LSL #4       ;1760
00006e  ee777aac          VADD.F32 s15,s15,s25
000072  ed932a02          VLDR     s4,[r3,#8]            ;1763
000076  edd30a00          VLDR     s1,[r3,#0]            ;1760
00007a  ed930a01          VLDR     s0,[r3,#4]            ;1761
;;;1794             AtA_raw26 += aValues6;
;;;1795             AtA_raw27 += aValues7;
;;;1796   
;;;1797             AtA_raw66 += aValues6 * aValues6;
;;;1798             AtA_raw67 += aValues6 * aValues7;
;;;1799   
;;;1800             AtA_raw77 += aValues7 * aValues7;
;;;1801   
;;;1802             Atb_t_raw0 += xc * xp;
;;;1803             Atb_t_raw1 += yc * xp;
;;;1804             Atb_t_raw2 += xp;
00007e  ee733a82          VADD.F32 s7,s7,s4
000082  ee601ac2          VNMUL.F32 s3,s1,s4              ;1779
000086  ee201a42          VNMUL.F32 s2,s0,s4              ;1780
00008a  ee00caa0          VMLA.F32 s24,s1,s1             ;1782
00008e  ee40ba80          VMLA.F32 s23,s1,s0             ;1783
000092  ee40aaa1          VMLA.F32 s21,s1,s3             ;1785
000096  ee00aa81          VMLA.F32 s20,s1,s2             ;1786
00009a  ee409a00          VMLA.F32 s19,s0,s0             ;1788
00009e  ee408a21          VMLA.F32 s17,s0,s3             ;1790
0000a2  ee008a01          VMLA.F32 s16,s0,s2             ;1791
0000a6  ee016aa1          VMLA.F32 s12,s3,s3             ;1797
0000aa  ee415a81          VMLA.F32 s11,s3,s2             ;1798
0000ae  ee015a01          VMLA.F32 s10,s2,s2             ;1800
0000b2  ee404a82          VMLA.F32 s9,s1,s4              ;1802
0000b6  ee004a02          VMLA.F32 s8,s0,s4              ;1803
;;;1805             Atb_t_raw6 += aValues6 * xp;
0000ba  ee013a82          VMLA.F32 s6,s3,s4
;;;1806             Atb_t_raw7 += aValues7 * xp;
0000be  ee412a02          VMLA.F32 s5,s2,s4
0000c2  ee3bba20          VADD.F32 s22,s22,s1            ;1784
0000c6  ee399a00          VADD.F32 s18,s18,s0            ;1789
0000ca  ee377a21          VADD.F32 s14,s14,s3            ;1794
0000ce  ee766a81          VADD.F32 s13,s13,s2            ;1795
0000d2  1c40              ADDS     r0,r0,#1              ;1759
0000d4  4584              CMP      r12,r0                ;1759
0000d6  dcc8              BGT      |L27.106|
                  |L27.216|
0000d8  f8d1c008          LDR      r12,[r1,#8]           ;1759
0000dc  690b              LDR      r3,[r1,#0x10]         ;1759
;;;1807   #endif // #if !defined(USE_ARM_ACCELERATION) ... #else
;;;1808           } // for(s32 iMatch=0; iMatch<numMatchingIndexes; iMatch++)
;;;1809   
;;;1810   #if !defined(USE_ARM_ACCELERATION) // natural C
;;;1811           for(s32 ia=0; ia<8; ia++) {
;;;1812             for(s32 ja=ia; ja<8; ja++) {
;;;1813               AtA[ia][ja] = AtA_raw[ia][ja];
;;;1814             }
;;;1815             Atb_t[0][ia] = Atb_t_raw[ia];
;;;1816           }
;;;1817   #else // ARM optimized
;;;1818           AtA[0][0] = AtA_raw00; AtA[0][1] = AtA_raw01; AtA[0][2] = AtA_raw02; AtA[0][6] = AtA_raw06; AtA[0][7] = AtA_raw07;
0000de  2000              MOVS     r0,#0
0000e0  fb00300c          MLA      r0,r0,r12,r3
0000e4  ed80ca00          VSTR     s24,[r0,#0]
0000e8  f8d1c008          LDR      r12,[r1,#8]
0000ec  690b              LDR      r3,[r1,#0x10]
0000ee  2000              MOVS     r0,#0
0000f0  fb00300c          MLA      r0,r0,r12,r3
0000f4  edc0ba01          VSTR     s23,[r0,#4]
0000f8  f8d1c008          LDR      r12,[r1,#8]
0000fc  690b              LDR      r3,[r1,#0x10]
0000fe  2000              MOVS     r0,#0
000100  fb00300c          MLA      r0,r0,r12,r3
000104  ed80ba02          VSTR     s22,[r0,#8]
000108  f8d1c008          LDR      r12,[r1,#8]
00010c  690b              LDR      r3,[r1,#0x10]
00010e  2000              MOVS     r0,#0
000110  fb00300c          MLA      r0,r0,r12,r3
000114  edc0aa06          VSTR     s21,[r0,#0x18]
000118  f8d1c008          LDR      r12,[r1,#8]
00011c  690b              LDR      r3,[r1,#0x10]
00011e  2000              MOVS     r0,#0
000120  fb00300c          MLA      r0,r0,r12,r3
000124  ed80aa07          VSTR     s20,[r0,#0x1c]
000128  f8d1c008          LDR      r12,[r1,#8]
00012c  690b              LDR      r3,[r1,#0x10]
;;;1819           AtA[1][1] = AtA_raw11; AtA[1][2] = AtA_raw12; AtA[1][6] = AtA_raw16; AtA[1][7] = AtA_raw17;
00012e  2001              MOVS     r0,#1
000130  fb00300c          MLA      r0,r0,r12,r3
000134  edc09a01          VSTR     s19,[r0,#4]
000138  f8d1c008          LDR      r12,[r1,#8]
00013c  690b              LDR      r3,[r1,#0x10]
00013e  2001              MOVS     r0,#1
000140  fb00300c          MLA      r0,r0,r12,r3
000144  ed809a02          VSTR     s18,[r0,#8]
000148  f8d1c008          LDR      r12,[r1,#8]
00014c  690b              LDR      r3,[r1,#0x10]
00014e  2001              MOVS     r0,#1
000150  fb00300c          MLA      r0,r0,r12,r3
000154  edc08a06          VSTR     s17,[r0,#0x18]
000158  f8d1c008          LDR      r12,[r1,#8]
00015c  690b              LDR      r3,[r1,#0x10]
00015e  2001              MOVS     r0,#1
000160  fb00300c          MLA      r0,r0,r12,r3
000164  ed808a07          VSTR     s16,[r0,#0x1c]
000168  f8d1c008          LDR      r12,[r1,#8]
00016c  690b              LDR      r3,[r1,#0x10]
;;;1820           AtA[2][2] = AtA_raw22; AtA[2][6] = AtA_raw26; AtA[2][7] = AtA_raw27;
00016e  2002              MOVS     r0,#2
000170  fb00300c          MLA      r0,r0,r12,r3
000174  edc07a02          VSTR     s15,[r0,#8]
000178  f8d1c008          LDR      r12,[r1,#8]
00017c  690b              LDR      r3,[r1,#0x10]
00017e  2002              MOVS     r0,#2
000180  fb00300c          MLA      r0,r0,r12,r3
000184  ed807a06          VSTR     s14,[r0,#0x18]
000188  f8d1c008          LDR      r12,[r1,#8]
00018c  690b              LDR      r3,[r1,#0x10]
00018e  2002              MOVS     r0,#2
000190  fb00300c          MLA      r0,r0,r12,r3
000194  edc06a07          VSTR     s13,[r0,#0x1c]
000198  f8d1c008          LDR      r12,[r1,#8]
00019c  690b              LDR      r3,[r1,#0x10]
;;;1821           AtA[6][6] = AtA_raw66; AtA[6][7] = AtA_raw67;
00019e  2006              MOVS     r0,#6
0001a0  fb00300c          MLA      r0,r0,r12,r3
0001a4  ed806a06          VSTR     s12,[r0,#0x18]
0001a8  f8d1c008          LDR      r12,[r1,#8]
0001ac  690b              LDR      r3,[r1,#0x10]
0001ae  2006              MOVS     r0,#6
0001b0  fb00300c          MLA      r0,r0,r12,r3
0001b4  edc05a07          VSTR     s11,[r0,#0x1c]
0001b8  690b              LDR      r3,[r1,#0x10]
0001ba  6889              LDR      r1,[r1,#8]
;;;1822           AtA[7][7] = AtA_raw77;
0001bc  2007              MOVS     r0,#7
0001be  fb003001          MLA      r0,r0,r1,r3
0001c2  ed805a07          VSTR     s10,[r0,#0x1c]
0001c6  6893              LDR      r3,[r2,#8]
0001c8  6911              LDR      r1,[r2,#0x10]
;;;1823   
;;;1824           Atb_t[0][0] = Atb_t_raw0; Atb_t[0][1] = Atb_t_raw1; Atb_t[0][2] = Atb_t_raw2; Atb_t[0][6] = Atb_t_raw6; Atb_t[0][7] = Atb_t_raw7;
0001ca  2000              MOVS     r0,#0
0001cc  fb001003          MLA      r0,r0,r3,r1
0001d0  edc04a00          VSTR     s9,[r0,#0]
0001d4  6893              LDR      r3,[r2,#8]
0001d6  6911              LDR      r1,[r2,#0x10]
0001d8  2000              MOVS     r0,#0
0001da  fb001003          MLA      r0,r0,r3,r1
0001de  ed804a01          VSTR     s8,[r0,#4]
0001e2  6893              LDR      r3,[r2,#8]
0001e4  6911              LDR      r1,[r2,#0x10]
0001e6  2000              MOVS     r0,#0
0001e8  fb001003          MLA      r0,r0,r3,r1
0001ec  edc03a02          VSTR     s7,[r0,#8]
0001f0  6893              LDR      r3,[r2,#8]
0001f2  6911              LDR      r1,[r2,#0x10]
0001f4  2000              MOVS     r0,#0
0001f6  fb001003          MLA      r0,r0,r3,r1
0001fa  ed803a06          VSTR     s6,[r0,#0x18]
0001fe  6911              LDR      r1,[r2,#0x10]
000200  6892              LDR      r2,[r2,#8]
000202  2000              MOVS     r0,#0
000204  fb001002          MLA      r0,r0,r2,r1
000208  edc02a07          VSTR     s5,[r0,#0x1c]
;;;1825   #endif // #if !defined(USE_ARM_ACCELERATION) ... #else
;;;1826   
;;;1827           return RESULT_OK;
00020c  2000              MOVS     r0,#0
;;;1828         }
00020e  ecbd8b0a          VPOP     {d8-d12}
000212  bc10              POP      {r4}
000214  4770              BX       lr
;;;1829   
                          ENDP

000216  0000              DCW      0x0000
                  |L27.536|
000218  00000000          DCFS     0x00000000 ; 0
                  |L27.540|
00021c  3f800000          DCFS     0x3f800000 ; 1

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC1ENS_6Vision10MarkerTypeERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfRKNS2_23EdgeDetectionParametersERNS0_11MemoryStackESH_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC2ENS_6Vision10MarkerTypeERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfRKNS2_23EdgeDetectionParametersERNS0_11MemoryStackESH_                  ; Alternate entry point ; Anki::Embedded::TemplateTracker::BinaryTracker::BinaryTracker__sub_object(Anki::Vision::MarkerType, const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, float, const Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters&, Anki::Embedded::MemoryStack&, Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC1ENS_6Vision10MarkerTypeERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfRKNS2_23EdgeDetectionParametersERNS0_11MemoryStackESH_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::BinaryTracker(Anki::Vision::MarkerType, const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, float, const Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters&, Anki::Embedded::MemoryStack&, Anki::Embedded::MemoryStack&)
;;;143    
;;;144          BinaryTracker::BinaryTracker(
;;;145            const Anki::Vision::MarkerType markerType,
;;;146            const Array<u8> &templateImage,
;;;147            const Quadrilateral<f32> &templateQuad,
;;;148            const f32 scaleTemplateRegionPercent,
;;;149            const EdgeDetectionParameters &edgeDetectionParams,
;;;150            MemoryStack &fastMemory,
;;;151            MemoryStack &slowMemory)
;;;152            : isValid(false)
;;;153          {
;;;154            const bool useRealTemplateImage = true;
;;;155    
;;;156            this->templateImageHeight = templateImage.get_size(0);
;;;157            this->templateImageWidth = templateImage.get_size(1);
;;;158    
;;;159            // Only a few markers are currently supported
;;;160    
;;;161            // TODO: Update this now that we've removed the battery marker image
;;;162    
;;;163            //AnkiConditionalErrorAndReturn(markerType == Anki::Vision::MARKER_BATTERIES,
;;;164            //  "BinaryTracker::BinaryTracker", "markerType %d is not supported for header initialization", markerType);
;;;165            AnkiError("BinaryTracker::BinaryTracker", "BinaryTracker needs to be updated now that Battery marker has been removed.");
;;;166    
;;;167            AnkiConditionalErrorAndReturn(templateImageHeight > 0 && templateImageWidth > 0,
;;;168              "BinaryTracker::BinaryTracker", "template widths and heights must be greater than zero");
;;;169    
;;;170            // TODO: make this work for non-qvga resolution
;;;171            Point<f32> centerOffset((templateImageWidth-1) / 2.0f, (templateImageHeight-1) / 2.0f);
;;;172            this->transformation = Transformations::PlanarTransformation_f32(Transformations::TRANSFORM_PROJECTIVE, templateQuad, centerOffset, slowMemory);
;;;173    
;;;174            this->templateQuad = templateQuad;
;;;175    
;;;176            this->templateEdges.xDecreasing = FixedLengthList<Point<s16> >(edgeDetectionParams.maxDetectionsPerType, fastMemory);
;;;177            this->templateEdges.xIncreasing = FixedLengthList<Point<s16> >(edgeDetectionParams.maxDetectionsPerType, fastMemory);
;;;178            this->templateEdges.yDecreasing = FixedLengthList<Point<s16> >(edgeDetectionParams.maxDetectionsPerType, fastMemory);
;;;179            this->templateEdges.yIncreasing = FixedLengthList<Point<s16> >(edgeDetectionParams.maxDetectionsPerType, fastMemory);
;;;180    
;;;181            //this->templateIntegerCounts = IntegerCounts(256, fastMemory);
;;;182            //this->lastImageIntegerCounts = IntegerCounts(256, fastMemory);
;;;183    
;;;184            this->templateImage = Array<u8>(templateImageHeight, templateImageWidth, slowMemory);
;;;185    
;;;186            AnkiConditionalErrorAndReturn(
;;;187              AreValid(this->templateEdges.xDecreasing, this->templateEdges.xIncreasing, this->templateEdges.yDecreasing, this->templateEdges.yIncreasing, this->templateImage),
;;;188              "BinaryTracker::BinaryTracker", "Could not allocate local memory");
;;;189    
;;;190            this->templateImage.Set(templateImage);
;;;191    
;;;192            // Place the header image in the templateImage
;;;193            {
;;;194              PUSH_MEMORY_STACK(slowMemory);
;;;195    
;;;196              const s32 borderWidth = edgeDetectionParams.minComponentWidth + 2;
;;;197    
;;;198              //
;;;199              // Decode the compressed binary image to an uncompressed image
;;;200              //
;;;201    
;;;202              Array<u8> binaryTemplate;
;;;203    
;;;204              // TODO: BinaryTracker needs to be updated now that Battery marker has been removed
;;;205              if(false) { //markerType == Anki::Vision::MARKER_BATTERIES) {
;;;206                binaryTemplate = DecodeRunLengthBinary<u8>(
;;;207                  &battery[0], battery_WIDTH,
;;;208                  battery_ORIGINAL_HEIGHT, battery_ORIGINAL_WIDTH, Flags::Buffer(false,false,false),
;;;209                  slowMemory);
;;;210              }
;;;211    
;;;212              AnkiConditionalErrorAndReturn(binaryTemplate.IsValid(),
;;;213                "BinaryTracker::BinaryTracker", "Could not allocate local memory");
;;;214    
;;;215              Matrix::DotMultiply<u8,u8,u8>(binaryTemplate, 255, binaryTemplate);
;;;216    
;;;217              const s32 binaryTemplateHeight = binaryTemplate.get_size(0);
;;;218              const s32 binaryTemplateWidth = binaryTemplate.get_size(1);
;;;219    
;;;220              //
;;;221              // Create a padded version of the binary template
;;;222              //
;;;223    
;;;224              const s32 binaryTemplateWithBorderHeight = binaryTemplateHeight + 2*borderWidth;
;;;225              const s32 binaryTemplateWithBorderWidth = binaryTemplateWidth + 2*borderWidth;
;;;226              Array<u8> binaryTemplateWithBorder(binaryTemplateWithBorderHeight, binaryTemplateWithBorderWidth, slowMemory, Flags::Buffer(false,false,false));
;;;227    
;;;228              AnkiConditionalErrorAndReturn(binaryTemplateWithBorder.IsValid(),
;;;229                "BinaryTracker::BinaryTracker", "Could not allocate local memory");
;;;230    
;;;231              binaryTemplateWithBorder.Set(255);
;;;232    
;;;233              for(s32 y=0; y<binaryTemplateHeight; y++) {
;;;234                const u8 * restrict pBinaryTemplate = binaryTemplate.Pointer(y,0);
;;;235                u8 * restrict pBinaryTemplateWithBorder = binaryTemplateWithBorder.Pointer(y+borderWidth,borderWidth);
;;;236    
;;;237                memcpy(pBinaryTemplateWithBorder, pBinaryTemplate, binaryTemplateWidth);
;;;238              }
;;;239    
;;;240              //
;;;241              // Compute the warp between the binary header and fiducial detection
;;;242              //
;;;243    
;;;244              const f32 binaryTemplateHeightF32 = static_cast<f32>(binaryTemplate.get_size(0));
;;;245              const f32 binaryTemplateWidthF32 = static_cast<f32>(binaryTemplate.get_size(1));
;;;246    
;;;247              FixedLengthList<Point<f32> > binaryCorners(4, slowMemory);
;;;248              binaryCorners.set_size(4);
;;;249              binaryCorners[0] = Point<f32>(0.5f+borderWidth,                        0.5f+borderWidth);
;;;250              binaryCorners[1] = Point<f32>(0.5f+borderWidth,                        binaryTemplateHeightF32-0.5f+borderWidth);
;;;251              binaryCorners[2] = Point<f32>(binaryTemplateWidthF32-0.5f+borderWidth, 0.5f+borderWidth);
;;;252              binaryCorners[3] = Point<f32>(binaryTemplateWidthF32-0.5f+borderWidth, binaryTemplateHeightF32-0.5f+borderWidth);
;;;253    
;;;254              FixedLengthList<Point<f32> > templateCorners(4, slowMemory);
;;;255              templateCorners.set_size(4);
;;;256              templateCorners[0] = templateQuad[0];
;;;257              templateCorners[1] = templateQuad[1];
;;;258              templateCorners[2] = templateQuad[2];
;;;259              templateCorners[3] = templateQuad[3];
;;;260    
;;;261              Array<f32> binaryTemplateHomography(3, 3, slowMemory);
;;;262              bool numericalFailure;
;;;263              Matrix::EstimateHomography(binaryCorners, templateCorners, binaryTemplateHomography, numericalFailure, slowMemory);
;;;264    
;;;265              Transformations::PlanarTransformation_f32 binaryTemplateTransform(
;;;266                Transformations::TRANSFORM_PROJECTIVE,
;;;267                Quadrilateral<f32>(binaryCorners[0], binaryCorners[1], binaryCorners[2], binaryCorners[3]),
;;;268                binaryTemplateHomography,
;;;269                Point<f32>(0.0f,0.0f),
;;;270                slowMemory);
;;;271    
;;;272              this->originalTemplateOrientation = binaryTemplateTransform.get_transformedOrientation(slowMemory);
;;;273    
;;;274              Array<u8> rotatedBinaryTemplateWithBorder(binaryTemplateWithBorder.get_size(0), binaryTemplateWithBorder.get_size(1), slowMemory);
;;;275    
;;;276              s32 rotationOrder[4];
;;;277              if(this->originalTemplateOrientation >= (-PI/4) && this->originalTemplateOrientation < (PI/4)) { // No rotation
;;;278                rotatedBinaryTemplateWithBorder.Set(binaryTemplateWithBorder);
;;;279    
;;;280                rotationOrder[0] = 0;
;;;281                rotationOrder[1] = 1;
;;;282                rotationOrder[2] = 2;
;;;283                rotationOrder[3] = 3;
;;;284              } else if(this->originalTemplateOrientation >= (PI/4) && this->originalTemplateOrientation < (3*PI/4)) { // Rotate 90 degrees clockwise
;;;285                Matrix::Rotate90<u8,u8>(binaryTemplateWithBorder, rotatedBinaryTemplateWithBorder);
;;;286    
;;;287                rotationOrder[0] = 2;
;;;288                rotationOrder[1] = 0;
;;;289                rotationOrder[2] = 3;
;;;290                rotationOrder[3] = 1;
;;;291              } else if(this->originalTemplateOrientation >= (3*PI/4) && this->originalTemplateOrientation < (5*PI/4)) { // Rotate 180 degrees clockwise
;;;292                Matrix::Rotate180<u8,u8>(binaryTemplateWithBorder, rotatedBinaryTemplateWithBorder);
;;;293    
;;;294                rotationOrder[0] = 3;
;;;295                rotationOrder[1] = 2;
;;;296                rotationOrder[2] = 1;
;;;297                rotationOrder[3] = 0;
;;;298              } else { // Rotate 270 degrees clockwise
;;;299                Matrix::Rotate270<u8,u8>(binaryTemplateWithBorder, rotatedBinaryTemplateWithBorder);
;;;300    
;;;301                rotationOrder[0] = 1;
;;;302                rotationOrder[1] = 3;
;;;303                rotationOrder[2] = 0;
;;;304                rotationOrder[3] = 2;
;;;305              }
;;;306    
;;;307              FixedLengthList<Point<f32> > rotatedBinaryCorners(4, slowMemory);
;;;308              rotatedBinaryCorners.set_size(4);
;;;309    
;;;310              for(s32 i=0; i<4; i++) {
;;;311                rotatedBinaryCorners[i] = binaryCorners[rotationOrder[i]];
;;;312              }
;;;313    
;;;314              Matrix::EstimateHomography(rotatedBinaryCorners, templateCorners, binaryTemplateHomography, numericalFailure, slowMemory);
;;;315    
;;;316              binaryTemplateTransform.set_homography(binaryTemplateHomography);
;;;317    
;;;318              // Extract the edges, and transform them to the actual fiducial detection location
;;;319              // TODO: add subpixel
;;;320              const Rectangle<s32> templateRect(0, binaryTemplateWithBorderWidth-1, 0, binaryTemplateWithBorderHeight-1);
;;;321    
;;;322              Result result = RESULT_FAIL;
;;;323              if(edgeDetectionParams.type == TemplateTracker::BinaryTracker::EDGE_TYPE_GRAYVALUE) {
;;;324                result = DetectBlurredEdges_GrayvalueThreshold(rotatedBinaryTemplateWithBorder, templateRect, 128, edgeDetectionParams.minComponentWidth, edgeDetectionParams.everyNLines, this->templateEdges);
;;;325              } else if(edgeDetectionParams.type == TemplateTracker::BinaryTracker::EDGE_TYPE_DERIVATIVE) {
;;;326                result = DetectBlurredEdges_DerivativeThreshold(rotatedBinaryTemplateWithBorder, templateRect, edgeDetectionParams.combHalfWidth, edgeDetectionParams.combResponseThreshold, edgeDetectionParams.everyNLines, this->templateEdges);
;;;327              }
;;;328    
;;;329              this->templateEdges.imageHeight = templateImageHeight;
;;;330              this->templateEdges.imageWidth = templateImageWidth;
;;;331    
;;;332              AnkiConditionalErrorAndReturn(result == RESULT_OK,
;;;333                "BinaryTracker::BinaryTracker", "DetectBlurredEdge failed");
;;;334    
;;;335              binaryTemplateTransform.Transform(this->templateEdges.xDecreasing, this->templateEdges.xDecreasing, slowMemory);
;;;336              binaryTemplateTransform.Transform(this->templateEdges.xIncreasing, this->templateEdges.xIncreasing, slowMemory);
;;;337              binaryTemplateTransform.Transform(this->templateEdges.yDecreasing, this->templateEdges.yDecreasing, slowMemory);
;;;338              binaryTemplateTransform.Transform(this->templateEdges.yIncreasing, this->templateEdges.yIncreasing, slowMemory);
;;;339    
;;;340              //this->templateImage.Show("template real", false, false, true);
;;;341              //this->ShowTemplate("Template", false, true);
;;;342    
;;;343              if(!useRealTemplateImage) {
;;;344                // Just warp the binary header image to the template image
;;;345                bool numericalFailure;
;;;346                Matrix::EstimateHomography(templateCorners, binaryCorners, binaryTemplateHomography, numericalFailure, slowMemory);
;;;347                const Point<f32> centerOffset(0.0f, 0.0f);
;;;348                Meshgrid<f32> originalCoordinates( LinearSequence<f32>(0.5f, 1.0f, templateImageWidth-0.5f), LinearSequence<f32>(0.5f, 1.0f, templateImageHeight-0.5f));
;;;349    
;;;350                Interp2_Projective<u8,u8>(binaryTemplateWithBorder, originalCoordinates, binaryTemplateHomography, centerOffset, this->templateImage, INTERPOLATE_LINEAR, 255);
;;;351              }
;;;352    
;;;353              //this->templateImage.Show("template binary", true, false, true);
;;;354    
;;;355              //Matlab matlab(false);
;;;356    
;;;357              //matlab.PutArray(binaryTemplate, "binaryTemplate");
;;;358              //matlab.PutArray(binaryTemplateWithBorder, "binaryTemplateWithBorder");
;;;359              //matlab.PutArray(this->templateImage, "templateImage");
;;;360            }
;;;361    
;;;362            const Rectangle<s32> edgeDetection_imageRegionOfInterest = templateQuad.ComputeBoundingRectangle<s32>().ComputeScaledRectangle<s32>(edgeDetectionParams.threshold_scaleRegionPercent);
;;;363    
;;;364            this->templateIntegerCounts = IntegerCounts(
;;;365              this->templateImage, edgeDetection_imageRegionOfInterest,
;;;366              edgeDetectionParams.threshold_yIncrement,
;;;367              edgeDetectionParams.threshold_xIncrement,
;;;368              fastMemory);
;;;369    
;;;370            AnkiConditionalErrorAndReturn(this->templateIntegerCounts.IsValid() ,
;;;371              "BinaryTracker::BinaryTracker", "Could not allocate local memory");
;;;372    
;;;373            this->lastGrayvalueThreshold = ComputeGrayvalueThreshold(this->templateIntegerCounts, edgeDetectionParams.threshold_blackPercentile, edgeDetectionParams.threshold_whitePercentile);
;;;374    
;;;375            //this->lastImageIntegerCounts.Set(this->templateIntegerCounts);
;;;376            this->lastUsedGrayvalueThreshold = this->lastGrayvalueThreshold;
;;;377    
;;;378            this->isValid = true;
;;;379          }
;;;380    
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  4699              MOV      r9,r3
000006  ed2d0b02          VPUSH    {d0}
00000a  300c              ADDS     r0,r0,#0xc
00000c  ed2d8b04          VPUSH    {d8-d9}
000010  f5ad7d5b          SUB      sp,sp,#0x36c
000014  9ef0              LDR      r6,[sp,#0x3c0]
000016  9dee              LDR      r5,[sp,#0x3b8]
000018  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00001c  f04f37ff          MOV      r7,#0xffffffff
000020  f8407d0c          STR      r7,[r0,#-0xc]!
000024  f04f0800          MOV      r8,#0
000028  6047              STR      r7,[r0,#4]
00002a  f8c08010          STR      r8,[r0,#0x10]
00002e  6087              STR      r7,[r0,#8]
000030  301c              ADDS     r0,r0,#0x1c
000032  2304              MOVS     r3,#4
000034  2208              MOVS     r2,#8
000036  49fe              LDR      r1,|L28.1072|
000038  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
00003c  2100              MOVS     r1,#0
00003e  ed9f8afd          VLDR     s16,|L28.1076|
                  |L28.66|
000042  eb0002c1          ADD      r2,r0,r1,LSL #3
000046  ed8d8a00          VSTR     s16,[sp,#0]
00004a  ed8d8a01          VSTR     s16,[sp,#4]
00004e  ed9d0a00          VLDR     s0,[sp,#0]
000052  1c49              ADDS     r1,r1,#1
000054  ed820a00          VSTR     s0,[r2,#0]
000058  ed9d0a01          VLDR     s0,[sp,#4]
00005c  2904              CMP      r1,#4
00005e  ed820a01          VSTR     s0,[r2,#4]
000062  dbee              BLT      |L28.66|
000064  3020              ADDS     r0,r0,#0x20
000066  f7fffffe          BL       _ZN4Anki8Embedded13IntegerCountsC1Ev ; Anki::Embedded::IntegerCounts::IntegerCounts()
00006a  3038              ADDS     r0,r0,#0x38
00006c  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
000070  3034              ADDS     r0,r0,#0x34
000072  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
000076  3034              ADDS     r0,r0,#0x34
000078  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
00007c  3034              ADDS     r0,r0,#0x34
00007e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
000082  3040              ADDS     r0,r0,#0x40
000084  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1Ev ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32()
000088  f5a074a8          SUB      r4,r0,#0x150
00008c  f8808046          STRB     r8,[r0,#0x46]
000090  2100              MOVS     r1,#0
000092  98e3              LDR      r0,[sp,#0x38c]
000094  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000098  6160              STR      r0,[r4,#0x14]
00009a  2101              MOVS     r1,#1
00009c  98e3              LDR      r0,[sp,#0x38c]
00009e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000a2  61a0              STR      r0,[r4,#0x18]
0000a4  48e4              LDR      r0,|L28.1080|
0000a6  21a5              MOVS     r1,#0xa5
0000a8  e9cd0100          STRD     r0,r1,[sp,#0]
0000ac  f60022cc          ADD      r2,r0,#0xacc
0000b0  a3e2              ADR      r3,|L28.1084|
0000b2  a1ee              ADR      r1,|L28.1132|
0000b4  2005              MOVS     r0,#5
0000b6  f7fffffe          BL       _Anki_Log
0000ba  6961              LDR      r1,[r4,#0x14]
0000bc  2900              CMP      r1,#0
0000be  bfc4              ITT      GT
0000c0  69a0              LDRGT    r0,[r4,#0x18]
0000c2  2800              CMPGT    r0,#0
0000c4  dc11              BGT      |L28.234|
0000c6  21a7              MOVS     r1,#0xa7
0000c8  48db              LDR      r0,|L28.1080|
0000ca  e9cd0100          STRD     r0,r1,[sp,#0]
0000ce  a3db              ADR      r3,|L28.1084|
0000d0  a2ee              ADR      r2,|L28.1164|
0000d2  a1e6              ADR      r1,|L28.1132|
0000d4  2005              MOVS     r0,#5
0000d6  f7fffffe          BL       _Anki_Log
0000da  4620              MOV      r0,r4
                  |L28.220|
0000dc  f50d7d5b          ADD      sp,sp,#0x36c
0000e0  ecbd8b04          VPOP     {d8-d9}
0000e4  b006              ADD      sp,sp,#0x18
0000e6  e8bd8ff0          POP      {r4-r11,pc}
                  |L28.234|
0000ea  1e40              SUBS     r0,r0,#1
0000ec  ee000a10          VMOV     s0,r0
0000f0  eef68a00          VMOV.F32 s17,#0.50000000
0000f4  1e48              SUBS     r0,r1,#1
0000f6  eeb80ac0          VCVT.F32.S32 s0,s0
0000fa  f5047aa8          ADD      r10,r4,#0x150
0000fe  ab0c              ADD      r3,sp,#0x30
000100  464a              MOV      r2,r9
000102  ee600a28          VMUL.F32 s1,s0,s17
000106  ee000a10          VMOV     s0,r0
00010a  f44f6100          MOV      r1,#0x800
00010e  edcd0a0c          VSTR     s1,[sp,#0x30]
000112  eeb80ac0          VCVT.F32.S32 s0,s0
000116  a87b              ADD      r0,sp,#0x1ec
000118  ee200a28          VMUL.F32 s0,s0,s17
00011c  ed8d0a0d          VSTR     s0,[sp,#0x34]
000120  9600              STR      r6,[sp,#0]
000122  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5PointIfEERNS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
000126  7801              LDRB     r1,[r0,#0]
000128  f88a1000          STRB     r1,[r10,#0]
00012c  8841              LDRH     r1,[r0,#2]
00012e  f8aa1002          STRH     r1,[r10,#2]
000132  6842              LDR      r2,[r0,#4]
000134  f8ca2004          STR      r2,[r10,#4]
000138  6882              LDR      r2,[r0,#8]
00013a  f8ca2008          STR      r2,[r10,#8]
00013e  68c2              LDR      r2,[r0,#0xc]
000140  f8ca200c          STR      r2,[r10,#0xc]
000144  6902              LDR      r2,[r0,#0x10]
000146  f8ca2010          STR      r2,[r10,#0x10]
00014a  6942              LDR      r2,[r0,#0x14]
00014c  f10a0b18          ADD      r11,r10,#0x18
000150  f1000c18          ADD      r12,r0,#0x18
000154  2100              MOVS     r1,#0
000156  f8ca2014          STR      r2,[r10,#0x14]
                  |L28.346|
00015a  eb0c02c1          ADD      r2,r12,r1,LSL #3
00015e  eb0b03c1          ADD      r3,r11,r1,LSL #3
000162  ed920a00          VLDR     s0,[r2,#0]
000166  1c49              ADDS     r1,r1,#1
000168  ed830a00          VSTR     s0,[r3,#0]
00016c  ed920a01          VLDR     s0,[r2,#4]
000170  2904              CMP      r1,#4
000172  ed830a01          VSTR     s0,[r3,#4]
000176  dbf0              BLT      |L28.346|
000178  f8901038          LDRB     r1,[r0,#0x38]
00017c  f88a1038          STRB     r1,[r10,#0x38]
000180  ed900a0f          VLDR     s0,[r0,#0x3c]
000184  f104031c          ADD      r3,r4,#0x1c
000188  ed8a0a0f          VSTR     s0,[r10,#0x3c]
00018c  ed900a10          VLDR     s0,[r0,#0x40]
000190  2000              MOVS     r0,#0
000192  ed8a0a10          VSTR     s0,[r10,#0x40]
                  |L28.406|
000196  eb0901c0          ADD      r1,r9,r0,LSL #3
00019a  eb0302c0          ADD      r2,r3,r0,LSL #3
00019e  ed910a00          VLDR     s0,[r1,#0]
0001a2  1c40              ADDS     r0,r0,#1
0001a4  ed820a00          VSTR     s0,[r2,#0]
0001a8  ed910a01          VLDR     s0,[r1,#4]
0001ac  2804              CMP      r0,#4
0001ae  ed820a01          VSTR     s0,[r2,#4]
0001b2  dbf0              BLT      |L28.406|
0001b4  2300              MOVS     r3,#0
0001b6  461a              MOV      r2,r3
0001b8  2101              MOVS     r1,#1
0001ba  a8c0              ADD      r0,sp,#0x300
0001bc  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001c0  6803              LDR      r3,[r0,#0]
0001c2  69e9              LDR      r1,[r5,#0x1c]
0001c4  a84a              ADD      r0,sp,#0x128
0001c6  9aef              LDR      r2,[sp,#0x3bc]
0001c8  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0001cc  4601              MOV      r1,r0
0001ce  f1040074          ADD      r0,r4,#0x74
0001d2  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
0001d6  2300              MOVS     r3,#0
0001d8  461a              MOV      r2,r3
0001da  2101              MOVS     r1,#1
0001dc  a8c0              ADD      r0,sp,#0x300
0001de  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001e2  6803              LDR      r3,[r0,#0]
0001e4  69e9              LDR      r1,[r5,#0x1c]
0001e6  a84a              ADD      r0,sp,#0x128
0001e8  9aef              LDR      r2,[sp,#0x3bc]
0001ea  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0001ee  4601              MOV      r1,r0
0001f0  f10400a8          ADD      r0,r4,#0xa8
0001f4  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
0001f8  2300              MOVS     r3,#0
0001fa  461a              MOV      r2,r3
0001fc  2101              MOVS     r1,#1
0001fe  a8c0              ADD      r0,sp,#0x300
000200  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000204  6803              LDR      r3,[r0,#0]
000206  69e9              LDR      r1,[r5,#0x1c]
000208  a84a              ADD      r0,sp,#0x128
00020a  9aef              LDR      r2,[sp,#0x3bc]
00020c  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000210  4601              MOV      r1,r0
000212  f10400dc          ADD      r0,r4,#0xdc
000216  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
00021a  2300              MOVS     r3,#0
00021c  461a              MOV      r2,r3
00021e  2101              MOVS     r1,#1
000220  a8c0              ADD      r0,sp,#0x300
000222  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000226  6803              LDR      r3,[r0,#0]
000228  69e9              LDR      r1,[r5,#0x1c]
00022a  a84a              ADD      r0,sp,#0x128
00022c  9aef              LDR      r2,[sp,#0x3bc]
00022e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000232  4601              MOV      r1,r0
000234  f5047088          ADD      r0,r4,#0x110
000238  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
00023c  2300              MOVS     r3,#0
00023e  461a              MOV      r2,r3
000240  2101              MOVS     r1,#1
000242  a8c0              ADD      r0,sp,#0x300
000244  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000248  6800              LDR      r0,[r0,#0]
00024a  9000              STR      r0,[sp,#0]
00024c  e9d41005          LDRD     r1,r0,[r4,#0x14]
000250  4602              MOV      r2,r0
000252  4633              MOV      r3,r6
000254  a8d2              ADD      r0,sp,#0x348
000256  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00025a  6801              LDR      r1,[r0,#0]
00025c  6021              STR      r1,[r4,#0]
00025e  6841              LDR      r1,[r0,#4]
000260  6061              STR      r1,[r4,#4]
000262  6881              LDR      r1,[r0,#8]
000264  60a1              STR      r1,[r4,#8]
000266  68c1              LDR      r1,[r0,#0xc]
000268  60e1              STR      r1,[r4,#0xc]
00026a  6900              LDR      r0,[r0,#0x10]
00026c  6120              STR      r0,[r4,#0x10]
00026e  f10401a8          ADD      r1,r4,#0xa8
000272  f1040074          ADD      r0,r4,#0x74
000276  f1040bdc          ADD      r11,r4,#0xdc
00027a  f5047a88          ADD      r10,r4,#0x110
00027e  9100              STR      r1,[sp,#0]
000280  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
000284  2800              CMP      r0,#0
000286  f000826c          BEQ.W    |L28.1890|
00028a  9800              LDR      r0,[sp,#0]
00028c  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
000290  2800              CMP      r0,#0
000292  f0008266          BEQ.W    |L28.1890|
000296  4658              MOV      r0,r11
000298  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
00029c  2800              CMP      r0,#0
00029e  f0008260          BEQ.W    |L28.1890|
0002a2  4650              MOV      r0,r10
0002a4  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
0002a8  2800              CMP      r0,#0
0002aa  f000825a          BEQ.W    |L28.1890|
0002ae  4620              MOV      r0,r4
0002b0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
0002b4  2800              CMP      r0,#0
0002b6  f0008254          BEQ.W    |L28.1890|
0002ba  4620              MOV      r0,r4
0002bc  99e3              LDR      r1,[sp,#0x38c]
0002be  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhE3SetERKS2_ ; Anki::Embedded::Array<unsigned char>::Set(const Anki::Embedded::Array<unsigned char>&)
0002c2  4631              MOV      r1,r6
0002c4  a890              ADD      r0,sp,#0x240
0002c6  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0002ca  a990              ADD      r1,sp,#0x240
0002cc  a81f              ADD      r0,sp,#0x7c
0002ce  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0002d2  69a8              LDR      r0,[r5,#0x18]
0002d4  1c86              ADDS     r6,r0,#2
0002d6  a836              ADD      r0,sp,#0xd8
0002d8  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
0002dc  f8407d0c          STR      r7,[r0,#-0xc]!
0002e0  2100              MOVS     r1,#0
0002e2  6047              STR      r7,[r0,#4]
0002e4  6087              STR      r7,[r0,#8]
0002e6  6101              STR      r1,[r0,#0x10]
0002e8  a833              ADD      r0,sp,#0xcc
0002ea  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
0002ee  2800              CMP      r0,#0
0002f0  f0008245          BEQ.W    |L28.1918|
0002f4  f10d0acc          ADD      r10,sp,#0xcc
0002f8  a8a6              ADD      r0,sp,#0x298
0002fa  e8ba018e          LDM      r10!,{r1-r3,r7,r8}
0002fe  e88d018e          STM      sp,{r1-r3,r7,r8}
000302  2700              MOVS     r7,#0
000304  4669              MOV      r1,sp
000306  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIhEC1ERKNS0_5ArrayIhEE ; Anki::Embedded::ConstArraySlice<unsigned char>::ConstArraySlice(const Anki::Embedded::Array<unsigned char>&)
00030a  f8807030          STRB     r7,[r0,#0x30]
00030e  90d8              STR      r0,[sp,#0x360]
000310  20ff              MOVS     r0,#0xff
000312  90d7              STR      r0,[sp,#0x35c]
000314  f10d0acc          ADD      r10,sp,#0xcc
000318  a8b3              ADD      r0,sp,#0x2cc
00031a  e8ba018e          LDM      r10!,{r1-r3,r7,r8}
00031e  e88d018e          STM      sp,{r1-r3,r7,r8}
000322  4669              MOV      r1,sp
000324  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIhEC1ERKNS0_5ArrayIhEE ; Anki::Embedded::ConstArraySlice<unsigned char>::ConstArraySlice(const Anki::Embedded::Array<unsigned char>&)
000328  9900              LDR      r1,[sp,#0]
00032a  2900              CMP      r1,#0
00032c  bfc4              ITT      GT
00032e  9901              LDRGT    r1,[sp,#4]
000330  2900              CMPGT    r1,#0
000332  f3408232          BLE.W    |L28.1946|
000336  e9dd1200          LDRD     r1,r2,[sp,#0]
00033a  4351              MULS     r1,r2,r1
00033c  2900              CMP      r1,#0
00033e  f000822c          BEQ.W    |L28.1946|
000342  9b02              LDR      r3,[sp,#8]
000344  9a04              LDR      r2,[sp,#0x10]
000346  2100              MOVS     r1,#0
000348  fb012103          MLA      r1,r1,r3,r2
                  |L28.844|
00034c  6301              STR      r1,[r0,#0x30]
00034e  f1000108          ADD      r1,r0,#8
000352  e9d03c06          LDRD     r3,r12,[r0,#0x18]
000356  e8910c06          LDM      r1,{r1,r2,r10,r11}
00035a  e9d07800          LDRD     r7,r8,[r0,#0]
00035e  970b              STR      r7,[sp,#0x2c]
000360  f8cd8304          STR      r8,[sp,#0x304]
000364  f1000720          ADD      r7,r0,#0x20
000368  e9cdab05          STRD     r10,r11,[sp,#0x14]
00036c  e8970d80          LDM      r7,{r7,r8,r10,r11}
000370  6b00              LDR      r0,[r0,#0x30]
000372  e9cd8a07          STRD     r8,r10,[sp,#0x1c]
000376  46de              MOV      lr,r11
000378  e9ddab05          LDRD     r10,r11,[sp,#0x14]
00037c  9706              STR      r7,[sp,#0x18]
00037e  e9cde009          STRD     lr,r0,[sp,#0x24]
000382  e88d0c06          STM      sp,{r1,r2,r10,r11}
000386  e9cd3c04          STRD     r3,r12,[sp,#0x10]
00038a  e9dd10d7          LDRD     r1,r0,[sp,#0x35c]
00038e  9bc1              LDR      r3,[sp,#0x304]
000390  9a0b              LDR      r2,[sp,#0x2c]
000392  f7fffffe          BL       _ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIhNS2_11DotMultiplyIhhhEEhEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<unsigned char, Anki::Embedded::Matrix::Elementwise::DotMultiply<unsigned char, unsigned char, unsigned char>, unsigned char>(const Anki::Embedded::ConstArraySliceExpression<T1>&, T1, Anki::Embedded::ArraySlice<T3>)
000396  2100              MOVS     r1,#0
000398  a833              ADD      r0,sp,#0xcc
00039a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00039e  4682              MOV      r10,r0
0003a0  2101              MOVS     r1,#1
0003a2  a833              ADD      r0,sp,#0xcc
0003a4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0003a8  4683              MOV      r11,r0
0003aa  eb0a0046          ADD      r0,r10,r6,LSL #1
0003ae  9003              STR      r0,[sp,#0xc]
0003b0  eb0b0046          ADD      r0,r11,r6,LSL #1
0003b4  2300              MOVS     r3,#0
0003b6  9002              STR      r0,[sp,#8]
0003b8  461a              MOV      r2,r3
0003ba  4619              MOV      r1,r3
0003bc  a897              ADD      r0,sp,#0x25c
0003be  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0003c2  6800              LDR      r0,[r0,#0]
0003c4  e9dd2102          LDRD     r2,r1,[sp,#8]
0003c8  9000              STR      r0,[sp,#0]
0003ca  ab1f              ADD      r3,sp,#0x7c
0003cc  a838              ADD      r0,sp,#0xe0
0003ce  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0003d2  a838              ADD      r0,sp,#0xe0
0003d4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
0003d8  2800              CMP      r0,#0
0003da  f00081e0          BEQ.W    |L28.1950|
0003de  af38              ADD      r7,sp,#0xe0
0003e0  f04f08ff          MOV      r8,#0xff
0003e4  4638              MOV      r0,r7
0003e6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
0003ea  2800              CMP      r0,#0
0003ec  f00081e5          BEQ.W    |L28.1978|
0003f0  9838              LDR      r0,[sp,#0xe0]
0003f2  2100              MOVS     r1,#0
0003f4  2800              CMP      r0,#0
0003f6  dd11              BLE      |L28.1052|
                  |L28.1016|
0003f8  68ba              LDR      r2,[r7,#8]
0003fa  6938              LDR      r0,[r7,#0x10]
0003fc  687b              LDR      r3,[r7,#4]
0003fe  fb010202          MLA      r2,r1,r2,r0
000402  2000              MOVS     r0,#0
000404  2b00              CMP      r3,#0
000406  dd05              BLE      |L28.1044|
                  |L28.1032|
000408  f8028000          STRB     r8,[r2,r0]
00040c  687b              LDR      r3,[r7,#4]
00040e  1c40              ADDS     r0,r0,#1
000410  4283              CMP      r3,r0
000412  dcf9              BGT      |L28.1032|
                  |L28.1044|
000414  6838              LDR      r0,[r7,#0]
000416  1c49              ADDS     r1,r1,#1
000418  4288              CMP      r0,r1
00041a  dced              BGT      |L28.1016|
                  |L28.1052|
00041c  2700              MOVS     r7,#0
00041e  f1ba0f00          CMP      r10,#0
000422  dd5a              BLE      |L28.1242|
                  |L28.1060|
000424  9935              LDR      r1,[sp,#0xd4]
000426  9837              LDR      r0,[sp,#0xdc]
000428  fb070101          MLA      r1,r7,r1,r0
00042c  19b8              ADDS     r0,r7,r6
00042e  e049              B        |L28.1220|
                  |L28.1072|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()
                  |L28.1076|
000434  00000000          DCFS     0x00000000 ; 0
                  |L28.1080|
                          DCD      ||.constdata||+0x130
                  |L28.1084|
00043c  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\binaryTracker.cpp",0
000440  6f726574
000444  6563685c
000448  76697369
00044c  6f6e5c72
000450  6f626f74
000454  5c737263
000458  5c62696e
00045c  61727954
000460  7261636b
000464  65722e63
000468  707000  
00046b  00                DCB      0
                  |L28.1132|
00046c  42696e61          DCB      "BinaryTracker::BinaryTracker",0
000470  72795472
000474  61636b65
000478  723a3a42
00047c  696e6172
000480  79547261
000484  636b6572
000488  00      
000489  00                DCB      0
00048a  00                DCB      0
00048b  00                DCB      0
                  |L28.1164|
00048c  74656d70          DCB      "template widths and heights must be greater than zero",0
000490  6c617465
000494  20776964
000498  74687320
00049c  616e6420
0004a0  68656967
0004a4  68747320
0004a8  6d757374
0004ac  20626520
0004b0  67726561
0004b4  74657220
0004b8  7468616e
0004bc  207a6572
0004c0  6f00    
0004c2  00                DCB      0
0004c3  00                DCB      0
                  |L28.1220|
0004c4  9b3a              LDR      r3,[sp,#0xe8]
0004c6  9a3c              LDR      r2,[sp,#0xf0]
0004c8  fb002003          MLA      r0,r0,r3,r2
0004cc  4430              ADD      r0,r0,r6
0004ce  465a              MOV      r2,r11
0004d0  f7fffffe          BL       __aeabi_memcpy
0004d4  1c7f              ADDS     r7,r7,#1
0004d6  45ba              CMP      r10,r7
0004d8  dca4              BGT      |L28.1060|
                  |L28.1242|
0004da  2100              MOVS     r1,#0
0004dc  a833              ADD      r0,sp,#0xcc
0004de  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0004e2  ee000a10          VMOV     s0,r0
0004e6  2101              MOVS     r1,#1
0004e8  a833              ADD      r0,sp,#0xcc
0004ea  eef89ac0          VCVT.F32.S32 s19,s0
0004ee  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0004f2  ee000a10          VMOV     s0,r0
0004f6  2300              MOVS     r3,#0
0004f8  461a              MOV      r2,r3
0004fa  eeb89ac0          VCVT.F32.S32 s18,s0
0004fe  2101              MOVS     r1,#1
000500  a897              ADD      r0,sp,#0x25c
000502  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000506  6803              LDR      r3,[r0,#0]
000508  aa1f              ADD      r2,sp,#0x7c
00050a  2104              MOVS     r1,#4
00050c  a83d              ADD      r0,sp,#0xf4
00050e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000512  2104              MOVS     r1,#4
000514  a83d              ADD      r0,sp,#0xf4
000516  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::set_size(int)
00051a  ee006a10          VMOV     s0,r6
00051e  9849              LDR      r0,[sp,#0x124]
000520  ee016a10          VMOV     s2,r6
000524  eeb80ac0          VCVT.F32.S32 s0,s0
000528  ee016a90          VMOV     s3,r6
00052c  eeb81ac1          VCVT.F32.S32 s2,s2
000530  2300              MOVS     r3,#0
000532  ee700a28          VADD.F32 s1,s0,s17
000536  ee006a10          VMOV     s0,r6
00053a  eef81ae1          VCVT.F32.S32 s3,s3
00053e  edcd0a70          VSTR     s1,[sp,#0x1c0]
000542  eeb80ac0          VCVT.F32.S32 s0,s0
000546  461a              MOV      r2,r3
000548  ee711aa8          VADD.F32 s3,s3,s17
00054c  2101              MOVS     r1,#1
00054e  ee300a28          VADD.F32 s0,s0,s17
000552  ed8d0a71          VSTR     s0,[sp,#0x1c4]
000556  edc00a00          VSTR     s1,[r0,#0]
00055a  ed9d0a71          VLDR     s0,[sp,#0x1c4]
00055e  ee790ae8          VSUB.F32 s1,s19,s17
000562  ed800a01          VSTR     s0,[r0,#4]
000566  ee006a10          VMOV     s0,r6
00056a  9849              LDR      r0,[sp,#0x124]
00056c  ee301a81          VADD.F32 s2,s1,s2
000570  eeb80ac0          VCVT.F32.S32 s0,s0
000574  ee300a28          VADD.F32 s0,s0,s17
000578  ed8d0a70          VSTR     s0,[sp,#0x1c0]
00057c  ed8d1a71          VSTR     s2,[sp,#0x1c4]
000580  ed800a02          VSTR     s0,[r0,#8]
000584  ed9d0a71          VLDR     s0,[sp,#0x1c4]
000588  ee016a10          VMOV     s2,r6
00058c  ed800a03          VSTR     s0,[r0,#0xc]
000590  ee390a68          VSUB.F32 s0,s18,s17
000594  eeb81ac1          VCVT.F32.S32 s2,s2
000598  9849              LDR      r0,[sp,#0x124]
00059a  ee301a01          VADD.F32 s2,s0,s2
00059e  ed8d1a70          VSTR     s2,[sp,#0x1c0]
0005a2  edcd1a71          VSTR     s3,[sp,#0x1c4]
0005a6  ed801a04          VSTR     s2,[r0,#0x10]
0005aa  ed9d1a71          VLDR     s2,[sp,#0x1c4]
0005ae  ed801a05          VSTR     s2,[r0,#0x14]
0005b2  ee016a10          VMOV     s2,r6
0005b6  9849              LDR      r0,[sp,#0x124]
0005b8  eeb81ac1          VCVT.F32.S32 s2,s2
0005bc  ee300a01          VADD.F32 s0,s0,s2
0005c0  ee016a10          VMOV     s2,r6
0005c4  ed8d0a70          VSTR     s0,[sp,#0x1c0]
0005c8  eeb81ac1          VCVT.F32.S32 s2,s2
0005cc  ee700a81          VADD.F32 s1,s1,s2
0005d0  edcd0a71          VSTR     s1,[sp,#0x1c4]
0005d4  ed800a06          VSTR     s0,[r0,#0x18]
0005d8  ed9d0a71          VLDR     s0,[sp,#0x1c4]
0005dc  ed800a07          VSTR     s0,[r0,#0x1c]
0005e0  a897              ADD      r0,sp,#0x25c
0005e2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0005e6  6803              LDR      r3,[r0,#0]
0005e8  aa1f              ADD      r2,sp,#0x7c
0005ea  2104              MOVS     r1,#4
0005ec  a826              ADD      r0,sp,#0x98
0005ee  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0005f2  2104              MOVS     r1,#4
0005f4  a826              ADD      r0,sp,#0x98
0005f6  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::set_size(int)
0005fa  9832              LDR      r0,[sp,#0xc8]
0005fc  ed990a00          VLDR     s0,[r9,#0]
000600  2300              MOVS     r3,#0
000602  ed800a00          VSTR     s0,[r0,#0]
000606  ed990a01          VLDR     s0,[r9,#4]
00060a  2101              MOVS     r1,#1
00060c  ed800a01          VSTR     s0,[r0,#4]
000610  9a32              LDR      r2,[sp,#0xc8]
000612  ed990a02          VLDR     s0,[r9,#8]
000616  a897              ADD      r0,sp,#0x25c
000618  ed820a02          VSTR     s0,[r2,#8]
00061c  ed990a03          VLDR     s0,[r9,#0xc]
000620  ed820a03          VSTR     s0,[r2,#0xc]
000624  9a32              LDR      r2,[sp,#0xc8]
000626  ed990a04          VLDR     s0,[r9,#0x10]
00062a  ed820a04          VSTR     s0,[r2,#0x10]
00062e  ed990a05          VLDR     s0,[r9,#0x14]
000632  ed820a05          VSTR     s0,[r2,#0x14]
000636  9a32              LDR      r2,[sp,#0xc8]
000638  ed990a06          VLDR     s0,[r9,#0x18]
00063c  ed820a06          VSTR     s0,[r2,#0x18]
000640  ed990a07          VLDR     s0,[r9,#0x1c]
000644  ed820a07          VSTR     s0,[r2,#0x1c]
000648  461a              MOV      r2,r3
00064a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00064e  6800              LDR      r0,[r0,#0]
000650  2203              MOVS     r2,#3
000652  9000              STR      r0,[sp,#0]
000654  ab1f              ADD      r3,sp,#0x7c
000656  4611              MOV      r1,r2
000658  a876              ADD      r0,sp,#0x1d8
00065a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00065e  a91f              ADD      r1,sp,#0x7c
000660  a857              ADD      r0,sp,#0x15c
000662  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000666  9000              STR      r0,[sp,#0]
000668  abd9              ADD      r3,sp,#0x364
00066a  aa76              ADD      r2,sp,#0x1d8
00066c  a926              ADD      r1,sp,#0x98
00066e  a83d              ADD      r0,sp,#0xf4
000670  f7fffffe          BL       _ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE ; Anki::Embedded::Matrix::EstimateHomography<float>(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, Anki::Embedded::Array<T1>&, bool&, Anki::Embedded::MemoryStack)
000674  ed8d8a70          VSTR     s16,[sp,#0x1c0]
000678  ed8d8a71          VSTR     s16,[sp,#0x1c4]
00067c  f8dda124          LDR      r10,[sp,#0x124]
000680  f50d7be0          ADD      r11,sp,#0x1c0
000684  a8ca              ADD      r0,sp,#0x328
000686  f10a0808          ADD      r8,r10,#8
00068a  f10a0710          ADD      r7,r10,#0x10
00068e  f10a0618          ADD      r6,r10,#0x18
000692  2304              MOVS     r3,#4
000694  2208              MOVS     r2,#8
000696  49f9              LDR      r1,|L28.2684|
000698  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
00069c  ed9a0a00          VLDR     s0,[r10,#0]
0006a0  ab1f              ADD      r3,sp,#0x7c
0006a2  ed800a00          VSTR     s0,[r0,#0]
0006a6  ed9a0a01          VLDR     s0,[r10,#4]
0006aa  4602              MOV      r2,r0
0006ac  ed800a01          VSTR     s0,[r0,#4]
0006b0  ed980a00          VLDR     s0,[r8,#0]
0006b4  f44f6100          MOV      r1,#0x800
0006b8  ed800a02          VSTR     s0,[r0,#8]
0006bc  ed980a01          VLDR     s0,[r8,#4]
0006c0  ed800a03          VSTR     s0,[r0,#0xc]
0006c4  ed970a00          VLDR     s0,[r7,#0]
0006c8  ed800a04          VSTR     s0,[r0,#0x10]
0006cc  ed970a01          VLDR     s0,[r7,#4]
0006d0  ed800a05          VSTR     s0,[r0,#0x14]
0006d4  ed960a00          VLDR     s0,[r6,#0]
0006d8  ed800a06          VSTR     s0,[r0,#0x18]
0006dc  ed960a01          VLDR     s0,[r6,#4]
0006e0  ed800a07          VSTR     s0,[r0,#0x1c]
0006e4  e9cdb300          STRD     r11,r3,[sp,#0]
0006e8  ab76              ADD      r3,sp,#0x1d8
0006ea  a80e              ADD      r0,sp,#0x38
0006ec  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
0006f0  a91f              ADD      r1,sp,#0x7c
0006f2  a857              ADD      r0,sp,#0x15c
0006f4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0006f8  4601              MOV      r1,r0
0006fa  a80e              ADD      r0,sp,#0x38
0006fc  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3226get_transformedOrientationENS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_transformedOrientation(Anki::Embedded::MemoryStack) const
000700  2300              MOVS     r3,#0
000702  ed840a53          VSTR     s0,[r4,#0x14c]
000706  461a              MOV      r2,r3
000708  2101              MOVS     r1,#1
00070a  a897              ADD      r0,sp,#0x25c
00070c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000710  4607              MOV      r7,r0
000712  2101              MOVS     r1,#1
000714  a838              ADD      r0,sp,#0xe0
000716  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00071a  4606              MOV      r6,r0
00071c  2100              MOVS     r1,#0
00071e  a838              ADD      r0,sp,#0xe0
000720  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000724  6839              LDR      r1,[r7,#0]
000726  9100              STR      r1,[sp,#0]
000728  4601              MOV      r1,r0
00072a  ab1f              ADD      r3,sp,#0x7c
00072c  4632              MOV      r2,r6
00072e  a85e              ADD      r0,sp,#0x178
000730  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000734  49d2              LDR      r1,|L28.2688|
000736  f8d4014c          LDR      r0,[r4,#0x14c]
00073a  4288              CMP      r0,r1
00073c  f2008049          BHI.W    |L28.2002|
000740  49d0              LDR      r1,|L28.2692|
000742  4288              CMP      r0,r1
000744  f2808045          BGE.W    |L28.2002|
000748  a938              ADD      r1,sp,#0xe0
00074a  a85e              ADD      r0,sp,#0x178
00074c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhE3SetERKS2_ ; Anki::Embedded::Array<unsigned char>::Set(const Anki::Embedded::Array<unsigned char>&)
000750  2000              MOVS     r0,#0
000752  9072              STR      r0,[sp,#0x1c8]
000754  2001              MOVS     r0,#1
000756  9073              STR      r0,[sp,#0x1cc]
000758  2002              MOVS     r0,#2
00075a  9074              STR      r0,[sp,#0x1d0]
00075c  2003              MOVS     r0,#3
00075e  f000b8b2          B.W      |L28.2246|
                  |L28.1890|
000762  48c9              LDR      r0,|L28.2696|
000764  21ba              MOVS     r1,#0xba
000766  f2af332c          ADR      r3,|L28.1084|
00076a  a2c8              ADR      r2,|L28.2700|
00076c  e9cd0100          STRD     r0,r1,[sp,#0]
000770  f2af3108          ADR      r1,|L28.1132|
000774  2005              MOVS     r0,#5
000776  f7fffffe          BL       _Anki_Log
00077a  4620              MOV      r0,r4
00077c  e4ae              B        |L28.220|
                  |L28.1918|
00077e  48c2              LDR      r0,|L28.2696|
000780  21d4              MOVS     r1,#0xd4
000782  f2af3348          ADR      r3,|L28.1084|
000786  a2c1              ADR      r2,|L28.2700|
000788  e9cd0100          STRD     r0,r1,[sp,#0]
00078c  f2af3124          ADR      r1,|L28.1132|
000790  2005              MOVS     r0,#5
000792  f7fffffe          BL       _Anki_Log
000796  4620              MOV      r0,r4
000798  e4a0              B        |L28.220|
                  |L28.1946|
00079a  2100              MOVS     r1,#0
00079c  e5d6              B        |L28.844|
                  |L28.1950|
00079e  48ba              LDR      r0,|L28.2696|
0007a0  21e4              MOVS     r1,#0xe4
0007a2  f2af3368          ADR      r3,|L28.1084|
0007a6  a2b9              ADR      r2,|L28.2700|
0007a8  e9cd0100          STRD     r0,r1,[sp,#0]
0007ac  f2af3144          ADR      r1,|L28.1132|
0007b0  2005              MOVS     r0,#5
0007b2  f7fffffe          BL       _Anki_Log
0007b6  4620              MOV      r0,r4
0007b8  e490              B        |L28.220|
                  |L28.1978|
0007ba  f2402182          MOV      r1,#0x282
0007be  48bb              LDR      r0,|L28.2732|
0007c0  e9cd0100          STRD     r0,r1,[sp,#0]
0007c4  a3ba              ADR      r3,|L28.2736|
0007c6  a2c8              ADR      r2,|L28.2792|
0007c8  a1ce              ADR      r1,|L28.2820|
0007ca  2005              MOVS     r0,#5
0007cc  f7fffffe          BL       _Anki_Log
0007d0  e624              B        |L28.1052|
                  |L28.2002|
0007d2  49d1              LDR      r1,|L28.2840|
0007d4  4ad1              LDR      r2,|L28.2844|
0007d6  4401              ADD      r1,r1,r0
0007d8  4291              CMP      r1,r2
0007da  f08080d6          BCS.W    |L28.2442|
0007de  f10d08e0          ADD      r8,sp,#0xe0
0007e2  af5e              ADD      r7,sp,#0x178
0007e4  2101              MOVS     r1,#1
0007e6  4640              MOV      r0,r8
0007e8  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0007ec  4606              MOV      r6,r0
0007ee  4640              MOV      r0,r8
0007f0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
0007f4  f8dfa328          LDR      r10,|L28.2848|
0007f8  b1c8              CBZ      r0,|L28.2094|
0007fa  4638              MOV      r0,r7
0007fc  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000800  b1a8              CBZ      r0,|L28.2094|
000802  2100              MOVS     r1,#0
000804  4640              MOV      r0,r8
000806  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00080a  4683              MOV      r11,r0
00080c  2101              MOVS     r1,#1
00080e  4640              MOV      r0,r8
000810  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000814  4583              CMP      r11,r0
000816  d015              BEQ      |L28.2116|
000818  f44f703a          MOV      r0,#0x2e8
00081c  e9cda000          STRD     r10,r0,[sp,#0]
000820  a3c0              ADR      r3,|L28.2852|
000822  a2ce              ADR      r2,|L28.2908|
000824  a1d4              ADR      r1,|L28.2936|
000826  2005              MOVS     r0,#5
000828  f7fffffe          BL       _Anki_Log
00082c  e044              B        |L28.2232|
                  |L28.2094|
00082e  f24020e5          MOV      r0,#0x2e5
000832  e9cda000          STRD     r10,r0,[sp,#0]
000836  a3bb              ADR      r3,|L28.2852|
000838  a2d2              ADR      r2,|L28.2948|
00083a  a1cf              ADR      r1,|L28.2936|
00083c  2005              MOVS     r0,#5
00083e  f7fffffe          BL       _Anki_Log
000842  e039              B        |L28.2232|
                  |L28.2116|
000844  4638              MOV      r0,r7
000846  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
00084a  2800              CMP      r0,#0
00084c  d07e              BEQ      |L28.2380|
00084e  2100              MOVS     r1,#0
000850  4638              MOV      r0,r7
000852  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000856  42b0              CMP      r0,r6
000858  d178              BNE      |L28.2380|
00085a  2101              MOVS     r1,#1
00085c  4638              MOV      r0,r7
00085e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000862  42b0              CMP      r0,r6
000864  d17b              BNE      |L28.2398|
000866  4639              MOV      r1,r7
000868  4640              MOV      r0,r8
00086a  f7fffffe          BL       _ZN4Anki8Embedded10NotAliasedINS0_5ArrayIhEES3_EEbRKT_RKT0_ ; Anki::Embedded::NotAliased<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<unsigned char>>(const T1&, const T2&)
00086e  2800              CMP      r0,#0
000870  d06d              BEQ      |L28.2382|
000872  2200              MOVS     r2,#0
000874  f8ddc180          LDR      r12,[sp,#0x180]
000878  2e00              CMP      r6,#0
00087a  dd1d              BLE      |L28.2232|
                  |L28.2172|
00087c  f8d81008          LDR      r1,[r8,#8]
000880  f8d80010          LDR      r0,[r8,#0x10]
000884  f8d7b008          LDR      r11,[r7,#8]
000888  fb020301          MLA      r3,r2,r1,r0
00088c  f8d7a010          LDR      r10,[r7,#0x10]
000890  2100              MOVS     r1,#0
000892  1ab0              SUBS     r0,r6,r2
000894  fb01a10b          MLA      r1,r1,r11,r10
000898  1e40              SUBS     r0,r0,#1
00089a  4401              ADD      r1,r1,r0
00089c  2000              MOVS     r0,#0
00089e  2e00              CMP      r6,#0
0008a0  dd07              BLE      |L28.2226|
                  |L28.2210|
0008a2  f813a000          LDRB     r10,[r3,r0]
0008a6  f881a000          STRB     r10,[r1,#0]
0008aa  1c40              ADDS     r0,r0,#1
0008ac  4461              ADD      r1,r1,r12
0008ae  4286              CMP      r6,r0
0008b0  dcf7              BGT      |L28.2210|
                  |L28.2226|
0008b2  1c52              ADDS     r2,r2,#1
0008b4  42b2              CMP      r2,r6
0008b6  dbe1              BLT      |L28.2172|
                  |L28.2232|
0008b8  2002              MOVS     r0,#2
0008ba  9072              STR      r0,[sp,#0x1c8]
0008bc  2000              MOVS     r0,#0
0008be  9073              STR      r0,[sp,#0x1cc]
0008c0  2003              MOVS     r0,#3
0008c2  9074              STR      r0,[sp,#0x1d0]
0008c4  2001              MOVS     r0,#1
                  |L28.2246|
0008c6  2300              MOVS     r3,#0
0008c8  9075              STR      r0,[sp,#0x1d4]
0008ca  461a              MOV      r2,r3
0008cc  2101              MOVS     r1,#1
0008ce  a897              ADD      r0,sp,#0x25c
0008d0  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0008d4  6803              LDR      r3,[r0,#0]
0008d6  aa1f              ADD      r2,sp,#0x7c
0008d8  2104              MOVS     r1,#4
0008da  a863              ADD      r0,sp,#0x18c
0008dc  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0008e0  2104              MOVS     r1,#4
0008e2  a863              ADD      r0,sp,#0x18c
0008e4  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::set_size(int)
0008e8  2000              MOVS     r0,#0
0008ea  ab72              ADD      r3,sp,#0x1c8
                  |L28.2284|
0008ec  996f              LDR      r1,[sp,#0x1bc]
0008ee  f8ddc124          LDR      r12,[sp,#0x124]
0008f2  eb0102c0          ADD      r2,r1,r0,LSL #3
0008f6  f8531020          LDR      r1,[r3,r0,LSL #2]
0008fa  1c40              ADDS     r0,r0,#1
0008fc  eb0c01c1          ADD      r1,r12,r1,LSL #3
000900  2804              CMP      r0,#4
000902  ed910a00          VLDR     s0,[r1,#0]
000906  ed820a00          VSTR     s0,[r2,#0]
00090a  ed910a01          VLDR     s0,[r1,#4]
00090e  ed820a01          VSTR     s0,[r2,#4]
000912  dbeb              BLT      |L28.2284|
000914  a91f              ADD      r1,sp,#0x7c
000916  a857              ADD      r0,sp,#0x15c
000918  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00091c  9000              STR      r0,[sp,#0]
00091e  abd9              ADD      r3,sp,#0x364
000920  aa76              ADD      r2,sp,#0x1d8
000922  a926              ADD      r1,sp,#0x98
000924  a863              ADD      r0,sp,#0x18c
000926  f7fffffe          BL       _ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE ; Anki::Embedded::Matrix::EstimateHomography<float>(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, Anki::Embedded::Array<T1>&, bool&, Anki::Embedded::MemoryStack)
00092a  a976              ADD      r1,sp,#0x1d8
00092c  a80e              ADD      r0,sp,#0x38
00092e  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3214set_homographyERKNS0_5ArrayIfEE ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_homography(const Anki::Embedded::Array<float>&)
000932  9802              LDR      r0,[sp,#8]
000934  2200              MOVS     r2,#0
000936  1e43              SUBS     r3,r0,#1
000938  9803              LDR      r0,[sp,#0xc]
00093a  e9cd238c          STRD     r2,r3,[sp,#0x230]
00093e  1e40              SUBS     r0,r0,#1
000940  e9cd208e          STRD     r2,r0,[sp,#0x238]
000944  7829              LDRB     r1,[r5,#0]
000946  2001              MOVS     r0,#1
000948  2900              CMP      r1,#0
00094a  e001              B        |L28.2384|
                  |L28.2380|
00094c  e007              B        |L28.2398|
                  |L28.2382|
00094e  e011              B        |L28.2420|
                  |L28.2384|
000950  f00081e6          BEQ.W    |L28.3360|
000954  2901              CMP      r1,#1
000956  f00081ef          BEQ.W    |L28.3384|
00095a  f000b9f8          B.W      |L28.3406|
                  |L28.2398|
00095e  f24020eb          MOV      r0,#0x2eb
000962  e9cda000          STRD     r10,r0,[sp,#0]
000966  a36f              ADR      r3,|L28.2852|
000968  a27c              ADR      r2,|L28.2908|
00096a  a183              ADR      r1,|L28.2936|
00096c  2005              MOVS     r0,#5
00096e  f7fffffe          BL       _Anki_Log
000972  e7a1              B        |L28.2232|
                  |L28.2420|
000974  f24020ee          MOV      r0,#0x2ee
000978  e9cda000          STRD     r10,r0,[sp,#0]
00097c  a369              ADR      r3,|L28.2852|
00097e  a285              ADR      r2,|L28.2964|
000980  a17d              ADR      r1,|L28.2936|
000982  2005              MOVS     r0,#5
000984  f7fffffe          BL       _Anki_Log
000988  e796              B        |L28.2232|
                  |L28.2442|
00098a  498b              LDR      r1,|L28.3000|
00098c  f10d08e0          ADD      r8,sp,#0xe0
000990  4408              ADD      r0,r0,r1
000992  498a              LDR      r1,|L28.3004|
000994  af5e              ADD      r7,sp,#0x178
000996  4288              CMP      r0,r1
000998  f04f0101          MOV      r1,#1
00099c  4640              MOV      r0,r8
00099e  f0808133          BCS.W    |L28.3080|
0009a2  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0009a6  4606              MOV      r6,r0
0009a8  4640              MOV      r0,r8
0009aa  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
0009ae  f8dfa210          LDR      r10,|L28.3008|
0009b2  b1c8              CBZ      r0,|L28.2536|
0009b4  4638              MOV      r0,r7
0009b6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
0009ba  b1a8              CBZ      r0,|L28.2536|
0009bc  2100              MOVS     r1,#0
0009be  4640              MOV      r0,r8
0009c0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0009c4  4683              MOV      r11,r0
0009c6  2101              MOVS     r1,#1
0009c8  4640              MOV      r0,r8
0009ca  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0009ce  4583              CMP      r11,r0
0009d0  d015              BEQ      |L28.2558|
0009d2  f44f7042          MOV      r0,#0x308
0009d6  e9cda000          STRD     r10,r0,[sp,#0]
0009da  a352              ADR      r3,|L28.2852|
0009dc  a25f              ADR      r2,|L28.2908|
0009de  a179              ADR      r1,|L28.3012|
0009e0  2005              MOVS     r0,#5
0009e2  f7fffffe          BL       _Anki_Log
0009e6  e03f              B        |L28.2664|
                  |L28.2536|
0009e8  f2403005          MOV      r0,#0x305
0009ec  e9cda000          STRD     r10,r0,[sp,#0]
0009f0  a34c              ADR      r3,|L28.2852|
0009f2  a264              ADR      r2,|L28.2948|
0009f4  a173              ADR      r1,|L28.3012|
0009f6  2005              MOVS     r0,#5
0009f8  f7fffffe          BL       _Anki_Log
0009fc  e034              B        |L28.2664|
                  |L28.2558|
0009fe  4638              MOV      r0,r7
000a00  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000a04  b3c0              CBZ      r0,|L28.2680|
000a06  2100              MOVS     r1,#0
000a08  4638              MOV      r0,r7
000a0a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000a0e  42b0              CMP      r0,r6
000a10  d132              BNE      |L28.2680|
000a12  2101              MOVS     r1,#1
000a14  4638              MOV      r0,r7
000a16  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000a1a  42b0              CMP      r0,r6
000a1c  d12c              BNE      |L28.2680|
000a1e  4639              MOV      r1,r7
000a20  4640              MOV      r0,r8
000a22  f7fffffe          BL       _ZN4Anki8Embedded10NotAliasedINS0_5ArrayIhEES3_EEbRKT_RKT0_ ; Anki::Embedded::NotAliased<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<unsigned char>>(const T1&, const T2&)
000a26  b340              CBZ      r0,|L28.2682|
000a28  2100              MOVS     r1,#0
000a2a  2e00              CMP      r6,#0
000a2c  dd1c              BLE      |L28.2664|
                  |L28.2606|
000a2e  f8d82008          LDR      r2,[r8,#8]
000a32  f8d80010          LDR      r0,[r8,#0x10]
000a36  f8d7c008          LDR      r12,[r7,#8]
000a3a  fb010202          MLA      r2,r1,r2,r0
000a3e  1a70              SUBS     r0,r6,r1
000a40  693b              LDR      r3,[r7,#0x10]
000a42  1e40              SUBS     r0,r0,#1
000a44  fb00330c          MLA      r3,r0,r12,r3
000a48  2000              MOVS     r0,#0
000a4a  2e00              CMP      r6,#0
000a4c  dd09              BLE      |L28.2658|
                  |L28.2638|
000a4e  eba60a00          SUB      r10,r6,r0
000a52  f812c000          LDRB     r12,[r2,r0]
000a56  449a              ADD      r10,r10,r3
000a58  1c40              ADDS     r0,r0,#1
000a5a  f80acc01          STRB     r12,[r10,#-1]
000a5e  4286              CMP      r6,r0
000a60  dcf5              BGT      |L28.2638|
                  |L28.2658|
000a62  1c49              ADDS     r1,r1,#1
000a64  42b1              CMP      r1,r6
000a66  dbe2              BLT      |L28.2606|
                  |L28.2664|
000a68  2003              MOVS     r0,#3
000a6a  9072              STR      r0,[sp,#0x1c8]
000a6c  2002              MOVS     r0,#2
000a6e  9073              STR      r0,[sp,#0x1cc]
000a70  2001              MOVS     r0,#1
000a72  9074              STR      r0,[sp,#0x1d0]
000a74  2000              MOVS     r0,#0
000a76  e726              B        |L28.2246|
                  |L28.2680|
000a78  e0aa              B        |L28.3024|
                  |L28.2682|
000a7a  e0b7              B        |L28.3052|
                  |L28.2684|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()
                  |L28.2688|
                          DCD      0xbf490fdb
                  |L28.2692|
                          DCD      0x3f490fdb
                  |L28.2696|
                          DCD      ||.constdata||+0x130
                  |L28.2700|
000a8c  436f756c          DCB      "Could not allocate local memory",0
000a90  64206e6f
000a94  7420616c
000a98  6c6f6361
000a9c  7465206c
000aa0  6f63616c
000aa4  206d656d
000aa8  6f727900
                  |L28.2732|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE3SetEhE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::Set(unsigned char)::__PRETTY_FUNCTION__
                  |L28.2736|
000ab0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000ab4  6f726574
000ab8  6563685c
000abc  636f6d6d
000ac0  6f6e5c69
000ac4  6e636c75
000ac8  64655c61
000acc  6e6b692f
000ad0  636f6d6d
000ad4  6f6e2f72
000ad8  6f626f74
000adc  2f617272
000ae0  617932  
000ae3  642e6800          DCB      "d.h",0
000ae7  00                DCB      0
                  |L28.2792|
000ae8  41727261          DCB      "Array<Type> is not valid",0
000aec  793c5479
000af0  70653e20
000af4  6973206e
000af8  6f742076
000afc  616c6964
000b00  00      
000b01  00                DCB      0
000b02  00                DCB      0
000b03  00                DCB      0
                  |L28.2820|
000b04  41727261          DCB      "Array<Type>::Set",0
000b08  793c5479
000b0c  70653e3a
000b10  3a536574
000b14  00      
000b15  00                DCB      0
000b16  00                DCB      0
000b17  00                DCB      0
                  |L28.2840|
                          DCD      0xc0b6f025
                  |L28.2844|
                          DCD      0x00cdbc09
                  |L28.2848|
                          DCD      _ZZN4Anki8Embedded6Matrix8Rotate90IhhEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Rotate90<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L28.2852|
000b24  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000b28  6f726574
000b2c  6563685c
000b30  636f6d6d
000b34  6f6e5c69
000b38  6e636c75
000b3c  64655c61
000b40  6e6b692f
000b44  636f6d6d
000b48  6f6e2f72
000b4c  6f626f74
000b50  2f6d6174
000b54  726978  
000b57  2e6800            DCB      ".h",0
000b5a  00                DCB      0
000b5b  00                DCB      0
                  |L28.2908|
000b5c  696e2061          DCB      "in and out must be square",0
000b60  6e64206f
000b64  7574206d
000b68  75737420
000b6c  62652073
000b70  71756172
000b74  6500    
000b76  00                DCB      0
000b77  00                DCB      0
                  |L28.2936|
000b78  526f7461          DCB      "Rotate90",0
000b7c  74653930
000b80  00      
000b81  00                DCB      0
000b82  00                DCB      0
000b83  00                DCB      0
                  |L28.2948|
000b84  496e7661          DCB      "Invalid objects",0
000b88  6c696420
000b8c  6f626a65
000b90  63747300
                  |L28.2964|
000b94  696e2061          DCB      "in and out cannot be the same array",0
000b98  6e64206f
000b9c  75742063
000ba0  616e6e6f
000ba4  74206265
000ba8  20746865
000bac  2073616d
000bb0  65206172
000bb4  72617900
                  |L28.3000|
                          DCD      0xbfe9341c
                  |L28.3004|
                          DCD      0x006487ee
                  |L28.3008|
                          DCD      _ZZN4Anki8Embedded6Matrix9Rotate180IhhEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Rotate180<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L28.3012|
000bc4  526f7461          DCB      "Rotate180",0
000bc8  74653138
000bcc  3000    
000bce  00                DCB      0
000bcf  00                DCB      0
                  |L28.3024|
000bd0  f240300b          MOV      r0,#0x30b
000bd4  f2af03b4          ADR      r3,|L28.2852|
000bd8  f2af0280          ADR      r2,|L28.2908|
000bdc  f2af011c          ADR      r1,|L28.3012|
000be0  e9cda000          STRD     r10,r0,[sp,#0]
000be4  2005              MOVS     r0,#5
000be6  f7fffffe          BL       _Anki_Log
000bea  e73d              B        |L28.2664|
                  |L28.3052|
000bec  f240300e          MOV      r0,#0x30e
000bf0  f2af03d0          ADR      r3,|L28.2852|
000bf4  f2af0264          ADR      r2,|L28.2964|
000bf8  f2af0138          ADR      r1,|L28.3012|
000bfc  e9cda000          STRD     r10,r0,[sp,#0]
000c00  2005              MOVS     r0,#5
000c02  f7fffffe          BL       _Anki_Log
000c06  e72f              B        |L28.2664|
                  |L28.3080|
000c08  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000c0c  4606              MOV      r6,r0
000c0e  4640              MOV      r0,r8
000c10  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000c14  f8dfa284          LDR      r10,|L28.3740|
000c18  b1d8              CBZ      r0,|L28.3154|
000c1a  4638              MOV      r0,r7
000c1c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000c20  b1b8              CBZ      r0,|L28.3154|
000c22  2100              MOVS     r1,#0
000c24  4640              MOV      r0,r8
000c26  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000c2a  4683              MOV      r11,r0
000c2c  2101              MOVS     r1,#1
000c2e  4640              MOV      r0,r8
000c30  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000c34  4583              CMP      r11,r0
000c36  d019              BEQ      |L28.3180|
000c38  f44f7049          MOV      r0,#0x324
000c3c  f2af131c          ADR      r3,|L28.2852|
000c40  f2af02e8          ADR      r2,|L28.2908|
000c44  e9cda000          STRD     r10,r0,[sp,#0]
000c48  a195              ADR      r1,|L28.3744|
000c4a  2005              MOVS     r0,#5
000c4c  f7fffffe          BL       _Anki_Log
000c50  e042              B        |L28.3288|
                  |L28.3154|
000c52  f2403021          MOV      r0,#0x321
000c56  f2af1334          ADR      r3,|L28.2852|
000c5a  f2af02d8          ADR      r2,|L28.2948|
000c5e  e9cda000          STRD     r10,r0,[sp,#0]
000c62  a18f              ADR      r1,|L28.3744|
000c64  2005              MOVS     r0,#5
000c66  f7fffffe          BL       _Anki_Log
000c6a  e035              B        |L28.3288|
                  |L28.3180|
000c6c  4638              MOV      r0,r7
000c6e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000c72  b3c8              CBZ      r0,|L28.3304|
000c74  2100              MOVS     r1,#0
000c76  4638              MOV      r0,r7
000c78  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000c7c  42b0              CMP      r0,r6
000c7e  d135              BNE      |L28.3308|
000c80  2101              MOVS     r1,#1
000c82  4638              MOV      r0,r7
000c84  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000c88  42b0              CMP      r0,r6
000c8a  d12f              BNE      |L28.3308|
000c8c  4639              MOV      r1,r7
000c8e  4640              MOV      r0,r8
000c90  f7fffffe          BL       _ZN4Anki8Embedded10NotAliasedINS0_5ArrayIhEES3_EEbRKT_RKT0_ ; Anki::Embedded::NotAliased<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<unsigned char>>(const T1&, const T2&)
000c94  b348              CBZ      r0,|L28.3306|
000c96  2200              MOVS     r2,#0
000c98  f8ddc180          LDR      r12,[sp,#0x180]
000c9c  2e00              CMP      r6,#0
000c9e  dd1b              BLE      |L28.3288|
                  |L28.3232|
000ca0  f8d81008          LDR      r1,[r8,#8]
000ca4  f8d80010          LDR      r0,[r8,#0x10]
000ca8  f8d7a008          LDR      r10,[r7,#8]
000cac  fb020301          MLA      r3,r2,r1,r0
000cb0  6939              LDR      r1,[r7,#0x10]
000cb2  1e70              SUBS     r0,r6,#1
000cb4  fb00100a          MLA      r0,r0,r10,r1
000cb8  1881              ADDS     r1,r0,r2
000cba  2000              MOVS     r0,#0
000cbc  2e00              CMP      r6,#0
000cbe  dd08              BLE      |L28.3282|
                  |L28.3264|
000cc0  f813a000          LDRB     r10,[r3,r0]
000cc4  f881a000          STRB     r10,[r1,#0]
000cc8  1c40              ADDS     r0,r0,#1
000cca  eba1010c          SUB      r1,r1,r12
000cce  4286              CMP      r6,r0
000cd0  dcf6              BGT      |L28.3264|
                  |L28.3282|
000cd2  1c52              ADDS     r2,r2,#1
000cd4  42b2              CMP      r2,r6
000cd6  dbe3              BLT      |L28.3232|
                  |L28.3288|
000cd8  2001              MOVS     r0,#1
000cda  9072              STR      r0,[sp,#0x1c8]
000cdc  2003              MOVS     r0,#3
000cde  9073              STR      r0,[sp,#0x1cc]
000ce0  2000              MOVS     r0,#0
000ce2  9074              STR      r0,[sp,#0x1d0]
000ce4  2002              MOVS     r0,#2
000ce6  e5ee              B        |L28.2246|
                  |L28.3304|
000ce8  e000              B        |L28.3308|
                  |L28.3306|
000cea  e00c              B        |L28.3334|
                  |L28.3308|
000cec  f2403027          MOV      r0,#0x327
000cf0  f2af13d0          ADR      r3,|L28.2852|
000cf4  f2af129c          ADR      r2,|L28.2908|
000cf8  e9cda000          STRD     r10,r0,[sp,#0]
000cfc  a168              ADR      r1,|L28.3744|
000cfe  2005              MOVS     r0,#5
000d00  f7fffffe          BL       _Anki_Log
000d04  e7e8              B        |L28.3288|
                  |L28.3334|
000d06  f240302a          MOV      r0,#0x32a
000d0a  f2af13e8          ADR      r3,|L28.2852|
000d0e  f2af127c          ADR      r2,|L28.2964|
000d12  e9cda000          STRD     r10,r0,[sp,#0]
000d16  a162              ADR      r1,|L28.3744|
000d18  2005              MOVS     r0,#5
000d1a  f7fffffe          BL       _Anki_Log
000d1e  e7db              B        |L28.3288|
                  |L28.3360|
000d20  f1040174          ADD      r1,r4,#0x74
000d24  6aa8              LDR      r0,[r5,#0x28]
000d26  e9cd0100          STRD     r0,r1,[sp,#0]
000d2a  2280              MOVS     r2,#0x80
000d2c  a98c              ADD      r1,sp,#0x230
000d2e  a85e              ADD      r0,sp,#0x178
000d30  69ab              LDR      r3,[r5,#0x18]
000d32  f7fffffe          BL       _ZN4Anki8Embedded37DetectBlurredEdges_GrayvalueThresholdERKNS0_5ArrayIhEERKNS0_9RectangleIiEEhiiRNS0_9EdgeListsE ; Anki::Embedded::DetectBlurredEdges_GrayvalueThreshold(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Rectangle<int>&, unsigned char, int, int, Anki::Embedded::EdgeLists&)
000d36  e00a              B        |L28.3406|
                  |L28.3384|
000d38  f1040174          ADD      r1,r4,#0x74
000d3c  6aa8              LDR      r0,[r5,#0x28]
000d3e  e9cd0100          STRD     r0,r1,[sp,#0]
000d42  e9d52308          LDRD     r2,r3,[r5,#0x20]
000d46  a98c              ADD      r1,sp,#0x230
000d48  a85e              ADD      r0,sp,#0x178
000d4a  f7fffffe          BL       _ZN4Anki8Embedded38DetectBlurredEdges_DerivativeThresholdERKNS0_5ArrayIhEERKNS0_9RectangleIiEEiiiRNS0_9EdgeListsE ; Anki::Embedded::DetectBlurredEdges_DerivativeThreshold(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Rectangle<int>&, int, int, int, Anki::Embedded::EdgeLists&)
                  |L28.3406|
000d4e  6961              LDR      r1,[r4,#0x14]
000d50  f8c41144          STR      r1,[r4,#0x144]
000d54  69a1              LDR      r1,[r4,#0x18]
000d56  f8c41148          STR      r1,[r4,#0x148]
000d5a  b178              CBZ      r0,|L28.3452|
000d5c  4853              LDR      r0,|L28.3756|
000d5e  f44f71a6          MOV      r1,#0x14c
000d62  f6af1328          ADR      r3,|L28.1084|
000d66  a252              ADR      r2,|L28.3760|
000d68  e9cd0100          STRD     r0,r1,[sp,#0]
000d6c  f6af1104          ADR      r1,|L28.1132|
000d70  2005              MOVS     r0,#5
000d72  f7fffffe          BL       _Anki_Log
000d76  4620              MOV      r0,r4
000d78  f7ffb9b0          B        |L28.220|
                  |L28.3452|
000d7c  a91f              ADD      r1,sp,#0x7c
000d7e  a857              ADD      r0,sp,#0x15c
000d80  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000d84  4603              MOV      r3,r0
000d86  f1040274          ADD      r2,r4,#0x74
000d8a  eeb70a00          VMOV.F32 s0,#1.00000000
000d8e  4611              MOV      r1,r2
000d90  a80e              ADD      r0,sp,#0x38
000d92  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_15FixedLengthListINS0_5PointIsEEEERS6_NS0_11MemoryStackEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::Transform(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::MemoryStack, float) const
000d96  a91f              ADD      r1,sp,#0x7c
000d98  a857              ADD      r0,sp,#0x15c
000d9a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000d9e  4603              MOV      r3,r0
000da0  f10402a8          ADD      r2,r4,#0xa8
000da4  eeb70a00          VMOV.F32 s0,#1.00000000
000da8  4611              MOV      r1,r2
000daa  a80e              ADD      r0,sp,#0x38
000dac  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_15FixedLengthListINS0_5PointIsEEEERS6_NS0_11MemoryStackEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::Transform(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::MemoryStack, float) const
000db0  a91f              ADD      r1,sp,#0x7c
000db2  a857              ADD      r0,sp,#0x15c
000db4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000db8  4603              MOV      r3,r0
000dba  f10402dc          ADD      r2,r4,#0xdc
000dbe  eeb70a00          VMOV.F32 s0,#1.00000000
000dc2  4611              MOV      r1,r2
000dc4  a80e              ADD      r0,sp,#0x38
000dc6  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_15FixedLengthListINS0_5PointIsEEEERS6_NS0_11MemoryStackEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::Transform(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::MemoryStack, float) const
000dca  a91f              ADD      r1,sp,#0x7c
000dcc  a857              ADD      r0,sp,#0x15c
000dce  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000dd2  4603              MOV      r3,r0
000dd4  f5047288          ADD      r2,r4,#0x110
000dd8  eeb70a00          VMOV.F32 s0,#1.00000000
000ddc  4611              MOV      r1,r2
000dde  a80e              ADD      r0,sp,#0x38
000de0  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_15FixedLengthListINS0_5PointIsEEEERS6_NS0_11MemoryStackEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::Transform(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::MemoryStack, float) const
000de4  4649              MOV      r1,r9
000de6  a8c2              ADD      r0,sp,#0x308
000de8  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE24ComputeBoundingRectangleIiEENS0_9RectangleIT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeBoundingRectangle<int>() const
000dec  ed950a05          VLDR     s0,[r5,#0x14]
000df0  a9c2              ADD      r1,sp,#0x308
000df2  a8c6              ADD      r0,sp,#0x318
000df4  f7fffffe          BL       _ZNK4Anki8Embedded9RectangleIiE22ComputeScaledRectangleIiEENS1_IT_EEf ; Anki::Embedded::Rectangle<int>::ComputeScaledRectangle<int>(float) const
000df8  99ef              LDR      r1,[sp,#0x3bc]
000dfa  68a8              LDR      r0,[r5,#8]
000dfc  e9cd0100          STRD     r0,r1,[sp,#0]
000e00  f104073c          ADD      r7,r4,#0x3c
000e04  aac6              ADD      r2,sp,#0x318
000e06  4621              MOV      r1,r4
000e08  a898              ADD      r0,sp,#0x260
000e0a  686b              LDR      r3,[r5,#4]
000e0c  f7fffffe          BL       _ZN4Anki8Embedded13IntegerCountsC1ERKNS0_5ArrayIhEERKNS0_9RectangleIiEEiiRNS0_11MemoryStackE ; Anki::Embedded::IntegerCounts::IntegerCounts(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Rectangle<int>&, int, int, Anki::Embedded::MemoryStack&)
000e10  e9d02300          LDRD     r2,r3,[r0,#0]
000e14  4639              MOV      r1,r7
000e16  f8d0c008          LDR      r12,[r0,#8]
000e1a  f8c7c008          STR      r12,[r7,#8]
000e1e  e9c12300          STRD     r2,r3,[r1,#0]
000e22  e9d02303          LDRD     r2,r3,[r0,#0xc]
000e26  f8d0c014          LDR      r12,[r0,#0x14]
000e2a  f8c7c014          STR      r12,[r7,#0x14]
000e2e  e9c12303          STRD     r2,r3,[r1,#0xc]
000e32  6982              LDR      r2,[r0,#0x18]
000e34  61ba              STR      r2,[r7,#0x18]
000e36  69c2              LDR      r2,[r0,#0x1c]
000e38  61fa              STR      r2,[r7,#0x1c]
000e3a  6a02              LDR      r2,[r0,#0x20]
000e3c  623a              STR      r2,[r7,#0x20]
000e3e  6a42              LDR      r2,[r0,#0x24]
000e40  627a              STR      r2,[r7,#0x24]
000e42  6a82              LDR      r2,[r0,#0x28]
000e44  62ba              STR      r2,[r7,#0x28]
000e46  6ac2              LDR      r2,[r0,#0x2c]
000e48  62ca              STR      r2,[r1,#0x2c]
000e4a  6b02              LDR      r2,[r0,#0x30]
000e4c  633a              STR      r2,[r7,#0x30]
000e4e  6b40              LDR      r0,[r0,#0x34]
000e50  6348              STR      r0,[r1,#0x34]
000e52  4638              MOV      r0,r7
000e54  f7fffffe          BL       _ZNK4Anki8Embedded13IntegerCounts7IsValidEv ; Anki::Embedded::IntegerCounts::IsValid() const
000e58  b180              CBZ      r0,|L28.3708|
000e5a  edd50a04          VLDR     s1,[r5,#0x10]
000e5e  ed950a03          VLDR     s0,[r5,#0xc]
000e62  4638              MOV      r0,r7
000e64  f7fffffe          BL       _ZN4Anki8Embedded25ComputeGrayvalueThresholdERKNS0_13IntegerCountsEff ; Anki::Embedded::ComputeGrayvalueThreshold(const Anki::Embedded::IntegerCounts&, float, float)
000e68  f8840195          STRB     r0,[r4,#0x195]
000e6c  f8840194          STRB     r0,[r4,#0x194]
000e70  2001              MOVS     r0,#1
000e72  f8840196          STRB     r0,[r4,#0x196]
                  |L28.3702|
000e76  4620              MOV      r0,r4
000e78  f7ffb930          B        |L28.220|
                  |L28.3708|
000e7c  480b              LDR      r0,|L28.3756|
000e7e  f44f71b9          MOV      r1,#0x172
000e82  f6af2348          ADR      r3,|L28.1084|
000e86  f2af32fc          ADR      r2,|L28.2700|
000e8a  e9cd0100          STRD     r0,r1,[sp,#0]
000e8e  f6af2124          ADR      r1,|L28.1132|
000e92  2005              MOVS     r0,#5
000e94  f7fffffe          BL       _Anki_Log
000e98  e7ed              B        |L28.3702|
                          ENDP

000e9a  0000              DCW      0x0000
                  |L28.3740|
                          DCD      _ZZN4Anki8Embedded6Matrix9Rotate270IhhEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Rotate270<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L28.3744|
000ea0  526f7461          DCB      "Rotate270",0
000ea4  74653237
000ea8  3000    
000eaa  00                DCB      0
000eab  00                DCB      0
                  |L28.3756|
                          DCD      ||.constdata||+0x130
                  |L28.3760|
000eb0  44657465          DCB      "DetectBlurredEdge failed",0
000eb4  6374426c
000eb8  75727265
000ebc  64456467
000ec0  65206661
000ec4  696c6564
000ec8  00      
000ec9  00                DCB      0
000eca  00                DCB      0
000ecb  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfRKNS2_23EdgeDetectionParametersERNS0_11MemoryStackESF_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC2ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfRKNS2_23EdgeDetectionParametersERNS0_11MemoryStackESF_                  ; Alternate entry point ; Anki::Embedded::TemplateTracker::BinaryTracker::BinaryTracker__sub_object(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, float, const Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters&, Anki::Embedded::MemoryStack&, Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfRKNS2_23EdgeDetectionParametersERNS0_11MemoryStackESF_ PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::BinaryTracker(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, float, const Anki::Embedded::TemplateTracker::BinaryTracker::EdgeDetectionParameters&, Anki::Embedded::MemoryStack&, Anki::Embedded::MemoryStack&)
;;;74     
;;;75           BinaryTracker::BinaryTracker(
;;;76             const Array<u8> &templateImage,
;;;77             const Quadrilateral<f32> &templateQuad,
;;;78             const f32 scaleTemplateRegionPercent, //< Shrinks the region if less-than 1.0, expands the region if greater-than 1.0
;;;79             const EdgeDetectionParameters &edgeDetectionParams,
;;;80             MemoryStack &fastMemory,
;;;81             MemoryStack &slowMemory)
;;;82             : isValid(false)
;;;83           {
;;;84             this->templateImageHeight = templateImage.get_size(0);
;;;85             this->templateImageWidth = templateImage.get_size(1);
;;;86     
;;;87             AnkiConditionalErrorAndReturn(templateImageHeight > 0 && templateImageWidth > 0,
;;;88               "BinaryTracker::BinaryTracker", "template widths and heights must be greater than zero");
;;;89     
;;;90             AnkiConditionalErrorAndReturn(AreValid(templateImage, fastMemory, slowMemory),
;;;91               "BinaryTracker::BinaryTracker", "Invalid objects");
;;;92     
;;;93             // TODO: make this work for non-qvga resolution
;;;94             Point<f32> centerOffset((templateImageWidth-1) / 2.0f, (templateImageHeight-1) / 2.0f);
;;;95             this->transformation = Transformations::PlanarTransformation_f32(Transformations::TRANSFORM_PROJECTIVE, templateQuad, centerOffset, slowMemory);
;;;96     
;;;97             this->templateQuad = templateQuad;
;;;98     
;;;99             this->templateEdges.xDecreasing = FixedLengthList<Point<s16> >(edgeDetectionParams.maxDetectionsPerType, fastMemory);
;;;100            this->templateEdges.xIncreasing = FixedLengthList<Point<s16> >(edgeDetectionParams.maxDetectionsPerType, fastMemory);
;;;101            this->templateEdges.yDecreasing = FixedLengthList<Point<s16> >(edgeDetectionParams.maxDetectionsPerType, fastMemory);
;;;102            this->templateEdges.yIncreasing = FixedLengthList<Point<s16> >(edgeDetectionParams.maxDetectionsPerType, fastMemory);
;;;103    
;;;104            this->templateImage = Array<u8>(templateImageHeight, templateImageWidth, slowMemory);
;;;105            this->templateImage.Set(templateImage);
;;;106    
;;;107            this->originalTemplateOrientation = 0.0f;
;;;108    
;;;109            AnkiConditionalErrorAndReturn(AreValid(this->templateEdges.xDecreasing, this->templateEdges.xIncreasing, this->templateEdges.yDecreasing, this->templateEdges.yIncreasing),
;;;110              "BinaryTracker::BinaryTracker", "Could not allocate local memory");
;;;111    
;;;112            const Rectangle<s32> edgeDetection_imageRegionOfInterest = templateQuad.ComputeBoundingRectangle<s32>().ComputeScaledRectangle<s32>(edgeDetectionParams.threshold_scaleRegionPercent);
;;;113    
;;;114            this->templateIntegerCounts = IntegerCounts(
;;;115              this->templateImage, edgeDetection_imageRegionOfInterest,
;;;116              edgeDetectionParams.threshold_yIncrement,
;;;117              edgeDetectionParams.threshold_xIncrement,
;;;118              fastMemory);
;;;119    
;;;120            AnkiConditionalErrorAndReturn(this->templateIntegerCounts.IsValid() ,
;;;121              "BinaryTracker::BinaryTracker", "Could not allocate local memory");
;;;122    
;;;123            this->lastGrayvalueThreshold = ComputeGrayvalueThreshold(this->templateIntegerCounts, edgeDetectionParams.threshold_blackPercentile, edgeDetectionParams.threshold_whitePercentile);
;;;124    
;;;125            //this->lastImageIntegerCounts.Set(this->templateIntegerCounts);
;;;126    
;;;127            const Rectangle<s32> templateRect = templateQuad.ComputeBoundingRectangle<s32>().ComputeScaledRectangle<s32>(scaleTemplateRegionPercent);
;;;128    
;;;129            Result result = RESULT_FAIL;
;;;130            if(edgeDetectionParams.type == TemplateTracker::BinaryTracker::EDGE_TYPE_GRAYVALUE) {
;;;131              result = DetectBlurredEdges_GrayvalueThreshold(templateImage, templateRect, this->lastGrayvalueThreshold, edgeDetectionParams.minComponentWidth, edgeDetectionParams.everyNLines, this->templateEdges);
;;;132            } else if(edgeDetectionParams.type == TemplateTracker::BinaryTracker::EDGE_TYPE_DERIVATIVE) {
;;;133              result = DetectBlurredEdges_DerivativeThreshold(templateImage, templateRect, edgeDetectionParams.combHalfWidth, edgeDetectionParams.combResponseThreshold, edgeDetectionParams.everyNLines, this->templateEdges);
;;;134            }
;;;135    
;;;136            this->lastUsedGrayvalueThreshold = this->lastGrayvalueThreshold;
;;;137    
;;;138            AnkiConditionalErrorAndReturn(result == RESULT_OK,
;;;139              "BinaryTracker::BinaryTracker", "DetectBlurredEdge failed");
;;;140    
;;;141            this->isValid = true;
;;;142          } // BinaryTracker::BinaryTracker()
;;;143    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  461d              MOV      r5,r3
000006  ed2d8b02          VPUSH    {d8}
00000a  b0c3              SUB      sp,sp,#0x10c
00000c  eef08a40          VMOV.F32 s17,s0
000010  e9dd874e          LDRD     r8,r7,[sp,#0x138]
000014  4692              MOV      r10,r2
000016  468b              MOV      r11,r1
000018  300c              ADDS     r0,r0,#0xc
00001a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00001e  f04f31ff          MOV      r1,#0xffffffff
000022  f8401d0c          STR      r1,[r0,#-0xc]!
000026  2600              MOVS     r6,#0
000028  6041              STR      r1,[r0,#4]
00002a  6106              STR      r6,[r0,#0x10]
00002c  6081              STR      r1,[r0,#8]
00002e  301c              ADDS     r0,r0,#0x1c
000030  2304              MOVS     r3,#4
000032  2208              MOVS     r2,#8
000034  49ee              LDR      r1,|L29.1008|
000036  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
00003a  4602              MOV      r2,r0
00003c  2000              MOVS     r0,#0
00003e  ed9f8aed          VLDR     s16,|L29.1012|
                  |L29.66|
000042  eb0201c0          ADD      r1,r2,r0,LSL #3
000046  ed8d8a00          VSTR     s16,[sp,#0]
00004a  ed8d8a01          VSTR     s16,[sp,#4]
00004e  ed9d0a00          VLDR     s0,[sp,#0]
000052  1c40              ADDS     r0,r0,#1
000054  ed810a00          VSTR     s0,[r1,#0]
000058  ed9d0a01          VLDR     s0,[sp,#4]
00005c  2804              CMP      r0,#4
00005e  ed810a01          VSTR     s0,[r1,#4]
000062  dbee              BLT      |L29.66|
000064  f1020020          ADD      r0,r2,#0x20
000068  f7fffffe          BL       _ZN4Anki8Embedded13IntegerCountsC1Ev ; Anki::Embedded::IntegerCounts::IntegerCounts()
00006c  3038              ADDS     r0,r0,#0x38
00006e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
000072  3034              ADDS     r0,r0,#0x34
000074  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
000078  3034              ADDS     r0,r0,#0x34
00007a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
00007e  3034              ADDS     r0,r0,#0x34
000080  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
000084  3040              ADDS     r0,r0,#0x40
000086  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1Ev ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32()
00008a  f5a074a8          SUB      r4,r0,#0x150
00008e  f8806046          STRB     r6,[r0,#0x46]
000092  2100              MOVS     r1,#0
000094  4658              MOV      r0,r11
000096  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00009a  6160              STR      r0,[r4,#0x14]
00009c  2101              MOVS     r1,#1
00009e  4658              MOV      r0,r11
0000a0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000a4  61a0              STR      r0,[r4,#0x18]
0000a6  6961              LDR      r1,[r4,#0x14]
0000a8  f8df934c          LDR      r9,|L29.1016|
0000ac  2900              CMP      r1,#0
0000ae  bfc8              IT       GT
0000b0  2800              CMPGT    r0,#0
0000b2  dc0e              BGT      |L29.210|
0000b4  2057              MOVS     r0,#0x57
0000b6  e9cd9000          STRD     r9,r0,[sp,#0]
0000ba  a3d0              ADR      r3,|L29.1020|
0000bc  a2db              ADR      r2,|L29.1068|
0000be  a1e9              ADR      r1,|L29.1124|
0000c0  2005              MOVS     r0,#5
0000c2  f7fffffe          BL       _Anki_Log
0000c6  4620              MOV      r0,r4
                  |L29.200|
0000c8  b043              ADD      sp,sp,#0x10c
0000ca  ecbd8b02          VPOP     {d8}
0000ce  e8bd8ff0          POP      {r4-r11,pc}
                  |L29.210|
0000d2  4658              MOV      r0,r11
0000d4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
0000d8  2800              CMP      r0,#0
0000da  f000813a          BEQ.W    |L29.850|
0000de  4640              MOV      r0,r8
0000e0  f7fffffe          BL       _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
0000e4  2800              CMP      r0,#0
0000e6  f0008134          BEQ.W    |L29.850|
0000ea  4638              MOV      r0,r7
0000ec  f7fffffe          BL       _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
0000f0  2800              CMP      r0,#0
0000f2  f000812e          BEQ.W    |L29.850|
0000f6  69a0              LDR      r0,[r4,#0x18]
0000f8  f50476a8          ADD      r6,r4,#0x150
0000fc  1e40              SUBS     r0,r0,#1
0000fe  ee000a10          VMOV     s0,r0
000102  6960              LDR      r0,[r4,#0x14]
000104  ab3c              ADD      r3,sp,#0xf0
000106  1e40              SUBS     r0,r0,#1
000108  ee010a10          VMOV     s2,r0
00010c  eef80ac0          VCVT.F32.S32 s1,s0
000110  eeb60a00          VMOV.F32 s0,#0.50000000
000114  eeb81ac1          VCVT.F32.S32 s2,s2
000118  4652              MOV      r2,r10
00011a  ee600a80          VMUL.F32 s1,s1,s0
00011e  f44f6100          MOV      r1,#0x800
000122  ee210a00          VMUL.F32 s0,s2,s0
000126  edcd0a3c          VSTR     s1,[sp,#0xf0]
00012a  a814              ADD      r0,sp,#0x50
00012c  ed8d0a3d          VSTR     s0,[sp,#0xf4]
000130  9700              STR      r7,[sp,#0]
000132  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5PointIfEERNS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
000136  7801              LDRB     r1,[r0,#0]
000138  7031              STRB     r1,[r6,#0]
00013a  8841              LDRH     r1,[r0,#2]
00013c  8071              STRH     r1,[r6,#2]
00013e  6842              LDR      r2,[r0,#4]
000140  6072              STR      r2,[r6,#4]
000142  6882              LDR      r2,[r0,#8]
000144  60b2              STR      r2,[r6,#8]
000146  68c2              LDR      r2,[r0,#0xc]
000148  60f2              STR      r2,[r6,#0xc]
00014a  6902              LDR      r2,[r0,#0x10]
00014c  6132              STR      r2,[r6,#0x10]
00014e  6942              LDR      r2,[r0,#0x14]
000150  f1060e18          ADD      lr,r6,#0x18
000154  f1000c18          ADD      r12,r0,#0x18
000158  2100              MOVS     r1,#0
00015a  6172              STR      r2,[r6,#0x14]
                  |L29.348|
00015c  eb0c02c1          ADD      r2,r12,r1,LSL #3
000160  eb0e03c1          ADD      r3,lr,r1,LSL #3
000164  ed920a00          VLDR     s0,[r2,#0]
000168  1c49              ADDS     r1,r1,#1
00016a  ed830a00          VSTR     s0,[r3,#0]
00016e  ed920a01          VLDR     s0,[r2,#4]
000172  2904              CMP      r1,#4
000174  ed830a01          VSTR     s0,[r3,#4]
000178  dbf0              BLT      |L29.348|
00017a  f8901038          LDRB     r1,[r0,#0x38]
00017e  f8861038          STRB     r1,[r6,#0x38]
000182  ed900a0f          VLDR     s0,[r0,#0x3c]
000186  f1040c1c          ADD      r12,r4,#0x1c
00018a  ed860a0f          VSTR     s0,[r6,#0x3c]
00018e  ed900a10          VLDR     s0,[r0,#0x40]
000192  4653              MOV      r3,r10
000194  ed860a10          VSTR     s0,[r6,#0x40]
000198  2000              MOVS     r0,#0
                  |L29.410|
00019a  eb0301c0          ADD      r1,r3,r0,LSL #3
00019e  eb0c02c0          ADD      r2,r12,r0,LSL #3
0001a2  ed910a00          VLDR     s0,[r1,#0]
0001a6  1c40              ADDS     r0,r0,#1
0001a8  ed820a00          VSTR     s0,[r2,#0]
0001ac  ed910a01          VLDR     s0,[r1,#4]
0001b0  2804              CMP      r0,#4
0001b2  ed820a01          VSTR     s0,[r2,#4]
0001b6  dbf0              BLT      |L29.410|
0001b8  2300              MOVS     r3,#0
0001ba  461a              MOV      r2,r3
0001bc  2101              MOVS     r1,#1
0001be  a80f              ADD      r0,sp,#0x3c
0001c0  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001c4  6803              LDR      r3,[r0,#0]
0001c6  69e9              LDR      r1,[r5,#0x1c]
0001c8  4642              MOV      r2,r8
0001ca  a802              ADD      r0,sp,#8
0001cc  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0001d0  4601              MOV      r1,r0
0001d2  f1040074          ADD      r0,r4,#0x74
0001d6  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
0001da  2300              MOVS     r3,#0
0001dc  461a              MOV      r2,r3
0001de  2101              MOVS     r1,#1
0001e0  a80f              ADD      r0,sp,#0x3c
0001e2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001e6  6803              LDR      r3,[r0,#0]
0001e8  69e9              LDR      r1,[r5,#0x1c]
0001ea  4642              MOV      r2,r8
0001ec  a802              ADD      r0,sp,#8
0001ee  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0001f2  4601              MOV      r1,r0
0001f4  f10400a8          ADD      r0,r4,#0xa8
0001f8  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
0001fc  2300              MOVS     r3,#0
0001fe  461a              MOV      r2,r3
000200  2101              MOVS     r1,#1
000202  a80f              ADD      r0,sp,#0x3c
000204  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000208  6803              LDR      r3,[r0,#0]
00020a  69e9              LDR      r1,[r5,#0x1c]
00020c  4642              MOV      r2,r8
00020e  a802              ADD      r0,sp,#8
000210  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000214  4601              MOV      r1,r0
000216  f10400dc          ADD      r0,r4,#0xdc
00021a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
00021e  2300              MOVS     r3,#0
000220  461a              MOV      r2,r3
000222  2101              MOVS     r1,#1
000224  a80f              ADD      r0,sp,#0x3c
000226  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00022a  6803              LDR      r3,[r0,#0]
00022c  69e9              LDR      r1,[r5,#0x1c]
00022e  4642              MOV      r2,r8
000230  a802              ADD      r0,sp,#8
000232  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000236  4601              MOV      r1,r0
000238  f5047088          ADD      r0,r4,#0x110
00023c  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
000240  2300              MOVS     r3,#0
000242  461a              MOV      r2,r3
000244  2101              MOVS     r1,#1
000246  a80f              ADD      r0,sp,#0x3c
000248  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00024c  6800              LDR      r0,[r0,#0]
00024e  9000              STR      r0,[sp,#0]
000250  e9d41205          LDRD     r1,r2,[r4,#0x14]
000254  463b              MOV      r3,r7
000256  a83e              ADD      r0,sp,#0xf8
000258  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00025c  6801              LDR      r1,[r0,#0]
00025e  6021              STR      r1,[r4,#0]
000260  6841              LDR      r1,[r0,#4]
000262  6061              STR      r1,[r4,#4]
000264  6881              LDR      r1,[r0,#8]
000266  60a1              STR      r1,[r4,#8]
000268  68c1              LDR      r1,[r0,#0xc]
00026a  60e1              STR      r1,[r4,#0xc]
00026c  6900              LDR      r0,[r0,#0x10]
00026e  6120              STR      r0,[r4,#0x10]
000270  4659              MOV      r1,r11
000272  4620              MOV      r0,r4
000274  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhE3SetERKS2_ ; Anki::Embedded::Array<unsigned char>::Set(const Anki::Embedded::Array<unsigned char>&)
000278  ed848a53          VSTR     s16,[r4,#0x14c]
00027c  f10401a8          ADD      r1,r4,#0xa8
000280  f1040074          ADD      r0,r4,#0x74
000284  f10407dc          ADD      r7,r4,#0xdc
000288  f5047688          ADD      r6,r4,#0x110
00028c  9100              STR      r1,[sp,#0]
00028e  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
000292  2800              CMP      r0,#0
000294  d068              BEQ      |L29.872|
000296  9800              LDR      r0,[sp,#0]
000298  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
00029c  2800              CMP      r0,#0
00029e  d063              BEQ      |L29.872|
0002a0  4638              MOV      r0,r7
0002a2  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
0002a6  2800              CMP      r0,#0
0002a8  d05e              BEQ      |L29.872|
0002aa  4630              MOV      r0,r6
0002ac  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
0002b0  2800              CMP      r0,#0
0002b2  d059              BEQ      |L29.872|
0002b4  4651              MOV      r1,r10
0002b6  a810              ADD      r0,sp,#0x40
0002b8  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE24ComputeBoundingRectangleIiEENS0_9RectangleIT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeBoundingRectangle<int>() const
0002bc  ed950a05          VLDR     s0,[r5,#0x14]
0002c0  a910              ADD      r1,sp,#0x40
0002c2  a838              ADD      r0,sp,#0xe0
0002c4  f7fffffe          BL       _ZNK4Anki8Embedded9RectangleIiE22ComputeScaledRectangleIiEENS1_IT_EEf ; Anki::Embedded::Rectangle<int>::ComputeScaledRectangle<int>(float) const
0002c8  68a8              LDR      r0,[r5,#8]
0002ca  e9cd0800          STRD     r0,r8,[sp,#0]
0002ce  3ed4              SUBS     r6,r6,#0xd4
0002d0  aa38              ADD      r2,sp,#0xe0
0002d2  4621              MOV      r1,r4
0002d4  a826              ADD      r0,sp,#0x98
0002d6  686b              LDR      r3,[r5,#4]
0002d8  f7fffffe          BL       _ZN4Anki8Embedded13IntegerCountsC1ERKNS0_5ArrayIhEERKNS0_9RectangleIiEEiiRNS0_11MemoryStackE ; Anki::Embedded::IntegerCounts::IntegerCounts(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Rectangle<int>&, int, int, Anki::Embedded::MemoryStack&)
0002dc  e9d01200          LDRD     r1,r2,[r0,#0]
0002e0  6883              LDR      r3,[r0,#8]
0002e2  60b3              STR      r3,[r6,#8]
0002e4  e9c61200          STRD     r1,r2,[r6,#0]
0002e8  e9d01203          LDRD     r1,r2,[r0,#0xc]
0002ec  6943              LDR      r3,[r0,#0x14]
0002ee  6173              STR      r3,[r6,#0x14]
0002f0  e9c61203          STRD     r1,r2,[r6,#0xc]
0002f4  6982              LDR      r2,[r0,#0x18]
0002f6  61b2              STR      r2,[r6,#0x18]
0002f8  69c2              LDR      r2,[r0,#0x1c]
0002fa  61f2              STR      r2,[r6,#0x1c]
0002fc  6a02              LDR      r2,[r0,#0x20]
0002fe  6232              STR      r2,[r6,#0x20]
000300  6a42              LDR      r2,[r0,#0x24]
000302  6272              STR      r2,[r6,#0x24]
000304  6a82              LDR      r2,[r0,#0x28]
000306  62b2              STR      r2,[r6,#0x28]
000308  6ac1              LDR      r1,[r0,#0x2c]
00030a  62f1              STR      r1,[r6,#0x2c]
00030c  6b01              LDR      r1,[r0,#0x30]
00030e  6331              STR      r1,[r6,#0x30]
000310  6b40              LDR      r0,[r0,#0x34]
000312  6370              STR      r0,[r6,#0x34]
000314  4630              MOV      r0,r6
000316  f7fffffe          BL       _ZNK4Anki8Embedded13IntegerCounts7IsValidEv ; Anki::Embedded::IntegerCounts::IsValid() const
00031a  2800              CMP      r0,#0
00031c  d02f              BEQ      |L29.894|
00031e  edd50a04          VLDR     s1,[r5,#0x10]
000322  ed950a03          VLDR     s0,[r5,#0xc]
000326  4630              MOV      r0,r6
000328  f7fffffe          BL       _ZN4Anki8Embedded25ComputeGrayvalueThresholdERKNS0_13IntegerCountsEff ; Anki::Embedded::ComputeGrayvalueThreshold(const Anki::Embedded::IntegerCounts&, float, float)
00032c  f8840195          STRB     r0,[r4,#0x195]
000330  4651              MOV      r1,r10
000332  a810              ADD      r0,sp,#0x40
000334  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE24ComputeBoundingRectangleIiEENS0_9RectangleIT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeBoundingRectangle<int>() const
000338  eeb00a68          VMOV.F32 s0,s17
00033c  a910              ADD      r1,sp,#0x40
00033e  a834              ADD      r0,sp,#0xd0
000340  f7fffffe          BL       _ZNK4Anki8Embedded9RectangleIiE22ComputeScaledRectangleIiEENS1_IT_EEf ; Anki::Embedded::Rectangle<int>::ComputeScaledRectangle<int>(float) const
000344  7829              LDRB     r1,[r5,#0]
000346  2001              MOVS     r0,#1
000348  2900              CMP      r1,#0
00034a  d023              BEQ      |L29.916|
00034c  2901              CMP      r1,#1
00034e  d02e              BEQ      |L29.942|
000350  e038              B        |L29.964|
                  |L29.850|
000352  205a              MOVS     r0,#0x5a
000354  e9cd9000          STRD     r9,r0,[sp,#0]
000358  a328              ADR      r3,|L29.1020|
00035a  a24a              ADR      r2,|L29.1156|
00035c  a141              ADR      r1,|L29.1124|
00035e  2005              MOVS     r0,#5
000360  f7fffffe          BL       _Anki_Log
000364  4620              MOV      r0,r4
000366  e6af              B        |L29.200|
                  |L29.872|
000368  206d              MOVS     r0,#0x6d
00036a  e9cd9000          STRD     r9,r0,[sp,#0]
00036e  a323              ADR      r3,|L29.1020|
000370  a248              ADR      r2,|L29.1172|
000372  a13c              ADR      r1,|L29.1124|
000374  2005              MOVS     r0,#5
000376  f7fffffe          BL       _Anki_Log
00037a  4620              MOV      r0,r4
00037c  e6a4              B        |L29.200|
                  |L29.894|
00037e  2078              MOVS     r0,#0x78
000380  e9cd9000          STRD     r9,r0,[sp,#0]
000384  a31d              ADR      r3,|L29.1020|
000386  a243              ADR      r2,|L29.1172|
000388  a136              ADR      r1,|L29.1124|
00038a  2005              MOVS     r0,#5
00038c  f7fffffe          BL       _Anki_Log
000390  4620              MOV      r0,r4
000392  e699              B        |L29.200|
                  |L29.916|
000394  f1040174          ADD      r1,r4,#0x74
000398  6aa8              LDR      r0,[r5,#0x28]
00039a  e9cd0100          STRD     r0,r1,[sp,#0]
00039e  f8942195          LDRB     r2,[r4,#0x195]
0003a2  a934              ADD      r1,sp,#0xd0
0003a4  4658              MOV      r0,r11
0003a6  69ab              LDR      r3,[r5,#0x18]
0003a8  f7fffffe          BL       _ZN4Anki8Embedded37DetectBlurredEdges_GrayvalueThresholdERKNS0_5ArrayIhEERKNS0_9RectangleIiEEhiiRNS0_9EdgeListsE ; Anki::Embedded::DetectBlurredEdges_GrayvalueThreshold(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Rectangle<int>&, unsigned char, int, int, Anki::Embedded::EdgeLists&)
0003ac  e00a              B        |L29.964|
                  |L29.942|
0003ae  f1040174          ADD      r1,r4,#0x74
0003b2  6aa8              LDR      r0,[r5,#0x28]
0003b4  e9cd0100          STRD     r0,r1,[sp,#0]
0003b8  e9d52308          LDRD     r2,r3,[r5,#0x20]
0003bc  a934              ADD      r1,sp,#0xd0
0003be  4658              MOV      r0,r11
0003c0  f7fffffe          BL       _ZN4Anki8Embedded38DetectBlurredEdges_DerivativeThresholdERKNS0_5ArrayIhEERKNS0_9RectangleIiEEiiiRNS0_9EdgeListsE ; Anki::Embedded::DetectBlurredEdges_DerivativeThreshold(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Rectangle<int>&, int, int, int, Anki::Embedded::EdgeLists&)
                  |L29.964|
0003c4  f8941195          LDRB     r1,[r4,#0x195]
0003c8  f8841194          STRB     r1,[r4,#0x194]
0003cc  2800              CMP      r0,#0
0003ce  bf04              ITT      EQ
0003d0  2001              MOVEQ    r0,#1
0003d2  f8840196          STRBEQ   r0,[r4,#0x196]
0003d6  d008              BEQ      |L29.1002|
0003d8  208a              MOVS     r0,#0x8a
0003da  e9cd9000          STRD     r9,r0,[sp,#0]
0003de  a307              ADR      r3,|L29.1020|
0003e0  a234              ADR      r2,|L29.1204|
0003e2  a120              ADR      r1,|L29.1124|
0003e4  2005              MOVS     r0,#5
0003e6  f7fffffe          BL       _Anki_Log
                  |L29.1002|
0003ea  4620              MOV      r0,r4
0003ec  e66c              B        |L29.200|
                          ENDP

0003ee  0000              DCW      0x0000
                  |L29.1008|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()
                  |L29.1012|
0003f4  00000000          DCFS     0x00000000 ; 0
                  |L29.1016|
                          DCD      ||.constdata||
                  |L29.1020|
0003fc  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\binaryTracker.cpp",0
000400  6f726574
000404  6563685c
000408  76697369
00040c  6f6e5c72
000410  6f626f74
000414  5c737263
000418  5c62696e
00041c  61727954
000420  7261636b
000424  65722e63
000428  707000  
00042b  00                DCB      0
                  |L29.1068|
00042c  74656d70          DCB      "template widths and heights must be greater than zero",0
000430  6c617465
000434  20776964
000438  74687320
00043c  616e6420
000440  68656967
000444  68747320
000448  6d757374
00044c  20626520
000450  67726561
000454  74657220
000458  7468616e
00045c  207a6572
000460  6f00    
000462  00                DCB      0
000463  00                DCB      0
                  |L29.1124|
000464  42696e61          DCB      "BinaryTracker::BinaryTracker",0
000468  72795472
00046c  61636b65
000470  723a3a42
000474  696e6172
000478  79547261
00047c  636b6572
000480  00      
000481  00                DCB      0
000482  00                DCB      0
000483  00                DCB      0
                  |L29.1156|
000484  496e7661          DCB      "Invalid objects",0
000488  6c696420
00048c  6f626a65
000490  63747300
                  |L29.1172|
000494  436f756c          DCB      "Could not allocate local memory",0
000498  64206e6f
00049c  7420616c
0004a0  6c6f6361
0004a4  7465206c
0004a8  6f63616c
0004ac  206d656d
0004b0  6f727900
                  |L29.1204|
0004b4  44657465          DCB      "DetectBlurredEdge failed",0
0004b8  6374426c
0004bc  75727265
0004c0  64456467
0004c4  65206661
0004c8  696c6564
0004cc  00      
0004cd  00                DCB      0
0004ce  00                DCB      0
0004cf  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC1Ev||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC2Ev                  ; Alternate entry point ; Anki::Embedded::TemplateTracker::BinaryTracker::BinaryTracker__sub_object()
                  _ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC1Ev PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::BinaryTracker()
;;;69     
;;;70           BinaryTracker::BinaryTracker()
;;;71             : isValid(false)
;;;72           {
;;;73           }
;;;74     
000000  b510              PUSH     {r4,lr}
000002  b082              SUB      sp,sp,#8
000004  300c              ADDS     r0,r0,#0xc
000006  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00000a  f04f31ff          MOV      r1,#0xffffffff
00000e  f8401d0c          STR      r1,[r0,#-0xc]!
000012  2400              MOVS     r4,#0
000014  6041              STR      r1,[r0,#4]
000016  6104              STR      r4,[r0,#0x10]
000018  6081              STR      r1,[r0,#8]
00001a  301c              ADDS     r0,r0,#0x1c
00001c  2304              MOVS     r3,#4
00001e  2208              MOVS     r2,#8
000020  4917              LDR      r1,|L30.128|
000022  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
000026  ed9f0a17          VLDR     s0,|L30.132|
00002a  2100              MOVS     r1,#0
                  |L30.44|
00002c  ed8d0a00          VSTR     s0,[sp,#0]
000030  ed8d0a01          VSTR     s0,[sp,#4]
000034  eb0002c1          ADD      r2,r0,r1,LSL #3
000038  eddd0a00          VLDR     s1,[sp,#0]
00003c  1c49              ADDS     r1,r1,#1
00003e  edc20a00          VSTR     s1,[r2,#0]
000042  eddd0a01          VLDR     s1,[sp,#4]
000046  2904              CMP      r1,#4
000048  edc20a01          VSTR     s1,[r2,#4]
00004c  dbee              BLT      |L30.44|
00004e  3020              ADDS     r0,r0,#0x20
000050  f7fffffe          BL       _ZN4Anki8Embedded13IntegerCountsC1Ev ; Anki::Embedded::IntegerCounts::IntegerCounts()
000054  3038              ADDS     r0,r0,#0x38
000056  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
00005a  3034              ADDS     r0,r0,#0x34
00005c  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
000060  3034              ADDS     r0,r0,#0x34
000062  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
000066  3034              ADDS     r0,r0,#0x34
000068  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
00006c  3040              ADDS     r0,r0,#0x40
00006e  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1Ev ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32()
000072  f5a070a8          SUB      r0,r0,#0x150
000076  f8804196          STRB     r4,[r0,#0x196]
00007a  b002              ADD      sp,sp,#8
00007c  bd10              POP      {r4,pc}
                          ENDP

00007e  0000              DCW      0x0000
                  |L30.128|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()
                  |L30.132|
000084  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf PROC ; Anki::Embedded::TemplateTracker::RoundS32_minusPointFive(float)
                  |symbol_number.449|
;;;42         {
;;;43           NO_INLINE static s32 RoundS32_minusPointFive(f32 x)
000000  eeb50ac0          VCMPE.F32 s0,#0.0
;;;44           {
;;;45     #if !defined(USE_ARM_ACCELERATION)
;;;46             // Some platforms may not round to zero correctly, so do the function calls
;;;47             if(x > 0)
;;;48               return static_cast<s32>(floorf(x));
;;;49             else
;;;50               return static_cast<s32>(ceilf(x - 1.0f));
;;;51     #else
;;;52             // The M4 rounds to zero correctly, without the function call
;;;53             if(x > 0)
000004  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;54               return static_cast<s32>(x);
000008  bfc2              ITTT     GT
00000a  eebd0ac0          VCVTGT.S32.F32 s0,s0
00000e  ee100a10          VMOVGT   r0,s0
;;;55             else
;;;56               return static_cast<s32>(x - 1.0f);
;;;57     #endif
;;;58           }
000012  4770              BXGT     lr
000014  eef70a00          VMOV.F32 s1,#1.00000000        ;56
000018  ee300a60          VSUB.F32 s0,s0,s1              ;56
00001c  eebd0ac0          VCVT.S32.F32 s0,s0                 ;56
000020  ee100a10          VMOV     r0,s0                 ;56
000024  4770              BX       lr
;;;59     
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker12ShowTemplateEPKcbbf||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker13BinaryTracker12ShowTemplateEPKcbbf PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::ShowTemplate(const char*, bool, bool, float) const
;;;380    
;;;381          Result BinaryTracker::ShowTemplate(const char * windowName, const bool waitForKeypress, const bool fitImageToWindow, const f32 displayScale) const
000000  2001              MOVS     r0,#1
;;;382          {
;;;383    #if !ANKICORETECH_EMBEDDED_USE_OPENCV || defined(__GNUC__)
;;;384            return RESULT_FAIL;
;;;385    #else
;;;386            //if(!this->IsValid())
;;;387            //  return RESULT_FAIL;
;;;388    
;;;389            cv::Mat toShow = this->templateEdges.DrawIndexes(displayScale);
;;;390    
;;;391            if(toShow.cols == 0)
;;;392              return RESULT_FAIL;
;;;393    
;;;394            if(fitImageToWindow) {
;;;395              cv::namedWindow(windowName, CV_WINDOW_NORMAL);
;;;396            } else {
;;;397              cv::namedWindow(windowName, CV_WINDOW_AUTOSIZE);
;;;398            }
;;;399    
;;;400            cv::imshow(windowName, toShow);
;;;401    
;;;402            if(waitForKeypress)
;;;403              cv::waitKey();
;;;404    
;;;405            return RESULT_OK;
;;;406    #endif // #if !ANKICORETECH_EMBEDDED_USE_OPENCV ... #else
;;;407          } // Result BinaryTracker::ShowTemplate()
000002  4770              BX       lr
;;;408    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker18get_transformationEv||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15TemplateTracker13BinaryTracker18get_transformationEv PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::get_transformation() const
;;;507    
;;;508          Transformations::PlanarTransformation_f32 BinaryTracker::get_transformation() const
000000  b570              PUSH     {r4-r6,lr}
;;;509          {
;;;510            return transformation;
000002  f50174a8          ADD      r4,r1,#0x150
000006  f8911150          LDRB     r1,[r1,#0x150]
00000a  7001              STRB     r1,[r0,#0]
00000c  8861              LDRH     r1,[r4,#2]
00000e  8041              STRH     r1,[r0,#2]
000010  1d22              ADDS     r2,r4,#4
000012  1d06              ADDS     r6,r0,#4
000014  e892102e          LDM      r2,{r1-r3,r5,r12}
000018  e8a6102e          STM      r6!,{r1-r3,r5,r12}
00001c  3018              ADDS     r0,r0,#0x18
00001e  f1040518          ADD      r5,r4,#0x18
000022  2304              MOVS     r3,#4
000024  2208              MOVS     r2,#8
000026  4910              LDR      r1,|L33.104|
000028  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
00002c  2200              MOVS     r2,#0
                  |L33.46|
00002e  eb0501c2          ADD      r1,r5,r2,LSL #3
000032  eb0003c2          ADD      r3,r0,r2,LSL #3
000036  ed910a00          VLDR     s0,[r1,#0]
00003a  1c52              ADDS     r2,r2,#1
00003c  ed830a00          VSTR     s0,[r3,#0]
000040  ed910a01          VLDR     s0,[r1,#4]
000044  2a04              CMP      r2,#4
000046  ed830a01          VSTR     s0,[r3,#4]
00004a  dbf0              BLT      |L33.46|
00004c  f8942038          LDRB     r2,[r4,#0x38]
000050  f8802020          STRB     r2,[r0,#0x20]
000054  ed940a0f          VLDR     s0,[r4,#0x3c]
000058  ed800a09          VSTR     s0,[r0,#0x24]
00005c  ed940a10          VLDR     s0,[r4,#0x40]
000060  ed800a0a          VSTR     s0,[r0,#0x28]
;;;511          }
000064  bd70              POP      {r4-r6,pc}
;;;512    
                          ENDP

000066  0000              DCW      0x0000
                  |L33.104|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()

                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker21get_numTemplatePixelsEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker13BinaryTracker21get_numTemplatePixelsEv PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::get_numTemplatePixels() const
;;;494    
;;;495          s32 BinaryTracker::get_numTemplatePixels() const
000000  f8d020b4          LDR      r2,[r0,#0xb4]
;;;496          {
;;;497            return this->templateEdges.xDecreasing.get_size() +
000004  f8d01080          LDR      r1,[r0,#0x80]
000008  440a              ADD      r2,r2,r1
00000a  f8d010e8          LDR      r1,[r0,#0xe8]
00000e  f8d0011c          LDR      r0,[r0,#0x11c]
000012  4411              ADD      r1,r1,r2
000014  4408              ADD      r0,r0,r1
;;;498              this->templateEdges.xIncreasing.get_size() +
;;;499              this->templateEdges.yDecreasing.get_size() +
;;;500              this->templateEdges.yIncreasing.get_size();
;;;501          }
000016  4770              BX       lr
;;;502    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker21get_serializationSizeEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker13BinaryTracker21get_serializationSizeEv PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::get_serializationSize() const
;;;2436   
;;;2437         s32 BinaryTracker::get_serializationSize() const
000000  b510              PUSH     {r4,lr}
000002  f8d03080          LDR      r3,[r0,#0x80]
000006  f8d020b4          LDR      r2,[r0,#0xb4]
00000a  f8d010e8          LDR      r1,[r0,#0xe8]
00000e  f8d0011c          LDR      r0,[r0,#0x11c]
000012  330f              ADDS     r3,r3,#0xf
000014  320f              ADDS     r2,r2,#0xf
000016  f023030f          BIC      r3,r3,#0xf
00001a  f022020f          BIC      r2,r2,#0xf
00001e  310f              ADDS     r1,r1,#0xf
;;;2438         {
;;;2439           // TODO: make the correct length
;;;2440   
;;;2441           const s32 xDecreasingUsed = this->templateEdges.xDecreasing.get_size();
;;;2442           const s32 xIncreasingUsed = this->templateEdges.xIncreasing.get_size();
;;;2443           const s32 yDecreasingUsed = this->templateEdges.yDecreasing.get_size();
;;;2444           const s32 yIncreasingUsed = this->templateEdges.yIncreasing.get_size();
;;;2445   
;;;2446           const size_t numTemplatePixels =
000020  441a              ADD      r2,r2,r3
000022  f021010f          BIC      r1,r1,#0xf
000026  300f              ADDS     r0,r0,#0xf
000028  4411              ADD      r1,r1,r2
00002a  f020000f          BIC      r0,r0,#0xf
00002e  180c              ADDS     r4,r1,r0
;;;2447             RoundUp<size_t>(xDecreasingUsed, MEMORY_ALIGNMENT) +
;;;2448             RoundUp<size_t>(xIncreasingUsed, MEMORY_ALIGNMENT) +
;;;2449             RoundUp<size_t>(yDecreasingUsed, MEMORY_ALIGNMENT) +
;;;2450             RoundUp<size_t>(yIncreasingUsed, MEMORY_ALIGNMENT);
;;;2451   
;;;2452           AnkiAssert(numTemplatePixels < s32_MAX);
;;;2453           const s32 requiredBytes = 512 + static_cast<s32>(numTemplatePixels)*sizeof(Point<s16>) + Transformations::PlanarTransformation_f32::get_serializationSize() + 16*SerializedBuffer::DESCRIPTION_STRING_LENGTH;
000030  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221get_serializationSizeEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_serializationSize()
000034  eb000084          ADD      r0,r0,r4,LSL #2
000038  f5006080          ADD      r0,r0,#0x400
;;;2454   
;;;2455           return requiredBytes;
;;;2456         }
00003c  bd10              POP      {r4,pc}
;;;2457   
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker26get_lastGrayvalueThresholdEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker13BinaryTracker26get_lastGrayvalueThresholdEv PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::get_lastGrayvalueThreshold() const
;;;2462   
;;;2463         s32 BinaryTracker::get_lastGrayvalueThreshold() const
000000  f8900195          LDRB     r0,[r0,#0x195]
;;;2464         {
;;;2465           return this->lastGrayvalueThreshold;
;;;2466         }
000004  4770              BX       lr
;;;2467       } // namespace TemplateTracker
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker29get_lastUsedGrayvalueThreholdEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker13BinaryTracker29get_lastUsedGrayvalueThreholdEv PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::get_lastUsedGrayvalueThrehold() const
;;;2457   
;;;2458         s32 BinaryTracker::get_lastUsedGrayvalueThrehold() const
000000  f8900194          LDRB     r0,[r0,#0x194]
;;;2459         {
;;;2460           return this->lastUsedGrayvalueThreshold;
;;;2461         }
000004  4770              BX       lr
;;;2462   
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker7IsValidEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker13BinaryTracker7IsValidEv PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::IsValid() const
;;;408    
;;;409          bool BinaryTracker::IsValid() const
000000  f8901196          LDRB     r1,[r0,#0x196]
;;;410          {
;;;411            if(!this->isValid)
000004  2900              CMP      r1,#0
;;;412              return false;
000006  bf04              ITT      EQ
000008  2000              MOVEQ    r0,#0
;;;413    
;;;414            if(!AreValid(templateEdges.xDecreasing, templateEdges.xIncreasing, templateEdges.yDecreasing, templateEdges.yIncreasing))
;;;415              return false;
;;;416    
;;;417            return true;
;;;418          } // bool BinaryTracker::IsValid()
00000a  4770              BXEQ     lr
00000c  b570              PUSH     {r4-r6,lr}            ;410
00000e  f1000174          ADD      r1,r0,#0x74           ;414
000012  f10004a8          ADD      r4,r0,#0xa8           ;414
000016  f10005dc          ADD      r5,r0,#0xdc           ;414
00001a  f5007688          ADD      r6,r0,#0x110          ;414
00001e  4608              MOV      r0,r1                 ;414
000020  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
000024  b170              CBZ      r0,|L38.68|
000026  4620              MOV      r0,r4                 ;414
000028  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
00002c  b150              CBZ      r0,|L38.68|
00002e  4628              MOV      r0,r5                 ;414
000030  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
000034  b130              CBZ      r0,|L38.68|
000036  4630              MOV      r0,r6                 ;414
000038  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
00003c  2800              CMP      r0,#0                 ;414
00003e  bf1c              ITT      NE                    ;417
000040  2001              MOVNE    r0,#1                 ;417
000042  bd70              POPNE    {r4-r6,pc}
                  |L38.68|
000044  2000              MOVS     r0,#0                 ;415
000046  bd70              POP      {r4-r6,pc}
;;;419    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker9SerializeEPKcRNS0_16SerializedBufferE||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15TemplateTracker13BinaryTracker9SerializeEPKcRNS0_16SerializedBufferE PROC ; Anki::Embedded::TemplateTracker::BinaryTracker::Serialize(const char*, Anki::Embedded::SerializedBuffer&) const
;;;424    
;;;425          Result BinaryTracker::Serialize(const char *objectName, SerializedBuffer &buffer) const
000000  b5f0              PUSH     {r4-r7,lr}
000002  f8d0c080          LDR      r12,[r0,#0x80]
000006  f8d030b4          LDR      r3,[r0,#0xb4]
;;;426          {
00000a  4616              MOV      r6,r2
00000c  f8d020e8          LDR      r2,[r0,#0xe8]
000010  460d              MOV      r5,r1
000012  f10c010f          ADD      r1,r12,#0xf
000016  330f              ADDS     r3,r3,#0xf
000018  4604              MOV      r4,r0
00001a  f021010f          BIC      r1,r1,#0xf
00001e  f023030f          BIC      r3,r3,#0xf
000022  f8d0011c          LDR      r0,[r0,#0x11c]
000026  440b              ADD      r3,r3,r1
000028  f102010f          ADD      r1,r2,#0xf
00002c  f021010f          BIC      r1,r1,#0xf
000030  300f              ADDS     r0,r0,#0xf
000032  4419              ADD      r1,r1,r3
000034  f020000f          BIC      r0,r0,#0xf
000038  b083              SUB      sp,sp,#0xc
00003a  180f              ADDS     r7,r1,r0
00003c  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221get_serializationSizeEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_serializationSize()
000040  eb000087          ADD      r0,r0,r7,LSL #2
000044  f5006380          ADD      r3,r0,#0x400
;;;427            s32 totalDataLength = this->get_serializationSize();
;;;428    
;;;429            void *segment = buffer.Allocate("BinaryTracker", objectName, totalDataLength);
000048  462a              MOV      r2,r5
00004a  a139              ADR      r1,|L39.304|
00004c  4630              MOV      r0,r6
00004e  9300              STR      r3,[sp,#0]
000050  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer8AllocateEPKcS3_i ; Anki::Embedded::SerializedBuffer::Allocate(const char*, const char*, int)
;;;430    
;;;431            if(segment == NULL) {
000054  9001              STR      r0,[sp,#4]
000056  2800              CMP      r0,#0
000058  f0008067          BEQ.W    |L39.298|
;;;432              return RESULT_FAIL;
;;;433            }
;;;434    
;;;435            if(SerializedBuffer::SerializeDescriptionStrings("BinaryTracker", objectName, &segment, totalDataLength) != RESULT_OK)
00005c  466b              MOV      r3,sp
00005e  aa01              ADD      r2,sp,#4
000060  4629              MOV      r1,r5
000062  a033              ADR      r0,|L39.304|
000064  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeDescriptionStrings(const char*, const char*, void**, int&)
000068  2800              CMP      r0,#0
00006a  d15e              BNE      |L39.298|
;;;436              return RESULT_FAIL;
;;;437    
;;;438            if(SerializedBuffer::SerializeRawBasicType<bool>("templateEdges.isValid", this->isValid, &segment, totalDataLength) != RESULT_OK)
00006c  a134              ADR      r1,|L39.320|
00006e  f50476cb          ADD      r6,r4,#0x196
000072  aa01              ADD      r2,sp,#4
000074  466b              MOV      r3,sp
000076  2501              MOVS     r5,#1
000078  a037              ADR      r0,|L39.344|
00007a  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeDescriptionStrings(const char*, const char*, void**, int&)
00007e  2800              CMP      r0,#0
000080  d153              BNE      |L39.298|
000082  9800              LDR      r0,[sp,#0]
000084  2808              CMP      r0,#8
000086  db07              BLT      |L39.152|
000088  9801              LDR      r0,[sp,#4]
00008a  4938              LDR      r1,|L39.364|
00008c  e8e01502          STRD     r1,r5,[r0],#8
000090  9001              STR      r0,[sp,#4]
000092  9800              LDR      r0,[sp,#0]
000094  3808              SUBS     r0,r0,#8
000096  9000              STR      r0,[sp,#0]
                  |L39.152|
000098  462a              MOV      r2,r5
00009a  4631              MOV      r1,r6
00009c  9801              LDR      r0,[sp,#4]
00009e  f7fffffe          BL       __aeabi_memcpy
0000a2  9801              LDR      r0,[sp,#4]
;;;439              return RESULT_FAIL;
;;;440    
;;;441            // First, serialize the transformation
;;;442            if(this->transformation.SerializeRaw("transformation", &segment, totalDataLength) != RESULT_OK)
0000a4  466b              MOV      r3,sp
0000a6  1c40              ADDS     r0,r0,#1
0000a8  9001              STR      r0,[sp,#4]
0000aa  9800              LDR      r0,[sp,#0]
0000ac  aa01              ADD      r2,sp,#4
0000ae  1e40              SUBS     r0,r0,#1
0000b0  9000              STR      r0,[sp,#0]
0000b2  a12f              ADR      r1,|L39.368|
0000b4  f50470a8          ADD      r0,r4,#0x150
0000b8  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3212SerializeRawEPKcPPvRi ; Anki::Embedded::Transformations::PlanarTransformation_f32::SerializeRaw(const char*, void**, int&) const
0000bc  2800              CMP      r0,#0
0000be  d134              BNE      |L39.298|
;;;443              return RESULT_FAIL;
;;;444    
;;;445            // Next, serialize the template lists
;;;446            if(SerializedBuffer::SerializeRawBasicType<s32>("templateEdges.imageHeight", this->templateEdges.imageHeight, &segment, totalDataLength) != RESULT_OK)
0000c0  466b              MOV      r3,sp
0000c2  aa01              ADD      r2,sp,#4
0000c4  f50471a2          ADD      r1,r4,#0x144
0000c8  a02d              ADR      r0,|L39.384|
0000ca  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIiEENS_6ResultEPKcRKT_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeRawBasicType<int>(const char*, const T1&, void**, int&)
0000ce  2800              CMP      r0,#0
0000d0  d12b              BNE      |L39.298|
;;;447              return RESULT_FAIL;
;;;448    
;;;449            if(SerializedBuffer::SerializeRawBasicType<s32>("templateEdges.imageWidth", this->templateEdges.imageWidth, &segment, totalDataLength) != RESULT_OK)
0000d2  466b              MOV      r3,sp
0000d4  aa01              ADD      r2,sp,#4
0000d6  f50471a4          ADD      r1,r4,#0x148
0000da  a030              ADR      r0,|L39.412|
0000dc  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIiEENS_6ResultEPKcRKT_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeRawBasicType<int>(const char*, const T1&, void**, int&)
0000e0  2800              CMP      r0,#0
0000e2  d122              BNE      |L39.298|
;;;450              return RESULT_FAIL;
;;;451    
;;;452            if(SerializedBuffer::SerializeRawFixedLengthList<Point<s16> >("templateEdges.xDecreasing", this->templateEdges.xDecreasing, &segment, totalDataLength) != RESULT_OK)
0000e4  a034              ADR      r0,|L39.440|
0000e6  f1040174          ADD      r1,r4,#0x74
0000ea  aa01              ADD      r2,sp,#4
0000ec  466b              MOV      r3,sp
0000ee  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRi ; Anki::Embedded::SerializedBuffer::SerializeRawArraySlice<Anki::Embedded::Point<short>>(const char*, const Anki::Embedded::ConstArraySlice<T1>&, void**, int&)
0000f2  b9d0              CBNZ     r0,|L39.298|
;;;453              return RESULT_FAIL;
;;;454    
;;;455            if(SerializedBuffer::SerializeRawFixedLengthList<Point<s16> >("templateEdges.xIncreasing", this->templateEdges.xIncreasing, &segment, totalDataLength) != RESULT_OK)
0000f4  a037              ADR      r0,|L39.468|
0000f6  f10401a8          ADD      r1,r4,#0xa8
0000fa  aa01              ADD      r2,sp,#4
0000fc  466b              MOV      r3,sp
0000fe  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRi ; Anki::Embedded::SerializedBuffer::SerializeRawArraySlice<Anki::Embedded::Point<short>>(const char*, const Anki::Embedded::ConstArraySlice<T1>&, void**, int&)
000102  b990              CBNZ     r0,|L39.298|
;;;456              return RESULT_FAIL;
;;;457    
;;;458            if(SerializedBuffer::SerializeRawFixedLengthList<Point<s16> >("templateEdges.yDecreasing", this->templateEdges.yDecreasing, &segment, totalDataLength) != RESULT_OK)
000104  a03a              ADR      r0,|L39.496|
000106  f10401dc          ADD      r1,r4,#0xdc
00010a  aa01              ADD      r2,sp,#4
00010c  466b              MOV      r3,sp
00010e  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRi ; Anki::Embedded::SerializedBuffer::SerializeRawArraySlice<Anki::Embedded::Point<short>>(const char*, const Anki::Embedded::ConstArraySlice<T1>&, void**, int&)
000112  b950              CBNZ     r0,|L39.298|
;;;459              return RESULT_FAIL;
;;;460    
;;;461            if(SerializedBuffer::SerializeRawFixedLengthList<Point<s16> >("templateEdges.yIncreasing", this->templateEdges.yIncreasing, &segment, totalDataLength) != RESULT_OK)
000114  a03d              ADR      r0,|L39.524|
000116  f5047188          ADD      r1,r4,#0x110
00011a  aa01              ADD      r2,sp,#4
00011c  466b              MOV      r3,sp
00011e  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRi ; Anki::Embedded::SerializedBuffer::SerializeRawArraySlice<Anki::Embedded::Point<short>>(const char*, const Anki::Embedded::ConstArraySlice<T1>&, void**, int&)
000122  2800              CMP      r0,#0
;;;462              return RESULT_FAIL;
;;;463    
;;;464            return RESULT_OK;
;;;465          }
000124  bf04              ITT      EQ
000126  b003              ADDEQ    sp,sp,#0xc
000128  bdf0              POPEQ    {r4-r7,pc}
                  |L39.298|
00012a  2001              MOVS     r0,#1                 ;462
00012c  b003              ADD      sp,sp,#0xc
00012e  bdf0              POP      {r4-r7,pc}
;;;466    
                          ENDP

                  |L39.304|
000130  42696e61          DCB      "BinaryTracker",0
000134  72795472
000138  61636b65
00013c  7200    
00013e  00                DCB      0
00013f  00                DCB      0
                  |L39.320|
000140  74656d70          DCB      "templateEdges.isValid",0
000144  6c617465
000148  45646765
00014c  732e6973
000150  56616c69
000154  6400    
000156  00                DCB      0
000157  00                DCB      0
                  |L39.344|
000158  42617369          DCB      "Basic Type Buffer",0
00015c  63205479
000160  70652042
000164  75666665
000168  7200    
00016a  00                DCB      0
00016b  00                DCB      0
                  |L39.364|
                          DCD      0x00010003
                  |L39.368|
000170  7472616e          DCB      "transformation",0
000174  73666f72
000178  6d617469
00017c  6f6e00  
00017f  00                DCB      0
                  |L39.384|
000180  74656d70          DCB      "templateEdges.imageHeight",0
000184  6c617465
000188  45646765
00018c  732e696d
000190  61676548
000194  65696768
000198  7400    
00019a  00                DCB      0
00019b  00                DCB      0
                  |L39.412|
00019c  74656d70          DCB      "templateEdges.imageWidth",0
0001a0  6c617465
0001a4  45646765
0001a8  732e696d
0001ac  61676557
0001b0  69647468
0001b4  00      
0001b5  00                DCB      0
0001b6  00                DCB      0
0001b7  00                DCB      0
                  |L39.440|
0001b8  74656d70          DCB      "templateEdges.xDecreasing",0
0001bc  6c617465
0001c0  45646765
0001c4  732e7844
0001c8  65637265
0001cc  6173696e
0001d0  6700    
0001d2  00                DCB      0
0001d3  00                DCB      0
                  |L39.468|
0001d4  74656d70          DCB      "templateEdges.xIncreasing",0
0001d8  6c617465
0001dc  45646765
0001e0  732e7849
0001e4  6e637265
0001e8  6173696e
0001ec  6700    
0001ee  00                DCB      0
0001ef  00                DCB      0
                  |L39.496|
0001f0  74656d70          DCB      "templateEdges.yDecreasing",0
0001f4  6c617465
0001f8  45646765
0001fc  732e7944
000200  65637265
000204  6173696e
000208  6700    
00020a  00                DCB      0
00020b  00                DCB      0
                  |L39.524|
00020c  74656d70          DCB      "templateEdges.yIncreasing",0
000210  6c617465
000214  45646765
000218  732e7949
00021c  6e637265
000220  6173696e
000224  6700    
000226  00                DCB      0
000227  00                DCB      0

                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC1Ev||
                          DCD      0x00000001

                          AREA ||area_number.41||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfRKNS2_23EdgeDetectionParametersERNS0_11MemoryStackESF_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfRKNS2_23EdgeDetectionParametersERNS0_11MemoryStackESF_||
                          DCD      0x00000001

                          AREA ||area_number.42||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC1ENS_6Vision10MarkerTypeERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfRKNS2_23EdgeDetectionParametersERNS0_11MemoryStackESH_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTrackerC1ENS_6Vision10MarkerTypeERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfRKNS2_23EdgeDetectionParametersERNS0_11MemoryStackESH_||
                          DCD      0x00000001

                          AREA ||area_number.43||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker18get_transformationEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker18get_transformationEv||
                          DCD      0x00000001

                          AREA ||area_number.44||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker23RoundS32_minusPointFiveEf||
                          DCD      0x00000001

                          AREA ||area_number.45||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindVerticalCorrespondences_VerifyEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindVerticalCorrespondences_VerifyEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERi||
                          DCD      0x00000001

                          AREA ||area_number.46||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker36FindHorizontalCorrespondences_VerifyEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker36FindHorizontalCorrespondences_VerifyEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERi||
                          DCD      0x00000001

                          AREA ||area_number.47||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker11VerifyTrackERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker11VerifyTrackERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiRi||
                          DCD      0x00000001

                          AREA ||area_number.48||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker42ApplyVerticalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.48||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker42ApplyVerticalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_||
                          DCD      0x00000001

                          AREA ||area_number.49||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker32FindVerticalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.49||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker32FindVerticalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE||
                          DCD      0x00000001

                          AREA ||area_number.50||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker44ApplyHorizontalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.50||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker44ApplyHorizontalCorrespondenceList_ProjectiveERKNS0_15FixedLengthListINS2_19IndexCorrespondenceEEERNS0_5ArrayIfEESA_||
                          DCD      0x00000001

                          AREA ||area_number.51||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindHorizontalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker34FindHorizontalCorrespondences_ListEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNS7_INS2_19IndexCorrespondenceEEE||
                          DCD      0x00000001

                          AREA ||area_number.52||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker38IterativelyRefineTrack_Projective_ListERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiiNS0_11MemoryStackES9_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.52||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker38IterativelyRefineTrack_Projective_ListERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiiNS0_11MemoryStackES9_||
                          DCD      0x00000001

                          AREA ||area_number.53||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker38FindVerticalCorrespondences_ProjectiveEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNSD_IfEESI_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker38FindVerticalCorrespondences_ProjectiveEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNSD_IfEESI_||
                          DCD      0x00000001

                          AREA ||area_number.54||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker40FindHorizontalCorrespondences_ProjectiveEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNSD_IfEESI_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.54||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker40FindHorizontalCorrespondences_ProjectiveEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERNSD_IfEESI_||
                          DCD      0x00000001

                          AREA ||area_number.55||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker33IterativelyRefineTrack_ProjectiveERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.55||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker33IterativelyRefineTrack_ProjectiveERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.56||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker39FindVerticalCorrespondences_TranslationEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERiSH_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.56||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker39FindVerticalCorrespondences_TranslationEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERiSH_||
                          DCD      0x00000001

                          AREA ||area_number.57||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker41FindHorizontalCorrespondences_TranslationEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERiSH_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker41FindHorizontalCorrespondences_TranslationEiRKNS0_15Transformations24PlanarTransformation_f32ERKNS0_15FixedLengthListINS0_5PointIsEEEESC_iiRKNS0_5ArrayIiEERiSH_||
                          DCD      0x00000001

                          AREA ||area_number.58||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker34IterativelyRefineTrack_TranslationERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker34IterativelyRefineTrack_TranslationERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.59||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker40IterativelyRefineTrack_Projective_RansacERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiiiiiRiNS0_11MemoryStackESA_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.59||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker40IterativelyRefineTrack_Projective_RansacERKNS0_9EdgeListsERKNS2_14AllIndexLimitsEiiiiiRiNS0_11MemoryStackESA_||
                          DCD      0x00000001

                          AREA ||area_number.60||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker28ComputeIndexLimitsHorizontalERKNS0_15FixedLengthListINS0_5PointIsEEEERNS0_5ArrayIiEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker28ComputeIndexLimitsHorizontalERKNS0_15FixedLengthListINS0_5PointIsEEEERNS0_5ArrayIiEE||
                          DCD      0x00000001

                          AREA ||area_number.61||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker26ComputeIndexLimitsVerticalERKNS0_15FixedLengthListINS0_5PointIsEEEERNS0_5ArrayIiEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.61||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker26ComputeIndexLimitsVerticalERKNS0_15FixedLengthListINS0_5PointIsEEEERNS0_5ArrayIiEE||
                          DCD      0x00000001

                          AREA ||area_number.62||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker21ComputeAllIndexLimitsERKNS0_9EdgeListsERNS2_14AllIndexLimitsERNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.62||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker21ComputeAllIndexLimitsERKNS0_9EdgeListsERNS2_14AllIndexLimitsERNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.63||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker19UpdateTrack_GenericENS2_13UpdateVersionERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiiiiRiSB_SB_SB_NS0_11MemoryStackESC_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.63||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker19UpdateTrack_GenericENS2_13UpdateVersionERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiiiiRiSB_SB_SB_NS0_11MemoryStackESC_||
                          DCD      0x00000001

                          AREA ||area_number.64||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker18UpdateTrack_NormalERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiRiSA_SA_SA_NS0_11MemoryStackESB_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.64||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker18UpdateTrack_NormalERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiRiSA_SA_SA_NS0_11MemoryStackESB_||
                          DCD      0x00000001

                          AREA ||area_number.65||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker16UpdateTrack_ListERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiRiSA_SA_SA_NS0_11MemoryStackESB_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.65||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker16UpdateTrack_ListERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiiihiRiSA_SA_SA_NS0_11MemoryStackESB_||
                          DCD      0x00000001

                          AREA ||area_number.66||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker18UpdateTrack_RansacERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiihiiiiRiSA_SA_SA_NS0_11MemoryStackESB_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.66||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker18UpdateTrack_RansacERKNS0_5ArrayIhEERKNS2_23EdgeDetectionParametersEiihiiiiRiSA_SA_SA_NS0_11MemoryStackESB_||
                          DCD      0x00000001

                          AREA ||area_number.67||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker7IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.67||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker7IsValidEv||
                          DCD      0x00000001

                          AREA ||area_number.68||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker12ShowTemplateEPKcbbf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.68||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker12ShowTemplateEPKcbbf||
                          DCD      0x00000001

                          AREA ||area_number.69||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker20UpdateTransformationERKNS0_5ArrayIfEEfNS0_11MemoryStackENS0_15Transformations13TransformTypeE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.69||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker20UpdateTransformationERKNS0_5ArrayIfEEfNS0_11MemoryStackENS0_15Transformations13TransformTypeE||
                          DCD      0x00000001

                          AREA ||area_number.70||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker21get_serializationSizeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.70||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker21get_serializationSizeEv||
                          DCD      0x00000001

                          AREA ||area_number.71||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker9SerializeEPKcRNS0_16SerializedBufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.71||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker9SerializeEPKcRNS0_16SerializedBufferE||
                          DCD      0x00000001

                          AREA ||area_number.72||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker11DeserializeEPcPPvRiRNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.72||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker11DeserializeEPcPPvRiRNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.73||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker21get_numTemplatePixelsEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.73||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker21get_numTemplatePixelsEv||
                          DCD      0x00000001

                          AREA ||area_number.74||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker18set_transformationERKNS0_15Transformations24PlanarTransformation_f32E||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.74||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker18set_transformationERKNS0_15Transformations24PlanarTransformation_f32E||
                          DCD      0x00000001

                          AREA ||area_number.75||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker29get_lastUsedGrayvalueThreholdEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.75||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker29get_lastUsedGrayvalueThreholdEv||
                          DCD      0x00000001

                          AREA ||area_number.76||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker26get_lastGrayvalueThresholdEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.76||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker13BinaryTracker26get_lastGrayvalueThresholdEv||
                          DCD      0x00000001

                          AREA ||area_number.77||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker23EdgeDetectionParametersC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.77||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker23EdgeDetectionParametersC1Ev||
                          DCD      0x00000001

                          AREA ||area_number.78||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker23EdgeDetectionParametersC1ENS2_17EdgeDetectionTypeEiifffiiiii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.78||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker13BinaryTracker23EdgeDetectionParametersC1ENS2_17EdgeDetectionTypeEiifffiiiii||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  __PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  54656d70          DCB      0x54,0x65,0x6d,0x70
000014  6c617465          DCB      0x6c,0x61,0x74,0x65
000018  54726163          DCB      0x54,0x72,0x61,0x63
00001c  6b65723a          DCB      0x6b,0x65,0x72,0x3a
000020  3a42696e          DCB      0x3a,0x42,0x69,0x6e
000024  61727954          DCB      0x61,0x72,0x79,0x54
000028  7261636b          DCB      0x72,0x61,0x63,0x6b
00002c  65723a3a          DCB      0x65,0x72,0x3a,0x3a
000030  42696e61          DCB      0x42,0x69,0x6e,0x61
000034  72795472          DCB      0x72,0x79,0x54,0x72
000038  61636b65          DCB      0x61,0x63,0x6b,0x65
00003c  7228636f          DCB      0x72,0x28,0x63,0x6f
000040  6e737420          DCB      0x6e,0x73,0x74,0x20
000044  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000048  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00004c  62656464          DCB      0x62,0x65,0x64,0x64
000050  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000054  41727261          DCB      0x41,0x72,0x72,0x61
000058  793c756e          DCB      0x79,0x3c,0x75,0x6e
00005c  7369676e          DCB      0x73,0x69,0x67,0x6e
000060  65642063          DCB      0x65,0x64,0x20,0x63
000064  6861723e          DCB      0x68,0x61,0x72,0x3e
000068  20262c20          DCB      0x20,0x26,0x2c,0x20
00006c  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000070  7420416e          DCB      0x74,0x20,0x41,0x6e
000074  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000078  456d6265          DCB      0x45,0x6d,0x62,0x65
00007c  64646564          DCB      0x64,0x64,0x65,0x64
000080  3a3a5175          DCB      0x3a,0x3a,0x51,0x75
000084  61647269          DCB      0x61,0x64,0x72,0x69
000088  6c617465          DCB      0x6c,0x61,0x74,0x65
00008c  72616c3c          DCB      0x72,0x61,0x6c,0x3c
000090  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000094  743e2026          DCB      0x74,0x3e,0x20,0x26
000098  2c20666c          DCB      0x2c,0x20,0x66,0x6c
00009c  6f61742c          DCB      0x6f,0x61,0x74,0x2c
0000a0  20636f6e          DCB      0x20,0x63,0x6f,0x6e
0000a4  73742041          DCB      0x73,0x74,0x20,0x41
0000a8  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000ac  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000b0  65646465          DCB      0x65,0x64,0x64,0x65
0000b4  643a3a54          DCB      0x64,0x3a,0x3a,0x54
0000b8  656d706c          DCB      0x65,0x6d,0x70,0x6c
0000bc  61746554          DCB      0x61,0x74,0x65,0x54
0000c0  7261636b          DCB      0x72,0x61,0x63,0x6b
0000c4  65723a3a          DCB      0x65,0x72,0x3a,0x3a
0000c8  42696e61          DCB      0x42,0x69,0x6e,0x61
0000cc  72795472          DCB      0x72,0x79,0x54,0x72
0000d0  61636b65          DCB      0x61,0x63,0x6b,0x65
0000d4  723a3a45          DCB      0x72,0x3a,0x3a,0x45
0000d8  64676544          DCB      0x64,0x67,0x65,0x44
0000dc  65746563          DCB      0x65,0x74,0x65,0x63
0000e0  74696f6e          DCB      0x74,0x69,0x6f,0x6e
0000e4  50617261          DCB      0x50,0x61,0x72,0x61
0000e8  6d657465          DCB      0x6d,0x65,0x74,0x65
0000ec  72732026          DCB      0x72,0x73,0x20,0x26
0000f0  2c20416e          DCB      0x2c,0x20,0x41,0x6e
0000f4  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0000f8  456d6265          DCB      0x45,0x6d,0x62,0x65
0000fc  64646564          DCB      0x64,0x64,0x65,0x64
000100  3a3a4d65          DCB      0x3a,0x3a,0x4d,0x65
000104  6d6f7279          DCB      0x6d,0x6f,0x72,0x79
000108  53746163          DCB      0x53,0x74,0x61,0x63
00010c  6b20262c          DCB      0x6b,0x20,0x26,0x2c
000110  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000114  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000118  6d626564          DCB      0x6d,0x62,0x65,0x64
00011c  6465643a          DCB      0x64,0x65,0x64,0x3a
000120  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
000124  6f727953          DCB      0x6f,0x72,0x79,0x53
000128  7461636b          DCB      0x74,0x61,0x63,0x6b
00012c  20262900          DCB      0x20,0x26,0x29,0x00
                  |symbol_number.269|
000130  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000134  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000138  62656464          DCB      0x62,0x65,0x64,0x64
00013c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000140  54656d70          DCB      0x54,0x65,0x6d,0x70
000144  6c617465          DCB      0x6c,0x61,0x74,0x65
000148  54726163          DCB      0x54,0x72,0x61,0x63
00014c  6b65723a          DCB      0x6b,0x65,0x72,0x3a
000150  3a42696e          DCB      0x3a,0x42,0x69,0x6e
000154  61727954          DCB      0x61,0x72,0x79,0x54
000158  7261636b          DCB      0x72,0x61,0x63,0x6b
00015c  65723a3a          DCB      0x65,0x72,0x3a,0x3a
000160  42696e61          DCB      0x42,0x69,0x6e,0x61
000164  72795472          DCB      0x72,0x79,0x54,0x72
000168  61636b65          DCB      0x61,0x63,0x6b,0x65
00016c  7228416e          DCB      0x72,0x28,0x41,0x6e
000170  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000174  56697369          DCB      0x56,0x69,0x73,0x69
000178  6f6e3a3a          DCB      0x6f,0x6e,0x3a,0x3a
00017c  4d61726b          DCB      0x4d,0x61,0x72,0x6b
000180  65725479          DCB      0x65,0x72,0x54,0x79
000184  70652c20          DCB      0x70,0x65,0x2c,0x20
000188  636f6e73          DCB      0x63,0x6f,0x6e,0x73
00018c  7420416e          DCB      0x74,0x20,0x41,0x6e
000190  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000194  456d6265          DCB      0x45,0x6d,0x62,0x65
000198  64646564          DCB      0x64,0x64,0x65,0x64
00019c  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
0001a0  7261793c          DCB      0x72,0x61,0x79,0x3c
0001a4  756e7369          DCB      0x75,0x6e,0x73,0x69
0001a8  676e6564          DCB      0x67,0x6e,0x65,0x64
0001ac  20636861          DCB      0x20,0x63,0x68,0x61
0001b0  723e2026          DCB      0x72,0x3e,0x20,0x26
0001b4  2c20636f          DCB      0x2c,0x20,0x63,0x6f
0001b8  6e737420          DCB      0x6e,0x73,0x74,0x20
0001bc  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0001c0  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0001c4  62656464          DCB      0x62,0x65,0x64,0x64
0001c8  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0001cc  51756164          DCB      0x51,0x75,0x61,0x64
0001d0  72696c61          DCB      0x72,0x69,0x6c,0x61
0001d4  74657261          DCB      0x74,0x65,0x72,0x61
0001d8  6c3c666c          DCB      0x6c,0x3c,0x66,0x6c
0001dc  6f61743e          DCB      0x6f,0x61,0x74,0x3e
0001e0  20262c20          DCB      0x20,0x26,0x2c,0x20
0001e4  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0001e8  742c2063          DCB      0x74,0x2c,0x20,0x63
0001ec  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0001f0  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0001f4  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0001f8  6d626564          DCB      0x6d,0x62,0x65,0x64
0001fc  6465643a          DCB      0x64,0x65,0x64,0x3a
000200  3a54656d          DCB      0x3a,0x54,0x65,0x6d
000204  706c6174          DCB      0x70,0x6c,0x61,0x74
000208  65547261          DCB      0x65,0x54,0x72,0x61
00020c  636b6572          DCB      0x63,0x6b,0x65,0x72
000210  3a3a4269          DCB      0x3a,0x3a,0x42,0x69
000214  6e617279          DCB      0x6e,0x61,0x72,0x79
000218  54726163          DCB      0x54,0x72,0x61,0x63
00021c  6b65723a          DCB      0x6b,0x65,0x72,0x3a
000220  3a456467          DCB      0x3a,0x45,0x64,0x67
000224  65446574          DCB      0x65,0x44,0x65,0x74
000228  65637469          DCB      0x65,0x63,0x74,0x69
00022c  6f6e5061          DCB      0x6f,0x6e,0x50,0x61
000230  72616d65          DCB      0x72,0x61,0x6d,0x65
000234  74657273          DCB      0x74,0x65,0x72,0x73
000238  20262c20          DCB      0x20,0x26,0x2c,0x20
00023c  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000240  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000244  62656464          DCB      0x62,0x65,0x64,0x64
000248  65643a3a          DCB      0x65,0x64,0x3a,0x3a
00024c  4d656d6f          DCB      0x4d,0x65,0x6d,0x6f
000250  72795374          DCB      0x72,0x79,0x53,0x74
000254  61636b20          DCB      0x61,0x63,0x6b,0x20
000258  262c2041          DCB      0x26,0x2c,0x20,0x41
00025c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000260  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000264  65646465          DCB      0x65,0x64,0x64,0x65
000268  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00026c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000270  79537461          DCB      0x79,0x53,0x74,0x61
000274  636b2026          DCB      0x63,0x6b,0x20,0x26
000278  2900              DCB      0x29,0x00
                  |symbol_number.270|
00027a  416e              DCB      0x41,0x6e
00027c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000280  52657375          DCB      0x52,0x65,0x73,0x75
000284  6c742041          DCB      0x6c,0x74,0x20,0x41
000288  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00028c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000290  65646465          DCB      0x65,0x64,0x64,0x65
000294  643a3a54          DCB      0x64,0x3a,0x3a,0x54
000298  656d706c          DCB      0x65,0x6d,0x70,0x6c
00029c  61746554          DCB      0x61,0x74,0x65,0x54
0002a0  7261636b          DCB      0x72,0x61,0x63,0x6b
0002a4  65723a3a          DCB      0x65,0x72,0x3a,0x3a
0002a8  42696e61          DCB      0x42,0x69,0x6e,0x61
0002ac  72795472          DCB      0x72,0x79,0x54,0x72
0002b0  61636b65          DCB      0x61,0x63,0x6b,0x65
0002b4  723a3a43          DCB      0x72,0x3a,0x3a,0x43
0002b8  6f6d7075          DCB      0x6f,0x6d,0x70,0x75
0002bc  7465416c          DCB      0x74,0x65,0x41,0x6c
0002c0  6c496e64          DCB      0x6c,0x49,0x6e,0x64
0002c4  65784c69          DCB      0x65,0x78,0x4c,0x69
0002c8  6d697473          DCB      0x6d,0x69,0x74,0x73
0002cc  28636f6e          DCB      0x28,0x63,0x6f,0x6e
0002d0  73742041          DCB      0x73,0x74,0x20,0x41
0002d4  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0002d8  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0002dc  65646465          DCB      0x65,0x64,0x64,0x65
0002e0  643a3a45          DCB      0x64,0x3a,0x3a,0x45
0002e4  6467654c          DCB      0x64,0x67,0x65,0x4c
0002e8  69737473          DCB      0x69,0x73,0x74,0x73
0002ec  20262c20          DCB      0x20,0x26,0x2c,0x20
0002f0  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0002f4  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0002f8  62656464          DCB      0x62,0x65,0x64,0x64
0002fc  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000300  54656d70          DCB      0x54,0x65,0x6d,0x70
000304  6c617465          DCB      0x6c,0x61,0x74,0x65
000308  54726163          DCB      0x54,0x72,0x61,0x63
00030c  6b65723a          DCB      0x6b,0x65,0x72,0x3a
000310  3a42696e          DCB      0x3a,0x42,0x69,0x6e
000314  61727954          DCB      0x61,0x72,0x79,0x54
000318  7261636b          DCB      0x72,0x61,0x63,0x6b
00031c  65723a3a          DCB      0x65,0x72,0x3a,0x3a
000320  416c6c49          DCB      0x41,0x6c,0x6c,0x49
000324  6e646578          DCB      0x6e,0x64,0x65,0x78
000328  4c696d69          DCB      0x4c,0x69,0x6d,0x69
00032c  74732026          DCB      0x74,0x73,0x20,0x26
000330  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000334  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000338  456d6265          DCB      0x45,0x6d,0x62,0x65
00033c  64646564          DCB      0x64,0x64,0x65,0x64
000340  3a3a4d65          DCB      0x3a,0x3a,0x4d,0x65
000344  6d6f7279          DCB      0x6d,0x6f,0x72,0x79
000348  53746163          DCB      0x53,0x74,0x61,0x63
00034c  6b202629          DCB      0x6b,0x20,0x26,0x29
000350  00                DCB      0x00
                  |symbol_number.271|
000351  416e6b            DCB      0x41,0x6e,0x6b
000354  693a3a52          DCB      0x69,0x3a,0x3a,0x52
000358  6573756c          DCB      0x65,0x73,0x75,0x6c
00035c  7420416e          DCB      0x74,0x20,0x41,0x6e
000360  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000364  456d6265          DCB      0x45,0x6d,0x62,0x65
000368  64646564          DCB      0x64,0x64,0x65,0x64
00036c  3a3a5465          DCB      0x3a,0x3a,0x54,0x65
000370  6d706c61          DCB      0x6d,0x70,0x6c,0x61
000374  74655472          DCB      0x74,0x65,0x54,0x72
000378  61636b65          DCB      0x61,0x63,0x6b,0x65
00037c  723a3a42          DCB      0x72,0x3a,0x3a,0x42
000380  696e6172          DCB      0x69,0x6e,0x61,0x72
000384  79547261          DCB      0x79,0x54,0x72,0x61
000388  636b6572          DCB      0x63,0x6b,0x65,0x72
00038c  3a3a4974          DCB      0x3a,0x3a,0x49,0x74
000390  65726174          DCB      0x65,0x72,0x61,0x74
000394  6976656c          DCB      0x69,0x76,0x65,0x6c
000398  79526566          DCB      0x79,0x52,0x65,0x66
00039c  696e6554          DCB      0x69,0x6e,0x65,0x54
0003a0  7261636b          DCB      0x72,0x61,0x63,0x6b
0003a4  5f547261          DCB      0x5f,0x54,0x72,0x61
0003a8  6e736c61          DCB      0x6e,0x73,0x6c,0x61
0003ac  74696f6e          DCB      0x74,0x69,0x6f,0x6e
0003b0  28636f6e          DCB      0x28,0x63,0x6f,0x6e
0003b4  73742041          DCB      0x73,0x74,0x20,0x41
0003b8  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0003bc  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0003c0  65646465          DCB      0x65,0x64,0x64,0x65
0003c4  643a3a45          DCB      0x64,0x3a,0x3a,0x45
0003c8  6467654c          DCB      0x64,0x67,0x65,0x4c
0003cc  69737473          DCB      0x69,0x73,0x74,0x73
0003d0  20262c20          DCB      0x20,0x26,0x2c,0x20
0003d4  636f6e73          DCB      0x63,0x6f,0x6e,0x73
0003d8  7420416e          DCB      0x74,0x20,0x41,0x6e
0003dc  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0003e0  456d6265          DCB      0x45,0x6d,0x62,0x65
0003e4  64646564          DCB      0x64,0x64,0x65,0x64
0003e8  3a3a5465          DCB      0x3a,0x3a,0x54,0x65
0003ec  6d706c61          DCB      0x6d,0x70,0x6c,0x61
0003f0  74655472          DCB      0x74,0x65,0x54,0x72
0003f4  61636b65          DCB      0x61,0x63,0x6b,0x65
0003f8  723a3a42          DCB      0x72,0x3a,0x3a,0x42
0003fc  696e6172          DCB      0x69,0x6e,0x61,0x72
000400  79547261          DCB      0x79,0x54,0x72,0x61
000404  636b6572          DCB      0x63,0x6b,0x65,0x72
000408  3a3a416c          DCB      0x3a,0x3a,0x41,0x6c
00040c  6c496e64          DCB      0x6c,0x49,0x6e,0x64
000410  65784c69          DCB      0x65,0x78,0x4c,0x69
000414  6d697473          DCB      0x6d,0x69,0x74,0x73
000418  20262c20          DCB      0x20,0x26,0x2c,0x20
00041c  7369676e          DCB      0x73,0x69,0x67,0x6e
000420  65642069          DCB      0x65,0x64,0x20,0x69
000424  6e742c20          DCB      0x6e,0x74,0x2c,0x20
000428  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00042c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000430  62656464          DCB      0x62,0x65,0x64,0x64
000434  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000438  4d656d6f          DCB      0x4d,0x65,0x6d,0x6f
00043c  72795374          DCB      0x72,0x79,0x53,0x74
000440  61636b29          DCB      0x61,0x63,0x6b,0x29
000444  00                DCB      0x00
                  |symbol_number.272|
000445  416e6b            DCB      0x41,0x6e,0x6b
000448  693a3a52          DCB      0x69,0x3a,0x3a,0x52
00044c  6573756c          DCB      0x65,0x73,0x75,0x6c
000450  7420416e          DCB      0x74,0x20,0x41,0x6e
000454  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000458  456d6265          DCB      0x45,0x6d,0x62,0x65
00045c  64646564          DCB      0x64,0x64,0x65,0x64
000460  3a3a5465          DCB      0x3a,0x3a,0x54,0x65
000464  6d706c61          DCB      0x6d,0x70,0x6c,0x61
000468  74655472          DCB      0x74,0x65,0x54,0x72
00046c  61636b65          DCB      0x61,0x63,0x6b,0x65
000470  723a3a42          DCB      0x72,0x3a,0x3a,0x42
000474  696e6172          DCB      0x69,0x6e,0x61,0x72
000478  79547261          DCB      0x79,0x54,0x72,0x61
00047c  636b6572          DCB      0x63,0x6b,0x65,0x72
000480  3a3a4974          DCB      0x3a,0x3a,0x49,0x74
000484  65726174          DCB      0x65,0x72,0x61,0x74
000488  6976656c          DCB      0x69,0x76,0x65,0x6c
00048c  79526566          DCB      0x79,0x52,0x65,0x66
000490  696e6554          DCB      0x69,0x6e,0x65,0x54
000494  7261636b          DCB      0x72,0x61,0x63,0x6b
000498  5f50726f          DCB      0x5f,0x50,0x72,0x6f
00049c  6a656374          DCB      0x6a,0x65,0x63,0x74
0004a0  69766528          DCB      0x69,0x76,0x65,0x28
0004a4  636f6e73          DCB      0x63,0x6f,0x6e,0x73
0004a8  7420416e          DCB      0x74,0x20,0x41,0x6e
0004ac  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0004b0  456d6265          DCB      0x45,0x6d,0x62,0x65
0004b4  64646564          DCB      0x64,0x64,0x65,0x64
0004b8  3a3a4564          DCB      0x3a,0x3a,0x45,0x64
0004bc  67654c69          DCB      0x67,0x65,0x4c,0x69
0004c0  73747320          DCB      0x73,0x74,0x73,0x20
0004c4  262c2063          DCB      0x26,0x2c,0x20,0x63
0004c8  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0004cc  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0004d0  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0004d4  6d626564          DCB      0x6d,0x62,0x65,0x64
0004d8  6465643a          DCB      0x64,0x65,0x64,0x3a
0004dc  3a54656d          DCB      0x3a,0x54,0x65,0x6d
0004e0  706c6174          DCB      0x70,0x6c,0x61,0x74
0004e4  65547261          DCB      0x65,0x54,0x72,0x61
0004e8  636b6572          DCB      0x63,0x6b,0x65,0x72
0004ec  3a3a4269          DCB      0x3a,0x3a,0x42,0x69
0004f0  6e617279          DCB      0x6e,0x61,0x72,0x79
0004f4  54726163          DCB      0x54,0x72,0x61,0x63
0004f8  6b65723a          DCB      0x6b,0x65,0x72,0x3a
0004fc  3a416c6c          DCB      0x3a,0x41,0x6c,0x6c
000500  496e6465          DCB      0x49,0x6e,0x64,0x65
000504  784c696d          DCB      0x78,0x4c,0x69,0x6d
000508  69747320          DCB      0x69,0x74,0x73,0x20
00050c  262c2073          DCB      0x26,0x2c,0x20,0x73
000510  69676e65          DCB      0x69,0x67,0x6e,0x65
000514  6420696e          DCB      0x64,0x20,0x69,0x6e
000518  742c2041          DCB      0x74,0x2c,0x20,0x41
00051c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000520  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000524  65646465          DCB      0x65,0x64,0x64,0x65
000528  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00052c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000530  79537461          DCB      0x79,0x53,0x74,0x61
000534  636b2900          DCB      0x63,0x6b,0x29,0x00
                  |symbol_number.273|
000538  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00053c  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000540  73756c74          DCB      0x73,0x75,0x6c,0x74
000544  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000548  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00054c  6d626564          DCB      0x6d,0x62,0x65,0x64
000550  6465643a          DCB      0x64,0x65,0x64,0x3a
000554  3a54656d          DCB      0x3a,0x54,0x65,0x6d
000558  706c6174          DCB      0x70,0x6c,0x61,0x74
00055c  65547261          DCB      0x65,0x54,0x72,0x61
000560  636b6572          DCB      0x63,0x6b,0x65,0x72
000564  3a3a4269          DCB      0x3a,0x3a,0x42,0x69
000568  6e617279          DCB      0x6e,0x61,0x72,0x79
00056c  54726163          DCB      0x54,0x72,0x61,0x63
000570  6b65723a          DCB      0x6b,0x65,0x72,0x3a
000574  3a497465          DCB      0x3a,0x49,0x74,0x65
000578  72617469          DCB      0x72,0x61,0x74,0x69
00057c  76656c79          DCB      0x76,0x65,0x6c,0x79
000580  52656669          DCB      0x52,0x65,0x66,0x69
000584  6e655472          DCB      0x6e,0x65,0x54,0x72
000588  61636b5f          DCB      0x61,0x63,0x6b,0x5f
00058c  50726f6a          DCB      0x50,0x72,0x6f,0x6a
000590  65637469          DCB      0x65,0x63,0x74,0x69
000594  76655f4c          DCB      0x76,0x65,0x5f,0x4c
000598  69737428          DCB      0x69,0x73,0x74,0x28
00059c  636f6e73          DCB      0x63,0x6f,0x6e,0x73
0005a0  7420416e          DCB      0x74,0x20,0x41,0x6e
0005a4  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0005a8  456d6265          DCB      0x45,0x6d,0x62,0x65
0005ac  64646564          DCB      0x64,0x64,0x65,0x64
0005b0  3a3a4564          DCB      0x3a,0x3a,0x45,0x64
0005b4  67654c69          DCB      0x67,0x65,0x4c,0x69
0005b8  73747320          DCB      0x73,0x74,0x73,0x20
0005bc  262c2063          DCB      0x26,0x2c,0x20,0x63
0005c0  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0005c4  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0005c8  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0005cc  6d626564          DCB      0x6d,0x62,0x65,0x64
0005d0  6465643a          DCB      0x64,0x65,0x64,0x3a
0005d4  3a54656d          DCB      0x3a,0x54,0x65,0x6d
0005d8  706c6174          DCB      0x70,0x6c,0x61,0x74
0005dc  65547261          DCB      0x65,0x54,0x72,0x61
0005e0  636b6572          DCB      0x63,0x6b,0x65,0x72
0005e4  3a3a4269          DCB      0x3a,0x3a,0x42,0x69
0005e8  6e617279          DCB      0x6e,0x61,0x72,0x79
0005ec  54726163          DCB      0x54,0x72,0x61,0x63
0005f0  6b65723a          DCB      0x6b,0x65,0x72,0x3a
0005f4  3a416c6c          DCB      0x3a,0x41,0x6c,0x6c
0005f8  496e6465          DCB      0x49,0x6e,0x64,0x65
0005fc  784c696d          DCB      0x78,0x4c,0x69,0x6d
000600  69747320          DCB      0x69,0x74,0x73,0x20
000604  262c2073          DCB      0x26,0x2c,0x20,0x73
000608  69676e65          DCB      0x69,0x67,0x6e,0x65
00060c  6420696e          DCB      0x64,0x20,0x69,0x6e
000610  742c2073          DCB      0x74,0x2c,0x20,0x73
000614  69676e65          DCB      0x69,0x67,0x6e,0x65
000618  6420696e          DCB      0x64,0x20,0x69,0x6e
00061c  742c2041          DCB      0x74,0x2c,0x20,0x41
000620  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000624  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000628  65646465          DCB      0x65,0x64,0x64,0x65
00062c  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
000630  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000634  79537461          DCB      0x79,0x53,0x74,0x61
000638  636b2c20          DCB      0x63,0x6b,0x2c,0x20
00063c  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000640  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000644  62656464          DCB      0x62,0x65,0x64,0x64
000648  65643a3a          DCB      0x65,0x64,0x3a,0x3a
00064c  4d656d6f          DCB      0x4d,0x65,0x6d,0x6f
000650  72795374          DCB      0x72,0x79,0x53,0x74
000654  61636b29          DCB      0x61,0x63,0x6b,0x29
000658  00                DCB      0x00
                  |symbol_number.274|
000659  416e6b            DCB      0x41,0x6e,0x6b
00065c  693a3a52          DCB      0x69,0x3a,0x3a,0x52
000660  6573756c          DCB      0x65,0x73,0x75,0x6c
000664  7420416e          DCB      0x74,0x20,0x41,0x6e
000668  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00066c  456d6265          DCB      0x45,0x6d,0x62,0x65
000670  64646564          DCB      0x64,0x64,0x65,0x64
000674  3a3a5465          DCB      0x3a,0x3a,0x54,0x65
000678  6d706c61          DCB      0x6d,0x70,0x6c,0x61
00067c  74655472          DCB      0x74,0x65,0x54,0x72
000680  61636b65          DCB      0x61,0x63,0x6b,0x65
000684  723a3a42          DCB      0x72,0x3a,0x3a,0x42
000688  696e6172          DCB      0x69,0x6e,0x61,0x72
00068c  79547261          DCB      0x79,0x54,0x72,0x61
000690  636b6572          DCB      0x63,0x6b,0x65,0x72
000694  3a3a4974          DCB      0x3a,0x3a,0x49,0x74
000698  65726174          DCB      0x65,0x72,0x61,0x74
00069c  6976656c          DCB      0x69,0x76,0x65,0x6c
0006a0  79526566          DCB      0x79,0x52,0x65,0x66
0006a4  696e6554          DCB      0x69,0x6e,0x65,0x54
0006a8  7261636b          DCB      0x72,0x61,0x63,0x6b
0006ac  5f50726f          DCB      0x5f,0x50,0x72,0x6f
0006b0  6a656374          DCB      0x6a,0x65,0x63,0x74
0006b4  6976655f          DCB      0x69,0x76,0x65,0x5f
0006b8  52616e73          DCB      0x52,0x61,0x6e,0x73
0006bc  61632863          DCB      0x61,0x63,0x28,0x63
0006c0  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0006c4  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0006c8  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0006cc  6d626564          DCB      0x6d,0x62,0x65,0x64
0006d0  6465643a          DCB      0x64,0x65,0x64,0x3a
0006d4  3a456467          DCB      0x3a,0x45,0x64,0x67
0006d8  654c6973          DCB      0x65,0x4c,0x69,0x73
0006dc  74732026          DCB      0x74,0x73,0x20,0x26
0006e0  2c20636f          DCB      0x2c,0x20,0x63,0x6f
0006e4  6e737420          DCB      0x6e,0x73,0x74,0x20
0006e8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0006ec  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0006f0  62656464          DCB      0x62,0x65,0x64,0x64
0006f4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0006f8  54656d70          DCB      0x54,0x65,0x6d,0x70
0006fc  6c617465          DCB      0x6c,0x61,0x74,0x65
000700  54726163          DCB      0x54,0x72,0x61,0x63
000704  6b65723a          DCB      0x6b,0x65,0x72,0x3a
000708  3a42696e          DCB      0x3a,0x42,0x69,0x6e
00070c  61727954          DCB      0x61,0x72,0x79,0x54
000710  7261636b          DCB      0x72,0x61,0x63,0x6b
000714  65723a3a          DCB      0x65,0x72,0x3a,0x3a
000718  416c6c49          DCB      0x41,0x6c,0x6c,0x49
00071c  6e646578          DCB      0x6e,0x64,0x65,0x78
000720  4c696d69          DCB      0x4c,0x69,0x6d,0x69
000724  74732026          DCB      0x74,0x73,0x20,0x26
000728  2c207369          DCB      0x2c,0x20,0x73,0x69
00072c  676e6564          DCB      0x67,0x6e,0x65,0x64
000730  20696e74          DCB      0x20,0x69,0x6e,0x74
000734  2c207369          DCB      0x2c,0x20,0x73,0x69
000738  676e6564          DCB      0x67,0x6e,0x65,0x64
00073c  20696e74          DCB      0x20,0x69,0x6e,0x74
000740  2c207369          DCB      0x2c,0x20,0x73,0x69
000744  676e6564          DCB      0x67,0x6e,0x65,0x64
000748  20696e74          DCB      0x20,0x69,0x6e,0x74
00074c  2c207369          DCB      0x2c,0x20,0x73,0x69
000750  676e6564          DCB      0x67,0x6e,0x65,0x64
000754  20696e74          DCB      0x20,0x69,0x6e,0x74
000758  2c207369          DCB      0x2c,0x20,0x73,0x69
00075c  676e6564          DCB      0x67,0x6e,0x65,0x64
000760  20696e74          DCB      0x20,0x69,0x6e,0x74
000764  2c207369          DCB      0x2c,0x20,0x73,0x69
000768  676e6564          DCB      0x67,0x6e,0x65,0x64
00076c  20696e74          DCB      0x20,0x69,0x6e,0x74
000770  20262c20          DCB      0x20,0x26,0x2c,0x20
000774  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000778  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00077c  62656464          DCB      0x62,0x65,0x64,0x64
000780  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000784  4d656d6f          DCB      0x4d,0x65,0x6d,0x6f
000788  72795374          DCB      0x72,0x79,0x53,0x74
00078c  61636b2c          DCB      0x61,0x63,0x6b,0x2c
000790  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000794  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000798  6d626564          DCB      0x6d,0x62,0x65,0x64
00079c  6465643a          DCB      0x64,0x65,0x64,0x3a
0007a0  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
0007a4  6f727953          DCB      0x6f,0x72,0x79,0x53
0007a8  7461636b          DCB      0x74,0x61,0x63,0x6b
0007ac  2900              DCB      0x29,0x00
                  |symbol_number.275|
0007ae  416e              DCB      0x41,0x6e
0007b0  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0007b4  52657375          DCB      0x52,0x65,0x73,0x75
0007b8  6c742041          DCB      0x6c,0x74,0x20,0x41
0007bc  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0007c0  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0007c4  65646465          DCB      0x65,0x64,0x64,0x65
0007c8  643a3a54          DCB      0x64,0x3a,0x3a,0x54
0007cc  656d706c          DCB      0x65,0x6d,0x70,0x6c
0007d0  61746554          DCB      0x61,0x74,0x65,0x54
0007d4  7261636b          DCB      0x72,0x61,0x63,0x6b
0007d8  65723a3a          DCB      0x65,0x72,0x3a,0x3a
0007dc  42696e61          DCB      0x42,0x69,0x6e,0x61
0007e0  72795472          DCB      0x72,0x79,0x54,0x72
0007e4  61636b65          DCB      0x61,0x63,0x6b,0x65
0007e8  723a3a56          DCB      0x72,0x3a,0x3a,0x56
0007ec  65726966          DCB      0x65,0x72,0x69,0x66
0007f0  79547261          DCB      0x79,0x54,0x72,0x61
0007f4  636b2863          DCB      0x63,0x6b,0x28,0x63
0007f8  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0007fc  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000800  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000804  6d626564          DCB      0x6d,0x62,0x65,0x64
000808  6465643a          DCB      0x64,0x65,0x64,0x3a
00080c  3a456467          DCB      0x3a,0x45,0x64,0x67
000810  654c6973          DCB      0x65,0x4c,0x69,0x73
000814  74732026          DCB      0x74,0x73,0x20,0x26
000818  2c20636f          DCB      0x2c,0x20,0x63,0x6f
00081c  6e737420          DCB      0x6e,0x73,0x74,0x20
000820  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000824  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000828  62656464          DCB      0x62,0x65,0x64,0x64
00082c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000830  54656d70          DCB      0x54,0x65,0x6d,0x70
000834  6c617465          DCB      0x6c,0x61,0x74,0x65
000838  54726163          DCB      0x54,0x72,0x61,0x63
00083c  6b65723a          DCB      0x6b,0x65,0x72,0x3a
000840  3a42696e          DCB      0x3a,0x42,0x69,0x6e
000844  61727954          DCB      0x61,0x72,0x79,0x54
000848  7261636b          DCB      0x72,0x61,0x63,0x6b
00084c  65723a3a          DCB      0x65,0x72,0x3a,0x3a
000850  416c6c49          DCB      0x41,0x6c,0x6c,0x49
000854  6e646578          DCB      0x6e,0x64,0x65,0x78
000858  4c696d69          DCB      0x4c,0x69,0x6d,0x69
00085c  74732026          DCB      0x74,0x73,0x20,0x26
000860  2c207369          DCB      0x2c,0x20,0x73,0x69
000864  676e6564          DCB      0x67,0x6e,0x65,0x64
000868  20696e74          DCB      0x20,0x69,0x6e,0x74
00086c  2c207369          DCB      0x2c,0x20,0x73,0x69
000870  676e6564          DCB      0x67,0x6e,0x65,0x64
000874  20696e74          DCB      0x20,0x69,0x6e,0x74
000878  20262900          DCB      0x20,0x26,0x29,0x00
                  |symbol_number.276|
00087c  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000880  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000884  73756c74          DCB      0x73,0x75,0x6c,0x74
000888  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00088c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000890  6d626564          DCB      0x6d,0x62,0x65,0x64
000894  6465643a          DCB      0x64,0x65,0x64,0x3a
000898  3a54656d          DCB      0x3a,0x54,0x65,0x6d
00089c  706c6174          DCB      0x70,0x6c,0x61,0x74
0008a0  65547261          DCB      0x65,0x54,0x72,0x61
0008a4  636b6572          DCB      0x63,0x6b,0x65,0x72
0008a8  3a3a4269          DCB      0x3a,0x3a,0x42,0x69
0008ac  6e617279          DCB      0x6e,0x61,0x72,0x79
0008b0  54726163          DCB      0x54,0x72,0x61,0x63
0008b4  6b65723a          DCB      0x6b,0x65,0x72,0x3a
0008b8  3a557064          DCB      0x3a,0x55,0x70,0x64
0008bc  61746554          DCB      0x61,0x74,0x65,0x54
0008c0  7261636b          DCB      0x72,0x61,0x63,0x6b
0008c4  5f47656e          DCB      0x5f,0x47,0x65,0x6e
0008c8  65726963          DCB      0x65,0x72,0x69,0x63
0008cc  28416e6b          DCB      0x28,0x41,0x6e,0x6b
0008d0  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0008d4  6d626564          DCB      0x6d,0x62,0x65,0x64
0008d8  6465643a          DCB      0x64,0x65,0x64,0x3a
0008dc  3a54656d          DCB      0x3a,0x54,0x65,0x6d
0008e0  706c6174          DCB      0x70,0x6c,0x61,0x74
0008e4  65547261          DCB      0x65,0x54,0x72,0x61
0008e8  636b6572          DCB      0x63,0x6b,0x65,0x72
0008ec  3a3a4269          DCB      0x3a,0x3a,0x42,0x69
0008f0  6e617279          DCB      0x6e,0x61,0x72,0x79
0008f4  54726163          DCB      0x54,0x72,0x61,0x63
0008f8  6b65723a          DCB      0x6b,0x65,0x72,0x3a
0008fc  3a557064          DCB      0x3a,0x55,0x70,0x64
000900  61746556          DCB      0x61,0x74,0x65,0x56
000904  65727369          DCB      0x65,0x72,0x73,0x69
000908  6f6e2c20          DCB      0x6f,0x6e,0x2c,0x20
00090c  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000910  7420416e          DCB      0x74,0x20,0x41,0x6e
000914  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000918  456d6265          DCB      0x45,0x6d,0x62,0x65
00091c  64646564          DCB      0x64,0x64,0x65,0x64
000920  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000924  7261793c          DCB      0x72,0x61,0x79,0x3c
000928  756e7369          DCB      0x75,0x6e,0x73,0x69
00092c  676e6564          DCB      0x67,0x6e,0x65,0x64
000930  20636861          DCB      0x20,0x63,0x68,0x61
000934  723e2026          DCB      0x72,0x3e,0x20,0x26
000938  2c20636f          DCB      0x2c,0x20,0x63,0x6f
00093c  6e737420          DCB      0x6e,0x73,0x74,0x20
000940  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000944  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000948  62656464          DCB      0x62,0x65,0x64,0x64
00094c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000950  54656d70          DCB      0x54,0x65,0x6d,0x70
000954  6c617465          DCB      0x6c,0x61,0x74,0x65
000958  54726163          DCB      0x54,0x72,0x61,0x63
00095c  6b65723a          DCB      0x6b,0x65,0x72,0x3a
000960  3a42696e          DCB      0x3a,0x42,0x69,0x6e
000964  61727954          DCB      0x61,0x72,0x79,0x54
000968  7261636b          DCB      0x72,0x61,0x63,0x6b
00096c  65723a3a          DCB      0x65,0x72,0x3a,0x3a
000970  45646765          DCB      0x45,0x64,0x67,0x65
000974  44657465          DCB      0x44,0x65,0x74,0x65
000978  6374696f          DCB      0x63,0x74,0x69,0x6f
00097c  6e506172          DCB      0x6e,0x50,0x61,0x72
000980  616d6574          DCB      0x61,0x6d,0x65,0x74
000984  65727320          DCB      0x65,0x72,0x73,0x20
000988  262c2073          DCB      0x26,0x2c,0x20,0x73
00098c  69676e65          DCB      0x69,0x67,0x6e,0x65
000990  6420696e          DCB      0x64,0x20,0x69,0x6e
000994  742c2073          DCB      0x74,0x2c,0x20,0x73
000998  69676e65          DCB      0x69,0x67,0x6e,0x65
00099c  6420696e          DCB      0x64,0x20,0x69,0x6e
0009a0  742c2073          DCB      0x74,0x2c,0x20,0x73
0009a4  69676e65          DCB      0x69,0x67,0x6e,0x65
0009a8  6420696e          DCB      0x64,0x20,0x69,0x6e
0009ac  742c2075          DCB      0x74,0x2c,0x20,0x75
0009b0  6e736967          DCB      0x6e,0x73,0x69,0x67
0009b4  6e656420          DCB      0x6e,0x65,0x64,0x20
0009b8  63686172          DCB      0x63,0x68,0x61,0x72
0009bc  2c207369          DCB      0x2c,0x20,0x73,0x69
0009c0  676e6564          DCB      0x67,0x6e,0x65,0x64
0009c4  20696e74          DCB      0x20,0x69,0x6e,0x74
0009c8  2c207369          DCB      0x2c,0x20,0x73,0x69
0009cc  676e6564          DCB      0x67,0x6e,0x65,0x64
0009d0  20696e74          DCB      0x20,0x69,0x6e,0x74
0009d4  2c207369          DCB      0x2c,0x20,0x73,0x69
0009d8  676e6564          DCB      0x67,0x6e,0x65,0x64
0009dc  20696e74          DCB      0x20,0x69,0x6e,0x74
0009e0  2c207369          DCB      0x2c,0x20,0x73,0x69
0009e4  676e6564          DCB      0x67,0x6e,0x65,0x64
0009e8  20696e74          DCB      0x20,0x69,0x6e,0x74
0009ec  2c207369          DCB      0x2c,0x20,0x73,0x69
0009f0  676e6564          DCB      0x67,0x6e,0x65,0x64
0009f4  20696e74          DCB      0x20,0x69,0x6e,0x74
0009f8  20262c20          DCB      0x20,0x26,0x2c,0x20
0009fc  7369676e          DCB      0x73,0x69,0x67,0x6e
000a00  65642069          DCB      0x65,0x64,0x20,0x69
000a04  6e742026          DCB      0x6e,0x74,0x20,0x26
000a08  2c207369          DCB      0x2c,0x20,0x73,0x69
000a0c  676e6564          DCB      0x67,0x6e,0x65,0x64
000a10  20696e74          DCB      0x20,0x69,0x6e,0x74
000a14  20262c20          DCB      0x20,0x26,0x2c,0x20
000a18  7369676e          DCB      0x73,0x69,0x67,0x6e
000a1c  65642069          DCB      0x65,0x64,0x20,0x69
000a20  6e742026          DCB      0x6e,0x74,0x20,0x26
000a24  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000a28  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000a2c  456d6265          DCB      0x45,0x6d,0x62,0x65
000a30  64646564          DCB      0x64,0x64,0x65,0x64
000a34  3a3a4d65          DCB      0x3a,0x3a,0x4d,0x65
000a38  6d6f7279          DCB      0x6d,0x6f,0x72,0x79
000a3c  53746163          DCB      0x53,0x74,0x61,0x63
000a40  6b2c2041          DCB      0x6b,0x2c,0x20,0x41
000a44  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000a48  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000a4c  65646465          DCB      0x65,0x64,0x64,0x65
000a50  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
000a54  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000a58  79537461          DCB      0x79,0x53,0x74,0x61
000a5c  636b2900          DCB      0x63,0x6b,0x29,0x00
000a60  41727261          DCB      0x41,0x72,0x72,0x61
000a64  793c5479          DCB      0x79,0x3c,0x54,0x79
000a68  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000a6c  3a436f6d          DCB      0x3a,0x43,0x6f,0x6d
000a70  70757465          DCB      0x70,0x75,0x74,0x65
000a74  52657175          DCB      0x52,0x65,0x71,0x75
000a78  69726564          DCB      0x69,0x72,0x65,0x64
000a7c  53747269          DCB      0x53,0x74,0x72,0x69
000a80  64650000          DCB      0x64,0x65,0x00,0x00
000a84  496e7661          DCB      0x49,0x6e,0x76,0x61
000a88  6c696420          DCB      0x6c,0x69,0x64,0x20
000a8c  73697a65          DCB      0x73,0x69,0x7a,0x65
000a90  00000000          DCB      0x00,0x00,0x00,0x00
000a94  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000a98  6f726574          DCB      0x6f,0x72,0x65,0x74
000a9c  6563685c          DCB      0x65,0x63,0x68,0x5c
000aa0  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000aa4  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000aa8  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000aac  64655c61          DCB      0x64,0x65,0x5c,0x61
000ab0  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000ab4  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000ab8  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000abc  6f626f74          DCB      0x6f,0x62,0x6f,0x74
000ac0  2f617272          DCB      0x2f,0x61,0x72,0x72
000ac4  61793264          DCB      0x61,0x79,0x32,0x64
000ac8  2e680000          DCB      0x2e,0x68,0x00,0x00
000acc  41727261          DCB      0x41,0x72,0x72,0x61
000ad0  793c5479          DCB      0x79,0x3c,0x54,0x79
000ad4  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000ad8  3a676574          DCB      0x3a,0x67,0x65,0x74
000adc  5f73697a          DCB      0x5f,0x73,0x69,0x7a
000ae0  65000000          DCB      0x65,0x00,0x00,0x00
000ae4  4e656761          DCB      0x4e,0x65,0x67,0x61
000ae8  74697665          DCB      0x74,0x69,0x76,0x65
000aec  2064696d          DCB      0x20,0x64,0x69,0x6d
000af0  656e7369          DCB      0x65,0x6e,0x73,0x69
000af4  6f6e0000          DCB      0x6f,0x6e,0x00,0x00
000af8  42617369          DCB      0x42,0x61,0x73,0x69
000afc  63205479          DCB      0x63,0x20,0x54,0x79
000b00  70652042          DCB      0x70,0x65,0x20,0x42
000b04  75666665          DCB      0x75,0x66,0x66,0x65
000b08  72000000          DCB      0x72,0x00,0x00,0x00
000b0c  53657269          DCB      0x53,0x65,0x72,0x69
000b10  616c697a          DCB      0x61,0x6c,0x69,0x7a
000b14  65644275          DCB      0x65,0x64,0x42,0x75
000b18  66666572          DCB      0x66,0x66,0x65,0x72
000b1c  3a3a4465          DCB      0x3a,0x3a,0x44,0x65
000b20  73657269          DCB      0x73,0x65,0x72,0x69
000b24  616c697a          DCB      0x61,0x6c,0x69,0x7a
000b28  65526177          DCB      0x65,0x52,0x61,0x77
000b2c  42617369          DCB      0x42,0x61,0x73,0x69
000b30  63547970          DCB      0x63,0x54,0x79,0x70
000b34  65000000          DCB      0x65,0x00,0x00,0x00
000b38  556e7265          DCB      0x55,0x6e,0x72,0x65
000b3c  61736f6e          DCB      0x61,0x73,0x6f,0x6e
000b40  61626c65          DCB      0x61,0x62,0x6c,0x65
000b44  20646573          DCB      0x20,0x64,0x65,0x73
000b48  65726961          DCB      0x65,0x72,0x69,0x61
000b4c  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000b50  64207661          DCB      0x64,0x20,0x76,0x61
000b54  6c756573          DCB      0x6c,0x75,0x65,0x73
000b58  00000000          DCB      0x00,0x00,0x00,0x00
000b5c  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000b60  6f726574          DCB      0x6f,0x72,0x65,0x74
000b64  6563685c          DCB      0x65,0x63,0x68,0x5c
000b68  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000b6c  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000b70  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000b74  64655c61          DCB      0x64,0x65,0x5c,0x61
000b78  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000b7c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000b80  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000b84  6f626f74          DCB      0x6f,0x62,0x6f,0x74
000b88  2f736572          DCB      0x2f,0x73,0x65,0x72
000b8c  69616c69          DCB      0x69,0x61,0x6c,0x69
000b90  7a652e68          DCB      0x7a,0x65,0x2e,0x68
000b94  00000000          DCB      0x00,0x00,0x00,0x00
000b98  6f726967          DCB      0x6f,0x72,0x69,0x67
000b9c  696e616c          DCB      0x69,0x6e,0x61,0x6c
000ba0  506f696e          DCB      0x50,0x6f,0x69,0x6e
000ba4  74732061          DCB      0x74,0x73,0x20,0x61
000ba8  6e642074          DCB      0x6e,0x64,0x20,0x74
000bac  72616e73          DCB      0x72,0x61,0x6e,0x73
000bb0  666f726d          DCB      0x66,0x6f,0x72,0x6d
000bb4  6564506f          DCB      0x65,0x64,0x50,0x6f
000bb8  696e7473          DCB      0x69,0x6e,0x74,0x73
000bbc  206d7573          DCB      0x20,0x6d,0x75,0x73
000bc0  74206265          DCB      0x74,0x20,0x62,0x65
000bc4  20746865          DCB      0x20,0x74,0x68,0x65
000bc8  2073616d          DCB      0x20,0x73,0x61,0x6d
000bcc  65207369          DCB      0x65,0x20,0x73,0x69
000bd0  7a652c20          DCB      0x7a,0x65,0x2c,0x20
000bd4  616e6420          DCB      0x61,0x6e,0x64,0x20
000bd8  68617665          DCB      0x68,0x61,0x76,0x65
000bdc  20617420          DCB      0x20,0x61,0x74,0x20
000be0  6c656173          DCB      0x6c,0x65,0x61,0x73
000be4  7420666f          DCB      0x74,0x20,0x66,0x6f
000be8  75722070          DCB      0x75,0x72,0x20,0x70
000bec  6f696e74          DCB      0x6f,0x69,0x6e,0x74
000bf0  73206170          DCB      0x73,0x20,0x61,0x70
000bf4  69656365          DCB      0x69,0x65,0x63,0x65
000bf8  2e000000          DCB      0x2e,0x00,0x00,0x00
000bfc  42696e61          DCB      0x42,0x69,0x6e,0x61
000c00  72795472          DCB      0x72,0x79,0x54,0x72
000c04  61636b65          DCB      0x61,0x63,0x6b,0x65
000c08  72206e65          DCB      0x72,0x20,0x6e,0x65
000c0c  65647320          DCB      0x65,0x64,0x73,0x20
000c10  746f2062          DCB      0x74,0x6f,0x20,0x62
000c14  65207570          DCB      0x65,0x20,0x75,0x70
000c18  64617465          DCB      0x64,0x61,0x74,0x65
000c1c  64206e6f          DCB      0x64,0x20,0x6e,0x6f
000c20  77207468          DCB      0x77,0x20,0x74,0x68
000c24  61742042          DCB      0x61,0x74,0x20,0x42
000c28  61747465          DCB      0x61,0x74,0x74,0x65
000c2c  7279206d          DCB      0x72,0x79,0x20,0x6d
000c30  61726b65          DCB      0x61,0x72,0x6b,0x65
000c34  72206861          DCB      0x72,0x20,0x68,0x61
000c38  73206265          DCB      0x73,0x20,0x62,0x65
000c3c  656e2072          DCB      0x65,0x6e,0x20,0x72
000c40  656d6f76          DCB      0x65,0x6d,0x6f,0x76
000c44  65642e00          DCB      0x65,0x64,0x2e,0x00

                          AREA ||.ram1||, DATA, READONLY, ALIGN=4

                  battery
000000  7f7f7f7f          DCB      0x7f,0x7f,0x7f,0x7f
000004  7f7f7f7f          DCB      0x7f,0x7f,0x7f,0x7f
000008  7f7f7f7f          DCB      0x7f,0x7f,0x7f,0x7f
00000c  7f0ce519          DCB      0x7f,0x0c,0xe5,0x19
000010  e519e519          DCB      0xe5,0x19,0xe5,0x19
000014  e519e519          DCB      0xe5,0x19,0xe5,0x19
000018  e519e519          DCB      0xe5,0x19,0xe5,0x19
00001c  e519e519          DCB      0xe5,0x19,0xe5,0x19
000020  e519e519          DCB      0xe5,0x19,0xe5,0x19
000024  e519e519          DCB      0xe5,0x19,0xe5,0x19
000028  e519e519          DCB      0xe5,0x19,0xe5,0x19
00002c  e519e519          DCB      0xe5,0x19,0xe5,0x19
000030  e519e519          DCB      0xe5,0x19,0xe5,0x19
000034  e519e519          DCB      0xe5,0x19,0xe5,0x19
000038  e519e519          DCB      0xe5,0x19,0xe5,0x19
00003c  e519e519          DCB      0xe5,0x19,0xe5,0x19
000040  95049405          DCB      0x95,0x04,0x94,0x05
000044  94049519          DCB      0x94,0x04,0x95,0x19
000048  93089107          DCB      0x93,0x08,0x91,0x07
00004c  91089319          DCB      0x91,0x08,0x93,0x19
000050  920a8f09          DCB      0x92,0x0a,0x8f,0x09
000054  8f0a9219          DCB      0x8f,0x0a,0x92,0x19
000058  8c168217          DCB      0x8c,0x16,0x82,0x17
00005c  82168c19          DCB      0x82,0x16,0x8c,0x19
000060  8b188117          DCB      0x8b,0x18,0x81,0x17
000064  81188b19          DCB      0x81,0x18,0x8b,0x19
000068  8b188117          DCB      0x8b,0x18,0x81,0x17
00006c  81188b19          DCB      0x81,0x18,0x8b,0x19
000070  8b188117          DCB      0x8b,0x18,0x81,0x17
000074  81188b19          DCB      0x81,0x18,0x8b,0x19
000078  8b188117          DCB      0x8b,0x18,0x81,0x17
00007c  81188b19          DCB      0x81,0x18,0x8b,0x19
000080  8b188117          DCB      0x8b,0x18,0x81,0x17
000084  81188b19          DCB      0x81,0x18,0x8b,0x19
000088  8b188117          DCB      0x8b,0x18,0x81,0x17
00008c  81188b19          DCB      0x81,0x18,0x8b,0x19
000090  8b188117          DCB      0x8b,0x18,0x81,0x17
000094  81188b19          DCB      0x81,0x18,0x8b,0x19
000098  8b188117          DCB      0x8b,0x18,0x81,0x17
00009c  81188b19          DCB      0x81,0x18,0x8b,0x19
0000a0  8b188117          DCB      0x8b,0x18,0x81,0x17
0000a4  81188b19          DCB      0x81,0x18,0x8b,0x19
0000a8  8b188117          DCB      0x8b,0x18,0x81,0x17
0000ac  81188b19          DCB      0x81,0x18,0x8b,0x19
0000b0  8b188117          DCB      0x8b,0x18,0x81,0x17
0000b4  81188b19          DCB      0x81,0x18,0x8b,0x19
0000b8  8b0d8009          DCB      0x8b,0x0d,0x80,0x09
0000bc  810c8009          DCB      0x81,0x0c,0x80,0x09
0000c0  810d8009          DCB      0x81,0x0d,0x80,0x09
0000c4  8b198b0c          DCB      0x8b,0x19,0x8b,0x0c
0000c8  800a810c          DCB      0x80,0x0a,0x81,0x0c
0000cc  8009810d          DCB      0x80,0x09,0x81,0x0d
0000d0  80098b19          DCB      0x80,0x09,0x8b,0x19
0000d4  8b0b810a          DCB      0x8b,0x0b,0x81,0x0a
0000d8  810b8109          DCB      0x81,0x0b,0x81,0x09
0000dc  810c8109          DCB      0x81,0x0c,0x81,0x09
0000e0  8b198b0b          DCB      0x8b,0x19,0x8b,0x0b
0000e4  810a810a          DCB      0x81,0x0a,0x81,0x0a
0000e8  8209810b          DCB      0x82,0x09,0x81,0x0b
0000ec  82098b19          DCB      0x82,0x09,0x8b,0x19
0000f0  8b0a820a          DCB      0x8b,0x0a,0x82,0x0a
0000f4  8109820a          DCB      0x81,0x09,0x82,0x0a
0000f8  810a820a          DCB      0x81,0x0a,0x82,0x0a
0000fc  8b198b09          DCB      0x8b,0x19,0x8b,0x09
000100  830a8109          DCB      0x83,0x0a,0x81,0x09
000104  820a810a          DCB      0x82,0x0a,0x81,0x0a
000108  820a8b19          DCB      0x82,0x0a,0x8b,0x19
00010c  8b08840a          DCB      0x8b,0x08,0x84,0x0a
000110  8108830a          DCB      0x81,0x08,0x83,0x0a
000114  8109830a          DCB      0x81,0x09,0x83,0x0a
000118  8b198b08          DCB      0x8b,0x19,0x8b,0x08
00011c  830b8107          DCB      0x83,0x0b,0x81,0x07
000120  840a8108          DCB      0x84,0x0a,0x81,0x08
000124  840a8b19          DCB      0x84,0x0a,0x8b,0x19
000128  8b078a05          DCB      0x8b,0x07,0x8a,0x05
00012c  81078905          DCB      0x81,0x07,0x89,0x05
000130  81078a05          DCB      0x81,0x07,0x8a,0x05
000134  8b198b06          DCB      0x8b,0x19,0x8b,0x06
000138  8a068106          DCB      0x8a,0x06,0x81,0x06
00013c  8a058107          DCB      0x8a,0x05,0x81,0x07
000140  8a058b19          DCB      0x8a,0x05,0x8b,0x19
000144  8b068a06          DCB      0x8b,0x06,0x8a,0x06
000148  81058a06          DCB      0x81,0x05,0x8a,0x06
00014c  81068a06          DCB      0x81,0x06,0x8a,0x06
000150  8b198b05          DCB      0x8b,0x19,0x8b,0x05
000154  8a078105          DCB      0x8a,0x07,0x81,0x05
000158  89078106          DCB      0x89,0x07,0x81,0x06
00015c  89078b19          DCB      0x89,0x07,0x8b,0x19
000160  8b0b8308          DCB      0x8b,0x0b,0x83,0x08
000164  810a8407          DCB      0x81,0x0a,0x84,0x07
000168  810b8407          DCB      0x81,0x0b,0x84,0x07
00016c  8b198b0a          DCB      0x8b,0x19,0x8b,0x0a
000170  8309810a          DCB      0x83,0x09,0x81,0x0a
000174  8308810b          DCB      0x83,0x08,0x81,0x0b
000178  83088b19          DCB      0x83,0x08,0x8b,0x19
00017c  8b0a8309          DCB      0x8b,0x0a,0x83,0x09
000180  810a8209          DCB      0x81,0x0a,0x82,0x09
000184  810b8209          DCB      0x81,0x0b,0x82,0x09
000188  8b198b0a          DCB      0x8b,0x19,0x8b,0x0a
00018c  820a8109          DCB      0x82,0x0a,0x81,0x09
000190  820a810a          DCB      0x82,0x0a,0x81,0x0a
000194  820a8b19          DCB      0x82,0x0a,0x8b,0x19
000198  8b09820b          DCB      0x8b,0x09,0x82,0x0b
00019c  8109820a          DCB      0x81,0x09,0x82,0x0a
0001a0  810a820a          DCB      0x81,0x0a,0x82,0x0a
0001a4  8b198b09          DCB      0x8b,0x19,0x8b,0x09
0001a8  810c8109          DCB      0x81,0x0c,0x81,0x09
0001ac  810b810a          DCB      0x81,0x0b,0x81,0x0a
0001b0  810b8b19          DCB      0x81,0x0b,0x8b,0x19
0001b4  8b09810c          DCB      0x8b,0x09,0x81,0x0c
0001b8  8108810c          DCB      0x81,0x08,0x81,0x0c
0001bc  8109810c          DCB      0x81,0x09,0x81,0x0c
0001c0  8b198b09          DCB      0x8b,0x19,0x8b,0x09
0001c4  800d8108          DCB      0x80,0x0d,0x81,0x08
0001c8  800d8109          DCB      0x80,0x0d,0x81,0x09
0001cc  800d8b19          DCB      0x80,0x0d,0x8b,0x19
0001d0  8b08800e          DCB      0x8b,0x08,0x80,0x0e
0001d4  8108800d          DCB      0x81,0x08,0x80,0x0d
0001d8  8109800d          DCB      0x81,0x09,0x80,0x0d
0001dc  8b198b18          DCB      0x8b,0x19,0x8b,0x18
0001e0  8107800e          DCB      0x81,0x07,0x80,0x0e
0001e4  8108800e          DCB      0x81,0x08,0x80,0x0e
0001e8  8b198b18          DCB      0x8b,0x19,0x8b,0x18
0001ec  81178118          DCB      0x81,0x17,0x81,0x18
0001f0  8b198b18          DCB      0x8b,0x19,0x8b,0x18
0001f4  81178118          DCB      0x81,0x17,0x81,0x18
0001f8  8b198b18          DCB      0x8b,0x19,0x8b,0x18
0001fc  81178118          DCB      0x81,0x17,0x81,0x18
000200  8b198b18          DCB      0x8b,0x19,0x8b,0x18
000204  81178118          DCB      0x81,0x17,0x81,0x18
000208  8b198b18          DCB      0x8b,0x19,0x8b,0x18
00020c  81178118          DCB      0x81,0x17,0x81,0x18
000210  8b198b18          DCB      0x8b,0x19,0x8b,0x18
000214  81178118          DCB      0x81,0x17,0x81,0x18
000218  8b198b18          DCB      0x8b,0x19,0x8b,0x18
00021c  81178118          DCB      0x81,0x17,0x81,0x18
000220  8b198b18          DCB      0x8b,0x19,0x8b,0x18
000224  81178118          DCB      0x81,0x17,0x81,0x18
000228  8b198b18          DCB      0x8b,0x19,0x8b,0x18
00022c  81178118          DCB      0x81,0x17,0x81,0x18
000230  8b198b18          DCB      0x8b,0x19,0x8b,0x18
000234  81178118          DCB      0x81,0x17,0x81,0x18
000238  8b198b18          DCB      0x8b,0x19,0x8b,0x18
00023c  81178118          DCB      0x81,0x17,0x81,0x18
000240  8b198b18          DCB      0x8b,0x19,0x8b,0x18
000244  81178118          DCB      0x81,0x17,0x81,0x18
000248  8b198b18          DCB      0x8b,0x19,0x8b,0x18
00024c  81178118          DCB      0x81,0x17,0x81,0x18
000250  8b198b18          DCB      0x8b,0x19,0x8b,0x18
000254  81178118          DCB      0x81,0x17,0x81,0x18
000258  8b198b18          DCB      0x8b,0x19,0x8b,0x18
00025c  81178118          DCB      0x81,0x17,0x81,0x18
000260  8b19e519          DCB      0x8b,0x19,0xe5,0x19
000264  e519e519          DCB      0xe5,0x19,0xe5,0x19
000268  e519e519          DCB      0xe5,0x19,0xe5,0x19
00026c  e519e519          DCB      0xe5,0x19,0xe5,0x19
000270  e519e519          DCB      0xe5,0x19,0xe5,0x19
000274  e519e519          DCB      0xe5,0x19,0xe5,0x19
000278  e519e519          DCB      0xe5,0x19,0xe5,0x19
00027c  e519e519          DCB      0xe5,0x19,0xe5,0x19
000280  e519e519          DCB      0xe5,0x19,0xe5,0x19
000284  e519e519          DCB      0xe5,0x19,0xe5,0x19
000288  e519e519          DCB      0xe5,0x19,0xe5,0x19
00028c  e519e519          DCB      0xe5,0x19,0xe5,0x19
000290  e519e57f          DCB      0xe5,0x19,0xe5,0x7f
000294  7f7f7f7f          DCB      0x7f,0x7f,0x7f,0x7f
000298  7f7f7f7f          DCB      0x7f,0x7f,0x7f,0x7f
00029c  7f7f7f7f          DCB      0x7f,0x7f,0x7f,0x7f
0002a0  0c                DCB      0x0c

                          AREA ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Eii, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded14LinearSequenceIiEC2Eii                  ; Alternate entry point ; Anki::Embedded::LinearSequence<int>::LinearSequence__sub_object(int, int)
                  _ZN4Anki8Embedded14LinearSequenceIiEC1Eii PROC ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
;;;30     
;;;31         template<typename Type> LinearSequence<Type>::LinearSequence(const Type start, const Type end)
;;;32           : start(start), increment(1)
;;;33         {
;;;34           this->size = computeSize(this->start, this->increment, end);
;;;35         }
;;;36     
000000  b530              PUSH     {r4,r5,lr}
000002  4604              MOV      r4,r0
000004  2301              MOVS     r3,#1
000006  b083              SUB      sp,sp,#0xc
000008  e9c41301          STRD     r1,r3,[r4,#4]
00000c  4291              CMP      r1,r2
00000e  d017              BEQ      |L244.64|
000010  2500              MOVS     r5,#0
000012  429d              CMP      r5,r3
000014  da01              BGE      |L244.26|
000016  4291              CMP      r1,r2
000018  dd01              BLE      |L244.30|
                  |L244.26|
00001a  462b              MOV      r3,r5
00001c  e010              B        |L244.64|
                  |L244.30|
00001e  1a50              SUBS     r0,r2,r1
000020  1c40              ADDS     r0,r0,#1
000022  fb90f3f3          SDIV     r3,r0,r3
000026  2b00              CMP      r3,#0
000028  da0a              BGE      |L244.64|
00002a  2185              MOVS     r1,#0x85
00002c  4806              LDR      r0,|L244.72|
00002e  e9cd0100          STRD     r0,r1,[sp,#0]
000032  a306              ADR      r3,|L244.76|
000034  a214              ADR      r2,|L244.136|
000036  a11a              ADR      r1,|L244.160|
000038  2005              MOVS     r0,#5
00003a  f7fffffe          BL       _Anki_Log
00003e  462b              MOV      r3,r5
                  |L244.64|
000040  6023              STR      r3,[r4,#0]
000042  b003              ADD      sp,sp,#0xc
000044  4620              MOV      r0,r4
000046  bd30              POP      {r4,r5,pc}
                          ENDP

                  |L244.72|
                          DCD      _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
                  |L244.76|
00004c  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/sequen"
000050  6f726574
000054  6563685c
000058  636f6d6d
00005c  6f6e5c69
000060  6e636c75
000064  64655c61
000068  6e6b692f
00006c  636f6d6d
000070  6f6e2f72
000074  6f626f74
000078  2f736571
00007c  75656e  
00007f  6365732e          DCB      "ces.h",0
000083  6800    
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L244.136|
000088  73697a65          DCB      "size estimation failed",0
00008c  20657374
000090  696d6174
000094  696f6e20
000098  6661696c
00009c  656400  
00009f  00                DCB      0
                  |L244.160|
0000a0  4c696e65          DCB      "LinearSequence<Type>::computeSize",0
0000a4  61725365
0000a8  7175656e
0000ac  63653c54
0000b0  7970653e
0000b4  3a3a636f
0000b8  6d707574
0000bc  6553697a
0000c0  6500    
0000c2  00                DCB      0
0000c3  00                DCB      0

                          AREA ||area_number.245||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Eii, LINKORDER=||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.245||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIiEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<int>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L251.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L251.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L251.384|
000044  a25c              ADR      r2,|L251.440|
000046  a160              ADR      r1,|L251.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L251.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L251.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L251.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L251.384|
000080  a24d              ADR      r2,|L251.440|
000082  a157              ADR      r1,|L251.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L251.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L251.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L251.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L251.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L251.384|
0000c8  a251              ADR      r2,|L251.528|
0000ca  a156              ADR      r1,|L251.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L251.372|
                  |L251.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L251.384|
0000e0  a258              ADR      r2,|L251.580|
0000e2  a15f              ADR      r1,|L251.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L251.372|
                  |L251.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L251.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L251.384|
000110  a259              ADR      r2,|L251.632|
000112  a144              ADR      r1,|L251.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L251.372|
                  |L251.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L251.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L251.384|
00015a  a251              ADR      r2,|L251.672|
00015c  a140              ADR      r1,|L251.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L251.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L251.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L251.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L251.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L251.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L251.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L251.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L251.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L251.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L251.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L251.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L251.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L251.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L251.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.252||, COMGROUP=_ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.252||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<float>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L258.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L258.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L258.384|
000044  a25c              ADR      r2,|L258.440|
000046  a160              ADR      r1,|L258.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L258.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L258.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L258.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L258.384|
000080  a24d              ADR      r2,|L258.440|
000082  a157              ADR      r1,|L258.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L258.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L258.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L258.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L258.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L258.384|
0000c8  a251              ADR      r2,|L258.528|
0000ca  a156              ADR      r1,|L258.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L258.372|
                  |L258.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L258.384|
0000e0  a258              ADR      r2,|L258.580|
0000e2  a15f              ADR      r1,|L258.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L258.372|
                  |L258.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L258.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L258.384|
000110  a259              ADR      r2,|L258.632|
000112  a144              ADR      r1,|L258.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L258.372|
                  |L258.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L258.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L258.384|
00015a  a251              ADR      r2,|L258.672|
00015c  a140              ADR      r1,|L258.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L258.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L258.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L258.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L258.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L258.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L258.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L258.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L258.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L258.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L258.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L258.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L258.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L258.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L258.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.259||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.259||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfE7SetZeroEv||, COMGROUP=_ZN4Anki8Embedded5ArrayIfE7SetZeroEv, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfE7SetZeroEv PROC ; Anki::Embedded::Array<float>::SetZero()
;;;627    
;;;628        template<typename Type> s32 Array<Type>::SetZero()
000000  b530              PUSH     {r4,r5,lr}
;;;629        {
000002  4604              MOV      r4,r0
000004  6900              LDR      r0,[r0,#0x10]
000006  b083              SUB      sp,sp,#0xc
000008  b1b8              CBZ      r0,|L265.58|
00000a  6820              LDR      r0,[r4,#0]
00000c  2800              CMP      r0,#0
00000e  bfa4              ITT      GE
000010  6860              LDRGE    r0,[r4,#4]
000012  2800              CMPGE    r0,#0
000014  db11              BLT      |L265.58|
;;;630          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;631            0, "Array<Type>::SetZero", "Array<Type> is not valid");
;;;632    
;;;633          const s32 numBytes = this->get_size(0)*this->get_stride();
000016  2100              MOVS     r1,#0
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001e  4601              MOV      r1,r0
000020  68a0              LDR      r0,[r4,#8]
;;;634    
;;;635          memset(this->Pointer(0,0), 0, numBytes);
000022  2200              MOVS     r2,#0
000024  fb01f500          MUL      r5,r1,r0              ;633
000028  6921              LDR      r1,[r4,#0x10]         ;633
00002a  fb021000          MLA      r0,r2,r0,r1           ;633
00002e  4629              MOV      r1,r5
000030  f7fffffe          BL       __aeabi_memclr4
;;;636    
;;;637          return numBytes;
;;;638        }
000034  b003              ADD      sp,sp,#0xc
000036  4628              MOV      r0,r5                 ;637
000038  bd30              POP      {r4,r5,pc}
                  |L265.58|
00003a  f2402176          MOV      r1,#0x276             ;630
00003e  4806              LDR      r0,|L265.88|
000040  e9cd0100          STRD     r0,r1,[sp,#0]         ;630
000044  a305              ADR      r3,|L265.92|
000046  a213              ADR      r2,|L265.148|
000048  a119              ADR      r1,|L265.176|
00004a  2005              MOVS     r0,#5                 ;630
00004c  f7fffffe          BL       _Anki_Log
000050  b003              ADD      sp,sp,#0xc
000052  2000              MOVS     r0,#0                 ;630
000054  bd30              POP      {r4,r5,pc}
;;;639    
                          ENDP

000056  0000              DCW      0x0000
                  |L265.88|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::SetZero()::__PRETTY_FUNCTION__
                  |L265.92|
00005c  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000060  6f726574
000064  6563685c
000068  636f6d6d
00006c  6f6e5c69
000070  6e636c75
000074  64655c61
000078  6e6b692f
00007c  636f6d6d
000080  6f6e2f72
000084  6f626f74
000088  2f617272
00008c  617932  
00008f  642e6800          DCB      "d.h",0
000093  00                DCB      0
                  |L265.148|
000094  41727261          DCB      "Array<Type> is not valid",0
000098  793c5479
00009c  70653e20
0000a0  6973206e
0000a4  6f742076
0000a8  616c6964
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L265.176|
0000b0  41727261          DCB      "Array<Type>::SetZero",0
0000b4  793c5479
0000b8  70653e3a
0000bc  3a536574
0000c0  5a65726f
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0

                          AREA ||area_number.266||, COMGROUP=_ZN4Anki8Embedded5ArrayIfE7SetZeroEv, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfE7SetZeroEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.266||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfE7SetZeroEv||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfE3SetERKS2_||, COMGROUP=_ZN4Anki8Embedded5ArrayIfE3SetERKS2_, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfE3SetERKS2_ PROC ; Anki::Embedded::Array<float>::Set(const Anki::Embedded::Array<float>&)
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;656        {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
000008  b082              SUB      sp,sp,#8
00000a  2100              MOVS     r1,#0
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000012  4607              MOV      r7,r0
000014  2101              MOVS     r1,#1
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001c  4606              MOV      r6,r0
00001e  4629              MOV      r1,r5
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       _ZN4Anki8Embedded8AreValidINS0_5ArrayIfEES3_EEbRKT_RKT0_ ; Anki::Embedded::AreValid<Anki::Embedded::Array<float>, Anki::Embedded::Array<float>>(const T1&, const T2&)
000026  4925              LDR      r1,|L272.188|
000028  f04f0800          MOV      r8,#0
00002c  2800              CMP      r0,#0
00002e  d013              BEQ      |L272.88|
000030  6820              LDR      r0,[r4,#0]
000032  42b8              CMP      r0,r7
000034  bf04              ITT      EQ
000036  6862              LDREQ    r2,[r4,#4]
000038  42b2              CMPEQ    r2,r6
00003a  d01b              BEQ      |L272.116|
00003c  f44f7027          MOV      r0,#0x29c
000040  e9cd1000          STRD     r1,r0,[sp,#0]
000044  a31e              ADR      r3,|L272.192|
000046  a22c              ADR      r2,|L272.248|
000048  a131              ADR      r1,|L272.272|
00004a  2005              MOVS     r0,#5
00004c  f7fffffe          BL       _Anki_Log
;;;657          return this->SetCast<Type>(in);
;;;658        }
000050  b002              ADD      sp,sp,#8
000052  4640              MOV      r0,r8
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L272.88|
000058  f2402099          MOV      r0,#0x299
00005c  e9cd1000          STRD     r1,r0,[sp,#0]
000060  a317              ADR      r3,|L272.192|
000062  a230              ADR      r2,|L272.292|
000064  a12a              ADR      r1,|L272.272|
000066  2005              MOVS     r0,#5
000068  f7fffffe          BL       _Anki_Log
00006c  b002              ADD      sp,sp,#8
00006e  4640              MOV      r0,r8
000070  e8bd81f0          POP      {r4-r8,pc}
                  |L272.116|
000074  2200              MOVS     r2,#0
000076  2800              CMP      r0,#0
000078  dd1b              BLE      |L272.178|
                  |L272.122|
00007a  68a9              LDR      r1,[r5,#8]
00007c  6928              LDR      r0,[r5,#0x10]
00007e  fb020301          MLA      r3,r2,r1,r0
000082  68a1              LDR      r1,[r4,#8]
000084  6920              LDR      r0,[r4,#0x10]
000086  fb020c01          MLA      r12,r2,r1,r0
00008a  6861              LDR      r1,[r4,#4]
00008c  2000              MOVS     r0,#0
00008e  2900              CMP      r1,#0
000090  dd0b              BLE      |L272.170|
                  |L272.146|
000092  eb030180          ADD      r1,r3,r0,LSL #2
000096  ed910a00          VLDR     s0,[r1,#0]
00009a  eb0c0180          ADD      r1,r12,r0,LSL #2
00009e  1c40              ADDS     r0,r0,#1
0000a0  ed810a00          VSTR     s0,[r1,#0]
0000a4  6861              LDR      r1,[r4,#4]
0000a6  4281              CMP      r1,r0
0000a8  dcf3              BGT      |L272.146|
                  |L272.170|
0000aa  6820              LDR      r0,[r4,#0]
0000ac  1c52              ADDS     r2,r2,#1
0000ae  4290              CMP      r0,r2
0000b0  dce3              BGT      |L272.122|
                  |L272.178|
0000b2  6861              LDR      r1,[r4,#4]
0000b4  b002              ADD      sp,sp,#8
0000b6  4348              MULS     r0,r1,r0
0000b8  e8bd81f0          POP      {r4-r8,pc}
;;;659    
                          ENDP

                  |L272.188|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE7SetCastIfEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::SetCast<float>(const Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
                  |L272.192|
0000c0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
0000c4  6f726574
0000c8  6563685c
0000cc  636f6d6d
0000d0  6f6e5c69
0000d4  6e636c75
0000d8  64655c61
0000dc  6e6b692f
0000e0  636f6d6d
0000e4  6f6e2f72
0000e8  6f626f74
0000ec  2f617272
0000f0  617932  
0000f3  642e6800          DCB      "d.h",0
0000f7  00                DCB      0
                  |L272.248|
0000f8  41727261          DCB      "Array sizes don't match",0
0000fc  79207369
000100  7a657320
000104  646f6e27
000108  74206d61
00010c  74636800
                  |L272.272|
000110  41727261          DCB      "Array<Type>::Set",0
000114  793c5479
000118  70653e3a
00011c  3a536574
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L272.292|
000124  496e7661          DCB      "Invalid objects",0
000128  6c696420
00012c  6f626a65
000130  63747300

                          AREA ||area_number.273||, COMGROUP=_ZN4Anki8Embedded5ArrayIfE3SetERKS2_, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfE3SetERKS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.273||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfE3SetERKS2_||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded13QuadrilateralIfE24ComputeBoundingRectangleIiEENS0_9RectangleIT_EEv||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE24ComputeBoundingRectangleIiEENS0_9RectangleIT_EEv, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded13QuadrilateralIfE24ComputeBoundingRectangleIiEENS0_9RectangleIT_EEv PROC ; Anki::Embedded::Quadrilateral<float>::ComputeBoundingRectangle<int>() const
;;;264          // The width and height of a floating point Rectangle is different than that of an integer rectangle.
;;;265          template<typename OutType> Rectangle<OutType> ComputeBoundingRectangle() const;
000000  b410              PUSH     {r4}
000002  ed910a00          VLDR     s0,[r1,#0]
000006  2201              MOVS     r2,#1
000008  eefd0ac0          VCVT.S32.F32 s1,s0
00000c  ed910a01          VLDR     s0,[r1,#4]
000010  edc00a00          VSTR     s1,[r0,#0]
000014  eebd0ac0          VCVT.S32.F32 s0,s0
000018  edc00a01          VSTR     s1,[r0,#4]
00001c  ed800a02          VSTR     s0,[r0,#8]
000020  ed800a03          VSTR     s0,[r0,#0xc]
                  |L279.36|
000024  eb0103c2          ADD      r3,r1,r2,LSL #3
000028  f8d0c000          LDR      r12,[r0,#0]
00002c  ed930a00          VLDR     s0,[r3,#0]
000030  eebd0ac0          VCVT.S32.F32 s0,s0
000034  ee104a10          VMOV     r4,s0
000038  45a4              CMP      r12,r4
00003a  bfa8              IT       GE
00003c  ee10ca10          VMOVGE   r12,s0
000040  f8c0c000          STR      r12,[r0,#0]
000044  ed930a00          VLDR     s0,[r3,#0]
000048  f8d0c004          LDR      r12,[r0,#4]
00004c  eebd0ac0          VCVT.S32.F32 s0,s0
000050  ee104a10          VMOV     r4,s0
000054  45a4              CMP      r12,r4
000056  bfd8              IT       LE
000058  ee10ca10          VMOVLE   r12,s0
00005c  f8c0c004          STR      r12,[r0,#4]
000060  ed930a01          VLDR     s0,[r3,#4]
000064  f8d0c008          LDR      r12,[r0,#8]
000068  eebd0ac0          VCVT.S32.F32 s0,s0
00006c  ee104a10          VMOV     r4,s0
000070  45a4              CMP      r12,r4
000072  bfa8              IT       GE
000074  ee10ca10          VMOVGE   r12,s0
000078  f8c0c008          STR      r12,[r0,#8]
00007c  ed930a01          VLDR     s0,[r3,#4]
000080  f8d0c00c          LDR      r12,[r0,#0xc]
000084  eebd0ac0          VCVT.S32.F32 s0,s0
000088  ee103a10          VMOV     r3,s0
00008c  459c              CMP      r12,r3
00008e  bfd8              IT       LE
000090  ee10ca10          VMOVLE   r12,s0
000094  1c52              ADDS     r2,r2,#1
000096  f8c0c00c          STR      r12,[r0,#0xc]
00009a  2a04              CMP      r2,#4
00009c  dbc2              BLT      |L279.36|
00009e  bc10              POP      {r4}
0000a0  4770              BX       lr
;;;266    
;;;267          // Returns a copy of this Quadrilateral with sorted corners, so they are clockwise around the centroid
;;;268          // Warning: This may give weird results for non-convex quadrilaterals
;;;269          template<typename OutType> Quadrilateral<OutType> ComputeClockwiseCorners() const;
;;;270    
;;;271          template<typename OutType> Quadrilateral<OutType> ComputeRotatedCorners(const f32 radians) const;
;;;272    
;;;273          bool IsConvex() const;
;;;274    
;;;275          bool operator== (const Quadrilateral<Type> &quad2) const;
;;;276    
;;;277          Quadrilateral<Type> operator+ (const Quadrilateral<Type> &quad2) const;
;;;278    
;;;279          Quadrilateral<Type> operator- (const Quadrilateral<Type> &quad2) const;
;;;280    
;;;281          inline Quadrilateral<Type>& operator= (const Quadrilateral<Type> &quad2);
;;;282    
;;;283          // Keeping this explicit to avoid accidental setting of quads of
;;;284          // different types
;;;285          template<typename InType> void SetCast(const Quadrilateral<InType> &quad2);
;;;286    
;;;287          inline const Point<Type>& operator[] (const s32 index) const;
;;;288          inline Point<Type>& operator[] (const s32 index);
;;;289        }; // class Quadrilateral<Type>
;;;290      } // namespace Embedded
;;;291    } // namespace Anki
;;;292    
;;;293    #endif // _ANKICORETECHEMBEDDED_COMMON_POINT_DECLARATIONS_H_
;;;20     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;21     #include "anki/common/robot/sequences_declarations.h"
;;;1      /**
;;;2      File: sequences_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      A Sequence is a mathematically-defined, ordered list. The sequence classes allow for operations on sequences, without requiring them to be explicitly evaluated.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/flags_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> class Array;
;;;23         template<typename Type> class FixedLengthList;
;;;24         template<typename Type> class ArraySlice;
;;;25         class MemoryStack;
;;;26     
;;;27         // #pragma mark --- Class Declarations ---
;;;28         template<typename Type> class Sequence
;;;29         {
;;;30         }; // class Sequence
;;;31     
;;;32         // A LinearSequence is like the result of a call to Matlab's linspace() It has a start, end, and
;;;33         // increment. It does not explicitly compute the values in the sequence, so does not require
;;;34         // much memory.
;;;35         //
;;;36         // WARNING:
;;;37         // The "end" of a LinearSequence is computed automatically, and is less-than-or-equal-to the
;;;38         // requested end.
;;;39         template<typename Type> class LinearSequence : public Sequence<Type>
;;;40         {
;;;41         public:
;;;42     
;;;43           LinearSequence();
;;;44     
;;;45           // Matlab equivalent: start:end
;;;46           LinearSequence(const Type start, const Type end);
;;;47     
;;;48           // Matlab equivalent: start:increment:end
;;;49           LinearSequence(const Type start, const Type increment, const Type end);
;;;50     
;;;51           // No Matlab equivalent
;;;52           // NOTE: end is unused. It is just present to prevent confusion with the other polymorphic constructors
;;;53           LinearSequence(const Type start, const Type increment, const Type end, const s32 size);
;;;54     
;;;55           // Explicitly evaluate each element of the sequence, and put the results in an Array.
;;;56           Array<Type> Evaluate(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;57           Result Evaluate(ArraySlice<Type> out) const;
;;;58     
;;;59           Type get_start() const;
;;;60     
;;;61           // NOTE: The increment is meaningless for LinearSequences of size 0 or 1.
;;;62           Type get_increment() const;
;;;63     
;;;64           // Note: End it not computed, as it is tempting to use it as a loop condition, but it is not safe
;;;65           // Type get_end() const;
;;;66     
;;;67           // Matlab equivalent: length(start:increment:end)
;;;68           s32 get_size() const;
;;;69     
;;;70         protected:
;;;71           // For speed, FixedLengthList is allowed to access protected members, instead of having to
;;;72           // construct a new LinearSequence every time an element is popped or pushed
;;;73           template<typename FixedLengthListType> friend class FixedLengthList;
;;;74     
;;;75           s32 size;
;;;76     
;;;77           Type start;
;;;78           Type increment;
;;;79     
;;;80           static s32 computeSize(const Type start, const Type increment, const Type end);
;;;81         }; // class LinearSequence
;;;82     
;;;83         // IndexSequence creates the input for slicing an Array
;;;84         // If start or end is less than 0, it is equivalent to (end+value)
;;;85         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type end, s32 arraySize);
;;;86         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type increment, Type end, s32 arraySize);
;;;87         LinearSequence<s32> IndexSequence(s32 arraySize); // Internally, it sets start==0, end=arraySize-1, like the Matlab colon operator array(:,:)
;;;88     
;;;89         // Linspace only works correctly for f32 and f64. To prevent misusage, trying ints will give a linker error.
;;;90         template<typename Type> LinearSequence<Type> Linspace(const Type start, const Type end, const s32 size);
;;;91     
;;;92         // These do not link, as they are unsafe
;;;93         template<> LinearSequence<u8> Linspace(const u8 start, const u8 end, const s32 size);
;;;94         template<> LinearSequence<s8> Linspace(const s8 start, const s8 end, const s32 size);
;;;95         template<> LinearSequence<u16> Linspace(const u16 start, const u16 end, const s32 size);
;;;96         template<> LinearSequence<s16> Linspace(const s16 start, const s16 end, const s32 size);
;;;97         template<> LinearSequence<u32> Linspace(const u32 start, const u32 end, const s32 size);
;;;98         template<> LinearSequence<s32> Linspace(const s32 start, const s32 end, const s32 size);
;;;99         template<> LinearSequence<u64> Linspace(const u64 start, const u64 end, const s32 size);
;;;100        template<> LinearSequence<s64> Linspace(const s64 start, const s64 end, const s32 size);
;;;101    
;;;102        // TODO: Logspace
;;;103        //template<typename Type> class Logspace : public Sequence<Type>
;;;104        //{
;;;105        //public:
;;;106        //protected:
;;;107        //};
;;;108    
;;;109        // A Meshgrid is like the result of a call to Matlab's meshgrid(). It is made of two
;;;110        // LinearSequence objects, so does not require much memory.
;;;111        template<typename Type> class Meshgrid
;;;112        {
;;;113        public:
;;;114          Meshgrid();
;;;115    
;;;116          // Matlab equivalent: meshgrid(xGridVector, yGridVector)
;;;117          Meshgrid(const LinearSequence<Type> xGridVector, const LinearSequence<Type> yGridVector);
;;;118    
;;;119          // Allocate an Array, and evaluate this Meshgrid object
;;;120          //
;;;121          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;122          // The first suffix X or Y is for the xGrid vs yGrid
;;;123          // The second suffix 1 or 2 is for 1D vs 2D output
;;;124          Array<Type> EvaluateX1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;125          Array<Type> EvaluateX2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;126          Array<Type> EvaluateY1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;127          Array<Type> EvaluateY2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;128    
;;;129          // Evaluate this Meshgrid object into a pre-allocated Array
;;;130          //
;;;131          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;132          Result EvaluateX1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;133          Result EvaluateX2(ArraySlice<Type> out) const;
;;;134          Result EvaluateY1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;135          Result EvaluateY2(ArraySlice<Type> out) const;
;;;136    
;;;137          s32 get_numElements() const;
;;;138    
;;;139          inline const LinearSequence<Type>& get_xGridVector() const;
;;;140    
;;;141          inline const LinearSequence<Type>& get_yGridVector() const;
;;;142    
;;;143        protected:
;;;144          LinearSequence<Type> xGridVector;
;;;145          LinearSequence<Type> yGridVector;
;;;146        };
;;;147      } // namespace Embedded
;;;148    } //namespace Anki
;;;149    
;;;150    #endif // #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;22     
;;;23     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;24     namespace cv
;;;25     {
;;;26       class Mat;
;;;27       template<typename Type> class Mat_;
;;;28     }
;;;29     #endif
;;;30     
;;;31     namespace Anki
;;;32     {
;;;33       namespace Embedded
;;;34       {
;;;35         template<typename Type> class ArraySlice;
;;;36         template<typename Type> class ConstArraySlice;
;;;37         template<typename Type> class ConstArraySliceExpression;
;;;38     
;;;39         const s32 ARRAY_FILE_HEADER_LENGTH = 32;
;;;40         const s32 ARRAY_FILE_HEADER_VALID_LENGTH = 14; //< How many characters are not spaces
;;;41         const char ARRAY_FILE_HEADER[ARRAY_FILE_HEADER_LENGTH+1] = "\x89" "AnkiEArray1.2                  ";
;;;42     
;;;43         // #pragma mark --- Array Class Declaration ---
;;;44     
;;;45         template<typename Type> class Array
;;;46         {
;;;47         public:
;;;48     
;;;49           // The stride is the "numCols*sizeof(Type)" rounded up by 16, plus any boundary padding
;;;50           static s32 ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags);
;;;51     
;;;52           // The minimum required memory is the size of a stride, times the number of rows
;;;53           static s32 ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags);
;;;54     
;;;55           // Initializes Array as invalid
;;;56           Array();
;;;57     
;;;58           // Constructor for a Array, pointing to user-allocated MemoryStack. This is the preferred
;;;59           // method for creating a new Array.
;;;60           //
;;;61           // Flags::Buffer.isFullyAllocated doesn't do anything
;;;62           Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;63     
;;;64           // Constructor for a Array, pointing to user-allocated data. This type of array is more
;;;65           // restrictive than most matrix libraries. For example, it may make it hard to convert from
;;;66           // OpenCV::Mat to Array, though the reverse is trivial.
;;;67           //
;;;68           // If following are true, then the contents of data will not be modified, and it will work as
;;;69           // a normal buffer without extra zeros as stride padding:
;;;70           // 1. (numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0
;;;71           // 2. reinterpret_cast<size_t>(data) % MEMORY_ALIGNMENT == 0
;;;72           // 3. numRows*numCols*sizeof(Type) <= dataLength
;;;73           //
;;;74           // If Flags::Buffer.isFullyAllocated == true, then the input data buffer's stride must be a
;;;75           // simple multiple
;;;76           Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags=Flags::Buffer(false,false,true));
;;;77     
;;;78           // Load an image from file. Requires OpenCV;
;;;79           static Array<Type> LoadImage(const char * filename, MemoryStack &memory);
;;;80     
;;;81           // Load or save an array saved as a debugStream.
;;;82           // compressionLevel can be from 0 (uncompressed) to 9 (most compressed). If OpenCV is not used, it must be zero.
;;;83           static Array<Type> LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory);
;;;84           static Array<Type> LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength); //< allocatedBuffer must be allocated and freed manually
;;;85           Result SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const;
;;;86     
;;;87           // Pointer to the data, at a given (y,x) location
;;;88           //
;;;89           // NOTE:
;;;90           // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;91           // inner loop, like: "Type * restrict pArray = Array.Pointer(5);", then index
;;;92           // pArray in the inner loop.
;;;93           inline const Type* Pointer(const s32 index0, const s32 index1) const;
;;;94           inline Type* Pointer(const s32 index0, const s32 index1);
;;;95     
;;;96           // Use this operator for normal C-style 2d matrix indexing. For example, "array[5][0] = 6;"
;;;97           // will set the element in the fifth row and first column to 6. This is the same as
;;;98           // "array.Pointer(5)[0] = 6;"
;;;99           //
;;;100          // NOTE:
;;;101          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;102          // inner loop, like: "Type * restrict pArray = Array[5];", then index
;;;103          // pArray in the inner loop.
;;;104          inline const Type * operator[](const s32 index0) const;
;;;105          inline Type * operator[](const s32 index0);
;;;106    
;;;107          // Pointer to the data, at a given (y,x) location
;;;108          //
;;;109          // NOTE:
;;;110          // The default order of coordinates for the Point() constructor is (x,y). So for example,
;;;111          // access Array[5][3] via Array.Pointer(Point<s16>(3,5))
;;;112          //
;;;113          // NOTE:
;;;114          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;115          // inner loop, like: "Type * restrict pArray = Array.Pointer(Point<s16>(5,0));", then index
;;;116          // pArray in the inner loop.
;;;117          inline const Type* Pointer(const Point<s16> &point) const;
;;;118          inline Type* Pointer(const Point<s16> &point);
;;;119    
;;;120          // Get the ith element, like Matlab's 1D indexing of a 2D array.
;;;121          // For example, the 5th element of Arrays of size (1,6) and (6,1) is the same;
;;;122          const Type& Element(const s32 elementIndex) const;
;;;123          Type& Element(const s32 elementIndex);
;;;124    
;;;125          // Return a slice accessor for this array, like the Matlab expression "array(1:5, 2:3:5)"
;;;126          //
;;;127          // NOTE:
;;;128          // If min or max is less than 0, it is equivalent to (end+value). For example, "Array(0,-1,3,5)"
;;;129          // is the same as "Array(0,arrayHeight-1,3,5)"
;;;130          ArraySlice<Type> operator() ();
;;;131          ArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;132          ArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX);
;;;133          ArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX);
;;;134          ConstArraySlice<Type> operator() () const;
;;;135          ConstArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const;
;;;136          ConstArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const;
;;;137          ConstArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const;
;;;138    
;;;139          // ArraySlice Transpose doesn't modify the data, it just sets an "isTransposed" flag.
;;;140          // Anything that uses ArraySliceExpression respects this flag. This doesn't include things
;;;141          // like Matrix::Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out) for example.
;;;142          ConstArraySliceExpression<Type> Transpose() const;
;;;143    
;;;144    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;145          // Copies the OpenCV Mat. If needed, it converts from color to grayscale by averaging the color channels.
;;;146          s32 Set(const cv::Mat_<Type> &in);
;;;147    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;148    
;;;149          // Use the simple OpenCV gui to display this array as an image
;;;150          // Does nothing is OpenCV is not available
;;;151          void Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues=false, const bool fitImageToWindow=false) const;
;;;152    
;;;153          // Print out the contents of this Array
;;;154          //
;;;155          // NOTE:
;;;156          // * If the min X or Y is less than zero, it will be treated as zero
;;;157          // * If the max X or Y is greater than the size of the array minus one, it will be treated as
;;;158          //   the size of the array minus one
;;;159          Result Print(const char * const variableName = "Array", const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;160          Result PrintAlternate(const char * const variableName = "Array", const s32 version=2, const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;161    
;;;162          // Checks if this array is equal to another array, up to some allowable
;;;163          // per-element varation, epsilon. If the arrays are not the same size,
;;;164          // false is returned.
;;;165          bool IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const;
;;;166    
;;;167          // Checks the basic parameters of this Array, and if it is allocated.
;;;168          bool IsValid() const;
;;;169    
;;;170          // Resize will use MemoryStack::Reallocate() to change the Array's size. It only works if this
;;;171          // Array was the last thing allocated. The reallocated memory will not be cleared
;;;172          //
;;;173          // WARNING:
;;;174          // This will not update any references to the memory, you must update all references manually.
;;;175          Result Resize(const s32 numRows, const s32 numCols, MemoryStack &memory);
;;;176    
;;;177          // Set every element in the Array to zero, including the stride padding.
;;;178          // Returns the number of bytes set to zero
;;;179          s32 SetZero();
;;;180    
;;;181          // Set every element in the Array to this value
;;;182          // Returns the number of values set
;;;183          s32 Set(const Type value);
;;;184    
;;;185          // Elementwise copies the input Array into this array. No memory is allocated.
;;;186          s32 Set(const Array<Type> &in);
;;;187    
;;;188          // Copy values to this Array.
;;;189          // If the input array does not contain enough elements, the remainder of this Array will be filled with zeros.
;;;190          // Returns the number of values set (not counting extra zeros)
;;;191          s32 Set(const Type * const values, const s32 numValues);
;;;192    
;;;193          // Read in the input, then cast it to this object's type
;;;194          //
;;;195          // WARNING:
;;;196          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;197          template<typename InType> s32 SetCast(const Array<InType> &in);
;;;198          template<typename InType> s32 SetCast(const InType * const values, const s32 numValues);
;;;199    
;;;200          // This is a shallow copy. There's no reference counting. Updating the data of one array will
;;;201          // update that of others (because they point to the same location in memory).
;;;202          // However, Resizing or other operations on one array won't update the others.
;;;203          Array& operator= (const Array & rightHandSide);
;;;204    
;;;205          // Similar to Matlabs size(matrix, dimension), and dimension is in {0,1}
;;;206          s32 get_size(s32 dimension) const;
;;;207    
;;;208          // Get the stride, which is the number of bytes between an element at (n,m) and an element at (n+1,m)
;;;209          s32 get_stride() const;
;;;210    
;;;211          // just size[0] * size[1]
;;;212          s32 get_numElements() const;
;;;213    
;;;214          // Return the flags that were used when this object was constructed.
;;;215          Flags::Buffer get_flags() const;
;;;216    
;;;217          // Equivalent to Pointer(0,0)
;;;218          //
;;;219          // These are for very low-level access to the buffers. Probably you want to be using one of
;;;220          // the Pointer() accessor methods instead of these.
;;;221          void* get_buffer();
;;;222          const void* get_buffer() const;
;;;223    
;;;224        protected:
;;;225          static const s32 HEADER_LENGTH = 8;
;;;226          static const s32 FOOTER_LENGTH = 8;
;;;227    
;;;228          s32 size[2];
;;;229          s32 stride;
;;;230          Flags::Buffer flags;
;;;231    
;;;232          Type * data;
;;;233    
;;;234          // Basic allocation method
;;;235          void* AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate);
;;;236    
;;;237          // Performs checks and sets appropriate parameters for this object
;;;238          Result InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags);
;;;239    
;;;240          // Set all the buffers and sizes to zero, to signal an invalid array
;;;241          void InvalidateArray();
;;;242    
;;;243          // If this object's Type is a basic type, this method prints out this object.
;;;244          Result PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;245    
;;;246          // If this object's Type is a string, this method prints out this object.
;;;247          Result PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;248        }; // class Array
;;;249    
;;;250        // #pragma mark --- FixedPointArray Class Declaration ---
;;;251    
;;;252        template<typename Type> class FixedPointArray : public Array<Type>
;;;253        {
;;;254        public:
;;;255          FixedPointArray();
;;;256    
;;;257          // Same as Array() constructor
;;;258          // This is the preferred method for constructing an FixedPointArray
;;;259          FixedPointArray(const s32 numRows, const s32 numCols, const s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;260    
;;;261          // Same as Array() constructor
;;;262          // This is the advanced method for constructing an FixedPointArray
;;;263          FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;264    
;;;265          s32 get_numFractionalBits() const;
;;;266    
;;;267        protected:
;;;268          s32 numFractionalBits;
;;;269        };
;;;270    
;;;271        // If you don't know the type of the Array you're loading, use this function directly, then cast it based on the read parameters
;;;272        Array<u8> LoadBinaryArray_UnknownType(
;;;273          const char * filename,
;;;274          MemoryStack *scratch,
;;;275          MemoryStack *memory,
;;;276          void * allocatedBuffer,
;;;277          const s32 allocatedBufferLength,
;;;278          u16  &basicType_sizeOfType,
;;;279          bool &basicType_isBasicType,
;;;280          bool &basicType_isInteger,
;;;281          bool &basicType_isSigned,
;;;282          bool &basicType_isFloat,
;;;283          bool &basicType_isString
;;;284          );
;;;285    
;;;286    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;287        // Returns a cv::Mat that mirrors the data in the input Array.
;;;288        // WARNING: If you copy the cv::Mat or assign it incorrectly, it will no longer mirror the input Array
;;;289        // WARNING: This const_casts the input array, so you can unsafely modify it via the output cv::Mat
;;;290        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out);
;;;291    #endif
;;;292      } // namespace Embedded
;;;293    } //namespace Anki
;;;294    
;;;295    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_DECLARATIONS_H_
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;1      /**
;;;2      File: utilities.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of utilities_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;14     
;;;15     #include "anki/common/robot/utilities_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;17     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;2      * File: trig_fast.h
;;;3      *
;;;4      * Author: Kevin Yoon
;;;5      * Created: 22-OCT-2012
;;;6      *
;;;7      * Some trig functions to supplement incomplete math libraries on embedded targets.
;;;8      * Error of all functions is less than +/- 0.01.
;;;9      * For bettery accuracy, lookup tables should be regenerated with u16.
;;;10     *
;;;11     **/
;;;12     #ifndef _TRIG_FAST_H
;;;13     #define _TRIG_FAST_H
;;;14     
;;;15     // When USE_SMALL_LUT defined, a smaller lookup table is used to conserve space.
;;;16     // USE_INTERPOLATION is also automatically defined, since without it answers are probably too wrong to be useful.
;;;17     // If USE_SMALL_LUT is not defined, a large LUT is used.
;;;18     //#define USE_SMALL_LUT
;;;19     
;;;20     // When defined, interpolates between lookup values for higher accuracy.
;;;21     #define USE_INTERPOLATION
;;;22     
;;;23     // Arctangent function based on lookup table
;;;24     // returns answer in radians
;;;25     float atan_fast(float x);
;;;26     
;;;27     // Arcsine function based on lookup table
;;;28     // returns answer in radians
;;;29     float asin_fast(float x);
;;;30     
;;;31     // Arctangent function which uses atan_fast
;;;32     // returns answer in radians
;;;33     float atan2_fast(float y, float x);
;;;34     
;;;35     // Arctangent function which uses asin from math.h
;;;36     // Useful on embedded systems that don't include atan2 in math.h
;;;37     // More accurate than atan2_fast.
;;;38     // Nothing particularly fast about this implementation.
;;;39     // returns answer in radians
;;;40     float atan2_acc(float y, float x);
;;;41     
;;;42     #endif
;;;19     
;;;20     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;21     #include "opencv2/core/core.hpp"
;;;22     #endif
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         //template<typename Type> inline Type RoundUp(const Type number, const Type multiple)
;;;29     
;;;30         // void* and size_t is a special case, good for aligning pointers
;;;31         inline const void* RoundUp(const void* number, const size_t multiple)
;;;32         {
;;;33           const size_t numberT = reinterpret_cast<size_t>(number);
;;;34           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;35         }
;;;36     
;;;37         inline void* RoundUp(void* number, const size_t multiple)
;;;38         {
;;;39           const size_t numberT = reinterpret_cast<size_t>(number);
;;;40           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;41         }
;;;42     
;;;43         template<> inline u32 RoundUp(const u32 number, const u32 multiple)
;;;44         {
;;;45           return (number + (multiple-1)) & ~(multiple-1);
;;;46         }
;;;47     
;;;48         template<> inline s32 RoundUp(const s32 number, const s32 multiple)
;;;49         {
;;;50           if(number <= 0) {
;;;51             return multiple*( number/multiple );
;;;52           } else {
;;;53             return multiple*( (number-1)/multiple + 1 );
;;;54           }
;;;55         }
;;;56     
;;;57     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;58         template<> inline unsigned long RoundUp(const unsigned long number, const unsigned long multiple)
;;;59         {
;;;60           return (number + (multiple-1)) & ~(multiple-1);
;;;61         }
;;;62     #endif
;;;63     
;;;64         template<> inline u32 RoundDown(const u32 number, const u32 multiple)
;;;65         {
;;;66           return multiple * (number/multiple);
;;;67         }
;;;68     
;;;69         template<> inline s32 RoundDown(const s32 number, const s32 multiple)
;;;70         {
;;;71           if(number < 0) {
;;;72             return multiple * ((number-multiple+1) / multiple);
;;;73           } else {
;;;74             return multiple * (number/multiple);
;;;75           }
;;;76         }
;;;77     
;;;78     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;79         template<> inline unsigned long RoundDown(const unsigned long number, const unsigned long multiple)
;;;80         {
;;;81           return multiple * (number/multiple);
;;;82         }
;;;83     #endif
;;;84     
;;;85         template<typename Type> Type ApproximateExp(const Type exponent, const s32 numTerms)
;;;86         {
;;;87           AnkiAssert(numTerms > 2);
;;;88     
;;;89           const Type exponentAbs = ABS(exponent);
;;;90     
;;;91           Type sum = static_cast<Type>(1) + exponentAbs;
;;;92     
;;;93           Type numerator = static_cast<Type>(exponentAbs);
;;;94           Type denominator = static_cast<Type>(1);
;;;95           for(s32 i=2; i<=numTerms; i++) {
;;;96             numerator *= exponentAbs;
;;;97             denominator *= i;
;;;98     
;;;99             sum += numerator / denominator;
;;;100          }
;;;101    
;;;102          if(exponent < 0) {
;;;103            sum = static_cast<Type>(1) / sum;
;;;104          }
;;;105    
;;;106          return sum;
;;;107        }
;;;108    
;;;109        template<typename Type> void Swap(Type &a, Type &b)
;;;110        {
;;;111          const Type tmp = a;
;;;112          a = b;
;;;113          b = tmp;
;;;114        } // template<typename Type> Swap(Type a, Type b)
;;;115    
;;;116        template<typename Type> u32 BinaryStringToUnsignedNumber(const FixedLengthList<Type> &bits, bool firstBitIsLow)
;;;117        {
;;;118          u32 number = 0;
;;;119    
;;;120          const s32 numBits = bits.get_size();
;;;121    
;;;122          for(s32 bit=0; bit<numBits; bit++) {
;;;123            if(firstBitIsLow) {
;;;124              if(bit == 0) {
;;;125                number += bits[bit];
;;;126              } else {
;;;127                number += bits[bit] << bit;
;;;128              }
;;;129            } else {
;;;130              if(bit == (numBits-1)) {
;;;131                number += bits[bit];
;;;132              } else {
;;;133                number += bits[bit] << (numBits - bit - 1);
;;;134              }
;;;135            }
;;;136          }
;;;137    
;;;138          return number;
;;;139        }
;;;140    
;;;141        template<typename Type> Type Determinant2x2(const Type a, const Type b, const Type c, const Type d)
;;;142        {
;;;143          return a*d - b*c;
;;;144        }
;;;145    
;;;146        template<typename Type> Type Determinant3x3(const Type a, const Type b, const Type c, const Type d, const Type e, const Type f, const Type g, const Type h, const Type i)
;;;147        {
;;;148          return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
;;;149        }
;;;150    
;;;151        template<typename Type> void Invert3x3(Type &a, Type &b, Type &c, Type &d, Type &e, Type &f, Type &g, Type &h, Type &i)
;;;152        {
;;;153          const Type determinant = Determinant3x3(a,b,c,d,e,f,g,h,i);
;;;154          const Type determinantInverse = static_cast<Type>(1) / determinant;
;;;155    
;;;156          const Type A =  (e*i - f*h);
;;;157          const Type B = -(d*i - f*g);
;;;158          const Type C =  (d*h - e*g);
;;;159          const Type D = -(b*i - c*h);
;;;160          const Type E =  (a*i - c*g);
;;;161          const Type F = -(a*h - b*g);
;;;162          const Type G =  (b*f - c*e);
;;;163          const Type H = -(a*f - c*d);
;;;164          const Type I =  (a*e - b*d);
;;;165    
;;;166          a = A * determinantInverse;
;;;167          b = D * determinantInverse;
;;;168          c = G * determinantInverse;
;;;169          d = B * determinantInverse;
;;;170          e = E * determinantInverse;
;;;171          f = H * determinantInverse;
;;;172          g = C * determinantInverse;
;;;173          h = F * determinantInverse;
;;;174          i = I * determinantInverse;
;;;175        }
;;;176    
;;;177        template<typename Type> void Cart2Pol(const Type x, const Type y, Type &rho, Type &theta)
;;;178        {
;;;179          if (x==0 && y==0) {
;;;180            theta = 0;
;;;181            rho = 0;
;;;182          } else {
;;;183            theta = atan2f(y, x);
;;;184            rho = sqrtf(x*x + y*y);
;;;185          }
;;;186        }
;;;187    
;;;188        template<typename Type> void Pol2Cart(const Type rho, const Type theta, Type &x, Type &y)
;;;189        {
;;;190          x = rho * cosf(theta);
;;;191          y = rho * sinf(theta);
;;;192        }
;;;193    
;;;194        inline s32 FloorS32(f32 x)
;;;195        {
;;;196          return static_cast<s32>(floorf(x));
;;;197        }
;;;198    
;;;199        inline s32 CeilS32(f32 x)
;;;200        {
;;;201          return static_cast<s32>(ceilf(x));
;;;202        }
;;;203    
;;;204    #if !defined(__EDG__)
;;;205        // Some platforms may not round to zero correctly, so do the function calls
;;;206        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(floorf(v + 0.5f)) : 0; }
;;;207        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(floorf(v + 0.5f)) : 0; }
;;;208        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(floorf(v + 0.5f)) : static_cast<s32>(ceilf(v - 0.5f)); }
;;;209        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(floorf(v + 0.5f)) : static_cast<s64>(ceilf(v - 0.5f)); }
;;;210        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;211        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;212    
;;;213        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(floor(v + 0.5)) : 0; }
;;;214        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(floor(v + 0.5)) : 0; }
;;;215        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(floor(v + 0.5)) : static_cast<s32>(ceil(v - 0.5)); }
;;;216        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(floor(v + 0.5)) : static_cast<s64>(ceil(v - 0.5)); }
;;;217        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;218        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;219    #else
;;;220        // The M4 rounds to zero correctly, without the function calls
;;;221        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(v + 0.5f) : 0; }
;;;222        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(v + 0.5f) : 0; }
;;;223        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(v + 0.5f) : static_cast<s32>(v - 0.5f); }
;;;224        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(v + 0.5f) : static_cast<s64>(v - 0.5f); }
;;;225        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;226        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;227    
;;;228        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(v + 0.5) : 0; }
;;;229        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(v + 0.5) : 0; }
;;;230        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(v + 0.5) : static_cast<s32>(v - 0.5); }
;;;231        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(v + 0.5) : static_cast<s64>(v - 0.5); }
;;;232        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;233        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;234    #endif
;;;235    
;;;236        // Most cases of RoundIfInteger are from int-to-int or float-to-float, so just do a normal cast
;;;237        template<typename Type> inline Type RoundIfInteger(const u8  v) { return static_cast<Type>(v); }
;;;238        template<typename Type> inline Type RoundIfInteger(const s8  v) { return static_cast<Type>(v); }
;;;239        template<typename Type> inline Type RoundIfInteger(const u16 v) { return static_cast<Type>(v); }
;;;240        template<typename Type> inline Type RoundIfInteger(const s16 v) { return static_cast<Type>(v); }
;;;241        template<typename Type> inline Type RoundIfInteger(const u32 v) { return static_cast<Type>(v); }
;;;242        template<typename Type> inline Type RoundIfInteger(const s32 v) { return static_cast<Type>(v); }
;;;243        template<typename Type> inline Type RoundIfInteger(const u64 v) { return static_cast<Type>(v); }
;;;244        template<typename Type> inline Type RoundIfInteger(const s64 v) { return static_cast<Type>(v); }
;;;245        template<typename Type> inline Type RoundIfInteger(const f32 v) { return static_cast<Type>(v); }
;;;246        template<typename Type> inline Type RoundIfInteger(const f64 v) { return static_cast<Type>(v); }
;;;247    
;;;248        // Specialize for cases with float-to-int
;;;249        template<> inline u8  RoundIfInteger(const f32 v) { return static_cast<u8> (Round<s32>(v)); }
;;;250        template<> inline s8  RoundIfInteger(const f32 v) { return static_cast<s8> (Round<s32>(v)); }
;;;251        template<> inline u16 RoundIfInteger(const f32 v) { return static_cast<u16>(Round<s32>(v)); }
;;;252        template<> inline s16 RoundIfInteger(const f32 v) { return static_cast<s16>(Round<s32>(v)); }
;;;253        template<> inline u32 RoundIfInteger(const f32 v) { return static_cast<u32>(Round<u32>(v)); }
;;;254        template<> inline s32 RoundIfInteger(const f32 v) { return static_cast<s32>(Round<s32>(v)); }
;;;255        template<> inline u64 RoundIfInteger(const f32 v) { return static_cast<u64>(Round<u64>(v)); }
;;;256        template<> inline s64 RoundIfInteger(const f32 v) { return static_cast<s64>(Round<s64>(v)); }
;;;257    
;;;258        template<> inline u8  RoundIfInteger(const f64 v) { return static_cast<u8> (Round<s32>(v)); }
;;;259        template<> inline s8  RoundIfInteger(const f64 v) { return static_cast<s8> (Round<s32>(v)); }
;;;260        template<> inline u16 RoundIfInteger(const f64 v) { return static_cast<u16>(Round<s32>(v)); }
;;;261        template<> inline s16 RoundIfInteger(const f64 v) { return static_cast<s16>(Round<s32>(v)); }
;;;262        template<> inline u32 RoundIfInteger(const f64 v) { return static_cast<u32>(Round<u32>(v)); }
;;;263        template<> inline s32 RoundIfInteger(const f64 v) { return static_cast<s32>(Round<s32>(v)); }
;;;264        template<> inline u64 RoundIfInteger(const f64 v) { return static_cast<u64>(Round<u64>(v)); }
;;;265        template<> inline s64 RoundIfInteger(const f64 v) { return static_cast<s64>(Round<s64>(v)); }
;;;266    
;;;267        // Floats and complex data types aren't specialized
;;;268        template<typename Type> inline Type saturate_cast(const u8  v) { return static_cast<Type>(v); }
;;;269        template<typename Type> inline Type saturate_cast(const s8  v) { return static_cast<Type>(v); }
;;;270        template<typename Type> inline Type saturate_cast(const u16 v) { return static_cast<Type>(v); }
;;;271        template<typename Type> inline Type saturate_cast(const s16 v) { return static_cast<Type>(v); }
;;;272        template<typename Type> inline Type saturate_cast(const u32 v) { return static_cast<Type>(v); }
;;;273        template<typename Type> inline Type saturate_cast(const s32 v) { return static_cast<Type>(v); }
;;;274        template<typename Type> inline Type saturate_cast(const u64 v) { return static_cast<Type>(v); }
;;;275        template<typename Type> inline Type saturate_cast(const s64 v) { return static_cast<Type>(v); }
;;;276        template<typename Type> inline Type saturate_cast(const f32 v) { return static_cast<Type>(v); }
;;;277        template<typename Type> inline Type saturate_cast(const f64 v) { return static_cast<Type>(v); }
;;;278    
;;;279        // Most saturate_cast calls are explicitly specialized
;;;280        template<> inline u8  saturate_cast<u8> (const u8  v) { return v; }
;;;281        template<> inline u8  saturate_cast<u8> (const u16 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;282        template<> inline u8  saturate_cast<u8> (const u32 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;283        template<> inline u8  saturate_cast<u8> (const u64 v) { return (u8)             MIN((u64)u8_MAX, (u64)v); }
;;;284        template<> inline u8  saturate_cast<u8> (const s8  v) { return (u8)                              MAX((s32)0, (s32)v);  }
;;;285        template<> inline u8  saturate_cast<u8> (const s16 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;286        template<> inline u8  saturate_cast<u8> (const s32 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;287        template<> inline u8  saturate_cast<u8> (const s64 v) { return (u8)             MIN((s64)u8_MAX, MAX((s64)0, (s64)v)); }
;;;288        template<> inline u8  saturate_cast<u8> (const f32 v) { return (u8) Round<s32>( MIN((f32)u8_MAX, MAX((f32)0, (f32)v)) ); }
;;;289        template<> inline u8  saturate_cast<u8> (const f64 v) { return (u8) Round<s32>( MIN((f64)u8_MAX, MAX((f64)0, (f64)v)) ); }
;;;290    
;;;291        template<> inline s8  saturate_cast<s8> (const u8  v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;292        template<> inline s8  saturate_cast<s8> (const u16 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;293        template<> inline s8  saturate_cast<s8> (const u32 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;294        template<> inline s8  saturate_cast<s8> (const u64 v) { return (s8)             MIN((u64)s8_MAX, (u64)v); }
;;;295        template<> inline s8  saturate_cast<s8> (const s8  v) { return v; }
;;;296        template<> inline s8  saturate_cast<s8> (const s16 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;297        template<> inline s8  saturate_cast<s8> (const s32 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;298        template<> inline s8  saturate_cast<s8> (const s64 v) { return (s8)             MIN((s64)s8_MAX, MAX((s64)s8_MIN, (s64)v)); }
;;;299        template<> inline s8  saturate_cast<s8> (const f32 v) { return (s8) Round<s32>( MIN((f32)s8_MAX, MAX((f32)s8_MIN, (f32)v)) ); }
;;;300        template<> inline s8  saturate_cast<s8> (const f64 v) { return (s8) Round<s32>( MIN((f64)s8_MAX, MAX((f64)s8_MIN, (f64)v)) ); }
;;;301    
;;;302        template<> inline u16 saturate_cast<u16>(const u8  v) { return v; }
;;;303        template<> inline u16 saturate_cast<u16>(const u16 v) { return v; }
;;;304        template<> inline u16 saturate_cast<u16>(const u32 v) { return (u16)             MIN((u32)u16_MAX, (u32)v); }
;;;305        template<> inline u16 saturate_cast<u16>(const u64 v) { return (u16)             MIN((u64)u16_MAX, (u64)v); }
;;;306        template<> inline u16 saturate_cast<u16>(const s8  v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;307        template<> inline u16 saturate_cast<u16>(const s16 v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;308        template<> inline u16 saturate_cast<u16>(const s32 v) { return (u16)             MIN((s32)u16_MAX, MAX((s32)0, (s32)v)); }
;;;309        template<> inline u16 saturate_cast<u16>(const s64 v) { return (u16)             MIN((s64)u16_MAX, MAX((s64)0, (s64)v)); }
;;;310        template<> inline u16 saturate_cast<u16>(const f32 v) { return (u16) Round<s32>( MIN((f32)u16_MAX, MAX((f32)0, (f32)v)) ); }
;;;311        template<> inline u16 saturate_cast<u16>(const f64 v) { return (u16) Round<s32>( MIN((f64)u16_MAX, MAX((f64)0, (f64)v)) ); }
;;;312    
;;;313        template<> inline s16 saturate_cast<s16>(const u8  v) { return v; }
;;;314        template<> inline s16 saturate_cast<s16>(const u16 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;315        template<> inline s16 saturate_cast<s16>(const u32 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;316        template<> inline s16 saturate_cast<s16>(const u64 v) { return (s16)             MIN((u64)s16_MAX, (u64)v); }
;;;317        template<> inline s16 saturate_cast<s16>(const s8  v) { return v; }
;;;318        template<> inline s16 saturate_cast<s16>(const s16 v) { return v; }
;;;319        template<> inline s16 saturate_cast<s16>(const s32 v) { return (s16)             MIN((s32)s16_MAX, MAX((s32)s16_MIN, (s32)v)); }
;;;320        template<> inline s16 saturate_cast<s16>(const s64 v) { return (s16)             MIN((s64)s16_MAX, MAX((s64)s16_MIN, (s64)v)); }
;;;321        template<> inline s16 saturate_cast<s16>(const f32 v) { return (s16) Round<s32>( MIN((f32)s16_MAX, MAX((f32)s16_MIN, (f32)v)) ); }
;;;322        template<> inline s16 saturate_cast<s16>(const f64 v) { return (s16) Round<s32>( MIN((f64)s16_MAX, MAX((f64)s16_MIN, (f64)v)) ); }
;;;323    
;;;324        template<> inline u32 saturate_cast<u32>(const u8  v) { return v; }
;;;325        template<> inline u32 saturate_cast<u32>(const u16 v) { return v; }
;;;326        template<> inline u32 saturate_cast<u32>(const u32 v) { return v; }
;;;327        template<> inline u32 saturate_cast<u32>(const u64 v) { return (u32)             MIN((u64)u32_MAX, (u64)v); }
;;;328        template<> inline u32 saturate_cast<u32>(const s8  v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;329        template<> inline u32 saturate_cast<u32>(const s16 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;330        template<> inline u32 saturate_cast<u32>(const s32 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;331        template<> inline u32 saturate_cast<u32>(const s64 v) { return (u32)             MIN((s64)u32_MAX, MAX((s64)0, (s64)v)); }
;;;332        template<> inline u32 saturate_cast<u32>(const f32 v) { return (u32) (v > (f32)0xFFFFFF7F) ? 0xFFFFFFFF : Round<u32>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;333        template<> inline u32 saturate_cast<u32>(const f64 v) { return (u32) Round<u32>( MIN((f64)u32_MAX, MAX((f64)0, (f64)v)) ); }
;;;334    
;;;335        template<> inline s32 saturate_cast<s32>(const u8  v) { return v; }
;;;336        template<> inline s32 saturate_cast<s32>(const u16 v) { return v; }
;;;337        template<> inline s32 saturate_cast<s32>(const u32 v) { return (s32)             MIN((u32)s32_MAX, (u32)v); }
;;;338        template<> inline s32 saturate_cast<s32>(const u64 v) { return (s32)             MIN((u64)s32_MAX, (u64)v); }
;;;339        template<> inline s32 saturate_cast<s32>(const s8  v) { return v; }
;;;340        template<> inline s32 saturate_cast<s32>(const s16 v) { return v; }
;;;341        template<> inline s32 saturate_cast<s32>(const s32 v) { return v; }
;;;342        template<> inline s32 saturate_cast<s32>(const s64 v) { return (s32)             MIN((s64)s32_MAX, MAX((s64)s32_MIN, (s64)v)); }
;;;343        template<> inline s32 saturate_cast<s32>(const f32 v) { return (s32) (v > (f32)0x7FFFFFBF) ? 0x7FFFFFFF : Round<s32>(MAX((f32)s32_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;344        template<> inline s32 saturate_cast<s32>(const f64 v) { return (s32) Round<s32>( MIN((f64)s32_MAX, MAX((f64)s32_MIN, (f64)v)) ); }
;;;345    
;;;346        template<> inline u64 saturate_cast<u64>(const u8  v) { return v; }
;;;347        template<> inline u64 saturate_cast<u64>(const u16 v) { return v; }
;;;348        template<> inline u64 saturate_cast<u64>(const u32 v) { return v; }
;;;349        template<> inline u64 saturate_cast<u64>(const u64 v) { return v; }
;;;350        template<> inline u64 saturate_cast<u64>(const s8  v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;351        template<> inline u64 saturate_cast<u64>(const s16 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;352        template<> inline u64 saturate_cast<u64>(const s32 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;353        template<> inline u64 saturate_cast<u64>(const s64 v) { return (u64)                               MAX((s64)0, (s64)v);  }
;;;354        template<> inline u64 saturate_cast<u64>(const f32 v) { return (u64) (v > (f32)0XFFFFFF7FFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;355        template<> inline u64 saturate_cast<u64>(const f64 v) { return (u64) (v > (f64)0xFFFFFFFFFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f64)0, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;356    
;;;357        template<> inline s64 saturate_cast<s64>(const u8  v) { return v; }
;;;358        template<> inline s64 saturate_cast<s64>(const u16 v) { return v; }
;;;359        template<> inline s64 saturate_cast<s64>(const u32 v) { return v; }
;;;360        template<> inline s64 saturate_cast<s64>(const u64 v) { return (s64)             MIN((u64)s64_MAX, (u64)v); }
;;;361        template<> inline s64 saturate_cast<s64>(const s8  v) { return v; }
;;;362        template<> inline s64 saturate_cast<s64>(const s16 v) { return v; }
;;;363        template<> inline s64 saturate_cast<s64>(const s32 v) { return v; }
;;;364        template<> inline s64 saturate_cast<s64>(const s64 v) { return v; }
;;;365        template<> inline s64 saturate_cast<s64>(const f32 v) { return (s64) (v > (f32)0x7FFFFFBFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f32)s64_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;366        template<> inline s64 saturate_cast<s64>(const f64 v) { return (s64) (v > (f64)0x7FFFFFFFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f64)s64_MIN, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;367    
;;;368        template<> inline f32 saturate_cast(const f64 v) { return (f32) MIN((f64)FLT_MAX, MAX(-(f64)FLT_MAX, (f64)v)); }
;;;369      } // namespace Embedded
;;;370    } // namespace Anki
;;;371    
;;;372    #endif // _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;18     #include "anki/common/robot/memory.h"
;;;1      /**
;;;19     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;20     #include "anki/common/robot/geometry.h"
;;;1      /**
;;;2      File: geometry.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of geometry_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/geometry_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/memory.h"
;;;1      /**
;;;18     #include "anki/common/robot/matrix.h"
;;;1      /**
;;;2      File: matrix.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of matrix_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;14     
;;;15     #include "anki/common/robot/matrix_declarations.h"
;;;1      /**
;;;2      File: matrix_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various Matrix operations, such as matrix multiply and addition.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;2      File: arraySlices_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      An array slice is a sub-array of an Array object.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Class Declarations ---
;;;23     
;;;24         template<typename Type> class ConstArraySlice;
;;;25         template<typename Type> class ArraySlice;
;;;26         template<typename Type> class ConstArraySliceExpression;
;;;27     
;;;28         // An ArraySlice is a simple indexing wrapper on top of an Array. The slice of an Array could be
;;;29         // a sub-rectangle of an array and/or skip every n-th element.
;;;30         //
;;;31         // For example, Array(0,3,-1,1,2,4) is the same as Matlab's array(1:3:end, 2:2:5).
;;;32         // (The Array indexing starts from zero vs Matlab's one, hence the different numbers).
;;;33         //
;;;34         // TODO: support non-int indexes
;;;35         // TODO: is there a better way of doing this than a completely different class, different only
;;;36         //       by const?
;;;37         template<typename Type> class ConstArraySlice
;;;38         {
;;;39         public:
;;;40           ConstArraySlice();
;;;41     
;;;42           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;43           ConstArraySlice(const Array<Type> &array);
;;;44     
;;;45           // It's probably easier to call array.operator() than this constructor directly
;;;46           ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;47     
;;;48           // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;49           ConstArraySliceExpression<Type> Transpose() const;
;;;50     
;;;51           bool IsValid() const;
;;;52     
;;;53           const LinearSequence<s32>& get_ySlice() const;
;;;54     
;;;55           const LinearSequence<s32>& get_xSlice() const;
;;;56     
;;;57           // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;58           // don't support the full ArraySlice type, and should be used with caution.
;;;59           const Array<Type>& get_array() const;
;;;60     
;;;61         protected:
;;;62           LinearSequence<s32> ySlice;
;;;63           LinearSequence<s32> xSlice;
;;;64     
;;;65           Array<Type> array;
;;;66     
;;;67           // For speed, this is a direct pointer to the Array's protected data
;;;68           const Type * constArrayData;
;;;69         }; // template<typename Type> class ArraySlice
;;;70     
;;;71         // A non-const version of ConstArraySlice, see ConstArraySlice for details
;;;72         //
;;;73         // WARNING: A "const ArraySlice" doesn't have a const Array. Only ConstArraySlice has a const
;;;74         //          Array. This allows for implicit conversion to non-const function parameters.
;;;75         template<typename Type> class ArraySlice : public ConstArraySlice<Type>
;;;76         {
;;;77         public:
;;;78           ArraySlice();
;;;79     
;;;80           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;81           // The Array parameter is not a reference, to allow for implicit conversion
;;;82           ArraySlice(Array<Type> array);
;;;83     
;;;84           // It's probably easier to call array.operator() than this constructor directly
;;;85           // The Array parameter is not a reference, to allow for implicit conversion
;;;86           ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;87     
;;;88           // If automaticTranspose==true, then you can set a MxN slice with a NxM input.
;;;89           // Matlab allows this for vectors, though this method will also work for
;;;90           // arbitrary-sized arrays.
;;;91           s32 Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
;;;92     
;;;93           // Explicitly evaluate the input LinearSequence into this ArraySlice
;;;94           s32 Set(const LinearSequence<Type> &input);
;;;95     
;;;96           // Set all values of this slice to the given value.
;;;97           //
;;;98           // For example, "array(0,-1,1,4).Set(5);" is the same as
;;;99           // Matlab's "array(1:end, 2:5) = 5;"
;;;100          s32 Set(const Type value);
;;;101    
;;;102          // Copy values to this ArraySlice.
;;;103          // numValues must be equal to the number of values in this slice
;;;104          // Returns the number of values set
;;;105          s32 Set(const Type * const values, const s32 numValues);
;;;106    
;;;107          // Read in the input, then cast it to this object's type
;;;108          //
;;;109          // WARNING:
;;;110          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;111          template<typename InType> s32 SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
;;;112          //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;113    
;;;114          // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;115          // don't support the full ArraySlice type, and should be used with caution.
;;;116          Array<Type>& get_array();
;;;117    
;;;118        protected:
;;;119    
;;;120          // For speed, this is a direct pointer to the Array's protected data
;;;121          Type * arrayData;
;;;122        }; // template<typename Type> class ArraySlice
;;;123    
;;;124        // An ConstArraySliceExpression is like a ConstArraySlice, but can also be transposed
;;;125        // It may have other abilities in the future, but will probably always be const
;;;126        template<typename Type> class ConstArraySliceExpression : public ConstArraySlice<Type>
;;;127        {
;;;128        public:
;;;129          ConstArraySliceExpression();
;;;130    
;;;131          ConstArraySliceExpression(const Array<Type> input, bool isTransposed=false);
;;;132    
;;;133          ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed=false);
;;;134    
;;;135          ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed=false);
;;;136    
;;;137          // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;138          // This object isn't modified, but the returned object is.
;;;139          ConstArraySliceExpression<Type> Transpose() const;
;;;140    
;;;141          bool get_isTransposed() const;
;;;142    
;;;143        protected:
;;;144          bool isTransposed;
;;;145        };
;;;146    
;;;147        // To simplify the creation of kernels using an ArraySlice, and to aid the compiler optimizer,
;;;148        // an ArraySliceLimits can be initialized at the beginning of the function, then used as the
;;;149        // limits for the inner loops.
;;;150    
;;;151        // The suffix of in# and out# refer to the number of input and output matrices.
;;;152        // If output == 0, then the output is a scalar.
;;;153    
;;;154        template<typename Type> class ArraySliceSimpleLimits
;;;155        {
;;;156        public:
;;;157          Type xStart;
;;;158          Type xIncrement;
;;;159          s32  xSize;
;;;160    
;;;161          Type yStart;
;;;162          Type yIncrement;
;;;163          s32  ySize;
;;;164    
;;;165          ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;166        };
;;;167    
;;;168        // In1 and out0 is a special, ultra-simple case, for one matrix input and a scalar output
;;;169        template<typename Type> class ArraySliceLimits_in1_out0
;;;170        {
;;;171        public:
;;;172          // Was this ArraySliceLimits initialized?
;;;173          bool isValid;
;;;174    
;;;175          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;176    
;;;177          ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;178        };
;;;179    
;;;180        // One input, one output
;;;181        template<typename Type> class ArraySliceLimits_in1_out1
;;;182        {
;;;183        public:
;;;184          // Was this ArraySliceLimits initialized?
;;;185          bool isValid;
;;;186    
;;;187          // Can a simple (non-transposed) iteration be performed?
;;;188          bool isSimpleIteration;
;;;189    
;;;190          // These are the current values for the coordinates in the input and output images
;;;191          s32 out1Y;
;;;192          s32 out1X;
;;;193          s32 in1Y;
;;;194          s32 in1X;
;;;195    
;;;196          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;197          s32 ySize;
;;;198          s32 xSize;
;;;199    
;;;200          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;201          // incremented every iteration of the inner loop
;;;202          s32 out1_xInnerIncrement;
;;;203          s32 in1_xInnerIncrement;
;;;204          s32 in1_yInnerIncrement;
;;;205    
;;;206          ArraySliceLimits_in1_out1(
;;;207            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;208            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;209    
;;;210          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;211          inline void OuterIncrementTop();
;;;212    
;;;213          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;214          inline void OuterIncrementBottom();
;;;215    
;;;216        protected:
;;;217          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;218    
;;;219          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;220          bool in1_isTransposed;
;;;221        };
;;;222    
;;;223        // Two inputs, one output
;;;224        template<typename Type> class ArraySliceLimits_in2_out1
;;;225        {
;;;226        public:
;;;227          // Was this ArraySliceLimits initialized?
;;;228          bool isValid;
;;;229    
;;;230          // Can a simple (non-transposed) iteration be performed?
;;;231          bool isSimpleIteration;
;;;232    
;;;233          // These are the current values for the coordinates in the input and output images
;;;234          s32 out1Y;
;;;235          s32 out1X;
;;;236          s32 in1Y;
;;;237          s32 in1X;
;;;238          s32 in2Y;
;;;239          s32 in2X;
;;;240    
;;;241          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;242          s32 ySize;
;;;243          s32 xSize;
;;;244    
;;;245          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;246          // incremented every iteration of the inner loop
;;;247          s32 out1_xInnerIncrement;
;;;248          s32 in1_xInnerIncrement;
;;;249          s32 in1_yInnerIncrement;
;;;250          s32 in2_xInnerIncrement;
;;;251          s32 in2_yInnerIncrement;
;;;252    
;;;253          ArraySliceLimits_in2_out1(
;;;254            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;255            const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed,
;;;256            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;257    
;;;258          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;259          inline void OuterIncrementTop();
;;;260    
;;;261          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;262          inline void OuterIncrementBottom();
;;;263    
;;;264        protected:
;;;265          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;266    
;;;267          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;268          bool in1_isTransposed;
;;;269    
;;;270          ArraySliceSimpleLimits<Type> rawIn2Limits;
;;;271          bool in2_isTransposed;
;;;272        };
;;;273      } // namespace Embedded
;;;274    } // namespace Anki
;;;275    
;;;276    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         namespace Matrix
;;;24         {
;;;25           // #pragma mark --- Declarations ---
;;;26     
;;;27           //
;;;28           // Simple matrix statistics
;;;29           //
;;;30     
;;;31           // Return the minimum element in this Array
;;;32           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat);
;;;33     
;;;34           // Return the maximum element in this Array
;;;35           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat);
;;;36     
;;;37           // Return the sum of every element in the Array
;;;38           template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat);
;;;39     
;;;40           // Return the mean of every element in the Array
;;;41           template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat);
;;;42     
;;;43           // Simultaneously compute the mean and variance of every element in the Array
;;;44           template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(const ConstArraySliceExpression<Array_Type> &mat,
;;;45             Accumulator_Type& mean, Accumulator_Type& var);
;;;46     
;;;47           //
;;;48           // Elementwise matrix operations
;;;49           //
;;;50     
;;;51           // Elementwise add two arrays. in1, in2, and out can be the same array
;;;52           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;53           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;54           template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;55     
;;;56           // Elementwise subtract two arrays. in1, in2, and out can be the same array
;;;57           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;58           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;59           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;60     
;;;61           // Elementwise multiply two arrays. in1, in2, and out can be the same array
;;;62           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;63           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;64           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;65     
;;;66           // Elementwise divide two arrays. in1, in2, and out can be the same array
;;;67           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;68           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;69           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;70     
;;;71           // Elementwise exponential on an array
;;;72           template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;73     
;;;74           // Elementwise square root on an array
;;;75           template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;76     
;;;77           //
;;;78           // Standard matrix operations
;;;79           //
;;;80     
;;;81           // Perform the matrix multiplication "out = in1 * in2"
;;;82           // Note that this is the naive O(n^3) Definition
;;;83           template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out);
;;;84     
;;;85           // Perform the matrix multiplication "out = in1 * in2'"
;;;86           // Note that this is the naive O(n^3) Definition
;;;87           // MultiplyTranspose has better access patterns than Multiply for certain types of arrays, so could be a lot faster (and easier to accelerate)
;;;88           template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out);
;;;89     
;;;90           //
;;;91           // Rotation Matrices
;;;92           //
;;;93     
;;;94           // TODO: Add other rotation-related math, like Rodrigues' formula, or Pose chaining...
;;;95     
;;;96           // Compute the three Euler angles from a given 3x3 Rotation Matrix.
;;;97           Result GetEulerAngles(const Array<f32>& R, f32& angle_x, f32& angle_y, f32& angle_z);
;;;98     
;;;99           //
;;;100          // Linear Algebra and Linear Solvers
;;;101          //
;;;102    
;;;103          // Compute the Cholesky-Banachiewicz decomposition, to return a lower-triangular matrix L such that A=L*L'
;;;104          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;105            Array<Type> &A_L,      //!< Input A Matrix and Output lower-triangular L matrix
;;;106            Array<Type> &Bt_Xt,    //!< Input B-transpose matrix and Output X-transpose solution
;;;107            bool realCholesky,     //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;108            bool &numericalFailure //!< If true, the solver failed because of numerical instability
;;;109            );
;;;110    
;;;111          // Compute the homography such that "transformedPoints = homography * originalPoints"
;;;112          //
;;;113          // WARNING: This uses the inhomogeneous solution and the Cholesky decomposition, therefore it
;;;114          //          will be incorrect if H_33 is zero, which happens in certain cases of lines at
;;;115          //          inifinty. For more details, see Multiple View Geometry 2nd Edition, Example 4.1
;;;116          template<typename Type> Result EstimateHomography(
;;;117            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;118            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;119            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;120            bool &numericalFailure, //!< Did the homography solver fail?
;;;121            MemoryStack scratch //!< Scratch memory
;;;122            );
;;;123    
;;;124          //template<typename InType, typename IntermediateType, typename OutType> Result CholeskyDecomposition(
;;;125          //  const Array<InType> &A,                    //!< Input A Matrix
;;;126          //  Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;127          //  Array<OutType> &L                          //!< Output lower-triangular L matrix
;;;128          //  );
;;;129    
;;;130          //template<typename InType, typename IntermediateType, typename OutType> Result SolveWithLowerTriangular(
;;;131          //  const Array<InType> &L,                          //!< Input lower-triangular L matrix (such as computed by CholeskyDecomposition)
;;;132          //  const Array<InType> &b,                          //!< Input b matrix
;;;133          //  const Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;134          //  Array<OutType> &x                                //!< Output x solution
;;;135          //  );
;;;136    
;;;137          // Solves Ax = b
;;;138          // Specifically, it uses SVD to minimize ||Ax - b||
;;;139          // Note that the A, b, and x matrices are transposed (this is because for large numbers of samples, transposed inputs are liable to be faster)
;;;140          //Result SolveLeastSquaresWithSVD_f32(Array<f32> &At, const Array<f32> &bt, Array<f32> &xt, MemoryStack scratch);
;;;141          //Result SolveLeastSquaresWithSVD_f64(Array<f64> &At, const Array<f64> &bt, Array<f64> &xt, MemoryStack scratch);
;;;142    
;;;143          //
;;;144          // Matrix structure operations
;;;145          //
;;;146    
;;;147          // matlab equivalent: out = reshape(in, [M,N]);
;;;148          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;149          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory);
;;;150    
;;;151          // matlab equivalent: out = in(:);
;;;152          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;153          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory);
;;;154    
;;;155          // Perform an immediate matrix transpose (unlike the lazy transpose of ArraySlice)
;;;156          // in and out must be different Array objects
;;;157          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out);
;;;158    
;;;159          // Rotate an array clockwise by 90, 180, or 270 degrees.
;;;160          // NOTE: Only works for a square matrix.
;;;161          // NOTE: In and out must be different arrays (unlike the interview question)
;;;162          template<typename InType, typename OutType> Result Rotate90( const Array<InType> &in, Array<OutType> &out);
;;;163          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out);
;;;164          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out);
;;;165    
;;;166          //
;;;167          // Misc matrix operations
;;;168          //
;;;169    
;;;170          // Works the same as the Matlab sort() for matrices.
;;;171          // InsertionSort(X) sorts each column of X in ascending order.
;;;172          // The minIndex and maxIndex are for the sortWhichDimension. maxIndex is automatically clipped to the size of the input Array.
;;;173          // NOTE: this currently uses insertion sort, so may be slow for large, badly-unsorted arrays
;;;174          template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;175    
;;;176          // Subsections less-than-or-equal-to insertionSortSize are sorted with insertion sort
;;;177          template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;178    
;;;179          // indexes must be allocated, but will be overwritten by InsertionSort()
;;;180          template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;181    
;;;182          template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;183    
;;;184          // For a square array, either:
;;;185          // 1. When lowerToUpper==true,  copies the lower (left)  triangle to the upper (right) triangle
;;;186          // 2. When lowerToUpper==false, copies the upper (right) triangle to the lower (left)  triangle
;;;187          // Functionally the same as OpenCV completeSymm()
;;;188          template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper = false);
;;;189    
;;;190          // There's probably no need to use these directly. Instead, use the normal Matrix:: operations, like Matrix::Add
;;;191          namespace Elementwise
;;;192          {
;;;193            template<typename InType, typename IntermediateType, typename OutType> class Add {
;;;194            public:
;;;195              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) + static_cast<IntermediateType>(value2));}
;;;196            };
;;;197    
;;;198            template<typename InType, typename IntermediateType, typename OutType> class Subtract {
;;;199            public:
;;;200              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) - static_cast<IntermediateType>(value2));}
;;;201            };
;;;202    
;;;203            template<typename InType, typename IntermediateType, typename OutType> class DotMultiply {
;;;204            public:
;;;205              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) * static_cast<IntermediateType>(value2));}
;;;206            };
;;;207    
;;;208            template<typename InType, typename IntermediateType, typename OutType> class DotDivide {
;;;209            public:
;;;210              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) / static_cast<IntermediateType>(value2));}
;;;211            };
;;;212    
;;;213            // Technically a unary operator, but we ignore the second parameter
;;;214            // TODO: if this is slow, make a unary version of ApplyOperation
;;;215            template<typename InType, typename IntermediateType, typename OutType> class Exp {
;;;216            public:
;;;217              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(expf(static_cast<IntermediateType>(value1)));}
;;;218            };
;;;219    
;;;220            template<typename InType, typename IntermediateType, typename OutType> class Sqrt {
;;;221            public:
;;;222              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(sqrtf(static_cast<IntermediateType>(value1)));}
;;;223            };
;;;224    
;;;225            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;226            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;227            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;228          } // namespace Elementwise
;;;229        } // namespace Matrix
;;;230      } // namespace Embedded
;;;231    } // namespace Anki
;;;232    
;;;233    #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;18     #include "anki/common/robot/memory.h"
;;;19     #include "anki/common/robot/errorHandling.h"
;;;20     #include "anki/common/robot/geometry.h"
;;;21     #include "anki/common/robot/utilities_c.h"
;;;22     #include "anki/common/robot/sequences.h"
;;;23     #include "anki/common/robot/matrix.h"
;;;24     #include "anki/common/robot/comparisons.h"
;;;25     
;;;26     #include "anki/common/shared/utilities_shared.h"
;;;27     
;;;28     #include "anki/common/robot/serialize_declarations.h"
;;;29     
;;;30     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;31     #include "opencv2/core/core.hpp"
;;;32     #include "opencv2/highgui/highgui.hpp"
;;;33     #include "opencv2/imgproc/imgproc.hpp"
;;;34     #include "opencv2/objdetect/objdetect.hpp"
;;;35     #endif
;;;36     
;;;37     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;38     #define ANKICORETECH_EMBEDDED_USE_MALLOC 1
;;;39     #define ANKICORETECH_EMBEDDED_USE_ZLIB 1
;;;40     #endif
;;;41     
;;;42     #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;43     #include "zlib.h"
;;;44     #endif
;;;45     
;;;46     namespace Anki
;;;47     {
;;;48       namespace Embedded
;;;49       {
;;;50         template<typename Type> class ArraySlice;
;;;51         template<typename Type> class ConstArraySlice;
;;;52         template<typename Type> class ConstArraySliceExpression;
;;;53     
;;;54         // #pragma mark --- Array Definitions ---
;;;55     
;;;56         template<typename Type> s32 Array<Type>::ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags)
;;;57         {
;;;58           AnkiConditionalErrorAndReturnValue(numCols >= 0,
;;;59             0, "Array<Type>::ComputeRequiredStride", "Invalid size");
;;;60     
;;;61           const s32 numColsCapped = MAX(numCols, 1);
;;;62     
;;;63           const s32 bufferRequired = static_cast<s32>(RoundUp<size_t>(sizeof(Type)*numColsCapped, MEMORY_ALIGNMENT));
;;;64     
;;;65           return bufferRequired;
;;;66         }
;;;67     
;;;68         template<typename Type> s32 Array<Type>::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags)
;;;69         {
;;;70           AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0,
;;;71             0, "Array<Type>::ComputeMinimumRequiredMemory", "Invalid size");
;;;72     
;;;73           const s32 numRowsCapped = MAX(numRows, 1);
;;;74     
;;;75           return numRowsCapped * Array<Type>::ComputeRequiredStride(numCols, flags);
;;;76         }
;;;77     
;;;78         template<typename Type> Array<Type>::Array()
;;;79         {
;;;80           InvalidateArray();
;;;81         }
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
;;;139        template<typename Type> Array<Type> Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;140        {
;;;141          Array<Type> newArray = Array<Type>();
;;;142    
;;;143    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;144          const cv::Mat cvImage = cv::imread(filename, CV_LOAD_IMAGE_GRAYSCALE);
;;;145    
;;;146          AnkiConditionalErrorAndReturnValue(cvImage.cols >= 0 && cvImage.rows >= 0,
;;;147            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;148    
;;;149          newArray = Array<Type>(cvImage.rows, cvImage.cols, memory);
;;;150    
;;;151          AnkiConditionalErrorAndReturnValue(newArray.IsValid(),
;;;152            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;153    
;;;154          const u8 * restrict pCvImage = cvImage.data;
;;;155    
;;;156          for(s32 y=0; y<cvImage.rows; y++) {
;;;157            Type * restrict pNewArray = newArray.Pointer(y, 0);
;;;158    
;;;159            for(s32 x=0; x<cvImage.cols; x++) {
;;;160              pNewArray[x] = static_cast<Type>(pCvImage[x]);
;;;161            }
;;;162    
;;;163            pCvImage += cvImage.step.buf[0];
;;;164          }
;;;165    #else
;;;166          AnkiError("Array<Type>::Array", "OpenCV is required to load an image from an image file");
;;;167    #endif
;;;168    
;;;169          return newArray;
;;;170        } // Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;171    
;;;172        template<typename Type> Array<Type> LoadBinaryArray_Generic(const char * filename, MemoryStack *scratch, MemoryStack *memory, void * allocatedBuffer, const s32 allocatedBufferLength)
;;;173        {
;;;174          u16  basicType_sizeOfType;
;;;175          bool basicType_isBasicType;
;;;176          bool basicType_isInteger;
;;;177          bool basicType_isSigned;
;;;178          bool basicType_isFloat;
;;;179          bool basicType_isString;
;;;180    
;;;181          Array<u8> rawArray = LoadBinaryArray_UnknownType(
;;;182            filename,
;;;183            scratch, memory,
;;;184            allocatedBuffer, allocatedBufferLength,
;;;185            basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString);
;;;186    
;;;187          // TODO: check that the types match
;;;188    
;;;189          Array<Type> newArray = *reinterpret_cast<Array<Type>*>( &rawArray );
;;;190    
;;;191          return newArray;
;;;192        } // / LoadBinaryArray_Generic()
;;;193    
;;;194        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;195        {
;;;196          return LoadBinaryArray_Generic<Type>(filename, &scratch, &memory, NULL, -1);
;;;197        } // Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;198    
;;;199        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength) //< allocatedBuffer must be freed manually
;;;200        {
;;;201          return LoadBinaryArray_Generic<Type>(filename, NULL, NULL, allocatedBuffer, allocatedBufferLength);
;;;202        } // LoadBinaryMalloc()
;;;203    
;;;204        template<typename Type> Result Array<Type>::SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const
;;;205        {
;;;206          AnkiConditionalErrorAndReturnValue(AreValid(*this, scratch) && filename,
;;;207            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::SaveBinary", "Invalid inputs");
;;;208    
;;;209          AnkiConditionalErrorAndReturnValue(compressionLevel >= 0 && compressionLevel <= 9,
;;;210            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::SaveBinary", "Invalid compression level");
;;;211    
;;;212          // If this is a string array, add the sizes of the null terminated strings (or zero otherwise)
;;;213          const s32 stringsLength = TotalArrayStringLengths<Type>(*this);
;;;214    
;;;215          const s32 serializedBufferLength = 4096 + ARRAY_FILE_HEADER_LENGTH + this->get_size(0) * this->get_stride() + stringsLength;
;;;216          void *buffer = scratch.Allocate(serializedBufferLength);
;;;217    
;;;218          AnkiConditionalErrorAndReturnValue(buffer,
;;;219            RESULT_FAIL_OUT_OF_MEMORY, "Array<Type>::SaveBinary", "Memory could not be allocated");
;;;220    
;;;221          SerializedBuffer toSave(buffer, serializedBufferLength);
;;;222    
;;;223          toSave.PushBack<Type>("Array", *this);
;;;224    
;;;225          s32 startIndex;
;;;226          u8 * bufferStart = reinterpret_cast<u8*>(toSave.get_memoryStack().get_validBufferStart(startIndex));
;;;227          const s32 validUsedBytes = toSave.get_memoryStack().get_usedBytes() - startIndex;
;;;228    
;;;229          // const s32 startDiff = static_cast<s32>( reinterpret_cast<size_t>(bufferStart) - reinterpret_cast<size_t>(toSave.get_memoryStack().get_buffer()) );
;;;230          // const s32 endDiff = toSave.get_memoryStack().get_totalBytes() - toSave.get_memoryStack().get_usedBytes();
;;;231    
;;;232          FILE *fp = fopen(filename, "wb");
;;;233    
;;;234          AnkiConditionalErrorAndReturnValue(fp,
;;;235            RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Could not open file %s", filename);
;;;236    
;;;237          if(compressionLevel > 0) {
;;;238    #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;239            char tmpTextHeader[ARRAY_FILE_HEADER_LENGTH+1];
;;;240            strncpy(tmpTextHeader, &ARRAY_FILE_HEADER[0], ARRAY_FILE_HEADER_LENGTH+1);
;;;241            snprintf(tmpTextHeader+ARRAY_FILE_HEADER_VALID_LENGTH+1, ARRAY_FILE_HEADER_LENGTH-ARRAY_FILE_HEADER_VALID_LENGTH, "z%s ", ZLIB_VERSION);
;;;242    
;;;243            const s32 originalLength = validUsedBytes + SERIALIZED_BUFFER_HEADER_LENGTH + SERIALIZED_BUFFER_FOOTER_LENGTH;
;;;244    
;;;245            uLongf compressedLength = 128 + saturate_cast<s32>(1.1 * originalLength);
;;;246    
;;;247            void * uncompressed = malloc(originalLength);
;;;248            void * compressed = malloc(compressedLength + 2*sizeof(s32));
;;;249    
;;;250            if(!uncompressed || !compressed) {
;;;251              if(uncompressed)
;;;252                free(uncompressed);
;;;253    
;;;254              if(compressed)
;;;255                free(compressed);
;;;256    
;;;257              AnkiError("Array<Type>::SaveBinary", "Out of memory");
;;;258    
;;;259              return RESULT_FAIL_OUT_OF_MEMORY;
;;;260            }
;;;261    
;;;262            // Copy the uncompressed data into one buffer
;;;263            {
;;;264              char * pUncompressed = reinterpret_cast<char*>(uncompressed);
;;;265    
;;;266              memcpy(pUncompressed, &SERIALIZED_BUFFER_HEADER[0], SERIALIZED_BUFFER_HEADER_LENGTH);
;;;267              pUncompressed += SERIALIZED_BUFFER_HEADER_LENGTH;
;;;268    
;;;269              memcpy(pUncompressed, bufferStart, validUsedBytes);
;;;270              pUncompressed += validUsedBytes;
;;;271    
;;;272              memcpy(pUncompressed, &SERIALIZED_BUFFER_FOOTER[0], SERIALIZED_BUFFER_FOOTER_LENGTH);
;;;273            }
;;;274    
;;;275            const s32 compressionResult = compress2(reinterpret_cast<Bytef*>(compressed) + 2*sizeof(s32), &compressedLength, reinterpret_cast<Bytef*>(uncompressed), originalLength, compressionLevel);
;;;276    
;;;277            if(compressionResult != Z_OK) {
;;;278              if(uncompressed)
;;;279                free(uncompressed);
;;;280    
;;;281              if(compressed)
;;;282                free(compressed);
;;;283    
;;;284              AnkiError("Array<Type>::SaveBinary", "Zlib error");
;;;285              return RESULT_FAIL_IO;
;;;286            }
;;;287    
;;;288            reinterpret_cast<s32*>(compressed)[0] = static_cast<s32>(originalLength);
;;;289            reinterpret_cast<s32*>(compressed)[1] = static_cast<s32>(compressedLength);
;;;290    
;;;291            const size_t bytesWrittenForTextHeader = fwrite(tmpTextHeader, 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;292    
;;;293            const size_t bytesWritten = fwrite(compressed, 1, compressedLength + 2*sizeof(s32), fp);
;;;294    
;;;295            if(uncompressed)
;;;296              free(uncompressed);
;;;297    
;;;298            if(compressed)
;;;299              free(compressed);
;;;300    
;;;301            AnkiConditionalErrorAndReturnValue(
;;;302              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;303              bytesWritten == (compressedLength + 2*sizeof(s32)),
;;;304              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;305    
;;;306    #else
;;;307            AnkiError("Array<Type>::SaveBinary", "Saving with compression requires zlib");
;;;308            return RESULT_FAIL;
;;;309    #endif
;;;310          } else {
;;;311            const size_t bytesWrittenForTextHeader = fwrite(&ARRAY_FILE_HEADER[0], 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;312    
;;;313            const size_t bytesWrittenForHeader = fwrite(&SERIALIZED_BUFFER_HEADER[0], 1, SERIALIZED_BUFFER_HEADER_LENGTH, fp);
;;;314    
;;;315            const size_t bytesWritten = fwrite(bufferStart, 1, validUsedBytes, fp);
;;;316    
;;;317            const size_t bytesWrittenForFooter = fwrite(&SERIALIZED_BUFFER_FOOTER[0], 1, SERIALIZED_BUFFER_FOOTER_LENGTH, fp);
;;;318    
;;;319            AnkiConditionalErrorAndReturnValue(
;;;320              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;321              bytesWrittenForHeader == SERIALIZED_BUFFER_HEADER_LENGTH &&
;;;322              bytesWritten == validUsedBytes &&
;;;323              bytesWrittenForFooter == SERIALIZED_BUFFER_FOOTER_LENGTH,
;;;324              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;325          }
;;;326    
;;;327          fclose(fp);
;;;328    
;;;329          return RESULT_OK;
;;;330        } // Array<Type>::SaveBinary(const char * filename, MemoryStack scratch)
;;;331    
;;;332        template<typename Type> const Type* Array<Type>::Pointer(const s32 index0, const s32 index1) const
;;;333        {
;;;334          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;335          AnkiAssert(this->IsValid());
;;;336    
;;;337          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride ) + index1;
;;;338        }
;;;339    
;;;340        template<typename Type> Type* Array<Type>::Pointer(const s32 index0, const s32 index1)
;;;341        {
;;;342          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;343          AnkiAssert(this->IsValid());
;;;344    
;;;345          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride ) + index1;
;;;346        }
;;;347    
;;;348        template<typename Type> inline const Type * Array<Type>::operator[](const s32 index0) const
;;;349        {
;;;350          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;351    
;;;352          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride );
;;;353        }
;;;354    
;;;355        template<typename Type> inline Type * Array<Type>::operator[](const s32 index0)
;;;356        {
;;;357          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;358    
;;;359          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride );
;;;360        }
;;;361    
;;;362        template<typename Type> const Type* Array<Type>::Pointer(const Point<s16> &point) const
;;;363        {
;;;364          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;365        }
;;;366    
;;;367        template<typename Type> Type* Array<Type>::Pointer(const Point<s16> &point)
;;;368        {
;;;369          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;370        }
;;;371    
;;;372        template<typename Type> const Type& Array<Type>::Element(const s32 elementIndex) const
;;;373        {
;;;374          const s32 index1 = elementIndex % size[1];
;;;375          const s32 index0 = (elementIndex - index1) / size[1];
;;;376    
;;;377          return *Pointer(index0, index1);
;;;378        }
;;;379    
;;;380        template<typename Type> Type& Array<Type>::Element(const s32 elementIndex)
;;;381        {
;;;382          const s32 index1 = elementIndex % size[1];
;;;383          const s32 index0 = (elementIndex - index1) / size[1];
;;;384    
;;;385          return *Pointer(index0, index1);
;;;386        }
;;;387    
;;;388        template<typename Type> ArraySlice<Type> Array<Type>::operator() ()
;;;389        {
;;;390          ArraySlice<Type> slice(*this);
;;;391    
;;;392          return slice;
;;;393        }
;;;394    
;;;395        template<typename Type> ArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;396        {
;;;397          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;398    
;;;399          return slice;
;;;400        }
;;;401    
;;;402        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX)
;;;403        {
;;;404          LinearSequence<s32> ySlice = IndexSequence<s32>(minY, 1, maxY, this->size[0]);
;;;405          LinearSequence<s32> xSlice = IndexSequence<s32>(minX, 1, maxX, this->size[1]);
;;;406    
;;;407          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;408    
;;;409          return slice;
;;;410        }
;;;411    
;;;412        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX)
;;;413        {
;;;414          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;415          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;416    
;;;417          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;418    
;;;419          return slice;
;;;420        }
;;;421    
;;;422        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() () const
;;;423        {
;;;424          ConstArraySlice<Type> slice(*this);
;;;425    
;;;426          return slice;
;;;427        }
;;;428    
;;;429        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const
;;;430        {
;;;431          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;432    
;;;433          return slice;
;;;434        }
;;;435    
;;;436        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const
;;;437        {
;;;438          LinearSequence<s32> ySlice = IndexSequence(minY, 1, maxY, this->size[0]);
;;;439          LinearSequence<s32> xSlice = IndexSequence(minX, 1, maxX, this->size[1]);
;;;440    
;;;441          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;442    
;;;443          return slice;
;;;444        }
;;;445    
;;;446        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const
;;;447        {
;;;448          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;449          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;450    
;;;451          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;452    
;;;453          return slice;
;;;454        }
;;;455    
;;;456        template<typename Type> ConstArraySliceExpression<Type> Array<Type>::Transpose() const
;;;457        {
;;;458          ConstArraySliceExpression<Type> expression(this->operator() ());
;;;459          expression.Transpose();
;;;460    
;;;461          return expression;
;;;462        }
;;;463    
;;;464    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;465        template<typename Type> s32 Array<Type>::Set(const cv::Mat_<Type> &in)
;;;466        {
;;;467          const s32 inHeight = in.rows;
;;;468          const s32 inWidth = in.cols;
;;;469    
;;;470          AnkiConditionalErrorAndReturnValue(inHeight != 0,
;;;471            0, "Array<Type>::Set", "input cv::Mat is invalid. If you use the release OpenCV libraries with the debug build, lots of things like file loading don't work.");
;;;472    
;;;473          const bool isColor = in.channels() == 3 || inWidth == this->size[1]*3;
;;;474    
;;;475          if(isColor) {
;;;476            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0],
;;;477              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;478          } else {
;;;479            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;480              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;481          }
;;;482    
;;;483          for(s32 y=0; y<this->size[0]; y++) {
;;;484            const Type * restrict pIn = reinterpret_cast<const Type*>(in.ptr(y,0));
;;;485            Type * restrict pThis = this->Pointer(y,0);
;;;486    
;;;487            // If grayscale, just copy. If color, convert to grayscale
;;;488            if(isColor) {
;;;489              for(s32 x=0; x<this->size[1]; x++) {
;;;490                pThis[x] = (pIn[3*x] + pIn[3*x + 1] + pIn[3*x + 2]) / 3;
;;;491              }
;;;492            } else {
;;;493              memcpy(pThis, pIn, inWidth*sizeof(Type));
;;;494            }
;;;495          }
;;;496    
;;;497          return this->size[0]*this->size[1];
;;;498        }
;;;499    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;500    
;;;501        template<typename Type> void Array<Type>::Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues, const bool fitImageToWindow) const
;;;502        {
;;;503    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;504          AnkiConditionalError(this->IsValid(), "Array<Type>::Show", "Array<Type> is not valid");
;;;505    
;;;506          if(fitImageToWindow) {
;;;507            cv::namedWindow(windowName, CV_WINDOW_NORMAL);
;;;508          } else {
;;;509            cv::namedWindow(windowName, CV_WINDOW_AUTOSIZE);
;;;510          }
;;;511    
;;;512          if(scaleValues) {
;;;513            cv::Mat_<f64> scaledArray;
;;;514    
;;;515            if(ArrayToCvMat(*this, &scaledArray) != RESULT_OK)
;;;516              return;
;;;517    
;;;518            const f64 minValue = Matrix::Min<Type>(*this);
;;;519            const f64 maxValue = Matrix::Max<Type>(*this);
;;;520            const f64 range = maxValue - minValue;
;;;521    
;;;522            scaledArray -= minValue;
;;;523            scaledArray /= range;
;;;524    
;;;525            cv::imshow(windowName, scaledArray);
;;;526          } else {
;;;527            cv::Mat_<Type> arrayCopy;
;;;528    
;;;529            if(ArrayToCvMat(*this, &arrayCopy) != RESULT_OK)
;;;530              return;
;;;531    
;;;532            cv::imshow(windowName, arrayCopy);
;;;533          }
;;;534    
;;;535          if(waitForKeypress) {
;;;536            cv::waitKey();
;;;537          }
;;;538    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;539        }
;;;540    
;;;541        template<typename Type> Result Array<Type>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;542        {
;;;543          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;544            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;545    
;;;546          CoreTechPrint(variableName);
;;;547          CoreTechPrint(":\n");
;;;548          for(s32 y=MAX(0,minY); y<MIN(maxY+1,size[0]); y++) {
;;;549            const Type * const pThisData = this->Pointer(y, 0);
;;;550            for(s32 x=MAX(0,minX); x<MIN(maxX+1,size[1]); x++) {
;;;551              pThisData[x].Print();
;;;552            }
;;;553            CoreTechPrint("\n");
;;;554          }
;;;555          CoreTechPrint("\n");
;;;556    
;;;557          return RESULT_OK;
;;;558        }
;;;559    
;;;560        template<typename Type> Result Array<Type>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;561        {
;;;562          return this->Print(variableName, minY, maxY, minX, maxX);
;;;563        }
;;;564    
;;;565        template<typename Type> bool Array<Type>::IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const
;;;566        {
;;;567          bool isSame = false;
;;;568          if(AreValid(*this, other)) {
;;;569            const s32 nrows = this->get_size(0);
;;;570            const s32 ncols = this->get_size(1);
;;;571    
;;;572            if(other.get_size(0)==nrows && other.get_size(1) == ncols) {
;;;573              isSame = true;
;;;574              for(s32 i=0; i<nrows && isSame; ++i) {
;;;575                const Type * restrict pThis  = this->Pointer(i,0);
;;;576                const Type * restrict pOther = other.Pointer(i,0);
;;;577    
;;;578                for(s32 j=0; j<ncols; ++j) {
;;;579                  if(!NEAR(pThis[j], pOther[j], epsilon)) {
;;;580                    isSame = false;
;;;581                    break;
;;;582                  }
;;;583                } // for j
;;;584              } // for i
;;;585            } // if sizes match
;;;586          } // if both valid
;;;587    
;;;588          return isSame;
;;;589        } // IsNearlyEqualTo()
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
;;;592        {
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
;;;602        }
;;;603    
;;;604        template<typename Type> Result Array<Type>::Resize(const s32 numRows, const s32 numCols, MemoryStack &memory)
;;;605        {
;;;606          AnkiConditionalErrorAndReturnValue(numCols > 0 && numRows > 0,
;;;607            RESULT_FAIL_INVALID_SIZE, "Array<Type>::Resize", "Invalid size");
;;;608    
;;;609          s32 numBytesAllocated = 0;
;;;610    
;;;611          this->data = reinterpret_cast<Type*>( AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, true) );
;;;612    
;;;613          // Don't clear the reallocated memory
;;;614          const bool clearMemory = this->flags.get_zeroAllocatedMemory();
;;;615          this->flags.set_zeroAllocatedMemory(false);
;;;616    
;;;617          const Result result = InitializeBuffer(numRows,
;;;618            numCols,
;;;619            this->data,
;;;620            numBytesAllocated,
;;;621            this->flags);
;;;622    
;;;623          this->flags.set_zeroAllocatedMemory(clearMemory);
;;;624    
;;;625          return result;
;;;626        }
;;;627    
;;;628        template<typename Type> s32 Array<Type>::SetZero()
;;;629        {
;;;630          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;631            0, "Array<Type>::SetZero", "Array<Type> is not valid");
;;;632    
;;;633          const s32 numBytes = this->get_size(0)*this->get_stride();
;;;634    
;;;635          memset(this->Pointer(0,0), 0, numBytes);
;;;636    
;;;637          return numBytes;
;;;638        }
;;;639    
;;;640        template<typename Type> s32 Array<Type>::Set(const Type value)
;;;641        {
;;;642          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;643            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;644    
;;;645          for(s32 y=0; y<size[0]; y++) {
;;;646            Type * restrict pThisData = Pointer(y, 0);
;;;647            for(s32 x=0; x<size[1]; x++) {
;;;648              pThisData[x] = value;
;;;649            }
;;;650          }
;;;651    
;;;652          return size[0]*size[1];
;;;653        }
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
;;;656        {
;;;657          return this->SetCast<Type>(in);
;;;658        }
;;;659    
;;;660        template<typename Type> template<typename InType> s32 Array<Type>::SetCast(const Array<InType> &in)
;;;661        {
;;;662          const s32 inHeight = in.get_size(0);
;;;663          const s32 inWidth = in.get_size(1);
;;;664    
;;;665          AnkiConditionalErrorAndReturnValue(AreValid(*this, in),
;;;666            0, "Array<Type>::Set", "Invalid objects");
;;;667    
;;;668          AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;669            0, "Array<Type>::Set", "Array sizes don't match");
;;;670    
;;;671          for(s32 y=0; y<size[0]; y++) {
;;;672            const InType * restrict pIn = in.Pointer(y, 0);
;;;673            Type * restrict pThisData = Pointer(y, 0);
;;;674    
;;;675            for(s32 x=0; x<size[1]; x++) {
;;;676              pThisData[x] = saturate_cast<Type>(pIn[x]);
;;;677            }
;;;678          }
;;;679    
;;;680          return size[0]*size[1];
;;;681        }
;;;682    
;;;683        template<typename InType> s32 SetCast(const InType * const values, const s32 numValues)
;;;684        {
;;;685          // This is a little tough to write a general case for, so this method should be specialized
;;;686          // for each relevant case
;;;687          AnkiAssert(false);
;;;688    
;;;689          return 0;
;;;690        }
;;;691    
;;;692        template<typename Type> s32 Array<Type>::Set(const Type * const values, const s32 numValues)
;;;693        {
;;;694          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;695            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;696    
;;;697          s32 numValuesSet = 0;
;;;698    
;;;699          for(s32 y=0; y<size[0]; y++) {
;;;700            u32 * restrict pThisData = reinterpret_cast<u32*>(Pointer(y, 0));
;;;701    
;;;702            const s32 numValuesThisRow = MAX(0, MIN(numValues - y*size[1], size[1]));
;;;703    
;;;704            if(numValuesThisRow > 0) {
;;;705              // For small data types, this may be too many bytes, but the stride padding should make
;;;706              // the writing okay (I think)
;;;707              const s32 numWordsToCopy = (sizeof(Type)*numValuesThisRow + 3) / 4;
;;;708    
;;;709              //memcpy(pThisData, values + y*size[1], numValuesThisRow*sizeof(Type));
;;;710              for(s32 x=0; x<numWordsToCopy; x++) {
;;;711                //AnkiAssert(reinterpret_cast<size_t>(values+y*size[1]) % 4 == 0);
;;;712                pThisData[x] = reinterpret_cast<const u32*>(values+y*size[1])[x];
;;;713              }
;;;714              numValuesSet += numValuesThisRow;
;;;715            }
;;;716    
;;;717            if(numValuesThisRow < size[1]) {
;;;718              memset(pThisData+numValuesThisRow*sizeof(Type), 0, (size[1]-numValuesThisRow)*sizeof(Type));
;;;719            }
;;;720          }
;;;721    
;;;722          return numValuesSet;
;;;723        }
;;;724    
;;;725        template<typename Type> Array<Type>& Array<Type>::operator= (const Array<Type> & rightHandSide)
;;;726        {
;;;727          this->size[0] = rightHandSide.size[0];
;;;728          this->size[1] = rightHandSide.size[1];
;;;729    
;;;730          this->stride = rightHandSide.stride;
;;;731          this->flags = rightHandSide.flags;
;;;732          this->data = rightHandSide.data;
;;;733    
;;;734          return *this;
;;;735        }
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
;;;738        {
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
;;;747    
;;;748        template<typename Type> s32 Array<Type>::get_stride() const
;;;749        {
;;;750          return stride;
;;;751        }
;;;752    
;;;753        template<typename Type> s32 Array<Type>::get_numElements() const
;;;754        {
;;;755          if(size[0] > 0 && size[1] > 0) {
;;;756            return size[0] * size[1];
;;;757          } else {
;;;758            return 0;
;;;759          }
;;;760        }
;;;761    
;;;762        template<typename Type> void* Array<Type>::get_buffer()
;;;763        {
;;;764          return data;
;;;765        }
;;;766    
;;;767        template<typename Type> const void* Array<Type>::get_buffer() const
;;;768        {
;;;769          return data;
;;;770        }
;;;771    
;;;772        template<typename Type> Flags::Buffer Array<Type>::get_flags() const
;;;773        {
;;;774          return flags;
;;;775        }
;;;776    
;;;777        template<typename Type> void* Array<Type>::AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate)
;;;778        {
;;;779          AnkiConditionalError(numRows >= 0 && stride > 0,
;;;780            "Array<Type>::AllocateBufferFromMemoryStack", "Invalid size");
;;;781    
;;;782          const s32 numRowsCapped = MAX(numRows, 1);
;;;783    
;;;784          this->stride = stride;
;;;785    
;;;786          const s32 numBytesRequested = numRowsCapped * this->stride;
;;;787    
;;;788          if(reAllocate) {
;;;789            return memory.Reallocate(this->data, numBytesRequested, numBytesAllocated);
;;;790          } else {
;;;791            return memory.Allocate(numBytesRequested, flags.get_zeroAllocatedMemory(), numBytesAllocated);
;;;792          }
;;;793        }
;;;794    
;;;795        template<typename Type> Result Array<Type>::InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags)
;;;796        {
;;;797          if(!rawData) {
;;;798            AnkiError("Anki.Array2d.initialize", "input data buffer is NULL");
;;;799            InvalidateArray();
;;;800            return RESULT_FAIL_UNINITIALIZED_MEMORY;
;;;801          }
;;;802    
;;;803          AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0 && dataLength >= MEMORY_ALIGNMENT,
;;;804            RESULT_FAIL_INVALID_SIZE, "Array<Type>::InitializeBuffer", "Negative dimension");
;;;805    
;;;806          AnkiConditionalErrorAndReturnValue(!flags.get_useBoundaryFillPatterns(),
;;;807            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::InitializeBuffer", "Fill patterns not supported for Array");
;;;808    
;;;809          this->flags = flags;
;;;810          this->size[0] = numRows;
;;;811          this->size[1] = numCols;
;;;812    
;;;813          // Initialize an empty array.
;;;814    
;;;815          this->data = reinterpret_cast<Type*>(rawData);
;;;816    
;;;817          const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData), MEMORY_ALIGNMENT) - reinterpret_cast<size_t>(rawData));
;;;818          const s32 requiredBytes = ComputeRequiredStride(numCols,flags)*numRows + extraAlignmentBytes;
;;;819    
;;;820          if(requiredBytes > dataLength) {
;;;821            AnkiError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
;;;822            InvalidateArray();
;;;823            return RESULT_FAIL_OUT_OF_MEMORY;
;;;824          }
;;;825    
;;;826          this->data = reinterpret_cast<Type*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
;;;827    
;;;828          //#if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;829          //      this->UpdateCvMatMirror(*this);
;;;830          //#endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;831    
;;;832          return RESULT_OK;
;;;833        } // Array<Type>::InitializeBuffer()
;;;834    
;;;835        // Set all the buffers and sizes to -1, to signal an invalid array
;;;836        template<typename Type> void Array<Type>::InvalidateArray()
;;;837        {
;;;838          this->size[0] = -1;
;;;839          this->size[1] = -1;
;;;840          this->stride = -1;
;;;841          this->data = NULL;
;;;842        } // void Array<Type>::InvalidateArray()
;;;843    
;;;844        template<typename Type> Result Array<Type>::PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX)  const
;;;845        {
;;;846          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;847            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;848    
;;;849          const s32 realMinX = MAX(0,minX);
;;;850          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;851          const s32 realMinY = MAX(0,minY);
;;;852          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;853    
;;;854          CoreTechPrint("%s type(int:%d,signed:%d,float:%d,sizeof:%d):\n", variableName, Flags::TypeCharacteristics<Type>::isInteger, Flags::TypeCharacteristics<Type>::isSigned, Flags::TypeCharacteristics<Type>::isFloat, sizeof(Type));
;;;855    
;;;856          for(s32 y=realMinY; y<realMaxY; y++) {
;;;857            const Type * const pThisData = this->Pointer(y, 0);
;;;858            for(s32 x=realMinX; x<realMaxX; x++) {
;;;859              if(Flags::TypeCharacteristics<Type>::isBasicType) {
;;;860                if(Flags::TypeCharacteristics<Type>::isInteger) {
;;;861                  CoreTechPrint("%d ", static_cast<s32>(pThisData[x]));
;;;862                } else {
;;;863                  if(version==1) {
;;;864                    CoreTechPrint("%f ", (float)pThisData[x]);
;;;865                  } else {
;;;866                    CoreTechPrint("%e ", (float)pThisData[x]);
;;;867                  }
;;;868                }
;;;869              } else {
;;;870                CoreTechPrint("! ");
;;;871              }
;;;872            }
;;;873            CoreTechPrint("\n");
;;;874          }
;;;875          CoreTechPrint("\n");
;;;876    
;;;877          return RESULT_OK;
;;;878        }
;;;879    
;;;880        template<typename Type> Result Array<Type>::PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;881        {
;;;882          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;883            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::PrintString", "Array<Type> is not valid");
;;;884    
;;;885          const s32 realMinX = MAX(0,minX);
;;;886          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;887          const s32 realMinY = MAX(0,minY);
;;;888          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;889    
;;;890          CoreTechPrint("%s:\n", variableName);
;;;891    
;;;892          for(s32 y=realMinY; y<realMaxY; y++) {
;;;893            const char * const * pThisData = this->Pointer(y, 0);
;;;894            for(s32 x=realMinX; x<realMaxX; x++) {
;;;895              const char * curString = pThisData[x];
;;;896              if(!curString) {
;;;897                CoreTechPrint("NULL, ");
;;;898              } else {
;;;899                CoreTechPrint("\"%s\", ", curString);
;;;900              }
;;;901            }
;;;902            CoreTechPrint("\n");
;;;903          }
;;;904          CoreTechPrint("\n");
;;;905    
;;;906          return RESULT_OK;
;;;907        }
;;;908    
;;;909        // #pragma mark --- FixedPointArray Definitions ---
;;;910    
;;;911        template<typename Type> FixedPointArray<Type>::FixedPointArray()
;;;912          : Array<Type>(), numFractionalBits(-1)
;;;913        {
;;;914        }
;;;915    
;;;916        template<typename Type> FixedPointArray<Type>::FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags)
;;;917          : Array<Type>(numRows, numCols, data, dataLength, flags), numFractionalBits(numFractionalBits)
;;;918        {
;;;919          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= (sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;920        }
;;;921    
;;;922        template<typename Type> FixedPointArray<Type>::FixedPointArray(s32 numRows, s32 numCols, s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags)
;;;923          : Array<Type>(numRows, numCols, memory, flags), numFractionalBits(numFractionalBits)
;;;924        {
;;;925          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= static_cast<s32>(sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;926        }
;;;927    
;;;928        template<typename Type> s32 FixedPointArray<Type>::get_numFractionalBits() const
;;;929        {
;;;930          return numFractionalBits;
;;;931        }
;;;932    
;;;933    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;934        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;935        {
;;;936          AnkiConditionalErrorAndReturnValue(in.IsValid() && out,
;;;937            RESULT_FAIL, "ArrayToCvMat", "This Array is invalid");
;;;938    
;;;939          out->refcount = NULL;
;;;940    
;;;941          // These two should be set, because if the Mat_ constructor was not called, these will not be initialized
;;;942          out->step.p = out->step.buf;
;;;943          out->size = &out->rows;
;;;944    
;;;945          *out = cv::Mat_<Type>(in.get_size(0), in.get_size(1), const_cast<Type*>(in.Pointer(0,0)), static_cast<size_t>(in.get_stride()));
;;;946    
;;;947          return RESULT_OK;
;;;948        } // template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;949    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;950    
;;;951        // #pragma mark --- Array Specializations ---
;;;952    
;;;953        template<> Result Array<bool>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;954        template<> Result Array<u8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;955        template<> Result Array<s8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;956        template<> Result Array<u16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;957        template<> Result Array<s16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;958        template<> Result Array<u32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;959        template<> Result Array<s32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;960        template<> Result Array<u64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;961        template<> Result Array<s64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;962        template<> Result Array<f32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;963        template<> Result Array<f64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;964        template<> Result Array<const char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;965        template<> Result Array<char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;966    
;;;967        template<> Result Array<f32>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;968        template<> Result Array<f64>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;969    
;;;970        template<> template<> s32 Array<u8>::SetCast(const s32 * const values, const s32 numValues);
;;;971        template<> template<> s32 Array<s16>::SetCast(const s32 * const values, const s32 numValues);
;;;972      } // namespace Embedded
;;;973    } //namespace Anki
;;;974    
;;;975    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;17     #include "anki/common/robot/arraySlices.h"
;;;1      /**
;;;2      File: arraySlices.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of arraySlices_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;14     
;;;15     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> ConstArraySlice<Type>::ConstArraySlice()
;;;23           : ySlice(LinearSequence<s32>()), xSlice(LinearSequence<s32>()), array(Array<Type>()), constArrayData(NULL)
;;;24         {
;;;25         }
;;;26     
;;;27         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array)
;;;28           : ySlice(LinearSequence<s32>(0,array.get_size(0)-1)), xSlice(LinearSequence<s32>(0,array.get_size(1)-1)), array(array)
;;;29         {
;;;30           if(array.get_numElements() == 0) {
;;;31             this->constArrayData = NULL;
;;;32           } else {
;;;33             this->constArrayData = array.Pointer(0,0);
;;;34           }
;;;35         }
;;;36     
;;;37         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;38           : ySlice(ySlice), xSlice(xSlice), array(array)
;;;39         {
;;;40           if(array.get_numElements() == 0) {
;;;41             this->constArrayData = NULL;
;;;42           } else {
;;;43             this->constArrayData = array.Pointer(0,0);
;;;44           }
;;;45         }
;;;46     
;;;47         template<typename Type> ConstArraySliceExpression<Type> ConstArraySlice<Type>::Transpose() const
;;;48         {
;;;49           ConstArraySliceExpression<Type> expression(*this, true);
;;;50     
;;;51           return expression;
;;;52         }
;;;53     
;;;54         template<typename Type> bool ConstArraySlice<Type>::IsValid() const
;;;55         {
;;;56           return this->array.IsValid();
;;;57         }
;;;58     
;;;59         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_ySlice() const
;;;60         {
;;;61           return ySlice;
;;;62         }
;;;63     
;;;64         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_xSlice() const
;;;65         {
;;;66           return xSlice;
;;;67         }
;;;68     
;;;69         template<typename Type> const Array<Type>& ConstArraySlice<Type>::get_array() const
;;;70         {
;;;71           return this->array;
;;;72         }
;;;73     
;;;74         template<typename Type> ArraySlice<Type>::ArraySlice()
;;;75           : ConstArraySlice<Type>(), arrayData(NULL)
;;;76         {
;;;77         }
;;;78     
;;;79         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array)
;;;80           : ConstArraySlice<Type>(array)
;;;81         {
;;;82           if(array.get_numElements() == 0) {
;;;83             this->arrayData = NULL;
;;;84           } else {
;;;85             this->arrayData = array.Pointer(0,0);
;;;86           }
;;;87         }
;;;88     
;;;89         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;90           : ConstArraySlice<Type>(array, ySlice, xSlice)
;;;91         {
;;;92           if(array.get_numElements() == 0) {
;;;93             this->arrayData = NULL;
;;;94           } else {
;;;95             this->arrayData = array.Pointer(0,0);
;;;96           }
;;;97         }
;;;98     
;;;99         template<typename Type> s32 ArraySlice<Type>::Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;100        {
;;;101          return this->SetCast<Type>(input, automaticTranspose);
;;;102        }
;;;103    
;;;104        template<typename Type> s32 ArraySlice<Type>::Set(const LinearSequence<Type> &input)
;;;105        {
;;;106          const Result result = input.Evaluate(*this);
;;;107          return (result==RESULT_OK) ? input.get_size() : 0;
;;;108        }
;;;109    
;;;110        template<typename Type> s32 ArraySlice<Type>::Set(const Type value)
;;;111        {
;;;112          Array<Type> &array = this->get_array();
;;;113    
;;;114          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;115            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;116    
;;;117          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;118    
;;;119          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;120            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;121    
;;;122          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;123            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;124            Type * restrict pMat = array.Pointer(y, 0);
;;;125    
;;;126            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;127              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;128              pMat[x] = value;
;;;129            }
;;;130          }
;;;131    
;;;132          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;133        }
;;;134    
;;;135        template<typename Type> s32 ArraySlice<Type>::Set(const Type * const values, const s32 numValues)
;;;136        {
;;;137          Array<Type> &array = this->get_array();
;;;138    
;;;139          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;140            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;141    
;;;142          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;143    
;;;144          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;145            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;146    
;;;147          AnkiConditionalErrorAndReturnValue(limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize == numValues,
;;;148            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;149    
;;;150          s32 ci = 0;
;;;151          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;152            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;153            Type * restrict pMat = array.Pointer(y, 0);
;;;154    
;;;155            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;156              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;157              pMat[x] = values[ci];
;;;158              ci++;
;;;159            }
;;;160          }
;;;161    
;;;162          AnkiAssert(ci == limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize);
;;;163    
;;;164          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;165        }
;;;166    
;;;167        template<typename Type> template<typename InType> s32 ArraySlice<Type>::SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;168        {
;;;169          AnkiConditionalErrorAndReturnValue(AreValid(*this, input),
;;;170            0, "ArraySlice<Type>::Set", "Invalid objects");
;;;171    
;;;172          AnkiConditionalErrorAndReturnValue(this->get_array().get_buffer() != input.get_array().get_buffer(),
;;;173            0, "ArraySlice<Type>::Set", "Arrays must be in different memory locations");
;;;174    
;;;175          ArraySliceLimits_in1_out1<s32> limits(
;;;176            input.get_ySlice(), input.get_xSlice(), input.get_isTransposed(),
;;;177            this->get_ySlice(), this->get_xSlice());
;;;178    
;;;179          if(!limits.isValid) {
;;;180            if(automaticTranspose) {
;;;181              // If we're allowed to transpose, give it another shot
;;;182              limits = ArraySliceLimits_in1_out1<s32> (input.get_ySlice(), input.get_xSlice(), !input.get_isTransposed(), this->get_ySlice(), this->get_xSlice());
;;;183    
;;;184              if(!limits.isValid) {
;;;185                AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;186                return 0;
;;;187              }
;;;188            } else {
;;;189              AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;190              return 0;
;;;191            }
;;;192          }
;;;193    
;;;194          Array<Type> &out1Array = this->get_array();
;;;195          const Array<InType> &in1Array = input.get_array();
;;;196    
;;;197          if(limits.isSimpleIteration) {
;;;198            // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;199    
;;;200            for(s32 y=0; y<limits.ySize; y++) {
;;;201              const InType * restrict pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;202              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;203    
;;;204              limits.OuterIncrementTop();
;;;205    
;;;206              for(s32 x=0; x<limits.xSize; x++) {
;;;207                pOut1[limits.out1X] = static_cast<Type>( pIn1[limits.in1X] );
;;;208    
;;;209                limits.out1X += limits.out1_xInnerIncrement;
;;;210                limits.in1X += limits.in1_xInnerIncrement;
;;;211              }
;;;212    
;;;213              limits.OuterIncrementBottom();
;;;214            }
;;;215          } else {
;;;216            for(s32 y=0; y<limits.ySize; y++) {
;;;217              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;218    
;;;219              limits.OuterIncrementTop();
;;;220    
;;;221              for(s32 x=0; x<limits.xSize; x++) {
;;;222                const InType pIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;223    
;;;224                pOut1[limits.out1X] = static_cast<Type>( pIn1 );
;;;225    
;;;226                limits.out1X += limits.out1_xInnerIncrement;
;;;227                limits.in1Y += limits.in1_yInnerIncrement;
;;;228              }
;;;229    
;;;230              limits.OuterIncrementBottom();
;;;231            }
;;;232          }
;;;233    
;;;234          return limits.ySize*limits.xSize;
;;;235        }
;;;236    
;;;237        template<typename Type> Array<Type>& ArraySlice<Type>::get_array()
;;;238        {
;;;239          return this->array;
;;;240        }
;;;241    
;;;242        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression()
;;;243          : ConstArraySlice<Type>(), isTransposed(false)
;;;244        {
;;;245        }
;;;246    
;;;247        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const Array<Type> input, bool isTransposed)
;;;248          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;249        {
;;;250        }
;;;251    
;;;252        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed)
;;;253          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;254        {
;;;255        }
;;;256    
;;;257        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed)
;;;258          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;259        {
;;;260        }
;;;261    
;;;262        template<typename Type> ConstArraySliceExpression<Type> ConstArraySliceExpression<Type>::Transpose() const
;;;263        {
;;;264          ConstArraySliceExpression<Type> expression(*this, !this->get_isTransposed());
;;;265    
;;;266          return expression;
;;;267        }
;;;268    
;;;269        template<typename Type> bool ConstArraySliceExpression<Type>::get_isTransposed() const
;;;270        {
;;;271          return isTransposed;
;;;272        }
;;;273    
;;;274        template<typename Type> ArraySliceSimpleLimits<Type>::ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;275          : xStart(in1_xSlice.get_start()), xIncrement(in1_xSlice.get_increment()), xSize(in1_xSlice.get_size()),
;;;276          yStart(in1_ySlice.get_start()), yIncrement(in1_ySlice.get_increment()), ySize(in1_ySlice.get_size())
;;;277        {
;;;278        }
;;;279    
;;;280        template<typename Type> ArraySliceLimits_in1_out0<Type>::ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;281          : isValid(true), rawIn1Limits(in1_ySlice, in1_xSlice)
;;;282        {
;;;283        } // ArraySliceLimits_in1_out0
;;;284    
;;;285        template<typename Type> ArraySliceLimits_in1_out1<Type>::ArraySliceLimits_in1_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;286          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;287          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;288          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed)
;;;289        {
;;;290          isValid = false;
;;;291    
;;;292          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;293    
;;;294          if(!in1_isTransposed) {
;;;295            if(rawOut1Limits.xSize == rawIn1Limits.xSize && rawOut1Limits.ySize == rawIn1Limits.ySize) {
;;;296              isValid = true;
;;;297              isSimpleIteration = true;
;;;298    
;;;299              this->in1Y = this->rawIn1Limits.yStart;
;;;300              this->out1Y = this->rawOut1Limits.yStart;
;;;301    
;;;302              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;303              this->in1_yInnerIncrement = 0;
;;;304            }
;;;305          } else { // if(!in1_isTransposed)
;;;306            if(rawOut1Limits.xSize == rawIn1Limits.ySize && rawOut1Limits.ySize == rawIn1Limits.xSize) {
;;;307              isValid = true;
;;;308              isSimpleIteration = false;
;;;309    
;;;310              this->in1X = this->rawIn1Limits.xStart;
;;;311              this->out1Y = this->rawOut1Limits.yStart;
;;;312    
;;;313              this->in1_xInnerIncrement = 0;
;;;314              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;315            }
;;;316          } // if(!in1_isTransposed) ... else
;;;317    
;;;318          if(!isValid) {
;;;319            AnkiError("ArraySliceLimits_in1_out1", "Subscripted assignment dimension mismatch");
;;;320            return;
;;;321          }
;;;322        } // ArraySliceLimits_in1_out1
;;;323    
;;;324        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;325        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;326        {
;;;327          if(isSimpleIteration) {
;;;328            this->in1X = this->rawIn1Limits.xStart;
;;;329            this->out1X = this->rawOut1Limits.xStart;
;;;330          } else { // if(isSimpleIteration)
;;;331            this->in1Y = this->rawIn1Limits.yStart;
;;;332            this->out1X = this->rawOut1Limits.xStart;
;;;333          } // if(isSimpleIteration) ... else
;;;334        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;335    
;;;336        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;337        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;338        {
;;;339          if(isSimpleIteration) {
;;;340            this->in1Y += this->rawIn1Limits.yIncrement;
;;;341            this->out1Y += this->rawOut1Limits.yIncrement;
;;;342          } else { // if(isSimpleIteration)
;;;343            this->in1X += this->rawIn1Limits.xIncrement;
;;;344            this->out1Y += this->rawOut1Limits.yIncrement;
;;;345          } // if(isSimpleIteration) ... else
;;;346        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;347    
;;;348        template<typename Type> ArraySliceLimits_in2_out1<Type>::ArraySliceLimits_in2_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;349          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;350          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;351          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed),
;;;352          rawIn2Limits(in2_ySlice, in2_xSlice), in2_isTransposed(in2_isTransposed)
;;;353        {
;;;354          isValid = false;
;;;355    
;;;356          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;357          this->in1_yInnerIncrement = 0;
;;;358          this->in1_xInnerIncrement = 0;
;;;359          this->in2_yInnerIncrement = 0;
;;;360          this->in2_xInnerIncrement = 0;
;;;361    
;;;362          if(!in1_isTransposed && !in2_isTransposed) {
;;;363            const bool sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;364    
;;;365            if(sizesMatch) {
;;;366              isValid = true;
;;;367              isSimpleIteration = true;
;;;368    
;;;369              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;370              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;371    
;;;372              this->in1Y = this->rawIn1Limits.yStart;
;;;373              this->in2Y = this->rawIn2Limits.yStart;
;;;374              this->out1Y = this->rawOut1Limits.yStart;
;;;375            }
;;;376          } else { // if(!in1_isTransposed)
;;;377            isSimpleIteration = false;
;;;378    
;;;379            bool sizesMatch = false;
;;;380    
;;;381            if(in1_isTransposed && in2_isTransposed) {
;;;382              sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;383              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;384              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;385            } else if(in1_isTransposed) {
;;;386              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;387              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;388              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;389            } else if(in2_isTransposed) {
;;;390              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;391              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;392              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;393            } else {
;;;394              AnkiAssert(false); // should not be possible
;;;395            }
;;;396    
;;;397            if(!sizesMatch) {
;;;398              AnkiError("ArraySliceLimits_in2_out1", "Subscripted assignment dimension mismatch");
;;;399              return;
;;;400            }
;;;401    
;;;402            isValid = true;
;;;403    
;;;404            this->in1X = this->rawIn1Limits.xStart;
;;;405            this->in1Y = this->rawIn1Limits.yStart;
;;;406            this->in2X = this->rawIn2Limits.xStart;
;;;407            this->in2Y = this->rawIn2Limits.yStart;
;;;408    
;;;409            this->out1Y = this->rawOut1Limits.yStart;
;;;410          } // if(!in1_isTransposed) ... else
;;;411        } // ArraySliceLimits_in1_out1
;;;412    
;;;413        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;414        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;415        {
;;;416          if(isSimpleIteration) {
;;;417            this->out1X = this->rawOut1Limits.xStart;
;;;418            this->in1X = this->rawIn1Limits.xStart;
;;;419            this->in2X = this->rawIn2Limits.xStart;
;;;420          } else { // if(isSimpleIteration)
;;;421            this->out1X = this->rawOut1Limits.xStart;
;;;422    
;;;423            if(in1_isTransposed) {
;;;424              this->in1Y = this->rawIn1Limits.yStart;
;;;425            } else {
;;;426              this->in1X = this->rawIn1Limits.xStart;
;;;427            }
;;;428    
;;;429            if(in2_isTransposed) {
;;;430              this->in2Y = this->rawIn2Limits.yStart;
;;;431            } else {
;;;432              this->in2X = this->rawIn2Limits.xStart;
;;;433            }
;;;434          } // if(isSimpleIteration) ... else
;;;435        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;436    
;;;437        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;438        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;439        {
;;;440          if(isSimpleIteration) {
;;;441            this->in1Y += this->rawIn1Limits.yIncrement;
;;;442            this->in2Y += this->rawIn2Limits.yIncrement;
;;;443            this->out1Y += this->rawOut1Limits.yIncrement;
;;;444          } else { // if(isSimpleIteration)
;;;445            this->out1Y += this->rawOut1Limits.yIncrement;
;;;446    
;;;447            if(in1_isTransposed) {
;;;448              this->in1X += this->rawIn1Limits.xIncrement;
;;;449            } else {
;;;450              this->in1Y += this->rawIn1Limits.yIncrement;
;;;451            }
;;;452    
;;;453            if(in2_isTransposed) {
;;;454              this->in2X += this->rawIn2Limits.xIncrement;
;;;455            } else {
;;;456              this->in2Y += this->rawIn2Limits.yIncrement;
;;;457            }
;;;458          } // if(isSimpleIteration) ... else
;;;459        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;460      } // namespace Embedded
;;;461    } // namespace Anki
;;;462    
;;;463    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;19     #include "anki/common/robot/benchmarking.h"
;;;1      /**
;;;2      File: benchmarkins.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Low-overhead benchmarking, based on a list of start and end events.
;;;7      
;;;8      The basic use of this benchmarking utility is as follows:
;;;9      1. InitBenchmarking()
;;;10     2. At the beginning of the section you want to benchmark, put BeginBenchmark("event type");
;;;11     3. At the end of the section you want to benchmark, put EndBenchmark("event type");
;;;12     4. When you're done running the program, call PrintBenchmarkResults() to print the results
;;;13     
;;;14     Copyright Anki, Inc. 2013
;;;15     For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;16     **/
;;;17     
;;;18     #ifndef _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;19     #define _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     
;;;21     #include "anki/common/robot/config.h"
;;;1      /**
;;;22     #include "anki/common/robot/fixedLengthList_declarations.h"
;;;1      /**
;;;2      File: fixedLengthList_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      A FixedLengthList is like a std::vector, but has a fixed maximum size. This maximum is allocated at contruction.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         class SerializedBuffer;
;;;24     
;;;25         // A FixedLengthList is a list with a fixed maximum size, which is allocated at construction.
;;;26         template<typename Type> class FixedLengthList : public ArraySlice<Type>
;;;27         {
;;;28         public:
;;;29           FixedLengthList();
;;;30     
;;;31           // Constructor for a FixedLengthList, pointing to user-allocated data.
;;;32           FixedLengthList(s32 maximumSize, void * data, s32 dataLength, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;33     
;;;34           // Constructor for a FixedLengthList, pointing to user-allocated MemoryStack
;;;35           FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;36     
;;;37           bool IsValid() const;
;;;38     
;;;39           // Resize will use MemoryStack::Reallocate() to change the FixedLengthList's size. It only works if this
;;;40           // FixedLengthList was the last thing allocated. The reallocated memory will not be cleared
;;;41           //
;;;42           // WARNING:
;;;43           // This will not update any references to the memory, you must update all references manually.
;;;44           Result Resize(s32 maximumSize, MemoryStack &memory);
;;;45     
;;;46           Result PushBack(const Type &value);
;;;47     
;;;48           // Will act as a normal pop, except when the list is empty. Then subsequent
;;;49           // calls will keep returning the first value in the list.
;;;50           Type PopBack();
;;;51     
;;;52           // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
;;;53           inline void Clear();
;;;54     
;;;55           // Does this ever need to be declared explicitly?
;;;56           //FixedLengthList& operator= (const FixedLengthList & rightHandSide);
;;;57     
;;;58           // Pointer to the data, at a given location
;;;59           inline Type* Pointer(const s32 index);
;;;60           inline const Type* Pointer(const s32 index) const;
;;;61     
;;;62           // Use this operator for normal C-style vector indexing. For example, "list[5] = 6;" will set
;;;63           // the element in the fifth row and first column to 6. This is the same as "*list.Pointer(5) =
;;;64           // 6;"
;;;65           //
;;;66           // NOTE:
;;;67           // Using this in a inner loop may be less efficient than using an explicit pointer with a
;;;68           // restrict keyword (Though the runtime cost isn't nearly as large as the [] operator for the
;;;69           // Array class). For speeding up performance-critical inner loops, use something like: "Type *
;;;70           // restrict pList = list.Pointer(0);" outside the inner loop, then index
;;;71           // pList in the inner loop.
;;;72           inline const Type& operator[](const s32 index) const;
;;;73           inline Type& operator[](const s32 index);
;;;74     
;;;75           // Print out the contents of this FixedLengthList
;;;76           Result Print(const char * const variableName = "FixedLengthList", const s32 minIndex = 0, const s32 maxIndex = 0x7FFFFFE) const;
;;;77     
;;;78           // Set every element in the Array to zero, including the stride padding, but not including the optional fill patterns (if they exist)
;;;79           // Returns the number of bytes set to zero
;;;80           inline s32 SetZero();
;;;81     
;;;82           // Read in the input, then cast it to this object's type
;;;83           //
;;;84           // WARNING:
;;;85           // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;86           template<typename InType> s32 SetCast(const FixedLengthList<InType> &input, bool automaticTranspose=true);
;;;87           //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;88     
;;;89           // The maximum size is set at object construction
;;;90           inline s32 get_maximumSize() const;
;;;91     
;;;92           // The current size changes as the FixedLengthList is used
;;;93           inline s32 get_size() const;
;;;94     
;;;95           // Attempt to set the size to newSize. Returns the value that was actually set.
;;;96           s32 set_size(s32 newSize);
;;;97     
;;;98         protected:
;;;99           // TODO: make less hacky
;;;100          friend class SerializedBuffer;
;;;101        }; // class FixedLengthList
;;;102      } // namespace Embedded
;;;103    } //namespace Anki
;;;104    
;;;105    #endif // _ANKICORETECHEMBEDDED_COMMON_FIXEDLENGTHLIST_DECLARATIONS_H_
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         const s32 MAX_BENCHMARK_EVENTS = 16000;
;;;29     
;;;30         typedef struct BenchmarkElement
;;;31         {
;;;32           // All times in microseconds, on all platforms
;;;33     
;;;34           static const s32 NAME_LENGTH = 64;
;;;35     
;;;36           // Inclusive includes all the time for all sub-benchmarks
;;;37           u32 inclusive_mean;
;;;38           u32 inclusive_min;
;;;39           u32 inclusive_max;
;;;40           u32 inclusive_total;
;;;41     
;;;42           // Exclusive does not include sub-benchmarks
;;;43           u32 exclusive_mean;
;;;44           u32 exclusive_min;
;;;45           u32 exclusive_max;
;;;46           u32 exclusive_total;
;;;47     
;;;48           // How many times was this element's name benchmarked?
;;;49           u32 numEvents;
;;;50     
;;;51           char name[BenchmarkElement::NAME_LENGTH];
;;;52     
;;;53           BenchmarkElement(const char * name);
;;;54     
;;;55           // Print with CoreTechPrint()
;;;56           void Print(const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;57     
;;;58           // Like snprintf(). Returns the number of characters printed, not including the final null byte.
;;;59           s32 Snprint(char * buffer, const s32 bufferLength, const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;60         } BenchmarkElement;
;;;61     
;;;62         typedef struct ShowBenchmarkParameters
;;;63         {
;;;64           char name[BenchmarkElement::NAME_LENGTH];
;;;65           bool showExclusiveTime;
;;;66           u8 red, green, blue;
;;;67     
;;;68           ShowBenchmarkParameters(
;;;69             const char * name,
;;;70             const bool showExclusiveTime,
;;;71             const u8 *color); //< Color is {R,G,B}
;;;72         } ShowBenchmarkParameters;
;;;73     
;;;74         // Call this before doing any benchmarking, to clear the buffer of benchmarkEvents.
;;;75         // Can be called multiple times.
;;;76         void InitBenchmarking();
;;;77     
;;;78         // Use these functions to add a new event to the list. These functions are very fast.
;;;79         //
;;;80         // WARNING: name must be in globally available memory
;;;81         //
;;;82         // WARNING: the character string must be less than BenchmarkElement::NAME_LENGTH bytes
;;;83         //
;;;84         // WARNING: Using the same name for different benchmark events
;;;85         //
;;;86         // WARNING: nesting BeginBenchmark() and EndBenchmark() events that have the same name won't work.
;;;87         // This is okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("b"); EndBenchmark("a");
;;;88         // This is not okay: BeginBenchmark("a"); BeginBenchmark("a"); EndBenchmark("a"); EndBenchmark("a");
;;;89         // This is not okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("a"); EndBenchmark("b");
;;;90         void BeginBenchmark(const char *name);
;;;91         void EndBenchmark(const char *name);
;;;92     
;;;93         // Compile all the benchmark events that were recorded
;;;94         FixedLengthList<BenchmarkElement> ComputeBenchmarkResults(MemoryStack &memory);
;;;95     
;;;96         // CoreTechPrint() the benchmark results
;;;97         // WARNING: This doesn't work well with multi-threaded programs
;;;98         Result PrintBenchmarkResults(const FixedLengthList<BenchmarkElement> &results, const bool verbose=true, const bool microseconds=true);
;;;99     
;;;100        // Compile and print out all the benchmark events that were recorded
;;;101        Result ComputeAndPrintBenchmarkResults(const bool verbose, const bool microseconds, MemoryStack scratch);
;;;102    
;;;103        // Use OpenCV to display a running benchmark
;;;104        // Requires a "TotalTime" benchmark event
;;;105        // namesToDisplay can be 11 or less names
;;;106        Result ShowBenchmarkResults(
;;;107          const FixedLengthList<BenchmarkElement> &results,
;;;108          const FixedLengthList<ShowBenchmarkParameters> &namesToDisplay,
;;;109          const f32 pixelsPerMillisecond,
;;;110          const s32 imageHeight,
;;;111          const s32 imageWidth);
;;;112    
;;;113        s32 GetNameIndex(const char * name, const FixedLengthList<BenchmarkElement> &outputResults);
;;;114      } // namespace Embedded
;;;115    } // namespace Anki
;;;116    
;;;117    #endif // _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     #include "anki/common/robot/comparisons.h"
;;;1      /**
;;;2      File: comparisons.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of comparisons_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;14     
;;;15     #include "anki/common/robot/comparisons_declarations.h"
;;;1      /**
;;;2      File: comparisons_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various elementwise tests, to ensure that the data of two Arrays is equal.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Declarations ---
;;;23         // Check every element of this array against the input array. If the arrays are different
;;;24         // sizes, uninitialized, or if any element is more different than the threshold, then
;;;25         // return false.
;;;26         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold = static_cast<Type>(0.0001));
;;;27     
;;;28         // Check every element of this array against the input array. If the arrays are different
;;;29         // sizes or uninitialized, return false. The percentThreshold is between 0.0 and 1.0. To
;;;30         // return false, an element must fail both thresholds. The percent threshold fails if an
;;;31         // element is more than a percentage different than its matching element (calulated from the
;;;32         // maximum of the two).
;;;33         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold = 0.01, const double absoluteThreshold = 0.0001);
;;;34     
;;;35         // If any of the input objects are not valid, then return false
;;;36         // NOTE: the objects must have an IsValid() method
;;;37         template<typename Type1> bool AreValid(const Type1 &object1);
;;;38         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2);
;;;39         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;40         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;41         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;42         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;43         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;44         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;45         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;46     
;;;47         // If the objects have different sizes or are uninitialized, then return false.
;;;48         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;49         template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2);
;;;50         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;51         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;52         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;53         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;54         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;55         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;56         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;57     
;;;58         // Check sizes against an input height and width
;;;59         template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1);
;;;60         template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2);
;;;61         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;62         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;63         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;64         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;65         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;66         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;67         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;68     
;;;69         // If the Arrays are aliased (pointing to the same location in memory) or uninitialized, then return false
;;;70         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;71         template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2);
;;;72         template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;73         template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;74         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;75         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;76         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;77         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;78         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;79       } // namespace Embedded
;;;80     } // namespace Anki
;;;81     
;;;82     #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark
;;;23     
;;;24         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold)
;;;25         {
;;;26           if(!AreEqualSize(array1, array2))
;;;27             return false;
;;;28     
;;;29           const s32 height = array1.get_size(0);
;;;30           const s32 width = array1.get_size(1);
;;;31     
;;;32           for(s32 y=0; y<height; y++) {
;;;33             const Type * const pArray1 = array1.Pointer(y, 0);
;;;34             const Type * const pArray2 = array2.Pointer(y, 0);
;;;35             for(s32 x=0; x<width; x++) {
;;;36               if(pArray1[x] > pArray2[x]) {
;;;37                 if((pArray1[x] - pArray2[x]) > threshold)
;;;38                   return false;
;;;39               } else {
;;;40                 if((pArray2[x] - pArray1[x]) > threshold)
;;;41                   return false;
;;;42               }
;;;43             }
;;;44           }
;;;45     
;;;46           return true;
;;;47         }
;;;48     
;;;49         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold, const double absoluteThreshold)
;;;50         {
;;;51           if(!AreEqualSize(array1, array2))
;;;52             return false;
;;;53     
;;;54           const s32 height = array1.get_size(0);
;;;55           const s32 width = array1.get_size(1);
;;;56     
;;;57           for(s32 y=0; y<height; y++) {
;;;58             const Type * const pArray1 = array1.Pointer(y, 0);
;;;59             const Type * const pArray2 = array2.Pointer(y, 0);
;;;60             for(s32 x=0; x<width; x++) {
;;;61               const double value1 = static_cast<double>(pArray1[x]);
;;;62               const double value2 = static_cast<double>(pArray2[x]);
;;;63               const double percentThresholdValue = percentThreshold * MAX(value1,value2);
;;;64     
;;;65               if(fabs(value1 - value2) > percentThresholdValue && fabs(value1 - value2) > absoluteThreshold)
;;;66                 return false;
;;;67             }
;;;68           }
;;;69     
;;;70           return true;
;;;71         }
;;;72     
;;;73         template<typename Type1> bool AreValid(const Type1 &object1)
;;;74         {
;;;75           if(!object1.IsValid())
;;;76             return false;
;;;77     
;;;78           return true;
;;;79         }
;;;80     
;;;81         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2)
;;;82         {
;;;83           if(!object1.IsValid() || !object2.IsValid())
;;;84             return false;
;;;85     
;;;86           return true;
;;;87         }
;;;88     
;;;89         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;90         {
;;;91           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid())
;;;92             return false;
;;;93     
;;;94           return true;
;;;95         }
;;;96     
;;;97         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;98         {
;;;99           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid())
;;;100            return false;
;;;101    
;;;102          return true;
;;;103        }
;;;104    
;;;105        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;106        {
;;;107          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid())
;;;108            return false;
;;;109    
;;;110          return true;
;;;111        }
;;;112    
;;;113        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;114        {
;;;115          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid())
;;;116            return false;
;;;117    
;;;118          return true;
;;;119        }
;;;120    
;;;121        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;122        {
;;;123          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid())
;;;124            return false;
;;;125    
;;;126          return true;
;;;127        }
;;;128    
;;;129        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;130        {
;;;131          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid())
;;;132            return false;
;;;133    
;;;134          return true;
;;;135        }
;;;136    
;;;137        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;138        {
;;;139          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid() || !object9.IsValid())
;;;140            return false;
;;;141    
;;;142          return true;
;;;143        }
;;;144    
;;;145        template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2)
;;;146        {
;;;147          if(!AreValid(object1, object2))
;;;148            return false;
;;;149    
;;;150          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1))
;;;151            return false;
;;;152    
;;;153          return true;
;;;154        }
;;;155    
;;;156        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;157        {
;;;158          if(!AreValid(object1, object2, object3))
;;;159            return false;
;;;160    
;;;161          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;162            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1))
;;;163            return false;
;;;164    
;;;165          return true;
;;;166        }
;;;167    
;;;168        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;169        {
;;;170          if(!AreValid(object1, object2, object3, object4))
;;;171            return false;
;;;172    
;;;173          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;174            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;175            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1))
;;;176            return false;
;;;177    
;;;178          return true;
;;;179        }
;;;180    
;;;181        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;182        {
;;;183          if(!AreValid(object1, object2, object3, object4, object5))
;;;184            return false;
;;;185    
;;;186          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;187            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;188            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;189            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1))
;;;190            return false;
;;;191    
;;;192          return true;
;;;193        }
;;;194    
;;;195        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;196        {
;;;197          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;198            return false;
;;;199    
;;;200          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;201            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;202            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;203            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;204            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1))
;;;205            return false;
;;;206    
;;;207          return true;
;;;208        }
;;;209    
;;;210        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;211        {
;;;212          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;213            return false;
;;;214    
;;;215          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;216            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;217            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;218            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;219            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;220            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1))
;;;221            return false;
;;;222    
;;;223          return true;
;;;224        }
;;;225    
;;;226        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;227        {
;;;228          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;229            return false;
;;;230    
;;;231          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;232            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;233            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;234            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;235            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;236            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;237            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1))
;;;238            return false;
;;;239    
;;;240          return true;
;;;241        }
;;;242    
;;;243        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;244        {
;;;245          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;246            return false;
;;;247    
;;;248          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;249            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;250            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;251            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;252            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;253            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;254            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1) ||
;;;255            object1.get_size(0) != object9.get_size(0) || object1.get_size(1) != object9.get_size(1))
;;;256            return false;
;;;257    
;;;258          return true;
;;;259        }
;;;260    
;;;261        template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1)
;;;262        {
;;;263          if(!AreValid(object1))
;;;264            return false;
;;;265    
;;;266          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;267            return false;
;;;268    
;;;269          return true;
;;;270        }
;;;271    
;;;272        template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2)
;;;273        {
;;;274          if(!AreValid(object1, object2))
;;;275            return false;
;;;276    
;;;277          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;278            return false;
;;;279    
;;;280          return AreEqualSize(object1, object2);
;;;281        }
;;;282    
;;;283        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;284        {
;;;285          if(!AreValid(object1, object2, object3))
;;;286            return false;
;;;287    
;;;288          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;289            return false;
;;;290    
;;;291          return AreEqualSize(object1, object2, object3);
;;;292        }
;;;293    
;;;294        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;295        {
;;;296          if(!AreValid(object1, object2, object3, object4))
;;;297            return false;
;;;298    
;;;299          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;300            return false;
;;;301    
;;;302          return AreEqualSize(object1, object2, object3, object4);
;;;303        }
;;;304    
;;;305        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;306        {
;;;307          if(!AreValid(object1, object2, object3, object4, object5))
;;;308            return false;
;;;309    
;;;310          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;311            return false;
;;;312    
;;;313          return AreEqualSize(object1, object2, object3, object4, object5);
;;;314        }
;;;315    
;;;316        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;317        {
;;;318          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;319            return false;
;;;320    
;;;321          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;322            return false;
;;;323    
;;;324          return AreEqualSize(object1, object2, object3, object4, object5, object6);
;;;325        }
;;;326    
;;;327        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;328        {
;;;329          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;330            return false;
;;;331    
;;;332          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;333            return false;
;;;334    
;;;335          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7);
;;;336        }
;;;337    
;;;338        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;339        {
;;;340          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;341            return false;
;;;342    
;;;343          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;344            return false;
;;;345    
;;;346          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8);
;;;347        }
;;;348    
;;;349        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;350        {
;;;351          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;352            return false;
;;;353    
;;;354          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;355            return false;
;;;356    
;;;357          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8, object9);
;;;358        }
;;;359    
;;;360        template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2)
;;;361        {
;;;362          if(!AreValid(object1, object2))
;;;363            return false;
;;;364    
;;;365          const size_t bufferPointers[] = {
;;;366            reinterpret_cast<size_t>(object1.get_buffer()),
;;;367            reinterpret_cast<size_t>(object2.get_buffer())};
;;;368    
;;;369          for(s32 i=0; i<2; i++) {
;;;370            for(s32 j=i+1; j<2; j++) {
;;;371              if(bufferPointers[i] == bufferPointers[j])
;;;372                return false;
;;;373            }
;;;374          }
;;;375    
;;;376          return true;
;;;377        }
;;;378    
;;;379        template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;380        {
;;;381          if(!AreValid(object1, object2, object3))
;;;382            return false;
;;;383    
;;;384          const size_t bufferPointers[] = {
;;;385            reinterpret_cast<size_t>(object1.get_buffer()),
;;;386            reinterpret_cast<size_t>(object2.get_buffer()),
;;;387            reinterpret_cast<size_t>(object3.get_buffer())};
;;;388    
;;;389          for(s32 i=0; i<3; i++) {
;;;390            for(s32 j=i+1; j<3; j++) {
;;;391              if(bufferPointers[i] == bufferPointers[j])
;;;392                return false;
;;;393            }
;;;394          }
;;;395    
;;;396          return true;
;;;397        }
;;;398    
;;;399        template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;400        {
;;;401          if(!AreValid(object1, object2, object3, object4))
;;;402            return false;
;;;403    
;;;404          const size_t bufferPointers[] = {
;;;405            reinterpret_cast<size_t>(object1.get_buffer()),
;;;406            reinterpret_cast<size_t>(object2.get_buffer()),
;;;407            reinterpret_cast<size_t>(object3.get_buffer()),
;;;408            reinterpret_cast<size_t>(object4.get_buffer())};
;;;409    
;;;410          for(s32 i=0; i<4; i++) {
;;;411            for(s32 j=i+1; j<4; j++) {
;;;412              if(bufferPointers[i] == bufferPointers[j])
;;;413                return false;
;;;414            }
;;;415          }
;;;416    
;;;417          return true;
;;;418        }
;;;419    
;;;420        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;421        {
;;;422          if(!AreValid(object1, object2, object3, object4, object5))
;;;423            return false;
;;;424    
;;;425          const size_t bufferPointers[] = {
;;;426            reinterpret_cast<size_t>(object1.get_buffer()),
;;;427            reinterpret_cast<size_t>(object2.get_buffer()),
;;;428            reinterpret_cast<size_t>(object3.get_buffer()),
;;;429            reinterpret_cast<size_t>(object4.get_buffer()),
;;;430            reinterpret_cast<size_t>(object5.get_buffer())};
;;;431    
;;;432          for(s32 i=0; i<5; i++) {
;;;433            for(s32 j=i+1; j<5; j++) {
;;;434              if(bufferPointers[i] == bufferPointers[j])
;;;435                return false;
;;;436            }
;;;437          }
;;;438    
;;;439          return true;
;;;440        }
;;;441    
;;;442        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;443        {
;;;444          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;445            return false;
;;;446    
;;;447          const size_t bufferPointers[] = {
;;;448            reinterpret_cast<size_t>(object1.get_buffer()),
;;;449            reinterpret_cast<size_t>(object2.get_buffer()),
;;;450            reinterpret_cast<size_t>(object3.get_buffer()),
;;;451            reinterpret_cast<size_t>(object4.get_buffer()),
;;;452            reinterpret_cast<size_t>(object5.get_buffer()),
;;;453            reinterpret_cast<size_t>(object6.get_buffer())};
;;;454    
;;;455          for(s32 i=0; i<6; i++) {
;;;456            for(s32 j=i+1; j<6; j++) {
;;;457              if(bufferPointers[i] == bufferPointers[j])
;;;458                return false;
;;;459            }
;;;460          }
;;;461    
;;;462          return true;
;;;463        }
;;;464    
;;;465        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;466        {
;;;467          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;468            return false;
;;;469    
;;;470          const size_t bufferPointers[] = {
;;;471            reinterpret_cast<size_t>(object1.get_buffer()),
;;;472            reinterpret_cast<size_t>(object2.get_buffer()),
;;;473            reinterpret_cast<size_t>(object3.get_buffer()),
;;;474            reinterpret_cast<size_t>(object4.get_buffer()),
;;;475            reinterpret_cast<size_t>(object5.get_buffer()),
;;;476            reinterpret_cast<size_t>(object6.get_buffer()),
;;;477            reinterpret_cast<size_t>(object7.get_buffer())};
;;;478    
;;;479          for(s32 i=0; i<7; i++) {
;;;480            for(s32 j=i+1; j<7; j++) {
;;;481              if(bufferPointers[i] == bufferPointers[j])
;;;482                return false;
;;;483            }
;;;484          }
;;;485    
;;;486          return true;
;;;487        }
;;;488    
;;;489        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;490        {
;;;491          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;492            return false;
;;;493    
;;;494          const size_t bufferPointers[] = {
;;;495            reinterpret_cast<size_t>(object1.get_buffer()),
;;;496            reinterpret_cast<size_t>(object2.get_buffer()),
;;;497            reinterpret_cast<size_t>(object3.get_buffer()),
;;;498            reinterpret_cast<size_t>(object4.get_buffer()),
;;;499            reinterpret_cast<size_t>(object5.get_buffer()),
;;;500            reinterpret_cast<size_t>(object6.get_buffer()),
;;;501            reinterpret_cast<size_t>(object7.get_buffer()),
;;;502            reinterpret_cast<size_t>(object8.get_buffer())};
;;;503    
;;;504          for(s32 i=0; i<8; i++) {
;;;505            for(s32 j=i+1; j<8; j++) {
;;;506              if(bufferPointers[i] == bufferPointers[j])
;;;507                return false;
;;;508            }
;;;509          }
;;;510    
;;;511          return true;
;;;512        }
;;;513    
;;;514        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;515        {
;;;516          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;517            return false;
;;;518    
;;;519          const size_t bufferPointers[] = {
;;;520            reinterpret_cast<size_t>(object1.get_buffer()),
;;;521            reinterpret_cast<size_t>(object2.get_buffer()),
;;;522            reinterpret_cast<size_t>(object3.get_buffer()),
;;;523            reinterpret_cast<size_t>(object4.get_buffer()),
;;;524            reinterpret_cast<size_t>(object5.get_buffer()),
;;;525            reinterpret_cast<size_t>(object6.get_buffer()),
;;;526            reinterpret_cast<size_t>(object7.get_buffer()),
;;;527            reinterpret_cast<size_t>(object8.get_buffer()),
;;;528            reinterpret_cast<size_t>(object9.get_buffer()) };
;;;529    
;;;530          for(s32 i=0; i<9; i++) {
;;;531            for(s32 j=i+1; j<9; j++) {
;;;532              if(bufferPointers[i] == bufferPointers[j])
;;;533                return false;
;;;534            }
;;;535          }
;;;536    
;;;537          return true;
;;;538        }
;;;539      } // namespace Embedded
;;;540    } // namespace Anki
;;;541    
;;;542    #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26         namespace Matrix
;;;27         {
;;;28           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;29           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;30           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;31           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;32     
;;;33           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;34           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;35           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;36           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;37     
;;;38           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;39           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;40           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;41           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;42     
;;;43           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;44           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;45           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;46           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;47     
;;;48           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;49           {
;;;50             const Array<Type> &array = mat.get_array();
;;;51     
;;;52             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;53               0, "Matrix::Min", "Array<Type> is not valid");
;;;54     
;;;55             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;56     
;;;57             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;58               0, "Matrix::Min", "Limits is not valid");
;;;59     
;;;60             Type minValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;61             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;62               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;63               const Type * restrict pMat = array.Pointer(y, 0);
;;;64     
;;;65               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;66                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;67                 minValue = MIN(minValue, pMat[x]);
;;;68               }
;;;69             }
;;;70     
;;;71             return minValue;
;;;72           } // template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;73     
;;;74           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;75           {
;;;76             const Array<Type> &array = mat.get_array();
;;;77     
;;;78             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;79               0, "Matrix::Max", "Array<Type> is not valid");
;;;80     
;;;81             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;82     
;;;83             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;84               0, "Matrix::Max", "Limits is not valid");
;;;85     
;;;86             Type maxValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;87             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;88               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;89               const Type * restrict pMat = array.Pointer(y, 0);
;;;90     
;;;91               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;92                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;93                 maxValue = MAX(maxValue, pMat[x]);
;;;94               }
;;;95             }
;;;96     
;;;97             return maxValue;
;;;98           } // template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;99     
;;;100          template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat)
;;;101          {
;;;102            const Array<Array_Type> &array = mat.get_array();
;;;103    
;;;104            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;105              0, "Matrix::Sum", "Array<Type> is not valid");
;;;106    
;;;107            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;108    
;;;109            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;110              0, "Matrix::Sum", "Limits is not valid");
;;;111    
;;;112            Accumulator_Type sum = 0;
;;;113            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;114              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;115              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;116    
;;;117              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;118                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;119                sum += pMat[x];
;;;120              }
;;;121            }
;;;122    
;;;123            return sum;
;;;124          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;125    
;;;126          template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;127          {
;;;128            const Accumulator_Type sum = Sum<Array_Type,Accumulator_Type>(mat);
;;;129            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;130            const Array_Type mean = static_cast<Array_Type>(sum / numElements);
;;;131    
;;;132            return mean;
;;;133          } // template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;134    
;;;135          template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(
;;;136            const ConstArraySliceExpression<Array_Type> &mat,
;;;137            Accumulator_Type& mean,
;;;138            Accumulator_Type& var)
;;;139          {
;;;140            const Array<Array_Type> &array = mat.get_array();
;;;141    
;;;142            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;143              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Array<Type> is not valid");
;;;144    
;;;145            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;146    
;;;147            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;148              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Limits is not valid");
;;;149    
;;;150            Accumulator_Type sum = 0;
;;;151            Accumulator_Type sumSq = 0;
;;;152            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;153              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;154              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;155    
;;;156              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;157                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;158                const Accumulator_Type val = static_cast<Accumulator_Type>(pMat[x]);
;;;159                sum   += val;
;;;160                sumSq += val*val;
;;;161              }
;;;162            }
;;;163    
;;;164            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;165    
;;;166            mean = sum / numElements;                  // mean = E[x]
;;;167            var  = (sumSq / numElements) - (mean*mean);  // var  = E[x^2] - E[x]^2
;;;168    
;;;169            return RESULT_OK;
;;;170          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;171    
;;;172          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;173          {
;;;174            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;175          } // template<typename Type> Result Add(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;176    
;;;177          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;178          {
;;;179            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;180          }
;;;181    
;;;182          template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;183          {
;;;184            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;185          }
;;;186    
;;;187          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;188          {
;;;189            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;190          } // template<typename Type> Result Subtract(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;191    
;;;192          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;193          {
;;;194            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;195          }
;;;196    
;;;197          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;198          {
;;;199            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;200          }
;;;201    
;;;202          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;203          {
;;;204            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;205          } // template<typename Type> Result DotMultiply(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;206    
;;;207          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;208          {
;;;209            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;210          }
;;;211    
;;;212          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;213          {
;;;214            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;215          }
;;;216    
;;;217          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;218          {
;;;219            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;220          } // template<typename Type> Result DotDivide(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;221    
;;;222          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;223          {
;;;224            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;225          }
;;;226    
;;;227          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;228          {
;;;229            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;230          }
;;;231    
;;;232          template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;233          {
;;;234            return Elementwise::ApplyOperation<InType, Elementwise::Exp<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;235          } // template<typename Type> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;236    
;;;237          template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;238          {
;;;239            return Elementwise::ApplyOperation<InType, Elementwise::Sqrt<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;240          }
;;;241    
;;;242          template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;243          {
;;;244            const s32 in1Height = in1.get_size(0);
;;;245            const s32 in1Width = in1.get_size(1);
;;;246    
;;;247            const s32 in2Height = in2.get_size(0);
;;;248            const s32 in2Width = in2.get_size(1);
;;;249            const s32 in2Stride = in2.get_stride();
;;;250    
;;;251            AnkiConditionalErrorAndReturnValue(in1Width == in2Height,
;;;252              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;253    
;;;254            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2Width, out),
;;;255              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;256    
;;;257            for(s32 y1=0; y1<in1Height; y1++) {
;;;258              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;259              OutType * restrict pOut = out.Pointer(y1, 0);
;;;260    
;;;261              for(s32 x2=0; x2<in2Width; x2++) {
;;;262                const u8 * restrict pIn2 = reinterpret_cast<const u8*>(in2.Pointer(0, x2));
;;;263    
;;;264                OutType accumulator = 0;
;;;265    
;;;266                s32 y2;
;;;267                for(y2=0; y2<in2Height-3; y2+=4) {
;;;268                  const InType in1_0 = pIn1[y2];
;;;269                  const InType in1_1 = pIn1[y2+1];
;;;270                  const InType in1_2 = pIn1[y2+2];
;;;271                  const InType in1_3 = pIn1[y2+3];
;;;272    
;;;273                  const InType in2_0 = *reinterpret_cast<const InType*>(pIn2);
;;;274                  const InType in2_1 = *reinterpret_cast<const InType*>(pIn2 + in2Stride);
;;;275                  const InType in2_2 = *reinterpret_cast<const InType*>(pIn2 + 2*in2Stride);
;;;276                  const InType in2_3 = *reinterpret_cast<const InType*>(pIn2 + 3*in2Stride);
;;;277    
;;;278                  accumulator +=
;;;279                    in1_0 * in2_0 +
;;;280                    in1_1 * in2_1 +
;;;281                    in1_2 * in2_2 +
;;;282                    in1_3 * in2_3;
;;;283    
;;;284                  pIn2 += 4*in2Stride;
;;;285                }
;;;286    
;;;287                for(; y2<in2Height; y2++) {
;;;288                  accumulator += pIn1[y2] * (*reinterpret_cast<const InType*>(pIn2));
;;;289    
;;;290                  pIn2 += in2Stride;
;;;291                }
;;;292    
;;;293                pOut[x2] = accumulator;
;;;294              }
;;;295            }
;;;296    
;;;297            return RESULT_OK;
;;;298          } // template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;299    
;;;300          template<typename InType, typename OutType> NO_INLINE Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;301          {
;;;302            const s32 in1Height = in1.get_size(0);
;;;303            const s32 in1Width = in1.get_size(1);
;;;304    
;;;305            const s32 in2TransposedHeight = in2Transposed.get_size(0);
;;;306            const s32 in2TransposedWidth = in2Transposed.get_size(1);
;;;307    
;;;308            AnkiConditionalErrorAndReturnValue(in1Width == in2TransposedWidth,
;;;309              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;310    
;;;311            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2TransposedHeight, out),
;;;312              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;313    
;;;314            for(s32 y1=0; y1<in1Height; y1++)
;;;315            {
;;;316              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;317    
;;;318              for(s32 y2=0; y2<in2TransposedHeight; y2++) {
;;;319                const InType * restrict pIn2 = in2Transposed.Pointer(y2, 0);
;;;320    
;;;321                OutType accumulator = 0;
;;;322    
;;;323                s32 x;
;;;324                for(x=0; x<in2TransposedWidth-3; x+=4) {
;;;325                  const InType in1_0 = pIn1[x];
;;;326                  const InType in1_1 = pIn1[x+1];
;;;327                  const InType in1_2 = pIn1[x+2];
;;;328                  const InType in1_3 = pIn1[x+3];
;;;329    
;;;330                  const InType in2_0 = pIn2[x];
;;;331                  const InType in2_1 = pIn2[x+1];
;;;332                  const InType in2_2 = pIn2[x+2];
;;;333                  const InType in2_3 = pIn2[x+3];
;;;334    
;;;335                  accumulator +=
;;;336                    in1_0 * in2_0 +
;;;337                    in1_1 * in2_1 +
;;;338                    in1_2 * in2_2 +
;;;339                    in1_3 * in2_3;
;;;340                }
;;;341    
;;;342                for(; x<in2TransposedWidth; x++) {
;;;343                  accumulator += pIn1[x] * pIn2[x];
;;;344                }
;;;345    
;;;346                *out.Pointer(y1, y2) = accumulator;
;;;347              }
;;;348            }
;;;349    
;;;350            return RESULT_OK;
;;;351          } // template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;352    
;;;353          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;354            Array<Type> &A_L,       //!< Input A Matrix and Output lower-triangular L matrix
;;;355            Array<Type> &Bt_Xt,     //!< Input B-transpose matrix and Output X-transpose solution
;;;356            bool realCholesky,      //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;357            bool &numericalFailure  //!< If true, the solver failed because of numerical instability
;;;358            )
;;;359          {
;;;360            const s32 matrixHeight = A_L.get_size(0);
;;;361            const s32 numSamples = Bt_Xt.get_size(0);
;;;362    
;;;363            numericalFailure = false;
;;;364    
;;;365            AnkiConditionalErrorAndReturnValue(AreValid(A_L, Bt_Xt),
;;;366              RESULT_FAIL_INVALID_OBJECT, "CholeskyDecomposition", "Invalid objects");
;;;367    
;;;368            AnkiConditionalErrorAndReturnValue(matrixHeight == A_L.get_size(1),
;;;369              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "A_L is not square");
;;;370    
;;;371            AnkiConditionalErrorAndReturnValue(Bt_Xt.get_size(1) == matrixHeight,
;;;372              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "Xt and Bt are the wrong sizes");
;;;373    
;;;374            // TODO: check if symmetric and positive-definite
;;;375    
;;;376            const Type minStableValue = Anki::Embedded::Flags::numeric_limits<Type>::epsilon();
;;;377    
;;;378            for(s32 i = 0; i < matrixHeight; i++) {
;;;379              // First, compute the non-diagonal values
;;;380              // This uses the results from the diagonal inverse computation from previous iterations of i
;;;381              Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;382    
;;;383              for(s32 j = 0; j < i; j++) {
;;;384                Type * restrict pAL_yj = A_L.Pointer(j, 0);
;;;385    
;;;386                Type sum = pAL_yi[j];
;;;387                for(s32 k = 0; k < j; k++) {
;;;388                  const Type value1 = pAL_yi[k];
;;;389                  const Type value2 = pAL_yj[k];
;;;390                  sum -= value1*value2;
;;;391                }
;;;392    
;;;393                pAL_yi[j] = sum*pAL_yj[j];
;;;394              } // for(s32 j = 0; j < i; j++)
;;;395    
;;;396              // Second, compute the inverse of the diagonal
;;;397              {
;;;398                Type sum = pAL_yi[i];
;;;399                for(s32 k = 0; k < i; k++) {
;;;400                  const Type value = pAL_yi[k];
;;;401                  sum -= value*value;
;;;402                }
;;;403    
;;;404                if(sum < minStableValue) {
;;;405                  numericalFailure = true;
;;;406                  return RESULT_OK;
;;;407                }
;;;408    
;;;409                // TODO: change this f32 square root to f64 if Type==f64
;;;410                const Type sumRoot = static_cast<Type>(sqrtf(static_cast<f32>(sum)));
;;;411                pAL_yi[i] = static_cast<Type>(1) / sumRoot;
;;;412              }
;;;413            } // for(s32 i = 0; i < m; i++)
;;;414    
;;;415            // Solve L*y = b via forward substitution
;;;416            for(s32 i = 0; i < matrixHeight; i++) {
;;;417              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;418              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;419    
;;;420              for(s32 j = 0; j < numSamples; j++) {
;;;421                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;422    
;;;423                Type sum = pBX_yj[i];
;;;424                for(s32 k = 0; k < i; k++) {
;;;425                  const Type value1 = pAL_yi[k];
;;;426                  const Type value2 = pBX_yj[k];
;;;427                  sum -= value1*value2;
;;;428                }
;;;429    
;;;430                pBX_yj[i] = sum*pAL_yi[i];
;;;431              }
;;;432            }
;;;433    
;;;434            // Solve L'*X = Y via back substitution
;;;435            for(s32 i = matrixHeight-1; i >= 0; i--) {
;;;436              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;437              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;438    
;;;439              for(s32 j = 0; j < numSamples; j++) {
;;;440                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;441    
;;;442                Type sum = pBX_yj[i];
;;;443                for(s32 k = matrixHeight-1; k > i; k-- ) {
;;;444                  const Type value1 = A_L[k][i];
;;;445                  const Type value2 = pBX_yj[k];
;;;446                  sum -= value1*value2;
;;;447                }
;;;448    
;;;449                pBX_yj[i] = sum*pAL_yi[i];
;;;450              }
;;;451            }
;;;452    
;;;453            if(realCholesky) {
;;;454              // Invert the diagonal values of L, and set upper triangular to zero
;;;455              for(s32 i = 0; i < matrixHeight; i++) {
;;;456                Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;457    
;;;458                pAL_yi[i] = static_cast<Type>(1) / pAL_yi[i];
;;;459    
;;;460                for(s32 j = i+1; j < matrixHeight; j++) {
;;;461                  pAL_yi[j] = 0;
;;;462                }
;;;463              }
;;;464            }
;;;465    
;;;466            return RESULT_OK;
;;;467          } // SolveLeastSquaresWithCholesky()
;;;468    
;;;469          template<typename Type> NO_INLINE Result EstimateHomography(
;;;470            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;471            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;472            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;473            bool &numericalFailure, //!< Did the homography solver fail?
;;;474            MemoryStack scratch //!< Scratch memory
;;;475            )
;;;476          {
;;;477            const Type MAX_SOLVE_DISTANCE = static_cast<Type>(0.1);
;;;478    
;;;479            //BeginBenchmark("EstimateHomography_init");
;;;480    
;;;481            const s32 numPoints = originalPoints.get_size();
;;;482    
;;;483            AnkiConditionalErrorAndReturnValue(AreValid(originalPoints, transformedPoints, homography, scratch),
;;;484              RESULT_FAIL_INVALID_OBJECT, "EstimateHomography", "Invalid objects");
;;;485    
;;;486            AnkiConditionalErrorAndReturnValue(transformedPoints.get_size() == numPoints && numPoints >= 4,
;;;487              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "originalPoints and transformedPoints must be the same size, and have at least four points apiece.");
;;;488    
;;;489            AnkiConditionalErrorAndReturnValue(AreEqualSize(3, 3, homography),
;;;490              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "homography must be 3x3");
;;;491    
;;;492            homography.SetZero();
;;;493            homography[0][0] = 1;
;;;494            homography[1][1] = 1;
;;;495            homography[2][2] = 1;
;;;496    
;;;497            Array<Type> A(8, 2*numPoints, scratch);
;;;498            Array<Type> bt(1, 2*numPoints, scratch);
;;;499    
;;;500            const Point<Type> * const pOriginalPoints = originalPoints.Pointer(0);
;;;501            const Point<Type> * const pTransformedPoints = transformedPoints.Pointer(0);
;;;502    
;;;503            Type * restrict pBt = bt.Pointer(0,0);
;;;504    
;;;505            //EndBenchmark("EstimateHomography_init");
;;;506    
;;;507            //BeginBenchmark("EstimateHomography_a&b");
;;;508    
;;;509            for(s32 i=0; i<numPoints; i++) {
;;;510              Type * restrict A_y1 = A.Pointer(2*i, 0);
;;;511              Type * restrict A_y2 = A.Pointer(2*i + 1, 0);
;;;512    
;;;513              const Type xi = pOriginalPoints[i].x;
;;;514              const Type yi = pOriginalPoints[i].y;
;;;515    
;;;516              const Type xp = pTransformedPoints[i].x;
;;;517              const Type yp = pTransformedPoints[i].y;
;;;518    
;;;519              A_y1[0] = 0;  A_y1[1] = 0;  A_y1[2] = 0; A_y1[3] = -xi; A_y1[4] = -yi; A_y1[5] = -1; A_y1[6] = xi*yp;  A_y1[7] = yi*yp;
;;;520              A_y2[0] = xi; A_y2[1] = yi; A_y2[2] = 1; A_y2[3] = 0;   A_y2[4] = 0;   A_y2[5] = 0;  A_y2[6] = -xi*xp; A_y2[7] = -yi*xp;
;;;521    
;;;522              pBt[2*i] = -yp;
;;;523              pBt[2*i + 1] = xp;
;;;524            }
;;;525    
;;;526            //EndBenchmark("EstimateHomography_a&b");
;;;527    
;;;528            //BeginBenchmark("EstimateHomography_At");
;;;529    
;;;530            Array<Type> At(2*numPoints, 8, scratch);
;;;531    
;;;532            Matrix::Transpose(A, At);
;;;533    
;;;534            //EndBenchmark("EstimateHomography_At");
;;;535    
;;;536            //BeginBenchmark("EstimateHomography_AtA");
;;;537    
;;;538            Array<Type> AtA(8, 8, scratch, Flags::Buffer(false,false,false));
;;;539            Array<Type> Atb(8, 1, scratch, Flags::Buffer(false,false,false));
;;;540    
;;;541            Matrix::Multiply(At, A, AtA);
;;;542    
;;;543            //EndBenchmark("EstimateHomography_AtA");
;;;544    
;;;545            //BeginBenchmark("EstimateHomography_Atb");
;;;546    
;;;547            Matrix::MultiplyTranspose(At, bt, Atb);
;;;548    
;;;549            //EndBenchmark("EstimateHomography_Atb");
;;;550    
;;;551            //BeginBenchmark("EstimateHomography_transposeAtb");
;;;552    
;;;553            Array<Type> Atbt(1, 8, scratch);
;;;554    
;;;555            Matrix::Transpose(Atb, Atbt);
;;;556    
;;;557            //EndBenchmark("EstimateHomography_transposeAtb");
;;;558    
;;;559            //BeginBenchmark("EstimateHomography_cholesky");
;;;560    
;;;561            const Result choleskyResult = SolveLeastSquaresWithCholesky(AtA, Atbt, false, numericalFailure);
;;;562    
;;;563            AnkiConditionalErrorAndReturnValue(choleskyResult == RESULT_OK,
;;;564              choleskyResult, "EstimateHomography", "SolveLeastSquaresWithCholesky failed");
;;;565    
;;;566            if(numericalFailure){
;;;567              AnkiWarn("EstimateHomography", "numericalFailure");
;;;568              return RESULT_OK;
;;;569            }
;;;570    
;;;571            Type * restrict pAtbt = Atbt.Pointer(0,0);
;;;572    
;;;573            homography[0][0] = pAtbt[0]; homography[0][1] = pAtbt[1]; homography[0][2] = pAtbt[2];
;;;574            homography[1][0] = pAtbt[3]; homography[1][1] = pAtbt[4]; homography[1][2] = pAtbt[5];
;;;575            homography[2][0] = pAtbt[6]; homography[2][1] = pAtbt[7]; homography[2][2] = static_cast<Type>(1);
;;;576    
;;;577            // Check that the solution is fairly close
;;;578            // TODO: make work for numPoints != 4
;;;579            if(numPoints == 4) {
;;;580              Array<Type> point1(3,1,scratch);
;;;581              Array<Type> point1Warped(3,1,scratch);
;;;582              for(s32 iPoint=0; iPoint<numPoints; iPoint++) {
;;;583                point1[0][0] = originalPoints[iPoint].x;
;;;584                point1[1][0] = originalPoints[iPoint].y;
;;;585                point1[2][0] = 1;
;;;586    
;;;587                Matrix::Multiply(homography, point1, point1Warped);
;;;588                point1Warped[0][0] /= point1Warped[2][0];
;;;589                point1Warped[1][0] /= point1Warped[2][0];
;;;590    
;;;591                const Type distance = sqrtf(powf(static_cast<f32>(transformedPoints[iPoint].x) - static_cast<f32>(point1Warped[0][0]), 2.0f) + powf(static_cast<f32>(transformedPoints[iPoint].y) - static_cast<f32>(point1Warped[1][0]), 2.0f));
;;;592    
;;;593                if(distance > MAX_SOLVE_DISTANCE) {
;;;594                  AnkiWarn("EstimateHomography", "Poor solution precision");
;;;595    
;;;596                  numericalFailure = true;
;;;597    
;;;598                  homography.SetZero();
;;;599                  homography[0][0] = 1;
;;;600                  homography[1][1] = 1;
;;;601                  homography[2][2] = 1;
;;;602    
;;;603                  return RESULT_OK;
;;;604                }
;;;605              }
;;;606            }
;;;607            //EndBenchmark("EstimateHomography_cholesky");
;;;608    
;;;609            return RESULT_OK;
;;;610          } // EstimateHomography()
;;;611    
;;;612          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;613          {
;;;614            const s32 inHeight = in.get_size(0);
;;;615            const s32 inWidth = in.get_size(1);
;;;616    
;;;617            const s32 outHeight = out.get_size(0);
;;;618            const s32 outWidth = out.get_size(1);
;;;619    
;;;620            AnkiConditionalErrorAndReturnValue((inHeight*inWidth) == (outHeight*outWidth),
;;;621              RESULT_FAIL_INVALID_SIZE, "Reshape", "Input and Output matrices are incompatible sizes");
;;;622    
;;;623            s32 inIndexY = 0;
;;;624            s32 inIndexX = 0;
;;;625    
;;;626            if(isColumnMajor) {
;;;627              for(s32 y = 0; y < outHeight; y++)
;;;628              {
;;;629                OutType * const pOut = out.Pointer(y,0);
;;;630    
;;;631                for(s32 x = 0; x < outWidth; x++) {
;;;632                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;633    
;;;634                  pOut[x] = static_cast<OutType>(curIn);
;;;635    
;;;636                  inIndexY++;
;;;637                  if(inIndexY >= inHeight) {
;;;638                    inIndexY = 0;
;;;639                    inIndexX++;
;;;640                  }
;;;641                }
;;;642              }
;;;643            } else { // if(isColumnMajor)
;;;644              for(s32 y = 0; y < outHeight; y++)
;;;645              {
;;;646                OutType * const pOut = out.Pointer(y,0);
;;;647    
;;;648                for(s32 x = 0; x < outWidth; x++) {
;;;649                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;650    
;;;651                  pOut[x] = static_cast<OutType>(curIn);
;;;652    
;;;653                  inIndexX++;
;;;654                  if(inIndexX >= inWidth) {
;;;655                    inIndexX = 0;
;;;656                    inIndexY++;
;;;657                  }
;;;658                }
;;;659              }
;;;660            } // if(isColumnMajor) ... else
;;;661    
;;;662            return RESULT_OK;
;;;663          } // Reshape()
;;;664    
;;;665          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory)
;;;666          {
;;;667            Array<OutType> out(newHeight, newWidth, memory);
;;;668    
;;;669            Reshape<InType, OutType>(isColumnMajor, in, out);
;;;670    
;;;671            return out;
;;;672          }
;;;673    
;;;674          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;675          {
;;;676            AnkiConditionalErrorAndReturnValue(out.get_size(0) == 1,
;;;677              RESULT_FAIL_INVALID_SIZE, "Vectorize", "Output is not 1xN");
;;;678    
;;;679            return Reshape<InType, OutType>(isColumnMajor, in, out);
;;;680          }
;;;681    
;;;682          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory)
;;;683          {
;;;684            const s32 inHeight = in.get_size(0);
;;;685            const s32 inWidth = in.get_size(1);
;;;686    
;;;687            Array<OutType> out(1, inHeight*inWidth, memory);
;;;688    
;;;689            Vectorize<InType, OutType>(isColumnMajor, in, out);
;;;690    
;;;691            return out;
;;;692          }
;;;693    
;;;694          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out)
;;;695          {
;;;696            const s32 inHeight = in.get_size(0);
;;;697            const s32 inWidth = in.get_size(1);
;;;698    
;;;699            const s32 outStride = out.get_stride();
;;;700    
;;;701            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;702              RESULT_FAIL_INVALID_OBJECT, "Transpose", "Invalid objects");
;;;703    
;;;704            AnkiConditionalErrorAndReturnValue(AreEqualSize(in.get_size(1), in.get_size(0), out),
;;;705              RESULT_FAIL_INVALID_SIZE, "Transpose", "out is not the correct size");
;;;706    
;;;707            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;708              RESULT_FAIL_ALIASED_MEMORY, "Transpose", "in and out cannot be the same array");
;;;709    
;;;710            for(s32 yIn=0; yIn<inHeight; yIn++) {
;;;711              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;712              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0,yIn));
;;;713    
;;;714              s32 xIn;
;;;715              s32 outOffset0 = 0;
;;;716    
;;;717              for(xIn=0; xIn<inWidth-1; xIn+=2) {
;;;718                const InType in0 = pIn[xIn];
;;;719                const InType in1 = pIn[xIn+1];
;;;720    
;;;721                const s32 outOffset1 = outOffset0 + outStride;
;;;722    
;;;723                *reinterpret_cast<OutType*>(pOut + outOffset0) = static_cast<OutType>(in0);
;;;724                *reinterpret_cast<OutType*>(pOut + outOffset1) = static_cast<OutType>(in1);
;;;725    
;;;726                outOffset0 += 2*outStride;
;;;727              }
;;;728    
;;;729              for(; xIn<inWidth; xIn++) {
;;;730                *out.Pointer(xIn,yIn) = static_cast<OutType>(pIn[xIn]);
;;;731              }
;;;732            }
;;;733    
;;;734            return RESULT_OK;
;;;735          } // Transpose()
;;;736    
;;;737          template<typename InType, typename OutType> Result Rotate90(const Array<InType> &in, Array<OutType> &out)
;;;738          {
;;;739            const s32 arrWidth = in.get_size(1);
;;;740    
;;;741            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;742              RESULT_FAIL_INVALID_OBJECT, "Rotate90", "Invalid objects");
;;;743    
;;;744            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;745              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;746    
;;;747            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;748              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;749    
;;;750            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;751              RESULT_FAIL_ALIASED_MEMORY, "Rotate90", "in and out cannot be the same array");
;;;752    
;;;753            const s32 outStride = out.get_stride();
;;;754    
;;;755            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;756              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;757              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0, arrWidth-yIn-1));
;;;758    
;;;759              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;760                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;761    
;;;762                pOut += outStride;
;;;763              }
;;;764            }
;;;765    
;;;766            return RESULT_OK;
;;;767          } // Rotate90()
;;;768    
;;;769          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out)
;;;770          {
;;;771            const s32 arrWidth = in.get_size(1);
;;;772    
;;;773            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;774              RESULT_FAIL_INVALID_OBJECT, "Rotate180", "Invalid objects");
;;;775    
;;;776            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;777              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;778    
;;;779            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;780              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;781    
;;;782            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;783              RESULT_FAIL_ALIASED_MEMORY, "Rotate180", "in and out cannot be the same array");
;;;784    
;;;785            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;786              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;787              OutType * restrict pOut = out.Pointer(arrWidth-yIn-1, 0);
;;;788    
;;;789              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;790                pOut[arrWidth-xIn-1] = static_cast<OutType>(pIn[xIn]);
;;;791              }
;;;792            }
;;;793    
;;;794            return RESULT_OK;
;;;795          } // Rotate180()
;;;796    
;;;797          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out)
;;;798          {
;;;799            const s32 arrWidth = in.get_size(1);
;;;800    
;;;801            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;802              RESULT_FAIL_INVALID_OBJECT, "Rotate270", "Invalid objects");
;;;803    
;;;804            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;805              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;806    
;;;807            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;808              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;809    
;;;810            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;811              RESULT_FAIL_ALIASED_MEMORY, "Rotate270", "in and out cannot be the same array");
;;;812    
;;;813            const s32 outStride = out.get_stride();
;;;814    
;;;815            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;816              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;817              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(arrWidth-1, yIn));
;;;818    
;;;819              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;820                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;821    
;;;822                pOut -= outStride;
;;;823              }
;;;824            }
;;;825    
;;;826            return RESULT_OK;
;;;827          } // Rotate270()
;;;828    
;;;829          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;830          {
;;;831            const s32 arrWidth = arr.get_size(1);
;;;832    
;;;833            for(s32 x=0; x<arrWidth; x++) {
;;;834              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;835                const Type valueToInsert = arr[y][x];
;;;836    
;;;837                s32 holePosition = y;
;;;838    
;;;839                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;840                  arr[holePosition][x] = arr[holePosition-1][x];
;;;841                  holePosition--;
;;;842                }
;;;843    
;;;844                arr[holePosition][x] = valueToInsert;
;;;845              }
;;;846            } // for(s32 x=0; x<arrWidth; x++)
;;;847          } // InsertionSort_sortAscendingDimension0()
;;;848    
;;;849          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;850          {
;;;851            const s32 arrWidth = arr.get_size(1);
;;;852    
;;;853            for(s32 x=0; x<arrWidth; x++) {
;;;854              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;855                const Type valueToInsert = arr[y][x];
;;;856    
;;;857                s32 holePosition = y;
;;;858    
;;;859                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;860                  arr[holePosition][x] = arr[holePosition-1][x];
;;;861                  holePosition--;
;;;862                }
;;;863    
;;;864                arr[holePosition][x] = valueToInsert;
;;;865              }
;;;866            } // for(s32 x=0; x<arrWidth; x++)
;;;867          } // InsertionSort_sortDescendingDimension0
;;;868    
;;;869          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;870          {
;;;871            const s32 arrHeight = arr.get_size(0);
;;;872    
;;;873            for(s32 y=0; y<arrHeight; y++) {
;;;874              Type * const pArr = arr[y];
;;;875    
;;;876              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;877                const Type valueToInsert = pArr[x];
;;;878    
;;;879                s32 holePosition = x;
;;;880    
;;;881                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;882                  pArr[holePosition] = pArr[holePosition-1];
;;;883                  holePosition--;
;;;884                }
;;;885    
;;;886                pArr[holePosition] = valueToInsert;
;;;887              }
;;;888            } // for(s32 x=0; x<arrWidth; x++)
;;;889          } // InsertionSort_sortAscendingDimension1()
;;;890    
;;;891          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;892          {
;;;893            const s32 arrHeight = arr.get_size(0);
;;;894    
;;;895            for(s32 y=0; y<arrHeight; y++) {
;;;896              Type * const pArr = arr[y];
;;;897    
;;;898              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;899                const Type valueToInsert = pArr[x];
;;;900    
;;;901                s32 holePosition = x;
;;;902    
;;;903                while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;904                  pArr[holePosition] = pArr[holePosition-1];
;;;905                  holePosition--;
;;;906                }
;;;907    
;;;908                pArr[holePosition] = valueToInsert;
;;;909              }
;;;910            } // for(s32 x=0; x<arrWidth; x++)
;;;911          } // InsertionSort_sortAscendingDimension1()
;;;912    
;;;913          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;914          {
;;;915            const s32 arrWidth = arr.get_size(1);
;;;916    
;;;917            for(s32 x=0; x<arrWidth; x++) {
;;;918              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;919                const Type valueToInsert = arr[y][x];
;;;920                const s32 indexToInsert = indexes[y][x];
;;;921    
;;;922                s32 holePosition = y;
;;;923    
;;;924                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;925                  arr[holePosition][x] = arr[holePosition-1][x];
;;;926                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;927                  holePosition--;
;;;928                }
;;;929    
;;;930                arr[holePosition][x] = valueToInsert;
;;;931                indexes[holePosition][x] = indexToInsert;
;;;932              }
;;;933            } // for(s32 x=0; x<arrWidth; x++)
;;;934          } // InsertionSort_sortAscendingDimension0()
;;;935    
;;;936          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;937          {
;;;938            const s32 arrWidth = arr.get_size(1);
;;;939    
;;;940            for(s32 x=0; x<arrWidth; x++) {
;;;941              indexes[0][x] = 0;
;;;942    
;;;943              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;944                const Type valueToInsert = arr[y][x];
;;;945                const s32 indexToInsert = indexes[y][x];
;;;946    
;;;947                s32 holePosition = y;
;;;948    
;;;949                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;950                  arr[holePosition][x] = arr[holePosition-1][x];
;;;951                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;952                  holePosition--;
;;;953                }
;;;954    
;;;955                arr[holePosition][x] = valueToInsert;
;;;956                indexes[holePosition][x] = indexToInsert;
;;;957              }
;;;958            } // for(s32 x=0; x<arrWidth; x++)
;;;959          } // InsertionSort_sortDescendingDimension0()
;;;960    
;;;961          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;962          {
;;;963            const s32 arrHeight = arr.get_size(0);
;;;964    
;;;965            for(s32 y=0; y<arrHeight; y++) {
;;;966              Type * const pArr = arr[y];
;;;967              s32 * const pIndexes = indexes[y];
;;;968    
;;;969              pIndexes[0] = 0;
;;;970    
;;;971              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;972                const Type valueToInsert = pArr[x];
;;;973                const s32 indexToInsert = pIndexes[x];
;;;974    
;;;975                s32 holePosition = x;
;;;976    
;;;977                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;978                  pArr[holePosition] = pArr[holePosition-1];
;;;979                  pIndexes[holePosition] = pIndexes[holePosition-1];
;;;980                  holePosition--;
;;;981                }
;;;982    
;;;983                pArr[holePosition] = valueToInsert;
;;;984                pIndexes[holePosition] = indexToInsert;
;;;985              }
;;;986            } // for(s32 x=0; x<arrWidth; x++)
;;;987          } // InsertionSort_sortAscendingDimension1()
;;;988    
;;;989          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;990          {
;;;991            const s32 arrHeight = arr.get_size(0);
;;;992    
;;;993            for(s32 y=0; y<arrHeight; y++) {
;;;994              Type * const pArr = arr[y];
;;;995              s32 * const pIndexes = indexes[y];
;;;996    
;;;997              pIndexes[0] = 0;
;;;998    
;;;999              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;1000               const Type valueToInsert = pArr[x];
;;;1001               const s32 indexToInsert = pIndexes[x];
;;;1002   
;;;1003               s32 holePosition = x;
;;;1004   
;;;1005               while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;1006                 pArr[holePosition] = pArr[holePosition-1];
;;;1007                 pIndexes[holePosition] = pIndexes[holePosition-1];
;;;1008                 holePosition--;
;;;1009               }
;;;1010   
;;;1011               pArr[holePosition] = valueToInsert;
;;;1012               pIndexes[holePosition] = indexToInsert;
;;;1013             }
;;;1014           } // for(s32 x=0; x<arrWidth; x++)
;;;1015         } // InsertionSort_sortDescendingDimension1()
;;;1016   
;;;1017         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1018         {
;;;1019           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1020             return;
;;;1021           }
;;;1022   
;;;1023           // Select the median value of the first, middle, and last elements as the pivot
;;;1024           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1025   
;;;1026           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1027   
;;;1028           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1029             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1030   
;;;1031           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1032             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1033   
;;;1034           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x))
;;;1035             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1036   
;;;1037           // Search from the beginning to before the moved pivot
;;;1038           s32 i = trueMinIndex;
;;;1039           s32 j = trueMaxIndex - 2;
;;;1040   
;;;1041           if(i >= j) {
;;;1042             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1043             // NOTE: This really means your insertionSortSize value is too low
;;;1044             return;
;;;1045           }
;;;1046   
;;;1047           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1048   
;;;1049           const Type pivot = *arr.Pointer(midIndex, x);
;;;1050   
;;;1051           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1052   
;;;1053           // Main partitioning loop
;;;1054           while(true) {
;;;1055             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1056             while(*arr.Pointer(i,x) < pivot) {
;;;1057               i++;
;;;1058             }
;;;1059   
;;;1060             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1061             while(*arr.Pointer(j,x) > pivot) {
;;;1062               j--;
;;;1063             }
;;;1064   
;;;1065             if(i < j) {
;;;1066               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1067               i++;
;;;1068               j--;
;;;1069             } else {
;;;1070               break;
;;;1071             }
;;;1072           }
;;;1073   
;;;1074           // Replace the pivot
;;;1075           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1076   
;;;1077           // Recurse
;;;1078           QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1079   
;;;1080           QuickSort_sortAscendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1081         } // QuickSort_sortAscendingDimension0
;;;1082   
;;;1083         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1084         {
;;;1085           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1086             return;
;;;1087           }
;;;1088   
;;;1089           // Select the median value of the first, middle, and last elements as the pivot
;;;1090           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1091   
;;;1092           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1093   
;;;1094           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1095             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1096   
;;;1097           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1098             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1099   
;;;1100           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x))
;;;1101             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1102   
;;;1103           // Search from the beginning to before the moved pivot
;;;1104           s32 i = trueMinIndex;
;;;1105           s32 j = trueMaxIndex - 2;
;;;1106   
;;;1107           if(i >= j) {
;;;1108             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1109             // NOTE: This really means your insertionSortSize value is too low
;;;1110             return;
;;;1111           }
;;;1112   
;;;1113           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1114   
;;;1115           const Type pivot = *arr.Pointer(midIndex, x);
;;;1116   
;;;1117           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1118   
;;;1119           // Main partitioning loop
;;;1120           while(true) {
;;;1121             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1122             while(*arr.Pointer(i,x) > pivot) {
;;;1123               i++;
;;;1124             }
;;;1125   
;;;1126             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1127             while(*arr.Pointer(j,x) < pivot) {
;;;1128               j--;
;;;1129             }
;;;1130   
;;;1131             if(i < j) {
;;;1132               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1133               i++;
;;;1134               j--;
;;;1135             } else {
;;;1136               break;
;;;1137             }
;;;1138           }
;;;1139   
;;;1140           // Replace the pivot
;;;1141           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1142   
;;;1143           // Recurse
;;;1144           QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1145   
;;;1146           QuickSort_sortDescendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1147         } // QuickSort_sortDescendingDimension0
;;;1148   
;;;1149         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1150         {
;;;1151           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1152             return;
;;;1153           }
;;;1154   
;;;1155           Type * restrict pArr = arr.Pointer(y,0);
;;;1156   
;;;1157           // Select the median value of the first, middle, and last elements as the pivot
;;;1158           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1159   
;;;1160           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1161   
;;;1162           if(pArr[midIndex] < pArr[trueMinIndex])
;;;1163             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1164   
;;;1165           if(pArr[trueMaxIndex] < pArr[trueMinIndex])
;;;1166             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1167   
;;;1168           if(pArr[trueMaxIndex] < pArr[midIndex])
;;;1169             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1170   
;;;1171           // Search from the beginning to before the moved pivot
;;;1172           s32 i = trueMinIndex;
;;;1173           s32 j = trueMaxIndex - 2;
;;;1174   
;;;1175           if(i >= j) {
;;;1176             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1177             // NOTE: This really means your insertionSortSize value is too low
;;;1178             return;
;;;1179           }
;;;1180   
;;;1181           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1182   
;;;1183           const Type pivot = pArr[midIndex];
;;;1184   
;;;1185           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1186   
;;;1187           // Main partitioning loop
;;;1188           while(true) {
;;;1189             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1190             while(pArr[i] < pivot) {
;;;1191               i++;
;;;1192             }
;;;1193   
;;;1194             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1195             while(pArr[j] > pivot) {
;;;1196               j--;
;;;1197             }
;;;1198   
;;;1199             if(i < j) {
;;;1200               Swap<Type>(pArr[i], pArr[j]);
;;;1201               i++;
;;;1202               j--;
;;;1203             } else {
;;;1204               break;
;;;1205             }
;;;1206           }
;;;1207   
;;;1208           // Replace the pivot
;;;1209           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1210   
;;;1211           // Recurse
;;;1212           QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1213   
;;;1214           QuickSort_sortAscendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1215         } // QuickSort_sortAscendingDimension1
;;;1216   
;;;1217         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1218         {
;;;1219           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1220             return;
;;;1221           }
;;;1222   
;;;1223           Type * restrict pArr = arr.Pointer(y,0);
;;;1224   
;;;1225           // Select the median value of the first, middle, and last elements as the pivot
;;;1226           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1227   
;;;1228           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1229   
;;;1230           if(pArr[midIndex] < pArr[trueMaxIndex])
;;;1231             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1232   
;;;1233           if(pArr[trueMinIndex] < pArr[trueMaxIndex])
;;;1234             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1235   
;;;1236           if(pArr[trueMinIndex] < pArr[midIndex])
;;;1237             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1238   
;;;1239           // Search from the beginning to before the moved pivot
;;;1240           s32 i = trueMinIndex;
;;;1241           s32 j = trueMaxIndex - 2;
;;;1242   
;;;1243           if(i >= j) {
;;;1244             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1245             // NOTE: This really means your insertionSortSize value is too low
;;;1246             return;
;;;1247           }
;;;1248   
;;;1249           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1250   
;;;1251           const Type pivot = pArr[midIndex];
;;;1252   
;;;1253           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1254   
;;;1255           // Main partitioning loop
;;;1256           while(true) {
;;;1257             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1258             while(pArr[i] > pivot) {
;;;1259               i++;
;;;1260             }
;;;1261   
;;;1262             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1263             while(pArr[j] < pivot) {
;;;1264               j--;
;;;1265             }
;;;1266   
;;;1267             if(i < j) {
;;;1268               Swap<Type>(pArr[i], pArr[j]);
;;;1269               i++;
;;;1270               j--;
;;;1271             } else {
;;;1272               break;
;;;1273             }
;;;1274           }
;;;1275   
;;;1276           // Replace the pivot
;;;1277           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1278   
;;;1279           // Recurse
;;;1280           QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1281   
;;;1282           QuickSort_sortDescendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1283         } // QuickSort_sortDescendingDimension1
;;;1284   
;;;1285         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1286         {
;;;1287           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1288             return;
;;;1289           }
;;;1290   
;;;1291           // Select the median value of the first, middle, and last elements as the pivot
;;;1292           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1293   
;;;1294           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1295   
;;;1296           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1297             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1298             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1299           }
;;;1300   
;;;1301           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1302             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1303             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1304           }
;;;1305   
;;;1306           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1307             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1308             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(midIndex, x));
;;;1309           }
;;;1310   
;;;1311           // Search from the beginning to before the moved pivot
;;;1312           s32 i = trueMinIndex;
;;;1313           s32 j = trueMaxIndex - 2;
;;;1314   
;;;1315           if(i >= j) {
;;;1316             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1317             // NOTE: This really means your insertionSortSize value is too low
;;;1318             return;
;;;1319           }
;;;1320   
;;;1321           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1322   
;;;1323           const Type pivot = *arr.Pointer(midIndex, x);
;;;1324   
;;;1325           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1326           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1327   
;;;1328           // Main partitioning loop
;;;1329           while(true) {
;;;1330             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1331             while(*arr.Pointer(i,x) < pivot) {
;;;1332               i++;
;;;1333             }
;;;1334   
;;;1335             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1336             while(*arr.Pointer(j,x) > pivot) {
;;;1337               j--;
;;;1338             }
;;;1339   
;;;1340             if(i < j) {
;;;1341               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1342               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1343               i++;
;;;1344               j--;
;;;1345             } else {
;;;1346               break;
;;;1347             }
;;;1348           }
;;;1349   
;;;1350           // Replace the pivot
;;;1351           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1352           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1353   
;;;1354           // Recurse
;;;1355           QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1356   
;;;1357           QuickSort_sortAscendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1358         } // QuickSort_sortAscendingDimension0
;;;1359   
;;;1360         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1361         {
;;;1362           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1363             return;
;;;1364           }
;;;1365   
;;;1366           // Select the median value of the first, middle, and last elements as the pivot
;;;1367           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1368   
;;;1369           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1370   
;;;1371           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1372             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1373             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1374           }
;;;1375   
;;;1376           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1377             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1378             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1379           }
;;;1380   
;;;1381           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1382             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1383             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(midIndex, x));
;;;1384           }
;;;1385   
;;;1386           // Search from the beginning to before the moved pivot
;;;1387           s32 i = trueMinIndex;
;;;1388           s32 j = trueMaxIndex - 2;
;;;1389   
;;;1390           if(i >= j) {
;;;1391             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1392             // NOTE: This really means your insertionSortSize value is too low
;;;1393             return;
;;;1394           }
;;;1395   
;;;1396           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1397   
;;;1398           const Type pivot = *arr.Pointer(midIndex, x);
;;;1399   
;;;1400           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1401           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1402   
;;;1403           // Main partitioning loop
;;;1404           while(true) {
;;;1405             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1406             while(*arr.Pointer(i,x) > pivot) {
;;;1407               i++;
;;;1408             }
;;;1409   
;;;1410             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1411             while(*arr.Pointer(j,x) < pivot) {
;;;1412               j--;
;;;1413             }
;;;1414   
;;;1415             if(i < j) {
;;;1416               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1417               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1418               i++;
;;;1419               j--;
;;;1420             } else {
;;;1421               break;
;;;1422             }
;;;1423           }
;;;1424   
;;;1425           // Replace the pivot
;;;1426           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1427           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1428   
;;;1429           // Recurse
;;;1430           QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1431   
;;;1432           QuickSort_sortDescendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1433         } // QuickSort_sortDescendingDimension0
;;;1434   
;;;1435         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1436         {
;;;1437           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1438             return;
;;;1439           }
;;;1440   
;;;1441           Type * restrict pArr = arr.Pointer(y,0);
;;;1442           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1443   
;;;1444           // Select the median value of the first, middle, and last elements as the pivot
;;;1445           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1446   
;;;1447           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1448   
;;;1449           if(pArr[midIndex] < pArr[trueMinIndex]) {
;;;1450             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1451             Swap<s32>(pIndexes[midIndex], pIndexes[trueMinIndex]);
;;;1452           }
;;;1453   
;;;1454           if(pArr[trueMaxIndex] < pArr[trueMinIndex]) {
;;;1455             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1456             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[trueMinIndex]);
;;;1457           }
;;;1458   
;;;1459           if(pArr[trueMaxIndex] < pArr[midIndex]) {
;;;1460             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1461             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[midIndex]);
;;;1462           }
;;;1463   
;;;1464           // Search from the beginning to before the moved pivot
;;;1465           s32 i = trueMinIndex;
;;;1466           s32 j = trueMaxIndex - 2;
;;;1467   
;;;1468           if(i >= j) {
;;;1469             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1470             // NOTE: This really means your insertionSortSize value is too low
;;;1471             return;
;;;1472           }
;;;1473   
;;;1474           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1475   
;;;1476           const Type pivot = pArr[midIndex];
;;;1477   
;;;1478           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1479           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1480   
;;;1481           // Main partitioning loop
;;;1482           while(true) {
;;;1483             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1484             while(pArr[i] < pivot) {
;;;1485               i++;
;;;1486             }
;;;1487   
;;;1488             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1489             while(pArr[j] > pivot) {
;;;1490               j--;
;;;1491             }
;;;1492   
;;;1493             if(i < j) {
;;;1494               Swap<Type>(pArr[i], pArr[j]);
;;;1495               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1496               i++;
;;;1497               j--;
;;;1498             } else {
;;;1499               break;
;;;1500             }
;;;1501           }
;;;1502   
;;;1503           // Replace the pivot
;;;1504           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1505           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1506   
;;;1507           // Recurse
;;;1508           QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1509   
;;;1510           QuickSort_sortAscendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1511         } // QuickSort_sortAscendingDimension1
;;;1512   
;;;1513         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1514         {
;;;1515           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1516             return;
;;;1517           }
;;;1518   
;;;1519           Type * restrict pArr = arr.Pointer(y,0);
;;;1520           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1521   
;;;1522           // Select the median value of the first, middle, and last elements as the pivot
;;;1523           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1524   
;;;1525           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1526   
;;;1527           if(pArr[midIndex] < pArr[trueMaxIndex]) {
;;;1528             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1529             Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex]);
;;;1530           }
;;;1531   
;;;1532           if(pArr[trueMinIndex] < pArr[trueMaxIndex]) {
;;;1533             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1534             Swap<s32>(pIndexes[trueMinIndex], pIndexes[trueMaxIndex]);
;;;1535           }
;;;1536   
;;;1537           if(pArr[trueMinIndex] < pArr[midIndex]) {
;;;1538             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1539             Swap<s32>(pIndexes[trueMinIndex], pIndexes[midIndex]);
;;;1540           }
;;;1541   
;;;1542           // Search from the beginning to before the moved pivot
;;;1543           s32 i = trueMinIndex;
;;;1544           s32 j = trueMaxIndex - 2;
;;;1545   
;;;1546           if(i >= j) {
;;;1547             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1548             // NOTE: This really means your insertionSortSize value is too low
;;;1549             return;
;;;1550           }
;;;1551   
;;;1552           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1553   
;;;1554           const Type pivot = pArr[midIndex];
;;;1555   
;;;1556           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1557           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1558   
;;;1559           // Main partitioning loop
;;;1560           while(true) {
;;;1561             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1562             while(pArr[i] > pivot) {
;;;1563               i++;
;;;1564             }
;;;1565   
;;;1566             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1567             while(pArr[j] < pivot) {
;;;1568               j--;
;;;1569             }
;;;1570   
;;;1571             if(i < j) {
;;;1572               Swap<Type>(pArr[i], pArr[j]);
;;;1573               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1574               i++;
;;;1575               j--;
;;;1576             } else {
;;;1577               break;
;;;1578             }
;;;1579           }
;;;1580   
;;;1581           // Replace the pivot
;;;1582           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1583           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1584   
;;;1585           // Recurse
;;;1586           QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1587   
;;;1588           QuickSort_sortDescendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1589         } // QuickSort_sortDescendingDimension1
;;;1590   
;;;1591         template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1592         {
;;;1593           // const s32 arrHeight = arr.get_size(0);
;;;1594           // const s32 arrWidth = arr.get_size(1);
;;;1595   
;;;1596           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1597             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1598   
;;;1599           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1600             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1601   
;;;1602           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1603           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1604   
;;;1605           if(sortWhichDimension == 0) {
;;;1606             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1607             if(sortAscending) {
;;;1608               InsertionSort_sortAscendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1609             } else { // if(sortAscending)
;;;1610               InsertionSort_sortDescendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1611             } // if(sortAscending) ... else
;;;1612           } else { // sortWhichDimension == 1
;;;1613             if(sortAscending) {
;;;1614               InsertionSort_sortAscendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1615             } else { // if(sortAscending)
;;;1616               InsertionSort_sortDescendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1617             } // if(sortAscending) ... else
;;;1618           } // if(sortWhichDimension == 0) ... else
;;;1619   
;;;1620           return RESULT_OK;
;;;1621         } // InsertionSort()
;;;1622   
;;;1623         template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1624         {
;;;1625           const s32 arrHeight = arr.get_size(0);
;;;1626           const s32 arrWidth = arr.get_size(1);
;;;1627   
;;;1628           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1629             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1630   
;;;1631           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1632             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1633   
;;;1634           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1635             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1636   
;;;1637           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1638           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1639   
;;;1640           if(sortWhichDimension == 0) {
;;;1641             for(s32 y=0; y<arrHeight; y++) {
;;;1642               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1643               for(s32 x=0; x<arrWidth; x++) {
;;;1644                 pIndexes[x] = y;
;;;1645               }
;;;1646             }
;;;1647   
;;;1648             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1649             if(sortAscending) {
;;;1650               InsertionSort_sortAscendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1651             } else { // if(sortAscending)
;;;1652               InsertionSort_sortDescendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1653             } // if(sortAscending) ... else
;;;1654           } else { // sortWhichDimension == 1
;;;1655             for(s32 y=0; y<arrHeight; y++) {
;;;1656               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1657               for(s32 x=0; x<arrWidth; x++) {
;;;1658                 pIndexes[x] = x;
;;;1659               }
;;;1660             }
;;;1661   
;;;1662             if(sortAscending) {
;;;1663               InsertionSort_sortAscendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1664             } else { // if(sortAscending)
;;;1665               InsertionSort_sortDescendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1666             } // if(sortAscending) ... else
;;;1667           } // if(sortWhichDimension == 0) ... else
;;;1668   
;;;1669           return RESULT_OK;
;;;1670         } // InsertionSort()
;;;1671   
;;;1672         template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1673         {
;;;1674           const s32 arrHeight = arr.get_size(0);
;;;1675           const s32 arrWidth = arr.get_size(1);
;;;1676   
;;;1677           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1678             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1679   
;;;1680           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1681             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1682   
;;;1683           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1684             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1685   
;;;1686           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1687           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1688   
;;;1689           if(sortWhichDimension == 0) {
;;;1690             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1691             if(sortAscending) {
;;;1692               for(s32 x=0; x<arrWidth; x++) {
;;;1693                 QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1694               }
;;;1695   
;;;1696               if(insertionSortSize > 1)
;;;1697                 InsertionSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1698             } else { // if(sortAscending)
;;;1699               for(s32 x=0; x<arrWidth; x++) {
;;;1700                 QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1701               }
;;;1702   
;;;1703               if(insertionSortSize > 1)
;;;1704                 InsertionSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1705             } // if(sortAscending) ... else
;;;1706           } else { // sortWhichDimension == 1
;;;1707             if(sortAscending) {
;;;1708               for(s32 y=0; y<arrHeight; y++) {
;;;1709                 QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1710               }
;;;1711   
;;;1712               if(insertionSortSize > 1)
;;;1713                 InsertionSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1714             } else { // if(sortAscending)
;;;1715               for(s32 y=0; y<arrHeight; y++) {
;;;1716                 QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1717               }
;;;1718   
;;;1719               if(insertionSortSize > 1)
;;;1720                 InsertionSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1721             } // if(sortAscending) ... else
;;;1722           } // if(sortWhichDimension == 0) ... else
;;;1723   
;;;1724           return RESULT_OK;
;;;1725         } // QuickSort()
;;;1726   
;;;1727         template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1728         {
;;;1729           const s32 arrHeight = arr.get_size(0);
;;;1730           const s32 arrWidth = arr.get_size(1);
;;;1731   
;;;1732           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1733             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1734   
;;;1735           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1736             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1737   
;;;1738           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1739             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1740   
;;;1741           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1742             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1743   
;;;1744           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1745           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1746   
;;;1747           if(sortWhichDimension == 0) {
;;;1748             for(s32 y=0; y<arrHeight; y++) {
;;;1749               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1750               for(s32 x=0; x<arrWidth; x++) {
;;;1751                 pIndexes[x] = y;
;;;1752               }
;;;1753             }
;;;1754   
;;;1755             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1756             if(sortAscending) {
;;;1757               for(s32 x=0; x<arrWidth; x++) {
;;;1758                 QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1759               }
;;;1760   
;;;1761               if(insertionSortSize > 1)
;;;1762                 InsertionSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1763             } else { // if(sortAscending)
;;;1764               for(s32 x=0; x<arrWidth; x++) {
;;;1765                 QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1766               }
;;;1767   
;;;1768               if(insertionSortSize > 1)
;;;1769                 InsertionSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1770             } // if(sortAscending) ... else
;;;1771           } else { // sortWhichDimension == 1
;;;1772             for(s32 y=0; y<arrHeight; y++) {
;;;1773               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1774               for(s32 x=0; x<arrWidth; x++) {
;;;1775                 pIndexes[x] = x;
;;;1776               }
;;;1777             }
;;;1778   
;;;1779             if(sortAscending) {
;;;1780               for(s32 y=0; y<arrHeight; y++) {
;;;1781                 QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1782               }
;;;1783   
;;;1784               if(insertionSortSize > 1)
;;;1785                 InsertionSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1786             } else { // if(sortAscending)
;;;1787               for(s32 y=0; y<arrHeight; y++) {
;;;1788                 QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1789               }
;;;1790   
;;;1791               if(insertionSortSize > 1)
;;;1792                 InsertionSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1793             } // if(sortAscending) ... else
;;;1794           } // if(sortWhichDimension == 0) ... else
;;;1795   
;;;1796           return RESULT_OK;
;;;1797         } // QuickSort()
;;;1798   
;;;1799         template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1800         {
;;;1801           AnkiConditionalErrorAndReturnValue(arr.get_size(0) == arr.get_size(1),
;;;1802             RESULT_FAIL_INVALID_SIZE, "MakeSymmetric", "Input array must be square");
;;;1803   
;;;1804           const s32 arrHeight = arr.get_size(0);
;;;1805           for(s32 y = 0; y < arrHeight; y++)
;;;1806           {
;;;1807             const s32 x0 = lowerToUpper ? (y+1)     : 0;
;;;1808             const s32 x1 = lowerToUpper ? arrHeight : y;
;;;1809   
;;;1810             for(s32 x = x0; x < x1; x++) {
;;;1811               *arr.Pointer(y,x) = *arr.Pointer(x,y);
;;;1812             }
;;;1813           }
;;;1814   
;;;1815           return RESULT_OK;
;;;1816         } // template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1817   
;;;1818         namespace Elementwise
;;;1819         {
;;;1820           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1821           {
;;;1822             const Array<InType> &in1Array = in1.get_array();
;;;1823             const Array<InType> &in2Array = in2.get_array();
;;;1824             Array<OutType> &out1Array = out.get_array();
;;;1825   
;;;1826             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, in2Array, out1Array),
;;;1827               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1828   
;;;1829             ArraySliceLimits_in2_out1<s32> limits(
;;;1830               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1831               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1832               out.get_ySlice(), out.get_xSlice());
;;;1833   
;;;1834             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1835               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1836   
;;;1837             if(limits.isSimpleIteration) {
;;;1838               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1839   
;;;1840               for(s32 y=0; y<limits.ySize; y++) {
;;;1841                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1842                 const InType * const pIn2 = in2Array.Pointer(limits.in2Y, 0);
;;;1843                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1844   
;;;1845                 limits.OuterIncrementTop();
;;;1846   
;;;1847                 for(s32 x=0; x<limits.xSize; x++) {
;;;1848                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], pIn2[limits.in2X]);
;;;1849   
;;;1850                   limits.in1X += limits.in1_xInnerIncrement;
;;;1851                   limits.in2X += limits.in2_xInnerIncrement;
;;;1852                   limits.out1X += limits.out1_xInnerIncrement;
;;;1853                 }
;;;1854   
;;;1855                 limits.OuterIncrementBottom();
;;;1856               }
;;;1857             } else { // if(limits.isSimpleIteration)
;;;1858               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1859   
;;;1860               for(s32 y=0; y<limits.ySize; y++) {
;;;1861                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1862   
;;;1863                 limits.OuterIncrementTop();
;;;1864   
;;;1865                 for(s32 x=0; x<limits.xSize; x++) {
;;;1866                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1867                   const InType valIn2 = *in2Array.Pointer(limits.in2Y, limits.in2X);
;;;1868   
;;;1869                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, valIn2);
;;;1870   
;;;1871                   limits.in1X += limits.in1_xInnerIncrement;
;;;1872                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1873                   limits.in2X += limits.in2_xInnerIncrement;
;;;1874                   limits.in2Y += limits.in2_yInnerIncrement;
;;;1875                   limits.out1X += limits.out1_xInnerIncrement;
;;;1876                 }
;;;1877   
;;;1878                 limits.OuterIncrementBottom();
;;;1879               }
;;;1880             } //   if(limits.isSimpleIteration)  ... else
;;;1881   
;;;1882             return RESULT_OK;
;;;1883           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1884   
;;;1885           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1886           {
;;;1887             const Array<InType> &in1Array = in1.get_array();
;;;1888             Array<OutType> &out1Array = out.get_array();
;;;1889   
;;;1890             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, out1Array),
;;;1891               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1892   
;;;1893             ArraySliceLimits_in1_out1<s32> limits(
;;;1894               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1895               out.get_ySlice(), out.get_xSlice());
;;;1896   
;;;1897             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1898               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1899   
;;;1900             if(limits.isSimpleIteration) {
;;;1901               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1902   
;;;1903               for(s32 y=0; y<limits.ySize; y++) {
;;;1904                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1905                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1906   
;;;1907                 limits.OuterIncrementTop();
;;;1908   
;;;1909                 for(s32 x=0; x<limits.xSize; x++) {
;;;1910                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], value2);
;;;1911   
;;;1912                   limits.in1X += limits.in1_xInnerIncrement;
;;;1913                   limits.out1X += limits.out1_xInnerIncrement;
;;;1914                 }
;;;1915   
;;;1916                 limits.OuterIncrementBottom();
;;;1917               }
;;;1918             } else { // if(limits.isSimpleIteration)
;;;1919               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1920   
;;;1921               for(s32 y=0; y<limits.ySize; y++) {
;;;1922                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1923   
;;;1924                 limits.OuterIncrementTop();
;;;1925   
;;;1926                 for(s32 x=0; x<limits.xSize; x++) {
;;;1927                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1928   
;;;1929                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, value2);
;;;1930   
;;;1931                   limits.in1X += limits.in1_xInnerIncrement;
;;;1932                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1933                   limits.out1X += limits.out1_xInnerIncrement;
;;;1934                 }
;;;1935   
;;;1936                 limits.OuterIncrementBottom();
;;;1937               }
;;;1938             } //   if(limits.isSimpleIteration)  ... else
;;;1939   
;;;1940             return RESULT_OK;
;;;1941           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1942   
;;;1943           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1944           {
;;;1945             const Array<InType> &in2Array = in2.get_array();
;;;1946             Array<OutType> &out1Array = out.get_array();
;;;1947   
;;;1948             AnkiConditionalErrorAndReturnValue(AreValid(in2Array, out1Array),
;;;1949               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1950   
;;;1951             ArraySliceLimits_in1_out1<s32> limits(
;;;1952               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1953               out.get_ySlice(), out.get_xSlice());
;;;1954   
;;;1955             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1956               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1957   
;;;1958             if(limits.isSimpleIteration) {
;;;1959               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1960   
;;;1961               for(s32 y=0; y<limits.ySize; y++) {
;;;1962                 const InType * const pIn2 = in2Array.Pointer(limits.in1Y, 0);
;;;1963                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1964   
;;;1965                 limits.OuterIncrementTop();
;;;1966   
;;;1967                 for(s32 x=0; x<limits.xSize; x++) {
;;;1968                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, pIn2[limits.in1X]);
;;;1969   
;;;1970                   limits.in1X += limits.in1_xInnerIncrement;
;;;1971                   limits.out1X += limits.out1_xInnerIncrement;
;;;1972                 }
;;;1973   
;;;1974                 limits.OuterIncrementBottom();
;;;1975               }
;;;1976             } else { // if(limits.isSimpleIteration)
;;;1977               // If either input is transposed, then we will do an inefficent loop iteration
;;;1978   
;;;1979               for(s32 y=0; y<limits.ySize; y++) {
;;;1980                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1981   
;;;1982                 limits.OuterIncrementTop();
;;;1983   
;;;1984                 for(s32 x=0; x<limits.xSize; x++) {
;;;1985                   const InType valIn2 = *in2Array.Pointer(limits.in1Y, limits.in1X);
;;;1986   
;;;1987                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, valIn2);
;;;1988   
;;;1989                   limits.in1X += limits.in1_xInnerIncrement;
;;;1990                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1991                   limits.out1X += limits.out1_xInnerIncrement;
;;;1992                 }
;;;1993   
;;;1994                 limits.OuterIncrementBottom();
;;;1995               }
;;;1996             } //   if(limits.isSimpleIteration)  ... else
;;;1997   
;;;1998             return RESULT_OK;
;;;1999           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;2000         } // namespace Elementwise
;;;2001       } // namespace Matrix
;;;2002     } // namespace Embedded
;;;2003   } // namespace Anki
;;;2004   
;;;2005   #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;19     
;;;20     #include "anki/common/shared/utilities_shared.h"
;;;1      /**
;;;2      File: utilities_shared.h
;;;3      Author: Kevin Yoon
;;;4      Created: 2014
;;;5      
;;;6      Copyright Anki, Inc. 2014
;;;7      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;8      **/
;;;9      
;;;10     #ifndef _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;11     #define _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;12     
;;;13     #include <stdarg.h>
;;;1      /* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
;;;14     
;;;15     namespace Anki
;;;16     {
;;;17       // For printing throughout Coretech libraries.
;;;18       // Calls printf() by default, but can be made to use an externally
;;;19       // defined function via SetCoreTechPrintFunctionPtr().
;;;20       int CoreTechPrint(const char * format, ...);
;;;21       int CoreTechPrint(const char * format, va_list argList);
;;;22     
;;;23       // Sets the function pointer that CoreTechPrint() uses.
;;;24       // Convenient for on-robot print which could be more complex
;;;25       // than just printf().
;;;26       void SetCoreTechPrintFunctionPtr( int (*fp)(const char * format, va_list) );
;;;27     } // namespace Anki
;;;28     
;;;29     #endif // _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26     #if 0
;;;27     #pragma mark --- 2D Point Implementations ---
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
;;;34         template<typename Type> Point<Type>::Point(const Type x, const Type y)
;;;35           : x(x), y(y)
;;;36         {
;;;37         }
;;;38     
;;;39         template<typename Type> Point<Type>::Point(const Point<Type>& pt)
;;;40           : x(pt.x), y(pt.y)
;;;41         {
;;;42         }
;;;43     
;;;44     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;45         template<typename Type> Point<Type>::Point(const cv::Point_<Type>& pt)
;;;46           : x(pt.x), y(pt.y)
;;;47         {
;;;48         }
;;;49     #endif
;;;50     
;;;51     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;52         template<typename Type> cv::Point_<Type> Point<Type>::get_CvPoint_() const
;;;53         {
;;;54           return cv::Point_<Type>(x,y);
;;;55         }
;;;56     #endif
;;;57     
;;;58         template<typename Type> template<typename InType> void Point<Type>::SetCast(const Point<InType> &in)
;;;59         {
;;;60           this->x = saturate_cast<Type>(in.x);
;;;61           this->y = saturate_cast<Type>(in.y);
;;;62         }
;;;63     
;;;64         template<typename Type> void Point<Type>::Print() const
;;;65         {
;;;66           CoreTechPrint("(%d,%d) ", this->x, this->y);
;;;67         }
;;;68     
;;;69         template<typename Type> bool Point<Type>::operator== (const Point<Type> &point2) const
;;;70         {
;;;71           if(this->x == point2.x && this->y == point2.y)
;;;72             return true;
;;;73     
;;;74           return false;
;;;75         }
;;;76     
;;;77         template<typename Type> Point<Type> Point<Type>::operator+ (const Point<Type> &point2) const
;;;78         {
;;;79           return Point<Type>(this->x+point2.x, this->y+point2.y);
;;;80         }
;;;81     
;;;82         template<typename Type> Point<Type> Point<Type>::operator- (const Point<Type> &point2) const
;;;83         {
;;;84           return Point<Type>(this->x-point2.x, this->y-point2.y);
;;;85         }
;;;86     
;;;87         template<typename Type> Point<Type> Point<Type>::operator- () const
;;;88         {
;;;89           return Point<Type>(-this->x, -this->y);
;;;90         }
;;;91     
;;;92         template<typename Type> Point<Type>& Point<Type>::operator*= (const Type value)
;;;93         {
;;;94           this->x *= value;
;;;95           this->y *= value;
;;;96           return *this;
;;;97         }
;;;98     
;;;99         template<typename Type> Point<Type>& Point<Type>::operator-= (const Type value)
;;;100        {
;;;101          this->x -= value;
;;;102          this->y -= value;
;;;103          return *this;
;;;104        }
;;;105    
;;;106        template<typename Type> Point<Type>& Point<Type>::operator+= (const Point<Type> &point2)
;;;107        {
;;;108          this->x += point2.x;
;;;109          this->y += point2.y;
;;;110          return *this;
;;;111        }
;;;112    
;;;113        template<typename Type> Point<Type>& Point<Type>::operator-= (const Point<Type> &point2)
;;;114        {
;;;115          this->x -= point2.x;
;;;116          this->y -= point2.y;
;;;117          return *this;
;;;118        }
;;;119    
;;;120        template<typename Type> inline Point<Type>& Point<Type>::operator= (const Point<Type> &point2)
;;;121        {
;;;122          this->x = point2.x;
;;;123          this->y = point2.y;
;;;124    
;;;125          return *this;
;;;126        }
;;;127    
;;;128        template<typename Type> f32 Point<Type>::Dist(const Point<Type> &point2) const
;;;129        {
;;;130          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) + (this->y - point2.y)*(this->y - point2.y));
;;;131        }
;;;132    
;;;133        template<typename Type> f32 Point<Type>::Length() const
;;;134        {
;;;135          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y)));
;;;136        }
;;;137    
;;;138        // #pragma mark --- Point Specializations ---
;;;139        template<> void Point<f32>::Print() const;
;;;140        template<> void Point<f64>::Print() const;
;;;141    
;;;142    #if 0
;;;143    #pragma mark --- 3D Point Implementations ---
;;;144    #endif
;;;145    
;;;146        template<typename Type> Point3<Type>::Point3()
;;;147          : x(static_cast<Type>(0)), y(static_cast<Type>(0)), z(static_cast<Type>(0))
;;;148        {
;;;149        }
;;;150    
;;;151        template<typename Type> Point3<Type>::Point3(const Type x, const Type y, const Type z)
;;;152          : x(x), y(y), z(z)
;;;153        {
;;;154        }
;;;155    
;;;156        template<typename Type> Point3<Type>::Point3(const Point3<Type>& pt)
;;;157          : x(pt.x), y(pt.y), z(pt.z)
;;;158        {
;;;159        }
;;;160    
;;;161    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;162        template<typename Type> Point3<Type>::Point3(const cv::Point3_<Type>& pt)
;;;163          : x(pt.x), y(pt.y), z(pt.z)
;;;164        {
;;;165        }
;;;166    #endif
;;;167    
;;;168    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;169        template<typename Type> cv::Point3_<Type> Point3<Type>::get_CvPoint_() const
;;;170        {
;;;171          return cv::Point3_<Type>(x,y,z);
;;;172        }
;;;173    #endif
;;;174    
;;;175        template<typename Type> void Point3<Type>::Print() const
;;;176        {
;;;177          CoreTechPrint("(%d,%d,%d) ", this->x, this->y, this->z);
;;;178        }
;;;179    
;;;180        template<typename Type> bool Point3<Type>::operator== (const Point3<Type> &point2) const
;;;181        {
;;;182          if(this->x == point2.x && this->y == point2.y && this->z == point2.z)
;;;183            return true;
;;;184    
;;;185          return false;
;;;186        }
;;;187    
;;;188        template<typename Type> Point3<Type> Point3<Type>::operator+ (const Point3<Type> &point2) const
;;;189        {
;;;190          return Point3<Type>(this->x+point2.x, this->y+point2.y, this->z+point2.z);
;;;191        }
;;;192    
;;;193        template<typename Type> Point3<Type> Point3<Type>::operator- (const Point3<Type> &point2) const
;;;194        {
;;;195          return Point3<Type>(this->x-point2.x, this->y-point2.y, this->z-point2.z);
;;;196        }
;;;197    
;;;198        template<typename Type> Point3<Type> Point3<Type>::operator- () const
;;;199        {
;;;200          return Point3<Type>(-this->x, -this->y, -this->z);
;;;201        }
;;;202    
;;;203        template<typename Type> Point3<Type>& Point3<Type>::operator*= (const Type value)
;;;204        {
;;;205          this->x *= value;
;;;206          this->y *= value;
;;;207          this->z *= value;
;;;208          return *this;
;;;209        }
;;;210    
;;;211        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Type value)
;;;212        {
;;;213          this->x -= value;
;;;214          this->y -= value;
;;;215          this->z -= value;
;;;216          return *this;
;;;217        }
;;;218    
;;;219        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Point3<Type> &point2)
;;;220        {
;;;221          this->x -= point2.x;
;;;222          this->y -= point2.y;
;;;223          this->z -= point2.z;
;;;224          return *this;
;;;225        }
;;;226    
;;;227        template<typename Type> inline Point3<Type>& Point3<Type>::operator= (const Point3<Type> &point2)
;;;228        {
;;;229          this->x = point2.x;
;;;230          this->y = point2.y;
;;;231          this->z = point2.z;
;;;232          return *this;
;;;233        }
;;;234    
;;;235        template<typename Type> f32 Point3<Type>::Dist(const Point3<Type> &point2) const
;;;236        {
;;;237          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) +
;;;238            (this->y - point2.y)*(this->y - point2.y) +
;;;239            (this->z - point2.z)*(this->z - point2.z));
;;;240        }
;;;241    
;;;242        template<typename Type> f32 Point3<Type>::Length() const
;;;243        {
;;;244          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y) + (this->z*this->z)));
;;;245        }
;;;246    
;;;247        template<typename Type> f32 Point3<Type>::MakeUnitLength()
;;;248        {
;;;249          const f32 L = this->Length();
;;;250          if(L != 0) {
;;;251            this->operator*=(1.f / L);
;;;252          }
;;;253          return L;
;;;254        }
;;;255    
;;;256        template<typename Type>
;;;257        Type DotProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;258        {
;;;259          return (point1.x*point2.x) + (point1.y*point2.y) + (point1.z*point2.z);
;;;260        }
;;;261    
;;;262        template<typename Type>
;;;263        Point3<Type> CrossProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;264        {
;;;265          return Point3<Type>(-point2.y*point1.z + point1.y*point2.z,
;;;266            point2.x*point1.z - point1.x*point2.z,
;;;267            -point2.x*point1.y + point1.x*point2.y);
;;;268        }
;;;269    
;;;270        template<typename Type>
;;;271        Point3<Type> operator* (const Array<Type>& M, const Point3<Type>& p)
;;;272        {
;;;273          // Matrix M must be 3x3
;;;274          AnkiAssert(AreEqualSize(3, 3, M));
;;;275    
;;;276          return Point3<Type>(M[0][0]*p.x + M[0][1]*p.y + M[0][2]*p.z,
;;;277            M[1][0]*p.x + M[1][1]*p.y + M[1][2]*p.z,
;;;278            M[2][0]*p.x + M[2][1]*p.y + M[2][2]*p.z);
;;;279        }
;;;280    
;;;281        // #pragma mark --- Point Specializations ---
;;;282        template<> void Point3<f32>::Print() const;
;;;283        template<> void Point3<f64>::Print() const;
;;;284    
;;;285    #if 0
;;;286    #pragma mark --- Pose Implementations ---
;;;287    #endif
;;;288    
;;;289        template<typename Type>
;;;290        Result ComputePoseDiff(const Array<Type>& R1, const Point3<Type>& T1,
;;;291          const Array<Type>& R2, const Point3<Type>& T2,
;;;292          Array<Type>& Rdiff, Point3<Type>& Tdiff,
;;;293          MemoryStack scratch)
;;;294        {
;;;295          // All the rotation matrices should be 3x3
;;;296          AnkiAssert(AreEqualSize(3, 3, R1));
;;;297          AnkiAssert(AreEqualSize(3, 3, R2));
;;;298          AnkiAssert(AreEqualSize(3, 3, Rdiff));
;;;299    
;;;300          Array<Type> invR1 = Array<Type>(3,3,scratch);
;;;301          Matrix::Transpose(R1, invR1);
;;;302    
;;;303          Matrix::Multiply(invR1, R2, Rdiff);
;;;304          Tdiff = invR1 * (T2 - T1);
;;;305    
;;;306          return RESULT_OK;
;;;307        }
;;;308    
;;;309    #if 0
;;;310    #pragma mark --- Rectangle Implementations ---
;;;311    #endif
;;;312    
;;;313        template<typename Type> Rectangle<Type>::Rectangle()
;;;314          : left(static_cast<Type>(0)), right(static_cast<Type>(0)), top(static_cast<Type>(0)), bottom(static_cast<Type>(0))
;;;315        {
;;;316        }
;;;317    
;;;318        template<typename Type> Rectangle<Type>::Rectangle(const Type left, const Type right, const Type top, const Type bottom)
;;;319          : left(left), right(right), top(top), bottom(bottom)
;;;320        {
;;;321        }
;;;322    
;;;323        template<typename Type> Rectangle<Type>::Rectangle(const Rectangle<Type>& rect)
;;;324          : left(rect.left), right(rect.right), top(rect.top), bottom(rect.bottom)
;;;325        {
;;;326        }
;;;327    
;;;328        template<typename Type> void Rectangle<Type>::Print() const
;;;329        {
;;;330          CoreTechPrint("(%d,%d)->(%d,%d) ", this->left, this->top, this->right, this->bottom);
;;;331        }
;;;332    
;;;333        template<typename Type> template<typename OutType> Point<OutType> Rectangle<Type>::ComputeCenter() const
;;;334        {
;;;335          Point<OutType> center(
;;;336            (static_cast<OutType>(this->left) + static_cast<OutType>(this->right)) / 2,
;;;337            (static_cast<OutType>(this->top) + static_cast<OutType>(this->bottom)) / 2);
;;;338    
;;;339          return center;
;;;340        }
;;;341    
;;;342        template<typename Type> template<typename OutType> Rectangle<OutType> Rectangle<Type>::ComputeScaledRectangle(const f32 scalePercent) const
;;;343        {
;;;344          const f32 width = static_cast<f32>(this->get_width());
;;;345          const f32 height = static_cast<f32>(this->get_height());
;;;346    
;;;347          const f32 scaledWidth = width * scalePercent;
;;;348          const f32 scaledHeight = height * scalePercent;
;;;349    
;;;350          const f32 dx2 = (scaledWidth - width) / 2.0f;
;;;351          const f32 dy2 = (scaledHeight - height) / 2.0f;
;;;352    
;;;353          Rectangle<OutType> scaledRect(
;;;354            static_cast<OutType>( static_cast<f32>(this->left)   - dx2 ),
;;;355            static_cast<OutType>( static_cast<f32>(this->right)  + dx2 ),
;;;356            static_cast<OutType>( static_cast<f32>(this->top)    - dy2 ),
;;;357            static_cast<OutType>( static_cast<f32>(this->bottom) + dy2 ));
;;;358    
;;;359          return scaledRect;
;;;360        }
;;;361    
;;;362        template<typename Type> bool Rectangle<Type>::operator== (const Rectangle<Type> &rectangle2) const
;;;363        {
;;;364          if(this->left == rectangle2.left && this->top == rectangle2.top && this->right == rectangle2.right && this->bottom == rectangle2.bottom)
;;;365            return true;
;;;366    
;;;367          return false;
;;;368        }
;;;369    
;;;370        template<typename Type> Rectangle<Type> Rectangle<Type>::operator+ (const Rectangle<Type> &rectangle2) const
;;;371        {
;;;372          return Rectangle<Type>(this->top+rectangle2.top, this->bottom+rectangle2.bottom, this->left+rectangle2.left, this->right+rectangle2.right);
;;;373        }
;;;374    
;;;375        template<typename Type> Rectangle<Type> Rectangle<Type>::operator- (const Rectangle<Type> &rectangle2) const
;;;376        {
;;;377          return Rectangle<Type>(this->top-rectangle2.top, this->bottom-rectangle2.bottom, this->left-rectangle2.left, this->right-rectangle2.right);
;;;378        }
;;;379    
;;;380        template<typename Type> inline Rectangle<Type>& Rectangle<Type>::operator= (const Rectangle<Type> &rect2)
;;;381        {
;;;382          this->left = rect2.left;
;;;383          this->right = rect2.right;
;;;384          this->top = rect2.top;
;;;385          this->bottom = rect2.bottom;
;;;386    
;;;387          return *this;
;;;388        }
;;;389    
;;;390        template<typename Type> Type Rectangle<Type>::get_width() const
;;;391        {
;;;392          return right - left;
;;;393        }
;;;394    
;;;395        template<typename Type> Type Rectangle<Type>::get_height() const
;;;396        {
;;;397          return bottom - top;
;;;398        }
;;;399    
;;;400        // #pragma mark --- Rectangle Specializations ---
;;;401        template<> void Rectangle<f32>::Print() const;
;;;402        template<> void Rectangle<f64>::Print() const;
;;;403    
;;;404        // #pragma mark --- Quadrilateral Definitions ---
;;;405    
;;;406        template<typename Type> Quadrilateral<Type>::Quadrilateral()
;;;407        {
;;;408          for(s32 i=0; i<4; i++) {
;;;409            corners[i] = Point<Type>();
;;;410          }
;;;411        }
;;;412    
;;;413        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Point<Type> &corner1, const Point<Type> &corner2, const Point<Type> &corner3, const Point<Type> &corner4)
;;;414        {
;;;415          corners[0] = corner1;
;;;416          corners[1] = corner2;
;;;417          corners[2] = corner3;
;;;418          corners[3] = corner4;
;;;419        }
;;;420    
;;;421        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Quadrilateral<Type>& quad2)
;;;422        {
;;;423          for(s32 i=0; i<4; i++) {
;;;424            this->corners[i] = quad2.corners[i];
;;;425          }
;;;426        }
;;;427    
;;;428        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Rectangle<Type>& rect)
;;;429        {
;;;430          this->corners[0].x = rect.left;   this->corners[0].y = rect.top;
;;;431          this->corners[1].x = rect.right;  this->corners[1].y = rect.top;
;;;432          this->corners[2].x = rect.left;   this->corners[2].y = rect.bottom;
;;;433          this->corners[3].x = rect.right;  this->corners[3].y = rect.bottom;
;;;434        }
;;;435    
;;;436        template<typename Type> void Quadrilateral<Type>::Print() const
;;;437        {
;;;438          CoreTechPrint("{(%d,%d), (%d,%d), (%d,%d), (%d,%d)} ",
;;;439            this->corners[0].x, this->corners[0].y,
;;;440            this->corners[1].x, this->corners[1].y,
;;;441            this->corners[2].x, this->corners[2].y,
;;;442            this->corners[3].x, this->corners[3].y);
;;;443        }
;;;444    
;;;445        template<typename Type> template<typename OutType> Point<OutType> Quadrilateral<Type>::ComputeCenter() const
;;;446        {
;;;447          Point<OutType> center(0, 0);
;;;448    
;;;449          for(s32 i=0; i<4; i++) {
;;;450            center.x += static_cast<OutType>(this->corners[i].x);
;;;451            center.y += static_cast<OutType>(this->corners[i].y);
;;;452          }
;;;453    
;;;454          center.x /= 4;
;;;455          center.y /= 4;
;;;456    
;;;457          return center;
;;;458        }
;;;459    
;;;460        template<typename Type> template<typename OutType> Rectangle<OutType> Quadrilateral<Type>::ComputeBoundingRectangle() const
;;;461        {
;;;462          Rectangle<OutType> boundingRect(
;;;463            static_cast<OutType>(this->corners[0].x),
;;;464            static_cast<OutType>(this->corners[0].x),
;;;465            static_cast<OutType>(this->corners[0].y),
;;;466            static_cast<OutType>(this->corners[0].y));
;;;467    
;;;468          // Initialize the template rectangle to the bounding box of the given
;;;469          // quadrilateral
;;;470          for(s32 i=1; i<4; ++i) {
;;;471            boundingRect.left   = MIN(boundingRect.left,   static_cast<OutType>(this->corners[i].x));
;;;472            boundingRect.right  = MAX(boundingRect.right,  static_cast<OutType>(this->corners[i].x));
;;;473            boundingRect.top    = MIN(boundingRect.top,    static_cast<OutType>(this->corners[i].y));
;;;474            boundingRect.bottom = MAX(boundingRect.bottom, static_cast<OutType>(this->corners[i].y));
;;;475          }
;;;476    
;;;477          return boundingRect;
;;;478        }
;;;479    
                          ENDP


                          AREA ||area_number.280||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE24ComputeBoundingRectangleIiEENS0_9RectangleIT_EEv, LINKORDER=||t._ZNK4Anki8Embedded13QuadrilateralIfE24ComputeBoundingRectangleIiEENS0_9RectangleIT_EEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.280||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded13QuadrilateralIfE24ComputeBoundingRectangleIiEENS0_9RectangleIT_EEv||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1Ev||, COMGROUP=_ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1Ev, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC2Ev                  ; Alternate entry point ; Anki::Embedded::ArraySlice<Anki::Embedded::Point<short>>::ArraySlice__sub_object()
                  _ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1Ev PROC ; Anki::Embedded::ArraySlice<Anki::Embedded::Point<short>>::ArraySlice()
;;;73     
;;;74         template<typename Type> ArraySlice<Type>::ArraySlice()
;;;75           : ConstArraySlice<Type>(), arrayData(NULL)
;;;76         {
;;;77         }
;;;78     
000000  b570              PUSH     {r4-r6,lr}
000002  f04f34ff          MOV      r4,#0xffffffff
000006  6004              STR      r4,[r0,#0]
000008  6044              STR      r4,[r0,#4]
00000a  4601              MOV      r1,r0
00000c  6084              STR      r4,[r0,#8]
00000e  f8404f0c          STR      r4,[r0,#0xc]!
000012  2500              MOVS     r5,#0
000014  6044              STR      r4,[r0,#4]
000016  6084              STR      r4,[r0,#8]
000018  f1010024          ADD      r0,r1,#0x24
00001c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000020  f8404d0c          STR      r4,[r0,#-0xc]!
000024  6044              STR      r4,[r0,#4]
000026  6105              STR      r5,[r0,#0x10]
000028  6084              STR      r4,[r0,#8]
00002a  3818              SUBS     r0,r0,#0x18
00002c  62c5              STR      r5,[r0,#0x2c]
00002e  6305              STR      r5,[r0,#0x30]
000030  bd70              POP      {r4-r6,pc}
                          ENDP


                          AREA ||area_number.287||, COMGROUP=_ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1Ev, LINKORDER=||t._ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.287||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_5PointIsEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_5PointIsEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_5PointIsEEEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS0_5PointIsEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L293.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L293.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L293.384|
000044  a25c              ADR      r2,|L293.440|
000046  a160              ADR      r1,|L293.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L293.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L293.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L293.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L293.384|
000080  a24d              ADR      r2,|L293.440|
000082  a157              ADR      r1,|L293.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L293.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L293.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L293.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L293.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L293.384|
0000c8  a251              ADR      r2,|L293.528|
0000ca  a156              ADR      r1,|L293.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L293.372|
                  |L293.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L293.384|
0000e0  a258              ADR      r2,|L293.580|
0000e2  a15f              ADR      r1,|L293.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L293.372|
                  |L293.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L293.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L293.384|
000110  a259              ADR      r2,|L293.632|
000112  a144              ADR      r1,|L293.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L293.372|
                  |L293.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L293.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L293.384|
00015a  a251              ADR      r2,|L293.672|
00015c  a140              ADR      r1,|L293.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L293.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L293.380|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_5PointIsEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L293.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L293.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L293.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L293.476|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_5PointIsEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L293.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L293.524|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_5PointIsEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L293.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L293.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L293.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L293.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L293.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L293.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.294||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_5PointIsEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_5PointIsEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.294||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_5PointIsEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded16SerializedBuffer29DeserializeRawFixedLengthListINS0_5PointIsEEEENS0_15FixedLengthListIT_EEPcPPvRiRNS0_11MemoryStackE||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer29DeserializeRawFixedLengthListINS0_5PointIsEEEENS0_15FixedLengthListIT_EEPcPPvRiRNS0_11MemoryStackE, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded16SerializedBuffer29DeserializeRawFixedLengthListINS0_5PointIsEEEENS0_15FixedLengthListIT_EEPcPPvRiRNS0_11MemoryStackE PROC ; Anki::Embedded::SerializedBuffer::DeserializeRawFixedLengthList<Anki::Embedded::Point<short>>(char*, void**, int&, Anki::Embedded::MemoryStack&)
;;;439    
;;;440        template<typename Type> FixedLengthList<Type> SerializedBuffer::DeserializeRawFixedLengthList(char *objectName, void ** buffer, s32 &bufferLength, MemoryStack &memory)
000000  b5f0              PUSH     {r4-r7,lr}
;;;441        {
000002  b09b              SUB      sp,sp,#0x6c
000004  4604              MOV      r4,r0
;;;442          ArraySlice<Type> arraySlice = SerializedBuffer::DeserializeRawArraySlice<Type>(objectName, buffer, bufferLength, memory);
000006  f8ddc080          LDR      r12,[sp,#0x80]
00000a  a80e              ADD      r0,sp,#0x38
00000c  f8cdc000          STR      r12,[sp,#0]
000010  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer24DeserializeRawArraySliceINS0_5PointIsEEEENS0_10ArraySliceIT_EEPcPPvRiRNS0_11MemoryStackE ; Anki::Embedded::SerializedBuffer::DeserializeRawArraySlice<Anki::Embedded::Point<short>>(char*, void**, int&, Anki::Embedded::MemoryStack&)
000014  9818              LDR      r0,[sp,#0x60]
000016  2800              CMP      r0,#0
000018  d031              BEQ      |L300.126|
00001a  9814              LDR      r0,[sp,#0x50]
00001c  2800              CMP      r0,#0
00001e  bfa4              ITT      GE
000020  9815              LDRGE    r0,[sp,#0x54]
000022  2800              CMPGE    r0,#0
000024  db2b              BLT      |L300.126|
;;;443    
;;;444          if(!arraySlice.IsValid())
;;;445            return FixedLengthList<Type>();
;;;446    
;;;447          FixedLengthList<Type> out;
000026  a801              ADD      r0,sp,#4
000028  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
;;;448    
;;;449          out.ySlice = arraySlice.get_ySlice();
00002c  e9dd010e          LDRD     r0,r1,[sp,#0x38]
000030  9a10              LDR      r2,[sp,#0x40]
000032  9203              STR      r2,[sp,#0xc]
000034  e9cd0101          STRD     r0,r1,[sp,#4]
;;;450          out.xSlice = arraySlice.get_xSlice();
000038  e9dd0111          LDRD     r0,r1,[sp,#0x44]
00003c  9a13              LDR      r2,[sp,#0x4c]
00003e  e9cd0104          STRD     r0,r1,[sp,#0x10]
000042  9814              LDR      r0,[sp,#0x50]
000044  9206              STR      r2,[sp,#0x18]
000046  9007              STR      r0,[sp,#0x1c]
000048  9815              LDR      r0,[sp,#0x54]
00004a  9008              STR      r0,[sp,#0x20]
00004c  9816              LDR      r0,[sp,#0x58]
00004e  9009              STR      r0,[sp,#0x24]
000050  9817              LDR      r0,[sp,#0x5c]
000052  900a              STR      r0,[sp,#0x28]
000054  9818              LDR      r0,[sp,#0x60]
000056  9a09              LDR      r2,[sp,#0x24]
;;;451          out.array = arraySlice.get_array();
;;;452          out.arrayData = out.array.Pointer(0,0);;
000058  2100              MOVS     r1,#0
00005a  fb010102          MLA      r1,r1,r2,r0
00005e  f10d0e04          ADD      lr,sp,#4
000062  900b              STR      r0,[sp,#0x2c]
000064  910d              STR      r1,[sp,#0x34]
000066  e8be10ef          LDM      lr!,{r0-r3,r5-r7,r12}
00006a  e88410ef          STM      r4,{r0-r3,r5-r7,r12}
00006e  ad09              ADD      r5,sp,#0x24
000070  3420              ADDS     r4,r4,#0x20
000072  e8b5100f          LDM      r5!,{r0-r3,r12}
000076  e8a4100f          STM      r4!,{r0-r3,r12}
;;;453    
;;;454          return out;
;;;455        }
00007a  b01b              ADD      sp,sp,#0x6c
00007c  bdf0              POP      {r4-r7,pc}
                  |L300.126|
00007e  4620              MOV      r0,r4                 ;445
000080  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
000084  b01b              ADD      sp,sp,#0x6c
000086  bdf0              POP      {r4-r7,pc}
;;;456    
                          ENDP


                          AREA ||area_number.301||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer29DeserializeRawFixedLengthListINS0_5PointIsEEEENS0_15FixedLengthListIT_EEPcPPvRiRNS0_11MemoryStackE, LINKORDER=||t._ZN4Anki8Embedded16SerializedBuffer29DeserializeRawFixedLengthListINS0_5PointIsEEEENS0_15FixedLengthListIT_EEPcPPvRiRNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.301||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded16SerializedBuffer29DeserializeRawFixedLengthListINS0_5PointIsEEEENS0_15FixedLengthListIT_EEPcPPvRiRNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIhEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<unsigned char>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L307.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L307.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L307.384|
000044  a25c              ADR      r2,|L307.440|
000046  a160              ADR      r1,|L307.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L307.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  300f              ADDS     r0,r0,#0xf
000064  f020050f          BIC      r5,r0,#0xf
000068  a804              ADD      r0,sp,#0x10
00006a  e9cd0902          STRD     r0,r9,[sp,#8]
00006e  2d00              CMP      r5,#0
000070  dc0a              BGT      |L307.136|
000072  f240310b          MOV      r1,#0x30b
000076  4859              LDR      r0,|L307.476|
000078  e9cd0100          STRD     r0,r1,[sp,#0]
00007c  a340              ADR      r3,|L307.384|
00007e  a24e              ADR      r2,|L307.440|
000080  a157              ADR      r1,|L307.480|
000082  2005              MOVS     r0,#5
000084  f7fffffe          BL       _Anki_Log
                  |L307.136|
000088  4638              MOV      r0,r7
00008a  2f01              CMP      r7,#1
00008c  bfd8              IT       LE
00008e  2001              MOVLE    r0,#1
000090  60a5              STR      r5,[r4,#8]
000092  4345              MULS     r5,r0,r5
000094  a803              ADD      r0,sp,#0xc
000096  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009a  4602              MOV      r2,r0
00009c  4629              MOV      r1,r5
00009e  4640              MOV      r0,r8
0000a0  9b02              LDR      r3,[sp,#8]
0000a2  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a6  f8cd900c          STR      r9,[sp,#0xc]
0000aa  f8dd8010          LDR      r8,[sp,#0x10]
0000ae  f8df915c          LDR      r9,|L307.524|
0000b2  0005              MOVS     r5,r0
0000b4  d00e              BEQ      |L307.212|
0000b6  f1b80f10          CMP      r8,#0x10
0000ba  d21e              BCS      |L307.250|
0000bc  f2403023          MOV      r0,#0x323
0000c0  e9cd9000          STRD     r9,r0,[sp,#0]
0000c4  a32e              ADR      r3,|L307.384|
0000c6  a252              ADR      r2,|L307.528|
0000c8  a156              ADR      r1,|L307.548|
0000ca  2005              MOVS     r0,#5
0000cc  f7fffffe          BL       _Anki_Log
0000d0  f000b84f          B.W      |L307.370|
                  |L307.212|
0000d4  f240301e          MOV      r0,#0x31e
0000d8  e9cd9000          STRD     r9,r0,[sp,#0]
0000dc  a328              ADR      r3,|L307.384|
0000de  a259              ADR      r2,|L307.580|
0000e0  a15f              ADR      r1,|L307.608|
0000e2  2005              MOVS     r0,#5
0000e4  f7fffffe          BL       _Anki_Log
0000e8  f8c4b000          STR      r11,[r4,#0]
0000ec  f8c4b004          STR      r11,[r4,#4]
0000f0  f8c4b008          STR      r11,[r4,#8]
0000f4  f8c4a010          STR      r10,[r4,#0x10]
0000f8  e03b              B        |L307.370|
                  |L307.250|
0000fa  a803              ADD      r0,sp,#0xc
0000fc  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000100  2800              CMP      r0,#0
000102  d00a              BEQ      |L307.282|
000104  f2403026          MOV      r0,#0x326
000108  e9cd9000          STRD     r9,r0,[sp,#0]
00010c  a31c              ADR      r3,|L307.384|
00010e  a25a              ADR      r2,|L307.632|
000110  a144              ADR      r1,|L307.548|
000112  2005              MOVS     r0,#5
000114  f7fffffe          BL       _Anki_Log
000118  e02b              B        |L307.370|
                  |L307.282|
00011a  9903              LDR      r1,[sp,#0xc]
00011c  e9c41503          STRD     r1,r5,[r4,#0xc]
000120  f105000f          ADD      r0,r5,#0xf
000124  f020000f          BIC      r0,r0,#0xf
000128  e9c47600          STRD     r7,r6,[r4,#0]
00012c  1b40              SUBS     r0,r0,r5
00012e  2e01              CMP      r6,#1
000130  bfd8              IT       LE
000132  2601              MOVLE    r6,#1
000134  f106010f          ADD      r1,r6,#0xf
000138  f021010f          BIC      r1,r1,#0xf
00013c  fb010107          MLA      r1,r1,r7,r0
000140  4541              CMP      r1,r8
000142  bfdc              ITT      LE
000144  1829              ADDLE    r1,r5,r0
000146  6121              STRLE    r1,[r4,#0x10]
000148  dd13              BLE      |L307.370|
00014a  f2403035          MOV      r0,#0x335
00014e  f8cd9000          STR      r9,[sp,#0]
000152  e9cd0101          STRD     r0,r1,[sp,#4]
000156  a30a              ADR      r3,|L307.384|
000158  a251              ADR      r2,|L307.672|
00015a  a141              ADR      r1,|L307.608|
00015c  2005              MOVS     r0,#5
00015e  f7fffffe          BL       _Anki_Log
000162  f8c4b000          STR      r11,[r4,#0]
000166  f8c4b004          STR      r11,[r4,#4]
00016a  f8c4b008          STR      r11,[r4,#8]
00016e  f8c4a010          STR      r10,[r4,#0x10]
                  |L307.370|
000172  b005              ADD      sp,sp,#0x14
000174  4620              MOV      r0,r4
000176  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

00017a  0000              DCW      0x0000
                  |L307.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L307.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L307.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L307.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L307.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L307.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L307.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L307.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L307.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L307.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L307.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L307.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L307.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.308||, COMGROUP=_ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.308||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIhE3SetERKS2_||, COMGROUP=_ZN4Anki8Embedded5ArrayIhE3SetERKS2_, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIhE3SetERKS2_ PROC ; Anki::Embedded::Array<unsigned char>::Set(const Anki::Embedded::Array<unsigned char>&)
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;656        {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
000008  b083              SUB      sp,sp,#0xc
00000a  2100              MOVS     r1,#0
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000012  4607              MOV      r7,r0
000014  2101              MOVS     r1,#1
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00001c  4606              MOV      r6,r0
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000024  f8df8094          LDR      r8,|L314.188|
000028  f04f0900          MOV      r9,#0
00002c  2800              CMP      r0,#0
;;;657          return this->SetCast<Type>(in);
00002e  d018              BEQ      |L314.98|
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000036  2800              CMP      r0,#0
000038  d013              BEQ      |L314.98|
00003a  6820              LDR      r0,[r4,#0]
00003c  42b8              CMP      r0,r7
00003e  bf04              ITT      EQ
000040  6861              LDREQ    r1,[r4,#4]
000042  42b1              CMPEQ    r1,r6
000044  d01b              BEQ      |L314.126|
000046  f44f7027          MOV      r0,#0x29c
00004a  e9cd8000          STRD     r8,r0,[sp,#0]
00004e  a31c              ADR      r3,|L314.192|
000050  a229              ADR      r2,|L314.248|
000052  a12f              ADR      r1,|L314.272|
000054  2005              MOVS     r0,#5
000056  f7fffffe          BL       _Anki_Log
;;;658        }
00005a  b003              ADD      sp,sp,#0xc
00005c  4648              MOV      r0,r9
00005e  e8bd83f0          POP      {r4-r9,pc}
                  |L314.98|
000062  f2402099          MOV      r0,#0x299
000066  e9cd8000          STRD     r8,r0,[sp,#0]
00006a  a315              ADR      r3,|L314.192|
00006c  a22d              ADR      r2,|L314.292|
00006e  a128              ADR      r1,|L314.272|
000070  2005              MOVS     r0,#5
000072  f7fffffe          BL       _Anki_Log
000076  b003              ADD      sp,sp,#0xc
000078  4648              MOV      r0,r9
00007a  e8bd83f0          POP      {r4-r9,pc}
                  |L314.126|
00007e  2100              MOVS     r1,#0
000080  2800              CMP      r0,#0
000082  dd16              BLE      |L314.178|
                  |L314.132|
000084  68aa              LDR      r2,[r5,#8]
000086  6928              LDR      r0,[r5,#0x10]
000088  fb010c02          MLA      r12,r1,r2,r0
00008c  68a2              LDR      r2,[r4,#8]
00008e  6920              LDR      r0,[r4,#0x10]
000090  fb010302          MLA      r3,r1,r2,r0
000094  6862              LDR      r2,[r4,#4]
000096  2000              MOVS     r0,#0
000098  2a00              CMP      r2,#0
00009a  dd06              BLE      |L314.170|
                  |L314.156|
00009c  f81c2000          LDRB     r2,[r12,r0]
0000a0  541a              STRB     r2,[r3,r0]
0000a2  6862              LDR      r2,[r4,#4]
0000a4  1c40              ADDS     r0,r0,#1
0000a6  4282              CMP      r2,r0
0000a8  dcf8              BGT      |L314.156|
                  |L314.170|
0000aa  6820              LDR      r0,[r4,#0]
0000ac  1c49              ADDS     r1,r1,#1
0000ae  4288              CMP      r0,r1
0000b0  dce8              BGT      |L314.132|
                  |L314.178|
0000b2  6861              LDR      r1,[r4,#4]
0000b4  b003              ADD      sp,sp,#0xc
0000b6  4348              MULS     r0,r1,r0
0000b8  e8bd83f0          POP      {r4-r9,pc}
;;;659    
                          ENDP

                  |L314.188|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
                  |L314.192|
0000c0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
0000c4  6f726574
0000c8  6563685c
0000cc  636f6d6d
0000d0  6f6e5c69
0000d4  6e636c75
0000d8  64655c61
0000dc  6e6b692f
0000e0  636f6d6d
0000e4  6f6e2f72
0000e8  6f626f74
0000ec  2f617272
0000f0  617932  
0000f3  642e6800          DCB      "d.h",0
0000f7  00                DCB      0
                  |L314.248|
0000f8  41727261          DCB      "Array sizes don't match",0
0000fc  79207369
000100  7a657320
000104  646f6e27
000108  74206d61
00010c  74636800
                  |L314.272|
000110  41727261          DCB      "Array<Type>::Set",0
000114  793c5479
000118  70653e3a
00011c  3a536574
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L314.292|
000124  496e7661          DCB      "Invalid objects",0
000128  6c696420
00012c  6f626a65
000130  63747300

                          AREA ||area_number.315||, COMGROUP=_ZN4Anki8Embedded5ArrayIhE3SetERKS2_, LINKORDER=||t._ZN4Anki8Embedded5ArrayIhE3SetERKS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.315||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIhE3SetERKS2_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC2EiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList__sub_object(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;75     
;;;76         template<typename Type> FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;77           : ArraySlice<Type>(Array<Type>(1, maximumSize, memory, flags), LinearSequence<s32>(0,0), LinearSequence<s32>(0,0))
;;;78         {
;;;79           if(this->array.get_numElements() == 0) {
;;;80             this->arrayData = NULL;
;;;81           } else {
;;;82             this->arrayData = this->array.Pointer(0,0);
;;;83           }
;;;84     
;;;85           if(flags.get_isFullyAllocated()) {
;;;86             this->set_size(maximumSize);
;;;87           } else {
;;;88             this->set_size(0);
;;;89           }
;;;90         } // FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;91     
000000  e92d41ff          PUSH     {r0-r8,lr}
000004  4690              MOV      r8,r2
000006  b090              SUB      sp,sp,#0x40
000008  460d              MOV      r5,r1
00000a  4604              MOV      r4,r0
00000c  2200              MOVS     r2,#0
00000e  4611              MOV      r1,r2
000010  a80c              ADD      r0,sp,#0x30
000012  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000016  4607              MOV      r7,r0
000018  2200              MOVS     r2,#0
00001a  4611              MOV      r1,r2
00001c  a809              ADD      r0,sp,#0x24
00001e  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000022  4606              MOV      r6,r0
000024  9813              LDR      r0,[sp,#0x4c]
000026  9000              STR      r0,[sp,#0]
000028  4643              MOV      r3,r8
00002a  462a              MOV      r2,r5
00002c  2101              MOVS     r1,#1
00002e  a804              ADD      r0,sp,#0x10
000030  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_5PointIsEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000034  e9cd6702          STRD     r6,r7,[sp,#8]
000038  e9d01203          LDRD     r1,r2,[r0,#0xc]
00003c  e9cd1200          STRD     r1,r2,[sp,#0]
000040  e9d01200          LDRD     r1,r2,[r0,#0]
000044  6883              LDR      r3,[r0,#8]
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_ ; Anki::Embedded::ArraySlice<Anki::Embedded::Point<short>>::ArraySlice(Anki::Embedded::Array<Anki::Embedded::Point<short>>, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
00004c  4604              MOV      r4,r0
00004e  6980              LDR      r0,[r0,#0x18]
000050  2800              CMP      r0,#0
000052  bfc4              ITT      GT
000054  69e2              LDRGT    r2,[r4,#0x1c]
000056  2a00              CMPGT    r2,#0
000058  dd1f              BLE      |L321.154|
00005a  4350              MULS     r0,r2,r0
00005c  b1e8              CBZ      r0,|L321.154|
00005e  6a22              LDR      r2,[r4,#0x20]
000060  6aa1              LDR      r1,[r4,#0x28]
000062  2000              MOVS     r0,#0
000064  fb001002          MLA      r0,r0,r2,r1
                  |L321.104|
000068  6320              STR      r0,[r4,#0x30]
00006a  a813              ADD      r0,sp,#0x4c
00006c  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
000070  b1a8              CBZ      r0,|L321.158|
000072  2101              MOVS     r1,#1
000074  f1040018          ADD      r0,r4,#0x18
000078  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const
00007c  4601              MOV      r1,r0
00007e  2d00              CMP      r5,#0
000080  bfac              ITE      GE
000082  4628              MOVGE    r0,r5
000084  2000              MOVLT    r0,#0
000086  4288              CMP      r0,r1
000088  dc11              BGT      |L321.174|
00008a  2d00              CMP      r5,#0
00008c  bfb8              IT       LT
00008e  2500              MOVLT    r5,#0
                  |L321.144|
000090  4620              MOV      r0,r4
000092  60e5              STR      r5,[r4,#0xc]
000094  b014              ADD      sp,sp,#0x50
000096  e8bd81f0          POP      {r4-r8,pc}
                  |L321.154|
00009a  2000              MOVS     r0,#0
00009c  e7e4              B        |L321.104|
                  |L321.158|
00009e  2500              MOVS     r5,#0
0000a0  2101              MOVS     r1,#1
0000a2  f1040018          ADD      r0,r4,#0x18
0000a6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const
0000aa  42a8              CMP      r0,r5
0000ac  daf0              BGE      |L321.144|
                  |L321.174|
0000ae  2101              MOVS     r1,#1
0000b0  f1040018          ADD      r0,r4,#0x18
0000b4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const
0000b8  4605              MOV      r5,r0
0000ba  e7e9              B        |L321.144|
                          ENDP


                          AREA ||area_number.322||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.322||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||i._ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_ PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::operator =(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&)
000000  e9d12300          LDRD     r2,r3,[r1,#0]
000004  f8d1c008          LDR      r12,[r1,#8]
000008  f8c0c008          STR      r12,[r0,#8]
00000c  e9c02300          STRD     r2,r3,[r0,#0]
000010  e9d12303          LDRD     r2,r3,[r1,#0xc]
000014  f8d1c014          LDR      r12,[r1,#0x14]
000018  f8c0c014          STR      r12,[r0,#0x14]
00001c  e9c02303          STRD     r2,r3,[r0,#0xc]
000020  698b              LDR      r3,[r1,#0x18]
000022  6183              STR      r3,[r0,#0x18]
000024  69cb              LDR      r3,[r1,#0x1c]
000026  61c3              STR      r3,[r0,#0x1c]
000028  6a0b              LDR      r3,[r1,#0x20]
00002a  6203              STR      r3,[r0,#0x20]
00002c  6a4b              LDR      r3,[r1,#0x24]
00002e  6243              STR      r3,[r0,#0x24]
000030  6a8b              LDR      r3,[r1,#0x28]
000032  6283              STR      r3,[r0,#0x28]
000034  6aca              LDR      r2,[r1,#0x2c]
000036  62c2              STR      r2,[r0,#0x2c]
000038  6b09              LDR      r1,[r1,#0x30]
00003a  6301              STR      r1,[r0,#0x30]
00003c  4770              BX       lr
                          ENDP


                          AREA ||area_number.329||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_, LINKORDER=||i._ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.329||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEaSERKS4_||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded9RectangleIiE22ComputeScaledRectangleIiEENS1_IT_EEf||, COMGROUP=_ZNK4Anki8Embedded9RectangleIiE22ComputeScaledRectangleIiEENS1_IT_EEf, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded9RectangleIiE22ComputeScaledRectangleIiEENS1_IT_EEf PROC ; Anki::Embedded::Rectangle<int>::ComputeScaledRectangle<int>(float) const
;;;174          // If scalePercent is greater-than 1.0, the rectangle is expanded around its center
;;;175          template<typename OutType> Rectangle<OutType> ComputeScaledRectangle(const f32 scalePercent) const;
000000  b410              PUSH     {r4}
000002  e9d1c200          LDRD     r12,r2,[r1,#0]
000006  eba2030c          SUB      r3,r2,r12
00000a  ee003a90          VMOV     s1,r3
00000e  68cb              LDR      r3,[r1,#0xc]
000010  6889              LDR      r1,[r1,#8]
000012  eeb81ae0          VCVT.F32.S32 s2,s1
000016  1a5c              SUBS     r4,r3,r1
000018  ee004a90          VMOV     s1,r4
00001c  ee212a00          VMUL.F32 s4,s2,s0
000020  eef80ae0          VCVT.F32.S32 s1,s1
000024  ee601a80          VMUL.F32 s3,s1,s0
000028  ee320a41          VSUB.F32 s0,s4,s2
00002c  eeb61a00          VMOV.F32 s2,#0.50000000
000030  ee023a10          VMOV     s4,r3
000034  ee710ae0          VSUB.F32 s1,s3,s1
000038  ee200a01          VMUL.F32 s0,s0,s2
00003c  ee012a90          VMOV     s3,r2
000040  eeb82ac2          VCVT.F32.S32 s4,s4
000044  ee600a81          VMUL.F32 s1,s1,s2
000048  ee01ca10          VMOV     s2,r12
00004c  eef81ae1          VCVT.F32.S32 s3,s3
000050  eeb81ac1          VCVT.F32.S32 s2,s2
000054  ee311a40          VSUB.F32 s2,s2,s0
000058  ee310a80          VADD.F32 s0,s3,s0
00005c  eebd1ac1          VCVT.S32.F32 s2,s2
000060  eefd1ac0          VCVT.S32.F32 s3,s0
000064  ee001a10          VMOV     s0,r1
000068  ed801a00          VSTR     s2,[r0,#0]
00006c  edc01a01          VSTR     s3,[r0,#4]
000070  eeb80ac0          VCVT.F32.S32 s0,s0
000074  ee300a60          VSUB.F32 s0,s0,s1
000078  ee720a20          VADD.F32 s1,s4,s1
00007c  eebd0ac0          VCVT.S32.F32 s0,s0
000080  eefd0ae0          VCVT.S32.F32 s1,s1
000084  ed800a02          VSTR     s0,[r0,#8]
000088  edc00a03          VSTR     s1,[r0,#0xc]
00008c  bc10              POP      {r4}
00008e  4770              BX       lr
;;;176    
;;;177          bool operator== (const Rectangle<Type> &rect2) const;
;;;178    
;;;179          Rectangle<Type> operator+ (const Rectangle<Type> &rect2) const;
;;;180    
;;;181          Rectangle<Type> operator- (const Rectangle<Type> &rect2) const;
;;;182    
;;;183          inline Rectangle<Type>& operator= (const Rectangle<Type> &rect2);
;;;184    
;;;185          // right - left
;;;186          Type get_width() const;
;;;187    
;;;188          // bottom - top
;;;189          Type get_height() const;
;;;190        }; // class Rectangle<Type>
;;;191    
;;;192    #if 0
;;;193    #pragma mark --- Pose2d Class Declaration ---
;;;194    #endif
;;;195        class Pose2d
;;;196        {
;;;197        public:
;;;198          // Constructors:
;;;199          Pose2d() : coord(0,0), angle(0) {}
;;;200          Pose2d(const float x, const float y, const Radians angle) : coord(x,y), angle(angle) {};
;;;201          Pose2d(const Pose2d &other) {
;;;202            *this = other;
;;;203          }
;;;204    
;;;205          // Accessors:
;;;206          float   GetX()     const {return coord.x;}
;;;207          float   GetY()     const {return coord.y;}
;;;208          Point2f get_xy()    const {return coord;}
;;;209          Radians GetAngle() const {return angle;}
;;;210    
;;;211          float& x() {return coord.x;}
;;;212          float& y() {return coord.y;}
;;;213    
;;;214          void operator=(const Pose2d &other) {
;;;215            this->coord = other.coord;
;;;216            this->angle = other.angle;
;;;217          }
;;;218    
;;;219          Point2f coord;
;;;220          Radians angle;
;;;221        }; // class Pose2d
;;;222    
;;;223        // Compute the difference between two 3D poses (Rotations+Translations)
;;;224        // All R matrices should be 3x3.
;;;225        //    [R2 T2] = [R1 T1] * [Rdiff Tdiff]
;;;226        // I.e., the diff pose is the one that takes pose 1 to pose 2.
;;;227        template<typename Type>
;;;228        Result ComputePoseDiff(const Array<Type>& R1, const Point3<Type>& T1,
;;;229          const Array<Type>& R2, const Point3<Type>& T2,
;;;230          Array<Type>& Rdiff, Point3<Type>& Tdiff,
;;;231          MemoryStack scratch);
;;;232    
;;;233    #if 0
;;;234    #pragma mark --- Quadrilateral Class Declaration ---
;;;235    #endif
;;;236        // A Quadrilateral is defined by four Point objects
;;;237        template<typename Type> class Quadrilateral
;;;238        {
;;;239        public:
;;;240          enum CornerName {
;;;241            FirstCorner = 0,
;;;242            TopLeft     = 0,
;;;243            BottomLeft  = 1,
;;;244            TopRight    = 2,
;;;245            BottomRight = 3,
;;;246            NumCorners  = 4
;;;247          };
;;;248    
;;;249          Point<Type> corners[4];
;;;250    
;;;251          Quadrilateral();
;;;252    
;;;253          Quadrilateral(const Point<Type> &corner1, const Point<Type> &corner2, const Point<Type> &corner3, const Point<Type> &corner4);
;;;254    
;;;255          Quadrilateral(const Quadrilateral<Type>& quad);
;;;256    
;;;257          Quadrilateral(const Rectangle<Type>& rect);
;;;258    
;;;259          void Print() const;
;;;260    
;;;261          template<typename OutType> Point<OutType> ComputeCenter() const;
;;;262    
;;;263          // WARNING:
;;;264          // The width and height of a floating point Rectangle is different than that of an integer rectangle.
;;;265          template<typename OutType> Rectangle<OutType> ComputeBoundingRectangle() const;
;;;266    
;;;267          // Returns a copy of this Quadrilateral with sorted corners, so they are clockwise around the centroid
;;;268          // Warning: This may give weird results for non-convex quadrilaterals
;;;269          template<typename OutType> Quadrilateral<OutType> ComputeClockwiseCorners() const;
;;;270    
;;;271          template<typename OutType> Quadrilateral<OutType> ComputeRotatedCorners(const f32 radians) const;
;;;272    
;;;273          bool IsConvex() const;
;;;274    
;;;275          bool operator== (const Quadrilateral<Type> &quad2) const;
;;;276    
;;;277          Quadrilateral<Type> operator+ (const Quadrilateral<Type> &quad2) const;
;;;278    
;;;279          Quadrilateral<Type> operator- (const Quadrilateral<Type> &quad2) const;
;;;280    
;;;281          inline Quadrilateral<Type>& operator= (const Quadrilateral<Type> &quad2);
;;;282    
;;;283          // Keeping this explicit to avoid accidental setting of quads of
;;;284          // different types
;;;285          template<typename InType> void SetCast(const Quadrilateral<InType> &quad2);
;;;286    
;;;287          inline const Point<Type>& operator[] (const s32 index) const;
;;;288          inline Point<Type>& operator[] (const s32 index);
;;;289        }; // class Quadrilateral<Type>
;;;290      } // namespace Embedded
;;;291    } // namespace Anki
;;;292    
;;;293    #endif // _ANKICORETECHEMBEDDED_COMMON_POINT_DECLARATIONS_H_
;;;20     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;21     #include "anki/common/robot/sequences_declarations.h"
;;;1      /**
;;;2      File: sequences_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      A Sequence is a mathematically-defined, ordered list. The sequence classes allow for operations on sequences, without requiring them to be explicitly evaluated.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/flags_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> class Array;
;;;23         template<typename Type> class FixedLengthList;
;;;24         template<typename Type> class ArraySlice;
;;;25         class MemoryStack;
;;;26     
;;;27         // #pragma mark --- Class Declarations ---
;;;28         template<typename Type> class Sequence
;;;29         {
;;;30         }; // class Sequence
;;;31     
;;;32         // A LinearSequence is like the result of a call to Matlab's linspace() It has a start, end, and
;;;33         // increment. It does not explicitly compute the values in the sequence, so does not require
;;;34         // much memory.
;;;35         //
;;;36         // WARNING:
;;;37         // The "end" of a LinearSequence is computed automatically, and is less-than-or-equal-to the
;;;38         // requested end.
;;;39         template<typename Type> class LinearSequence : public Sequence<Type>
;;;40         {
;;;41         public:
;;;42     
;;;43           LinearSequence();
;;;44     
;;;45           // Matlab equivalent: start:end
;;;46           LinearSequence(const Type start, const Type end);
;;;47     
;;;48           // Matlab equivalent: start:increment:end
;;;49           LinearSequence(const Type start, const Type increment, const Type end);
;;;50     
;;;51           // No Matlab equivalent
;;;52           // NOTE: end is unused. It is just present to prevent confusion with the other polymorphic constructors
;;;53           LinearSequence(const Type start, const Type increment, const Type end, const s32 size);
;;;54     
;;;55           // Explicitly evaluate each element of the sequence, and put the results in an Array.
;;;56           Array<Type> Evaluate(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;57           Result Evaluate(ArraySlice<Type> out) const;
;;;58     
;;;59           Type get_start() const;
;;;60     
;;;61           // NOTE: The increment is meaningless for LinearSequences of size 0 or 1.
;;;62           Type get_increment() const;
;;;63     
;;;64           // Note: End it not computed, as it is tempting to use it as a loop condition, but it is not safe
;;;65           // Type get_end() const;
;;;66     
;;;67           // Matlab equivalent: length(start:increment:end)
;;;68           s32 get_size() const;
;;;69     
;;;70         protected:
;;;71           // For speed, FixedLengthList is allowed to access protected members, instead of having to
;;;72           // construct a new LinearSequence every time an element is popped or pushed
;;;73           template<typename FixedLengthListType> friend class FixedLengthList;
;;;74     
;;;75           s32 size;
;;;76     
;;;77           Type start;
;;;78           Type increment;
;;;79     
;;;80           static s32 computeSize(const Type start, const Type increment, const Type end);
;;;81         }; // class LinearSequence
;;;82     
;;;83         // IndexSequence creates the input for slicing an Array
;;;84         // If start or end is less than 0, it is equivalent to (end+value)
;;;85         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type end, s32 arraySize);
;;;86         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type increment, Type end, s32 arraySize);
;;;87         LinearSequence<s32> IndexSequence(s32 arraySize); // Internally, it sets start==0, end=arraySize-1, like the Matlab colon operator array(:,:)
;;;88     
;;;89         // Linspace only works correctly for f32 and f64. To prevent misusage, trying ints will give a linker error.
;;;90         template<typename Type> LinearSequence<Type> Linspace(const Type start, const Type end, const s32 size);
;;;91     
;;;92         // These do not link, as they are unsafe
;;;93         template<> LinearSequence<u8> Linspace(const u8 start, const u8 end, const s32 size);
;;;94         template<> LinearSequence<s8> Linspace(const s8 start, const s8 end, const s32 size);
;;;95         template<> LinearSequence<u16> Linspace(const u16 start, const u16 end, const s32 size);
;;;96         template<> LinearSequence<s16> Linspace(const s16 start, const s16 end, const s32 size);
;;;97         template<> LinearSequence<u32> Linspace(const u32 start, const u32 end, const s32 size);
;;;98         template<> LinearSequence<s32> Linspace(const s32 start, const s32 end, const s32 size);
;;;99         template<> LinearSequence<u64> Linspace(const u64 start, const u64 end, const s32 size);
;;;100        template<> LinearSequence<s64> Linspace(const s64 start, const s64 end, const s32 size);
;;;101    
;;;102        // TODO: Logspace
;;;103        //template<typename Type> class Logspace : public Sequence<Type>
;;;104        //{
;;;105        //public:
;;;106        //protected:
;;;107        //};
;;;108    
;;;109        // A Meshgrid is like the result of a call to Matlab's meshgrid(). It is made of two
;;;110        // LinearSequence objects, so does not require much memory.
;;;111        template<typename Type> class Meshgrid
;;;112        {
;;;113        public:
;;;114          Meshgrid();
;;;115    
;;;116          // Matlab equivalent: meshgrid(xGridVector, yGridVector)
;;;117          Meshgrid(const LinearSequence<Type> xGridVector, const LinearSequence<Type> yGridVector);
;;;118    
;;;119          // Allocate an Array, and evaluate this Meshgrid object
;;;120          //
;;;121          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;122          // The first suffix X or Y is for the xGrid vs yGrid
;;;123          // The second suffix 1 or 2 is for 1D vs 2D output
;;;124          Array<Type> EvaluateX1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;125          Array<Type> EvaluateX2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;126          Array<Type> EvaluateY1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;127          Array<Type> EvaluateY2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;128    
;;;129          // Evaluate this Meshgrid object into a pre-allocated Array
;;;130          //
;;;131          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;132          Result EvaluateX1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;133          Result EvaluateX2(ArraySlice<Type> out) const;
;;;134          Result EvaluateY1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;135          Result EvaluateY2(ArraySlice<Type> out) const;
;;;136    
;;;137          s32 get_numElements() const;
;;;138    
;;;139          inline const LinearSequence<Type>& get_xGridVector() const;
;;;140    
;;;141          inline const LinearSequence<Type>& get_yGridVector() const;
;;;142    
;;;143        protected:
;;;144          LinearSequence<Type> xGridVector;
;;;145          LinearSequence<Type> yGridVector;
;;;146        };
;;;147      } // namespace Embedded
;;;148    } //namespace Anki
;;;149    
;;;150    #endif // #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;22     
;;;23     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;24     namespace cv
;;;25     {
;;;26       class Mat;
;;;27       template<typename Type> class Mat_;
;;;28     }
;;;29     #endif
;;;30     
;;;31     namespace Anki
;;;32     {
;;;33       namespace Embedded
;;;34       {
;;;35         template<typename Type> class ArraySlice;
;;;36         template<typename Type> class ConstArraySlice;
;;;37         template<typename Type> class ConstArraySliceExpression;
;;;38     
;;;39         const s32 ARRAY_FILE_HEADER_LENGTH = 32;
;;;40         const s32 ARRAY_FILE_HEADER_VALID_LENGTH = 14; //< How many characters are not spaces
;;;41         const char ARRAY_FILE_HEADER[ARRAY_FILE_HEADER_LENGTH+1] = "\x89" "AnkiEArray1.2                  ";
;;;42     
;;;43         // #pragma mark --- Array Class Declaration ---
;;;44     
;;;45         template<typename Type> class Array
;;;46         {
;;;47         public:
;;;48     
;;;49           // The stride is the "numCols*sizeof(Type)" rounded up by 16, plus any boundary padding
;;;50           static s32 ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags);
;;;51     
;;;52           // The minimum required memory is the size of a stride, times the number of rows
;;;53           static s32 ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags);
;;;54     
;;;55           // Initializes Array as invalid
;;;56           Array();
;;;57     
;;;58           // Constructor for a Array, pointing to user-allocated MemoryStack. This is the preferred
;;;59           // method for creating a new Array.
;;;60           //
;;;61           // Flags::Buffer.isFullyAllocated doesn't do anything
;;;62           Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;63     
;;;64           // Constructor for a Array, pointing to user-allocated data. This type of array is more
;;;65           // restrictive than most matrix libraries. For example, it may make it hard to convert from
;;;66           // OpenCV::Mat to Array, though the reverse is trivial.
;;;67           //
;;;68           // If following are true, then the contents of data will not be modified, and it will work as
;;;69           // a normal buffer without extra zeros as stride padding:
;;;70           // 1. (numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0
;;;71           // 2. reinterpret_cast<size_t>(data) % MEMORY_ALIGNMENT == 0
;;;72           // 3. numRows*numCols*sizeof(Type) <= dataLength
;;;73           //
;;;74           // If Flags::Buffer.isFullyAllocated == true, then the input data buffer's stride must be a
;;;75           // simple multiple
;;;76           Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags=Flags::Buffer(false,false,true));
;;;77     
;;;78           // Load an image from file. Requires OpenCV;
;;;79           static Array<Type> LoadImage(const char * filename, MemoryStack &memory);
;;;80     
;;;81           // Load or save an array saved as a debugStream.
;;;82           // compressionLevel can be from 0 (uncompressed) to 9 (most compressed). If OpenCV is not used, it must be zero.
;;;83           static Array<Type> LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory);
;;;84           static Array<Type> LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength); //< allocatedBuffer must be allocated and freed manually
;;;85           Result SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const;
;;;86     
;;;87           // Pointer to the data, at a given (y,x) location
;;;88           //
;;;89           // NOTE:
;;;90           // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;91           // inner loop, like: "Type * restrict pArray = Array.Pointer(5);", then index
;;;92           // pArray in the inner loop.
;;;93           inline const Type* Pointer(const s32 index0, const s32 index1) const;
;;;94           inline Type* Pointer(const s32 index0, const s32 index1);
;;;95     
;;;96           // Use this operator for normal C-style 2d matrix indexing. For example, "array[5][0] = 6;"
;;;97           // will set the element in the fifth row and first column to 6. This is the same as
;;;98           // "array.Pointer(5)[0] = 6;"
;;;99           //
;;;100          // NOTE:
;;;101          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;102          // inner loop, like: "Type * restrict pArray = Array[5];", then index
;;;103          // pArray in the inner loop.
;;;104          inline const Type * operator[](const s32 index0) const;
;;;105          inline Type * operator[](const s32 index0);
;;;106    
;;;107          // Pointer to the data, at a given (y,x) location
;;;108          //
;;;109          // NOTE:
;;;110          // The default order of coordinates for the Point() constructor is (x,y). So for example,
;;;111          // access Array[5][3] via Array.Pointer(Point<s16>(3,5))
;;;112          //
;;;113          // NOTE:
;;;114          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;115          // inner loop, like: "Type * restrict pArray = Array.Pointer(Point<s16>(5,0));", then index
;;;116          // pArray in the inner loop.
;;;117          inline const Type* Pointer(const Point<s16> &point) const;
;;;118          inline Type* Pointer(const Point<s16> &point);
;;;119    
;;;120          // Get the ith element, like Matlab's 1D indexing of a 2D array.
;;;121          // For example, the 5th element of Arrays of size (1,6) and (6,1) is the same;
;;;122          const Type& Element(const s32 elementIndex) const;
;;;123          Type& Element(const s32 elementIndex);
;;;124    
;;;125          // Return a slice accessor for this array, like the Matlab expression "array(1:5, 2:3:5)"
;;;126          //
;;;127          // NOTE:
;;;128          // If min or max is less than 0, it is equivalent to (end+value). For example, "Array(0,-1,3,5)"
;;;129          // is the same as "Array(0,arrayHeight-1,3,5)"
;;;130          ArraySlice<Type> operator() ();
;;;131          ArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;132          ArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX);
;;;133          ArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX);
;;;134          ConstArraySlice<Type> operator() () const;
;;;135          ConstArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const;
;;;136          ConstArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const;
;;;137          ConstArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const;
;;;138    
;;;139          // ArraySlice Transpose doesn't modify the data, it just sets an "isTransposed" flag.
;;;140          // Anything that uses ArraySliceExpression respects this flag. This doesn't include things
;;;141          // like Matrix::Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out) for example.
;;;142          ConstArraySliceExpression<Type> Transpose() const;
;;;143    
;;;144    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;145          // Copies the OpenCV Mat. If needed, it converts from color to grayscale by averaging the color channels.
;;;146          s32 Set(const cv::Mat_<Type> &in);
;;;147    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;148    
;;;149          // Use the simple OpenCV gui to display this array as an image
;;;150          // Does nothing is OpenCV is not available
;;;151          void Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues=false, const bool fitImageToWindow=false) const;
;;;152    
;;;153          // Print out the contents of this Array
;;;154          //
;;;155          // NOTE:
;;;156          // * If the min X or Y is less than zero, it will be treated as zero
;;;157          // * If the max X or Y is greater than the size of the array minus one, it will be treated as
;;;158          //   the size of the array minus one
;;;159          Result Print(const char * const variableName = "Array", const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;160          Result PrintAlternate(const char * const variableName = "Array", const s32 version=2, const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;161    
;;;162          // Checks if this array is equal to another array, up to some allowable
;;;163          // per-element varation, epsilon. If the arrays are not the same size,
;;;164          // false is returned.
;;;165          bool IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const;
;;;166    
;;;167          // Checks the basic parameters of this Array, and if it is allocated.
;;;168          bool IsValid() const;
;;;169    
;;;170          // Resize will use MemoryStack::Reallocate() to change the Array's size. It only works if this
;;;171          // Array was the last thing allocated. The reallocated memory will not be cleared
;;;172          //
;;;173          // WARNING:
;;;174          // This will not update any references to the memory, you must update all references manually.
;;;175          Result Resize(const s32 numRows, const s32 numCols, MemoryStack &memory);
;;;176    
;;;177          // Set every element in the Array to zero, including the stride padding.
;;;178          // Returns the number of bytes set to zero
;;;179          s32 SetZero();
;;;180    
;;;181          // Set every element in the Array to this value
;;;182          // Returns the number of values set
;;;183          s32 Set(const Type value);
;;;184    
;;;185          // Elementwise copies the input Array into this array. No memory is allocated.
;;;186          s32 Set(const Array<Type> &in);
;;;187    
;;;188          // Copy values to this Array.
;;;189          // If the input array does not contain enough elements, the remainder of this Array will be filled with zeros.
;;;190          // Returns the number of values set (not counting extra zeros)
;;;191          s32 Set(const Type * const values, const s32 numValues);
;;;192    
;;;193          // Read in the input, then cast it to this object's type
;;;194          //
;;;195          // WARNING:
;;;196          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;197          template<typename InType> s32 SetCast(const Array<InType> &in);
;;;198          template<typename InType> s32 SetCast(const InType * const values, const s32 numValues);
;;;199    
;;;200          // This is a shallow copy. There's no reference counting. Updating the data of one array will
;;;201          // update that of others (because they point to the same location in memory).
;;;202          // However, Resizing or other operations on one array won't update the others.
;;;203          Array& operator= (const Array & rightHandSide);
;;;204    
;;;205          // Similar to Matlabs size(matrix, dimension), and dimension is in {0,1}
;;;206          s32 get_size(s32 dimension) const;
;;;207    
;;;208          // Get the stride, which is the number of bytes between an element at (n,m) and an element at (n+1,m)
;;;209          s32 get_stride() const;
;;;210    
;;;211          // just size[0] * size[1]
;;;212          s32 get_numElements() const;
;;;213    
;;;214          // Return the flags that were used when this object was constructed.
;;;215          Flags::Buffer get_flags() const;
;;;216    
;;;217          // Equivalent to Pointer(0,0)
;;;218          //
;;;219          // These are for very low-level access to the buffers. Probably you want to be using one of
;;;220          // the Pointer() accessor methods instead of these.
;;;221          void* get_buffer();
;;;222          const void* get_buffer() const;
;;;223    
;;;224        protected:
;;;225          static const s32 HEADER_LENGTH = 8;
;;;226          static const s32 FOOTER_LENGTH = 8;
;;;227    
;;;228          s32 size[2];
;;;229          s32 stride;
;;;230          Flags::Buffer flags;
;;;231    
;;;232          Type * data;
;;;233    
;;;234          // Basic allocation method
;;;235          void* AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate);
;;;236    
;;;237          // Performs checks and sets appropriate parameters for this object
;;;238          Result InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags);
;;;239    
;;;240          // Set all the buffers and sizes to zero, to signal an invalid array
;;;241          void InvalidateArray();
;;;242    
;;;243          // If this object's Type is a basic type, this method prints out this object.
;;;244          Result PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;245    
;;;246          // If this object's Type is a string, this method prints out this object.
;;;247          Result PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;248        }; // class Array
;;;249    
;;;250        // #pragma mark --- FixedPointArray Class Declaration ---
;;;251    
;;;252        template<typename Type> class FixedPointArray : public Array<Type>
;;;253        {
;;;254        public:
;;;255          FixedPointArray();
;;;256    
;;;257          // Same as Array() constructor
;;;258          // This is the preferred method for constructing an FixedPointArray
;;;259          FixedPointArray(const s32 numRows, const s32 numCols, const s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;260    
;;;261          // Same as Array() constructor
;;;262          // This is the advanced method for constructing an FixedPointArray
;;;263          FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;264    
;;;265          s32 get_numFractionalBits() const;
;;;266    
;;;267        protected:
;;;268          s32 numFractionalBits;
;;;269        };
;;;270    
;;;271        // If you don't know the type of the Array you're loading, use this function directly, then cast it based on the read parameters
;;;272        Array<u8> LoadBinaryArray_UnknownType(
;;;273          const char * filename,
;;;274          MemoryStack *scratch,
;;;275          MemoryStack *memory,
;;;276          void * allocatedBuffer,
;;;277          const s32 allocatedBufferLength,
;;;278          u16  &basicType_sizeOfType,
;;;279          bool &basicType_isBasicType,
;;;280          bool &basicType_isInteger,
;;;281          bool &basicType_isSigned,
;;;282          bool &basicType_isFloat,
;;;283          bool &basicType_isString
;;;284          );
;;;285    
;;;286    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;287        // Returns a cv::Mat that mirrors the data in the input Array.
;;;288        // WARNING: If you copy the cv::Mat or assign it incorrectly, it will no longer mirror the input Array
;;;289        // WARNING: This const_casts the input array, so you can unsafely modify it via the output cv::Mat
;;;290        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out);
;;;291    #endif
;;;292      } // namespace Embedded
;;;293    } //namespace Anki
;;;294    
;;;295    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_DECLARATIONS_H_
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;1      /**
;;;2      File: utilities.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of utilities_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;14     
;;;15     #include "anki/common/robot/utilities_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;17     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;2      * File: trig_fast.h
;;;3      *
;;;4      * Author: Kevin Yoon
;;;5      * Created: 22-OCT-2012
;;;6      *
;;;7      * Some trig functions to supplement incomplete math libraries on embedded targets.
;;;8      * Error of all functions is less than +/- 0.01.
;;;9      * For bettery accuracy, lookup tables should be regenerated with u16.
;;;10     *
;;;11     **/
;;;12     #ifndef _TRIG_FAST_H
;;;13     #define _TRIG_FAST_H
;;;14     
;;;15     // When USE_SMALL_LUT defined, a smaller lookup table is used to conserve space.
;;;16     // USE_INTERPOLATION is also automatically defined, since without it answers are probably too wrong to be useful.
;;;17     // If USE_SMALL_LUT is not defined, a large LUT is used.
;;;18     //#define USE_SMALL_LUT
;;;19     
;;;20     // When defined, interpolates between lookup values for higher accuracy.
;;;21     #define USE_INTERPOLATION
;;;22     
;;;23     // Arctangent function based on lookup table
;;;24     // returns answer in radians
;;;25     float atan_fast(float x);
;;;26     
;;;27     // Arcsine function based on lookup table
;;;28     // returns answer in radians
;;;29     float asin_fast(float x);
;;;30     
;;;31     // Arctangent function which uses atan_fast
;;;32     // returns answer in radians
;;;33     float atan2_fast(float y, float x);
;;;34     
;;;35     // Arctangent function which uses asin from math.h
;;;36     // Useful on embedded systems that don't include atan2 in math.h
;;;37     // More accurate than atan2_fast.
;;;38     // Nothing particularly fast about this implementation.
;;;39     // returns answer in radians
;;;40     float atan2_acc(float y, float x);
;;;41     
;;;42     #endif
;;;19     
;;;20     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;21     #include "opencv2/core/core.hpp"
;;;22     #endif
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         //template<typename Type> inline Type RoundUp(const Type number, const Type multiple)
;;;29     
;;;30         // void* and size_t is a special case, good for aligning pointers
;;;31         inline const void* RoundUp(const void* number, const size_t multiple)
;;;32         {
;;;33           const size_t numberT = reinterpret_cast<size_t>(number);
;;;34           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;35         }
;;;36     
;;;37         inline void* RoundUp(void* number, const size_t multiple)
;;;38         {
;;;39           const size_t numberT = reinterpret_cast<size_t>(number);
;;;40           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;41         }
;;;42     
;;;43         template<> inline u32 RoundUp(const u32 number, const u32 multiple)
;;;44         {
;;;45           return (number + (multiple-1)) & ~(multiple-1);
;;;46         }
;;;47     
;;;48         template<> inline s32 RoundUp(const s32 number, const s32 multiple)
;;;49         {
;;;50           if(number <= 0) {
;;;51             return multiple*( number/multiple );
;;;52           } else {
;;;53             return multiple*( (number-1)/multiple + 1 );
;;;54           }
;;;55         }
;;;56     
;;;57     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;58         template<> inline unsigned long RoundUp(const unsigned long number, const unsigned long multiple)
;;;59         {
;;;60           return (number + (multiple-1)) & ~(multiple-1);
;;;61         }
;;;62     #endif
;;;63     
;;;64         template<> inline u32 RoundDown(const u32 number, const u32 multiple)
;;;65         {
;;;66           return multiple * (number/multiple);
;;;67         }
;;;68     
;;;69         template<> inline s32 RoundDown(const s32 number, const s32 multiple)
;;;70         {
;;;71           if(number < 0) {
;;;72             return multiple * ((number-multiple+1) / multiple);
;;;73           } else {
;;;74             return multiple * (number/multiple);
;;;75           }
;;;76         }
;;;77     
;;;78     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;79         template<> inline unsigned long RoundDown(const unsigned long number, const unsigned long multiple)
;;;80         {
;;;81           return multiple * (number/multiple);
;;;82         }
;;;83     #endif
;;;84     
;;;85         template<typename Type> Type ApproximateExp(const Type exponent, const s32 numTerms)
;;;86         {
;;;87           AnkiAssert(numTerms > 2);
;;;88     
;;;89           const Type exponentAbs = ABS(exponent);
;;;90     
;;;91           Type sum = static_cast<Type>(1) + exponentAbs;
;;;92     
;;;93           Type numerator = static_cast<Type>(exponentAbs);
;;;94           Type denominator = static_cast<Type>(1);
;;;95           for(s32 i=2; i<=numTerms; i++) {
;;;96             numerator *= exponentAbs;
;;;97             denominator *= i;
;;;98     
;;;99             sum += numerator / denominator;
;;;100          }
;;;101    
;;;102          if(exponent < 0) {
;;;103            sum = static_cast<Type>(1) / sum;
;;;104          }
;;;105    
;;;106          return sum;
;;;107        }
;;;108    
;;;109        template<typename Type> void Swap(Type &a, Type &b)
;;;110        {
;;;111          const Type tmp = a;
;;;112          a = b;
;;;113          b = tmp;
;;;114        } // template<typename Type> Swap(Type a, Type b)
;;;115    
;;;116        template<typename Type> u32 BinaryStringToUnsignedNumber(const FixedLengthList<Type> &bits, bool firstBitIsLow)
;;;117        {
;;;118          u32 number = 0;
;;;119    
;;;120          const s32 numBits = bits.get_size();
;;;121    
;;;122          for(s32 bit=0; bit<numBits; bit++) {
;;;123            if(firstBitIsLow) {
;;;124              if(bit == 0) {
;;;125                number += bits[bit];
;;;126              } else {
;;;127                number += bits[bit] << bit;
;;;128              }
;;;129            } else {
;;;130              if(bit == (numBits-1)) {
;;;131                number += bits[bit];
;;;132              } else {
;;;133                number += bits[bit] << (numBits - bit - 1);
;;;134              }
;;;135            }
;;;136          }
;;;137    
;;;138          return number;
;;;139        }
;;;140    
;;;141        template<typename Type> Type Determinant2x2(const Type a, const Type b, const Type c, const Type d)
;;;142        {
;;;143          return a*d - b*c;
;;;144        }
;;;145    
;;;146        template<typename Type> Type Determinant3x3(const Type a, const Type b, const Type c, const Type d, const Type e, const Type f, const Type g, const Type h, const Type i)
;;;147        {
;;;148          return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
;;;149        }
;;;150    
;;;151        template<typename Type> void Invert3x3(Type &a, Type &b, Type &c, Type &d, Type &e, Type &f, Type &g, Type &h, Type &i)
;;;152        {
;;;153          const Type determinant = Determinant3x3(a,b,c,d,e,f,g,h,i);
;;;154          const Type determinantInverse = static_cast<Type>(1) / determinant;
;;;155    
;;;156          const Type A =  (e*i - f*h);
;;;157          const Type B = -(d*i - f*g);
;;;158          const Type C =  (d*h - e*g);
;;;159          const Type D = -(b*i - c*h);
;;;160          const Type E =  (a*i - c*g);
;;;161          const Type F = -(a*h - b*g);
;;;162          const Type G =  (b*f - c*e);
;;;163          const Type H = -(a*f - c*d);
;;;164          const Type I =  (a*e - b*d);
;;;165    
;;;166          a = A * determinantInverse;
;;;167          b = D * determinantInverse;
;;;168          c = G * determinantInverse;
;;;169          d = B * determinantInverse;
;;;170          e = E * determinantInverse;
;;;171          f = H * determinantInverse;
;;;172          g = C * determinantInverse;
;;;173          h = F * determinantInverse;
;;;174          i = I * determinantInverse;
;;;175        }
;;;176    
;;;177        template<typename Type> void Cart2Pol(const Type x, const Type y, Type &rho, Type &theta)
;;;178        {
;;;179          if (x==0 && y==0) {
;;;180            theta = 0;
;;;181            rho = 0;
;;;182          } else {
;;;183            theta = atan2f(y, x);
;;;184            rho = sqrtf(x*x + y*y);
;;;185          }
;;;186        }
;;;187    
;;;188        template<typename Type> void Pol2Cart(const Type rho, const Type theta, Type &x, Type &y)
;;;189        {
;;;190          x = rho * cosf(theta);
;;;191          y = rho * sinf(theta);
;;;192        }
;;;193    
;;;194        inline s32 FloorS32(f32 x)
;;;195        {
;;;196          return static_cast<s32>(floorf(x));
;;;197        }
;;;198    
;;;199        inline s32 CeilS32(f32 x)
;;;200        {
;;;201          return static_cast<s32>(ceilf(x));
;;;202        }
;;;203    
;;;204    #if !defined(__EDG__)
;;;205        // Some platforms may not round to zero correctly, so do the function calls
;;;206        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(floorf(v + 0.5f)) : 0; }
;;;207        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(floorf(v + 0.5f)) : 0; }
;;;208        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(floorf(v + 0.5f)) : static_cast<s32>(ceilf(v - 0.5f)); }
;;;209        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(floorf(v + 0.5f)) : static_cast<s64>(ceilf(v - 0.5f)); }
;;;210        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;211        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;212    
;;;213        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(floor(v + 0.5)) : 0; }
;;;214        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(floor(v + 0.5)) : 0; }
;;;215        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(floor(v + 0.5)) : static_cast<s32>(ceil(v - 0.5)); }
;;;216        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(floor(v + 0.5)) : static_cast<s64>(ceil(v - 0.5)); }
;;;217        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;218        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;219    #else
;;;220        // The M4 rounds to zero correctly, without the function calls
;;;221        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(v + 0.5f) : 0; }
;;;222        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(v + 0.5f) : 0; }
;;;223        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(v + 0.5f) : static_cast<s32>(v - 0.5f); }
;;;224        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(v + 0.5f) : static_cast<s64>(v - 0.5f); }
;;;225        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;226        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;227    
;;;228        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(v + 0.5) : 0; }
;;;229        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(v + 0.5) : 0; }
;;;230        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(v + 0.5) : static_cast<s32>(v - 0.5); }
;;;231        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(v + 0.5) : static_cast<s64>(v - 0.5); }
;;;232        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;233        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;234    #endif
;;;235    
;;;236        // Most cases of RoundIfInteger are from int-to-int or float-to-float, so just do a normal cast
;;;237        template<typename Type> inline Type RoundIfInteger(const u8  v) { return static_cast<Type>(v); }
;;;238        template<typename Type> inline Type RoundIfInteger(const s8  v) { return static_cast<Type>(v); }
;;;239        template<typename Type> inline Type RoundIfInteger(const u16 v) { return static_cast<Type>(v); }
;;;240        template<typename Type> inline Type RoundIfInteger(const s16 v) { return static_cast<Type>(v); }
;;;241        template<typename Type> inline Type RoundIfInteger(const u32 v) { return static_cast<Type>(v); }
;;;242        template<typename Type> inline Type RoundIfInteger(const s32 v) { return static_cast<Type>(v); }
;;;243        template<typename Type> inline Type RoundIfInteger(const u64 v) { return static_cast<Type>(v); }
;;;244        template<typename Type> inline Type RoundIfInteger(const s64 v) { return static_cast<Type>(v); }
;;;245        template<typename Type> inline Type RoundIfInteger(const f32 v) { return static_cast<Type>(v); }
;;;246        template<typename Type> inline Type RoundIfInteger(const f64 v) { return static_cast<Type>(v); }
;;;247    
;;;248        // Specialize for cases with float-to-int
;;;249        template<> inline u8  RoundIfInteger(const f32 v) { return static_cast<u8> (Round<s32>(v)); }
;;;250        template<> inline s8  RoundIfInteger(const f32 v) { return static_cast<s8> (Round<s32>(v)); }
;;;251        template<> inline u16 RoundIfInteger(const f32 v) { return static_cast<u16>(Round<s32>(v)); }
;;;252        template<> inline s16 RoundIfInteger(const f32 v) { return static_cast<s16>(Round<s32>(v)); }
;;;253        template<> inline u32 RoundIfInteger(const f32 v) { return static_cast<u32>(Round<u32>(v)); }
;;;254        template<> inline s32 RoundIfInteger(const f32 v) { return static_cast<s32>(Round<s32>(v)); }
;;;255        template<> inline u64 RoundIfInteger(const f32 v) { return static_cast<u64>(Round<u64>(v)); }
;;;256        template<> inline s64 RoundIfInteger(const f32 v) { return static_cast<s64>(Round<s64>(v)); }
;;;257    
;;;258        template<> inline u8  RoundIfInteger(const f64 v) { return static_cast<u8> (Round<s32>(v)); }
;;;259        template<> inline s8  RoundIfInteger(const f64 v) { return static_cast<s8> (Round<s32>(v)); }
;;;260        template<> inline u16 RoundIfInteger(const f64 v) { return static_cast<u16>(Round<s32>(v)); }
;;;261        template<> inline s16 RoundIfInteger(const f64 v) { return static_cast<s16>(Round<s32>(v)); }
;;;262        template<> inline u32 RoundIfInteger(const f64 v) { return static_cast<u32>(Round<u32>(v)); }
;;;263        template<> inline s32 RoundIfInteger(const f64 v) { return static_cast<s32>(Round<s32>(v)); }
;;;264        template<> inline u64 RoundIfInteger(const f64 v) { return static_cast<u64>(Round<u64>(v)); }
;;;265        template<> inline s64 RoundIfInteger(const f64 v) { return static_cast<s64>(Round<s64>(v)); }
;;;266    
;;;267        // Floats and complex data types aren't specialized
;;;268        template<typename Type> inline Type saturate_cast(const u8  v) { return static_cast<Type>(v); }
;;;269        template<typename Type> inline Type saturate_cast(const s8  v) { return static_cast<Type>(v); }
;;;270        template<typename Type> inline Type saturate_cast(const u16 v) { return static_cast<Type>(v); }
;;;271        template<typename Type> inline Type saturate_cast(const s16 v) { return static_cast<Type>(v); }
;;;272        template<typename Type> inline Type saturate_cast(const u32 v) { return static_cast<Type>(v); }
;;;273        template<typename Type> inline Type saturate_cast(const s32 v) { return static_cast<Type>(v); }
;;;274        template<typename Type> inline Type saturate_cast(const u64 v) { return static_cast<Type>(v); }
;;;275        template<typename Type> inline Type saturate_cast(const s64 v) { return static_cast<Type>(v); }
;;;276        template<typename Type> inline Type saturate_cast(const f32 v) { return static_cast<Type>(v); }
;;;277        template<typename Type> inline Type saturate_cast(const f64 v) { return static_cast<Type>(v); }
;;;278    
;;;279        // Most saturate_cast calls are explicitly specialized
;;;280        template<> inline u8  saturate_cast<u8> (const u8  v) { return v; }
;;;281        template<> inline u8  saturate_cast<u8> (const u16 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;282        template<> inline u8  saturate_cast<u8> (const u32 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;283        template<> inline u8  saturate_cast<u8> (const u64 v) { return (u8)             MIN((u64)u8_MAX, (u64)v); }
;;;284        template<> inline u8  saturate_cast<u8> (const s8  v) { return (u8)                              MAX((s32)0, (s32)v);  }
;;;285        template<> inline u8  saturate_cast<u8> (const s16 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;286        template<> inline u8  saturate_cast<u8> (const s32 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;287        template<> inline u8  saturate_cast<u8> (const s64 v) { return (u8)             MIN((s64)u8_MAX, MAX((s64)0, (s64)v)); }
;;;288        template<> inline u8  saturate_cast<u8> (const f32 v) { return (u8) Round<s32>( MIN((f32)u8_MAX, MAX((f32)0, (f32)v)) ); }
;;;289        template<> inline u8  saturate_cast<u8> (const f64 v) { return (u8) Round<s32>( MIN((f64)u8_MAX, MAX((f64)0, (f64)v)) ); }
;;;290    
;;;291        template<> inline s8  saturate_cast<s8> (const u8  v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;292        template<> inline s8  saturate_cast<s8> (const u16 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;293        template<> inline s8  saturate_cast<s8> (const u32 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;294        template<> inline s8  saturate_cast<s8> (const u64 v) { return (s8)             MIN((u64)s8_MAX, (u64)v); }
;;;295        template<> inline s8  saturate_cast<s8> (const s8  v) { return v; }
;;;296        template<> inline s8  saturate_cast<s8> (const s16 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;297        template<> inline s8  saturate_cast<s8> (const s32 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;298        template<> inline s8  saturate_cast<s8> (const s64 v) { return (s8)             MIN((s64)s8_MAX, MAX((s64)s8_MIN, (s64)v)); }
;;;299        template<> inline s8  saturate_cast<s8> (const f32 v) { return (s8) Round<s32>( MIN((f32)s8_MAX, MAX((f32)s8_MIN, (f32)v)) ); }
;;;300        template<> inline s8  saturate_cast<s8> (const f64 v) { return (s8) Round<s32>( MIN((f64)s8_MAX, MAX((f64)s8_MIN, (f64)v)) ); }
;;;301    
;;;302        template<> inline u16 saturate_cast<u16>(const u8  v) { return v; }
;;;303        template<> inline u16 saturate_cast<u16>(const u16 v) { return v; }
;;;304        template<> inline u16 saturate_cast<u16>(const u32 v) { return (u16)             MIN((u32)u16_MAX, (u32)v); }
;;;305        template<> inline u16 saturate_cast<u16>(const u64 v) { return (u16)             MIN((u64)u16_MAX, (u64)v); }
;;;306        template<> inline u16 saturate_cast<u16>(const s8  v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;307        template<> inline u16 saturate_cast<u16>(const s16 v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;308        template<> inline u16 saturate_cast<u16>(const s32 v) { return (u16)             MIN((s32)u16_MAX, MAX((s32)0, (s32)v)); }
;;;309        template<> inline u16 saturate_cast<u16>(const s64 v) { return (u16)             MIN((s64)u16_MAX, MAX((s64)0, (s64)v)); }
;;;310        template<> inline u16 saturate_cast<u16>(const f32 v) { return (u16) Round<s32>( MIN((f32)u16_MAX, MAX((f32)0, (f32)v)) ); }
;;;311        template<> inline u16 saturate_cast<u16>(const f64 v) { return (u16) Round<s32>( MIN((f64)u16_MAX, MAX((f64)0, (f64)v)) ); }
;;;312    
;;;313        template<> inline s16 saturate_cast<s16>(const u8  v) { return v; }
;;;314        template<> inline s16 saturate_cast<s16>(const u16 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;315        template<> inline s16 saturate_cast<s16>(const u32 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;316        template<> inline s16 saturate_cast<s16>(const u64 v) { return (s16)             MIN((u64)s16_MAX, (u64)v); }
;;;317        template<> inline s16 saturate_cast<s16>(const s8  v) { return v; }
;;;318        template<> inline s16 saturate_cast<s16>(const s16 v) { return v; }
;;;319        template<> inline s16 saturate_cast<s16>(const s32 v) { return (s16)             MIN((s32)s16_MAX, MAX((s32)s16_MIN, (s32)v)); }
;;;320        template<> inline s16 saturate_cast<s16>(const s64 v) { return (s16)             MIN((s64)s16_MAX, MAX((s64)s16_MIN, (s64)v)); }
;;;321        template<> inline s16 saturate_cast<s16>(const f32 v) { return (s16) Round<s32>( MIN((f32)s16_MAX, MAX((f32)s16_MIN, (f32)v)) ); }
;;;322        template<> inline s16 saturate_cast<s16>(const f64 v) { return (s16) Round<s32>( MIN((f64)s16_MAX, MAX((f64)s16_MIN, (f64)v)) ); }
;;;323    
;;;324        template<> inline u32 saturate_cast<u32>(const u8  v) { return v; }
;;;325        template<> inline u32 saturate_cast<u32>(const u16 v) { return v; }
;;;326        template<> inline u32 saturate_cast<u32>(const u32 v) { return v; }
;;;327        template<> inline u32 saturate_cast<u32>(const u64 v) { return (u32)             MIN((u64)u32_MAX, (u64)v); }
;;;328        template<> inline u32 saturate_cast<u32>(const s8  v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;329        template<> inline u32 saturate_cast<u32>(const s16 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;330        template<> inline u32 saturate_cast<u32>(const s32 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;331        template<> inline u32 saturate_cast<u32>(const s64 v) { return (u32)             MIN((s64)u32_MAX, MAX((s64)0, (s64)v)); }
;;;332        template<> inline u32 saturate_cast<u32>(const f32 v) { return (u32) (v > (f32)0xFFFFFF7F) ? 0xFFFFFFFF : Round<u32>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;333        template<> inline u32 saturate_cast<u32>(const f64 v) { return (u32) Round<u32>( MIN((f64)u32_MAX, MAX((f64)0, (f64)v)) ); }
;;;334    
;;;335        template<> inline s32 saturate_cast<s32>(const u8  v) { return v; }
;;;336        template<> inline s32 saturate_cast<s32>(const u16 v) { return v; }
;;;337        template<> inline s32 saturate_cast<s32>(const u32 v) { return (s32)             MIN((u32)s32_MAX, (u32)v); }
;;;338        template<> inline s32 saturate_cast<s32>(const u64 v) { return (s32)             MIN((u64)s32_MAX, (u64)v); }
;;;339        template<> inline s32 saturate_cast<s32>(const s8  v) { return v; }
;;;340        template<> inline s32 saturate_cast<s32>(const s16 v) { return v; }
;;;341        template<> inline s32 saturate_cast<s32>(const s32 v) { return v; }
;;;342        template<> inline s32 saturate_cast<s32>(const s64 v) { return (s32)             MIN((s64)s32_MAX, MAX((s64)s32_MIN, (s64)v)); }
;;;343        template<> inline s32 saturate_cast<s32>(const f32 v) { return (s32) (v > (f32)0x7FFFFFBF) ? 0x7FFFFFFF : Round<s32>(MAX((f32)s32_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;344        template<> inline s32 saturate_cast<s32>(const f64 v) { return (s32) Round<s32>( MIN((f64)s32_MAX, MAX((f64)s32_MIN, (f64)v)) ); }
;;;345    
;;;346        template<> inline u64 saturate_cast<u64>(const u8  v) { return v; }
;;;347        template<> inline u64 saturate_cast<u64>(const u16 v) { return v; }
;;;348        template<> inline u64 saturate_cast<u64>(const u32 v) { return v; }
;;;349        template<> inline u64 saturate_cast<u64>(const u64 v) { return v; }
;;;350        template<> inline u64 saturate_cast<u64>(const s8  v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;351        template<> inline u64 saturate_cast<u64>(const s16 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;352        template<> inline u64 saturate_cast<u64>(const s32 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;353        template<> inline u64 saturate_cast<u64>(const s64 v) { return (u64)                               MAX((s64)0, (s64)v);  }
;;;354        template<> inline u64 saturate_cast<u64>(const f32 v) { return (u64) (v > (f32)0XFFFFFF7FFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;355        template<> inline u64 saturate_cast<u64>(const f64 v) { return (u64) (v > (f64)0xFFFFFFFFFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f64)0, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;356    
;;;357        template<> inline s64 saturate_cast<s64>(const u8  v) { return v; }
;;;358        template<> inline s64 saturate_cast<s64>(const u16 v) { return v; }
;;;359        template<> inline s64 saturate_cast<s64>(const u32 v) { return v; }
;;;360        template<> inline s64 saturate_cast<s64>(const u64 v) { return (s64)             MIN((u64)s64_MAX, (u64)v); }
;;;361        template<> inline s64 saturate_cast<s64>(const s8  v) { return v; }
;;;362        template<> inline s64 saturate_cast<s64>(const s16 v) { return v; }
;;;363        template<> inline s64 saturate_cast<s64>(const s32 v) { return v; }
;;;364        template<> inline s64 saturate_cast<s64>(const s64 v) { return v; }
;;;365        template<> inline s64 saturate_cast<s64>(const f32 v) { return (s64) (v > (f32)0x7FFFFFBFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f32)s64_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;366        template<> inline s64 saturate_cast<s64>(const f64 v) { return (s64) (v > (f64)0x7FFFFFFFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f64)s64_MIN, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;367    
;;;368        template<> inline f32 saturate_cast(const f64 v) { return (f32) MIN((f64)FLT_MAX, MAX(-(f64)FLT_MAX, (f64)v)); }
;;;369      } // namespace Embedded
;;;370    } // namespace Anki
;;;371    
;;;372    #endif // _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;18     #include "anki/common/robot/memory.h"
;;;1      /**
;;;19     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;20     #include "anki/common/robot/geometry.h"
;;;1      /**
;;;2      File: geometry.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of geometry_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/geometry_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/memory.h"
;;;1      /**
;;;18     #include "anki/common/robot/matrix.h"
;;;1      /**
;;;2      File: matrix.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of matrix_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;14     
;;;15     #include "anki/common/robot/matrix_declarations.h"
;;;1      /**
;;;2      File: matrix_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various Matrix operations, such as matrix multiply and addition.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;2      File: arraySlices_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      An array slice is a sub-array of an Array object.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Class Declarations ---
;;;23     
;;;24         template<typename Type> class ConstArraySlice;
;;;25         template<typename Type> class ArraySlice;
;;;26         template<typename Type> class ConstArraySliceExpression;
;;;27     
;;;28         // An ArraySlice is a simple indexing wrapper on top of an Array. The slice of an Array could be
;;;29         // a sub-rectangle of an array and/or skip every n-th element.
;;;30         //
;;;31         // For example, Array(0,3,-1,1,2,4) is the same as Matlab's array(1:3:end, 2:2:5).
;;;32         // (The Array indexing starts from zero vs Matlab's one, hence the different numbers).
;;;33         //
;;;34         // TODO: support non-int indexes
;;;35         // TODO: is there a better way of doing this than a completely different class, different only
;;;36         //       by const?
;;;37         template<typename Type> class ConstArraySlice
;;;38         {
;;;39         public:
;;;40           ConstArraySlice();
;;;41     
;;;42           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;43           ConstArraySlice(const Array<Type> &array);
;;;44     
;;;45           // It's probably easier to call array.operator() than this constructor directly
;;;46           ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;47     
;;;48           // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;49           ConstArraySliceExpression<Type> Transpose() const;
;;;50     
;;;51           bool IsValid() const;
;;;52     
;;;53           const LinearSequence<s32>& get_ySlice() const;
;;;54     
;;;55           const LinearSequence<s32>& get_xSlice() const;
;;;56     
;;;57           // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;58           // don't support the full ArraySlice type, and should be used with caution.
;;;59           const Array<Type>& get_array() const;
;;;60     
;;;61         protected:
;;;62           LinearSequence<s32> ySlice;
;;;63           LinearSequence<s32> xSlice;
;;;64     
;;;65           Array<Type> array;
;;;66     
;;;67           // For speed, this is a direct pointer to the Array's protected data
;;;68           const Type * constArrayData;
;;;69         }; // template<typename Type> class ArraySlice
;;;70     
;;;71         // A non-const version of ConstArraySlice, see ConstArraySlice for details
;;;72         //
;;;73         // WARNING: A "const ArraySlice" doesn't have a const Array. Only ConstArraySlice has a const
;;;74         //          Array. This allows for implicit conversion to non-const function parameters.
;;;75         template<typename Type> class ArraySlice : public ConstArraySlice<Type>
;;;76         {
;;;77         public:
;;;78           ArraySlice();
;;;79     
;;;80           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;81           // The Array parameter is not a reference, to allow for implicit conversion
;;;82           ArraySlice(Array<Type> array);
;;;83     
;;;84           // It's probably easier to call array.operator() than this constructor directly
;;;85           // The Array parameter is not a reference, to allow for implicit conversion
;;;86           ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;87     
;;;88           // If automaticTranspose==true, then you can set a MxN slice with a NxM input.
;;;89           // Matlab allows this for vectors, though this method will also work for
;;;90           // arbitrary-sized arrays.
;;;91           s32 Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
;;;92     
;;;93           // Explicitly evaluate the input LinearSequence into this ArraySlice
;;;94           s32 Set(const LinearSequence<Type> &input);
;;;95     
;;;96           // Set all values of this slice to the given value.
;;;97           //
;;;98           // For example, "array(0,-1,1,4).Set(5);" is the same as
;;;99           // Matlab's "array(1:end, 2:5) = 5;"
;;;100          s32 Set(const Type value);
;;;101    
;;;102          // Copy values to this ArraySlice.
;;;103          // numValues must be equal to the number of values in this slice
;;;104          // Returns the number of values set
;;;105          s32 Set(const Type * const values, const s32 numValues);
;;;106    
;;;107          // Read in the input, then cast it to this object's type
;;;108          //
;;;109          // WARNING:
;;;110          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;111          template<typename InType> s32 SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
;;;112          //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;113    
;;;114          // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;115          // don't support the full ArraySlice type, and should be used with caution.
;;;116          Array<Type>& get_array();
;;;117    
;;;118        protected:
;;;119    
;;;120          // For speed, this is a direct pointer to the Array's protected data
;;;121          Type * arrayData;
;;;122        }; // template<typename Type> class ArraySlice
;;;123    
;;;124        // An ConstArraySliceExpression is like a ConstArraySlice, but can also be transposed
;;;125        // It may have other abilities in the future, but will probably always be const
;;;126        template<typename Type> class ConstArraySliceExpression : public ConstArraySlice<Type>
;;;127        {
;;;128        public:
;;;129          ConstArraySliceExpression();
;;;130    
;;;131          ConstArraySliceExpression(const Array<Type> input, bool isTransposed=false);
;;;132    
;;;133          ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed=false);
;;;134    
;;;135          ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed=false);
;;;136    
;;;137          // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;138          // This object isn't modified, but the returned object is.
;;;139          ConstArraySliceExpression<Type> Transpose() const;
;;;140    
;;;141          bool get_isTransposed() const;
;;;142    
;;;143        protected:
;;;144          bool isTransposed;
;;;145        };
;;;146    
;;;147        // To simplify the creation of kernels using an ArraySlice, and to aid the compiler optimizer,
;;;148        // an ArraySliceLimits can be initialized at the beginning of the function, then used as the
;;;149        // limits for the inner loops.
;;;150    
;;;151        // The suffix of in# and out# refer to the number of input and output matrices.
;;;152        // If output == 0, then the output is a scalar.
;;;153    
;;;154        template<typename Type> class ArraySliceSimpleLimits
;;;155        {
;;;156        public:
;;;157          Type xStart;
;;;158          Type xIncrement;
;;;159          s32  xSize;
;;;160    
;;;161          Type yStart;
;;;162          Type yIncrement;
;;;163          s32  ySize;
;;;164    
;;;165          ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;166        };
;;;167    
;;;168        // In1 and out0 is a special, ultra-simple case, for one matrix input and a scalar output
;;;169        template<typename Type> class ArraySliceLimits_in1_out0
;;;170        {
;;;171        public:
;;;172          // Was this ArraySliceLimits initialized?
;;;173          bool isValid;
;;;174    
;;;175          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;176    
;;;177          ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;178        };
;;;179    
;;;180        // One input, one output
;;;181        template<typename Type> class ArraySliceLimits_in1_out1
;;;182        {
;;;183        public:
;;;184          // Was this ArraySliceLimits initialized?
;;;185          bool isValid;
;;;186    
;;;187          // Can a simple (non-transposed) iteration be performed?
;;;188          bool isSimpleIteration;
;;;189    
;;;190          // These are the current values for the coordinates in the input and output images
;;;191          s32 out1Y;
;;;192          s32 out1X;
;;;193          s32 in1Y;
;;;194          s32 in1X;
;;;195    
;;;196          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;197          s32 ySize;
;;;198          s32 xSize;
;;;199    
;;;200          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;201          // incremented every iteration of the inner loop
;;;202          s32 out1_xInnerIncrement;
;;;203          s32 in1_xInnerIncrement;
;;;204          s32 in1_yInnerIncrement;
;;;205    
;;;206          ArraySliceLimits_in1_out1(
;;;207            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;208            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;209    
;;;210          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;211          inline void OuterIncrementTop();
;;;212    
;;;213          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;214          inline void OuterIncrementBottom();
;;;215    
;;;216        protected:
;;;217          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;218    
;;;219          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;220          bool in1_isTransposed;
;;;221        };
;;;222    
;;;223        // Two inputs, one output
;;;224        template<typename Type> class ArraySliceLimits_in2_out1
;;;225        {
;;;226        public:
;;;227          // Was this ArraySliceLimits initialized?
;;;228          bool isValid;
;;;229    
;;;230          // Can a simple (non-transposed) iteration be performed?
;;;231          bool isSimpleIteration;
;;;232    
;;;233          // These are the current values for the coordinates in the input and output images
;;;234          s32 out1Y;
;;;235          s32 out1X;
;;;236          s32 in1Y;
;;;237          s32 in1X;
;;;238          s32 in2Y;
;;;239          s32 in2X;
;;;240    
;;;241          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;242          s32 ySize;
;;;243          s32 xSize;
;;;244    
;;;245          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;246          // incremented every iteration of the inner loop
;;;247          s32 out1_xInnerIncrement;
;;;248          s32 in1_xInnerIncrement;
;;;249          s32 in1_yInnerIncrement;
;;;250          s32 in2_xInnerIncrement;
;;;251          s32 in2_yInnerIncrement;
;;;252    
;;;253          ArraySliceLimits_in2_out1(
;;;254            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;255            const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed,
;;;256            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;257    
;;;258          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;259          inline void OuterIncrementTop();
;;;260    
;;;261          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;262          inline void OuterIncrementBottom();
;;;263    
;;;264        protected:
;;;265          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;266    
;;;267          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;268          bool in1_isTransposed;
;;;269    
;;;270          ArraySliceSimpleLimits<Type> rawIn2Limits;
;;;271          bool in2_isTransposed;
;;;272        };
;;;273      } // namespace Embedded
;;;274    } // namespace Anki
;;;275    
;;;276    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         namespace Matrix
;;;24         {
;;;25           // #pragma mark --- Declarations ---
;;;26     
;;;27           //
;;;28           // Simple matrix statistics
;;;29           //
;;;30     
;;;31           // Return the minimum element in this Array
;;;32           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat);
;;;33     
;;;34           // Return the maximum element in this Array
;;;35           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat);
;;;36     
;;;37           // Return the sum of every element in the Array
;;;38           template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat);
;;;39     
;;;40           // Return the mean of every element in the Array
;;;41           template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat);
;;;42     
;;;43           // Simultaneously compute the mean and variance of every element in the Array
;;;44           template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(const ConstArraySliceExpression<Array_Type> &mat,
;;;45             Accumulator_Type& mean, Accumulator_Type& var);
;;;46     
;;;47           //
;;;48           // Elementwise matrix operations
;;;49           //
;;;50     
;;;51           // Elementwise add two arrays. in1, in2, and out can be the same array
;;;52           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;53           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;54           template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;55     
;;;56           // Elementwise subtract two arrays. in1, in2, and out can be the same array
;;;57           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;58           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;59           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;60     
;;;61           // Elementwise multiply two arrays. in1, in2, and out can be the same array
;;;62           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;63           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;64           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;65     
;;;66           // Elementwise divide two arrays. in1, in2, and out can be the same array
;;;67           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;68           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;69           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;70     
;;;71           // Elementwise exponential on an array
;;;72           template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;73     
;;;74           // Elementwise square root on an array
;;;75           template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;76     
;;;77           //
;;;78           // Standard matrix operations
;;;79           //
;;;80     
;;;81           // Perform the matrix multiplication "out = in1 * in2"
;;;82           // Note that this is the naive O(n^3) Definition
;;;83           template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out);
;;;84     
;;;85           // Perform the matrix multiplication "out = in1 * in2'"
;;;86           // Note that this is the naive O(n^3) Definition
;;;87           // MultiplyTranspose has better access patterns than Multiply for certain types of arrays, so could be a lot faster (and easier to accelerate)
;;;88           template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out);
;;;89     
;;;90           //
;;;91           // Rotation Matrices
;;;92           //
;;;93     
;;;94           // TODO: Add other rotation-related math, like Rodrigues' formula, or Pose chaining...
;;;95     
;;;96           // Compute the three Euler angles from a given 3x3 Rotation Matrix.
;;;97           Result GetEulerAngles(const Array<f32>& R, f32& angle_x, f32& angle_y, f32& angle_z);
;;;98     
;;;99           //
;;;100          // Linear Algebra and Linear Solvers
;;;101          //
;;;102    
;;;103          // Compute the Cholesky-Banachiewicz decomposition, to return a lower-triangular matrix L such that A=L*L'
;;;104          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;105            Array<Type> &A_L,      //!< Input A Matrix and Output lower-triangular L matrix
;;;106            Array<Type> &Bt_Xt,    //!< Input B-transpose matrix and Output X-transpose solution
;;;107            bool realCholesky,     //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;108            bool &numericalFailure //!< If true, the solver failed because of numerical instability
;;;109            );
;;;110    
;;;111          // Compute the homography such that "transformedPoints = homography * originalPoints"
;;;112          //
;;;113          // WARNING: This uses the inhomogeneous solution and the Cholesky decomposition, therefore it
;;;114          //          will be incorrect if H_33 is zero, which happens in certain cases of lines at
;;;115          //          inifinty. For more details, see Multiple View Geometry 2nd Edition, Example 4.1
;;;116          template<typename Type> Result EstimateHomography(
;;;117            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;118            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;119            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;120            bool &numericalFailure, //!< Did the homography solver fail?
;;;121            MemoryStack scratch //!< Scratch memory
;;;122            );
;;;123    
;;;124          //template<typename InType, typename IntermediateType, typename OutType> Result CholeskyDecomposition(
;;;125          //  const Array<InType> &A,                    //!< Input A Matrix
;;;126          //  Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;127          //  Array<OutType> &L                          //!< Output lower-triangular L matrix
;;;128          //  );
;;;129    
;;;130          //template<typename InType, typename IntermediateType, typename OutType> Result SolveWithLowerTriangular(
;;;131          //  const Array<InType> &L,                          //!< Input lower-triangular L matrix (such as computed by CholeskyDecomposition)
;;;132          //  const Array<InType> &b,                          //!< Input b matrix
;;;133          //  const Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;134          //  Array<OutType> &x                                //!< Output x solution
;;;135          //  );
;;;136    
;;;137          // Solves Ax = b
;;;138          // Specifically, it uses SVD to minimize ||Ax - b||
;;;139          // Note that the A, b, and x matrices are transposed (this is because for large numbers of samples, transposed inputs are liable to be faster)
;;;140          //Result SolveLeastSquaresWithSVD_f32(Array<f32> &At, const Array<f32> &bt, Array<f32> &xt, MemoryStack scratch);
;;;141          //Result SolveLeastSquaresWithSVD_f64(Array<f64> &At, const Array<f64> &bt, Array<f64> &xt, MemoryStack scratch);
;;;142    
;;;143          //
;;;144          // Matrix structure operations
;;;145          //
;;;146    
;;;147          // matlab equivalent: out = reshape(in, [M,N]);
;;;148          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;149          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory);
;;;150    
;;;151          // matlab equivalent: out = in(:);
;;;152          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;153          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory);
;;;154    
;;;155          // Perform an immediate matrix transpose (unlike the lazy transpose of ArraySlice)
;;;156          // in and out must be different Array objects
;;;157          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out);
;;;158    
;;;159          // Rotate an array clockwise by 90, 180, or 270 degrees.
;;;160          // NOTE: Only works for a square matrix.
;;;161          // NOTE: In and out must be different arrays (unlike the interview question)
;;;162          template<typename InType, typename OutType> Result Rotate90( const Array<InType> &in, Array<OutType> &out);
;;;163          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out);
;;;164          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out);
;;;165    
;;;166          //
;;;167          // Misc matrix operations
;;;168          //
;;;169    
;;;170          // Works the same as the Matlab sort() for matrices.
;;;171          // InsertionSort(X) sorts each column of X in ascending order.
;;;172          // The minIndex and maxIndex are for the sortWhichDimension. maxIndex is automatically clipped to the size of the input Array.
;;;173          // NOTE: this currently uses insertion sort, so may be slow for large, badly-unsorted arrays
;;;174          template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;175    
;;;176          // Subsections less-than-or-equal-to insertionSortSize are sorted with insertion sort
;;;177          template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;178    
;;;179          // indexes must be allocated, but will be overwritten by InsertionSort()
;;;180          template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;181    
;;;182          template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;183    
;;;184          // For a square array, either:
;;;185          // 1. When lowerToUpper==true,  copies the lower (left)  triangle to the upper (right) triangle
;;;186          // 2. When lowerToUpper==false, copies the upper (right) triangle to the lower (left)  triangle
;;;187          // Functionally the same as OpenCV completeSymm()
;;;188          template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper = false);
;;;189    
;;;190          // There's probably no need to use these directly. Instead, use the normal Matrix:: operations, like Matrix::Add
;;;191          namespace Elementwise
;;;192          {
;;;193            template<typename InType, typename IntermediateType, typename OutType> class Add {
;;;194            public:
;;;195              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) + static_cast<IntermediateType>(value2));}
;;;196            };
;;;197    
;;;198            template<typename InType, typename IntermediateType, typename OutType> class Subtract {
;;;199            public:
;;;200              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) - static_cast<IntermediateType>(value2));}
;;;201            };
;;;202    
;;;203            template<typename InType, typename IntermediateType, typename OutType> class DotMultiply {
;;;204            public:
;;;205              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) * static_cast<IntermediateType>(value2));}
;;;206            };
;;;207    
;;;208            template<typename InType, typename IntermediateType, typename OutType> class DotDivide {
;;;209            public:
;;;210              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) / static_cast<IntermediateType>(value2));}
;;;211            };
;;;212    
;;;213            // Technically a unary operator, but we ignore the second parameter
;;;214            // TODO: if this is slow, make a unary version of ApplyOperation
;;;215            template<typename InType, typename IntermediateType, typename OutType> class Exp {
;;;216            public:
;;;217              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(expf(static_cast<IntermediateType>(value1)));}
;;;218            };
;;;219    
;;;220            template<typename InType, typename IntermediateType, typename OutType> class Sqrt {
;;;221            public:
;;;222              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(sqrtf(static_cast<IntermediateType>(value1)));}
;;;223            };
;;;224    
;;;225            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;226            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;227            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;228          } // namespace Elementwise
;;;229        } // namespace Matrix
;;;230      } // namespace Embedded
;;;231    } // namespace Anki
;;;232    
;;;233    #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;18     #include "anki/common/robot/memory.h"
;;;19     #include "anki/common/robot/errorHandling.h"
;;;20     #include "anki/common/robot/geometry.h"
;;;21     #include "anki/common/robot/utilities_c.h"
;;;22     #include "anki/common/robot/sequences.h"
;;;23     #include "anki/common/robot/matrix.h"
;;;24     #include "anki/common/robot/comparisons.h"
;;;25     
;;;26     #include "anki/common/shared/utilities_shared.h"
;;;27     
;;;28     #include "anki/common/robot/serialize_declarations.h"
;;;29     
;;;30     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;31     #include "opencv2/core/core.hpp"
;;;32     #include "opencv2/highgui/highgui.hpp"
;;;33     #include "opencv2/imgproc/imgproc.hpp"
;;;34     #include "opencv2/objdetect/objdetect.hpp"
;;;35     #endif
;;;36     
;;;37     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;38     #define ANKICORETECH_EMBEDDED_USE_MALLOC 1
;;;39     #define ANKICORETECH_EMBEDDED_USE_ZLIB 1
;;;40     #endif
;;;41     
;;;42     #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;43     #include "zlib.h"
;;;44     #endif
;;;45     
;;;46     namespace Anki
;;;47     {
;;;48       namespace Embedded
;;;49       {
;;;50         template<typename Type> class ArraySlice;
;;;51         template<typename Type> class ConstArraySlice;
;;;52         template<typename Type> class ConstArraySliceExpression;
;;;53     
;;;54         // #pragma mark --- Array Definitions ---
;;;55     
;;;56         template<typename Type> s32 Array<Type>::ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags)
;;;57         {
;;;58           AnkiConditionalErrorAndReturnValue(numCols >= 0,
;;;59             0, "Array<Type>::ComputeRequiredStride", "Invalid size");
;;;60     
;;;61           const s32 numColsCapped = MAX(numCols, 1);
;;;62     
;;;63           const s32 bufferRequired = static_cast<s32>(RoundUp<size_t>(sizeof(Type)*numColsCapped, MEMORY_ALIGNMENT));
;;;64     
;;;65           return bufferRequired;
;;;66         }
;;;67     
;;;68         template<typename Type> s32 Array<Type>::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags)
;;;69         {
;;;70           AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0,
;;;71             0, "Array<Type>::ComputeMinimumRequiredMemory", "Invalid size");
;;;72     
;;;73           const s32 numRowsCapped = MAX(numRows, 1);
;;;74     
;;;75           return numRowsCapped * Array<Type>::ComputeRequiredStride(numCols, flags);
;;;76         }
;;;77     
;;;78         template<typename Type> Array<Type>::Array()
;;;79         {
;;;80           InvalidateArray();
;;;81         }
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
;;;139        template<typename Type> Array<Type> Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;140        {
;;;141          Array<Type> newArray = Array<Type>();
;;;142    
;;;143    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;144          const cv::Mat cvImage = cv::imread(filename, CV_LOAD_IMAGE_GRAYSCALE);
;;;145    
;;;146          AnkiConditionalErrorAndReturnValue(cvImage.cols >= 0 && cvImage.rows >= 0,
;;;147            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;148    
;;;149          newArray = Array<Type>(cvImage.rows, cvImage.cols, memory);
;;;150    
;;;151          AnkiConditionalErrorAndReturnValue(newArray.IsValid(),
;;;152            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;153    
;;;154          const u8 * restrict pCvImage = cvImage.data;
;;;155    
;;;156          for(s32 y=0; y<cvImage.rows; y++) {
;;;157            Type * restrict pNewArray = newArray.Pointer(y, 0);
;;;158    
;;;159            for(s32 x=0; x<cvImage.cols; x++) {
;;;160              pNewArray[x] = static_cast<Type>(pCvImage[x]);
;;;161            }
;;;162    
;;;163            pCvImage += cvImage.step.buf[0];
;;;164          }
;;;165    #else
;;;166          AnkiError("Array<Type>::Array", "OpenCV is required to load an image from an image file");
;;;167    #endif
;;;168    
;;;169          return newArray;
;;;170        } // Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;171    
;;;172        template<typename Type> Array<Type> LoadBinaryArray_Generic(const char * filename, MemoryStack *scratch, MemoryStack *memory, void * allocatedBuffer, const s32 allocatedBufferLength)
;;;173        {
;;;174          u16  basicType_sizeOfType;
;;;175          bool basicType_isBasicType;
;;;176          bool basicType_isInteger;
;;;177          bool basicType_isSigned;
;;;178          bool basicType_isFloat;
;;;179          bool basicType_isString;
;;;180    
;;;181          Array<u8> rawArray = LoadBinaryArray_UnknownType(
;;;182            filename,
;;;183            scratch, memory,
;;;184            allocatedBuffer, allocatedBufferLength,
;;;185            basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString);
;;;186    
;;;187          // TODO: check that the types match
;;;188    
;;;189          Array<Type> newArray = *reinterpret_cast<Array<Type>*>( &rawArray );
;;;190    
;;;191          return newArray;
;;;192        } // / LoadBinaryArray_Generic()
;;;193    
;;;194        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;195        {
;;;196          return LoadBinaryArray_Generic<Type>(filename, &scratch, &memory, NULL, -1);
;;;197        } // Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;198    
;;;199        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength) //< allocatedBuffer must be freed manually
;;;200        {
;;;201          return LoadBinaryArray_Generic<Type>(filename, NULL, NULL, allocatedBuffer, allocatedBufferLength);
;;;202        } // LoadBinaryMalloc()
;;;203    
;;;204        template<typename Type> Result Array<Type>::SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const
;;;205        {
;;;206          AnkiConditionalErrorAndReturnValue(AreValid(*this, scratch) && filename,
;;;207            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::SaveBinary", "Invalid inputs");
;;;208    
;;;209          AnkiConditionalErrorAndReturnValue(compressionLevel >= 0 && compressionLevel <= 9,
;;;210            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::SaveBinary", "Invalid compression level");
;;;211    
;;;212          // If this is a string array, add the sizes of the null terminated strings (or zero otherwise)
;;;213          const s32 stringsLength = TotalArrayStringLengths<Type>(*this);
;;;214    
;;;215          const s32 serializedBufferLength = 4096 + ARRAY_FILE_HEADER_LENGTH + this->get_size(0) * this->get_stride() + stringsLength;
;;;216          void *buffer = scratch.Allocate(serializedBufferLength);
;;;217    
;;;218          AnkiConditionalErrorAndReturnValue(buffer,
;;;219            RESULT_FAIL_OUT_OF_MEMORY, "Array<Type>::SaveBinary", "Memory could not be allocated");
;;;220    
;;;221          SerializedBuffer toSave(buffer, serializedBufferLength);
;;;222    
;;;223          toSave.PushBack<Type>("Array", *this);
;;;224    
;;;225          s32 startIndex;
;;;226          u8 * bufferStart = reinterpret_cast<u8*>(toSave.get_memoryStack().get_validBufferStart(startIndex));
;;;227          const s32 validUsedBytes = toSave.get_memoryStack().get_usedBytes() - startIndex;
;;;228    
;;;229          // const s32 startDiff = static_cast<s32>( reinterpret_cast<size_t>(bufferStart) - reinterpret_cast<size_t>(toSave.get_memoryStack().get_buffer()) );
;;;230          // const s32 endDiff = toSave.get_memoryStack().get_totalBytes() - toSave.get_memoryStack().get_usedBytes();
;;;231    
;;;232          FILE *fp = fopen(filename, "wb");
;;;233    
;;;234          AnkiConditionalErrorAndReturnValue(fp,
;;;235            RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Could not open file %s", filename);
;;;236    
;;;237          if(compressionLevel > 0) {
;;;238    #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;239            char tmpTextHeader[ARRAY_FILE_HEADER_LENGTH+1];
;;;240            strncpy(tmpTextHeader, &ARRAY_FILE_HEADER[0], ARRAY_FILE_HEADER_LENGTH+1);
;;;241            snprintf(tmpTextHeader+ARRAY_FILE_HEADER_VALID_LENGTH+1, ARRAY_FILE_HEADER_LENGTH-ARRAY_FILE_HEADER_VALID_LENGTH, "z%s ", ZLIB_VERSION);
;;;242    
;;;243            const s32 originalLength = validUsedBytes + SERIALIZED_BUFFER_HEADER_LENGTH + SERIALIZED_BUFFER_FOOTER_LENGTH;
;;;244    
;;;245            uLongf compressedLength = 128 + saturate_cast<s32>(1.1 * originalLength);
;;;246    
;;;247            void * uncompressed = malloc(originalLength);
;;;248            void * compressed = malloc(compressedLength + 2*sizeof(s32));
;;;249    
;;;250            if(!uncompressed || !compressed) {
;;;251              if(uncompressed)
;;;252                free(uncompressed);
;;;253    
;;;254              if(compressed)
;;;255                free(compressed);
;;;256    
;;;257              AnkiError("Array<Type>::SaveBinary", "Out of memory");
;;;258    
;;;259              return RESULT_FAIL_OUT_OF_MEMORY;
;;;260            }
;;;261    
;;;262            // Copy the uncompressed data into one buffer
;;;263            {
;;;264              char * pUncompressed = reinterpret_cast<char*>(uncompressed);
;;;265    
;;;266              memcpy(pUncompressed, &SERIALIZED_BUFFER_HEADER[0], SERIALIZED_BUFFER_HEADER_LENGTH);
;;;267              pUncompressed += SERIALIZED_BUFFER_HEADER_LENGTH;
;;;268    
;;;269              memcpy(pUncompressed, bufferStart, validUsedBytes);
;;;270              pUncompressed += validUsedBytes;
;;;271    
;;;272              memcpy(pUncompressed, &SERIALIZED_BUFFER_FOOTER[0], SERIALIZED_BUFFER_FOOTER_LENGTH);
;;;273            }
;;;274    
;;;275            const s32 compressionResult = compress2(reinterpret_cast<Bytef*>(compressed) + 2*sizeof(s32), &compressedLength, reinterpret_cast<Bytef*>(uncompressed), originalLength, compressionLevel);
;;;276    
;;;277            if(compressionResult != Z_OK) {
;;;278              if(uncompressed)
;;;279                free(uncompressed);
;;;280    
;;;281              if(compressed)
;;;282                free(compressed);
;;;283    
;;;284              AnkiError("Array<Type>::SaveBinary", "Zlib error");
;;;285              return RESULT_FAIL_IO;
;;;286            }
;;;287    
;;;288            reinterpret_cast<s32*>(compressed)[0] = static_cast<s32>(originalLength);
;;;289            reinterpret_cast<s32*>(compressed)[1] = static_cast<s32>(compressedLength);
;;;290    
;;;291            const size_t bytesWrittenForTextHeader = fwrite(tmpTextHeader, 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;292    
;;;293            const size_t bytesWritten = fwrite(compressed, 1, compressedLength + 2*sizeof(s32), fp);
;;;294    
;;;295            if(uncompressed)
;;;296              free(uncompressed);
;;;297    
;;;298            if(compressed)
;;;299              free(compressed);
;;;300    
;;;301            AnkiConditionalErrorAndReturnValue(
;;;302              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;303              bytesWritten == (compressedLength + 2*sizeof(s32)),
;;;304              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;305    
;;;306    #else
;;;307            AnkiError("Array<Type>::SaveBinary", "Saving with compression requires zlib");
;;;308            return RESULT_FAIL;
;;;309    #endif
;;;310          } else {
;;;311            const size_t bytesWrittenForTextHeader = fwrite(&ARRAY_FILE_HEADER[0], 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;312    
;;;313            const size_t bytesWrittenForHeader = fwrite(&SERIALIZED_BUFFER_HEADER[0], 1, SERIALIZED_BUFFER_HEADER_LENGTH, fp);
;;;314    
;;;315            const size_t bytesWritten = fwrite(bufferStart, 1, validUsedBytes, fp);
;;;316    
;;;317            const size_t bytesWrittenForFooter = fwrite(&SERIALIZED_BUFFER_FOOTER[0], 1, SERIALIZED_BUFFER_FOOTER_LENGTH, fp);
;;;318    
;;;319            AnkiConditionalErrorAndReturnValue(
;;;320              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;321              bytesWrittenForHeader == SERIALIZED_BUFFER_HEADER_LENGTH &&
;;;322              bytesWritten == validUsedBytes &&
;;;323              bytesWrittenForFooter == SERIALIZED_BUFFER_FOOTER_LENGTH,
;;;324              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;325          }
;;;326    
;;;327          fclose(fp);
;;;328    
;;;329          return RESULT_OK;
;;;330        } // Array<Type>::SaveBinary(const char * filename, MemoryStack scratch)
;;;331    
;;;332        template<typename Type> const Type* Array<Type>::Pointer(const s32 index0, const s32 index1) const
;;;333        {
;;;334          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;335          AnkiAssert(this->IsValid());
;;;336    
;;;337          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride ) + index1;
;;;338        }
;;;339    
;;;340        template<typename Type> Type* Array<Type>::Pointer(const s32 index0, const s32 index1)
;;;341        {
;;;342          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;343          AnkiAssert(this->IsValid());
;;;344    
;;;345          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride ) + index1;
;;;346        }
;;;347    
;;;348        template<typename Type> inline const Type * Array<Type>::operator[](const s32 index0) const
;;;349        {
;;;350          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;351    
;;;352          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride );
;;;353        }
;;;354    
;;;355        template<typename Type> inline Type * Array<Type>::operator[](const s32 index0)
;;;356        {
;;;357          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;358    
;;;359          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride );
;;;360        }
;;;361    
;;;362        template<typename Type> const Type* Array<Type>::Pointer(const Point<s16> &point) const
;;;363        {
;;;364          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;365        }
;;;366    
;;;367        template<typename Type> Type* Array<Type>::Pointer(const Point<s16> &point)
;;;368        {
;;;369          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;370        }
;;;371    
;;;372        template<typename Type> const Type& Array<Type>::Element(const s32 elementIndex) const
;;;373        {
;;;374          const s32 index1 = elementIndex % size[1];
;;;375          const s32 index0 = (elementIndex - index1) / size[1];
;;;376    
;;;377          return *Pointer(index0, index1);
;;;378        }
;;;379    
;;;380        template<typename Type> Type& Array<Type>::Element(const s32 elementIndex)
;;;381        {
;;;382          const s32 index1 = elementIndex % size[1];
;;;383          const s32 index0 = (elementIndex - index1) / size[1];
;;;384    
;;;385          return *Pointer(index0, index1);
;;;386        }
;;;387    
;;;388        template<typename Type> ArraySlice<Type> Array<Type>::operator() ()
;;;389        {
;;;390          ArraySlice<Type> slice(*this);
;;;391    
;;;392          return slice;
;;;393        }
;;;394    
;;;395        template<typename Type> ArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;396        {
;;;397          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;398    
;;;399          return slice;
;;;400        }
;;;401    
;;;402        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX)
;;;403        {
;;;404          LinearSequence<s32> ySlice = IndexSequence<s32>(minY, 1, maxY, this->size[0]);
;;;405          LinearSequence<s32> xSlice = IndexSequence<s32>(minX, 1, maxX, this->size[1]);
;;;406    
;;;407          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;408    
;;;409          return slice;
;;;410        }
;;;411    
;;;412        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX)
;;;413        {
;;;414          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;415          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;416    
;;;417          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;418    
;;;419          return slice;
;;;420        }
;;;421    
;;;422        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() () const
;;;423        {
;;;424          ConstArraySlice<Type> slice(*this);
;;;425    
;;;426          return slice;
;;;427        }
;;;428    
;;;429        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const
;;;430        {
;;;431          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;432    
;;;433          return slice;
;;;434        }
;;;435    
;;;436        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const
;;;437        {
;;;438          LinearSequence<s32> ySlice = IndexSequence(minY, 1, maxY, this->size[0]);
;;;439          LinearSequence<s32> xSlice = IndexSequence(minX, 1, maxX, this->size[1]);
;;;440    
;;;441          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;442    
;;;443          return slice;
;;;444        }
;;;445    
;;;446        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const
;;;447        {
;;;448          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;449          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;450    
;;;451          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;452    
;;;453          return slice;
;;;454        }
;;;455    
;;;456        template<typename Type> ConstArraySliceExpression<Type> Array<Type>::Transpose() const
;;;457        {
;;;458          ConstArraySliceExpression<Type> expression(this->operator() ());
;;;459          expression.Transpose();
;;;460    
;;;461          return expression;
;;;462        }
;;;463    
;;;464    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;465        template<typename Type> s32 Array<Type>::Set(const cv::Mat_<Type> &in)
;;;466        {
;;;467          const s32 inHeight = in.rows;
;;;468          const s32 inWidth = in.cols;
;;;469    
;;;470          AnkiConditionalErrorAndReturnValue(inHeight != 0,
;;;471            0, "Array<Type>::Set", "input cv::Mat is invalid. If you use the release OpenCV libraries with the debug build, lots of things like file loading don't work.");
;;;472    
;;;473          const bool isColor = in.channels() == 3 || inWidth == this->size[1]*3;
;;;474    
;;;475          if(isColor) {
;;;476            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0],
;;;477              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;478          } else {
;;;479            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;480              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;481          }
;;;482    
;;;483          for(s32 y=0; y<this->size[0]; y++) {
;;;484            const Type * restrict pIn = reinterpret_cast<const Type*>(in.ptr(y,0));
;;;485            Type * restrict pThis = this->Pointer(y,0);
;;;486    
;;;487            // If grayscale, just copy. If color, convert to grayscale
;;;488            if(isColor) {
;;;489              for(s32 x=0; x<this->size[1]; x++) {
;;;490                pThis[x] = (pIn[3*x] + pIn[3*x + 1] + pIn[3*x + 2]) / 3;
;;;491              }
;;;492            } else {
;;;493              memcpy(pThis, pIn, inWidth*sizeof(Type));
;;;494            }
;;;495          }
;;;496    
;;;497          return this->size[0]*this->size[1];
;;;498        }
;;;499    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;500    
;;;501        template<typename Type> void Array<Type>::Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues, const bool fitImageToWindow) const
;;;502        {
;;;503    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;504          AnkiConditionalError(this->IsValid(), "Array<Type>::Show", "Array<Type> is not valid");
;;;505    
;;;506          if(fitImageToWindow) {
;;;507            cv::namedWindow(windowName, CV_WINDOW_NORMAL);
;;;508          } else {
;;;509            cv::namedWindow(windowName, CV_WINDOW_AUTOSIZE);
;;;510          }
;;;511    
;;;512          if(scaleValues) {
;;;513            cv::Mat_<f64> scaledArray;
;;;514    
;;;515            if(ArrayToCvMat(*this, &scaledArray) != RESULT_OK)
;;;516              return;
;;;517    
;;;518            const f64 minValue = Matrix::Min<Type>(*this);
;;;519            const f64 maxValue = Matrix::Max<Type>(*this);
;;;520            const f64 range = maxValue - minValue;
;;;521    
;;;522            scaledArray -= minValue;
;;;523            scaledArray /= range;
;;;524    
;;;525            cv::imshow(windowName, scaledArray);
;;;526          } else {
;;;527            cv::Mat_<Type> arrayCopy;
;;;528    
;;;529            if(ArrayToCvMat(*this, &arrayCopy) != RESULT_OK)
;;;530              return;
;;;531    
;;;532            cv::imshow(windowName, arrayCopy);
;;;533          }
;;;534    
;;;535          if(waitForKeypress) {
;;;536            cv::waitKey();
;;;537          }
;;;538    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;539        }
;;;540    
;;;541        template<typename Type> Result Array<Type>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;542        {
;;;543          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;544            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;545    
;;;546          CoreTechPrint(variableName);
;;;547          CoreTechPrint(":\n");
;;;548          for(s32 y=MAX(0,minY); y<MIN(maxY+1,size[0]); y++) {
;;;549            const Type * const pThisData = this->Pointer(y, 0);
;;;550            for(s32 x=MAX(0,minX); x<MIN(maxX+1,size[1]); x++) {
;;;551              pThisData[x].Print();
;;;552            }
;;;553            CoreTechPrint("\n");
;;;554          }
;;;555          CoreTechPrint("\n");
;;;556    
;;;557          return RESULT_OK;
;;;558        }
;;;559    
;;;560        template<typename Type> Result Array<Type>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;561        {
;;;562          return this->Print(variableName, minY, maxY, minX, maxX);
;;;563        }
;;;564    
;;;565        template<typename Type> bool Array<Type>::IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const
;;;566        {
;;;567          bool isSame = false;
;;;568          if(AreValid(*this, other)) {
;;;569            const s32 nrows = this->get_size(0);
;;;570            const s32 ncols = this->get_size(1);
;;;571    
;;;572            if(other.get_size(0)==nrows && other.get_size(1) == ncols) {
;;;573              isSame = true;
;;;574              for(s32 i=0; i<nrows && isSame; ++i) {
;;;575                const Type * restrict pThis  = this->Pointer(i,0);
;;;576                const Type * restrict pOther = other.Pointer(i,0);
;;;577    
;;;578                for(s32 j=0; j<ncols; ++j) {
;;;579                  if(!NEAR(pThis[j], pOther[j], epsilon)) {
;;;580                    isSame = false;
;;;581                    break;
;;;582                  }
;;;583                } // for j
;;;584              } // for i
;;;585            } // if sizes match
;;;586          } // if both valid
;;;587    
;;;588          return isSame;
;;;589        } // IsNearlyEqualTo()
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
;;;592        {
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
;;;602        }
;;;603    
;;;604        template<typename Type> Result Array<Type>::Resize(const s32 numRows, const s32 numCols, MemoryStack &memory)
;;;605        {
;;;606          AnkiConditionalErrorAndReturnValue(numCols > 0 && numRows > 0,
;;;607            RESULT_FAIL_INVALID_SIZE, "Array<Type>::Resize", "Invalid size");
;;;608    
;;;609          s32 numBytesAllocated = 0;
;;;610    
;;;611          this->data = reinterpret_cast<Type*>( AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, true) );
;;;612    
;;;613          // Don't clear the reallocated memory
;;;614          const bool clearMemory = this->flags.get_zeroAllocatedMemory();
;;;615          this->flags.set_zeroAllocatedMemory(false);
;;;616    
;;;617          const Result result = InitializeBuffer(numRows,
;;;618            numCols,
;;;619            this->data,
;;;620            numBytesAllocated,
;;;621            this->flags);
;;;622    
;;;623          this->flags.set_zeroAllocatedMemory(clearMemory);
;;;624    
;;;625          return result;
;;;626        }
;;;627    
;;;628        template<typename Type> s32 Array<Type>::SetZero()
;;;629        {
;;;630          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;631            0, "Array<Type>::SetZero", "Array<Type> is not valid");
;;;632    
;;;633          const s32 numBytes = this->get_size(0)*this->get_stride();
;;;634    
;;;635          memset(this->Pointer(0,0), 0, numBytes);
;;;636    
;;;637          return numBytes;
;;;638        }
;;;639    
;;;640        template<typename Type> s32 Array<Type>::Set(const Type value)
;;;641        {
;;;642          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;643            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;644    
;;;645          for(s32 y=0; y<size[0]; y++) {
;;;646            Type * restrict pThisData = Pointer(y, 0);
;;;647            for(s32 x=0; x<size[1]; x++) {
;;;648              pThisData[x] = value;
;;;649            }
;;;650          }
;;;651    
;;;652          return size[0]*size[1];
;;;653        }
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
;;;656        {
;;;657          return this->SetCast<Type>(in);
;;;658        }
;;;659    
;;;660        template<typename Type> template<typename InType> s32 Array<Type>::SetCast(const Array<InType> &in)
;;;661        {
;;;662          const s32 inHeight = in.get_size(0);
;;;663          const s32 inWidth = in.get_size(1);
;;;664    
;;;665          AnkiConditionalErrorAndReturnValue(AreValid(*this, in),
;;;666            0, "Array<Type>::Set", "Invalid objects");
;;;667    
;;;668          AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;669            0, "Array<Type>::Set", "Array sizes don't match");
;;;670    
;;;671          for(s32 y=0; y<size[0]; y++) {
;;;672            const InType * restrict pIn = in.Pointer(y, 0);
;;;673            Type * restrict pThisData = Pointer(y, 0);
;;;674    
;;;675            for(s32 x=0; x<size[1]; x++) {
;;;676              pThisData[x] = saturate_cast<Type>(pIn[x]);
;;;677            }
;;;678          }
;;;679    
;;;680          return size[0]*size[1];
;;;681        }
;;;682    
;;;683        template<typename InType> s32 SetCast(const InType * const values, const s32 numValues)
;;;684        {
;;;685          // This is a little tough to write a general case for, so this method should be specialized
;;;686          // for each relevant case
;;;687          AnkiAssert(false);
;;;688    
;;;689          return 0;
;;;690        }
;;;691    
;;;692        template<typename Type> s32 Array<Type>::Set(const Type * const values, const s32 numValues)
;;;693        {
;;;694          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;695            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;696    
;;;697          s32 numValuesSet = 0;
;;;698    
;;;699          for(s32 y=0; y<size[0]; y++) {
;;;700            u32 * restrict pThisData = reinterpret_cast<u32*>(Pointer(y, 0));
;;;701    
;;;702            const s32 numValuesThisRow = MAX(0, MIN(numValues - y*size[1], size[1]));
;;;703    
;;;704            if(numValuesThisRow > 0) {
;;;705              // For small data types, this may be too many bytes, but the stride padding should make
;;;706              // the writing okay (I think)
;;;707              const s32 numWordsToCopy = (sizeof(Type)*numValuesThisRow + 3) / 4;
;;;708    
;;;709              //memcpy(pThisData, values + y*size[1], numValuesThisRow*sizeof(Type));
;;;710              for(s32 x=0; x<numWordsToCopy; x++) {
;;;711                //AnkiAssert(reinterpret_cast<size_t>(values+y*size[1]) % 4 == 0);
;;;712                pThisData[x] = reinterpret_cast<const u32*>(values+y*size[1])[x];
;;;713              }
;;;714              numValuesSet += numValuesThisRow;
;;;715            }
;;;716    
;;;717            if(numValuesThisRow < size[1]) {
;;;718              memset(pThisData+numValuesThisRow*sizeof(Type), 0, (size[1]-numValuesThisRow)*sizeof(Type));
;;;719            }
;;;720          }
;;;721    
;;;722          return numValuesSet;
;;;723        }
;;;724    
;;;725        template<typename Type> Array<Type>& Array<Type>::operator= (const Array<Type> & rightHandSide)
;;;726        {
;;;727          this->size[0] = rightHandSide.size[0];
;;;728          this->size[1] = rightHandSide.size[1];
;;;729    
;;;730          this->stride = rightHandSide.stride;
;;;731          this->flags = rightHandSide.flags;
;;;732          this->data = rightHandSide.data;
;;;733    
;;;734          return *this;
;;;735        }
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
;;;738        {
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
;;;747    
;;;748        template<typename Type> s32 Array<Type>::get_stride() const
;;;749        {
;;;750          return stride;
;;;751        }
;;;752    
;;;753        template<typename Type> s32 Array<Type>::get_numElements() const
;;;754        {
;;;755          if(size[0] > 0 && size[1] > 0) {
;;;756            return size[0] * size[1];
;;;757          } else {
;;;758            return 0;
;;;759          }
;;;760        }
;;;761    
;;;762        template<typename Type> void* Array<Type>::get_buffer()
;;;763        {
;;;764          return data;
;;;765        }
;;;766    
;;;767        template<typename Type> const void* Array<Type>::get_buffer() const
;;;768        {
;;;769          return data;
;;;770        }
;;;771    
;;;772        template<typename Type> Flags::Buffer Array<Type>::get_flags() const
;;;773        {
;;;774          return flags;
;;;775        }
;;;776    
;;;777        template<typename Type> void* Array<Type>::AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate)
;;;778        {
;;;779          AnkiConditionalError(numRows >= 0 && stride > 0,
;;;780            "Array<Type>::AllocateBufferFromMemoryStack", "Invalid size");
;;;781    
;;;782          const s32 numRowsCapped = MAX(numRows, 1);
;;;783    
;;;784          this->stride = stride;
;;;785    
;;;786          const s32 numBytesRequested = numRowsCapped * this->stride;
;;;787    
;;;788          if(reAllocate) {
;;;789            return memory.Reallocate(this->data, numBytesRequested, numBytesAllocated);
;;;790          } else {
;;;791            return memory.Allocate(numBytesRequested, flags.get_zeroAllocatedMemory(), numBytesAllocated);
;;;792          }
;;;793        }
;;;794    
;;;795        template<typename Type> Result Array<Type>::InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags)
;;;796        {
;;;797          if(!rawData) {
;;;798            AnkiError("Anki.Array2d.initialize", "input data buffer is NULL");
;;;799            InvalidateArray();
;;;800            return RESULT_FAIL_UNINITIALIZED_MEMORY;
;;;801          }
;;;802    
;;;803          AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0 && dataLength >= MEMORY_ALIGNMENT,
;;;804            RESULT_FAIL_INVALID_SIZE, "Array<Type>::InitializeBuffer", "Negative dimension");
;;;805    
;;;806          AnkiConditionalErrorAndReturnValue(!flags.get_useBoundaryFillPatterns(),
;;;807            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::InitializeBuffer", "Fill patterns not supported for Array");
;;;808    
;;;809          this->flags = flags;
;;;810          this->size[0] = numRows;
;;;811          this->size[1] = numCols;
;;;812    
;;;813          // Initialize an empty array.
;;;814    
;;;815          this->data = reinterpret_cast<Type*>(rawData);
;;;816    
;;;817          const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData), MEMORY_ALIGNMENT) - reinterpret_cast<size_t>(rawData));
;;;818          const s32 requiredBytes = ComputeRequiredStride(numCols,flags)*numRows + extraAlignmentBytes;
;;;819    
;;;820          if(requiredBytes > dataLength) {
;;;821            AnkiError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
;;;822            InvalidateArray();
;;;823            return RESULT_FAIL_OUT_OF_MEMORY;
;;;824          }
;;;825    
;;;826          this->data = reinterpret_cast<Type*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
;;;827    
;;;828          //#if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;829          //      this->UpdateCvMatMirror(*this);
;;;830          //#endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;831    
;;;832          return RESULT_OK;
;;;833        } // Array<Type>::InitializeBuffer()
;;;834    
;;;835        // Set all the buffers and sizes to -1, to signal an invalid array
;;;836        template<typename Type> void Array<Type>::InvalidateArray()
;;;837        {
;;;838          this->size[0] = -1;
;;;839          this->size[1] = -1;
;;;840          this->stride = -1;
;;;841          this->data = NULL;
;;;842        } // void Array<Type>::InvalidateArray()
;;;843    
;;;844        template<typename Type> Result Array<Type>::PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX)  const
;;;845        {
;;;846          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;847            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;848    
;;;849          const s32 realMinX = MAX(0,minX);
;;;850          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;851          const s32 realMinY = MAX(0,minY);
;;;852          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;853    
;;;854          CoreTechPrint("%s type(int:%d,signed:%d,float:%d,sizeof:%d):\n", variableName, Flags::TypeCharacteristics<Type>::isInteger, Flags::TypeCharacteristics<Type>::isSigned, Flags::TypeCharacteristics<Type>::isFloat, sizeof(Type));
;;;855    
;;;856          for(s32 y=realMinY; y<realMaxY; y++) {
;;;857            const Type * const pThisData = this->Pointer(y, 0);
;;;858            for(s32 x=realMinX; x<realMaxX; x++) {
;;;859              if(Flags::TypeCharacteristics<Type>::isBasicType) {
;;;860                if(Flags::TypeCharacteristics<Type>::isInteger) {
;;;861                  CoreTechPrint("%d ", static_cast<s32>(pThisData[x]));
;;;862                } else {
;;;863                  if(version==1) {
;;;864                    CoreTechPrint("%f ", (float)pThisData[x]);
;;;865                  } else {
;;;866                    CoreTechPrint("%e ", (float)pThisData[x]);
;;;867                  }
;;;868                }
;;;869              } else {
;;;870                CoreTechPrint("! ");
;;;871              }
;;;872            }
;;;873            CoreTechPrint("\n");
;;;874          }
;;;875          CoreTechPrint("\n");
;;;876    
;;;877          return RESULT_OK;
;;;878        }
;;;879    
;;;880        template<typename Type> Result Array<Type>::PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;881        {
;;;882          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;883            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::PrintString", "Array<Type> is not valid");
;;;884    
;;;885          const s32 realMinX = MAX(0,minX);
;;;886          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;887          const s32 realMinY = MAX(0,minY);
;;;888          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;889    
;;;890          CoreTechPrint("%s:\n", variableName);
;;;891    
;;;892          for(s32 y=realMinY; y<realMaxY; y++) {
;;;893            const char * const * pThisData = this->Pointer(y, 0);
;;;894            for(s32 x=realMinX; x<realMaxX; x++) {
;;;895              const char * curString = pThisData[x];
;;;896              if(!curString) {
;;;897                CoreTechPrint("NULL, ");
;;;898              } else {
;;;899                CoreTechPrint("\"%s\", ", curString);
;;;900              }
;;;901            }
;;;902            CoreTechPrint("\n");
;;;903          }
;;;904          CoreTechPrint("\n");
;;;905    
;;;906          return RESULT_OK;
;;;907        }
;;;908    
;;;909        // #pragma mark --- FixedPointArray Definitions ---
;;;910    
;;;911        template<typename Type> FixedPointArray<Type>::FixedPointArray()
;;;912          : Array<Type>(), numFractionalBits(-1)
;;;913        {
;;;914        }
;;;915    
;;;916        template<typename Type> FixedPointArray<Type>::FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags)
;;;917          : Array<Type>(numRows, numCols, data, dataLength, flags), numFractionalBits(numFractionalBits)
;;;918        {
;;;919          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= (sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;920        }
;;;921    
;;;922        template<typename Type> FixedPointArray<Type>::FixedPointArray(s32 numRows, s32 numCols, s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags)
;;;923          : Array<Type>(numRows, numCols, memory, flags), numFractionalBits(numFractionalBits)
;;;924        {
;;;925          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= static_cast<s32>(sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;926        }
;;;927    
;;;928        template<typename Type> s32 FixedPointArray<Type>::get_numFractionalBits() const
;;;929        {
;;;930          return numFractionalBits;
;;;931        }
;;;932    
;;;933    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;934        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;935        {
;;;936          AnkiConditionalErrorAndReturnValue(in.IsValid() && out,
;;;937            RESULT_FAIL, "ArrayToCvMat", "This Array is invalid");
;;;938    
;;;939          out->refcount = NULL;
;;;940    
;;;941          // These two should be set, because if the Mat_ constructor was not called, these will not be initialized
;;;942          out->step.p = out->step.buf;
;;;943          out->size = &out->rows;
;;;944    
;;;945          *out = cv::Mat_<Type>(in.get_size(0), in.get_size(1), const_cast<Type*>(in.Pointer(0,0)), static_cast<size_t>(in.get_stride()));
;;;946    
;;;947          return RESULT_OK;
;;;948        } // template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;949    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;950    
;;;951        // #pragma mark --- Array Specializations ---
;;;952    
;;;953        template<> Result Array<bool>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;954        template<> Result Array<u8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;955        template<> Result Array<s8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;956        template<> Result Array<u16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;957        template<> Result Array<s16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;958        template<> Result Array<u32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;959        template<> Result Array<s32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;960        template<> Result Array<u64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;961        template<> Result Array<s64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;962        template<> Result Array<f32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;963        template<> Result Array<f64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;964        template<> Result Array<const char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;965        template<> Result Array<char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;966    
;;;967        template<> Result Array<f32>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;968        template<> Result Array<f64>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;969    
;;;970        template<> template<> s32 Array<u8>::SetCast(const s32 * const values, const s32 numValues);
;;;971        template<> template<> s32 Array<s16>::SetCast(const s32 * const values, const s32 numValues);
;;;972      } // namespace Embedded
;;;973    } //namespace Anki
;;;974    
;;;975    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;17     #include "anki/common/robot/arraySlices.h"
;;;1      /**
;;;2      File: arraySlices.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of arraySlices_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;14     
;;;15     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> ConstArraySlice<Type>::ConstArraySlice()
;;;23           : ySlice(LinearSequence<s32>()), xSlice(LinearSequence<s32>()), array(Array<Type>()), constArrayData(NULL)
;;;24         {
;;;25         }
;;;26     
;;;27         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array)
;;;28           : ySlice(LinearSequence<s32>(0,array.get_size(0)-1)), xSlice(LinearSequence<s32>(0,array.get_size(1)-1)), array(array)
;;;29         {
;;;30           if(array.get_numElements() == 0) {
;;;31             this->constArrayData = NULL;
;;;32           } else {
;;;33             this->constArrayData = array.Pointer(0,0);
;;;34           }
;;;35         }
;;;36     
;;;37         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;38           : ySlice(ySlice), xSlice(xSlice), array(array)
;;;39         {
;;;40           if(array.get_numElements() == 0) {
;;;41             this->constArrayData = NULL;
;;;42           } else {
;;;43             this->constArrayData = array.Pointer(0,0);
;;;44           }
;;;45         }
;;;46     
;;;47         template<typename Type> ConstArraySliceExpression<Type> ConstArraySlice<Type>::Transpose() const
;;;48         {
;;;49           ConstArraySliceExpression<Type> expression(*this, true);
;;;50     
;;;51           return expression;
;;;52         }
;;;53     
;;;54         template<typename Type> bool ConstArraySlice<Type>::IsValid() const
;;;55         {
;;;56           return this->array.IsValid();
;;;57         }
;;;58     
;;;59         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_ySlice() const
;;;60         {
;;;61           return ySlice;
;;;62         }
;;;63     
;;;64         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_xSlice() const
;;;65         {
;;;66           return xSlice;
;;;67         }
;;;68     
;;;69         template<typename Type> const Array<Type>& ConstArraySlice<Type>::get_array() const
;;;70         {
;;;71           return this->array;
;;;72         }
;;;73     
;;;74         template<typename Type> ArraySlice<Type>::ArraySlice()
;;;75           : ConstArraySlice<Type>(), arrayData(NULL)
;;;76         {
;;;77         }
;;;78     
;;;79         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array)
;;;80           : ConstArraySlice<Type>(array)
;;;81         {
;;;82           if(array.get_numElements() == 0) {
;;;83             this->arrayData = NULL;
;;;84           } else {
;;;85             this->arrayData = array.Pointer(0,0);
;;;86           }
;;;87         }
;;;88     
;;;89         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;90           : ConstArraySlice<Type>(array, ySlice, xSlice)
;;;91         {
;;;92           if(array.get_numElements() == 0) {
;;;93             this->arrayData = NULL;
;;;94           } else {
;;;95             this->arrayData = array.Pointer(0,0);
;;;96           }
;;;97         }
;;;98     
;;;99         template<typename Type> s32 ArraySlice<Type>::Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;100        {
;;;101          return this->SetCast<Type>(input, automaticTranspose);
;;;102        }
;;;103    
;;;104        template<typename Type> s32 ArraySlice<Type>::Set(const LinearSequence<Type> &input)
;;;105        {
;;;106          const Result result = input.Evaluate(*this);
;;;107          return (result==RESULT_OK) ? input.get_size() : 0;
;;;108        }
;;;109    
;;;110        template<typename Type> s32 ArraySlice<Type>::Set(const Type value)
;;;111        {
;;;112          Array<Type> &array = this->get_array();
;;;113    
;;;114          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;115            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;116    
;;;117          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;118    
;;;119          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;120            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;121    
;;;122          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;123            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;124            Type * restrict pMat = array.Pointer(y, 0);
;;;125    
;;;126            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;127              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;128              pMat[x] = value;
;;;129            }
;;;130          }
;;;131    
;;;132          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;133        }
;;;134    
;;;135        template<typename Type> s32 ArraySlice<Type>::Set(const Type * const values, const s32 numValues)
;;;136        {
;;;137          Array<Type> &array = this->get_array();
;;;138    
;;;139          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;140            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;141    
;;;142          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;143    
;;;144          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;145            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;146    
;;;147          AnkiConditionalErrorAndReturnValue(limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize == numValues,
;;;148            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;149    
;;;150          s32 ci = 0;
;;;151          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;152            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;153            Type * restrict pMat = array.Pointer(y, 0);
;;;154    
;;;155            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;156              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;157              pMat[x] = values[ci];
;;;158              ci++;
;;;159            }
;;;160          }
;;;161    
;;;162          AnkiAssert(ci == limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize);
;;;163    
;;;164          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;165        }
;;;166    
;;;167        template<typename Type> template<typename InType> s32 ArraySlice<Type>::SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;168        {
;;;169          AnkiConditionalErrorAndReturnValue(AreValid(*this, input),
;;;170            0, "ArraySlice<Type>::Set", "Invalid objects");
;;;171    
;;;172          AnkiConditionalErrorAndReturnValue(this->get_array().get_buffer() != input.get_array().get_buffer(),
;;;173            0, "ArraySlice<Type>::Set", "Arrays must be in different memory locations");
;;;174    
;;;175          ArraySliceLimits_in1_out1<s32> limits(
;;;176            input.get_ySlice(), input.get_xSlice(), input.get_isTransposed(),
;;;177            this->get_ySlice(), this->get_xSlice());
;;;178    
;;;179          if(!limits.isValid) {
;;;180            if(automaticTranspose) {
;;;181              // If we're allowed to transpose, give it another shot
;;;182              limits = ArraySliceLimits_in1_out1<s32> (input.get_ySlice(), input.get_xSlice(), !input.get_isTransposed(), this->get_ySlice(), this->get_xSlice());
;;;183    
;;;184              if(!limits.isValid) {
;;;185                AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;186                return 0;
;;;187              }
;;;188            } else {
;;;189              AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;190              return 0;
;;;191            }
;;;192          }
;;;193    
;;;194          Array<Type> &out1Array = this->get_array();
;;;195          const Array<InType> &in1Array = input.get_array();
;;;196    
;;;197          if(limits.isSimpleIteration) {
;;;198            // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;199    
;;;200            for(s32 y=0; y<limits.ySize; y++) {
;;;201              const InType * restrict pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;202              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;203    
;;;204              limits.OuterIncrementTop();
;;;205    
;;;206              for(s32 x=0; x<limits.xSize; x++) {
;;;207                pOut1[limits.out1X] = static_cast<Type>( pIn1[limits.in1X] );
;;;208    
;;;209                limits.out1X += limits.out1_xInnerIncrement;
;;;210                limits.in1X += limits.in1_xInnerIncrement;
;;;211              }
;;;212    
;;;213              limits.OuterIncrementBottom();
;;;214            }
;;;215          } else {
;;;216            for(s32 y=0; y<limits.ySize; y++) {
;;;217              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;218    
;;;219              limits.OuterIncrementTop();
;;;220    
;;;221              for(s32 x=0; x<limits.xSize; x++) {
;;;222                const InType pIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;223    
;;;224                pOut1[limits.out1X] = static_cast<Type>( pIn1 );
;;;225    
;;;226                limits.out1X += limits.out1_xInnerIncrement;
;;;227                limits.in1Y += limits.in1_yInnerIncrement;
;;;228              }
;;;229    
;;;230              limits.OuterIncrementBottom();
;;;231            }
;;;232          }
;;;233    
;;;234          return limits.ySize*limits.xSize;
;;;235        }
;;;236    
;;;237        template<typename Type> Array<Type>& ArraySlice<Type>::get_array()
;;;238        {
;;;239          return this->array;
;;;240        }
;;;241    
;;;242        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression()
;;;243          : ConstArraySlice<Type>(), isTransposed(false)
;;;244        {
;;;245        }
;;;246    
;;;247        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const Array<Type> input, bool isTransposed)
;;;248          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;249        {
;;;250        }
;;;251    
;;;252        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed)
;;;253          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;254        {
;;;255        }
;;;256    
;;;257        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed)
;;;258          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;259        {
;;;260        }
;;;261    
;;;262        template<typename Type> ConstArraySliceExpression<Type> ConstArraySliceExpression<Type>::Transpose() const
;;;263        {
;;;264          ConstArraySliceExpression<Type> expression(*this, !this->get_isTransposed());
;;;265    
;;;266          return expression;
;;;267        }
;;;268    
;;;269        template<typename Type> bool ConstArraySliceExpression<Type>::get_isTransposed() const
;;;270        {
;;;271          return isTransposed;
;;;272        }
;;;273    
;;;274        template<typename Type> ArraySliceSimpleLimits<Type>::ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;275          : xStart(in1_xSlice.get_start()), xIncrement(in1_xSlice.get_increment()), xSize(in1_xSlice.get_size()),
;;;276          yStart(in1_ySlice.get_start()), yIncrement(in1_ySlice.get_increment()), ySize(in1_ySlice.get_size())
;;;277        {
;;;278        }
;;;279    
;;;280        template<typename Type> ArraySliceLimits_in1_out0<Type>::ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;281          : isValid(true), rawIn1Limits(in1_ySlice, in1_xSlice)
;;;282        {
;;;283        } // ArraySliceLimits_in1_out0
;;;284    
;;;285        template<typename Type> ArraySliceLimits_in1_out1<Type>::ArraySliceLimits_in1_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;286          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;287          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;288          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed)
;;;289        {
;;;290          isValid = false;
;;;291    
;;;292          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;293    
;;;294          if(!in1_isTransposed) {
;;;295            if(rawOut1Limits.xSize == rawIn1Limits.xSize && rawOut1Limits.ySize == rawIn1Limits.ySize) {
;;;296              isValid = true;
;;;297              isSimpleIteration = true;
;;;298    
;;;299              this->in1Y = this->rawIn1Limits.yStart;
;;;300              this->out1Y = this->rawOut1Limits.yStart;
;;;301    
;;;302              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;303              this->in1_yInnerIncrement = 0;
;;;304            }
;;;305          } else { // if(!in1_isTransposed)
;;;306            if(rawOut1Limits.xSize == rawIn1Limits.ySize && rawOut1Limits.ySize == rawIn1Limits.xSize) {
;;;307              isValid = true;
;;;308              isSimpleIteration = false;
;;;309    
;;;310              this->in1X = this->rawIn1Limits.xStart;
;;;311              this->out1Y = this->rawOut1Limits.yStart;
;;;312    
;;;313              this->in1_xInnerIncrement = 0;
;;;314              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;315            }
;;;316          } // if(!in1_isTransposed) ... else
;;;317    
;;;318          if(!isValid) {
;;;319            AnkiError("ArraySliceLimits_in1_out1", "Subscripted assignment dimension mismatch");
;;;320            return;
;;;321          }
;;;322        } // ArraySliceLimits_in1_out1
;;;323    
;;;324        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;325        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;326        {
;;;327          if(isSimpleIteration) {
;;;328            this->in1X = this->rawIn1Limits.xStart;
;;;329            this->out1X = this->rawOut1Limits.xStart;
;;;330          } else { // if(isSimpleIteration)
;;;331            this->in1Y = this->rawIn1Limits.yStart;
;;;332            this->out1X = this->rawOut1Limits.xStart;
;;;333          } // if(isSimpleIteration) ... else
;;;334        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;335    
;;;336        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;337        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;338        {
;;;339          if(isSimpleIteration) {
;;;340            this->in1Y += this->rawIn1Limits.yIncrement;
;;;341            this->out1Y += this->rawOut1Limits.yIncrement;
;;;342          } else { // if(isSimpleIteration)
;;;343            this->in1X += this->rawIn1Limits.xIncrement;
;;;344            this->out1Y += this->rawOut1Limits.yIncrement;
;;;345          } // if(isSimpleIteration) ... else
;;;346        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;347    
;;;348        template<typename Type> ArraySliceLimits_in2_out1<Type>::ArraySliceLimits_in2_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;349          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;350          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;351          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed),
;;;352          rawIn2Limits(in2_ySlice, in2_xSlice), in2_isTransposed(in2_isTransposed)
;;;353        {
;;;354          isValid = false;
;;;355    
;;;356          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;357          this->in1_yInnerIncrement = 0;
;;;358          this->in1_xInnerIncrement = 0;
;;;359          this->in2_yInnerIncrement = 0;
;;;360          this->in2_xInnerIncrement = 0;
;;;361    
;;;362          if(!in1_isTransposed && !in2_isTransposed) {
;;;363            const bool sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;364    
;;;365            if(sizesMatch) {
;;;366              isValid = true;
;;;367              isSimpleIteration = true;
;;;368    
;;;369              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;370              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;371    
;;;372              this->in1Y = this->rawIn1Limits.yStart;
;;;373              this->in2Y = this->rawIn2Limits.yStart;
;;;374              this->out1Y = this->rawOut1Limits.yStart;
;;;375            }
;;;376          } else { // if(!in1_isTransposed)
;;;377            isSimpleIteration = false;
;;;378    
;;;379            bool sizesMatch = false;
;;;380    
;;;381            if(in1_isTransposed && in2_isTransposed) {
;;;382              sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;383              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;384              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;385            } else if(in1_isTransposed) {
;;;386              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;387              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;388              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;389            } else if(in2_isTransposed) {
;;;390              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;391              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;392              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;393            } else {
;;;394              AnkiAssert(false); // should not be possible
;;;395            }
;;;396    
;;;397            if(!sizesMatch) {
;;;398              AnkiError("ArraySliceLimits_in2_out1", "Subscripted assignment dimension mismatch");
;;;399              return;
;;;400            }
;;;401    
;;;402            isValid = true;
;;;403    
;;;404            this->in1X = this->rawIn1Limits.xStart;
;;;405            this->in1Y = this->rawIn1Limits.yStart;
;;;406            this->in2X = this->rawIn2Limits.xStart;
;;;407            this->in2Y = this->rawIn2Limits.yStart;
;;;408    
;;;409            this->out1Y = this->rawOut1Limits.yStart;
;;;410          } // if(!in1_isTransposed) ... else
;;;411        } // ArraySliceLimits_in1_out1
;;;412    
;;;413        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;414        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;415        {
;;;416          if(isSimpleIteration) {
;;;417            this->out1X = this->rawOut1Limits.xStart;
;;;418            this->in1X = this->rawIn1Limits.xStart;
;;;419            this->in2X = this->rawIn2Limits.xStart;
;;;420          } else { // if(isSimpleIteration)
;;;421            this->out1X = this->rawOut1Limits.xStart;
;;;422    
;;;423            if(in1_isTransposed) {
;;;424              this->in1Y = this->rawIn1Limits.yStart;
;;;425            } else {
;;;426              this->in1X = this->rawIn1Limits.xStart;
;;;427            }
;;;428    
;;;429            if(in2_isTransposed) {
;;;430              this->in2Y = this->rawIn2Limits.yStart;
;;;431            } else {
;;;432              this->in2X = this->rawIn2Limits.xStart;
;;;433            }
;;;434          } // if(isSimpleIteration) ... else
;;;435        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;436    
;;;437        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;438        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;439        {
;;;440          if(isSimpleIteration) {
;;;441            this->in1Y += this->rawIn1Limits.yIncrement;
;;;442            this->in2Y += this->rawIn2Limits.yIncrement;
;;;443            this->out1Y += this->rawOut1Limits.yIncrement;
;;;444          } else { // if(isSimpleIteration)
;;;445            this->out1Y += this->rawOut1Limits.yIncrement;
;;;446    
;;;447            if(in1_isTransposed) {
;;;448              this->in1X += this->rawIn1Limits.xIncrement;
;;;449            } else {
;;;450              this->in1Y += this->rawIn1Limits.yIncrement;
;;;451            }
;;;452    
;;;453            if(in2_isTransposed) {
;;;454              this->in2X += this->rawIn2Limits.xIncrement;
;;;455            } else {
;;;456              this->in2Y += this->rawIn2Limits.yIncrement;
;;;457            }
;;;458          } // if(isSimpleIteration) ... else
;;;459        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;460      } // namespace Embedded
;;;461    } // namespace Anki
;;;462    
;;;463    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;19     #include "anki/common/robot/benchmarking.h"
;;;1      /**
;;;2      File: benchmarkins.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Low-overhead benchmarking, based on a list of start and end events.
;;;7      
;;;8      The basic use of this benchmarking utility is as follows:
;;;9      1. InitBenchmarking()
;;;10     2. At the beginning of the section you want to benchmark, put BeginBenchmark("event type");
;;;11     3. At the end of the section you want to benchmark, put EndBenchmark("event type");
;;;12     4. When you're done running the program, call PrintBenchmarkResults() to print the results
;;;13     
;;;14     Copyright Anki, Inc. 2013
;;;15     For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;16     **/
;;;17     
;;;18     #ifndef _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;19     #define _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     
;;;21     #include "anki/common/robot/config.h"
;;;1      /**
;;;22     #include "anki/common/robot/fixedLengthList_declarations.h"
;;;1      /**
;;;2      File: fixedLengthList_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      A FixedLengthList is like a std::vector, but has a fixed maximum size. This maximum is allocated at contruction.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         class SerializedBuffer;
;;;24     
;;;25         // A FixedLengthList is a list with a fixed maximum size, which is allocated at construction.
;;;26         template<typename Type> class FixedLengthList : public ArraySlice<Type>
;;;27         {
;;;28         public:
;;;29           FixedLengthList();
;;;30     
;;;31           // Constructor for a FixedLengthList, pointing to user-allocated data.
;;;32           FixedLengthList(s32 maximumSize, void * data, s32 dataLength, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;33     
;;;34           // Constructor for a FixedLengthList, pointing to user-allocated MemoryStack
;;;35           FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;36     
;;;37           bool IsValid() const;
;;;38     
;;;39           // Resize will use MemoryStack::Reallocate() to change the FixedLengthList's size. It only works if this
;;;40           // FixedLengthList was the last thing allocated. The reallocated memory will not be cleared
;;;41           //
;;;42           // WARNING:
;;;43           // This will not update any references to the memory, you must update all references manually.
;;;44           Result Resize(s32 maximumSize, MemoryStack &memory);
;;;45     
;;;46           Result PushBack(const Type &value);
;;;47     
;;;48           // Will act as a normal pop, except when the list is empty. Then subsequent
;;;49           // calls will keep returning the first value in the list.
;;;50           Type PopBack();
;;;51     
;;;52           // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
;;;53           inline void Clear();
;;;54     
;;;55           // Does this ever need to be declared explicitly?
;;;56           //FixedLengthList& operator= (const FixedLengthList & rightHandSide);
;;;57     
;;;58           // Pointer to the data, at a given location
;;;59           inline Type* Pointer(const s32 index);
;;;60           inline const Type* Pointer(const s32 index) const;
;;;61     
;;;62           // Use this operator for normal C-style vector indexing. For example, "list[5] = 6;" will set
;;;63           // the element in the fifth row and first column to 6. This is the same as "*list.Pointer(5) =
;;;64           // 6;"
;;;65           //
;;;66           // NOTE:
;;;67           // Using this in a inner loop may be less efficient than using an explicit pointer with a
;;;68           // restrict keyword (Though the runtime cost isn't nearly as large as the [] operator for the
;;;69           // Array class). For speeding up performance-critical inner loops, use something like: "Type *
;;;70           // restrict pList = list.Pointer(0);" outside the inner loop, then index
;;;71           // pList in the inner loop.
;;;72           inline const Type& operator[](const s32 index) const;
;;;73           inline Type& operator[](const s32 index);
;;;74     
;;;75           // Print out the contents of this FixedLengthList
;;;76           Result Print(const char * const variableName = "FixedLengthList", const s32 minIndex = 0, const s32 maxIndex = 0x7FFFFFE) const;
;;;77     
;;;78           // Set every element in the Array to zero, including the stride padding, but not including the optional fill patterns (if they exist)
;;;79           // Returns the number of bytes set to zero
;;;80           inline s32 SetZero();
;;;81     
;;;82           // Read in the input, then cast it to this object's type
;;;83           //
;;;84           // WARNING:
;;;85           // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;86           template<typename InType> s32 SetCast(const FixedLengthList<InType> &input, bool automaticTranspose=true);
;;;87           //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;88     
;;;89           // The maximum size is set at object construction
;;;90           inline s32 get_maximumSize() const;
;;;91     
;;;92           // The current size changes as the FixedLengthList is used
;;;93           inline s32 get_size() const;
;;;94     
;;;95           // Attempt to set the size to newSize. Returns the value that was actually set.
;;;96           s32 set_size(s32 newSize);
;;;97     
;;;98         protected:
;;;99           // TODO: make less hacky
;;;100          friend class SerializedBuffer;
;;;101        }; // class FixedLengthList
;;;102      } // namespace Embedded
;;;103    } //namespace Anki
;;;104    
;;;105    #endif // _ANKICORETECHEMBEDDED_COMMON_FIXEDLENGTHLIST_DECLARATIONS_H_
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         const s32 MAX_BENCHMARK_EVENTS = 16000;
;;;29     
;;;30         typedef struct BenchmarkElement
;;;31         {
;;;32           // All times in microseconds, on all platforms
;;;33     
;;;34           static const s32 NAME_LENGTH = 64;
;;;35     
;;;36           // Inclusive includes all the time for all sub-benchmarks
;;;37           u32 inclusive_mean;
;;;38           u32 inclusive_min;
;;;39           u32 inclusive_max;
;;;40           u32 inclusive_total;
;;;41     
;;;42           // Exclusive does not include sub-benchmarks
;;;43           u32 exclusive_mean;
;;;44           u32 exclusive_min;
;;;45           u32 exclusive_max;
;;;46           u32 exclusive_total;
;;;47     
;;;48           // How many times was this element's name benchmarked?
;;;49           u32 numEvents;
;;;50     
;;;51           char name[BenchmarkElement::NAME_LENGTH];
;;;52     
;;;53           BenchmarkElement(const char * name);
;;;54     
;;;55           // Print with CoreTechPrint()
;;;56           void Print(const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;57     
;;;58           // Like snprintf(). Returns the number of characters printed, not including the final null byte.
;;;59           s32 Snprint(char * buffer, const s32 bufferLength, const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;60         } BenchmarkElement;
;;;61     
;;;62         typedef struct ShowBenchmarkParameters
;;;63         {
;;;64           char name[BenchmarkElement::NAME_LENGTH];
;;;65           bool showExclusiveTime;
;;;66           u8 red, green, blue;
;;;67     
;;;68           ShowBenchmarkParameters(
;;;69             const char * name,
;;;70             const bool showExclusiveTime,
;;;71             const u8 *color); //< Color is {R,G,B}
;;;72         } ShowBenchmarkParameters;
;;;73     
;;;74         // Call this before doing any benchmarking, to clear the buffer of benchmarkEvents.
;;;75         // Can be called multiple times.
;;;76         void InitBenchmarking();
;;;77     
;;;78         // Use these functions to add a new event to the list. These functions are very fast.
;;;79         //
;;;80         // WARNING: name must be in globally available memory
;;;81         //
;;;82         // WARNING: the character string must be less than BenchmarkElement::NAME_LENGTH bytes
;;;83         //
;;;84         // WARNING: Using the same name for different benchmark events
;;;85         //
;;;86         // WARNING: nesting BeginBenchmark() and EndBenchmark() events that have the same name won't work.
;;;87         // This is okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("b"); EndBenchmark("a");
;;;88         // This is not okay: BeginBenchmark("a"); BeginBenchmark("a"); EndBenchmark("a"); EndBenchmark("a");
;;;89         // This is not okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("a"); EndBenchmark("b");
;;;90         void BeginBenchmark(const char *name);
;;;91         void EndBenchmark(const char *name);
;;;92     
;;;93         // Compile all the benchmark events that were recorded
;;;94         FixedLengthList<BenchmarkElement> ComputeBenchmarkResults(MemoryStack &memory);
;;;95     
;;;96         // CoreTechPrint() the benchmark results
;;;97         // WARNING: This doesn't work well with multi-threaded programs
;;;98         Result PrintBenchmarkResults(const FixedLengthList<BenchmarkElement> &results, const bool verbose=true, const bool microseconds=true);
;;;99     
;;;100        // Compile and print out all the benchmark events that were recorded
;;;101        Result ComputeAndPrintBenchmarkResults(const bool verbose, const bool microseconds, MemoryStack scratch);
;;;102    
;;;103        // Use OpenCV to display a running benchmark
;;;104        // Requires a "TotalTime" benchmark event
;;;105        // namesToDisplay can be 11 or less names
;;;106        Result ShowBenchmarkResults(
;;;107          const FixedLengthList<BenchmarkElement> &results,
;;;108          const FixedLengthList<ShowBenchmarkParameters> &namesToDisplay,
;;;109          const f32 pixelsPerMillisecond,
;;;110          const s32 imageHeight,
;;;111          const s32 imageWidth);
;;;112    
;;;113        s32 GetNameIndex(const char * name, const FixedLengthList<BenchmarkElement> &outputResults);
;;;114      } // namespace Embedded
;;;115    } // namespace Anki
;;;116    
;;;117    #endif // _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     #include "anki/common/robot/comparisons.h"
;;;1      /**
;;;2      File: comparisons.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of comparisons_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;14     
;;;15     #include "anki/common/robot/comparisons_declarations.h"
;;;1      /**
;;;2      File: comparisons_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various elementwise tests, to ensure that the data of two Arrays is equal.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Declarations ---
;;;23         // Check every element of this array against the input array. If the arrays are different
;;;24         // sizes, uninitialized, or if any element is more different than the threshold, then
;;;25         // return false.
;;;26         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold = static_cast<Type>(0.0001));
;;;27     
;;;28         // Check every element of this array against the input array. If the arrays are different
;;;29         // sizes or uninitialized, return false. The percentThreshold is between 0.0 and 1.0. To
;;;30         // return false, an element must fail both thresholds. The percent threshold fails if an
;;;31         // element is more than a percentage different than its matching element (calulated from the
;;;32         // maximum of the two).
;;;33         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold = 0.01, const double absoluteThreshold = 0.0001);
;;;34     
;;;35         // If any of the input objects are not valid, then return false
;;;36         // NOTE: the objects must have an IsValid() method
;;;37         template<typename Type1> bool AreValid(const Type1 &object1);
;;;38         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2);
;;;39         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;40         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;41         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;42         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;43         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;44         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;45         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;46     
;;;47         // If the objects have different sizes or are uninitialized, then return false.
;;;48         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;49         template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2);
;;;50         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;51         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;52         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;53         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;54         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;55         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;56         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;57     
;;;58         // Check sizes against an input height and width
;;;59         template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1);
;;;60         template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2);
;;;61         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;62         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;63         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;64         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;65         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;66         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;67         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;68     
;;;69         // If the Arrays are aliased (pointing to the same location in memory) or uninitialized, then return false
;;;70         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;71         template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2);
;;;72         template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;73         template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;74         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;75         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;76         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;77         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;78         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;79       } // namespace Embedded
;;;80     } // namespace Anki
;;;81     
;;;82     #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark
;;;23     
;;;24         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold)
;;;25         {
;;;26           if(!AreEqualSize(array1, array2))
;;;27             return false;
;;;28     
;;;29           const s32 height = array1.get_size(0);
;;;30           const s32 width = array1.get_size(1);
;;;31     
;;;32           for(s32 y=0; y<height; y++) {
;;;33             const Type * const pArray1 = array1.Pointer(y, 0);
;;;34             const Type * const pArray2 = array2.Pointer(y, 0);
;;;35             for(s32 x=0; x<width; x++) {
;;;36               if(pArray1[x] > pArray2[x]) {
;;;37                 if((pArray1[x] - pArray2[x]) > threshold)
;;;38                   return false;
;;;39               } else {
;;;40                 if((pArray2[x] - pArray1[x]) > threshold)
;;;41                   return false;
;;;42               }
;;;43             }
;;;44           }
;;;45     
;;;46           return true;
;;;47         }
;;;48     
;;;49         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold, const double absoluteThreshold)
;;;50         {
;;;51           if(!AreEqualSize(array1, array2))
;;;52             return false;
;;;53     
;;;54           const s32 height = array1.get_size(0);
;;;55           const s32 width = array1.get_size(1);
;;;56     
;;;57           for(s32 y=0; y<height; y++) {
;;;58             const Type * const pArray1 = array1.Pointer(y, 0);
;;;59             const Type * const pArray2 = array2.Pointer(y, 0);
;;;60             for(s32 x=0; x<width; x++) {
;;;61               const double value1 = static_cast<double>(pArray1[x]);
;;;62               const double value2 = static_cast<double>(pArray2[x]);
;;;63               const double percentThresholdValue = percentThreshold * MAX(value1,value2);
;;;64     
;;;65               if(fabs(value1 - value2) > percentThresholdValue && fabs(value1 - value2) > absoluteThreshold)
;;;66                 return false;
;;;67             }
;;;68           }
;;;69     
;;;70           return true;
;;;71         }
;;;72     
;;;73         template<typename Type1> bool AreValid(const Type1 &object1)
;;;74         {
;;;75           if(!object1.IsValid())
;;;76             return false;
;;;77     
;;;78           return true;
;;;79         }
;;;80     
;;;81         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2)
;;;82         {
;;;83           if(!object1.IsValid() || !object2.IsValid())
;;;84             return false;
;;;85     
;;;86           return true;
;;;87         }
;;;88     
;;;89         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;90         {
;;;91           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid())
;;;92             return false;
;;;93     
;;;94           return true;
;;;95         }
;;;96     
;;;97         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;98         {
;;;99           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid())
;;;100            return false;
;;;101    
;;;102          return true;
;;;103        }
;;;104    
;;;105        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;106        {
;;;107          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid())
;;;108            return false;
;;;109    
;;;110          return true;
;;;111        }
;;;112    
;;;113        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;114        {
;;;115          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid())
;;;116            return false;
;;;117    
;;;118          return true;
;;;119        }
;;;120    
;;;121        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;122        {
;;;123          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid())
;;;124            return false;
;;;125    
;;;126          return true;
;;;127        }
;;;128    
;;;129        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;130        {
;;;131          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid())
;;;132            return false;
;;;133    
;;;134          return true;
;;;135        }
;;;136    
;;;137        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;138        {
;;;139          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid() || !object9.IsValid())
;;;140            return false;
;;;141    
;;;142          return true;
;;;143        }
;;;144    
;;;145        template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2)
;;;146        {
;;;147          if(!AreValid(object1, object2))
;;;148            return false;
;;;149    
;;;150          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1))
;;;151            return false;
;;;152    
;;;153          return true;
;;;154        }
;;;155    
;;;156        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;157        {
;;;158          if(!AreValid(object1, object2, object3))
;;;159            return false;
;;;160    
;;;161          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;162            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1))
;;;163            return false;
;;;164    
;;;165          return true;
;;;166        }
;;;167    
;;;168        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;169        {
;;;170          if(!AreValid(object1, object2, object3, object4))
;;;171            return false;
;;;172    
;;;173          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;174            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;175            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1))
;;;176            return false;
;;;177    
;;;178          return true;
;;;179        }
;;;180    
;;;181        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;182        {
;;;183          if(!AreValid(object1, object2, object3, object4, object5))
;;;184            return false;
;;;185    
;;;186          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;187            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;188            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;189            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1))
;;;190            return false;
;;;191    
;;;192          return true;
;;;193        }
;;;194    
;;;195        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;196        {
;;;197          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;198            return false;
;;;199    
;;;200          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;201            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;202            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;203            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;204            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1))
;;;205            return false;
;;;206    
;;;207          return true;
;;;208        }
;;;209    
;;;210        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;211        {
;;;212          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;213            return false;
;;;214    
;;;215          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;216            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;217            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;218            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;219            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;220            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1))
;;;221            return false;
;;;222    
;;;223          return true;
;;;224        }
;;;225    
;;;226        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;227        {
;;;228          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;229            return false;
;;;230    
;;;231          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;232            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;233            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;234            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;235            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;236            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;237            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1))
;;;238            return false;
;;;239    
;;;240          return true;
;;;241        }
;;;242    
;;;243        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;244        {
;;;245          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;246            return false;
;;;247    
;;;248          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;249            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;250            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;251            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;252            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;253            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;254            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1) ||
;;;255            object1.get_size(0) != object9.get_size(0) || object1.get_size(1) != object9.get_size(1))
;;;256            return false;
;;;257    
;;;258          return true;
;;;259        }
;;;260    
;;;261        template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1)
;;;262        {
;;;263          if(!AreValid(object1))
;;;264            return false;
;;;265    
;;;266          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;267            return false;
;;;268    
;;;269          return true;
;;;270        }
;;;271    
;;;272        template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2)
;;;273        {
;;;274          if(!AreValid(object1, object2))
;;;275            return false;
;;;276    
;;;277          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;278            return false;
;;;279    
;;;280          return AreEqualSize(object1, object2);
;;;281        }
;;;282    
;;;283        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;284        {
;;;285          if(!AreValid(object1, object2, object3))
;;;286            return false;
;;;287    
;;;288          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;289            return false;
;;;290    
;;;291          return AreEqualSize(object1, object2, object3);
;;;292        }
;;;293    
;;;294        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;295        {
;;;296          if(!AreValid(object1, object2, object3, object4))
;;;297            return false;
;;;298    
;;;299          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;300            return false;
;;;301    
;;;302          return AreEqualSize(object1, object2, object3, object4);
;;;303        }
;;;304    
;;;305        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;306        {
;;;307          if(!AreValid(object1, object2, object3, object4, object5))
;;;308            return false;
;;;309    
;;;310          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;311            return false;
;;;312    
;;;313          return AreEqualSize(object1, object2, object3, object4, object5);
;;;314        }
;;;315    
;;;316        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;317        {
;;;318          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;319            return false;
;;;320    
;;;321          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;322            return false;
;;;323    
;;;324          return AreEqualSize(object1, object2, object3, object4, object5, object6);
;;;325        }
;;;326    
;;;327        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;328        {
;;;329          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;330            return false;
;;;331    
;;;332          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;333            return false;
;;;334    
;;;335          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7);
;;;336        }
;;;337    
;;;338        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;339        {
;;;340          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;341            return false;
;;;342    
;;;343          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;344            return false;
;;;345    
;;;346          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8);
;;;347        }
;;;348    
;;;349        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;350        {
;;;351          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;352            return false;
;;;353    
;;;354          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;355            return false;
;;;356    
;;;357          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8, object9);
;;;358        }
;;;359    
;;;360        template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2)
;;;361        {
;;;362          if(!AreValid(object1, object2))
;;;363            return false;
;;;364    
;;;365          const size_t bufferPointers[] = {
;;;366            reinterpret_cast<size_t>(object1.get_buffer()),
;;;367            reinterpret_cast<size_t>(object2.get_buffer())};
;;;368    
;;;369          for(s32 i=0; i<2; i++) {
;;;370            for(s32 j=i+1; j<2; j++) {
;;;371              if(bufferPointers[i] == bufferPointers[j])
;;;372                return false;
;;;373            }
;;;374          }
;;;375    
;;;376          return true;
;;;377        }
;;;378    
;;;379        template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;380        {
;;;381          if(!AreValid(object1, object2, object3))
;;;382            return false;
;;;383    
;;;384          const size_t bufferPointers[] = {
;;;385            reinterpret_cast<size_t>(object1.get_buffer()),
;;;386            reinterpret_cast<size_t>(object2.get_buffer()),
;;;387            reinterpret_cast<size_t>(object3.get_buffer())};
;;;388    
;;;389          for(s32 i=0; i<3; i++) {
;;;390            for(s32 j=i+1; j<3; j++) {
;;;391              if(bufferPointers[i] == bufferPointers[j])
;;;392                return false;
;;;393            }
;;;394          }
;;;395    
;;;396          return true;
;;;397        }
;;;398    
;;;399        template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;400        {
;;;401          if(!AreValid(object1, object2, object3, object4))
;;;402            return false;
;;;403    
;;;404          const size_t bufferPointers[] = {
;;;405            reinterpret_cast<size_t>(object1.get_buffer()),
;;;406            reinterpret_cast<size_t>(object2.get_buffer()),
;;;407            reinterpret_cast<size_t>(object3.get_buffer()),
;;;408            reinterpret_cast<size_t>(object4.get_buffer())};
;;;409    
;;;410          for(s32 i=0; i<4; i++) {
;;;411            for(s32 j=i+1; j<4; j++) {
;;;412              if(bufferPointers[i] == bufferPointers[j])
;;;413                return false;
;;;414            }
;;;415          }
;;;416    
;;;417          return true;
;;;418        }
;;;419    
;;;420        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;421        {
;;;422          if(!AreValid(object1, object2, object3, object4, object5))
;;;423            return false;
;;;424    
;;;425          const size_t bufferPointers[] = {
;;;426            reinterpret_cast<size_t>(object1.get_buffer()),
;;;427            reinterpret_cast<size_t>(object2.get_buffer()),
;;;428            reinterpret_cast<size_t>(object3.get_buffer()),
;;;429            reinterpret_cast<size_t>(object4.get_buffer()),
;;;430            reinterpret_cast<size_t>(object5.get_buffer())};
;;;431    
;;;432          for(s32 i=0; i<5; i++) {
;;;433            for(s32 j=i+1; j<5; j++) {
;;;434              if(bufferPointers[i] == bufferPointers[j])
;;;435                return false;
;;;436            }
;;;437          }
;;;438    
;;;439          return true;
;;;440        }
;;;441    
;;;442        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;443        {
;;;444          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;445            return false;
;;;446    
;;;447          const size_t bufferPointers[] = {
;;;448            reinterpret_cast<size_t>(object1.get_buffer()),
;;;449            reinterpret_cast<size_t>(object2.get_buffer()),
;;;450            reinterpret_cast<size_t>(object3.get_buffer()),
;;;451            reinterpret_cast<size_t>(object4.get_buffer()),
;;;452            reinterpret_cast<size_t>(object5.get_buffer()),
;;;453            reinterpret_cast<size_t>(object6.get_buffer())};
;;;454    
;;;455          for(s32 i=0; i<6; i++) {
;;;456            for(s32 j=i+1; j<6; j++) {
;;;457              if(bufferPointers[i] == bufferPointers[j])
;;;458                return false;
;;;459            }
;;;460          }
;;;461    
;;;462          return true;
;;;463        }
;;;464    
;;;465        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;466        {
;;;467          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;468            return false;
;;;469    
;;;470          const size_t bufferPointers[] = {
;;;471            reinterpret_cast<size_t>(object1.get_buffer()),
;;;472            reinterpret_cast<size_t>(object2.get_buffer()),
;;;473            reinterpret_cast<size_t>(object3.get_buffer()),
;;;474            reinterpret_cast<size_t>(object4.get_buffer()),
;;;475            reinterpret_cast<size_t>(object5.get_buffer()),
;;;476            reinterpret_cast<size_t>(object6.get_buffer()),
;;;477            reinterpret_cast<size_t>(object7.get_buffer())};
;;;478    
;;;479          for(s32 i=0; i<7; i++) {
;;;480            for(s32 j=i+1; j<7; j++) {
;;;481              if(bufferPointers[i] == bufferPointers[j])
;;;482                return false;
;;;483            }
;;;484          }
;;;485    
;;;486          return true;
;;;487        }
;;;488    
;;;489        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;490        {
;;;491          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;492            return false;
;;;493    
;;;494          const size_t bufferPointers[] = {
;;;495            reinterpret_cast<size_t>(object1.get_buffer()),
;;;496            reinterpret_cast<size_t>(object2.get_buffer()),
;;;497            reinterpret_cast<size_t>(object3.get_buffer()),
;;;498            reinterpret_cast<size_t>(object4.get_buffer()),
;;;499            reinterpret_cast<size_t>(object5.get_buffer()),
;;;500            reinterpret_cast<size_t>(object6.get_buffer()),
;;;501            reinterpret_cast<size_t>(object7.get_buffer()),
;;;502            reinterpret_cast<size_t>(object8.get_buffer())};
;;;503    
;;;504          for(s32 i=0; i<8; i++) {
;;;505            for(s32 j=i+1; j<8; j++) {
;;;506              if(bufferPointers[i] == bufferPointers[j])
;;;507                return false;
;;;508            }
;;;509          }
;;;510    
;;;511          return true;
;;;512        }
;;;513    
;;;514        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;515        {
;;;516          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;517            return false;
;;;518    
;;;519          const size_t bufferPointers[] = {
;;;520            reinterpret_cast<size_t>(object1.get_buffer()),
;;;521            reinterpret_cast<size_t>(object2.get_buffer()),
;;;522            reinterpret_cast<size_t>(object3.get_buffer()),
;;;523            reinterpret_cast<size_t>(object4.get_buffer()),
;;;524            reinterpret_cast<size_t>(object5.get_buffer()),
;;;525            reinterpret_cast<size_t>(object6.get_buffer()),
;;;526            reinterpret_cast<size_t>(object7.get_buffer()),
;;;527            reinterpret_cast<size_t>(object8.get_buffer()),
;;;528            reinterpret_cast<size_t>(object9.get_buffer()) };
;;;529    
;;;530          for(s32 i=0; i<9; i++) {
;;;531            for(s32 j=i+1; j<9; j++) {
;;;532              if(bufferPointers[i] == bufferPointers[j])
;;;533                return false;
;;;534            }
;;;535          }
;;;536    
;;;537          return true;
;;;538        }
;;;539      } // namespace Embedded
;;;540    } // namespace Anki
;;;541    
;;;542    #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26         namespace Matrix
;;;27         {
;;;28           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;29           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;30           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;31           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;32     
;;;33           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;34           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;35           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;36           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;37     
;;;38           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;39           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;40           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;41           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;42     
;;;43           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;44           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;45           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;46           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;47     
;;;48           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;49           {
;;;50             const Array<Type> &array = mat.get_array();
;;;51     
;;;52             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;53               0, "Matrix::Min", "Array<Type> is not valid");
;;;54     
;;;55             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;56     
;;;57             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;58               0, "Matrix::Min", "Limits is not valid");
;;;59     
;;;60             Type minValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;61             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;62               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;63               const Type * restrict pMat = array.Pointer(y, 0);
;;;64     
;;;65               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;66                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;67                 minValue = MIN(minValue, pMat[x]);
;;;68               }
;;;69             }
;;;70     
;;;71             return minValue;
;;;72           } // template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;73     
;;;74           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;75           {
;;;76             const Array<Type> &array = mat.get_array();
;;;77     
;;;78             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;79               0, "Matrix::Max", "Array<Type> is not valid");
;;;80     
;;;81             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;82     
;;;83             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;84               0, "Matrix::Max", "Limits is not valid");
;;;85     
;;;86             Type maxValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;87             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;88               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;89               const Type * restrict pMat = array.Pointer(y, 0);
;;;90     
;;;91               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;92                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;93                 maxValue = MAX(maxValue, pMat[x]);
;;;94               }
;;;95             }
;;;96     
;;;97             return maxValue;
;;;98           } // template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;99     
;;;100          template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat)
;;;101          {
;;;102            const Array<Array_Type> &array = mat.get_array();
;;;103    
;;;104            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;105              0, "Matrix::Sum", "Array<Type> is not valid");
;;;106    
;;;107            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;108    
;;;109            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;110              0, "Matrix::Sum", "Limits is not valid");
;;;111    
;;;112            Accumulator_Type sum = 0;
;;;113            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;114              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;115              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;116    
;;;117              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;118                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;119                sum += pMat[x];
;;;120              }
;;;121            }
;;;122    
;;;123            return sum;
;;;124          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;125    
;;;126          template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;127          {
;;;128            const Accumulator_Type sum = Sum<Array_Type,Accumulator_Type>(mat);
;;;129            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;130            const Array_Type mean = static_cast<Array_Type>(sum / numElements);
;;;131    
;;;132            return mean;
;;;133          } // template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;134    
;;;135          template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(
;;;136            const ConstArraySliceExpression<Array_Type> &mat,
;;;137            Accumulator_Type& mean,
;;;138            Accumulator_Type& var)
;;;139          {
;;;140            const Array<Array_Type> &array = mat.get_array();
;;;141    
;;;142            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;143              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Array<Type> is not valid");
;;;144    
;;;145            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;146    
;;;147            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;148              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Limits is not valid");
;;;149    
;;;150            Accumulator_Type sum = 0;
;;;151            Accumulator_Type sumSq = 0;
;;;152            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;153              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;154              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;155    
;;;156              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;157                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;158                const Accumulator_Type val = static_cast<Accumulator_Type>(pMat[x]);
;;;159                sum   += val;
;;;160                sumSq += val*val;
;;;161              }
;;;162            }
;;;163    
;;;164            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;165    
;;;166            mean = sum / numElements;                  // mean = E[x]
;;;167            var  = (sumSq / numElements) - (mean*mean);  // var  = E[x^2] - E[x]^2
;;;168    
;;;169            return RESULT_OK;
;;;170          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;171    
;;;172          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;173          {
;;;174            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;175          } // template<typename Type> Result Add(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;176    
;;;177          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;178          {
;;;179            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;180          }
;;;181    
;;;182          template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;183          {
;;;184            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;185          }
;;;186    
;;;187          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;188          {
;;;189            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;190          } // template<typename Type> Result Subtract(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;191    
;;;192          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;193          {
;;;194            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;195          }
;;;196    
;;;197          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;198          {
;;;199            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;200          }
;;;201    
;;;202          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;203          {
;;;204            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;205          } // template<typename Type> Result DotMultiply(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;206    
;;;207          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;208          {
;;;209            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;210          }
;;;211    
;;;212          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;213          {
;;;214            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;215          }
;;;216    
;;;217          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;218          {
;;;219            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;220          } // template<typename Type> Result DotDivide(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;221    
;;;222          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;223          {
;;;224            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;225          }
;;;226    
;;;227          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;228          {
;;;229            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;230          }
;;;231    
;;;232          template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;233          {
;;;234            return Elementwise::ApplyOperation<InType, Elementwise::Exp<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;235          } // template<typename Type> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;236    
;;;237          template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;238          {
;;;239            return Elementwise::ApplyOperation<InType, Elementwise::Sqrt<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;240          }
;;;241    
;;;242          template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;243          {
;;;244            const s32 in1Height = in1.get_size(0);
;;;245            const s32 in1Width = in1.get_size(1);
;;;246    
;;;247            const s32 in2Height = in2.get_size(0);
;;;248            const s32 in2Width = in2.get_size(1);
;;;249            const s32 in2Stride = in2.get_stride();
;;;250    
;;;251            AnkiConditionalErrorAndReturnValue(in1Width == in2Height,
;;;252              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;253    
;;;254            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2Width, out),
;;;255              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;256    
;;;257            for(s32 y1=0; y1<in1Height; y1++) {
;;;258              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;259              OutType * restrict pOut = out.Pointer(y1, 0);
;;;260    
;;;261              for(s32 x2=0; x2<in2Width; x2++) {
;;;262                const u8 * restrict pIn2 = reinterpret_cast<const u8*>(in2.Pointer(0, x2));
;;;263    
;;;264                OutType accumulator = 0;
;;;265    
;;;266                s32 y2;
;;;267                for(y2=0; y2<in2Height-3; y2+=4) {
;;;268                  const InType in1_0 = pIn1[y2];
;;;269                  const InType in1_1 = pIn1[y2+1];
;;;270                  const InType in1_2 = pIn1[y2+2];
;;;271                  const InType in1_3 = pIn1[y2+3];
;;;272    
;;;273                  const InType in2_0 = *reinterpret_cast<const InType*>(pIn2);
;;;274                  const InType in2_1 = *reinterpret_cast<const InType*>(pIn2 + in2Stride);
;;;275                  const InType in2_2 = *reinterpret_cast<const InType*>(pIn2 + 2*in2Stride);
;;;276                  const InType in2_3 = *reinterpret_cast<const InType*>(pIn2 + 3*in2Stride);
;;;277    
;;;278                  accumulator +=
;;;279                    in1_0 * in2_0 +
;;;280                    in1_1 * in2_1 +
;;;281                    in1_2 * in2_2 +
;;;282                    in1_3 * in2_3;
;;;283    
;;;284                  pIn2 += 4*in2Stride;
;;;285                }
;;;286    
;;;287                for(; y2<in2Height; y2++) {
;;;288                  accumulator += pIn1[y2] * (*reinterpret_cast<const InType*>(pIn2));
;;;289    
;;;290                  pIn2 += in2Stride;
;;;291                }
;;;292    
;;;293                pOut[x2] = accumulator;
;;;294              }
;;;295            }
;;;296    
;;;297            return RESULT_OK;
;;;298          } // template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;299    
;;;300          template<typename InType, typename OutType> NO_INLINE Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;301          {
;;;302            const s32 in1Height = in1.get_size(0);
;;;303            const s32 in1Width = in1.get_size(1);
;;;304    
;;;305            const s32 in2TransposedHeight = in2Transposed.get_size(0);
;;;306            const s32 in2TransposedWidth = in2Transposed.get_size(1);
;;;307    
;;;308            AnkiConditionalErrorAndReturnValue(in1Width == in2TransposedWidth,
;;;309              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;310    
;;;311            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2TransposedHeight, out),
;;;312              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;313    
;;;314            for(s32 y1=0; y1<in1Height; y1++)
;;;315            {
;;;316              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;317    
;;;318              for(s32 y2=0; y2<in2TransposedHeight; y2++) {
;;;319                const InType * restrict pIn2 = in2Transposed.Pointer(y2, 0);
;;;320    
;;;321                OutType accumulator = 0;
;;;322    
;;;323                s32 x;
;;;324                for(x=0; x<in2TransposedWidth-3; x+=4) {
;;;325                  const InType in1_0 = pIn1[x];
;;;326                  const InType in1_1 = pIn1[x+1];
;;;327                  const InType in1_2 = pIn1[x+2];
;;;328                  const InType in1_3 = pIn1[x+3];
;;;329    
;;;330                  const InType in2_0 = pIn2[x];
;;;331                  const InType in2_1 = pIn2[x+1];
;;;332                  const InType in2_2 = pIn2[x+2];
;;;333                  const InType in2_3 = pIn2[x+3];
;;;334    
;;;335                  accumulator +=
;;;336                    in1_0 * in2_0 +
;;;337                    in1_1 * in2_1 +
;;;338                    in1_2 * in2_2 +
;;;339                    in1_3 * in2_3;
;;;340                }
;;;341    
;;;342                for(; x<in2TransposedWidth; x++) {
;;;343                  accumulator += pIn1[x] * pIn2[x];
;;;344                }
;;;345    
;;;346                *out.Pointer(y1, y2) = accumulator;
;;;347              }
;;;348            }
;;;349    
;;;350            return RESULT_OK;
;;;351          } // template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;352    
;;;353          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;354            Array<Type> &A_L,       //!< Input A Matrix and Output lower-triangular L matrix
;;;355            Array<Type> &Bt_Xt,     //!< Input B-transpose matrix and Output X-transpose solution
;;;356            bool realCholesky,      //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;357            bool &numericalFailure  //!< If true, the solver failed because of numerical instability
;;;358            )
;;;359          {
;;;360            const s32 matrixHeight = A_L.get_size(0);
;;;361            const s32 numSamples = Bt_Xt.get_size(0);
;;;362    
;;;363            numericalFailure = false;
;;;364    
;;;365            AnkiConditionalErrorAndReturnValue(AreValid(A_L, Bt_Xt),
;;;366              RESULT_FAIL_INVALID_OBJECT, "CholeskyDecomposition", "Invalid objects");
;;;367    
;;;368            AnkiConditionalErrorAndReturnValue(matrixHeight == A_L.get_size(1),
;;;369              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "A_L is not square");
;;;370    
;;;371            AnkiConditionalErrorAndReturnValue(Bt_Xt.get_size(1) == matrixHeight,
;;;372              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "Xt and Bt are the wrong sizes");
;;;373    
;;;374            // TODO: check if symmetric and positive-definite
;;;375    
;;;376            const Type minStableValue = Anki::Embedded::Flags::numeric_limits<Type>::epsilon();
;;;377    
;;;378            for(s32 i = 0; i < matrixHeight; i++) {
;;;379              // First, compute the non-diagonal values
;;;380              // This uses the results from the diagonal inverse computation from previous iterations of i
;;;381              Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;382    
;;;383              for(s32 j = 0; j < i; j++) {
;;;384                Type * restrict pAL_yj = A_L.Pointer(j, 0);
;;;385    
;;;386                Type sum = pAL_yi[j];
;;;387                for(s32 k = 0; k < j; k++) {
;;;388                  const Type value1 = pAL_yi[k];
;;;389                  const Type value2 = pAL_yj[k];
;;;390                  sum -= value1*value2;
;;;391                }
;;;392    
;;;393                pAL_yi[j] = sum*pAL_yj[j];
;;;394              } // for(s32 j = 0; j < i; j++)
;;;395    
;;;396              // Second, compute the inverse of the diagonal
;;;397              {
;;;398                Type sum = pAL_yi[i];
;;;399                for(s32 k = 0; k < i; k++) {
;;;400                  const Type value = pAL_yi[k];
;;;401                  sum -= value*value;
;;;402                }
;;;403    
;;;404                if(sum < minStableValue) {
;;;405                  numericalFailure = true;
;;;406                  return RESULT_OK;
;;;407                }
;;;408    
;;;409                // TODO: change this f32 square root to f64 if Type==f64
;;;410                const Type sumRoot = static_cast<Type>(sqrtf(static_cast<f32>(sum)));
;;;411                pAL_yi[i] = static_cast<Type>(1) / sumRoot;
;;;412              }
;;;413            } // for(s32 i = 0; i < m; i++)
;;;414    
;;;415            // Solve L*y = b via forward substitution
;;;416            for(s32 i = 0; i < matrixHeight; i++) {
;;;417              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;418              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;419    
;;;420              for(s32 j = 0; j < numSamples; j++) {
;;;421                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;422    
;;;423                Type sum = pBX_yj[i];
;;;424                for(s32 k = 0; k < i; k++) {
;;;425                  const Type value1 = pAL_yi[k];
;;;426                  const Type value2 = pBX_yj[k];
;;;427                  sum -= value1*value2;
;;;428                }
;;;429    
;;;430                pBX_yj[i] = sum*pAL_yi[i];
;;;431              }
;;;432            }
;;;433    
;;;434            // Solve L'*X = Y via back substitution
;;;435            for(s32 i = matrixHeight-1; i >= 0; i--) {
;;;436              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;437              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;438    
;;;439              for(s32 j = 0; j < numSamples; j++) {
;;;440                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;441    
;;;442                Type sum = pBX_yj[i];
;;;443                for(s32 k = matrixHeight-1; k > i; k-- ) {
;;;444                  const Type value1 = A_L[k][i];
;;;445                  const Type value2 = pBX_yj[k];
;;;446                  sum -= value1*value2;
;;;447                }
;;;448    
;;;449                pBX_yj[i] = sum*pAL_yi[i];
;;;450              }
;;;451            }
;;;452    
;;;453            if(realCholesky) {
;;;454              // Invert the diagonal values of L, and set upper triangular to zero
;;;455              for(s32 i = 0; i < matrixHeight; i++) {
;;;456                Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;457    
;;;458                pAL_yi[i] = static_cast<Type>(1) / pAL_yi[i];
;;;459    
;;;460                for(s32 j = i+1; j < matrixHeight; j++) {
;;;461                  pAL_yi[j] = 0;
;;;462                }
;;;463              }
;;;464            }
;;;465    
;;;466            return RESULT_OK;
;;;467          } // SolveLeastSquaresWithCholesky()
;;;468    
;;;469          template<typename Type> NO_INLINE Result EstimateHomography(
;;;470            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;471            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;472            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;473            bool &numericalFailure, //!< Did the homography solver fail?
;;;474            MemoryStack scratch //!< Scratch memory
;;;475            )
;;;476          {
;;;477            const Type MAX_SOLVE_DISTANCE = static_cast<Type>(0.1);
;;;478    
;;;479            //BeginBenchmark("EstimateHomography_init");
;;;480    
;;;481            const s32 numPoints = originalPoints.get_size();
;;;482    
;;;483            AnkiConditionalErrorAndReturnValue(AreValid(originalPoints, transformedPoints, homography, scratch),
;;;484              RESULT_FAIL_INVALID_OBJECT, "EstimateHomography", "Invalid objects");
;;;485    
;;;486            AnkiConditionalErrorAndReturnValue(transformedPoints.get_size() == numPoints && numPoints >= 4,
;;;487              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "originalPoints and transformedPoints must be the same size, and have at least four points apiece.");
;;;488    
;;;489            AnkiConditionalErrorAndReturnValue(AreEqualSize(3, 3, homography),
;;;490              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "homography must be 3x3");
;;;491    
;;;492            homography.SetZero();
;;;493            homography[0][0] = 1;
;;;494            homography[1][1] = 1;
;;;495            homography[2][2] = 1;
;;;496    
;;;497            Array<Type> A(8, 2*numPoints, scratch);
;;;498            Array<Type> bt(1, 2*numPoints, scratch);
;;;499    
;;;500            const Point<Type> * const pOriginalPoints = originalPoints.Pointer(0);
;;;501            const Point<Type> * const pTransformedPoints = transformedPoints.Pointer(0);
;;;502    
;;;503            Type * restrict pBt = bt.Pointer(0,0);
;;;504    
;;;505            //EndBenchmark("EstimateHomography_init");
;;;506    
;;;507            //BeginBenchmark("EstimateHomography_a&b");
;;;508    
;;;509            for(s32 i=0; i<numPoints; i++) {
;;;510              Type * restrict A_y1 = A.Pointer(2*i, 0);
;;;511              Type * restrict A_y2 = A.Pointer(2*i + 1, 0);
;;;512    
;;;513              const Type xi = pOriginalPoints[i].x;
;;;514              const Type yi = pOriginalPoints[i].y;
;;;515    
;;;516              const Type xp = pTransformedPoints[i].x;
;;;517              const Type yp = pTransformedPoints[i].y;
;;;518    
;;;519              A_y1[0] = 0;  A_y1[1] = 0;  A_y1[2] = 0; A_y1[3] = -xi; A_y1[4] = -yi; A_y1[5] = -1; A_y1[6] = xi*yp;  A_y1[7] = yi*yp;
;;;520              A_y2[0] = xi; A_y2[1] = yi; A_y2[2] = 1; A_y2[3] = 0;   A_y2[4] = 0;   A_y2[5] = 0;  A_y2[6] = -xi*xp; A_y2[7] = -yi*xp;
;;;521    
;;;522              pBt[2*i] = -yp;
;;;523              pBt[2*i + 1] = xp;
;;;524            }
;;;525    
;;;526            //EndBenchmark("EstimateHomography_a&b");
;;;527    
;;;528            //BeginBenchmark("EstimateHomography_At");
;;;529    
;;;530            Array<Type> At(2*numPoints, 8, scratch);
;;;531    
;;;532            Matrix::Transpose(A, At);
;;;533    
;;;534            //EndBenchmark("EstimateHomography_At");
;;;535    
;;;536            //BeginBenchmark("EstimateHomography_AtA");
;;;537    
;;;538            Array<Type> AtA(8, 8, scratch, Flags::Buffer(false,false,false));
;;;539            Array<Type> Atb(8, 1, scratch, Flags::Buffer(false,false,false));
;;;540    
;;;541            Matrix::Multiply(At, A, AtA);
;;;542    
;;;543            //EndBenchmark("EstimateHomography_AtA");
;;;544    
;;;545            //BeginBenchmark("EstimateHomography_Atb");
;;;546    
;;;547            Matrix::MultiplyTranspose(At, bt, Atb);
;;;548    
;;;549            //EndBenchmark("EstimateHomography_Atb");
;;;550    
;;;551            //BeginBenchmark("EstimateHomography_transposeAtb");
;;;552    
;;;553            Array<Type> Atbt(1, 8, scratch);
;;;554    
;;;555            Matrix::Transpose(Atb, Atbt);
;;;556    
;;;557            //EndBenchmark("EstimateHomography_transposeAtb");
;;;558    
;;;559            //BeginBenchmark("EstimateHomography_cholesky");
;;;560    
;;;561            const Result choleskyResult = SolveLeastSquaresWithCholesky(AtA, Atbt, false, numericalFailure);
;;;562    
;;;563            AnkiConditionalErrorAndReturnValue(choleskyResult == RESULT_OK,
;;;564              choleskyResult, "EstimateHomography", "SolveLeastSquaresWithCholesky failed");
;;;565    
;;;566            if(numericalFailure){
;;;567              AnkiWarn("EstimateHomography", "numericalFailure");
;;;568              return RESULT_OK;
;;;569            }
;;;570    
;;;571            Type * restrict pAtbt = Atbt.Pointer(0,0);
;;;572    
;;;573            homography[0][0] = pAtbt[0]; homography[0][1] = pAtbt[1]; homography[0][2] = pAtbt[2];
;;;574            homography[1][0] = pAtbt[3]; homography[1][1] = pAtbt[4]; homography[1][2] = pAtbt[5];
;;;575            homography[2][0] = pAtbt[6]; homography[2][1] = pAtbt[7]; homography[2][2] = static_cast<Type>(1);
;;;576    
;;;577            // Check that the solution is fairly close
;;;578            // TODO: make work for numPoints != 4
;;;579            if(numPoints == 4) {
;;;580              Array<Type> point1(3,1,scratch);
;;;581              Array<Type> point1Warped(3,1,scratch);
;;;582              for(s32 iPoint=0; iPoint<numPoints; iPoint++) {
;;;583                point1[0][0] = originalPoints[iPoint].x;
;;;584                point1[1][0] = originalPoints[iPoint].y;
;;;585                point1[2][0] = 1;
;;;586    
;;;587                Matrix::Multiply(homography, point1, point1Warped);
;;;588                point1Warped[0][0] /= point1Warped[2][0];
;;;589                point1Warped[1][0] /= point1Warped[2][0];
;;;590    
;;;591                const Type distance = sqrtf(powf(static_cast<f32>(transformedPoints[iPoint].x) - static_cast<f32>(point1Warped[0][0]), 2.0f) + powf(static_cast<f32>(transformedPoints[iPoint].y) - static_cast<f32>(point1Warped[1][0]), 2.0f));
;;;592    
;;;593                if(distance > MAX_SOLVE_DISTANCE) {
;;;594                  AnkiWarn("EstimateHomography", "Poor solution precision");
;;;595    
;;;596                  numericalFailure = true;
;;;597    
;;;598                  homography.SetZero();
;;;599                  homography[0][0] = 1;
;;;600                  homography[1][1] = 1;
;;;601                  homography[2][2] = 1;
;;;602    
;;;603                  return RESULT_OK;
;;;604                }
;;;605              }
;;;606            }
;;;607            //EndBenchmark("EstimateHomography_cholesky");
;;;608    
;;;609            return RESULT_OK;
;;;610          } // EstimateHomography()
;;;611    
;;;612          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;613          {
;;;614            const s32 inHeight = in.get_size(0);
;;;615            const s32 inWidth = in.get_size(1);
;;;616    
;;;617            const s32 outHeight = out.get_size(0);
;;;618            const s32 outWidth = out.get_size(1);
;;;619    
;;;620            AnkiConditionalErrorAndReturnValue((inHeight*inWidth) == (outHeight*outWidth),
;;;621              RESULT_FAIL_INVALID_SIZE, "Reshape", "Input and Output matrices are incompatible sizes");
;;;622    
;;;623            s32 inIndexY = 0;
;;;624            s32 inIndexX = 0;
;;;625    
;;;626            if(isColumnMajor) {
;;;627              for(s32 y = 0; y < outHeight; y++)
;;;628              {
;;;629                OutType * const pOut = out.Pointer(y,0);
;;;630    
;;;631                for(s32 x = 0; x < outWidth; x++) {
;;;632                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;633    
;;;634                  pOut[x] = static_cast<OutType>(curIn);
;;;635    
;;;636                  inIndexY++;
;;;637                  if(inIndexY >= inHeight) {
;;;638                    inIndexY = 0;
;;;639                    inIndexX++;
;;;640                  }
;;;641                }
;;;642              }
;;;643            } else { // if(isColumnMajor)
;;;644              for(s32 y = 0; y < outHeight; y++)
;;;645              {
;;;646                OutType * const pOut = out.Pointer(y,0);
;;;647    
;;;648                for(s32 x = 0; x < outWidth; x++) {
;;;649                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;650    
;;;651                  pOut[x] = static_cast<OutType>(curIn);
;;;652    
;;;653                  inIndexX++;
;;;654                  if(inIndexX >= inWidth) {
;;;655                    inIndexX = 0;
;;;656                    inIndexY++;
;;;657                  }
;;;658                }
;;;659              }
;;;660            } // if(isColumnMajor) ... else
;;;661    
;;;662            return RESULT_OK;
;;;663          } // Reshape()
;;;664    
;;;665          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory)
;;;666          {
;;;667            Array<OutType> out(newHeight, newWidth, memory);
;;;668    
;;;669            Reshape<InType, OutType>(isColumnMajor, in, out);
;;;670    
;;;671            return out;
;;;672          }
;;;673    
;;;674          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;675          {
;;;676            AnkiConditionalErrorAndReturnValue(out.get_size(0) == 1,
;;;677              RESULT_FAIL_INVALID_SIZE, "Vectorize", "Output is not 1xN");
;;;678    
;;;679            return Reshape<InType, OutType>(isColumnMajor, in, out);
;;;680          }
;;;681    
;;;682          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory)
;;;683          {
;;;684            const s32 inHeight = in.get_size(0);
;;;685            const s32 inWidth = in.get_size(1);
;;;686    
;;;687            Array<OutType> out(1, inHeight*inWidth, memory);
;;;688    
;;;689            Vectorize<InType, OutType>(isColumnMajor, in, out);
;;;690    
;;;691            return out;
;;;692          }
;;;693    
;;;694          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out)
;;;695          {
;;;696            const s32 inHeight = in.get_size(0);
;;;697            const s32 inWidth = in.get_size(1);
;;;698    
;;;699            const s32 outStride = out.get_stride();
;;;700    
;;;701            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;702              RESULT_FAIL_INVALID_OBJECT, "Transpose", "Invalid objects");
;;;703    
;;;704            AnkiConditionalErrorAndReturnValue(AreEqualSize(in.get_size(1), in.get_size(0), out),
;;;705              RESULT_FAIL_INVALID_SIZE, "Transpose", "out is not the correct size");
;;;706    
;;;707            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;708              RESULT_FAIL_ALIASED_MEMORY, "Transpose", "in and out cannot be the same array");
;;;709    
;;;710            for(s32 yIn=0; yIn<inHeight; yIn++) {
;;;711              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;712              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0,yIn));
;;;713    
;;;714              s32 xIn;
;;;715              s32 outOffset0 = 0;
;;;716    
;;;717              for(xIn=0; xIn<inWidth-1; xIn+=2) {
;;;718                const InType in0 = pIn[xIn];
;;;719                const InType in1 = pIn[xIn+1];
;;;720    
;;;721                const s32 outOffset1 = outOffset0 + outStride;
;;;722    
;;;723                *reinterpret_cast<OutType*>(pOut + outOffset0) = static_cast<OutType>(in0);
;;;724                *reinterpret_cast<OutType*>(pOut + outOffset1) = static_cast<OutType>(in1);
;;;725    
;;;726                outOffset0 += 2*outStride;
;;;727              }
;;;728    
;;;729              for(; xIn<inWidth; xIn++) {
;;;730                *out.Pointer(xIn,yIn) = static_cast<OutType>(pIn[xIn]);
;;;731              }
;;;732            }
;;;733    
;;;734            return RESULT_OK;
;;;735          } // Transpose()
;;;736    
;;;737          template<typename InType, typename OutType> Result Rotate90(const Array<InType> &in, Array<OutType> &out)
;;;738          {
;;;739            const s32 arrWidth = in.get_size(1);
;;;740    
;;;741            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;742              RESULT_FAIL_INVALID_OBJECT, "Rotate90", "Invalid objects");
;;;743    
;;;744            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;745              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;746    
;;;747            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;748              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;749    
;;;750            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;751              RESULT_FAIL_ALIASED_MEMORY, "Rotate90", "in and out cannot be the same array");
;;;752    
;;;753            const s32 outStride = out.get_stride();
;;;754    
;;;755            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;756              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;757              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0, arrWidth-yIn-1));
;;;758    
;;;759              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;760                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;761    
;;;762                pOut += outStride;
;;;763              }
;;;764            }
;;;765    
;;;766            return RESULT_OK;
;;;767          } // Rotate90()
;;;768    
;;;769          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out)
;;;770          {
;;;771            const s32 arrWidth = in.get_size(1);
;;;772    
;;;773            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;774              RESULT_FAIL_INVALID_OBJECT, "Rotate180", "Invalid objects");
;;;775    
;;;776            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;777              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;778    
;;;779            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;780              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;781    
;;;782            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;783              RESULT_FAIL_ALIASED_MEMORY, "Rotate180", "in and out cannot be the same array");
;;;784    
;;;785            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;786              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;787              OutType * restrict pOut = out.Pointer(arrWidth-yIn-1, 0);
;;;788    
;;;789              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;790                pOut[arrWidth-xIn-1] = static_cast<OutType>(pIn[xIn]);
;;;791              }
;;;792            }
;;;793    
;;;794            return RESULT_OK;
;;;795          } // Rotate180()
;;;796    
;;;797          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out)
;;;798          {
;;;799            const s32 arrWidth = in.get_size(1);
;;;800    
;;;801            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;802              RESULT_FAIL_INVALID_OBJECT, "Rotate270", "Invalid objects");
;;;803    
;;;804            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;805              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;806    
;;;807            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;808              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;809    
;;;810            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;811              RESULT_FAIL_ALIASED_MEMORY, "Rotate270", "in and out cannot be the same array");
;;;812    
;;;813            const s32 outStride = out.get_stride();
;;;814    
;;;815            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;816              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;817              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(arrWidth-1, yIn));
;;;818    
;;;819              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;820                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;821    
;;;822                pOut -= outStride;
;;;823              }
;;;824            }
;;;825    
;;;826            return RESULT_OK;
;;;827          } // Rotate270()
;;;828    
;;;829          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;830          {
;;;831            const s32 arrWidth = arr.get_size(1);
;;;832    
;;;833            for(s32 x=0; x<arrWidth; x++) {
;;;834              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;835                const Type valueToInsert = arr[y][x];
;;;836    
;;;837                s32 holePosition = y;
;;;838    
;;;839                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;840                  arr[holePosition][x] = arr[holePosition-1][x];
;;;841                  holePosition--;
;;;842                }
;;;843    
;;;844                arr[holePosition][x] = valueToInsert;
;;;845              }
;;;846            } // for(s32 x=0; x<arrWidth; x++)
;;;847          } // InsertionSort_sortAscendingDimension0()
;;;848    
;;;849          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;850          {
;;;851            const s32 arrWidth = arr.get_size(1);
;;;852    
;;;853            for(s32 x=0; x<arrWidth; x++) {
;;;854              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;855                const Type valueToInsert = arr[y][x];
;;;856    
;;;857                s32 holePosition = y;
;;;858    
;;;859                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;860                  arr[holePosition][x] = arr[holePosition-1][x];
;;;861                  holePosition--;
;;;862                }
;;;863    
;;;864                arr[holePosition][x] = valueToInsert;
;;;865              }
;;;866            } // for(s32 x=0; x<arrWidth; x++)
;;;867          } // InsertionSort_sortDescendingDimension0
;;;868    
;;;869          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;870          {
;;;871            const s32 arrHeight = arr.get_size(0);
;;;872    
;;;873            for(s32 y=0; y<arrHeight; y++) {
;;;874              Type * const pArr = arr[y];
;;;875    
;;;876              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;877                const Type valueToInsert = pArr[x];
;;;878    
;;;879                s32 holePosition = x;
;;;880    
;;;881                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;882                  pArr[holePosition] = pArr[holePosition-1];
;;;883                  holePosition--;
;;;884                }
;;;885    
;;;886                pArr[holePosition] = valueToInsert;
;;;887              }
;;;888            } // for(s32 x=0; x<arrWidth; x++)
;;;889          } // InsertionSort_sortAscendingDimension1()
;;;890    
;;;891          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;892          {
;;;893            const s32 arrHeight = arr.get_size(0);
;;;894    
;;;895            for(s32 y=0; y<arrHeight; y++) {
;;;896              Type * const pArr = arr[y];
;;;897    
;;;898              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;899                const Type valueToInsert = pArr[x];
;;;900    
;;;901                s32 holePosition = x;
;;;902    
;;;903                while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;904                  pArr[holePosition] = pArr[holePosition-1];
;;;905                  holePosition--;
;;;906                }
;;;907    
;;;908                pArr[holePosition] = valueToInsert;
;;;909              }
;;;910            } // for(s32 x=0; x<arrWidth; x++)
;;;911          } // InsertionSort_sortAscendingDimension1()
;;;912    
;;;913          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;914          {
;;;915            const s32 arrWidth = arr.get_size(1);
;;;916    
;;;917            for(s32 x=0; x<arrWidth; x++) {
;;;918              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;919                const Type valueToInsert = arr[y][x];
;;;920                const s32 indexToInsert = indexes[y][x];
;;;921    
;;;922                s32 holePosition = y;
;;;923    
;;;924                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;925                  arr[holePosition][x] = arr[holePosition-1][x];
;;;926                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;927                  holePosition--;
;;;928                }
;;;929    
;;;930                arr[holePosition][x] = valueToInsert;
;;;931                indexes[holePosition][x] = indexToInsert;
;;;932              }
;;;933            } // for(s32 x=0; x<arrWidth; x++)
;;;934          } // InsertionSort_sortAscendingDimension0()
;;;935    
;;;936          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;937          {
;;;938            const s32 arrWidth = arr.get_size(1);
;;;939    
;;;940            for(s32 x=0; x<arrWidth; x++) {
;;;941              indexes[0][x] = 0;
;;;942    
;;;943              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;944                const Type valueToInsert = arr[y][x];
;;;945                const s32 indexToInsert = indexes[y][x];
;;;946    
;;;947                s32 holePosition = y;
;;;948    
;;;949                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;950                  arr[holePosition][x] = arr[holePosition-1][x];
;;;951                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;952                  holePosition--;
;;;953                }
;;;954    
;;;955                arr[holePosition][x] = valueToInsert;
;;;956                indexes[holePosition][x] = indexToInsert;
;;;957              }
;;;958            } // for(s32 x=0; x<arrWidth; x++)
;;;959          } // InsertionSort_sortDescendingDimension0()
;;;960    
;;;961          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;962          {
;;;963            const s32 arrHeight = arr.get_size(0);
;;;964    
;;;965            for(s32 y=0; y<arrHeight; y++) {
;;;966              Type * const pArr = arr[y];
;;;967              s32 * const pIndexes = indexes[y];
;;;968    
;;;969              pIndexes[0] = 0;
;;;970    
;;;971              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;972                const Type valueToInsert = pArr[x];
;;;973                const s32 indexToInsert = pIndexes[x];
;;;974    
;;;975                s32 holePosition = x;
;;;976    
;;;977                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;978                  pArr[holePosition] = pArr[holePosition-1];
;;;979                  pIndexes[holePosition] = pIndexes[holePosition-1];
;;;980                  holePosition--;
;;;981                }
;;;982    
;;;983                pArr[holePosition] = valueToInsert;
;;;984                pIndexes[holePosition] = indexToInsert;
;;;985              }
;;;986            } // for(s32 x=0; x<arrWidth; x++)
;;;987          } // InsertionSort_sortAscendingDimension1()
;;;988    
;;;989          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;990          {
;;;991            const s32 arrHeight = arr.get_size(0);
;;;992    
;;;993            for(s32 y=0; y<arrHeight; y++) {
;;;994              Type * const pArr = arr[y];
;;;995              s32 * const pIndexes = indexes[y];
;;;996    
;;;997              pIndexes[0] = 0;
;;;998    
;;;999              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;1000               const Type valueToInsert = pArr[x];
;;;1001               const s32 indexToInsert = pIndexes[x];
;;;1002   
;;;1003               s32 holePosition = x;
;;;1004   
;;;1005               while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;1006                 pArr[holePosition] = pArr[holePosition-1];
;;;1007                 pIndexes[holePosition] = pIndexes[holePosition-1];
;;;1008                 holePosition--;
;;;1009               }
;;;1010   
;;;1011               pArr[holePosition] = valueToInsert;
;;;1012               pIndexes[holePosition] = indexToInsert;
;;;1013             }
;;;1014           } // for(s32 x=0; x<arrWidth; x++)
;;;1015         } // InsertionSort_sortDescendingDimension1()
;;;1016   
;;;1017         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1018         {
;;;1019           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1020             return;
;;;1021           }
;;;1022   
;;;1023           // Select the median value of the first, middle, and last elements as the pivot
;;;1024           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1025   
;;;1026           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1027   
;;;1028           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1029             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1030   
;;;1031           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1032             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1033   
;;;1034           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x))
;;;1035             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1036   
;;;1037           // Search from the beginning to before the moved pivot
;;;1038           s32 i = trueMinIndex;
;;;1039           s32 j = trueMaxIndex - 2;
;;;1040   
;;;1041           if(i >= j) {
;;;1042             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1043             // NOTE: This really means your insertionSortSize value is too low
;;;1044             return;
;;;1045           }
;;;1046   
;;;1047           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1048   
;;;1049           const Type pivot = *arr.Pointer(midIndex, x);
;;;1050   
;;;1051           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1052   
;;;1053           // Main partitioning loop
;;;1054           while(true) {
;;;1055             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1056             while(*arr.Pointer(i,x) < pivot) {
;;;1057               i++;
;;;1058             }
;;;1059   
;;;1060             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1061             while(*arr.Pointer(j,x) > pivot) {
;;;1062               j--;
;;;1063             }
;;;1064   
;;;1065             if(i < j) {
;;;1066               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1067               i++;
;;;1068               j--;
;;;1069             } else {
;;;1070               break;
;;;1071             }
;;;1072           }
;;;1073   
;;;1074           // Replace the pivot
;;;1075           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1076   
;;;1077           // Recurse
;;;1078           QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1079   
;;;1080           QuickSort_sortAscendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1081         } // QuickSort_sortAscendingDimension0
;;;1082   
;;;1083         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1084         {
;;;1085           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1086             return;
;;;1087           }
;;;1088   
;;;1089           // Select the median value of the first, middle, and last elements as the pivot
;;;1090           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1091   
;;;1092           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1093   
;;;1094           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1095             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1096   
;;;1097           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1098             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1099   
;;;1100           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x))
;;;1101             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1102   
;;;1103           // Search from the beginning to before the moved pivot
;;;1104           s32 i = trueMinIndex;
;;;1105           s32 j = trueMaxIndex - 2;
;;;1106   
;;;1107           if(i >= j) {
;;;1108             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1109             // NOTE: This really means your insertionSortSize value is too low
;;;1110             return;
;;;1111           }
;;;1112   
;;;1113           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1114   
;;;1115           const Type pivot = *arr.Pointer(midIndex, x);
;;;1116   
;;;1117           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1118   
;;;1119           // Main partitioning loop
;;;1120           while(true) {
;;;1121             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1122             while(*arr.Pointer(i,x) > pivot) {
;;;1123               i++;
;;;1124             }
;;;1125   
;;;1126             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1127             while(*arr.Pointer(j,x) < pivot) {
;;;1128               j--;
;;;1129             }
;;;1130   
;;;1131             if(i < j) {
;;;1132               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1133               i++;
;;;1134               j--;
;;;1135             } else {
;;;1136               break;
;;;1137             }
;;;1138           }
;;;1139   
;;;1140           // Replace the pivot
;;;1141           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1142   
;;;1143           // Recurse
;;;1144           QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1145   
;;;1146           QuickSort_sortDescendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1147         } // QuickSort_sortDescendingDimension0
;;;1148   
;;;1149         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1150         {
;;;1151           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1152             return;
;;;1153           }
;;;1154   
;;;1155           Type * restrict pArr = arr.Pointer(y,0);
;;;1156   
;;;1157           // Select the median value of the first, middle, and last elements as the pivot
;;;1158           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1159   
;;;1160           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1161   
;;;1162           if(pArr[midIndex] < pArr[trueMinIndex])
;;;1163             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1164   
;;;1165           if(pArr[trueMaxIndex] < pArr[trueMinIndex])
;;;1166             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1167   
;;;1168           if(pArr[trueMaxIndex] < pArr[midIndex])
;;;1169             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1170   
;;;1171           // Search from the beginning to before the moved pivot
;;;1172           s32 i = trueMinIndex;
;;;1173           s32 j = trueMaxIndex - 2;
;;;1174   
;;;1175           if(i >= j) {
;;;1176             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1177             // NOTE: This really means your insertionSortSize value is too low
;;;1178             return;
;;;1179           }
;;;1180   
;;;1181           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1182   
;;;1183           const Type pivot = pArr[midIndex];
;;;1184   
;;;1185           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1186   
;;;1187           // Main partitioning loop
;;;1188           while(true) {
;;;1189             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1190             while(pArr[i] < pivot) {
;;;1191               i++;
;;;1192             }
;;;1193   
;;;1194             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1195             while(pArr[j] > pivot) {
;;;1196               j--;
;;;1197             }
;;;1198   
;;;1199             if(i < j) {
;;;1200               Swap<Type>(pArr[i], pArr[j]);
;;;1201               i++;
;;;1202               j--;
;;;1203             } else {
;;;1204               break;
;;;1205             }
;;;1206           }
;;;1207   
;;;1208           // Replace the pivot
;;;1209           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1210   
;;;1211           // Recurse
;;;1212           QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1213   
;;;1214           QuickSort_sortAscendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1215         } // QuickSort_sortAscendingDimension1
;;;1216   
;;;1217         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1218         {
;;;1219           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1220             return;
;;;1221           }
;;;1222   
;;;1223           Type * restrict pArr = arr.Pointer(y,0);
;;;1224   
;;;1225           // Select the median value of the first, middle, and last elements as the pivot
;;;1226           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1227   
;;;1228           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1229   
;;;1230           if(pArr[midIndex] < pArr[trueMaxIndex])
;;;1231             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1232   
;;;1233           if(pArr[trueMinIndex] < pArr[trueMaxIndex])
;;;1234             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1235   
;;;1236           if(pArr[trueMinIndex] < pArr[midIndex])
;;;1237             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1238   
;;;1239           // Search from the beginning to before the moved pivot
;;;1240           s32 i = trueMinIndex;
;;;1241           s32 j = trueMaxIndex - 2;
;;;1242   
;;;1243           if(i >= j) {
;;;1244             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1245             // NOTE: This really means your insertionSortSize value is too low
;;;1246             return;
;;;1247           }
;;;1248   
;;;1249           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1250   
;;;1251           const Type pivot = pArr[midIndex];
;;;1252   
;;;1253           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1254   
;;;1255           // Main partitioning loop
;;;1256           while(true) {
;;;1257             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1258             while(pArr[i] > pivot) {
;;;1259               i++;
;;;1260             }
;;;1261   
;;;1262             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1263             while(pArr[j] < pivot) {
;;;1264               j--;
;;;1265             }
;;;1266   
;;;1267             if(i < j) {
;;;1268               Swap<Type>(pArr[i], pArr[j]);
;;;1269               i++;
;;;1270               j--;
;;;1271             } else {
;;;1272               break;
;;;1273             }
;;;1274           }
;;;1275   
;;;1276           // Replace the pivot
;;;1277           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1278   
;;;1279           // Recurse
;;;1280           QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1281   
;;;1282           QuickSort_sortDescendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1283         } // QuickSort_sortDescendingDimension1
;;;1284   
;;;1285         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1286         {
;;;1287           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1288             return;
;;;1289           }
;;;1290   
;;;1291           // Select the median value of the first, middle, and last elements as the pivot
;;;1292           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1293   
;;;1294           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1295   
;;;1296           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1297             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1298             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1299           }
;;;1300   
;;;1301           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1302             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1303             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1304           }
;;;1305   
;;;1306           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1307             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1308             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(midIndex, x));
;;;1309           }
;;;1310   
;;;1311           // Search from the beginning to before the moved pivot
;;;1312           s32 i = trueMinIndex;
;;;1313           s32 j = trueMaxIndex - 2;
;;;1314   
;;;1315           if(i >= j) {
;;;1316             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1317             // NOTE: This really means your insertionSortSize value is too low
;;;1318             return;
;;;1319           }
;;;1320   
;;;1321           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1322   
;;;1323           const Type pivot = *arr.Pointer(midIndex, x);
;;;1324   
;;;1325           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1326           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1327   
;;;1328           // Main partitioning loop
;;;1329           while(true) {
;;;1330             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1331             while(*arr.Pointer(i,x) < pivot) {
;;;1332               i++;
;;;1333             }
;;;1334   
;;;1335             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1336             while(*arr.Pointer(j,x) > pivot) {
;;;1337               j--;
;;;1338             }
;;;1339   
;;;1340             if(i < j) {
;;;1341               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1342               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1343               i++;
;;;1344               j--;
;;;1345             } else {
;;;1346               break;
;;;1347             }
;;;1348           }
;;;1349   
;;;1350           // Replace the pivot
;;;1351           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1352           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1353   
;;;1354           // Recurse
;;;1355           QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1356   
;;;1357           QuickSort_sortAscendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1358         } // QuickSort_sortAscendingDimension0
;;;1359   
;;;1360         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1361         {
;;;1362           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1363             return;
;;;1364           }
;;;1365   
;;;1366           // Select the median value of the first, middle, and last elements as the pivot
;;;1367           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1368   
;;;1369           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1370   
;;;1371           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1372             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1373             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1374           }
;;;1375   
;;;1376           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1377             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1378             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1379           }
;;;1380   
;;;1381           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1382             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1383             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(midIndex, x));
;;;1384           }
;;;1385   
;;;1386           // Search from the beginning to before the moved pivot
;;;1387           s32 i = trueMinIndex;
;;;1388           s32 j = trueMaxIndex - 2;
;;;1389   
;;;1390           if(i >= j) {
;;;1391             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1392             // NOTE: This really means your insertionSortSize value is too low
;;;1393             return;
;;;1394           }
;;;1395   
;;;1396           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1397   
;;;1398           const Type pivot = *arr.Pointer(midIndex, x);
;;;1399   
;;;1400           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1401           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1402   
;;;1403           // Main partitioning loop
;;;1404           while(true) {
;;;1405             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1406             while(*arr.Pointer(i,x) > pivot) {
;;;1407               i++;
;;;1408             }
;;;1409   
;;;1410             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1411             while(*arr.Pointer(j,x) < pivot) {
;;;1412               j--;
;;;1413             }
;;;1414   
;;;1415             if(i < j) {
;;;1416               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1417               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1418               i++;
;;;1419               j--;
;;;1420             } else {
;;;1421               break;
;;;1422             }
;;;1423           }
;;;1424   
;;;1425           // Replace the pivot
;;;1426           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1427           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1428   
;;;1429           // Recurse
;;;1430           QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1431   
;;;1432           QuickSort_sortDescendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1433         } // QuickSort_sortDescendingDimension0
;;;1434   
;;;1435         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1436         {
;;;1437           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1438             return;
;;;1439           }
;;;1440   
;;;1441           Type * restrict pArr = arr.Pointer(y,0);
;;;1442           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1443   
;;;1444           // Select the median value of the first, middle, and last elements as the pivot
;;;1445           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1446   
;;;1447           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1448   
;;;1449           if(pArr[midIndex] < pArr[trueMinIndex]) {
;;;1450             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1451             Swap<s32>(pIndexes[midIndex], pIndexes[trueMinIndex]);
;;;1452           }
;;;1453   
;;;1454           if(pArr[trueMaxIndex] < pArr[trueMinIndex]) {
;;;1455             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1456             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[trueMinIndex]);
;;;1457           }
;;;1458   
;;;1459           if(pArr[trueMaxIndex] < pArr[midIndex]) {
;;;1460             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1461             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[midIndex]);
;;;1462           }
;;;1463   
;;;1464           // Search from the beginning to before the moved pivot
;;;1465           s32 i = trueMinIndex;
;;;1466           s32 j = trueMaxIndex - 2;
;;;1467   
;;;1468           if(i >= j) {
;;;1469             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1470             // NOTE: This really means your insertionSortSize value is too low
;;;1471             return;
;;;1472           }
;;;1473   
;;;1474           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1475   
;;;1476           const Type pivot = pArr[midIndex];
;;;1477   
;;;1478           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1479           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1480   
;;;1481           // Main partitioning loop
;;;1482           while(true) {
;;;1483             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1484             while(pArr[i] < pivot) {
;;;1485               i++;
;;;1486             }
;;;1487   
;;;1488             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1489             while(pArr[j] > pivot) {
;;;1490               j--;
;;;1491             }
;;;1492   
;;;1493             if(i < j) {
;;;1494               Swap<Type>(pArr[i], pArr[j]);
;;;1495               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1496               i++;
;;;1497               j--;
;;;1498             } else {
;;;1499               break;
;;;1500             }
;;;1501           }
;;;1502   
;;;1503           // Replace the pivot
;;;1504           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1505           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1506   
;;;1507           // Recurse
;;;1508           QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1509   
;;;1510           QuickSort_sortAscendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1511         } // QuickSort_sortAscendingDimension1
;;;1512   
;;;1513         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1514         {
;;;1515           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1516             return;
;;;1517           }
;;;1518   
;;;1519           Type * restrict pArr = arr.Pointer(y,0);
;;;1520           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1521   
;;;1522           // Select the median value of the first, middle, and last elements as the pivot
;;;1523           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1524   
;;;1525           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1526   
;;;1527           if(pArr[midIndex] < pArr[trueMaxIndex]) {
;;;1528             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1529             Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex]);
;;;1530           }
;;;1531   
;;;1532           if(pArr[trueMinIndex] < pArr[trueMaxIndex]) {
;;;1533             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1534             Swap<s32>(pIndexes[trueMinIndex], pIndexes[trueMaxIndex]);
;;;1535           }
;;;1536   
;;;1537           if(pArr[trueMinIndex] < pArr[midIndex]) {
;;;1538             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1539             Swap<s32>(pIndexes[trueMinIndex], pIndexes[midIndex]);
;;;1540           }
;;;1541   
;;;1542           // Search from the beginning to before the moved pivot
;;;1543           s32 i = trueMinIndex;
;;;1544           s32 j = trueMaxIndex - 2;
;;;1545   
;;;1546           if(i >= j) {
;;;1547             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1548             // NOTE: This really means your insertionSortSize value is too low
;;;1549             return;
;;;1550           }
;;;1551   
;;;1552           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1553   
;;;1554           const Type pivot = pArr[midIndex];
;;;1555   
;;;1556           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1557           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1558   
;;;1559           // Main partitioning loop
;;;1560           while(true) {
;;;1561             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1562             while(pArr[i] > pivot) {
;;;1563               i++;
;;;1564             }
;;;1565   
;;;1566             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1567             while(pArr[j] < pivot) {
;;;1568               j--;
;;;1569             }
;;;1570   
;;;1571             if(i < j) {
;;;1572               Swap<Type>(pArr[i], pArr[j]);
;;;1573               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1574               i++;
;;;1575               j--;
;;;1576             } else {
;;;1577               break;
;;;1578             }
;;;1579           }
;;;1580   
;;;1581           // Replace the pivot
;;;1582           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1583           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1584   
;;;1585           // Recurse
;;;1586           QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1587   
;;;1588           QuickSort_sortDescendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1589         } // QuickSort_sortDescendingDimension1
;;;1590   
;;;1591         template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1592         {
;;;1593           // const s32 arrHeight = arr.get_size(0);
;;;1594           // const s32 arrWidth = arr.get_size(1);
;;;1595   
;;;1596           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1597             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1598   
;;;1599           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1600             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1601   
;;;1602           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1603           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1604   
;;;1605           if(sortWhichDimension == 0) {
;;;1606             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1607             if(sortAscending) {
;;;1608               InsertionSort_sortAscendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1609             } else { // if(sortAscending)
;;;1610               InsertionSort_sortDescendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1611             } // if(sortAscending) ... else
;;;1612           } else { // sortWhichDimension == 1
;;;1613             if(sortAscending) {
;;;1614               InsertionSort_sortAscendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1615             } else { // if(sortAscending)
;;;1616               InsertionSort_sortDescendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1617             } // if(sortAscending) ... else
;;;1618           } // if(sortWhichDimension == 0) ... else
;;;1619   
;;;1620           return RESULT_OK;
;;;1621         } // InsertionSort()
;;;1622   
;;;1623         template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1624         {
;;;1625           const s32 arrHeight = arr.get_size(0);
;;;1626           const s32 arrWidth = arr.get_size(1);
;;;1627   
;;;1628           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1629             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1630   
;;;1631           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1632             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1633   
;;;1634           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1635             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1636   
;;;1637           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1638           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1639   
;;;1640           if(sortWhichDimension == 0) {
;;;1641             for(s32 y=0; y<arrHeight; y++) {
;;;1642               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1643               for(s32 x=0; x<arrWidth; x++) {
;;;1644                 pIndexes[x] = y;
;;;1645               }
;;;1646             }
;;;1647   
;;;1648             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1649             if(sortAscending) {
;;;1650               InsertionSort_sortAscendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1651             } else { // if(sortAscending)
;;;1652               InsertionSort_sortDescendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1653             } // if(sortAscending) ... else
;;;1654           } else { // sortWhichDimension == 1
;;;1655             for(s32 y=0; y<arrHeight; y++) {
;;;1656               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1657               for(s32 x=0; x<arrWidth; x++) {
;;;1658                 pIndexes[x] = x;
;;;1659               }
;;;1660             }
;;;1661   
;;;1662             if(sortAscending) {
;;;1663               InsertionSort_sortAscendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1664             } else { // if(sortAscending)
;;;1665               InsertionSort_sortDescendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1666             } // if(sortAscending) ... else
;;;1667           } // if(sortWhichDimension == 0) ... else
;;;1668   
;;;1669           return RESULT_OK;
;;;1670         } // InsertionSort()
;;;1671   
;;;1672         template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1673         {
;;;1674           const s32 arrHeight = arr.get_size(0);
;;;1675           const s32 arrWidth = arr.get_size(1);
;;;1676   
;;;1677           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1678             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1679   
;;;1680           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1681             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1682   
;;;1683           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1684             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1685   
;;;1686           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1687           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1688   
;;;1689           if(sortWhichDimension == 0) {
;;;1690             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1691             if(sortAscending) {
;;;1692               for(s32 x=0; x<arrWidth; x++) {
;;;1693                 QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1694               }
;;;1695   
;;;1696               if(insertionSortSize > 1)
;;;1697                 InsertionSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1698             } else { // if(sortAscending)
;;;1699               for(s32 x=0; x<arrWidth; x++) {
;;;1700                 QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1701               }
;;;1702   
;;;1703               if(insertionSortSize > 1)
;;;1704                 InsertionSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1705             } // if(sortAscending) ... else
;;;1706           } else { // sortWhichDimension == 1
;;;1707             if(sortAscending) {
;;;1708               for(s32 y=0; y<arrHeight; y++) {
;;;1709                 QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1710               }
;;;1711   
;;;1712               if(insertionSortSize > 1)
;;;1713                 InsertionSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1714             } else { // if(sortAscending)
;;;1715               for(s32 y=0; y<arrHeight; y++) {
;;;1716                 QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1717               }
;;;1718   
;;;1719               if(insertionSortSize > 1)
;;;1720                 InsertionSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1721             } // if(sortAscending) ... else
;;;1722           } // if(sortWhichDimension == 0) ... else
;;;1723   
;;;1724           return RESULT_OK;
;;;1725         } // QuickSort()
;;;1726   
;;;1727         template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1728         {
;;;1729           const s32 arrHeight = arr.get_size(0);
;;;1730           const s32 arrWidth = arr.get_size(1);
;;;1731   
;;;1732           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1733             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1734   
;;;1735           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1736             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1737   
;;;1738           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1739             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1740   
;;;1741           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1742             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1743   
;;;1744           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1745           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1746   
;;;1747           if(sortWhichDimension == 0) {
;;;1748             for(s32 y=0; y<arrHeight; y++) {
;;;1749               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1750               for(s32 x=0; x<arrWidth; x++) {
;;;1751                 pIndexes[x] = y;
;;;1752               }
;;;1753             }
;;;1754   
;;;1755             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1756             if(sortAscending) {
;;;1757               for(s32 x=0; x<arrWidth; x++) {
;;;1758                 QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1759               }
;;;1760   
;;;1761               if(insertionSortSize > 1)
;;;1762                 InsertionSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1763             } else { // if(sortAscending)
;;;1764               for(s32 x=0; x<arrWidth; x++) {
;;;1765                 QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1766               }
;;;1767   
;;;1768               if(insertionSortSize > 1)
;;;1769                 InsertionSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1770             } // if(sortAscending) ... else
;;;1771           } else { // sortWhichDimension == 1
;;;1772             for(s32 y=0; y<arrHeight; y++) {
;;;1773               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1774               for(s32 x=0; x<arrWidth; x++) {
;;;1775                 pIndexes[x] = x;
;;;1776               }
;;;1777             }
;;;1778   
;;;1779             if(sortAscending) {
;;;1780               for(s32 y=0; y<arrHeight; y++) {
;;;1781                 QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1782               }
;;;1783   
;;;1784               if(insertionSortSize > 1)
;;;1785                 InsertionSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1786             } else { // if(sortAscending)
;;;1787               for(s32 y=0; y<arrHeight; y++) {
;;;1788                 QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1789               }
;;;1790   
;;;1791               if(insertionSortSize > 1)
;;;1792                 InsertionSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1793             } // if(sortAscending) ... else
;;;1794           } // if(sortWhichDimension == 0) ... else
;;;1795   
;;;1796           return RESULT_OK;
;;;1797         } // QuickSort()
;;;1798   
;;;1799         template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1800         {
;;;1801           AnkiConditionalErrorAndReturnValue(arr.get_size(0) == arr.get_size(1),
;;;1802             RESULT_FAIL_INVALID_SIZE, "MakeSymmetric", "Input array must be square");
;;;1803   
;;;1804           const s32 arrHeight = arr.get_size(0);
;;;1805           for(s32 y = 0; y < arrHeight; y++)
;;;1806           {
;;;1807             const s32 x0 = lowerToUpper ? (y+1)     : 0;
;;;1808             const s32 x1 = lowerToUpper ? arrHeight : y;
;;;1809   
;;;1810             for(s32 x = x0; x < x1; x++) {
;;;1811               *arr.Pointer(y,x) = *arr.Pointer(x,y);
;;;1812             }
;;;1813           }
;;;1814   
;;;1815           return RESULT_OK;
;;;1816         } // template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1817   
;;;1818         namespace Elementwise
;;;1819         {
;;;1820           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1821           {
;;;1822             const Array<InType> &in1Array = in1.get_array();
;;;1823             const Array<InType> &in2Array = in2.get_array();
;;;1824             Array<OutType> &out1Array = out.get_array();
;;;1825   
;;;1826             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, in2Array, out1Array),
;;;1827               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1828   
;;;1829             ArraySliceLimits_in2_out1<s32> limits(
;;;1830               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1831               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1832               out.get_ySlice(), out.get_xSlice());
;;;1833   
;;;1834             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1835               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1836   
;;;1837             if(limits.isSimpleIteration) {
;;;1838               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1839   
;;;1840               for(s32 y=0; y<limits.ySize; y++) {
;;;1841                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1842                 const InType * const pIn2 = in2Array.Pointer(limits.in2Y, 0);
;;;1843                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1844   
;;;1845                 limits.OuterIncrementTop();
;;;1846   
;;;1847                 for(s32 x=0; x<limits.xSize; x++) {
;;;1848                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], pIn2[limits.in2X]);
;;;1849   
;;;1850                   limits.in1X += limits.in1_xInnerIncrement;
;;;1851                   limits.in2X += limits.in2_xInnerIncrement;
;;;1852                   limits.out1X += limits.out1_xInnerIncrement;
;;;1853                 }
;;;1854   
;;;1855                 limits.OuterIncrementBottom();
;;;1856               }
;;;1857             } else { // if(limits.isSimpleIteration)
;;;1858               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1859   
;;;1860               for(s32 y=0; y<limits.ySize; y++) {
;;;1861                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1862   
;;;1863                 limits.OuterIncrementTop();
;;;1864   
;;;1865                 for(s32 x=0; x<limits.xSize; x++) {
;;;1866                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1867                   const InType valIn2 = *in2Array.Pointer(limits.in2Y, limits.in2X);
;;;1868   
;;;1869                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, valIn2);
;;;1870   
;;;1871                   limits.in1X += limits.in1_xInnerIncrement;
;;;1872                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1873                   limits.in2X += limits.in2_xInnerIncrement;
;;;1874                   limits.in2Y += limits.in2_yInnerIncrement;
;;;1875                   limits.out1X += limits.out1_xInnerIncrement;
;;;1876                 }
;;;1877   
;;;1878                 limits.OuterIncrementBottom();
;;;1879               }
;;;1880             } //   if(limits.isSimpleIteration)  ... else
;;;1881   
;;;1882             return RESULT_OK;
;;;1883           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1884   
;;;1885           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1886           {
;;;1887             const Array<InType> &in1Array = in1.get_array();
;;;1888             Array<OutType> &out1Array = out.get_array();
;;;1889   
;;;1890             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, out1Array),
;;;1891               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1892   
;;;1893             ArraySliceLimits_in1_out1<s32> limits(
;;;1894               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1895               out.get_ySlice(), out.get_xSlice());
;;;1896   
;;;1897             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1898               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1899   
;;;1900             if(limits.isSimpleIteration) {
;;;1901               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1902   
;;;1903               for(s32 y=0; y<limits.ySize; y++) {
;;;1904                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1905                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1906   
;;;1907                 limits.OuterIncrementTop();
;;;1908   
;;;1909                 for(s32 x=0; x<limits.xSize; x++) {
;;;1910                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], value2);
;;;1911   
;;;1912                   limits.in1X += limits.in1_xInnerIncrement;
;;;1913                   limits.out1X += limits.out1_xInnerIncrement;
;;;1914                 }
;;;1915   
;;;1916                 limits.OuterIncrementBottom();
;;;1917               }
;;;1918             } else { // if(limits.isSimpleIteration)
;;;1919               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1920   
;;;1921               for(s32 y=0; y<limits.ySize; y++) {
;;;1922                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1923   
;;;1924                 limits.OuterIncrementTop();
;;;1925   
;;;1926                 for(s32 x=0; x<limits.xSize; x++) {
;;;1927                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1928   
;;;1929                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, value2);
;;;1930   
;;;1931                   limits.in1X += limits.in1_xInnerIncrement;
;;;1932                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1933                   limits.out1X += limits.out1_xInnerIncrement;
;;;1934                 }
;;;1935   
;;;1936                 limits.OuterIncrementBottom();
;;;1937               }
;;;1938             } //   if(limits.isSimpleIteration)  ... else
;;;1939   
;;;1940             return RESULT_OK;
;;;1941           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1942   
;;;1943           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1944           {
;;;1945             const Array<InType> &in2Array = in2.get_array();
;;;1946             Array<OutType> &out1Array = out.get_array();
;;;1947   
;;;1948             AnkiConditionalErrorAndReturnValue(AreValid(in2Array, out1Array),
;;;1949               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1950   
;;;1951             ArraySliceLimits_in1_out1<s32> limits(
;;;1952               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1953               out.get_ySlice(), out.get_xSlice());
;;;1954   
;;;1955             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1956               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1957   
;;;1958             if(limits.isSimpleIteration) {
;;;1959               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1960   
;;;1961               for(s32 y=0; y<limits.ySize; y++) {
;;;1962                 const InType * const pIn2 = in2Array.Pointer(limits.in1Y, 0);
;;;1963                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1964   
;;;1965                 limits.OuterIncrementTop();
;;;1966   
;;;1967                 for(s32 x=0; x<limits.xSize; x++) {
;;;1968                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, pIn2[limits.in1X]);
;;;1969   
;;;1970                   limits.in1X += limits.in1_xInnerIncrement;
;;;1971                   limits.out1X += limits.out1_xInnerIncrement;
;;;1972                 }
;;;1973   
;;;1974                 limits.OuterIncrementBottom();
;;;1975               }
;;;1976             } else { // if(limits.isSimpleIteration)
;;;1977               // If either input is transposed, then we will do an inefficent loop iteration
;;;1978   
;;;1979               for(s32 y=0; y<limits.ySize; y++) {
;;;1980                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1981   
;;;1982                 limits.OuterIncrementTop();
;;;1983   
;;;1984                 for(s32 x=0; x<limits.xSize; x++) {
;;;1985                   const InType valIn2 = *in2Array.Pointer(limits.in1Y, limits.in1X);
;;;1986   
;;;1987                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, valIn2);
;;;1988   
;;;1989                   limits.in1X += limits.in1_xInnerIncrement;
;;;1990                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1991                   limits.out1X += limits.out1_xInnerIncrement;
;;;1992                 }
;;;1993   
;;;1994                 limits.OuterIncrementBottom();
;;;1995               }
;;;1996             } //   if(limits.isSimpleIteration)  ... else
;;;1997   
;;;1998             return RESULT_OK;
;;;1999           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;2000         } // namespace Elementwise
;;;2001       } // namespace Matrix
;;;2002     } // namespace Embedded
;;;2003   } // namespace Anki
;;;2004   
;;;2005   #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;19     
;;;20     #include "anki/common/shared/utilities_shared.h"
;;;1      /**
;;;2      File: utilities_shared.h
;;;3      Author: Kevin Yoon
;;;4      Created: 2014
;;;5      
;;;6      Copyright Anki, Inc. 2014
;;;7      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;8      **/
;;;9      
;;;10     #ifndef _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;11     #define _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;12     
;;;13     #include <stdarg.h>
;;;1      /* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
;;;14     
;;;15     namespace Anki
;;;16     {
;;;17       // For printing throughout Coretech libraries.
;;;18       // Calls printf() by default, but can be made to use an externally
;;;19       // defined function via SetCoreTechPrintFunctionPtr().
;;;20       int CoreTechPrint(const char * format, ...);
;;;21       int CoreTechPrint(const char * format, va_list argList);
;;;22     
;;;23       // Sets the function pointer that CoreTechPrint() uses.
;;;24       // Convenient for on-robot print which could be more complex
;;;25       // than just printf().
;;;26       void SetCoreTechPrintFunctionPtr( int (*fp)(const char * format, va_list) );
;;;27     } // namespace Anki
;;;28     
;;;29     #endif // _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26     #if 0
;;;27     #pragma mark --- 2D Point Implementations ---
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
;;;34         template<typename Type> Point<Type>::Point(const Type x, const Type y)
;;;35           : x(x), y(y)
;;;36         {
;;;37         }
;;;38     
;;;39         template<typename Type> Point<Type>::Point(const Point<Type>& pt)
;;;40           : x(pt.x), y(pt.y)
;;;41         {
;;;42         }
;;;43     
;;;44     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;45         template<typename Type> Point<Type>::Point(const cv::Point_<Type>& pt)
;;;46           : x(pt.x), y(pt.y)
;;;47         {
;;;48         }
;;;49     #endif
;;;50     
;;;51     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;52         template<typename Type> cv::Point_<Type> Point<Type>::get_CvPoint_() const
;;;53         {
;;;54           return cv::Point_<Type>(x,y);
;;;55         }
;;;56     #endif
;;;57     
;;;58         template<typename Type> template<typename InType> void Point<Type>::SetCast(const Point<InType> &in)
;;;59         {
;;;60           this->x = saturate_cast<Type>(in.x);
;;;61           this->y = saturate_cast<Type>(in.y);
;;;62         }
;;;63     
;;;64         template<typename Type> void Point<Type>::Print() const
;;;65         {
;;;66           CoreTechPrint("(%d,%d) ", this->x, this->y);
;;;67         }
;;;68     
;;;69         template<typename Type> bool Point<Type>::operator== (const Point<Type> &point2) const
;;;70         {
;;;71           if(this->x == point2.x && this->y == point2.y)
;;;72             return true;
;;;73     
;;;74           return false;
;;;75         }
;;;76     
;;;77         template<typename Type> Point<Type> Point<Type>::operator+ (const Point<Type> &point2) const
;;;78         {
;;;79           return Point<Type>(this->x+point2.x, this->y+point2.y);
;;;80         }
;;;81     
;;;82         template<typename Type> Point<Type> Point<Type>::operator- (const Point<Type> &point2) const
;;;83         {
;;;84           return Point<Type>(this->x-point2.x, this->y-point2.y);
;;;85         }
;;;86     
;;;87         template<typename Type> Point<Type> Point<Type>::operator- () const
;;;88         {
;;;89           return Point<Type>(-this->x, -this->y);
;;;90         }
;;;91     
;;;92         template<typename Type> Point<Type>& Point<Type>::operator*= (const Type value)
;;;93         {
;;;94           this->x *= value;
;;;95           this->y *= value;
;;;96           return *this;
;;;97         }
;;;98     
;;;99         template<typename Type> Point<Type>& Point<Type>::operator-= (const Type value)
;;;100        {
;;;101          this->x -= value;
;;;102          this->y -= value;
;;;103          return *this;
;;;104        }
;;;105    
;;;106        template<typename Type> Point<Type>& Point<Type>::operator+= (const Point<Type> &point2)
;;;107        {
;;;108          this->x += point2.x;
;;;109          this->y += point2.y;
;;;110          return *this;
;;;111        }
;;;112    
;;;113        template<typename Type> Point<Type>& Point<Type>::operator-= (const Point<Type> &point2)
;;;114        {
;;;115          this->x -= point2.x;
;;;116          this->y -= point2.y;
;;;117          return *this;
;;;118        }
;;;119    
;;;120        template<typename Type> inline Point<Type>& Point<Type>::operator= (const Point<Type> &point2)
;;;121        {
;;;122          this->x = point2.x;
;;;123          this->y = point2.y;
;;;124    
;;;125          return *this;
;;;126        }
;;;127    
;;;128        template<typename Type> f32 Point<Type>::Dist(const Point<Type> &point2) const
;;;129        {
;;;130          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) + (this->y - point2.y)*(this->y - point2.y));
;;;131        }
;;;132    
;;;133        template<typename Type> f32 Point<Type>::Length() const
;;;134        {
;;;135          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y)));
;;;136        }
;;;137    
;;;138        // #pragma mark --- Point Specializations ---
;;;139        template<> void Point<f32>::Print() const;
;;;140        template<> void Point<f64>::Print() const;
;;;141    
;;;142    #if 0
;;;143    #pragma mark --- 3D Point Implementations ---
;;;144    #endif
;;;145    
;;;146        template<typename Type> Point3<Type>::Point3()
;;;147          : x(static_cast<Type>(0)), y(static_cast<Type>(0)), z(static_cast<Type>(0))
;;;148        {
;;;149        }
;;;150    
;;;151        template<typename Type> Point3<Type>::Point3(const Type x, const Type y, const Type z)
;;;152          : x(x), y(y), z(z)
;;;153        {
;;;154        }
;;;155    
;;;156        template<typename Type> Point3<Type>::Point3(const Point3<Type>& pt)
;;;157          : x(pt.x), y(pt.y), z(pt.z)
;;;158        {
;;;159        }
;;;160    
;;;161    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;162        template<typename Type> Point3<Type>::Point3(const cv::Point3_<Type>& pt)
;;;163          : x(pt.x), y(pt.y), z(pt.z)
;;;164        {
;;;165        }
;;;166    #endif
;;;167    
;;;168    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;169        template<typename Type> cv::Point3_<Type> Point3<Type>::get_CvPoint_() const
;;;170        {
;;;171          return cv::Point3_<Type>(x,y,z);
;;;172        }
;;;173    #endif
;;;174    
;;;175        template<typename Type> void Point3<Type>::Print() const
;;;176        {
;;;177          CoreTechPrint("(%d,%d,%d) ", this->x, this->y, this->z);
;;;178        }
;;;179    
;;;180        template<typename Type> bool Point3<Type>::operator== (const Point3<Type> &point2) const
;;;181        {
;;;182          if(this->x == point2.x && this->y == point2.y && this->z == point2.z)
;;;183            return true;
;;;184    
;;;185          return false;
;;;186        }
;;;187    
;;;188        template<typename Type> Point3<Type> Point3<Type>::operator+ (const Point3<Type> &point2) const
;;;189        {
;;;190          return Point3<Type>(this->x+point2.x, this->y+point2.y, this->z+point2.z);
;;;191        }
;;;192    
;;;193        template<typename Type> Point3<Type> Point3<Type>::operator- (const Point3<Type> &point2) const
;;;194        {
;;;195          return Point3<Type>(this->x-point2.x, this->y-point2.y, this->z-point2.z);
;;;196        }
;;;197    
;;;198        template<typename Type> Point3<Type> Point3<Type>::operator- () const
;;;199        {
;;;200          return Point3<Type>(-this->x, -this->y, -this->z);
;;;201        }
;;;202    
;;;203        template<typename Type> Point3<Type>& Point3<Type>::operator*= (const Type value)
;;;204        {
;;;205          this->x *= value;
;;;206          this->y *= value;
;;;207          this->z *= value;
;;;208          return *this;
;;;209        }
;;;210    
;;;211        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Type value)
;;;212        {
;;;213          this->x -= value;
;;;214          this->y -= value;
;;;215          this->z -= value;
;;;216          return *this;
;;;217        }
;;;218    
;;;219        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Point3<Type> &point2)
;;;220        {
;;;221          this->x -= point2.x;
;;;222          this->y -= point2.y;
;;;223          this->z -= point2.z;
;;;224          return *this;
;;;225        }
;;;226    
;;;227        template<typename Type> inline Point3<Type>& Point3<Type>::operator= (const Point3<Type> &point2)
;;;228        {
;;;229          this->x = point2.x;
;;;230          this->y = point2.y;
;;;231          this->z = point2.z;
;;;232          return *this;
;;;233        }
;;;234    
;;;235        template<typename Type> f32 Point3<Type>::Dist(const Point3<Type> &point2) const
;;;236        {
;;;237          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) +
;;;238            (this->y - point2.y)*(this->y - point2.y) +
;;;239            (this->z - point2.z)*(this->z - point2.z));
;;;240        }
;;;241    
;;;242        template<typename Type> f32 Point3<Type>::Length() const
;;;243        {
;;;244          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y) + (this->z*this->z)));
;;;245        }
;;;246    
;;;247        template<typename Type> f32 Point3<Type>::MakeUnitLength()
;;;248        {
;;;249          const f32 L = this->Length();
;;;250          if(L != 0) {
;;;251            this->operator*=(1.f / L);
;;;252          }
;;;253          return L;
;;;254        }
;;;255    
;;;256        template<typename Type>
;;;257        Type DotProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;258        {
;;;259          return (point1.x*point2.x) + (point1.y*point2.y) + (point1.z*point2.z);
;;;260        }
;;;261    
;;;262        template<typename Type>
;;;263        Point3<Type> CrossProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;264        {
;;;265          return Point3<Type>(-point2.y*point1.z + point1.y*point2.z,
;;;266            point2.x*point1.z - point1.x*point2.z,
;;;267            -point2.x*point1.y + point1.x*point2.y);
;;;268        }
;;;269    
;;;270        template<typename Type>
;;;271        Point3<Type> operator* (const Array<Type>& M, const Point3<Type>& p)
;;;272        {
;;;273          // Matrix M must be 3x3
;;;274          AnkiAssert(AreEqualSize(3, 3, M));
;;;275    
;;;276          return Point3<Type>(M[0][0]*p.x + M[0][1]*p.y + M[0][2]*p.z,
;;;277            M[1][0]*p.x + M[1][1]*p.y + M[1][2]*p.z,
;;;278            M[2][0]*p.x + M[2][1]*p.y + M[2][2]*p.z);
;;;279        }
;;;280    
;;;281        // #pragma mark --- Point Specializations ---
;;;282        template<> void Point3<f32>::Print() const;
;;;283        template<> void Point3<f64>::Print() const;
;;;284    
;;;285    #if 0
;;;286    #pragma mark --- Pose Implementations ---
;;;287    #endif
;;;288    
;;;289        template<typename Type>
;;;290        Result ComputePoseDiff(const Array<Type>& R1, const Point3<Type>& T1,
;;;291          const Array<Type>& R2, const Point3<Type>& T2,
;;;292          Array<Type>& Rdiff, Point3<Type>& Tdiff,
;;;293          MemoryStack scratch)
;;;294        {
;;;295          // All the rotation matrices should be 3x3
;;;296          AnkiAssert(AreEqualSize(3, 3, R1));
;;;297          AnkiAssert(AreEqualSize(3, 3, R2));
;;;298          AnkiAssert(AreEqualSize(3, 3, Rdiff));
;;;299    
;;;300          Array<Type> invR1 = Array<Type>(3,3,scratch);
;;;301          Matrix::Transpose(R1, invR1);
;;;302    
;;;303          Matrix::Multiply(invR1, R2, Rdiff);
;;;304          Tdiff = invR1 * (T2 - T1);
;;;305    
;;;306          return RESULT_OK;
;;;307        }
;;;308    
;;;309    #if 0
;;;310    #pragma mark --- Rectangle Implementations ---
;;;311    #endif
;;;312    
;;;313        template<typename Type> Rectangle<Type>::Rectangle()
;;;314          : left(static_cast<Type>(0)), right(static_cast<Type>(0)), top(static_cast<Type>(0)), bottom(static_cast<Type>(0))
;;;315        {
;;;316        }
;;;317    
;;;318        template<typename Type> Rectangle<Type>::Rectangle(const Type left, const Type right, const Type top, const Type bottom)
;;;319          : left(left), right(right), top(top), bottom(bottom)
;;;320        {
;;;321        }
;;;322    
;;;323        template<typename Type> Rectangle<Type>::Rectangle(const Rectangle<Type>& rect)
;;;324          : left(rect.left), right(rect.right), top(rect.top), bottom(rect.bottom)
;;;325        {
;;;326        }
;;;327    
;;;328        template<typename Type> void Rectangle<Type>::Print() const
;;;329        {
;;;330          CoreTechPrint("(%d,%d)->(%d,%d) ", this->left, this->top, this->right, this->bottom);
;;;331        }
;;;332    
;;;333        template<typename Type> template<typename OutType> Point<OutType> Rectangle<Type>::ComputeCenter() const
;;;334        {
;;;335          Point<OutType> center(
;;;336            (static_cast<OutType>(this->left) + static_cast<OutType>(this->right)) / 2,
;;;337            (static_cast<OutType>(this->top) + static_cast<OutType>(this->bottom)) / 2);
;;;338    
;;;339          return center;
;;;340        }
;;;341    
;;;342        template<typename Type> template<typename OutType> Rectangle<OutType> Rectangle<Type>::ComputeScaledRectangle(const f32 scalePercent) const
;;;343        {
;;;344          const f32 width = static_cast<f32>(this->get_width());
;;;345          const f32 height = static_cast<f32>(this->get_height());
;;;346    
;;;347          const f32 scaledWidth = width * scalePercent;
;;;348          const f32 scaledHeight = height * scalePercent;
;;;349    
;;;350          const f32 dx2 = (scaledWidth - width) / 2.0f;
;;;351          const f32 dy2 = (scaledHeight - height) / 2.0f;
;;;352    
;;;353          Rectangle<OutType> scaledRect(
;;;354            static_cast<OutType>( static_cast<f32>(this->left)   - dx2 ),
;;;355            static_cast<OutType>( static_cast<f32>(this->right)  + dx2 ),
;;;356            static_cast<OutType>( static_cast<f32>(this->top)    - dy2 ),
;;;357            static_cast<OutType>( static_cast<f32>(this->bottom) + dy2 ));
;;;358    
;;;359          return scaledRect;
;;;360        }
;;;361    
                          ENDP


                          AREA ||area_number.333||, COMGROUP=_ZNK4Anki8Embedded9RectangleIiE22ComputeScaledRectangleIiEENS1_IT_EEf, LINKORDER=||t._ZNK4Anki8Embedded9RectangleIiE22ComputeScaledRectangleIiEENS1_IT_EEf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.333||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded9RectangleIiE22ComputeScaledRectangleIiEENS1_IT_EEf||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L339.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L339.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.340||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.340||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC2EiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::FixedLengthList__sub_object(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;75     
;;;76         template<typename Type> FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;77           : ArraySlice<Type>(Array<Type>(1, maximumSize, memory, flags), LinearSequence<s32>(0,0), LinearSequence<s32>(0,0))
;;;78         {
;;;79           if(this->array.get_numElements() == 0) {
;;;80             this->arrayData = NULL;
;;;81           } else {
;;;82             this->arrayData = this->array.Pointer(0,0);
;;;83           }
;;;84     
;;;85           if(flags.get_isFullyAllocated()) {
;;;86             this->set_size(maximumSize);
;;;87           } else {
;;;88             this->set_size(0);
;;;89           }
;;;90         } // FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;91     
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  b08d              SUB      sp,sp,#0x34
000006  4604              MOV      r4,r0
000008  9810              LDR      r0,[sp,#0x40]
00000a  4613              MOV      r3,r2
00000c  468b              MOV      r11,r1
00000e  460a              MOV      r2,r1
000010  9000              STR      r0,[sp,#0]
000012  2101              MOVS     r1,#1
000014  a801              ADD      r0,sp,#4
000016  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00001a  f8d08010          LDR      r8,[r0,#0x10]
00001e  e8b002e0          LDM      r0!,{r5-r7,r9}
000022  2200              MOVS     r2,#0
000024  4611              MOV      r1,r2
000026  a806              ADD      r0,sp,#0x18
000028  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00002c  4682              MOV      r10,r0
00002e  2200              MOVS     r2,#0
000030  4611              MOV      r1,r2
000032  a809              ADD      r0,sp,#0x24
000034  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000038  e9da1200          LDRD     r1,r2,[r10,#0]
00003c  f8da3008          LDR      r3,[r10,#8]
000040  60a3              STR      r3,[r4,#8]
000042  e9c41200          STRD     r1,r2,[r4,#0]
000046  e9d01200          LDRD     r1,r2,[r0,#0]
00004a  6880              LDR      r0,[r0,#8]
00004c  f8c48028          STR      r8,[r4,#0x28]
000050  60e1              STR      r1,[r4,#0xc]
000052  e9c42004          STRD     r2,r0,[r4,#0x10]
000056  f1040018          ADD      r0,r4,#0x18
00005a  2200              MOVS     r2,#0
00005c  e8a002e0          STM      r0!,{r5-r7,r9}
000060  2d00              CMP      r5,#0
000062  bfc8              IT       GT
000064  2e00              CMPGT    r6,#0
000066  dd25              BLE      |L346.180|
000068  fb05f006          MUL      r0,r5,r6
00006c  b310              CBZ      r0,|L346.180|
00006e  2000              MOVS     r0,#0
000070  fb008007          MLA      r0,r0,r7,r8
000074  62e0              STR      r0,[r4,#0x2c]
                  |L346.118|
000076  2d00              CMP      r5,#0
000078  bfc8              IT       GT
00007a  2e00              CMPGT    r6,#0
00007c  dd1c              BLE      |L346.184|
00007e  fb05f006          MUL      r0,r5,r6
000082  b1c8              CBZ      r0,|L346.184|
000084  2000              MOVS     r0,#0
000086  fb008007          MLA      r0,r0,r7,r8
00008a  6320              STR      r0,[r4,#0x30]
                  |L346.140|
00008c  2d00              CMP      r5,#0
00008e  bfc8              IT       GT
000090  2e00              CMPGT    r6,#0
000092  dd13              BLE      |L346.188|
000094  fb05f006          MUL      r0,r5,r6
000098  b180              CBZ      r0,|L346.188|
00009a  2000              MOVS     r0,#0
00009c  fb008007          MLA      r0,r0,r7,r8
0000a0  6320              STR      r0,[r4,#0x30]
                  |L346.162|
0000a2  a810              ADD      r0,sp,#0x40
0000a4  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0000a8  b150              CBZ      r0,|L346.192|
0000aa  4659              MOV      r1,r11
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::set_size(int)
0000b2  e009              B        |L346.200|
                  |L346.180|
0000b4  62e2              STR      r2,[r4,#0x2c]
0000b6  e7de              B        |L346.118|
                  |L346.184|
0000b8  6322              STR      r2,[r4,#0x30]
0000ba  e7e7              B        |L346.140|
                  |L346.188|
0000bc  6322              STR      r2,[r4,#0x30]
0000be  e7f0              B        |L346.162|
                  |L346.192|
0000c0  2100              MOVS     r1,#0
0000c2  4620              MOV      r0,r4
0000c4  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::set_size(int)
                  |L346.200|
0000c8  b011              ADD      sp,sp,#0x44
0000ca  4620              MOV      r0,r4
0000cc  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP


                          AREA ||area_number.347||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.347||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC2EiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList__sub_object(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;75     
;;;76         template<typename Type> FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;77           : ArraySlice<Type>(Array<Type>(1, maximumSize, memory, flags), LinearSequence<s32>(0,0), LinearSequence<s32>(0,0))
;;;78         {
;;;79           if(this->array.get_numElements() == 0) {
;;;80             this->arrayData = NULL;
;;;81           } else {
;;;82             this->arrayData = this->array.Pointer(0,0);
;;;83           }
;;;84     
;;;85           if(flags.get_isFullyAllocated()) {
;;;86             this->set_size(maximumSize);
;;;87           } else {
;;;88             this->set_size(0);
;;;89           }
;;;90         } // FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;91     
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  b08d              SUB      sp,sp,#0x34
000006  4604              MOV      r4,r0
000008  9810              LDR      r0,[sp,#0x40]
00000a  4613              MOV      r3,r2
00000c  468b              MOV      r11,r1
00000e  460a              MOV      r2,r1
000010  9000              STR      r0,[sp,#0]
000012  2101              MOVS     r1,#1
000014  a801              ADD      r0,sp,#4
000016  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00001a  f8d08010          LDR      r8,[r0,#0x10]
00001e  e8b002e0          LDM      r0!,{r5-r7,r9}
000022  2200              MOVS     r2,#0
000024  4611              MOV      r1,r2
000026  a806              ADD      r0,sp,#0x18
000028  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00002c  4682              MOV      r10,r0
00002e  2200              MOVS     r2,#0
000030  4611              MOV      r1,r2
000032  a809              ADD      r0,sp,#0x24
000034  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000038  e9da1200          LDRD     r1,r2,[r10,#0]
00003c  f8da3008          LDR      r3,[r10,#8]
000040  60a3              STR      r3,[r4,#8]
000042  e9c41200          STRD     r1,r2,[r4,#0]
000046  e9d01200          LDRD     r1,r2,[r0,#0]
00004a  6880              LDR      r0,[r0,#8]
00004c  f8c48028          STR      r8,[r4,#0x28]
000050  60e1              STR      r1,[r4,#0xc]
000052  e9c42004          STRD     r2,r0,[r4,#0x10]
000056  f1040018          ADD      r0,r4,#0x18
00005a  2200              MOVS     r2,#0
00005c  e8a002e0          STM      r0!,{r5-r7,r9}
000060  2d00              CMP      r5,#0
000062  bfc8              IT       GT
000064  2e00              CMPGT    r6,#0
000066  dd25              BLE      |L353.180|
000068  fb05f006          MUL      r0,r5,r6
00006c  b310              CBZ      r0,|L353.180|
00006e  2000              MOVS     r0,#0
000070  fb008007          MLA      r0,r0,r7,r8
000074  62e0              STR      r0,[r4,#0x2c]
                  |L353.118|
000076  2d00              CMP      r5,#0
000078  bfc8              IT       GT
00007a  2e00              CMPGT    r6,#0
00007c  dd1c              BLE      |L353.184|
00007e  fb05f006          MUL      r0,r5,r6
000082  b1c8              CBZ      r0,|L353.184|
000084  2000              MOVS     r0,#0
000086  fb008007          MLA      r0,r0,r7,r8
00008a  6320              STR      r0,[r4,#0x30]
                  |L353.140|
00008c  2d00              CMP      r5,#0
00008e  bfc8              IT       GT
000090  2e00              CMPGT    r6,#0
000092  dd13              BLE      |L353.188|
000094  fb05f006          MUL      r0,r5,r6
000098  b180              CBZ      r0,|L353.188|
00009a  2000              MOVS     r0,#0
00009c  fb008007          MLA      r0,r0,r7,r8
0000a0  6320              STR      r0,[r4,#0x30]
                  |L353.162|
0000a2  a810              ADD      r0,sp,#0x40
0000a4  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0000a8  b150              CBZ      r0,|L353.192|
0000aa  4659              MOV      r1,r11
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::set_size(int)
0000b2  e009              B        |L353.200|
                  |L353.180|
0000b4  62e2              STR      r2,[r4,#0x2c]
0000b6  e7de              B        |L353.118|
                  |L353.184|
0000b8  6322              STR      r2,[r4,#0x30]
0000ba  e7e7              B        |L353.140|
                  |L353.188|
0000bc  6322              STR      r2,[r4,#0x30]
0000be  e7f0              B        |L353.162|
                  |L353.192|
0000c0  2100              MOVS     r1,#0
0000c2  4620              MOV      r0,r4
0000c4  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::set_size(int)
                  |L353.200|
0000c8  b011              ADD      sp,sp,#0x44
0000ca  4620              MOV      r0,r4
0000cc  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP


                          AREA ||area_number.354||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.354||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE PROC ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
;;;241    
;;;242          template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;243          {
000004  b082              SUB      sp,sp,#8
000006  460e              MOV      r6,r1
;;;244            const s32 in1Height = in1.get_size(0);
000008  2100              MOVS     r1,#0
00000a  9802              LDR      r0,[sp,#8]
00000c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
;;;245            const s32 in1Width = in1.get_size(1);
000010  9000              STR      r0,[sp,#0]
000012  2101              MOVS     r1,#1
000014  9802              LDR      r0,[sp,#8]
000016  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001a  4680              MOV      r8,r0
;;;246    
;;;247            const s32 in2Height = in2.get_size(0);
00001c  2100              MOVS     r1,#0
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000024  4605              MOV      r5,r0
;;;248            const s32 in2Width = in2.get_size(1);
000026  2101              MOVS     r1,#1
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
;;;249            const s32 in2Stride = in2.get_stride();
;;;250    
;;;251            AnkiConditionalErrorAndReturnValue(in1Width == in2Height,
00002e  f8df9124          LDR      r9,|L360.340|
000032  68b4              LDR      r4,[r6,#8]
000034  4607              MOV      r7,r0                 ;248
000036  45a8              CMP      r8,r5
000038  d00d              BEQ      |L360.86|
00003a  20fb              MOVS     r0,#0xfb
00003c  e9cd9000          STRD     r9,r0,[sp,#0]
000040  a345              ADR      r3,|L360.344|
000042  a253              ADR      r2,|L360.400|
000044  a15c              ADR      r1,|L360.440|
000046  2005              MOVS     r0,#5
000048  f7fffffe          BL       _Anki_Log
;;;252              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;253    
;;;254            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2Width, out),
;;;255              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;256    
;;;257            for(s32 y1=0; y1<in1Height; y1++) {
;;;258              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;259              OutType * restrict pOut = out.Pointer(y1, 0);
;;;260    
;;;261              for(s32 x2=0; x2<in2Width; x2++) {
;;;262                const u8 * restrict pIn2 = reinterpret_cast<const u8*>(in2.Pointer(0, x2));
;;;263    
;;;264                OutType accumulator = 0;
;;;265    
;;;266                s32 y2;
;;;267                for(y2=0; y2<in2Height-3; y2+=4) {
;;;268                  const InType in1_0 = pIn1[y2];
;;;269                  const InType in1_1 = pIn1[y2+1];
;;;270                  const InType in1_2 = pIn1[y2+2];
;;;271                  const InType in1_3 = pIn1[y2+3];
;;;272    
;;;273                  const InType in2_0 = *reinterpret_cast<const InType*>(pIn2);
;;;274                  const InType in2_1 = *reinterpret_cast<const InType*>(pIn2 + in2Stride);
;;;275                  const InType in2_2 = *reinterpret_cast<const InType*>(pIn2 + 2*in2Stride);
;;;276                  const InType in2_3 = *reinterpret_cast<const InType*>(pIn2 + 3*in2Stride);
;;;277    
;;;278                  accumulator +=
;;;279                    in1_0 * in2_0 +
;;;280                    in1_1 * in2_1 +
;;;281                    in1_2 * in2_2 +
;;;282                    in1_3 * in2_3;
;;;283    
;;;284                  pIn2 += 4*in2Stride;
;;;285                }
;;;286    
;;;287                for(; y2<in2Height; y2++) {
;;;288                  accumulator += pIn1[y2] * (*reinterpret_cast<const InType*>(pIn2));
;;;289    
;;;290                  pIn2 += in2Stride;
;;;291                }
;;;292    
;;;293                pOut[x2] = accumulator;
;;;294              }
;;;295            }
;;;296    
;;;297            return RESULT_OK;
;;;298          } // template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
00004c  b005              ADD      sp,sp,#0x14
00004e  f04f60a0          MOV      r0,#0x5000000         ;251
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L360.86|
000056  4601              MOV      r1,r0                 ;254
000058  9a04              LDR      r2,[sp,#0x10]         ;254
00005a  9800              LDR      r0,[sp,#0]            ;254
00005c  f7fffffe          BL       _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_ ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<float>>(int, int, const T1&)
000060  2800              CMP      r0,#0                 ;254
000062  d068              BEQ      |L360.310|
000064  9800              LDR      r0,[sp,#0]            ;257
000066  f04f0900          MOV      r9,#0                 ;257
00006a  2800              CMP      r0,#0                 ;257
00006c  dd5f              BLE      |L360.302|
00006e  eddf4a55          VLDR     s9,|L360.452|
000072  f1a50803          SUB      r8,r5,#3              ;267
000076  eb040a44          ADD      r10,r4,r4,LSL #1      ;276
                  |L360.122|
00007a  9802              LDR      r0,[sp,#8]            ;276
00007c  2300              MOVS     r3,#0                 ;261
00007e  2f00              CMP      r7,#0                 ;261
000080  6901              LDR      r1,[r0,#0x10]         ;261
000082  6880              LDR      r0,[r0,#8]            ;261
000084  fb091c00          MLA      r12,r9,r0,r1          ;261
000088  9804              LDR      r0,[sp,#0x10]         ;261
00008a  6901              LDR      r1,[r0,#0x10]         ;261
00008c  6880              LDR      r0,[r0,#8]            ;261
00008e  fb091b00          MLA      r11,r9,r0,r1          ;261
000092  dd47              BLE      |L360.292|
                  |L360.148|
000094  68b2              LDR      r2,[r6,#8]            ;261
000096  6931              LDR      r1,[r6,#0x10]         ;261
000098  2000              MOVS     r0,#0                 ;262
00009a  fb001002          MLA      r0,r0,r2,r1           ;262
00009e  2100              MOVS     r1,#0                 ;267
0000a0  eb000083          ADD      r0,r0,r3,LSL #2       ;267
0000a4  eeb00a64          VMOV.F32 s0,s9                 ;264
0000a8  f1b80f00          CMP      r8,#0                 ;267
0000ac  dd25              BLE      |L360.250|
                  |L360.174|
0000ae  eb0c0281          ADD      r2,r12,r1,LSL #2      ;268
0000b2  edd03a00          VLDR     s7,[r0,#0]            ;273
0000b6  ed924a00          VLDR     s8,[r2,#0]            ;268
0000ba  ed923a01          VLDR     s6,[r2,#4]            ;269
0000be  edd22a02          VLDR     s5,[r2,#8]            ;270
0000c2  ed922a03          VLDR     s4,[r2,#0xc]          ;271
0000c6  1902              ADDS     r2,r0,r4              ;274
0000c8  ee643a23          VMUL.F32 s7,s8,s7              ;278
0000cc  edd21a00          VLDR     s3,[r2,#0]            ;274
0000d0  eb000244          ADD      r2,r0,r4,LSL #1       ;275
0000d4  1d09              ADDS     r1,r1,#4              ;267
0000d6  ee433a21          VMLA.F32 s7,s6,s3              ;278
0000da  ed921a00          VLDR     s2,[r2,#0]            ;275
0000de  eb0a0200          ADD      r2,r10,r0             ;276
0000e2  eb000084          ADD      r0,r0,r4,LSL #2       ;284
0000e6  edd20a00          VLDR     s1,[r2,#0]            ;276
0000ea  4588              CMP      r8,r1                 ;267
0000ec  ee423a81          VMLA.F32 s7,s5,s2              ;278
0000f0  ee423a20          VMLA.F32 s7,s4,s1              ;278
0000f4  ee330a80          VADD.F32 s0,s7,s0              ;278
0000f8  dcd9              BGT      |L360.174|
                  |L360.250|
0000fa  42a9              CMP      r1,r5                 ;287
0000fc  da0b              BGE      |L360.278|
                  |L360.254|
0000fe  eb0c0281          ADD      r2,r12,r1,LSL #2      ;288
000102  ed901a00          VLDR     s2,[r0,#0]            ;288
000106  edd20a00          VLDR     s1,[r2,#0]            ;288
00010a  1c49              ADDS     r1,r1,#1              ;287
00010c  4420              ADD      r0,r0,r4              ;290
00010e  ee000a81          VMLA.F32 s0,s1,s2              ;288
000112  42a9              CMP      r1,r5                 ;287
000114  dbf3              BLT      |L360.254|
                  |L360.278|
000116  eb0b0083          ADD      r0,r11,r3,LSL #2      ;293
00011a  1c5b              ADDS     r3,r3,#1              ;261
00011c  ed800a00          VSTR     s0,[r0,#0]            ;293
000120  42bb              CMP      r3,r7                 ;261
000122  dbb7              BLT      |L360.148|
                  |L360.292|
000124  9800              LDR      r0,[sp,#0]            ;257
000126  f1090901          ADD      r9,r9,#1              ;257
00012a  4581              CMP      r9,r0                 ;257
00012c  dba5              BLT      |L360.122|
                  |L360.302|
00012e  b005              ADD      sp,sp,#0x14
000130  2000              MOVS     r0,#0                 ;297
000132  e8bd8ff0          POP      {r4-r11,pc}
                  |L360.310|
000136  20fe              MOVS     r0,#0xfe              ;254
000138  e9cd9000          STRD     r9,r0,[sp,#0]         ;254
00013c  a306              ADR      r3,|L360.344|
00013e  a222              ADR      r2,|L360.456|
000140  a11d              ADR      r1,|L360.440|
000142  2005              MOVS     r0,#5                 ;254
000144  f7fffffe          BL       _Anki_Log
000148  b005              ADD      sp,sp,#0x14
00014a  f04f60a0          MOV      r0,#0x5000000         ;254
00014e  e8bd8ff0          POP      {r4-r11,pc}
;;;299    
                          ENDP

000152  0000              DCW      0x0000
                  |L360.340|
                          DCD      _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L360.344|
000158  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
00015c  6f726574
000160  6563685c
000164  636f6d6d
000168  6f6e5c69
00016c  6e636c75
000170  64655c61
000174  6e6b692f
000178  636f6d6d
00017c  6f6e2f72
000180  6f626f74
000184  2f6d6174
000188  726978  
00018b  2e6800            DCB      ".h",0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L360.400|
000190  496e7075          DCB      "Input matrices are incompatible sizes",0
000194  74206d61
000198  74726963
00019c  65732061
0001a0  72652069
0001a4  6e636f6d
0001a8  70617469
0001ac  626c6520
0001b0  73697a65
0001b4  7300    
0001b6  00                DCB      0
0001b7  00                DCB      0
                  |L360.440|
0001b8  4d756c74          DCB      "Multiply",0
0001bc  69706c79
0001c0  00      
0001c1  00                DCB      0
0001c2  00                DCB      0
0001c3  00                DCB      0
                  |L360.452|
0001c4  00000000          DCFS     0x00000000 ; 0
                  |L360.456|
0001c8  496e7075          DCB      "Input and Output matrices are incompatible sizes",0
0001cc  7420616e
0001d0  64204f75
0001d4  74707574
0001d8  206d6174
0001dc  72696365
0001e0  73206172
0001e4  6520696e
0001e8  636f6d70
0001ec  61746962
0001f0  6c652073
0001f4  697a6573
0001f8  00      
0001f9  00                DCB      0
0001fa  00                DCB      0
0001fb  00                DCB      0

                          AREA ||area_number.361||, COMGROUP=_ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.361||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb||, COMGROUP=_ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb PROC ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)
;;;352    
;;;353          template<typename Type> Result SolveLeastSquaresWithCholesky(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;354            Array<Type> &A_L,       //!< Input A Matrix and Output lower-triangular L matrix
;;;355            Array<Type> &Bt_Xt,     //!< Input B-transpose matrix and Output X-transpose solution
;;;356            bool realCholesky,      //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;357            bool &numericalFailure  //!< If true, the solver failed because of numerical instability
;;;358            )
;;;359          {
000004  460e              MOV      r6,r1
000006  ed2d8b02          VPUSH    {d8}
00000a  b083              SUB      sp,sp,#0xc
00000c  4699              MOV      r9,r3
00000e  4604              MOV      r4,r0
;;;360            const s32 matrixHeight = A_L.get_size(0);
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000016  4605              MOV      r5,r0
;;;361            const s32 numSamples = Bt_Xt.get_size(0);
000018  2100              MOVS     r1,#0
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000020  4607              MOV      r7,r0
;;;362    
;;;363            numericalFailure = false;
000022  2000              MOVS     r0,#0
000024  f8890000          STRB     r0,[r9,#0]
;;;364    
;;;365            AnkiConditionalErrorAndReturnValue(AreValid(A_L, Bt_Xt),
000028  4631              MOV      r1,r6
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       _ZN4Anki8Embedded8AreValidINS0_5ArrayIfEES3_EEbRKT_RKT0_ ; Anki::Embedded::AreValid<Anki::Embedded::Array<float>, Anki::Embedded::Array<float>>(const T1&, const T2&)
000030  f8df824c          LDR      r8,|L367.640|
000034  2800              CMP      r0,#0
000036  d017              BEQ      |L367.104|
;;;366              RESULT_FAIL_INVALID_OBJECT, "CholeskyDecomposition", "Invalid objects");
;;;367    
;;;368            AnkiConditionalErrorAndReturnValue(matrixHeight == A_L.get_size(1),
000038  2101              MOVS     r1,#1
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000040  42a8              CMP      r0,r5
000042  d01e              BEQ      |L367.130|
000044  f44f70b8          MOV      r0,#0x170
000048  e9cd8000          STRD     r8,r0,[sp,#0]
00004c  a38d              ADR      r3,|L367.644|
00004e  a29b              ADR      r2,|L367.700|
000050  a19f              ADR      r1,|L367.720|
000052  2005              MOVS     r0,#5
000054  f7fffffe          BL       _Anki_Log
000058  f04f60a0          MOV      r0,#0x5000000
                  |L367.92|
;;;369              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "A_L is not square");
;;;370    
;;;371            AnkiConditionalErrorAndReturnValue(Bt_Xt.get_size(1) == matrixHeight,
;;;372              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "Xt and Bt are the wrong sizes");
;;;373    
;;;374            // TODO: check if symmetric and positive-definite
;;;375    
;;;376            const Type minStableValue = Anki::Embedded::Flags::numeric_limits<Type>::epsilon();
;;;377    
;;;378            for(s32 i = 0; i < matrixHeight; i++) {
;;;379              // First, compute the non-diagonal values
;;;380              // This uses the results from the diagonal inverse computation from previous iterations of i
;;;381              Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;382    
;;;383              for(s32 j = 0; j < i; j++) {
;;;384                Type * restrict pAL_yj = A_L.Pointer(j, 0);
;;;385    
;;;386                Type sum = pAL_yi[j];
;;;387                for(s32 k = 0; k < j; k++) {
;;;388                  const Type value1 = pAL_yi[k];
;;;389                  const Type value2 = pAL_yj[k];
;;;390                  sum -= value1*value2;
;;;391                }
;;;392    
;;;393                pAL_yi[j] = sum*pAL_yj[j];
;;;394              } // for(s32 j = 0; j < i; j++)
;;;395    
;;;396              // Second, compute the inverse of the diagonal
;;;397              {
;;;398                Type sum = pAL_yi[i];
;;;399                for(s32 k = 0; k < i; k++) {
;;;400                  const Type value = pAL_yi[k];
;;;401                  sum -= value*value;
;;;402                }
;;;403    
;;;404                if(sum < minStableValue) {
;;;405                  numericalFailure = true;
;;;406                  return RESULT_OK;
;;;407                }
;;;408    
;;;409                // TODO: change this f32 square root to f64 if Type==f64
;;;410                const Type sumRoot = static_cast<Type>(sqrtf(static_cast<f32>(sum)));
;;;411                pAL_yi[i] = static_cast<Type>(1) / sumRoot;
;;;412              }
;;;413            } // for(s32 i = 0; i < m; i++)
;;;414    
;;;415            // Solve L*y = b via forward substitution
;;;416            for(s32 i = 0; i < matrixHeight; i++) {
;;;417              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;418              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;419    
;;;420              for(s32 j = 0; j < numSamples; j++) {
;;;421                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;422    
;;;423                Type sum = pBX_yj[i];
;;;424                for(s32 k = 0; k < i; k++) {
;;;425                  const Type value1 = pAL_yi[k];
;;;426                  const Type value2 = pBX_yj[k];
;;;427                  sum -= value1*value2;
;;;428                }
;;;429    
;;;430                pBX_yj[i] = sum*pAL_yi[i];
;;;431              }
;;;432            }
;;;433    
;;;434            // Solve L'*X = Y via back substitution
;;;435            for(s32 i = matrixHeight-1; i >= 0; i--) {
;;;436              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;437              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;438    
;;;439              for(s32 j = 0; j < numSamples; j++) {
;;;440                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;441    
;;;442                Type sum = pBX_yj[i];
;;;443                for(s32 k = matrixHeight-1; k > i; k-- ) {
;;;444                  const Type value1 = A_L[k][i];
;;;445                  const Type value2 = pBX_yj[k];
;;;446                  sum -= value1*value2;
;;;447                }
;;;448    
;;;449                pBX_yj[i] = sum*pAL_yi[i];
;;;450              }
;;;451            }
;;;452    
;;;453            if(realCholesky) {
;;;454              // Invert the diagonal values of L, and set upper triangular to zero
;;;455              for(s32 i = 0; i < matrixHeight; i++) {
;;;456                Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;457    
;;;458                pAL_yi[i] = static_cast<Type>(1) / pAL_yi[i];
;;;459    
;;;460                for(s32 j = i+1; j < matrixHeight; j++) {
;;;461                  pAL_yi[j] = 0;
;;;462                }
;;;463              }
;;;464            }
;;;465    
;;;466            return RESULT_OK;
;;;467          } // SolveLeastSquaresWithCholesky()
00005c  b003              ADD      sp,sp,#0xc
00005e  ecbd8b02          VPOP     {d8}
000062  b004              ADD      sp,sp,#0x10
000064  e8bd8ff0          POP      {r4-r11,pc}
                  |L367.104|
000068  f240106d          MOV      r0,#0x16d             ;365
00006c  e9cd8000          STRD     r8,r0,[sp,#0]         ;365
000070  a384              ADR      r3,|L367.644|
000072  a29d              ADR      r2,|L367.744|
000074  a196              ADR      r1,|L367.720|
000076  2005              MOVS     r0,#5                 ;365
000078  f7fffffe          BL       _Anki_Log
00007c  f04f6080          MOV      r0,#0x4000000         ;365
000080  e7ec              B        |L367.92|
                  |L367.130|
000082  2101              MOVS     r1,#1                 ;371
000084  4630              MOV      r0,r6                 ;371
000086  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00008a  42a8              CMP      r0,r5                 ;371
00008c  d00c              BEQ      |L367.168|
00008e  f2401073          MOV      r0,#0x173             ;371
000092  e9cd8000          STRD     r8,r0,[sp,#0]         ;371
000096  a37b              ADR      r3,|L367.644|
000098  a297              ADR      r2,|L367.760|
00009a  a18d              ADR      r1,|L367.720|
00009c  2005              MOVS     r0,#5                 ;371
00009e  f7fffffe          BL       _Anki_Log
0000a2  f04f60a0          MOV      r0,#0x5000000         ;371
0000a6  e7d9              B        |L367.92|
                  |L367.168|
0000a8  eddf8a9b          VLDR     s17,|L367.792|
0000ac  f04f0800          MOV      r8,#0                 ;378
0000b0  eeb78a00          VMOV.F32 s16,#1.00000000       ;411
0000b4  2d00              CMP      r5,#0                 ;378
0000b6  dd58              BLE      |L367.362|
                  |L367.184|
0000b8  68a1              LDR      r1,[r4,#8]            ;378
0000ba  6920              LDR      r0,[r4,#0x10]         ;378
0000bc  2200              MOVS     r2,#0                 ;383
0000be  fb080101          MLA      r1,r8,r1,r0           ;383
0000c2  f1b80f00          CMP      r8,#0                 ;383
0000c6  dd22              BLE      |L367.270|
                  |L367.200|
0000c8  68a3              LDR      r3,[r4,#8]            ;383
0000ca  6920              LDR      r0,[r4,#0x10]         ;383
0000cc  eb010c82          ADD      r12,r1,r2,LSL #2      ;386
0000d0  fb020303          MLA      r3,r2,r3,r0           ;386
0000d4  ed9c0a00          VLDR     s0,[r12,#0]           ;386
0000d8  2000              MOVS     r0,#0                 ;387
0000da  2a00              CMP      r2,#0                 ;387
0000dc  dd0c              BLE      |L367.248|
                  |L367.222|
0000de  eb010a80          ADD      r10,r1,r0,LSL #2      ;388
0000e2  ed9a1a00          VLDR     s2,[r10,#0]           ;388
0000e6  eb030a80          ADD      r10,r3,r0,LSL #2      ;389
0000ea  1c40              ADDS     r0,r0,#1              ;387
0000ec  edda0a00          VLDR     s1,[r10,#0]           ;389
0000f0  4282              CMP      r2,r0                 ;387
0000f2  ee010a60          VMLS.F32 s0,s2,s1              ;390
0000f6  dcf2              BGT      |L367.222|
                  |L367.248|
0000f8  eb030082          ADD      r0,r3,r2,LSL #2       ;393
0000fc  1c52              ADDS     r2,r2,#1              ;383
0000fe  edd00a00          VLDR     s1,[r0,#0]            ;393
000102  4542              CMP      r2,r8                 ;383
000104  ee200a80          VMUL.F32 s0,s1,s0              ;393
000108  ed8c0a00          VSTR     s0,[r12,#0]           ;393
00010c  dbdc              BLT      |L367.200|
                  |L367.270|
00010e  eb010a88          ADD      r10,r1,r8,LSL #2      ;398
000112  2000              MOVS     r0,#0                 ;399
000114  ed9a0a00          VLDR     s0,[r10,#0]           ;398
000118  f1b80f00          CMP      r8,#0                 ;399
00011c  dd08              BLE      |L367.304|
                  |L367.286|
00011e  eb010280          ADD      r2,r1,r0,LSL #2       ;400
000122  1c40              ADDS     r0,r0,#1              ;399
000124  edd20a00          VLDR     s1,[r2,#0]            ;400
000128  4580              CMP      r8,r0                 ;399
00012a  ee000ae0          VMLS.F32 s0,s1,s1              ;401
00012e  dcf6              BGT      |L367.286|
                  |L367.304|
000130  eef48ac0          VCMPE.F32 s17,s0                ;404
000134  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;404
000138  dd04              BLE      |L367.324|
00013a  2001              MOVS     r0,#1                 ;405
00013c  f8890000          STRB     r0,[r9,#0]            ;405
000140  2000              MOVS     r0,#0                 ;406
000142  e78b              B        |L367.92|
                  |L367.324|
000144  eef10ac0          VSQRT.F32 s1,s0                 ;410
000148  eef40a60          VCMP.F32 s1,s1                 ;410
00014c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;410
000150  d003              BEQ      |L367.346|
000152  f7fffffe          BL       __hardfp_sqrtf
000156  eef00a40          VMOV.F32 s1,s0                 ;410
                  |L367.346|
00015a  f1080801          ADD      r8,r8,#1              ;378
00015e  ee880a20          VDIV.F32 s0,s16,s1             ;411
000162  45a8              CMP      r8,r5                 ;378
000164  ed8a0a00          VSTR     s0,[r10,#0]           ;411
000168  dba6              BLT      |L367.184|
                  |L367.362|
00016a  2100              MOVS     r1,#0                 ;416
00016c  2d00              CMP      r5,#0                 ;416
00016e  dd2d              BLE      |L367.460|
                  |L367.368|
000170  68a2              LDR      r2,[r4,#8]            ;416
000172  6920              LDR      r0,[r4,#0x10]         ;416
000174  fb010c02          MLA      r12,r1,r2,r0          ;416
000178  2200              MOVS     r2,#0                 ;420
00017a  2f00              CMP      r7,#0                 ;420
00017c  bfc8              IT       GT                    ;430
00017e  eb0c0981          ADDGT    r9,r12,r1,LSL #2      ;430
000182  dd20              BLE      |L367.454|
                  |L367.388|
000184  68b3              LDR      r3,[r6,#8]            ;420
000186  6930              LDR      r0,[r6,#0x10]         ;420
000188  fb020303          MLA      r3,r2,r3,r0           ;420
00018c  eb030881          ADD      r8,r3,r1,LSL #2       ;423
000190  2000              MOVS     r0,#0                 ;424
000192  ed980a00          VLDR     s0,[r8,#0]            ;423
000196  2900              CMP      r1,#0                 ;424
000198  dd0c              BLE      |L367.436|
                  |L367.410|
00019a  eb0c0a80          ADD      r10,r12,r0,LSL #2     ;425
00019e  ed9a1a00          VLDR     s2,[r10,#0]           ;425
0001a2  eb030a80          ADD      r10,r3,r0,LSL #2      ;426
0001a6  1c40              ADDS     r0,r0,#1              ;424
0001a8  edda0a00          VLDR     s1,[r10,#0]           ;426
0001ac  4281              CMP      r1,r0                 ;424
0001ae  ee010a60          VMLS.F32 s0,s2,s1              ;427
0001b2  dcf2              BGT      |L367.410|
                  |L367.436|
0001b4  edd90a00          VLDR     s1,[r9,#0]            ;430
0001b8  1c52              ADDS     r2,r2,#1              ;420
0001ba  42ba              CMP      r2,r7                 ;420
0001bc  ee200a80          VMUL.F32 s0,s1,s0              ;430
0001c0  ed880a00          VSTR     s0,[r8,#0]            ;430
0001c4  dbde              BLT      |L367.388|
                  |L367.454|
0001c6  1c49              ADDS     r1,r1,#1              ;416
0001c8  42a9              CMP      r1,r5                 ;416
0001ca  dbd1              BLT      |L367.368|
                  |L367.460|
0001cc  1e69              SUBS     r1,r5,#1              ;435
0001ce  d433              BMI      |L367.568|
                  |L367.464|
0001d0  68a2              LDR      r2,[r4,#8]            ;435
0001d2  6920              LDR      r0,[r4,#0x10]         ;435
0001d4  fb010002          MLA      r0,r1,r2,r0           ;435
0001d8  2200              MOVS     r2,#0                 ;439
0001da  2f00              CMP      r7,#0                 ;439
0001dc  bfc8              IT       GT                    ;449
0001de  eb000a81          ADDGT    r10,r0,r1,LSL #2      ;449
0001e2  dd27              BLE      |L367.564|
                  |L367.484|
0001e4  68b3              LDR      r3,[r6,#8]            ;439
0001e6  6930              LDR      r0,[r6,#0x10]         ;439
0001e8  fb020303          MLA      r3,r2,r3,r0           ;439
0001ec  eb030981          ADD      r9,r3,r1,LSL #2       ;442
0001f0  1e68              SUBS     r0,r5,#1              ;443
0001f2  ed990a00          VLDR     s0,[r9,#0]            ;442
0001f6  4288              CMP      r0,r1                 ;443
0001f8  bfc4              ITT      GT                    ;443
0001fa  f8d4c008          LDRGT    r12,[r4,#8]           ;443
0001fe  f8d48010          LDRGT    r8,[r4,#0x10]         ;443
000202  dd0e              BLE      |L367.546|
                  |L367.516|
000204  fb008b0c          MLA      r11,r0,r12,r8         ;443
000208  eb0b0b81          ADD      r11,r11,r1,LSL #2     ;444
00020c  ed9b1a00          VLDR     s2,[r11,#0]           ;444
000210  eb030b80          ADD      r11,r3,r0,LSL #2      ;445
000214  1e40              SUBS     r0,r0,#1              ;443
000216  eddb0a00          VLDR     s1,[r11,#0]           ;445
00021a  4288              CMP      r0,r1                 ;443
00021c  ee010a60          VMLS.F32 s0,s2,s1              ;446
000220  dcf0              BGT      |L367.516|
                  |L367.546|
000222  edda0a00          VLDR     s1,[r10,#0]           ;449
000226  1c52              ADDS     r2,r2,#1              ;439
000228  4297              CMP      r7,r2                 ;439
00022a  ee200a80          VMUL.F32 s0,s1,s0              ;449
00022e  ed890a00          VSTR     s0,[r9,#0]            ;449
000232  dcd7              BGT      |L367.484|
                  |L367.564|
000234  1e49              SUBS     r1,r1,#1              ;435
000236  d5cb              BPL      |L367.464|
                  |L367.568|
000238  9807              LDR      r0,[sp,#0x1c]         ;453
00023a  2800              CMP      r0,#0                 ;453
00023c  bf1c              ITT      NE                    ;455
00023e  2100              MOVNE    r1,#0                 ;455
000240  2d00              CMPNE    r5,#0                 ;455
000242  bfc8              IT       GT                    ;461
000244  ed9f0a35          VLDRGT   s0,|L367.796|
000248  dd18              BLE      |L367.636|
                  |L367.586|
00024a  68a2              LDR      r2,[r4,#8]            ;453
00024c  6920              LDR      r0,[r4,#0x10]         ;453
00024e  fb010202          MLA      r2,r1,r2,r0           ;453
000252  eb020081          ADD      r0,r2,r1,LSL #2       ;458
000256  edd00a00          VLDR     s1,[r0,#0]            ;458
00025a  ee881a20          VDIV.F32 s2,s16,s1             ;458
00025e  ed801a00          VSTR     s2,[r0,#0]            ;458
000262  1c48              ADDS     r0,r1,#1              ;460
000264  4285              CMP      r5,r0                 ;460
000266  dd06              BLE      |L367.630|
                  |L367.616|
000268  eb020380          ADD      r3,r2,r0,LSL #2       ;461
00026c  1c40              ADDS     r0,r0,#1              ;460
00026e  ed830a00          VSTR     s0,[r3,#0]            ;461
000272  4285              CMP      r5,r0                 ;460
000274  dcf8              BGT      |L367.616|
                  |L367.630|
000276  1c49              ADDS     r1,r1,#1              ;455
000278  42a9              CMP      r1,r5                 ;455
00027a  dbe6              BLT      |L367.586|
                  |L367.636|
00027c  2000              MOVS     r0,#0                 ;466
00027e  e6ed              B        |L367.92|
;;;468    
                          ENDP

                  |L367.640|
                          DCD      _ZZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)::__PRETTY_FUNCTION__
                  |L367.644|
000284  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000288  6f726574
00028c  6563685c
000290  636f6d6d
000294  6f6e5c69
000298  6e636c75
00029c  64655c61
0002a0  6e6b692f
0002a4  636f6d6d
0002a8  6f6e2f72
0002ac  6f626f74
0002b0  2f6d6174
0002b4  726978  
0002b7  2e6800            DCB      ".h",0
0002ba  00                DCB      0
0002bb  00                DCB      0
                  |L367.700|
0002bc  415f4c20          DCB      "A_L is not square",0
0002c0  6973206e
0002c4  6f742073
0002c8  71756172
0002cc  6500    
0002ce  00                DCB      0
0002cf  00                DCB      0
                  |L367.720|
0002d0  43686f6c          DCB      "CholeskyDecomposition",0
0002d4  65736b79
0002d8  4465636f
0002dc  6d706f73
0002e0  6974696f
0002e4  6e00    
0002e6  00                DCB      0
0002e7  00                DCB      0
                  |L367.744|
0002e8  496e7661          DCB      "Invalid objects",0
0002ec  6c696420
0002f0  6f626a65
0002f4  63747300
                  |L367.760|
0002f8  58742061          DCB      "Xt and Bt are the wrong sizes",0
0002fc  6e642042
000300  74206172
000304  65207468
000308  65207772
00030c  6f6e6720
000310  73697a65
000314  7300    
000316  00                DCB      0
000317  00                DCB      0
                  |L367.792|
000318  34000000          DCFS     0x34000000 ; 1.1920928955078125e-07
                  |L367.796|
00031c  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.368||, COMGROUP=_ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb, LINKORDER=||t._ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.368||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE PROC ; Anki::Embedded::Matrix::Transpose<float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
;;;693    
;;;694          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;695          {
000004  460c              MOV      r4,r1
000006  b083              SUB      sp,sp,#0xc
000008  4607              MOV      r7,r0
;;;696            const s32 inHeight = in.get_size(0);
00000a  2100              MOVS     r1,#0
00000c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000010  4680              MOV      r8,r0
;;;697            const s32 inWidth = in.get_size(1);
000012  2101              MOVS     r1,#1
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001a  4606              MOV      r6,r0
;;;698    
;;;699            const s32 outStride = out.get_stride();
;;;700    
;;;701            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
00001c  4621              MOV      r1,r4
00001e  4638              MOV      r0,r7
000020  68a5              LDR      r5,[r4,#8]
000022  f7fffffe          BL       _ZN4Anki8Embedded8AreValidINS0_5ArrayIfEES3_EEbRKT_RKT0_ ; Anki::Embedded::AreValid<Anki::Embedded::Array<float>, Anki::Embedded::Array<float>>(const T1&, const T2&)
000026  f8df913c          LDR      r9,|L374.356|
00002a  2800              CMP      r0,#0
00002c  d06c              BEQ      |L374.264|
;;;702              RESULT_FAIL_INVALID_OBJECT, "Transpose", "Invalid objects");
;;;703    
;;;704            AnkiConditionalErrorAndReturnValue(AreEqualSize(in.get_size(1), in.get_size(0), out),
00002e  2100              MOVS     r1,#0
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000036  4682              MOV      r10,r0
000038  2101              MOVS     r1,#1
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000040  4622              MOV      r2,r4
000042  4651              MOV      r1,r10
000044  f7fffffe          BL       _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_ ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<float>>(int, int, const T1&)
000048  2800              CMP      r0,#0
00004a  d06c              BEQ      |L374.294|
00004c  4621              MOV      r1,r4
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       _ZN4Anki8Embedded8AreValidINS0_5ArrayIfEES3_EEbRKT_RKT0_ ; Anki::Embedded::AreValid<Anki::Embedded::Array<float>, Anki::Embedded::Array<float>>(const T1&, const T2&)
000054  2800              CMP      r0,#0
000056  d076              BEQ      |L374.326|
000058  6938              LDR      r0,[r7,#0x10]
00005a  9000              STR      r0,[sp,#0]
00005c  6920              LDR      r0,[r4,#0x10]
00005e  2100              MOVS     r1,#0
000060  466a              MOV      r2,sp
000062  9001              STR      r0,[sp,#4]
                  |L374.100|
000064  1c48              ADDS     r0,r1,#1
000066  2802              CMP      r0,#2
000068  bfb8              IT       LT
00006a  f8523021          LDRLT    r3,[r2,r1,LSL #2]
00006e  da06              BGE      |L374.126|
                  |L374.112|
000070  f852c020          LDR      r12,[r2,r0,LSL #2]
000074  4563              CMP      r3,r12
000076  d066              BEQ      |L374.326|
000078  1c40              ADDS     r0,r0,#1
00007a  2802              CMP      r0,#2
00007c  dbf8              BLT      |L374.112|
                  |L374.126|
00007e  1c49              ADDS     r1,r1,#1
000080  2902              CMP      r1,#2
000082  dbef              BLT      |L374.100|
;;;705              RESULT_FAIL_INVALID_SIZE, "Transpose", "out is not the correct size");
;;;706    
;;;707            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;708              RESULT_FAIL_ALIASED_MEMORY, "Transpose", "in and out cannot be the same array");
;;;709    
;;;710            for(s32 yIn=0; yIn<inHeight; yIn++) {
000084  2200              MOVS     r2,#0
000086  f1b80f00          CMP      r8,#0
;;;711              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;712              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0,yIn));
;;;713    
;;;714              s32 xIn;
;;;715              s32 outOffset0 = 0;
;;;716    
;;;717              for(xIn=0; xIn<inWidth-1; xIn+=2) {
00008a  bfc8              IT       GT
00008c  f1a60a01          SUBGT    r10,r6,#1
000090  dd36              BLE      |L374.256|
                  |L374.146|
000092  68b9              LDR      r1,[r7,#8]            ;710
000094  6938              LDR      r0,[r7,#0x10]         ;710
000096  68a3              LDR      r3,[r4,#8]            ;710
000098  fb020c01          MLA      r12,r2,r1,r0          ;710
00009c  6921              LDR      r1,[r4,#0x10]         ;710
00009e  2000              MOVS     r0,#0                 ;712
0000a0  fb001003          MLA      r0,r0,r3,r1           ;712
0000a4  2100              MOVS     r1,#0                 ;715
0000a6  eb000982          ADD      r9,r0,r2,LSL #2       ;715
0000aa  4608              MOV      r0,r1
0000ac  f1ba0f00          CMP      r10,#0
0000b0  dd12              BLE      |L374.216|
                  |L374.178|
;;;718                const InType in0 = pIn[xIn];
0000b2  eb0c0380          ADD      r3,r12,r0,LSL #2
;;;719                const InType in1 = pIn[xIn+1];
;;;720    
;;;721                const s32 outOffset1 = outOffset0 + outStride;
;;;722    
;;;723                *reinterpret_cast<OutType*>(pOut + outOffset0) = static_cast<OutType>(in0);
0000b6  eb090b01          ADD      r11,r9,r1
0000ba  ed930a00          VLDR     s0,[r3,#0]            ;718
0000be  edd30a01          VLDR     s1,[r3,#4]            ;719
0000c2  194b              ADDS     r3,r1,r5              ;721
;;;724                *reinterpret_cast<OutType*>(pOut + outOffset1) = static_cast<OutType>(in1);
0000c4  444b              ADD      r3,r3,r9
0000c6  ed8b0a00          VSTR     s0,[r11,#0]           ;723
0000ca  1c80              ADDS     r0,r0,#2              ;717
0000cc  edc30a00          VSTR     s1,[r3,#0]
;;;725    
;;;726                outOffset0 += 2*outStride;
0000d0  eb010145          ADD      r1,r1,r5,LSL #1
0000d4  4582              CMP      r10,r0                ;717
0000d6  dcec              BGT      |L374.178|
                  |L374.216|
;;;727              }
;;;728    
;;;729              for(; xIn<inWidth; xIn++) {
0000d8  42b0              CMP      r0,r6
0000da  da0e              BGE      |L374.250|
                  |L374.220|
0000dc  68a3              LDR      r3,[r4,#8]
0000de  6921              LDR      r1,[r4,#0x10]
0000e0  fb001103          MLA      r1,r0,r3,r1
;;;730                *out.Pointer(xIn,yIn) = static_cast<OutType>(pIn[xIn]);
0000e4  eb0c0380          ADD      r3,r12,r0,LSL #2
0000e8  eb010182          ADD      r1,r1,r2,LSL #2
0000ec  ed930a00          VLDR     s0,[r3,#0]
0000f0  1c40              ADDS     r0,r0,#1              ;729
0000f2  ed810a00          VSTR     s0,[r1,#0]
0000f6  42b0              CMP      r0,r6                 ;729
0000f8  dbf0              BLT      |L374.220|
                  |L374.250|
0000fa  1c52              ADDS     r2,r2,#1              ;710
0000fc  4542              CMP      r2,r8                 ;710
0000fe  dbc8              BLT      |L374.146|
                  |L374.256|
;;;731              }
;;;732            }
;;;733    
;;;734            return RESULT_OK;
;;;735          } // Transpose()
000100  b003              ADD      sp,sp,#0xc
000102  2000              MOVS     r0,#0                 ;734
000104  e8bd8ff0          POP      {r4-r11,pc}
                  |L374.264|
000108  f24020bd          MOV      r0,#0x2bd             ;701
00010c  e9cd9000          STRD     r9,r0,[sp,#0]         ;701
000110  a315              ADR      r3,|L374.360|
000112  a223              ADR      r2,|L374.416|
000114  a126              ADR      r1,|L374.432|
000116  2005              MOVS     r0,#5                 ;701
000118  f7fffffe          BL       _Anki_Log
00011c  b003              ADD      sp,sp,#0xc
00011e  f04f6080          MOV      r0,#0x4000000         ;701
000122  e8bd8ff0          POP      {r4-r11,pc}
                  |L374.294|
000126  f44f7030          MOV      r0,#0x2c0             ;704
00012a  e9cd9000          STRD     r9,r0,[sp,#0]         ;704
00012e  a30e              ADR      r3,|L374.360|
000130  a222              ADR      r2,|L374.444|
000132  a11f              ADR      r1,|L374.432|
000134  2005              MOVS     r0,#5                 ;704
000136  f7fffffe          BL       _Anki_Log
00013a  b003              ADD      sp,sp,#0xc
00013c  f04f60a0          MOV      r0,#0x5000000         ;704
000140  e8bd8ff0          POP      {r4-r11,pc}
000144  e7ff              B        |L374.326|
                  |L374.326|
000146  f24020c3          MOV      r0,#0x2c3             ;707
00014a  e9cd9000          STRD     r9,r0,[sp,#0]         ;707
00014e  a306              ADR      r3,|L374.360|
000150  a221              ADR      r2,|L374.472|
000152  a117              ADR      r1,|L374.432|
000154  2005              MOVS     r0,#5                 ;707
000156  f7fffffe          BL       _Anki_Log
00015a  b003              ADD      sp,sp,#0xc
00015c  4827              LDR      r0,|L374.508|
00015e  e8bd8ff0          POP      {r4-r11,pc}
;;;736    
                          ENDP

000162  0000              DCW      0x0000
                  |L374.356|
                          DCD      _ZZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Transpose<float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L374.360|
000168  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
00016c  6f726574
000170  6563685c
000174  636f6d6d
000178  6f6e5c69
00017c  6e636c75
000180  64655c61
000184  6e6b692f
000188  636f6d6d
00018c  6f6e2f72
000190  6f626f74
000194  2f6d6174
000198  726978  
00019b  2e6800            DCB      ".h",0
00019e  00                DCB      0
00019f  00                DCB      0
                  |L374.416|
0001a0  496e7661          DCB      "Invalid objects",0
0001a4  6c696420
0001a8  6f626a65
0001ac  63747300
                  |L374.432|
0001b0  5472616e          DCB      "Transpose",0
0001b4  73706f73
0001b8  6500    
0001ba  00                DCB      0
0001bb  00                DCB      0
                  |L374.444|
0001bc  6f757420          DCB      "out is not the correct size",0
0001c0  6973206e
0001c4  6f742074
0001c8  68652063
0001cc  6f727265
0001d0  63742073
0001d4  697a6500
                  |L374.472|
0001d8  696e2061          DCB      "in and out cannot be the same array",0
0001dc  6e64206f
0001e0  75742063
0001e4  616e6e6f
0001e8  74206265
0001ec  20746865
0001f0  2073616d
0001f4  65206172
0001f8  72617900
                  |L374.508|
                          DCD      0x01000003

                          AREA ||area_number.375||, COMGROUP=_ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.375||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE PROC ; Anki::Embedded::Matrix::MultiplyTranspose<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
                  |symbol_number.450|
;;;299    
;;;300          template<typename InType, typename OutType> NO_INLINE Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;301          {
000004  460d              MOV      r5,r1
000006  b083              SUB      sp,sp,#0xc
000008  4616              MOV      r6,r2
00000a  4680              MOV      r8,r0
;;;302            const s32 in1Height = in1.get_size(0);
00000c  2100              MOVS     r1,#0
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000012  4681              MOV      r9,r0
;;;303            const s32 in1Width = in1.get_size(1);
000014  2101              MOVS     r1,#1
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001c  4682              MOV      r10,r0
;;;304    
;;;305            const s32 in2TransposedHeight = in2Transposed.get_size(0);
00001e  2100              MOVS     r1,#0
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000026  4607              MOV      r7,r0
;;;306            const s32 in2TransposedWidth = in2Transposed.get_size(1);
000028  2101              MOVS     r1,#1
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000030  4604              MOV      r4,r0
;;;307    
;;;308            AnkiConditionalErrorAndReturnValue(in1Width == in2TransposedWidth,
000032  f8dfb110          LDR      r11,|L381.324|
000036  45a2              CMP      r10,r4
000038  d00e              BEQ      |L381.88|
00003a  f44f709a          MOV      r0,#0x134
00003e  e9cdb000          STRD     r11,r0,[sp,#0]
000042  a341              ADR      r3,|L381.328|
000044  a24e              ADR      r2,|L381.384|
000046  a158              ADR      r1,|L381.424|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
;;;309              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;310    
;;;311            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2TransposedHeight, out),
;;;312              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;313    
;;;314            for(s32 y1=0; y1<in1Height; y1++)
;;;315            {
;;;316              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;317    
;;;318              for(s32 y2=0; y2<in2TransposedHeight; y2++) {
;;;319                const InType * restrict pIn2 = in2Transposed.Pointer(y2, 0);
;;;320    
;;;321                OutType accumulator = 0;
;;;322    
;;;323                s32 x;
;;;324                for(x=0; x<in2TransposedWidth-3; x+=4) {
;;;325                  const InType in1_0 = pIn1[x];
;;;326                  const InType in1_1 = pIn1[x+1];
;;;327                  const InType in1_2 = pIn1[x+2];
;;;328                  const InType in1_3 = pIn1[x+3];
;;;329    
;;;330                  const InType in2_0 = pIn2[x];
;;;331                  const InType in2_1 = pIn2[x+1];
;;;332                  const InType in2_2 = pIn2[x+2];
;;;333                  const InType in2_3 = pIn2[x+3];
;;;334    
;;;335                  accumulator +=
;;;336                    in1_0 * in2_0 +
;;;337                    in1_1 * in2_1 +
;;;338                    in1_2 * in2_2 +
;;;339                    in1_3 * in2_3;
;;;340                }
;;;341    
;;;342                for(; x<in2TransposedWidth; x++) {
;;;343                  accumulator += pIn1[x] * pIn2[x];
;;;344                }
;;;345    
;;;346                *out.Pointer(y1, y2) = accumulator;
;;;347              }
;;;348            }
;;;349    
;;;350            return RESULT_OK;
;;;351          } // template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
00004e  b003              ADD      sp,sp,#0xc
000050  f04f60a0          MOV      r0,#0x5000000         ;308
000054  e8bd8ff0          POP      {r4-r11,pc}
                  |L381.88|
000058  4632              MOV      r2,r6                 ;311
00005a  4639              MOV      r1,r7                 ;311
00005c  4648              MOV      r0,r9                 ;311
00005e  f7fffffe          BL       _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_ ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<float>>(int, int, const T1&)
000062  2800              CMP      r0,#0                 ;311
000064  d05f              BEQ      |L381.294|
000066  f04f0a00          MOV      r10,#0                ;314
00006a  f1b90f00          CMP      r9,#0                 ;314
00006e  bfc4              ITT      GT                    ;321
000070  eddf4a50          VLDRGT   s9,|L381.436|
000074  f1a40b03          SUBGT    r11,r4,#3             ;324
000078  dd51              BLE      |L381.286|
                  |L381.122|
00007a  f8d81008          LDR      r1,[r8,#8]            ;314
00007e  f8d80010          LDR      r0,[r8,#0x10]         ;314
000082  2200              MOVS     r2,#0                 ;318
000084  fb0a0c01          MLA      r12,r10,r1,r0         ;318
000088  2f00              CMP      r7,#0                 ;318
00008a  dd44              BLE      |L381.278|
                  |L381.140|
00008c  68a9              LDR      r1,[r5,#8]            ;318
00008e  6928              LDR      r0,[r5,#0x10]         ;318
000090  eeb00a64          VMOV.F32 s0,s9                 ;321
000094  fb020301          MLA      r3,r2,r1,r0           ;321
000098  2000              MOVS     r0,#0                 ;324
00009a  f1bb0f00          CMP      r11,#0                ;324
00009e  dd20              BLE      |L381.226|
                  |L381.160|
0000a0  eb0c0180          ADD      r1,r12,r0,LSL #2      ;325
0000a4  ed914a00          VLDR     s8,[r1,#0]            ;325
0000a8  ed912a01          VLDR     s4,[r1,#4]            ;326
0000ac  edd13a02          VLDR     s7,[r1,#8]            ;327
0000b0  ed913a03          VLDR     s6,[r1,#0xc]          ;328
0000b4  eb030180          ADD      r1,r3,r0,LSL #2       ;330
0000b8  1d00              ADDS     r0,r0,#4              ;324
0000ba  edd12a00          VLDR     s5,[r1,#0]            ;330
0000be  edd11a01          VLDR     s3,[r1,#4]            ;331
0000c2  ed911a02          VLDR     s2,[r1,#8]            ;332
0000c6  ee642a22          VMUL.F32 s5,s8,s5              ;335
0000ca  edd10a03          VLDR     s1,[r1,#0xc]          ;333
0000ce  4583              CMP      r11,r0                ;324
0000d0  ee422a21          VMLA.F32 s5,s4,s3              ;335
0000d4  ee432a81          VMLA.F32 s5,s7,s2              ;335
0000d8  ee432a20          VMLA.F32 s5,s6,s1              ;335
0000dc  ee320a80          VADD.F32 s0,s5,s0              ;335
0000e0  dcde              BGT      |L381.160|
                  |L381.226|
0000e2  42a0              CMP      r0,r4                 ;342
0000e4  da0c              BGE      |L381.256|
                  |L381.230|
0000e6  eb0c0180          ADD      r1,r12,r0,LSL #2      ;343
0000ea  edd10a00          VLDR     s1,[r1,#0]            ;343
0000ee  eb030180          ADD      r1,r3,r0,LSL #2       ;343
0000f2  1c40              ADDS     r0,r0,#1              ;342
0000f4  ed911a00          VLDR     s2,[r1,#0]            ;343
0000f8  42a0              CMP      r0,r4                 ;342
0000fa  ee000a81          VMLA.F32 s0,s1,s2              ;343
0000fe  dbf2              BLT      |L381.230|
                  |L381.256|
000100  68b1              LDR      r1,[r6,#8]            ;342
000102  6930              LDR      r0,[r6,#0x10]         ;342
000104  fb0a0001          MLA      r0,r10,r1,r0          ;342
000108  eb000082          ADD      r0,r0,r2,LSL #2       ;342
00010c  1c52              ADDS     r2,r2,#1              ;318
00010e  ed800a00          VSTR     s0,[r0,#0]            ;346
000112  42ba              CMP      r2,r7                 ;318
000114  dbba              BLT      |L381.140|
                  |L381.278|
000116  f10a0a01          ADD      r10,r10,#1            ;314
00011a  45ca              CMP      r10,r9                ;314
00011c  dbad              BLT      |L381.122|
                  |L381.286|
00011e  b003              ADD      sp,sp,#0xc
000120  2000              MOVS     r0,#0                 ;350
000122  e8bd8ff0          POP      {r4-r11,pc}
                  |L381.294|
000126  f2401037          MOV      r0,#0x137             ;311
00012a  e9cdb000          STRD     r11,r0,[sp,#0]        ;311
00012e  a306              ADR      r3,|L381.328|
000130  a221              ADR      r2,|L381.440|
000132  a11d              ADR      r1,|L381.424|
000134  2005              MOVS     r0,#5                 ;311
000136  f7fffffe          BL       _Anki_Log
00013a  b003              ADD      sp,sp,#0xc
00013c  f04f60a0          MOV      r0,#0x5000000         ;311
000140  e8bd8ff0          POP      {r4-r11,pc}
;;;352    
                          ENDP

                  |L381.324|
                          DCD      _ZZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::MultiplyTranspose<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L381.328|
000148  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
00014c  6f726574
000150  6563685c
000154  636f6d6d
000158  6f6e5c69
00015c  6e636c75
000160  64655c61
000164  6e6b692f
000168  636f6d6d
00016c  6f6e2f72
000170  6f626f74
000174  2f6d6174
000178  726978  
00017b  2e6800            DCB      ".h",0
00017e  00                DCB      0
00017f  00                DCB      0
                  |L381.384|
000180  496e7075          DCB      "Input matrices are incompatible sizes",0
000184  74206d61
000188  74726963
00018c  65732061
000190  72652069
000194  6e636f6d
000198  70617469
00019c  626c6520
0001a0  73697a65
0001a4  7300    
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L381.424|
0001a8  4d756c74          DCB      "Multiply",0
0001ac  69706c79
0001b0  00      
0001b1  00                DCB      0
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L381.436|
0001b4  00000000          DCFS     0x00000000 ; 0
                  |L381.440|
0001b8  496e7075          DCB      "Input and Output matrices are incompatible sizes",0
0001bc  7420616e
0001c0  64204f75
0001c4  74707574
0001c8  206d6174
0001cc  72696365
0001d0  73206172
0001d4  6520696e
0001d8  636f6d70
0001dc  61746962
0001e0  6c652073
0001e4  697a6573
0001e8  00      
0001e9  00                DCB      0
0001ea  00                DCB      0
0001eb  00                DCB      0

                          AREA ||area_number.382||, COMGROUP=_ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.382||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE||, COMGROUP=_ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE PROC ; Anki::Embedded::Matrix::EstimateHomography<float>(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, Anki::Embedded::Array<T1>&, bool&, Anki::Embedded::MemoryStack)
                  |symbol_number.451|
;;;468    
;;;469          template<typename Type> NO_INLINE Result EstimateHomography(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;470            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;471            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;472            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;473            bool &numericalFailure, //!< Did the homography solver fail?
;;;474            MemoryStack scratch //!< Scratch memory
;;;475            )
;;;476          {
000004  4607              MOV      r7,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  b0ad              SUB      sp,sp,#0xb4
;;;477            const Type MAX_SOLVE_DISTANCE = static_cast<Type>(0.1);
;;;478    
;;;479            //BeginBenchmark("EstimateHomography_init");
;;;480    
;;;481            const s32 numPoints = originalPoints.get_size();
;;;482    
;;;483            AnkiConditionalErrorAndReturnValue(AreValid(originalPoints, transformedPoints, homography, scratch),
00000c  68c5              LDR      r5,[r0,#0xc]
00000e  460e              MOV      r6,r1                 ;476
000010  4608              MOV      r0,r1
000012  4614              MOV      r4,r2                 ;476
000014  69f9              LDR      r1,[r7,#0x1c]         ;476
000016  9a38              LDR      r2,[sp,#0xe0]         ;476
000018  f8df9420          LDR      r9,|L388.1084|
00001c  4698              MOV      r8,r3                 ;476
00001e  428d              CMP      r5,r1                 ;476
000020  dc3c              BGT      |L388.156|
000022  6abb              LDR      r3,[r7,#0x28]         ;476
000024  b12b              CBZ      r3,|L388.50|
000026  69bb              LDR      r3,[r7,#0x18]         ;476
000028  2b00              CMP      r3,#0                 ;476
00002a  bfa4              ITT      GE                    ;476
00002c  2900              CMPGE    r1,#0                 ;476
00002e  2101              MOVGE    r1,#1                 ;476
000030  da00              BGE      |L388.52|
                  |L388.50|
000032  2100              MOVS     r1,#0                 ;476
                  |L388.52|
000034  2900              CMP      r1,#0                 ;476
000036  d031              BEQ      |L388.156|
000038  68c3              LDR      r3,[r0,#0xc]          ;476
00003a  69c1              LDR      r1,[r0,#0x1c]         ;476
00003c  428b              CMP      r3,r1                 ;476
00003e  dc2d              BGT      |L388.156|
000040  6a83              LDR      r3,[r0,#0x28]         ;476
000042  b12b              CBZ      r3,|L388.80|
000044  6980              LDR      r0,[r0,#0x18]         ;476
000046  2800              CMP      r0,#0                 ;476
000048  bfa4              ITT      GE                    ;476
00004a  2900              CMPGE    r1,#0                 ;476
00004c  2001              MOVGE    r0,#1                 ;476
00004e  da00              BGE      |L388.82|
                  |L388.80|
000050  2000              MOVS     r0,#0                 ;476
                  |L388.82|
000052  2800              CMP      r0,#0                 ;476
000054  bf1c              ITT      NE                    ;476
000056  6920              LDRNE    r0,[r4,#0x10]         ;476
000058  2800              CMPNE    r0,#0                 ;476
00005a  d01f              BEQ      |L388.156|
00005c  6820              LDR      r0,[r4,#0]            ;476
00005e  2800              CMP      r0,#0                 ;476
000060  bfa4              ITT      GE                    ;476
000062  6860              LDRGE    r0,[r4,#4]            ;476
000064  2800              CMPGE    r0,#0                 ;476
000066  db19              BLT      |L388.156|
000068  4610              MOV      r0,r2                 ;476
00006a  f7fffffe          BL       _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
00006e  b1a8              CBZ      r0,|L388.156|
;;;484              RESULT_FAIL_INVALID_OBJECT, "EstimateHomography", "Invalid objects");
;;;485    
;;;486            AnkiConditionalErrorAndReturnValue(transformedPoints.get_size() == numPoints && numPoints >= 4,
000070  68f0              LDR      r0,[r6,#0xc]
000072  42a8              CMP      r0,r5
000074  d101              BNE      |L388.122|
000076  2d04              CMP      r5,#4
000078  da1d              BGE      |L388.182|
                  |L388.122|
00007a  f44f70f3          MOV      r0,#0x1e6
00007e  e9cd9000          STRD     r9,r0,[sp,#0]
000082  a3ef              ADR      r3,|L388.1088|
000084  4afc              LDR      r2,|L388.1144|
000086  a1fd              ADR      r1,|L388.1148|
000088  2005              MOVS     r0,#5
00008a  f7fffffe          BL       _Anki_Log
00008e  f04f60a0          MOV      r0,#0x5000000
                  |L388.146|
;;;487              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "originalPoints and transformedPoints must be the same size, and have at least four points apiece.");
;;;488    
;;;489            AnkiConditionalErrorAndReturnValue(AreEqualSize(3, 3, homography),
;;;490              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "homography must be 3x3");
;;;491    
;;;492            homography.SetZero();
;;;493            homography[0][0] = 1;
;;;494            homography[1][1] = 1;
;;;495            homography[2][2] = 1;
;;;496    
;;;497            Array<Type> A(8, 2*numPoints, scratch);
;;;498            Array<Type> bt(1, 2*numPoints, scratch);
;;;499    
;;;500            const Point<Type> * const pOriginalPoints = originalPoints.Pointer(0);
;;;501            const Point<Type> * const pTransformedPoints = transformedPoints.Pointer(0);
;;;502    
;;;503            Type * restrict pBt = bt.Pointer(0,0);
;;;504    
;;;505            //EndBenchmark("EstimateHomography_init");
;;;506    
;;;507            //BeginBenchmark("EstimateHomography_a&b");
;;;508    
;;;509            for(s32 i=0; i<numPoints; i++) {
;;;510              Type * restrict A_y1 = A.Pointer(2*i, 0);
;;;511              Type * restrict A_y2 = A.Pointer(2*i + 1, 0);
;;;512    
;;;513              const Type xi = pOriginalPoints[i].x;
;;;514              const Type yi = pOriginalPoints[i].y;
;;;515    
;;;516              const Type xp = pTransformedPoints[i].x;
;;;517              const Type yp = pTransformedPoints[i].y;
;;;518    
;;;519              A_y1[0] = 0;  A_y1[1] = 0;  A_y1[2] = 0; A_y1[3] = -xi; A_y1[4] = -yi; A_y1[5] = -1; A_y1[6] = xi*yp;  A_y1[7] = yi*yp;
;;;520              A_y2[0] = xi; A_y2[1] = yi; A_y2[2] = 1; A_y2[3] = 0;   A_y2[4] = 0;   A_y2[5] = 0;  A_y2[6] = -xi*xp; A_y2[7] = -yi*xp;
;;;521    
;;;522              pBt[2*i] = -yp;
;;;523              pBt[2*i + 1] = xp;
;;;524            }
;;;525    
;;;526            //EndBenchmark("EstimateHomography_a&b");
;;;527    
;;;528            //BeginBenchmark("EstimateHomography_At");
;;;529    
;;;530            Array<Type> At(2*numPoints, 8, scratch);
;;;531    
;;;532            Matrix::Transpose(A, At);
;;;533    
;;;534            //EndBenchmark("EstimateHomography_At");
;;;535    
;;;536            //BeginBenchmark("EstimateHomography_AtA");
;;;537    
;;;538            Array<Type> AtA(8, 8, scratch, Flags::Buffer(false,false,false));
;;;539            Array<Type> Atb(8, 1, scratch, Flags::Buffer(false,false,false));
;;;540    
;;;541            Matrix::Multiply(At, A, AtA);
;;;542    
;;;543            //EndBenchmark("EstimateHomography_AtA");
;;;544    
;;;545            //BeginBenchmark("EstimateHomography_Atb");
;;;546    
;;;547            Matrix::MultiplyTranspose(At, bt, Atb);
;;;548    
;;;549            //EndBenchmark("EstimateHomography_Atb");
;;;550    
;;;551            //BeginBenchmark("EstimateHomography_transposeAtb");
;;;552    
;;;553            Array<Type> Atbt(1, 8, scratch);
;;;554    
;;;555            Matrix::Transpose(Atb, Atbt);
;;;556    
;;;557            //EndBenchmark("EstimateHomography_transposeAtb");
;;;558    
;;;559            //BeginBenchmark("EstimateHomography_cholesky");
;;;560    
;;;561            const Result choleskyResult = SolveLeastSquaresWithCholesky(AtA, Atbt, false, numericalFailure);
;;;562    
;;;563            AnkiConditionalErrorAndReturnValue(choleskyResult == RESULT_OK,
;;;564              choleskyResult, "EstimateHomography", "SolveLeastSquaresWithCholesky failed");
;;;565    
;;;566            if(numericalFailure){
;;;567              AnkiWarn("EstimateHomography", "numericalFailure");
;;;568              return RESULT_OK;
;;;569            }
;;;570    
;;;571            Type * restrict pAtbt = Atbt.Pointer(0,0);
;;;572    
;;;573            homography[0][0] = pAtbt[0]; homography[0][1] = pAtbt[1]; homography[0][2] = pAtbt[2];
;;;574            homography[1][0] = pAtbt[3]; homography[1][1] = pAtbt[4]; homography[1][2] = pAtbt[5];
;;;575            homography[2][0] = pAtbt[6]; homography[2][1] = pAtbt[7]; homography[2][2] = static_cast<Type>(1);
;;;576    
;;;577            // Check that the solution is fairly close
;;;578            // TODO: make work for numPoints != 4
;;;579            if(numPoints == 4) {
;;;580              Array<Type> point1(3,1,scratch);
;;;581              Array<Type> point1Warped(3,1,scratch);
;;;582              for(s32 iPoint=0; iPoint<numPoints; iPoint++) {
;;;583                point1[0][0] = originalPoints[iPoint].x;
;;;584                point1[1][0] = originalPoints[iPoint].y;
;;;585                point1[2][0] = 1;
;;;586    
;;;587                Matrix::Multiply(homography, point1, point1Warped);
;;;588                point1Warped[0][0] /= point1Warped[2][0];
;;;589                point1Warped[1][0] /= point1Warped[2][0];
;;;590    
;;;591                const Type distance = sqrtf(powf(static_cast<f32>(transformedPoints[iPoint].x) - static_cast<f32>(point1Warped[0][0]), 2.0f) + powf(static_cast<f32>(transformedPoints[iPoint].y) - static_cast<f32>(point1Warped[1][0]), 2.0f));
;;;592    
;;;593                if(distance > MAX_SOLVE_DISTANCE) {
;;;594                  AnkiWarn("EstimateHomography", "Poor solution precision");
;;;595    
;;;596                  numericalFailure = true;
;;;597    
;;;598                  homography.SetZero();
;;;599                  homography[0][0] = 1;
;;;600                  homography[1][1] = 1;
;;;601                  homography[2][2] = 1;
;;;602    
;;;603                  return RESULT_OK;
;;;604                }
;;;605              }
;;;606            }
;;;607            //EndBenchmark("EstimateHomography_cholesky");
;;;608    
;;;609            return RESULT_OK;
;;;610          } // EstimateHomography()
000092  b02d              ADD      sp,sp,#0xb4
000094  ecbd8b02          VPOP     {d8}
000098  e8bd8ff0          POP      {r4-r11,pc}
                  |L388.156|
00009c  f24010e3          MOV      r0,#0x1e3             ;483
0000a0  e9cd9000          STRD     r9,r0,[sp,#0]         ;483
0000a4  a3e6              ADR      r3,|L388.1088|
0000a6  a2fa              ADR      r2,|L388.1168|
0000a8  a1f4              ADR      r1,|L388.1148|
0000aa  2005              MOVS     r0,#5                 ;483
0000ac  f7fffffe          BL       _Anki_Log
0000b0  f04f6080          MOV      r0,#0x4000000         ;483
0000b4  e7ed              B        |L388.146|
                  |L388.182|
0000b6  2103              MOVS     r1,#3                 ;489
0000b8  4622              MOV      r2,r4                 ;489
0000ba  4608              MOV      r0,r1                 ;489
0000bc  f7fffffe          BL       _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_ ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<float>>(int, int, const T1&)
0000c0  2800              CMP      r0,#0                 ;489
0000c2  f00080f5          BEQ.W    |L388.688|
0000c6  4620              MOV      r0,r4                 ;492
0000c8  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
0000cc  68a2              LDR      r2,[r4,#8]            ;492
0000ce  6921              LDR      r1,[r4,#0x10]         ;492
0000d0  2000              MOVS     r0,#0                 ;493
0000d2  fb001002          MLA      r0,r0,r2,r1           ;493
0000d6  eeb78a00          VMOV.F32 s16,#1.00000000       ;493
0000da  ed808a00          VSTR     s16,[r0,#0]           ;493
0000de  68a2              LDR      r2,[r4,#8]            ;493
0000e0  6921              LDR      r1,[r4,#0x10]         ;493
0000e2  2001              MOVS     r0,#1                 ;494
0000e4  fb001002          MLA      r0,r0,r2,r1           ;494
0000e8  2300              MOVS     r3,#0                 ;497
0000ea  ed808a01          VSTR     s16,[r0,#4]           ;494
0000ee  68a2              LDR      r2,[r4,#8]            ;494
0000f0  6921              LDR      r1,[r4,#0x10]         ;494
0000f2  2002              MOVS     r0,#2                 ;495
0000f4  fb001002          MLA      r0,r0,r2,r1           ;495
0000f8  461a              MOV      r2,r3                 ;497
0000fa  ed808a02          VSTR     s16,[r0,#8]           ;495
0000fe  2101              MOVS     r1,#1                 ;497
000100  a82a              ADD      r0,sp,#0xa8           ;497
000102  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000106  006a              LSLS     r2,r5,#1              ;497
000108  6800              LDR      r0,[r0,#0]            ;497
00010a  e9cd0200          STRD     r0,r2,[sp,#0]         ;497
00010e  4692              MOV      r10,r2                ;497
000110  2108              MOVS     r1,#8                 ;497
000112  a806              ADD      r0,sp,#0x18           ;497
000114  9b38              LDR      r3,[sp,#0xe0]         ;497
000116  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00011a  2300              MOVS     r3,#0                 ;498
00011c  461a              MOV      r2,r3                 ;498
00011e  2101              MOVS     r1,#1                 ;498
000120  a829              ADD      r0,sp,#0xa4           ;498
000122  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000126  6800              LDR      r0,[r0,#0]            ;498
000128  9000              STR      r0,[sp,#0]            ;498
00012a  4652              MOV      r2,r10                ;498
00012c  2101              MOVS     r1,#1                 ;498
00012e  a824              ADD      r0,sp,#0x90           ;498
000130  9b38              LDR      r3,[sp,#0xe0]         ;498
000132  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000136  9a26              LDR      r2,[sp,#0x98]         ;498
000138  9928              LDR      r1,[sp,#0xa0]         ;498
00013a  2000              MOVS     r0,#0                 ;503
00013c  fb001c02          MLA      r12,r0,r2,r1          ;503
000140  f8d7b030          LDR      r11,[r7,#0x30]        ;503
000144  f8d6a030          LDR      r10,[r6,#0x30]        ;503
000148  4601              MOV      r1,r0                 ;509
00014a  ed9f2ad5          VLDR     s4,|L388.1184|
00014e  eeff2a00          VMOV.F32 s5,#-1.00000000       ;519
                  |L388.338|
000152  9b08              LDR      r3,[sp,#0x20]         ;519
000154  9a0a              LDR      r2,[sp,#0x28]         ;519
000156  0048              LSLS     r0,r1,#1              ;510
000158  fb002203          MLA      r2,r0,r3,r2           ;510
00015c  2001              MOVS     r0,#1                 ;511
00015e  f8dde020          LDR      lr,[sp,#0x20]         ;511
000162  9b0a              LDR      r3,[sp,#0x28]         ;511
000164  eb000041          ADD      r0,r0,r1,LSL #1       ;511
000168  fb00300e          MLA      r0,r0,lr,r3           ;511
00016c  eb0b03c1          ADD      r3,r11,r1,LSL #3      ;513
000170  edd30a00          VLDR     s1,[r3,#0]            ;513
000174  ed930a01          VLDR     s0,[r3,#4]            ;514
000178  eb0a03c1          ADD      r3,r10,r1,LSL #3      ;516
00017c  eeb13a60          VNEG.F32 s6,s1                 ;519
000180  edd31a00          VLDR     s3,[r3,#0]            ;516
000184  ed931a01          VLDR     s2,[r3,#4]            ;517
000188  ed822a00          VSTR     s4,[r2,#0]            ;519
00018c  ed822a01          VSTR     s4,[r2,#4]            ;519
000190  ed822a02          VSTR     s4,[r2,#8]            ;519
000194  ed823a03          VSTR     s6,[r2,#0xc]          ;519
000198  eeb13a40          VNEG.F32 s6,s0                 ;519
00019c  ed823a04          VSTR     s6,[r2,#0x10]         ;519
0001a0  ee203a81          VMUL.F32 s6,s1,s2              ;519
0001a4  edc22a05          VSTR     s5,[r2,#0x14]         ;519
0001a8  ed823a06          VSTR     s6,[r2,#0x18]         ;519
0001ac  ee203a01          VMUL.F32 s6,s0,s2              ;519
0001b0  ed823a07          VSTR     s6,[r2,#0x1c]         ;519
0001b4  edc00a00          VSTR     s1,[r0,#0]            ;520
0001b8  ed800a01          VSTR     s0,[r0,#4]            ;520
0001bc  ed808a02          VSTR     s16,[r0,#8]           ;520
0001c0  ed802a03          VSTR     s4,[r0,#0xc]          ;520
0001c4  ee600ae1          VNMUL.F32 s1,s1,s3              ;520
0001c8  ed802a04          VSTR     s4,[r0,#0x10]         ;520
0001cc  ee200a61          VNMUL.F32 s0,s0,s3              ;520
0001d0  ed802a05          VSTR     s4,[r0,#0x14]         ;520
0001d4  edc00a06          VSTR     s1,[r0,#0x18]         ;520
0001d8  ed800a07          VSTR     s0,[r0,#0x1c]         ;520
0001dc  eb0c00c1          ADD      r0,r12,r1,LSL #3      ;522
0001e0  eeb10a41          VNEG.F32 s0,s2                 ;522
0001e4  ed800a00          VSTR     s0,[r0,#0]            ;522
0001e8  1c49              ADDS     r1,r1,#1              ;509
0001ea  edc01a01          VSTR     s3,[r0,#4]            ;523
0001ee  42a9              CMP      r1,r5                 ;509
0001f0  dbaf              BLT      |L388.338|
0001f2  2300              MOVS     r3,#0                 ;530
0001f4  461a              MOV      r2,r3                 ;530
0001f6  2101              MOVS     r1,#1                 ;530
0001f8  a829              ADD      r0,sp,#0xa4           ;530
0001fa  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001fe  6800              LDR      r0,[r0,#0]            ;530
000200  9000              STR      r0,[sp,#0]            ;530
000202  2208              MOVS     r2,#8                 ;530
000204  a80b              ADD      r0,sp,#0x2c           ;530
000206  9b38              LDR      r3,[sp,#0xe0]         ;530
000208  9901              LDR      r1,[sp,#4]            ;530
00020a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00020e  a90b              ADD      r1,sp,#0x2c           ;532
000210  a806              ADD      r0,sp,#0x18           ;532
000212  f7fffffe          BL       _ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE ; Anki::Embedded::Matrix::Transpose<float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
000216  2300              MOVS     r3,#0                 ;538
000218  461a              MOV      r2,r3                 ;538
00021a  4619              MOV      r1,r3                 ;538
00021c  a829              ADD      r0,sp,#0xa4           ;538
00021e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000222  6800              LDR      r0,[r0,#0]            ;538
000224  9000              STR      r0,[sp,#0]            ;538
000226  2208              MOVS     r2,#8                 ;538
000228  4611              MOV      r1,r2                 ;538
00022a  a81a              ADD      r0,sp,#0x68           ;538
00022c  9b38              LDR      r3,[sp,#0xe0]         ;538
00022e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000232  2300              MOVS     r3,#0                 ;539
000234  461a              MOV      r2,r3                 ;539
000236  4619              MOV      r1,r3                 ;539
000238  a82a              ADD      r0,sp,#0xa8           ;539
00023a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00023e  6800              LDR      r0,[r0,#0]            ;539
000240  9000              STR      r0,[sp,#0]            ;539
000242  2201              MOVS     r2,#1                 ;539
000244  2108              MOVS     r1,#8                 ;539
000246  a81f              ADD      r0,sp,#0x7c           ;539
000248  9b38              LDR      r3,[sp,#0xe0]         ;539
00024a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00024e  aa1a              ADD      r2,sp,#0x68           ;541
000250  a906              ADD      r1,sp,#0x18           ;541
000252  a80b              ADD      r0,sp,#0x2c           ;541
000254  f7fffffe          BL       _ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
000258  aa1f              ADD      r2,sp,#0x7c           ;547
00025a  a924              ADD      r1,sp,#0x90           ;547
00025c  a80b              ADD      r0,sp,#0x2c           ;547
00025e  f7fffffe          BL       _ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE ; Anki::Embedded::Matrix::MultiplyTranspose<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
000262  2300              MOVS     r3,#0                 ;553
000264  461a              MOV      r2,r3                 ;553
000266  2101              MOVS     r1,#1                 ;553
000268  a829              ADD      r0,sp,#0xa4           ;553
00026a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00026e  6800              LDR      r0,[r0,#0]            ;553
000270  9000              STR      r0,[sp,#0]            ;553
000272  2208              MOVS     r2,#8                 ;553
000274  2101              MOVS     r1,#1                 ;553
000276  a815              ADD      r0,sp,#0x54           ;553
000278  9b38              LDR      r3,[sp,#0xe0]         ;553
00027a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00027e  a915              ADD      r1,sp,#0x54           ;555
000280  a81f              ADD      r0,sp,#0x7c           ;555
000282  f7fffffe          BL       _ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE ; Anki::Embedded::Matrix::Transpose<float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
000286  4643              MOV      r3,r8                 ;561
000288  2200              MOVS     r2,#0                 ;561
00028a  a915              ADD      r1,sp,#0x54           ;561
00028c  a81a              ADD      r0,sp,#0x68           ;561
00028e  f7fffffe          BL       _ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)
000292  ea5f0a00          MOVS     r10,r0                ;561
000296  d018              BEQ      |L388.714|
000298  f2402033          MOV      r0,#0x233             ;563
00029c  e9cd9000          STRD     r9,r0,[sp,#0]         ;563
0002a0  a367              ADR      r3,|L388.1088|
0002a2  a280              ADR      r2,|L388.1188|
0002a4  a175              ADR      r1,|L388.1148|
0002a6  2005              MOVS     r0,#5                 ;563
0002a8  f7fffffe          BL       _Anki_Log
0002ac  4650              MOV      r0,r10                ;563
0002ae  e6f0              B        |L388.146|
                  |L388.688|
0002b0  f24010e9          MOV      r0,#0x1e9             ;489
0002b4  e9cd9000          STRD     r9,r0,[sp,#0]         ;489
0002b8  a361              ADR      r3,|L388.1088|
0002ba  a284              ADR      r2,|L388.1228|
0002bc  a16f              ADR      r1,|L388.1148|
0002be  2005              MOVS     r0,#5                 ;489
0002c0  f7fffffe          BL       _Anki_Log
0002c4  f04f60a0          MOV      r0,#0x5000000         ;489
0002c8  e6e3              B        |L388.146|
                  |L388.714|
0002ca  f8980000          LDRB     r0,[r8,#0]            ;566
0002ce  2800              CMP      r0,#0                 ;566
0002d0  f040816e          BNE.W    |L388.1456|
0002d4  9a17              LDR      r2,[sp,#0x5c]         ;566
0002d6  9919              LDR      r1,[sp,#0x64]         ;566
0002d8  68a3              LDR      r3,[r4,#8]            ;566
0002da  fb001002          MLA      r0,r0,r2,r1           ;566
0002de  6922              LDR      r2,[r4,#0x10]         ;566
0002e0  2100              MOVS     r1,#0                 ;573
0002e2  fb012103          MLA      r1,r1,r3,r2           ;573
0002e6  ed900a00          VLDR     s0,[r0,#0]            ;573
0002ea  ed810a00          VSTR     s0,[r1,#0]            ;573
0002ee  68a3              LDR      r3,[r4,#8]            ;573
0002f0  6922              LDR      r2,[r4,#0x10]         ;573
0002f2  2100              MOVS     r1,#0                 ;573
0002f4  fb012103          MLA      r1,r1,r3,r2           ;573
0002f8  ed900a01          VLDR     s0,[r0,#4]            ;573
0002fc  ed810a01          VSTR     s0,[r1,#4]            ;573
000300  68a3              LDR      r3,[r4,#8]            ;573
000302  6922              LDR      r2,[r4,#0x10]         ;573
000304  2100              MOVS     r1,#0                 ;573
000306  fb012103          MLA      r1,r1,r3,r2           ;573
00030a  ed900a02          VLDR     s0,[r0,#8]            ;573
00030e  ed810a02          VSTR     s0,[r1,#8]            ;573
000312  68a3              LDR      r3,[r4,#8]            ;573
000314  6922              LDR      r2,[r4,#0x10]         ;573
000316  2101              MOVS     r1,#1                 ;574
000318  fb012103          MLA      r1,r1,r3,r2           ;574
00031c  ed900a03          VLDR     s0,[r0,#0xc]          ;574
000320  ed810a00          VSTR     s0,[r1,#0]            ;574
000324  68a3              LDR      r3,[r4,#8]            ;574
000326  6922              LDR      r2,[r4,#0x10]         ;574
000328  2101              MOVS     r1,#1                 ;574
00032a  fb012103          MLA      r1,r1,r3,r2           ;574
00032e  ed900a04          VLDR     s0,[r0,#0x10]         ;574
000332  ed810a01          VSTR     s0,[r1,#4]            ;574
000336  68a3              LDR      r3,[r4,#8]            ;574
000338  6922              LDR      r2,[r4,#0x10]         ;574
00033a  2101              MOVS     r1,#1                 ;574
00033c  fb012103          MLA      r1,r1,r3,r2           ;574
000340  ed900a05          VLDR     s0,[r0,#0x14]         ;574
000344  ed810a02          VSTR     s0,[r1,#8]            ;574
000348  68a3              LDR      r3,[r4,#8]            ;574
00034a  6922              LDR      r2,[r4,#0x10]         ;574
00034c  2102              MOVS     r1,#2                 ;575
00034e  fb012103          MLA      r1,r1,r3,r2           ;575
000352  ed900a06          VLDR     s0,[r0,#0x18]         ;575
000356  ed810a00          VSTR     s0,[r1,#0]            ;575
00035a  68a3              LDR      r3,[r4,#8]            ;575
00035c  6922              LDR      r2,[r4,#0x10]         ;575
00035e  2102              MOVS     r1,#2                 ;575
000360  fb012103          MLA      r1,r1,r3,r2           ;575
000364  ed900a07          VLDR     s0,[r0,#0x1c]         ;575
000368  2002              MOVS     r0,#2                 ;575
00036a  ed810a01          VSTR     s0,[r1,#4]            ;575
00036e  68a2              LDR      r2,[r4,#8]            ;575
000370  6921              LDR      r1,[r4,#0x10]         ;575
000372  2d04              CMP      r5,#4                 ;579
000374  fb001002          MLA      r0,r0,r2,r1           ;579
000378  ed808a02          VSTR     s16,[r0,#8]           ;575
00037c  d15c              BNE      |L388.1080|
00037e  2300              MOVS     r3,#0                 ;580
000380  461a              MOV      r2,r3                 ;580
000382  2101              MOVS     r1,#1                 ;580
000384  a82b              ADD      r0,sp,#0xac           ;580
000386  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00038a  6800              LDR      r0,[r0,#0]            ;580
00038c  9000              STR      r0,[sp,#0]            ;580
00038e  2201              MOVS     r2,#1                 ;580
000390  2103              MOVS     r1,#3                 ;580
000392  a810              ADD      r0,sp,#0x40           ;580
000394  9b38              LDR      r3,[sp,#0xe0]         ;580
000396  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00039a  2300              MOVS     r3,#0                 ;581
00039c  461a              MOV      r2,r3                 ;581
00039e  2101              MOVS     r1,#1                 ;581
0003a0  a82c              ADD      r0,sp,#0xb0           ;581
0003a2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0003a6  6800              LDR      r0,[r0,#0]            ;581
0003a8  9000              STR      r0,[sp,#0]            ;581
0003aa  2201              MOVS     r2,#1                 ;581
0003ac  2103              MOVS     r1,#3                 ;581
0003ae  a801              ADD      r0,sp,#4              ;581
0003b0  9b38              LDR      r3,[sp,#0xe0]         ;581
0003b2  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0003b6  f8dfa12c          LDR      r10,|L388.1252|
0003ba  f04f0900          MOV      r9,#0                 ;582
                  |L388.958|
0003be  6b38              LDR      r0,[r7,#0x30]         ;582
0003c0  9a12              LDR      r2,[sp,#0x48]         ;582
0003c2  eb0000c9          ADD      r0,r0,r9,LSL #3       ;582
0003c6  9914              LDR      r1,[sp,#0x50]         ;582
0003c8  ed900a00          VLDR     s0,[r0,#0]            ;583
0003cc  2000              MOVS     r0,#0                 ;583
0003ce  fb001002          MLA      r0,r0,r2,r1           ;583
0003d2  ed800a00          VSTR     s0,[r0,#0]            ;583
0003d6  6b38              LDR      r0,[r7,#0x30]         ;583
0003d8  9a12              LDR      r2,[sp,#0x48]         ;583
0003da  eb0000c9          ADD      r0,r0,r9,LSL #3       ;583
0003de  9914              LDR      r1,[sp,#0x50]         ;583
0003e0  ed900a01          VLDR     s0,[r0,#4]            ;584
0003e4  2001              MOVS     r0,#1                 ;584
0003e6  fb001002          MLA      r0,r0,r2,r1           ;584
0003ea  ed800a00          VSTR     s0,[r0,#0]            ;584
0003ee  9a12              LDR      r2,[sp,#0x48]         ;584
0003f0  9914              LDR      r1,[sp,#0x50]         ;584
0003f2  2002              MOVS     r0,#2                 ;585
0003f4  fb001002          MLA      r0,r0,r2,r1           ;585
0003f8  aa01              ADD      r2,sp,#4              ;587
0003fa  ed808a00          VSTR     s16,[r0,#0]           ;585
0003fe  a910              ADD      r1,sp,#0x40           ;587
000400  4620              MOV      r0,r4                 ;587
000402  f7fffffe          BL       _ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
000406  9a03              LDR      r2,[sp,#0xc]          ;587
000408  9905              LDR      r1,[sp,#0x14]         ;587
00040a  2000              MOVS     r0,#0                 ;588
00040c  fb001002          MLA      r0,r0,r2,r1           ;588
000410  9b03              LDR      r3,[sp,#0xc]          ;588
000412  9a05              LDR      r2,[sp,#0x14]         ;588
000414  2102              MOVS     r1,#2                 ;588
000416  fb012103          MLA      r1,r1,r3,r2           ;588
00041a  edd00a00          VLDR     s1,[r0,#0]            ;588
00041e  ed910a00          VLDR     s0,[r1,#0]            ;588
000422  ee801a80          VDIV.F32 s2,s1,s0              ;588
000426  ed801a00          VSTR     s2,[r0,#0]            ;588
00042a  9a03              LDR      r2,[sp,#0xc]          ;588
00042c  9905              LDR      r1,[sp,#0x14]         ;588
00042e  2001              MOVS     r0,#1                 ;589
000430  fb001002          MLA      r0,r0,r2,r1           ;589
000434  2102              MOVS     r1,#2                 ;589
000436  e057              B        |L388.1256|
                  |L388.1080|
000438  e0ba              B        |L388.1456|
00043a  0000              DCW      0x0000
                  |L388.1084|
                          DCD      _ZZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::EstimateHomography<float>(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, Anki::Embedded::Array<T1>&, bool&, Anki::Embedded::MemoryStack)::__PRETTY_FUNCTION__
                  |L388.1088|
000440  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000444  6f726574
000448  6563685c
00044c  636f6d6d
000450  6f6e5c69
000454  6e636c75
000458  64655c61
00045c  6e6b692f
000460  636f6d6d
000464  6f6e2f72
000468  6f626f74
00046c  2f6d6174
000470  726978  
000473  2e6800            DCB      ".h",0
000476  00                DCB      0
000477  00                DCB      0
                  |L388.1144|
                          DCD      ||.constdata||+0xb98
                  |L388.1148|
00047c  45737469          DCB      "EstimateHomography",0
000480  6d617465
000484  486f6d6f
000488  67726170
00048c  687900  
00048f  00                DCB      0
                  |L388.1168|
000490  496e7661          DCB      "Invalid objects",0
000494  6c696420
000498  6f626a65
00049c  63747300
                  |L388.1184|
0004a0  00000000          DCFS     0x00000000 ; 0
                  |L388.1188|
0004a4  536f6c76          DCB      "SolveLeastSquaresWithCholesky failed",0
0004a8  654c6561
0004ac  73745371
0004b0  75617265
0004b4  73576974
0004b8  6843686f
0004bc  6c65736b
0004c0  79206661
0004c4  696c6564
0004c8  00      
0004c9  00                DCB      0
0004ca  00                DCB      0
0004cb  00                DCB      0
                  |L388.1228|
0004cc  686f6d6f          DCB      "homography must be 3x3",0
0004d0  67726170
0004d4  6879206d
0004d8  75737420
0004dc  62652033
0004e0  783300  
0004e3  00                DCB      0
                  |L388.1252|
                          DCD      0x3dcccccd
                  |L388.1256|
0004e8  9b03              LDR      r3,[sp,#0xc]          ;589
0004ea  9a05              LDR      r2,[sp,#0x14]         ;589
0004ec  edd00a00          VLDR     s1,[r0,#0]            ;589
0004f0  fb012103          MLA      r1,r1,r3,r2           ;589
0004f4  ed910a00          VLDR     s0,[r1,#0]            ;589
0004f8  ee801a80          VDIV.F32 s2,s1,s0              ;589
0004fc  ed801a00          VSTR     s2,[r0,#0]            ;589
000500  6b30              LDR      r0,[r6,#0x30]         ;589
000502  9a03              LDR      r2,[sp,#0xc]          ;589
000504  eb0000c9          ADD      r0,r0,r9,LSL #3       ;589
000508  9905              LDR      r1,[sp,#0x14]         ;589
00050a  ed900a00          VLDR     s0,[r0,#0]            ;591
00050e  2000              MOVS     r0,#0                 ;591
000510  fb001002          MLA      r0,r0,r2,r1           ;591
000514  edd00a00          VLDR     s1,[r0,#0]            ;591
000518  ee300a60          VSUB.F32 s0,s0,s1              ;591
00051c  eef00a00          VMOV.F32 s1,#2.00000000        ;591
000520  f7fffffe          BL       __hardfp_powf
000524  6b30              LDR      r0,[r6,#0x30]         ;591
000526  eef08a40          VMOV.F32 s17,s0                ;591
00052a  eb0000c9          ADD      r0,r0,r9,LSL #3       ;591
00052e  9a03              LDR      r2,[sp,#0xc]          ;591
000530  ed900a01          VLDR     s0,[r0,#4]            ;591
000534  9905              LDR      r1,[sp,#0x14]         ;591
000536  2001              MOVS     r0,#1                 ;591
000538  fb001002          MLA      r0,r0,r2,r1           ;591
00053c  edd00a00          VLDR     s1,[r0,#0]            ;591
000540  ee300a60          VSUB.F32 s0,s0,s1              ;591
000544  eef00a00          VMOV.F32 s1,#2.00000000        ;591
000548  f7fffffe          BL       __hardfp_powf
00054c  ee380a80          VADD.F32 s0,s17,s0             ;591
000550  eef10ac0          VSQRT.F32 s1,s0                 ;591
000554  eef40a60          VCMP.F32 s1,s1                 ;591
000558  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;591
00055c  d003              BEQ      |L388.1382|
00055e  f7fffffe          BL       __hardfp_sqrtf
000562  eef00a40          VMOV.F32 s1,s0                 ;591
                  |L388.1382|
000566  ee100a90          VMOV     r0,s1                 ;591
00056a  4550              CMP      r0,r10                ;593
00056c  dd1b              BLE      |L388.1446|
00056e  2501              MOVS     r5,#1                 ;596
000570  f8885000          STRB     r5,[r8,#0]            ;596
000574  4620              MOV      r0,r4                 ;598
000576  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
00057a  68a2              LDR      r2,[r4,#8]            ;598
00057c  6921              LDR      r1,[r4,#0x10]         ;598
00057e  2000              MOVS     r0,#0                 ;599
000580  fb001002          MLA      r0,r0,r2,r1           ;599
000584  ed808a00          VSTR     s16,[r0,#0]           ;599
000588  68a1              LDR      r1,[r4,#8]            ;599
00058a  6920              LDR      r0,[r4,#0x10]         ;599
00058c  fb050001          MLA      r0,r5,r1,r0           ;599
000590  ed808a01          VSTR     s16,[r0,#4]           ;600
000594  68a2              LDR      r2,[r4,#8]            ;600
000596  6921              LDR      r1,[r4,#0x10]         ;600
000598  2002              MOVS     r0,#2                 ;601
00059a  fb001002          MLA      r0,r0,r2,r1           ;601
00059e  ed808a02          VSTR     s16,[r0,#8]           ;601
0005a2  2000              MOVS     r0,#0                 ;603
0005a4  e575              B        |L388.146|
                  |L388.1446|
0005a6  f1090901          ADD      r9,r9,#1              ;582
0005aa  454d              CMP      r5,r9                 ;582
0005ac  f73faf07          BGT      |L388.958|
                  |L388.1456|
0005b0  2000              MOVS     r0,#0                 ;609
0005b2  e56e              B        |L388.146|
;;;611    
                          ENDP


                          AREA ||area_number.389||, COMGROUP=_ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE, LINKORDER=||t._ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.389||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b||, COMGROUP=_ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b PROC ; Anki::Embedded::Matrix::MakeSymmetric<Anki::Embedded::Array<float>>(T1&, bool)
;;;1798   
;;;1799         template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1800         {
000002  460e              MOV      r6,r1
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
;;;1801           AnkiConditionalErrorAndReturnValue(arr.get_size(0) == arr.get_size(1),
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00000e  4604              MOV      r4,r0
000010  2101              MOVS     r1,#1
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000018  4284              CMP      r4,r0
00001a  d00e              BEQ      |L395.58|
00001c  f2407109          MOV      r1,#0x709
000020  481a              LDR      r0,|L395.140|
000022  e9cd0100          STRD     r0,r1,[sp,#0]
000026  a31a              ADR      r3,|L395.144|
000028  a227              ADR      r2,|L395.200|
00002a  a12e              ADR      r1,|L395.228|
00002c  2005              MOVS     r0,#5
00002e  f7fffffe          BL       _Anki_Log
;;;1802             RESULT_FAIL_INVALID_SIZE, "MakeSymmetric", "Input array must be square");
;;;1803   
;;;1804           const s32 arrHeight = arr.get_size(0);
;;;1805           for(s32 y = 0; y < arrHeight; y++)
;;;1806           {
;;;1807             const s32 x0 = lowerToUpper ? (y+1)     : 0;
;;;1808             const s32 x1 = lowerToUpper ? arrHeight : y;
;;;1809   
;;;1810             for(s32 x = x0; x < x1; x++) {
;;;1811               *arr.Pointer(y,x) = *arr.Pointer(x,y);
;;;1812             }
;;;1813           }
;;;1814   
;;;1815           return RESULT_OK;
;;;1816         } // template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
000032  b003              ADD      sp,sp,#0xc
000034  f04f60a0          MOV      r0,#0x5000000         ;1801
000038  bdf0              POP      {r4-r7,pc}
                  |L395.58|
00003a  2100              MOVS     r1,#0                 ;1804
00003c  4628              MOV      r0,r5                 ;1804
00003e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000042  1e01              SUBS     r1,r0,#0              ;1804
000044  f04f0300          MOV      r3,#0                 ;1805
000048  dd1c              BLE      |L395.132|
                  |L395.74|
00004a  2e00              CMP      r6,#0                 ;1807
00004c  bf15              ITETE    NE                    ;1807
00004e  1c5a              ADDNE    r2,r3,#1              ;1807
000050  2200              MOVEQ    r2,#0                 ;1807
000052  4608              MOVNE    r0,r1                 ;1808
000054  4618              MOVEQ    r0,r3                 ;1808
000056  4282              CMP      r2,r0                 ;1810
000058  da11              BGE      |L395.126|
                  |L395.90|
00005a  f8d5c010          LDR      r12,[r5,#0x10]        ;1810
00005e  68ac              LDR      r4,[r5,#8]            ;1810
000060  fb02c704          MLA      r7,r2,r4,r12          ;1810
000064  fb03cc04          MLA      r12,r3,r4,r12         ;1810
000068  eb070783          ADD      r7,r7,r3,LSL #2       ;1810
00006c  eb0c0c82          ADD      r12,r12,r2,LSL #2     ;1810
000070  ed970a00          VLDR     s0,[r7,#0]            ;1811
000074  1c52              ADDS     r2,r2,#1              ;1810
000076  ed8c0a00          VSTR     s0,[r12,#0]           ;1811
00007a  4282              CMP      r2,r0                 ;1810
00007c  dbed              BLT      |L395.90|
                  |L395.126|
00007e  1c5b              ADDS     r3,r3,#1              ;1805
000080  428b              CMP      r3,r1                 ;1805
000082  dbe2              BLT      |L395.74|
                  |L395.132|
000084  b003              ADD      sp,sp,#0xc
000086  2000              MOVS     r0,#0                 ;1815
000088  bdf0              POP      {r4-r7,pc}
;;;1817   
                          ENDP

00008a  0000              DCW      0x0000
                  |L395.140|
                          DCD      _ZZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_bE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::MakeSymmetric<Anki::Embedded::Array<float>>(T1&, bool)::__PRETTY_FUNCTION__
                  |L395.144|
000090  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000094  6f726574
000098  6563685c
00009c  636f6d6d
0000a0  6f6e5c69
0000a4  6e636c75
0000a8  64655c61
0000ac  6e6b692f
0000b0  636f6d6d
0000b4  6f6e2f72
0000b8  6f626f74
0000bc  2f6d6174
0000c0  726978  
0000c3  2e6800            DCB      ".h",0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L395.200|
0000c8  496e7075          DCB      "Input array must be square",0
0000cc  74206172
0000d0  72617920
0000d4  6d757374
0000d8  20626520
0000dc  73717561
0000e0  726500  
0000e3  00                DCB      0
                  |L395.228|
0000e4  4d616b65          DCB      "MakeSymmetric",0
0000e8  53796d6d
0000ec  65747269
0000f0  6300    
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||area_number.396||, COMGROUP=_ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b, LINKORDER=||t._ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.396||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5PointIfEC1Ev||, COMGROUP=_ZN4Anki8Embedded5PointIfEC1Ev, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5PointIfEC2Ev                  ; Alternate entry point ; Anki::Embedded::Point<float>::Point__sub_object()
                  _ZN4Anki8Embedded5PointIfEC1Ev PROC ; Anki::Embedded::Point<float>::Point()
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
000000  ed9f0a03          VLDR     s0,|L402.16|
000004  ed800a00          VSTR     s0,[r0,#0]
000008  ed800a01          VSTR     s0,[r0,#4]
00000c  4770              BX       lr
                          ENDP

00000e  0000              DCW      0x0000
                  |L402.16|
000010  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.403||, COMGROUP=_ZN4Anki8Embedded5PointIfEC1Ev, LINKORDER=||t._ZN4Anki8Embedded5PointIfEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.403||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5PointIfEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi PROC ; Anki::Embedded::Array<float>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L409.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L409.56|
00000e  4b0b              LDR      r3,|L409.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f1030250          ADD      r2,r3,#0x50
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L409.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L409.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::get_size(int) const::__PRETTY_FUNCTION__
                  |L409.60|
                          DCD      ||.constdata||+0xa94

                          AREA ||area_number.410||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.410||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded8AreValidINS0_5ArrayIfEES3_EEbRKT_RKT0_||, COMGROUP=_ZN4Anki8Embedded8AreValidINS0_5ArrayIfEES3_EEbRKT_RKT0_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded8AreValidINS0_5ArrayIfEES3_EEbRKT_RKT0_ PROC ; Anki::Embedded::AreValid<Anki::Embedded::Array<float>, Anki::Embedded::Array<float>>(const T1&, const T2&)
;;;80     
;;;81         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2)
000000  6902              LDR      r2,[r0,#0x10]
;;;82         {
000002  b172              CBZ      r2,|L416.34|
000004  6802              LDR      r2,[r0,#0]
000006  2a00              CMP      r2,#0
000008  bfa4              ITT      GE
00000a  6840              LDRGE    r0,[r0,#4]
00000c  2800              CMPGE    r0,#0
00000e  db08              BLT      |L416.34|
000010  6908              LDR      r0,[r1,#0x10]
000012  b130              CBZ      r0,|L416.34|
000014  6808              LDR      r0,[r1,#0]
000016  2800              CMP      r0,#0
000018  bfa1              ITTTT    GE
00001a  6848              LDRGE    r0,[r1,#4]
00001c  2800              CMPGE    r0,#0
;;;83           if(!object1.IsValid() || !object2.IsValid())
;;;84             return false;
;;;85     
;;;86           return true;
00001e  2001              MOVGE    r0,#1
;;;87         }
000020  4770              BXGE     lr
                  |L416.34|
000022  2000              MOVS     r0,#0                 ;84
000024  4770              BX       lr
;;;88     
                          ENDP


                          AREA ||area_number.417||, COMGROUP=_ZN4Anki8Embedded8AreValidINS0_5ArrayIfEES3_EEbRKT_RKT0_, LINKORDER=||t._ZN4Anki8Embedded8AreValidINS0_5ArrayIfEES3_EEbRKT_RKT0_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.417||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded8AreValidINS0_5ArrayIfEES3_EEbRKT_RKT0_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIiEENS_6ResultEPKcRKT_PPvRi||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIiEENS_6ResultEPKcRKT_PPvRi, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIiEENS_6ResultEPKcRKT_PPvRi PROC ; Anki::Embedded::SerializedBuffer::SerializeRawBasicType<int>(const char*, const T1&, void**, int&)
;;;133    
;;;134        template<typename Type> Result SerializedBuffer::SerializeRawBasicType(const char *objectName, const Type &in, void ** buffer, s32 &bufferLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;135        {
;;;136          return SerializeRawBasicType(objectName, &in, 1, buffer, bufferLength);
000004  460f              MOV      r7,r1
000006  4601              MOV      r1,r0
000008  461d              MOV      r5,r3                 ;135
00000a  4614              MOV      r4,r2                 ;135
00000c  2601              MOVS     r6,#1
00000e  4812              LDR      r0,|L423.88|
000010  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeDescriptionStrings(const char*, const char*, void**, int&)
000014  2800              CMP      r0,#0
000016  bf1c              ITT      NE
000018  2001              MOVNE    r0,#1
;;;137        }
00001a  e8bd81f0          POPNE    {r4-r8,pc}
00001e  6828              LDR      r0,[r5,#0]
000020  2808              CMP      r0,#8
000022  db0a              BLT      |L423.58|
000024  6821              LDR      r1,[r4,#0]
000026  480d              LDR      r0,|L423.92|
000028  6008              STR      r0,[r1,#0]
00002a  6820              LDR      r0,[r4,#0]
00002c  6046              STR      r6,[r0,#4]
00002e  6820              LDR      r0,[r4,#0]
000030  3008              ADDS     r0,r0,#8
000032  6020              STR      r0,[r4,#0]
000034  6828              LDR      r0,[r5,#0]
000036  3808              SUBS     r0,r0,#8
000038  6028              STR      r0,[r5,#0]
                  |L423.58|
00003a  2204              MOVS     r2,#4
00003c  4639              MOV      r1,r7
00003e  6820              LDR      r0,[r4,#0]
000040  f7fffffe          BL       __aeabi_memcpy
000044  6820              LDR      r0,[r4,#0]
000046  1d00              ADDS     r0,r0,#4
000048  6020              STR      r0,[r4,#0]
00004a  6828              LDR      r0,[r5,#0]
00004c  1f00              SUBS     r0,r0,#4
00004e  6028              STR      r0,[r5,#0]
000050  2000              MOVS     r0,#0
000052  e8bd81f0          POP      {r4-r8,pc}
;;;138    
                          ENDP

000056  0000              DCW      0x0000
                  |L423.88|
                          DCD      ||.constdata||+0xaf8
                  |L423.92|
                          DCD      0x00040007

                          AREA ||area_number.424||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIiEENS_6ResultEPKcRKT_PPvRi, LINKORDER=||t._ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIiEENS_6ResultEPKcRKT_PPvRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.424||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIiEENS_6ResultEPKcRKT_PPvRi||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi PROC ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L430.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L430.56|
00000e  4b0b              LDR      r3,|L430.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f1030250          ADD      r2,r3,#0x50
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L430.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L430.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const::__PRETTY_FUNCTION__
                  |L430.60|
                          DCD      ||.constdata||+0xa94

                          AREA ||area_number.431||, COMGROUP=_ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.431||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRi||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRi, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRi PROC ; Anki::Embedded::SerializedBuffer::SerializeRawArraySlice<Anki::Embedded::Point<short>>(const char*, const Anki::Embedded::ConstArraySlice<T1>&, void**, int&)
;;;186    
;;;187        template<typename Type> Result SerializedBuffer::SerializeRawArraySlice(const char *objectName, const ConstArraySlice<Type> &in, void ** buffer, s32 &bufferLength)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;188        {
000004  460d              MOV      r5,r1
000006  6a89              LDR      r1,[r1,#0x28]
;;;189          AnkiConditionalErrorAndReturnValue(in.IsValid(),
000008  4f73              LDR      r7,|L437.472|
00000a  b087              SUB      sp,sp,#0x1c           ;188
00000c  461e              MOV      r6,r3                 ;188
00000e  4614              MOV      r4,r2                 ;188
000010  2900              CMP      r1,#0                 ;188
000012  d02e              BEQ      |L437.114|
000014  69a9              LDR      r1,[r5,#0x18]         ;188
000016  2900              CMP      r1,#0                 ;188
000018  bfa4              ITT      GE                    ;188
00001a  69e9              LDRGE    r1,[r5,#0x1c]         ;188
00001c  2900              CMPGE    r1,#0                 ;188
00001e  db28              BLT      |L437.114|
;;;190            RESULT_FAIL, "SerializedBuffer::SerializeRawArraySlice", "in ArraySlice is not Valid");
;;;191    
;;;192          if(SerializeDescriptionStrings("ArraySlice", objectName, buffer, bufferLength) != RESULT_OK)
000020  4601              MOV      r1,r0
000022  a06e              ADR      r0,|L437.476|
000024  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeDescriptionStrings(const char*, const char*, void**, int&)
000028  2800              CMP      r0,#0
;;;193            return RESULT_FAIL;
00002a  bf1e              ITTT     NE
00002c  2001              MOVNE    r0,#1
;;;194    
;;;195          // NOTE: these parameters are the size that will be transmitted, not the original size
;;;196          const u32 height = in.get_ySlice().get_size();
;;;197          const u32 width = in.get_xSlice().get_size();
;;;198          const u32 stride = width*sizeof(Type);
;;;199    
;;;200          const s32 numRequiredBytes = height*stride + SerializedBuffer::EncodedArraySlice::CODE_LENGTH;
;;;201    
;;;202          AnkiConditionalErrorAndReturnValue(bufferLength >= numRequiredBytes,
;;;203            RESULT_FAIL_OUT_OF_MEMORY, "SerializedBuffer::SerializeRawArraySlice", "buffer needs at least %d bytes", numRequiredBytes);
;;;204    
;;;205          SerializedBuffer::EncodedArraySlice::Serialize<Type>(true, in, buffer, bufferLength);
;;;206    
;;;207          // TODO: this could be done more efficiently
;;;208          Type * restrict pDataType = reinterpret_cast<Type*>(*buffer);
;;;209          s32 iData = 0;
;;;210    
;;;211          const LinearSequence<s32>& ySlice = in.get_ySlice();
;;;212          const LinearSequence<s32>& xSlice = in.get_xSlice();
;;;213    
;;;214          const s32 yStart = ySlice.get_start();
;;;215          const s32 yIncrement = ySlice.get_increment();
;;;216          const s32 ySize = ySlice.get_size();
;;;217    
;;;218          const s32 xStart = xSlice.get_start();
;;;219          const s32 xIncrement = xSlice.get_increment();
;;;220          const s32 xSize = xSlice.get_size();
;;;221    
;;;222          for(s32 iy=0; iy<ySize; iy++) {
;;;223            const s32 y = yStart + iy * yIncrement;
;;;224            const Type * restrict pInData = in.get_array().Pointer(y, 0);
;;;225    
;;;226            for(s32 ix=0; ix<xSize; ix++) {
;;;227              const s32 x = xStart + ix * xIncrement;
;;;228              pDataType[iData] = pInData[x];
;;;229              iData++;
;;;230            }
;;;231          }
;;;232    
;;;233          AnkiAssert(iData == stride*height);
;;;234    
;;;235          *buffer = reinterpret_cast<u8*>(*buffer) + stride*height;
;;;236          bufferLength -= stride*height;
;;;237    
;;;238          return RESULT_OK;
;;;239        }
00002e  b007              ADDNE    sp,sp,#0x1c
000030  e8bd8ff0          POPNE    {r4-r11,pc}
000034  f8d5a000          LDR      r10,[r5,#0]           ;196
000038  f8cda008          STR      r10,[sp,#8]           ;196
00003c  f8d5900c          LDR      r9,[r5,#0xc]          ;198
000040  f105080c          ADD      r8,r5,#0xc            ;198
000044  ea4f0089          LSL      r0,r9,#2              ;198
000048  9003              STR      r0,[sp,#0xc]          ;200
00004a  fb0af000          MUL      r0,r10,r0             ;200
00004e  6831              LDR      r1,[r6,#0]            ;202
000050  3030              ADDS     r0,r0,#0x30           ;200
000052  4281              CMP      r1,r0                 ;202
000054  da1a              BGE      |L437.140|
000056  21ca              MOVS     r1,#0xca              ;202
000058  9700              STR      r7,[sp,#0]            ;202
00005a  e9cd1001          STRD     r1,r0,[sp,#4]         ;202
00005e  a362              ADR      r3,|L437.488|
000060  a270              ADR      r2,|L437.548|
000062  a178              ADR      r1,|L437.580|
000064  2005              MOVS     r0,#5                 ;202
000066  f7fffffe          BL       _Anki_Log
00006a  b007              ADD      sp,sp,#0x1c
00006c  4880              LDR      r0,|L437.624|
00006e  e8bd8ff0          POP      {r4-r11,pc}
                  |L437.114|
000072  20bd              MOVS     r0,#0xbd              ;189
000074  e9cd7000          STRD     r7,r0,[sp,#0]         ;189
000078  a35b              ADR      r3,|L437.488|
00007a  a27e              ADR      r2,|L437.628|
00007c  a171              ADR      r1,|L437.580|
00007e  2005              MOVS     r0,#5                 ;189
000080  f7fffffe          BL       _Anki_Log
000084  b007              ADD      sp,sp,#0x1c
000086  2001              MOVS     r0,#1                 ;189
000088  e8bd8ff0          POP      {r4-r11,pc}
                  |L437.140|
00008c  f1050718          ADD      r7,r5,#0x18
000090  2930              CMP      r1,#0x30
000092  db54              BLT      |L437.318|
000094  6aa8              LDR      r0,[r5,#0x28]
000096  2800              CMP      r0,#0
000098  d07e              BEQ      |L437.408|
00009a  69a8              LDR      r0,[r5,#0x18]
00009c  2800              CMP      r0,#0
00009e  bfa4              ITT      GE
0000a0  69e8              LDRGE    r0,[r5,#0x1c]
0000a2  2800              CMPGE    r0,#0
0000a4  db78              BLT      |L437.408|
0000a6  6869              LDR      r1,[r5,#4]
0000a8  9106              STR      r1,[sp,#0x18]
0000aa  68a8              LDR      r0,[r5,#8]
0000ac  9005              STR      r0,[sp,#0x14]
0000ae  f8d80004          LDR      r0,[r8,#4]
0000b2  9004              STR      r0,[sp,#0x10]
0000b4  f8d80008          LDR      r0,[r8,#8]
0000b8  9001              STR      r0,[sp,#4]
0000ba  2100              MOVS     r1,#0
0000bc  4638              MOV      r0,r7
0000be  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const
0000c2  4683              MOV      r11,r0
0000c4  2101              MOVS     r1,#1
0000c6  4638              MOV      r0,r7
0000c8  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const
0000cc  6831              LDR      r1,[r6,#0]
0000ce  fb0bf000          MUL      r0,r11,r0
0000d2  2908              CMP      r1,#8
0000d4  db05              BLT      |L437.226|
0000d6  6822              LDR      r2,[r4,#0]
0000d8  f44f2180          MOV      r1,#0x40000
0000dc  6011              STR      r1,[r2,#0]
0000de  6821              LDR      r1,[r4,#0]
0000e0  6048              STR      r0,[r1,#4]
                  |L437.226|
0000e2  2100              MOVS     r1,#0
0000e4  4638              MOV      r0,r7
0000e6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const
0000ea  6821              LDR      r1,[r4,#0]
0000ec  6088              STR      r0,[r1,#8]
0000ee  2101              MOVS     r1,#1
0000f0  4638              MOV      r0,r7
0000f2  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const
0000f6  6821              LDR      r1,[r4,#0]
0000f8  60c8              STR      r0,[r1,#0xc]
0000fa  6821              LDR      r1,[r4,#0]
0000fc  68b8              LDR      r0,[r7,#8]
0000fe  6108              STR      r0,[r1,#0x10]
000100  68f8              LDR      r0,[r7,#0xc]
000102  9000              STR      r0,[sp,#0]
000104  4668              MOV      r0,sp
000106  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer12get_rawFlagsEv ; Anki::Embedded::Flags::Buffer::get_rawFlags() const
00010a  6821              LDR      r1,[r4,#0]
00010c  6148              STR      r0,[r1,#0x14]
00010e  6821              LDR      r1,[r4,#0]
000110  9806              LDR      r0,[sp,#0x18]
000112  6188              STR      r0,[r1,#0x18]
000114  6821              LDR      r1,[r4,#0]
000116  9805              LDR      r0,[sp,#0x14]
000118  61c8              STR      r0,[r1,#0x1c]
00011a  6820              LDR      r0,[r4,#0]
00011c  f8c0a020          STR      r10,[r0,#0x20]
000120  6821              LDR      r1,[r4,#0]
000122  9804              LDR      r0,[sp,#0x10]
000124  6248              STR      r0,[r1,#0x24]
000126  6821              LDR      r1,[r4,#0]
000128  9801              LDR      r0,[sp,#4]
00012a  6288              STR      r0,[r1,#0x28]
00012c  6820              LDR      r0,[r4,#0]
00012e  f8c0902c          STR      r9,[r0,#0x2c]
000132  6820              LDR      r0,[r4,#0]
000134  3030              ADDS     r0,r0,#0x30
000136  6020              STR      r0,[r4,#0]
000138  6830              LDR      r0,[r6,#0]
00013a  3830              SUBS     r0,r0,#0x30
00013c  6030              STR      r0,[r6,#0]
                  |L437.318|
00013e  f8d4a000          LDR      r10,[r4,#0]
000142  6868              LDR      r0,[r5,#4]            ;214
000144  9000              STR      r0,[sp,#0]            ;214
000146  68a8              LDR      r0,[r5,#8]            ;215
000148  9001              STR      r0,[sp,#4]            ;215
00014a  6828              LDR      r0,[r5,#0]            ;216
00014c  9004              STR      r0,[sp,#0x10]         ;216
00014e  e9d8b901          LDRD     r11,r9,[r8,#4]        ;216
000152  2100              MOVS     r1,#0                 ;209
000154  f8d88000          LDR      r8,[r8,#0]            ;209
000158  460d              MOV      r5,r1                 ;222
00015a  2800              CMP      r0,#0                 ;222
00015c  dd21              BLE      |L437.418|
                  |L437.350|
00015e  e9dd0200          LDRD     r0,r2,[sp,#0]         ;222
000162  fb050002          MLA      r0,r5,r2,r0           ;223
000166  68bb              LDR      r3,[r7,#8]            ;223
000168  693a              LDR      r2,[r7,#0x10]         ;223
00016a  fb002e03          MLA      lr,r0,r3,r2           ;223
00016e  2000              MOVS     r0,#0                 ;226
000170  f1b80f00          CMP      r8,#0                 ;226
000174  dd0f              BLE      |L437.406|
                  |L437.374|
000176  fb00b209          MLA      r2,r0,r9,r11          ;227
00017a  eb0a0c81          ADD      r12,r10,r1,LSL #2     ;228
00017e  eb0e0282          ADD      r2,lr,r2,LSL #2       ;228
000182  1c49              ADDS     r1,r1,#1              ;229
000184  8813              LDRH     r3,[r2,#0]            ;229
000186  f8ac3000          STRH     r3,[r12,#0]           ;229
00018a  8852              LDRH     r2,[r2,#2]            ;229
00018c  1c40              ADDS     r0,r0,#1              ;226
00018e  f8ac2002          STRH     r2,[r12,#2]           ;226
000192  4580              CMP      r8,r0                 ;226
000194  dcef              BGT      |L437.374|
                  |L437.406|
000196  e000              B        |L437.410|
                  |L437.408|
000198  e013              B        |L437.450|
                  |L437.410|
00019a  9804              LDR      r0,[sp,#0x10]         ;222
00019c  1c6d              ADDS     r5,r5,#1              ;222
00019e  4285              CMP      r5,r0                 ;222
0001a0  dbdd              BLT      |L437.350|
                  |L437.418|
0001a2  e9dd1002          LDRD     r1,r0,[sp,#8]         ;235
0001a6  6822              LDR      r2,[r4,#0]            ;235
0001a8  fb002001          MLA      r0,r0,r1,r2           ;235
0001ac  6020              STR      r0,[r4,#0]            ;236
0001ae  e9dd1002          LDRD     r1,r0,[sp,#8]         ;236
0001b2  6832              LDR      r2,[r6,#0]            ;236
0001b4  fb002011          MLS      r0,r0,r1,r2           ;236
0001b8  6030              STR      r0,[r6,#0]            ;238
0001ba  b007              ADD      sp,sp,#0x1c
0001bc  2000              MOVS     r0,#0                 ;238
0001be  e8bd8ff0          POP      {r4-r11,pc}
                  |L437.450|
0001c2  2166              MOVS     r1,#0x66
0001c4  4832              LDR      r0,|L437.656|
0001c6  e9cd0100          STRD     r0,r1,[sp,#0]
0001ca  a307              ADR      r3,|L437.488|
0001cc  a231              ADR      r2,|L437.660|
0001ce  a136              ADR      r1,|L437.680|
0001d0  2005              MOVS     r0,#5
0001d2  f7fffffe          BL       _Anki_Log
0001d6  e7b2              B        |L437.318|
;;;240    
                          ENDP

                  |L437.472|
                          DCD      _ZZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::SerializeRawArraySlice<Anki::Embedded::Point<short>>(const char*, const Anki::Embedded::ConstArraySlice<T1>&, void**, int&)::__PRETTY_FUNCTION__
                  |L437.476|
0001dc  41727261          DCB      "ArraySlice",0
0001e0  79536c69
0001e4  636500  
0001e7  00                DCB      0
                  |L437.488|
0001e8  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/serial"
0001ec  6f726574
0001f0  6563685c
0001f4  636f6d6d
0001f8  6f6e5c69
0001fc  6e636c75
000200  64655c61
000204  6e6b692f
000208  636f6d6d
00020c  6f6e2f72
000210  6f626f74
000214  2f736572
000218  69616c  
00021b  697a652e          DCB      "ize.h",0
00021f  6800    
000221  00                DCB      0
000222  00                DCB      0
000223  00                DCB      0
                  |L437.548|
000224  62756666          DCB      "buffer needs at least %d bytes",0
000228  6572206e
00022c  65656473
000230  20617420
000234  6c656173
000238  74202564
00023c  20627974
000240  657300  
000243  00                DCB      0
                  |L437.580|
000244  53657269          DCB      "SerializedBuffer::SerializeRawArraySlice",0
000248  616c697a
00024c  65644275
000250  66666572
000254  3a3a5365
000258  7269616c
00025c  697a6552
000260  61774172
000264  72617953
000268  6c696365
00026c  00      
00026d  00                DCB      0
00026e  00                DCB      0
00026f  00                DCB      0
                  |L437.624|
                          DCD      0x01000001
                  |L437.628|
000274  696e2041          DCB      "in ArraySlice is not Valid",0
000278  72726179
00027c  536c6963
000280  65206973
000284  206e6f74
000288  2056616c
00028c  696400  
00028f  00                DCB      0
                  |L437.656|
                          DCD      _ZZN4Anki8Embedded16SerializedBuffer17EncodedArraySlice9SerializeINS0_5PointIsEEEENS_6ResultEbRKNS0_15ConstArraySliceIT_EEPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::EncodedArraySlice::Serialize<Anki::Embedded::Point<short>>(bool, const Anki::Embedded::ConstArraySlice<T1>&, void**, int&)::__PRETTY_FUNCTION__
                  |L437.660|
000294  696e2041          DCB      "in Array is invalid",0
000298  72726179
00029c  20697320
0002a0  696e7661
0002a4  6c696400
                  |L437.680|
0002a8  53657269          DCB      "SerializedBuffer::EncodedArraySlice",0
0002ac  616c697a
0002b0  65644275
0002b4  66666572
0002b8  3a3a456e
0002bc  636f6465
0002c0  64417272
0002c4  6179536c
0002c8  69636500

                          AREA ||area_number.438||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRi, LINKORDER=||t._ZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.438||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRi||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRi, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRi PROC ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<int>(char*, void**, int&)
;;;245    
;;;246        template<typename Type> Type SerializedBuffer::DeserializeRawBasicType(char *objectName, void ** buffer, s32 &bufferLength)
000000  b530              PUSH     {r4,r5,lr}
;;;247        {
000002  4614              MOV      r4,r2
;;;248          // TODO: check if description is valid
;;;249          DeserializeDescriptionStrings(NULL, objectName, buffer, bufferLength);
000004  4613              MOV      r3,r2
000006  460d              MOV      r5,r1                 ;247
000008  460a              MOV      r2,r1
00000a  4601              MOV      r1,r0
00000c  b08d              SUB      sp,sp,#0x34           ;247
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi ; Anki::Embedded::SerializedBuffer::DeserializeDescriptionStrings(char*, char*, void**, int&)
;;;250    
;;;251          // TODO: check if encoded type is valid
;;;252          u16 sizeOfType;
;;;253          bool isBasicType;
;;;254          bool isInteger;
;;;255          bool isSigned;
;;;256          bool isFloat;
;;;257          bool isString;
;;;258          s32 numElements;
;;;259          EncodedBasicTypeBuffer::Deserialize(true, sizeOfType, isBasicType, isInteger, isSigned, isFloat, isString, numElements, buffer, bufferLength);
000014  a807              ADD      r0,sp,#0x1c
000016  a90c              ADD      r1,sp,#0x30
000018  e9cd1002          STRD     r1,r0,[sp,#8]
00001c  a80b              ADD      r0,sp,#0x2c
00001e  a90a              ADD      r1,sp,#0x28
000020  e9cd1000          STRD     r1,r0,[sp,#0]
000024  e9cd5404          STRD     r5,r4,[sp,#0x10]
000028  ab09              ADD      r3,sp,#0x24
00002a  aa08              ADD      r2,sp,#0x20
00002c  a906              ADD      r1,sp,#0x18
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer22EncodedBasicTypeBuffer11DeserializeEbRtRbS4_S4_S4_S4_RiPPvS5_ ; Anki::Embedded::SerializedBuffer::EncodedBasicTypeBuffer::Deserialize(bool, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
;;;260    
;;;261          const Type var = *reinterpret_cast<Type*>(*buffer);
000034  682b              LDR      r3,[r5,#0]
;;;262    
;;;263          AnkiConditionalErrorAndReturnValue(sizeOfType < 10000 && numElements > 0 && numElements < 1000000,
000036  f8bd2018          LDRH     r2,[sp,#0x18]
00003a  f2427110          MOV      r1,#0x2710
00003e  6818              LDR      r0,[r3,#0]
000040  428a              CMP      r2,r1
000042  d206              BCS      |L444.82|
000044  9907              LDR      r1,[sp,#0x1c]
000046  2900              CMP      r1,#0
000048  bfc4              ITT      GT
00004a  f8dfc038          LDRGT    r12,|L444.132|
00004e  458c              CMPGT    r12,r1
000050  dc0f              BGT      |L444.114|
                  |L444.82|
000052  f2401107          MOV      r1,#0x107
000056  480c              LDR      r0,|L444.136|
000058  4b0c              LDR      r3,|L444.140|
00005a  e9cd0100          STRD     r0,r1,[sp,#0]
00005e  f1a30224          SUB      r2,r3,#0x24
000062  f1a2012c          SUB      r1,r2,#0x2c
000066  2005              MOVS     r0,#5
000068  f7fffffe          BL       _Anki_Log
;;;264            Type(), "SerializedBuffer::DeserializeRawBasicType", "Unreasonable deserialized values");
;;;265    
;;;266          *buffer = reinterpret_cast<u8*>(*buffer) + sizeOfType*numElements;
;;;267          bufferLength -= sizeOfType*numElements;
;;;268    
;;;269          return var;
;;;270        }
00006c  b00d              ADD      sp,sp,#0x34
00006e  2000              MOVS     r0,#0                 ;263
000070  bd30              POP      {r4,r5,pc}
                  |L444.114|
000072  fb023301          MLA      r3,r2,r1,r3           ;266
000076  602b              STR      r3,[r5,#0]            ;267
000078  6823              LDR      r3,[r4,#0]            ;267
00007a  fb023111          MLS      r1,r2,r1,r3           ;267
00007e  6021              STR      r1,[r4,#0]            ;267
000080  b00d              ADD      sp,sp,#0x34
000082  bd30              POP      {r4,r5,pc}
;;;271    
                          ENDP

                  |L444.132|
                          DCD      0x000f4240
                  |L444.136|
                          DCD      _ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<int>(char*, void**, int&)::__PRETTY_FUNCTION__
                  |L444.140|
                          DCD      ||.constdata||+0xb5c

                          AREA ||area_number.445||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRi, LINKORDER=||t._ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.445||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC2Ev                  ; Alternate entry point ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList__sub_object()
                  _ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::FixedLengthList()
;;;52     
;;;53         template<typename Type> FixedLengthList<Type>::FixedLengthList()
;;;54           : ArraySlice<Type>()
;;;55         {
;;;56           this->arrayData = NULL;
;;;57           this->set_size(0);
;;;58         } // FixedLengthList<Type>::FixedLengthList()
;;;59     
000000  b570              PUSH     {r4-r6,lr}
000002  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1Ev ; Anki::Embedded::ArraySlice<Anki::Embedded::Point<short>>::ArraySlice()
000006  4604              MOV      r4,r0
000008  2000              MOVS     r0,#0
00000a  4605              MOV      r5,r0
00000c  6320              STR      r0,[r4,#0x30]
00000e  2101              MOVS     r1,#1
000010  f1040018          ADD      r0,r4,#0x18
000014  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const
000018  42a8              CMP      r0,r5
00001a  da05              BGE      |L451.40|
00001c  2101              MOVS     r1,#1
00001e  f1040018          ADD      r0,r4,#0x18
000022  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const
000026  4605              MOV      r5,r0
                  |L451.40|
000028  4620              MOV      r0,r4
00002a  60e5              STR      r5,[r4,#0xc]
00002c  bd70              POP      {r4-r6,pc}
                          ENDP


                          AREA ||area_number.452||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.452||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIsEEEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_||, COMGROUP=_ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC2ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_                  ; Alternate entry point ; Anki::Embedded::ArraySlice<Anki::Embedded::Point<short>>::ArraySlice__sub_object(Anki::Embedded::Array<Anki::Embedded::Point<short>>, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
                  _ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_ PROC ; Anki::Embedded::ArraySlice<Anki::Embedded::Point<short>>::ArraySlice(Anki::Embedded::Array<Anki::Embedded::Point<short>>, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
;;;88     
;;;89         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;90           : ConstArraySlice<Type>(array, ySlice, xSlice)
;;;91         {
;;;92           if(array.get_numElements() == 0) {
;;;93             this->arrayData = NULL;
;;;94           } else {
;;;95             this->arrayData = array.Pointer(0,0);
;;;96           }
;;;97         }
;;;98     
000000  e92d01f0          PUSH     {r4-r8}
000004  e9dd4507          LDRD     r4,r5,[sp,#0x1c]
000008  e9dd6c05          LDRD     r6,r12,[sp,#0x14]
00000c  e9d47800          LDRD     r7,r8,[r4,#0]
000010  68a4              LDR      r4,[r4,#8]
000012  6007              STR      r7,[r0,#0]
000014  e9c08401          STRD     r8,r4,[r0,#4]
000018  e9d54700          LDRD     r4,r7,[r5,#0]
00001c  68ad              LDR      r5,[r5,#8]
00001e  e9c05105          STRD     r5,r1,[r0,#0x14]
000022  f100081c          ADD      r8,r0,#0x1c
000026  2500              MOVS     r5,#0
000028  e8a8104c          STM      r8!,{r2,r3,r6,r12}
00002c  e9c04703          STRD     r4,r7,[r0,#0xc]
000030  2900              CMP      r1,#0
000032  bfc8              IT       GT
000034  2a00              CMPGT    r2,#0
000036  dd13              BLE      |L458.96|
000038  fb01f402          MUL      r4,r1,r2
00003c  b184              CBZ      r4,|L458.96|
00003e  2400              MOVS     r4,#0
000040  fb04c403          MLA      r4,r4,r3,r12
000044  62c4              STR      r4,[r0,#0x2c]
                  |L458.70|
000046  2900              CMP      r1,#0
000048  bfc8              IT       GT
00004a  2a00              CMPGT    r2,#0
00004c  dd0a              BLE      |L458.100|
00004e  4351              MULS     r1,r2,r1
000050  b141              CBZ      r1,|L458.100|
000052  2100              MOVS     r1,#0
000054  fb01c103          MLA      r1,r1,r3,r12
000058  6301              STR      r1,[r0,#0x30]
00005a  e8bd01f0          POP      {r4-r8}
00005e  4770              BX       lr
                  |L458.96|
000060  62c5              STR      r5,[r0,#0x2c]
000062  e7f0              B        |L458.70|
                  |L458.100|
000064  6305              STR      r5,[r0,#0x30]
000066  e8bd01f0          POP      {r4-r8}
00006a  4770              BX       lr
                          ENDP


                          AREA ||area_number.459||, COMGROUP=_ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_, LINKORDER=||t._ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.459||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded16SerializedBuffer24DeserializeRawArraySliceINS0_5PointIsEEEENS0_10ArraySliceIT_EEPcPPvRiRNS0_11MemoryStackE||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer24DeserializeRawArraySliceINS0_5PointIsEEEENS0_10ArraySliceIT_EEPcPPvRiRNS0_11MemoryStackE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer24DeserializeRawArraySliceINS0_5PointIsEEEENS0_10ArraySliceIT_EEPcPPvRiRNS0_11MemoryStackE PROC ; Anki::Embedded::SerializedBuffer::DeserializeRawArraySlice<Anki::Embedded::Point<short>>(char*, void**, int&, Anki::Embedded::MemoryStack&)
;;;358    
;;;359        template<typename Type> ArraySlice<Type> SerializedBuffer::DeserializeRawArraySlice(char *objectName, void ** buffer, s32 &bufferLength, MemoryStack &memory)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;360        {
000004  b0bb              SUB      sp,sp,#0xec
000006  4604              MOV      r4,r0
000008  461f              MOV      r7,r3
00000a  4690              MOV      r8,r2
;;;361          // TODO: check if description is valid
;;;362          DeserializeDescriptionStrings(NULL, objectName, buffer, bufferLength);
00000c  2000              MOVS     r0,#0
00000e  9d44              LDR      r5,[sp,#0x110]
000010  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi ; Anki::Embedded::SerializedBuffer::DeserializeDescriptionStrings(char*, char*, void**, int&)
;;;363    
;;;364          // TODO: check if encoded type is valid
;;;365          s32 height;
;;;366          s32 width;
;;;367          s32 stride;
;;;368          Flags::Buffer flags;
000014  a833              ADD      r0,sp,#0xcc
000016  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
;;;369          s32 ySlice_start;
;;;370          s32 ySlice_increment;
;;;371          s32 ySlice_size;
;;;372          s32 xSlice_start;
;;;373          s32 xSlice_increment;
;;;374          s32 xSlice_size;
;;;375          u16 basicType_sizeOfType;
;;;376          bool basicType_isBasicType;
;;;377          bool basicType_isInteger;
;;;378          bool basicType_isSigned;
;;;379          bool basicType_isFloat;
;;;380          bool basicType_isString;
;;;381          s32 basicType_numElements;
;;;382          EncodedArraySlice::Deserialize(true, height, width, stride, flags, ySlice_start, ySlice_increment, ySlice_size, xSlice_start, xSlice_increment, xSlice_size, basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString, basicType_numElements, buffer, bufferLength);
00001a  a832              ADD      r0,sp,#0xc8
00001c  a939              ADD      r1,sp,#0xe4
00001e  e9cd100c          STRD     r1,r0,[sp,#0x30]
000022  a838              ADD      r0,sp,#0xe0
000024  a937              ADD      r1,sp,#0xdc
000026  e9cd100a          STRD     r1,r0,[sp,#0x28]
00002a  aa36              ADD      r2,sp,#0xd8
00002c  ab35              ADD      r3,sp,#0xd4
00002e  e9cd3208          STRD     r3,r2,[sp,#0x20]
000032  a831              ADD      r0,sp,#0xc4
000034  a92f              ADD      r1,sp,#0xbc
000036  e9cd1006          STRD     r1,r0,[sp,#0x18]
00003a  aa29              ADD      r2,sp,#0xa4
00003c  ab28              ADD      r3,sp,#0xa0
00003e  e9cd3204          STRD     r3,r2,[sp,#0x10]
000042  aa2a              ADD      r2,sp,#0xa8
000044  ab33              ADD      r3,sp,#0xcc
000046  e9cd3200          STRD     r3,r2,[sp,#0]
00004a  a82e              ADD      r0,sp,#0xb8
00004c  a92b              ADD      r1,sp,#0xac
00004e  e9cd1002          STRD     r1,r0,[sp,#8]
000052  e9cd870e          STRD     r8,r7,[sp,#0x38]
000056  ab30              ADD      r3,sp,#0xc0
000058  aa2c              ADD      r2,sp,#0xb0
00005a  a92d              ADD      r1,sp,#0xb4
00005c  2001              MOVS     r0,#1
00005e  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer17EncodedArraySlice11DeserializeEbRiS3_S3_RNS0_5Flags6BufferES3_S3_S3_S3_S3_S3_RtRbS8_S8_S8_S8_S3_PPvS3_ ; Anki::Embedded::SerializedBuffer::EncodedArraySlice::Deserialize(bool, int&, int&, int&, Anki::Embedded::Flags::Buffer&, int&, int&, int&, int&, int&, int&, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
;;;383    
;;;384          AnkiConditionalErrorAndReturnValue(
000062  4983              LDR      r1,|L465.624|
000064  982d              LDR      r0,[sp,#0xb4]
000066  f8df920c          LDR      r9,|L465.628|
00006a  4288              CMP      r0,r1
00006c  d22b              BCS      |L465.198|
00006e  982c              LDR      r0,[sp,#0xb0]
000070  2800              CMP      r0,#0
000072  bfa4              ITT      GE
000074  f8dfb200          LDRGE    r11,|L465.632|
000078  4583              CMPGE    r11,r0
00007a  dd24              BLE      |L465.198|
00007c  9a30              LDR      r2,[sp,#0xc0]
00007e  2a00              CMP      r2,#0
000080  bfc8              IT       GT
000082  4593              CMPGT    r11,r2
000084  dd1f              BLE      |L465.198|
000086  f8dda0a8          LDR      r10,[sp,#0xa8]
00008a  f1ba0f00          CMP      r10,#0
00008e  bfa4              ITT      GE
000090  9e2b              LDRGE    r6,[sp,#0xac]
000092  2e00              CMPGE    r6,#0
000094  dd17              BLE      |L465.198|
000096  f8ddc0a0          LDR      r12,[sp,#0xa0]
00009a  f1bc0f00          CMP      r12,#0
00009e  bfa4              ITT      GE
0000a0  9929              LDRGE    r1,[sp,#0xa4]
0000a2  2900              CMPGE    r1,#0
0000a4  bfc4              ITT      GT
0000a6  4b75              LDRGT    r3,|L465.636|
0000a8  428b              CMPGT    r3,r1
0000aa  dd0c              BLE      |L465.198|
0000ac  f8bd30c4          LDRH     r3,[sp,#0xc4]
0000b0  2b00              CMP      r3,#0
0000b2  bf1c              ITT      NE
0000b4  f2427e10          MOVNE    lr,#0x2710
0000b8  4573              CMPNE    r3,lr
0000ba  d204              BCS      |L465.198|
0000bc  9b32              LDR      r3,[sp,#0xc8]
0000be  2b00              CMP      r3,#0
0000c0  bfa8              IT       GE
0000c2  459b              CMPGE    r11,r3
0000c4  dc0f              BGT      |L465.230|
                  |L465.198|
0000c6  f44f70c0          MOV      r0,#0x180
0000ca  e9cd9000          STRD     r9,r0,[sp,#0]
0000ce  a36c              ADR      r3,|L465.640|
0000d0  a27a              ADR      r2,|L465.700|
0000d2  a183              ADR      r1,|L465.736|
0000d4  2005              MOVS     r0,#5
0000d6  f7fffffe          BL       _Anki_Log
0000da  4620              MOV      r0,r4
0000dc  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1Ev ; Anki::Embedded::ArraySlice<Anki::Embedded::Point<short>>::ArraySlice()
;;;385            height >= 0 && height < s32(1e9) &&
;;;386            width >= 0 && width < s32(2e9) &&
;;;387            stride > 0 && stride < s32(2e9) &&
;;;388            ySlice_start >= 0 &&  ySlice_increment > 0 &&
;;;389            xSlice_start >= 0 && xSlice_increment > 0 && xSlice_increment < 1000000 &&
;;;390            basicType_sizeOfType > 0 && basicType_sizeOfType < 10000 &&
;;;391            basicType_numElements >= 0 && basicType_numElements < s32(2e9),
;;;392    
;;;393            ArraySlice<Type>(), "SerializedBuffer::DeserializeRawArraySlice", "Unreasonable deserialized values");
;;;394    
;;;395          if(width > 0) {
;;;396            AnkiConditionalErrorAndReturnValue(stride == RoundUp(width*sizeof(Type), MEMORY_ALIGNMENT),
;;;397              ArraySlice<Type>(), "SerializedBuffer::DeserializeRawArraySlice", "Parsed stride is not reasonable");
;;;398          }
;;;399    
;;;400          const LinearSequence<s32> ySlice(ySlice_start, ySlice_increment, -1, ySlice_size);
;;;401          const LinearSequence<s32> xSlice(xSlice_start, xSlice_increment, -1, xSlice_size);
;;;402    
;;;403          AnkiConditionalErrorAndReturnValue(bufferLength >= static_cast<s32>(xSlice.get_size()*ySlice.get_size()*sizeof(Type)),
;;;404            ArraySlice<Type>(), "SerializedBuffer::DeserializeRawArraySlice", "Not enought bytes left to set the array");
;;;405    
;;;406          Array<Type> array(height, width, memory);
;;;407    
;;;408          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;409            ArraySlice<Type>(), "SerializedBuffer::DeserializeRawArraySlice", "Out of memory");
;;;410    
;;;411          // TODO: this could be done more efficiently
;;;412    
;;;413          Type * restrict pDataType = reinterpret_cast<Type*>(*buffer);
;;;414          s32 iData = 0;
;;;415    
;;;416          for(s32 iy=0; iy<ySlice_size; iy++) {
;;;417            const s32 y = ySlice_start + iy * ySlice_increment;
;;;418            Type * restrict pArrayData = array.Pointer(y, 0);
;;;419    
;;;420            for(s32 ix=0; ix<xSlice_size; ix++) {
;;;421              const s32 x = xSlice_start + ix * xSlice_increment;
;;;422              pArrayData[x] = pDataType[iData];
;;;423              iData++;
;;;424            }
;;;425          }
;;;426    
;;;427          const s32 numElements = xSlice.get_size()*ySlice.get_size();
;;;428    
;;;429          AnkiConditionalErrorAndReturnValue(iData == numElements,
;;;430            ArraySlice<Type>(), "SerializedBuffer::DeserializeRawArraySlice", "Deserialization error");
;;;431    
;;;432          ArraySlice<Type> out = ArraySlice<Type>(array, ySlice, xSlice);
;;;433    
;;;434          *buffer = reinterpret_cast<u8*>(*buffer) + numElements*sizeof(Type);
;;;435          bufferLength -= numElements*sizeof(Type);
;;;436    
;;;437          return out;
;;;438        }
0000e0  b03b              ADD      sp,sp,#0xec
0000e2  e8bd8ff0          POP      {r4-r11,pc}
                  |L465.230|
0000e6  2800              CMP      r0,#0                 ;395
0000e8  dd15              BLE      |L465.278|
0000ea  0080              LSLS     r0,r0,#2              ;396
0000ec  300f              ADDS     r0,r0,#0xf            ;396
0000ee  f020000f          BIC      r0,r0,#0xf            ;396
0000f2  4290              CMP      r0,r2                 ;396
0000f4  d00f              BEQ      |L465.278|
0000f6  f44f70c6          MOV      r0,#0x18c             ;396
0000fa  e9cd9000          STRD     r9,r0,[sp,#0]         ;396
0000fe  a360              ADR      r3,|L465.640|
000100  a282              ADR      r2,|L465.780|
000102  a177              ADR      r1,|L465.736|
000104  2005              MOVS     r0,#5                 ;396
000106  f7fffffe          BL       _Anki_Log
00010a  4620              MOV      r0,r4                 ;396
00010c  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1Ev ; Anki::Embedded::ArraySlice<Anki::Embedded::Point<short>>::ArraySlice()
000110  b03b              ADD      sp,sp,#0xec
000112  e8bd8ff0          POP      {r4-r11,pc}
                  |L465.278|
000116  982e              LDR      r0,[sp,#0xb8]
000118  e9cd0a22          STRD     r0,r10,[sp,#0x88]
00011c  9624              STR      r6,[sp,#0x90]
00011e  982f              LDR      r0,[sp,#0xbc]
000120  9127              STR      r1,[sp,#0x9c]
000122  e9cd0c25          STRD     r0,r12,[sp,#0x94]
000126  9922              LDR      r1,[sp,#0x88]         ;403
000128  4348              MULS     r0,r1,r0              ;403
00012a  6839              LDR      r1,[r7,#0]            ;403
00012c  ebb10f80          CMP      r1,r0,LSL #2          ;403
000130  da0f              BGE      |L465.338|
000132  f2401093          MOV      r0,#0x193             ;403
000136  e9cd9000          STRD     r9,r0,[sp,#0]         ;403
00013a  a351              ADR      r3,|L465.640|
00013c  a27b              ADR      r2,|L465.812|
00013e  a168              ADR      r1,|L465.736|
000140  2005              MOVS     r0,#5                 ;403
000142  f7fffffe          BL       _Anki_Log
000146  4620              MOV      r0,r4                 ;403
000148  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1Ev ; Anki::Embedded::ArraySlice<Anki::Embedded::Point<short>>::ArraySlice()
00014c  b03b              ADD      sp,sp,#0xec
00014e  e8bd8ff0          POP      {r4-r11,pc}
                  |L465.338|
000152  2300              MOVS     r3,#0                 ;406
000154  461a              MOV      r2,r3                 ;406
000156  2101              MOVS     r1,#1                 ;406
000158  a834              ADD      r0,sp,#0xd0           ;406
00015a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00015e  6800              LDR      r0,[r0,#0]            ;406
000160  9000              STR      r0,[sp,#0]            ;406
000162  e9dd212c          LDRD     r2,r1,[sp,#0xb0]      ;406
000166  462b              MOV      r3,r5                 ;406
000168  a81d              ADD      r0,sp,#0x74           ;406
00016a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_5PointIsEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00016e  9821              LDR      r0,[sp,#0x84]         ;406
000170  b170              CBZ      r0,|L465.400|
000172  981d              LDR      r0,[sp,#0x74]         ;406
000174  2800              CMP      r0,#0                 ;406
000176  bfa4              ITT      GE                    ;406
000178  981e              LDRGE    r0,[sp,#0x78]         ;406
00017a  2800              CMPGE    r0,#0                 ;406
00017c  db08              BLT      |L465.400|
00017e  992e              LDR      r1,[sp,#0xb8]         ;416
000180  f04f0c00          MOV      r12,#0                ;414
000184  f8d8a000          LDR      r10,[r8,#0]           ;416
000188  4660              MOV      r0,r12                ;416
00018a  2900              CMP      r1,#0                 ;416
00018c  dd32              BLE      |L465.500|
00018e  e00f              B        |L465.432|
                  |L465.400|
000190  f44f70cc          MOV      r0,#0x198             ;408
000194  e9cd9000          STRD     r9,r0,[sp,#0]         ;408
000198  a339              ADR      r3,|L465.640|
00019a  a26e              ADR      r2,|L465.852|
00019c  a150              ADR      r1,|L465.736|
00019e  2005              MOVS     r0,#5                 ;408
0001a0  f7fffffe          BL       _Anki_Log
0001a4  4620              MOV      r0,r4                 ;408
0001a6  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1Ev ; Anki::Embedded::ArraySlice<Anki::Embedded::Point<short>>::ArraySlice()
0001aa  b03b              ADD      sp,sp,#0xec
0001ac  e8bd8ff0          POP      {r4-r11,pc}
                  |L465.432|
0001b0  e9dd122a          LDRD     r1,r2,[sp,#0xa8]
0001b4  fb001102          MLA      r1,r0,r2,r1           ;417
0001b8  9b1f              LDR      r3,[sp,#0x7c]         ;417
0001ba  9a21              LDR      r2,[sp,#0x84]         ;417
0001bc  fb012303          MLA      r3,r1,r3,r2           ;417
0001c0  9a2f              LDR      r2,[sp,#0xbc]         ;420
0001c2  2100              MOVS     r1,#0                 ;420
0001c4  2a00              CMP      r2,#0                 ;420
0001c6  dd11              BLE      |L465.492|
                  |L465.456|
0001c8  e9dd2528          LDRD     r2,r5,[sp,#0xa0]      ;420
0001cc  fb012205          MLA      r2,r1,r5,r2           ;421
0001d0  eb0a058c          ADD      r5,r10,r12,LSL #2     ;422
0001d4  eb030682          ADD      r6,r3,r2,LSL #2       ;422
0001d8  882a              LDRH     r2,[r5,#0]            ;422
0001da  8032              STRH     r2,[r6,#0]            ;422
0001dc  886a              LDRH     r2,[r5,#2]            ;422
0001de  8072              STRH     r2,[r6,#2]            ;422
0001e0  9a2f              LDR      r2,[sp,#0xbc]         ;420
0001e2  1c49              ADDS     r1,r1,#1              ;420
0001e4  f10c0c01          ADD      r12,r12,#1            ;423
0001e8  428a              CMP      r2,r1                 ;420
0001ea  dced              BGT      |L465.456|
                  |L465.492|
0001ec  992e              LDR      r1,[sp,#0xb8]         ;416
0001ee  1c40              ADDS     r0,r0,#1              ;416
0001f0  4288              CMP      r0,r1                 ;416
0001f2  dbdd              BLT      |L465.432|
                  |L465.500|
0001f4  9922              LDR      r1,[sp,#0x88]         ;427
0001f6  9825              LDR      r0,[sp,#0x94]         ;427
0001f8  fb00f501          MUL      r5,r0,r1              ;427
0001fc  45ac              CMP      r12,r5                ;429
0001fe  d00f              BEQ      |L465.544|
000200  f24010ad          MOV      r0,#0x1ad             ;429
000204  e9cd9000          STRD     r9,r0,[sp,#0]         ;429
000208  a31d              ADR      r3,|L465.640|
00020a  a256              ADR      r2,|L465.868|
00020c  a134              ADR      r1,|L465.736|
00020e  2005              MOVS     r0,#5                 ;429
000210  f7fffffe          BL       _Anki_Log
000214  4620              MOV      r0,r4                 ;429
000216  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1Ev ; Anki::Embedded::ArraySlice<Anki::Embedded::Point<short>>::ArraySlice()
00021a  b03b              ADD      sp,sp,#0xec
00021c  e8bd8ff0          POP      {r4-r11,pc}
                  |L465.544|
000220  a925              ADD      r1,sp,#0x94           ;432
000222  a822              ADD      r0,sp,#0x88           ;432
000224  e9cd0102          STRD     r0,r1,[sp,#8]         ;432
000228  e9dd0120          LDRD     r0,r1,[sp,#0x80]      ;432
00022c  e9cd0100          STRD     r0,r1,[sp,#0]         ;432
000230  e9dd121d          LDRD     r1,r2,[sp,#0x74]      ;432
000234  a810              ADD      r0,sp,#0x40           ;432
000236  9b1f              LDR      r3,[sp,#0x7c]         ;432
000238  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceINS0_5PointIsEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_ ; Anki::Embedded::ArraySlice<Anki::Embedded::Point<short>>::ArraySlice(Anki::Embedded::Array<Anki::Embedded::Point<short>>, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
00023c  f8d80000          LDR      r0,[r8,#0]            ;434
000240  4269              RSBS     r1,r5,#0              ;435
000242  eb000085          ADD      r0,r0,r5,LSL #2       ;434
000246  f8c80000          STR      r0,[r8,#0]            ;435
00024a  6838              LDR      r0,[r7,#0]            ;435
00024c  f10d0940          ADD      r9,sp,#0x40           ;435
000250  eb000081          ADD      r0,r0,r1,LSL #2       ;435
000254  6038              STR      r0,[r7,#0]            ;435
000256  e8b910ef          LDM      r9!,{r0-r3,r5-r7,r12} ;435
00025a  e88410ef          STM      r4,{r0-r3,r5-r7,r12}  ;435
00025e  ae18              ADD      r6,sp,#0x60           ;435
000260  3420              ADDS     r4,r4,#0x20           ;435
000262  e8b6100f          LDM      r6!,{r0-r3,r12}       ;435
000266  e8a4100f          STM      r4!,{r0-r3,r12}       ;435
00026a  b03b              ADD      sp,sp,#0xec
00026c  e8bd8ff0          POP      {r4-r11,pc}
;;;439    
                          ENDP

                  |L465.624|
                          DCD      0x3b9aca00
                  |L465.628|
                          DCD      _ZZN4Anki8Embedded16SerializedBuffer24DeserializeRawArraySliceINS0_5PointIsEEEENS0_10ArraySliceIT_EEPcPPvRiRNS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawArraySlice<Anki::Embedded::Point<short>>(char*, void**, int&, Anki::Embedded::MemoryStack&)::__PRETTY_FUNCTION__
                  |L465.632|
                          DCD      0x77359400
                  |L465.636|
                          DCD      0x000f4240
                  |L465.640|
000280  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/serial"
000284  6f726574
000288  6563685c
00028c  636f6d6d
000290  6f6e5c69
000294  6e636c75
000298  64655c61
00029c  6e6b692f
0002a0  636f6d6d
0002a4  6f6e2f72
0002a8  6f626f74
0002ac  2f736572
0002b0  69616c  
0002b3  697a652e          DCB      "ize.h",0
0002b7  6800    
0002b9  00                DCB      0
0002ba  00                DCB      0
0002bb  00                DCB      0
                  |L465.700|
0002bc  556e7265          DCB      "Unreasonable deserialized values",0
0002c0  61736f6e
0002c4  61626c65
0002c8  20646573
0002cc  65726961
0002d0  6c697a65
0002d4  64207661
0002d8  6c756573
0002dc  00      
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0
                  |L465.736|
0002e0  53657269          DCB      "SerializedBuffer::DeserializeRawArraySlice",0
0002e4  616c697a
0002e8  65644275
0002ec  66666572
0002f0  3a3a4465
0002f4  73657269
0002f8  616c697a
0002fc  65526177
000300  41727261
000304  79536c69
000308  636500  
00030b  00                DCB      0
                  |L465.780|
00030c  50617273          DCB      "Parsed stride is not reasonable",0
000310  65642073
000314  74726964
000318  65206973
00031c  206e6f74
000320  20726561
000324  736f6e61
000328  626c6500
                  |L465.812|
00032c  4e6f7420          DCB      "Not enought bytes left to set the array",0
000330  656e6f75
000334  67687420
000338  62797465
00033c  73206c65
000340  66742074
000344  6f207365
000348  74207468
00034c  65206172
000350  72617900
                  |L465.852|
000354  4f757420          DCB      "Out of memory",0
000358  6f66206d
00035c  656d6f72
000360  7900    
000362  00                DCB      0
000363  00                DCB      0
                  |L465.868|
000364  44657365          DCB      "Deserialization error",0
000368  7269616c
00036c  697a6174
000370  696f6e20
000374  6572726f
000378  7200    
00037a  00                DCB      0
00037b  00                DCB      0

                          AREA ||area_number.466||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer24DeserializeRawArraySliceINS0_5PointIsEEEENS0_10ArraySliceIT_EEPcPPvRiRNS0_11MemoryStackE, LINKORDER=||t._ZN4Anki8Embedded16SerializedBuffer24DeserializeRawArraySliceINS0_5PointIsEEEENS0_10ArraySliceIT_EEPcPPvRiRNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.466||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded16SerializedBuffer24DeserializeRawArraySliceINS0_5PointIsEEEENS0_10ArraySliceIT_EEPcPPvRiRNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIhE7IsValidEv||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE7IsValidEv, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded5ArrayIhE7IsValidEv PROC ; Anki::Embedded::Array<unsigned char>::IsValid() const
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
000000  6901              LDR      r1,[r0,#0x10]
;;;592        {
000002  b131              CBZ      r1,|L472.18|
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
000004  6801              LDR      r1,[r0,#0]
000006  2900              CMP      r1,#0
000008  bfa1              ITTTT    GE
00000a  6840              LDRGE    r0,[r0,#4]
00000c  2800              CMPGE    r0,#0
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
00000e  2001              MOVGE    r0,#1
;;;602        }
000010  4770              BXGE     lr
                  |L472.18|
000012  2000              MOVS     r0,#0                 ;598
000014  4770              BX       lr
;;;603    
                          ENDP


                          AREA ||area_number.473||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE7IsValidEv, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIhE7IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.473||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIhE7IsValidEv||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi PROC ; Anki::Embedded::Array<unsigned char>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L479.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L479.56|
00000e  4b0b              LDR      r3,|L479.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f1030250          ADD      r2,r3,#0x50
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L479.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L479.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::get_size(int) const::__PRETTY_FUNCTION__
                  |L479.60|
                          DCD      ||.constdata||+0xa94

                          AREA ||area_number.480||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.480||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv||, COMGROUP=_ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
;;;91     
;;;92         template<typename Type> bool FixedLengthList<Type>::IsValid() const
000000  b570              PUSH     {r4-r6,lr}
;;;93         {
000002  4604              MOV      r4,r0
000004  68c5              LDR      r5,[r0,#0xc]
000006  2101              MOVS     r1,#1
000008  3018              ADDS     r0,r0,#0x18
00000a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEi ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const
;;;94           if(this->get_size() > this->get_maximumSize()) {
00000e  4285              CMP      r5,r0
000010  dc0a              BGT      |L486.40|
000012  6aa0              LDR      r0,[r4,#0x28]
000014  2800              CMP      r0,#0
;;;95             return false;
;;;96           }
;;;97     
;;;98           return ArraySlice<Type>::IsValid();
;;;99         } // bool FixedLengthList<Type>::IsValid() const
000016  bf08              IT       EQ
000018  bd70              POPEQ    {r4-r6,pc}
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  2800              CMP      r0,#0
00001e  bfa1              ITTTT    GE
000020  69e0              LDRGE    r0,[r4,#0x1c]
000022  2800              CMPGE    r0,#0
000024  2001              MOVGE    r0,#1
000026  bd70              POPGE    {r4-r6,pc}
                  |L486.40|
000028  2000              MOVS     r0,#0
00002a  bd70              POP      {r4-r6,pc}
;;;100    
                          ENDP


                          AREA ||area_number.487||, COMGROUP=_ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv, LINKORDER=||t._ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.487||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15ConstArraySliceIhEC1ERKNS0_5ArrayIhEE||, COMGROUP=_ZN4Anki8Embedded15ConstArraySliceIhEC1ERKNS0_5ArrayIhEE, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15ConstArraySliceIhEC2ERKNS0_5ArrayIhEE                  ; Alternate entry point ; Anki::Embedded::ConstArraySlice<unsigned char>::ConstArraySlice__sub_object(const Anki::Embedded::Array<unsigned char>&)
                  _ZN4Anki8Embedded15ConstArraySliceIhEC1ERKNS0_5ArrayIhEE PROC ; Anki::Embedded::ConstArraySlice<unsigned char>::ConstArraySlice(const Anki::Embedded::Array<unsigned char>&)
;;;26     
;;;27         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array)
;;;28           : ySlice(LinearSequence<s32>(0,array.get_size(0)-1)), xSlice(LinearSequence<s32>(0,array.get_size(1)-1)), array(array)
;;;29         {
;;;30           if(array.get_numElements() == 0) {
;;;31             this->constArrayData = NULL;
;;;32           } else {
;;;33             this->constArrayData = array.Pointer(0,0);
;;;34           }
;;;35         }
;;;36     
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
000006  2100              MOVS     r1,#0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00000e  1e42              SUBS     r2,r0,#1
000010  2100              MOVS     r1,#0
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000018  4605              MOV      r5,r0
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000022  1e42              SUBS     r2,r0,#1
000024  2100              MOVS     r1,#0
000026  f105000c          ADD      r0,r5,#0xc
00002a  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00002e  e894102e          LDM      r4,{r1-r3,r5,r12}
000032  380c              SUBS     r0,r0,#0xc
000034  f1000618          ADD      r6,r0,#0x18
000038  e8a6102e          STM      r6!,{r1-r3,r5,r12}
00003c  6821              LDR      r1,[r4,#0]
00003e  2900              CMP      r1,#0
000040  bfc4              ITT      GT
000042  6862              LDRGT    r2,[r4,#4]
000044  2a00              CMPGT    r2,#0
000046  dd08              BLE      |L493.90|
000048  4351              MULS     r1,r2,r1
00004a  b131              CBZ      r1,|L493.90|
00004c  68a3              LDR      r3,[r4,#8]
00004e  6922              LDR      r2,[r4,#0x10]
000050  2100              MOVS     r1,#0
000052  fb012103          MLA      r1,r1,r3,r2
                  |L493.86|
000056  62c1              STR      r1,[r0,#0x2c]
000058  bd70              POP      {r4-r6,pc}
                  |L493.90|
00005a  2100              MOVS     r1,#0
00005c  e7fb              B        |L493.86|
                          ENDP


                          AREA ||area_number.494||, COMGROUP=_ZN4Anki8Embedded15ConstArraySliceIhEC1ERKNS0_5ArrayIhEE, LINKORDER=||t._ZN4Anki8Embedded15ConstArraySliceIhEC1ERKNS0_5ArrayIhEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.494||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15ConstArraySliceIhEC1ERKNS0_5ArrayIhEE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L500.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L500.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L500.384|
000044  a25c              ADR      r2,|L500.440|
000046  a160              ADR      r1,|L500.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L500.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  00c0              LSLS     r0,r0,#3
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L500.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L500.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L500.384|
000080  a24d              ADR      r2,|L500.440|
000082  a157              ADR      r1,|L500.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L500.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L500.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L500.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L500.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L500.384|
0000c8  a251              ADR      r2,|L500.528|
0000ca  a156              ADR      r1,|L500.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L500.372|
                  |L500.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L500.384|
0000e0  a258              ADR      r2,|L500.580|
0000e2  a15f              ADR      r1,|L500.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L500.372|
                  |L500.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L500.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L500.384|
000110  a259              ADR      r2,|L500.632|
000112  a144              ADR      r1,|L500.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L500.372|
                  |L500.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00f1              LSLS     r1,r6,#3
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L500.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L500.384|
00015a  a251              ADR      r2,|L500.672|
00015c  a140              ADR      r1,|L500.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L500.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L500.380|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L500.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L500.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L500.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L500.476|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L500.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L500.524|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L500.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L500.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L500.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L500.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L500.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L500.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.501||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.501||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L507.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L507.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L507.384|
000044  a25c              ADR      r2,|L507.440|
000046  a160              ADR      r1,|L507.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L507.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0100              LSLS     r0,r0,#4
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L507.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L507.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L507.384|
000080  a24d              ADR      r2,|L507.440|
000082  a157              ADR      r1,|L507.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L507.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L507.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L507.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L507.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L507.384|
0000c8  a251              ADR      r2,|L507.528|
0000ca  a156              ADR      r1,|L507.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L507.372|
                  |L507.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L507.384|
0000e0  a258              ADR      r2,|L507.580|
0000e2  a15f              ADR      r1,|L507.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L507.372|
                  |L507.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L507.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L507.384|
000110  a259              ADR      r2,|L507.632|
000112  a144              ADR      r1,|L507.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L507.372|
                  |L507.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  0131              LSLS     r1,r6,#4
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L507.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L507.384|
00015a  a251              ADR      r2,|L507.672|
00015c  a140              ADR      r1,|L507.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L507.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L507.380|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L507.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L507.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L507.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L507.476|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L507.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L507.524|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L507.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L507.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L507.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L507.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L507.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L507.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.508||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.508||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE15get_maximumSizeEv||, COMGROUP=_ZNK4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE15get_maximumSizeEv, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE15get_maximumSizeEv PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::get_maximumSize() const
;;;169    
;;;170        template<typename Type> inline s32 FixedLengthList<Type>::get_maximumSize() const
000000  69c0              LDR      r0,[r0,#0x1c]
;;;171        {
;;;172          return this->array.get_size(1);
;;;173        } // s32 FixedLengthList<Type>::get_maximumSize() const
000002  4770              BX       lr
;;;174    
                          ENDP


                          AREA ||area_number.515||, COMGROUP=_ZNK4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE15get_maximumSizeEv, LINKORDER=||t._ZNK4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE15get_maximumSizeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.515||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE15get_maximumSizeEv||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  b570              PUSH     {r4-r6,lr}
;;;182        {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000006  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::get_maximumSize() const
00000a  2c00              CMP      r4,#0
00000c  bfb4              ITE      LT
00000e  2100              MOVLT    r1,#0
000010  4621              MOVGE    r1,r4
000012  4281              CMP      r1,r0
000014  dd04              BLE      |L521.32|
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::get_maximumSize() const
00001c  4604              MOV      r4,r0
00001e  e002              B        |L521.38|
                  |L521.32|
000020  2c00              CMP      r4,#0
000022  bfb8              IT       LT
000024  2400              MOVLT    r4,#0
                  |L521.38|
000026  4620              MOV      r0,r4
;;;184    
;;;185          this->xSlice.size = newSize;
000028  60ec              STR      r4,[r5,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00002a  bd70              POP      {r4-r6,pc}
;;;189    
                          ENDP


                          AREA ||area_number.522||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.522||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_||, COMGROUP=_ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_ PROC ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<float>>(int, int, const T1&)
;;;260    
;;;261        template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1)
000000  b570              PUSH     {r4-r6,lr}
;;;262        {
000002  4605              MOV      r5,r0
000004  6910              LDR      r0,[r2,#0x10]
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  b198              CBZ      r0,|L528.52|
00000c  6820              LDR      r0,[r4,#0]
00000e  2800              CMP      r0,#0
000010  bfa4              ITT      GE
000012  6860              LDRGE    r0,[r4,#4]
000014  2800              CMPGE    r0,#0
000016  db0d              BLT      |L528.52|
;;;263          if(!AreValid(object1))
;;;264            return false;
;;;265    
;;;266          if(object1.get_size(0) != height || object1.get_size(1) != width)
000018  2100              MOVS     r1,#0
00001a  4610              MOV      r0,r2
00001c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000020  42a8              CMP      r0,r5
000022  d107              BNE      |L528.52|
000024  2101              MOVS     r1,#1
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00002c  42b0              CMP      r0,r6
;;;267            return false;
;;;268    
;;;269          return true;
00002e  bf04              ITT      EQ
000030  2001              MOVEQ    r0,#1
;;;270        }
000032  bd70              POPEQ    {r4-r6,pc}
                  |L528.52|
000034  2000              MOVS     r0,#0                 ;267
000036  bd70              POP      {r4-r6,pc}
;;;271    
                          ENDP


                          AREA ||area_number.529||, COMGROUP=_ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_, LINKORDER=||t._ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.529||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded10NotAliasedINS0_5ArrayIhEES3_EEbRKT_RKT0_||, COMGROUP=_ZN4Anki8Embedded10NotAliasedINS0_5ArrayIhEES3_EEbRKT_RKT0_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded10NotAliasedINS0_5ArrayIhEES3_EEbRKT_RKT0_ PROC ; Anki::Embedded::NotAliased<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<unsigned char>>(const T1&, const T2&)
;;;359    
;;;360        template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2)
000000  b530              PUSH     {r4,r5,lr}
;;;361        {
000002  b083              SUB      sp,sp,#0xc
000004  460c              MOV      r4,r1
000006  4605              MOV      r5,r0
000008  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
;;;362          if(!AreValid(object1, object2))
00000c  b198              CBZ      r0,|L535.54|
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000014  b178              CBZ      r0,|L535.54|
;;;363            return false;
;;;364    
;;;365          const size_t bufferPointers[] = {
000016  6928              LDR      r0,[r5,#0x10]
000018  9000              STR      r0,[sp,#0]
00001a  6920              LDR      r0,[r4,#0x10]
;;;366            reinterpret_cast<size_t>(object1.get_buffer()),
;;;367            reinterpret_cast<size_t>(object2.get_buffer())};
;;;368    
;;;369          for(s32 i=0; i<2; i++) {
00001c  2100              MOVS     r1,#0
00001e  466a              MOV      r2,sp                 ;365
000020  9001              STR      r0,[sp,#4]            ;365
                  |L535.34|
;;;370            for(s32 j=i+1; j<2; j++) {
000022  1c48              ADDS     r0,r1,#1
000024  2802              CMP      r0,#2
;;;371              if(bufferPointers[i] == bufferPointers[j])
000026  bfb8              IT       LT
000028  f8523021          LDRLT    r3,[r2,r1,LSL #2]
00002c  da09              BGE      |L535.66|
                  |L535.46|
00002e  f852c020          LDR      r12,[r2,r0,LSL #2]
000032  4563              CMP      r3,r12
000034  d102              BNE      |L535.60|
                  |L535.54|
;;;372                return false;
;;;373            }
;;;374          }
;;;375    
;;;376          return true;
;;;377        }
000036  b003              ADD      sp,sp,#0xc
000038  2000              MOVS     r0,#0                 ;372
00003a  bd30              POP      {r4,r5,pc}
                  |L535.60|
00003c  1c40              ADDS     r0,r0,#1              ;370
00003e  2802              CMP      r0,#2                 ;370
000040  dbf5              BLT      |L535.46|
                  |L535.66|
000042  1c49              ADDS     r1,r1,#1              ;369
000044  2902              CMP      r1,#2                 ;369
000046  dbec              BLT      |L535.34|
000048  b003              ADD      sp,sp,#0xc
00004a  2001              MOVS     r0,#1                 ;376
00004c  bd30              POP      {r4,r5,pc}
;;;378    
                          ENDP


                          AREA ||area_number.536||, COMGROUP=_ZN4Anki8Embedded10NotAliasedINS0_5ArrayIhEES3_EEbRKT_RKT0_, LINKORDER=||t._ZN4Anki8Embedded10NotAliasedINS0_5ArrayIhEES3_EEbRKT_RKT0_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.536||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded10NotAliasedINS0_5ArrayIhEES3_EEbRKT_RKT0_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIhNS2_11DotMultiplyIhhhEEhEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIhNS2_11DotMultiplyIhhhEEhEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIhNS2_11DotMultiplyIhhhEEhEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE PROC ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<unsigned char, Anki::Embedded::Matrix::Elementwise::DotMultiply<unsigned char, unsigned char, unsigned char>, unsigned char>(const Anki::Embedded::ConstArraySliceExpression<T1>&, T1, Anki::Embedded::ArraySlice<T3>)
;;;1884   
;;;1885           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
000000  b40f              PUSH     {r0-r3}
;;;1886           {
000002  e92d41f0          PUSH     {r4-r8,lr}
000006  b09a              SUB      sp,sp,#0x68
000008  4607              MOV      r7,r0
00000a  f1000418          ADD      r4,r0,#0x18
00000e  460e              MOV      r6,r1
000010  ad28              ADD      r5,sp,#0xa0
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
;;;1887             const Array<InType> &in1Array = in1.get_array();
;;;1888             Array<OutType> &out1Array = out.get_array();
;;;1889   
;;;1890             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, out1Array),
000018  f8df8240          LDR      r8,|L542.604|
00001c  2800              CMP      r0,#0
00001e  d043              BEQ      |L542.168|
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000026  2800              CMP      r0,#0
000028  d03e              BEQ      |L542.168|
00002a  f8971030          LDRB     r1,[r7,#0x30]
00002e  9a22              LDR      r2,[sp,#0x88]
000030  9207              STR      r2,[sp,#0x1c]
000032  9a25              LDR      r2,[sp,#0x94]
000034  9208              STR      r2,[sp,#0x20]
000036  9a26              LDR      r2,[sp,#0x98]
000038  920c              STR      r2,[sp,#0x30]
00003a  9a27              LDR      r2,[sp,#0x9c]
00003c  920d              STR      r2,[sp,#0x34]
00003e  9a25              LDR      r2,[sp,#0x94]
000040  920e              STR      r2,[sp,#0x38]
000042  9a23              LDR      r2,[sp,#0x8c]
000044  920f              STR      r2,[sp,#0x3c]
000046  9a24              LDR      r2,[sp,#0x90]
000048  9210              STR      r2,[sp,#0x40]
00004a  9a22              LDR      r2,[sp,#0x88]
00004c  f107000c          ADD      r0,r7,#0xc
000050  9211              STR      r2,[sp,#0x44]         ;1886
000052  6843              LDR      r3,[r0,#4]            ;1886
000054  9312              STR      r3,[sp,#0x48]         ;1886
000056  6883              LDR      r3,[r0,#8]            ;1886
000058  9313              STR      r3,[sp,#0x4c]         ;1886
00005a  6800              LDR      r0,[r0,#0]            ;1886
00005c  9014              STR      r0,[sp,#0x50]         ;1886
00005e  6878              LDR      r0,[r7,#4]            ;1886
000060  9015              STR      r0,[sp,#0x54]         ;1886
000062  68b8              LDR      r0,[r7,#8]            ;1886
000064  9016              STR      r0,[sp,#0x58]         ;1886
000066  6838              LDR      r0,[r7,#0]            ;1886
000068  9017              STR      r0,[sp,#0x5c]         ;1886
00006a  f88d1060          STRB     r1,[sp,#0x60]         ;1886
00006e  980d              LDR      r0,[sp,#0x34]         ;1886
000070  9009              STR      r0,[sp,#0x24]         ;1886
000072  2200              MOVS     r2,#0                 ;1886
000074  2001              MOVS     r0,#1                 ;1886
000076  2900              CMP      r1,#0                 ;1886
000078  990e              LDR      r1,[sp,#0x38]         ;1886
00007a  f88d2008          STRB     r2,[sp,#8]            ;1886
00007e  d024              BEQ      |L542.202|
000080  9b17              LDR      r3,[sp,#0x5c]         ;1886
000082  4299              CMP      r1,r3                 ;1886
000084  d134              BNE      |L542.240|
000086  9b14              LDR      r3,[sp,#0x50]         ;1886
000088  9911              LDR      r1,[sp,#0x44]         ;1886
00008a  4299              CMP      r1,r3                 ;1886
00008c  d130              BNE      |L542.240|
00008e  f88d0008          STRB     r0,[sp,#8]            ;1886
000092  9812              LDR      r0,[sp,#0x48]         ;1886
000094  9006              STR      r0,[sp,#0x18]         ;1886
000096  980f              LDR      r0,[sp,#0x3c]         ;1886
000098  f88d2009          STRB     r2,[sp,#9]            ;1886
00009c  9003              STR      r0,[sp,#0xc]          ;1886
00009e  9816              LDR      r0,[sp,#0x58]         ;1886
0000a0  920a              STR      r2,[sp,#0x28]         ;1886
0000a2  900b              STR      r0,[sp,#0x2c]         ;1886
0000a4  f000b88c          B.W      |L542.448|
                  |L542.168|
0000a8  f2407062          MOV      r0,#0x762
0000ac  e9cd8000          STRD     r8,r0,[sp,#0]
0000b0  a36b              ADR      r3,|L542.608|
0000b2  a279              ADR      r2,|L542.664|
0000b4  a17c              ADR      r1,|L542.680|
0000b6  2005              MOVS     r0,#5
0000b8  f7fffffe          BL       _Anki_Log
0000bc  f04f6080          MOV      r0,#0x4000000
                  |L542.192|
;;;1891               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1892   
;;;1893             ArraySliceLimits_in1_out1<s32> limits(
;;;1894               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1895               out.get_ySlice(), out.get_xSlice());
;;;1896   
;;;1897             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1898               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1899   
;;;1900             if(limits.isSimpleIteration) {
;;;1901               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1902   
;;;1903               for(s32 y=0; y<limits.ySize; y++) {
;;;1904                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1905                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1906   
;;;1907                 limits.OuterIncrementTop();
;;;1908   
;;;1909                 for(s32 x=0; x<limits.xSize; x++) {
;;;1910                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], value2);
;;;1911   
;;;1912                   limits.in1X += limits.in1_xInnerIncrement;
;;;1913                   limits.out1X += limits.out1_xInnerIncrement;
;;;1914                 }
;;;1915   
;;;1916                 limits.OuterIncrementBottom();
;;;1917               }
;;;1918             } else { // if(limits.isSimpleIteration)
;;;1919               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1920   
;;;1921               for(s32 y=0; y<limits.ySize; y++) {
;;;1922                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1923   
;;;1924                 limits.OuterIncrementTop();
;;;1925   
;;;1926                 for(s32 x=0; x<limits.xSize; x++) {
;;;1927                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1928   
;;;1929                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, value2);
;;;1930   
;;;1931                   limits.in1X += limits.in1_xInnerIncrement;
;;;1932                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1933                   limits.out1X += limits.out1_xInnerIncrement;
;;;1934                 }
;;;1935   
;;;1936                 limits.OuterIncrementBottom();
;;;1937               }
;;;1938             } //   if(limits.isSimpleIteration)  ... else
;;;1939   
;;;1940             return RESULT_OK;
;;;1941           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
0000c0  b01a              ADD      sp,sp,#0x68
0000c2  e8bd01f0          POP      {r4-r8}
0000c6  f85dfb14          LDR      pc,[sp],#0x14
                  |L542.202|
0000ca  9b14              LDR      r3,[sp,#0x50]
0000cc  4299              CMP      r1,r3
0000ce  d10f              BNE      |L542.240|
0000d0  9b17              LDR      r3,[sp,#0x5c]
0000d2  9911              LDR      r1,[sp,#0x44]
0000d4  4299              CMP      r1,r3
0000d6  d10b              BNE      |L542.240|
0000d8  f88d0008          STRB     r0,[sp,#8]
0000dc  f88d0009          STRB     r0,[sp,#9]
0000e0  9815              LDR      r0,[sp,#0x54]
0000e2  9005              STR      r0,[sp,#0x14]
0000e4  980f              LDR      r0,[sp,#0x3c]
0000e6  9003              STR      r0,[sp,#0xc]
0000e8  9813              LDR      r0,[sp,#0x4c]
0000ea  e9cd020a          STRD     r0,r2,[sp,#0x28]
0000ee  e012              B        |L542.278|
                  |L542.240|
0000f0  f240113f          MOV      r1,#0x13f
0000f4  4875              LDR      r0,|L542.716|
0000f6  e9cd0100          STRD     r0,r1,[sp,#0]
0000fa  a375              ADR      r3,|L542.720|
0000fc  a283              ADR      r2,|L542.780|
0000fe  a18e              ADR      r1,|L542.824|
000100  2005              MOVS     r0,#5
000102  f7fffffe          BL       _Anki_Log
000106  f89d0008          LDRB     r0,[sp,#8]            ;1897
00010a  2800              CMP      r0,#0                 ;1897
00010c  d03e              BEQ      |L542.396|
00010e  f89d0009          LDRB     r0,[sp,#9]            ;1900
000112  2800              CMP      r0,#0                 ;1900
000114  d054              BEQ      |L542.448|
                  |L542.278|
000116  9807              LDR      r0,[sp,#0x1c]         ;1903
000118  2200              MOVS     r2,#0                 ;1903
00011a  2800              CMP      r0,#0                 ;1903
00011c  f340809b          BLE.W    |L542.598|
                  |L542.288|
000120  9805              LDR      r0,[sp,#0x14]         ;1903
000122  68a3              LDR      r3,[r4,#8]            ;1903
000124  6921              LDR      r1,[r4,#0x10]         ;1903
000126  fb001c03          MLA      r12,r0,r3,r1          ;1903
00012a  9803              LDR      r0,[sp,#0xc]          ;1903
00012c  68ab              LDR      r3,[r5,#8]            ;1903
00012e  6929              LDR      r1,[r5,#0x10]         ;1903
000130  fb001303          MLA      r3,r0,r3,r1           ;1903
000134  f89d0009          LDRB     r0,[sp,#9]            ;1903
000138  2800              CMP      r0,#0                 ;1903
00013a  bf19              ITTEE    NE                    ;1903
00013c  9812              LDRNE    r0,[sp,#0x48]         ;1903
00013e  9006              STRNE    r0,[sp,#0x18]         ;1903
000140  9815              LDREQ    r0,[sp,#0x54]         ;1903
000142  9005              STREQ    r0,[sp,#0x14]         ;1903
000144  980c              LDR      r0,[sp,#0x30]         ;1903
000146  9004              STR      r0,[sp,#0x10]         ;1909
000148  9908              LDR      r1,[sp,#0x20]         ;1909
00014a  2000              MOVS     r0,#0                 ;1909
00014c  2900              CMP      r1,#0                 ;1909
00014e  dd11              BLE      |L542.372|
                  |L542.336|
000150  9906              LDR      r1,[sp,#0x18]         ;1910
000152  9f04              LDR      r7,[sp,#0x10]         ;1910
000154  1c40              ADDS     r0,r0,#1              ;1909
000156  f81c1001          LDRB     r1,[r12,r1]           ;1910
00015a  4371              MULS     r1,r6,r1              ;1910
00015c  55d9              STRB     r1,[r3,r7]            ;1910
00015e  9f0a              LDR      r7,[sp,#0x28]         ;1912
000160  9906              LDR      r1,[sp,#0x18]         ;1912
000162  4439              ADD      r1,r1,r7              ;1912
000164  9106              STR      r1,[sp,#0x18]         ;1913
000166  9f09              LDR      r7,[sp,#0x24]         ;1913
000168  9904              LDR      r1,[sp,#0x10]         ;1913
00016a  4439              ADD      r1,r1,r7              ;1913
00016c  9104              STR      r1,[sp,#0x10]         ;1909
00016e  9908              LDR      r1,[sp,#0x20]         ;1909
000170  4281              CMP      r1,r0                 ;1909
000172  dced              BGT      |L542.336|
                  |L542.372|
000174  f89d0009          LDRB     r0,[sp,#9]            ;1909
000178  b1a8              CBZ      r0,|L542.422|
00017a  9916              LDR      r1,[sp,#0x58]         ;1909
00017c  9805              LDR      r0,[sp,#0x14]         ;1909
00017e  4408              ADD      r0,r0,r1              ;1909
000180  9005              STR      r0,[sp,#0x14]         ;1909
000182  9910              LDR      r1,[sp,#0x40]         ;1909
000184  9803              LDR      r0,[sp,#0xc]          ;1909
000186  4408              ADD      r0,r0,r1              ;1909
000188  9003              STR      r0,[sp,#0xc]          ;1909
00018a  e014              B        |L542.438|
                  |L542.396|
00018c  f2407069          MOV      r0,#0x769             ;1897
000190  e9cd8000          STRD     r8,r0,[sp,#0]         ;1897
000194  a332              ADR      r3,|L542.608|
000196  a26f              ADR      r2,|L542.852|
000198  a143              ADR      r1,|L542.680|
00019a  2005              MOVS     r0,#5                 ;1897
00019c  f7fffffe          BL       _Anki_Log
0001a0  f04f6080          MOV      r0,#0x4000000         ;1897
0001a4  e78c              B        |L542.192|
                  |L542.422|
0001a6  9913              LDR      r1,[sp,#0x4c]         ;1897
0001a8  9806              LDR      r0,[sp,#0x18]         ;1897
0001aa  4408              ADD      r0,r0,r1              ;1897
0001ac  9006              STR      r0,[sp,#0x18]         ;1897
0001ae  9910              LDR      r1,[sp,#0x40]         ;1897
0001b0  9803              LDR      r0,[sp,#0xc]          ;1897
0001b2  4408              ADD      r0,r0,r1              ;1897
0001b4  9003              STR      r0,[sp,#0xc]          ;1897
                  |L542.438|
0001b6  9807              LDR      r0,[sp,#0x1c]         ;1903
0001b8  1c52              ADDS     r2,r2,#1              ;1903
0001ba  4290              CMP      r0,r2                 ;1903
0001bc  dcb0              BGT      |L542.288|
0001be  e04a              B        |L542.598|
                  |L542.448|
0001c0  9807              LDR      r0,[sp,#0x1c]         ;1921
0001c2  2300              MOVS     r3,#0                 ;1921
0001c4  2800              CMP      r0,#0                 ;1921
0001c6  dd46              BLE      |L542.598|
                  |L542.456|
0001c8  9803              LDR      r0,[sp,#0xc]          ;1921
0001ca  68aa              LDR      r2,[r5,#8]            ;1921
0001cc  6929              LDR      r1,[r5,#0x10]         ;1921
0001ce  fb001c02          MLA      r12,r0,r2,r1          ;1921
0001d2  f89d0009          LDRB     r0,[sp,#9]            ;1921
0001d6  2800              CMP      r0,#0                 ;1921
0001d8  bf19              ITTEE    NE                    ;1921
0001da  9812              LDRNE    r0,[sp,#0x48]         ;1921
0001dc  9006              STRNE    r0,[sp,#0x18]         ;1921
0001de  9815              LDREQ    r0,[sp,#0x54]         ;1921
0001e0  9005              STREQ    r0,[sp,#0x14]         ;1921
0001e2  980c              LDR      r0,[sp,#0x30]         ;1921
0001e4  9004              STR      r0,[sp,#0x10]         ;1926
0001e6  9908              LDR      r1,[sp,#0x20]         ;1926
0001e8  2000              MOVS     r0,#0                 ;1926
0001ea  2900              CMP      r1,#0                 ;1926
0001ec  dd1b              BLE      |L542.550|
                  |L542.494|
0001ee  e9dd2105          LDRD     r2,r1,[sp,#0x14]      ;1926
0001f2  f8d48008          LDR      r8,[r4,#8]            ;1926
0001f6  6927              LDR      r7,[r4,#0x10]         ;1926
0001f8  1c40              ADDS     r0,r0,#1              ;1926
0001fa  fb027208          MLA      r2,r2,r8,r7           ;1926
0001fe  5c51              LDRB     r1,[r2,r1]            ;1927
000200  9a04              LDR      r2,[sp,#0x10]         ;1929
000202  4371              MULS     r1,r6,r1              ;1929
000204  f80c1002          STRB     r1,[r12,r2]           ;1929
000208  9a0a              LDR      r2,[sp,#0x28]         ;1931
00020a  9906              LDR      r1,[sp,#0x18]         ;1931
00020c  4411              ADD      r1,r1,r2              ;1931
00020e  9106              STR      r1,[sp,#0x18]         ;1932
000210  9a0b              LDR      r2,[sp,#0x2c]         ;1932
000212  9905              LDR      r1,[sp,#0x14]         ;1932
000214  4411              ADD      r1,r1,r2              ;1932
000216  9105              STR      r1,[sp,#0x14]         ;1933
000218  9a09              LDR      r2,[sp,#0x24]         ;1933
00021a  9904              LDR      r1,[sp,#0x10]         ;1933
00021c  4411              ADD      r1,r1,r2              ;1933
00021e  9104              STR      r1,[sp,#0x10]         ;1926
000220  9908              LDR      r1,[sp,#0x20]         ;1926
000222  4281              CMP      r1,r0                 ;1926
000224  dce3              BGT      |L542.494|
                  |L542.550|
000226  f89d0009          LDRB     r0,[sp,#9]            ;1926
00022a  b140              CBZ      r0,|L542.574|
00022c  9916              LDR      r1,[sp,#0x58]         ;1926
00022e  9805              LDR      r0,[sp,#0x14]         ;1926
000230  4408              ADD      r0,r0,r1              ;1926
000232  9005              STR      r0,[sp,#0x14]         ;1926
000234  9910              LDR      r1,[sp,#0x40]         ;1926
000236  9803              LDR      r0,[sp,#0xc]          ;1926
000238  4408              ADD      r0,r0,r1              ;1926
00023a  9003              STR      r0,[sp,#0xc]          ;1926
00023c  e007              B        |L542.590|
                  |L542.574|
00023e  9913              LDR      r1,[sp,#0x4c]         ;1926
000240  9806              LDR      r0,[sp,#0x18]         ;1926
000242  4408              ADD      r0,r0,r1              ;1926
000244  9006              STR      r0,[sp,#0x18]         ;1926
000246  9910              LDR      r1,[sp,#0x40]         ;1926
000248  9803              LDR      r0,[sp,#0xc]          ;1926
00024a  4408              ADD      r0,r0,r1              ;1926
00024c  9003              STR      r0,[sp,#0xc]          ;1926
                  |L542.590|
00024e  9807              LDR      r0,[sp,#0x1c]         ;1921
000250  1c5b              ADDS     r3,r3,#1              ;1921
000252  4298              CMP      r0,r3                 ;1921
000254  dcb8              BGT      |L542.456|
                  |L542.598|
000256  2000              MOVS     r0,#0                 ;1940
000258  e732              B        |L542.192|
;;;1942   
                          ENDP

00025a  0000              DCW      0x0000
                  |L542.604|
                          DCD      _ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIhNS2_11DotMultiplyIhhhEEhEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<unsigned char, Anki::Embedded::Matrix::Elementwise::DotMultiply<unsigned char, unsigned char, unsigned char>, unsigned char>(const Anki::Embedded::ConstArraySliceExpression<T1>&, T1, Anki::Embedded::ArraySlice<T3>)::__PRETTY_FUNCTION__
                  |L542.608|
000260  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000264  6f726574
000268  6563685c
00026c  636f6d6d
000270  6f6e5c69
000274  6e636c75
000278  64655c61
00027c  6e6b692f
000280  636f6d6d
000284  6f6e2f72
000288  6f626f74
00028c  2f6d6174
000290  726978  
000293  2e6800            DCB      ".h",0
000296  00                DCB      0
000297  00                DCB      0
                  |L542.664|
000298  496e7661          DCB      "Invalid objects",0
00029c  6c696420
0002a0  6f626a65
0002a4  63747300
                  |L542.680|
0002a8  4d617472          DCB      "Matrix::Elementwise::ApplyOperation",0
0002ac  69783a3a
0002b0  456c656d
0002b4  656e7477
0002b8  6973653a
0002bc  3a417070
0002c0  6c794f70
0002c4  65726174
0002c8  696f6e00
                  |L542.716|
                          DCD      _ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)::__PRETTY_FUNCTION__
                  |L542.720|
0002d0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/arrayS"
0002d4  6f726574
0002d8  6563685c
0002dc  636f6d6d
0002e0  6f6e5c69
0002e4  6e636c75
0002e8  64655c61
0002ec  6e6b692f
0002f0  636f6d6d
0002f4  6f6e2f72
0002f8  6f626f74
0002fc  2f617272
000300  617953  
000303  6c696365          DCB      "lices.h",0
000307  732e6800
00030b  00                DCB      0
                  |L542.780|
00030c  53756273          DCB      "Subscripted assignment dimension mismatch",0
000310  63726970
000314  74656420
000318  61737369
00031c  676e6d65
000320  6e742064
000324  696d656e
000328  73696f6e
00032c  206d6973
000330  6d617463
000334  6800    
000336  00                DCB      0
000337  00                DCB      0
                  |L542.824|
000338  41727261          DCB      "ArraySliceLimits_in1_out1",0
00033c  79536c69
000340  63654c69
000344  6d697473
000348  5f696e31
00034c  5f6f7574
000350  3100    
000352  00                DCB      0
000353  00                DCB      0
                  |L542.852|
000354  4c696d69          DCB      "Limits is not valid",0
000358  74732069
00035c  73206e6f
000360  74207661
000364  6c696400

                          AREA ||area_number.543||, COMGROUP=_ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIhNS2_11DotMultiplyIhhhEEhEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIhNS2_11DotMultiplyIhhhEEhEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.543||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIhNS2_11DotMultiplyIhhhEEhEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE||
                          DCD      0x00000001

                          AREA ||.constdata__ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
00001c  696e6561          DCB      0x69,0x6e,0x65,0x61
000020  72536571          DCB      0x72,0x53,0x65,0x71
000024  75656e63          DCB      0x75,0x65,0x6e,0x63
000028  653c5479          DCB      0x65,0x3c,0x54,0x79
00002c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000030  3a636f6d          DCB      0x3a,0x63,0x6f,0x6d
000034  70757465          DCB      0x70,0x75,0x74,0x65
000038  53697a65          DCB      0x53,0x69,0x7a,0x65
00003c  28547970          DCB      0x28,0x54,0x79,0x70
000040  652c2054          DCB      0x65,0x2c,0x20,0x54
000044  7970652c          DCB      0x79,0x70,0x65,0x2c
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  6529205b          DCB      0x65,0x29,0x20,0x5b
000050  77697468          DCB      0x77,0x69,0x74,0x68
000054  20547970          DCB      0x20,0x54,0x79,0x70
000058  65203d20          DCB      0x65,0x20,0x3d,0x20
00005c  7369676e          DCB      0x73,0x69,0x67,0x6e
000060  65642069          DCB      0x65,0x64,0x20,0x69
000064  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  79536c69          DCB      0x79,0x53,0x6c,0x69
000018  63654c69          DCB      0x63,0x65,0x4c,0x69
00001c  6d697473          DCB      0x6d,0x69,0x74,0x73
000020  5f696e31          DCB      0x5f,0x69,0x6e,0x31
000024  5f6f7574          DCB      0x5f,0x6f,0x75,0x74
000028  313c5479          DCB      0x31,0x3c,0x54,0x79
00002c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000030  3a417272          DCB      0x3a,0x41,0x72,0x72
000034  6179536c          DCB      0x61,0x79,0x53,0x6c
000038  6963654c          DCB      0x69,0x63,0x65,0x4c
00003c  696d6974          DCB      0x69,0x6d,0x69,0x74
000040  735f696e          DCB      0x73,0x5f,0x69,0x6e
000044  315f6f75          DCB      0x31,0x5f,0x6f,0x75
000048  74312863          DCB      0x74,0x31,0x28,0x63
00004c  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000050  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000054  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000058  6d626564          DCB      0x6d,0x62,0x65,0x64
00005c  6465643a          DCB      0x64,0x65,0x64,0x3a
000060  3a4c696e          DCB      0x3a,0x4c,0x69,0x6e
000064  65617253          DCB      0x65,0x61,0x72,0x53
000068  65717565          DCB      0x65,0x71,0x75,0x65
00006c  6e63653c          DCB      0x6e,0x63,0x65,0x3c
000070  54797065          DCB      0x54,0x79,0x70,0x65
000074  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000078  20636f6e          DCB      0x20,0x63,0x6f,0x6e
00007c  73742041          DCB      0x73,0x74,0x20,0x41
000080  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000084  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000088  65646465          DCB      0x65,0x64,0x64,0x65
00008c  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
000090  696e6561          DCB      0x69,0x6e,0x65,0x61
000094  72536571          DCB      0x72,0x53,0x65,0x71
000098  75656e63          DCB      0x75,0x65,0x6e,0x63
00009c  653c5479          DCB      0x65,0x3c,0x54,0x79
0000a0  70653e20          DCB      0x70,0x65,0x3e,0x20
0000a4  262c2062          DCB      0x26,0x2c,0x20,0x62
0000a8  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
0000ac  20636f6e          DCB      0x20,0x63,0x6f,0x6e
0000b0  73742041          DCB      0x73,0x74,0x20,0x41
0000b4  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000b8  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000bc  65646465          DCB      0x65,0x64,0x64,0x65
0000c0  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
0000c4  696e6561          DCB      0x69,0x6e,0x65,0x61
0000c8  72536571          DCB      0x72,0x53,0x65,0x71
0000cc  75656e63          DCB      0x75,0x65,0x6e,0x63
0000d0  653c5479          DCB      0x65,0x3c,0x54,0x79
0000d4  70653e20          DCB      0x70,0x65,0x3e,0x20
0000d8  262c2063          DCB      0x26,0x2c,0x20,0x63
0000dc  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0000e0  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000e4  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000e8  6d626564          DCB      0x6d,0x62,0x65,0x64
0000ec  6465643a          DCB      0x64,0x65,0x64,0x3a
0000f0  3a4c696e          DCB      0x3a,0x4c,0x69,0x6e
0000f4  65617253          DCB      0x65,0x61,0x72,0x53
0000f8  65717565          DCB      0x65,0x71,0x75,0x65
0000fc  6e63653c          DCB      0x6e,0x63,0x65,0x3c
000100  54797065          DCB      0x54,0x79,0x70,0x65
000104  3e202629          DCB      0x3e,0x20,0x26,0x29
000108  205b7769          DCB      0x20,0x5b,0x77,0x69
00010c  74682054          DCB      0x74,0x68,0x20,0x54
000110  79706520          DCB      0x79,0x70,0x65,0x20
000114  3d207369          DCB      0x3d,0x20,0x73,0x69
000118  676e6564          DCB      0x67,0x6e,0x65,0x64
00011c  20696e74          DCB      0x20,0x69,0x6e,0x74
000120  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d207369          DCB      0x3d,0x20,0x73,0x69
000088  676e6564          DCB      0x67,0x6e,0x65,0x64
00008c  20696e74          DCB      0x20,0x69,0x6e,0x74
000090  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  7369676e          DCB      0x73,0x69,0x67,0x6e
0000bc  65642069          DCB      0x65,0x64,0x20,0x69
0000c0  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2073          DCB      0x20,0x3d,0x20,0x73
000094  69676e65          DCB      0x69,0x67,0x6e,0x65
000098  6420696e          DCB      0x64,0x20,0x69,0x6e
00009c  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000088  6f61745d          DCB      0x6f,0x61,0x74,0x5d
00008c  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::SetZero()::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  5365745a          DCB      0x53,0x65,0x74,0x5a
00002c  65726f28          DCB      0x65,0x72,0x6f,0x28
000030  29205b77          DCB      0x29,0x20,0x5b,0x77
000034  69746820          DCB      0x69,0x74,0x68,0x20
000038  54797065          DCB      0x54,0x79,0x70,0x65
00003c  203d2066          DCB      0x20,0x3d,0x20,0x66
000040  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000044  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000054  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000bc  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2066          DCB      0x20,0x3d,0x20,0x66
000094  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000098  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE7SetCastIfEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE7SetCastIfEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE7SetCastIfEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::SetCast<float>(const Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  53657443          DCB      0x53,0x65,0x74,0x43
00002c  61737428          DCB      0x61,0x73,0x74,0x28
000030  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000034  7420416e          DCB      0x74,0x20,0x41,0x6e
000038  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00003c  456d6265          DCB      0x45,0x6d,0x62,0x65
000040  64646564          DCB      0x64,0x64,0x65,0x64
000044  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000048  7261793c          DCB      0x72,0x61,0x79,0x3c
00004c  496e5479          DCB      0x49,0x6e,0x54,0x79
000050  70653e20          DCB      0x70,0x65,0x3e,0x20
000054  2629205b          DCB      0x26,0x29,0x20,0x5b
000058  77697468          DCB      0x77,0x69,0x74,0x68
00005c  20496e54          DCB      0x20,0x49,0x6e,0x54
000060  79706520          DCB      0x79,0x70,0x65,0x20
000064  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000068  6f61742c          DCB      0x6f,0x61,0x74,0x2c
00006c  20547970          DCB      0x20,0x54,0x79,0x70
000070  65203d20          DCB      0x65,0x20,0x3d,0x20
000074  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000078  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<bool>(char*, void**, int&)::__PRETTY_FUNCTION__
000000  54797065          DCB      0x54,0x79,0x70,0x65
000004  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000008  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00000c  6d626564          DCB      0x6d,0x62,0x65,0x64
000010  6465643a          DCB      0x64,0x65,0x64,0x3a
000014  3a536572          DCB      0x3a,0x53,0x65,0x72
000018  69616c69          DCB      0x69,0x61,0x6c,0x69
00001c  7a656442          DCB      0x7a,0x65,0x64,0x42
000020  75666665          DCB      0x75,0x66,0x66,0x65
000024  723a3a44          DCB      0x72,0x3a,0x3a,0x44
000028  65736572          DCB      0x65,0x73,0x65,0x72
00002c  69616c69          DCB      0x69,0x61,0x6c,0x69
000030  7a655261          DCB      0x7a,0x65,0x52,0x61
000034  77426173          DCB      0x77,0x42,0x61,0x73
000038  69635479          DCB      0x69,0x63,0x54,0x79
00003c  70652863          DCB      0x70,0x65,0x28,0x63
000040  68617220          DCB      0x68,0x61,0x72,0x20
000044  2a2c2076          DCB      0x2a,0x2c,0x20,0x76
000048  6f696420          DCB      0x6f,0x69,0x64,0x20
00004c  2a2a2c20          DCB      0x2a,0x2a,0x2c,0x20
000050  7369676e          DCB      0x73,0x69,0x67,0x6e
000054  65642069          DCB      0x65,0x64,0x20,0x69
000058  6e742026          DCB      0x6e,0x74,0x20,0x26
00005c  29205b77          DCB      0x29,0x20,0x5b,0x77
000060  69746820          DCB      0x69,0x74,0x68,0x20
000064  54797065          DCB      0x54,0x79,0x70,0x65
000068  203d2062          DCB      0x20,0x3d,0x20,0x62
00006c  6f6f6c5d          DCB      0x6f,0x6f,0x6c,0x5d
000070  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<int>(char*, void**, int&)::__PRETTY_FUNCTION__
000000  54797065          DCB      0x54,0x79,0x70,0x65
000004  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000008  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00000c  6d626564          DCB      0x6d,0x62,0x65,0x64
000010  6465643a          DCB      0x64,0x65,0x64,0x3a
000014  3a536572          DCB      0x3a,0x53,0x65,0x72
000018  69616c69          DCB      0x69,0x61,0x6c,0x69
00001c  7a656442          DCB      0x7a,0x65,0x64,0x42
000020  75666665          DCB      0x75,0x66,0x66,0x65
000024  723a3a44          DCB      0x72,0x3a,0x3a,0x44
000028  65736572          DCB      0x65,0x73,0x65,0x72
00002c  69616c69          DCB      0x69,0x61,0x6c,0x69
000030  7a655261          DCB      0x7a,0x65,0x52,0x61
000034  77426173          DCB      0x77,0x42,0x61,0x73
000038  69635479          DCB      0x69,0x63,0x54,0x79
00003c  70652863          DCB      0x70,0x65,0x28,0x63
000040  68617220          DCB      0x68,0x61,0x72,0x20
000044  2a2c2076          DCB      0x2a,0x2c,0x20,0x76
000048  6f696420          DCB      0x6f,0x69,0x64,0x20
00004c  2a2a2c20          DCB      0x2a,0x2a,0x2c,0x20
000050  7369676e          DCB      0x73,0x69,0x67,0x6e
000054  65642069          DCB      0x65,0x64,0x20,0x69
000058  6e742026          DCB      0x6e,0x74,0x20,0x26
00005c  29205b77          DCB      0x29,0x20,0x5b,0x77
000060  69746820          DCB      0x69,0x74,0x68,0x20
000064  54797065          DCB      0x54,0x79,0x70,0x65
000068  203d2073          DCB      0x20,0x3d,0x20,0x73
00006c  69676e65          DCB      0x69,0x67,0x6e,0x65
000070  6420696e          DCB      0x64,0x20,0x69,0x6e
000074  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded16SerializedBuffer22SerializeRawArraySliceINS0_5PointIsEEEENS_6ResultEPKcRKNS0_15ConstArraySliceIT_EEPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::SerializeRawArraySlice<Anki::Embedded::Point<short>>(const char*, const Anki::Embedded::ConstArraySlice<T1>&, void**, int&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a536572          DCB      0x3a,0x53,0x65,0x72
000020  69616c69          DCB      0x69,0x61,0x6c,0x69
000024  7a656442          DCB      0x7a,0x65,0x64,0x42
000028  75666665          DCB      0x75,0x66,0x66,0x65
00002c  723a3a53          DCB      0x72,0x3a,0x3a,0x53
000030  65726961          DCB      0x65,0x72,0x69,0x61
000034  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000038  52617741          DCB      0x52,0x61,0x77,0x41
00003c  72726179          DCB      0x72,0x72,0x61,0x79
000040  536c6963          DCB      0x53,0x6c,0x69,0x63
000044  6528636f          DCB      0x65,0x28,0x63,0x6f
000048  6e737420          DCB      0x6e,0x73,0x74,0x20
00004c  63686172          DCB      0x63,0x68,0x61,0x72
000050  202a2c20          DCB      0x20,0x2a,0x2c,0x20
000054  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000058  7420416e          DCB      0x74,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a436f          DCB      0x3a,0x3a,0x43,0x6f
00006c  6e737441          DCB      0x6e,0x73,0x74,0x41
000070  72726179          DCB      0x72,0x72,0x61,0x79
000074  536c6963          DCB      0x53,0x6c,0x69,0x63
000078  653c5479          DCB      0x65,0x3c,0x54,0x79
00007c  70653e20          DCB      0x70,0x65,0x3e,0x20
000080  262c2076          DCB      0x26,0x2c,0x20,0x76
000084  6f696420          DCB      0x6f,0x69,0x64,0x20
000088  2a2a2c20          DCB      0x2a,0x2a,0x2c,0x20
00008c  7369676e          DCB      0x73,0x69,0x67,0x6e
000090  65642069          DCB      0x65,0x64,0x20,0x69
000094  6e742026          DCB      0x6e,0x74,0x20,0x26
000098  29205b77          DCB      0x29,0x20,0x5b,0x77
00009c  69746820          DCB      0x69,0x74,0x68,0x20
0000a0  54797065          DCB      0x54,0x79,0x70,0x65
0000a4  203d2041          DCB      0x20,0x3d,0x20,0x41
0000a8  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000ac  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000b0  65646465          DCB      0x65,0x64,0x64,0x65
0000b4  643a3a50          DCB      0x64,0x3a,0x3a,0x50
0000b8  6f696e74          DCB      0x6f,0x69,0x6e,0x74
0000bc  3c736967          DCB      0x3c,0x73,0x69,0x67
0000c0  6e656420          DCB      0x6e,0x65,0x64,0x20
0000c4  73686f72          DCB      0x73,0x68,0x6f,0x72
0000c8  743e5d00          DCB      0x74,0x3e,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded16SerializedBuffer24DeserializeRawArraySliceINS0_5PointIsEEEENS0_10ArraySliceIT_EEPcPPvRiRNS0_11MemoryStackEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded16SerializedBuffer24DeserializeRawArraySliceINS0_5PointIsEEEENS0_10ArraySliceIT_EEPcPPvRiRNS0_11MemoryStackEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded16SerializedBuffer24DeserializeRawArraySliceINS0_5PointIsEEEENS0_10ArraySliceIT_EEPcPPvRiRNS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawArraySlice<Anki::Embedded::Point<short>>(char*, void**, int&, Anki::Embedded::MemoryStack&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  79536c69          DCB      0x79,0x53,0x6c,0x69
000018  63653c54          DCB      0x63,0x65,0x3c,0x54
00001c  7970653e          DCB      0x79,0x70,0x65,0x3e
000020  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000024  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000028  6d626564          DCB      0x6d,0x62,0x65,0x64
00002c  6465643a          DCB      0x64,0x65,0x64,0x3a
000030  3a536572          DCB      0x3a,0x53,0x65,0x72
000034  69616c69          DCB      0x69,0x61,0x6c,0x69
000038  7a656442          DCB      0x7a,0x65,0x64,0x42
00003c  75666665          DCB      0x75,0x66,0x66,0x65
000040  723a3a44          DCB      0x72,0x3a,0x3a,0x44
000044  65736572          DCB      0x65,0x73,0x65,0x72
000048  69616c69          DCB      0x69,0x61,0x6c,0x69
00004c  7a655261          DCB      0x7a,0x65,0x52,0x61
000050  77417272          DCB      0x77,0x41,0x72,0x72
000054  6179536c          DCB      0x61,0x79,0x53,0x6c
000058  69636528          DCB      0x69,0x63,0x65,0x28
00005c  63686172          DCB      0x63,0x68,0x61,0x72
000060  202a2c20          DCB      0x20,0x2a,0x2c,0x20
000064  766f6964          DCB      0x76,0x6f,0x69,0x64
000068  202a2a2c          DCB      0x20,0x2a,0x2a,0x2c
00006c  20736967          DCB      0x20,0x73,0x69,0x67
000070  6e656420          DCB      0x6e,0x65,0x64,0x20
000074  696e7420          DCB      0x69,0x6e,0x74,0x20
000078  262c2041          DCB      0x26,0x2c,0x20,0x41
00007c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000080  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000084  65646465          DCB      0x65,0x64,0x64,0x65
000088  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00008c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000090  79537461          DCB      0x79,0x53,0x74,0x61
000094  636b2026          DCB      0x63,0x6b,0x20,0x26
000098  29205b77          DCB      0x29,0x20,0x5b,0x77
00009c  69746820          DCB      0x69,0x74,0x68,0x20
0000a0  54797065          DCB      0x54,0x79,0x70,0x65
0000a4  203d2041          DCB      0x20,0x3d,0x20,0x41
0000a8  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000ac  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000b0  65646465          DCB      0x65,0x64,0x64,0x65
0000b4  643a3a50          DCB      0x64,0x3a,0x3a,0x50
0000b8  6f696e74          DCB      0x6f,0x69,0x6e,0x74
0000bc  3c736967          DCB      0x3c,0x73,0x69,0x67
0000c0  6e656420          DCB      0x6e,0x65,0x64,0x20
0000c4  73686f72          DCB      0x73,0x68,0x6f,0x72
0000c8  743e5d00          DCB      0x74,0x3e,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded16SerializedBuffer17EncodedArraySlice9SerializeINS0_5PointIsEEEENS_6ResultEbRKNS0_15ConstArraySliceIT_EEPPvRiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded16SerializedBuffer17EncodedArraySlice9SerializeINS0_5PointIsEEEENS_6ResultEbRKNS0_15ConstArraySliceIT_EEPPvRiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded16SerializedBuffer17EncodedArraySlice9SerializeINS0_5PointIsEEEENS_6ResultEbRKNS0_15ConstArraySliceIT_EEPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::EncodedArraySlice::Serialize<Anki::Embedded::Point<short>>(bool, const Anki::Embedded::ConstArraySlice<T1>&, void**, int&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a536572          DCB      0x3a,0x53,0x65,0x72
000020  69616c69          DCB      0x69,0x61,0x6c,0x69
000024  7a656442          DCB      0x7a,0x65,0x64,0x42
000028  75666665          DCB      0x75,0x66,0x66,0x65
00002c  723a3a45          DCB      0x72,0x3a,0x3a,0x45
000030  6e636f64          DCB      0x6e,0x63,0x6f,0x64
000034  65644172          DCB      0x65,0x64,0x41,0x72
000038  72617953          DCB      0x72,0x61,0x79,0x53
00003c  6c696365          DCB      0x6c,0x69,0x63,0x65
000040  3a3a5365          DCB      0x3a,0x3a,0x53,0x65
000044  7269616c          DCB      0x72,0x69,0x61,0x6c
000048  697a6528          DCB      0x69,0x7a,0x65,0x28
00004c  626f6f6c          DCB      0x62,0x6f,0x6f,0x6c
000050  2c20636f          DCB      0x2c,0x20,0x63,0x6f
000054  6e737420          DCB      0x6e,0x73,0x74,0x20
000058  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00005c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000060  62656464          DCB      0x62,0x65,0x64,0x64
000064  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000068  436f6e73          DCB      0x43,0x6f,0x6e,0x73
00006c  74417272          DCB      0x74,0x41,0x72,0x72
000070  6179536c          DCB      0x61,0x79,0x53,0x6c
000074  6963653c          DCB      0x69,0x63,0x65,0x3c
000078  54797065          DCB      0x54,0x79,0x70,0x65
00007c  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000080  20766f69          DCB      0x20,0x76,0x6f,0x69
000084  64202a2a          DCB      0x64,0x20,0x2a,0x2a
000088  2c207369          DCB      0x2c,0x20,0x73,0x69
00008c  676e6564          DCB      0x67,0x6e,0x65,0x64
000090  20696e74          DCB      0x20,0x69,0x6e,0x74
000094  20262920          DCB      0x20,0x26,0x29,0x20
000098  5b776974          DCB      0x5b,0x77,0x69,0x74
00009c  68205479          DCB      0x68,0x20,0x54,0x79
0000a0  7065203d          DCB      0x70,0x65,0x20,0x3d
0000a4  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000a8  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000ac  6d626564          DCB      0x6d,0x62,0x65,0x64
0000b0  6465643a          DCB      0x64,0x65,0x64,0x3a
0000b4  3a506f69          DCB      0x3a,0x50,0x6f,0x69
0000b8  6e743c73          DCB      0x6e,0x74,0x3c,0x73
0000bc  69676e65          DCB      0x69,0x67,0x6e,0x65
0000c0  64207368          DCB      0x64,0x20,0x73,0x68
0000c4  6f72743e          DCB      0x6f,0x72,0x74,0x3e
0000c8  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20756e          DCB      0x3d,0x20,0x75,0x6e
000088  7369676e          DCB      0x73,0x69,0x67,0x6e
00008c  65642063          DCB      0x65,0x64,0x20,0x63
000090  6861725d          DCB      0x68,0x61,0x72,0x5d
000094  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhE3SetEhE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE3SetEhE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE3SetEhE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::Set(unsigned char)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  53657428          DCB      0x53,0x65,0x74,0x28
00002c  54797065          DCB      0x54,0x79,0x70,0x65
000030  29205b77          DCB      0x29,0x20,0x5b,0x77
000034  69746820          DCB      0x69,0x74,0x68,0x20
000038  54797065          DCB      0x54,0x79,0x70,0x65
00003c  203d2075          DCB      0x20,0x3d,0x20,0x75
000040  6e736967          DCB      0x6e,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  63686172          DCB      0x63,0x68,0x61,0x72
00004c  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  756e7369          DCB      0x75,0x6e,0x73,0x69
000054  676e6564          DCB      0x67,0x6e,0x65,0x64
000058  20636861          DCB      0x20,0x63,0x68,0x61
00005c  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  756e7369          DCB      0x75,0x6e,0x73,0x69
0000bc  676e6564          DCB      0x67,0x6e,0x65,0x64
0000c0  20636861          DCB      0x20,0x63,0x68,0x61
0000c4  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2075          DCB      0x20,0x3d,0x20,0x75
000094  6e736967          DCB      0x6e,0x73,0x69,0x67
000098  6e656420          DCB      0x6e,0x65,0x64,0x20
00009c  63686172          DCB      0x63,0x68,0x61,0x72
0000a0  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  53657443          DCB      0x53,0x65,0x74,0x43
00002c  61737428          DCB      0x61,0x73,0x74,0x28
000030  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000034  7420416e          DCB      0x74,0x20,0x41,0x6e
000038  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00003c  456d6265          DCB      0x45,0x6d,0x62,0x65
000040  64646564          DCB      0x64,0x64,0x65,0x64
000044  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000048  7261793c          DCB      0x72,0x61,0x79,0x3c
00004c  496e5479          DCB      0x49,0x6e,0x54,0x79
000050  70653e20          DCB      0x70,0x65,0x3e,0x20
000054  2629205b          DCB      0x26,0x29,0x20,0x5b
000058  77697468          DCB      0x77,0x69,0x74,0x68
00005c  20496e54          DCB      0x20,0x49,0x6e,0x54
000060  79706520          DCB      0x79,0x70,0x65,0x20
000064  3d20756e          DCB      0x3d,0x20,0x75,0x6e
000068  7369676e          DCB      0x73,0x69,0x67,0x6e
00006c  65642063          DCB      0x65,0x64,0x20,0x63
000070  6861722c          DCB      0x68,0x61,0x72,0x2c
000074  20547970          DCB      0x20,0x54,0x79,0x70
000078  65203d20          DCB      0x65,0x20,0x3d,0x20
00007c  756e7369          DCB      0x75,0x6e,0x73,0x69
000080  676e6564          DCB      0x67,0x6e,0x65,0x64
000084  20636861          DCB      0x20,0x63,0x68,0x61
000088  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_5PointIsEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_5PointIsEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_5PointIsEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a506f          DCB      0x3a,0x3a,0x50,0x6f
000098  696e743c          DCB      0x69,0x6e,0x74,0x3c
00009c  7369676e          DCB      0x73,0x69,0x67,0x6e
0000a0  65642073          DCB      0x65,0x64,0x20,0x73
0000a4  686f7274          DCB      0x68,0x6f,0x72,0x74
0000a8  3e5d00            DCB      0x3e,0x5d,0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayINS0_5PointIsEEE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000054  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000058  62656464          DCB      0x62,0x65,0x64,0x64
00005c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000060  506f696e          DCB      0x50,0x6f,0x69,0x6e
000064  743c7369          DCB      0x74,0x3c,0x73,0x69
000068  676e6564          DCB      0x67,0x6e,0x65,0x64
00006c  2073686f          DCB      0x20,0x73,0x68,0x6f
000070  72743e5d          DCB      0x72,0x74,0x3e,0x5d
000074  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_5PointIsEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_5PointIsEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_5PointIsEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  506f696e          DCB      0x50,0x6f,0x69,0x6e
0000cc  743c7369          DCB      0x74,0x3c,0x73,0x69
0000d0  676e6564          DCB      0x67,0x6e,0x65,0x64
0000d4  2073686f          DCB      0x20,0x73,0x68,0x6f
0000d8  72743e5d          DCB      0x72,0x74,0x3e,0x5d
0000dc  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_5PointIsEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_5PointIsEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_5PointIsEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<short>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a50          DCB      0x64,0x3a,0x3a,0x50
0000a4  6f696e74          DCB      0x6f,0x69,0x6e,0x74
0000a8  3c736967          DCB      0x3c,0x73,0x69,0x67
0000ac  6e656420          DCB      0x6e,0x65,0x64,0x20
0000b0  73686f72          DCB      0x73,0x68,0x6f,0x72
0000b4  743e5d00          DCB      0x74,0x3e,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a506f          DCB      0x3a,0x3a,0x50,0x6f
000098  696e743c          DCB      0x69,0x6e,0x74,0x3c
00009c  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000a0  743e5d00          DCB      0x74,0x3e,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  506f696e          DCB      0x50,0x6f,0x69,0x6e
0000cc  743c666c          DCB      0x74,0x3c,0x66,0x6c
0000d0  6f61743e          DCB      0x6f,0x61,0x74,0x3e
0000d4  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a50          DCB      0x64,0x3a,0x3a,0x50
0000a4  6f696e74          DCB      0x6f,0x69,0x6e,0x74
0000a8  3c666c6f          DCB      0x3c,0x66,0x6c,0x6f
0000ac  61743e5d          DCB      0x61,0x74,0x3e,0x5d
0000b0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a5465          DCB      0x3a,0x3a,0x54,0x65
000098  6d706c61          DCB      0x6d,0x70,0x6c,0x61
00009c  74655472          DCB      0x74,0x65,0x54,0x72
0000a0  61636b65          DCB      0x61,0x63,0x6b,0x65
0000a4  723a3a42          DCB      0x72,0x3a,0x3a,0x42
0000a8  696e6172          DCB      0x69,0x6e,0x61,0x72
0000ac  79547261          DCB      0x79,0x54,0x72,0x61
0000b0  636b6572          DCB      0x63,0x6b,0x65,0x72
0000b4  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
0000b8  64657843          DCB      0x64,0x65,0x78,0x43
0000bc  6f727265          DCB      0x6f,0x72,0x72,0x65
0000c0  73706f6e          DCB      0x73,0x70,0x6f,0x6e
0000c4  64656e63          DCB      0x64,0x65,0x6e,0x63
0000c8  655d00            DCB      0x65,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  54656d70          DCB      0x54,0x65,0x6d,0x70
0000cc  6c617465          DCB      0x6c,0x61,0x74,0x65
0000d0  54726163          DCB      0x54,0x72,0x61,0x63
0000d4  6b65723a          DCB      0x6b,0x65,0x72,0x3a
0000d8  3a42696e          DCB      0x3a,0x42,0x69,0x6e
0000dc  61727954          DCB      0x61,0x72,0x79,0x54
0000e0  7261636b          DCB      0x72,0x61,0x63,0x6b
0000e4  65723a3a          DCB      0x65,0x72,0x3a,0x3a
0000e8  496e6465          DCB      0x49,0x6e,0x64,0x65
0000ec  78436f72          DCB      0x78,0x43,0x6f,0x72
0000f0  72657370          DCB      0x72,0x65,0x73,0x70
0000f4  6f6e6465          DCB      0x6f,0x6e,0x64,0x65
0000f8  6e63655d          DCB      0x6e,0x63,0x65,0x5d
0000fc  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker13BinaryTracker19IndexCorrespondenceEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::BinaryTracker::IndexCorrespondence>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a54          DCB      0x64,0x3a,0x3a,0x54
0000a4  656d706c          DCB      0x65,0x6d,0x70,0x6c
0000a8  61746554          DCB      0x61,0x74,0x65,0x54
0000ac  7261636b          DCB      0x72,0x61,0x63,0x6b
0000b0  65723a3a          DCB      0x65,0x72,0x3a,0x3a
0000b4  42696e61          DCB      0x42,0x69,0x6e,0x61
0000b8  72795472          DCB      0x72,0x79,0x54,0x72
0000bc  61636b65          DCB      0x61,0x63,0x6b,0x65
0000c0  723a3a49          DCB      0x72,0x3a,0x3a,0x49
0000c4  6e646578          DCB      0x6e,0x64,0x65,0x78
0000c8  436f7272          DCB      0x43,0x6f,0x72,0x72
0000cc  6573706f          DCB      0x65,0x73,0x70,0x6f
0000d0  6e64656e          DCB      0x6e,0x64,0x65,0x6e
0000d4  63655d00          DCB      0x63,0x65,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIhNS2_11DotMultiplyIhhhEEhEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIhNS2_11DotMultiplyIhhhEEhEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIhNS2_11DotMultiplyIhhhEEhEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<unsigned char, Anki::Embedded::Matrix::Elementwise::DotMultiply<unsigned char, unsigned char, unsigned char>, unsigned char>(const Anki::Embedded::ConstArraySliceExpression<T1>&, T1, Anki::Embedded::ArraySlice<T3>)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a456c65          DCB      0x3a,0x45,0x6c,0x65
000028  6d656e74          DCB      0x6d,0x65,0x6e,0x74
00002c  77697365          DCB      0x77,0x69,0x73,0x65
000030  3a3a4170          DCB      0x3a,0x3a,0x41,0x70
000034  706c794f          DCB      0x70,0x6c,0x79,0x4f
000038  70657261          DCB      0x70,0x65,0x72,0x61
00003c  74696f6e          DCB      0x74,0x69,0x6f,0x6e
000040  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000044  73742041          DCB      0x73,0x74,0x20,0x41
000048  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00004c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000050  65646465          DCB      0x65,0x64,0x64,0x65
000054  643a3a43          DCB      0x64,0x3a,0x3a,0x43
000058  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
00005c  41727261          DCB      0x41,0x72,0x72,0x61
000060  79536c69          DCB      0x79,0x53,0x6c,0x69
000064  63654578          DCB      0x63,0x65,0x45,0x78
000068  70726573          DCB      0x70,0x72,0x65,0x73
00006c  73696f6e          DCB      0x73,0x69,0x6f,0x6e
000070  3c547970          DCB      0x3c,0x54,0x79,0x70
000074  653e2026          DCB      0x65,0x3e,0x20,0x26
000078  2c20496e          DCB      0x2c,0x20,0x49,0x6e
00007c  54797065          DCB      0x54,0x79,0x70,0x65
000080  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000084  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000088  456d6265          DCB      0x45,0x6d,0x62,0x65
00008c  64646564          DCB      0x64,0x64,0x65,0x64
000090  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000094  72617953          DCB      0x72,0x61,0x79,0x53
000098  6c696365          DCB      0x6c,0x69,0x63,0x65
00009c  3c4f7574          DCB      0x3c,0x4f,0x75,0x74
0000a0  54797065          DCB      0x54,0x79,0x70,0x65
0000a4  3e29205b          DCB      0x3e,0x29,0x20,0x5b
0000a8  77697468          DCB      0x77,0x69,0x74,0x68
0000ac  20496e54          DCB      0x20,0x49,0x6e,0x54
0000b0  79706520          DCB      0x79,0x70,0x65,0x20
0000b4  3d20756e          DCB      0x3d,0x20,0x75,0x6e
0000b8  7369676e          DCB      0x73,0x69,0x67,0x6e
0000bc  65642063          DCB      0x65,0x64,0x20,0x63
0000c0  6861722c          DCB      0x68,0x61,0x72,0x2c
0000c4  204f7065          DCB      0x20,0x4f,0x70,0x65
0000c8  7261746f          DCB      0x72,0x61,0x74,0x6f
0000cc  72203d20          DCB      0x72,0x20,0x3d,0x20
0000d0  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000d4  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000d8  62656464          DCB      0x62,0x65,0x64,0x64
0000dc  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000e0  4d617472          DCB      0x4d,0x61,0x74,0x72
0000e4  69783a3a          DCB      0x69,0x78,0x3a,0x3a
0000e8  456c656d          DCB      0x45,0x6c,0x65,0x6d
0000ec  656e7477          DCB      0x65,0x6e,0x74,0x77
0000f0  6973653a          DCB      0x69,0x73,0x65,0x3a
0000f4  3a446f74          DCB      0x3a,0x44,0x6f,0x74
0000f8  4d756c74          DCB      0x4d,0x75,0x6c,0x74
0000fc  69706c79          DCB      0x69,0x70,0x6c,0x79
000100  3c756e73          DCB      0x3c,0x75,0x6e,0x73
000104  69676e65          DCB      0x69,0x67,0x6e,0x65
000108  64206368          DCB      0x64,0x20,0x63,0x68
00010c  61722c20          DCB      0x61,0x72,0x2c,0x20
000110  756e7369          DCB      0x75,0x6e,0x73,0x69
000114  676e6564          DCB      0x67,0x6e,0x65,0x64
000118  20636861          DCB      0x20,0x63,0x68,0x61
00011c  722c2075          DCB      0x72,0x2c,0x20,0x75
000120  6e736967          DCB      0x6e,0x73,0x69,0x67
000124  6e656420          DCB      0x6e,0x65,0x64,0x20
000128  63686172          DCB      0x63,0x68,0x61,0x72
00012c  3e2c204f          DCB      0x3e,0x2c,0x20,0x4f
000130  75745479          DCB      0x75,0x74,0x54,0x79
000134  7065203d          DCB      0x70,0x65,0x20,0x3d
000138  20756e73          DCB      0x20,0x75,0x6e,0x73
00013c  69676e65          DCB      0x69,0x67,0x6e,0x65
000140  64206368          DCB      0x64,0x20,0x63,0x68
000144  61725d00          DCB      0x61,0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::EstimateHomography<float>(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, Anki::Embedded::Array<T1>&, bool&, Anki::Embedded::MemoryStack)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a457374          DCB      0x3a,0x45,0x73,0x74
000028  696d6174          DCB      0x69,0x6d,0x61,0x74
00002c  65486f6d          DCB      0x65,0x48,0x6f,0x6d
000030  6f677261          DCB      0x6f,0x67,0x72,0x61
000034  70687928          DCB      0x70,0x68,0x79,0x28
000038  636f6e73          DCB      0x63,0x6f,0x6e,0x73
00003c  7420416e          DCB      0x74,0x20,0x41,0x6e
000040  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000044  456d6265          DCB      0x45,0x6d,0x62,0x65
000048  64646564          DCB      0x64,0x64,0x65,0x64
00004c  3a3a4669          DCB      0x3a,0x3a,0x46,0x69
000050  7865644c          DCB      0x78,0x65,0x64,0x4c
000054  656e6774          DCB      0x65,0x6e,0x67,0x74
000058  684c6973          DCB      0x68,0x4c,0x69,0x73
00005c  743c416e          DCB      0x74,0x3c,0x41,0x6e
000060  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000064  456d6265          DCB      0x45,0x6d,0x62,0x65
000068  64646564          DCB      0x64,0x64,0x65,0x64
00006c  3a3a506f          DCB      0x3a,0x3a,0x50,0x6f
000070  696e743c          DCB      0x69,0x6e,0x74,0x3c
000074  54797065          DCB      0x54,0x79,0x70,0x65
000078  3e3e2026          DCB      0x3e,0x3e,0x20,0x26
00007c  2c20636f          DCB      0x2c,0x20,0x63,0x6f
000080  6e737420          DCB      0x6e,0x73,0x74,0x20
000084  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000088  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00008c  62656464          DCB      0x62,0x65,0x64,0x64
000090  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000094  46697865          DCB      0x46,0x69,0x78,0x65
000098  644c656e          DCB      0x64,0x4c,0x65,0x6e
00009c  6774684c          DCB      0x67,0x74,0x68,0x4c
0000a0  6973743c          DCB      0x69,0x73,0x74,0x3c
0000a4  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000a8  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000ac  62656464          DCB      0x62,0x65,0x64,0x64
0000b0  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000b4  506f696e          DCB      0x50,0x6f,0x69,0x6e
0000b8  743c5479          DCB      0x74,0x3c,0x54,0x79
0000bc  70653e3e          DCB      0x70,0x65,0x3e,0x3e
0000c0  20262c20          DCB      0x20,0x26,0x2c,0x20
0000c4  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000c8  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000cc  62656464          DCB      0x62,0x65,0x64,0x64
0000d0  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000d4  41727261          DCB      0x41,0x72,0x72,0x61
0000d8  793c5479          DCB      0x79,0x3c,0x54,0x79
0000dc  70653e20          DCB      0x70,0x65,0x3e,0x20
0000e0  262c2062          DCB      0x26,0x2c,0x20,0x62
0000e4  6f6f6c20          DCB      0x6f,0x6f,0x6c,0x20
0000e8  262c2041          DCB      0x26,0x2c,0x20,0x41
0000ec  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000f0  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000f4  65646465          DCB      0x65,0x64,0x64,0x65
0000f8  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
0000fc  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000100  79537461          DCB      0x79,0x53,0x74,0x61
000104  636b2920          DCB      0x63,0x6b,0x29,0x20
000108  5b776974          DCB      0x5b,0x77,0x69,0x74
00010c  68205479          DCB      0x68,0x20,0x54,0x79
000110  7065203d          DCB      0x70,0x65,0x20,0x3d
000114  20666c6f          DCB      0x20,0x66,0x6c,0x6f
000118  61745d00          DCB      0x61,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix8Rotate90IhhEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix8Rotate90IhhEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix8Rotate90IhhEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Rotate90<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a526f74          DCB      0x3a,0x52,0x6f,0x74
000028  61746539          DCB      0x61,0x74,0x65,0x39
00002c  3028636f          DCB      0x30,0x28,0x63,0x6f
000030  6e737420          DCB      0x6e,0x73,0x74,0x20
000034  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000038  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00003c  62656464          DCB      0x62,0x65,0x64,0x64
000040  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000044  41727261          DCB      0x41,0x72,0x72,0x61
000048  793c5479          DCB      0x79,0x3c,0x54,0x79
00004c  70653e20          DCB      0x70,0x65,0x3e,0x20
000050  262c2041          DCB      0x26,0x2c,0x20,0x41
000054  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000058  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00005c  65646465          DCB      0x65,0x64,0x64,0x65
000060  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000064  72726179          DCB      0x72,0x72,0x61,0x79
000068  3c4f7574          DCB      0x3c,0x4f,0x75,0x74
00006c  54797065          DCB      0x54,0x79,0x70,0x65
000070  3e202629          DCB      0x3e,0x20,0x26,0x29
000074  205b7769          DCB      0x20,0x5b,0x77,0x69
000078  74682049          DCB      0x74,0x68,0x20,0x49
00007c  6e547970          DCB      0x6e,0x54,0x79,0x70
000080  65203d20          DCB      0x65,0x20,0x3d,0x20
000084  756e7369          DCB      0x75,0x6e,0x73,0x69
000088  676e6564          DCB      0x67,0x6e,0x65,0x64
00008c  20636861          DCB      0x20,0x63,0x68,0x61
000090  722c204f          DCB      0x72,0x2c,0x20,0x4f
000094  75745479          DCB      0x75,0x74,0x54,0x79
000098  7065203d          DCB      0x70,0x65,0x20,0x3d
00009c  20756e73          DCB      0x20,0x75,0x6e,0x73
0000a0  69676e65          DCB      0x69,0x67,0x6e,0x65
0000a4  64206368          DCB      0x64,0x20,0x63,0x68
0000a8  61725d00          DCB      0x61,0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix9Rotate180IhhEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix9Rotate180IhhEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix9Rotate180IhhEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Rotate180<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a526f74          DCB      0x3a,0x52,0x6f,0x74
000028  61746531          DCB      0x61,0x74,0x65,0x31
00002c  38302863          DCB      0x38,0x30,0x28,0x63
000030  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000034  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000038  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00003c  6d626564          DCB      0x6d,0x62,0x65,0x64
000040  6465643a          DCB      0x64,0x65,0x64,0x3a
000044  3a417272          DCB      0x3a,0x41,0x72,0x72
000048  61793c54          DCB      0x61,0x79,0x3c,0x54
00004c  7970653e          DCB      0x79,0x70,0x65,0x3e
000050  20262c20          DCB      0x20,0x26,0x2c,0x20
000054  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000058  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00005c  62656464          DCB      0x62,0x65,0x64,0x64
000060  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000064  41727261          DCB      0x41,0x72,0x72,0x61
000068  793c4f75          DCB      0x79,0x3c,0x4f,0x75
00006c  74547970          DCB      0x74,0x54,0x79,0x70
000070  653e2026          DCB      0x65,0x3e,0x20,0x26
000074  29205b77          DCB      0x29,0x20,0x5b,0x77
000078  69746820          DCB      0x69,0x74,0x68,0x20
00007c  496e5479          DCB      0x49,0x6e,0x54,0x79
000080  7065203d          DCB      0x70,0x65,0x20,0x3d
000084  20756e73          DCB      0x20,0x75,0x6e,0x73
000088  69676e65          DCB      0x69,0x67,0x6e,0x65
00008c  64206368          DCB      0x64,0x20,0x63,0x68
000090  61722c20          DCB      0x61,0x72,0x2c,0x20
000094  4f757454          DCB      0x4f,0x75,0x74,0x54
000098  79706520          DCB      0x79,0x70,0x65,0x20
00009c  3d20756e          DCB      0x3d,0x20,0x75,0x6e
0000a0  7369676e          DCB      0x73,0x69,0x67,0x6e
0000a4  65642063          DCB      0x65,0x64,0x20,0x63
0000a8  6861725d          DCB      0x68,0x61,0x72,0x5d
0000ac  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix9Rotate270IhhEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix9Rotate270IhhEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix9Rotate270IhhEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Rotate270<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a526f74          DCB      0x3a,0x52,0x6f,0x74
000028  61746532          DCB      0x61,0x74,0x65,0x32
00002c  37302863          DCB      0x37,0x30,0x28,0x63
000030  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000034  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000038  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00003c  6d626564          DCB      0x6d,0x62,0x65,0x64
000040  6465643a          DCB      0x64,0x65,0x64,0x3a
000044  3a417272          DCB      0x3a,0x41,0x72,0x72
000048  61793c54          DCB      0x61,0x79,0x3c,0x54
00004c  7970653e          DCB      0x79,0x70,0x65,0x3e
000050  20262c20          DCB      0x20,0x26,0x2c,0x20
000054  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000058  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00005c  62656464          DCB      0x62,0x65,0x64,0x64
000060  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000064  41727261          DCB      0x41,0x72,0x72,0x61
000068  793c4f75          DCB      0x79,0x3c,0x4f,0x75
00006c  74547970          DCB      0x74,0x54,0x79,0x70
000070  653e2026          DCB      0x65,0x3e,0x20,0x26
000074  29205b77          DCB      0x29,0x20,0x5b,0x77
000078  69746820          DCB      0x69,0x74,0x68,0x20
00007c  496e5479          DCB      0x49,0x6e,0x54,0x79
000080  7065203d          DCB      0x70,0x65,0x20,0x3d
000084  20756e73          DCB      0x20,0x75,0x6e,0x73
000088  69676e65          DCB      0x69,0x67,0x6e,0x65
00008c  64206368          DCB      0x64,0x20,0x63,0x68
000090  61722c20          DCB      0x61,0x72,0x2c,0x20
000094  4f757454          DCB      0x4f,0x75,0x74,0x54
000098  79706520          DCB      0x79,0x70,0x65,0x20
00009c  3d20756e          DCB      0x3d,0x20,0x75,0x6e
0000a0  7369676e          DCB      0x73,0x69,0x67,0x6e
0000a4  65642063          DCB      0x65,0x64,0x20,0x63
0000a8  6861725d          DCB      0x68,0x61,0x72,0x5d
0000ac  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_bE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_bE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_bE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::MakeSymmetric<Anki::Embedded::Array<float>>(T1&, bool)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a4d616b          DCB      0x3a,0x4d,0x61,0x6b
000028  6553796d          DCB      0x65,0x53,0x79,0x6d
00002c  6d657472          DCB      0x6d,0x65,0x74,0x72
000030  69632854          DCB      0x69,0x63,0x28,0x54
000034  79706520          DCB      0x79,0x70,0x65,0x20
000038  262c2062          DCB      0x26,0x2c,0x20,0x62
00003c  6f6f6c29          DCB      0x6f,0x6f,0x6c,0x29
000040  205b7769          DCB      0x20,0x5b,0x77,0x69
000044  74682054          DCB      0x74,0x68,0x20,0x54
000048  79706520          DCB      0x79,0x70,0x65,0x20
00004c  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000050  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000054  456d6265          DCB      0x45,0x6d,0x62,0x65
000058  64646564          DCB      0x64,0x64,0x65,0x64
00005c  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000060  7261793c          DCB      0x72,0x61,0x79,0x3c
000064  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000068  743e5d00          DCB      0x74,0x3e,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a536f6c          DCB      0x3a,0x53,0x6f,0x6c
000028  76654c65          DCB      0x76,0x65,0x4c,0x65
00002c  61737453          DCB      0x61,0x73,0x74,0x53
000030  71756172          DCB      0x71,0x75,0x61,0x72
000034  65735769          DCB      0x65,0x73,0x57,0x69
000038  74684368          DCB      0x74,0x68,0x43,0x68
00003c  6f6c6573          DCB      0x6f,0x6c,0x65,0x73
000040  6b792841          DCB      0x6b,0x79,0x28,0x41
000044  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000048  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00004c  65646465          DCB      0x65,0x64,0x64,0x65
000050  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000054  72726179          DCB      0x72,0x72,0x61,0x79
000058  3c547970          DCB      0x3c,0x54,0x79,0x70
00005c  653e2026          DCB      0x65,0x3e,0x20,0x26
000060  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000064  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000068  456d6265          DCB      0x45,0x6d,0x62,0x65
00006c  64646564          DCB      0x64,0x64,0x65,0x64
000070  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000074  7261793c          DCB      0x72,0x61,0x79,0x3c
000078  54797065          DCB      0x54,0x79,0x70,0x65
00007c  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000080  20626f6f          DCB      0x20,0x62,0x6f,0x6f
000084  6c2c2062          DCB      0x6c,0x2c,0x20,0x62
000088  6f6f6c20          DCB      0x6f,0x6f,0x6c,0x20
00008c  2629205b          DCB      0x26,0x29,0x20,0x5b
000090  77697468          DCB      0x77,0x69,0x74,0x68
000094  20547970          DCB      0x20,0x54,0x79,0x70
000098  65203d20          DCB      0x65,0x20,0x3d,0x20
00009c  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000a0  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Transpose<float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a547261          DCB      0x3a,0x54,0x72,0x61
000028  6e73706f          DCB      0x6e,0x73,0x70,0x6f
00002c  73652863          DCB      0x73,0x65,0x28,0x63
000030  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000034  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000038  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00003c  6d626564          DCB      0x6d,0x62,0x65,0x64
000040  6465643a          DCB      0x64,0x65,0x64,0x3a
000044  3a417272          DCB      0x3a,0x41,0x72,0x72
000048  61793c54          DCB      0x61,0x79,0x3c,0x54
00004c  7970653e          DCB      0x79,0x70,0x65,0x3e
000050  20262c20          DCB      0x20,0x26,0x2c,0x20
000054  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000058  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00005c  62656464          DCB      0x62,0x65,0x64,0x64
000060  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000064  41727261          DCB      0x41,0x72,0x72,0x61
000068  793c4f75          DCB      0x79,0x3c,0x4f,0x75
00006c  74547970          DCB      0x74,0x54,0x79,0x70
000070  653e2026          DCB      0x65,0x3e,0x20,0x26
000074  29205b77          DCB      0x29,0x20,0x5b,0x77
000078  69746820          DCB      0x69,0x74,0x68,0x20
00007c  496e5479          DCB      0x49,0x6e,0x54,0x79
000080  7065203d          DCB      0x70,0x65,0x20,0x3d
000084  20666c6f          DCB      0x20,0x66,0x6c,0x6f
000088  61742c20          DCB      0x61,0x74,0x2c,0x20
00008c  4f757454          DCB      0x4f,0x75,0x74,0x54
000090  79706520          DCB      0x79,0x70,0x65,0x20
000094  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000098  6f61745d          DCB      0x6f,0x61,0x74,0x5d
00009c  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a4d756c          DCB      0x3a,0x4d,0x75,0x6c
000028  7469706c          DCB      0x74,0x69,0x70,0x6c
00002c  7928636f          DCB      0x79,0x28,0x63,0x6f
000030  6e737420          DCB      0x6e,0x73,0x74,0x20
000034  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000038  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00003c  62656464          DCB      0x62,0x65,0x64,0x64
000040  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000044  41727261          DCB      0x41,0x72,0x72,0x61
000048  793c5479          DCB      0x79,0x3c,0x54,0x79
00004c  70653e20          DCB      0x70,0x65,0x3e,0x20
000050  262c2063          DCB      0x26,0x2c,0x20,0x63
000054  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a417272          DCB      0x3a,0x41,0x72,0x72
00006c  61793c54          DCB      0x61,0x79,0x3c,0x54
000070  7970653e          DCB      0x79,0x70,0x65,0x3e
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00007c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000080  62656464          DCB      0x62,0x65,0x64,0x64
000084  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000088  41727261          DCB      0x41,0x72,0x72,0x61
00008c  793c4f75          DCB      0x79,0x3c,0x4f,0x75
000090  74547970          DCB      0x74,0x54,0x79,0x70
000094  653e2026          DCB      0x65,0x3e,0x20,0x26
000098  29205b77          DCB      0x29,0x20,0x5b,0x77
00009c  69746820          DCB      0x69,0x74,0x68,0x20
0000a0  496e5479          DCB      0x49,0x6e,0x54,0x79
0000a4  7065203d          DCB      0x70,0x65,0x20,0x3d
0000a8  20666c6f          DCB      0x20,0x66,0x6c,0x6f
0000ac  61742c20          DCB      0x61,0x74,0x2c,0x20
0000b0  4f757454          DCB      0x4f,0x75,0x74,0x54
0000b4  79706520          DCB      0x79,0x70,0x65,0x20
0000b8  3d20666c          DCB      0x3d,0x20,0x66,0x6c
0000bc  6f61745d          DCB      0x6f,0x61,0x74,0x5d
0000c0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::MultiplyTranspose<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a4d756c          DCB      0x3a,0x4d,0x75,0x6c
000028  7469706c          DCB      0x74,0x69,0x70,0x6c
00002c  79547261          DCB      0x79,0x54,0x72,0x61
000030  6e73706f          DCB      0x6e,0x73,0x70,0x6f
000034  73652863          DCB      0x73,0x65,0x28,0x63
000038  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
00003c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000040  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000044  6d626564          DCB      0x6d,0x62,0x65,0x64
000048  6465643a          DCB      0x64,0x65,0x64,0x3a
00004c  3a417272          DCB      0x3a,0x41,0x72,0x72
000050  61793c54          DCB      0x61,0x79,0x3c,0x54
000054  7970653e          DCB      0x79,0x70,0x65,0x3e
000058  20262c20          DCB      0x20,0x26,0x2c,0x20
00005c  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000060  7420416e          DCB      0x74,0x20,0x41,0x6e
000064  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000068  456d6265          DCB      0x45,0x6d,0x62,0x65
00006c  64646564          DCB      0x64,0x64,0x65,0x64
000070  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000074  7261793c          DCB      0x72,0x61,0x79,0x3c
000078  54797065          DCB      0x54,0x79,0x70,0x65
00007c  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000080  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000084  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000088  6d626564          DCB      0x6d,0x62,0x65,0x64
00008c  6465643a          DCB      0x64,0x65,0x64,0x3a
000090  3a417272          DCB      0x3a,0x41,0x72,0x72
000094  61793c4f          DCB      0x61,0x79,0x3c,0x4f
000098  75745479          DCB      0x75,0x74,0x54,0x79
00009c  70653e20          DCB      0x70,0x65,0x3e,0x20
0000a0  2629205b          DCB      0x26,0x29,0x20,0x5b
0000a4  77697468          DCB      0x77,0x69,0x74,0x68
0000a8  20496e54          DCB      0x20,0x49,0x6e,0x54
0000ac  79706520          DCB      0x79,0x70,0x65,0x20
0000b0  3d20666c          DCB      0x3d,0x20,0x66,0x6c
0000b4  6f61742c          DCB      0x6f,0x61,0x74,0x2c
0000b8  204f7574          DCB      0x20,0x4f,0x75,0x74
0000bc  54797065          DCB      0x54,0x79,0x70,0x65
0000c0  203d2066          DCB      0x20,0x3d,0x20,0x66
0000c4  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
0000c8  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded3EyeIfEENS_6ResultERNS0_5ArrayIT_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded3EyeIfEENS_6ResultERNS0_5ArrayIT_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded3EyeIfEENS_6ResultERNS0_5ArrayIT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Eye<float>(Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a457965          DCB      0x3a,0x45,0x79,0x65
000020  28416e6b          DCB      0x28,0x41,0x6e,0x6b
000024  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000028  6d626564          DCB      0x6d,0x62,0x65,0x64
00002c  6465643a          DCB      0x64,0x65,0x64,0x3a
000030  3a417272          DCB      0x3a,0x41,0x72,0x72
000034  61793c54          DCB      0x61,0x79,0x3c,0x54
000038  7970653e          DCB      0x79,0x70,0x65,0x3e
00003c  20262920          DCB      0x20,0x26,0x29,0x20
000040  5b776974          DCB      0x5b,0x77,0x69,0x74
000044  68205479          DCB      0x68,0x20,0x54,0x79
000048  7065203d          DCB      0x70,0x65,0x20,0x3d
00004c  20666c6f          DCB      0x20,0x66,0x6c,0x6f
000050  61745d00          DCB      0x61,0x74,0x5d,0x00

;*** Start embedded assembler ***

#line 1 "..\\coretech\\vision\\robot\\src\\binaryTracker.cpp"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_binaryTracker_cpp_c605df93___Z7__REV16j|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___17_binaryTracker_cpp_c605df93___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_binaryTracker_cpp_c605df93___Z7__REVSHi|
#line 144
|__asm___17_binaryTracker_cpp_c605df93___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
