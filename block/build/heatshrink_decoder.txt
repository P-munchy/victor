; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\heatshrink_decoder.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\heatshrink_decoder.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DANKICORETECH_EMBEDDED_USE_HEATSHRINK -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\heatshrink_decoder.crf ..\..\coretech-external\heatshrink\heatshrink_decoder.cpp]
                          THUMB

                          AREA ||i._Z23heatshrink_decoder_pollP18heatshrink_decoderPhjPj||, CODE, READONLY, ALIGN=1

                  _Z23heatshrink_decoder_pollP18heatshrink_decoderPhjPj PROC ; heatshrink_decoder_poll(heatshrink_decoder*, unsigned char*, unsigned, unsigned*)
;;;147    
;;;148    HSD_poll_res heatshrink_decoder_poll(heatshrink_decoder *hsd,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;149            uint8_t *out_buf, size_t out_buf_size, size_t *output_size) {
000004  4693              MOV      r11,r2
000006  0004              MOVS     r4,r0
;;;150        if ((hsd == NULL) || (out_buf == NULL) || (output_size == NULL)) {
000008  bf1d              ITTTE    NE
00000a  2900              CMPNE    r1,#0
00000c  9803              LDRNE    r0,[sp,#0xc]
00000e  2800              CMPNE    r0,#0
;;;151            return HSDR_POLL_ERROR_NULL;
000010  f04f30ff          MOVEQ    r0,#0xffffffff
;;;152        }
;;;153        *output_size = 0;
;;;154    
;;;155        output_info oi;
;;;156        oi.buf = out_buf;
;;;157        oi.buf_size = out_buf_size;
;;;158        oi.output_size = output_size;
;;;159    
;;;160        while (1) {
;;;161            LOG("-- poll, state is %d (%s), input_size %d\n",
;;;162                hsd->state, state_names[hsd->state], hsd->input_size);
;;;163            uint8_t in_state = hsd->state;
;;;164            switch (in_state) {
;;;165            case HSDS_EMPTY:
;;;166                return HSDR_POLL_EMPTY;
;;;167            case HSDS_INPUT_AVAILABLE:
;;;168                hsd->state = st_input_available(hsd);
;;;169                break;
;;;170            case HSDS_YIELD_LITERAL:
;;;171                hsd->state = st_yield_literal(hsd, &oi);
;;;172                break;
;;;173            case HSDS_BACKREF_INDEX_MSB:
;;;174                hsd->state = st_backref_index_msb(hsd);
;;;175                break;
;;;176            case HSDS_BACKREF_INDEX_LSB:
;;;177                hsd->state = st_backref_index_lsb(hsd);
;;;178                break;
;;;179            case HSDS_BACKREF_COUNT_MSB:
;;;180                hsd->state = st_backref_count_msb(hsd);
;;;181                break;
;;;182            case HSDS_BACKREF_COUNT_LSB:
;;;183                hsd->state = st_backref_count_lsb(hsd);
;;;184                break;
;;;185            case HSDS_YIELD_BACKREF:
;;;186                hsd->state = st_yield_backref(hsd, &oi);
;;;187                break;
;;;188            case HSDS_CHECK_FOR_MORE_INPUT:
;;;189                hsd->state = st_check_for_input(hsd);
;;;190                break;
;;;191            default:
;;;192                return HSDR_POLL_ERROR_UNKNOWN;
;;;193            }
;;;194            
;;;195            /* If the current state cannot advance, check if input or output
;;;196             * buffer are exhausted. */
;;;197            if (hsd->state == in_state) {
;;;198                if (*output_size == out_buf_size) { return HSDR_POLL_MORE; }
;;;199                return HSDR_POLL_EMPTY;
;;;200            }
;;;201        }
;;;202    }
000014  bf04              ITT      EQ
000016  b004              ADDEQ    sp,sp,#0x10
000018  e8bd9ff0          POPEQ    {r4-r12,pc}
00001c  2000              MOVS     r0,#0                 ;153
00001e  9a03              LDR      r2,[sp,#0xc]          ;153
000020  460e              MOV      r6,r1                 ;156
000022  6010              STR      r0,[r2,#0]            ;158
000024  9d03              LDR      r5,[sp,#0xc]          ;158
                  |L1.38|
000026  7b27              LDRB     r7,[r4,#0xc]          ;163
000028  2f09              CMP      r7,#9                 ;164
00002a  d26f              BCS      |L1.268|
00002c  e8dff007          TBB      [pc,r7]               ;164
000030  17051b35          DCB      0x17,0x05,0x1b,0x35
000034  4453626f          DCB      0x44,0x53,0x62,0x6f
000038  a300              DCB      0xa3,0x00
00003a  2101              MOVS     r1,#1                 ;164
00003c  4620              MOV      r0,r4                 ;164
00003e  f7fffffe          BL       _Z8get_bitsP18heatshrink_decoderh ; get_bits(heatshrink_decoder*, unsigned char)
000042  bb40              CBNZ     r0,|L1.150|
000044  e036              B        |L1.180|
                  |L1.70|
000046  7320              STRB     r0,[r4,#0xc]          ;168
000048  b2c0              UXTB     r0,r0                 ;197
00004a  42b8              CMP      r0,r7                 ;197
00004c  d1eb              BNE      |L1.38|
00004e  9803              LDR      r0,[sp,#0xc]          ;198
000050  6801              LDR      r1,[r0,#0]            ;198
000052  4559              CMP      r1,r11                ;198
000054  bf02              ITTT     EQ                    ;198
000056  2001              MOVEQ    r0,#1                 ;198
000058  b004              ADDEQ    sp,sp,#0x10
00005a  e8bd9ff0          POPEQ    {r4-r12,pc}
00005e  2000              MOVS     r0,#0                 ;199
000060  b004              ADD      sp,sp,#0x10
000062  e8bd9ff0          POP      {r4-r12,pc}
000066  6829              LDR      r1,[r5,#0]
000068  4559              CMP      r1,r11
00006a  d214              BCS      |L1.150|
00006c  2108              MOVS     r1,#8
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       _Z8get_bitsP18heatshrink_decoderh ; get_bits(heatshrink_decoder*, unsigned char)
000074  1c41              ADDS     r1,r0,#1
000076  d00e              BEQ      |L1.150|
000078  8921              LDRH     r1,[r4,#8]
00007a  f104028f          ADD      r2,r4,#0x8f
00007e  f3c10c0d          UBFX     r12,r1,#0,#14
000082  1c49              ADDS     r1,r1,#1
000084  8121              STRH     r1,[r4,#8]
000086  f802000c          STRB     r0,[r2,r12]
00008a  6829              LDR      r1,[r5,#0]
00008c  1c4a              ADDS     r2,r1,#1
00008e  602a              STR      r2,[r5,#0]
000090  5470              STRB     r0,[r6,r1]
000092  2008              MOVS     r0,#8
000094  e7d7              B        |L1.70|
                  |L1.150|
000096  2002              MOVS     r0,#2
000098  e7d5              B        |L1.70|
00009a  2106              MOVS     r1,#6
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       _Z8get_bitsP18heatshrink_decoderh ; get_bits(heatshrink_decoder*, unsigned char)
0000a2  1c41              ADDS     r1,r0,#1
0000a4  d006              BEQ      |L1.180|
0000a6  f64f71ff          MOV      r1,#0xffff
0000aa  ea012100          AND      r1,r1,r0,LSL #8
0000ae  80e1              STRH     r1,[r4,#6]
0000b0  2004              MOVS     r0,#4
0000b2  e7c8              B        |L1.70|
                  |L1.180|
0000b4  2003              MOVS     r0,#3
0000b6  e7c6              B        |L1.70|
0000b8  2108              MOVS     r1,#8
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       _Z8get_bitsP18heatshrink_decoderh ; get_bits(heatshrink_decoder*, unsigned char)
0000c0  1c41              ADDS     r1,r0,#1
0000c2  bf08              IT       EQ
0000c4  2004              MOVEQ    r0,#4
0000c6  d0be              BEQ      |L1.70|
0000c8  88e1              LDRH     r1,[r4,#6]
0000ca  4308              ORRS     r0,r0,r1
0000cc  1c40              ADDS     r0,r0,#1
0000ce  80e0              STRH     r0,[r4,#6]
0000d0  2000              MOVS     r0,#0
0000d2  80a0              STRH     r0,[r4,#4]
0000d4  e00c              B        |L1.240|
0000d6  21fe              MOVS     r1,#0xfe
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       _Z8get_bitsP18heatshrink_decoderh ; get_bits(heatshrink_decoder*, unsigned char)
0000de  1c41              ADDS     r1,r0,#1
0000e0  bf08              IT       EQ
0000e2  2005              MOVEQ    r0,#5
0000e4  d0af              BEQ      |L1.70|
0000e6  f64f71ff          MOV      r1,#0xffff
0000ea  ea012100          AND      r1,r1,r0,LSL #8
0000ee  80a1              STRH     r1,[r4,#4]
                  |L1.240|
0000f0  2006              MOVS     r0,#6
0000f2  e7a8              B        |L1.70|
0000f4  2106              MOVS     r1,#6
0000f6  4620              MOV      r0,r4
0000f8  f7fffffe          BL       _Z8get_bitsP18heatshrink_decoderh ; get_bits(heatshrink_decoder*, unsigned char)
0000fc  1c41              ADDS     r1,r0,#1
0000fe  d0f7              BEQ      |L1.240|
000100  88a1              LDRH     r1,[r4,#4]
000102  4308              ORRS     r0,r0,r1
000104  1c40              ADDS     r0,r0,#1
000106  80a0              STRH     r0,[r4,#4]
000108  2007              MOVS     r0,#7
00010a  e79c              B        |L1.70|
                  |L1.268|
00010c  e038              B        |L1.384|
00010e  6829              LDR      r1,[r5,#0]
000110  ebbb0001          SUBS     r0,r11,r1
000114  d02d              BEQ      |L1.370|
000116  88a1              LDRH     r1,[r4,#4]
000118  4281              CMP      r1,r0
00011a  bf38              IT       CC
00011c  4608              MOVCC    r0,r1
00011e  f104088f          ADD      r8,r4,#0x8f
000122  f8b4a006          LDRH     r10,[r4,#6]
000126  2200              MOVS     r2,#0
000128  f6437cff          MOV      r12,#0x3fff
00012c  2800              CMP      r0,#0
00012e  d917              BLS      |L1.352|
                  |L1.304|
000130  8921              LDRH     r1,[r4,#8]
000132  682b              LDR      r3,[r5,#0]
000134  eba1010a          SUB      r1,r1,r10
000138  ea01010c          AND      r1,r1,r12
00013c  f1030901          ADD      r9,r3,#1
000140  f8181001          LDRB     r1,[r8,r1]
000144  f8c59000          STR      r9,[r5,#0]
000148  54f1              STRB     r1,[r6,r3]
00014a  8923              LDRH     r3,[r4,#8]
00014c  1c52              ADDS     r2,r2,#1
00014e  ea03030c          AND      r3,r3,r12
000152  f8081003          STRB     r1,[r8,r3]
000156  8921              LDRH     r1,[r4,#8]
000158  1c49              ADDS     r1,r1,#1
00015a  8121              STRH     r1,[r4,#8]
00015c  4290              CMP      r0,r2
00015e  d8e7              BHI      |L1.304|
                  |L1.352|
000160  88a1              LDRH     r1,[r4,#4]
000162  1a08              SUBS     r0,r1,r0
000164  0400              LSLS     r0,r0,#16
000166  0c00              LSRS     r0,r0,#16
000168  80a0              STRH     r0,[r4,#4]
00016a  bf08              IT       EQ
00016c  2008              MOVEQ    r0,#8
00016e  f43faf6a          BEQ      |L1.70|
                  |L1.370|
000172  2007              MOVS     r0,#7
000174  e767              B        |L1.70|
000176  8820              LDRH     r0,[r4,#0]
000178  2800              CMP      r0,#0
00017a  bf18              IT       NE
00017c  2001              MOVNE    r0,#1
00017e  e762              B        |L1.70|
                  |L1.384|
000180  b004              ADD      sp,sp,#0x10
000182  f06f0001          MVN      r0,#1                 ;192
000186  e8bd9ff0          POP      {r4-r12,pc}
;;;203    
                          ENDP


                          AREA ||i._Z23heatshrink_decoder_sinkP18heatshrink_decoderPhjPj||, CODE, READONLY, ALIGN=1

                  _Z23heatshrink_decoder_sinkP18heatshrink_decoderPhjPj PROC ; heatshrink_decoder_sink(heatshrink_decoder*, unsigned char*, unsigned, unsigned*)
;;;102    /* Copy SIZE bytes into the decoder's input buffer, if it will fit. */
;;;103    HSD_sink_res heatshrink_decoder_sink(heatshrink_decoder *hsd,
000000  2800              CMP      r0,#0
;;;104            uint8_t *in_buf, size_t size, size_t *input_size) {
;;;105        if ((hsd == NULL) || (in_buf == NULL) || (input_size == NULL)) {
000002  bf19              ITTEE    NE
000004  2900              CMPNE    r1,#0
000006  2b00              CMPNE    r3,#0
;;;106            return HSDR_SINK_ERROR_NULL;
000008  f04f30ff          MOVEQ    r0,#0xffffffff
;;;107        }
;;;108    
;;;109        size_t rem = HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd) - hsd->input_size;
;;;110        if (rem == 0) {
;;;111            *input_size = 0;
;;;112            return HSDR_SINK_FULL;
;;;113        }
;;;114    
;;;115        size = rem < size ? rem : size;
;;;116        LOG("-- sinking %zd bytes\n", size);
;;;117        /* copy into input buffer (at head of buffers) */
;;;118        memcpy(&hsd->buffers[hsd->input_size], in_buf, size);
;;;119        hsd->input_size += size;
;;;120        if (hsd->state == HSDS_EMPTY) {
;;;121            hsd->state = HSDS_INPUT_AVAILABLE;
;;;122            hsd->input_index = 0;
;;;123        }
;;;124        *input_size = size;
;;;125        return HSDR_SINK_OK;
;;;126    }
00000c  4770              BXEQ     lr
00000e  e92d41f0          PUSH     {r4-r8,lr}            ;104
000012  461d              MOV      r5,r3                 ;104
000014  8803              LDRH     r3,[r0,#0]            ;109
000016  4604              MOV      r4,r0                 ;104
000018  f1d30080          RSBS     r0,r3,#0x80           ;109
00001c  f04f0700          MOV      r7,#0                 ;109
000020  bf02              ITTT     EQ                    ;112
000022  2001              MOVEQ    r0,#1                 ;112
000024  602f              STREQ    r7,[r5,#0]            ;112
000026  e8bd81f0          POPEQ    {r4-r8,pc}
00002a  4290              CMP      r0,r2                 ;115
00002c  bf28              IT       CS                    ;115
00002e  4610              MOVCS    r0,r2                 ;115
000030  4606              MOV      r6,r0                 ;115
000032  f104000f          ADD      r0,r4,#0xf            ;118
000036  4418              ADD      r0,r0,r3              ;118
000038  4632              MOV      r2,r6                 ;118
00003a  f7fffffe          BL       __aeabi_memcpy
00003e  8820              LDRH     r0,[r4,#0]            ;119
000040  4430              ADD      r0,r0,r6              ;119
000042  8020              STRH     r0,[r4,#0]            ;119
000044  7b20              LDRB     r0,[r4,#0xc]          ;120
000046  b910              CBNZ     r0,|L2.78|
000048  2001              MOVS     r0,#1                 ;121
00004a  7320              STRB     r0,[r4,#0xc]          ;121
00004c  8067              STRH     r7,[r4,#2]            ;122
                  |L2.78|
00004e  2000              MOVS     r0,#0                 ;125
000050  602e              STR      r6,[r5,#0]            ;125
000052  e8bd81f0          POP      {r4-r8,pc}
;;;127    
                          ENDP


                          AREA ||i._Z24heatshrink_decoder_resetP18heatshrink_decoder||, CODE, READONLY, ALIGN=1

                  _Z24heatshrink_decoder_resetP18heatshrink_decoder PROC ; heatshrink_decoder_reset(heatshrink_decoder*)
;;;86     
;;;87     void heatshrink_decoder_reset(heatshrink_decoder *hsd) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;88         size_t buf_sz = 1 << HEATSHRINK_DECODER_WINDOW_BITS(hsd);
;;;89         size_t input_sz = HEATSHRINK_DECODER_INPUT_BUFFER_SIZE(hsd);
;;;90         memset(hsd->buffers, 0, buf_sz + input_sz);
;;;91         hsd->state = HSDS_EMPTY;
;;;92         hsd->input_size = 0;
;;;93         hsd->input_index = 0;
;;;94         hsd->bit_index = 0x00;
;;;95         hsd->current_byte = 0x00;
;;;96         hsd->output_count = 0;
;;;97         hsd->output_index = 0;
;;;98         hsd->head_index = 0;
;;;99         hsd->bit_accumulator = 0x00000000;
;;;100    }
000004  f44f4181          MOV      r1,#0x4080
000008  300f              ADDS     r0,r0,#0xf            ;90
00000a  f7fffffe          BL       __aeabi_memclr
00000e  2000              MOVS     r0,#0                 ;91
000010  7320              STRB     r0,[r4,#0xc]          ;91
000012  8020              STRH     r0,[r4,#0]            ;92
000014  8060              STRH     r0,[r4,#2]            ;93
000016  73a0              STRB     r0,[r4,#0xe]          ;94
000018  7360              STRB     r0,[r4,#0xd]          ;95
00001a  80a0              STRH     r0,[r4,#4]            ;96
00001c  80e0              STRH     r0,[r4,#6]            ;97
00001e  8120              STRH     r0,[r4,#8]            ;98
000020  8160              STRH     r0,[r4,#0xa]          ;99
000022  bd10              POP      {r4,pc}
;;;101    
                          ENDP


                          AREA ||i._Z25heatshrink_decoder_finishP18heatshrink_decoder||, CODE, READONLY, ALIGN=1

                  _Z25heatshrink_decoder_finishP18heatshrink_decoder PROC ; heatshrink_decoder_finish(heatshrink_decoder*)
;;;356    
;;;357    HSD_finish_res heatshrink_decoder_finish(heatshrink_decoder *hsd) {
000000  2800              CMP      r0,#0
;;;358        if (hsd == NULL) { return HSDR_FINISH_ERROR_NULL; }
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;359        switch (hsd->state) {
;;;360        case HSDS_EMPTY:
;;;361            return HSDR_FINISH_DONE;
;;;362    
;;;363        /* If we want to finish with no input, but are in these states, it's
;;;364         * because the 0-bit padding to the last byte looks like a backref
;;;365         * marker bit followed by all 0s for index and count bits. */
;;;366        case HSDS_BACKREF_INDEX_LSB:
;;;367        case HSDS_BACKREF_INDEX_MSB:
;;;368        case HSDS_BACKREF_COUNT_LSB:
;;;369        case HSDS_BACKREF_COUNT_MSB:
;;;370            return hsd->input_size == 0 ? HSDR_FINISH_DONE : HSDR_FINISH_MORE;
;;;371        /* fall through */
;;;372        default:
;;;373            return HSDR_FINISH_MORE;
;;;374        }
;;;375    }
000008  4770              BXEQ     lr
00000a  7b01              LDRB     r1,[r0,#0xc]          ;359
00000c  2907              CMP      r1,#7                 ;359
00000e  d20b              BCS      |L4.40|
000010  e8dff001          TBB      [pc,r1]               ;359
000014  040a0a06          DCB      0x04,0x0a,0x0a,0x06
000018  06060600          DCB      0x06,0x06,0x06,0x00
00001c  2000              MOVS     r0,#0                 ;361
00001e  4770              BX       lr
000020  8800              LDRH     r0,[r0,#0]            ;370
000022  2800              CMP      r0,#0                 ;370
000024  bf08              IT       EQ
000026  4770              BXEQ     lr
                  |L4.40|
000028  2001              MOVS     r0,#1                 ;370
00002a  4770              BX       lr
;;;376    
                          ENDP


                          AREA ||i._Z8get_bitsP18heatshrink_decoderh||, CODE, READONLY, ALIGN=1

                  _Z8get_bitsP18heatshrink_decoderh PROC ; get_bits(heatshrink_decoder*, unsigned char)
;;;308     * Returns NO_BITS on end of input, or if more than 31 bits are requested. */
;;;309    static uint32_t get_bits(heatshrink_decoder *hsd, uint8_t count) {
000000  291f              CMP      r1,#0x1f
;;;310        if (count > 31) { return NO_BITS; }
000002  d809              BHI      |L5.24|
;;;311        LOG("-- popping %u bit(s)\n", count);
;;;312    
;;;313        /* If we aren't able to get COUNT bits, suspend immediately, because we
;;;314         * don't track how many bits of COUNT we've accumulated before suspend. */
;;;315        if (hsd->input_size == 0) {
000004  8802              LDRH     r2,[r0,#0]
000006  b952              CBNZ     r2,|L5.30|
;;;316            if (hsd->bit_index < (1 << (count - 1))) { return NO_BITS; }
000008  7b82              LDRB     r2,[r0,#0xe]
00000a  1e4b              SUBS     r3,r1,#1
00000c  f04f0c01          MOV      r12,#1
000010  fa0cf303          LSL      r3,r12,r3
000014  429a              CMP      r2,r3
000016  da02              BGE      |L5.30|
                  |L5.24|
000018  f04f30ff          MOV      r0,#0xffffffff
;;;317        }
;;;318    
;;;319        for (int i = 0; i < count; i++) {
;;;320            if (hsd->bit_index == 0x00) {
;;;321                if (hsd->input_size == 0) {
;;;322                    LOG("  -- out of bits, suspending w/ accumulator of %u (0x%02x)\n",
;;;323                        hsd->bit_accumulator, hsd->bit_accumulator);
;;;324                    return NO_BITS;
;;;325                }
;;;326                hsd->current_byte = hsd->buffers[hsd->input_index++];
;;;327                LOG("  -- pulled byte 0x%02x\n", hsd->current_byte);
;;;328                if (hsd->input_index == hsd->input_size) {
;;;329                    hsd->input_index = 0; /* input is exhausted */
;;;330                    hsd->input_size = 0;
;;;331                }
;;;332                hsd->bit_index = 0x80;
;;;333            }
;;;334            hsd->bit_accumulator <<= 1;
;;;335            if (hsd->current_byte & hsd->bit_index) {
;;;336                hsd->bit_accumulator |= 0x01;
;;;337                if (0) {
;;;338                    LOG("  -- got 1, accumulator 0x%04x, bit_index 0x%02x\n",
;;;339                    hsd->bit_accumulator, hsd->bit_index);
;;;340                }
;;;341            } else {
;;;342                if (0) {
;;;343                    LOG("  -- got 0, accumulator 0x%04x, bit_index 0x%02x\n",
;;;344                    hsd->bit_accumulator, hsd->bit_index);
;;;345                }
;;;346            }
;;;347            hsd->bit_index >>= 1;
;;;348        }
;;;349    
;;;350        uint32_t res = 0;
;;;351        res = hsd->bit_accumulator;
;;;352        hsd->bit_accumulator = 0x00000000;
;;;353        if (count > 1) { LOG("  -- accumulated %08x\n", res); }
;;;354        return res;
;;;355    }
00001c  4770              BX       lr
                  |L5.30|
00001e  e92d01f0          PUSH     {r4-r8}               ;309
000022  2200              MOVS     r2,#0                 ;319
000024  4616              MOV      r6,r2                 ;319
000026  2900              CMP      r1,#0                 ;319
000028  dd18              BLE      |L5.92|
00002a  f100050f          ADD      r5,r0,#0xf            ;326
00002e  2780              MOVS     r7,#0x80              ;332
000030  f64f78ff          MOV      r8,#0xffff            ;334
                  |L5.52|
000034  7b83              LDRB     r3,[r0,#0xe]          ;320
000036  b1bb              CBZ      r3,|L5.104|
                  |L5.56|
000038  8943              LDRH     r3,[r0,#0xa]          ;334
00003a  ea080c43          AND      r12,r8,r3,LSL #1      ;334
00003e  f8a0c00a          STRH     r12,[r0,#0xa]         ;334
000042  7b44              LDRB     r4,[r0,#0xd]          ;335
000044  7b83              LDRB     r3,[r0,#0xe]          ;335
000046  421c              TST      r4,r3                 ;335
000048  bf1c              ITT      NE                    ;336
00004a  f04c0c01          ORRNE    r12,r12,#1            ;336
00004e  f8a0c00a          STRHNE   r12,[r0,#0xa]         ;336
000052  085b              LSRS     r3,r3,#1              ;347
000054  1c52              ADDS     r2,r2,#1              ;319
000056  7383              STRB     r3,[r0,#0xe]          ;347
000058  428a              CMP      r2,r1                 ;319
00005a  dbeb              BLT      |L5.52|
                  |L5.92|
00005c  8941              LDRH     r1,[r0,#0xa]          ;351
00005e  8146              STRH     r6,[r0,#0xa]          ;352
000060  e8bd01f0          POP      {r4-r8}
000064  4608              MOV      r0,r1                 ;354
000066  4770              BX       lr
                  |L5.104|
000068  8804              LDRH     r4,[r0,#0]            ;321
00006a  b174              CBZ      r4,|L5.138|
00006c  8843              LDRH     r3,[r0,#2]            ;326
00006e  f1030c01          ADD      r12,r3,#1             ;326
000072  fa1ffc8c          UXTH     r12,r12               ;326
000076  f8a0c002          STRH     r12,[r0,#2]           ;326
00007a  5d5b              LDRB     r3,[r3,r5]            ;326
00007c  7343              STRB     r3,[r0,#0xd]          ;326
00007e  45a4              CMP      r12,r4                ;328
000080  bf04              ITT      EQ                    ;329
000082  8046              STRHEQ   r6,[r0,#2]            ;329
000084  8006              STRHEQ   r6,[r0,#0]            ;330
000086  7387              STRB     r7,[r0,#0xe]          ;332
000088  e7d6              B        |L5.56|
                  |L5.138|
00008a  e8bd01f0          POP      {r4-r8}
00008e  f04f30ff          MOV      r0,#0xffffffff        ;324
000092  4770              BX       lr
;;;356    
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._Z24heatshrink_decoder_resetP18heatshrink_decoder||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._Z24heatshrink_decoder_resetP18heatshrink_decoder||
                          DCD      0x00000001

                          AREA ||area_number.7||, LINKORDER=||i._Z23heatshrink_decoder_sinkP18heatshrink_decoderPhjPj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z23heatshrink_decoder_sinkP18heatshrink_decoderPhjPj||
                          DCD      0x00000001

                          AREA ||area_number.8||, LINKORDER=||i._Z8get_bitsP18heatshrink_decoderh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8get_bitsP18heatshrink_decoderh||
                          DCD      0x00000001

                          AREA ||area_number.9||, LINKORDER=||i._Z23heatshrink_decoder_pollP18heatshrink_decoderPhjPj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z23heatshrink_decoder_pollP18heatshrink_decoderPhjPj||
                          DCD      0x00000001

                          AREA ||area_number.10||, LINKORDER=||i._Z25heatshrink_decoder_finishP18heatshrink_decoder||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z25heatshrink_decoder_finishP18heatshrink_decoder||
                          DCD      0x00000001
