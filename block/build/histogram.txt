; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\histogram.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\histogram.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\histogram.crf ..\coretech\vision\robot\src\histogram.cpp]
                          THUMB

                          AREA ||i._ZN4Anki8Embedded13IntegerCounts3SetERKS1_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded13IntegerCounts3SetERKS1_ PROC ; Anki::Embedded::IntegerCounts::Set(const Anki::Embedded::IntegerCounts&)
;;;208    
;;;209        Result IntegerCounts::Set(const IntegerCounts &in)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;210        {
000004  460c              MOV      r4,r1
000006  4605              MOV      r5,r0
000008  68c9              LDR      r1,[r1,#0xc]
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  b090              SUB      sp,sp,#0x40
;;;211          AnkiConditionalErrorAndReturnValue(in.counts.get_size() == this->counts.get_size(),
00000e  4281              CMP      r1,r0
000010  d00d              BEQ      |L1.46|
000012  21d3              MOVS     r1,#0xd3
000014  4817              LDR      r0,|L1.116|
000016  e9cd0100          STRD     r0,r1,[sp,#0]
00001a  a317              ADR      r3,|L1.120|
00001c  a221              ADR      r2,|L1.164|
00001e  a128              ADR      r1,|L1.192|
000020  2005              MOVS     r0,#5
000022  f7fffffe          BL       _Anki_Log
;;;212            RESULT_FAIL, "Histogram::Set", "counts must be allocated");
;;;213    
;;;214          this->counts.Set(in.counts);
;;;215          this->numElements = in.numElements;
;;;216    
;;;217          return RESULT_OK;
;;;218        }
000026  b010              ADD      sp,sp,#0x40
000028  2001              MOVS     r0,#1                 ;211
00002a  e8bd87f0          POP      {r4-r10,pc}
                  |L1.46|
00002e  f1040710          ADD      r7,r4,#0x10
000032  e9d40c00          LDRD     r0,r12,[r4,#0]
000036  e8970780          LDM      r7,{r7-r10}
00003a  68a6              LDR      r6,[r4,#8]
00003c  e9cd0c02          STRD     r0,r12,[sp,#8]
000040  a805              ADD      r0,sp,#0x14
000042  9604              STR      r6,[sp,#0x10]
000044  e8a00782          STM      r0!,{r1,r7-r10}
000048  f1040020          ADD      r0,r4,#0x20
00004c  af0a              ADD      r7,sp,#0x28
00004e  e8901043          LDM      r0,{r0,r1,r6,r12}
000052  e8a71043          STM      r7!,{r0,r1,r6,r12}
000056  2200              MOVS     r2,#0                 ;214
000058  ab02              ADD      r3,sp,#8              ;214
00005a  f88d2038          STRB     r2,[sp,#0x38]         ;214
00005e  2201              MOVS     r2,#1                 ;214
000060  4619              MOV      r1,r3                 ;214
000062  4628              MOV      r0,r5                 ;214
000064  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceIiE7SetCastIiEEiRKNS0_25ConstArraySliceExpressionIiEEb ; Anki::Embedded::ArraySlice<int>::SetCast<int>(const Anki::Embedded::ConstArraySliceExpression<int>&, bool)
000068  6b60              LDR      r0,[r4,#0x34]         ;215
00006a  6368              STR      r0,[r5,#0x34]         ;217
00006c  b010              ADD      sp,sp,#0x40
00006e  2000              MOVS     r0,#0                 ;217
000070  e8bd87f0          POP      {r4-r10,pc}
;;;219    
                          ENDP

                  |L1.116|
                          DCD      ||.constdata||+0x181
                  |L1.120|
000078  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\histogram.cpp",0
00007c  6f726574
000080  6563685c
000084  76697369
000088  6f6e5c72
00008c  6f626f74
000090  5c737263
000094  5c686973
000098  746f6772
00009c  616d2e63
0000a0  707000  
0000a3  00                DCB      0
                  |L1.164|
0000a4  636f756e          DCB      "counts must be allocated",0
0000a8  7473206d
0000ac  75737420
0000b0  62652061
0000b4  6c6c6f63
0000b8  61746564
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L1.192|
0000c0  48697374          DCB      "Histogram::Set",0
0000c4  6f677261
0000c8  6d3a3a53
0000cc  657400  
0000cf  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded13IntegerCountsC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEiiRNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded13IntegerCountsC2ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEiiRNS0_11MemoryStackE                  ; Alternate entry point ; Anki::Embedded::IntegerCounts::IntegerCounts__sub_object(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, int, int, Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded13IntegerCountsC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEiiRNS0_11MemoryStackE PROC ; Anki::Embedded::IntegerCounts::IntegerCounts(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, int, int, Anki::Embedded::MemoryStack&)
;;;63     
;;;64         IntegerCounts::IntegerCounts(const Array<u8> &image, const Quadrilateral<f32> &imageRegionOfInterest, const s32 yIncrement, const s32 xIncrement, MemoryStack &memory)
;;;65           : counts(FixedLengthList<s32>()), numElements(-1)
;;;66         {
;;;67           // Based off DrawFilledConvexQuadrilateral()
;;;68     
;;;69           const s32 imageHeight = image.get_size(0);
;;;70           const s32 imageWidth = image.get_size(1);
;;;71     
;;;72           this->counts = FixedLengthList<s32>(256, memory);
;;;73           this->counts.set_size(this->counts.get_maximumSize());
;;;74     
;;;75           AnkiConditionalErrorAndReturn(this->counts.IsValid(),
;;;76             "IntegerCounts::IntegerCounts", "Out of memory");
;;;77     
;;;78           this->counts.set_size(this->counts.get_maximumSize());
;;;79           this->counts.SetZero();
;;;80     
;;;81           s32 * restrict pCounts = this->counts.Pointer(0);
;;;82     
;;;83           this->numElements = 0;
;;;84     
;;;85           const Rectangle<f32> boundingRect = imageRegionOfInterest.ComputeBoundingRectangle<f32>();
;;;86           const Quadrilateral<f32> sortedQuad = imageRegionOfInterest.ComputeClockwiseCorners<f32>();
;;;87     
;;;88           const f32 rect_y0 = boundingRect.top;
;;;89           const f32 rect_y1 = boundingRect.bottom;
;;;90     
;;;91           // For circular indexing
;;;92           Point<f32> corners[5];
;;;93           for(s32 i=0; i<4; i++) {
;;;94             corners[i] = sortedQuad[i];
;;;95           }
;;;96           corners[4] = sortedQuad[0];
;;;97     
;;;98           const s32 minYS32 = MAX(0,             Round<s32>(ceilf(rect_y0 - 0.5f)));
;;;99           const s32 maxYS32 = MIN(imageHeight-1, Round<s32>(floorf(rect_y1 - 0.5f)));
;;;100          const f32 minYF32 = minYS32 + 0.5f;
;;;101          const f32 maxYF32 = maxYS32 + 0.5f;
;;;102          const LinearSequence<f32> ys(minYF32, maxYF32);
;;;103          const s32 numYs = ys.get_size();
;;;104    
;;;105          f32 yF32 = ys.get_start();
;;;106          for(s32 iy=0; iy<numYs; iy+=yIncrement) {
;;;107            // Compute all intersections
;;;108            f32 minXF32 = FLT_MAX;
;;;109            f32 maxXF32 = FLT_MIN;
;;;110            for(s32 iCorner=0; iCorner<4; iCorner++) {
;;;111              if( (corners[iCorner].y < yF32 && corners[iCorner+1].y >= yF32) || (corners[iCorner+1].y < yF32 && corners[iCorner].y >= yF32) ) {
;;;112                const f32 dy = corners[iCorner+1].y - corners[iCorner].y;
;;;113                const f32 dx = corners[iCorner+1].x - corners[iCorner].x;
;;;114    
;;;115                const f32 alpha = (yF32 - corners[iCorner].y) / dy;
;;;116    
;;;117                const f32 xIntercept = corners[iCorner].x + alpha * dx;
;;;118    
;;;119                minXF32 = MIN(minXF32, xIntercept);
;;;120                maxXF32 = MAX(maxXF32, xIntercept);
;;;121              }
;;;122            } // for(s32 iCorner=0; iCorner<4; iCorner++)
;;;123    
;;;124            const s32 minXS32 = MAX(0,            Round<s32>(floorf(minXF32+0.5f)));
;;;125            const s32 maxXS32 = MIN(imageWidth-1, Round<s32>(floorf(maxXF32-0.5f)));
;;;126    
;;;127            const s32 yS32 = minYS32 + iy;
;;;128            const u8 * restrict pImage = image.Pointer(yS32, 0);
;;;129            for(s32 x=minXS32; x<=maxXS32; x+=xIncrement) {
;;;130              const u8 curImage = pImage[x];
;;;131              pCounts[curImage]++;
;;;132              this->numElements++;
;;;133            }
;;;134    
;;;135            yF32 += static_cast<f32>(yIncrement);
;;;136          } // for(s32 iy=0; iy<numYs; iy++)
;;;137        } // IntegerCounts::IntegerCounts(const Array<u8> &image, const Quadrilateral<f32> &imageRegionOfInterest, const s32 yIncrement, const s32 xIncrement, MemoryStack &memory)
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  4698              MOV      r8,r3
000006  ed2d8b06          VPUSH    {d8-d10}
00000a  b0ab              SUB      sp,sp,#0xac
00000c  4692              MOV      r10,r2
00000e  4689              MOV      r9,r1
000010  e9dd763a          LDRD     r7,r6,[sp,#0xe8]
000014  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiEC1Ev ; Anki::Embedded::FixedLengthList<int>::FixedLengthList()
000018  4604              MOV      r4,r0
00001a  f04f30ff          MOV      r0,#0xffffffff
00001e  6360              STR      r0,[r4,#0x34]
000020  2100              MOVS     r1,#0
000022  4648              MOV      r0,r9
000024  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000028  4605              MOV      r5,r0
00002a  2101              MOVS     r1,#1
00002c  4648              MOV      r0,r9
00002e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000032  2300              MOVS     r3,#0
000034  9028              STR      r0,[sp,#0xa0]
000036  461a              MOV      r2,r3
000038  2101              MOVS     r1,#1
00003a  a829              ADD      r0,sp,#0xa4
00003c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000040  6803              LDR      r3,[r0,#0]
000042  4632              MOV      r2,r6
000044  f44f7180          MOV      r1,#0x100
000048  a818              ADD      r0,sp,#0x60
00004a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<int>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00004e  e9d01200          LDRD     r1,r2,[r0,#0]
000052  6883              LDR      r3,[r0,#8]
000054  60a3              STR      r3,[r4,#8]
000056  e9c41200          STRD     r1,r2,[r4,#0]
00005a  e9d01203          LDRD     r1,r2,[r0,#0xc]
00005e  6943              LDR      r3,[r0,#0x14]
000060  6163              STR      r3,[r4,#0x14]
000062  e9c41203          STRD     r1,r2,[r4,#0xc]
000066  6981              LDR      r1,[r0,#0x18]
000068  61a1              STR      r1,[r4,#0x18]
00006a  69c1              LDR      r1,[r0,#0x1c]
00006c  61e1              STR      r1,[r4,#0x1c]
00006e  6a01              LDR      r1,[r0,#0x20]
000070  6221              STR      r1,[r4,#0x20]
000072  6a41              LDR      r1,[r0,#0x24]
000074  6261              STR      r1,[r4,#0x24]
000076  6a81              LDR      r1,[r0,#0x28]
000078  62a1              STR      r1,[r4,#0x28]
00007a  6ac1              LDR      r1,[r0,#0x2c]
00007c  62e1              STR      r1,[r4,#0x2c]
00007e  6b00              LDR      r0,[r0,#0x30]
000080  f1040218          ADD      r2,r4,#0x18
000084  6320              STR      r0,[r4,#0x30]
000086  2101              MOVS     r1,#1
000088  4610              MOV      r0,r2
00008a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
00008e  4601              MOV      r1,r0
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi ; Anki::Embedded::FixedLengthList<int>::set_size(int)
000096  2101              MOVS     r1,#1
000098  f1040018          ADD      r0,r4,#0x18
00009c  68e6              LDR      r6,[r4,#0xc]
00009e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
0000a2  4286              CMP      r6,r0
0000a4  dc2f              BGT      |L2.262|
0000a6  6aa0              LDR      r0,[r4,#0x28]
0000a8  b130              CBZ      r0,|L2.184|
0000aa  69a0              LDR      r0,[r4,#0x18]
0000ac  2800              CMP      r0,#0
0000ae  bfa3              ITTTE    GE
0000b0  69e0              LDRGE    r0,[r4,#0x1c]
0000b2  2800              CMPGE    r0,#0
0000b4  2001              MOVGE    r0,#1
0000b6  2000              MOVLT    r0,#0
                  |L2.184|
0000b8  b328              CBZ      r0,|L2.262|
0000ba  2101              MOVS     r1,#1
0000bc  f1040018          ADD      r0,r4,#0x18
0000c0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
0000c4  4601              MOV      r1,r0
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi ; Anki::Embedded::FixedLengthList<int>::set_size(int)
0000cc  6aa0              LDR      r0,[r4,#0x28]
0000ce  f1040618          ADD      r6,r4,#0x18
0000d2  f04f0b00          MOV      r11,#0
0000d6  2800              CMP      r0,#0
0000d8  d025              BEQ      |L2.294|
0000da  6830              LDR      r0,[r6,#0]
0000dc  2800              CMP      r0,#0
0000de  bfa4              ITT      GE
0000e0  6870              LDRGE    r0,[r6,#4]
0000e2  2800              CMPGE    r0,#0
0000e4  db1f              BLT      |L2.294|
0000e6  2100              MOVS     r1,#0
0000e8  4630              MOV      r0,r6
0000ea  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
0000ee  4601              MOV      r1,r0
0000f0  68b0              LDR      r0,[r6,#8]
0000f2  6933              LDR      r3,[r6,#0x10]
0000f4  fb01f200          MUL      r2,r1,r0
0000f8  2100              MOVS     r1,#0
0000fa  fb013000          MLA      r0,r1,r0,r3
0000fe  4611              MOV      r1,r2
000100  f7fffffe          BL       __aeabi_memclr4
000104  e01c              B        |L2.320|
                  |L2.262|
000106  214b              MOVS     r1,#0x4b
000108  48c6              LDR      r0,|L2.1060|
00010a  e9cd0100          STRD     r0,r1,[sp,#0]
00010e  a3c6              ADR      r3,|L2.1064|
000110  a2d0              ADR      r2,|L2.1108|
000112  a1d4              ADR      r1,|L2.1124|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  4620              MOV      r0,r4
                  |L2.284|
00011c  b02b              ADD      sp,sp,#0xac
00011e  ecbd8b06          VPOP     {d8-d10}
000122  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.294|
000126  f2402176          MOV      r1,#0x276
00012a  48d6              LDR      r0,|L2.1156|
00012c  4bd6              LDR      r3,|L2.1160|
00012e  e9cd0100          STRD     r0,r1,[sp,#0]
000132  f103027c          ADD      r2,r3,#0x7c
000136  f1a20118          SUB      r1,r2,#0x18
00013a  2005              MOVS     r0,#5
00013c  f7fffffe          BL       _Anki_Log
                  |L2.320|
000140  6b26              LDR      r6,[r4,#0x30]
000142  f8c4b034          STR      r11,[r4,#0x34]
000146  ed9a0a00          VLDR     s0,[r10,#0]
00014a  edda0a01          VLDR     s1,[r10,#4]
00014e  ed8d0a14          VSTR     s0,[sp,#0x50]
000152  ed8d0a15          VSTR     s0,[sp,#0x54]
000156  edcd0a16          VSTR     s1,[sp,#0x58]
00015a  a814              ADD      r0,sp,#0x50
00015c  edcd0a17          VSTR     s1,[sp,#0x5c]
000160  2101              MOVS     r1,#1
                  |L2.354|
000162  eb0a02c1          ADD      r2,r10,r1,LSL #3
000166  ed900a00          VLDR     s0,[r0,#0]
00016a  edd20a00          VLDR     s1,[r2,#0]
00016e  eeb40ae0          VCMPE.F32 s0,s1
000172  eef1fa10          VMRS     APSR_nzcv,FPSCR
000176  bf28              IT       CS
000178  eeb00a60          VMOVCS.F32 s0,s1
00017c  ed800a00          VSTR     s0,[r0,#0]
000180  ed900a01          VLDR     s0,[r0,#4]
000184  edd20a00          VLDR     s1,[r2,#0]
000188  eeb40ae0          VCMPE.F32 s0,s1
00018c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000190  bfd8              IT       LE
000192  eeb00a60          VMOVLE.F32 s0,s1
000196  ed800a01          VSTR     s0,[r0,#4]
00019a  ed900a02          VLDR     s0,[r0,#8]
00019e  edd20a01          VLDR     s1,[r2,#4]
0001a2  eeb40ae0          VCMPE.F32 s0,s1
0001a6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001aa  bf28              IT       CS
0001ac  eeb00a60          VMOVCS.F32 s0,s1
0001b0  ed800a02          VSTR     s0,[r0,#8]
0001b4  edd00a03          VLDR     s1,[r0,#0xc]
0001b8  ed920a01          VLDR     s0,[r2,#4]
0001bc  eef40ac0          VCMPE.F32 s1,s0
0001c0  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001c4  bfc8              IT       GT
0001c6  eeb00a60          VMOVGT.F32 s0,s1
0001ca  ed800a03          VSTR     s0,[r0,#0xc]
0001ce  1c49              ADDS     r1,r1,#1
0001d0  2904              CMP      r1,#4
0001d2  dbc6              BLT      |L2.354|
0001d4  4651              MOV      r1,r10
0001d6  a80c              ADD      r0,sp,#0x30
0001d8  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeClockwiseCorners<float>() const
0001dc  eddd8a16          VLDR     s17,[sp,#0x58]
0001e0  ed9d8a17          VLDR     s16,[sp,#0x5c]
0001e4  2305              MOVS     r3,#5
0001e6  2208              MOVS     r2,#8
0001e8  49a8              LDR      r1,|L2.1164|
0001ea  a802              ADD      r0,sp,#8
0001ec  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
0001f0  2000              MOVS     r0,#0
0001f2  f10d0b08          ADD      r11,sp,#8
                  |L2.502|
0001f6  a90c              ADD      r1,sp,#0x30
0001f8  eb0101c0          ADD      r1,r1,r0,LSL #3
0001fc  eb0b02c0          ADD      r2,r11,r0,LSL #3
000200  ed910a00          VLDR     s0,[r1,#0]
000204  1c40              ADDS     r0,r0,#1
000206  ed820a00          VSTR     s0,[r2,#0]
00020a  ed910a01          VLDR     s0,[r1,#4]
00020e  2804              CMP      r0,#4
000210  ed820a01          VSTR     s0,[r2,#4]
000214  dbef              BLT      |L2.502|
000216  ed9d0a0c          VLDR     s0,[sp,#0x30]
00021a  eef69a00          VMOV.F32 s19,#0.50000000
00021e  ed8d0a0a          VSTR     s0,[sp,#0x28]
000222  ed9d0a0d          VLDR     s0,[sp,#0x34]
000226  ed8d0a0b          VSTR     s0,[sp,#0x2c]
00022a  ee380ae9          VSUB.F32 s0,s17,s19
00022e  f7fffffe          BL       __hardfp_ceilf
000232  eef08a40          VMOV.F32 s17,s0
000236  f7fffffe          BL       _ZN4Anki8Embedded5RoundIiEET_f ; Anki::Embedded::Round<int>(float)
00023a  2800              CMP      r0,#0
00023c  bfb8              IT       LT
00023e  f04f0a00          MOVLT    r10,#0
000242  db04              BLT      |L2.590|
000244  eeb00a68          VMOV.F32 s0,s17
000248  f7fffffe          BL       _ZN4Anki8Embedded5RoundIiEET_f ; Anki::Embedded::Round<int>(float)
00024c  4682              MOV      r10,r0
                  |L2.590|
00024e  ee380a69          VSUB.F32 s0,s16,s19
000252  f7fffffe          BL       __hardfp_floorf
000256  eeb08a40          VMOV.F32 s16,s0
00025a  f7fffffe          BL       _ZN4Anki8Embedded5RoundIiEET_f ; Anki::Embedded::Round<int>(float)
00025e  1e69              SUBS     r1,r5,#1
000260  4288              CMP      r0,r1
000262  bfd6              ITET     LE
000264  eeb00a48          VMOVLE.F32 s0,s16
000268  4608              MOVGT    r0,r1
00026a  f7fffffe          BLLE     _ZN4Anki8Embedded5RoundIiEET_f ; Anki::Embedded::Round<int>(float)
00026e  ee00aa10          VMOV     s0,r10
000272  ee000a90          VMOV     s1,r0
000276  eeb80ac0          VCVT.F32.S32 s0,s0
00027a  eef80ae0          VCVT.F32.S32 s1,s1
00027e  ee300a29          VADD.F32 s0,s0,s19
000282  ee301aa9          VADD.F32 s2,s1,s19
000286  eef70a00          VMOV.F32 s1,#1.00000000
00028a  ed8d0a26          VSTR     s0,[sp,#0x98]
00028e  edcd0a27          VSTR     s1,[sp,#0x9c]
000292  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIfE11computeSizeEfff ; Anki::Embedded::LinearSequence<float>::computeSize(float, float, float)
000296  9025              STR      r0,[sp,#0x94]
000298  9000              STR      r0,[sp,#0]
00029a  ed9d8a26          VLDR     s16,[sp,#0x98]
00029e  2500              MOVS     r5,#0
0002a0  2800              CMP      r0,#0
0002a2  dd7b              BLE      |L2.924|
0002a4  ed9faa7a          VLDR     s20,|L2.1168|
0002a8  eddfaa7a          VLDR     s21,|L2.1172|
0002ac  9828              LDR      r0,[sp,#0xa0]
0002ae  1e40              SUBS     r0,r0,#1
0002b0  9001              STR      r0,[sp,#4]
                  |L2.690|
0002b2  eeb00a4a          VMOV.F32 s0,s20
0002b6  eeb09a6a          VMOV.F32 s18,s21
0002ba  2100              MOVS     r1,#0
0002bc  aa02              ADD      r2,sp,#8
                  |L2.702|
0002be  eb0200c1          ADD      r0,r2,r1,LSL #3
0002c2  edd00a01          VLDR     s1,[r0,#4]
0002c6  eef40ac8          VCMPE.F32 s1,s16
0002ca  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002ce  d206              BCS      |L2.734|
0002d0  ed901a03          VLDR     s2,[r0,#0xc]
0002d4  eeb41ac8          VCMPE.F32 s2,s16
0002d8  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002dc  da0b              BGE      |L2.758|
                  |L2.734|
0002de  ed901a03          VLDR     s2,[r0,#0xc]
0002e2  eeb41ac8          VCMPE.F32 s2,s16
0002e6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002ea  d222              BCS      |L2.818|
0002ec  eef40ac8          VCMPE.F32 s1,s16
0002f0  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002f4  db1d              BLT      |L2.818|
                  |L2.758|
0002f6  ee711a60          VSUB.F32 s3,s2,s1
0002fa  ee382a60          VSUB.F32 s4,s16,s1
0002fe  ed901a02          VLDR     s2,[r0,#8]
000302  edd08a00          VLDR     s17,[r0,#0]
000306  eec20a21          VDIV.F32 s1,s4,s3
00030a  ee311a68          VSUB.F32 s2,s2,s17
00030e  ee408a81          VMLA.F32 s17,s1,s2
000312  eeb40ae8          VCMPE.F32 s0,s17
000316  eef1fa10          VMRS     APSR_nzcv,FPSCR
00031a  bf28              IT       CS
00031c  eeb00a68          VMOVCS.F32 s0,s17
000320  eeb49ae8          VCMPE.F32 s18,s17
000324  eef1fa10          VMRS     APSR_nzcv,FPSCR
000328  bfc8              IT       GT
00032a  eef08a49          VMOVGT.F32 s17,s18
00032e  eeb09a68          VMOV.F32 s18,s17
                  |L2.818|
000332  1c49              ADDS     r1,r1,#1
000334  2904              CMP      r1,#4
000336  dbc2              BLT      |L2.702|
000338  ee300a29          VADD.F32 s0,s0,s19
00033c  f7fffffe          BL       __hardfp_floorf
000340  eeb50ac0          VCMPE.F32 s0,#0.0
000344  eeb01a40          VMOV.F32 s2,s0
000348  eef1fa10          VMRS     APSR_nzcv,FPSCR
00034c  bfd4              ITE      LE
00034e  ee700a69          VSUBLE.F32 s1,s0,s19
000352  ee700a29          VADDGT.F32 s1,s0,s19
000356  eefd0ae0          VCVT.S32.F32 s1,s1
00035a  ee100a90          VMOV     r0,s1
00035e  2800              CMP      r0,#0
000360  bfb8              IT       LT
000362  f04f0b00          MOVLT    r11,#0
000366  db0e              BLT      |L2.902|
000368  eeb00a41          VMOV.F32 s0,s2
00036c  eeb50ac0          VCMPE.F32 s0,#0.0
000370  eef1fa10          VMRS     APSR_nzcv,FPSCR
000374  bfcc              ITE      GT
000376  ee300a29          VADDGT.F32 s0,s0,s19
00037a  ee300a69          VSUBLE.F32 s0,s0,s19
00037e  eebd0ac0          VCVT.S32.F32 s0,s0
000382  ee10ba10          VMOV     r11,s0
                  |L2.902|
000386  ee390a69          VSUB.F32 s0,s18,s19
00038a  f7fffffe          BL       __hardfp_floorf
00038e  eeb50ac0          VCMPE.F32 s0,#0.0
000392  eeb01a40          VMOV.F32 s2,s0
000396  eef1fa10          VMRS     APSR_nzcv,FPSCR
00039a  e000              B        |L2.926|
                  |L2.924|
00039c  e03f              B        |L2.1054|
                  |L2.926|
00039e  bfcc              ITE      GT
0003a0  ee700a29          VADDGT.F32 s1,s0,s19
0003a4  ee700a69          VSUBLE.F32 s1,s0,s19
0003a8  eefd0ae0          VCVT.S32.F32 s1,s1
0003ac  9901              LDR      r1,[sp,#4]
0003ae  ee100a90          VMOV     r0,s1
0003b2  4288              CMP      r0,r1
0003b4  bfc4              ITT      GT
0003b6  9828              LDRGT    r0,[sp,#0xa0]
0003b8  1e41              SUBGT    r1,r0,#1
0003ba  dc0e              BGT      |L2.986|
0003bc  eeb00a41          VMOV.F32 s0,s2
0003c0  eeb50ac0          VCMPE.F32 s0,#0.0
0003c4  eef1fa10          VMRS     APSR_nzcv,FPSCR
0003c8  bfcc              ITE      GT
0003ca  ee300a29          VADDGT.F32 s0,s0,s19
0003ce  ee300a69          VSUBLE.F32 s0,s0,s19
0003d2  eebd0ac0          VCVT.S32.F32 s0,s0
0003d6  ee101a10          VMOV     r1,s0
                  |L2.986|
0003da  f8d93008          LDR      r3,[r9,#8]
0003de  f8d92010          LDR      r2,[r9,#0x10]
0003e2  eb0a0005          ADD      r0,r10,r5
0003e6  fb002203          MLA      r2,r0,r3,r2
0003ea  458b              CMP      r11,r1
0003ec  dc0c              BGT      |L2.1032|
                  |L2.1006|
0003ee  f812000b          LDRB     r0,[r2,r11]
0003f2  44bb              ADD      r11,r11,r7
0003f4  f8563020          LDR      r3,[r6,r0,LSL #2]
0003f8  1c5b              ADDS     r3,r3,#1
0003fa  f8463020          STR      r3,[r6,r0,LSL #2]
0003fe  6b60              LDR      r0,[r4,#0x34]
000400  1c40              ADDS     r0,r0,#1
000402  6360              STR      r0,[r4,#0x34]
000404  458b              CMP      r11,r1
000406  ddf2              BLE      |L2.1006|
                  |L2.1032|
000408  ee008a10          VMOV     s0,r8
00040c  9800              LDR      r0,[sp,#0]
00040e  4445              ADD      r5,r5,r8
000410  eeb80ac0          VCVT.F32.S32 s0,s0
000414  4285              CMP      r5,r0
000416  ee388a00          VADD.F32 s16,s16,s0
00041a  f6ffaf4a          BLT      |L2.690|
                  |L2.1054|
00041e  4620              MOV      r0,r4
000420  e67c              B        |L2.284|
                          ENDP

000422  0000              DCW      0x0000
                  |L2.1060|
                          DCD      ||.constdata||+0xc1
                  |L2.1064|
000428  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\histogram.cpp",0
00042c  6f726574
000430  6563685c
000434  76697369
000438  6f6e5c72
00043c  6f626f74
000440  5c737263
000444  5c686973
000448  746f6772
00044c  616d2e63
000450  707000  
000453  00                DCB      0
                  |L2.1108|
000454  4f757420          DCB      "Out of memory",0
000458  6f66206d
00045c  656d6f72
000460  7900    
000462  00                DCB      0
000463  00                DCB      0
                  |L2.1124|
000464  496e7465          DCB      "IntegerCounts::IntegerCounts",0
000468  67657243
00046c  6f756e74
000470  733a3a49
000474  6e746567
000478  6572436f
00047c  756e7473
000480  00      
000481  00                DCB      0
000482  00                DCB      0
000483  00                DCB      0
                  |L2.1156|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::SetZero()::__PRETTY_FUNCTION__
                  |L2.1160|
                          DCD      ||.constdata||+0x284
                  |L2.1164|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()
                  |L2.1168|
000490  7f7fffff          DCFS     0x7f7fffff ; 3.4028234663852886e+38
                  |L2.1172|
000494  00800000          DCFS     0x00800000 ; 1.1754943508222875e-38

                          AREA ||i._ZN4Anki8Embedded13IntegerCountsC1ERKNS0_5ArrayIhEERKNS0_9RectangleIiEEiiRNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded13IntegerCountsC2ERKNS0_5ArrayIhEERKNS0_9RectangleIiEEiiRNS0_11MemoryStackE                  ; Alternate entry point ; Anki::Embedded::IntegerCounts::IntegerCounts__sub_object(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Rectangle<int>&, int, int, Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded13IntegerCountsC1ERKNS0_5ArrayIhEERKNS0_9RectangleIiEEiiRNS0_11MemoryStackE PROC ; Anki::Embedded::IntegerCounts::IntegerCounts(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Rectangle<int>&, int, int, Anki::Embedded::MemoryStack&)
;;;20     
;;;21         IntegerCounts::IntegerCounts(const Array<u8> &image, const Rectangle<s32> &imageRegionOfInterest, const s32 yIncrement, const s32 xIncrement, MemoryStack &memory)
;;;22           : counts(FixedLengthList<s32>()), numElements(-1)
;;;23         {
;;;24           const s32 imageHeight = image.get_size(0);
;;;25           const s32 imageWidth = image.get_size(1);
;;;26     
;;;27           this->counts = FixedLengthList<s32>(256, memory);
;;;28           this->counts.set_size(this->counts.get_maximumSize());
;;;29     
;;;30           AnkiConditionalErrorAndReturn(this->counts.IsValid(),
;;;31             "IntegerCounts::IntegerCounts", "Out of memory");
;;;32     
;;;33           this->counts.set_size(this->counts.get_maximumSize());
;;;34           this->counts.SetZero();
;;;35     
;;;36           s32 * restrict pCounts = this->counts.Pointer(0);
;;;37     
;;;38           const Rectangle<s32> imageRegionOfInterestClipped(
;;;39             MAX(0, MIN(imageWidth, imageRegionOfInterest.left)),
;;;40             MAX(0, MIN(imageWidth, imageRegionOfInterest.right)),
;;;41             MAX(0, MIN(imageHeight, imageRegionOfInterest.top)),
;;;42             MAX(0, MIN(imageHeight, imageRegionOfInterest.bottom)));
;;;43     
;;;44           this->numElements = 0;
;;;45     
;;;46           for(s32 y=imageRegionOfInterestClipped.top; y<=(imageRegionOfInterestClipped.bottom-1); y+=yIncrement) {
;;;47             const u8 * restrict pImage = image.Pointer(y,0);
;;;48     
;;;49             for(s32 x=imageRegionOfInterestClipped.left; x<=(imageRegionOfInterestClipped.right-1); x+=xIncrement) {
;;;50               const u8 curImage = pImage[x];
;;;51               pCounts[curImage]++;
;;;52               this->numElements++;
;;;53             }
;;;54           }
;;;55     
;;;56           // TODO: fix for speed
;;;57           /*const s32 numY = ((imageRegionOfInterest.bottom - imageRegionOfInterest.top) / yIncrement) + 1;
;;;58           const s32 numX = ((imageRegionOfInterest.right - imageRegionOfInterest.left) / xIncrement) + 1;
;;;59           this->numElements = numY * numX;
;;;60     
;;;61           CoreTechPrint("%d %d", this->numElements, numPoints);*/
;;;62         }
;;;63     
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b095              SUB      sp,sp,#0x54
000006  469a              MOV      r10,r3
000008  e9dd7b1e          LDRD     r7,r11,[sp,#0x78]
00000c  4690              MOV      r8,r2
00000e  4689              MOV      r9,r1
000010  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiEC1Ev ; Anki::Embedded::FixedLengthList<int>::FixedLengthList()
000014  4604              MOV      r4,r0
000016  f04f30ff          MOV      r0,#0xffffffff
00001a  6360              STR      r0,[r4,#0x34]
00001c  2100              MOVS     r1,#0
00001e  4648              MOV      r0,r9
000020  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000024  4606              MOV      r6,r0
000026  2101              MOVS     r1,#1
000028  4648              MOV      r0,r9
00002a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00002e  4605              MOV      r5,r0
000030  2300              MOVS     r3,#0
000032  461a              MOV      r2,r3
000034  2101              MOVS     r1,#1
000036  a813              ADD      r0,sp,#0x4c
000038  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00003c  6803              LDR      r3,[r0,#0]
00003e  465a              MOV      r2,r11
000040  f44f7180          MOV      r1,#0x100
000044  a806              ADD      r0,sp,#0x18
000046  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<int>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00004a  e9d01200          LDRD     r1,r2,[r0,#0]
00004e  6883              LDR      r3,[r0,#8]
000050  60a3              STR      r3,[r4,#8]
000052  e9c41200          STRD     r1,r2,[r4,#0]
000056  e9d01203          LDRD     r1,r2,[r0,#0xc]
00005a  6943              LDR      r3,[r0,#0x14]
00005c  6163              STR      r3,[r4,#0x14]
00005e  e9c41203          STRD     r1,r2,[r4,#0xc]
000062  6981              LDR      r1,[r0,#0x18]
000064  61a1              STR      r1,[r4,#0x18]
000066  69c1              LDR      r1,[r0,#0x1c]
000068  61e1              STR      r1,[r4,#0x1c]
00006a  6a01              LDR      r1,[r0,#0x20]
00006c  6221              STR      r1,[r4,#0x20]
00006e  6a41              LDR      r1,[r0,#0x24]
000070  6261              STR      r1,[r4,#0x24]
000072  6a81              LDR      r1,[r0,#0x28]
000074  62a1              STR      r1,[r4,#0x28]
000076  6ac1              LDR      r1,[r0,#0x2c]
000078  62e1              STR      r1,[r4,#0x2c]
00007a  6b00              LDR      r0,[r0,#0x30]
00007c  f1040218          ADD      r2,r4,#0x18
000080  6320              STR      r0,[r4,#0x30]
000082  2101              MOVS     r1,#1
000084  4610              MOV      r0,r2
000086  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
00008a  4601              MOV      r1,r0
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi ; Anki::Embedded::FixedLengthList<int>::set_size(int)
000092  2101              MOVS     r1,#1
000094  f1040018          ADD      r0,r4,#0x18
000098  f8d4b00c          LDR      r11,[r4,#0xc]
00009c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
0000a0  4583              CMP      r11,r0
0000a2  dc31              BGT      |L3.264|
0000a4  6aa0              LDR      r0,[r4,#0x28]
0000a6  b130              CBZ      r0,|L3.182|
0000a8  69a0              LDR      r0,[r4,#0x18]
0000aa  2800              CMP      r0,#0
0000ac  bfa3              ITTTE    GE
0000ae  69e0              LDRGE    r0,[r4,#0x1c]
0000b0  2800              CMPGE    r0,#0
0000b2  2001              MOVGE    r0,#1
0000b4  2000              MOVLT    r0,#0
                  |L3.182|
0000b6  b338              CBZ      r0,|L3.264|
0000b8  2101              MOVS     r1,#1
0000ba  f1040018          ADD      r0,r4,#0x18
0000be  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
0000c2  4601              MOV      r1,r0
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi ; Anki::Embedded::FixedLengthList<int>::set_size(int)
0000ca  6aa0              LDR      r0,[r4,#0x28]
0000cc  f1040b18          ADD      r11,r4,#0x18
0000d0  2800              CMP      r0,#0
0000d2  d027              BEQ      |L3.292|
0000d4  f8db0000          LDR      r0,[r11,#0]
0000d8  2800              CMP      r0,#0
0000da  bfa4              ITT      GE
0000dc  f8db0004          LDRGE    r0,[r11,#4]
0000e0  2800              CMPGE    r0,#0
0000e2  db1f              BLT      |L3.292|
0000e4  2100              MOVS     r1,#0
0000e6  4658              MOV      r0,r11
0000e8  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
0000ec  4601              MOV      r1,r0
0000ee  f8db0008          LDR      r0,[r11,#8]
0000f2  f8db3010          LDR      r3,[r11,#0x10]
0000f6  fb01f200          MUL      r2,r1,r0
0000fa  2100              MOVS     r1,#0
0000fc  fb013000          MLA      r0,r1,r0,r3
000100  4611              MOV      r1,r2
000102  f7fffffe          BL       __aeabi_memclr4
000106  e01a              B        |L3.318|
                  |L3.264|
000108  211e              MOVS     r1,#0x1e
00010a  483f              LDR      r0,|L3.520|
00010c  e9cd0100          STRD     r0,r1,[sp,#0]
000110  a33e              ADR      r3,|L3.524|
000112  a249              ADR      r2,|L3.568|
000114  a14c              ADR      r1,|L3.584|
000116  2005              MOVS     r0,#5
000118  f7fffffe          BL       _Anki_Log
00011c  b015              ADD      sp,sp,#0x54
00011e  4620              MOV      r0,r4
000120  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.292|
000124  f2402176          MOV      r1,#0x276
000128  484f              LDR      r0,|L3.616|
00012a  4b50              LDR      r3,|L3.620|
00012c  e9cd0100          STRD     r0,r1,[sp,#0]
000130  f103027c          ADD      r2,r3,#0x7c
000134  f1a20118          SUB      r1,r2,#0x18
000138  2005              MOVS     r0,#5
00013a  f7fffffe          BL       _Anki_Log
                  |L3.318|
00013e  f8d82000          LDR      r2,[r8,#0]
000142  6b23              LDR      r3,[r4,#0x30]
000144  42aa              CMP      r2,r5
000146  bfcc              ITE      GT
000148  4628              MOVGT    r0,r5
00014a  4610              MOVLE    r0,r2
00014c  2800              CMP      r0,#0
00014e  bfb8              IT       LT
000150  2200              MOVLT    r2,#0
000152  db02              BLT      |L3.346|
000154  4295              CMP      r5,r2
000156  bfb8              IT       LT
000158  462a              MOVLT    r2,r5
                  |L3.346|
00015a  f8d80004          LDR      r0,[r8,#4]
00015e  42a8              CMP      r0,r5
000160  bfcc              ITE      GT
000162  4629              MOVGT    r1,r5
000164  4601              MOVLE    r1,r0
000166  2900              CMP      r1,#0
000168  bfb8              IT       LT
00016a  2500              MOVLT    r5,#0
00016c  db02              BLT      |L3.372|
00016e  4285              CMP      r5,r0
000170  bfa8              IT       GE
000172  4605              MOVGE    r5,r0
                  |L3.372|
000174  f8d8c008          LDR      r12,[r8,#8]
000178  45b4              CMP      r12,r6
00017a  bfcc              ITE      GT
00017c  4630              MOVGT    r0,r6
00017e  4660              MOVLE    r0,r12
000180  2800              CMP      r0,#0
000182  bfb8              IT       LT
000184  f04f0c00          MOVLT    r12,#0
000188  db02              BLT      |L3.400|
00018a  4566              CMP      r6,r12
00018c  bfb8              IT       LT
00018e  46b4              MOVLT    r12,r6
                  |L3.400|
000190  f8d8100c          LDR      r1,[r8,#0xc]
000194  42b1              CMP      r1,r6
000196  bfcc              ITE      GT
000198  4630              MOVGT    r0,r6
00019a  4608              MOVLE    r0,r1
00019c  2800              CMP      r0,#0
00019e  bfb8              IT       LT
0001a0  2600              MOVLT    r6,#0
0001a2  db02              BLT      |L3.426|
0001a4  428e              CMP      r6,r1
0001a6  bfa8              IT       GE
0001a8  460e              MOVGE    r6,r1
                  |L3.426|
0001aa  2000              MOVS     r0,#0
0001ac  e9cd2502          STRD     r2,r5,[sp,#8]
0001b0  e9cdc604          STRD     r12,r6,[sp,#0x10]
0001b4  6360              STR      r0,[r4,#0x34]
0001b6  e9dd2004          LDRD     r2,r0,[sp,#0x10]
0001ba  1e40              SUBS     r0,r0,#1
0001bc  4290              CMP      r0,r2
0001be  db1e              BLT      |L3.510|
                  |L3.448|
0001c0  f8d91008          LDR      r1,[r9,#8]
0001c4  f8d90010          LDR      r0,[r9,#0x10]
0001c8  fb020c01          MLA      r12,r2,r1,r0
0001cc  e9dd0102          LDRD     r0,r1,[sp,#8]
0001d0  1e49              SUBS     r1,r1,#1
0001d2  4281              CMP      r1,r0
0001d4  db0e              BLT      |L3.500|
                  |L3.470|
0001d6  f81c1000          LDRB     r1,[r12,r0]
0001da  4438              ADD      r0,r0,r7
0001dc  f8535021          LDR      r5,[r3,r1,LSL #2]
0001e0  1c6d              ADDS     r5,r5,#1
0001e2  f8435021          STR      r5,[r3,r1,LSL #2]
0001e6  6b61              LDR      r1,[r4,#0x34]
0001e8  1c49              ADDS     r1,r1,#1
0001ea  6361              STR      r1,[r4,#0x34]
0001ec  9903              LDR      r1,[sp,#0xc]
0001ee  1e49              SUBS     r1,r1,#1
0001f0  4281              CMP      r1,r0
0001f2  daf0              BGE      |L3.470|
                  |L3.500|
0001f4  9805              LDR      r0,[sp,#0x14]
0001f6  4452              ADD      r2,r2,r10
0001f8  1e40              SUBS     r0,r0,#1
0001fa  4290              CMP      r0,r2
0001fc  dae0              BGE      |L3.448|
                  |L3.510|
0001fe  b015              ADD      sp,sp,#0x54
000200  4620              MOV      r0,r4
000202  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

000206  0000              DCW      0x0000
                  |L3.520|
                          DCD      ||.constdata||
                  |L3.524|
00020c  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\histogram.cpp",0
000210  6f726574
000214  6563685c
000218  76697369
00021c  6f6e5c72
000220  6f626f74
000224  5c737263
000228  5c686973
00022c  746f6772
000230  616d2e63
000234  707000  
000237  00                DCB      0
                  |L3.568|
000238  4f757420          DCB      "Out of memory",0
00023c  6f66206d
000240  656d6f72
000244  7900    
000246  00                DCB      0
000247  00                DCB      0
                  |L3.584|
000248  496e7465          DCB      "IntegerCounts::IntegerCounts",0
00024c  67657243
000250  6f756e74
000254  733a3a49
000258  6e746567
00025c  6572436f
000260  756e7473
000264  00      
000265  00                DCB      0
000266  00                DCB      0
000267  00                DCB      0
                  |L3.616|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::SetZero()::__PRETTY_FUNCTION__
                  |L3.620|
                          DCD      ||.constdata||+0x284

                          AREA ||i._ZN4Anki8Embedded13IntegerCountsC1Ev||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded13IntegerCountsC2Ev                  ; Alternate entry point ; Anki::Embedded::IntegerCounts::IntegerCounts__sub_object()
                  _ZN4Anki8Embedded13IntegerCountsC1Ev PROC ; Anki::Embedded::IntegerCounts::IntegerCounts()
;;;15       {
;;;16         IntegerCounts::IntegerCounts()
;;;17           : counts(FixedLengthList<s32>()), numElements(-1)
;;;18         {
;;;19         }
;;;20     
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiEC1Ev ; Anki::Embedded::FixedLengthList<int>::FixedLengthList()
000006  f04f31ff          MOV      r1,#0xffffffff
00000a  6341              STR      r1,[r0,#0x34]
00000c  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded13IntegerCounts10get_countsEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded13IntegerCounts10get_countsEv PROC ; Anki::Embedded::IntegerCounts::get_counts() const
;;;227    
;;;228        const FixedLengthList<s32>& IntegerCounts::get_counts() const
000000  4770              BX       lr
;;;229        {
;;;230          return this->counts;
;;;231        }
;;;232    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded13IntegerCounts11get_numBinsEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded13IntegerCounts11get_numBinsEv PROC ; Anki::Embedded::IntegerCounts::get_numBins() const
;;;232    
;;;233        s32 IntegerCounts::get_numBins() const
000000  68c0              LDR      r0,[r0,#0xc]
;;;234        {
;;;235          return this->counts.get_size();
;;;236        }
000002  4770              BX       lr
;;;237    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded13IntegerCounts15get_numElementsEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded13IntegerCounts15get_numElementsEv PROC ; Anki::Embedded::IntegerCounts::get_numElements() const
;;;237    
;;;238        s32 IntegerCounts::get_numElements() const
000000  6b40              LDR      r0,[r0,#0x34]
;;;239        {
;;;240          return this->numElements;
;;;241        }
000002  4770              BX       lr
;;;242      } // namespace Embedded
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded13IntegerCounts17ComputePercentileEf||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded13IntegerCounts17ComputePercentileEf PROC ; Anki::Embedded::IntegerCounts::ComputePercentile(float) const
;;;138    
;;;139        s32 IntegerCounts::ComputePercentile(const f32 percentile) const
000000  b570              PUSH     {r4-r6,lr}
;;;140        {
;;;141          // TODO: there may be a boundary error in this function
;;;142    
;;;143          s32 binIndex = 0;
;;;144          s32 count = 0;
;;;145    
;;;146          const s32 numBins = this->get_numBins();
;;;147    
;;;148          const s32 * restrict pCounts = this->counts.Pointer(0);
;;;149    
;;;150          const s32 numBelow = Round<s32>(static_cast<f32>(this->numElements) * percentile);
000002  edd00a0d          VLDR     s1,[r0,#0x34]
000006  2400              MOVS     r4,#0                 ;143
000008  68c6              LDR      r6,[r0,#0xc]
00000a  eef80ae0          VCVT.F32.S32 s1,s1
00000e  6b05              LDR      r5,[r0,#0x30]
000010  ee200a80          VMUL.F32 s0,s1,s0
000014  f7fffffe          BL       _ZN4Anki8Embedded5RoundIiEET_f ; Anki::Embedded::Round<int>(float)
000018  4601              MOV      r1,r0
;;;151    
;;;152          count += pCounts[0];
;;;153    
;;;154          while(count < numBelow && binIndex < (numBins-1)) {
00001a  1e72              SUBS     r2,r6,#1
00001c  6828              LDR      r0,[r5,#0]
00001e  e003              B        |L8.40|
                  |L8.32|
;;;155            binIndex++;
000020  1c64              ADDS     r4,r4,#1
;;;156            count += pCounts[binIndex];
000022  f8553024          LDR      r3,[r5,r4,LSL #2]
000026  4418              ADD      r0,r0,r3
                  |L8.40|
000028  4288              CMP      r0,r1                 ;154
00002a  bfb8              IT       LT                    ;154
00002c  4294              CMPLT    r4,r2                 ;154
00002e  dbf7              BLT      |L8.32|
;;;157          }
;;;158    
;;;159          return binIndex;
000030  4620              MOV      r0,r4
;;;160        }
000032  bd70              POP      {r4-r6,pc}
;;;161    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded13IntegerCounts17ComputeStatisticsEv||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded13IntegerCounts17ComputeStatisticsEv PROC ; Anki::Embedded::IntegerCounts::ComputeStatistics() const
;;;161    
;;;162        IntegerCounts::Statistics IntegerCounts::ComputeStatistics() const
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;163        {
;;;164          IntegerCounts::Statistics statistics;
;;;165    
;;;166          statistics.isValid = false;
000004  2600              MOVS     r6,#0
000006  ed2d8b02          VPUSH    {d8}                  ;163
00000a  4683              MOV      r11,r0                ;163
;;;167    
;;;168          statistics.numElements = this->numElements;
;;;169    
;;;170          const s32 numBins = this->get_numBins();
;;;171    
;;;172          const s32 * restrict pCounts = this->counts.Pointer(0);
;;;173    
;;;174          statistics.sum = 0;
;;;175          for(s32 i=0; i<numBins; i++) {
00000c  e9d15a0c          LDRD     r5,r10,[r1,#0x30]
000010  68cc              LDR      r4,[r1,#0xc]
000012  f3660907          BFI      r9,r6,#0,#8           ;166
000016  4630              MOV      r0,r6
000018  2c00              CMP      r4,#0
00001a  dd06              BLE      |L9.42|
                  |L9.28|
;;;176            statistics.sum += i * pCounts[i];
00001c  f8551020          LDR      r1,[r5,r0,LSL #2]
000020  fb006601          MLA      r6,r0,r1,r6
000024  1c40              ADDS     r0,r0,#1              ;175
000026  4284              CMP      r4,r0                 ;175
000028  dcf8              BGT      |L9.28|
                  |L9.42|
;;;177          }
;;;178    
;;;179          statistics.mean = static_cast<f32>(statistics.sum) / static_cast<f32>(this->numElements);
00002a  ee006a10          VMOV     s0,r6
;;;180    
;;;181          f32 sumOfSquaredDifferences = 0;
;;;182          for(s32 i=0; i<numBins; i++) {
00002e  2000              MOVS     r0,#0
000030  2c00              CMP      r4,#0
000032  eef80ac0          VCVT.F32.S32 s1,s0                 ;179
000036  ee00aa10          VMOV     s0,r10                ;179
00003a  eeb80ac0          VCVT.F32.S32 s0,s0                 ;179
00003e  ee808a80          VDIV.F32 s16,s1,s0             ;179
000042  eddf0a29          VLDR     s1,|L9.232|
000046  eeb01a48          VMOV.F32 s2,s16                ;179
00004a  dd12              BLE      |L9.114|
                  |L9.76|
;;;183            const f32 diff = static_cast<f32>(i) - statistics.mean;
00004c  ee000a10          VMOV     s0,r0
;;;184            sumOfSquaredDifferences += static_cast<f32>(pCounts[i]) * (diff*diff);
000050  f8551020          LDR      r1,[r5,r0,LSL #2]
000054  1c40              ADDS     r0,r0,#1              ;182
000056  eeb80ac0          VCVT.F32.S32 s0,s0                 ;183
00005a  ee011a90          VMOV     s3,r1
00005e  4284              CMP      r4,r0                 ;182
000060  ee300a41          VSUB.F32 s0,s0,s2              ;183
000064  eef81ae1          VCVT.F32.S32 s3,s3
000068  ee200a00          VMUL.F32 s0,s0,s0
00006c  ee410a80          VMLA.F32 s1,s3,s0
000070  dcec              BGT      |L9.76|
                  |L9.114|
;;;185          }
;;;186    
;;;187          // Unbiased standard deviation
;;;188          statistics.standardDeviation = sqrtf( sumOfSquaredDifferences / static_cast<f32>(this->numElements - 1) );
000072  f1aa0001          SUB      r0,r10,#1
000076  ee000a10          VMOV     s0,r0
00007a  eeb81ac0          VCVT.F32.S32 s2,s0
00007e  ee800a81          VDIV.F32 s0,s1,s2
000082  eef10ac0          VSQRT.F32 s1,s0
000086  eef40a60          VCMP.F32 s1,s1
00008a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00008e  d003              BEQ      |L9.152|
000090  f7fffffe          BL       __hardfp_sqrtf
000094  eef00a40          VMOV.F32 s1,s0
                  |L9.152|
;;;189    
;;;190          for(s32 i=0; i<numBins; i++) {
000098  2000              MOVS     r0,#0
00009a  2c00              CMP      r4,#0
00009c  dd08              BLE      |L9.176|
                  |L9.158|
;;;191            if(pCounts[i] > 0) {
00009e  f8551020          LDR      r1,[r5,r0,LSL #2]
0000a2  2900              CMP      r1,#0
0000a4  dd01              BLE      |L9.170|
;;;192              statistics.min = i;
0000a6  4680              MOV      r8,r0
;;;193              break;
0000a8  e002              B        |L9.176|
                  |L9.170|
0000aa  1c40              ADDS     r0,r0,#1              ;190
0000ac  4284              CMP      r4,r0                 ;190
0000ae  dcf6              BGT      |L9.158|
                  |L9.176|
;;;194            };
;;;195          }
;;;196    
;;;197          for(s32 i=numBins-1; i>=0; i--) {
0000b0  1e60              SUBS     r0,r4,#1
0000b2  d407              BMI      |L9.196|
                  |L9.180|
;;;198            if(pCounts[i] > 0) {
0000b4  f8551020          LDR      r1,[r5,r0,LSL #2]
0000b8  2900              CMP      r1,#0
0000ba  dd01              BLE      |L9.192|
;;;199              statistics.max = i;
0000bc  4607              MOV      r7,r0
;;;200              break;
0000be  e001              B        |L9.196|
                  |L9.192|
0000c0  1e40              SUBS     r0,r0,#1              ;197
0000c2  d5f7              BPL      |L9.180|
                  |L9.196|
;;;201            };
;;;202          }
;;;203    
;;;204          statistics.isValid = true;
0000c4  2001              MOVS     r0,#1
0000c6  f3600907          BFI      r9,r0,#0,#8
;;;205    
;;;206          return statistics;
0000ca  f8cb9000          STR      r9,[r11,#0]
0000ce  e9cb7603          STRD     r7,r6,[r11,#0xc]
0000d2  e9cba801          STRD     r10,r8,[r11,#4]
0000d6  ed8b8a05          VSTR     s16,[r11,#0x14]
0000da  edcb0a06          VSTR     s1,[r11,#0x18]
;;;207        }
0000de  ecbd8b02          VPOP     {d8}
0000e2  e8bd9ff0          POP      {r4-r12,pc}
;;;208    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L9.232|
0000e8  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZNK4Anki8Embedded13IntegerCounts7IsValidEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded13IntegerCounts7IsValidEv PROC ; Anki::Embedded::IntegerCounts::IsValid() const
;;;219    
;;;220        bool IntegerCounts::IsValid() const
000000  6b41              LDR      r1,[r0,#0x34]
;;;221        {
;;;222          if(numElements < 0)
000002  2900              CMP      r1,#0
;;;223            return false;
000004  bfbc              ITT      LT
000006  2000              MOVLT    r0,#0
;;;224    
;;;225          return counts.IsValid();
;;;226        }
000008  4770              BXLT     lr
00000a  b570              PUSH     {r4-r6,lr}            ;221
00000c  4604              MOV      r4,r0                 ;225
00000e  68c5              LDR      r5,[r0,#0xc]          ;225
000010  2101              MOVS     r1,#1                 ;225
000012  3018              ADDS     r0,r0,#0x18           ;225
000014  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
000018  4285              CMP      r5,r0                 ;225
00001a  dc0a              BGT      |L10.50|
00001c  6aa0              LDR      r0,[r4,#0x28]         ;225
00001e  2800              CMP      r0,#0                 ;225
000020  bf08              IT       EQ
000022  bd70              POPEQ    {r4-r6,pc}
000024  69a0              LDR      r0,[r4,#0x18]
000026  2800              CMP      r0,#0
000028  bfa1              ITTTT    GE
00002a  69e0              LDRGE    r0,[r4,#0x1c]
00002c  2800              CMPGE    r0,#0
00002e  2001              MOVGE    r0,#1
000030  bd70              POPGE    {r4-r6,pc}
                  |L10.50|
000032  2000              MOVS     r0,#0
000034  bd70              POP      {r4-r6,pc}
;;;227    
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki8Embedded13IntegerCountsC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded13IntegerCountsC1Ev||
                          DCD      0x00000001

                          AREA ||area_number.12||, LINKORDER=||i._ZN4Anki8Embedded13IntegerCountsC1ERKNS0_5ArrayIhEERKNS0_9RectangleIiEEiiRNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded13IntegerCountsC1ERKNS0_5ArrayIhEERKNS0_9RectangleIiEEiiRNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.13||, LINKORDER=||i._ZN4Anki8Embedded13IntegerCountsC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEiiRNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded13IntegerCountsC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEiiRNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i._ZNK4Anki8Embedded13IntegerCounts11get_numBinsEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded13IntegerCounts11get_numBinsEv||
                          DCD      0x00000001

                          AREA ||area_number.15||, LINKORDER=||i._ZNK4Anki8Embedded13IntegerCounts17ComputePercentileEf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded13IntegerCounts17ComputePercentileEf||
                          DCD      0x00000001

                          AREA ||area_number.16||, LINKORDER=||i._ZNK4Anki8Embedded13IntegerCounts17ComputeStatisticsEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded13IntegerCounts17ComputeStatisticsEv||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i._ZN4Anki8Embedded13IntegerCounts3SetERKS1_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded13IntegerCounts3SetERKS1_||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i._ZNK4Anki8Embedded13IntegerCounts7IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded13IntegerCounts7IsValidEv||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i._ZNK4Anki8Embedded13IntegerCounts10get_countsEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded13IntegerCounts10get_countsEv||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i._ZNK4Anki8Embedded13IntegerCounts15get_numElementsEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded13IntegerCounts15get_numElementsEv||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  __PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  496e7465          DCB      0x49,0x6e,0x74,0x65
000014  67657243          DCB      0x67,0x65,0x72,0x43
000018  6f756e74          DCB      0x6f,0x75,0x6e,0x74
00001c  733a3a49          DCB      0x73,0x3a,0x3a,0x49
000020  6e746567          DCB      0x6e,0x74,0x65,0x67
000024  6572436f          DCB      0x65,0x72,0x43,0x6f
000028  756e7473          DCB      0x75,0x6e,0x74,0x73
00002c  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000030  73742041          DCB      0x73,0x74,0x20,0x41
000034  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000038  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00003c  65646465          DCB      0x65,0x64,0x64,0x65
000040  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000044  72726179          DCB      0x72,0x72,0x61,0x79
000048  3c756e73          DCB      0x3c,0x75,0x6e,0x73
00004c  69676e65          DCB      0x69,0x67,0x6e,0x65
000050  64206368          DCB      0x64,0x20,0x63,0x68
000054  61723e20          DCB      0x61,0x72,0x3e,0x20
000058  262c2063          DCB      0x26,0x2c,0x20,0x63
00005c  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000060  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000064  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000068  6d626564          DCB      0x6d,0x62,0x65,0x64
00006c  6465643a          DCB      0x64,0x65,0x64,0x3a
000070  3a526563          DCB      0x3a,0x52,0x65,0x63
000074  74616e67          DCB      0x74,0x61,0x6e,0x67
000078  6c653c73          DCB      0x6c,0x65,0x3c,0x73
00007c  69676e65          DCB      0x69,0x67,0x6e,0x65
000080  6420696e          DCB      0x64,0x20,0x69,0x6e
000084  743e2026          DCB      0x74,0x3e,0x20,0x26
000088  2c207369          DCB      0x2c,0x20,0x73,0x69
00008c  676e6564          DCB      0x67,0x6e,0x65,0x64
000090  20696e74          DCB      0x20,0x69,0x6e,0x74
000094  2c207369          DCB      0x2c,0x20,0x73,0x69
000098  676e6564          DCB      0x67,0x6e,0x65,0x64
00009c  20696e74          DCB      0x20,0x69,0x6e,0x74
0000a0  2c20416e          DCB      0x2c,0x20,0x41,0x6e
0000a4  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0000a8  456d6265          DCB      0x45,0x6d,0x62,0x65
0000ac  64646564          DCB      0x64,0x64,0x65,0x64
0000b0  3a3a4d65          DCB      0x3a,0x3a,0x4d,0x65
0000b4  6d6f7279          DCB      0x6d,0x6f,0x72,0x79
0000b8  53746163          DCB      0x53,0x74,0x61,0x63
0000bc  6b202629          DCB      0x6b,0x20,0x26,0x29
0000c0  00                DCB      0x00
                  |symbol_number.85|
0000c1  416e6b            DCB      0x41,0x6e,0x6b
0000c4  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000c8  6d626564          DCB      0x6d,0x62,0x65,0x64
0000cc  6465643a          DCB      0x64,0x65,0x64,0x3a
0000d0  3a496e74          DCB      0x3a,0x49,0x6e,0x74
0000d4  65676572          DCB      0x65,0x67,0x65,0x72
0000d8  436f756e          DCB      0x43,0x6f,0x75,0x6e
0000dc  74733a3a          DCB      0x74,0x73,0x3a,0x3a
0000e0  496e7465          DCB      0x49,0x6e,0x74,0x65
0000e4  67657243          DCB      0x67,0x65,0x72,0x43
0000e8  6f756e74          DCB      0x6f,0x75,0x6e,0x74
0000ec  7328636f          DCB      0x73,0x28,0x63,0x6f
0000f0  6e737420          DCB      0x6e,0x73,0x74,0x20
0000f4  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000f8  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000fc  62656464          DCB      0x62,0x65,0x64,0x64
000100  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000104  41727261          DCB      0x41,0x72,0x72,0x61
000108  793c756e          DCB      0x79,0x3c,0x75,0x6e
00010c  7369676e          DCB      0x73,0x69,0x67,0x6e
000110  65642063          DCB      0x65,0x64,0x20,0x63
000114  6861723e          DCB      0x68,0x61,0x72,0x3e
000118  20262c20          DCB      0x20,0x26,0x2c,0x20
00011c  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000120  7420416e          DCB      0x74,0x20,0x41,0x6e
000124  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000128  456d6265          DCB      0x45,0x6d,0x62,0x65
00012c  64646564          DCB      0x64,0x64,0x65,0x64
000130  3a3a5175          DCB      0x3a,0x3a,0x51,0x75
000134  61647269          DCB      0x61,0x64,0x72,0x69
000138  6c617465          DCB      0x6c,0x61,0x74,0x65
00013c  72616c3c          DCB      0x72,0x61,0x6c,0x3c
000140  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000144  743e2026          DCB      0x74,0x3e,0x20,0x26
000148  2c207369          DCB      0x2c,0x20,0x73,0x69
00014c  676e6564          DCB      0x67,0x6e,0x65,0x64
000150  20696e74          DCB      0x20,0x69,0x6e,0x74
000154  2c207369          DCB      0x2c,0x20,0x73,0x69
000158  676e6564          DCB      0x67,0x6e,0x65,0x64
00015c  20696e74          DCB      0x20,0x69,0x6e,0x74
000160  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000164  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000168  456d6265          DCB      0x45,0x6d,0x62,0x65
00016c  64646564          DCB      0x64,0x64,0x65,0x64
000170  3a3a4d65          DCB      0x3a,0x3a,0x4d,0x65
000174  6d6f7279          DCB      0x6d,0x6f,0x72,0x79
000178  53746163          DCB      0x53,0x74,0x61,0x63
00017c  6b202629          DCB      0x6b,0x20,0x26,0x29
000180  00                DCB      0x00
                  |symbol_number.86|
000181  416e6b            DCB      0x41,0x6e,0x6b
000184  693a3a52          DCB      0x69,0x3a,0x3a,0x52
000188  6573756c          DCB      0x65,0x73,0x75,0x6c
00018c  7420416e          DCB      0x74,0x20,0x41,0x6e
000190  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000194  456d6265          DCB      0x45,0x6d,0x62,0x65
000198  64646564          DCB      0x64,0x64,0x65,0x64
00019c  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
0001a0  74656765          DCB      0x74,0x65,0x67,0x65
0001a4  72436f75          DCB      0x72,0x43,0x6f,0x75
0001a8  6e74733a          DCB      0x6e,0x74,0x73,0x3a
0001ac  3a536574          DCB      0x3a,0x53,0x65,0x74
0001b0  28636f6e          DCB      0x28,0x63,0x6f,0x6e
0001b4  73742041          DCB      0x73,0x74,0x20,0x41
0001b8  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0001bc  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0001c0  65646465          DCB      0x65,0x64,0x64,0x65
0001c4  643a3a49          DCB      0x64,0x3a,0x3a,0x49
0001c8  6e746567          DCB      0x6e,0x74,0x65,0x67
0001cc  6572436f          DCB      0x65,0x72,0x43,0x6f
0001d0  756e7473          DCB      0x75,0x6e,0x74,0x73
0001d4  20262900          DCB      0x20,0x26,0x29,0x00
0001d8  4c696e65          DCB      0x4c,0x69,0x6e,0x65
0001dc  61725365          DCB      0x61,0x72,0x53,0x65
0001e0  7175656e          DCB      0x71,0x75,0x65,0x6e
0001e4  63653c54          DCB      0x63,0x65,0x3c,0x54
0001e8  7970653e          DCB      0x79,0x70,0x65,0x3e
0001ec  3a3a636f          DCB      0x3a,0x3a,0x63,0x6f
0001f0  6d707574          DCB      0x6d,0x70,0x75,0x74
0001f4  6553697a          DCB      0x65,0x53,0x69,0x7a
0001f8  65000000          DCB      0x65,0x00,0x00,0x00
0001fc  73697a65          DCB      0x73,0x69,0x7a,0x65
000200  20657374          DCB      0x20,0x65,0x73,0x74
000204  696d6174          DCB      0x69,0x6d,0x61,0x74
000208  696f6e20          DCB      0x69,0x6f,0x6e,0x20
00020c  6661696c          DCB      0x66,0x61,0x69,0x6c
000210  65640000          DCB      0x65,0x64,0x00,0x00
000214  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000218  6f726574          DCB      0x6f,0x72,0x65,0x74
00021c  6563685c          DCB      0x65,0x63,0x68,0x5c
000220  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000224  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000228  6e636c75          DCB      0x6e,0x63,0x6c,0x75
00022c  64655c61          DCB      0x64,0x65,0x5c,0x61
000230  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000234  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000238  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
00023c  6f626f74          DCB      0x6f,0x62,0x6f,0x74
000240  2f736571          DCB      0x2f,0x73,0x65,0x71
000244  75656e63          DCB      0x75,0x65,0x6e,0x63
000248  65732e68          DCB      0x65,0x73,0x2e,0x68
00024c  00000000          DCB      0x00,0x00,0x00,0x00
000250  41727261          DCB      0x41,0x72,0x72,0x61
000254  793c5479          DCB      0x79,0x3c,0x54,0x79
000258  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00025c  3a436f6d          DCB      0x3a,0x43,0x6f,0x6d
000260  70757465          DCB      0x70,0x75,0x74,0x65
000264  52657175          DCB      0x52,0x65,0x71,0x75
000268  69726564          DCB      0x69,0x72,0x65,0x64
00026c  53747269          DCB      0x53,0x74,0x72,0x69
000270  64650000          DCB      0x64,0x65,0x00,0x00
000274  496e7661          DCB      0x49,0x6e,0x76,0x61
000278  6c696420          DCB      0x6c,0x69,0x64,0x20
00027c  73697a65          DCB      0x73,0x69,0x7a,0x65
000280  00000000          DCB      0x00,0x00,0x00,0x00
000284  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000288  6f726574          DCB      0x6f,0x72,0x65,0x74
00028c  6563685c          DCB      0x65,0x63,0x68,0x5c
000290  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000294  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000298  6e636c75          DCB      0x6e,0x63,0x6c,0x75
00029c  64655c61          DCB      0x64,0x65,0x5c,0x61
0002a0  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
0002a4  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
0002a8  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
0002ac  6f626f74          DCB      0x6f,0x62,0x6f,0x74
0002b0  2f617272          DCB      0x2f,0x61,0x72,0x72
0002b4  61793264          DCB      0x61,0x79,0x32,0x64
0002b8  2e680000          DCB      0x2e,0x68,0x00,0x00
0002bc  41727261          DCB      0x41,0x72,0x72,0x61
0002c0  793c5479          DCB      0x79,0x3c,0x54,0x79
0002c4  70653e3a          DCB      0x70,0x65,0x3e,0x3a
0002c8  3a676574          DCB      0x3a,0x67,0x65,0x74
0002cc  5f73697a          DCB      0x5f,0x73,0x69,0x7a
0002d0  65000000          DCB      0x65,0x00,0x00,0x00
0002d4  4e656761          DCB      0x4e,0x65,0x67,0x61
0002d8  74697665          DCB      0x74,0x69,0x76,0x65
0002dc  2064696d          DCB      0x20,0x64,0x69,0x6d
0002e0  656e7369          DCB      0x65,0x6e,0x73,0x69
0002e4  6f6e0000          DCB      0x6f,0x6e,0x00,0x00
0002e8  41727261          DCB      0x41,0x72,0x72,0x61
0002ec  793c5479          DCB      0x79,0x3c,0x54,0x79
0002f0  70653e3a          DCB      0x70,0x65,0x3e,0x3a
0002f4  3a536574          DCB      0x3a,0x53,0x65,0x74
0002f8  5a65726f          DCB      0x5a,0x65,0x72,0x6f
0002fc  00000000          DCB      0x00,0x00,0x00,0x00
000300  41727261          DCB      0x41,0x72,0x72,0x61
000304  793c5479          DCB      0x79,0x3c,0x54,0x79
000308  70653e20          DCB      0x70,0x65,0x3e,0x20
00030c  6973206e          DCB      0x69,0x73,0x20,0x6e
000310  6f742076          DCB      0x6f,0x74,0x20,0x76
000314  616c6964          DCB      0x61,0x6c,0x69,0x64
000318  00                DCB      0x00

                          AREA ||t._ZN4Anki8Embedded5PointIfEC1Ev||, COMGROUP=_ZN4Anki8Embedded5PointIfEC1Ev, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5PointIfEC2Ev                  ; Alternate entry point ; Anki::Embedded::Point<float>::Point__sub_object()
                  _ZN4Anki8Embedded5PointIfEC1Ev PROC ; Anki::Embedded::Point<float>::Point()
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
000000  ed9f0a03          VLDR     s0,|L68.16|
000004  ed800a00          VSTR     s0,[r0,#0]
000008  ed800a01          VSTR     s0,[r0,#4]
00000c  4770              BX       lr
                          ENDP

00000e  0000              DCW      0x0000
                  |L68.16|
000010  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.69||, COMGROUP=_ZN4Anki8Embedded5PointIfEC1Ev, LINKORDER=||t._ZN4Anki8Embedded5PointIfEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.69||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5PointIfEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_||, COMGROUP=_ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC2ERKNS0_14LinearSequenceIiEES6_bS6_S6_                  ; Alternate entry point ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1__sub_object(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
                  _ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_ PROC ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
;;;284    
;;;285        template<typename Type> ArraySliceLimits_in1_out1<Type>::ArraySliceLimits_in1_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;286          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;287          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;288          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed)
;;;289        {
;;;290          isValid = false;
;;;291    
;;;292          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;293    
;;;294          if(!in1_isTransposed) {
;;;295            if(rawOut1Limits.xSize == rawIn1Limits.xSize && rawOut1Limits.ySize == rawIn1Limits.ySize) {
;;;296              isValid = true;
;;;297              isSimpleIteration = true;
;;;298    
;;;299              this->in1Y = this->rawIn1Limits.yStart;
;;;300              this->out1Y = this->rawOut1Limits.yStart;
;;;301    
;;;302              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;303              this->in1_yInnerIncrement = 0;
;;;304            }
;;;305          } else { // if(!in1_isTransposed)
;;;306            if(rawOut1Limits.xSize == rawIn1Limits.ySize && rawOut1Limits.ySize == rawIn1Limits.xSize) {
;;;307              isValid = true;
;;;308              isSimpleIteration = false;
;;;309    
;;;310              this->in1X = this->rawIn1Limits.xStart;
;;;311              this->out1Y = this->rawOut1Limits.yStart;
;;;312    
;;;313              this->in1_xInnerIncrement = 0;
;;;314              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;315            }
;;;316          } // if(!in1_isTransposed) ... else
;;;317    
;;;318          if(!isValid) {
;;;319            AnkiError("ArraySliceLimits_in1_out1", "Subscripted assignment dimension mismatch");
;;;320            return;
;;;321          }
;;;322        } // ArraySliceLimits_in1_out1
;;;323    
000000  b570              PUSH     {r4-r6,lr}
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  e9dd5c06          LDRD     r5,r12,[sp,#0x18]
00000a  6828              LDR      r0,[r5,#0]
00000c  6160              STR      r0,[r4,#0x14]
00000e  f8dc0000          LDR      r0,[r12,#0]
000012  61a0              STR      r0,[r4,#0x18]
000014  f8dc6004          LDR      r6,[r12,#4]
000018  62a6              STR      r6,[r4,#0x28]
00001a  f8dc6008          LDR      r6,[r12,#8]
00001e  62e6              STR      r6,[r4,#0x2c]
000020  f8dcc000          LDR      r12,[r12,#0]
000024  f8c4c030          STR      r12,[r4,#0x30]
000028  f8d5c004          LDR      r12,[r5,#4]
00002c  f8c4c034          STR      r12,[r4,#0x34]
000030  f8d5c008          LDR      r12,[r5,#8]
000034  f8c4c038          STR      r12,[r4,#0x38]
000038  f8d5c000          LDR      r12,[r5,#0]
00003c  f8c4c03c          STR      r12,[r4,#0x3c]
000040  6855              LDR      r5,[r2,#4]
000042  6425              STR      r5,[r4,#0x40]
000044  6895              LDR      r5,[r2,#8]
000046  6465              STR      r5,[r4,#0x44]
000048  6812              LDR      r2,[r2,#0]
00004a  64a2              STR      r2,[r4,#0x48]
00004c  684a              LDR      r2,[r1,#4]
00004e  64e2              STR      r2,[r4,#0x4c]
000050  688a              LDR      r2,[r1,#8]
000052  6522              STR      r2,[r4,#0x50]
000054  6809              LDR      r1,[r1,#0]
000056  6561              STR      r1,[r4,#0x54]
000058  f04f0c00          MOV      r12,#0
00005c  f8843058          STRB     r3,[r4,#0x58]
000060  f884c000          STRB     r12,[r4,#0]
000064  6ae0              LDR      r0,[r4,#0x2c]
000066  61e0              STR      r0,[r4,#0x1c]
000068  6b22              LDR      r2,[r4,#0x30]
00006a  2001              MOVS     r0,#1
00006c  b18b              CBZ      r3,|L75.146|
00006e  428a              CMP      r2,r1
000070  d121              BNE      |L75.182|
000072  6ca2              LDR      r2,[r4,#0x48]
000074  6be1              LDR      r1,[r4,#0x3c]
000076  4291              CMP      r1,r2
000078  d11d              BNE      |L75.182|
00007a  7020              STRB     r0,[r4,#0]
00007c  f884c001          STRB     r12,[r4,#1]
000080  6c20              LDR      r0,[r4,#0x40]
000082  6120              STR      r0,[r4,#0x10]
000084  6b60              LDR      r0,[r4,#0x34]
000086  f8c4c020          STR      r12,[r4,#0x20]
00008a  6060              STR      r0,[r4,#4]
00008c  6d20              LDR      r0,[r4,#0x50]
00008e  6260              STR      r0,[r4,#0x24]
000090  e00e              B        |L75.176|
                  |L75.146|
000092  6ca3              LDR      r3,[r4,#0x48]
000094  429a              CMP      r2,r3
000096  bf04              ITT      EQ
000098  6be2              LDREQ    r2,[r4,#0x3c]
00009a  428a              CMPEQ    r2,r1
00009c  d10b              BNE      |L75.182|
00009e  7020              STRB     r0,[r4,#0]
0000a0  7060              STRB     r0,[r4,#1]
0000a2  6ce0              LDR      r0,[r4,#0x4c]
0000a4  60e0              STR      r0,[r4,#0xc]
0000a6  6b60              LDR      r0,[r4,#0x34]
0000a8  6060              STR      r0,[r4,#4]
0000aa  6c60              LDR      r0,[r4,#0x44]
0000ac  e9c40c08          STRD     r0,r12,[r4,#0x20]
                  |L75.176|
0000b0  b002              ADD      sp,sp,#8
0000b2  4620              MOV      r0,r4
0000b4  bd70              POP      {r4-r6,pc}
                  |L75.182|
0000b6  f240113f          MOV      r1,#0x13f
0000ba  4806              LDR      r0,|L75.212|
0000bc  e9cd0100          STRD     r0,r1,[sp,#0]
0000c0  a305              ADR      r3,|L75.216|
0000c2  a214              ADR      r2,|L75.276|
0000c4  a11e              ADR      r1,|L75.320|
0000c6  2005              MOVS     r0,#5
0000c8  f7fffffe          BL       _Anki_Log
0000cc  b002              ADD      sp,sp,#8
0000ce  4620              MOV      r0,r4
0000d0  bd70              POP      {r4-r6,pc}
                          ENDP

0000d2  0000              DCW      0x0000
                  |L75.212|
                          DCD      _ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)::__PRETTY_FUNCTION__
                  |L75.216|
0000d8  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/arrayS"
0000dc  6f726574
0000e0  6563685c
0000e4  636f6d6d
0000e8  6f6e5c69
0000ec  6e636c75
0000f0  64655c61
0000f4  6e6b692f
0000f8  636f6d6d
0000fc  6f6e2f72
000100  6f626f74
000104  2f617272
000108  617953  
00010b  6c696365          DCB      "lices.h",0
00010f  732e6800
000113  00                DCB      0
                  |L75.276|
000114  53756273          DCB      "Subscripted assignment dimension mismatch",0
000118  63726970
00011c  74656420
000120  61737369
000124  676e6d65
000128  6e742064
00012c  696d656e
000130  73696f6e
000134  206d6973
000138  6d617463
00013c  6800    
00013e  00                DCB      0
00013f  00                DCB      0
                  |L75.320|
000140  41727261          DCB      "ArraySliceLimits_in1_out1",0
000144  79536c69
000148  63654c69
00014c  6d697473
000150  5f696e31
000154  5f6f7574
000158  3100    
00015a  00                DCB      0
00015b  00                DCB      0

                          AREA ||area_number.76||, COMGROUP=_ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_, LINKORDER=||t._ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.76||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIiEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<int>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L82.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L82.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L82.384|
000044  a25c              ADR      r2,|L82.440|
000046  a160              ADR      r1,|L82.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L82.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L82.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L82.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L82.384|
000080  a24d              ADR      r2,|L82.440|
000082  a157              ADR      r1,|L82.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L82.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L82.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L82.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L82.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L82.384|
0000c8  a251              ADR      r2,|L82.528|
0000ca  a156              ADR      r1,|L82.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L82.372|
                  |L82.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L82.384|
0000e0  a258              ADR      r2,|L82.580|
0000e2  a15f              ADR      r1,|L82.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L82.372|
                  |L82.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L82.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L82.384|
000110  a259              ADR      r2,|L82.632|
000112  a144              ADR      r1,|L82.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L82.372|
                  |L82.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L82.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L82.384|
00015a  a251              ADR      r2,|L82.672|
00015c  a140              ADR      r1,|L82.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L82.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L82.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L82.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L82.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L82.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L82.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L82.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L82.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L82.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L82.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L82.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L82.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L82.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L82.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.83||, COMGROUP=_ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.83||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListIiEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIiEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListIiEC2EiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::FixedLengthList<int>::FixedLengthList__sub_object(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded15FixedLengthListIiEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::FixedLengthList<int>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;75     
;;;76         template<typename Type> FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;77           : ArraySlice<Type>(Array<Type>(1, maximumSize, memory, flags), LinearSequence<s32>(0,0), LinearSequence<s32>(0,0))
;;;78         {
;;;79           if(this->array.get_numElements() == 0) {
;;;80             this->arrayData = NULL;
;;;81           } else {
;;;82             this->arrayData = this->array.Pointer(0,0);
;;;83           }
;;;84     
;;;85           if(flags.get_isFullyAllocated()) {
;;;86             this->set_size(maximumSize);
;;;87           } else {
;;;88             this->set_size(0);
;;;89           }
;;;90         } // FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;91     
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  b08d              SUB      sp,sp,#0x34
000006  4604              MOV      r4,r0
000008  9810              LDR      r0,[sp,#0x40]
00000a  4613              MOV      r3,r2
00000c  468b              MOV      r11,r1
00000e  460a              MOV      r2,r1
000010  9000              STR      r0,[sp,#0]
000012  2101              MOVS     r1,#1
000014  a801              ADD      r0,sp,#4
000016  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00001a  f8d08010          LDR      r8,[r0,#0x10]
00001e  e8b002e0          LDM      r0!,{r5-r7,r9}
000022  2200              MOVS     r2,#0
000024  4611              MOV      r1,r2
000026  a806              ADD      r0,sp,#0x18
000028  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00002c  4682              MOV      r10,r0
00002e  2200              MOVS     r2,#0
000030  4611              MOV      r1,r2
000032  a809              ADD      r0,sp,#0x24
000034  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000038  e9da1200          LDRD     r1,r2,[r10,#0]
00003c  f8da3008          LDR      r3,[r10,#8]
000040  60a3              STR      r3,[r4,#8]
000042  e9c41200          STRD     r1,r2,[r4,#0]
000046  e9d01200          LDRD     r1,r2,[r0,#0]
00004a  6880              LDR      r0,[r0,#8]
00004c  f8c48028          STR      r8,[r4,#0x28]
000050  60e1              STR      r1,[r4,#0xc]
000052  e9c42004          STRD     r2,r0,[r4,#0x10]
000056  f1040018          ADD      r0,r4,#0x18
00005a  2200              MOVS     r2,#0
00005c  e8a002e0          STM      r0!,{r5-r7,r9}
000060  2d00              CMP      r5,#0
000062  bfc8              IT       GT
000064  2e00              CMPGT    r6,#0
000066  dd25              BLE      |L89.180|
000068  fb05f006          MUL      r0,r5,r6
00006c  b310              CBZ      r0,|L89.180|
00006e  2000              MOVS     r0,#0
000070  fb008007          MLA      r0,r0,r7,r8
000074  62e0              STR      r0,[r4,#0x2c]
                  |L89.118|
000076  2d00              CMP      r5,#0
000078  bfc8              IT       GT
00007a  2e00              CMPGT    r6,#0
00007c  dd1c              BLE      |L89.184|
00007e  fb05f006          MUL      r0,r5,r6
000082  b1c8              CBZ      r0,|L89.184|
000084  2000              MOVS     r0,#0
000086  fb008007          MLA      r0,r0,r7,r8
00008a  6320              STR      r0,[r4,#0x30]
                  |L89.140|
00008c  2d00              CMP      r5,#0
00008e  bfc8              IT       GT
000090  2e00              CMPGT    r6,#0
000092  dd13              BLE      |L89.188|
000094  fb05f006          MUL      r0,r5,r6
000098  b180              CBZ      r0,|L89.188|
00009a  2000              MOVS     r0,#0
00009c  fb008007          MLA      r0,r0,r7,r8
0000a0  6320              STR      r0,[r4,#0x30]
                  |L89.162|
0000a2  a810              ADD      r0,sp,#0x40
0000a4  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0000a8  b150              CBZ      r0,|L89.192|
0000aa  4659              MOV      r1,r11
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi ; Anki::Embedded::FixedLengthList<int>::set_size(int)
0000b2  e009              B        |L89.200|
                  |L89.180|
0000b4  62e2              STR      r2,[r4,#0x2c]
0000b6  e7de              B        |L89.118|
                  |L89.184|
0000b8  6322              STR      r2,[r4,#0x30]
0000ba  e7e7              B        |L89.140|
                  |L89.188|
0000bc  6322              STR      r2,[r4,#0x30]
0000be  e7f0              B        |L89.162|
                  |L89.192|
0000c0  2100              MOVS     r1,#0
0000c2  4620              MOV      r0,r4
0000c4  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi ; Anki::Embedded::FixedLengthList<int>::set_size(int)
                  |L89.200|
0000c8  b011              ADD      sp,sp,#0x44
0000ca  4620              MOV      r0,r4
0000cc  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP


                          AREA ||area_number.90||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIiEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListIiEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.90||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListIiEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Eii, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded14LinearSequenceIiEC2Eii                  ; Alternate entry point ; Anki::Embedded::LinearSequence<int>::LinearSequence__sub_object(int, int)
                  _ZN4Anki8Embedded14LinearSequenceIiEC1Eii PROC ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
;;;30     
;;;31         template<typename Type> LinearSequence<Type>::LinearSequence(const Type start, const Type end)
;;;32           : start(start), increment(1)
;;;33         {
;;;34           this->size = computeSize(this->start, this->increment, end);
;;;35         }
;;;36     
000000  b530              PUSH     {r4,r5,lr}
000002  4604              MOV      r4,r0
000004  2301              MOVS     r3,#1
000006  b083              SUB      sp,sp,#0xc
000008  e9c41301          STRD     r1,r3,[r4,#4]
00000c  4291              CMP      r1,r2
00000e  d019              BEQ      |L96.68|
000010  2500              MOVS     r5,#0
000012  429d              CMP      r5,r3
000014  da01              BGE      |L96.26|
000016  4291              CMP      r1,r2
000018  dd01              BLE      |L96.30|
                  |L96.26|
00001a  462b              MOV      r3,r5
00001c  e012              B        |L96.68|
                  |L96.30|
00001e  1a50              SUBS     r0,r2,r1
000020  1c40              ADDS     r0,r0,#1
000022  fb90f3f3          SDIV     r3,r0,r3
000026  2b00              CMP      r3,#0
000028  da0c              BGE      |L96.68|
00002a  2185              MOVS     r1,#0x85
00002c  4807              LDR      r0,|L96.76|
00002e  4b08              LDR      r3,|L96.80|
000030  e9cd0100          STRD     r0,r1,[sp,#0]
000034  f1a30218          SUB      r2,r3,#0x18
000038  f1a20124          SUB      r1,r2,#0x24
00003c  2005              MOVS     r0,#5
00003e  f7fffffe          BL       _Anki_Log
000042  462b              MOV      r3,r5
                  |L96.68|
000044  6023              STR      r3,[r4,#0]
000046  b003              ADD      sp,sp,#0xc
000048  4620              MOV      r0,r4
00004a  bd30              POP      {r4,r5,pc}
                          ENDP

                  |L96.76|
                          DCD      _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
                  |L96.80|
                          DCD      ||.constdata||+0x214

                          AREA ||area_number.97||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Eii, LINKORDER=||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.97||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIiE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIiE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi PROC ; Anki::Embedded::Array<int>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L103.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L103.56|
00000e  4b0b              LDR      r3,|L103.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f1030250          ADD      r2,r3,#0x50
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L103.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L103.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::get_size(int) const::__PRETTY_FUNCTION__
                  |L103.60|
                          DCD      ||.constdata||+0x284

                          AREA ||area_number.104||, COMGROUP=_ZNK4Anki8Embedded5ArrayIiE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIiE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.104||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIiE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv PROC ; Anki::Embedded::Quadrilateral<float>::ComputeClockwiseCorners<float>() const
;;;268          // Warning: This may give weird results for non-convex quadrilaterals
;;;269          template<typename OutType> Quadrilateral<OutType> ComputeClockwiseCorners() const;
000000  b5f0              PUSH     {r4-r7,lr}
000002  460d              MOV      r5,r1
000004  ed2d8b04          VPUSH    {d8-d9}
000008  b0c1              SUB      sp,sp,#0x104
00000a  4607              MOV      r7,r0
00000c  2201              MOVS     r2,#1
00000e  2300              MOVS     r3,#0
000010  4611              MOV      r1,r2
000012  a833              ADD      r0,sp,#0xcc
000014  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000018  6803              LDR      r3,[r0,#0]
00001a  2280              MOVS     r2,#0x80
00001c  a902              ADD      r1,sp,#8
00001e  a822              ADD      r0,sp,#0x88
000020  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
000024  2300              MOVS     r3,#0
000026  461a              MOV      r2,r3
000028  2101              MOVS     r1,#1
00002a  a83e              ADD      r0,sp,#0xf8
00002c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000030  6800              LDR      r0,[r0,#0]
000032  9000              STR      r0,[sp,#0]
000034  ab22              ADD      r3,sp,#0x88
000036  2204              MOVS     r2,#4
000038  2101              MOVS     r1,#1
00003a  a829              ADD      r0,sp,#0xa4
00003c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000040  2300              MOVS     r3,#0
000042  461a              MOV      r2,r3
000044  2101              MOVS     r1,#1
000046  a83f              ADD      r0,sp,#0xfc
000048  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00004c  6800              LDR      r0,[r0,#0]
00004e  9000              STR      r0,[sp,#0]
000050  ab22              ADD      r3,sp,#0x88
000052  2204              MOVS     r2,#4
000054  2101              MOVS     r1,#1
000056  a82e              ADD      r0,sp,#0xb8
000058  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00005c  aa34              ADD      r2,sp,#0xd0
00005e  4628              MOV      r0,r5
000060  ed9f9a64          VLDR     s18,|L110.500|
000064  2300              MOVS     r3,#0
000066  ed8d9a34          VSTR     s18,[sp,#0xd0]
00006a  ed8d9a35          VSTR     s18,[sp,#0xd4]
                  |L110.110|
00006e  eb0001c3          ADD      r1,r0,r3,LSL #3
000072  edd20a00          VLDR     s1,[r2,#0]
000076  ed910a00          VLDR     s0,[r1,#0]
00007a  1c5b              ADDS     r3,r3,#1
00007c  2b04              CMP      r3,#4
00007e  ee300a80          VADD.F32 s0,s1,s0
000082  ed820a00          VSTR     s0,[r2,#0]
000086  ed920a01          VLDR     s0,[r2,#4]
00008a  edd10a01          VLDR     s1,[r1,#4]
00008e  ee300a20          VADD.F32 s0,s0,s1
000092  ed820a01          VSTR     s0,[r2,#4]
000096  dbea              BLT      |L110.110|
000098  edd20a00          VLDR     s1,[r2,#0]
00009c  eeb50a00          VMOV.F32 s0,#0.25000000
0000a0  2400              MOVS     r4,#0
0000a2  ee600a80          VMUL.F32 s1,s1,s0
0000a6  edc20a00          VSTR     s1,[r2,#0]
0000aa  edd20a01          VLDR     s1,[r2,#4]
0000ae  ee200a80          VMUL.F32 s0,s1,s0
0000b2  ed820a01          VSTR     s0,[r2,#4]
                  |L110.182|
0000b6  eb0501c4          ADD      r1,r5,r4,LSL #3
0000ba  eddd0a34          VLDR     s1,[sp,#0xd0]
0000be  ed910a00          VLDR     s0,[r1,#0]
0000c2  2000              MOVS     r0,#0
0000c4  9a2b              LDR      r2,[sp,#0xac]
0000c6  ee708a60          VSUB.F32 s17,s0,s1
0000ca  ed910a01          VLDR     s0,[r1,#4]
0000ce  eddd0a35          VLDR     s1,[sp,#0xd4]
0000d2  992d              LDR      r1,[sp,#0xb4]
0000d4  eef58ac0          VCMPE.F32 s17,#0.0
0000d8  ee308a60          VSUB.F32 s16,s0,s1
0000dc  fb001002          MLA      r0,r0,r2,r1
0000e0  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000e4  eb000684          ADD      r6,r0,r4,LSL #2
0000e8  bf02              ITTT     EQ
0000ea  eeb58ac0          VCMPEEQ.F32 s16,#0.0
0000ee  eef1fa10          VMRSEQ   APSR_nzcv,FPSCR
0000f2  ed869a00          VSTREQ   s18,[r6,#0]
0000f6  d016              BEQ      |L110.294|
0000f8  eef00a68          VMOV.F32 s1,s17
0000fc  eeb00a48          VMOV.F32 s0,s16
000100  f7fffffe          BL       __hardfp_atan2f
000104  ee680aa8          VMUL.F32 s1,s17,s17
000108  ed860a00          VSTR     s0,[r6,#0]
00010c  ee480a08          VMLA.F32 s1,s16,s16
000110  eeb10ae0          VSQRT.F32 s0,s1
000114  eeb40a40          VCMP.F32 s0,s0
000118  eef1fa10          VMRS     APSR_nzcv,FPSCR
00011c  bf1c              ITT      NE
00011e  eeb00a60          VMOVNE.F32 s0,s1
000122  f7fffffe          BLNE     __hardfp_sqrtf
                  |L110.294|
000126  1c64              ADDS     r4,r4,#1
000128  2c04              CMP      r4,#4
00012a  dbc4              BLT      |L110.182|
00012c  4832              LDR      r0,|L110.504|
00012e  2400              MOVS     r4,#0
000130  e9cd4000          STRD     r4,r0,[sp,#0]
000134  2301              MOVS     r3,#1
000136  461a              MOV      r2,r3
000138  a92e              ADD      r1,sp,#0xb8
00013a  a829              ADD      r0,sp,#0xa4
00013c  f7fffffe          BL       _ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)
000140  9a30              LDR      r2,[sp,#0xc0]
000142  9932              LDR      r1,[sp,#0xc8]
000144  4638              MOV      r0,r7
000146  fb041102          MLA      r1,r4,r2,r1
00014a  2304              MOVS     r3,#4
00014c  680a              LDR      r2,[r1,#0]
00014e  eb0502c2          ADD      r2,r5,r2,LSL #3
000152  ed920a00          VLDR     s0,[r2,#0]
000156  edd20a01          VLDR     s1,[r2,#4]
00015a  ed8d0a36          VSTR     s0,[sp,#0xd8]
00015e  edcd0a37          VSTR     s1,[sp,#0xdc]
000162  684a              LDR      r2,[r1,#4]
000164  eb0502c2          ADD      r2,r5,r2,LSL #3
000168  ed920a00          VLDR     s0,[r2,#0]
00016c  edd20a01          VLDR     s1,[r2,#4]
000170  ed8d0a38          VSTR     s0,[sp,#0xe0]
000174  edcd0a39          VSTR     s1,[sp,#0xe4]
000178  688a              LDR      r2,[r1,#8]
00017a  eb0502c2          ADD      r2,r5,r2,LSL #3
00017e  ed920a00          VLDR     s0,[r2,#0]
000182  edd20a01          VLDR     s1,[r2,#4]
000186  ed8d0a3a          VSTR     s0,[sp,#0xe8]
00018a  edcd0a3b          VSTR     s1,[sp,#0xec]
00018e  68c9              LDR      r1,[r1,#0xc]
000190  2208              MOVS     r2,#8
000192  eb0501c1          ADD      r1,r5,r1,LSL #3
000196  ed910a00          VLDR     s0,[r1,#0]
00019a  edd10a01          VLDR     s1,[r1,#4]
00019e  ed8d0a3c          VSTR     s0,[sp,#0xf0]
0001a2  edcd0a3d          VSTR     s1,[sp,#0xf4]
0001a6  4915              LDR      r1,|L110.508|
0001a8  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
0001ac  ed9d0a36          VLDR     s0,[sp,#0xd8]
0001b0  ed800a00          VSTR     s0,[r0,#0]
0001b4  ed9d0a37          VLDR     s0,[sp,#0xdc]
0001b8  ed800a01          VSTR     s0,[r0,#4]
0001bc  ed9d0a38          VLDR     s0,[sp,#0xe0]
0001c0  ed800a02          VSTR     s0,[r0,#8]
0001c4  ed9d0a39          VLDR     s0,[sp,#0xe4]
0001c8  ed800a03          VSTR     s0,[r0,#0xc]
0001cc  ed9d0a3a          VLDR     s0,[sp,#0xe8]
0001d0  ed800a04          VSTR     s0,[r0,#0x10]
0001d4  ed9d0a3b          VLDR     s0,[sp,#0xec]
0001d8  ed800a05          VSTR     s0,[r0,#0x14]
0001dc  ed9d0a3c          VLDR     s0,[sp,#0xf0]
0001e0  ed800a06          VSTR     s0,[r0,#0x18]
0001e4  ed9d0a3d          VLDR     s0,[sp,#0xf4]
0001e8  ed800a07          VSTR     s0,[r0,#0x1c]
0001ec  b041              ADD      sp,sp,#0x104
0001ee  ecbd8b04          VPOP     {d8-d9}
0001f2  bdf0              POP      {r4-r7,pc}
;;;270    
;;;271          template<typename OutType> Quadrilateral<OutType> ComputeRotatedCorners(const f32 radians) const;
;;;272    
;;;273          bool IsConvex() const;
;;;274    
;;;275          bool operator== (const Quadrilateral<Type> &quad2) const;
;;;276    
;;;277          Quadrilateral<Type> operator+ (const Quadrilateral<Type> &quad2) const;
;;;278    
;;;279          Quadrilateral<Type> operator- (const Quadrilateral<Type> &quad2) const;
;;;280    
;;;281          inline Quadrilateral<Type>& operator= (const Quadrilateral<Type> &quad2);
;;;282    
;;;283          // Keeping this explicit to avoid accidental setting of quads of
;;;284          // different types
;;;285          template<typename InType> void SetCast(const Quadrilateral<InType> &quad2);
;;;286    
;;;287          inline const Point<Type>& operator[] (const s32 index) const;
;;;288          inline Point<Type>& operator[] (const s32 index);
;;;289        }; // class Quadrilateral<Type>
;;;290      } // namespace Embedded
;;;291    } // namespace Anki
;;;292    
;;;293    #endif // _ANKICORETECHEMBEDDED_COMMON_POINT_DECLARATIONS_H_
;;;20     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;21     #include "anki/common/robot/sequences_declarations.h"
;;;1      /**
;;;2      File: sequences_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      A Sequence is a mathematically-defined, ordered list. The sequence classes allow for operations on sequences, without requiring them to be explicitly evaluated.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/flags_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> class Array;
;;;23         template<typename Type> class FixedLengthList;
;;;24         template<typename Type> class ArraySlice;
;;;25         class MemoryStack;
;;;26     
;;;27         // #pragma mark --- Class Declarations ---
;;;28         template<typename Type> class Sequence
;;;29         {
;;;30         }; // class Sequence
;;;31     
;;;32         // A LinearSequence is like the result of a call to Matlab's linspace() It has a start, end, and
;;;33         // increment. It does not explicitly compute the values in the sequence, so does not require
;;;34         // much memory.
;;;35         //
;;;36         // WARNING:
;;;37         // The "end" of a LinearSequence is computed automatically, and is less-than-or-equal-to the
;;;38         // requested end.
;;;39         template<typename Type> class LinearSequence : public Sequence<Type>
;;;40         {
;;;41         public:
;;;42     
;;;43           LinearSequence();
;;;44     
;;;45           // Matlab equivalent: start:end
;;;46           LinearSequence(const Type start, const Type end);
;;;47     
;;;48           // Matlab equivalent: start:increment:end
;;;49           LinearSequence(const Type start, const Type increment, const Type end);
;;;50     
;;;51           // No Matlab equivalent
;;;52           // NOTE: end is unused. It is just present to prevent confusion with the other polymorphic constructors
;;;53           LinearSequence(const Type start, const Type increment, const Type end, const s32 size);
;;;54     
;;;55           // Explicitly evaluate each element of the sequence, and put the results in an Array.
;;;56           Array<Type> Evaluate(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;57           Result Evaluate(ArraySlice<Type> out) const;
;;;58     
;;;59           Type get_start() const;
;;;60     
;;;61           // NOTE: The increment is meaningless for LinearSequences of size 0 or 1.
;;;62           Type get_increment() const;
;;;63     
;;;64           // Note: End it not computed, as it is tempting to use it as a loop condition, but it is not safe
;;;65           // Type get_end() const;
;;;66     
;;;67           // Matlab equivalent: length(start:increment:end)
;;;68           s32 get_size() const;
;;;69     
;;;70         protected:
;;;71           // For speed, FixedLengthList is allowed to access protected members, instead of having to
;;;72           // construct a new LinearSequence every time an element is popped or pushed
;;;73           template<typename FixedLengthListType> friend class FixedLengthList;
;;;74     
;;;75           s32 size;
;;;76     
;;;77           Type start;
;;;78           Type increment;
;;;79     
;;;80           static s32 computeSize(const Type start, const Type increment, const Type end);
;;;81         }; // class LinearSequence
;;;82     
;;;83         // IndexSequence creates the input for slicing an Array
;;;84         // If start or end is less than 0, it is equivalent to (end+value)
;;;85         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type end, s32 arraySize);
;;;86         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type increment, Type end, s32 arraySize);
;;;87         LinearSequence<s32> IndexSequence(s32 arraySize); // Internally, it sets start==0, end=arraySize-1, like the Matlab colon operator array(:,:)
;;;88     
;;;89         // Linspace only works correctly for f32 and f64. To prevent misusage, trying ints will give a linker error.
;;;90         template<typename Type> LinearSequence<Type> Linspace(const Type start, const Type end, const s32 size);
;;;91     
;;;92         // These do not link, as they are unsafe
;;;93         template<> LinearSequence<u8> Linspace(const u8 start, const u8 end, const s32 size);
;;;94         template<> LinearSequence<s8> Linspace(const s8 start, const s8 end, const s32 size);
;;;95         template<> LinearSequence<u16> Linspace(const u16 start, const u16 end, const s32 size);
;;;96         template<> LinearSequence<s16> Linspace(const s16 start, const s16 end, const s32 size);
;;;97         template<> LinearSequence<u32> Linspace(const u32 start, const u32 end, const s32 size);
;;;98         template<> LinearSequence<s32> Linspace(const s32 start, const s32 end, const s32 size);
;;;99         template<> LinearSequence<u64> Linspace(const u64 start, const u64 end, const s32 size);
;;;100        template<> LinearSequence<s64> Linspace(const s64 start, const s64 end, const s32 size);
;;;101    
;;;102        // TODO: Logspace
;;;103        //template<typename Type> class Logspace : public Sequence<Type>
;;;104        //{
;;;105        //public:
;;;106        //protected:
;;;107        //};
;;;108    
;;;109        // A Meshgrid is like the result of a call to Matlab's meshgrid(). It is made of two
;;;110        // LinearSequence objects, so does not require much memory.
;;;111        template<typename Type> class Meshgrid
;;;112        {
;;;113        public:
;;;114          Meshgrid();
;;;115    
;;;116          // Matlab equivalent: meshgrid(xGridVector, yGridVector)
;;;117          Meshgrid(const LinearSequence<Type> xGridVector, const LinearSequence<Type> yGridVector);
;;;118    
;;;119          // Allocate an Array, and evaluate this Meshgrid object
;;;120          //
;;;121          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;122          // The first suffix X or Y is for the xGrid vs yGrid
;;;123          // The second suffix 1 or 2 is for 1D vs 2D output
;;;124          Array<Type> EvaluateX1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;125          Array<Type> EvaluateX2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;126          Array<Type> EvaluateY1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;127          Array<Type> EvaluateY2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;128    
;;;129          // Evaluate this Meshgrid object into a pre-allocated Array
;;;130          //
;;;131          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;132          Result EvaluateX1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;133          Result EvaluateX2(ArraySlice<Type> out) const;
;;;134          Result EvaluateY1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;135          Result EvaluateY2(ArraySlice<Type> out) const;
;;;136    
;;;137          s32 get_numElements() const;
;;;138    
;;;139          inline const LinearSequence<Type>& get_xGridVector() const;
;;;140    
;;;141          inline const LinearSequence<Type>& get_yGridVector() const;
;;;142    
;;;143        protected:
;;;144          LinearSequence<Type> xGridVector;
;;;145          LinearSequence<Type> yGridVector;
;;;146        };
;;;147      } // namespace Embedded
;;;148    } //namespace Anki
;;;149    
;;;150    #endif // #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;22     
;;;23     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;24     namespace cv
;;;25     {
;;;26       class Mat;
;;;27       template<typename Type> class Mat_;
;;;28     }
;;;29     #endif
;;;30     
;;;31     namespace Anki
;;;32     {
;;;33       namespace Embedded
;;;34       {
;;;35         template<typename Type> class ArraySlice;
;;;36         template<typename Type> class ConstArraySlice;
;;;37         template<typename Type> class ConstArraySliceExpression;
;;;38     
;;;39         const s32 ARRAY_FILE_HEADER_LENGTH = 32;
;;;40         const s32 ARRAY_FILE_HEADER_VALID_LENGTH = 14; //< How many characters are not spaces
;;;41         const char ARRAY_FILE_HEADER[ARRAY_FILE_HEADER_LENGTH+1] = "\x89" "AnkiEArray1.2                  ";
;;;42     
;;;43         // #pragma mark --- Array Class Declaration ---
;;;44     
;;;45         template<typename Type> class Array
;;;46         {
;;;47         public:
;;;48     
;;;49           // The stride is the "numCols*sizeof(Type)" rounded up by 16, plus any boundary padding
;;;50           static s32 ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags);
;;;51     
;;;52           // The minimum required memory is the size of a stride, times the number of rows
;;;53           static s32 ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags);
;;;54     
;;;55           // Initializes Array as invalid
;;;56           Array();
;;;57     
;;;58           // Constructor for a Array, pointing to user-allocated MemoryStack. This is the preferred
;;;59           // method for creating a new Array.
;;;60           //
;;;61           // Flags::Buffer.isFullyAllocated doesn't do anything
;;;62           Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;63     
;;;64           // Constructor for a Array, pointing to user-allocated data. This type of array is more
;;;65           // restrictive than most matrix libraries. For example, it may make it hard to convert from
;;;66           // OpenCV::Mat to Array, though the reverse is trivial.
;;;67           //
;;;68           // If following are true, then the contents of data will not be modified, and it will work as
;;;69           // a normal buffer without extra zeros as stride padding:
;;;70           // 1. (numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0
;;;71           // 2. reinterpret_cast<size_t>(data) % MEMORY_ALIGNMENT == 0
;;;72           // 3. numRows*numCols*sizeof(Type) <= dataLength
;;;73           //
;;;74           // If Flags::Buffer.isFullyAllocated == true, then the input data buffer's stride must be a
;;;75           // simple multiple
;;;76           Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags=Flags::Buffer(false,false,true));
;;;77     
;;;78           // Load an image from file. Requires OpenCV;
;;;79           static Array<Type> LoadImage(const char * filename, MemoryStack &memory);
;;;80     
;;;81           // Load or save an array saved as a debugStream.
;;;82           // compressionLevel can be from 0 (uncompressed) to 9 (most compressed). If OpenCV is not used, it must be zero.
;;;83           static Array<Type> LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory);
;;;84           static Array<Type> LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength); //< allocatedBuffer must be allocated and freed manually
;;;85           Result SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const;
;;;86     
;;;87           // Pointer to the data, at a given (y,x) location
;;;88           //
;;;89           // NOTE:
;;;90           // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;91           // inner loop, like: "Type * restrict pArray = Array.Pointer(5);", then index
;;;92           // pArray in the inner loop.
;;;93           inline const Type* Pointer(const s32 index0, const s32 index1) const;
;;;94           inline Type* Pointer(const s32 index0, const s32 index1);
;;;95     
;;;96           // Use this operator for normal C-style 2d matrix indexing. For example, "array[5][0] = 6;"
;;;97           // will set the element in the fifth row and first column to 6. This is the same as
;;;98           // "array.Pointer(5)[0] = 6;"
;;;99           //
;;;100          // NOTE:
;;;101          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;102          // inner loop, like: "Type * restrict pArray = Array[5];", then index
;;;103          // pArray in the inner loop.
;;;104          inline const Type * operator[](const s32 index0) const;
;;;105          inline Type * operator[](const s32 index0);
;;;106    
;;;107          // Pointer to the data, at a given (y,x) location
;;;108          //
;;;109          // NOTE:
;;;110          // The default order of coordinates for the Point() constructor is (x,y). So for example,
;;;111          // access Array[5][3] via Array.Pointer(Point<s16>(3,5))
;;;112          //
;;;113          // NOTE:
;;;114          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;115          // inner loop, like: "Type * restrict pArray = Array.Pointer(Point<s16>(5,0));", then index
;;;116          // pArray in the inner loop.
;;;117          inline const Type* Pointer(const Point<s16> &point) const;
;;;118          inline Type* Pointer(const Point<s16> &point);
;;;119    
;;;120          // Get the ith element, like Matlab's 1D indexing of a 2D array.
;;;121          // For example, the 5th element of Arrays of size (1,6) and (6,1) is the same;
;;;122          const Type& Element(const s32 elementIndex) const;
;;;123          Type& Element(const s32 elementIndex);
;;;124    
;;;125          // Return a slice accessor for this array, like the Matlab expression "array(1:5, 2:3:5)"
;;;126          //
;;;127          // NOTE:
;;;128          // If min or max is less than 0, it is equivalent to (end+value). For example, "Array(0,-1,3,5)"
;;;129          // is the same as "Array(0,arrayHeight-1,3,5)"
;;;130          ArraySlice<Type> operator() ();
;;;131          ArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;132          ArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX);
;;;133          ArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX);
;;;134          ConstArraySlice<Type> operator() () const;
;;;135          ConstArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const;
;;;136          ConstArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const;
;;;137          ConstArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const;
;;;138    
;;;139          // ArraySlice Transpose doesn't modify the data, it just sets an "isTransposed" flag.
;;;140          // Anything that uses ArraySliceExpression respects this flag. This doesn't include things
;;;141          // like Matrix::Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out) for example.
;;;142          ConstArraySliceExpression<Type> Transpose() const;
;;;143    
;;;144    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;145          // Copies the OpenCV Mat. If needed, it converts from color to grayscale by averaging the color channels.
;;;146          s32 Set(const cv::Mat_<Type> &in);
;;;147    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;148    
;;;149          // Use the simple OpenCV gui to display this array as an image
;;;150          // Does nothing is OpenCV is not available
;;;151          void Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues=false, const bool fitImageToWindow=false) const;
;;;152    
;;;153          // Print out the contents of this Array
;;;154          //
;;;155          // NOTE:
;;;156          // * If the min X or Y is less than zero, it will be treated as zero
;;;157          // * If the max X or Y is greater than the size of the array minus one, it will be treated as
;;;158          //   the size of the array minus one
;;;159          Result Print(const char * const variableName = "Array", const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;160          Result PrintAlternate(const char * const variableName = "Array", const s32 version=2, const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;161    
;;;162          // Checks if this array is equal to another array, up to some allowable
;;;163          // per-element varation, epsilon. If the arrays are not the same size,
;;;164          // false is returned.
;;;165          bool IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const;
;;;166    
;;;167          // Checks the basic parameters of this Array, and if it is allocated.
;;;168          bool IsValid() const;
;;;169    
;;;170          // Resize will use MemoryStack::Reallocate() to change the Array's size. It only works if this
;;;171          // Array was the last thing allocated. The reallocated memory will not be cleared
;;;172          //
;;;173          // WARNING:
;;;174          // This will not update any references to the memory, you must update all references manually.
;;;175          Result Resize(const s32 numRows, const s32 numCols, MemoryStack &memory);
;;;176    
;;;177          // Set every element in the Array to zero, including the stride padding.
;;;178          // Returns the number of bytes set to zero
;;;179          s32 SetZero();
;;;180    
;;;181          // Set every element in the Array to this value
;;;182          // Returns the number of values set
;;;183          s32 Set(const Type value);
;;;184    
;;;185          // Elementwise copies the input Array into this array. No memory is allocated.
;;;186          s32 Set(const Array<Type> &in);
;;;187    
;;;188          // Copy values to this Array.
;;;189          // If the input array does not contain enough elements, the remainder of this Array will be filled with zeros.
;;;190          // Returns the number of values set (not counting extra zeros)
;;;191          s32 Set(const Type * const values, const s32 numValues);
;;;192    
;;;193          // Read in the input, then cast it to this object's type
;;;194          //
;;;195          // WARNING:
;;;196          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;197          template<typename InType> s32 SetCast(const Array<InType> &in);
;;;198          template<typename InType> s32 SetCast(const InType * const values, const s32 numValues);
;;;199    
;;;200          // This is a shallow copy. There's no reference counting. Updating the data of one array will
;;;201          // update that of others (because they point to the same location in memory).
;;;202          // However, Resizing or other operations on one array won't update the others.
;;;203          Array& operator= (const Array & rightHandSide);
;;;204    
;;;205          // Similar to Matlabs size(matrix, dimension), and dimension is in {0,1}
;;;206          s32 get_size(s32 dimension) const;
;;;207    
;;;208          // Get the stride, which is the number of bytes between an element at (n,m) and an element at (n+1,m)
;;;209          s32 get_stride() const;
;;;210    
;;;211          // just size[0] * size[1]
;;;212          s32 get_numElements() const;
;;;213    
;;;214          // Return the flags that were used when this object was constructed.
;;;215          Flags::Buffer get_flags() const;
;;;216    
;;;217          // Equivalent to Pointer(0,0)
;;;218          //
;;;219          // These are for very low-level access to the buffers. Probably you want to be using one of
;;;220          // the Pointer() accessor methods instead of these.
;;;221          void* get_buffer();
;;;222          const void* get_buffer() const;
;;;223    
;;;224        protected:
;;;225          static const s32 HEADER_LENGTH = 8;
;;;226          static const s32 FOOTER_LENGTH = 8;
;;;227    
;;;228          s32 size[2];
;;;229          s32 stride;
;;;230          Flags::Buffer flags;
;;;231    
;;;232          Type * data;
;;;233    
;;;234          // Basic allocation method
;;;235          void* AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate);
;;;236    
;;;237          // Performs checks and sets appropriate parameters for this object
;;;238          Result InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags);
;;;239    
;;;240          // Set all the buffers and sizes to zero, to signal an invalid array
;;;241          void InvalidateArray();
;;;242    
;;;243          // If this object's Type is a basic type, this method prints out this object.
;;;244          Result PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;245    
;;;246          // If this object's Type is a string, this method prints out this object.
;;;247          Result PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;248        }; // class Array
;;;249    
;;;250        // #pragma mark --- FixedPointArray Class Declaration ---
;;;251    
;;;252        template<typename Type> class FixedPointArray : public Array<Type>
;;;253        {
;;;254        public:
;;;255          FixedPointArray();
;;;256    
;;;257          // Same as Array() constructor
;;;258          // This is the preferred method for constructing an FixedPointArray
;;;259          FixedPointArray(const s32 numRows, const s32 numCols, const s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;260    
;;;261          // Same as Array() constructor
;;;262          // This is the advanced method for constructing an FixedPointArray
;;;263          FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;264    
;;;265          s32 get_numFractionalBits() const;
;;;266    
;;;267        protected:
;;;268          s32 numFractionalBits;
;;;269        };
;;;270    
;;;271        // If you don't know the type of the Array you're loading, use this function directly, then cast it based on the read parameters
;;;272        Array<u8> LoadBinaryArray_UnknownType(
;;;273          const char * filename,
;;;274          MemoryStack *scratch,
;;;275          MemoryStack *memory,
;;;276          void * allocatedBuffer,
;;;277          const s32 allocatedBufferLength,
;;;278          u16  &basicType_sizeOfType,
;;;279          bool &basicType_isBasicType,
;;;280          bool &basicType_isInteger,
;;;281          bool &basicType_isSigned,
;;;282          bool &basicType_isFloat,
;;;283          bool &basicType_isString
;;;284          );
;;;285    
;;;286    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;287        // Returns a cv::Mat that mirrors the data in the input Array.
;;;288        // WARNING: If you copy the cv::Mat or assign it incorrectly, it will no longer mirror the input Array
;;;289        // WARNING: This const_casts the input array, so you can unsafely modify it via the output cv::Mat
;;;290        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out);
;;;291    #endif
;;;292      } // namespace Embedded
;;;293    } //namespace Anki
;;;294    
;;;295    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_DECLARATIONS_H_
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;2      File: arraySlices_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      An array slice is a sub-array of an Array object.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Class Declarations ---
;;;23     
;;;24         template<typename Type> class ConstArraySlice;
;;;25         template<typename Type> class ArraySlice;
;;;26         template<typename Type> class ConstArraySliceExpression;
;;;27     
;;;28         // An ArraySlice is a simple indexing wrapper on top of an Array. The slice of an Array could be
;;;29         // a sub-rectangle of an array and/or skip every n-th element.
;;;30         //
;;;31         // For example, Array(0,3,-1,1,2,4) is the same as Matlab's array(1:3:end, 2:2:5).
;;;32         // (The Array indexing starts from zero vs Matlab's one, hence the different numbers).
;;;33         //
;;;34         // TODO: support non-int indexes
;;;35         // TODO: is there a better way of doing this than a completely different class, different only
;;;36         //       by const?
;;;37         template<typename Type> class ConstArraySlice
;;;38         {
;;;39         public:
;;;40           ConstArraySlice();
;;;41     
;;;42           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;43           ConstArraySlice(const Array<Type> &array);
;;;44     
;;;45           // It's probably easier to call array.operator() than this constructor directly
;;;46           ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;47     
;;;48           // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;49           ConstArraySliceExpression<Type> Transpose() const;
;;;50     
;;;51           bool IsValid() const;
;;;52     
;;;53           const LinearSequence<s32>& get_ySlice() const;
;;;54     
;;;55           const LinearSequence<s32>& get_xSlice() const;
;;;56     
;;;57           // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;58           // don't support the full ArraySlice type, and should be used with caution.
;;;59           const Array<Type>& get_array() const;
;;;60     
;;;61         protected:
;;;62           LinearSequence<s32> ySlice;
;;;63           LinearSequence<s32> xSlice;
;;;64     
;;;65           Array<Type> array;
;;;66     
;;;67           // For speed, this is a direct pointer to the Array's protected data
;;;68           const Type * constArrayData;
;;;69         }; // template<typename Type> class ArraySlice
;;;70     
;;;71         // A non-const version of ConstArraySlice, see ConstArraySlice for details
;;;72         //
;;;73         // WARNING: A "const ArraySlice" doesn't have a const Array. Only ConstArraySlice has a const
;;;74         //          Array. This allows for implicit conversion to non-const function parameters.
;;;75         template<typename Type> class ArraySlice : public ConstArraySlice<Type>
;;;76         {
;;;77         public:
;;;78           ArraySlice();
;;;79     
;;;80           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;81           // The Array parameter is not a reference, to allow for implicit conversion
;;;82           ArraySlice(Array<Type> array);
;;;83     
;;;84           // It's probably easier to call array.operator() than this constructor directly
;;;85           // The Array parameter is not a reference, to allow for implicit conversion
;;;86           ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;87     
;;;88           // If automaticTranspose==true, then you can set a MxN slice with a NxM input.
;;;89           // Matlab allows this for vectors, though this method will also work for
;;;90           // arbitrary-sized arrays.
;;;91           s32 Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
;;;92     
;;;93           // Explicitly evaluate the input LinearSequence into this ArraySlice
;;;94           s32 Set(const LinearSequence<Type> &input);
;;;95     
;;;96           // Set all values of this slice to the given value.
;;;97           //
;;;98           // For example, "array(0,-1,1,4).Set(5);" is the same as
;;;99           // Matlab's "array(1:end, 2:5) = 5;"
;;;100          s32 Set(const Type value);
;;;101    
;;;102          // Copy values to this ArraySlice.
;;;103          // numValues must be equal to the number of values in this slice
;;;104          // Returns the number of values set
;;;105          s32 Set(const Type * const values, const s32 numValues);
;;;106    
;;;107          // Read in the input, then cast it to this object's type
;;;108          //
;;;109          // WARNING:
;;;110          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;111          template<typename InType> s32 SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
;;;112          //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;113    
;;;114          // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;115          // don't support the full ArraySlice type, and should be used with caution.
;;;116          Array<Type>& get_array();
;;;117    
;;;118        protected:
;;;119    
;;;120          // For speed, this is a direct pointer to the Array's protected data
;;;121          Type * arrayData;
;;;122        }; // template<typename Type> class ArraySlice
;;;123    
;;;124        // An ConstArraySliceExpression is like a ConstArraySlice, but can also be transposed
;;;125        // It may have other abilities in the future, but will probably always be const
;;;126        template<typename Type> class ConstArraySliceExpression : public ConstArraySlice<Type>
;;;127        {
;;;128        public:
;;;129          ConstArraySliceExpression();
;;;130    
;;;131          ConstArraySliceExpression(const Array<Type> input, bool isTransposed=false);
;;;132    
;;;133          ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed=false);
;;;134    
;;;135          ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed=false);
;;;136    
;;;137          // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;138          // This object isn't modified, but the returned object is.
;;;139          ConstArraySliceExpression<Type> Transpose() const;
;;;140    
;;;141          bool get_isTransposed() const;
;;;142    
;;;143        protected:
;;;144          bool isTransposed;
;;;145        };
;;;146    
;;;147        // To simplify the creation of kernels using an ArraySlice, and to aid the compiler optimizer,
;;;148        // an ArraySliceLimits can be initialized at the beginning of the function, then used as the
;;;149        // limits for the inner loops.
;;;150    
;;;151        // The suffix of in# and out# refer to the number of input and output matrices.
;;;152        // If output == 0, then the output is a scalar.
;;;153    
;;;154        template<typename Type> class ArraySliceSimpleLimits
;;;155        {
;;;156        public:
;;;157          Type xStart;
;;;158          Type xIncrement;
;;;159          s32  xSize;
;;;160    
;;;161          Type yStart;
;;;162          Type yIncrement;
;;;163          s32  ySize;
;;;164    
;;;165          ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;166        };
;;;167    
;;;168        // In1 and out0 is a special, ultra-simple case, for one matrix input and a scalar output
;;;169        template<typename Type> class ArraySliceLimits_in1_out0
;;;170        {
;;;171        public:
;;;172          // Was this ArraySliceLimits initialized?
;;;173          bool isValid;
;;;174    
;;;175          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;176    
;;;177          ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;178        };
;;;179    
;;;180        // One input, one output
;;;181        template<typename Type> class ArraySliceLimits_in1_out1
;;;182        {
;;;183        public:
;;;184          // Was this ArraySliceLimits initialized?
;;;185          bool isValid;
;;;186    
;;;187          // Can a simple (non-transposed) iteration be performed?
;;;188          bool isSimpleIteration;
;;;189    
;;;190          // These are the current values for the coordinates in the input and output images
;;;191          s32 out1Y;
;;;192          s32 out1X;
;;;193          s32 in1Y;
;;;194          s32 in1X;
;;;195    
;;;196          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;197          s32 ySize;
;;;198          s32 xSize;
;;;199    
;;;200          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;201          // incremented every iteration of the inner loop
;;;202          s32 out1_xInnerIncrement;
;;;203          s32 in1_xInnerIncrement;
;;;204          s32 in1_yInnerIncrement;
;;;205    
;;;206          ArraySliceLimits_in1_out1(
;;;207            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;208            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;209    
;;;210          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;211          inline void OuterIncrementTop();
;;;212    
;;;213          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;214          inline void OuterIncrementBottom();
;;;215    
;;;216        protected:
;;;217          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;218    
;;;219          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;220          bool in1_isTransposed;
;;;221        };
;;;222    
;;;223        // Two inputs, one output
;;;224        template<typename Type> class ArraySliceLimits_in2_out1
;;;225        {
;;;226        public:
;;;227          // Was this ArraySliceLimits initialized?
;;;228          bool isValid;
;;;229    
;;;230          // Can a simple (non-transposed) iteration be performed?
;;;231          bool isSimpleIteration;
;;;232    
;;;233          // These are the current values for the coordinates in the input and output images
;;;234          s32 out1Y;
;;;235          s32 out1X;
;;;236          s32 in1Y;
;;;237          s32 in1X;
;;;238          s32 in2Y;
;;;239          s32 in2X;
;;;240    
;;;241          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;242          s32 ySize;
;;;243          s32 xSize;
;;;244    
;;;245          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;246          // incremented every iteration of the inner loop
;;;247          s32 out1_xInnerIncrement;
;;;248          s32 in1_xInnerIncrement;
;;;249          s32 in1_yInnerIncrement;
;;;250          s32 in2_xInnerIncrement;
;;;251          s32 in2_yInnerIncrement;
;;;252    
;;;253          ArraySliceLimits_in2_out1(
;;;254            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;255            const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed,
;;;256            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;257    
;;;258          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;259          inline void OuterIncrementTop();
;;;260    
;;;261          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;262          inline void OuterIncrementBottom();
;;;263    
;;;264        protected:
;;;265          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;266    
;;;267          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;268          bool in1_isTransposed;
;;;269    
;;;270          ArraySliceSimpleLimits<Type> rawIn2Limits;
;;;271          bool in2_isTransposed;
;;;272        };
;;;273      } // namespace Embedded
;;;274    } // namespace Anki
;;;275    
;;;276    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         class SerializedBuffer;
;;;24     
;;;25         // A FixedLengthList is a list with a fixed maximum size, which is allocated at construction.
;;;26         template<typename Type> class FixedLengthList : public ArraySlice<Type>
;;;27         {
;;;28         public:
;;;29           FixedLengthList();
;;;30     
;;;31           // Constructor for a FixedLengthList, pointing to user-allocated data.
;;;32           FixedLengthList(s32 maximumSize, void * data, s32 dataLength, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;33     
;;;34           // Constructor for a FixedLengthList, pointing to user-allocated MemoryStack
;;;35           FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;36     
;;;37           bool IsValid() const;
;;;38     
;;;39           // Resize will use MemoryStack::Reallocate() to change the FixedLengthList's size. It only works if this
;;;40           // FixedLengthList was the last thing allocated. The reallocated memory will not be cleared
;;;41           //
;;;42           // WARNING:
;;;43           // This will not update any references to the memory, you must update all references manually.
;;;44           Result Resize(s32 maximumSize, MemoryStack &memory);
;;;45     
;;;46           Result PushBack(const Type &value);
;;;47     
;;;48           // Will act as a normal pop, except when the list is empty. Then subsequent
;;;49           // calls will keep returning the first value in the list.
;;;50           Type PopBack();
;;;51     
;;;52           // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
;;;53           inline void Clear();
;;;54     
;;;55           // Does this ever need to be declared explicitly?
;;;56           //FixedLengthList& operator= (const FixedLengthList & rightHandSide);
;;;57     
;;;58           // Pointer to the data, at a given location
;;;59           inline Type* Pointer(const s32 index);
;;;60           inline const Type* Pointer(const s32 index) const;
;;;61     
;;;62           // Use this operator for normal C-style vector indexing. For example, "list[5] = 6;" will set
;;;63           // the element in the fifth row and first column to 6. This is the same as "*list.Pointer(5) =
;;;64           // 6;"
;;;65           //
;;;66           // NOTE:
;;;67           // Using this in a inner loop may be less efficient than using an explicit pointer with a
;;;68           // restrict keyword (Though the runtime cost isn't nearly as large as the [] operator for the
;;;69           // Array class). For speeding up performance-critical inner loops, use something like: "Type *
;;;70           // restrict pList = list.Pointer(0);" outside the inner loop, then index
;;;71           // pList in the inner loop.
;;;72           inline const Type& operator[](const s32 index) const;
;;;73           inline Type& operator[](const s32 index);
;;;74     
;;;75           // Print out the contents of this FixedLengthList
;;;76           Result Print(const char * const variableName = "FixedLengthList", const s32 minIndex = 0, const s32 maxIndex = 0x7FFFFFE) const;
;;;77     
;;;78           // Set every element in the Array to zero, including the stride padding, but not including the optional fill patterns (if they exist)
;;;79           // Returns the number of bytes set to zero
;;;80           inline s32 SetZero();
;;;81     
;;;82           // Read in the input, then cast it to this object's type
;;;83           //
;;;84           // WARNING:
;;;85           // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;86           template<typename InType> s32 SetCast(const FixedLengthList<InType> &input, bool automaticTranspose=true);
;;;87           //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;88     
;;;89           // The maximum size is set at object construction
;;;90           inline s32 get_maximumSize() const;
;;;91     
;;;92           // The current size changes as the FixedLengthList is used
;;;93           inline s32 get_size() const;
;;;94     
;;;95           // Attempt to set the size to newSize. Returns the value that was actually set.
;;;96           s32 set_size(s32 newSize);
;;;97     
;;;98         protected:
;;;99           // TODO: make less hacky
;;;100          friend class SerializedBuffer;
;;;101        }; // class FixedLengthList
;;;102      } // namespace Embedded
;;;103    } //namespace Anki
;;;104    
;;;105    #endif // _ANKICORETECHEMBEDDED_COMMON_FIXEDLENGTHLIST_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;1      /**
;;;2      File: utilities.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of utilities_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;14     
;;;15     #include "anki/common/robot/utilities_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;17     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;2      * File: trig_fast.h
;;;3      *
;;;4      * Author: Kevin Yoon
;;;5      * Created: 22-OCT-2012
;;;6      *
;;;7      * Some trig functions to supplement incomplete math libraries on embedded targets.
;;;8      * Error of all functions is less than +/- 0.01.
;;;9      * For bettery accuracy, lookup tables should be regenerated with u16.
;;;10     *
;;;11     **/
;;;12     #ifndef _TRIG_FAST_H
;;;13     #define _TRIG_FAST_H
;;;14     
;;;15     // When USE_SMALL_LUT defined, a smaller lookup table is used to conserve space.
;;;16     // USE_INTERPOLATION is also automatically defined, since without it answers are probably too wrong to be useful.
;;;17     // If USE_SMALL_LUT is not defined, a large LUT is used.
;;;18     //#define USE_SMALL_LUT
;;;19     
;;;20     // When defined, interpolates between lookup values for higher accuracy.
;;;21     #define USE_INTERPOLATION
;;;22     
;;;23     // Arctangent function based on lookup table
;;;24     // returns answer in radians
;;;25     float atan_fast(float x);
;;;26     
;;;27     // Arcsine function based on lookup table
;;;28     // returns answer in radians
;;;29     float asin_fast(float x);
;;;30     
;;;31     // Arctangent function which uses atan_fast
;;;32     // returns answer in radians
;;;33     float atan2_fast(float y, float x);
;;;34     
;;;35     // Arctangent function which uses asin from math.h
;;;36     // Useful on embedded systems that don't include atan2 in math.h
;;;37     // More accurate than atan2_fast.
;;;38     // Nothing particularly fast about this implementation.
;;;39     // returns answer in radians
;;;40     float atan2_acc(float y, float x);
;;;41     
;;;42     #endif
;;;19     
;;;20     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;21     #include "opencv2/core/core.hpp"
;;;22     #endif
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         //template<typename Type> inline Type RoundUp(const Type number, const Type multiple)
;;;29     
;;;30         // void* and size_t is a special case, good for aligning pointers
;;;31         inline const void* RoundUp(const void* number, const size_t multiple)
;;;32         {
;;;33           const size_t numberT = reinterpret_cast<size_t>(number);
;;;34           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;35         }
;;;36     
;;;37         inline void* RoundUp(void* number, const size_t multiple)
;;;38         {
;;;39           const size_t numberT = reinterpret_cast<size_t>(number);
;;;40           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;41         }
;;;42     
;;;43         template<> inline u32 RoundUp(const u32 number, const u32 multiple)
;;;44         {
;;;45           return (number + (multiple-1)) & ~(multiple-1);
;;;46         }
;;;47     
;;;48         template<> inline s32 RoundUp(const s32 number, const s32 multiple)
;;;49         {
;;;50           if(number <= 0) {
;;;51             return multiple*( number/multiple );
;;;52           } else {
;;;53             return multiple*( (number-1)/multiple + 1 );
;;;54           }
;;;55         }
;;;56     
;;;57     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;58         template<> inline unsigned long RoundUp(const unsigned long number, const unsigned long multiple)
;;;59         {
;;;60           return (number + (multiple-1)) & ~(multiple-1);
;;;61         }
;;;62     #endif
;;;63     
;;;64         template<> inline u32 RoundDown(const u32 number, const u32 multiple)
;;;65         {
;;;66           return multiple * (number/multiple);
;;;67         }
;;;68     
;;;69         template<> inline s32 RoundDown(const s32 number, const s32 multiple)
;;;70         {
;;;71           if(number < 0) {
;;;72             return multiple * ((number-multiple+1) / multiple);
;;;73           } else {
;;;74             return multiple * (number/multiple);
;;;75           }
;;;76         }
;;;77     
;;;78     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;79         template<> inline unsigned long RoundDown(const unsigned long number, const unsigned long multiple)
;;;80         {
;;;81           return multiple * (number/multiple);
;;;82         }
;;;83     #endif
;;;84     
;;;85         template<typename Type> Type ApproximateExp(const Type exponent, const s32 numTerms)
;;;86         {
;;;87           AnkiAssert(numTerms > 2);
;;;88     
;;;89           const Type exponentAbs = ABS(exponent);
;;;90     
;;;91           Type sum = static_cast<Type>(1) + exponentAbs;
;;;92     
;;;93           Type numerator = static_cast<Type>(exponentAbs);
;;;94           Type denominator = static_cast<Type>(1);
;;;95           for(s32 i=2; i<=numTerms; i++) {
;;;96             numerator *= exponentAbs;
;;;97             denominator *= i;
;;;98     
;;;99             sum += numerator / denominator;
;;;100          }
;;;101    
;;;102          if(exponent < 0) {
;;;103            sum = static_cast<Type>(1) / sum;
;;;104          }
;;;105    
;;;106          return sum;
;;;107        }
;;;108    
;;;109        template<typename Type> void Swap(Type &a, Type &b)
;;;110        {
;;;111          const Type tmp = a;
;;;112          a = b;
;;;113          b = tmp;
;;;114        } // template<typename Type> Swap(Type a, Type b)
;;;115    
;;;116        template<typename Type> u32 BinaryStringToUnsignedNumber(const FixedLengthList<Type> &bits, bool firstBitIsLow)
;;;117        {
;;;118          u32 number = 0;
;;;119    
;;;120          const s32 numBits = bits.get_size();
;;;121    
;;;122          for(s32 bit=0; bit<numBits; bit++) {
;;;123            if(firstBitIsLow) {
;;;124              if(bit == 0) {
;;;125                number += bits[bit];
;;;126              } else {
;;;127                number += bits[bit] << bit;
;;;128              }
;;;129            } else {
;;;130              if(bit == (numBits-1)) {
;;;131                number += bits[bit];
;;;132              } else {
;;;133                number += bits[bit] << (numBits - bit - 1);
;;;134              }
;;;135            }
;;;136          }
;;;137    
;;;138          return number;
;;;139        }
;;;140    
;;;141        template<typename Type> Type Determinant2x2(const Type a, const Type b, const Type c, const Type d)
;;;142        {
;;;143          return a*d - b*c;
;;;144        }
;;;145    
;;;146        template<typename Type> Type Determinant3x3(const Type a, const Type b, const Type c, const Type d, const Type e, const Type f, const Type g, const Type h, const Type i)
;;;147        {
;;;148          return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
;;;149        }
;;;150    
;;;151        template<typename Type> void Invert3x3(Type &a, Type &b, Type &c, Type &d, Type &e, Type &f, Type &g, Type &h, Type &i)
;;;152        {
;;;153          const Type determinant = Determinant3x3(a,b,c,d,e,f,g,h,i);
;;;154          const Type determinantInverse = static_cast<Type>(1) / determinant;
;;;155    
;;;156          const Type A =  (e*i - f*h);
;;;157          const Type B = -(d*i - f*g);
;;;158          const Type C =  (d*h - e*g);
;;;159          const Type D = -(b*i - c*h);
;;;160          const Type E =  (a*i - c*g);
;;;161          const Type F = -(a*h - b*g);
;;;162          const Type G =  (b*f - c*e);
;;;163          const Type H = -(a*f - c*d);
;;;164          const Type I =  (a*e - b*d);
;;;165    
;;;166          a = A * determinantInverse;
;;;167          b = D * determinantInverse;
;;;168          c = G * determinantInverse;
;;;169          d = B * determinantInverse;
;;;170          e = E * determinantInverse;
;;;171          f = H * determinantInverse;
;;;172          g = C * determinantInverse;
;;;173          h = F * determinantInverse;
;;;174          i = I * determinantInverse;
;;;175        }
;;;176    
;;;177        template<typename Type> void Cart2Pol(const Type x, const Type y, Type &rho, Type &theta)
;;;178        {
;;;179          if (x==0 && y==0) {
;;;180            theta = 0;
;;;181            rho = 0;
;;;182          } else {
;;;183            theta = atan2f(y, x);
;;;184            rho = sqrtf(x*x + y*y);
;;;185          }
;;;186        }
;;;187    
;;;188        template<typename Type> void Pol2Cart(const Type rho, const Type theta, Type &x, Type &y)
;;;189        {
;;;190          x = rho * cosf(theta);
;;;191          y = rho * sinf(theta);
;;;192        }
;;;193    
;;;194        inline s32 FloorS32(f32 x)
;;;195        {
;;;196          return static_cast<s32>(floorf(x));
;;;197        }
;;;198    
;;;199        inline s32 CeilS32(f32 x)
;;;200        {
;;;201          return static_cast<s32>(ceilf(x));
;;;202        }
;;;203    
;;;204    #if !defined(__EDG__)
;;;205        // Some platforms may not round to zero correctly, so do the function calls
;;;206        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(floorf(v + 0.5f)) : 0; }
;;;207        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(floorf(v + 0.5f)) : 0; }
;;;208        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(floorf(v + 0.5f)) : static_cast<s32>(ceilf(v - 0.5f)); }
;;;209        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(floorf(v + 0.5f)) : static_cast<s64>(ceilf(v - 0.5f)); }
;;;210        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;211        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;212    
;;;213        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(floor(v + 0.5)) : 0; }
;;;214        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(floor(v + 0.5)) : 0; }
;;;215        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(floor(v + 0.5)) : static_cast<s32>(ceil(v - 0.5)); }
;;;216        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(floor(v + 0.5)) : static_cast<s64>(ceil(v - 0.5)); }
;;;217        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;218        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;219    #else
;;;220        // The M4 rounds to zero correctly, without the function calls
;;;221        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(v + 0.5f) : 0; }
;;;222        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(v + 0.5f) : 0; }
;;;223        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(v + 0.5f) : static_cast<s32>(v - 0.5f); }
;;;224        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(v + 0.5f) : static_cast<s64>(v - 0.5f); }
;;;225        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;226        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;227    
;;;228        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(v + 0.5) : 0; }
;;;229        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(v + 0.5) : 0; }
;;;230        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(v + 0.5) : static_cast<s32>(v - 0.5); }
;;;231        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(v + 0.5) : static_cast<s64>(v - 0.5); }
;;;232        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;233        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;234    #endif
;;;235    
;;;236        // Most cases of RoundIfInteger are from int-to-int or float-to-float, so just do a normal cast
;;;237        template<typename Type> inline Type RoundIfInteger(const u8  v) { return static_cast<Type>(v); }
;;;238        template<typename Type> inline Type RoundIfInteger(const s8  v) { return static_cast<Type>(v); }
;;;239        template<typename Type> inline Type RoundIfInteger(const u16 v) { return static_cast<Type>(v); }
;;;240        template<typename Type> inline Type RoundIfInteger(const s16 v) { return static_cast<Type>(v); }
;;;241        template<typename Type> inline Type RoundIfInteger(const u32 v) { return static_cast<Type>(v); }
;;;242        template<typename Type> inline Type RoundIfInteger(const s32 v) { return static_cast<Type>(v); }
;;;243        template<typename Type> inline Type RoundIfInteger(const u64 v) { return static_cast<Type>(v); }
;;;244        template<typename Type> inline Type RoundIfInteger(const s64 v) { return static_cast<Type>(v); }
;;;245        template<typename Type> inline Type RoundIfInteger(const f32 v) { return static_cast<Type>(v); }
;;;246        template<typename Type> inline Type RoundIfInteger(const f64 v) { return static_cast<Type>(v); }
;;;247    
;;;248        // Specialize for cases with float-to-int
;;;249        template<> inline u8  RoundIfInteger(const f32 v) { return static_cast<u8> (Round<s32>(v)); }
;;;250        template<> inline s8  RoundIfInteger(const f32 v) { return static_cast<s8> (Round<s32>(v)); }
;;;251        template<> inline u16 RoundIfInteger(const f32 v) { return static_cast<u16>(Round<s32>(v)); }
;;;252        template<> inline s16 RoundIfInteger(const f32 v) { return static_cast<s16>(Round<s32>(v)); }
;;;253        template<> inline u32 RoundIfInteger(const f32 v) { return static_cast<u32>(Round<u32>(v)); }
;;;254        template<> inline s32 RoundIfInteger(const f32 v) { return static_cast<s32>(Round<s32>(v)); }
;;;255        template<> inline u64 RoundIfInteger(const f32 v) { return static_cast<u64>(Round<u64>(v)); }
;;;256        template<> inline s64 RoundIfInteger(const f32 v) { return static_cast<s64>(Round<s64>(v)); }
;;;257    
;;;258        template<> inline u8  RoundIfInteger(const f64 v) { return static_cast<u8> (Round<s32>(v)); }
;;;259        template<> inline s8  RoundIfInteger(const f64 v) { return static_cast<s8> (Round<s32>(v)); }
;;;260        template<> inline u16 RoundIfInteger(const f64 v) { return static_cast<u16>(Round<s32>(v)); }
;;;261        template<> inline s16 RoundIfInteger(const f64 v) { return static_cast<s16>(Round<s32>(v)); }
;;;262        template<> inline u32 RoundIfInteger(const f64 v) { return static_cast<u32>(Round<u32>(v)); }
;;;263        template<> inline s32 RoundIfInteger(const f64 v) { return static_cast<s32>(Round<s32>(v)); }
;;;264        template<> inline u64 RoundIfInteger(const f64 v) { return static_cast<u64>(Round<u64>(v)); }
;;;265        template<> inline s64 RoundIfInteger(const f64 v) { return static_cast<s64>(Round<s64>(v)); }
;;;266    
;;;267        // Floats and complex data types aren't specialized
;;;268        template<typename Type> inline Type saturate_cast(const u8  v) { return static_cast<Type>(v); }
;;;269        template<typename Type> inline Type saturate_cast(const s8  v) { return static_cast<Type>(v); }
;;;270        template<typename Type> inline Type saturate_cast(const u16 v) { return static_cast<Type>(v); }
;;;271        template<typename Type> inline Type saturate_cast(const s16 v) { return static_cast<Type>(v); }
;;;272        template<typename Type> inline Type saturate_cast(const u32 v) { return static_cast<Type>(v); }
;;;273        template<typename Type> inline Type saturate_cast(const s32 v) { return static_cast<Type>(v); }
;;;274        template<typename Type> inline Type saturate_cast(const u64 v) { return static_cast<Type>(v); }
;;;275        template<typename Type> inline Type saturate_cast(const s64 v) { return static_cast<Type>(v); }
;;;276        template<typename Type> inline Type saturate_cast(const f32 v) { return static_cast<Type>(v); }
;;;277        template<typename Type> inline Type saturate_cast(const f64 v) { return static_cast<Type>(v); }
;;;278    
;;;279        // Most saturate_cast calls are explicitly specialized
;;;280        template<> inline u8  saturate_cast<u8> (const u8  v) { return v; }
;;;281        template<> inline u8  saturate_cast<u8> (const u16 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;282        template<> inline u8  saturate_cast<u8> (const u32 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;283        template<> inline u8  saturate_cast<u8> (const u64 v) { return (u8)             MIN((u64)u8_MAX, (u64)v); }
;;;284        template<> inline u8  saturate_cast<u8> (const s8  v) { return (u8)                              MAX((s32)0, (s32)v);  }
;;;285        template<> inline u8  saturate_cast<u8> (const s16 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;286        template<> inline u8  saturate_cast<u8> (const s32 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;287        template<> inline u8  saturate_cast<u8> (const s64 v) { return (u8)             MIN((s64)u8_MAX, MAX((s64)0, (s64)v)); }
;;;288        template<> inline u8  saturate_cast<u8> (const f32 v) { return (u8) Round<s32>( MIN((f32)u8_MAX, MAX((f32)0, (f32)v)) ); }
;;;289        template<> inline u8  saturate_cast<u8> (const f64 v) { return (u8) Round<s32>( MIN((f64)u8_MAX, MAX((f64)0, (f64)v)) ); }
;;;290    
;;;291        template<> inline s8  saturate_cast<s8> (const u8  v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;292        template<> inline s8  saturate_cast<s8> (const u16 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;293        template<> inline s8  saturate_cast<s8> (const u32 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;294        template<> inline s8  saturate_cast<s8> (const u64 v) { return (s8)             MIN((u64)s8_MAX, (u64)v); }
;;;295        template<> inline s8  saturate_cast<s8> (const s8  v) { return v; }
;;;296        template<> inline s8  saturate_cast<s8> (const s16 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;297        template<> inline s8  saturate_cast<s8> (const s32 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;298        template<> inline s8  saturate_cast<s8> (const s64 v) { return (s8)             MIN((s64)s8_MAX, MAX((s64)s8_MIN, (s64)v)); }
;;;299        template<> inline s8  saturate_cast<s8> (const f32 v) { return (s8) Round<s32>( MIN((f32)s8_MAX, MAX((f32)s8_MIN, (f32)v)) ); }
;;;300        template<> inline s8  saturate_cast<s8> (const f64 v) { return (s8) Round<s32>( MIN((f64)s8_MAX, MAX((f64)s8_MIN, (f64)v)) ); }
;;;301    
;;;302        template<> inline u16 saturate_cast<u16>(const u8  v) { return v; }
;;;303        template<> inline u16 saturate_cast<u16>(const u16 v) { return v; }
;;;304        template<> inline u16 saturate_cast<u16>(const u32 v) { return (u16)             MIN((u32)u16_MAX, (u32)v); }
;;;305        template<> inline u16 saturate_cast<u16>(const u64 v) { return (u16)             MIN((u64)u16_MAX, (u64)v); }
;;;306        template<> inline u16 saturate_cast<u16>(const s8  v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;307        template<> inline u16 saturate_cast<u16>(const s16 v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;308        template<> inline u16 saturate_cast<u16>(const s32 v) { return (u16)             MIN((s32)u16_MAX, MAX((s32)0, (s32)v)); }
;;;309        template<> inline u16 saturate_cast<u16>(const s64 v) { return (u16)             MIN((s64)u16_MAX, MAX((s64)0, (s64)v)); }
;;;310        template<> inline u16 saturate_cast<u16>(const f32 v) { return (u16) Round<s32>( MIN((f32)u16_MAX, MAX((f32)0, (f32)v)) ); }
;;;311        template<> inline u16 saturate_cast<u16>(const f64 v) { return (u16) Round<s32>( MIN((f64)u16_MAX, MAX((f64)0, (f64)v)) ); }
;;;312    
;;;313        template<> inline s16 saturate_cast<s16>(const u8  v) { return v; }
;;;314        template<> inline s16 saturate_cast<s16>(const u16 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;315        template<> inline s16 saturate_cast<s16>(const u32 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;316        template<> inline s16 saturate_cast<s16>(const u64 v) { return (s16)             MIN((u64)s16_MAX, (u64)v); }
;;;317        template<> inline s16 saturate_cast<s16>(const s8  v) { return v; }
;;;318        template<> inline s16 saturate_cast<s16>(const s16 v) { return v; }
;;;319        template<> inline s16 saturate_cast<s16>(const s32 v) { return (s16)             MIN((s32)s16_MAX, MAX((s32)s16_MIN, (s32)v)); }
;;;320        template<> inline s16 saturate_cast<s16>(const s64 v) { return (s16)             MIN((s64)s16_MAX, MAX((s64)s16_MIN, (s64)v)); }
;;;321        template<> inline s16 saturate_cast<s16>(const f32 v) { return (s16) Round<s32>( MIN((f32)s16_MAX, MAX((f32)s16_MIN, (f32)v)) ); }
;;;322        template<> inline s16 saturate_cast<s16>(const f64 v) { return (s16) Round<s32>( MIN((f64)s16_MAX, MAX((f64)s16_MIN, (f64)v)) ); }
;;;323    
;;;324        template<> inline u32 saturate_cast<u32>(const u8  v) { return v; }
;;;325        template<> inline u32 saturate_cast<u32>(const u16 v) { return v; }
;;;326        template<> inline u32 saturate_cast<u32>(const u32 v) { return v; }
;;;327        template<> inline u32 saturate_cast<u32>(const u64 v) { return (u32)             MIN((u64)u32_MAX, (u64)v); }
;;;328        template<> inline u32 saturate_cast<u32>(const s8  v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;329        template<> inline u32 saturate_cast<u32>(const s16 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;330        template<> inline u32 saturate_cast<u32>(const s32 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;331        template<> inline u32 saturate_cast<u32>(const s64 v) { return (u32)             MIN((s64)u32_MAX, MAX((s64)0, (s64)v)); }
;;;332        template<> inline u32 saturate_cast<u32>(const f32 v) { return (u32) (v > (f32)0xFFFFFF7F) ? 0xFFFFFFFF : Round<u32>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;333        template<> inline u32 saturate_cast<u32>(const f64 v) { return (u32) Round<u32>( MIN((f64)u32_MAX, MAX((f64)0, (f64)v)) ); }
;;;334    
;;;335        template<> inline s32 saturate_cast<s32>(const u8  v) { return v; }
;;;336        template<> inline s32 saturate_cast<s32>(const u16 v) { return v; }
;;;337        template<> inline s32 saturate_cast<s32>(const u32 v) { return (s32)             MIN((u32)s32_MAX, (u32)v); }
;;;338        template<> inline s32 saturate_cast<s32>(const u64 v) { return (s32)             MIN((u64)s32_MAX, (u64)v); }
;;;339        template<> inline s32 saturate_cast<s32>(const s8  v) { return v; }
;;;340        template<> inline s32 saturate_cast<s32>(const s16 v) { return v; }
;;;341        template<> inline s32 saturate_cast<s32>(const s32 v) { return v; }
;;;342        template<> inline s32 saturate_cast<s32>(const s64 v) { return (s32)             MIN((s64)s32_MAX, MAX((s64)s32_MIN, (s64)v)); }
;;;343        template<> inline s32 saturate_cast<s32>(const f32 v) { return (s32) (v > (f32)0x7FFFFFBF) ? 0x7FFFFFFF : Round<s32>(MAX((f32)s32_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;344        template<> inline s32 saturate_cast<s32>(const f64 v) { return (s32) Round<s32>( MIN((f64)s32_MAX, MAX((f64)s32_MIN, (f64)v)) ); }
;;;345    
;;;346        template<> inline u64 saturate_cast<u64>(const u8  v) { return v; }
;;;347        template<> inline u64 saturate_cast<u64>(const u16 v) { return v; }
;;;348        template<> inline u64 saturate_cast<u64>(const u32 v) { return v; }
;;;349        template<> inline u64 saturate_cast<u64>(const u64 v) { return v; }
;;;350        template<> inline u64 saturate_cast<u64>(const s8  v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;351        template<> inline u64 saturate_cast<u64>(const s16 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;352        template<> inline u64 saturate_cast<u64>(const s32 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;353        template<> inline u64 saturate_cast<u64>(const s64 v) { return (u64)                               MAX((s64)0, (s64)v);  }
;;;354        template<> inline u64 saturate_cast<u64>(const f32 v) { return (u64) (v > (f32)0XFFFFFF7FFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;355        template<> inline u64 saturate_cast<u64>(const f64 v) { return (u64) (v > (f64)0xFFFFFFFFFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f64)0, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;356    
;;;357        template<> inline s64 saturate_cast<s64>(const u8  v) { return v; }
;;;358        template<> inline s64 saturate_cast<s64>(const u16 v) { return v; }
;;;359        template<> inline s64 saturate_cast<s64>(const u32 v) { return v; }
;;;360        template<> inline s64 saturate_cast<s64>(const u64 v) { return (s64)             MIN((u64)s64_MAX, (u64)v); }
;;;361        template<> inline s64 saturate_cast<s64>(const s8  v) { return v; }
;;;362        template<> inline s64 saturate_cast<s64>(const s16 v) { return v; }
;;;363        template<> inline s64 saturate_cast<s64>(const s32 v) { return v; }
;;;364        template<> inline s64 saturate_cast<s64>(const s64 v) { return v; }
;;;365        template<> inline s64 saturate_cast<s64>(const f32 v) { return (s64) (v > (f32)0x7FFFFFBFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f32)s64_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;366        template<> inline s64 saturate_cast<s64>(const f64 v) { return (s64) (v > (f64)0x7FFFFFFFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f64)s64_MIN, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;367    
;;;368        template<> inline f32 saturate_cast(const f64 v) { return (f32) MIN((f64)FLT_MAX, MAX(-(f64)FLT_MAX, (f64)v)); }
;;;369      } // namespace Embedded
;;;370    } // namespace Anki
;;;371    
;;;372    #endif // _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;18     #include "anki/common/robot/memory.h"
;;;1      /**
;;;19     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;20     #include "anki/common/robot/geometry.h"
;;;1      /**
;;;2      File: geometry.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of geometry_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/geometry_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/memory.h"
;;;1      /**
;;;18     #include "anki/common/robot/matrix.h"
;;;1      /**
;;;2      File: matrix.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of matrix_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;14     
;;;15     #include "anki/common/robot/matrix_declarations.h"
;;;1      /**
;;;2      File: matrix_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various Matrix operations, such as matrix multiply and addition.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         namespace Matrix
;;;24         {
;;;25           // #pragma mark --- Declarations ---
;;;26     
;;;27           //
;;;28           // Simple matrix statistics
;;;29           //
;;;30     
;;;31           // Return the minimum element in this Array
;;;32           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat);
;;;33     
;;;34           // Return the maximum element in this Array
;;;35           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat);
;;;36     
;;;37           // Return the sum of every element in the Array
;;;38           template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat);
;;;39     
;;;40           // Return the mean of every element in the Array
;;;41           template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat);
;;;42     
;;;43           // Simultaneously compute the mean and variance of every element in the Array
;;;44           template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(const ConstArraySliceExpression<Array_Type> &mat,
;;;45             Accumulator_Type& mean, Accumulator_Type& var);
;;;46     
;;;47           //
;;;48           // Elementwise matrix operations
;;;49           //
;;;50     
;;;51           // Elementwise add two arrays. in1, in2, and out can be the same array
;;;52           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;53           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;54           template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;55     
;;;56           // Elementwise subtract two arrays. in1, in2, and out can be the same array
;;;57           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;58           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;59           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;60     
;;;61           // Elementwise multiply two arrays. in1, in2, and out can be the same array
;;;62           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;63           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;64           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;65     
;;;66           // Elementwise divide two arrays. in1, in2, and out can be the same array
;;;67           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;68           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;69           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;70     
;;;71           // Elementwise exponential on an array
;;;72           template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;73     
;;;74           // Elementwise square root on an array
;;;75           template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;76     
;;;77           //
;;;78           // Standard matrix operations
;;;79           //
;;;80     
;;;81           // Perform the matrix multiplication "out = in1 * in2"
;;;82           // Note that this is the naive O(n^3) Definition
;;;83           template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out);
;;;84     
;;;85           // Perform the matrix multiplication "out = in1 * in2'"
;;;86           // Note that this is the naive O(n^3) Definition
;;;87           // MultiplyTranspose has better access patterns than Multiply for certain types of arrays, so could be a lot faster (and easier to accelerate)
;;;88           template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out);
;;;89     
;;;90           //
;;;91           // Rotation Matrices
;;;92           //
;;;93     
;;;94           // TODO: Add other rotation-related math, like Rodrigues' formula, or Pose chaining...
;;;95     
;;;96           // Compute the three Euler angles from a given 3x3 Rotation Matrix.
;;;97           Result GetEulerAngles(const Array<f32>& R, f32& angle_x, f32& angle_y, f32& angle_z);
;;;98     
;;;99           //
;;;100          // Linear Algebra and Linear Solvers
;;;101          //
;;;102    
;;;103          // Compute the Cholesky-Banachiewicz decomposition, to return a lower-triangular matrix L such that A=L*L'
;;;104          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;105            Array<Type> &A_L,      //!< Input A Matrix and Output lower-triangular L matrix
;;;106            Array<Type> &Bt_Xt,    //!< Input B-transpose matrix and Output X-transpose solution
;;;107            bool realCholesky,     //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;108            bool &numericalFailure //!< If true, the solver failed because of numerical instability
;;;109            );
;;;110    
;;;111          // Compute the homography such that "transformedPoints = homography * originalPoints"
;;;112          //
;;;113          // WARNING: This uses the inhomogeneous solution and the Cholesky decomposition, therefore it
;;;114          //          will be incorrect if H_33 is zero, which happens in certain cases of lines at
;;;115          //          inifinty. For more details, see Multiple View Geometry 2nd Edition, Example 4.1
;;;116          template<typename Type> Result EstimateHomography(
;;;117            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;118            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;119            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;120            bool &numericalFailure, //!< Did the homography solver fail?
;;;121            MemoryStack scratch //!< Scratch memory
;;;122            );
;;;123    
;;;124          //template<typename InType, typename IntermediateType, typename OutType> Result CholeskyDecomposition(
;;;125          //  const Array<InType> &A,                    //!< Input A Matrix
;;;126          //  Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;127          //  Array<OutType> &L                          //!< Output lower-triangular L matrix
;;;128          //  );
;;;129    
;;;130          //template<typename InType, typename IntermediateType, typename OutType> Result SolveWithLowerTriangular(
;;;131          //  const Array<InType> &L,                          //!< Input lower-triangular L matrix (such as computed by CholeskyDecomposition)
;;;132          //  const Array<InType> &b,                          //!< Input b matrix
;;;133          //  const Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;134          //  Array<OutType> &x                                //!< Output x solution
;;;135          //  );
;;;136    
;;;137          // Solves Ax = b
;;;138          // Specifically, it uses SVD to minimize ||Ax - b||
;;;139          // Note that the A, b, and x matrices are transposed (this is because for large numbers of samples, transposed inputs are liable to be faster)
;;;140          //Result SolveLeastSquaresWithSVD_f32(Array<f32> &At, const Array<f32> &bt, Array<f32> &xt, MemoryStack scratch);
;;;141          //Result SolveLeastSquaresWithSVD_f64(Array<f64> &At, const Array<f64> &bt, Array<f64> &xt, MemoryStack scratch);
;;;142    
;;;143          //
;;;144          // Matrix structure operations
;;;145          //
;;;146    
;;;147          // matlab equivalent: out = reshape(in, [M,N]);
;;;148          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;149          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory);
;;;150    
;;;151          // matlab equivalent: out = in(:);
;;;152          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;153          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory);
;;;154    
;;;155          // Perform an immediate matrix transpose (unlike the lazy transpose of ArraySlice)
;;;156          // in and out must be different Array objects
;;;157          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out);
;;;158    
;;;159          // Rotate an array clockwise by 90, 180, or 270 degrees.
;;;160          // NOTE: Only works for a square matrix.
;;;161          // NOTE: In and out must be different arrays (unlike the interview question)
;;;162          template<typename InType, typename OutType> Result Rotate90( const Array<InType> &in, Array<OutType> &out);
;;;163          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out);
;;;164          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out);
;;;165    
;;;166          //
;;;167          // Misc matrix operations
;;;168          //
;;;169    
;;;170          // Works the same as the Matlab sort() for matrices.
;;;171          // InsertionSort(X) sorts each column of X in ascending order.
;;;172          // The minIndex and maxIndex are for the sortWhichDimension. maxIndex is automatically clipped to the size of the input Array.
;;;173          // NOTE: this currently uses insertion sort, so may be slow for large, badly-unsorted arrays
;;;174          template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;175    
;;;176          // Subsections less-than-or-equal-to insertionSortSize are sorted with insertion sort
;;;177          template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;178    
;;;179          // indexes must be allocated, but will be overwritten by InsertionSort()
;;;180          template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;181    
;;;182          template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;183    
;;;184          // For a square array, either:
;;;185          // 1. When lowerToUpper==true,  copies the lower (left)  triangle to the upper (right) triangle
;;;186          // 2. When lowerToUpper==false, copies the upper (right) triangle to the lower (left)  triangle
;;;187          // Functionally the same as OpenCV completeSymm()
;;;188          template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper = false);
;;;189    
;;;190          // There's probably no need to use these directly. Instead, use the normal Matrix:: operations, like Matrix::Add
;;;191          namespace Elementwise
;;;192          {
;;;193            template<typename InType, typename IntermediateType, typename OutType> class Add {
;;;194            public:
;;;195              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) + static_cast<IntermediateType>(value2));}
;;;196            };
;;;197    
;;;198            template<typename InType, typename IntermediateType, typename OutType> class Subtract {
;;;199            public:
;;;200              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) - static_cast<IntermediateType>(value2));}
;;;201            };
;;;202    
;;;203            template<typename InType, typename IntermediateType, typename OutType> class DotMultiply {
;;;204            public:
;;;205              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) * static_cast<IntermediateType>(value2));}
;;;206            };
;;;207    
;;;208            template<typename InType, typename IntermediateType, typename OutType> class DotDivide {
;;;209            public:
;;;210              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) / static_cast<IntermediateType>(value2));}
;;;211            };
;;;212    
;;;213            // Technically a unary operator, but we ignore the second parameter
;;;214            // TODO: if this is slow, make a unary version of ApplyOperation
;;;215            template<typename InType, typename IntermediateType, typename OutType> class Exp {
;;;216            public:
;;;217              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(expf(static_cast<IntermediateType>(value1)));}
;;;218            };
;;;219    
;;;220            template<typename InType, typename IntermediateType, typename OutType> class Sqrt {
;;;221            public:
;;;222              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(sqrtf(static_cast<IntermediateType>(value1)));}
;;;223            };
;;;224    
;;;225            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;226            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;227            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;228          } // namespace Elementwise
;;;229        } // namespace Matrix
;;;230      } // namespace Embedded
;;;231    } // namespace Anki
;;;232    
;;;233    #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;18     #include "anki/common/robot/memory.h"
;;;19     #include "anki/common/robot/errorHandling.h"
;;;20     #include "anki/common/robot/geometry.h"
;;;21     #include "anki/common/robot/utilities_c.h"
;;;22     #include "anki/common/robot/sequences.h"
;;;23     #include "anki/common/robot/matrix.h"
;;;24     #include "anki/common/robot/comparisons.h"
;;;25     
;;;26     #include "anki/common/shared/utilities_shared.h"
;;;27     
;;;28     #include "anki/common/robot/serialize_declarations.h"
;;;29     
;;;30     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;31     #include "opencv2/core/core.hpp"
;;;32     #include "opencv2/highgui/highgui.hpp"
;;;33     #include "opencv2/imgproc/imgproc.hpp"
;;;34     #include "opencv2/objdetect/objdetect.hpp"
;;;35     #endif
;;;36     
;;;37     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;38     #define ANKICORETECH_EMBEDDED_USE_MALLOC 1
;;;39     #define ANKICORETECH_EMBEDDED_USE_ZLIB 1
;;;40     #endif
;;;41     
;;;42     #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;43     #include "zlib.h"
;;;44     #endif
;;;45     
;;;46     namespace Anki
;;;47     {
;;;48       namespace Embedded
;;;49       {
;;;50         template<typename Type> class ArraySlice;
;;;51         template<typename Type> class ConstArraySlice;
;;;52         template<typename Type> class ConstArraySliceExpression;
;;;53     
;;;54         // #pragma mark --- Array Definitions ---
;;;55     
;;;56         template<typename Type> s32 Array<Type>::ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags)
;;;57         {
;;;58           AnkiConditionalErrorAndReturnValue(numCols >= 0,
;;;59             0, "Array<Type>::ComputeRequiredStride", "Invalid size");
;;;60     
;;;61           const s32 numColsCapped = MAX(numCols, 1);
;;;62     
;;;63           const s32 bufferRequired = static_cast<s32>(RoundUp<size_t>(sizeof(Type)*numColsCapped, MEMORY_ALIGNMENT));
;;;64     
;;;65           return bufferRequired;
;;;66         }
;;;67     
;;;68         template<typename Type> s32 Array<Type>::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags)
;;;69         {
;;;70           AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0,
;;;71             0, "Array<Type>::ComputeMinimumRequiredMemory", "Invalid size");
;;;72     
;;;73           const s32 numRowsCapped = MAX(numRows, 1);
;;;74     
;;;75           return numRowsCapped * Array<Type>::ComputeRequiredStride(numCols, flags);
;;;76         }
;;;77     
;;;78         template<typename Type> Array<Type>::Array()
;;;79         {
;;;80           InvalidateArray();
;;;81         }
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
;;;139        template<typename Type> Array<Type> Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;140        {
;;;141          Array<Type> newArray = Array<Type>();
;;;142    
;;;143    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;144          const cv::Mat cvImage = cv::imread(filename, CV_LOAD_IMAGE_GRAYSCALE);
;;;145    
;;;146          AnkiConditionalErrorAndReturnValue(cvImage.cols >= 0 && cvImage.rows >= 0,
;;;147            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;148    
;;;149          newArray = Array<Type>(cvImage.rows, cvImage.cols, memory);
;;;150    
;;;151          AnkiConditionalErrorAndReturnValue(newArray.IsValid(),
;;;152            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;153    
;;;154          const u8 * restrict pCvImage = cvImage.data;
;;;155    
;;;156          for(s32 y=0; y<cvImage.rows; y++) {
;;;157            Type * restrict pNewArray = newArray.Pointer(y, 0);
;;;158    
;;;159            for(s32 x=0; x<cvImage.cols; x++) {
;;;160              pNewArray[x] = static_cast<Type>(pCvImage[x]);
;;;161            }
;;;162    
;;;163            pCvImage += cvImage.step.buf[0];
;;;164          }
;;;165    #else
;;;166          AnkiError("Array<Type>::Array", "OpenCV is required to load an image from an image file");
;;;167    #endif
;;;168    
;;;169          return newArray;
;;;170        } // Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;171    
;;;172        template<typename Type> Array<Type> LoadBinaryArray_Generic(const char * filename, MemoryStack *scratch, MemoryStack *memory, void * allocatedBuffer, const s32 allocatedBufferLength)
;;;173        {
;;;174          u16  basicType_sizeOfType;
;;;175          bool basicType_isBasicType;
;;;176          bool basicType_isInteger;
;;;177          bool basicType_isSigned;
;;;178          bool basicType_isFloat;
;;;179          bool basicType_isString;
;;;180    
;;;181          Array<u8> rawArray = LoadBinaryArray_UnknownType(
;;;182            filename,
;;;183            scratch, memory,
;;;184            allocatedBuffer, allocatedBufferLength,
;;;185            basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString);
;;;186    
;;;187          // TODO: check that the types match
;;;188    
;;;189          Array<Type> newArray = *reinterpret_cast<Array<Type>*>( &rawArray );
;;;190    
;;;191          return newArray;
;;;192        } // / LoadBinaryArray_Generic()
;;;193    
;;;194        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;195        {
;;;196          return LoadBinaryArray_Generic<Type>(filename, &scratch, &memory, NULL, -1);
;;;197        } // Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;198    
;;;199        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength) //< allocatedBuffer must be freed manually
;;;200        {
;;;201          return LoadBinaryArray_Generic<Type>(filename, NULL, NULL, allocatedBuffer, allocatedBufferLength);
;;;202        } // LoadBinaryMalloc()
;;;203    
;;;204        template<typename Type> Result Array<Type>::SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const
;;;205        {
;;;206          AnkiConditionalErrorAndReturnValue(AreValid(*this, scratch) && filename,
;;;207            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::SaveBinary", "Invalid inputs");
;;;208    
;;;209          AnkiConditionalErrorAndReturnValue(compressionLevel >= 0 && compressionLevel <= 9,
;;;210            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::SaveBinary", "Invalid compression level");
;;;211    
;;;212          // If this is a string array, add the sizes of the null terminated strings (or zero otherwise)
;;;213          const s32 stringsLength = TotalArrayStringLengths<Type>(*this);
;;;214    
;;;215          const s32 serializedBufferLength = 4096 + ARRAY_FILE_HEADER_LENGTH + this->get_size(0) * this->get_stride() + stringsLength;
;;;216          void *buffer = scratch.Allocate(serializedBufferLength);
;;;217    
;;;218          AnkiConditionalErrorAndReturnValue(buffer,
;;;219            RESULT_FAIL_OUT_OF_MEMORY, "Array<Type>::SaveBinary", "Memory could not be allocated");
;;;220    
;;;221          SerializedBuffer toSave(buffer, serializedBufferLength);
;;;222    
;;;223          toSave.PushBack<Type>("Array", *this);
;;;224    
;;;225          s32 startIndex;
;;;226          u8 * bufferStart = reinterpret_cast<u8*>(toSave.get_memoryStack().get_validBufferStart(startIndex));
;;;227          const s32 validUsedBytes = toSave.get_memoryStack().get_usedBytes() - startIndex;
;;;228    
;;;229          // const s32 startDiff = static_cast<s32>( reinterpret_cast<size_t>(bufferStart) - reinterpret_cast<size_t>(toSave.get_memoryStack().get_buffer()) );
;;;230          // const s32 endDiff = toSave.get_memoryStack().get_totalBytes() - toSave.get_memoryStack().get_usedBytes();
;;;231    
;;;232          FILE *fp = fopen(filename, "wb");
;;;233    
;;;234          AnkiConditionalErrorAndReturnValue(fp,
;;;235            RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Could not open file %s", filename);
;;;236    
;;;237          if(compressionLevel > 0) {
;;;238    #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;239            char tmpTextHeader[ARRAY_FILE_HEADER_LENGTH+1];
;;;240            strncpy(tmpTextHeader, &ARRAY_FILE_HEADER[0], ARRAY_FILE_HEADER_LENGTH+1);
;;;241            snprintf(tmpTextHeader+ARRAY_FILE_HEADER_VALID_LENGTH+1, ARRAY_FILE_HEADER_LENGTH-ARRAY_FILE_HEADER_VALID_LENGTH, "z%s ", ZLIB_VERSION);
;;;242    
;;;243            const s32 originalLength = validUsedBytes + SERIALIZED_BUFFER_HEADER_LENGTH + SERIALIZED_BUFFER_FOOTER_LENGTH;
;;;244    
;;;245            uLongf compressedLength = 128 + saturate_cast<s32>(1.1 * originalLength);
;;;246    
;;;247            void * uncompressed = malloc(originalLength);
;;;248            void * compressed = malloc(compressedLength + 2*sizeof(s32));
;;;249    
;;;250            if(!uncompressed || !compressed) {
;;;251              if(uncompressed)
;;;252                free(uncompressed);
;;;253    
;;;254              if(compressed)
;;;255                free(compressed);
;;;256    
;;;257              AnkiError("Array<Type>::SaveBinary", "Out of memory");
;;;258    
;;;259              return RESULT_FAIL_OUT_OF_MEMORY;
;;;260            }
;;;261    
;;;262            // Copy the uncompressed data into one buffer
;;;263            {
;;;264              char * pUncompressed = reinterpret_cast<char*>(uncompressed);
;;;265    
;;;266              memcpy(pUncompressed, &SERIALIZED_BUFFER_HEADER[0], SERIALIZED_BUFFER_HEADER_LENGTH);
;;;267              pUncompressed += SERIALIZED_BUFFER_HEADER_LENGTH;
;;;268    
;;;269              memcpy(pUncompressed, bufferStart, validUsedBytes);
;;;270              pUncompressed += validUsedBytes;
;;;271    
;;;272              memcpy(pUncompressed, &SERIALIZED_BUFFER_FOOTER[0], SERIALIZED_BUFFER_FOOTER_LENGTH);
;;;273            }
;;;274    
;;;275            const s32 compressionResult = compress2(reinterpret_cast<Bytef*>(compressed) + 2*sizeof(s32), &compressedLength, reinterpret_cast<Bytef*>(uncompressed), originalLength, compressionLevel);
;;;276    
;;;277            if(compressionResult != Z_OK) {
;;;278              if(uncompressed)
;;;279                free(uncompressed);
;;;280    
;;;281              if(compressed)
;;;282                free(compressed);
;;;283    
;;;284              AnkiError("Array<Type>::SaveBinary", "Zlib error");
;;;285              return RESULT_FAIL_IO;
;;;286            }
;;;287    
;;;288            reinterpret_cast<s32*>(compressed)[0] = static_cast<s32>(originalLength);
;;;289            reinterpret_cast<s32*>(compressed)[1] = static_cast<s32>(compressedLength);
;;;290    
;;;291            const size_t bytesWrittenForTextHeader = fwrite(tmpTextHeader, 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;292    
;;;293            const size_t bytesWritten = fwrite(compressed, 1, compressedLength + 2*sizeof(s32), fp);
;;;294    
;;;295            if(uncompressed)
;;;296              free(uncompressed);
;;;297    
;;;298            if(compressed)
;;;299              free(compressed);
;;;300    
;;;301            AnkiConditionalErrorAndReturnValue(
;;;302              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;303              bytesWritten == (compressedLength + 2*sizeof(s32)),
;;;304              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;305    
;;;306    #else
;;;307            AnkiError("Array<Type>::SaveBinary", "Saving with compression requires zlib");
;;;308            return RESULT_FAIL;
;;;309    #endif
;;;310          } else {
;;;311            const size_t bytesWrittenForTextHeader = fwrite(&ARRAY_FILE_HEADER[0], 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;312    
;;;313            const size_t bytesWrittenForHeader = fwrite(&SERIALIZED_BUFFER_HEADER[0], 1, SERIALIZED_BUFFER_HEADER_LENGTH, fp);
;;;314    
;;;315            const size_t bytesWritten = fwrite(bufferStart, 1, validUsedBytes, fp);
;;;316    
;;;317            const size_t bytesWrittenForFooter = fwrite(&SERIALIZED_BUFFER_FOOTER[0], 1, SERIALIZED_BUFFER_FOOTER_LENGTH, fp);
;;;318    
;;;319            AnkiConditionalErrorAndReturnValue(
;;;320              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;321              bytesWrittenForHeader == SERIALIZED_BUFFER_HEADER_LENGTH &&
;;;322              bytesWritten == validUsedBytes &&
;;;323              bytesWrittenForFooter == SERIALIZED_BUFFER_FOOTER_LENGTH,
;;;324              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;325          }
;;;326    
;;;327          fclose(fp);
;;;328    
;;;329          return RESULT_OK;
;;;330        } // Array<Type>::SaveBinary(const char * filename, MemoryStack scratch)
;;;331    
;;;332        template<typename Type> const Type* Array<Type>::Pointer(const s32 index0, const s32 index1) const
;;;333        {
;;;334          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;335          AnkiAssert(this->IsValid());
;;;336    
;;;337          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride ) + index1;
;;;338        }
;;;339    
;;;340        template<typename Type> Type* Array<Type>::Pointer(const s32 index0, const s32 index1)
;;;341        {
;;;342          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;343          AnkiAssert(this->IsValid());
;;;344    
;;;345          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride ) + index1;
;;;346        }
;;;347    
;;;348        template<typename Type> inline const Type * Array<Type>::operator[](const s32 index0) const
;;;349        {
;;;350          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;351    
;;;352          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride );
;;;353        }
;;;354    
;;;355        template<typename Type> inline Type * Array<Type>::operator[](const s32 index0)
;;;356        {
;;;357          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;358    
;;;359          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride );
;;;360        }
;;;361    
;;;362        template<typename Type> const Type* Array<Type>::Pointer(const Point<s16> &point) const
;;;363        {
;;;364          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;365        }
;;;366    
;;;367        template<typename Type> Type* Array<Type>::Pointer(const Point<s16> &point)
;;;368        {
;;;369          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;370        }
;;;371    
;;;372        template<typename Type> const Type& Array<Type>::Element(const s32 elementIndex) const
;;;373        {
;;;374          const s32 index1 = elementIndex % size[1];
;;;375          const s32 index0 = (elementIndex - index1) / size[1];
;;;376    
;;;377          return *Pointer(index0, index1);
;;;378        }
;;;379    
;;;380        template<typename Type> Type& Array<Type>::Element(const s32 elementIndex)
;;;381        {
;;;382          const s32 index1 = elementIndex % size[1];
;;;383          const s32 index0 = (elementIndex - index1) / size[1];
;;;384    
;;;385          return *Pointer(index0, index1);
;;;386        }
;;;387    
;;;388        template<typename Type> ArraySlice<Type> Array<Type>::operator() ()
;;;389        {
;;;390          ArraySlice<Type> slice(*this);
;;;391    
;;;392          return slice;
;;;393        }
;;;394    
;;;395        template<typename Type> ArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;396        {
;;;397          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;398    
;;;399          return slice;
;;;400        }
;;;401    
;;;402        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX)
;;;403        {
;;;404          LinearSequence<s32> ySlice = IndexSequence<s32>(minY, 1, maxY, this->size[0]);
;;;405          LinearSequence<s32> xSlice = IndexSequence<s32>(minX, 1, maxX, this->size[1]);
;;;406    
;;;407          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;408    
;;;409          return slice;
;;;410        }
;;;411    
;;;412        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX)
;;;413        {
;;;414          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;415          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;416    
;;;417          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;418    
;;;419          return slice;
;;;420        }
;;;421    
;;;422        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() () const
;;;423        {
;;;424          ConstArraySlice<Type> slice(*this);
;;;425    
;;;426          return slice;
;;;427        }
;;;428    
;;;429        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const
;;;430        {
;;;431          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;432    
;;;433          return slice;
;;;434        }
;;;435    
;;;436        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const
;;;437        {
;;;438          LinearSequence<s32> ySlice = IndexSequence(minY, 1, maxY, this->size[0]);
;;;439          LinearSequence<s32> xSlice = IndexSequence(minX, 1, maxX, this->size[1]);
;;;440    
;;;441          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;442    
;;;443          return slice;
;;;444        }
;;;445    
;;;446        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const
;;;447        {
;;;448          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;449          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;450    
;;;451          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;452    
;;;453          return slice;
;;;454        }
;;;455    
;;;456        template<typename Type> ConstArraySliceExpression<Type> Array<Type>::Transpose() const
;;;457        {
;;;458          ConstArraySliceExpression<Type> expression(this->operator() ());
;;;459          expression.Transpose();
;;;460    
;;;461          return expression;
;;;462        }
;;;463    
;;;464    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;465        template<typename Type> s32 Array<Type>::Set(const cv::Mat_<Type> &in)
;;;466        {
;;;467          const s32 inHeight = in.rows;
;;;468          const s32 inWidth = in.cols;
;;;469    
;;;470          AnkiConditionalErrorAndReturnValue(inHeight != 0,
;;;471            0, "Array<Type>::Set", "input cv::Mat is invalid. If you use the release OpenCV libraries with the debug build, lots of things like file loading don't work.");
;;;472    
;;;473          const bool isColor = in.channels() == 3 || inWidth == this->size[1]*3;
;;;474    
;;;475          if(isColor) {
;;;476            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0],
;;;477              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;478          } else {
;;;479            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;480              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;481          }
;;;482    
;;;483          for(s32 y=0; y<this->size[0]; y++) {
;;;484            const Type * restrict pIn = reinterpret_cast<const Type*>(in.ptr(y,0));
;;;485            Type * restrict pThis = this->Pointer(y,0);
;;;486    
;;;487            // If grayscale, just copy. If color, convert to grayscale
;;;488            if(isColor) {
;;;489              for(s32 x=0; x<this->size[1]; x++) {
;;;490                pThis[x] = (pIn[3*x] + pIn[3*x + 1] + pIn[3*x + 2]) / 3;
;;;491              }
;;;492            } else {
;;;493              memcpy(pThis, pIn, inWidth*sizeof(Type));
;;;494            }
;;;495          }
;;;496    
;;;497          return this->size[0]*this->size[1];
;;;498        }
;;;499    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;500    
;;;501        template<typename Type> void Array<Type>::Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues, const bool fitImageToWindow) const
;;;502        {
;;;503    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;504          AnkiConditionalError(this->IsValid(), "Array<Type>::Show", "Array<Type> is not valid");
;;;505    
;;;506          if(fitImageToWindow) {
;;;507            cv::namedWindow(windowName, CV_WINDOW_NORMAL);
;;;508          } else {
;;;509            cv::namedWindow(windowName, CV_WINDOW_AUTOSIZE);
;;;510          }
;;;511    
;;;512          if(scaleValues) {
;;;513            cv::Mat_<f64> scaledArray;
;;;514    
;;;515            if(ArrayToCvMat(*this, &scaledArray) != RESULT_OK)
;;;516              return;
;;;517    
;;;518            const f64 minValue = Matrix::Min<Type>(*this);
;;;519            const f64 maxValue = Matrix::Max<Type>(*this);
;;;520            const f64 range = maxValue - minValue;
;;;521    
;;;522            scaledArray -= minValue;
;;;523            scaledArray /= range;
;;;524    
;;;525            cv::imshow(windowName, scaledArray);
;;;526          } else {
;;;527            cv::Mat_<Type> arrayCopy;
;;;528    
;;;529            if(ArrayToCvMat(*this, &arrayCopy) != RESULT_OK)
;;;530              return;
;;;531    
;;;532            cv::imshow(windowName, arrayCopy);
;;;533          }
;;;534    
;;;535          if(waitForKeypress) {
;;;536            cv::waitKey();
;;;537          }
;;;538    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;539        }
;;;540    
;;;541        template<typename Type> Result Array<Type>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;542        {
;;;543          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;544            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;545    
;;;546          CoreTechPrint(variableName);
;;;547          CoreTechPrint(":\n");
;;;548          for(s32 y=MAX(0,minY); y<MIN(maxY+1,size[0]); y++) {
;;;549            const Type * const pThisData = this->Pointer(y, 0);
;;;550            for(s32 x=MAX(0,minX); x<MIN(maxX+1,size[1]); x++) {
;;;551              pThisData[x].Print();
;;;552            }
;;;553            CoreTechPrint("\n");
;;;554          }
;;;555          CoreTechPrint("\n");
;;;556    
;;;557          return RESULT_OK;
;;;558        }
;;;559    
;;;560        template<typename Type> Result Array<Type>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;561        {
;;;562          return this->Print(variableName, minY, maxY, minX, maxX);
;;;563        }
;;;564    
;;;565        template<typename Type> bool Array<Type>::IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const
;;;566        {
;;;567          bool isSame = false;
;;;568          if(AreValid(*this, other)) {
;;;569            const s32 nrows = this->get_size(0);
;;;570            const s32 ncols = this->get_size(1);
;;;571    
;;;572            if(other.get_size(0)==nrows && other.get_size(1) == ncols) {
;;;573              isSame = true;
;;;574              for(s32 i=0; i<nrows && isSame; ++i) {
;;;575                const Type * restrict pThis  = this->Pointer(i,0);
;;;576                const Type * restrict pOther = other.Pointer(i,0);
;;;577    
;;;578                for(s32 j=0; j<ncols; ++j) {
;;;579                  if(!NEAR(pThis[j], pOther[j], epsilon)) {
;;;580                    isSame = false;
;;;581                    break;
;;;582                  }
;;;583                } // for j
;;;584              } // for i
;;;585            } // if sizes match
;;;586          } // if both valid
;;;587    
;;;588          return isSame;
;;;589        } // IsNearlyEqualTo()
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
;;;592        {
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
;;;602        }
;;;603    
;;;604        template<typename Type> Result Array<Type>::Resize(const s32 numRows, const s32 numCols, MemoryStack &memory)
;;;605        {
;;;606          AnkiConditionalErrorAndReturnValue(numCols > 0 && numRows > 0,
;;;607            RESULT_FAIL_INVALID_SIZE, "Array<Type>::Resize", "Invalid size");
;;;608    
;;;609          s32 numBytesAllocated = 0;
;;;610    
;;;611          this->data = reinterpret_cast<Type*>( AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, true) );
;;;612    
;;;613          // Don't clear the reallocated memory
;;;614          const bool clearMemory = this->flags.get_zeroAllocatedMemory();
;;;615          this->flags.set_zeroAllocatedMemory(false);
;;;616    
;;;617          const Result result = InitializeBuffer(numRows,
;;;618            numCols,
;;;619            this->data,
;;;620            numBytesAllocated,
;;;621            this->flags);
;;;622    
;;;623          this->flags.set_zeroAllocatedMemory(clearMemory);
;;;624    
;;;625          return result;
;;;626        }
;;;627    
;;;628        template<typename Type> s32 Array<Type>::SetZero()
;;;629        {
;;;630          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;631            0, "Array<Type>::SetZero", "Array<Type> is not valid");
;;;632    
;;;633          const s32 numBytes = this->get_size(0)*this->get_stride();
;;;634    
;;;635          memset(this->Pointer(0,0), 0, numBytes);
;;;636    
;;;637          return numBytes;
;;;638        }
;;;639    
;;;640        template<typename Type> s32 Array<Type>::Set(const Type value)
;;;641        {
;;;642          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;643            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;644    
;;;645          for(s32 y=0; y<size[0]; y++) {
;;;646            Type * restrict pThisData = Pointer(y, 0);
;;;647            for(s32 x=0; x<size[1]; x++) {
;;;648              pThisData[x] = value;
;;;649            }
;;;650          }
;;;651    
;;;652          return size[0]*size[1];
;;;653        }
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
;;;656        {
;;;657          return this->SetCast<Type>(in);
;;;658        }
;;;659    
;;;660        template<typename Type> template<typename InType> s32 Array<Type>::SetCast(const Array<InType> &in)
;;;661        {
;;;662          const s32 inHeight = in.get_size(0);
;;;663          const s32 inWidth = in.get_size(1);
;;;664    
;;;665          AnkiConditionalErrorAndReturnValue(AreValid(*this, in),
;;;666            0, "Array<Type>::Set", "Invalid objects");
;;;667    
;;;668          AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;669            0, "Array<Type>::Set", "Array sizes don't match");
;;;670    
;;;671          for(s32 y=0; y<size[0]; y++) {
;;;672            const InType * restrict pIn = in.Pointer(y, 0);
;;;673            Type * restrict pThisData = Pointer(y, 0);
;;;674    
;;;675            for(s32 x=0; x<size[1]; x++) {
;;;676              pThisData[x] = saturate_cast<Type>(pIn[x]);
;;;677            }
;;;678          }
;;;679    
;;;680          return size[0]*size[1];
;;;681        }
;;;682    
;;;683        template<typename InType> s32 SetCast(const InType * const values, const s32 numValues)
;;;684        {
;;;685          // This is a little tough to write a general case for, so this method should be specialized
;;;686          // for each relevant case
;;;687          AnkiAssert(false);
;;;688    
;;;689          return 0;
;;;690        }
;;;691    
;;;692        template<typename Type> s32 Array<Type>::Set(const Type * const values, const s32 numValues)
;;;693        {
;;;694          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;695            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;696    
;;;697          s32 numValuesSet = 0;
;;;698    
;;;699          for(s32 y=0; y<size[0]; y++) {
;;;700            u32 * restrict pThisData = reinterpret_cast<u32*>(Pointer(y, 0));
;;;701    
;;;702            const s32 numValuesThisRow = MAX(0, MIN(numValues - y*size[1], size[1]));
;;;703    
;;;704            if(numValuesThisRow > 0) {
;;;705              // For small data types, this may be too many bytes, but the stride padding should make
;;;706              // the writing okay (I think)
;;;707              const s32 numWordsToCopy = (sizeof(Type)*numValuesThisRow + 3) / 4;
;;;708    
;;;709              //memcpy(pThisData, values + y*size[1], numValuesThisRow*sizeof(Type));
;;;710              for(s32 x=0; x<numWordsToCopy; x++) {
;;;711                //AnkiAssert(reinterpret_cast<size_t>(values+y*size[1]) % 4 == 0);
;;;712                pThisData[x] = reinterpret_cast<const u32*>(values+y*size[1])[x];
;;;713              }
;;;714              numValuesSet += numValuesThisRow;
;;;715            }
;;;716    
;;;717            if(numValuesThisRow < size[1]) {
;;;718              memset(pThisData+numValuesThisRow*sizeof(Type), 0, (size[1]-numValuesThisRow)*sizeof(Type));
;;;719            }
;;;720          }
;;;721    
;;;722          return numValuesSet;
;;;723        }
;;;724    
;;;725        template<typename Type> Array<Type>& Array<Type>::operator= (const Array<Type> & rightHandSide)
;;;726        {
;;;727          this->size[0] = rightHandSide.size[0];
;;;728          this->size[1] = rightHandSide.size[1];
;;;729    
;;;730          this->stride = rightHandSide.stride;
;;;731          this->flags = rightHandSide.flags;
;;;732          this->data = rightHandSide.data;
;;;733    
;;;734          return *this;
;;;735        }
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
;;;738        {
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
;;;747    
;;;748        template<typename Type> s32 Array<Type>::get_stride() const
;;;749        {
;;;750          return stride;
;;;751        }
;;;752    
;;;753        template<typename Type> s32 Array<Type>::get_numElements() const
;;;754        {
;;;755          if(size[0] > 0 && size[1] > 0) {
;;;756            return size[0] * size[1];
;;;757          } else {
;;;758            return 0;
;;;759          }
;;;760        }
;;;761    
;;;762        template<typename Type> void* Array<Type>::get_buffer()
;;;763        {
;;;764          return data;
;;;765        }
;;;766    
;;;767        template<typename Type> const void* Array<Type>::get_buffer() const
;;;768        {
;;;769          return data;
;;;770        }
;;;771    
;;;772        template<typename Type> Flags::Buffer Array<Type>::get_flags() const
;;;773        {
;;;774          return flags;
;;;775        }
;;;776    
;;;777        template<typename Type> void* Array<Type>::AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate)
;;;778        {
;;;779          AnkiConditionalError(numRows >= 0 && stride > 0,
;;;780            "Array<Type>::AllocateBufferFromMemoryStack", "Invalid size");
;;;781    
;;;782          const s32 numRowsCapped = MAX(numRows, 1);
;;;783    
;;;784          this->stride = stride;
;;;785    
;;;786          const s32 numBytesRequested = numRowsCapped * this->stride;
;;;787    
;;;788          if(reAllocate) {
;;;789            return memory.Reallocate(this->data, numBytesRequested, numBytesAllocated);
;;;790          } else {
;;;791            return memory.Allocate(numBytesRequested, flags.get_zeroAllocatedMemory(), numBytesAllocated);
;;;792          }
;;;793        }
;;;794    
;;;795        template<typename Type> Result Array<Type>::InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags)
;;;796        {
;;;797          if(!rawData) {
;;;798            AnkiError("Anki.Array2d.initialize", "input data buffer is NULL");
;;;799            InvalidateArray();
;;;800            return RESULT_FAIL_UNINITIALIZED_MEMORY;
;;;801          }
;;;802    
;;;803          AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0 && dataLength >= MEMORY_ALIGNMENT,
;;;804            RESULT_FAIL_INVALID_SIZE, "Array<Type>::InitializeBuffer", "Negative dimension");
;;;805    
;;;806          AnkiConditionalErrorAndReturnValue(!flags.get_useBoundaryFillPatterns(),
;;;807            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::InitializeBuffer", "Fill patterns not supported for Array");
;;;808    
;;;809          this->flags = flags;
;;;810          this->size[0] = numRows;
;;;811          this->size[1] = numCols;
;;;812    
;;;813          // Initialize an empty array.
;;;814    
;;;815          this->data = reinterpret_cast<Type*>(rawData);
;;;816    
;;;817          const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData), MEMORY_ALIGNMENT) - reinterpret_cast<size_t>(rawData));
;;;818          const s32 requiredBytes = ComputeRequiredStride(numCols,flags)*numRows + extraAlignmentBytes;
;;;819    
;;;820          if(requiredBytes > dataLength) {
;;;821            AnkiError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
;;;822            InvalidateArray();
;;;823            return RESULT_FAIL_OUT_OF_MEMORY;
;;;824          }
;;;825    
;;;826          this->data = reinterpret_cast<Type*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
;;;827    
;;;828          //#if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;829          //      this->UpdateCvMatMirror(*this);
;;;830          //#endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;831    
;;;832          return RESULT_OK;
;;;833        } // Array<Type>::InitializeBuffer()
;;;834    
;;;835        // Set all the buffers and sizes to -1, to signal an invalid array
;;;836        template<typename Type> void Array<Type>::InvalidateArray()
;;;837        {
;;;838          this->size[0] = -1;
;;;839          this->size[1] = -1;
;;;840          this->stride = -1;
;;;841          this->data = NULL;
;;;842        } // void Array<Type>::InvalidateArray()
;;;843    
;;;844        template<typename Type> Result Array<Type>::PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX)  const
;;;845        {
;;;846          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;847            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;848    
;;;849          const s32 realMinX = MAX(0,minX);
;;;850          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;851          const s32 realMinY = MAX(0,minY);
;;;852          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;853    
;;;854          CoreTechPrint("%s type(int:%d,signed:%d,float:%d,sizeof:%d):\n", variableName, Flags::TypeCharacteristics<Type>::isInteger, Flags::TypeCharacteristics<Type>::isSigned, Flags::TypeCharacteristics<Type>::isFloat, sizeof(Type));
;;;855    
;;;856          for(s32 y=realMinY; y<realMaxY; y++) {
;;;857            const Type * const pThisData = this->Pointer(y, 0);
;;;858            for(s32 x=realMinX; x<realMaxX; x++) {
;;;859              if(Flags::TypeCharacteristics<Type>::isBasicType) {
;;;860                if(Flags::TypeCharacteristics<Type>::isInteger) {
;;;861                  CoreTechPrint("%d ", static_cast<s32>(pThisData[x]));
;;;862                } else {
;;;863                  if(version==1) {
;;;864                    CoreTechPrint("%f ", (float)pThisData[x]);
;;;865                  } else {
;;;866                    CoreTechPrint("%e ", (float)pThisData[x]);
;;;867                  }
;;;868                }
;;;869              } else {
;;;870                CoreTechPrint("! ");
;;;871              }
;;;872            }
;;;873            CoreTechPrint("\n");
;;;874          }
;;;875          CoreTechPrint("\n");
;;;876    
;;;877          return RESULT_OK;
;;;878        }
;;;879    
;;;880        template<typename Type> Result Array<Type>::PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;881        {
;;;882          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;883            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::PrintString", "Array<Type> is not valid");
;;;884    
;;;885          const s32 realMinX = MAX(0,minX);
;;;886          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;887          const s32 realMinY = MAX(0,minY);
;;;888          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;889    
;;;890          CoreTechPrint("%s:\n", variableName);
;;;891    
;;;892          for(s32 y=realMinY; y<realMaxY; y++) {
;;;893            const char * const * pThisData = this->Pointer(y, 0);
;;;894            for(s32 x=realMinX; x<realMaxX; x++) {
;;;895              const char * curString = pThisData[x];
;;;896              if(!curString) {
;;;897                CoreTechPrint("NULL, ");
;;;898              } else {
;;;899                CoreTechPrint("\"%s\", ", curString);
;;;900              }
;;;901            }
;;;902            CoreTechPrint("\n");
;;;903          }
;;;904          CoreTechPrint("\n");
;;;905    
;;;906          return RESULT_OK;
;;;907        }
;;;908    
;;;909        // #pragma mark --- FixedPointArray Definitions ---
;;;910    
;;;911        template<typename Type> FixedPointArray<Type>::FixedPointArray()
;;;912          : Array<Type>(), numFractionalBits(-1)
;;;913        {
;;;914        }
;;;915    
;;;916        template<typename Type> FixedPointArray<Type>::FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags)
;;;917          : Array<Type>(numRows, numCols, data, dataLength, flags), numFractionalBits(numFractionalBits)
;;;918        {
;;;919          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= (sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;920        }
;;;921    
;;;922        template<typename Type> FixedPointArray<Type>::FixedPointArray(s32 numRows, s32 numCols, s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags)
;;;923          : Array<Type>(numRows, numCols, memory, flags), numFractionalBits(numFractionalBits)
;;;924        {
;;;925          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= static_cast<s32>(sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;926        }
;;;927    
;;;928        template<typename Type> s32 FixedPointArray<Type>::get_numFractionalBits() const
;;;929        {
;;;930          return numFractionalBits;
;;;931        }
;;;932    
;;;933    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;934        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;935        {
;;;936          AnkiConditionalErrorAndReturnValue(in.IsValid() && out,
;;;937            RESULT_FAIL, "ArrayToCvMat", "This Array is invalid");
;;;938    
;;;939          out->refcount = NULL;
;;;940    
;;;941          // These two should be set, because if the Mat_ constructor was not called, these will not be initialized
;;;942          out->step.p = out->step.buf;
;;;943          out->size = &out->rows;
;;;944    
;;;945          *out = cv::Mat_<Type>(in.get_size(0), in.get_size(1), const_cast<Type*>(in.Pointer(0,0)), static_cast<size_t>(in.get_stride()));
;;;946    
;;;947          return RESULT_OK;
;;;948        } // template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;949    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;950    
;;;951        // #pragma mark --- Array Specializations ---
;;;952    
;;;953        template<> Result Array<bool>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;954        template<> Result Array<u8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;955        template<> Result Array<s8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;956        template<> Result Array<u16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;957        template<> Result Array<s16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;958        template<> Result Array<u32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;959        template<> Result Array<s32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;960        template<> Result Array<u64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;961        template<> Result Array<s64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;962        template<> Result Array<f32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;963        template<> Result Array<f64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;964        template<> Result Array<const char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;965        template<> Result Array<char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;966    
;;;967        template<> Result Array<f32>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;968        template<> Result Array<f64>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;969    
;;;970        template<> template<> s32 Array<u8>::SetCast(const s32 * const values, const s32 numValues);
;;;971        template<> template<> s32 Array<s16>::SetCast(const s32 * const values, const s32 numValues);
;;;972      } // namespace Embedded
;;;973    } //namespace Anki
;;;974    
;;;975    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;17     #include "anki/common/robot/arraySlices.h"
;;;1      /**
;;;2      File: arraySlices.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of arraySlices_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;14     
;;;15     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> ConstArraySlice<Type>::ConstArraySlice()
;;;23           : ySlice(LinearSequence<s32>()), xSlice(LinearSequence<s32>()), array(Array<Type>()), constArrayData(NULL)
;;;24         {
;;;25         }
;;;26     
;;;27         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array)
;;;28           : ySlice(LinearSequence<s32>(0,array.get_size(0)-1)), xSlice(LinearSequence<s32>(0,array.get_size(1)-1)), array(array)
;;;29         {
;;;30           if(array.get_numElements() == 0) {
;;;31             this->constArrayData = NULL;
;;;32           } else {
;;;33             this->constArrayData = array.Pointer(0,0);
;;;34           }
;;;35         }
;;;36     
;;;37         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;38           : ySlice(ySlice), xSlice(xSlice), array(array)
;;;39         {
;;;40           if(array.get_numElements() == 0) {
;;;41             this->constArrayData = NULL;
;;;42           } else {
;;;43             this->constArrayData = array.Pointer(0,0);
;;;44           }
;;;45         }
;;;46     
;;;47         template<typename Type> ConstArraySliceExpression<Type> ConstArraySlice<Type>::Transpose() const
;;;48         {
;;;49           ConstArraySliceExpression<Type> expression(*this, true);
;;;50     
;;;51           return expression;
;;;52         }
;;;53     
;;;54         template<typename Type> bool ConstArraySlice<Type>::IsValid() const
;;;55         {
;;;56           return this->array.IsValid();
;;;57         }
;;;58     
;;;59         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_ySlice() const
;;;60         {
;;;61           return ySlice;
;;;62         }
;;;63     
;;;64         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_xSlice() const
;;;65         {
;;;66           return xSlice;
;;;67         }
;;;68     
;;;69         template<typename Type> const Array<Type>& ConstArraySlice<Type>::get_array() const
;;;70         {
;;;71           return this->array;
;;;72         }
;;;73     
;;;74         template<typename Type> ArraySlice<Type>::ArraySlice()
;;;75           : ConstArraySlice<Type>(), arrayData(NULL)
;;;76         {
;;;77         }
;;;78     
;;;79         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array)
;;;80           : ConstArraySlice<Type>(array)
;;;81         {
;;;82           if(array.get_numElements() == 0) {
;;;83             this->arrayData = NULL;
;;;84           } else {
;;;85             this->arrayData = array.Pointer(0,0);
;;;86           }
;;;87         }
;;;88     
;;;89         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;90           : ConstArraySlice<Type>(array, ySlice, xSlice)
;;;91         {
;;;92           if(array.get_numElements() == 0) {
;;;93             this->arrayData = NULL;
;;;94           } else {
;;;95             this->arrayData = array.Pointer(0,0);
;;;96           }
;;;97         }
;;;98     
;;;99         template<typename Type> s32 ArraySlice<Type>::Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;100        {
;;;101          return this->SetCast<Type>(input, automaticTranspose);
;;;102        }
;;;103    
;;;104        template<typename Type> s32 ArraySlice<Type>::Set(const LinearSequence<Type> &input)
;;;105        {
;;;106          const Result result = input.Evaluate(*this);
;;;107          return (result==RESULT_OK) ? input.get_size() : 0;
;;;108        }
;;;109    
;;;110        template<typename Type> s32 ArraySlice<Type>::Set(const Type value)
;;;111        {
;;;112          Array<Type> &array = this->get_array();
;;;113    
;;;114          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;115            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;116    
;;;117          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;118    
;;;119          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;120            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;121    
;;;122          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;123            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;124            Type * restrict pMat = array.Pointer(y, 0);
;;;125    
;;;126            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;127              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;128              pMat[x] = value;
;;;129            }
;;;130          }
;;;131    
;;;132          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;133        }
;;;134    
;;;135        template<typename Type> s32 ArraySlice<Type>::Set(const Type * const values, const s32 numValues)
;;;136        {
;;;137          Array<Type> &array = this->get_array();
;;;138    
;;;139          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;140            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;141    
;;;142          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;143    
;;;144          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;145            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;146    
;;;147          AnkiConditionalErrorAndReturnValue(limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize == numValues,
;;;148            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;149    
;;;150          s32 ci = 0;
;;;151          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;152            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;153            Type * restrict pMat = array.Pointer(y, 0);
;;;154    
;;;155            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;156              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;157              pMat[x] = values[ci];
;;;158              ci++;
;;;159            }
;;;160          }
;;;161    
;;;162          AnkiAssert(ci == limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize);
;;;163    
;;;164          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;165        }
;;;166    
;;;167        template<typename Type> template<typename InType> s32 ArraySlice<Type>::SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;168        {
;;;169          AnkiConditionalErrorAndReturnValue(AreValid(*this, input),
;;;170            0, "ArraySlice<Type>::Set", "Invalid objects");
;;;171    
;;;172          AnkiConditionalErrorAndReturnValue(this->get_array().get_buffer() != input.get_array().get_buffer(),
;;;173            0, "ArraySlice<Type>::Set", "Arrays must be in different memory locations");
;;;174    
;;;175          ArraySliceLimits_in1_out1<s32> limits(
;;;176            input.get_ySlice(), input.get_xSlice(), input.get_isTransposed(),
;;;177            this->get_ySlice(), this->get_xSlice());
;;;178    
;;;179          if(!limits.isValid) {
;;;180            if(automaticTranspose) {
;;;181              // If we're allowed to transpose, give it another shot
;;;182              limits = ArraySliceLimits_in1_out1<s32> (input.get_ySlice(), input.get_xSlice(), !input.get_isTransposed(), this->get_ySlice(), this->get_xSlice());
;;;183    
;;;184              if(!limits.isValid) {
;;;185                AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;186                return 0;
;;;187              }
;;;188            } else {
;;;189              AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;190              return 0;
;;;191            }
;;;192          }
;;;193    
;;;194          Array<Type> &out1Array = this->get_array();
;;;195          const Array<InType> &in1Array = input.get_array();
;;;196    
;;;197          if(limits.isSimpleIteration) {
;;;198            // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;199    
;;;200            for(s32 y=0; y<limits.ySize; y++) {
;;;201              const InType * restrict pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;202              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;203    
;;;204              limits.OuterIncrementTop();
;;;205    
;;;206              for(s32 x=0; x<limits.xSize; x++) {
;;;207                pOut1[limits.out1X] = static_cast<Type>( pIn1[limits.in1X] );
;;;208    
;;;209                limits.out1X += limits.out1_xInnerIncrement;
;;;210                limits.in1X += limits.in1_xInnerIncrement;
;;;211              }
;;;212    
;;;213              limits.OuterIncrementBottom();
;;;214            }
;;;215          } else {
;;;216            for(s32 y=0; y<limits.ySize; y++) {
;;;217              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;218    
;;;219              limits.OuterIncrementTop();
;;;220    
;;;221              for(s32 x=0; x<limits.xSize; x++) {
;;;222                const InType pIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;223    
;;;224                pOut1[limits.out1X] = static_cast<Type>( pIn1 );
;;;225    
;;;226                limits.out1X += limits.out1_xInnerIncrement;
;;;227                limits.in1Y += limits.in1_yInnerIncrement;
;;;228              }
;;;229    
;;;230              limits.OuterIncrementBottom();
;;;231            }
;;;232          }
;;;233    
;;;234          return limits.ySize*limits.xSize;
;;;235        }
;;;236    
;;;237        template<typename Type> Array<Type>& ArraySlice<Type>::get_array()
;;;238        {
;;;239          return this->array;
;;;240        }
;;;241    
;;;242        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression()
;;;243          : ConstArraySlice<Type>(), isTransposed(false)
;;;244        {
;;;245        }
;;;246    
;;;247        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const Array<Type> input, bool isTransposed)
;;;248          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;249        {
;;;250        }
;;;251    
;;;252        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed)
;;;253          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;254        {
;;;255        }
;;;256    
;;;257        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed)
;;;258          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;259        {
;;;260        }
;;;261    
;;;262        template<typename Type> ConstArraySliceExpression<Type> ConstArraySliceExpression<Type>::Transpose() const
;;;263        {
;;;264          ConstArraySliceExpression<Type> expression(*this, !this->get_isTransposed());
;;;265    
;;;266          return expression;
;;;267        }
;;;268    
;;;269        template<typename Type> bool ConstArraySliceExpression<Type>::get_isTransposed() const
;;;270        {
;;;271          return isTransposed;
;;;272        }
;;;273    
;;;274        template<typename Type> ArraySliceSimpleLimits<Type>::ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;275          : xStart(in1_xSlice.get_start()), xIncrement(in1_xSlice.get_increment()), xSize(in1_xSlice.get_size()),
;;;276          yStart(in1_ySlice.get_start()), yIncrement(in1_ySlice.get_increment()), ySize(in1_ySlice.get_size())
;;;277        {
;;;278        }
;;;279    
;;;280        template<typename Type> ArraySliceLimits_in1_out0<Type>::ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;281          : isValid(true), rawIn1Limits(in1_ySlice, in1_xSlice)
;;;282        {
;;;283        } // ArraySliceLimits_in1_out0
;;;284    
;;;285        template<typename Type> ArraySliceLimits_in1_out1<Type>::ArraySliceLimits_in1_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;286          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;287          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;288          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed)
;;;289        {
;;;290          isValid = false;
;;;291    
;;;292          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;293    
;;;294          if(!in1_isTransposed) {
;;;295            if(rawOut1Limits.xSize == rawIn1Limits.xSize && rawOut1Limits.ySize == rawIn1Limits.ySize) {
;;;296              isValid = true;
;;;297              isSimpleIteration = true;
;;;298    
;;;299              this->in1Y = this->rawIn1Limits.yStart;
;;;300              this->out1Y = this->rawOut1Limits.yStart;
;;;301    
;;;302              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;303              this->in1_yInnerIncrement = 0;
;;;304            }
;;;305          } else { // if(!in1_isTransposed)
;;;306            if(rawOut1Limits.xSize == rawIn1Limits.ySize && rawOut1Limits.ySize == rawIn1Limits.xSize) {
;;;307              isValid = true;
;;;308              isSimpleIteration = false;
;;;309    
;;;310              this->in1X = this->rawIn1Limits.xStart;
;;;311              this->out1Y = this->rawOut1Limits.yStart;
;;;312    
;;;313              this->in1_xInnerIncrement = 0;
;;;314              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;315            }
;;;316          } // if(!in1_isTransposed) ... else
;;;317    
;;;318          if(!isValid) {
;;;319            AnkiError("ArraySliceLimits_in1_out1", "Subscripted assignment dimension mismatch");
;;;320            return;
;;;321          }
;;;322        } // ArraySliceLimits_in1_out1
;;;323    
;;;324        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;325        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;326        {
;;;327          if(isSimpleIteration) {
;;;328            this->in1X = this->rawIn1Limits.xStart;
;;;329            this->out1X = this->rawOut1Limits.xStart;
;;;330          } else { // if(isSimpleIteration)
;;;331            this->in1Y = this->rawIn1Limits.yStart;
;;;332            this->out1X = this->rawOut1Limits.xStart;
;;;333          } // if(isSimpleIteration) ... else
;;;334        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;335    
;;;336        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;337        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;338        {
;;;339          if(isSimpleIteration) {
;;;340            this->in1Y += this->rawIn1Limits.yIncrement;
;;;341            this->out1Y += this->rawOut1Limits.yIncrement;
;;;342          } else { // if(isSimpleIteration)
;;;343            this->in1X += this->rawIn1Limits.xIncrement;
;;;344            this->out1Y += this->rawOut1Limits.yIncrement;
;;;345          } // if(isSimpleIteration) ... else
;;;346        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;347    
;;;348        template<typename Type> ArraySliceLimits_in2_out1<Type>::ArraySliceLimits_in2_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;349          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;350          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;351          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed),
;;;352          rawIn2Limits(in2_ySlice, in2_xSlice), in2_isTransposed(in2_isTransposed)
;;;353        {
;;;354          isValid = false;
;;;355    
;;;356          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;357          this->in1_yInnerIncrement = 0;
;;;358          this->in1_xInnerIncrement = 0;
;;;359          this->in2_yInnerIncrement = 0;
;;;360          this->in2_xInnerIncrement = 0;
;;;361    
;;;362          if(!in1_isTransposed && !in2_isTransposed) {
;;;363            const bool sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;364    
;;;365            if(sizesMatch) {
;;;366              isValid = true;
;;;367              isSimpleIteration = true;
;;;368    
;;;369              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;370              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;371    
;;;372              this->in1Y = this->rawIn1Limits.yStart;
;;;373              this->in2Y = this->rawIn2Limits.yStart;
;;;374              this->out1Y = this->rawOut1Limits.yStart;
;;;375            }
;;;376          } else { // if(!in1_isTransposed)
;;;377            isSimpleIteration = false;
;;;378    
;;;379            bool sizesMatch = false;
;;;380    
;;;381            if(in1_isTransposed && in2_isTransposed) {
;;;382              sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;383              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;384              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;385            } else if(in1_isTransposed) {
;;;386              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;387              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;388              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;389            } else if(in2_isTransposed) {
;;;390              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;391              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;392              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;393            } else {
;;;394              AnkiAssert(false); // should not be possible
;;;395            }
;;;396    
;;;397            if(!sizesMatch) {
;;;398              AnkiError("ArraySliceLimits_in2_out1", "Subscripted assignment dimension mismatch");
;;;399              return;
;;;400            }
;;;401    
;;;402            isValid = true;
;;;403    
;;;404            this->in1X = this->rawIn1Limits.xStart;
;;;405            this->in1Y = this->rawIn1Limits.yStart;
;;;406            this->in2X = this->rawIn2Limits.xStart;
;;;407            this->in2Y = this->rawIn2Limits.yStart;
;;;408    
;;;409            this->out1Y = this->rawOut1Limits.yStart;
;;;410          } // if(!in1_isTransposed) ... else
;;;411        } // ArraySliceLimits_in1_out1
;;;412    
;;;413        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;414        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;415        {
;;;416          if(isSimpleIteration) {
;;;417            this->out1X = this->rawOut1Limits.xStart;
;;;418            this->in1X = this->rawIn1Limits.xStart;
;;;419            this->in2X = this->rawIn2Limits.xStart;
;;;420          } else { // if(isSimpleIteration)
;;;421            this->out1X = this->rawOut1Limits.xStart;
;;;422    
;;;423            if(in1_isTransposed) {
;;;424              this->in1Y = this->rawIn1Limits.yStart;
;;;425            } else {
;;;426              this->in1X = this->rawIn1Limits.xStart;
;;;427            }
;;;428    
;;;429            if(in2_isTransposed) {
;;;430              this->in2Y = this->rawIn2Limits.yStart;
;;;431            } else {
;;;432              this->in2X = this->rawIn2Limits.xStart;
;;;433            }
;;;434          } // if(isSimpleIteration) ... else
;;;435        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;436    
;;;437        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;438        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;439        {
;;;440          if(isSimpleIteration) {
;;;441            this->in1Y += this->rawIn1Limits.yIncrement;
;;;442            this->in2Y += this->rawIn2Limits.yIncrement;
;;;443            this->out1Y += this->rawOut1Limits.yIncrement;
;;;444          } else { // if(isSimpleIteration)
;;;445            this->out1Y += this->rawOut1Limits.yIncrement;
;;;446    
;;;447            if(in1_isTransposed) {
;;;448              this->in1X += this->rawIn1Limits.xIncrement;
;;;449            } else {
;;;450              this->in1Y += this->rawIn1Limits.yIncrement;
;;;451            }
;;;452    
;;;453            if(in2_isTransposed) {
;;;454              this->in2X += this->rawIn2Limits.xIncrement;
;;;455            } else {
;;;456              this->in2Y += this->rawIn2Limits.yIncrement;
;;;457            }
;;;458          } // if(isSimpleIteration) ... else
;;;459        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;460      } // namespace Embedded
;;;461    } // namespace Anki
;;;462    
;;;463    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;19     #include "anki/common/robot/benchmarking.h"
;;;1      /**
;;;2      File: benchmarkins.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Low-overhead benchmarking, based on a list of start and end events.
;;;7      
;;;8      The basic use of this benchmarking utility is as follows:
;;;9      1. InitBenchmarking()
;;;10     2. At the beginning of the section you want to benchmark, put BeginBenchmark("event type");
;;;11     3. At the end of the section you want to benchmark, put EndBenchmark("event type");
;;;12     4. When you're done running the program, call PrintBenchmarkResults() to print the results
;;;13     
;;;14     Copyright Anki, Inc. 2013
;;;15     For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;16     **/
;;;17     
;;;18     #ifndef _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;19     #define _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     
;;;21     #include "anki/common/robot/config.h"
;;;1      /**
;;;22     #include "anki/common/robot/fixedLengthList_declarations.h"
;;;1      /**
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         const s32 MAX_BENCHMARK_EVENTS = 16000;
;;;29     
;;;30         typedef struct BenchmarkElement
;;;31         {
;;;32           // All times in microseconds, on all platforms
;;;33     
;;;34           static const s32 NAME_LENGTH = 64;
;;;35     
;;;36           // Inclusive includes all the time for all sub-benchmarks
;;;37           u32 inclusive_mean;
;;;38           u32 inclusive_min;
;;;39           u32 inclusive_max;
;;;40           u32 inclusive_total;
;;;41     
;;;42           // Exclusive does not include sub-benchmarks
;;;43           u32 exclusive_mean;
;;;44           u32 exclusive_min;
;;;45           u32 exclusive_max;
;;;46           u32 exclusive_total;
;;;47     
;;;48           // How many times was this element's name benchmarked?
;;;49           u32 numEvents;
;;;50     
;;;51           char name[BenchmarkElement::NAME_LENGTH];
;;;52     
;;;53           BenchmarkElement(const char * name);
;;;54     
;;;55           // Print with CoreTechPrint()
;;;56           void Print(const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;57     
;;;58           // Like snprintf(). Returns the number of characters printed, not including the final null byte.
;;;59           s32 Snprint(char * buffer, const s32 bufferLength, const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;60         } BenchmarkElement;
;;;61     
;;;62         typedef struct ShowBenchmarkParameters
;;;63         {
;;;64           char name[BenchmarkElement::NAME_LENGTH];
;;;65           bool showExclusiveTime;
;;;66           u8 red, green, blue;
;;;67     
;;;68           ShowBenchmarkParameters(
;;;69             const char * name,
;;;70             const bool showExclusiveTime,
;;;71             const u8 *color); //< Color is {R,G,B}
;;;72         } ShowBenchmarkParameters;
;;;73     
;;;74         // Call this before doing any benchmarking, to clear the buffer of benchmarkEvents.
;;;75         // Can be called multiple times.
;;;76         void InitBenchmarking();
;;;77     
;;;78         // Use these functions to add a new event to the list. These functions are very fast.
;;;79         //
;;;80         // WARNING: name must be in globally available memory
;;;81         //
;;;82         // WARNING: the character string must be less than BenchmarkElement::NAME_LENGTH bytes
;;;83         //
;;;84         // WARNING: Using the same name for different benchmark events
;;;85         //
;;;86         // WARNING: nesting BeginBenchmark() and EndBenchmark() events that have the same name won't work.
;;;87         // This is okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("b"); EndBenchmark("a");
;;;88         // This is not okay: BeginBenchmark("a"); BeginBenchmark("a"); EndBenchmark("a"); EndBenchmark("a");
;;;89         // This is not okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("a"); EndBenchmark("b");
;;;90         void BeginBenchmark(const char *name);
;;;91         void EndBenchmark(const char *name);
;;;92     
;;;93         // Compile all the benchmark events that were recorded
;;;94         FixedLengthList<BenchmarkElement> ComputeBenchmarkResults(MemoryStack &memory);
;;;95     
;;;96         // CoreTechPrint() the benchmark results
;;;97         // WARNING: This doesn't work well with multi-threaded programs
;;;98         Result PrintBenchmarkResults(const FixedLengthList<BenchmarkElement> &results, const bool verbose=true, const bool microseconds=true);
;;;99     
;;;100        // Compile and print out all the benchmark events that were recorded
;;;101        Result ComputeAndPrintBenchmarkResults(const bool verbose, const bool microseconds, MemoryStack scratch);
;;;102    
;;;103        // Use OpenCV to display a running benchmark
;;;104        // Requires a "TotalTime" benchmark event
;;;105        // namesToDisplay can be 11 or less names
;;;106        Result ShowBenchmarkResults(
;;;107          const FixedLengthList<BenchmarkElement> &results,
;;;108          const FixedLengthList<ShowBenchmarkParameters> &namesToDisplay,
;;;109          const f32 pixelsPerMillisecond,
;;;110          const s32 imageHeight,
;;;111          const s32 imageWidth);
;;;112    
;;;113        s32 GetNameIndex(const char * name, const FixedLengthList<BenchmarkElement> &outputResults);
;;;114      } // namespace Embedded
;;;115    } // namespace Anki
;;;116    
;;;117    #endif // _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     #include "anki/common/robot/comparisons.h"
;;;1      /**
;;;2      File: comparisons.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of comparisons_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;14     
;;;15     #include "anki/common/robot/comparisons_declarations.h"
;;;1      /**
;;;2      File: comparisons_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various elementwise tests, to ensure that the data of two Arrays is equal.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Declarations ---
;;;23         // Check every element of this array against the input array. If the arrays are different
;;;24         // sizes, uninitialized, or if any element is more different than the threshold, then
;;;25         // return false.
;;;26         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold = static_cast<Type>(0.0001));
;;;27     
;;;28         // Check every element of this array against the input array. If the arrays are different
;;;29         // sizes or uninitialized, return false. The percentThreshold is between 0.0 and 1.0. To
;;;30         // return false, an element must fail both thresholds. The percent threshold fails if an
;;;31         // element is more than a percentage different than its matching element (calulated from the
;;;32         // maximum of the two).
;;;33         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold = 0.01, const double absoluteThreshold = 0.0001);
;;;34     
;;;35         // If any of the input objects are not valid, then return false
;;;36         // NOTE: the objects must have an IsValid() method
;;;37         template<typename Type1> bool AreValid(const Type1 &object1);
;;;38         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2);
;;;39         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;40         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;41         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;42         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;43         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;44         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;45         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;46     
;;;47         // If the objects have different sizes or are uninitialized, then return false.
;;;48         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;49         template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2);
;;;50         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;51         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;52         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;53         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;54         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;55         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;56         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;57     
;;;58         // Check sizes against an input height and width
;;;59         template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1);
;;;60         template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2);
;;;61         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;62         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;63         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;64         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;65         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;66         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;67         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;68     
;;;69         // If the Arrays are aliased (pointing to the same location in memory) or uninitialized, then return false
;;;70         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;71         template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2);
;;;72         template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;73         template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;74         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;75         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;76         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;77         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;78         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;79       } // namespace Embedded
;;;80     } // namespace Anki
;;;81     
;;;82     #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark
;;;23     
;;;24         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold)
;;;25         {
;;;26           if(!AreEqualSize(array1, array2))
;;;27             return false;
;;;28     
;;;29           const s32 height = array1.get_size(0);
;;;30           const s32 width = array1.get_size(1);
;;;31     
;;;32           for(s32 y=0; y<height; y++) {
;;;33             const Type * const pArray1 = array1.Pointer(y, 0);
;;;34             const Type * const pArray2 = array2.Pointer(y, 0);
;;;35             for(s32 x=0; x<width; x++) {
;;;36               if(pArray1[x] > pArray2[x]) {
;;;37                 if((pArray1[x] - pArray2[x]) > threshold)
;;;38                   return false;
;;;39               } else {
;;;40                 if((pArray2[x] - pArray1[x]) > threshold)
;;;41                   return false;
;;;42               }
;;;43             }
;;;44           }
;;;45     
;;;46           return true;
;;;47         }
;;;48     
;;;49         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold, const double absoluteThreshold)
;;;50         {
;;;51           if(!AreEqualSize(array1, array2))
;;;52             return false;
;;;53     
;;;54           const s32 height = array1.get_size(0);
;;;55           const s32 width = array1.get_size(1);
;;;56     
;;;57           for(s32 y=0; y<height; y++) {
;;;58             const Type * const pArray1 = array1.Pointer(y, 0);
;;;59             const Type * const pArray2 = array2.Pointer(y, 0);
;;;60             for(s32 x=0; x<width; x++) {
;;;61               const double value1 = static_cast<double>(pArray1[x]);
;;;62               const double value2 = static_cast<double>(pArray2[x]);
;;;63               const double percentThresholdValue = percentThreshold * MAX(value1,value2);
;;;64     
;;;65               if(fabs(value1 - value2) > percentThresholdValue && fabs(value1 - value2) > absoluteThreshold)
;;;66                 return false;
;;;67             }
;;;68           }
;;;69     
;;;70           return true;
;;;71         }
;;;72     
;;;73         template<typename Type1> bool AreValid(const Type1 &object1)
;;;74         {
;;;75           if(!object1.IsValid())
;;;76             return false;
;;;77     
;;;78           return true;
;;;79         }
;;;80     
;;;81         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2)
;;;82         {
;;;83           if(!object1.IsValid() || !object2.IsValid())
;;;84             return false;
;;;85     
;;;86           return true;
;;;87         }
;;;88     
;;;89         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;90         {
;;;91           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid())
;;;92             return false;
;;;93     
;;;94           return true;
;;;95         }
;;;96     
;;;97         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;98         {
;;;99           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid())
;;;100            return false;
;;;101    
;;;102          return true;
;;;103        }
;;;104    
;;;105        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;106        {
;;;107          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid())
;;;108            return false;
;;;109    
;;;110          return true;
;;;111        }
;;;112    
;;;113        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;114        {
;;;115          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid())
;;;116            return false;
;;;117    
;;;118          return true;
;;;119        }
;;;120    
;;;121        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;122        {
;;;123          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid())
;;;124            return false;
;;;125    
;;;126          return true;
;;;127        }
;;;128    
;;;129        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;130        {
;;;131          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid())
;;;132            return false;
;;;133    
;;;134          return true;
;;;135        }
;;;136    
;;;137        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;138        {
;;;139          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid() || !object9.IsValid())
;;;140            return false;
;;;141    
;;;142          return true;
;;;143        }
;;;144    
;;;145        template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2)
;;;146        {
;;;147          if(!AreValid(object1, object2))
;;;148            return false;
;;;149    
;;;150          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1))
;;;151            return false;
;;;152    
;;;153          return true;
;;;154        }
;;;155    
;;;156        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;157        {
;;;158          if(!AreValid(object1, object2, object3))
;;;159            return false;
;;;160    
;;;161          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;162            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1))
;;;163            return false;
;;;164    
;;;165          return true;
;;;166        }
;;;167    
;;;168        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;169        {
;;;170          if(!AreValid(object1, object2, object3, object4))
;;;171            return false;
;;;172    
;;;173          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;174            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;175            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1))
;;;176            return false;
;;;177    
;;;178          return true;
;;;179        }
;;;180    
;;;181        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;182        {
;;;183          if(!AreValid(object1, object2, object3, object4, object5))
;;;184            return false;
;;;185    
;;;186          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;187            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;188            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;189            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1))
;;;190            return false;
;;;191    
;;;192          return true;
;;;193        }
;;;194    
;;;195        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;196        {
;;;197          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;198            return false;
;;;199    
;;;200          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;201            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;202            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;203            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;204            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1))
;;;205            return false;
;;;206    
;;;207          return true;
;;;208        }
;;;209    
;;;210        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;211        {
;;;212          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;213            return false;
;;;214    
;;;215          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;216            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;217            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;218            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;219            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;220            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1))
;;;221            return false;
;;;222    
;;;223          return true;
;;;224        }
;;;225    
;;;226        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;227        {
;;;228          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;229            return false;
;;;230    
;;;231          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;232            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;233            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;234            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;235            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;236            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;237            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1))
;;;238            return false;
;;;239    
;;;240          return true;
;;;241        }
;;;242    
;;;243        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;244        {
;;;245          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;246            return false;
;;;247    
;;;248          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;249            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;250            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;251            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;252            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;253            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;254            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1) ||
;;;255            object1.get_size(0) != object9.get_size(0) || object1.get_size(1) != object9.get_size(1))
;;;256            return false;
;;;257    
;;;258          return true;
;;;259        }
;;;260    
;;;261        template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1)
;;;262        {
;;;263          if(!AreValid(object1))
;;;264            return false;
;;;265    
;;;266          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;267            return false;
;;;268    
;;;269          return true;
;;;270        }
;;;271    
;;;272        template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2)
;;;273        {
;;;274          if(!AreValid(object1, object2))
;;;275            return false;
;;;276    
;;;277          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;278            return false;
;;;279    
;;;280          return AreEqualSize(object1, object2);
;;;281        }
;;;282    
;;;283        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;284        {
;;;285          if(!AreValid(object1, object2, object3))
;;;286            return false;
;;;287    
;;;288          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;289            return false;
;;;290    
;;;291          return AreEqualSize(object1, object2, object3);
;;;292        }
;;;293    
;;;294        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;295        {
;;;296          if(!AreValid(object1, object2, object3, object4))
;;;297            return false;
;;;298    
;;;299          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;300            return false;
;;;301    
;;;302          return AreEqualSize(object1, object2, object3, object4);
;;;303        }
;;;304    
;;;305        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;306        {
;;;307          if(!AreValid(object1, object2, object3, object4, object5))
;;;308            return false;
;;;309    
;;;310          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;311            return false;
;;;312    
;;;313          return AreEqualSize(object1, object2, object3, object4, object5);
;;;314        }
;;;315    
;;;316        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;317        {
;;;318          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;319            return false;
;;;320    
;;;321          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;322            return false;
;;;323    
;;;324          return AreEqualSize(object1, object2, object3, object4, object5, object6);
;;;325        }
;;;326    
;;;327        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;328        {
;;;329          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;330            return false;
;;;331    
;;;332          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;333            return false;
;;;334    
;;;335          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7);
;;;336        }
;;;337    
;;;338        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;339        {
;;;340          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;341            return false;
;;;342    
;;;343          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;344            return false;
;;;345    
;;;346          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8);
;;;347        }
;;;348    
;;;349        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;350        {
;;;351          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;352            return false;
;;;353    
;;;354          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;355            return false;
;;;356    
;;;357          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8, object9);
;;;358        }
;;;359    
;;;360        template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2)
;;;361        {
;;;362          if(!AreValid(object1, object2))
;;;363            return false;
;;;364    
;;;365          const size_t bufferPointers[] = {
;;;366            reinterpret_cast<size_t>(object1.get_buffer()),
;;;367            reinterpret_cast<size_t>(object2.get_buffer())};
;;;368    
;;;369          for(s32 i=0; i<2; i++) {
;;;370            for(s32 j=i+1; j<2; j++) {
;;;371              if(bufferPointers[i] == bufferPointers[j])
;;;372                return false;
;;;373            }
;;;374          }
;;;375    
;;;376          return true;
;;;377        }
;;;378    
;;;379        template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;380        {
;;;381          if(!AreValid(object1, object2, object3))
;;;382            return false;
;;;383    
;;;384          const size_t bufferPointers[] = {
;;;385            reinterpret_cast<size_t>(object1.get_buffer()),
;;;386            reinterpret_cast<size_t>(object2.get_buffer()),
;;;387            reinterpret_cast<size_t>(object3.get_buffer())};
;;;388    
;;;389          for(s32 i=0; i<3; i++) {
;;;390            for(s32 j=i+1; j<3; j++) {
;;;391              if(bufferPointers[i] == bufferPointers[j])
;;;392                return false;
;;;393            }
;;;394          }
;;;395    
;;;396          return true;
;;;397        }
;;;398    
;;;399        template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;400        {
;;;401          if(!AreValid(object1, object2, object3, object4))
;;;402            return false;
;;;403    
;;;404          const size_t bufferPointers[] = {
;;;405            reinterpret_cast<size_t>(object1.get_buffer()),
;;;406            reinterpret_cast<size_t>(object2.get_buffer()),
;;;407            reinterpret_cast<size_t>(object3.get_buffer()),
;;;408            reinterpret_cast<size_t>(object4.get_buffer())};
;;;409    
;;;410          for(s32 i=0; i<4; i++) {
;;;411            for(s32 j=i+1; j<4; j++) {
;;;412              if(bufferPointers[i] == bufferPointers[j])
;;;413                return false;
;;;414            }
;;;415          }
;;;416    
;;;417          return true;
;;;418        }
;;;419    
;;;420        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;421        {
;;;422          if(!AreValid(object1, object2, object3, object4, object5))
;;;423            return false;
;;;424    
;;;425          const size_t bufferPointers[] = {
;;;426            reinterpret_cast<size_t>(object1.get_buffer()),
;;;427            reinterpret_cast<size_t>(object2.get_buffer()),
;;;428            reinterpret_cast<size_t>(object3.get_buffer()),
;;;429            reinterpret_cast<size_t>(object4.get_buffer()),
;;;430            reinterpret_cast<size_t>(object5.get_buffer())};
;;;431    
;;;432          for(s32 i=0; i<5; i++) {
;;;433            for(s32 j=i+1; j<5; j++) {
;;;434              if(bufferPointers[i] == bufferPointers[j])
;;;435                return false;
;;;436            }
;;;437          }
;;;438    
;;;439          return true;
;;;440        }
;;;441    
;;;442        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;443        {
;;;444          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;445            return false;
;;;446    
;;;447          const size_t bufferPointers[] = {
;;;448            reinterpret_cast<size_t>(object1.get_buffer()),
;;;449            reinterpret_cast<size_t>(object2.get_buffer()),
;;;450            reinterpret_cast<size_t>(object3.get_buffer()),
;;;451            reinterpret_cast<size_t>(object4.get_buffer()),
;;;452            reinterpret_cast<size_t>(object5.get_buffer()),
;;;453            reinterpret_cast<size_t>(object6.get_buffer())};
;;;454    
;;;455          for(s32 i=0; i<6; i++) {
;;;456            for(s32 j=i+1; j<6; j++) {
;;;457              if(bufferPointers[i] == bufferPointers[j])
;;;458                return false;
;;;459            }
;;;460          }
;;;461    
;;;462          return true;
;;;463        }
;;;464    
;;;465        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;466        {
;;;467          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;468            return false;
;;;469    
;;;470          const size_t bufferPointers[] = {
;;;471            reinterpret_cast<size_t>(object1.get_buffer()),
;;;472            reinterpret_cast<size_t>(object2.get_buffer()),
;;;473            reinterpret_cast<size_t>(object3.get_buffer()),
;;;474            reinterpret_cast<size_t>(object4.get_buffer()),
;;;475            reinterpret_cast<size_t>(object5.get_buffer()),
;;;476            reinterpret_cast<size_t>(object6.get_buffer()),
;;;477            reinterpret_cast<size_t>(object7.get_buffer())};
;;;478    
;;;479          for(s32 i=0; i<7; i++) {
;;;480            for(s32 j=i+1; j<7; j++) {
;;;481              if(bufferPointers[i] == bufferPointers[j])
;;;482                return false;
;;;483            }
;;;484          }
;;;485    
;;;486          return true;
;;;487        }
;;;488    
;;;489        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;490        {
;;;491          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;492            return false;
;;;493    
;;;494          const size_t bufferPointers[] = {
;;;495            reinterpret_cast<size_t>(object1.get_buffer()),
;;;496            reinterpret_cast<size_t>(object2.get_buffer()),
;;;497            reinterpret_cast<size_t>(object3.get_buffer()),
;;;498            reinterpret_cast<size_t>(object4.get_buffer()),
;;;499            reinterpret_cast<size_t>(object5.get_buffer()),
;;;500            reinterpret_cast<size_t>(object6.get_buffer()),
;;;501            reinterpret_cast<size_t>(object7.get_buffer()),
;;;502            reinterpret_cast<size_t>(object8.get_buffer())};
;;;503    
;;;504          for(s32 i=0; i<8; i++) {
;;;505            for(s32 j=i+1; j<8; j++) {
;;;506              if(bufferPointers[i] == bufferPointers[j])
;;;507                return false;
;;;508            }
;;;509          }
;;;510    
;;;511          return true;
;;;512        }
;;;513    
;;;514        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;515        {
;;;516          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;517            return false;
;;;518    
;;;519          const size_t bufferPointers[] = {
;;;520            reinterpret_cast<size_t>(object1.get_buffer()),
;;;521            reinterpret_cast<size_t>(object2.get_buffer()),
;;;522            reinterpret_cast<size_t>(object3.get_buffer()),
;;;523            reinterpret_cast<size_t>(object4.get_buffer()),
;;;524            reinterpret_cast<size_t>(object5.get_buffer()),
;;;525            reinterpret_cast<size_t>(object6.get_buffer()),
;;;526            reinterpret_cast<size_t>(object7.get_buffer()),
;;;527            reinterpret_cast<size_t>(object8.get_buffer()),
;;;528            reinterpret_cast<size_t>(object9.get_buffer()) };
;;;529    
;;;530          for(s32 i=0; i<9; i++) {
;;;531            for(s32 j=i+1; j<9; j++) {
;;;532              if(bufferPointers[i] == bufferPointers[j])
;;;533                return false;
;;;534            }
;;;535          }
;;;536    
;;;537          return true;
;;;538        }
;;;539      } // namespace Embedded
;;;540    } // namespace Anki
;;;541    
;;;542    #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26         namespace Matrix
;;;27         {
;;;28           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;29           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;30           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;31           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;32     
;;;33           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;34           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;35           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;36           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;37     
;;;38           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;39           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;40           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;41           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;42     
;;;43           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;44           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;45           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;46           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;47     
;;;48           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;49           {
;;;50             const Array<Type> &array = mat.get_array();
;;;51     
;;;52             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;53               0, "Matrix::Min", "Array<Type> is not valid");
;;;54     
;;;55             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;56     
;;;57             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;58               0, "Matrix::Min", "Limits is not valid");
;;;59     
;;;60             Type minValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;61             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;62               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;63               const Type * restrict pMat = array.Pointer(y, 0);
;;;64     
;;;65               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;66                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;67                 minValue = MIN(minValue, pMat[x]);
;;;68               }
;;;69             }
;;;70     
;;;71             return minValue;
;;;72           } // template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;73     
;;;74           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;75           {
;;;76             const Array<Type> &array = mat.get_array();
;;;77     
;;;78             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;79               0, "Matrix::Max", "Array<Type> is not valid");
;;;80     
;;;81             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;82     
;;;83             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;84               0, "Matrix::Max", "Limits is not valid");
;;;85     
;;;86             Type maxValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;87             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;88               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;89               const Type * restrict pMat = array.Pointer(y, 0);
;;;90     
;;;91               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;92                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;93                 maxValue = MAX(maxValue, pMat[x]);
;;;94               }
;;;95             }
;;;96     
;;;97             return maxValue;
;;;98           } // template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;99     
;;;100          template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat)
;;;101          {
;;;102            const Array<Array_Type> &array = mat.get_array();
;;;103    
;;;104            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;105              0, "Matrix::Sum", "Array<Type> is not valid");
;;;106    
;;;107            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;108    
;;;109            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;110              0, "Matrix::Sum", "Limits is not valid");
;;;111    
;;;112            Accumulator_Type sum = 0;
;;;113            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;114              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;115              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;116    
;;;117              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;118                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;119                sum += pMat[x];
;;;120              }
;;;121            }
;;;122    
;;;123            return sum;
;;;124          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;125    
;;;126          template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;127          {
;;;128            const Accumulator_Type sum = Sum<Array_Type,Accumulator_Type>(mat);
;;;129            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;130            const Array_Type mean = static_cast<Array_Type>(sum / numElements);
;;;131    
;;;132            return mean;
;;;133          } // template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;134    
;;;135          template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(
;;;136            const ConstArraySliceExpression<Array_Type> &mat,
;;;137            Accumulator_Type& mean,
;;;138            Accumulator_Type& var)
;;;139          {
;;;140            const Array<Array_Type> &array = mat.get_array();
;;;141    
;;;142            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;143              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Array<Type> is not valid");
;;;144    
;;;145            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;146    
;;;147            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;148              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Limits is not valid");
;;;149    
;;;150            Accumulator_Type sum = 0;
;;;151            Accumulator_Type sumSq = 0;
;;;152            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;153              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;154              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;155    
;;;156              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;157                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;158                const Accumulator_Type val = static_cast<Accumulator_Type>(pMat[x]);
;;;159                sum   += val;
;;;160                sumSq += val*val;
;;;161              }
;;;162            }
;;;163    
;;;164            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;165    
;;;166            mean = sum / numElements;                  // mean = E[x]
;;;167            var  = (sumSq / numElements) - (mean*mean);  // var  = E[x^2] - E[x]^2
;;;168    
;;;169            return RESULT_OK;
;;;170          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;171    
;;;172          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;173          {
;;;174            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;175          } // template<typename Type> Result Add(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;176    
;;;177          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;178          {
;;;179            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;180          }
;;;181    
;;;182          template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;183          {
;;;184            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;185          }
;;;186    
;;;187          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;188          {
;;;189            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;190          } // template<typename Type> Result Subtract(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;191    
;;;192          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;193          {
;;;194            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;195          }
;;;196    
;;;197          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;198          {
;;;199            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;200          }
;;;201    
;;;202          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;203          {
;;;204            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;205          } // template<typename Type> Result DotMultiply(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;206    
;;;207          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;208          {
;;;209            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;210          }
;;;211    
;;;212          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;213          {
;;;214            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;215          }
;;;216    
;;;217          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;218          {
;;;219            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;220          } // template<typename Type> Result DotDivide(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;221    
;;;222          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;223          {
;;;224            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;225          }
;;;226    
;;;227          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;228          {
;;;229            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;230          }
;;;231    
;;;232          template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;233          {
;;;234            return Elementwise::ApplyOperation<InType, Elementwise::Exp<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;235          } // template<typename Type> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;236    
;;;237          template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;238          {
;;;239            return Elementwise::ApplyOperation<InType, Elementwise::Sqrt<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;240          }
;;;241    
;;;242          template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;243          {
;;;244            const s32 in1Height = in1.get_size(0);
;;;245            const s32 in1Width = in1.get_size(1);
;;;246    
;;;247            const s32 in2Height = in2.get_size(0);
;;;248            const s32 in2Width = in2.get_size(1);
;;;249            const s32 in2Stride = in2.get_stride();
;;;250    
;;;251            AnkiConditionalErrorAndReturnValue(in1Width == in2Height,
;;;252              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;253    
;;;254            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2Width, out),
;;;255              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;256    
;;;257            for(s32 y1=0; y1<in1Height; y1++) {
;;;258              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;259              OutType * restrict pOut = out.Pointer(y1, 0);
;;;260    
;;;261              for(s32 x2=0; x2<in2Width; x2++) {
;;;262                const u8 * restrict pIn2 = reinterpret_cast<const u8*>(in2.Pointer(0, x2));
;;;263    
;;;264                OutType accumulator = 0;
;;;265    
;;;266                s32 y2;
;;;267                for(y2=0; y2<in2Height-3; y2+=4) {
;;;268                  const InType in1_0 = pIn1[y2];
;;;269                  const InType in1_1 = pIn1[y2+1];
;;;270                  const InType in1_2 = pIn1[y2+2];
;;;271                  const InType in1_3 = pIn1[y2+3];
;;;272    
;;;273                  const InType in2_0 = *reinterpret_cast<const InType*>(pIn2);
;;;274                  const InType in2_1 = *reinterpret_cast<const InType*>(pIn2 + in2Stride);
;;;275                  const InType in2_2 = *reinterpret_cast<const InType*>(pIn2 + 2*in2Stride);
;;;276                  const InType in2_3 = *reinterpret_cast<const InType*>(pIn2 + 3*in2Stride);
;;;277    
;;;278                  accumulator +=
;;;279                    in1_0 * in2_0 +
;;;280                    in1_1 * in2_1 +
;;;281                    in1_2 * in2_2 +
;;;282                    in1_3 * in2_3;
;;;283    
;;;284                  pIn2 += 4*in2Stride;
;;;285                }
;;;286    
;;;287                for(; y2<in2Height; y2++) {
;;;288                  accumulator += pIn1[y2] * (*reinterpret_cast<const InType*>(pIn2));
;;;289    
;;;290                  pIn2 += in2Stride;
;;;291                }
;;;292    
;;;293                pOut[x2] = accumulator;
;;;294              }
;;;295            }
;;;296    
;;;297            return RESULT_OK;
;;;298          } // template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;299    
;;;300          template<typename InType, typename OutType> NO_INLINE Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;301          {
;;;302            const s32 in1Height = in1.get_size(0);
;;;303            const s32 in1Width = in1.get_size(1);
;;;304    
;;;305            const s32 in2TransposedHeight = in2Transposed.get_size(0);
;;;306            const s32 in2TransposedWidth = in2Transposed.get_size(1);
;;;307    
;;;308            AnkiConditionalErrorAndReturnValue(in1Width == in2TransposedWidth,
;;;309              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;310    
;;;311            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2TransposedHeight, out),
;;;312              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;313    
;;;314            for(s32 y1=0; y1<in1Height; y1++)
;;;315            {
;;;316              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;317    
;;;318              for(s32 y2=0; y2<in2TransposedHeight; y2++) {
;;;319                const InType * restrict pIn2 = in2Transposed.Pointer(y2, 0);
;;;320    
;;;321                OutType accumulator = 0;
;;;322    
;;;323                s32 x;
;;;324                for(x=0; x<in2TransposedWidth-3; x+=4) {
;;;325                  const InType in1_0 = pIn1[x];
;;;326                  const InType in1_1 = pIn1[x+1];
;;;327                  const InType in1_2 = pIn1[x+2];
;;;328                  const InType in1_3 = pIn1[x+3];
;;;329    
;;;330                  const InType in2_0 = pIn2[x];
;;;331                  const InType in2_1 = pIn2[x+1];
;;;332                  const InType in2_2 = pIn2[x+2];
;;;333                  const InType in2_3 = pIn2[x+3];
;;;334    
;;;335                  accumulator +=
;;;336                    in1_0 * in2_0 +
;;;337                    in1_1 * in2_1 +
;;;338                    in1_2 * in2_2 +
;;;339                    in1_3 * in2_3;
;;;340                }
;;;341    
;;;342                for(; x<in2TransposedWidth; x++) {
;;;343                  accumulator += pIn1[x] * pIn2[x];
;;;344                }
;;;345    
;;;346                *out.Pointer(y1, y2) = accumulator;
;;;347              }
;;;348            }
;;;349    
;;;350            return RESULT_OK;
;;;351          } // template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;352    
;;;353          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;354            Array<Type> &A_L,       //!< Input A Matrix and Output lower-triangular L matrix
;;;355            Array<Type> &Bt_Xt,     //!< Input B-transpose matrix and Output X-transpose solution
;;;356            bool realCholesky,      //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;357            bool &numericalFailure  //!< If true, the solver failed because of numerical instability
;;;358            )
;;;359          {
;;;360            const s32 matrixHeight = A_L.get_size(0);
;;;361            const s32 numSamples = Bt_Xt.get_size(0);
;;;362    
;;;363            numericalFailure = false;
;;;364    
;;;365            AnkiConditionalErrorAndReturnValue(AreValid(A_L, Bt_Xt),
;;;366              RESULT_FAIL_INVALID_OBJECT, "CholeskyDecomposition", "Invalid objects");
;;;367    
;;;368            AnkiConditionalErrorAndReturnValue(matrixHeight == A_L.get_size(1),
;;;369              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "A_L is not square");
;;;370    
;;;371            AnkiConditionalErrorAndReturnValue(Bt_Xt.get_size(1) == matrixHeight,
;;;372              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "Xt and Bt are the wrong sizes");
;;;373    
;;;374            // TODO: check if symmetric and positive-definite
;;;375    
;;;376            const Type minStableValue = Anki::Embedded::Flags::numeric_limits<Type>::epsilon();
;;;377    
;;;378            for(s32 i = 0; i < matrixHeight; i++) {
;;;379              // First, compute the non-diagonal values
;;;380              // This uses the results from the diagonal inverse computation from previous iterations of i
;;;381              Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;382    
;;;383              for(s32 j = 0; j < i; j++) {
;;;384                Type * restrict pAL_yj = A_L.Pointer(j, 0);
;;;385    
;;;386                Type sum = pAL_yi[j];
;;;387                for(s32 k = 0; k < j; k++) {
;;;388                  const Type value1 = pAL_yi[k];
;;;389                  const Type value2 = pAL_yj[k];
;;;390                  sum -= value1*value2;
;;;391                }
;;;392    
;;;393                pAL_yi[j] = sum*pAL_yj[j];
;;;394              } // for(s32 j = 0; j < i; j++)
;;;395    
;;;396              // Second, compute the inverse of the diagonal
;;;397              {
;;;398                Type sum = pAL_yi[i];
;;;399                for(s32 k = 0; k < i; k++) {
;;;400                  const Type value = pAL_yi[k];
;;;401                  sum -= value*value;
;;;402                }
;;;403    
;;;404                if(sum < minStableValue) {
;;;405                  numericalFailure = true;
;;;406                  return RESULT_OK;
;;;407                }
;;;408    
;;;409                // TODO: change this f32 square root to f64 if Type==f64
;;;410                const Type sumRoot = static_cast<Type>(sqrtf(static_cast<f32>(sum)));
;;;411                pAL_yi[i] = static_cast<Type>(1) / sumRoot;
;;;412              }
;;;413            } // for(s32 i = 0; i < m; i++)
;;;414    
;;;415            // Solve L*y = b via forward substitution
;;;416            for(s32 i = 0; i < matrixHeight; i++) {
;;;417              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;418              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;419    
;;;420              for(s32 j = 0; j < numSamples; j++) {
;;;421                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;422    
;;;423                Type sum = pBX_yj[i];
;;;424                for(s32 k = 0; k < i; k++) {
;;;425                  const Type value1 = pAL_yi[k];
;;;426                  const Type value2 = pBX_yj[k];
;;;427                  sum -= value1*value2;
;;;428                }
;;;429    
;;;430                pBX_yj[i] = sum*pAL_yi[i];
;;;431              }
;;;432            }
;;;433    
;;;434            // Solve L'*X = Y via back substitution
;;;435            for(s32 i = matrixHeight-1; i >= 0; i--) {
;;;436              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;437              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;438    
;;;439              for(s32 j = 0; j < numSamples; j++) {
;;;440                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;441    
;;;442                Type sum = pBX_yj[i];
;;;443                for(s32 k = matrixHeight-1; k > i; k-- ) {
;;;444                  const Type value1 = A_L[k][i];
;;;445                  const Type value2 = pBX_yj[k];
;;;446                  sum -= value1*value2;
;;;447                }
;;;448    
;;;449                pBX_yj[i] = sum*pAL_yi[i];
;;;450              }
;;;451            }
;;;452    
;;;453            if(realCholesky) {
;;;454              // Invert the diagonal values of L, and set upper triangular to zero
;;;455              for(s32 i = 0; i < matrixHeight; i++) {
;;;456                Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;457    
;;;458                pAL_yi[i] = static_cast<Type>(1) / pAL_yi[i];
;;;459    
;;;460                for(s32 j = i+1; j < matrixHeight; j++) {
;;;461                  pAL_yi[j] = 0;
;;;462                }
;;;463              }
;;;464            }
;;;465    
;;;466            return RESULT_OK;
;;;467          } // SolveLeastSquaresWithCholesky()
;;;468    
;;;469          template<typename Type> NO_INLINE Result EstimateHomography(
;;;470            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;471            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;472            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;473            bool &numericalFailure, //!< Did the homography solver fail?
;;;474            MemoryStack scratch //!< Scratch memory
;;;475            )
;;;476          {
;;;477            const Type MAX_SOLVE_DISTANCE = static_cast<Type>(0.1);
;;;478    
;;;479            //BeginBenchmark("EstimateHomography_init");
;;;480    
;;;481            const s32 numPoints = originalPoints.get_size();
;;;482    
;;;483            AnkiConditionalErrorAndReturnValue(AreValid(originalPoints, transformedPoints, homography, scratch),
;;;484              RESULT_FAIL_INVALID_OBJECT, "EstimateHomography", "Invalid objects");
;;;485    
;;;486            AnkiConditionalErrorAndReturnValue(transformedPoints.get_size() == numPoints && numPoints >= 4,
;;;487              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "originalPoints and transformedPoints must be the same size, and have at least four points apiece.");
;;;488    
;;;489            AnkiConditionalErrorAndReturnValue(AreEqualSize(3, 3, homography),
;;;490              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "homography must be 3x3");
;;;491    
;;;492            homography.SetZero();
;;;493            homography[0][0] = 1;
;;;494            homography[1][1] = 1;
;;;495            homography[2][2] = 1;
;;;496    
;;;497            Array<Type> A(8, 2*numPoints, scratch);
;;;498            Array<Type> bt(1, 2*numPoints, scratch);
;;;499    
;;;500            const Point<Type> * const pOriginalPoints = originalPoints.Pointer(0);
;;;501            const Point<Type> * const pTransformedPoints = transformedPoints.Pointer(0);
;;;502    
;;;503            Type * restrict pBt = bt.Pointer(0,0);
;;;504    
;;;505            //EndBenchmark("EstimateHomography_init");
;;;506    
;;;507            //BeginBenchmark("EstimateHomography_a&b");
;;;508    
;;;509            for(s32 i=0; i<numPoints; i++) {
;;;510              Type * restrict A_y1 = A.Pointer(2*i, 0);
;;;511              Type * restrict A_y2 = A.Pointer(2*i + 1, 0);
;;;512    
;;;513              const Type xi = pOriginalPoints[i].x;
;;;514              const Type yi = pOriginalPoints[i].y;
;;;515    
;;;516              const Type xp = pTransformedPoints[i].x;
;;;517              const Type yp = pTransformedPoints[i].y;
;;;518    
;;;519              A_y1[0] = 0;  A_y1[1] = 0;  A_y1[2] = 0; A_y1[3] = -xi; A_y1[4] = -yi; A_y1[5] = -1; A_y1[6] = xi*yp;  A_y1[7] = yi*yp;
;;;520              A_y2[0] = xi; A_y2[1] = yi; A_y2[2] = 1; A_y2[3] = 0;   A_y2[4] = 0;   A_y2[5] = 0;  A_y2[6] = -xi*xp; A_y2[7] = -yi*xp;
;;;521    
;;;522              pBt[2*i] = -yp;
;;;523              pBt[2*i + 1] = xp;
;;;524            }
;;;525    
;;;526            //EndBenchmark("EstimateHomography_a&b");
;;;527    
;;;528            //BeginBenchmark("EstimateHomography_At");
;;;529    
;;;530            Array<Type> At(2*numPoints, 8, scratch);
;;;531    
;;;532            Matrix::Transpose(A, At);
;;;533    
;;;534            //EndBenchmark("EstimateHomography_At");
;;;535    
;;;536            //BeginBenchmark("EstimateHomography_AtA");
;;;537    
;;;538            Array<Type> AtA(8, 8, scratch, Flags::Buffer(false,false,false));
;;;539            Array<Type> Atb(8, 1, scratch, Flags::Buffer(false,false,false));
;;;540    
;;;541            Matrix::Multiply(At, A, AtA);
;;;542    
;;;543            //EndBenchmark("EstimateHomography_AtA");
;;;544    
;;;545            //BeginBenchmark("EstimateHomography_Atb");
;;;546    
;;;547            Matrix::MultiplyTranspose(At, bt, Atb);
;;;548    
;;;549            //EndBenchmark("EstimateHomography_Atb");
;;;550    
;;;551            //BeginBenchmark("EstimateHomography_transposeAtb");
;;;552    
;;;553            Array<Type> Atbt(1, 8, scratch);
;;;554    
;;;555            Matrix::Transpose(Atb, Atbt);
;;;556    
;;;557            //EndBenchmark("EstimateHomography_transposeAtb");
;;;558    
;;;559            //BeginBenchmark("EstimateHomography_cholesky");
;;;560    
;;;561            const Result choleskyResult = SolveLeastSquaresWithCholesky(AtA, Atbt, false, numericalFailure);
;;;562    
;;;563            AnkiConditionalErrorAndReturnValue(choleskyResult == RESULT_OK,
;;;564              choleskyResult, "EstimateHomography", "SolveLeastSquaresWithCholesky failed");
;;;565    
;;;566            if(numericalFailure){
;;;567              AnkiWarn("EstimateHomography", "numericalFailure");
;;;568              return RESULT_OK;
;;;569            }
;;;570    
;;;571            Type * restrict pAtbt = Atbt.Pointer(0,0);
;;;572    
;;;573            homography[0][0] = pAtbt[0]; homography[0][1] = pAtbt[1]; homography[0][2] = pAtbt[2];
;;;574            homography[1][0] = pAtbt[3]; homography[1][1] = pAtbt[4]; homography[1][2] = pAtbt[5];
;;;575            homography[2][0] = pAtbt[6]; homography[2][1] = pAtbt[7]; homography[2][2] = static_cast<Type>(1);
;;;576    
;;;577            // Check that the solution is fairly close
;;;578            // TODO: make work for numPoints != 4
;;;579            if(numPoints == 4) {
;;;580              Array<Type> point1(3,1,scratch);
;;;581              Array<Type> point1Warped(3,1,scratch);
;;;582              for(s32 iPoint=0; iPoint<numPoints; iPoint++) {
;;;583                point1[0][0] = originalPoints[iPoint].x;
;;;584                point1[1][0] = originalPoints[iPoint].y;
;;;585                point1[2][0] = 1;
;;;586    
;;;587                Matrix::Multiply(homography, point1, point1Warped);
;;;588                point1Warped[0][0] /= point1Warped[2][0];
;;;589                point1Warped[1][0] /= point1Warped[2][0];
;;;590    
;;;591                const Type distance = sqrtf(powf(static_cast<f32>(transformedPoints[iPoint].x) - static_cast<f32>(point1Warped[0][0]), 2.0f) + powf(static_cast<f32>(transformedPoints[iPoint].y) - static_cast<f32>(point1Warped[1][0]), 2.0f));
;;;592    
;;;593                if(distance > MAX_SOLVE_DISTANCE) {
;;;594                  AnkiWarn("EstimateHomography", "Poor solution precision");
;;;595    
;;;596                  numericalFailure = true;
;;;597    
;;;598                  homography.SetZero();
;;;599                  homography[0][0] = 1;
;;;600                  homography[1][1] = 1;
;;;601                  homography[2][2] = 1;
;;;602    
;;;603                  return RESULT_OK;
;;;604                }
;;;605              }
;;;606            }
;;;607            //EndBenchmark("EstimateHomography_cholesky");
;;;608    
;;;609            return RESULT_OK;
;;;610          } // EstimateHomography()
;;;611    
;;;612          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;613          {
;;;614            const s32 inHeight = in.get_size(0);
;;;615            const s32 inWidth = in.get_size(1);
;;;616    
;;;617            const s32 outHeight = out.get_size(0);
;;;618            const s32 outWidth = out.get_size(1);
;;;619    
;;;620            AnkiConditionalErrorAndReturnValue((inHeight*inWidth) == (outHeight*outWidth),
;;;621              RESULT_FAIL_INVALID_SIZE, "Reshape", "Input and Output matrices are incompatible sizes");
;;;622    
;;;623            s32 inIndexY = 0;
;;;624            s32 inIndexX = 0;
;;;625    
;;;626            if(isColumnMajor) {
;;;627              for(s32 y = 0; y < outHeight; y++)
;;;628              {
;;;629                OutType * const pOut = out.Pointer(y,0);
;;;630    
;;;631                for(s32 x = 0; x < outWidth; x++) {
;;;632                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;633    
;;;634                  pOut[x] = static_cast<OutType>(curIn);
;;;635    
;;;636                  inIndexY++;
;;;637                  if(inIndexY >= inHeight) {
;;;638                    inIndexY = 0;
;;;639                    inIndexX++;
;;;640                  }
;;;641                }
;;;642              }
;;;643            } else { // if(isColumnMajor)
;;;644              for(s32 y = 0; y < outHeight; y++)
;;;645              {
;;;646                OutType * const pOut = out.Pointer(y,0);
;;;647    
;;;648                for(s32 x = 0; x < outWidth; x++) {
;;;649                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;650    
;;;651                  pOut[x] = static_cast<OutType>(curIn);
;;;652    
;;;653                  inIndexX++;
;;;654                  if(inIndexX >= inWidth) {
;;;655                    inIndexX = 0;
;;;656                    inIndexY++;
;;;657                  }
;;;658                }
;;;659              }
;;;660            } // if(isColumnMajor) ... else
;;;661    
;;;662            return RESULT_OK;
;;;663          } // Reshape()
;;;664    
;;;665          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory)
;;;666          {
;;;667            Array<OutType> out(newHeight, newWidth, memory);
;;;668    
;;;669            Reshape<InType, OutType>(isColumnMajor, in, out);
;;;670    
;;;671            return out;
;;;672          }
;;;673    
;;;674          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;675          {
;;;676            AnkiConditionalErrorAndReturnValue(out.get_size(0) == 1,
;;;677              RESULT_FAIL_INVALID_SIZE, "Vectorize", "Output is not 1xN");
;;;678    
;;;679            return Reshape<InType, OutType>(isColumnMajor, in, out);
;;;680          }
;;;681    
;;;682          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory)
;;;683          {
;;;684            const s32 inHeight = in.get_size(0);
;;;685            const s32 inWidth = in.get_size(1);
;;;686    
;;;687            Array<OutType> out(1, inHeight*inWidth, memory);
;;;688    
;;;689            Vectorize<InType, OutType>(isColumnMajor, in, out);
;;;690    
;;;691            return out;
;;;692          }
;;;693    
;;;694          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out)
;;;695          {
;;;696            const s32 inHeight = in.get_size(0);
;;;697            const s32 inWidth = in.get_size(1);
;;;698    
;;;699            const s32 outStride = out.get_stride();
;;;700    
;;;701            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;702              RESULT_FAIL_INVALID_OBJECT, "Transpose", "Invalid objects");
;;;703    
;;;704            AnkiConditionalErrorAndReturnValue(AreEqualSize(in.get_size(1), in.get_size(0), out),
;;;705              RESULT_FAIL_INVALID_SIZE, "Transpose", "out is not the correct size");
;;;706    
;;;707            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;708              RESULT_FAIL_ALIASED_MEMORY, "Transpose", "in and out cannot be the same array");
;;;709    
;;;710            for(s32 yIn=0; yIn<inHeight; yIn++) {
;;;711              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;712              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0,yIn));
;;;713    
;;;714              s32 xIn;
;;;715              s32 outOffset0 = 0;
;;;716    
;;;717              for(xIn=0; xIn<inWidth-1; xIn+=2) {
;;;718                const InType in0 = pIn[xIn];
;;;719                const InType in1 = pIn[xIn+1];
;;;720    
;;;721                const s32 outOffset1 = outOffset0 + outStride;
;;;722    
;;;723                *reinterpret_cast<OutType*>(pOut + outOffset0) = static_cast<OutType>(in0);
;;;724                *reinterpret_cast<OutType*>(pOut + outOffset1) = static_cast<OutType>(in1);
;;;725    
;;;726                outOffset0 += 2*outStride;
;;;727              }
;;;728    
;;;729              for(; xIn<inWidth; xIn++) {
;;;730                *out.Pointer(xIn,yIn) = static_cast<OutType>(pIn[xIn]);
;;;731              }
;;;732            }
;;;733    
;;;734            return RESULT_OK;
;;;735          } // Transpose()
;;;736    
;;;737          template<typename InType, typename OutType> Result Rotate90(const Array<InType> &in, Array<OutType> &out)
;;;738          {
;;;739            const s32 arrWidth = in.get_size(1);
;;;740    
;;;741            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;742              RESULT_FAIL_INVALID_OBJECT, "Rotate90", "Invalid objects");
;;;743    
;;;744            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;745              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;746    
;;;747            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;748              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;749    
;;;750            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;751              RESULT_FAIL_ALIASED_MEMORY, "Rotate90", "in and out cannot be the same array");
;;;752    
;;;753            const s32 outStride = out.get_stride();
;;;754    
;;;755            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;756              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;757              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0, arrWidth-yIn-1));
;;;758    
;;;759              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;760                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;761    
;;;762                pOut += outStride;
;;;763              }
;;;764            }
;;;765    
;;;766            return RESULT_OK;
;;;767          } // Rotate90()
;;;768    
;;;769          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out)
;;;770          {
;;;771            const s32 arrWidth = in.get_size(1);
;;;772    
;;;773            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;774              RESULT_FAIL_INVALID_OBJECT, "Rotate180", "Invalid objects");
;;;775    
;;;776            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;777              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;778    
;;;779            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;780              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;781    
;;;782            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;783              RESULT_FAIL_ALIASED_MEMORY, "Rotate180", "in and out cannot be the same array");
;;;784    
;;;785            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;786              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;787              OutType * restrict pOut = out.Pointer(arrWidth-yIn-1, 0);
;;;788    
;;;789              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;790                pOut[arrWidth-xIn-1] = static_cast<OutType>(pIn[xIn]);
;;;791              }
;;;792            }
;;;793    
;;;794            return RESULT_OK;
;;;795          } // Rotate180()
;;;796    
;;;797          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out)
;;;798          {
;;;799            const s32 arrWidth = in.get_size(1);
;;;800    
;;;801            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;802              RESULT_FAIL_INVALID_OBJECT, "Rotate270", "Invalid objects");
;;;803    
;;;804            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;805              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;806    
;;;807            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;808              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;809    
;;;810            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;811              RESULT_FAIL_ALIASED_MEMORY, "Rotate270", "in and out cannot be the same array");
;;;812    
;;;813            const s32 outStride = out.get_stride();
;;;814    
;;;815            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;816              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;817              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(arrWidth-1, yIn));
;;;818    
;;;819              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;820                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;821    
;;;822                pOut -= outStride;
;;;823              }
;;;824            }
;;;825    
;;;826            return RESULT_OK;
;;;827          } // Rotate270()
;;;828    
;;;829          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;830          {
;;;831            const s32 arrWidth = arr.get_size(1);
;;;832    
;;;833            for(s32 x=0; x<arrWidth; x++) {
;;;834              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;835                const Type valueToInsert = arr[y][x];
;;;836    
;;;837                s32 holePosition = y;
;;;838    
;;;839                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;840                  arr[holePosition][x] = arr[holePosition-1][x];
;;;841                  holePosition--;
;;;842                }
;;;843    
;;;844                arr[holePosition][x] = valueToInsert;
;;;845              }
;;;846            } // for(s32 x=0; x<arrWidth; x++)
;;;847          } // InsertionSort_sortAscendingDimension0()
;;;848    
;;;849          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;850          {
;;;851            const s32 arrWidth = arr.get_size(1);
;;;852    
;;;853            for(s32 x=0; x<arrWidth; x++) {
;;;854              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;855                const Type valueToInsert = arr[y][x];
;;;856    
;;;857                s32 holePosition = y;
;;;858    
;;;859                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;860                  arr[holePosition][x] = arr[holePosition-1][x];
;;;861                  holePosition--;
;;;862                }
;;;863    
;;;864                arr[holePosition][x] = valueToInsert;
;;;865              }
;;;866            } // for(s32 x=0; x<arrWidth; x++)
;;;867          } // InsertionSort_sortDescendingDimension0
;;;868    
;;;869          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;870          {
;;;871            const s32 arrHeight = arr.get_size(0);
;;;872    
;;;873            for(s32 y=0; y<arrHeight; y++) {
;;;874              Type * const pArr = arr[y];
;;;875    
;;;876              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;877                const Type valueToInsert = pArr[x];
;;;878    
;;;879                s32 holePosition = x;
;;;880    
;;;881                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;882                  pArr[holePosition] = pArr[holePosition-1];
;;;883                  holePosition--;
;;;884                }
;;;885    
;;;886                pArr[holePosition] = valueToInsert;
;;;887              }
;;;888            } // for(s32 x=0; x<arrWidth; x++)
;;;889          } // InsertionSort_sortAscendingDimension1()
;;;890    
;;;891          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;892          {
;;;893            const s32 arrHeight = arr.get_size(0);
;;;894    
;;;895            for(s32 y=0; y<arrHeight; y++) {
;;;896              Type * const pArr = arr[y];
;;;897    
;;;898              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;899                const Type valueToInsert = pArr[x];
;;;900    
;;;901                s32 holePosition = x;
;;;902    
;;;903                while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;904                  pArr[holePosition] = pArr[holePosition-1];
;;;905                  holePosition--;
;;;906                }
;;;907    
;;;908                pArr[holePosition] = valueToInsert;
;;;909              }
;;;910            } // for(s32 x=0; x<arrWidth; x++)
;;;911          } // InsertionSort_sortAscendingDimension1()
;;;912    
;;;913          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;914          {
;;;915            const s32 arrWidth = arr.get_size(1);
;;;916    
;;;917            for(s32 x=0; x<arrWidth; x++) {
;;;918              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;919                const Type valueToInsert = arr[y][x];
;;;920                const s32 indexToInsert = indexes[y][x];
;;;921    
;;;922                s32 holePosition = y;
;;;923    
;;;924                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;925                  arr[holePosition][x] = arr[holePosition-1][x];
;;;926                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;927                  holePosition--;
;;;928                }
;;;929    
;;;930                arr[holePosition][x] = valueToInsert;
;;;931                indexes[holePosition][x] = indexToInsert;
;;;932              }
;;;933            } // for(s32 x=0; x<arrWidth; x++)
;;;934          } // InsertionSort_sortAscendingDimension0()
;;;935    
;;;936          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;937          {
;;;938            const s32 arrWidth = arr.get_size(1);
;;;939    
;;;940            for(s32 x=0; x<arrWidth; x++) {
;;;941              indexes[0][x] = 0;
;;;942    
;;;943              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;944                const Type valueToInsert = arr[y][x];
;;;945                const s32 indexToInsert = indexes[y][x];
;;;946    
;;;947                s32 holePosition = y;
;;;948    
;;;949                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;950                  arr[holePosition][x] = arr[holePosition-1][x];
;;;951                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;952                  holePosition--;
;;;953                }
;;;954    
;;;955                arr[holePosition][x] = valueToInsert;
;;;956                indexes[holePosition][x] = indexToInsert;
;;;957              }
;;;958            } // for(s32 x=0; x<arrWidth; x++)
;;;959          } // InsertionSort_sortDescendingDimension0()
;;;960    
;;;961          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;962          {
;;;963            const s32 arrHeight = arr.get_size(0);
;;;964    
;;;965            for(s32 y=0; y<arrHeight; y++) {
;;;966              Type * const pArr = arr[y];
;;;967              s32 * const pIndexes = indexes[y];
;;;968    
;;;969              pIndexes[0] = 0;
;;;970    
;;;971              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;972                const Type valueToInsert = pArr[x];
;;;973                const s32 indexToInsert = pIndexes[x];
;;;974    
;;;975                s32 holePosition = x;
;;;976    
;;;977                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;978                  pArr[holePosition] = pArr[holePosition-1];
;;;979                  pIndexes[holePosition] = pIndexes[holePosition-1];
;;;980                  holePosition--;
;;;981                }
;;;982    
;;;983                pArr[holePosition] = valueToInsert;
;;;984                pIndexes[holePosition] = indexToInsert;
;;;985              }
;;;986            } // for(s32 x=0; x<arrWidth; x++)
;;;987          } // InsertionSort_sortAscendingDimension1()
;;;988    
;;;989          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;990          {
;;;991            const s32 arrHeight = arr.get_size(0);
;;;992    
;;;993            for(s32 y=0; y<arrHeight; y++) {
;;;994              Type * const pArr = arr[y];
;;;995              s32 * const pIndexes = indexes[y];
;;;996    
;;;997              pIndexes[0] = 0;
;;;998    
;;;999              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;1000               const Type valueToInsert = pArr[x];
;;;1001               const s32 indexToInsert = pIndexes[x];
;;;1002   
;;;1003               s32 holePosition = x;
;;;1004   
;;;1005               while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;1006                 pArr[holePosition] = pArr[holePosition-1];
;;;1007                 pIndexes[holePosition] = pIndexes[holePosition-1];
;;;1008                 holePosition--;
;;;1009               }
;;;1010   
;;;1011               pArr[holePosition] = valueToInsert;
;;;1012               pIndexes[holePosition] = indexToInsert;
;;;1013             }
;;;1014           } // for(s32 x=0; x<arrWidth; x++)
;;;1015         } // InsertionSort_sortDescendingDimension1()
;;;1016   
;;;1017         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1018         {
;;;1019           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1020             return;
;;;1021           }
;;;1022   
;;;1023           // Select the median value of the first, middle, and last elements as the pivot
;;;1024           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1025   
;;;1026           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1027   
;;;1028           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1029             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1030   
;;;1031           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1032             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1033   
;;;1034           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x))
;;;1035             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1036   
;;;1037           // Search from the beginning to before the moved pivot
;;;1038           s32 i = trueMinIndex;
;;;1039           s32 j = trueMaxIndex - 2;
;;;1040   
;;;1041           if(i >= j) {
;;;1042             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1043             // NOTE: This really means your insertionSortSize value is too low
;;;1044             return;
;;;1045           }
;;;1046   
;;;1047           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1048   
;;;1049           const Type pivot = *arr.Pointer(midIndex, x);
;;;1050   
;;;1051           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1052   
;;;1053           // Main partitioning loop
;;;1054           while(true) {
;;;1055             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1056             while(*arr.Pointer(i,x) < pivot) {
;;;1057               i++;
;;;1058             }
;;;1059   
;;;1060             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1061             while(*arr.Pointer(j,x) > pivot) {
;;;1062               j--;
;;;1063             }
;;;1064   
;;;1065             if(i < j) {
;;;1066               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1067               i++;
;;;1068               j--;
;;;1069             } else {
;;;1070               break;
;;;1071             }
;;;1072           }
;;;1073   
;;;1074           // Replace the pivot
;;;1075           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1076   
;;;1077           // Recurse
;;;1078           QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1079   
;;;1080           QuickSort_sortAscendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1081         } // QuickSort_sortAscendingDimension0
;;;1082   
;;;1083         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1084         {
;;;1085           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1086             return;
;;;1087           }
;;;1088   
;;;1089           // Select the median value of the first, middle, and last elements as the pivot
;;;1090           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1091   
;;;1092           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1093   
;;;1094           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1095             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1096   
;;;1097           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1098             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1099   
;;;1100           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x))
;;;1101             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1102   
;;;1103           // Search from the beginning to before the moved pivot
;;;1104           s32 i = trueMinIndex;
;;;1105           s32 j = trueMaxIndex - 2;
;;;1106   
;;;1107           if(i >= j) {
;;;1108             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1109             // NOTE: This really means your insertionSortSize value is too low
;;;1110             return;
;;;1111           }
;;;1112   
;;;1113           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1114   
;;;1115           const Type pivot = *arr.Pointer(midIndex, x);
;;;1116   
;;;1117           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1118   
;;;1119           // Main partitioning loop
;;;1120           while(true) {
;;;1121             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1122             while(*arr.Pointer(i,x) > pivot) {
;;;1123               i++;
;;;1124             }
;;;1125   
;;;1126             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1127             while(*arr.Pointer(j,x) < pivot) {
;;;1128               j--;
;;;1129             }
;;;1130   
;;;1131             if(i < j) {
;;;1132               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1133               i++;
;;;1134               j--;
;;;1135             } else {
;;;1136               break;
;;;1137             }
;;;1138           }
;;;1139   
;;;1140           // Replace the pivot
;;;1141           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1142   
;;;1143           // Recurse
;;;1144           QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1145   
;;;1146           QuickSort_sortDescendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1147         } // QuickSort_sortDescendingDimension0
;;;1148   
;;;1149         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1150         {
;;;1151           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1152             return;
;;;1153           }
;;;1154   
;;;1155           Type * restrict pArr = arr.Pointer(y,0);
;;;1156   
;;;1157           // Select the median value of the first, middle, and last elements as the pivot
;;;1158           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1159   
;;;1160           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1161   
;;;1162           if(pArr[midIndex] < pArr[trueMinIndex])
;;;1163             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1164   
;;;1165           if(pArr[trueMaxIndex] < pArr[trueMinIndex])
;;;1166             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1167   
;;;1168           if(pArr[trueMaxIndex] < pArr[midIndex])
;;;1169             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1170   
;;;1171           // Search from the beginning to before the moved pivot
;;;1172           s32 i = trueMinIndex;
;;;1173           s32 j = trueMaxIndex - 2;
;;;1174   
;;;1175           if(i >= j) {
;;;1176             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1177             // NOTE: This really means your insertionSortSize value is too low
;;;1178             return;
;;;1179           }
;;;1180   
;;;1181           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1182   
;;;1183           const Type pivot = pArr[midIndex];
;;;1184   
;;;1185           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1186   
;;;1187           // Main partitioning loop
;;;1188           while(true) {
;;;1189             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1190             while(pArr[i] < pivot) {
;;;1191               i++;
;;;1192             }
;;;1193   
;;;1194             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1195             while(pArr[j] > pivot) {
;;;1196               j--;
;;;1197             }
;;;1198   
;;;1199             if(i < j) {
;;;1200               Swap<Type>(pArr[i], pArr[j]);
;;;1201               i++;
;;;1202               j--;
;;;1203             } else {
;;;1204               break;
;;;1205             }
;;;1206           }
;;;1207   
;;;1208           // Replace the pivot
;;;1209           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1210   
;;;1211           // Recurse
;;;1212           QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1213   
;;;1214           QuickSort_sortAscendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1215         } // QuickSort_sortAscendingDimension1
;;;1216   
;;;1217         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1218         {
;;;1219           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1220             return;
;;;1221           }
;;;1222   
;;;1223           Type * restrict pArr = arr.Pointer(y,0);
;;;1224   
;;;1225           // Select the median value of the first, middle, and last elements as the pivot
;;;1226           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1227   
;;;1228           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1229   
;;;1230           if(pArr[midIndex] < pArr[trueMaxIndex])
;;;1231             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1232   
;;;1233           if(pArr[trueMinIndex] < pArr[trueMaxIndex])
;;;1234             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1235   
;;;1236           if(pArr[trueMinIndex] < pArr[midIndex])
;;;1237             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1238   
;;;1239           // Search from the beginning to before the moved pivot
;;;1240           s32 i = trueMinIndex;
;;;1241           s32 j = trueMaxIndex - 2;
;;;1242   
;;;1243           if(i >= j) {
;;;1244             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1245             // NOTE: This really means your insertionSortSize value is too low
;;;1246             return;
;;;1247           }
;;;1248   
;;;1249           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1250   
;;;1251           const Type pivot = pArr[midIndex];
;;;1252   
;;;1253           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1254   
;;;1255           // Main partitioning loop
;;;1256           while(true) {
;;;1257             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1258             while(pArr[i] > pivot) {
;;;1259               i++;
;;;1260             }
;;;1261   
;;;1262             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1263             while(pArr[j] < pivot) {
;;;1264               j--;
;;;1265             }
;;;1266   
;;;1267             if(i < j) {
;;;1268               Swap<Type>(pArr[i], pArr[j]);
;;;1269               i++;
;;;1270               j--;
;;;1271             } else {
;;;1272               break;
;;;1273             }
;;;1274           }
;;;1275   
;;;1276           // Replace the pivot
;;;1277           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1278   
;;;1279           // Recurse
;;;1280           QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1281   
;;;1282           QuickSort_sortDescendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1283         } // QuickSort_sortDescendingDimension1
;;;1284   
;;;1285         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1286         {
;;;1287           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1288             return;
;;;1289           }
;;;1290   
;;;1291           // Select the median value of the first, middle, and last elements as the pivot
;;;1292           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1293   
;;;1294           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1295   
;;;1296           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1297             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1298             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1299           }
;;;1300   
;;;1301           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1302             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1303             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1304           }
;;;1305   
;;;1306           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1307             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1308             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(midIndex, x));
;;;1309           }
;;;1310   
;;;1311           // Search from the beginning to before the moved pivot
;;;1312           s32 i = trueMinIndex;
;;;1313           s32 j = trueMaxIndex - 2;
;;;1314   
;;;1315           if(i >= j) {
;;;1316             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1317             // NOTE: This really means your insertionSortSize value is too low
;;;1318             return;
;;;1319           }
;;;1320   
;;;1321           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1322   
;;;1323           const Type pivot = *arr.Pointer(midIndex, x);
;;;1324   
;;;1325           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1326           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1327   
;;;1328           // Main partitioning loop
;;;1329           while(true) {
;;;1330             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1331             while(*arr.Pointer(i,x) < pivot) {
;;;1332               i++;
;;;1333             }
;;;1334   
;;;1335             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1336             while(*arr.Pointer(j,x) > pivot) {
;;;1337               j--;
;;;1338             }
;;;1339   
;;;1340             if(i < j) {
;;;1341               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1342               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1343               i++;
;;;1344               j--;
;;;1345             } else {
;;;1346               break;
;;;1347             }
;;;1348           }
;;;1349   
;;;1350           // Replace the pivot
;;;1351           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1352           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1353   
;;;1354           // Recurse
;;;1355           QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1356   
;;;1357           QuickSort_sortAscendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1358         } // QuickSort_sortAscendingDimension0
;;;1359   
;;;1360         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1361         {
;;;1362           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1363             return;
;;;1364           }
;;;1365   
;;;1366           // Select the median value of the first, middle, and last elements as the pivot
;;;1367           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1368   
;;;1369           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1370   
;;;1371           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1372             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1373             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1374           }
;;;1375   
;;;1376           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1377             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1378             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1379           }
;;;1380   
;;;1381           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1382             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1383             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(midIndex, x));
;;;1384           }
;;;1385   
;;;1386           // Search from the beginning to before the moved pivot
;;;1387           s32 i = trueMinIndex;
;;;1388           s32 j = trueMaxIndex - 2;
;;;1389   
;;;1390           if(i >= j) {
;;;1391             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1392             // NOTE: This really means your insertionSortSize value is too low
;;;1393             return;
;;;1394           }
;;;1395   
;;;1396           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1397   
;;;1398           const Type pivot = *arr.Pointer(midIndex, x);
;;;1399   
;;;1400           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1401           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1402   
;;;1403           // Main partitioning loop
;;;1404           while(true) {
;;;1405             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1406             while(*arr.Pointer(i,x) > pivot) {
;;;1407               i++;
;;;1408             }
;;;1409   
;;;1410             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1411             while(*arr.Pointer(j,x) < pivot) {
;;;1412               j--;
;;;1413             }
;;;1414   
;;;1415             if(i < j) {
;;;1416               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1417               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1418               i++;
;;;1419               j--;
;;;1420             } else {
;;;1421               break;
;;;1422             }
;;;1423           }
;;;1424   
;;;1425           // Replace the pivot
;;;1426           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1427           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1428   
;;;1429           // Recurse
;;;1430           QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1431   
;;;1432           QuickSort_sortDescendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1433         } // QuickSort_sortDescendingDimension0
;;;1434   
;;;1435         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1436         {
;;;1437           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1438             return;
;;;1439           }
;;;1440   
;;;1441           Type * restrict pArr = arr.Pointer(y,0);
;;;1442           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1443   
;;;1444           // Select the median value of the first, middle, and last elements as the pivot
;;;1445           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1446   
;;;1447           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1448   
;;;1449           if(pArr[midIndex] < pArr[trueMinIndex]) {
;;;1450             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1451             Swap<s32>(pIndexes[midIndex], pIndexes[trueMinIndex]);
;;;1452           }
;;;1453   
;;;1454           if(pArr[trueMaxIndex] < pArr[trueMinIndex]) {
;;;1455             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1456             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[trueMinIndex]);
;;;1457           }
;;;1458   
;;;1459           if(pArr[trueMaxIndex] < pArr[midIndex]) {
;;;1460             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1461             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[midIndex]);
;;;1462           }
;;;1463   
;;;1464           // Search from the beginning to before the moved pivot
;;;1465           s32 i = trueMinIndex;
;;;1466           s32 j = trueMaxIndex - 2;
;;;1467   
;;;1468           if(i >= j) {
;;;1469             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1470             // NOTE: This really means your insertionSortSize value is too low
;;;1471             return;
;;;1472           }
;;;1473   
;;;1474           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1475   
;;;1476           const Type pivot = pArr[midIndex];
;;;1477   
;;;1478           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1479           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1480   
;;;1481           // Main partitioning loop
;;;1482           while(true) {
;;;1483             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1484             while(pArr[i] < pivot) {
;;;1485               i++;
;;;1486             }
;;;1487   
;;;1488             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1489             while(pArr[j] > pivot) {
;;;1490               j--;
;;;1491             }
;;;1492   
;;;1493             if(i < j) {
;;;1494               Swap<Type>(pArr[i], pArr[j]);
;;;1495               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1496               i++;
;;;1497               j--;
;;;1498             } else {
;;;1499               break;
;;;1500             }
;;;1501           }
;;;1502   
;;;1503           // Replace the pivot
;;;1504           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1505           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1506   
;;;1507           // Recurse
;;;1508           QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1509   
;;;1510           QuickSort_sortAscendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1511         } // QuickSort_sortAscendingDimension1
;;;1512   
;;;1513         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1514         {
;;;1515           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1516             return;
;;;1517           }
;;;1518   
;;;1519           Type * restrict pArr = arr.Pointer(y,0);
;;;1520           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1521   
;;;1522           // Select the median value of the first, middle, and last elements as the pivot
;;;1523           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1524   
;;;1525           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1526   
;;;1527           if(pArr[midIndex] < pArr[trueMaxIndex]) {
;;;1528             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1529             Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex]);
;;;1530           }
;;;1531   
;;;1532           if(pArr[trueMinIndex] < pArr[trueMaxIndex]) {
;;;1533             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1534             Swap<s32>(pIndexes[trueMinIndex], pIndexes[trueMaxIndex]);
;;;1535           }
;;;1536   
;;;1537           if(pArr[trueMinIndex] < pArr[midIndex]) {
;;;1538             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1539             Swap<s32>(pIndexes[trueMinIndex], pIndexes[midIndex]);
;;;1540           }
;;;1541   
;;;1542           // Search from the beginning to before the moved pivot
;;;1543           s32 i = trueMinIndex;
;;;1544           s32 j = trueMaxIndex - 2;
;;;1545   
;;;1546           if(i >= j) {
;;;1547             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1548             // NOTE: This really means your insertionSortSize value is too low
;;;1549             return;
;;;1550           }
;;;1551   
;;;1552           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1553   
;;;1554           const Type pivot = pArr[midIndex];
;;;1555   
;;;1556           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1557           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1558   
;;;1559           // Main partitioning loop
;;;1560           while(true) {
;;;1561             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1562             while(pArr[i] > pivot) {
;;;1563               i++;
;;;1564             }
;;;1565   
;;;1566             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1567             while(pArr[j] < pivot) {
;;;1568               j--;
;;;1569             }
;;;1570   
;;;1571             if(i < j) {
;;;1572               Swap<Type>(pArr[i], pArr[j]);
;;;1573               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1574               i++;
;;;1575               j--;
;;;1576             } else {
;;;1577               break;
;;;1578             }
;;;1579           }
;;;1580   
;;;1581           // Replace the pivot
;;;1582           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1583           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1584   
;;;1585           // Recurse
;;;1586           QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1587   
;;;1588           QuickSort_sortDescendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1589         } // QuickSort_sortDescendingDimension1
;;;1590   
;;;1591         template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1592         {
;;;1593           // const s32 arrHeight = arr.get_size(0);
;;;1594           // const s32 arrWidth = arr.get_size(1);
;;;1595   
;;;1596           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1597             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1598   
;;;1599           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1600             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1601   
;;;1602           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1603           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1604   
;;;1605           if(sortWhichDimension == 0) {
;;;1606             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1607             if(sortAscending) {
;;;1608               InsertionSort_sortAscendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1609             } else { // if(sortAscending)
;;;1610               InsertionSort_sortDescendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1611             } // if(sortAscending) ... else
;;;1612           } else { // sortWhichDimension == 1
;;;1613             if(sortAscending) {
;;;1614               InsertionSort_sortAscendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1615             } else { // if(sortAscending)
;;;1616               InsertionSort_sortDescendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1617             } // if(sortAscending) ... else
;;;1618           } // if(sortWhichDimension == 0) ... else
;;;1619   
;;;1620           return RESULT_OK;
;;;1621         } // InsertionSort()
;;;1622   
;;;1623         template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1624         {
;;;1625           const s32 arrHeight = arr.get_size(0);
;;;1626           const s32 arrWidth = arr.get_size(1);
;;;1627   
;;;1628           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1629             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1630   
;;;1631           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1632             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1633   
;;;1634           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1635             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1636   
;;;1637           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1638           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1639   
;;;1640           if(sortWhichDimension == 0) {
;;;1641             for(s32 y=0; y<arrHeight; y++) {
;;;1642               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1643               for(s32 x=0; x<arrWidth; x++) {
;;;1644                 pIndexes[x] = y;
;;;1645               }
;;;1646             }
;;;1647   
;;;1648             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1649             if(sortAscending) {
;;;1650               InsertionSort_sortAscendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1651             } else { // if(sortAscending)
;;;1652               InsertionSort_sortDescendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1653             } // if(sortAscending) ... else
;;;1654           } else { // sortWhichDimension == 1
;;;1655             for(s32 y=0; y<arrHeight; y++) {
;;;1656               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1657               for(s32 x=0; x<arrWidth; x++) {
;;;1658                 pIndexes[x] = x;
;;;1659               }
;;;1660             }
;;;1661   
;;;1662             if(sortAscending) {
;;;1663               InsertionSort_sortAscendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1664             } else { // if(sortAscending)
;;;1665               InsertionSort_sortDescendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1666             } // if(sortAscending) ... else
;;;1667           } // if(sortWhichDimension == 0) ... else
;;;1668   
;;;1669           return RESULT_OK;
;;;1670         } // InsertionSort()
;;;1671   
;;;1672         template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1673         {
;;;1674           const s32 arrHeight = arr.get_size(0);
;;;1675           const s32 arrWidth = arr.get_size(1);
;;;1676   
;;;1677           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1678             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1679   
;;;1680           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1681             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1682   
;;;1683           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1684             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1685   
;;;1686           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1687           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1688   
;;;1689           if(sortWhichDimension == 0) {
;;;1690             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1691             if(sortAscending) {
;;;1692               for(s32 x=0; x<arrWidth; x++) {
;;;1693                 QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1694               }
;;;1695   
;;;1696               if(insertionSortSize > 1)
;;;1697                 InsertionSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1698             } else { // if(sortAscending)
;;;1699               for(s32 x=0; x<arrWidth; x++) {
;;;1700                 QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1701               }
;;;1702   
;;;1703               if(insertionSortSize > 1)
;;;1704                 InsertionSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1705             } // if(sortAscending) ... else
;;;1706           } else { // sortWhichDimension == 1
;;;1707             if(sortAscending) {
;;;1708               for(s32 y=0; y<arrHeight; y++) {
;;;1709                 QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1710               }
;;;1711   
;;;1712               if(insertionSortSize > 1)
;;;1713                 InsertionSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1714             } else { // if(sortAscending)
;;;1715               for(s32 y=0; y<arrHeight; y++) {
;;;1716                 QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1717               }
;;;1718   
;;;1719               if(insertionSortSize > 1)
;;;1720                 InsertionSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1721             } // if(sortAscending) ... else
;;;1722           } // if(sortWhichDimension == 0) ... else
;;;1723   
;;;1724           return RESULT_OK;
;;;1725         } // QuickSort()
;;;1726   
;;;1727         template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1728         {
;;;1729           const s32 arrHeight = arr.get_size(0);
;;;1730           const s32 arrWidth = arr.get_size(1);
;;;1731   
;;;1732           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1733             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1734   
;;;1735           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1736             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1737   
;;;1738           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1739             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1740   
;;;1741           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1742             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1743   
;;;1744           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1745           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1746   
;;;1747           if(sortWhichDimension == 0) {
;;;1748             for(s32 y=0; y<arrHeight; y++) {
;;;1749               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1750               for(s32 x=0; x<arrWidth; x++) {
;;;1751                 pIndexes[x] = y;
;;;1752               }
;;;1753             }
;;;1754   
;;;1755             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1756             if(sortAscending) {
;;;1757               for(s32 x=0; x<arrWidth; x++) {
;;;1758                 QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1759               }
;;;1760   
;;;1761               if(insertionSortSize > 1)
;;;1762                 InsertionSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1763             } else { // if(sortAscending)
;;;1764               for(s32 x=0; x<arrWidth; x++) {
;;;1765                 QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1766               }
;;;1767   
;;;1768               if(insertionSortSize > 1)
;;;1769                 InsertionSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1770             } // if(sortAscending) ... else
;;;1771           } else { // sortWhichDimension == 1
;;;1772             for(s32 y=0; y<arrHeight; y++) {
;;;1773               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1774               for(s32 x=0; x<arrWidth; x++) {
;;;1775                 pIndexes[x] = x;
;;;1776               }
;;;1777             }
;;;1778   
;;;1779             if(sortAscending) {
;;;1780               for(s32 y=0; y<arrHeight; y++) {
;;;1781                 QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1782               }
;;;1783   
;;;1784               if(insertionSortSize > 1)
;;;1785                 InsertionSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1786             } else { // if(sortAscending)
;;;1787               for(s32 y=0; y<arrHeight; y++) {
;;;1788                 QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1789               }
;;;1790   
;;;1791               if(insertionSortSize > 1)
;;;1792                 InsertionSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1793             } // if(sortAscending) ... else
;;;1794           } // if(sortWhichDimension == 0) ... else
;;;1795   
;;;1796           return RESULT_OK;
;;;1797         } // QuickSort()
;;;1798   
;;;1799         template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1800         {
;;;1801           AnkiConditionalErrorAndReturnValue(arr.get_size(0) == arr.get_size(1),
;;;1802             RESULT_FAIL_INVALID_SIZE, "MakeSymmetric", "Input array must be square");
;;;1803   
;;;1804           const s32 arrHeight = arr.get_size(0);
;;;1805           for(s32 y = 0; y < arrHeight; y++)
;;;1806           {
;;;1807             const s32 x0 = lowerToUpper ? (y+1)     : 0;
;;;1808             const s32 x1 = lowerToUpper ? arrHeight : y;
;;;1809   
;;;1810             for(s32 x = x0; x < x1; x++) {
;;;1811               *arr.Pointer(y,x) = *arr.Pointer(x,y);
;;;1812             }
;;;1813           }
;;;1814   
;;;1815           return RESULT_OK;
;;;1816         } // template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1817   
;;;1818         namespace Elementwise
;;;1819         {
;;;1820           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1821           {
;;;1822             const Array<InType> &in1Array = in1.get_array();
;;;1823             const Array<InType> &in2Array = in2.get_array();
;;;1824             Array<OutType> &out1Array = out.get_array();
;;;1825   
;;;1826             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, in2Array, out1Array),
;;;1827               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1828   
;;;1829             ArraySliceLimits_in2_out1<s32> limits(
;;;1830               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1831               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1832               out.get_ySlice(), out.get_xSlice());
;;;1833   
;;;1834             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1835               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1836   
;;;1837             if(limits.isSimpleIteration) {
;;;1838               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1839   
;;;1840               for(s32 y=0; y<limits.ySize; y++) {
;;;1841                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1842                 const InType * const pIn2 = in2Array.Pointer(limits.in2Y, 0);
;;;1843                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1844   
;;;1845                 limits.OuterIncrementTop();
;;;1846   
;;;1847                 for(s32 x=0; x<limits.xSize; x++) {
;;;1848                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], pIn2[limits.in2X]);
;;;1849   
;;;1850                   limits.in1X += limits.in1_xInnerIncrement;
;;;1851                   limits.in2X += limits.in2_xInnerIncrement;
;;;1852                   limits.out1X += limits.out1_xInnerIncrement;
;;;1853                 }
;;;1854   
;;;1855                 limits.OuterIncrementBottom();
;;;1856               }
;;;1857             } else { // if(limits.isSimpleIteration)
;;;1858               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1859   
;;;1860               for(s32 y=0; y<limits.ySize; y++) {
;;;1861                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1862   
;;;1863                 limits.OuterIncrementTop();
;;;1864   
;;;1865                 for(s32 x=0; x<limits.xSize; x++) {
;;;1866                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1867                   const InType valIn2 = *in2Array.Pointer(limits.in2Y, limits.in2X);
;;;1868   
;;;1869                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, valIn2);
;;;1870   
;;;1871                   limits.in1X += limits.in1_xInnerIncrement;
;;;1872                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1873                   limits.in2X += limits.in2_xInnerIncrement;
;;;1874                   limits.in2Y += limits.in2_yInnerIncrement;
;;;1875                   limits.out1X += limits.out1_xInnerIncrement;
;;;1876                 }
;;;1877   
;;;1878                 limits.OuterIncrementBottom();
;;;1879               }
;;;1880             } //   if(limits.isSimpleIteration)  ... else
;;;1881   
;;;1882             return RESULT_OK;
;;;1883           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1884   
;;;1885           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1886           {
;;;1887             const Array<InType> &in1Array = in1.get_array();
;;;1888             Array<OutType> &out1Array = out.get_array();
;;;1889   
;;;1890             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, out1Array),
;;;1891               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1892   
;;;1893             ArraySliceLimits_in1_out1<s32> limits(
;;;1894               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1895               out.get_ySlice(), out.get_xSlice());
;;;1896   
;;;1897             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1898               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1899   
;;;1900             if(limits.isSimpleIteration) {
;;;1901               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1902   
;;;1903               for(s32 y=0; y<limits.ySize; y++) {
;;;1904                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1905                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1906   
;;;1907                 limits.OuterIncrementTop();
;;;1908   
;;;1909                 for(s32 x=0; x<limits.xSize; x++) {
;;;1910                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], value2);
;;;1911   
;;;1912                   limits.in1X += limits.in1_xInnerIncrement;
;;;1913                   limits.out1X += limits.out1_xInnerIncrement;
;;;1914                 }
;;;1915   
;;;1916                 limits.OuterIncrementBottom();
;;;1917               }
;;;1918             } else { // if(limits.isSimpleIteration)
;;;1919               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1920   
;;;1921               for(s32 y=0; y<limits.ySize; y++) {
;;;1922                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1923   
;;;1924                 limits.OuterIncrementTop();
;;;1925   
;;;1926                 for(s32 x=0; x<limits.xSize; x++) {
;;;1927                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1928   
;;;1929                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, value2);
;;;1930   
;;;1931                   limits.in1X += limits.in1_xInnerIncrement;
;;;1932                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1933                   limits.out1X += limits.out1_xInnerIncrement;
;;;1934                 }
;;;1935   
;;;1936                 limits.OuterIncrementBottom();
;;;1937               }
;;;1938             } //   if(limits.isSimpleIteration)  ... else
;;;1939   
;;;1940             return RESULT_OK;
;;;1941           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1942   
;;;1943           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1944           {
;;;1945             const Array<InType> &in2Array = in2.get_array();
;;;1946             Array<OutType> &out1Array = out.get_array();
;;;1947   
;;;1948             AnkiConditionalErrorAndReturnValue(AreValid(in2Array, out1Array),
;;;1949               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1950   
;;;1951             ArraySliceLimits_in1_out1<s32> limits(
;;;1952               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1953               out.get_ySlice(), out.get_xSlice());
;;;1954   
;;;1955             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1956               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1957   
;;;1958             if(limits.isSimpleIteration) {
;;;1959               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1960   
;;;1961               for(s32 y=0; y<limits.ySize; y++) {
;;;1962                 const InType * const pIn2 = in2Array.Pointer(limits.in1Y, 0);
;;;1963                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1964   
;;;1965                 limits.OuterIncrementTop();
;;;1966   
;;;1967                 for(s32 x=0; x<limits.xSize; x++) {
;;;1968                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, pIn2[limits.in1X]);
;;;1969   
;;;1970                   limits.in1X += limits.in1_xInnerIncrement;
;;;1971                   limits.out1X += limits.out1_xInnerIncrement;
;;;1972                 }
;;;1973   
;;;1974                 limits.OuterIncrementBottom();
;;;1975               }
;;;1976             } else { // if(limits.isSimpleIteration)
;;;1977               // If either input is transposed, then we will do an inefficent loop iteration
;;;1978   
;;;1979               for(s32 y=0; y<limits.ySize; y++) {
;;;1980                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1981   
;;;1982                 limits.OuterIncrementTop();
;;;1983   
;;;1984                 for(s32 x=0; x<limits.xSize; x++) {
;;;1985                   const InType valIn2 = *in2Array.Pointer(limits.in1Y, limits.in1X);
;;;1986   
;;;1987                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, valIn2);
;;;1988   
;;;1989                   limits.in1X += limits.in1_xInnerIncrement;
;;;1990                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1991                   limits.out1X += limits.out1_xInnerIncrement;
;;;1992                 }
;;;1993   
;;;1994                 limits.OuterIncrementBottom();
;;;1995               }
;;;1996             } //   if(limits.isSimpleIteration)  ... else
;;;1997   
;;;1998             return RESULT_OK;
;;;1999           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;2000         } // namespace Elementwise
;;;2001       } // namespace Matrix
;;;2002     } // namespace Embedded
;;;2003   } // namespace Anki
;;;2004   
;;;2005   #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;19     
;;;20     #include "anki/common/shared/utilities_shared.h"
;;;1      /**
;;;2      File: utilities_shared.h
;;;3      Author: Kevin Yoon
;;;4      Created: 2014
;;;5      
;;;6      Copyright Anki, Inc. 2014
;;;7      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;8      **/
;;;9      
;;;10     #ifndef _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;11     #define _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;12     
;;;13     #include <stdarg.h>
;;;1      /* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
;;;14     
;;;15     namespace Anki
;;;16     {
;;;17       // For printing throughout Coretech libraries.
;;;18       // Calls printf() by default, but can be made to use an externally
;;;19       // defined function via SetCoreTechPrintFunctionPtr().
;;;20       int CoreTechPrint(const char * format, ...);
;;;21       int CoreTechPrint(const char * format, va_list argList);
;;;22     
;;;23       // Sets the function pointer that CoreTechPrint() uses.
;;;24       // Convenient for on-robot print which could be more complex
;;;25       // than just printf().
;;;26       void SetCoreTechPrintFunctionPtr( int (*fp)(const char * format, va_list) );
;;;27     } // namespace Anki
;;;28     
;;;29     #endif // _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26     #if 0
;;;27     #pragma mark --- 2D Point Implementations ---
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
;;;34         template<typename Type> Point<Type>::Point(const Type x, const Type y)
;;;35           : x(x), y(y)
;;;36         {
;;;37         }
;;;38     
;;;39         template<typename Type> Point<Type>::Point(const Point<Type>& pt)
;;;40           : x(pt.x), y(pt.y)
;;;41         {
;;;42         }
;;;43     
;;;44     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;45         template<typename Type> Point<Type>::Point(const cv::Point_<Type>& pt)
;;;46           : x(pt.x), y(pt.y)
;;;47         {
;;;48         }
;;;49     #endif
;;;50     
;;;51     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;52         template<typename Type> cv::Point_<Type> Point<Type>::get_CvPoint_() const
;;;53         {
;;;54           return cv::Point_<Type>(x,y);
;;;55         }
;;;56     #endif
;;;57     
;;;58         template<typename Type> template<typename InType> void Point<Type>::SetCast(const Point<InType> &in)
;;;59         {
;;;60           this->x = saturate_cast<Type>(in.x);
;;;61           this->y = saturate_cast<Type>(in.y);
;;;62         }
;;;63     
;;;64         template<typename Type> void Point<Type>::Print() const
;;;65         {
;;;66           CoreTechPrint("(%d,%d) ", this->x, this->y);
;;;67         }
;;;68     
;;;69         template<typename Type> bool Point<Type>::operator== (const Point<Type> &point2) const
;;;70         {
;;;71           if(this->x == point2.x && this->y == point2.y)
;;;72             return true;
;;;73     
;;;74           return false;
;;;75         }
;;;76     
;;;77         template<typename Type> Point<Type> Point<Type>::operator+ (const Point<Type> &point2) const
;;;78         {
;;;79           return Point<Type>(this->x+point2.x, this->y+point2.y);
;;;80         }
;;;81     
;;;82         template<typename Type> Point<Type> Point<Type>::operator- (const Point<Type> &point2) const
;;;83         {
;;;84           return Point<Type>(this->x-point2.x, this->y-point2.y);
;;;85         }
;;;86     
;;;87         template<typename Type> Point<Type> Point<Type>::operator- () const
;;;88         {
;;;89           return Point<Type>(-this->x, -this->y);
;;;90         }
;;;91     
;;;92         template<typename Type> Point<Type>& Point<Type>::operator*= (const Type value)
;;;93         {
;;;94           this->x *= value;
;;;95           this->y *= value;
;;;96           return *this;
;;;97         }
;;;98     
;;;99         template<typename Type> Point<Type>& Point<Type>::operator-= (const Type value)
;;;100        {
;;;101          this->x -= value;
;;;102          this->y -= value;
;;;103          return *this;
;;;104        }
;;;105    
;;;106        template<typename Type> Point<Type>& Point<Type>::operator+= (const Point<Type> &point2)
;;;107        {
;;;108          this->x += point2.x;
;;;109          this->y += point2.y;
;;;110          return *this;
;;;111        }
;;;112    
;;;113        template<typename Type> Point<Type>& Point<Type>::operator-= (const Point<Type> &point2)
;;;114        {
;;;115          this->x -= point2.x;
;;;116          this->y -= point2.y;
;;;117          return *this;
;;;118        }
;;;119    
;;;120        template<typename Type> inline Point<Type>& Point<Type>::operator= (const Point<Type> &point2)
;;;121        {
;;;122          this->x = point2.x;
;;;123          this->y = point2.y;
;;;124    
;;;125          return *this;
;;;126        }
;;;127    
;;;128        template<typename Type> f32 Point<Type>::Dist(const Point<Type> &point2) const
;;;129        {
;;;130          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) + (this->y - point2.y)*(this->y - point2.y));
;;;131        }
;;;132    
;;;133        template<typename Type> f32 Point<Type>::Length() const
;;;134        {
;;;135          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y)));
;;;136        }
;;;137    
;;;138        // #pragma mark --- Point Specializations ---
;;;139        template<> void Point<f32>::Print() const;
;;;140        template<> void Point<f64>::Print() const;
;;;141    
;;;142    #if 0
;;;143    #pragma mark --- 3D Point Implementations ---
;;;144    #endif
;;;145    
;;;146        template<typename Type> Point3<Type>::Point3()
;;;147          : x(static_cast<Type>(0)), y(static_cast<Type>(0)), z(static_cast<Type>(0))
;;;148        {
;;;149        }
;;;150    
;;;151        template<typename Type> Point3<Type>::Point3(const Type x, const Type y, const Type z)
;;;152          : x(x), y(y), z(z)
;;;153        {
;;;154        }
;;;155    
;;;156        template<typename Type> Point3<Type>::Point3(const Point3<Type>& pt)
;;;157          : x(pt.x), y(pt.y), z(pt.z)
;;;158        {
;;;159        }
;;;160    
;;;161    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;162        template<typename Type> Point3<Type>::Point3(const cv::Point3_<Type>& pt)
;;;163          : x(pt.x), y(pt.y), z(pt.z)
;;;164        {
;;;165        }
;;;166    #endif
;;;167    
;;;168    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;169        template<typename Type> cv::Point3_<Type> Point3<Type>::get_CvPoint_() const
;;;170        {
;;;171          return cv::Point3_<Type>(x,y,z);
;;;172        }
;;;173    #endif
;;;174    
;;;175        template<typename Type> void Point3<Type>::Print() const
;;;176        {
;;;177          CoreTechPrint("(%d,%d,%d) ", this->x, this->y, this->z);
;;;178        }
;;;179    
;;;180        template<typename Type> bool Point3<Type>::operator== (const Point3<Type> &point2) const
;;;181        {
;;;182          if(this->x == point2.x && this->y == point2.y && this->z == point2.z)
;;;183            return true;
;;;184    
;;;185          return false;
;;;186        }
;;;187    
;;;188        template<typename Type> Point3<Type> Point3<Type>::operator+ (const Point3<Type> &point2) const
;;;189        {
;;;190          return Point3<Type>(this->x+point2.x, this->y+point2.y, this->z+point2.z);
;;;191        }
;;;192    
;;;193        template<typename Type> Point3<Type> Point3<Type>::operator- (const Point3<Type> &point2) const
;;;194        {
;;;195          return Point3<Type>(this->x-point2.x, this->y-point2.y, this->z-point2.z);
;;;196        }
;;;197    
;;;198        template<typename Type> Point3<Type> Point3<Type>::operator- () const
;;;199        {
;;;200          return Point3<Type>(-this->x, -this->y, -this->z);
;;;201        }
;;;202    
;;;203        template<typename Type> Point3<Type>& Point3<Type>::operator*= (const Type value)
;;;204        {
;;;205          this->x *= value;
;;;206          this->y *= value;
;;;207          this->z *= value;
;;;208          return *this;
;;;209        }
;;;210    
;;;211        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Type value)
;;;212        {
;;;213          this->x -= value;
;;;214          this->y -= value;
;;;215          this->z -= value;
;;;216          return *this;
;;;217        }
;;;218    
;;;219        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Point3<Type> &point2)
;;;220        {
;;;221          this->x -= point2.x;
;;;222          this->y -= point2.y;
;;;223          this->z -= point2.z;
;;;224          return *this;
;;;225        }
;;;226    
;;;227        template<typename Type> inline Point3<Type>& Point3<Type>::operator= (const Point3<Type> &point2)
;;;228        {
;;;229          this->x = point2.x;
;;;230          this->y = point2.y;
;;;231          this->z = point2.z;
;;;232          return *this;
;;;233        }
;;;234    
;;;235        template<typename Type> f32 Point3<Type>::Dist(const Point3<Type> &point2) const
;;;236        {
;;;237          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) +
;;;238            (this->y - point2.y)*(this->y - point2.y) +
;;;239            (this->z - point2.z)*(this->z - point2.z));
;;;240        }
;;;241    
;;;242        template<typename Type> f32 Point3<Type>::Length() const
;;;243        {
;;;244          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y) + (this->z*this->z)));
;;;245        }
;;;246    
;;;247        template<typename Type> f32 Point3<Type>::MakeUnitLength()
;;;248        {
;;;249          const f32 L = this->Length();
;;;250          if(L != 0) {
;;;251            this->operator*=(1.f / L);
;;;252          }
;;;253          return L;
;;;254        }
;;;255    
;;;256        template<typename Type>
;;;257        Type DotProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;258        {
;;;259          return (point1.x*point2.x) + (point1.y*point2.y) + (point1.z*point2.z);
;;;260        }
;;;261    
;;;262        template<typename Type>
;;;263        Point3<Type> CrossProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;264        {
;;;265          return Point3<Type>(-point2.y*point1.z + point1.y*point2.z,
;;;266            point2.x*point1.z - point1.x*point2.z,
;;;267            -point2.x*point1.y + point1.x*point2.y);
;;;268        }
;;;269    
;;;270        template<typename Type>
;;;271        Point3<Type> operator* (const Array<Type>& M, const Point3<Type>& p)
;;;272        {
;;;273          // Matrix M must be 3x3
;;;274          AnkiAssert(AreEqualSize(3, 3, M));
;;;275    
;;;276          return Point3<Type>(M[0][0]*p.x + M[0][1]*p.y + M[0][2]*p.z,
;;;277            M[1][0]*p.x + M[1][1]*p.y + M[1][2]*p.z,
;;;278            M[2][0]*p.x + M[2][1]*p.y + M[2][2]*p.z);
;;;279        }
;;;280    
;;;281        // #pragma mark --- Point Specializations ---
;;;282        template<> void Point3<f32>::Print() const;
;;;283        template<> void Point3<f64>::Print() const;
;;;284    
;;;285    #if 0
;;;286    #pragma mark --- Pose Implementations ---
;;;287    #endif
;;;288    
;;;289        template<typename Type>
;;;290        Result ComputePoseDiff(const Array<Type>& R1, const Point3<Type>& T1,
;;;291          const Array<Type>& R2, const Point3<Type>& T2,
;;;292          Array<Type>& Rdiff, Point3<Type>& Tdiff,
;;;293          MemoryStack scratch)
;;;294        {
;;;295          // All the rotation matrices should be 3x3
;;;296          AnkiAssert(AreEqualSize(3, 3, R1));
;;;297          AnkiAssert(AreEqualSize(3, 3, R2));
;;;298          AnkiAssert(AreEqualSize(3, 3, Rdiff));
;;;299    
;;;300          Array<Type> invR1 = Array<Type>(3,3,scratch);
;;;301          Matrix::Transpose(R1, invR1);
;;;302    
;;;303          Matrix::Multiply(invR1, R2, Rdiff);
;;;304          Tdiff = invR1 * (T2 - T1);
;;;305    
;;;306          return RESULT_OK;
;;;307        }
;;;308    
;;;309    #if 0
;;;310    #pragma mark --- Rectangle Implementations ---
;;;311    #endif
;;;312    
;;;313        template<typename Type> Rectangle<Type>::Rectangle()
;;;314          : left(static_cast<Type>(0)), right(static_cast<Type>(0)), top(static_cast<Type>(0)), bottom(static_cast<Type>(0))
;;;315        {
;;;316        }
;;;317    
;;;318        template<typename Type> Rectangle<Type>::Rectangle(const Type left, const Type right, const Type top, const Type bottom)
;;;319          : left(left), right(right), top(top), bottom(bottom)
;;;320        {
;;;321        }
;;;322    
;;;323        template<typename Type> Rectangle<Type>::Rectangle(const Rectangle<Type>& rect)
;;;324          : left(rect.left), right(rect.right), top(rect.top), bottom(rect.bottom)
;;;325        {
;;;326        }
;;;327    
;;;328        template<typename Type> void Rectangle<Type>::Print() const
;;;329        {
;;;330          CoreTechPrint("(%d,%d)->(%d,%d) ", this->left, this->top, this->right, this->bottom);
;;;331        }
;;;332    
;;;333        template<typename Type> template<typename OutType> Point<OutType> Rectangle<Type>::ComputeCenter() const
;;;334        {
;;;335          Point<OutType> center(
;;;336            (static_cast<OutType>(this->left) + static_cast<OutType>(this->right)) / 2,
;;;337            (static_cast<OutType>(this->top) + static_cast<OutType>(this->bottom)) / 2);
;;;338    
;;;339          return center;
;;;340        }
;;;341    
;;;342        template<typename Type> template<typename OutType> Rectangle<OutType> Rectangle<Type>::ComputeScaledRectangle(const f32 scalePercent) const
;;;343        {
;;;344          const f32 width = static_cast<f32>(this->get_width());
;;;345          const f32 height = static_cast<f32>(this->get_height());
;;;346    
;;;347          const f32 scaledWidth = width * scalePercent;
;;;348          const f32 scaledHeight = height * scalePercent;
;;;349    
;;;350          const f32 dx2 = (scaledWidth - width) / 2.0f;
;;;351          const f32 dy2 = (scaledHeight - height) / 2.0f;
;;;352    
;;;353          Rectangle<OutType> scaledRect(
;;;354            static_cast<OutType>( static_cast<f32>(this->left)   - dx2 ),
;;;355            static_cast<OutType>( static_cast<f32>(this->right)  + dx2 ),
;;;356            static_cast<OutType>( static_cast<f32>(this->top)    - dy2 ),
;;;357            static_cast<OutType>( static_cast<f32>(this->bottom) + dy2 ));
;;;358    
;;;359          return scaledRect;
;;;360        }
;;;361    
;;;362        template<typename Type> bool Rectangle<Type>::operator== (const Rectangle<Type> &rectangle2) const
;;;363        {
;;;364          if(this->left == rectangle2.left && this->top == rectangle2.top && this->right == rectangle2.right && this->bottom == rectangle2.bottom)
;;;365            return true;
;;;366    
;;;367          return false;
;;;368        }
;;;369    
;;;370        template<typename Type> Rectangle<Type> Rectangle<Type>::operator+ (const Rectangle<Type> &rectangle2) const
;;;371        {
;;;372          return Rectangle<Type>(this->top+rectangle2.top, this->bottom+rectangle2.bottom, this->left+rectangle2.left, this->right+rectangle2.right);
;;;373        }
;;;374    
;;;375        template<typename Type> Rectangle<Type> Rectangle<Type>::operator- (const Rectangle<Type> &rectangle2) const
;;;376        {
;;;377          return Rectangle<Type>(this->top-rectangle2.top, this->bottom-rectangle2.bottom, this->left-rectangle2.left, this->right-rectangle2.right);
;;;378        }
;;;379    
;;;380        template<typename Type> inline Rectangle<Type>& Rectangle<Type>::operator= (const Rectangle<Type> &rect2)
;;;381        {
;;;382          this->left = rect2.left;
;;;383          this->right = rect2.right;
;;;384          this->top = rect2.top;
;;;385          this->bottom = rect2.bottom;
;;;386    
;;;387          return *this;
;;;388        }
;;;389    
;;;390        template<typename Type> Type Rectangle<Type>::get_width() const
;;;391        {
;;;392          return right - left;
;;;393        }
;;;394    
;;;395        template<typename Type> Type Rectangle<Type>::get_height() const
;;;396        {
;;;397          return bottom - top;
;;;398        }
;;;399    
;;;400        // #pragma mark --- Rectangle Specializations ---
;;;401        template<> void Rectangle<f32>::Print() const;
;;;402        template<> void Rectangle<f64>::Print() const;
;;;403    
;;;404        // #pragma mark --- Quadrilateral Definitions ---
;;;405    
;;;406        template<typename Type> Quadrilateral<Type>::Quadrilateral()
;;;407        {
;;;408          for(s32 i=0; i<4; i++) {
;;;409            corners[i] = Point<Type>();
;;;410          }
;;;411        }
;;;412    
;;;413        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Point<Type> &corner1, const Point<Type> &corner2, const Point<Type> &corner3, const Point<Type> &corner4)
;;;414        {
;;;415          corners[0] = corner1;
;;;416          corners[1] = corner2;
;;;417          corners[2] = corner3;
;;;418          corners[3] = corner4;
;;;419        }
;;;420    
;;;421        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Quadrilateral<Type>& quad2)
;;;422        {
;;;423          for(s32 i=0; i<4; i++) {
;;;424            this->corners[i] = quad2.corners[i];
;;;425          }
;;;426        }
;;;427    
;;;428        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Rectangle<Type>& rect)
;;;429        {
;;;430          this->corners[0].x = rect.left;   this->corners[0].y = rect.top;
;;;431          this->corners[1].x = rect.right;  this->corners[1].y = rect.top;
;;;432          this->corners[2].x = rect.left;   this->corners[2].y = rect.bottom;
;;;433          this->corners[3].x = rect.right;  this->corners[3].y = rect.bottom;
;;;434        }
;;;435    
;;;436        template<typename Type> void Quadrilateral<Type>::Print() const
;;;437        {
;;;438          CoreTechPrint("{(%d,%d), (%d,%d), (%d,%d), (%d,%d)} ",
;;;439            this->corners[0].x, this->corners[0].y,
;;;440            this->corners[1].x, this->corners[1].y,
;;;441            this->corners[2].x, this->corners[2].y,
;;;442            this->corners[3].x, this->corners[3].y);
;;;443        }
;;;444    
;;;445        template<typename Type> template<typename OutType> Point<OutType> Quadrilateral<Type>::ComputeCenter() const
;;;446        {
;;;447          Point<OutType> center(0, 0);
;;;448    
;;;449          for(s32 i=0; i<4; i++) {
;;;450            center.x += static_cast<OutType>(this->corners[i].x);
;;;451            center.y += static_cast<OutType>(this->corners[i].y);
;;;452          }
;;;453    
;;;454          center.x /= 4;
;;;455          center.y /= 4;
;;;456    
;;;457          return center;
;;;458        }
;;;459    
;;;460        template<typename Type> template<typename OutType> Rectangle<OutType> Quadrilateral<Type>::ComputeBoundingRectangle() const
;;;461        {
;;;462          Rectangle<OutType> boundingRect(
;;;463            static_cast<OutType>(this->corners[0].x),
;;;464            static_cast<OutType>(this->corners[0].x),
;;;465            static_cast<OutType>(this->corners[0].y),
;;;466            static_cast<OutType>(this->corners[0].y));
;;;467    
;;;468          // Initialize the template rectangle to the bounding box of the given
;;;469          // quadrilateral
;;;470          for(s32 i=1; i<4; ++i) {
;;;471            boundingRect.left   = MIN(boundingRect.left,   static_cast<OutType>(this->corners[i].x));
;;;472            boundingRect.right  = MAX(boundingRect.right,  static_cast<OutType>(this->corners[i].x));
;;;473            boundingRect.top    = MIN(boundingRect.top,    static_cast<OutType>(this->corners[i].y));
;;;474            boundingRect.bottom = MAX(boundingRect.bottom, static_cast<OutType>(this->corners[i].y));
;;;475          }
;;;476    
;;;477          return boundingRect;
;;;478        }
;;;479    
;;;480        template<typename Type> template<typename OutType> Quadrilateral<OutType> Quadrilateral<Type>::ComputeClockwiseCorners() const
;;;481        {
;;;482          char tmpBuffer[128];
;;;483          MemoryStack scratch(tmpBuffer, 128);
;;;484    
;;;485          Array<f32> thetas(1,4,scratch);
;;;486          Array<s32> indexes(1,4,scratch);
;;;487          Point<f32> center = this->ComputeCenter<f32>();
;;;488    
;;;489          for(s32 i=0; i<4; i++) {
;;;490            f32 rho = 0.0f;
;;;491    
;;;492            Cart2Pol<f32>(
;;;493              static_cast<f32>(this->corners[i].x) - center.x,
;;;494              static_cast<f32>(this->corners[i].y) - center.y,
;;;495              rho, thetas[0][i]);
;;;496          }
;;;497    
;;;498          Matrix::InsertionSort(thetas, indexes, 1);
;;;499    
;;;500          const Quadrilateral<OutType> sortedQuad(
;;;501            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][0]].x), static_cast<OutType>(this->corners[indexes[0][0]].y)),
;;;502            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][1]].x), static_cast<OutType>(this->corners[indexes[0][1]].y)),
;;;503            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][2]].x), static_cast<OutType>(this->corners[indexes[0][2]].y)),
;;;504            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][3]].x), static_cast<OutType>(this->corners[indexes[0][3]].y)));
;;;505    
;;;506          return sortedQuad;
;;;507        }
;;;508    
                          ENDP

                  |L110.500|
0001f4  00000000          DCFS     0x00000000 ; 0
                  |L110.504|
                          DCD      0x07fffffe
                  |L110.508|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()

                          AREA ||area_number.111||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv, LINKORDER=||t._ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.111||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi PROC ; Anki::Embedded::Array<unsigned char>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L117.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L117.56|
00000e  4b0b              LDR      r3,|L117.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f1030250          ADD      r2,r3,#0x50
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L117.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L117.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::get_size(int) const::__PRETTY_FUNCTION__
                  |L117.60|
                          DCD      ||.constdata||+0x284

                          AREA ||area_number.118||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.118||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<int>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  b570              PUSH     {r4-r6,lr}
;;;182        {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
000006  2101              MOVS     r1,#1
000008  3018              ADDS     r0,r0,#0x18
00000a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
00000e  4601              MOV      r1,r0
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000010  2c00              CMP      r4,#0
000012  bfb4              ITE      LT
000014  2000              MOVLT    r0,#0
000016  4620              MOVGE    r0,r4
000018  4288              CMP      r0,r1
00001a  dd06              BLE      |L124.42|
00001c  2101              MOVS     r1,#1
00001e  f1050018          ADD      r0,r5,#0x18
000022  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
000026  4604              MOV      r4,r0
000028  e002              B        |L124.48|
                  |L124.42|
00002a  2c00              CMP      r4,#0
00002c  bfb8              IT       LT
00002e  2400              MOVLT    r4,#0
                  |L124.48|
000030  4620              MOV      r0,r4
;;;184    
;;;185          this->xSlice.size = newSize;
000032  60ec              STR      r4,[r5,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
000034  bd70              POP      {r4-r6,pc}
;;;189    
                          ENDP


                          AREA ||area_number.125||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.125||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListIiEC1Ev||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIiEC1Ev, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListIiEC2Ev                  ; Alternate entry point ; Anki::Embedded::FixedLengthList<int>::FixedLengthList__sub_object()
                  _ZN4Anki8Embedded15FixedLengthListIiEC1Ev PROC ; Anki::Embedded::FixedLengthList<int>::FixedLengthList()
;;;52     
;;;53         template<typename Type> FixedLengthList<Type>::FixedLengthList()
;;;54           : ArraySlice<Type>()
;;;55         {
;;;56           this->arrayData = NULL;
;;;57           this->set_size(0);
;;;58         } // FixedLengthList<Type>::FixedLengthList()
;;;59     
000000  b570              PUSH     {r4-r6,lr}
000002  f04f34ff          MOV      r4,#0xffffffff
000006  6004              STR      r4,[r0,#0]
000008  6044              STR      r4,[r0,#4]
00000a  4601              MOV      r1,r0
00000c  6084              STR      r4,[r0,#8]
00000e  f8404f0c          STR      r4,[r0,#0xc]!
000012  2500              MOVS     r5,#0
000014  6044              STR      r4,[r0,#4]
000016  6084              STR      r4,[r0,#8]
000018  f1010024          ADD      r0,r1,#0x24
00001c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000020  f8404d0c          STR      r4,[r0,#-0xc]!
000024  2100              MOVS     r1,#0
000026  6044              STR      r4,[r0,#4]
000028  6105              STR      r5,[r0,#0x10]
00002a  6084              STR      r4,[r0,#8]
00002c  6145              STR      r5,[r0,#0x14]
00002e  f1a00418          SUB      r4,r0,#0x18
000032  6185              STR      r5,[r0,#0x18]
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi ; Anki::Embedded::FixedLengthList<int>::set_size(int)
00003a  4620              MOV      r0,r4
00003c  bd70              POP      {r4-r6,pc}
                          ENDP


                          AREA ||area_number.132||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIiEC1Ev, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListIiEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.132||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListIiEC1Ev||
                          DCD      0x00000001

                          AREA ||i._ZN4Anki8Embedded5RoundIiEET_f||, COMGROUP=_ZN4Anki8Embedded5RoundIiEET_f, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded5RoundIiEET_f PROC ; Anki::Embedded::Round<int>(float)
;;;222        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(v + 0.5f) : 0; }
;;;223        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(v + 0.5f) : static_cast<s32>(v - 0.5f); }
000000  eeb50ac0          VCMPE.F32 s0,#0.0
000004  eef60a00          VMOV.F32 s1,#0.50000000
000008  eef1fa10          VMRS     APSR_nzcv,FPSCR
00000c  dd06              BLE      |L138.28|
00000e  ee300a20          VADD.F32 s0,s0,s1
000012  eebd0ac0          VCVT.S32.F32 s0,s0
000016  ee100a10          VMOV     r0,s0
00001a  4770              BX       lr
                  |L138.28|
00001c  ee300a60          VSUB.F32 s0,s0,s1
000020  eebd0ac0          VCVT.S32.F32 s0,s0
000024  ee100a10          VMOV     r0,s0
000028  4770              BX       lr
;;;224        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(v + 0.5f) : static_cast<s64>(v - 0.5f); }
                          ENDP


                          AREA ||area_number.139||, COMGROUP=_ZN4Anki8Embedded5RoundIiEET_f, LINKORDER=||i._ZN4Anki8Embedded5RoundIiEET_f||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.139||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded5RoundIiEET_f||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded10ArraySliceIiE7SetCastIiEEiRKNS0_25ConstArraySliceExpressionIiEEb||, COMGROUP=_ZN4Anki8Embedded10ArraySliceIiE7SetCastIiEEiRKNS0_25ConstArraySliceExpressionIiEEb, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded10ArraySliceIiE7SetCastIiEEiRKNS0_25ConstArraySliceExpressionIiEEb PROC ; Anki::Embedded::ArraySlice<int>::SetCast<int>(const Anki::Embedded::ConstArraySliceExpression<int>&, bool)
;;;110          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;111          template<typename InType> s32 SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  460d              MOV      r5,r1
000006  6a81              LDR      r1,[r0,#0x28]
000008  f8df8224          LDR      r8,|L145.560|
00000c  b0b1              SUB      sp,sp,#0xc4
00000e  4692              MOV      r10,r2
000010  4607              MOV      r7,r0
000012  2900              CMP      r1,#0
000014  d021              BEQ      |L145.90|
000016  69b8              LDR      r0,[r7,#0x18]
000018  2800              CMP      r0,#0
00001a  bfa4              ITT      GE
00001c  69f8              LDRGE    r0,[r7,#0x1c]
00001e  2800              CMPGE    r0,#0
000020  db1b              BLT      |L145.90|
000022  6aa8              LDR      r0,[r5,#0x28]
000024  2800              CMP      r0,#0
000026  d018              BEQ      |L145.90|
000028  69aa              LDR      r2,[r5,#0x18]
00002a  2a00              CMP      r2,#0
00002c  bfa4              ITT      GE
00002e  69ea              LDRGE    r2,[r5,#0x1c]
000030  2a00              CMPGE    r2,#0
000032  db12              BLT      |L145.90|
000034  f1070618          ADD      r6,r7,#0x18
000038  f1050418          ADD      r4,r5,#0x18
00003c  4281              CMP      r1,r0
00003e  d119              BNE      |L145.116|
000040  20ac              MOVS     r0,#0xac
000042  e9cd8000          STRD     r8,r0,[sp,#0]
000046  a37b              ADR      r3,|L145.564|
000048  a289              ADR      r2,|L145.624|
00004a  a195              ADR      r1,|L145.672|
00004c  2005              MOVS     r0,#5
00004e  f7fffffe          BL       _Anki_Log
000052  b031              ADD      sp,sp,#0xc4
000054  2000              MOVS     r0,#0
000056  e8bd8ff0          POP      {r4-r11,pc}
                  |L145.90|
00005a  20a9              MOVS     r0,#0xa9
00005c  e9cd8000          STRD     r8,r0,[sp,#0]
000060  a374              ADR      r3,|L145.564|
000062  a295              ADR      r2,|L145.696|
000064  a18e              ADR      r1,|L145.672|
000066  2005              MOVS     r0,#5
000068  f7fffffe          BL       _Anki_Log
00006c  b031              ADD      sp,sp,#0xc4
00006e  2000              MOVS     r0,#0
000070  e8bd8ff0          POP      {r4-r11,pc}
                  |L145.116|
000074  f107090c          ADD      r9,r7,#0xc
000078  f8953030          LDRB     r3,[r5,#0x30]
00007c  e9cd7900          STRD     r7,r9,[sp,#0]
000080  f105020c          ADD      r2,r5,#0xc
000084  4693              MOV      r11,r2
000086  4629              MOV      r1,r5
000088  a802              ADD      r0,sp,#8
00008a  f7fffffe          BL       _ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_ ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
00008e  f89d0008          LDRB     r0,[sp,#8]
000092  b9b0              CBNZ     r0,|L145.194|
000094  f1ba0f00          CMP      r10,#0
000098  d064              BEQ      |L145.356|
00009a  f8950030          LDRB     r0,[r5,#0x30]
00009e  e9cd7900          STRD     r7,r9,[sp,#0]
0000a2  f0800301          EOR      r3,r0,#1
0000a6  465a              MOV      r2,r11
0000a8  4629              MOV      r1,r5
0000aa  a819              ADD      r0,sp,#0x64
0000ac  f7fffffe          BL       _ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_ ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
0000b0  4601              MOV      r1,r0
0000b2  2259              MOVS     r2,#0x59
0000b4  a802              ADD      r0,sp,#8
0000b6  f7fffffe          BL       __aeabi_memcpy4
0000ba  f89d0008          LDRB     r0,[sp,#8]
0000be  2800              CMP      r0,#0
0000c0  d043              BEQ      |L145.330|
                  |L145.194|
0000c2  f89d0009          LDRB     r0,[sp,#9]
0000c6  2800              CMP      r0,#0
0000c8  f0008066          BEQ.W    |L145.408|
0000cc  9807              LDR      r0,[sp,#0x1c]
0000ce  2500              MOVS     r5,#0
0000d0  2800              CMP      r0,#0
0000d2  f34080a7          BLE.W    |L145.548|
                  |L145.214|
0000d6  9805              LDR      r0,[sp,#0x14]
0000d8  68a2              LDR      r2,[r4,#8]
0000da  6921              LDR      r1,[r4,#0x10]
0000dc  68b3              LDR      r3,[r6,#8]
0000de  fb001102          MLA      r1,r0,r2,r1
0000e2  9803              LDR      r0,[sp,#0xc]
0000e4  6932              LDR      r2,[r6,#0x10]
0000e6  fb002203          MLA      r2,r0,r3,r2
0000ea  f89d0009          LDRB     r0,[sp,#9]
0000ee  2800              CMP      r0,#0
0000f0  bf19              ITTEE    NE
0000f2  9812              LDRNE    r0,[sp,#0x48]
0000f4  9006              STRNE    r0,[sp,#0x18]
0000f6  9815              LDREQ    r0,[sp,#0x54]
0000f8  9005              STREQ    r0,[sp,#0x14]
0000fa  980c              LDR      r0,[sp,#0x30]
0000fc  9004              STR      r0,[sp,#0x10]
0000fe  9b08              LDR      r3,[sp,#0x20]
000100  2000              MOVS     r0,#0
000102  2b00              CMP      r3,#0
000104  dd14              BLE      |L145.304|
                  |L145.262|
000106  9b06              LDR      r3,[sp,#0x18]
000108  f8ddc010          LDR      r12,[sp,#0x10]
00010c  1c40              ADDS     r0,r0,#1
00010e  f8513023          LDR      r3,[r1,r3,LSL #2]
000112  f842302c          STR      r3,[r2,r12,LSL #2]
000116  f8ddc024          LDR      r12,[sp,#0x24]
00011a  9b04              LDR      r3,[sp,#0x10]
00011c  4463              ADD      r3,r3,r12
00011e  9304              STR      r3,[sp,#0x10]
000120  f8ddc028          LDR      r12,[sp,#0x28]
000124  9b06              LDR      r3,[sp,#0x18]
000126  4463              ADD      r3,r3,r12
000128  9306              STR      r3,[sp,#0x18]
00012a  9b08              LDR      r3,[sp,#0x20]
00012c  4283              CMP      r3,r0
00012e  dcea              BGT      |L145.262|
                  |L145.304|
000130  f89d0009          LDRB     r0,[sp,#9]
000134  2800              CMP      r0,#0
000136  d022              BEQ      |L145.382|
000138  9916              LDR      r1,[sp,#0x58]
00013a  9805              LDR      r0,[sp,#0x14]
00013c  4408              ADD      r0,r0,r1
00013e  9005              STR      r0,[sp,#0x14]
000140  9910              LDR      r1,[sp,#0x40]
000142  9803              LDR      r0,[sp,#0xc]
000144  4408              ADD      r0,r0,r1
000146  9003              STR      r0,[sp,#0xc]
000148  e021              B        |L145.398|
                  |L145.330|
00014a  20b9              MOVS     r0,#0xb9
00014c  e9cd8000          STRD     r8,r0,[sp,#0]
000150  a338              ADR      r3,|L145.564|
000152  a25d              ADR      r2,|L145.712|
000154  a152              ADR      r1,|L145.672|
000156  2005              MOVS     r0,#5
000158  f7fffffe          BL       _Anki_Log
00015c  b031              ADD      sp,sp,#0xc4
00015e  2000              MOVS     r0,#0
000160  e8bd8ff0          POP      {r4-r11,pc}
                  |L145.356|
000164  20bd              MOVS     r0,#0xbd
000166  e9cd8000          STRD     r8,r0,[sp,#0]
00016a  a332              ADR      r3,|L145.564|
00016c  a256              ADR      r2,|L145.712|
00016e  a14c              ADR      r1,|L145.672|
000170  2005              MOVS     r0,#5
000172  f7fffffe          BL       _Anki_Log
000176  b031              ADD      sp,sp,#0xc4
000178  2000              MOVS     r0,#0
00017a  e8bd8ff0          POP      {r4-r11,pc}
                  |L145.382|
00017e  9913              LDR      r1,[sp,#0x4c]
000180  9806              LDR      r0,[sp,#0x18]
000182  4408              ADD      r0,r0,r1
000184  9006              STR      r0,[sp,#0x18]
000186  9910              LDR      r1,[sp,#0x40]
000188  9803              LDR      r0,[sp,#0xc]
00018a  4408              ADD      r0,r0,r1
00018c  9003              STR      r0,[sp,#0xc]
                  |L145.398|
00018e  9807              LDR      r0,[sp,#0x1c]
000190  1c6d              ADDS     r5,r5,#1
000192  42a8              CMP      r0,r5
000194  dc9f              BGT      |L145.214|
000196  e045              B        |L145.548|
                  |L145.408|
000198  9807              LDR      r0,[sp,#0x1c]
00019a  2300              MOVS     r3,#0
00019c  2800              CMP      r0,#0
00019e  dd41              BLE      |L145.548|
                  |L145.416|
0001a0  9803              LDR      r0,[sp,#0xc]
0001a2  68b2              LDR      r2,[r6,#8]
0001a4  6931              LDR      r1,[r6,#0x10]
0001a6  fb001c02          MLA      r12,r0,r2,r1
0001aa  f89d0009          LDRB     r0,[sp,#9]
0001ae  2800              CMP      r0,#0
0001b0  bf19              ITTEE    NE
0001b2  9812              LDRNE    r0,[sp,#0x48]
0001b4  9006              STRNE    r0,[sp,#0x18]
0001b6  9815              LDREQ    r0,[sp,#0x54]
0001b8  9005              STREQ    r0,[sp,#0x14]
0001ba  980c              LDR      r0,[sp,#0x30]
0001bc  9004              STR      r0,[sp,#0x10]
0001be  9908              LDR      r1,[sp,#0x20]
0001c0  2000              MOVS     r0,#0
0001c2  2900              CMP      r1,#0
0001c4  dd16              BLE      |L145.500|
                  |L145.454|
0001c6  e9dd2105          LDRD     r2,r1,[sp,#0x14]
0001ca  68a7              LDR      r7,[r4,#8]
0001cc  6925              LDR      r5,[r4,#0x10]
0001ce  1c40              ADDS     r0,r0,#1
0001d0  fb025207          MLA      r2,r2,r7,r5
0001d4  f8521021          LDR      r1,[r2,r1,LSL #2]
0001d8  9a04              LDR      r2,[sp,#0x10]
0001da  f84c1022          STR      r1,[r12,r2,LSL #2]
0001de  9a09              LDR      r2,[sp,#0x24]
0001e0  9904              LDR      r1,[sp,#0x10]
0001e2  4411              ADD      r1,r1,r2
0001e4  9104              STR      r1,[sp,#0x10]
0001e6  9a0b              LDR      r2,[sp,#0x2c]
0001e8  9905              LDR      r1,[sp,#0x14]
0001ea  4411              ADD      r1,r1,r2
0001ec  9105              STR      r1,[sp,#0x14]
0001ee  9908              LDR      r1,[sp,#0x20]
0001f0  4281              CMP      r1,r0
0001f2  dce8              BGT      |L145.454|
                  |L145.500|
0001f4  f89d0009          LDRB     r0,[sp,#9]
0001f8  b140              CBZ      r0,|L145.524|
0001fa  9916              LDR      r1,[sp,#0x58]
0001fc  9805              LDR      r0,[sp,#0x14]
0001fe  4408              ADD      r0,r0,r1
000200  9005              STR      r0,[sp,#0x14]
000202  9910              LDR      r1,[sp,#0x40]
000204  9803              LDR      r0,[sp,#0xc]
000206  4408              ADD      r0,r0,r1
000208  9003              STR      r0,[sp,#0xc]
00020a  e007              B        |L145.540|
                  |L145.524|
00020c  9913              LDR      r1,[sp,#0x4c]
00020e  9806              LDR      r0,[sp,#0x18]
000210  4408              ADD      r0,r0,r1
000212  9006              STR      r0,[sp,#0x18]
000214  9910              LDR      r1,[sp,#0x40]
000216  9803              LDR      r0,[sp,#0xc]
000218  4408              ADD      r0,r0,r1
00021a  9003              STR      r0,[sp,#0xc]
                  |L145.540|
00021c  9807              LDR      r0,[sp,#0x1c]
00021e  1c5b              ADDS     r3,r3,#1
000220  4298              CMP      r0,r3
000222  dcbd              BGT      |L145.416|
                  |L145.548|
000224  9908              LDR      r1,[sp,#0x20]
000226  b031              ADD      sp,sp,#0xc4
000228  4348              MULS     r0,r1,r0
00022a  e8bd8ff0          POP      {r4-r11,pc}
;;;112          //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;113    
;;;114          // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;115          // don't support the full ArraySlice type, and should be used with caution.
;;;116          Array<Type>& get_array();
;;;117    
;;;118        protected:
;;;119    
;;;120          // For speed, this is a direct pointer to the Array's protected data
;;;121          Type * arrayData;
;;;122        }; // template<typename Type> class ArraySlice
;;;123    
;;;124        // An ConstArraySliceExpression is like a ConstArraySlice, but can also be transposed
;;;125        // It may have other abilities in the future, but will probably always be const
;;;126        template<typename Type> class ConstArraySliceExpression : public ConstArraySlice<Type>
;;;127        {
;;;128        public:
;;;129          ConstArraySliceExpression();
;;;130    
;;;131          ConstArraySliceExpression(const Array<Type> input, bool isTransposed=false);
;;;132    
;;;133          ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed=false);
;;;134    
;;;135          ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed=false);
;;;136    
;;;137          // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;138          // This object isn't modified, but the returned object is.
;;;139          ConstArraySliceExpression<Type> Transpose() const;
;;;140    
;;;141          bool get_isTransposed() const;
;;;142    
;;;143        protected:
;;;144          bool isTransposed;
;;;145        };
;;;146    
;;;147        // To simplify the creation of kernels using an ArraySlice, and to aid the compiler optimizer,
;;;148        // an ArraySliceLimits can be initialized at the beginning of the function, then used as the
;;;149        // limits for the inner loops.
;;;150    
;;;151        // The suffix of in# and out# refer to the number of input and output matrices.
;;;152        // If output == 0, then the output is a scalar.
;;;153    
;;;154        template<typename Type> class ArraySliceSimpleLimits
;;;155        {
;;;156        public:
;;;157          Type xStart;
;;;158          Type xIncrement;
;;;159          s32  xSize;
;;;160    
;;;161          Type yStart;
;;;162          Type yIncrement;
;;;163          s32  ySize;
;;;164    
;;;165          ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;166        };
;;;167    
;;;168        // In1 and out0 is a special, ultra-simple case, for one matrix input and a scalar output
;;;169        template<typename Type> class ArraySliceLimits_in1_out0
;;;170        {
;;;171        public:
;;;172          // Was this ArraySliceLimits initialized?
;;;173          bool isValid;
;;;174    
;;;175          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;176    
;;;177          ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;178        };
;;;179    
;;;180        // One input, one output
;;;181        template<typename Type> class ArraySliceLimits_in1_out1
;;;182        {
;;;183        public:
;;;184          // Was this ArraySliceLimits initialized?
;;;185          bool isValid;
;;;186    
;;;187          // Can a simple (non-transposed) iteration be performed?
;;;188          bool isSimpleIteration;
;;;189    
;;;190          // These are the current values for the coordinates in the input and output images
;;;191          s32 out1Y;
;;;192          s32 out1X;
;;;193          s32 in1Y;
;;;194          s32 in1X;
;;;195    
;;;196          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;197          s32 ySize;
;;;198          s32 xSize;
;;;199    
;;;200          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;201          // incremented every iteration of the inner loop
;;;202          s32 out1_xInnerIncrement;
;;;203          s32 in1_xInnerIncrement;
;;;204          s32 in1_yInnerIncrement;
;;;205    
;;;206          ArraySliceLimits_in1_out1(
;;;207            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;208            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;209    
;;;210          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;211          inline void OuterIncrementTop();
;;;212    
;;;213          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;214          inline void OuterIncrementBottom();
;;;215    
;;;216        protected:
;;;217          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;218    
;;;219          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;220          bool in1_isTransposed;
;;;221        };
;;;222    
;;;223        // Two inputs, one output
;;;224        template<typename Type> class ArraySliceLimits_in2_out1
;;;225        {
;;;226        public:
;;;227          // Was this ArraySliceLimits initialized?
;;;228          bool isValid;
;;;229    
;;;230          // Can a simple (non-transposed) iteration be performed?
;;;231          bool isSimpleIteration;
;;;232    
;;;233          // These are the current values for the coordinates in the input and output images
;;;234          s32 out1Y;
;;;235          s32 out1X;
;;;236          s32 in1Y;
;;;237          s32 in1X;
;;;238          s32 in2Y;
;;;239          s32 in2X;
;;;240    
;;;241          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;242          s32 ySize;
;;;243          s32 xSize;
;;;244    
;;;245          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;246          // incremented every iteration of the inner loop
;;;247          s32 out1_xInnerIncrement;
;;;248          s32 in1_xInnerIncrement;
;;;249          s32 in1_yInnerIncrement;
;;;250          s32 in2_xInnerIncrement;
;;;251          s32 in2_yInnerIncrement;
;;;252    
;;;253          ArraySliceLimits_in2_out1(
;;;254            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;255            const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed,
;;;256            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;257    
;;;258          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;259          inline void OuterIncrementTop();
;;;260    
;;;261          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;262          inline void OuterIncrementBottom();
;;;263    
;;;264        protected:
;;;265          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;266    
;;;267          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;268          bool in1_isTransposed;
;;;269    
;;;270          ArraySliceSimpleLimits<Type> rawIn2Limits;
;;;271          bool in2_isTransposed;
;;;272        };
;;;273      } // namespace Embedded
;;;274    } // namespace Anki
;;;275    
;;;276    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         class SerializedBuffer;
;;;24     
;;;25         // A FixedLengthList is a list with a fixed maximum size, which is allocated at construction.
;;;26         template<typename Type> class FixedLengthList : public ArraySlice<Type>
;;;27         {
;;;28         public:
;;;29           FixedLengthList();
;;;30     
;;;31           // Constructor for a FixedLengthList, pointing to user-allocated data.
;;;32           FixedLengthList(s32 maximumSize, void * data, s32 dataLength, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;33     
;;;34           // Constructor for a FixedLengthList, pointing to user-allocated MemoryStack
;;;35           FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;36     
;;;37           bool IsValid() const;
;;;38     
;;;39           // Resize will use MemoryStack::Reallocate() to change the FixedLengthList's size. It only works if this
;;;40           // FixedLengthList was the last thing allocated. The reallocated memory will not be cleared
;;;41           //
;;;42           // WARNING:
;;;43           // This will not update any references to the memory, you must update all references manually.
;;;44           Result Resize(s32 maximumSize, MemoryStack &memory);
;;;45     
;;;46           Result PushBack(const Type &value);
;;;47     
;;;48           // Will act as a normal pop, except when the list is empty. Then subsequent
;;;49           // calls will keep returning the first value in the list.
;;;50           Type PopBack();
;;;51     
;;;52           // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
;;;53           inline void Clear();
;;;54     
;;;55           // Does this ever need to be declared explicitly?
;;;56           //FixedLengthList& operator= (const FixedLengthList & rightHandSide);
;;;57     
;;;58           // Pointer to the data, at a given location
;;;59           inline Type* Pointer(const s32 index);
;;;60           inline const Type* Pointer(const s32 index) const;
;;;61     
;;;62           // Use this operator for normal C-style vector indexing. For example, "list[5] = 6;" will set
;;;63           // the element in the fifth row and first column to 6. This is the same as "*list.Pointer(5) =
;;;64           // 6;"
;;;65           //
;;;66           // NOTE:
;;;67           // Using this in a inner loop may be less efficient than using an explicit pointer with a
;;;68           // restrict keyword (Though the runtime cost isn't nearly as large as the [] operator for the
;;;69           // Array class). For speeding up performance-critical inner loops, use something like: "Type *
;;;70           // restrict pList = list.Pointer(0);" outside the inner loop, then index
;;;71           // pList in the inner loop.
;;;72           inline const Type& operator[](const s32 index) const;
;;;73           inline Type& operator[](const s32 index);
;;;74     
;;;75           // Print out the contents of this FixedLengthList
;;;76           Result Print(const char * const variableName = "FixedLengthList", const s32 minIndex = 0, const s32 maxIndex = 0x7FFFFFE) const;
;;;77     
;;;78           // Set every element in the Array to zero, including the stride padding, but not including the optional fill patterns (if they exist)
;;;79           // Returns the number of bytes set to zero
;;;80           inline s32 SetZero();
;;;81     
;;;82           // Read in the input, then cast it to this object's type
;;;83           //
;;;84           // WARNING:
;;;85           // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;86           template<typename InType> s32 SetCast(const FixedLengthList<InType> &input, bool automaticTranspose=true);
;;;87           //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;88     
;;;89           // The maximum size is set at object construction
;;;90           inline s32 get_maximumSize() const;
;;;91     
;;;92           // The current size changes as the FixedLengthList is used
;;;93           inline s32 get_size() const;
;;;94     
;;;95           // Attempt to set the size to newSize. Returns the value that was actually set.
;;;96           s32 set_size(s32 newSize);
;;;97     
;;;98         protected:
;;;99           // TODO: make less hacky
;;;100          friend class SerializedBuffer;
;;;101        }; // class FixedLengthList
;;;102      } // namespace Embedded
;;;103    } //namespace Anki
;;;104    
;;;105    #endif // _ANKICORETECHEMBEDDED_COMMON_FIXEDLENGTHLIST_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;1      /**
;;;2      File: utilities.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of utilities_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;14     
;;;15     #include "anki/common/robot/utilities_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;17     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;2      * File: trig_fast.h
;;;3      *
;;;4      * Author: Kevin Yoon
;;;5      * Created: 22-OCT-2012
;;;6      *
;;;7      * Some trig functions to supplement incomplete math libraries on embedded targets.
;;;8      * Error of all functions is less than +/- 0.01.
;;;9      * For bettery accuracy, lookup tables should be regenerated with u16.
;;;10     *
;;;11     **/
;;;12     #ifndef _TRIG_FAST_H
;;;13     #define _TRIG_FAST_H
;;;14     
;;;15     // When USE_SMALL_LUT defined, a smaller lookup table is used to conserve space.
;;;16     // USE_INTERPOLATION is also automatically defined, since without it answers are probably too wrong to be useful.
;;;17     // If USE_SMALL_LUT is not defined, a large LUT is used.
;;;18     //#define USE_SMALL_LUT
;;;19     
;;;20     // When defined, interpolates between lookup values for higher accuracy.
;;;21     #define USE_INTERPOLATION
;;;22     
;;;23     // Arctangent function based on lookup table
;;;24     // returns answer in radians
;;;25     float atan_fast(float x);
;;;26     
;;;27     // Arcsine function based on lookup table
;;;28     // returns answer in radians
;;;29     float asin_fast(float x);
;;;30     
;;;31     // Arctangent function which uses atan_fast
;;;32     // returns answer in radians
;;;33     float atan2_fast(float y, float x);
;;;34     
;;;35     // Arctangent function which uses asin from math.h
;;;36     // Useful on embedded systems that don't include atan2 in math.h
;;;37     // More accurate than atan2_fast.
;;;38     // Nothing particularly fast about this implementation.
;;;39     // returns answer in radians
;;;40     float atan2_acc(float y, float x);
;;;41     
;;;42     #endif
;;;19     
;;;20     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;21     #include "opencv2/core/core.hpp"
;;;22     #endif
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         //template<typename Type> inline Type RoundUp(const Type number, const Type multiple)
;;;29     
;;;30         // void* and size_t is a special case, good for aligning pointers
;;;31         inline const void* RoundUp(const void* number, const size_t multiple)
;;;32         {
;;;33           const size_t numberT = reinterpret_cast<size_t>(number);
;;;34           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;35         }
;;;36     
;;;37         inline void* RoundUp(void* number, const size_t multiple)
;;;38         {
;;;39           const size_t numberT = reinterpret_cast<size_t>(number);
;;;40           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;41         }
;;;42     
;;;43         template<> inline u32 RoundUp(const u32 number, const u32 multiple)
;;;44         {
;;;45           return (number + (multiple-1)) & ~(multiple-1);
;;;46         }
;;;47     
;;;48         template<> inline s32 RoundUp(const s32 number, const s32 multiple)
;;;49         {
;;;50           if(number <= 0) {
;;;51             return multiple*( number/multiple );
;;;52           } else {
;;;53             return multiple*( (number-1)/multiple + 1 );
;;;54           }
;;;55         }
;;;56     
;;;57     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;58         template<> inline unsigned long RoundUp(const unsigned long number, const unsigned long multiple)
;;;59         {
;;;60           return (number + (multiple-1)) & ~(multiple-1);
;;;61         }
;;;62     #endif
;;;63     
;;;64         template<> inline u32 RoundDown(const u32 number, const u32 multiple)
;;;65         {
;;;66           return multiple * (number/multiple);
;;;67         }
;;;68     
;;;69         template<> inline s32 RoundDown(const s32 number, const s32 multiple)
;;;70         {
;;;71           if(number < 0) {
;;;72             return multiple * ((number-multiple+1) / multiple);
;;;73           } else {
;;;74             return multiple * (number/multiple);
;;;75           }
;;;76         }
;;;77     
;;;78     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;79         template<> inline unsigned long RoundDown(const unsigned long number, const unsigned long multiple)
;;;80         {
;;;81           return multiple * (number/multiple);
;;;82         }
;;;83     #endif
;;;84     
;;;85         template<typename Type> Type ApproximateExp(const Type exponent, const s32 numTerms)
;;;86         {
;;;87           AnkiAssert(numTerms > 2);
;;;88     
;;;89           const Type exponentAbs = ABS(exponent);
;;;90     
;;;91           Type sum = static_cast<Type>(1) + exponentAbs;
;;;92     
;;;93           Type numerator = static_cast<Type>(exponentAbs);
;;;94           Type denominator = static_cast<Type>(1);
;;;95           for(s32 i=2; i<=numTerms; i++) {
;;;96             numerator *= exponentAbs;
;;;97             denominator *= i;
;;;98     
;;;99             sum += numerator / denominator;
;;;100          }
;;;101    
;;;102          if(exponent < 0) {
;;;103            sum = static_cast<Type>(1) / sum;
;;;104          }
;;;105    
;;;106          return sum;
;;;107        }
;;;108    
;;;109        template<typename Type> void Swap(Type &a, Type &b)
;;;110        {
;;;111          const Type tmp = a;
;;;112          a = b;
;;;113          b = tmp;
;;;114        } // template<typename Type> Swap(Type a, Type b)
;;;115    
;;;116        template<typename Type> u32 BinaryStringToUnsignedNumber(const FixedLengthList<Type> &bits, bool firstBitIsLow)
;;;117        {
;;;118          u32 number = 0;
;;;119    
;;;120          const s32 numBits = bits.get_size();
;;;121    
;;;122          for(s32 bit=0; bit<numBits; bit++) {
;;;123            if(firstBitIsLow) {
;;;124              if(bit == 0) {
;;;125                number += bits[bit];
;;;126              } else {
;;;127                number += bits[bit] << bit;
;;;128              }
;;;129            } else {
;;;130              if(bit == (numBits-1)) {
;;;131                number += bits[bit];
;;;132              } else {
;;;133                number += bits[bit] << (numBits - bit - 1);
;;;134              }
;;;135            }
;;;136          }
;;;137    
;;;138          return number;
;;;139        }
;;;140    
;;;141        template<typename Type> Type Determinant2x2(const Type a, const Type b, const Type c, const Type d)
;;;142        {
;;;143          return a*d - b*c;
;;;144        }
;;;145    
;;;146        template<typename Type> Type Determinant3x3(const Type a, const Type b, const Type c, const Type d, const Type e, const Type f, const Type g, const Type h, const Type i)
;;;147        {
;;;148          return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
;;;149        }
;;;150    
;;;151        template<typename Type> void Invert3x3(Type &a, Type &b, Type &c, Type &d, Type &e, Type &f, Type &g, Type &h, Type &i)
;;;152        {
;;;153          const Type determinant = Determinant3x3(a,b,c,d,e,f,g,h,i);
;;;154          const Type determinantInverse = static_cast<Type>(1) / determinant;
;;;155    
;;;156          const Type A =  (e*i - f*h);
;;;157          const Type B = -(d*i - f*g);
;;;158          const Type C =  (d*h - e*g);
;;;159          const Type D = -(b*i - c*h);
;;;160          const Type E =  (a*i - c*g);
;;;161          const Type F = -(a*h - b*g);
;;;162          const Type G =  (b*f - c*e);
;;;163          const Type H = -(a*f - c*d);
;;;164          const Type I =  (a*e - b*d);
;;;165    
;;;166          a = A * determinantInverse;
;;;167          b = D * determinantInverse;
;;;168          c = G * determinantInverse;
;;;169          d = B * determinantInverse;
;;;170          e = E * determinantInverse;
;;;171          f = H * determinantInverse;
;;;172          g = C * determinantInverse;
;;;173          h = F * determinantInverse;
;;;174          i = I * determinantInverse;
;;;175        }
;;;176    
;;;177        template<typename Type> void Cart2Pol(const Type x, const Type y, Type &rho, Type &theta)
;;;178        {
;;;179          if (x==0 && y==0) {
;;;180            theta = 0;
;;;181            rho = 0;
;;;182          } else {
;;;183            theta = atan2f(y, x);
;;;184            rho = sqrtf(x*x + y*y);
;;;185          }
;;;186        }
;;;187    
;;;188        template<typename Type> void Pol2Cart(const Type rho, const Type theta, Type &x, Type &y)
;;;189        {
;;;190          x = rho * cosf(theta);
;;;191          y = rho * sinf(theta);
;;;192        }
;;;193    
;;;194        inline s32 FloorS32(f32 x)
;;;195        {
;;;196          return static_cast<s32>(floorf(x));
;;;197        }
;;;198    
;;;199        inline s32 CeilS32(f32 x)
;;;200        {
;;;201          return static_cast<s32>(ceilf(x));
;;;202        }
;;;203    
;;;204    #if !defined(__EDG__)
;;;205        // Some platforms may not round to zero correctly, so do the function calls
;;;206        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(floorf(v + 0.5f)) : 0; }
;;;207        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(floorf(v + 0.5f)) : 0; }
;;;208        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(floorf(v + 0.5f)) : static_cast<s32>(ceilf(v - 0.5f)); }
;;;209        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(floorf(v + 0.5f)) : static_cast<s64>(ceilf(v - 0.5f)); }
;;;210        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;211        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;212    
;;;213        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(floor(v + 0.5)) : 0; }
;;;214        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(floor(v + 0.5)) : 0; }
;;;215        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(floor(v + 0.5)) : static_cast<s32>(ceil(v - 0.5)); }
;;;216        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(floor(v + 0.5)) : static_cast<s64>(ceil(v - 0.5)); }
;;;217        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;218        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;219    #else
;;;220        // The M4 rounds to zero correctly, without the function calls
;;;221        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(v + 0.5f) : 0; }
;;;222        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(v + 0.5f) : 0; }
;;;223        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(v + 0.5f) : static_cast<s32>(v - 0.5f); }
;;;224        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(v + 0.5f) : static_cast<s64>(v - 0.5f); }
;;;225        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;226        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;227    
;;;228        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(v + 0.5) : 0; }
;;;229        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(v + 0.5) : 0; }
;;;230        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(v + 0.5) : static_cast<s32>(v - 0.5); }
;;;231        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(v + 0.5) : static_cast<s64>(v - 0.5); }
;;;232        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;233        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;234    #endif
;;;235    
;;;236        // Most cases of RoundIfInteger are from int-to-int or float-to-float, so just do a normal cast
;;;237        template<typename Type> inline Type RoundIfInteger(const u8  v) { return static_cast<Type>(v); }
;;;238        template<typename Type> inline Type RoundIfInteger(const s8  v) { return static_cast<Type>(v); }
;;;239        template<typename Type> inline Type RoundIfInteger(const u16 v) { return static_cast<Type>(v); }
;;;240        template<typename Type> inline Type RoundIfInteger(const s16 v) { return static_cast<Type>(v); }
;;;241        template<typename Type> inline Type RoundIfInteger(const u32 v) { return static_cast<Type>(v); }
;;;242        template<typename Type> inline Type RoundIfInteger(const s32 v) { return static_cast<Type>(v); }
;;;243        template<typename Type> inline Type RoundIfInteger(const u64 v) { return static_cast<Type>(v); }
;;;244        template<typename Type> inline Type RoundIfInteger(const s64 v) { return static_cast<Type>(v); }
;;;245        template<typename Type> inline Type RoundIfInteger(const f32 v) { return static_cast<Type>(v); }
;;;246        template<typename Type> inline Type RoundIfInteger(const f64 v) { return static_cast<Type>(v); }
;;;247    
;;;248        // Specialize for cases with float-to-int
;;;249        template<> inline u8  RoundIfInteger(const f32 v) { return static_cast<u8> (Round<s32>(v)); }
;;;250        template<> inline s8  RoundIfInteger(const f32 v) { return static_cast<s8> (Round<s32>(v)); }
;;;251        template<> inline u16 RoundIfInteger(const f32 v) { return static_cast<u16>(Round<s32>(v)); }
;;;252        template<> inline s16 RoundIfInteger(const f32 v) { return static_cast<s16>(Round<s32>(v)); }
;;;253        template<> inline u32 RoundIfInteger(const f32 v) { return static_cast<u32>(Round<u32>(v)); }
;;;254        template<> inline s32 RoundIfInteger(const f32 v) { return static_cast<s32>(Round<s32>(v)); }
;;;255        template<> inline u64 RoundIfInteger(const f32 v) { return static_cast<u64>(Round<u64>(v)); }
;;;256        template<> inline s64 RoundIfInteger(const f32 v) { return static_cast<s64>(Round<s64>(v)); }
;;;257    
;;;258        template<> inline u8  RoundIfInteger(const f64 v) { return static_cast<u8> (Round<s32>(v)); }
;;;259        template<> inline s8  RoundIfInteger(const f64 v) { return static_cast<s8> (Round<s32>(v)); }
;;;260        template<> inline u16 RoundIfInteger(const f64 v) { return static_cast<u16>(Round<s32>(v)); }
;;;261        template<> inline s16 RoundIfInteger(const f64 v) { return static_cast<s16>(Round<s32>(v)); }
;;;262        template<> inline u32 RoundIfInteger(const f64 v) { return static_cast<u32>(Round<u32>(v)); }
;;;263        template<> inline s32 RoundIfInteger(const f64 v) { return static_cast<s32>(Round<s32>(v)); }
;;;264        template<> inline u64 RoundIfInteger(const f64 v) { return static_cast<u64>(Round<u64>(v)); }
;;;265        template<> inline s64 RoundIfInteger(const f64 v) { return static_cast<s64>(Round<s64>(v)); }
;;;266    
;;;267        // Floats and complex data types aren't specialized
;;;268        template<typename Type> inline Type saturate_cast(const u8  v) { return static_cast<Type>(v); }
;;;269        template<typename Type> inline Type saturate_cast(const s8  v) { return static_cast<Type>(v); }
;;;270        template<typename Type> inline Type saturate_cast(const u16 v) { return static_cast<Type>(v); }
;;;271        template<typename Type> inline Type saturate_cast(const s16 v) { return static_cast<Type>(v); }
;;;272        template<typename Type> inline Type saturate_cast(const u32 v) { return static_cast<Type>(v); }
;;;273        template<typename Type> inline Type saturate_cast(const s32 v) { return static_cast<Type>(v); }
;;;274        template<typename Type> inline Type saturate_cast(const u64 v) { return static_cast<Type>(v); }
;;;275        template<typename Type> inline Type saturate_cast(const s64 v) { return static_cast<Type>(v); }
;;;276        template<typename Type> inline Type saturate_cast(const f32 v) { return static_cast<Type>(v); }
;;;277        template<typename Type> inline Type saturate_cast(const f64 v) { return static_cast<Type>(v); }
;;;278    
;;;279        // Most saturate_cast calls are explicitly specialized
;;;280        template<> inline u8  saturate_cast<u8> (const u8  v) { return v; }
;;;281        template<> inline u8  saturate_cast<u8> (const u16 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;282        template<> inline u8  saturate_cast<u8> (const u32 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;283        template<> inline u8  saturate_cast<u8> (const u64 v) { return (u8)             MIN((u64)u8_MAX, (u64)v); }
;;;284        template<> inline u8  saturate_cast<u8> (const s8  v) { return (u8)                              MAX((s32)0, (s32)v);  }
;;;285        template<> inline u8  saturate_cast<u8> (const s16 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;286        template<> inline u8  saturate_cast<u8> (const s32 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;287        template<> inline u8  saturate_cast<u8> (const s64 v) { return (u8)             MIN((s64)u8_MAX, MAX((s64)0, (s64)v)); }
;;;288        template<> inline u8  saturate_cast<u8> (const f32 v) { return (u8) Round<s32>( MIN((f32)u8_MAX, MAX((f32)0, (f32)v)) ); }
;;;289        template<> inline u8  saturate_cast<u8> (const f64 v) { return (u8) Round<s32>( MIN((f64)u8_MAX, MAX((f64)0, (f64)v)) ); }
;;;290    
;;;291        template<> inline s8  saturate_cast<s8> (const u8  v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;292        template<> inline s8  saturate_cast<s8> (const u16 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;293        template<> inline s8  saturate_cast<s8> (const u32 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;294        template<> inline s8  saturate_cast<s8> (const u64 v) { return (s8)             MIN((u64)s8_MAX, (u64)v); }
;;;295        template<> inline s8  saturate_cast<s8> (const s8  v) { return v; }
;;;296        template<> inline s8  saturate_cast<s8> (const s16 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;297        template<> inline s8  saturate_cast<s8> (const s32 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;298        template<> inline s8  saturate_cast<s8> (const s64 v) { return (s8)             MIN((s64)s8_MAX, MAX((s64)s8_MIN, (s64)v)); }
;;;299        template<> inline s8  saturate_cast<s8> (const f32 v) { return (s8) Round<s32>( MIN((f32)s8_MAX, MAX((f32)s8_MIN, (f32)v)) ); }
;;;300        template<> inline s8  saturate_cast<s8> (const f64 v) { return (s8) Round<s32>( MIN((f64)s8_MAX, MAX((f64)s8_MIN, (f64)v)) ); }
;;;301    
;;;302        template<> inline u16 saturate_cast<u16>(const u8  v) { return v; }
;;;303        template<> inline u16 saturate_cast<u16>(const u16 v) { return v; }
;;;304        template<> inline u16 saturate_cast<u16>(const u32 v) { return (u16)             MIN((u32)u16_MAX, (u32)v); }
;;;305        template<> inline u16 saturate_cast<u16>(const u64 v) { return (u16)             MIN((u64)u16_MAX, (u64)v); }
;;;306        template<> inline u16 saturate_cast<u16>(const s8  v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;307        template<> inline u16 saturate_cast<u16>(const s16 v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;308        template<> inline u16 saturate_cast<u16>(const s32 v) { return (u16)             MIN((s32)u16_MAX, MAX((s32)0, (s32)v)); }
;;;309        template<> inline u16 saturate_cast<u16>(const s64 v) { return (u16)             MIN((s64)u16_MAX, MAX((s64)0, (s64)v)); }
;;;310        template<> inline u16 saturate_cast<u16>(const f32 v) { return (u16) Round<s32>( MIN((f32)u16_MAX, MAX((f32)0, (f32)v)) ); }
;;;311        template<> inline u16 saturate_cast<u16>(const f64 v) { return (u16) Round<s32>( MIN((f64)u16_MAX, MAX((f64)0, (f64)v)) ); }
;;;312    
;;;313        template<> inline s16 saturate_cast<s16>(const u8  v) { return v; }
;;;314        template<> inline s16 saturate_cast<s16>(const u16 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;315        template<> inline s16 saturate_cast<s16>(const u32 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;316        template<> inline s16 saturate_cast<s16>(const u64 v) { return (s16)             MIN((u64)s16_MAX, (u64)v); }
;;;317        template<> inline s16 saturate_cast<s16>(const s8  v) { return v; }
;;;318        template<> inline s16 saturate_cast<s16>(const s16 v) { return v; }
;;;319        template<> inline s16 saturate_cast<s16>(const s32 v) { return (s16)             MIN((s32)s16_MAX, MAX((s32)s16_MIN, (s32)v)); }
;;;320        template<> inline s16 saturate_cast<s16>(const s64 v) { return (s16)             MIN((s64)s16_MAX, MAX((s64)s16_MIN, (s64)v)); }
;;;321        template<> inline s16 saturate_cast<s16>(const f32 v) { return (s16) Round<s32>( MIN((f32)s16_MAX, MAX((f32)s16_MIN, (f32)v)) ); }
;;;322        template<> inline s16 saturate_cast<s16>(const f64 v) { return (s16) Round<s32>( MIN((f64)s16_MAX, MAX((f64)s16_MIN, (f64)v)) ); }
;;;323    
;;;324        template<> inline u32 saturate_cast<u32>(const u8  v) { return v; }
;;;325        template<> inline u32 saturate_cast<u32>(const u16 v) { return v; }
;;;326        template<> inline u32 saturate_cast<u32>(const u32 v) { return v; }
;;;327        template<> inline u32 saturate_cast<u32>(const u64 v) { return (u32)             MIN((u64)u32_MAX, (u64)v); }
;;;328        template<> inline u32 saturate_cast<u32>(const s8  v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;329        template<> inline u32 saturate_cast<u32>(const s16 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;330        template<> inline u32 saturate_cast<u32>(const s32 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;331        template<> inline u32 saturate_cast<u32>(const s64 v) { return (u32)             MIN((s64)u32_MAX, MAX((s64)0, (s64)v)); }
;;;332        template<> inline u32 saturate_cast<u32>(const f32 v) { return (u32) (v > (f32)0xFFFFFF7F) ? 0xFFFFFFFF : Round<u32>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;333        template<> inline u32 saturate_cast<u32>(const f64 v) { return (u32) Round<u32>( MIN((f64)u32_MAX, MAX((f64)0, (f64)v)) ); }
;;;334    
;;;335        template<> inline s32 saturate_cast<s32>(const u8  v) { return v; }
;;;336        template<> inline s32 saturate_cast<s32>(const u16 v) { return v; }
;;;337        template<> inline s32 saturate_cast<s32>(const u32 v) { return (s32)             MIN((u32)s32_MAX, (u32)v); }
;;;338        template<> inline s32 saturate_cast<s32>(const u64 v) { return (s32)             MIN((u64)s32_MAX, (u64)v); }
;;;339        template<> inline s32 saturate_cast<s32>(const s8  v) { return v; }
;;;340        template<> inline s32 saturate_cast<s32>(const s16 v) { return v; }
;;;341        template<> inline s32 saturate_cast<s32>(const s32 v) { return v; }
;;;342        template<> inline s32 saturate_cast<s32>(const s64 v) { return (s32)             MIN((s64)s32_MAX, MAX((s64)s32_MIN, (s64)v)); }
;;;343        template<> inline s32 saturate_cast<s32>(const f32 v) { return (s32) (v > (f32)0x7FFFFFBF) ? 0x7FFFFFFF : Round<s32>(MAX((f32)s32_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;344        template<> inline s32 saturate_cast<s32>(const f64 v) { return (s32) Round<s32>( MIN((f64)s32_MAX, MAX((f64)s32_MIN, (f64)v)) ); }
;;;345    
;;;346        template<> inline u64 saturate_cast<u64>(const u8  v) { return v; }
;;;347        template<> inline u64 saturate_cast<u64>(const u16 v) { return v; }
;;;348        template<> inline u64 saturate_cast<u64>(const u32 v) { return v; }
;;;349        template<> inline u64 saturate_cast<u64>(const u64 v) { return v; }
;;;350        template<> inline u64 saturate_cast<u64>(const s8  v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;351        template<> inline u64 saturate_cast<u64>(const s16 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;352        template<> inline u64 saturate_cast<u64>(const s32 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;353        template<> inline u64 saturate_cast<u64>(const s64 v) { return (u64)                               MAX((s64)0, (s64)v);  }
;;;354        template<> inline u64 saturate_cast<u64>(const f32 v) { return (u64) (v > (f32)0XFFFFFF7FFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;355        template<> inline u64 saturate_cast<u64>(const f64 v) { return (u64) (v > (f64)0xFFFFFFFFFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f64)0, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;356    
;;;357        template<> inline s64 saturate_cast<s64>(const u8  v) { return v; }
;;;358        template<> inline s64 saturate_cast<s64>(const u16 v) { return v; }
;;;359        template<> inline s64 saturate_cast<s64>(const u32 v) { return v; }
;;;360        template<> inline s64 saturate_cast<s64>(const u64 v) { return (s64)             MIN((u64)s64_MAX, (u64)v); }
;;;361        template<> inline s64 saturate_cast<s64>(const s8  v) { return v; }
;;;362        template<> inline s64 saturate_cast<s64>(const s16 v) { return v; }
;;;363        template<> inline s64 saturate_cast<s64>(const s32 v) { return v; }
;;;364        template<> inline s64 saturate_cast<s64>(const s64 v) { return v; }
;;;365        template<> inline s64 saturate_cast<s64>(const f32 v) { return (s64) (v > (f32)0x7FFFFFBFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f32)s64_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;366        template<> inline s64 saturate_cast<s64>(const f64 v) { return (s64) (v > (f64)0x7FFFFFFFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f64)s64_MIN, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;367    
;;;368        template<> inline f32 saturate_cast(const f64 v) { return (f32) MIN((f64)FLT_MAX, MAX(-(f64)FLT_MAX, (f64)v)); }
;;;369      } // namespace Embedded
;;;370    } // namespace Anki
;;;371    
;;;372    #endif // _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;18     #include "anki/common/robot/memory.h"
;;;1      /**
;;;19     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;20     #include "anki/common/robot/geometry.h"
;;;1      /**
;;;2      File: geometry.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of geometry_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/geometry_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/memory.h"
;;;1      /**
;;;18     #include "anki/common/robot/matrix.h"
;;;1      /**
;;;2      File: matrix.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of matrix_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;14     
;;;15     #include "anki/common/robot/matrix_declarations.h"
;;;1      /**
;;;2      File: matrix_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various Matrix operations, such as matrix multiply and addition.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         namespace Matrix
;;;24         {
;;;25           // #pragma mark --- Declarations ---
;;;26     
;;;27           //
;;;28           // Simple matrix statistics
;;;29           //
;;;30     
;;;31           // Return the minimum element in this Array
;;;32           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat);
;;;33     
;;;34           // Return the maximum element in this Array
;;;35           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat);
;;;36     
;;;37           // Return the sum of every element in the Array
;;;38           template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat);
;;;39     
;;;40           // Return the mean of every element in the Array
;;;41           template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat);
;;;42     
;;;43           // Simultaneously compute the mean and variance of every element in the Array
;;;44           template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(const ConstArraySliceExpression<Array_Type> &mat,
;;;45             Accumulator_Type& mean, Accumulator_Type& var);
;;;46     
;;;47           //
;;;48           // Elementwise matrix operations
;;;49           //
;;;50     
;;;51           // Elementwise add two arrays. in1, in2, and out can be the same array
;;;52           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;53           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;54           template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;55     
;;;56           // Elementwise subtract two arrays. in1, in2, and out can be the same array
;;;57           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;58           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;59           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;60     
;;;61           // Elementwise multiply two arrays. in1, in2, and out can be the same array
;;;62           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;63           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;64           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;65     
;;;66           // Elementwise divide two arrays. in1, in2, and out can be the same array
;;;67           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;68           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;69           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;70     
;;;71           // Elementwise exponential on an array
;;;72           template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;73     
;;;74           // Elementwise square root on an array
;;;75           template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;76     
;;;77           //
;;;78           // Standard matrix operations
;;;79           //
;;;80     
;;;81           // Perform the matrix multiplication "out = in1 * in2"
;;;82           // Note that this is the naive O(n^3) Definition
;;;83           template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out);
;;;84     
;;;85           // Perform the matrix multiplication "out = in1 * in2'"
;;;86           // Note that this is the naive O(n^3) Definition
;;;87           // MultiplyTranspose has better access patterns than Multiply for certain types of arrays, so could be a lot faster (and easier to accelerate)
;;;88           template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out);
;;;89     
;;;90           //
;;;91           // Rotation Matrices
;;;92           //
;;;93     
;;;94           // TODO: Add other rotation-related math, like Rodrigues' formula, or Pose chaining...
;;;95     
;;;96           // Compute the three Euler angles from a given 3x3 Rotation Matrix.
;;;97           Result GetEulerAngles(const Array<f32>& R, f32& angle_x, f32& angle_y, f32& angle_z);
;;;98     
;;;99           //
;;;100          // Linear Algebra and Linear Solvers
;;;101          //
;;;102    
;;;103          // Compute the Cholesky-Banachiewicz decomposition, to return a lower-triangular matrix L such that A=L*L'
;;;104          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;105            Array<Type> &A_L,      //!< Input A Matrix and Output lower-triangular L matrix
;;;106            Array<Type> &Bt_Xt,    //!< Input B-transpose matrix and Output X-transpose solution
;;;107            bool realCholesky,     //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;108            bool &numericalFailure //!< If true, the solver failed because of numerical instability
;;;109            );
;;;110    
;;;111          // Compute the homography such that "transformedPoints = homography * originalPoints"
;;;112          //
;;;113          // WARNING: This uses the inhomogeneous solution and the Cholesky decomposition, therefore it
;;;114          //          will be incorrect if H_33 is zero, which happens in certain cases of lines at
;;;115          //          inifinty. For more details, see Multiple View Geometry 2nd Edition, Example 4.1
;;;116          template<typename Type> Result EstimateHomography(
;;;117            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;118            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;119            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;120            bool &numericalFailure, //!< Did the homography solver fail?
;;;121            MemoryStack scratch //!< Scratch memory
;;;122            );
;;;123    
;;;124          //template<typename InType, typename IntermediateType, typename OutType> Result CholeskyDecomposition(
;;;125          //  const Array<InType> &A,                    //!< Input A Matrix
;;;126          //  Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;127          //  Array<OutType> &L                          //!< Output lower-triangular L matrix
;;;128          //  );
;;;129    
;;;130          //template<typename InType, typename IntermediateType, typename OutType> Result SolveWithLowerTriangular(
;;;131          //  const Array<InType> &L,                          //!< Input lower-triangular L matrix (such as computed by CholeskyDecomposition)
;;;132          //  const Array<InType> &b,                          //!< Input b matrix
;;;133          //  const Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;134          //  Array<OutType> &x                                //!< Output x solution
;;;135          //  );
;;;136    
;;;137          // Solves Ax = b
;;;138          // Specifically, it uses SVD to minimize ||Ax - b||
;;;139          // Note that the A, b, and x matrices are transposed (this is because for large numbers of samples, transposed inputs are liable to be faster)
;;;140          //Result SolveLeastSquaresWithSVD_f32(Array<f32> &At, const Array<f32> &bt, Array<f32> &xt, MemoryStack scratch);
;;;141          //Result SolveLeastSquaresWithSVD_f64(Array<f64> &At, const Array<f64> &bt, Array<f64> &xt, MemoryStack scratch);
;;;142    
;;;143          //
;;;144          // Matrix structure operations
;;;145          //
;;;146    
;;;147          // matlab equivalent: out = reshape(in, [M,N]);
;;;148          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;149          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory);
;;;150    
;;;151          // matlab equivalent: out = in(:);
;;;152          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;153          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory);
;;;154    
;;;155          // Perform an immediate matrix transpose (unlike the lazy transpose of ArraySlice)
;;;156          // in and out must be different Array objects
;;;157          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out);
;;;158    
;;;159          // Rotate an array clockwise by 90, 180, or 270 degrees.
;;;160          // NOTE: Only works for a square matrix.
;;;161          // NOTE: In and out must be different arrays (unlike the interview question)
;;;162          template<typename InType, typename OutType> Result Rotate90( const Array<InType> &in, Array<OutType> &out);
;;;163          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out);
;;;164          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out);
;;;165    
;;;166          //
;;;167          // Misc matrix operations
;;;168          //
;;;169    
;;;170          // Works the same as the Matlab sort() for matrices.
;;;171          // InsertionSort(X) sorts each column of X in ascending order.
;;;172          // The minIndex and maxIndex are for the sortWhichDimension. maxIndex is automatically clipped to the size of the input Array.
;;;173          // NOTE: this currently uses insertion sort, so may be slow for large, badly-unsorted arrays
;;;174          template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;175    
;;;176          // Subsections less-than-or-equal-to insertionSortSize are sorted with insertion sort
;;;177          template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;178    
;;;179          // indexes must be allocated, but will be overwritten by InsertionSort()
;;;180          template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;181    
;;;182          template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;183    
;;;184          // For a square array, either:
;;;185          // 1. When lowerToUpper==true,  copies the lower (left)  triangle to the upper (right) triangle
;;;186          // 2. When lowerToUpper==false, copies the upper (right) triangle to the lower (left)  triangle
;;;187          // Functionally the same as OpenCV completeSymm()
;;;188          template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper = false);
;;;189    
;;;190          // There's probably no need to use these directly. Instead, use the normal Matrix:: operations, like Matrix::Add
;;;191          namespace Elementwise
;;;192          {
;;;193            template<typename InType, typename IntermediateType, typename OutType> class Add {
;;;194            public:
;;;195              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) + static_cast<IntermediateType>(value2));}
;;;196            };
;;;197    
;;;198            template<typename InType, typename IntermediateType, typename OutType> class Subtract {
;;;199            public:
;;;200              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) - static_cast<IntermediateType>(value2));}
;;;201            };
;;;202    
;;;203            template<typename InType, typename IntermediateType, typename OutType> class DotMultiply {
;;;204            public:
;;;205              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) * static_cast<IntermediateType>(value2));}
;;;206            };
;;;207    
;;;208            template<typename InType, typename IntermediateType, typename OutType> class DotDivide {
;;;209            public:
;;;210              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) / static_cast<IntermediateType>(value2));}
;;;211            };
;;;212    
;;;213            // Technically a unary operator, but we ignore the second parameter
;;;214            // TODO: if this is slow, make a unary version of ApplyOperation
;;;215            template<typename InType, typename IntermediateType, typename OutType> class Exp {
;;;216            public:
;;;217              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(expf(static_cast<IntermediateType>(value1)));}
;;;218            };
;;;219    
;;;220            template<typename InType, typename IntermediateType, typename OutType> class Sqrt {
;;;221            public:
;;;222              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(sqrtf(static_cast<IntermediateType>(value1)));}
;;;223            };
;;;224    
;;;225            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;226            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;227            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;228          } // namespace Elementwise
;;;229        } // namespace Matrix
;;;230      } // namespace Embedded
;;;231    } // namespace Anki
;;;232    
;;;233    #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;18     #include "anki/common/robot/memory.h"
;;;19     #include "anki/common/robot/errorHandling.h"
;;;20     #include "anki/common/robot/geometry.h"
;;;21     #include "anki/common/robot/utilities_c.h"
;;;22     #include "anki/common/robot/sequences.h"
;;;23     #include "anki/common/robot/matrix.h"
;;;24     #include "anki/common/robot/comparisons.h"
;;;25     
;;;26     #include "anki/common/shared/utilities_shared.h"
;;;27     
;;;28     #include "anki/common/robot/serialize_declarations.h"
;;;29     
;;;30     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;31     #include "opencv2/core/core.hpp"
;;;32     #include "opencv2/highgui/highgui.hpp"
;;;33     #include "opencv2/imgproc/imgproc.hpp"
;;;34     #include "opencv2/objdetect/objdetect.hpp"
;;;35     #endif
;;;36     
;;;37     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;38     #define ANKICORETECH_EMBEDDED_USE_MALLOC 1
;;;39     #define ANKICORETECH_EMBEDDED_USE_ZLIB 1
;;;40     #endif
;;;41     
;;;42     #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;43     #include "zlib.h"
;;;44     #endif
;;;45     
;;;46     namespace Anki
;;;47     {
;;;48       namespace Embedded
;;;49       {
;;;50         template<typename Type> class ArraySlice;
;;;51         template<typename Type> class ConstArraySlice;
;;;52         template<typename Type> class ConstArraySliceExpression;
;;;53     
;;;54         // #pragma mark --- Array Definitions ---
;;;55     
;;;56         template<typename Type> s32 Array<Type>::ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags)
;;;57         {
;;;58           AnkiConditionalErrorAndReturnValue(numCols >= 0,
;;;59             0, "Array<Type>::ComputeRequiredStride", "Invalid size");
;;;60     
;;;61           const s32 numColsCapped = MAX(numCols, 1);
;;;62     
;;;63           const s32 bufferRequired = static_cast<s32>(RoundUp<size_t>(sizeof(Type)*numColsCapped, MEMORY_ALIGNMENT));
;;;64     
;;;65           return bufferRequired;
;;;66         }
;;;67     
;;;68         template<typename Type> s32 Array<Type>::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags)
;;;69         {
;;;70           AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0,
;;;71             0, "Array<Type>::ComputeMinimumRequiredMemory", "Invalid size");
;;;72     
;;;73           const s32 numRowsCapped = MAX(numRows, 1);
;;;74     
;;;75           return numRowsCapped * Array<Type>::ComputeRequiredStride(numCols, flags);
;;;76         }
;;;77     
;;;78         template<typename Type> Array<Type>::Array()
;;;79         {
;;;80           InvalidateArray();
;;;81         }
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
;;;139        template<typename Type> Array<Type> Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;140        {
;;;141          Array<Type> newArray = Array<Type>();
;;;142    
;;;143    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;144          const cv::Mat cvImage = cv::imread(filename, CV_LOAD_IMAGE_GRAYSCALE);
;;;145    
;;;146          AnkiConditionalErrorAndReturnValue(cvImage.cols >= 0 && cvImage.rows >= 0,
;;;147            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;148    
;;;149          newArray = Array<Type>(cvImage.rows, cvImage.cols, memory);
;;;150    
;;;151          AnkiConditionalErrorAndReturnValue(newArray.IsValid(),
;;;152            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;153    
;;;154          const u8 * restrict pCvImage = cvImage.data;
;;;155    
;;;156          for(s32 y=0; y<cvImage.rows; y++) {
;;;157            Type * restrict pNewArray = newArray.Pointer(y, 0);
;;;158    
;;;159            for(s32 x=0; x<cvImage.cols; x++) {
;;;160              pNewArray[x] = static_cast<Type>(pCvImage[x]);
;;;161            }
;;;162    
;;;163            pCvImage += cvImage.step.buf[0];
;;;164          }
;;;165    #else
;;;166          AnkiError("Array<Type>::Array", "OpenCV is required to load an image from an image file");
;;;167    #endif
;;;168    
;;;169          return newArray;
;;;170        } // Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;171    
;;;172        template<typename Type> Array<Type> LoadBinaryArray_Generic(const char * filename, MemoryStack *scratch, MemoryStack *memory, void * allocatedBuffer, const s32 allocatedBufferLength)
;;;173        {
;;;174          u16  basicType_sizeOfType;
;;;175          bool basicType_isBasicType;
;;;176          bool basicType_isInteger;
;;;177          bool basicType_isSigned;
;;;178          bool basicType_isFloat;
;;;179          bool basicType_isString;
;;;180    
;;;181          Array<u8> rawArray = LoadBinaryArray_UnknownType(
;;;182            filename,
;;;183            scratch, memory,
;;;184            allocatedBuffer, allocatedBufferLength,
;;;185            basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString);
;;;186    
;;;187          // TODO: check that the types match
;;;188    
;;;189          Array<Type> newArray = *reinterpret_cast<Array<Type>*>( &rawArray );
;;;190    
;;;191          return newArray;
;;;192        } // / LoadBinaryArray_Generic()
;;;193    
;;;194        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;195        {
;;;196          return LoadBinaryArray_Generic<Type>(filename, &scratch, &memory, NULL, -1);
;;;197        } // Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;198    
;;;199        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength) //< allocatedBuffer must be freed manually
;;;200        {
;;;201          return LoadBinaryArray_Generic<Type>(filename, NULL, NULL, allocatedBuffer, allocatedBufferLength);
;;;202        } // LoadBinaryMalloc()
;;;203    
;;;204        template<typename Type> Result Array<Type>::SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const
;;;205        {
;;;206          AnkiConditionalErrorAndReturnValue(AreValid(*this, scratch) && filename,
;;;207            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::SaveBinary", "Invalid inputs");
;;;208    
;;;209          AnkiConditionalErrorAndReturnValue(compressionLevel >= 0 && compressionLevel <= 9,
;;;210            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::SaveBinary", "Invalid compression level");
;;;211    
;;;212          // If this is a string array, add the sizes of the null terminated strings (or zero otherwise)
;;;213          const s32 stringsLength = TotalArrayStringLengths<Type>(*this);
;;;214    
;;;215          const s32 serializedBufferLength = 4096 + ARRAY_FILE_HEADER_LENGTH + this->get_size(0) * this->get_stride() + stringsLength;
;;;216          void *buffer = scratch.Allocate(serializedBufferLength);
;;;217    
;;;218          AnkiConditionalErrorAndReturnValue(buffer,
;;;219            RESULT_FAIL_OUT_OF_MEMORY, "Array<Type>::SaveBinary", "Memory could not be allocated");
;;;220    
;;;221          SerializedBuffer toSave(buffer, serializedBufferLength);
;;;222    
;;;223          toSave.PushBack<Type>("Array", *this);
;;;224    
;;;225          s32 startIndex;
;;;226          u8 * bufferStart = reinterpret_cast<u8*>(toSave.get_memoryStack().get_validBufferStart(startIndex));
;;;227          const s32 validUsedBytes = toSave.get_memoryStack().get_usedBytes() - startIndex;
;;;228    
;;;229          // const s32 startDiff = static_cast<s32>( reinterpret_cast<size_t>(bufferStart) - reinterpret_cast<size_t>(toSave.get_memoryStack().get_buffer()) );
;;;230          // const s32 endDiff = toSave.get_memoryStack().get_totalBytes() - toSave.get_memoryStack().get_usedBytes();
;;;231    
;;;232          FILE *fp = fopen(filename, "wb");
;;;233    
;;;234          AnkiConditionalErrorAndReturnValue(fp,
;;;235            RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Could not open file %s", filename);
;;;236    
;;;237          if(compressionLevel > 0) {
;;;238    #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;239            char tmpTextHeader[ARRAY_FILE_HEADER_LENGTH+1];
;;;240            strncpy(tmpTextHeader, &ARRAY_FILE_HEADER[0], ARRAY_FILE_HEADER_LENGTH+1);
;;;241            snprintf(tmpTextHeader+ARRAY_FILE_HEADER_VALID_LENGTH+1, ARRAY_FILE_HEADER_LENGTH-ARRAY_FILE_HEADER_VALID_LENGTH, "z%s ", ZLIB_VERSION);
;;;242    
;;;243            const s32 originalLength = validUsedBytes + SERIALIZED_BUFFER_HEADER_LENGTH + SERIALIZED_BUFFER_FOOTER_LENGTH;
;;;244    
;;;245            uLongf compressedLength = 128 + saturate_cast<s32>(1.1 * originalLength);
;;;246    
;;;247            void * uncompressed = malloc(originalLength);
;;;248            void * compressed = malloc(compressedLength + 2*sizeof(s32));
;;;249    
;;;250            if(!uncompressed || !compressed) {
;;;251              if(uncompressed)
;;;252                free(uncompressed);
;;;253    
;;;254              if(compressed)
;;;255                free(compressed);
;;;256    
;;;257              AnkiError("Array<Type>::SaveBinary", "Out of memory");
;;;258    
;;;259              return RESULT_FAIL_OUT_OF_MEMORY;
;;;260            }
;;;261    
;;;262            // Copy the uncompressed data into one buffer
;;;263            {
;;;264              char * pUncompressed = reinterpret_cast<char*>(uncompressed);
;;;265    
;;;266              memcpy(pUncompressed, &SERIALIZED_BUFFER_HEADER[0], SERIALIZED_BUFFER_HEADER_LENGTH);
;;;267              pUncompressed += SERIALIZED_BUFFER_HEADER_LENGTH;
;;;268    
;;;269              memcpy(pUncompressed, bufferStart, validUsedBytes);
;;;270              pUncompressed += validUsedBytes;
;;;271    
;;;272              memcpy(pUncompressed, &SERIALIZED_BUFFER_FOOTER[0], SERIALIZED_BUFFER_FOOTER_LENGTH);
;;;273            }
;;;274    
;;;275            const s32 compressionResult = compress2(reinterpret_cast<Bytef*>(compressed) + 2*sizeof(s32), &compressedLength, reinterpret_cast<Bytef*>(uncompressed), originalLength, compressionLevel);
;;;276    
;;;277            if(compressionResult != Z_OK) {
;;;278              if(uncompressed)
;;;279                free(uncompressed);
;;;280    
;;;281              if(compressed)
;;;282                free(compressed);
;;;283    
;;;284              AnkiError("Array<Type>::SaveBinary", "Zlib error");
;;;285              return RESULT_FAIL_IO;
;;;286            }
;;;287    
;;;288            reinterpret_cast<s32*>(compressed)[0] = static_cast<s32>(originalLength);
;;;289            reinterpret_cast<s32*>(compressed)[1] = static_cast<s32>(compressedLength);
;;;290    
;;;291            const size_t bytesWrittenForTextHeader = fwrite(tmpTextHeader, 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;292    
;;;293            const size_t bytesWritten = fwrite(compressed, 1, compressedLength + 2*sizeof(s32), fp);
;;;294    
;;;295            if(uncompressed)
;;;296              free(uncompressed);
;;;297    
;;;298            if(compressed)
;;;299              free(compressed);
;;;300    
;;;301            AnkiConditionalErrorAndReturnValue(
;;;302              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;303              bytesWritten == (compressedLength + 2*sizeof(s32)),
;;;304              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;305    
;;;306    #else
;;;307            AnkiError("Array<Type>::SaveBinary", "Saving with compression requires zlib");
;;;308            return RESULT_FAIL;
;;;309    #endif
;;;310          } else {
;;;311            const size_t bytesWrittenForTextHeader = fwrite(&ARRAY_FILE_HEADER[0], 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;312    
;;;313            const size_t bytesWrittenForHeader = fwrite(&SERIALIZED_BUFFER_HEADER[0], 1, SERIALIZED_BUFFER_HEADER_LENGTH, fp);
;;;314    
;;;315            const size_t bytesWritten = fwrite(bufferStart, 1, validUsedBytes, fp);
;;;316    
;;;317            const size_t bytesWrittenForFooter = fwrite(&SERIALIZED_BUFFER_FOOTER[0], 1, SERIALIZED_BUFFER_FOOTER_LENGTH, fp);
;;;318    
;;;319            AnkiConditionalErrorAndReturnValue(
;;;320              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;321              bytesWrittenForHeader == SERIALIZED_BUFFER_HEADER_LENGTH &&
;;;322              bytesWritten == validUsedBytes &&
;;;323              bytesWrittenForFooter == SERIALIZED_BUFFER_FOOTER_LENGTH,
;;;324              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;325          }
;;;326    
;;;327          fclose(fp);
;;;328    
;;;329          return RESULT_OK;
;;;330        } // Array<Type>::SaveBinary(const char * filename, MemoryStack scratch)
;;;331    
;;;332        template<typename Type> const Type* Array<Type>::Pointer(const s32 index0, const s32 index1) const
;;;333        {
;;;334          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;335          AnkiAssert(this->IsValid());
;;;336    
;;;337          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride ) + index1;
;;;338        }
;;;339    
;;;340        template<typename Type> Type* Array<Type>::Pointer(const s32 index0, const s32 index1)
;;;341        {
;;;342          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;343          AnkiAssert(this->IsValid());
;;;344    
;;;345          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride ) + index1;
;;;346        }
;;;347    
;;;348        template<typename Type> inline const Type * Array<Type>::operator[](const s32 index0) const
;;;349        {
;;;350          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;351    
;;;352          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride );
;;;353        }
;;;354    
;;;355        template<typename Type> inline Type * Array<Type>::operator[](const s32 index0)
;;;356        {
;;;357          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;358    
;;;359          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride );
;;;360        }
;;;361    
;;;362        template<typename Type> const Type* Array<Type>::Pointer(const Point<s16> &point) const
;;;363        {
;;;364          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;365        }
;;;366    
;;;367        template<typename Type> Type* Array<Type>::Pointer(const Point<s16> &point)
;;;368        {
;;;369          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;370        }
;;;371    
;;;372        template<typename Type> const Type& Array<Type>::Element(const s32 elementIndex) const
;;;373        {
;;;374          const s32 index1 = elementIndex % size[1];
;;;375          const s32 index0 = (elementIndex - index1) / size[1];
;;;376    
;;;377          return *Pointer(index0, index1);
;;;378        }
;;;379    
;;;380        template<typename Type> Type& Array<Type>::Element(const s32 elementIndex)
;;;381        {
;;;382          const s32 index1 = elementIndex % size[1];
;;;383          const s32 index0 = (elementIndex - index1) / size[1];
;;;384    
;;;385          return *Pointer(index0, index1);
;;;386        }
;;;387    
;;;388        template<typename Type> ArraySlice<Type> Array<Type>::operator() ()
;;;389        {
;;;390          ArraySlice<Type> slice(*this);
;;;391    
;;;392          return slice;
;;;393        }
;;;394    
;;;395        template<typename Type> ArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;396        {
;;;397          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;398    
;;;399          return slice;
;;;400        }
;;;401    
;;;402        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX)
;;;403        {
;;;404          LinearSequence<s32> ySlice = IndexSequence<s32>(minY, 1, maxY, this->size[0]);
;;;405          LinearSequence<s32> xSlice = IndexSequence<s32>(minX, 1, maxX, this->size[1]);
;;;406    
;;;407          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;408    
;;;409          return slice;
;;;410        }
;;;411    
;;;412        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX)
;;;413        {
;;;414          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;415          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;416    
;;;417          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;418    
;;;419          return slice;
;;;420        }
;;;421    
;;;422        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() () const
;;;423        {
;;;424          ConstArraySlice<Type> slice(*this);
;;;425    
;;;426          return slice;
;;;427        }
;;;428    
;;;429        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const
;;;430        {
;;;431          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;432    
;;;433          return slice;
;;;434        }
;;;435    
;;;436        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const
;;;437        {
;;;438          LinearSequence<s32> ySlice = IndexSequence(minY, 1, maxY, this->size[0]);
;;;439          LinearSequence<s32> xSlice = IndexSequence(minX, 1, maxX, this->size[1]);
;;;440    
;;;441          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;442    
;;;443          return slice;
;;;444        }
;;;445    
;;;446        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const
;;;447        {
;;;448          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;449          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;450    
;;;451          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;452    
;;;453          return slice;
;;;454        }
;;;455    
;;;456        template<typename Type> ConstArraySliceExpression<Type> Array<Type>::Transpose() const
;;;457        {
;;;458          ConstArraySliceExpression<Type> expression(this->operator() ());
;;;459          expression.Transpose();
;;;460    
;;;461          return expression;
;;;462        }
;;;463    
;;;464    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;465        template<typename Type> s32 Array<Type>::Set(const cv::Mat_<Type> &in)
;;;466        {
;;;467          const s32 inHeight = in.rows;
;;;468          const s32 inWidth = in.cols;
;;;469    
;;;470          AnkiConditionalErrorAndReturnValue(inHeight != 0,
;;;471            0, "Array<Type>::Set", "input cv::Mat is invalid. If you use the release OpenCV libraries with the debug build, lots of things like file loading don't work.");
;;;472    
;;;473          const bool isColor = in.channels() == 3 || inWidth == this->size[1]*3;
;;;474    
;;;475          if(isColor) {
;;;476            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0],
;;;477              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;478          } else {
;;;479            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;480              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;481          }
;;;482    
;;;483          for(s32 y=0; y<this->size[0]; y++) {
;;;484            const Type * restrict pIn = reinterpret_cast<const Type*>(in.ptr(y,0));
;;;485            Type * restrict pThis = this->Pointer(y,0);
;;;486    
;;;487            // If grayscale, just copy. If color, convert to grayscale
;;;488            if(isColor) {
;;;489              for(s32 x=0; x<this->size[1]; x++) {
;;;490                pThis[x] = (pIn[3*x] + pIn[3*x + 1] + pIn[3*x + 2]) / 3;
;;;491              }
;;;492            } else {
;;;493              memcpy(pThis, pIn, inWidth*sizeof(Type));
;;;494            }
;;;495          }
;;;496    
;;;497          return this->size[0]*this->size[1];
;;;498        }
;;;499    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;500    
;;;501        template<typename Type> void Array<Type>::Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues, const bool fitImageToWindow) const
;;;502        {
;;;503    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;504          AnkiConditionalError(this->IsValid(), "Array<Type>::Show", "Array<Type> is not valid");
;;;505    
;;;506          if(fitImageToWindow) {
;;;507            cv::namedWindow(windowName, CV_WINDOW_NORMAL);
;;;508          } else {
;;;509            cv::namedWindow(windowName, CV_WINDOW_AUTOSIZE);
;;;510          }
;;;511    
;;;512          if(scaleValues) {
;;;513            cv::Mat_<f64> scaledArray;
;;;514    
;;;515            if(ArrayToCvMat(*this, &scaledArray) != RESULT_OK)
;;;516              return;
;;;517    
;;;518            const f64 minValue = Matrix::Min<Type>(*this);
;;;519            const f64 maxValue = Matrix::Max<Type>(*this);
;;;520            const f64 range = maxValue - minValue;
;;;521    
;;;522            scaledArray -= minValue;
;;;523            scaledArray /= range;
;;;524    
;;;525            cv::imshow(windowName, scaledArray);
;;;526          } else {
;;;527            cv::Mat_<Type> arrayCopy;
;;;528    
;;;529            if(ArrayToCvMat(*this, &arrayCopy) != RESULT_OK)
;;;530              return;
;;;531    
;;;532            cv::imshow(windowName, arrayCopy);
;;;533          }
;;;534    
;;;535          if(waitForKeypress) {
;;;536            cv::waitKey();
;;;537          }
;;;538    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;539        }
;;;540    
;;;541        template<typename Type> Result Array<Type>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;542        {
;;;543          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;544            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;545    
;;;546          CoreTechPrint(variableName);
;;;547          CoreTechPrint(":\n");
;;;548          for(s32 y=MAX(0,minY); y<MIN(maxY+1,size[0]); y++) {
;;;549            const Type * const pThisData = this->Pointer(y, 0);
;;;550            for(s32 x=MAX(0,minX); x<MIN(maxX+1,size[1]); x++) {
;;;551              pThisData[x].Print();
;;;552            }
;;;553            CoreTechPrint("\n");
;;;554          }
;;;555          CoreTechPrint("\n");
;;;556    
;;;557          return RESULT_OK;
;;;558        }
;;;559    
;;;560        template<typename Type> Result Array<Type>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;561        {
;;;562          return this->Print(variableName, minY, maxY, minX, maxX);
;;;563        }
;;;564    
;;;565        template<typename Type> bool Array<Type>::IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const
;;;566        {
;;;567          bool isSame = false;
;;;568          if(AreValid(*this, other)) {
;;;569            const s32 nrows = this->get_size(0);
;;;570            const s32 ncols = this->get_size(1);
;;;571    
;;;572            if(other.get_size(0)==nrows && other.get_size(1) == ncols) {
;;;573              isSame = true;
;;;574              for(s32 i=0; i<nrows && isSame; ++i) {
;;;575                const Type * restrict pThis  = this->Pointer(i,0);
;;;576                const Type * restrict pOther = other.Pointer(i,0);
;;;577    
;;;578                for(s32 j=0; j<ncols; ++j) {
;;;579                  if(!NEAR(pThis[j], pOther[j], epsilon)) {
;;;580                    isSame = false;
;;;581                    break;
;;;582                  }
;;;583                } // for j
;;;584              } // for i
;;;585            } // if sizes match
;;;586          } // if both valid
;;;587    
;;;588          return isSame;
;;;589        } // IsNearlyEqualTo()
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
;;;592        {
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
;;;602        }
;;;603    
;;;604        template<typename Type> Result Array<Type>::Resize(const s32 numRows, const s32 numCols, MemoryStack &memory)
;;;605        {
;;;606          AnkiConditionalErrorAndReturnValue(numCols > 0 && numRows > 0,
;;;607            RESULT_FAIL_INVALID_SIZE, "Array<Type>::Resize", "Invalid size");
;;;608    
;;;609          s32 numBytesAllocated = 0;
;;;610    
;;;611          this->data = reinterpret_cast<Type*>( AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, true) );
;;;612    
;;;613          // Don't clear the reallocated memory
;;;614          const bool clearMemory = this->flags.get_zeroAllocatedMemory();
;;;615          this->flags.set_zeroAllocatedMemory(false);
;;;616    
;;;617          const Result result = InitializeBuffer(numRows,
;;;618            numCols,
;;;619            this->data,
;;;620            numBytesAllocated,
;;;621            this->flags);
;;;622    
;;;623          this->flags.set_zeroAllocatedMemory(clearMemory);
;;;624    
;;;625          return result;
;;;626        }
;;;627    
;;;628        template<typename Type> s32 Array<Type>::SetZero()
;;;629        {
;;;630          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;631            0, "Array<Type>::SetZero", "Array<Type> is not valid");
;;;632    
;;;633          const s32 numBytes = this->get_size(0)*this->get_stride();
;;;634    
;;;635          memset(this->Pointer(0,0), 0, numBytes);
;;;636    
;;;637          return numBytes;
;;;638        }
;;;639    
;;;640        template<typename Type> s32 Array<Type>::Set(const Type value)
;;;641        {
;;;642          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;643            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;644    
;;;645          for(s32 y=0; y<size[0]; y++) {
;;;646            Type * restrict pThisData = Pointer(y, 0);
;;;647            for(s32 x=0; x<size[1]; x++) {
;;;648              pThisData[x] = value;
;;;649            }
;;;650          }
;;;651    
;;;652          return size[0]*size[1];
;;;653        }
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
;;;656        {
;;;657          return this->SetCast<Type>(in);
;;;658        }
;;;659    
;;;660        template<typename Type> template<typename InType> s32 Array<Type>::SetCast(const Array<InType> &in)
;;;661        {
;;;662          const s32 inHeight = in.get_size(0);
;;;663          const s32 inWidth = in.get_size(1);
;;;664    
;;;665          AnkiConditionalErrorAndReturnValue(AreValid(*this, in),
;;;666            0, "Array<Type>::Set", "Invalid objects");
;;;667    
;;;668          AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;669            0, "Array<Type>::Set", "Array sizes don't match");
;;;670    
;;;671          for(s32 y=0; y<size[0]; y++) {
;;;672            const InType * restrict pIn = in.Pointer(y, 0);
;;;673            Type * restrict pThisData = Pointer(y, 0);
;;;674    
;;;675            for(s32 x=0; x<size[1]; x++) {
;;;676              pThisData[x] = saturate_cast<Type>(pIn[x]);
;;;677            }
;;;678          }
;;;679    
;;;680          return size[0]*size[1];
;;;681        }
;;;682    
;;;683        template<typename InType> s32 SetCast(const InType * const values, const s32 numValues)
;;;684        {
;;;685          // This is a little tough to write a general case for, so this method should be specialized
;;;686          // for each relevant case
;;;687          AnkiAssert(false);
;;;688    
;;;689          return 0;
;;;690        }
;;;691    
;;;692        template<typename Type> s32 Array<Type>::Set(const Type * const values, const s32 numValues)
;;;693        {
;;;694          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;695            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;696    
;;;697          s32 numValuesSet = 0;
;;;698    
;;;699          for(s32 y=0; y<size[0]; y++) {
;;;700            u32 * restrict pThisData = reinterpret_cast<u32*>(Pointer(y, 0));
;;;701    
;;;702            const s32 numValuesThisRow = MAX(0, MIN(numValues - y*size[1], size[1]));
;;;703    
;;;704            if(numValuesThisRow > 0) {
;;;705              // For small data types, this may be too many bytes, but the stride padding should make
;;;706              // the writing okay (I think)
;;;707              const s32 numWordsToCopy = (sizeof(Type)*numValuesThisRow + 3) / 4;
;;;708    
;;;709              //memcpy(pThisData, values + y*size[1], numValuesThisRow*sizeof(Type));
;;;710              for(s32 x=0; x<numWordsToCopy; x++) {
;;;711                //AnkiAssert(reinterpret_cast<size_t>(values+y*size[1]) % 4 == 0);
;;;712                pThisData[x] = reinterpret_cast<const u32*>(values+y*size[1])[x];
;;;713              }
;;;714              numValuesSet += numValuesThisRow;
;;;715            }
;;;716    
;;;717            if(numValuesThisRow < size[1]) {
;;;718              memset(pThisData+numValuesThisRow*sizeof(Type), 0, (size[1]-numValuesThisRow)*sizeof(Type));
;;;719            }
;;;720          }
;;;721    
;;;722          return numValuesSet;
;;;723        }
;;;724    
;;;725        template<typename Type> Array<Type>& Array<Type>::operator= (const Array<Type> & rightHandSide)
;;;726        {
;;;727          this->size[0] = rightHandSide.size[0];
;;;728          this->size[1] = rightHandSide.size[1];
;;;729    
;;;730          this->stride = rightHandSide.stride;
;;;731          this->flags = rightHandSide.flags;
;;;732          this->data = rightHandSide.data;
;;;733    
;;;734          return *this;
;;;735        }
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
;;;738        {
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
;;;747    
;;;748        template<typename Type> s32 Array<Type>::get_stride() const
;;;749        {
;;;750          return stride;
;;;751        }
;;;752    
;;;753        template<typename Type> s32 Array<Type>::get_numElements() const
;;;754        {
;;;755          if(size[0] > 0 && size[1] > 0) {
;;;756            return size[0] * size[1];
;;;757          } else {
;;;758            return 0;
;;;759          }
;;;760        }
;;;761    
;;;762        template<typename Type> void* Array<Type>::get_buffer()
;;;763        {
;;;764          return data;
;;;765        }
;;;766    
;;;767        template<typename Type> const void* Array<Type>::get_buffer() const
;;;768        {
;;;769          return data;
;;;770        }
;;;771    
;;;772        template<typename Type> Flags::Buffer Array<Type>::get_flags() const
;;;773        {
;;;774          return flags;
;;;775        }
;;;776    
;;;777        template<typename Type> void* Array<Type>::AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate)
;;;778        {
;;;779          AnkiConditionalError(numRows >= 0 && stride > 0,
;;;780            "Array<Type>::AllocateBufferFromMemoryStack", "Invalid size");
;;;781    
;;;782          const s32 numRowsCapped = MAX(numRows, 1);
;;;783    
;;;784          this->stride = stride;
;;;785    
;;;786          const s32 numBytesRequested = numRowsCapped * this->stride;
;;;787    
;;;788          if(reAllocate) {
;;;789            return memory.Reallocate(this->data, numBytesRequested, numBytesAllocated);
;;;790          } else {
;;;791            return memory.Allocate(numBytesRequested, flags.get_zeroAllocatedMemory(), numBytesAllocated);
;;;792          }
;;;793        }
;;;794    
;;;795        template<typename Type> Result Array<Type>::InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags)
;;;796        {
;;;797          if(!rawData) {
;;;798            AnkiError("Anki.Array2d.initialize", "input data buffer is NULL");
;;;799            InvalidateArray();
;;;800            return RESULT_FAIL_UNINITIALIZED_MEMORY;
;;;801          }
;;;802    
;;;803          AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0 && dataLength >= MEMORY_ALIGNMENT,
;;;804            RESULT_FAIL_INVALID_SIZE, "Array<Type>::InitializeBuffer", "Negative dimension");
;;;805    
;;;806          AnkiConditionalErrorAndReturnValue(!flags.get_useBoundaryFillPatterns(),
;;;807            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::InitializeBuffer", "Fill patterns not supported for Array");
;;;808    
;;;809          this->flags = flags;
;;;810          this->size[0] = numRows;
;;;811          this->size[1] = numCols;
;;;812    
;;;813          // Initialize an empty array.
;;;814    
;;;815          this->data = reinterpret_cast<Type*>(rawData);
;;;816    
;;;817          const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData), MEMORY_ALIGNMENT) - reinterpret_cast<size_t>(rawData));
;;;818          const s32 requiredBytes = ComputeRequiredStride(numCols,flags)*numRows + extraAlignmentBytes;
;;;819    
;;;820          if(requiredBytes > dataLength) {
;;;821            AnkiError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
;;;822            InvalidateArray();
;;;823            return RESULT_FAIL_OUT_OF_MEMORY;
;;;824          }
;;;825    
;;;826          this->data = reinterpret_cast<Type*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
;;;827    
;;;828          //#if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;829          //      this->UpdateCvMatMirror(*this);
;;;830          //#endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;831    
;;;832          return RESULT_OK;
;;;833        } // Array<Type>::InitializeBuffer()
;;;834    
;;;835        // Set all the buffers and sizes to -1, to signal an invalid array
;;;836        template<typename Type> void Array<Type>::InvalidateArray()
;;;837        {
;;;838          this->size[0] = -1;
;;;839          this->size[1] = -1;
;;;840          this->stride = -1;
;;;841          this->data = NULL;
;;;842        } // void Array<Type>::InvalidateArray()
;;;843    
;;;844        template<typename Type> Result Array<Type>::PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX)  const
;;;845        {
;;;846          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;847            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;848    
;;;849          const s32 realMinX = MAX(0,minX);
;;;850          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;851          const s32 realMinY = MAX(0,minY);
;;;852          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;853    
;;;854          CoreTechPrint("%s type(int:%d,signed:%d,float:%d,sizeof:%d):\n", variableName, Flags::TypeCharacteristics<Type>::isInteger, Flags::TypeCharacteristics<Type>::isSigned, Flags::TypeCharacteristics<Type>::isFloat, sizeof(Type));
;;;855    
;;;856          for(s32 y=realMinY; y<realMaxY; y++) {
;;;857            const Type * const pThisData = this->Pointer(y, 0);
;;;858            for(s32 x=realMinX; x<realMaxX; x++) {
;;;859              if(Flags::TypeCharacteristics<Type>::isBasicType) {
;;;860                if(Flags::TypeCharacteristics<Type>::isInteger) {
;;;861                  CoreTechPrint("%d ", static_cast<s32>(pThisData[x]));
;;;862                } else {
;;;863                  if(version==1) {
;;;864                    CoreTechPrint("%f ", (float)pThisData[x]);
;;;865                  } else {
;;;866                    CoreTechPrint("%e ", (float)pThisData[x]);
;;;867                  }
;;;868                }
;;;869              } else {
;;;870                CoreTechPrint("! ");
;;;871              }
;;;872            }
;;;873            CoreTechPrint("\n");
;;;874          }
;;;875          CoreTechPrint("\n");
;;;876    
;;;877          return RESULT_OK;
;;;878        }
;;;879    
;;;880        template<typename Type> Result Array<Type>::PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;881        {
;;;882          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;883            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::PrintString", "Array<Type> is not valid");
;;;884    
;;;885          const s32 realMinX = MAX(0,minX);
;;;886          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;887          const s32 realMinY = MAX(0,minY);
;;;888          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;889    
;;;890          CoreTechPrint("%s:\n", variableName);
;;;891    
;;;892          for(s32 y=realMinY; y<realMaxY; y++) {
;;;893            const char * const * pThisData = this->Pointer(y, 0);
;;;894            for(s32 x=realMinX; x<realMaxX; x++) {
;;;895              const char * curString = pThisData[x];
;;;896              if(!curString) {
;;;897                CoreTechPrint("NULL, ");
;;;898              } else {
;;;899                CoreTechPrint("\"%s\", ", curString);
;;;900              }
;;;901            }
;;;902            CoreTechPrint("\n");
;;;903          }
;;;904          CoreTechPrint("\n");
;;;905    
;;;906          return RESULT_OK;
;;;907        }
;;;908    
;;;909        // #pragma mark --- FixedPointArray Definitions ---
;;;910    
;;;911        template<typename Type> FixedPointArray<Type>::FixedPointArray()
;;;912          : Array<Type>(), numFractionalBits(-1)
;;;913        {
;;;914        }
;;;915    
;;;916        template<typename Type> FixedPointArray<Type>::FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags)
;;;917          : Array<Type>(numRows, numCols, data, dataLength, flags), numFractionalBits(numFractionalBits)
;;;918        {
;;;919          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= (sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;920        }
;;;921    
;;;922        template<typename Type> FixedPointArray<Type>::FixedPointArray(s32 numRows, s32 numCols, s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags)
;;;923          : Array<Type>(numRows, numCols, memory, flags), numFractionalBits(numFractionalBits)
;;;924        {
;;;925          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= static_cast<s32>(sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;926        }
;;;927    
;;;928        template<typename Type> s32 FixedPointArray<Type>::get_numFractionalBits() const
;;;929        {
;;;930          return numFractionalBits;
;;;931        }
;;;932    
;;;933    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;934        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;935        {
;;;936          AnkiConditionalErrorAndReturnValue(in.IsValid() && out,
;;;937            RESULT_FAIL, "ArrayToCvMat", "This Array is invalid");
;;;938    
;;;939          out->refcount = NULL;
;;;940    
;;;941          // These two should be set, because if the Mat_ constructor was not called, these will not be initialized
;;;942          out->step.p = out->step.buf;
;;;943          out->size = &out->rows;
;;;944    
;;;945          *out = cv::Mat_<Type>(in.get_size(0), in.get_size(1), const_cast<Type*>(in.Pointer(0,0)), static_cast<size_t>(in.get_stride()));
;;;946    
;;;947          return RESULT_OK;
;;;948        } // template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;949    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;950    
;;;951        // #pragma mark --- Array Specializations ---
;;;952    
;;;953        template<> Result Array<bool>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;954        template<> Result Array<u8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;955        template<> Result Array<s8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;956        template<> Result Array<u16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;957        template<> Result Array<s16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;958        template<> Result Array<u32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;959        template<> Result Array<s32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;960        template<> Result Array<u64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;961        template<> Result Array<s64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;962        template<> Result Array<f32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;963        template<> Result Array<f64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;964        template<> Result Array<const char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;965        template<> Result Array<char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;966    
;;;967        template<> Result Array<f32>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;968        template<> Result Array<f64>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;969    
;;;970        template<> template<> s32 Array<u8>::SetCast(const s32 * const values, const s32 numValues);
;;;971        template<> template<> s32 Array<s16>::SetCast(const s32 * const values, const s32 numValues);
;;;972      } // namespace Embedded
;;;973    } //namespace Anki
;;;974    
;;;975    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;17     #include "anki/common/robot/arraySlices.h"
;;;1      /**
;;;2      File: arraySlices.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of arraySlices_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;14     
;;;15     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> ConstArraySlice<Type>::ConstArraySlice()
;;;23           : ySlice(LinearSequence<s32>()), xSlice(LinearSequence<s32>()), array(Array<Type>()), constArrayData(NULL)
;;;24         {
;;;25         }
;;;26     
;;;27         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array)
;;;28           : ySlice(LinearSequence<s32>(0,array.get_size(0)-1)), xSlice(LinearSequence<s32>(0,array.get_size(1)-1)), array(array)
;;;29         {
;;;30           if(array.get_numElements() == 0) {
;;;31             this->constArrayData = NULL;
;;;32           } else {
;;;33             this->constArrayData = array.Pointer(0,0);
;;;34           }
;;;35         }
;;;36     
;;;37         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;38           : ySlice(ySlice), xSlice(xSlice), array(array)
;;;39         {
;;;40           if(array.get_numElements() == 0) {
;;;41             this->constArrayData = NULL;
;;;42           } else {
;;;43             this->constArrayData = array.Pointer(0,0);
;;;44           }
;;;45         }
;;;46     
;;;47         template<typename Type> ConstArraySliceExpression<Type> ConstArraySlice<Type>::Transpose() const
;;;48         {
;;;49           ConstArraySliceExpression<Type> expression(*this, true);
;;;50     
;;;51           return expression;
;;;52         }
;;;53     
;;;54         template<typename Type> bool ConstArraySlice<Type>::IsValid() const
;;;55         {
;;;56           return this->array.IsValid();
;;;57         }
;;;58     
;;;59         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_ySlice() const
;;;60         {
;;;61           return ySlice;
;;;62         }
;;;63     
;;;64         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_xSlice() const
;;;65         {
;;;66           return xSlice;
;;;67         }
;;;68     
;;;69         template<typename Type> const Array<Type>& ConstArraySlice<Type>::get_array() const
;;;70         {
;;;71           return this->array;
;;;72         }
;;;73     
;;;74         template<typename Type> ArraySlice<Type>::ArraySlice()
;;;75           : ConstArraySlice<Type>(), arrayData(NULL)
;;;76         {
;;;77         }
;;;78     
;;;79         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array)
;;;80           : ConstArraySlice<Type>(array)
;;;81         {
;;;82           if(array.get_numElements() == 0) {
;;;83             this->arrayData = NULL;
;;;84           } else {
;;;85             this->arrayData = array.Pointer(0,0);
;;;86           }
;;;87         }
;;;88     
;;;89         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;90           : ConstArraySlice<Type>(array, ySlice, xSlice)
;;;91         {
;;;92           if(array.get_numElements() == 0) {
;;;93             this->arrayData = NULL;
;;;94           } else {
;;;95             this->arrayData = array.Pointer(0,0);
;;;96           }
;;;97         }
;;;98     
;;;99         template<typename Type> s32 ArraySlice<Type>::Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;100        {
;;;101          return this->SetCast<Type>(input, automaticTranspose);
;;;102        }
;;;103    
;;;104        template<typename Type> s32 ArraySlice<Type>::Set(const LinearSequence<Type> &input)
;;;105        {
;;;106          const Result result = input.Evaluate(*this);
;;;107          return (result==RESULT_OK) ? input.get_size() : 0;
;;;108        }
;;;109    
;;;110        template<typename Type> s32 ArraySlice<Type>::Set(const Type value)
;;;111        {
;;;112          Array<Type> &array = this->get_array();
;;;113    
;;;114          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;115            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;116    
;;;117          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;118    
;;;119          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;120            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;121    
;;;122          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;123            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;124            Type * restrict pMat = array.Pointer(y, 0);
;;;125    
;;;126            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;127              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;128              pMat[x] = value;
;;;129            }
;;;130          }
;;;131    
;;;132          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;133        }
;;;134    
;;;135        template<typename Type> s32 ArraySlice<Type>::Set(const Type * const values, const s32 numValues)
;;;136        {
;;;137          Array<Type> &array = this->get_array();
;;;138    
;;;139          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;140            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;141    
;;;142          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;143    
;;;144          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;145            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;146    
;;;147          AnkiConditionalErrorAndReturnValue(limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize == numValues,
;;;148            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;149    
;;;150          s32 ci = 0;
;;;151          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;152            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;153            Type * restrict pMat = array.Pointer(y, 0);
;;;154    
;;;155            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;156              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;157              pMat[x] = values[ci];
;;;158              ci++;
;;;159            }
;;;160          }
;;;161    
;;;162          AnkiAssert(ci == limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize);
;;;163    
;;;164          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;165        }
;;;166    
;;;167        template<typename Type> template<typename InType> s32 ArraySlice<Type>::SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;168        {
;;;169          AnkiConditionalErrorAndReturnValue(AreValid(*this, input),
;;;170            0, "ArraySlice<Type>::Set", "Invalid objects");
;;;171    
;;;172          AnkiConditionalErrorAndReturnValue(this->get_array().get_buffer() != input.get_array().get_buffer(),
;;;173            0, "ArraySlice<Type>::Set", "Arrays must be in different memory locations");
;;;174    
;;;175          ArraySliceLimits_in1_out1<s32> limits(
;;;176            input.get_ySlice(), input.get_xSlice(), input.get_isTransposed(),
;;;177            this->get_ySlice(), this->get_xSlice());
;;;178    
;;;179          if(!limits.isValid) {
;;;180            if(automaticTranspose) {
;;;181              // If we're allowed to transpose, give it another shot
;;;182              limits = ArraySliceLimits_in1_out1<s32> (input.get_ySlice(), input.get_xSlice(), !input.get_isTransposed(), this->get_ySlice(), this->get_xSlice());
;;;183    
;;;184              if(!limits.isValid) {
;;;185                AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;186                return 0;
;;;187              }
;;;188            } else {
;;;189              AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;190              return 0;
;;;191            }
;;;192          }
;;;193    
;;;194          Array<Type> &out1Array = this->get_array();
;;;195          const Array<InType> &in1Array = input.get_array();
;;;196    
;;;197          if(limits.isSimpleIteration) {
;;;198            // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;199    
;;;200            for(s32 y=0; y<limits.ySize; y++) {
;;;201              const InType * restrict pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;202              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;203    
;;;204              limits.OuterIncrementTop();
;;;205    
;;;206              for(s32 x=0; x<limits.xSize; x++) {
;;;207                pOut1[limits.out1X] = static_cast<Type>( pIn1[limits.in1X] );
;;;208    
;;;209                limits.out1X += limits.out1_xInnerIncrement;
;;;210                limits.in1X += limits.in1_xInnerIncrement;
;;;211              }
;;;212    
;;;213              limits.OuterIncrementBottom();
;;;214            }
;;;215          } else {
;;;216            for(s32 y=0; y<limits.ySize; y++) {
;;;217              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;218    
;;;219              limits.OuterIncrementTop();
;;;220    
;;;221              for(s32 x=0; x<limits.xSize; x++) {
;;;222                const InType pIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;223    
;;;224                pOut1[limits.out1X] = static_cast<Type>( pIn1 );
;;;225    
;;;226                limits.out1X += limits.out1_xInnerIncrement;
;;;227                limits.in1Y += limits.in1_yInnerIncrement;
;;;228              }
;;;229    
;;;230              limits.OuterIncrementBottom();
;;;231            }
;;;232          }
;;;233    
;;;234          return limits.ySize*limits.xSize;
;;;235        }
;;;236    
                          ENDP

00022e  0000              DCW      0x0000
                  |L145.560|
                          DCD      _ZZN4Anki8Embedded10ArraySliceIiE7SetCastIiEEiRKNS0_25ConstArraySliceExpressionIiEEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySlice<int>::SetCast<int>(const Anki::Embedded::ConstArraySliceExpression<int>&, bool)::__PRETTY_FUNCTION__
                  |L145.564|
000234  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/arrayS"
000238  6f726574
00023c  6563685c
000240  636f6d6d
000244  6f6e5c69
000248  6e636c75
00024c  64655c61
000250  6e6b692f
000254  636f6d6d
000258  6f6e2f72
00025c  6f626f74
000260  2f617272
000264  617953  
000267  6c696365          DCB      "lices.h",0
00026b  732e6800
00026f  00                DCB      0
                  |L145.624|
000270  41727261          DCB      "Arrays must be in different memory locations",0
000274  7973206d
000278  75737420
00027c  62652069
000280  6e206469
000284  66666572
000288  656e7420
00028c  6d656d6f
000290  7279206c
000294  6f636174
000298  696f6e73
00029c  00      
00029d  00                DCB      0
00029e  00                DCB      0
00029f  00                DCB      0
                  |L145.672|
0002a0  41727261          DCB      "ArraySlice<Type>::Set",0
0002a4  79536c69
0002a8  63653c54
0002ac  7970653e
0002b0  3a3a5365
0002b4  7400    
0002b6  00                DCB      0
0002b7  00                DCB      0
                  |L145.696|
0002b8  496e7661          DCB      "Invalid objects",0
0002bc  6c696420
0002c0  6f626a65
0002c4  63747300
                  |L145.712|
0002c8  53756273          DCB      "Subscripted assignment dimension mismatch",0
0002cc  63726970
0002d0  74656420
0002d4  61737369
0002d8  676e6d65
0002dc  6e742064
0002e0  696d656e
0002e4  73696f6e
0002e8  206d6973
0002ec  6d617463
0002f0  6800    
0002f2  00                DCB      0
0002f3  00                DCB      0

                          AREA ||area_number.146||, COMGROUP=_ZN4Anki8Embedded10ArraySliceIiE7SetCastIiEEiRKNS0_25ConstArraySliceExpressionIiEEb, LINKORDER=||t._ZN4Anki8Embedded10ArraySliceIiE7SetCastIiEEiRKNS0_25ConstArraySliceExpressionIiEEb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.146||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded10ArraySliceIiE7SetCastIiEEiRKNS0_25ConstArraySliceExpressionIiEEb||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<float>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L152.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L152.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L152.384|
000044  a25c              ADR      r2,|L152.440|
000046  a160              ADR      r1,|L152.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L152.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L152.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L152.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L152.384|
000080  a24d              ADR      r2,|L152.440|
000082  a157              ADR      r1,|L152.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L152.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L152.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L152.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L152.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L152.384|
0000c8  a251              ADR      r2,|L152.528|
0000ca  a156              ADR      r1,|L152.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L152.372|
                  |L152.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L152.384|
0000e0  a258              ADR      r2,|L152.580|
0000e2  a15f              ADR      r1,|L152.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L152.372|
                  |L152.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L152.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L152.384|
000110  a259              ADR      r2,|L152.632|
000112  a144              ADR      r1,|L152.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L152.372|
                  |L152.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L152.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L152.384|
00015a  a251              ADR      r2,|L152.672|
00015c  a140              ADR      r1,|L152.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L152.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L152.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L152.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L152.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L152.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L152.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L152.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L152.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L152.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L152.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L152.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L152.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L152.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L152.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.153||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.153||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||, COMGROUP=_ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii PROC ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)
;;;1622   
;;;1623         template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1624         {
000004  b083              SUB      sp,sp,#0xc
000006  460c              MOV      r4,r1
000008  e9dd6710          LDRD     r6,r7,[sp,#0x40]
00000c  4692              MOV      r10,r2
00000e  4680              MOV      r8,r0
;;;1625           const s32 arrHeight = arr.get_size(0);
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000016  4681              MOV      r9,r0
;;;1626           const s32 arrWidth = arr.get_size(1);
000018  2101              MOVS     r1,#1
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000020  4605              MOV      r5,r0
000022  f8d80010          LDR      r0,[r8,#0x10]
000026  2800              CMP      r0,#0
000028  d026              BEQ      |L159.120|
00002a  f8d80000          LDR      r0,[r8,#0]
00002e  2800              CMP      r0,#0
000030  bfa4              ITT      GE
000032  f8d80004          LDRGE    r0,[r8,#4]
000036  2800              CMPGE    r0,#0
000038  db1e              BLT      |L159.120|
00003a  6920              LDR      r0,[r4,#0x10]
00003c  2800              CMP      r0,#0
00003e  d01b              BEQ      |L159.120|
000040  6820              LDR      r0,[r4,#0]
000042  2800              CMP      r0,#0
000044  bfa4              ITT      GE
000046  6860              LDRGE    r0,[r4,#4]
000048  2800              CMPGE    r0,#0
00004a  db15              BLT      |L159.120|
;;;1627   
;;;1628           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1629             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1630   
;;;1631           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
00004c  f1ba0f00          CMP      r10,#0
000050  bf18              IT       NE
000052  f1ba0f01          CMPNE    r10,#1
000056  d01f              BEQ      |L159.152|
000058  f240615f          MOV      r1,#0x65f
00005c  48e7              LDR      r0,|L159.1020|
00005e  e9cd0100          STRD     r0,r1,[sp,#0]
000062  a3e7              ADR      r3,|L159.1024|
000064  a2f4              ADR      r2,|L159.1080|
000066  a1fe              ADR      r1,|L159.1120|
000068  2005              MOVS     r0,#5
00006a  f7fffffe          BL       _Anki_Log
;;;1632             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1633   
;;;1634           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1635             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1636   
;;;1637           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1638           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1639   
;;;1640           if(sortWhichDimension == 0) {
;;;1641             for(s32 y=0; y<arrHeight; y++) {
;;;1642               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1643               for(s32 x=0; x<arrWidth; x++) {
;;;1644                 pIndexes[x] = y;
;;;1645               }
;;;1646             }
;;;1647   
;;;1648             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1649             if(sortAscending) {
;;;1650               InsertionSort_sortAscendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1651             } else { // if(sortAscending)
;;;1652               InsertionSort_sortDescendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1653             } // if(sortAscending) ... else
;;;1654           } else { // sortWhichDimension == 1
;;;1655             for(s32 y=0; y<arrHeight; y++) {
;;;1656               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1657               for(s32 x=0; x<arrWidth; x++) {
;;;1658                 pIndexes[x] = x;
;;;1659               }
;;;1660             }
;;;1661   
;;;1662             if(sortAscending) {
;;;1663               InsertionSort_sortAscendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1664             } else { // if(sortAscending)
;;;1665               InsertionSort_sortDescendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1666             } // if(sortAscending) ... else
;;;1667           } // if(sortWhichDimension == 0) ... else
;;;1668   
;;;1669           return RESULT_OK;
;;;1670         } // InsertionSort()
00006e  b007              ADD      sp,sp,#0x1c
000070  f04f7040          MOV      r0,#0x3000000         ;1631
000074  e8bd8ff0          POP      {r4-r11,pc}
                  |L159.120|
000078  f240615c          MOV      r1,#0x65c             ;1628
00007c  48df              LDR      r0,|L159.1020|
00007e  e9cd0100          STRD     r0,r1,[sp,#0]         ;1628
000082  a3df              ADR      r3,|L159.1024|
000084  a2f8              ADR      r2,|L159.1128|
000086  a1f6              ADR      r1,|L159.1120|
000088  2005              MOVS     r0,#5                 ;1628
00008a  f7fffffe          BL       _Anki_Log
00008e  b007              ADD      sp,sp,#0x1c
000090  f04f6080          MOV      r0,#0x4000000         ;1628
000094  e8bd8ff0          POP      {r4-r11,pc}
                  |L159.152|
000098  2100              MOVS     r1,#0
00009a  4640              MOV      r0,r8
00009c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000a0  4683              MOV      r11,r0
0000a2  2100              MOVS     r1,#0
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
0000aa  4583              CMP      r11,r0
0000ac  d10a              BNE      |L159.196|
0000ae  2101              MOVS     r1,#1
0000b0  4640              MOV      r0,r8
0000b2  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000b6  4683              MOV      r11,r0
0000b8  2101              MOVS     r1,#1
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
0000c0  4583              CMP      r11,r0
0000c2  d00f              BEQ      |L159.228|
                  |L159.196|
0000c4  f2406162          MOV      r1,#0x662             ;1634
0000c8  48cc              LDR      r0,|L159.1020|
0000ca  e9cd0100          STRD     r0,r1,[sp,#0]         ;1634
0000ce  a3cc              ADR      r3,|L159.1024|
0000d0  a2ea              ADR      r2,|L159.1148|
0000d2  a1e3              ADR      r1,|L159.1120|
0000d4  2005              MOVS     r0,#5                 ;1634
0000d6  f7fffffe          BL       _Anki_Log
0000da  b007              ADD      sp,sp,#0x1c
0000dc  f04f60a0          MOV      r0,#0x5000000         ;1634
0000e0  e8bd8ff0          POP      {r4-r11,pc}
                  |L159.228|
0000e4  4651              MOV      r1,r10                ;1637
0000e6  4640              MOV      r0,r8                 ;1637
0000e8  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000ec  1e41              SUBS     r1,r0,#1              ;1637
0000ee  2e00              CMP      r6,#0                 ;1637
0000f0  bfcc              ITE      GT                    ;1637
0000f2  4630              MOVGT    r0,r6                 ;1637
0000f4  2000              MOVLE    r0,#0                 ;1637
0000f6  4281              CMP      r1,r0                 ;1637
0000f8  dd03              BLE      |L159.258|
0000fa  2e00              CMP      r6,#0                 ;1637
0000fc  bfd8              IT       LE                    ;1637
0000fe  2600              MOVLE    r6,#0                 ;1637
000100  e004              B        |L159.268|
                  |L159.258|
000102  4651              MOV      r1,r10                ;1637
000104  4640              MOV      r0,r8                 ;1637
000106  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00010a  1e46              SUBS     r6,r0,#1              ;1637
                  |L159.268|
00010c  4651              MOV      r1,r10                ;1638
00010e  4640              MOV      r0,r8                 ;1638
000110  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000114  1e41              SUBS     r1,r0,#1              ;1638
000116  2f00              CMP      r7,#0                 ;1638
000118  bfcc              ITE      GT                    ;1638
00011a  4638              MOVGT    r0,r7                 ;1638
00011c  2000              MOVLE    r0,#0                 ;1638
00011e  4281              CMP      r1,r0                 ;1638
000120  dd03              BLE      |L159.298|
000122  2f00              CMP      r7,#0                 ;1638
000124  bfd8              IT       LE                    ;1638
000126  2700              MOVLE    r7,#0                 ;1638
000128  e004              B        |L159.308|
                  |L159.298|
00012a  4651              MOV      r1,r10                ;1638
00012c  4640              MOV      r0,r8                 ;1638
00012e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000132  1e47              SUBS     r7,r0,#1              ;1638
                  |L159.308|
000134  f04f0b00          MOV      r11,#0                ;1638
000138  f1ba0f00          CMP      r10,#0                ;1640
00013c  4659              MOV      r1,r11                ;1655
00013e  d037              BEQ      |L159.432|
000140  f1b90f00          CMP      r9,#0                 ;1655
000144  dd0e              BLE      |L159.356|
                  |L159.326|
000146  68a2              LDR      r2,[r4,#8]            ;1655
000148  6920              LDR      r0,[r4,#0x10]         ;1655
00014a  fb010202          MLA      r2,r1,r2,r0           ;1655
00014e  2000              MOVS     r0,#0                 ;1657
000150  2d00              CMP      r5,#0                 ;1657
000152  dd04              BLE      |L159.350|
                  |L159.340|
000154  f8420020          STR      r0,[r2,r0,LSL #2]     ;1658
000158  1c40              ADDS     r0,r0,#1              ;1657
00015a  4285              CMP      r5,r0                 ;1657
00015c  dcfa              BGT      |L159.340|
                  |L159.350|
00015e  1c49              ADDS     r1,r1,#1              ;1655
000160  4549              CMP      r1,r9                 ;1655
000162  dbf0              BLT      |L159.326|
                  |L159.356|
000164  9806              LDR      r0,[sp,#0x18]         ;1662
000166  f04f0100          MOV      r1,#0                 ;1662
00016a  2800              CMP      r0,#0                 ;1662
00016c  4640              MOV      r0,r8                 ;1662
00016e  f0008117          BEQ.W    |L159.928|
000172  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000176  f1b00a00          SUBS     r10,r0,#0             ;1662
00017a  f04f0500          MOV      r5,#0                 ;1662
00017e  f34081a5          BLE.W    |L159.1228|
                  |L159.386|
000182  f8d81008          LDR      r1,[r8,#8]            ;1662
000186  f8d80010          LDR      r0,[r8,#0x10]         ;1662
00018a  1c72              ADDS     r2,r6,#1              ;1662
00018c  fb050c01          MLA      r12,r5,r1,r0          ;1662
000190  68a1              LDR      r1,[r4,#8]            ;1662
000192  6920              LDR      r0,[r4,#0x10]         ;1662
000194  42ba              CMP      r2,r7                 ;1662
000196  fb050301          MLA      r3,r5,r1,r0           ;1662
00019a  f8c3b000          STR      r11,[r3,#0]           ;1662
00019e  dc7a              BGT      |L159.662|
                  |L159.416|
0001a0  eb0c0082          ADD      r0,r12,r2,LSL #2      ;1662
0001a4  f8539022          LDR      r9,[r3,r2,LSL #2]     ;1662
0001a8  edd00a00          VLDR     s1,[r0,#0]            ;1662
0001ac  4611              MOV      r1,r2                 ;1662
0001ae  e0dd              B        |L159.876|
                  |L159.432|
0001b0  f1b90f00          CMP      r9,#0                 ;1641
0001b4  dd0e              BLE      |L159.468|
                  |L159.438|
0001b6  68a2              LDR      r2,[r4,#8]            ;1641
0001b8  6920              LDR      r0,[r4,#0x10]         ;1641
0001ba  fb010202          MLA      r2,r1,r2,r0           ;1641
0001be  2000              MOVS     r0,#0                 ;1643
0001c0  2d00              CMP      r5,#0                 ;1643
0001c2  dd04              BLE      |L159.462|
                  |L159.452|
0001c4  f8421020          STR      r1,[r2,r0,LSL #2]     ;1644
0001c8  1c40              ADDS     r0,r0,#1              ;1643
0001ca  4285              CMP      r5,r0                 ;1643
0001cc  dcfa              BGT      |L159.452|
                  |L159.462|
0001ce  1c49              ADDS     r1,r1,#1              ;1641
0001d0  4549              CMP      r1,r9                 ;1641
0001d2  dbf0              BLT      |L159.438|
                  |L159.468|
0001d4  9806              LDR      r0,[sp,#0x18]         ;1649
0001d6  b3e0              CBZ      r0,|L159.594|
0001d8  2101              MOVS     r1,#1                 ;1649
0001da  4640              MOV      r0,r8                 ;1649
0001dc  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0001e0  f1b00900          SUBS     r9,r0,#0              ;1649
0001e4  f04f0200          MOV      r2,#0                 ;1649
0001e8  dd54              BLE      |L159.660|
                  |L159.490|
0001ea  1c70              ADDS     r0,r6,#1              ;1649
0001ec  42b8              CMP      r0,r7                 ;1649
0001ee  dc4e              BGT      |L159.654|
                  |L159.496|
0001f0  f8d83008          LDR      r3,[r8,#8]            ;1649
0001f4  f8d81010          LDR      r1,[r8,#0x10]         ;1649
0001f8  fb001103          MLA      r1,r0,r3,r1           ;1649
0001fc  eb010182          ADD      r1,r1,r2,LSL #2       ;1649
000200  68a3              LDR      r3,[r4,#8]            ;1649
000202  edd10a00          VLDR     s1,[r1,#0]            ;1649
000206  6921              LDR      r1,[r4,#0x10]         ;1649
000208  fb001103          MLA      r1,r0,r3,r1           ;1649
00020c  f8515022          LDR      r5,[r1,r2,LSL #2]     ;1649
000210  4601              MOV      r1,r0                 ;1649
000212  e013              B        |L159.572|
                  |L159.532|
000214  fb01330c          MLA      r3,r1,r12,r3          ;1649
000218  eb030382          ADD      r3,r3,r2,LSL #2       ;1649
00021c  f1a10a01          SUB      r10,r1,#1             ;1649
000220  ed830a00          VSTR     s0,[r3,#0]            ;1649
000224  f8d4c008          LDR      r12,[r4,#8]           ;1649
000228  6923              LDR      r3,[r4,#0x10]         ;1649
00022a  fb0a3a0c          MLA      r10,r10,r12,r3        ;1649
00022e  fb01330c          MLA      r3,r1,r12,r3          ;1649
000232  f85aa022          LDR      r10,[r10,r2,LSL #2]   ;1649
000236  f843a022          STR      r10,[r3,r2,LSL #2]    ;1649
00023a  1e49              SUBS     r1,r1,#1              ;1649
                  |L159.572|
00023c  42b1              CMP      r1,r6                 ;1649
00023e  dd12              BLE      |L159.614|
000240  f8d8c008          LDR      r12,[r8,#8]           ;1649
000244  f8d83010          LDR      r3,[r8,#0x10]         ;1649
000248  f1a10a01          SUB      r10,r1,#1             ;1649
00024c  fb0a3a0c          MLA      r10,r10,r12,r3        ;1649
000250  e000              B        |L159.596|
                  |L159.594|
000252  e021              B        |L159.664|
                  |L159.596|
000254  eb0a0a82          ADD      r10,r10,r2,LSL #2     ;1649
000258  ed9a0a00          VLDR     s0,[r10,#0]           ;1649
00025c  eeb40ae0          VCMPE.F32 s0,s1                 ;1649
000260  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1649
000264  dcd6              BGT      |L159.532|
                  |L159.614|
000266  f8d8c008          LDR      r12,[r8,#8]           ;1649
00026a  f8d83010          LDR      r3,[r8,#0x10]         ;1649
00026e  1c40              ADDS     r0,r0,#1              ;1649
000270  fb01330c          MLA      r3,r1,r12,r3          ;1649
000274  eb030382          ADD      r3,r3,r2,LSL #2       ;1649
000278  42b8              CMP      r0,r7                 ;1649
00027a  edc30a00          VSTR     s1,[r3,#0]            ;1649
00027e  f8d4c008          LDR      r12,[r4,#8]           ;1649
000282  6923              LDR      r3,[r4,#0x10]         ;1649
000284  fb01310c          MLA      r1,r1,r12,r3          ;1649
000288  f8415022          STR      r5,[r1,r2,LSL #2]     ;1649
00028c  ddb0              BLE      |L159.496|
                  |L159.654|
00028e  1c52              ADDS     r2,r2,#1              ;1649
000290  454a              CMP      r2,r9                 ;1649
000292  dbaa              BLT      |L159.490|
                  |L159.660|
000294  e11a              B        |L159.1228|
                  |L159.662|
000296  e07e              B        |L159.918|
                  |L159.664|
000298  4645              MOV      r5,r8                 ;1652
00029a  2101              MOVS     r1,#1                 ;1652
00029c  4640              MOV      r0,r8                 ;1652
00029e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0002a2  f1b00a00          SUBS     r10,r0,#0             ;1652
0002a6  f04f0100          MOV      r1,#0                 ;1652
0002aa  dd55              BLE      |L159.856|
                  |L159.684|
0002ac  68a3              LDR      r3,[r4,#8]            ;1652
0002ae  6922              LDR      r2,[r4,#0x10]         ;1652
0002b0  2000              MOVS     r0,#0                 ;1652
0002b2  fb002003          MLA      r0,r0,r3,r2           ;1652
0002b6  1c72              ADDS     r2,r6,#1              ;1652
0002b8  f840b021          STR      r11,[r0,r1,LSL #2]    ;1652
0002bc  42ba              CMP      r2,r7                 ;1652
0002be  dc48              BGT      |L159.850|
                  |L159.704|
0002c0  68ab              LDR      r3,[r5,#8]            ;1652
0002c2  6928              LDR      r0,[r5,#0x10]         ;1652
0002c4  fb020003          MLA      r0,r2,r3,r0           ;1652
0002c8  eb000081          ADD      r0,r0,r1,LSL #2       ;1652
0002cc  68a3              LDR      r3,[r4,#8]            ;1652
0002ce  edd00a00          VLDR     s1,[r0,#0]            ;1652
0002d2  6920              LDR      r0,[r4,#0x10]         ;1652
0002d4  fb020003          MLA      r0,r2,r3,r0           ;1652
0002d8  f8509021          LDR      r9,[r0,r1,LSL #2]     ;1652
0002dc  4610              MOV      r0,r2                 ;1652
0002de  e013              B        |L159.776|
                  |L159.736|
0002e0  fb00330c          MLA      r3,r0,r12,r3          ;1652
0002e4  eb030381          ADD      r3,r3,r1,LSL #2       ;1652
0002e8  f1a00801          SUB      r8,r0,#1              ;1652
0002ec  ed830a00          VSTR     s0,[r3,#0]            ;1652
0002f0  f8d4c008          LDR      r12,[r4,#8]           ;1652
0002f4  6923              LDR      r3,[r4,#0x10]         ;1652
0002f6  fb08380c          MLA      r8,r8,r12,r3          ;1652
0002fa  fb00330c          MLA      r3,r0,r12,r3          ;1652
0002fe  f8588021          LDR      r8,[r8,r1,LSL #2]     ;1652
000302  f8438021          STR      r8,[r3,r1,LSL #2]     ;1652
000306  1e40              SUBS     r0,r0,#1              ;1652
                  |L159.776|
000308  42b0              CMP      r0,r6                 ;1652
00030a  dd0f              BLE      |L159.812|
00030c  f8d5c008          LDR      r12,[r5,#8]           ;1652
000310  692b              LDR      r3,[r5,#0x10]         ;1652
000312  f1a00801          SUB      r8,r0,#1              ;1652
000316  fb08380c          MLA      r8,r8,r12,r3          ;1652
00031a  eb080881          ADD      r8,r8,r1,LSL #2       ;1652
00031e  ed980a00          VLDR     s0,[r8,#0]            ;1652
000322  eeb40ae0          VCMPE.F32 s0,s1                 ;1652
000326  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1652
00032a  d3d9              BCC      |L159.736|
                  |L159.812|
00032c  f8d5c008          LDR      r12,[r5,#8]           ;1652
000330  692b              LDR      r3,[r5,#0x10]         ;1652
000332  1c52              ADDS     r2,r2,#1              ;1652
000334  fb00330c          MLA      r3,r0,r12,r3          ;1652
000338  eb030381          ADD      r3,r3,r1,LSL #2       ;1652
00033c  42ba              CMP      r2,r7                 ;1652
00033e  edc30a00          VSTR     s1,[r3,#0]            ;1652
000342  f8d4c008          LDR      r12,[r4,#8]           ;1652
000346  6923              LDR      r3,[r4,#0x10]         ;1652
000348  fb00300c          MLA      r0,r0,r12,r3          ;1652
00034c  f8409021          STR      r9,[r0,r1,LSL #2]     ;1652
000350  ddb6              BLE      |L159.704|
                  |L159.850|
000352  1c49              ADDS     r1,r1,#1              ;1652
000354  4551              CMP      r1,r10                ;1652
000356  dba9              BLT      |L159.684|
                  |L159.856|
000358  e0b8              B        |L159.1228|
                  |L159.858|
00035a  ed800a00          VSTR     s0,[r0,#0]            ;1652
00035e  eb030081          ADD      r0,r3,r1,LSL #2       ;1652
000362  f8500c04          LDR      r0,[r0,#-4]           ;1652
000366  f8430021          STR      r0,[r3,r1,LSL #2]     ;1652
00036a  1e49              SUBS     r1,r1,#1              ;1652
                  |L159.876|
00036c  42b1              CMP      r1,r6                 ;1652
00036e  dd08              BLE      |L159.898|
000370  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1652
000374  ed100a01          VLDR     s0,[r0,#-4]           ;1652
000378  eeb40ae0          VCMPE.F32 s0,s1                 ;1652
00037c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1652
000380  dceb              BGT      |L159.858|
                  |L159.898|
000382  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1652
000386  1c52              ADDS     r2,r2,#1              ;1652
000388  edc00a00          VSTR     s1,[r0,#0]            ;1652
00038c  f8439021          STR      r9,[r3,r1,LSL #2]     ;1652
000390  42ba              CMP      r2,r7                 ;1652
000392  f77faf05          BLE      |L159.416|
                  |L159.918|
000396  1c6d              ADDS     r5,r5,#1              ;1652
000398  4555              CMP      r5,r10                ;1652
00039a  f6ffaef2          BLT      |L159.386|
00039e  e095              B        |L159.1228|
                  |L159.928|
0003a0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0003a4  f1b00a00          SUBS     r10,r0,#0             ;1652
0003a8  f04f0500          MOV      r5,#0                 ;1652
0003ac  dd7a              BLE      |L159.1188|
                  |L159.942|
0003ae  f8d81008          LDR      r1,[r8,#8]            ;1652
0003b2  f8d80010          LDR      r0,[r8,#0x10]         ;1652
0003b6  1c72              ADDS     r2,r6,#1              ;1652
0003b8  fb050c01          MLA      r12,r5,r1,r0          ;1652
0003bc  68a1              LDR      r1,[r4,#8]            ;1652
0003be  6920              LDR      r0,[r4,#0x10]         ;1652
0003c0  42ba              CMP      r2,r7                 ;1652
0003c2  fb050301          MLA      r3,r5,r1,r0           ;1652
0003c6  f8c3b000          STR      r11,[r3,#0]           ;1652
0003ca  dc7b              BGT      |L159.1220|
                  |L159.972|
0003cc  eb0c0082          ADD      r0,r12,r2,LSL #2      ;1652
0003d0  f8539022          LDR      r9,[r3,r2,LSL #2]     ;1652
0003d4  edd00a00          VLDR     s1,[r0,#0]            ;1652
0003d8  4611              MOV      r1,r2                 ;1652
0003da  e008              B        |L159.1006|
                  |L159.988|
0003dc  ed800a00          VSTR     s0,[r0,#0]            ;1652
0003e0  eb030081          ADD      r0,r3,r1,LSL #2       ;1652
0003e4  f8500c04          LDR      r0,[r0,#-4]           ;1652
0003e8  f8430021          STR      r0,[r3,r1,LSL #2]     ;1652
0003ec  1e49              SUBS     r1,r1,#1              ;1652
                  |L159.1006|
0003ee  42b1              CMP      r1,r6                 ;1652
0003f0  dd5f              BLE      |L159.1202|
0003f2  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1652
0003f6  ed100a01          VLDR     s0,[r0,#-4]           ;1652
0003fa  e055              B        |L159.1192|
                  |L159.1020|
                          DCD      _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::__PRETTY_FUNCTION__
                  |L159.1024|
000400  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000404  6f726574
000408  6563685c
00040c  636f6d6d
000410  6f6e5c69
000414  6e636c75
000418  64655c61
00041c  6e6b692f
000420  636f6d6d
000424  6f6e2f72
000428  6f626f74
00042c  2f6d6174
000430  726978  
000433  2e6800            DCB      ".h",0
000436  00                DCB      0
000437  00                DCB      0
                  |L159.1080|
000438  736f7274          DCB      "sortWhichDimension must be zero or one",0
00043c  57686963
000440  6844696d
000444  656e7369
000448  6f6e206d
00044c  75737420
000450  6265207a
000454  65726f20
000458  6f72206f
00045c  6e6500  
00045f  00                DCB      0
                  |L159.1120|
000460  536f7274          DCB      "Sort",0
000464  00      
000465  00                DCB      0
000466  00                DCB      0
000467  00                DCB      0
                  |L159.1128|
000468  4f626a65          DCB      "Objects are invalid",0
00046c  63747320
000470  61726520
000474  696e7661
000478  6c696400
                  |L159.1148|
00047c  696e6465          DCB      "indexes must be the same size as arr",0
000480  78657320
000484  6d757374
000488  20626520
00048c  74686520
000490  73616d65
000494  2073697a
000498  65206173
00049c  20617272
0004a0  00      
0004a1  00                DCB      0
0004a2  00                DCB      0
0004a3  00                DCB      0
                  |L159.1188|
0004a4  e012              B        |L159.1228|
0004a6  e00d              B        |L159.1220|
                  |L159.1192|
0004a8  eeb40ae0          VCMPE.F32 s0,s1                 ;1652
0004ac  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1652
0004b0  d394              BCC      |L159.988|
                  |L159.1202|
0004b2  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1652
0004b6  1c52              ADDS     r2,r2,#1              ;1652
0004b8  edc00a00          VSTR     s1,[r0,#0]            ;1652
0004bc  f8439021          STR      r9,[r3,r1,LSL #2]     ;1652
0004c0  42ba              CMP      r2,r7                 ;1652
0004c2  dd83              BLE      |L159.972|
                  |L159.1220|
0004c4  1c6d              ADDS     r5,r5,#1              ;1652
0004c6  4555              CMP      r5,r10                ;1652
0004c8  f6ffaf71          BLT      |L159.942|
                  |L159.1228|
0004cc  b007              ADD      sp,sp,#0x1c
0004ce  2000              MOVS     r0,#0                 ;1669
0004d0  e8bd8ff0          POP      {r4-r11,pc}
;;;1671   
                          ENDP


                          AREA ||area_number.160||, COMGROUP=_ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii, LINKORDER=||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.160||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi PROC ; Anki::Embedded::Array<float>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L166.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L166.56|
00000e  4b0b              LDR      r3,|L166.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f1030250          ADD      r2,r3,#0x50
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L166.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L166.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::get_size(int) const::__PRETTY_FUNCTION__
                  |L166.60|
                          DCD      ||.constdata||+0x284

                          AREA ||area_number.167||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.167||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||.constdata__ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
00001c  696e6561          DCB      0x69,0x6e,0x65,0x61
000020  72536571          DCB      0x72,0x53,0x65,0x71
000024  75656e63          DCB      0x75,0x65,0x6e,0x63
000028  653c5479          DCB      0x65,0x3c,0x54,0x79
00002c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000030  3a636f6d          DCB      0x3a,0x63,0x6f,0x6d
000034  70757465          DCB      0x70,0x75,0x74,0x65
000038  53697a65          DCB      0x53,0x69,0x7a,0x65
00003c  28547970          DCB      0x28,0x54,0x79,0x70
000040  652c2054          DCB      0x65,0x2c,0x20,0x54
000044  7970652c          DCB      0x79,0x70,0x65,0x2c
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  6529205b          DCB      0x65,0x29,0x20,0x5b
000050  77697468          DCB      0x77,0x69,0x74,0x68
000054  20547970          DCB      0x20,0x54,0x79,0x70
000058  65203d20          DCB      0x65,0x20,0x3d,0x20
00005c  7369676e          DCB      0x73,0x69,0x67,0x6e
000060  65642069          DCB      0x65,0x64,0x20,0x69
000064  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  79536c69          DCB      0x79,0x53,0x6c,0x69
000018  63654c69          DCB      0x63,0x65,0x4c,0x69
00001c  6d697473          DCB      0x6d,0x69,0x74,0x73
000020  5f696e31          DCB      0x5f,0x69,0x6e,0x31
000024  5f6f7574          DCB      0x5f,0x6f,0x75,0x74
000028  313c5479          DCB      0x31,0x3c,0x54,0x79
00002c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000030  3a417272          DCB      0x3a,0x41,0x72,0x72
000034  6179536c          DCB      0x61,0x79,0x53,0x6c
000038  6963654c          DCB      0x69,0x63,0x65,0x4c
00003c  696d6974          DCB      0x69,0x6d,0x69,0x74
000040  735f696e          DCB      0x73,0x5f,0x69,0x6e
000044  315f6f75          DCB      0x31,0x5f,0x6f,0x75
000048  74312863          DCB      0x74,0x31,0x28,0x63
00004c  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000050  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000054  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000058  6d626564          DCB      0x6d,0x62,0x65,0x64
00005c  6465643a          DCB      0x64,0x65,0x64,0x3a
000060  3a4c696e          DCB      0x3a,0x4c,0x69,0x6e
000064  65617253          DCB      0x65,0x61,0x72,0x53
000068  65717565          DCB      0x65,0x71,0x75,0x65
00006c  6e63653c          DCB      0x6e,0x63,0x65,0x3c
000070  54797065          DCB      0x54,0x79,0x70,0x65
000074  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000078  20636f6e          DCB      0x20,0x63,0x6f,0x6e
00007c  73742041          DCB      0x73,0x74,0x20,0x41
000080  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000084  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000088  65646465          DCB      0x65,0x64,0x64,0x65
00008c  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
000090  696e6561          DCB      0x69,0x6e,0x65,0x61
000094  72536571          DCB      0x72,0x53,0x65,0x71
000098  75656e63          DCB      0x75,0x65,0x6e,0x63
00009c  653c5479          DCB      0x65,0x3c,0x54,0x79
0000a0  70653e20          DCB      0x70,0x65,0x3e,0x20
0000a4  262c2062          DCB      0x26,0x2c,0x20,0x62
0000a8  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
0000ac  20636f6e          DCB      0x20,0x63,0x6f,0x6e
0000b0  73742041          DCB      0x73,0x74,0x20,0x41
0000b4  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000b8  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000bc  65646465          DCB      0x65,0x64,0x64,0x65
0000c0  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
0000c4  696e6561          DCB      0x69,0x6e,0x65,0x61
0000c8  72536571          DCB      0x72,0x53,0x65,0x71
0000cc  75656e63          DCB      0x75,0x65,0x6e,0x63
0000d0  653c5479          DCB      0x65,0x3c,0x54,0x79
0000d4  70653e20          DCB      0x70,0x65,0x3e,0x20
0000d8  262c2063          DCB      0x26,0x2c,0x20,0x63
0000dc  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0000e0  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000e4  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000e8  6d626564          DCB      0x6d,0x62,0x65,0x64
0000ec  6465643a          DCB      0x64,0x65,0x64,0x3a
0000f0  3a4c696e          DCB      0x3a,0x4c,0x69,0x6e
0000f4  65617253          DCB      0x65,0x61,0x72,0x53
0000f8  65717565          DCB      0x65,0x71,0x75,0x65
0000fc  6e63653c          DCB      0x6e,0x63,0x65,0x3c
000100  54797065          DCB      0x54,0x79,0x70,0x65
000104  3e202629          DCB      0x3e,0x20,0x26,0x29
000108  205b7769          DCB      0x20,0x5b,0x77,0x69
00010c  74682054          DCB      0x74,0x68,0x20,0x54
000110  79706520          DCB      0x79,0x70,0x65,0x20
000114  3d207369          DCB      0x3d,0x20,0x73,0x69
000118  676e6564          DCB      0x67,0x6e,0x65,0x64
00011c  20696e74          DCB      0x20,0x69,0x6e,0x74
000120  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d207369          DCB      0x3d,0x20,0x73,0x69
000088  676e6564          DCB      0x67,0x6e,0x65,0x64
00008c  20696e74          DCB      0x20,0x69,0x6e,0x74
000090  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE7SetZeroEvE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE7SetZeroEvE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::SetZero()::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  5365745a          DCB      0x53,0x65,0x74,0x5a
00002c  65726f28          DCB      0x65,0x72,0x6f,0x28
000030  29205b77          DCB      0x29,0x20,0x5b,0x77
000034  69746820          DCB      0x69,0x74,0x68,0x20
000038  54797065          DCB      0x54,0x79,0x70,0x65
00003c  203d2073          DCB      0x20,0x3d,0x20,0x73
000040  69676e65          DCB      0x69,0x67,0x6e,0x65
000044  6420696e          DCB      0x64,0x20,0x69,0x6e
000048  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  7369676e          DCB      0x73,0x69,0x67,0x6e
000054  65642069          DCB      0x65,0x64,0x20,0x69
000058  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  7369676e          DCB      0x73,0x69,0x67,0x6e
0000bc  65642069          DCB      0x65,0x64,0x20,0x69
0000c0  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2073          DCB      0x20,0x3d,0x20,0x73
000094  69676e65          DCB      0x69,0x67,0x6e,0x65
000098  6420696e          DCB      0x64,0x20,0x69,0x6e
00009c  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000088  6f61745d          DCB      0x6f,0x61,0x74,0x5d
00008c  00                DCB      0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000054  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000bc  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2066          DCB      0x20,0x3d,0x20,0x66
000094  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000098  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  756e7369          DCB      0x75,0x6e,0x73,0x69
000054  676e6564          DCB      0x67,0x6e,0x65,0x64
000058  20636861          DCB      0x20,0x63,0x68,0x61
00005c  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded10ArraySliceIiE7SetCastIiEEiRKNS0_25ConstArraySliceExpressionIiEEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded10ArraySliceIiE7SetCastIiEEiRKNS0_25ConstArraySliceExpressionIiEEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded10ArraySliceIiE7SetCastIiEEiRKNS0_25ConstArraySliceExpressionIiEEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySlice<int>::SetCast<int>(const Anki::Embedded::ConstArraySliceExpression<int>&, bool)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  536c6963          DCB      0x53,0x6c,0x69,0x63
000024  653c5479          DCB      0x65,0x3c,0x54,0x79
000028  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00002c  3a536574          DCB      0x3a,0x53,0x65,0x74
000030  43617374          DCB      0x43,0x61,0x73,0x74
000034  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000038  73742041          DCB      0x73,0x74,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a43          DCB      0x64,0x3a,0x3a,0x43
00004c  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000050  41727261          DCB      0x41,0x72,0x72,0x61
000054  79536c69          DCB      0x79,0x53,0x6c,0x69
000058  63654578          DCB      0x63,0x65,0x45,0x78
00005c  70726573          DCB      0x70,0x72,0x65,0x73
000060  73696f6e          DCB      0x73,0x69,0x6f,0x6e
000064  3c547970          DCB      0x3c,0x54,0x79,0x70
000068  653e2026          DCB      0x65,0x3e,0x20,0x26
00006c  2c20626f          DCB      0x2c,0x20,0x62,0x6f
000070  6f6c2920          DCB      0x6f,0x6c,0x29,0x20
000074  5b776974          DCB      0x5b,0x77,0x69,0x74
000078  6820496e          DCB      0x68,0x20,0x49,0x6e
00007c  54797065          DCB      0x54,0x79,0x70,0x65
000080  203d2073          DCB      0x20,0x3d,0x20,0x73
000084  69676e65          DCB      0x69,0x67,0x6e,0x65
000088  6420696e          DCB      0x64,0x20,0x69,0x6e
00008c  742c2054          DCB      0x74,0x2c,0x20,0x54
000090  79706520          DCB      0x79,0x70,0x65,0x20
000094  3d207369          DCB      0x3d,0x20,0x73,0x69
000098  676e6564          DCB      0x67,0x6e,0x65,0x64
00009c  20696e74          DCB      0x20,0x69,0x6e,0x74
0000a0  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a496e73          DCB      0x3a,0x49,0x6e,0x73
000028  65727469          DCB      0x65,0x72,0x74,0x69
00002c  6f6e536f          DCB      0x6f,0x6e,0x53,0x6f
000030  72742841          DCB      0x72,0x74,0x28,0x41
000034  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000038  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00003c  65646465          DCB      0x65,0x64,0x64,0x65
000040  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000044  72726179          DCB      0x72,0x72,0x61,0x79
000048  3c547970          DCB      0x3c,0x54,0x79,0x70
00004c  653e2026          DCB      0x65,0x3e,0x20,0x26
000050  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000054  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000058  456d6265          DCB      0x45,0x6d,0x62,0x65
00005c  64646564          DCB      0x64,0x64,0x65,0x64
000060  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000064  7261793c          DCB      0x72,0x61,0x79,0x3c
000068  7369676e          DCB      0x73,0x69,0x67,0x6e
00006c  65642069          DCB      0x65,0x64,0x20,0x69
000070  6e743e20          DCB      0x6e,0x74,0x3e,0x20
000074  262c2073          DCB      0x26,0x2c,0x20,0x73
000078  69676e65          DCB      0x69,0x67,0x6e,0x65
00007c  6420696e          DCB      0x64,0x20,0x69,0x6e
000080  742c2062          DCB      0x74,0x2c,0x20,0x62
000084  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
000088  20736967          DCB      0x20,0x73,0x69,0x67
00008c  6e656420          DCB      0x6e,0x65,0x64,0x20
000090  696e742c          DCB      0x69,0x6e,0x74,0x2c
000094  20736967          DCB      0x20,0x73,0x69,0x67
000098  6e656420          DCB      0x6e,0x65,0x64,0x20
00009c  696e7429          DCB      0x69,0x6e,0x74,0x29
0000a0  205b7769          DCB      0x20,0x5b,0x77,0x69
0000a4  74682054          DCB      0x74,0x68,0x20,0x54
0000a8  79706520          DCB      0x79,0x70,0x65,0x20
0000ac  3d20666c          DCB      0x3d,0x20,0x66,0x6c
0000b0  6f61745d          DCB      0x6f,0x61,0x74,0x5d
0000b4  00                DCB      0x00
