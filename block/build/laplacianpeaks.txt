; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\laplacianpeaks.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\laplacianpeaks.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\laplacianpeaks.crf ..\coretech\vision\robot\src\laplacianPeaks.cpp]
                          THUMB

                          AREA ||i._ZN4Anki8Embedded21ExtractLaplacianPeaksERKNS0_15FixedLengthListINS0_5PointIsEEEERS4_NS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded21ExtractLaplacianPeaksERKNS0_15FixedLengthListINS0_5PointIsEEEERS4_NS0_11MemoryStackE PROC ; Anki::Embedded::ExtractLaplacianPeaks(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::MemoryStack)
;;;20       {
;;;21         Result ExtractLaplacianPeaks(const FixedLengthList<Point<s16> > &boundary, FixedLengthList<Point<s16> > &peaks, MemoryStack scratch)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;22         {
000004  4690              MOV      r8,r2
000006  ed2d8b04          VPUSH    {d8-d9}
00000a  b0db              SUB      sp,sp,#0x16c
00000c  460e              MOV      r6,r1
00000e  4607              MOV      r7,r0
000010  68c5              LDR      r5,[r0,#0xc]
000012  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::get_maximumSize() const
;;;23           //BeginBenchmark("elp_part1");
;;;24     
;;;25           AnkiConditionalErrorAndReturnValue(boundary.IsValid(),
000016  4cfa              LDR      r4,|L1.1024|
000018  4285              CMP      r5,r0
00001a  dc36              BGT      |L1.138|
00001c  6ab8              LDR      r0,[r7,#0x28]
00001e  b130              CBZ      r0,|L1.46|
000020  69b8              LDR      r0,[r7,#0x18]
000022  2800              CMP      r0,#0
000024  bfa3              ITTTE    GE
000026  69f8              LDRGE    r0,[r7,#0x1c]
000028  2800              CMPGE    r0,#0
00002a  2001              MOVGE    r0,#1
00002c  2000              MOVLT    r0,#0
                  |L1.46|
00002e  2800              CMP      r0,#0
000030  d02b              BEQ      |L1.138|
000032  4630              MOV      r0,r6
000034  68f5              LDR      r5,[r6,#0xc]
000036  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::get_maximumSize() const
00003a  4285              CMP      r5,r0
00003c  dc31              BGT      |L1.162|
00003e  6ab0              LDR      r0,[r6,#0x28]
000040  b130              CBZ      r0,|L1.80|
000042  69b0              LDR      r0,[r6,#0x18]
000044  2800              CMP      r0,#0
000046  bfa3              ITTTE    GE
000048  69f0              LDRGE    r0,[r6,#0x1c]
00004a  2800              CMPGE    r0,#0
00004c  2001              MOVGE    r0,#1
00004e  2000              MOVLT    r0,#0
                  |L1.80|
;;;26             RESULT_FAIL_INVALID_OBJECT, "ComputeQuadrilateralsFromConnectedComponents", "boundary is not valid");
;;;27     
;;;28           AnkiConditionalErrorAndReturnValue(peaks.IsValid(),
000050  2800              CMP      r0,#0
000052  d026              BEQ      |L1.162|
;;;29             RESULT_FAIL_INVALID_OBJECT, "ComputeQuadrilateralsFromConnectedComponents", "peaks is not valid");
;;;30     
;;;31           AnkiConditionalErrorAndReturnValue(scratch.IsValid(),
000054  4640              MOV      r0,r8
000056  f7fffffe          BL       _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
00005a  2800              CMP      r0,#0
00005c  d02d              BEQ      |L1.186|
;;;32             RESULT_FAIL_INVALID_OBJECT, "ComputeQuadrilateralsFromConnectedComponents", "scratch is not valid");
;;;33     
;;;34           AnkiConditionalErrorAndReturnValue(peaks.get_maximumSize() == 4,
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::get_maximumSize() const
000064  2804              CMP      r0,#4
000066  f0008034          BEQ.W    |L1.210|
00006a  2022              MOVS     r0,#0x22
00006c  e9cd4000          STRD     r4,r0,[sp,#0]
000070  a3e4              ADR      r3,|L1.1028|
000072  a2f0              ADR      r2,|L1.1076|
000074  a1f8              ADR      r1,|L1.1112|
000076  2005              MOVS     r0,#5
000078  f7fffffe          BL       _Anki_Log
00007c  f04f7040          MOV      r0,#0x3000000
                  |L1.128|
;;;35             RESULT_FAIL_INVALID_PARAMETER, "ComputeQuadrilateralsFromConnectedComponents", "Currently only four peaks supported");
;;;36     
;;;37           const s32 maximumTemporaryPeaks = boundary.get_size() / 3; // Worst case
;;;38           const s32 numSigmaFractionalBits = 8;
;;;39           const s32 numStandardDeviations = 3;
;;;40     
;;;41           Result lastResult;
;;;42     
;;;43           const s32 boundaryLength = boundary.get_size();
;;;44     
;;;45           //sigma = boundaryLength/64;
;;;46           const s32 sigma = boundaryLength << (numSigmaFractionalBits-6); // SQ23.8
;;;47     
;;;48           // spacing about 1/4 of side-length
;;;49           //spacing = max(3, round(boundaryLength/16));
;;;50           const s32 spacing = MAX(3,  boundaryLength >> 4);
;;;51     
;;;52           //  stencil = [1 zeros(1, spacing-2) -2 zeros(1, spacing-2) 1];
;;;53           const s32 stencilLength = 1 + spacing - 2 + 1 + spacing - 2 + 1;
;;;54           FixedPointArray<s16> stencil(1, stencilLength, 0, scratch, Flags::Buffer(false,false,false)); // SQ15.0
;;;55           stencil.SetZero();
;;;56           *stencil.Pointer(0, 0) = 1;
;;;57           *stencil.Pointer(0, spacing-1) = -2;
;;;58           *stencil.Pointer(0, stencil.get_size(1)-1) = 1;
;;;59     
;;;60           //dg2 = conv(stencil, gaussian_kernel(sigma));
;;;61           FixedPointArray<s16> gaussian = ImageProcessing::Get1dGaussianKernel<s16>(sigma, numSigmaFractionalBits, numStandardDeviations, scratch); // SQ7.8
;;;62           FixedPointArray<s16> differenceOfGaussian(1, gaussian.get_size(1)+stencil.get_size(1)-1, numSigmaFractionalBits, scratch, Flags::Buffer(false,false,false)); // SQ7.8
;;;63     
;;;64           if((lastResult = ImageProcessing::Correlate1d<s16,s32,s16>(stencil, gaussian, differenceOfGaussian)) != RESULT_OK)
;;;65             return lastResult;
;;;66     
;;;67           FixedPointArray<s16> boundaryXFiltered(1, boundary.get_size(), numSigmaFractionalBits, scratch, Flags::Buffer(false,false,false)); // SQ23.8
;;;68           FixedPointArray<s16> boundaryYFiltered(1, boundary.get_size(), numSigmaFractionalBits, scratch, Flags::Buffer(false,false,false)); // SQ23.8
;;;69     
;;;70           if(!boundaryYFiltered.IsValid())
;;;71             return RESULT_FAIL_INVALID_OBJECT;
;;;72     
;;;73           //gaussian.Print("gaussian");
;;;74           //differenceOfGaussian.Print("differenceOfGaussian");
;;;75     
;;;76           //EndBenchmark("elp_part1");
;;;77     
;;;78           //BeginBenchmark("elp_part2");
;;;79     
;;;80           //r_smooth = imfilter(boundary, dg2(:), 'circular');
;;;81           {
;;;82             PUSH_MEMORY_STACK(scratch);
;;;83             FixedPointArray<s16> boundaryX(1, boundary.get_size(), 0, scratch, Flags::Buffer(false,false,false)); // SQ15.0
;;;84     
;;;85             if(!boundaryX.IsValid())
;;;86               return RESULT_FAIL_INVALID_OBJECT;
;;;87     
;;;88             const Point<s16> * restrict pConstBoundary = boundary.Pointer(0);
;;;89             s16 * restrict pBoundaryX = boundaryX.Pointer(0,0);
;;;90     
;;;91             const s32 lengthBoundary = boundary.get_size();
;;;92             for(s32 i=0; i<lengthBoundary; i++) {
;;;93               pBoundaryX[i] = pConstBoundary[i].x;
;;;94             }
;;;95     
;;;96             if((lastResult = ImageProcessing::Correlate1dCircularAndSameSizeOutput<s16,s32,s16>(boundaryX, differenceOfGaussian, boundaryXFiltered, scratch)) != RESULT_OK)
;;;97               return lastResult;
;;;98     
;;;99             //boundaryX.Print("boundaryX");
;;;100            //boundaryXFiltered.Print("boundaryXFiltered");
;;;101          } // PUSH_MEMORY_STACK(scratch);
;;;102    
;;;103          {
;;;104            PUSH_MEMORY_STACK(scratch);
;;;105            FixedPointArray<s16> boundaryY(1, boundary.get_size(), 0, scratch); // SQ15.0
;;;106    
;;;107            if(!boundaryY.IsValid())
;;;108              return RESULT_FAIL_INVALID_OBJECT;
;;;109    
;;;110            const Point<s16> * restrict pConstBoundary = boundary.Pointer(0);
;;;111            s16 * restrict pBoundaryY = boundaryY.Pointer(0,0);
;;;112    
;;;113            const s32 lengthBoundary = boundary.get_size();
;;;114            for(s32 i=0; i<lengthBoundary; i++) {
;;;115              pBoundaryY[i] = pConstBoundary[i].y;
;;;116            }
;;;117    
;;;118            if((lastResult = ImageProcessing::Correlate1dCircularAndSameSizeOutput<s16,s32,s16>(boundaryY, differenceOfGaussian, boundaryYFiltered, scratch)) != RESULT_OK)
;;;119              return lastResult;
;;;120    
;;;121            //boundaryY.Print("boundaryY");
;;;122            //boundaryYFiltered.Print("boundaryYFiltered");
;;;123          } // PUSH_MEMORY_STACK(scratch);
;;;124    
;;;125          //EndBenchmark("elp_part2");
;;;126    
;;;127          //BeginBenchmark("elp_part3");
;;;128    
;;;129          //r_smooth = sum(r_smooth.^2, 2);
;;;130          FixedPointArray<s32> boundaryFilteredAndCombined(1, boundary.get_size(), 2*numSigmaFractionalBits, scratch, Flags::Buffer(false,false,false)); // SQ15.16
;;;131          s32 * restrict pBoundaryFilteredAndCombined = boundaryFilteredAndCombined.Pointer(0,0);
;;;132    
;;;133          const s16 * restrict pConstBoundaryXFiltered = boundaryXFiltered.Pointer(0,0);
;;;134          const s16 * restrict pConstBoundaryYFiltered = boundaryYFiltered.Pointer(0,0);
;;;135    
;;;136          const s32 lengthBoundary = boundary.get_size();
;;;137          for(s32 i=0; i<lengthBoundary; i++) {
;;;138            //const s32 xSquared = (pConstBoundaryXFiltered[i] * pConstBoundaryXFiltered[i]) >> numSigmaFractionalBits; // SQ23.8
;;;139            //const s32 ySquared = (pConstBoundaryYFiltered[i] * pConstBoundaryYFiltered[i]) >> numSigmaFractionalBits; // SQ23.8
;;;140            const s32 xSquared = (pConstBoundaryXFiltered[i] * pConstBoundaryXFiltered[i]); // SQ31.0 (multiplied by 2^numSigmaFractionalBits)
;;;141            const s32 ySquared = (pConstBoundaryYFiltered[i] * pConstBoundaryYFiltered[i]); // SQ31.0 (multiplied by 2^numSigmaFractionalBits)
;;;142    
;;;143            pBoundaryFilteredAndCombined[i] = xSquared + ySquared;
;;;144          }
;;;145    
;;;146          FixedLengthList<s32> localMaxima(maximumTemporaryPeaks, scratch, Flags::Buffer(false,false,false));
;;;147    
;;;148          const s32 * restrict pConstBoundaryFilteredAndCombined = boundaryFilteredAndCombined.Pointer(0,0);
;;;149    
;;;150          //EndBenchmark("elp_part3");
;;;151    
;;;152          //BeginBenchmark("elp_part4");
;;;153    
;;;154          // Find local maxima -- these should correspond to the corners of the square.
;;;155          // NOTE: one of the comparisons is >= while the other is >, in order to
;;;156          // combat rare cases where we have two responses next to each other that are exactly equal.
;;;157          // localMaxima = find(r_smooth >= r_smooth([end 1:end-1]) & r_smooth > r_smooth([2:end 1]));
;;;158    
;;;159          if(pConstBoundaryFilteredAndCombined[0] > pConstBoundaryFilteredAndCombined[1] &&
;;;160            pConstBoundaryFilteredAndCombined[0] >= pConstBoundaryFilteredAndCombined[boundary.get_size()-1]) {
;;;161              localMaxima.PushBack(0);
;;;162          }
;;;163    
;;;164          for(s32 i=1; i<(lengthBoundary-1); i++) {
;;;165            if(pConstBoundaryFilteredAndCombined[i] > pConstBoundaryFilteredAndCombined[i+1] &&
;;;166              pConstBoundaryFilteredAndCombined[i] >= pConstBoundaryFilteredAndCombined[i-1]) {
;;;167                localMaxima.PushBack(i);
;;;168            }
;;;169          }
;;;170    
;;;171          if(pConstBoundaryFilteredAndCombined[boundary.get_size()-1] > pConstBoundaryFilteredAndCombined[0] &&
;;;172            pConstBoundaryFilteredAndCombined[boundary.get_size()-1] >= pConstBoundaryFilteredAndCombined[boundary.get_size()-2]) {
;;;173              localMaxima.PushBack(boundary.get_size()-1);
;;;174          }
;;;175    
;;;176          //boundaryFilteredAndCombined.Print("boundaryFilteredAndCombined");
;;;177          //for(s32 i=0; i<boundaryFilteredAndCombined.get_size(1); i++) {
;;;178          //  CoreTechPrint("%d\n", boundaryFilteredAndCombined[0][i]);
;;;179          //}
;;;180    
;;;181          //localMaxima.Print("localMaxima");
;;;182    
;;;183          //EndBenchmark("elp_part4");
;;;184    
;;;185          //BeginBenchmark("elp_part5");
;;;186    
;;;187          const Point<s16> * restrict pConstBoundary = boundary.Pointer(0);
;;;188    
;;;189          //localMaxima.Print("localMaxima");
;;;190    
;;;191          // Select the index of the top 4 local maxima
;;;192          // TODO: make efficient
;;;193          // TODO: make work for numbers of peaks other than 4
;;;194          s32 * restrict pLocalMaxima = localMaxima.Pointer(0);
;;;195          s32 maximaValues[4];
;;;196          s32 maximaIndexes[4];
;;;197          for(s32 i=0; i<4; i++) {
;;;198            maximaValues[i] = s32_MIN;
;;;199            maximaIndexes[i] = -1;
;;;200          }
;;;201    
;;;202          const s32 numLocalMaxima = localMaxima.get_size();
;;;203          for(s32 iMax=0; iMax<4; iMax++) {
;;;204            for(s32 i=0; i<numLocalMaxima; i++) {
;;;205              const s32 localMaximaIndex = pLocalMaxima[i];
;;;206              if(pConstBoundaryFilteredAndCombined[localMaximaIndex] > maximaValues[iMax]) {
;;;207                maximaValues[iMax] = pConstBoundaryFilteredAndCombined[localMaximaIndex];
;;;208                maximaIndexes[iMax] = localMaximaIndex;
;;;209              }
;;;210            }
;;;211            //CoreTechPrint("Maxima %d/%d is #%d %d\n", iMax, 4, maximaIndexes[iMax], maximaValues[iMax]);
;;;212            pBoundaryFilteredAndCombined[maximaIndexes[iMax]] = s32_MIN;
;;;213          }
;;;214    
;;;215          // Copy the maxima to the output peaks, ordered by their original index order, so they are
;;;216          // still in clockwise or counterclockwise order
;;;217          peaks.Clear();
;;;218    
;;;219          bool whichUsed[4];
;;;220          for(s32 i=0; i<4; i++) {
;;;221            whichUsed[i] = false;
;;;222          }
;;;223    
;;;224          for(s32 iMax=0; iMax<4; iMax++) {
;;;225            s32 curMinIndex = -1;
;;;226            for(s32 i=0; i<4; i++) {
;;;227              if(!whichUsed[i] && maximaIndexes[i] >= 0) {
;;;228                if(curMinIndex == -1 || maximaIndexes[curMinIndex] > maximaIndexes[i]) {
;;;229                  curMinIndex = i;
;;;230                }
;;;231              }
;;;232            }
;;;233    
;;;234            //if(maximaIndexes[iMax] >= 0) {
;;;235            if(curMinIndex >= 0) {
;;;236              whichUsed[curMinIndex] = true;
;;;237              peaks.PushBack(pConstBoundary[maximaIndexes[curMinIndex]]);
;;;238            }
;;;239          }
;;;240    
;;;241          //EndBenchmark("elp_part5");
;;;242    
;;;243          //boundary.Print();
;;;244          //peaks.Print();
;;;245    
;;;246          return RESULT_OK;
;;;247        } // Result ExtractLaplacianPeaks(const FixedLengthList<Point<s16> > &boundary, MemoryStack scratch)
000080  b05b              ADD      sp,sp,#0x16c
000082  ecbd8b04          VPOP     {d8-d9}
000086  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.138|
00008a  2019              MOVS     r0,#0x19              ;25
00008c  e9cd4000          STRD     r4,r0,[sp,#0]         ;25
000090  a3dc              ADR      r3,|L1.1028|
000092  a2fd              ADR      r2,|L1.1160|
000094  a1f0              ADR      r1,|L1.1112|
000096  2005              MOVS     r0,#5                 ;25
000098  f7fffffe          BL       _Anki_Log
00009c  f04f6080          MOV      r0,#0x4000000         ;25
0000a0  e7ee              B        |L1.128|
                  |L1.162|
0000a2  201c              MOVS     r0,#0x1c              ;28
0000a4  e9cd4000          STRD     r4,r0,[sp,#0]         ;28
0000a8  a3d6              ADR      r3,|L1.1028|
0000aa  a2fd              ADR      r2,|L1.1184|
0000ac  a1ea              ADR      r1,|L1.1112|
0000ae  2005              MOVS     r0,#5                 ;28
0000b0  f7fffffe          BL       _Anki_Log
0000b4  f04f6080          MOV      r0,#0x4000000         ;28
0000b8  e7e2              B        |L1.128|
                  |L1.186|
0000ba  201f              MOVS     r0,#0x1f              ;31
0000bc  e9cd4000          STRD     r4,r0,[sp,#0]         ;31
0000c0  a3d0              ADR      r3,|L1.1028|
0000c2  a2fc              ADR      r2,|L1.1204|
0000c4  a1e4              ADR      r1,|L1.1112|
0000c6  2005              MOVS     r0,#5                 ;31
0000c8  f7fffffe          BL       _Anki_Log
0000cc  f04f6080          MOV      r0,#0x4000000         ;31
0000d0  e7d6              B        |L1.128|
                  |L1.210|
0000d2  68f8              LDR      r0,[r7,#0xc]          ;37
0000d4  49fd              LDR      r1,|L1.1228|
0000d6  0084              LSLS     r4,r0,#2              ;46
0000d8  fb812100          SMULL    r2,r1,r1,r0           ;37
0000dc  eba171e1          SUB      r1,r1,r1,ASR #31      ;37
0000e0  9151              STR      r1,[sp,#0x144]        ;50
0000e2  2103              MOVS     r1,#3                 ;50
0000e4  ebb11f20          CMP      r1,r0,ASR #4          ;50
0000e8  bfcc              ITE      GT                    ;50
0000ea  f04f0903          MOVGT    r9,#3                 ;50
0000ee  ea4f1920          ASRLE    r9,r0,#4              ;50
0000f2  ea4f0049          LSL      r0,r9,#1              ;53
0000f6  2300              MOVS     r3,#0                 ;54
0000f8  1e45              SUBS     r5,r0,#1              ;53
0000fa  461a              MOV      r2,r3                 ;54
0000fc  4619              MOV      r1,r3                 ;54
0000fe  a82f              ADD      r0,sp,#0xbc           ;54
000100  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000104  6800              LDR      r0,[r0,#0]            ;54
000106  2300              MOVS     r3,#0                 ;54
000108  e9cd8000          STRD     r8,r0,[sp,#0]         ;54
00010c  462a              MOV      r2,r5                 ;54
00010e  2101              MOVS     r1,#1                 ;54
000110  a810              ADD      r0,sp,#0x40           ;54
000112  f7fffffe          BL       _ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedPointArray<short>::FixedPointArray(int, int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000116  ad10              ADD      r5,sp,#0x40           ;55
000118  4628              MOV      r0,r5                 ;55
00011a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
00011e  2800              CMP      r0,#0                 ;55
000120  f00082ba          BEQ.W    |L1.1688|
000124  2100              MOVS     r1,#0                 ;55
000126  4628              MOV      r0,r5                 ;55
000128  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
00012c  9912              LDR      r1,[sp,#0x48]         ;55
00012e  9b12              LDR      r3,[sp,#0x48]         ;55
000130  4341              MULS     r1,r0,r1              ;55
000132  9a14              LDR      r2,[sp,#0x50]         ;55
000134  2000              MOVS     r0,#0                 ;55
000136  fb002003          MLA      r0,r0,r3,r2           ;55
00013a  f7fffffe          BL       __aeabi_memclr
                  |L1.318|
00013e  9a12              LDR      r2,[sp,#0x48]         ;55
000140  9914              LDR      r1,[sp,#0x50]         ;55
000142  2000              MOVS     r0,#0                 ;56
000144  fb001002          MLA      r0,r0,r2,r1           ;56
000148  2501              MOVS     r5,#1                 ;56
00014a  8005              STRH     r5,[r0,#0]            ;56
00014c  9b12              LDR      r3,[sp,#0x48]         ;56
00014e  9a14              LDR      r2,[sp,#0x50]         ;56
000150  2000              MOVS     r0,#0                 ;57
000152  f1a90101          SUB      r1,r9,#1              ;57
000156  fb002003          MLA      r0,r0,r3,r2           ;57
00015a  eb000041          ADD      r0,r0,r1,LSL #1       ;57
00015e  1ee9              SUBS     r1,r5,#3              ;57
000160  8001              STRH     r1,[r0,#0]            ;57
000162  f04f0900          MOV      r9,#0                 ;58
000166  4629              MOV      r1,r5                 ;58
000168  a810              ADD      r0,sp,#0x40           ;58
00016a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
00016e  9a12              LDR      r2,[sp,#0x48]         ;58
000170  9914              LDR      r1,[sp,#0x50]         ;58
000172  1e40              SUBS     r0,r0,#1              ;58
000174  fb091102          MLA      r1,r9,r2,r1           ;58
000178  2300              MOVS     r3,#0                 ;58
00017a  f8215010          STRH     r5,[r1,r0,LSL #1]     ;58
00017e  a830              ADD      r0,sp,#0xc0           ;61
000180  900f              STR      r0,[sp,#0x3c]         ;61
000182  eb040044          ADD      r0,r4,r4,LSL #1       ;61
000186  1200              ASRS     r0,r0,#8              ;61
000188  f1000901          ADD      r9,r0,#1              ;61
00018c  ee009a10          VMOV     s0,r9                 ;61
000190  f04f0b08          MOV      r11,#8                ;61
000194  461a              MOV      r2,r3                 ;61
000196  eeb88ac0          VCVT.F32.S32 s16,s0                ;61
00019a  4619              MOV      r1,r3                 ;61
00019c  a84f              ADD      r0,sp,#0x13c          ;61
00019e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001a2  6800              LDR      r0,[r0,#0]            ;61
0001a4  eb050549          ADD      r5,r5,r9,LSL #1       ;61
0001a8  e9cd8000          STRD     r8,r0,[sp,#0]         ;61
0001ac  465b              MOV      r3,r11                ;61
0001ae  462a              MOV      r2,r5                 ;61
0001b0  2101              MOVS     r1,#1                 ;61
0001b2  a822              ADD      r0,sp,#0x88           ;61
0001b4  f7fffffe          BL       _ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedPointArray<short>::FixedPointArray(int, int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0001b8  9a24              LDR      r2,[sp,#0x90]         ;61
0001ba  9926              LDR      r1,[sp,#0x98]         ;61
0001bc  2000              MOVS     r0,#0                 ;61
0001be  fb001a02          MLA      r10,r0,r2,r1          ;61
0001c2  4641              MOV      r1,r8                 ;61
0001c4  a828              ADD      r0,sp,#0xa0           ;61
0001c6  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0001ca  a928              ADD      r1,sp,#0xa0           ;61
0001cc  a83c              ADD      r0,sp,#0xf0           ;61
0001ce  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0001d2  2300              MOVS     r3,#0                 ;61
0001d4  461a              MOV      r2,r3                 ;61
0001d6  2101              MOVS     r1,#1                 ;61
0001d8  a801              ADD      r0,sp,#4              ;61
0001da  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001de  6800              LDR      r0,[r0,#0]            ;61
0001e0  9000              STR      r0,[sp,#0]            ;61
0001e2  ab3c              ADD      r3,sp,#0xf0           ;61
0001e4  462a              MOV      r2,r5                 ;61
0001e6  2101              MOVS     r1,#1                 ;61
0001e8  a84a              ADD      r0,sp,#0x128          ;61
0001ea  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0001ee  9a4c              LDR      r2,[sp,#0x130]        ;61
0001f0  994e              LDR      r1,[sp,#0x138]        ;61
0001f2  2000              MOVS     r0,#0                 ;61
0001f4  fb001902          MLA      r9,r0,r2,r1           ;61
0001f8  eef30a00          VMOV.F32 s1,#16.00000000       ;61
0001fc  eeb00a00          VMOV.F32 s0,#2.00000000        ;61
000200  f7fffffe          BL       __hardfp_powf
000204  0060              LSLS     r0,r4,#1              ;61
000206  4360              MULS     r0,r4,r0              ;61
000208  ee000a90          VMOV     s1,r0                 ;61
00020c  2400              MOVS     r4,#0                 ;61
00020e  eef80ae0          VCVT.F32.S32 s1,s1                 ;61
000212  eec09a80          VDIV.F32 s19,s1,s0             ;61
000216  eddf8aae          VLDR     s17,|L1.1232|
00021a  eeb18a48          VNEG.F32 s16,s16               ;61
00021e  eeb79a00          VMOV.F32 s18,#1.00000000       ;61
000222  2d00              CMP      r5,#0                 ;61
000224  dd10              BLE      |L1.584|
                  |L1.550|
000226  ee680a48          VNMUL.F32 s1,s16,s16            ;61
00022a  ee800aa9          VDIV.F32 s0,s1,s19             ;61
00022e  f7fffffe          BL       __hardfp_expf
000232  eb090084          ADD      r0,r9,r4,LSL #2       ;61
000236  ee788a80          VADD.F32 s17,s17,s0            ;61
00023a  ee388a09          VADD.F32 s16,s16,s18           ;61
00023e  1c64              ADDS     r4,r4,#1              ;61
000240  ed800a00          VSTR     s0,[r0,#0]            ;61
000244  42a5              CMP      r5,r4                 ;61
000246  dcee              BGT      |L1.550|
                  |L1.584|
000248  ee898a28          VDIV.F32 s16,s18,s17           ;61
00024c  ee00ba10          VMOV     s0,r11                ;61
000250  eef80ac0          VCVT.F32.S32 s1,s0                 ;61
000254  eeb00a00          VMOV.F32 s0,#2.00000000        ;61
000258  f7fffffe          BL       __hardfp_powf
00025c  2000              MOVS     r0,#0                 ;61
00025e  2d00              CMP      r5,#0                 ;61
000260  dd37              BLE      |L1.722|
000262  4a9c              LDR      r2,|L1.1236|
000264  eddf2a9c          VLDR     s5,|L1.1240|
000268  ed9f2a9c          VLDR     s4,|L1.1244|
00026c  eef61a00          VMOV.F32 s3,#0.50000000        ;61
                  |L1.624|
000270  eb090180          ADD      r1,r9,r0,LSL #2       ;61
000274  edd10a00          VLDR     s1,[r1,#0]            ;61
000278  ee600a88          VMUL.F32 s1,s1,s16             ;61
00027c  ee600a80          VMUL.F32 s1,s1,s0              ;61
000280  ee101a90          VMOV     r1,s1                 ;61
000284  f1b14f47          CMP      r1,#0xc7000000        ;61
000288  bf8c              ITE      HI                    ;61
00028a  eeb01a42          VMOVHI.F32 s2,s4                 ;61
00028e  eeb01a60          VMOVLS.F32 s2,s1                 ;61
000292  ee111a10          VMOV     r1,s2                 ;61
000296  4291              CMP      r1,r2                 ;61
000298  bfc8              IT       GT                    ;61
00029a  eef00a62          VMOVGT.F32 s1,s5                 ;61
00029e  dc06              BGT      |L1.686|
0002a0  ee101a90          VMOV     r1,s1                 ;61
0002a4  f1b14f47          CMP      r1,#0xc7000000        ;61
0002a8  bf88              IT       HI                    ;61
0002aa  eef00a42          VMOVHI.F32 s1,s4                 ;61
                  |L1.686|
0002ae  eef50ac0          VCMPE.F32 s1,#0.0               ;61
0002b2  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;61
0002b6  bfcc              ITE      GT                    ;61
0002b8  ee700aa1          VADDGT.F32 s1,s1,s3              ;61
0002bc  ee700ae1          VSUBLE.F32 s1,s1,s3              ;61
0002c0  eefd0ae0          VCVT.S32.F32 s1,s1                 ;61
0002c4  ee101a90          VMOV     r1,s1                 ;61
0002c8  f82a1010          STRH     r1,[r10,r0,LSL #1]    ;61
0002cc  1c40              ADDS     r0,r0,#1              ;61
0002ce  4285              CMP      r5,r0                 ;61
0002d0  dcce              BGT      |L1.624|
                  |L1.722|
0002d2  f10d0988          ADD      r9,sp,#0x88           ;61
0002d6  980f              LDR      r0,[sp,#0x3c]         ;61
0002d8  e8b9100e          LDM      r9!,{r1-r3,r12}       ;61
0002dc  e9dd4526          LDRD     r4,r5,[sp,#0x98]      ;61
0002e0  e880100e          STM      r0,{r1-r3,r12}        ;61
0002e4  2300              MOVS     r3,#0                 ;62
0002e6  e9c04504          STRD     r4,r5,[r0,#0x10]      ;62
0002ea  461a              MOV      r2,r3                 ;62
0002ec  4619              MOV      r1,r3                 ;62
0002ee  a82f              ADD      r0,sp,#0xbc           ;62
0002f0  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0002f4  4604              MOV      r4,r0                 ;62
0002f6  2101              MOVS     r1,#1                 ;62
0002f8  a830              ADD      r0,sp,#0xc0           ;62
0002fa  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
0002fe  4605              MOV      r5,r0                 ;62
000300  2101              MOVS     r1,#1                 ;62
000302  a810              ADD      r0,sp,#0x40           ;62
000304  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
000308  4428              ADD      r0,r0,r5              ;62
00030a  1e42              SUBS     r2,r0,#1              ;62
00030c  6820              LDR      r0,[r4,#0]            ;62
00030e  2308              MOVS     r3,#8                 ;62
000310  e9cd8000          STRD     r8,r0,[sp,#0]         ;62
000314  2101              MOVS     r1,#1                 ;62
000316  a816              ADD      r0,sp,#0x58           ;62
000318  f7fffffe          BL       _ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedPointArray<short>::FixedPointArray(int, int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00031c  aa16              ADD      r2,sp,#0x58           ;64
00031e  a930              ADD      r1,sp,#0xc0           ;64
000320  a810              ADD      r0,sp,#0x40           ;64
000322  f7fffffe          BL       _ZN4Anki8Embedded15ImageProcessing11Correlate1dIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EE ; Anki::Embedded::ImageProcessing::Correlate1d<short, int, short>(const Anki::Embedded::FixedPointArray<T1>&, const Anki::Embedded::FixedPointArray<T1>&, Anki::Embedded::FixedPointArray<T3>&)
000326  2800              CMP      r0,#0                 ;64
000328  f47faeaa          BNE      |L1.128|
00032c  2300              MOVS     r3,#0                 ;67
00032e  461a              MOV      r2,r3                 ;67
000330  4619              MOV      r1,r3                 ;67
000332  a82f              ADD      r0,sp,#0xbc           ;67
000334  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000338  6800              LDR      r0,[r0,#0]            ;67
00033a  68fa              LDR      r2,[r7,#0xc]          ;67
00033c  e9cd8000          STRD     r8,r0,[sp,#0]         ;67
000340  2308              MOVS     r3,#8                 ;67
000342  2101              MOVS     r1,#1                 ;67
000344  a836              ADD      r0,sp,#0xd8           ;67
000346  f7fffffe          BL       _ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedPointArray<short>::FixedPointArray(int, int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00034a  2300              MOVS     r3,#0                 ;68
00034c  461a              MOV      r2,r3                 ;68
00034e  4619              MOV      r1,r3                 ;68
000350  a843              ADD      r0,sp,#0x10c          ;68
000352  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000356  6800              LDR      r0,[r0,#0]            ;68
000358  68fa              LDR      r2,[r7,#0xc]          ;68
00035a  e9cd8000          STRD     r8,r0,[sp,#0]         ;68
00035e  2308              MOVS     r3,#8                 ;68
000360  2101              MOVS     r1,#1                 ;68
000362  a81c              ADD      r0,sp,#0x70           ;68
000364  f7fffffe          BL       _ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedPointArray<short>::FixedPointArray(int, int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000368  a81c              ADD      r0,sp,#0x70           ;70
00036a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
00036e  2800              CMP      r0,#0                 ;70
000370  f000819e          BEQ.W    |L1.1712|
000374  4641              MOV      r1,r8                 ;82
000376  a83c              ADD      r0,sp,#0xf0           ;82
000378  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00037c  a93c              ADD      r1,sp,#0xf0           ;82
00037e  a828              ADD      r0,sp,#0xa0           ;82
000380  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000384  2300              MOVS     r3,#0                 ;83
000386  461a              MOV      r2,r3                 ;83
000388  4619              MOV      r1,r3                 ;83
00038a  a80f              ADD      r0,sp,#0x3c           ;83
00038c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000390  68fa              LDR      r2,[r7,#0xc]          ;83
000392  6800              LDR      r0,[r0,#0]            ;83
000394  9001              STR      r0,[sp,#4]            ;83
000396  a828              ADD      r0,sp,#0xa0           ;83
000398  9000              STR      r0,[sp,#0]            ;83
00039a  2300              MOVS     r3,#0                 ;83
00039c  2101              MOVS     r1,#1                 ;83
00039e  a822              ADD      r0,sp,#0x88           ;83
0003a0  f7fffffe          BL       _ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedPointArray<short>::FixedPointArray(int, int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0003a4  a822              ADD      r0,sp,#0x88           ;85
0003a6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
0003aa  2800              CMP      r0,#0                 ;85
0003ac  f0008180          BEQ.W    |L1.1712|
0003b0  9b24              LDR      r3,[sp,#0x90]         ;85
0003b2  9926              LDR      r1,[sp,#0x98]         ;85
0003b4  2000              MOVS     r0,#0                 ;89
0003b6  fb001303          MLA      r3,r0,r3,r1           ;89
0003ba  68f9              LDR      r1,[r7,#0xc]          ;92
0003bc  6b3a              LDR      r2,[r7,#0x30]         ;92
0003be  2900              CMP      r1,#0                 ;92
0003c0  dd06              BLE      |L1.976|
                  |L1.962|
0003c2  f832c020          LDRH     r12,[r2,r0,LSL #2]    ;93
0003c6  f823c010          STRH     r12,[r3,r0,LSL #1]    ;93
0003ca  1c40              ADDS     r0,r0,#1              ;92
0003cc  4281              CMP      r1,r0                 ;92
0003ce  dcf8              BGT      |L1.962|
                  |L1.976|
0003d0  a928              ADD      r1,sp,#0xa0           ;96
0003d2  a84a              ADD      r0,sp,#0x128          ;96
0003d4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0003d8  4603              MOV      r3,r0                 ;96
0003da  aa36              ADD      r2,sp,#0xd8           ;96
0003dc  a916              ADD      r1,sp,#0x58           ;96
0003de  a822              ADD      r0,sp,#0x88           ;96
0003e0  f7fffffe          BL       _ZN4Anki8Embedded15ImageProcessing36Correlate1dCircularAndSameSizeOutputIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EENS0_11MemoryStackE ; Anki::Embedded::ImageProcessing::Correlate1dCircularAndSameSizeOutput<short, int, short>(const Anki::Embedded::FixedPointArray<T1>&, const Anki::Embedded::FixedPointArray<T1>&, Anki::Embedded::FixedPointArray<T3>&, Anki::Embedded::MemoryStack)
0003e4  2800              CMP      r0,#0                 ;96
0003e6  f47fae4b          BNE      |L1.128|
0003ea  4641              MOV      r1,r8                 ;104
0003ec  a83c              ADD      r0,sp,#0xf0           ;104
0003ee  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0003f2  a93c              ADD      r1,sp,#0xf0           ;104
0003f4  a828              ADD      r0,sp,#0xa0           ;104
0003f6  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0003fa  2300              MOVS     r3,#0                 ;105
0003fc  461a              MOV      r2,r3                 ;105
0003fe  e06f              B        |L1.1248|
                  |L1.1024|
                          DCD      ||.constdata||
                  |L1.1028|
000404  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\laplacianPeaks.cpp",0
000408  6f726574
00040c  6563685c
000410  76697369
000414  6f6e5c72
000418  6f626f74
00041c  5c737263
000420  5c6c6170
000424  6c616369
000428  616e5065
00042c  616b732e
000430  63707000
                  |L1.1076|
000434  43757272          DCB      "Currently only four peaks supported",0
000438  656e746c
00043c  79206f6e
000440  6c792066
000444  6f757220
000448  7065616b
00044c  73207375
000450  70706f72
000454  74656400
                  |L1.1112|
000458  436f6d70          DCB      "ComputeQuadrilateralsFromConnectedComponents",0
00045c  75746551
000460  75616472
000464  696c6174
000468  6572616c
00046c  7346726f
000470  6d436f6e
000474  6e656374
000478  6564436f
00047c  6d706f6e
000480  656e7473
000484  00      
000485  00                DCB      0
000486  00                DCB      0
000487  00                DCB      0
                  |L1.1160|
000488  626f756e          DCB      "boundary is not valid",0
00048c  64617279
000490  20697320
000494  6e6f7420
000498  76616c69
00049c  6400    
00049e  00                DCB      0
00049f  00                DCB      0
                  |L1.1184|
0004a0  7065616b          DCB      "peaks is not valid",0
0004a4  73206973
0004a8  206e6f74
0004ac  2076616c
0004b0  696400  
0004b3  00                DCB      0
                  |L1.1204|
0004b4  73637261          DCB      "scratch is not valid",0
0004b8  74636820
0004bc  6973206e
0004c0  6f742076
0004c4  616c6964
0004c8  00      
0004c9  00                DCB      0
0004ca  00                DCB      0
0004cb  00                DCB      0
                  |L1.1228|
                          DCD      0x55555556
                  |L1.1232|
0004d0  00000000          DCFS     0x00000000 ; 0
                  |L1.1236|
                          DCD      0x46fffe00
                  |L1.1240|
0004d8  46fffe00          DCFS     0x46fffe00 ; 32767
                  |L1.1244|
0004dc  c7000000          DCFS     0xc7000000 ; -32768
                  |L1.1248|
0004e0  2101              MOVS     r1,#1                 ;105
0004e2  a80f              ADD      r0,sp,#0x3c           ;105
0004e4  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0004e8  68fa              LDR      r2,[r7,#0xc]          ;105
0004ea  6800              LDR      r0,[r0,#0]            ;105
0004ec  9001              STR      r0,[sp,#4]            ;105
0004ee  a828              ADD      r0,sp,#0xa0           ;105
0004f0  9000              STR      r0,[sp,#0]            ;105
0004f2  2300              MOVS     r3,#0                 ;105
0004f4  2101              MOVS     r1,#1                 ;105
0004f6  a822              ADD      r0,sp,#0x88           ;105
0004f8  f7fffffe          BL       _ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedPointArray<short>::FixedPointArray(int, int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0004fc  a822              ADD      r0,sp,#0x88           ;107
0004fe  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
000502  2800              CMP      r0,#0                 ;107
000504  f00080d4          BEQ.W    |L1.1712|
000508  9b24              LDR      r3,[sp,#0x90]         ;107
00050a  9926              LDR      r1,[sp,#0x98]         ;107
00050c  2000              MOVS     r0,#0                 ;111
00050e  fb001303          MLA      r3,r0,r3,r1           ;111
000512  68f9              LDR      r1,[r7,#0xc]          ;114
000514  6b3a              LDR      r2,[r7,#0x30]         ;114
000516  2900              CMP      r1,#0                 ;114
000518  dd08              BLE      |L1.1324|
                  |L1.1306|
00051a  eb020c80          ADD      r12,r2,r0,LSL #2      ;115
00051e  f8bcc002          LDRH     r12,[r12,#2]          ;115
000522  f823c010          STRH     r12,[r3,r0,LSL #1]    ;115
000526  1c40              ADDS     r0,r0,#1              ;114
000528  4281              CMP      r1,r0                 ;114
00052a  dcf6              BGT      |L1.1306|
                  |L1.1324|
00052c  a928              ADD      r1,sp,#0xa0           ;118
00052e  a84a              ADD      r0,sp,#0x128          ;118
000530  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000534  4603              MOV      r3,r0                 ;118
000536  aa1c              ADD      r2,sp,#0x70           ;118
000538  a916              ADD      r1,sp,#0x58           ;118
00053a  a822              ADD      r0,sp,#0x88           ;118
00053c  f7fffffe          BL       _ZN4Anki8Embedded15ImageProcessing36Correlate1dCircularAndSameSizeOutputIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EENS0_11MemoryStackE ; Anki::Embedded::ImageProcessing::Correlate1dCircularAndSameSizeOutput<short, int, short>(const Anki::Embedded::FixedPointArray<T1>&, const Anki::Embedded::FixedPointArray<T1>&, Anki::Embedded::FixedPointArray<T3>&, Anki::Embedded::MemoryStack)
000540  2800              CMP      r0,#0                 ;118
000542  f47fad9d          BNE      |L1.128|
000546  2300              MOVS     r3,#0                 ;130
000548  f50d7a88          ADD      r10,sp,#0x110         ;130
00054c  f04f0901          MOV      r9,#1                 ;130
000550  2410              MOVS     r4,#0x10              ;130
000552  461a              MOV      r2,r3                 ;130
000554  4619              MOV      r1,r3                 ;130
000556  a843              ADD      r0,sp,#0x10c          ;130
000558  68fd              LDR      r5,[r7,#0xc]          ;130
00055a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00055e  6800              LDR      r0,[r0,#0]            ;130
000560  9000              STR      r0,[sp,#0]            ;130
000562  4643              MOV      r3,r8                 ;130
000564  462a              MOV      r2,r5                 ;130
000566  4649              MOV      r1,r9                 ;130
000568  4650              MOV      r0,r10                ;130
00056a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00056e  6144              STR      r4,[r0,#0x14]         ;131
000570  2000              MOVS     r0,#0                 ;131
000572  9a46              LDR      r2,[sp,#0x118]        ;131
000574  9948              LDR      r1,[sp,#0x120]        ;131
000576  f8d7900c          LDR      r9,[r7,#0xc]          ;137
00057a  fb001502          MLA      r5,r0,r2,r1           ;137
00057e  9a38              LDR      r2,[sp,#0xe0]         ;137
000580  993a              LDR      r1,[sp,#0xe8]         ;137
000582  f1b90f00          CMP      r9,#0                 ;137
000586  fb001c02          MLA      r12,r0,r2,r1          ;137
00058a  9a1e              LDR      r2,[sp,#0x78]         ;137
00058c  9920              LDR      r1,[sp,#0x80]         ;137
00058e  fb001302          MLA      r3,r0,r2,r1           ;137
000592  dd0d              BLE      |L1.1456|
                  |L1.1428|
000594  f83c1010          LDRH     r1,[r12,r0,LSL #1]    ;140
000598  fb11f201          SMULBB   r2,r1,r1              ;140
00059c  f8331010          LDRH     r1,[r3,r0,LSL #1]     ;141
0005a0  fb11f101          SMULBB   r1,r1,r1              ;141
0005a4  4411              ADD      r1,r1,r2              ;143
0005a6  f8451020          STR      r1,[r5,r0,LSL #2]     ;143
0005aa  1c40              ADDS     r0,r0,#1              ;137
0005ac  4581              CMP      r9,r0                 ;137
0005ae  dcf1              BGT      |L1.1428|
                  |L1.1456|
0005b0  a802              ADD      r0,sp,#8              ;146
0005b2  9001              STR      r0,[sp,#4]            ;146
0005b4  9851              LDR      r0,[sp,#0x144]        ;146
0005b6  2300              MOVS     r3,#0                 ;146
0005b8  900f              STR      r0,[sp,#0x3c]         ;146
0005ba  461a              MOV      r2,r3                 ;146
0005bc  4619              MOV      r1,r3                 ;146
0005be  a843              ADD      r0,sp,#0x10c          ;146
0005c0  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0005c4  6800              LDR      r0,[r0,#0]            ;146
0005c6  902d              STR      r0,[sp,#0xb4]         ;146
0005c8  9000              STR      r0,[sp,#0]            ;146
0005ca  4643              MOV      r3,r8                 ;146
0005cc  2101              MOVS     r1,#1                 ;146
0005ce  a828              ADD      r0,sp,#0xa0           ;146
0005d0  9a0f              LDR      r2,[sp,#0x3c]         ;146
0005d2  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0005d6  e9d0a102          LDRD     r10,r1,[r0,#8]        ;146
0005da  e9d04800          LDRD     r4,r8,[r0,#0]         ;146
0005de  f8d0b010          LDR      r11,[r0,#0x10]        ;146
0005e2  2000              MOVS     r0,#0                 ;146
0005e4  4602              MOV      r2,r0                 ;146
0005e6  9026              STR      r0,[sp,#0x98]         ;146
0005e8  2001              MOVS     r0,#1                 ;146
0005ea  9100              STR      r1,[sp,#0]            ;146
0005ec  9027              STR      r0,[sp,#0x9c]         ;146
0005ee  2101              MOVS     r1,#1                 ;146
0005f0  9826              LDR      r0,[sp,#0x98]         ;146
0005f2  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
0005f6  9025              STR      r0,[sp,#0x94]         ;146
0005f8  2000              MOVS     r0,#0                 ;146
0005fa  4602              MOV      r2,r0                 ;146
0005fc  9023              STR      r0,[sp,#0x8c]         ;146
0005fe  2001              MOVS     r0,#1                 ;146
000600  9024              STR      r0,[sp,#0x90]         ;146
000602  2101              MOVS     r1,#1                 ;146
000604  9823              LDR      r0,[sp,#0x8c]         ;146
000606  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
00060a  9022              STR      r0,[sp,#0x88]         ;146
00060c  e9dd0125          LDRD     r0,r1,[sp,#0x94]      ;146
000610  9a27              LDR      r2,[sp,#0x9c]         ;146
000612  9204              STR      r2,[sp,#0x10]         ;146
000614  e9cd0102          STRD     r0,r1,[sp,#8]         ;146
000618  e9dd0122          LDRD     r0,r1,[sp,#0x88]      ;146
00061c  9a24              LDR      r2,[sp,#0x90]         ;146
00061e  9207              STR      r2,[sp,#0x1c]         ;146
000620  e9cd0105          STRD     r0,r1,[sp,#0x14]      ;146
000624  9900              LDR      r1,[sp,#0]            ;146
000626  e9cd4808          STRD     r4,r8,[sp,#0x20]      ;146
00062a  e9cda10a          STRD     r10,r1,[sp,#0x28]     ;146
00062e  f8cdb030          STR      r11,[sp,#0x30]        ;146
000632  2c00              CMP      r4,#0                 ;146
000634  bfc8              IT       GT                    ;146
000636  f1b80f00          CMPGT    r8,#0                 ;146
00063a  dd3c              BLE      |L1.1718|
00063c  fb04f008          MUL      r0,r4,r8              ;146
000640  2800              CMP      r0,#0                 ;146
000642  bf1c              ITT      NE                    ;146
000644  2000              MOVNE    r0,#0                 ;146
000646  fb00b00a          MLANE    r0,r0,r10,r11         ;146
00064a  d034              BEQ      |L1.1718|
                  |L1.1612|
00064c  900d              STR      r0,[sp,#0x34]         ;146
00064e  2c00              CMP      r4,#0                 ;146
000650  bfc8              IT       GT                    ;146
000652  f1b80f00          CMPGT    r8,#0                 ;146
000656  dd30              BLE      |L1.1722|
000658  fb04f008          MUL      r0,r4,r8              ;146
00065c  2800              CMP      r0,#0                 ;146
00065e  bf1c              ITT      NE                    ;146
000660  2000              MOVNE    r0,#0                 ;146
000662  fb00b00a          MLANE    r0,r0,r10,r11         ;146
000666  d028              BEQ      |L1.1722|
                  |L1.1640|
000668  900e              STR      r0,[sp,#0x38]         ;146
00066a  2c00              CMP      r4,#0                 ;146
00066c  bfc8              IT       GT                    ;146
00066e  f1b80f00          CMPGT    r8,#0                 ;146
000672  dd24              BLE      |L1.1726|
000674  fb04f008          MUL      r0,r4,r8              ;146
000678  2800              CMP      r0,#0                 ;146
00067a  bf1c              ITT      NE                    ;146
00067c  2000              MOVNE    r0,#0                 ;146
00067e  fb00b00a          MLANE    r0,r0,r10,r11         ;146
000682  d01c              BEQ      |L1.1726|
                  |L1.1668|
000684  900e              STR      r0,[sp,#0x38]         ;146
000686  a82d              ADD      r0,sp,#0xb4           ;146
000688  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
00068c  b1c8              CBZ      r0,|L1.1730|
00068e  990f              LDR      r1,[sp,#0x3c]         ;146
000690  9801              LDR      r0,[sp,#4]            ;146
000692  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi ; Anki::Embedded::FixedLengthList<int>::set_size(int)
000696  e018              B        |L1.1738|
                  |L1.1688|
000698  f2402176          MOV      r1,#0x276             ;146
00069c  4869              LDR      r0,|L1.2116|
00069e  e9cd0100          STRD     r0,r1,[sp,#0]         ;146
0006a2  a369              ADR      r3,|L1.2120|
0006a4  a276              ADR      r2,|L1.2176|
0006a6  a17d              ADR      r1,|L1.2204|
0006a8  2005              MOVS     r0,#5                 ;146
0006aa  f7fffffe          BL       _Anki_Log
0006ae  e546              B        |L1.318|
                  |L1.1712|
0006b0  f04f6080          MOV      r0,#0x4000000         ;108
0006b4  e4e4              B        |L1.128|
                  |L1.1718|
0006b6  2000              MOVS     r0,#0                 ;108
0006b8  e7c8              B        |L1.1612|
                  |L1.1722|
0006ba  2000              MOVS     r0,#0                 ;108
0006bc  e7d4              B        |L1.1640|
                  |L1.1726|
0006be  2000              MOVS     r0,#0                 ;108
0006c0  e7e0              B        |L1.1668|
                  |L1.1730|
0006c2  2100              MOVS     r1,#0                 ;108
0006c4  9801              LDR      r0,[sp,#4]            ;108
0006c6  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi ; Anki::Embedded::FixedLengthList<int>::set_size(int)
                  |L1.1738|
0006ca  9a46              LDR      r2,[sp,#0x118]        ;108
0006cc  9948              LDR      r1,[sp,#0x120]        ;108
0006ce  2000              MOVS     r0,#0                 ;148
0006d0  fb001402          MLA      r4,r0,r2,r1           ;148
0006d4  e9d40100          LDRD     r0,r1,[r4,#0]         ;148
0006d8  4288              CMP      r0,r1                 ;159
0006da  dd0c              BLE      |L1.1782|
0006dc  68f9              LDR      r1,[r7,#0xc]          ;160
0006de  eb040181          ADD      r1,r4,r1,LSL #2       ;160
0006e2  f8511c04          LDR      r1,[r1,#-4]           ;160
0006e6  4281              CMP      r1,r0                 ;160
0006e8  dc05              BGT      |L1.1782|
0006ea  2000              MOVS     r0,#0                 ;161
0006ec  9000              STR      r0,[sp,#0]            ;161
0006ee  4669              MOV      r1,sp                 ;161
0006f0  a802              ADD      r0,sp,#8              ;161
0006f2  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiE8PushBackERKi ; Anki::Embedded::FixedLengthList<int>::PushBack(const int&)
                  |L1.1782|
0006f6  2001              MOVS     r0,#1                 ;164
0006f8  f1a90301          SUB      r3,r9,#1              ;164
0006fc  2b01              CMP      r3,#1                 ;164
0006fe  dd17              BLE      |L1.1840|
                  |L1.1792|
000700  eb040280          ADD      r2,r4,r0,LSL #2       ;165
000704  f8541020          LDR      r1,[r4,r0,LSL #2]     ;165
000708  f8d2c004          LDR      r12,[r2,#4]           ;165
00070c  4561              CMP      r1,r12                ;165
00070e  dd0c              BLE      |L1.1834|
000710  f8522c04          LDR      r2,[r2,#-4]           ;166
000714  428a              CMP      r2,r1                 ;166
000716  dc08              BGT      |L1.1834|
000718  9a09              LDR      r2,[sp,#0x24]         ;166
00071a  9905              LDR      r1,[sp,#0x14]         ;166
00071c  4291              CMP      r1,r2                 ;166
00071e  da04              BGE      |L1.1834|
000720  9a0e              LDR      r2,[sp,#0x38]         ;166
000722  f8420021          STR      r0,[r2,r1,LSL #2]     ;166
000726  1c49              ADDS     r1,r1,#1              ;166
000728  9105              STR      r1,[sp,#0x14]         ;166
                  |L1.1834|
00072a  1c40              ADDS     r0,r0,#1              ;164
00072c  4298              CMP      r0,r3                 ;164
00072e  dbe7              BLT      |L1.1792|
                  |L1.1840|
000730  68f8              LDR      r0,[r7,#0xc]          ;171
000732  6823              LDR      r3,[r4,#0]            ;171
000734  eb040180          ADD      r1,r4,r0,LSL #2       ;171
000738  f8512c04          LDR      r2,[r1,#-4]           ;171
00073c  429a              CMP      r2,r3                 ;171
00073e  dd09              BLE      |L1.1876|
000740  f8511c08          LDR      r1,[r1,#-8]           ;172
000744  4291              CMP      r1,r2                 ;172
000746  dc05              BGT      |L1.1876|
000748  1e40              SUBS     r0,r0,#1              ;173
00074a  9000              STR      r0,[sp,#0]            ;173
00074c  4669              MOV      r1,sp                 ;173
00074e  a802              ADD      r0,sp,#8              ;173
000750  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiE8PushBackERKi ; Anki::Embedded::FixedLengthList<int>::PushBack(const int&)
                  |L1.1876|
000754  6b3f              LDR      r7,[r7,#0x30]         ;173
000756  2000              MOVS     r0,#0                 ;197
000758  f8ddb038          LDR      r11,[sp,#0x38]        ;196
00075c  1e41              SUBS     r1,r0,#1              ;199
00075e  f50d7aa4          ADD      r10,sp,#0x148         ;195
000762  f04f4e00          MOV      lr,#0x80000000        ;198
000766  f50d78ac          ADD      r8,sp,#0x158          ;196
                  |L1.1898|
00076a  f84ae020          STR      lr,[r10,r0,LSL #2]    ;198
00076e  f8481020          STR      r1,[r8,r0,LSL #2]     ;199
000772  1c40              ADDS     r0,r0,#1              ;197
000774  2804              CMP      r0,#4                 ;197
000776  dbf8              BLT      |L1.1898|
000778  f8dd9014          LDR      r9,[sp,#0x14]         ;203
00077c  2000              MOVS     r0,#0                 ;203
                  |L1.1918|
00077e  2100              MOVS     r1,#0                 ;204
000780  f1b90f00          CMP      r9,#0                 ;204
000784  dd0e              BLE      |L1.1956|
                  |L1.1926|
000786  f85b2021          LDR      r2,[r11,r1,LSL #2]    ;205
00078a  f85ac020          LDR      r12,[r10,r0,LSL #2]   ;206
00078e  f8543022          LDR      r3,[r4,r2,LSL #2]     ;206
000792  4563              CMP      r3,r12                ;206
000794  bfc4              ITT      GT                    ;207
000796  f84a3020          STRGT    r3,[r10,r0,LSL #2]    ;207
00079a  f8482020          STRGT    r2,[r8,r0,LSL #2]     ;208
00079e  1c49              ADDS     r1,r1,#1              ;204
0007a0  4549              CMP      r1,r9                 ;204
0007a2  dbf0              BLT      |L1.1926|
                  |L1.1956|
0007a4  f8581020          LDR      r1,[r8,r0,LSL #2]     ;212
0007a8  1c40              ADDS     r0,r0,#1              ;203
0007aa  2804              CMP      r0,#4                 ;203
0007ac  f845e021          STR      lr,[r5,r1,LSL #2]     ;212
0007b0  dbe5              BLT      |L1.1918|
0007b2  2400              MOVS     r4,#0                 ;203
0007b4  4630              MOV      r0,r6                 ;203
0007b6  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::get_maximumSize() const
0007ba  4284              CMP      r4,r0                 ;203
0007bc  dd03              BLE      |L1.1990|
0007be  4630              MOV      r0,r6                 ;203
0007c0  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::get_maximumSize() const
0007c4  4604              MOV      r4,r0                 ;203
                  |L1.1990|
0007c6  2000              MOVS     r0,#0                 ;220
0007c8  4601              MOV      r1,r0                 ;220
0007ca  f50d79b4          ADD      r9,sp,#0x168          ;219
0007ce  60f4              STR      r4,[r6,#0xc]          ;219
                  |L1.2000|
0007d0  f8091000          STRB     r1,[r9,r0]            ;221
0007d4  1c40              ADDS     r0,r0,#1              ;220
0007d6  2804              CMP      r0,#4                 ;220
0007d8  dbfa              BLT      |L1.2000|
0007da  2500              MOVS     r5,#0                 ;224
0007dc  f04f0a01          MOV      r10,#1                ;224
                  |L1.2016|
0007e0  f04f31ff          MOV      r1,#0xffffffff        ;225
0007e4  2000              MOVS     r0,#0                 ;226
                  |L1.2022|
0007e6  f8192000          LDRB     r2,[r9,r0]            ;227
0007ea  b952              CBNZ     r2,|L1.2050|
0007ec  f8582020          LDR      r2,[r8,r0,LSL #2]     ;227
0007f0  2a00              CMP      r2,#0                 ;227
0007f2  db06              BLT      |L1.2050|
0007f4  1c4b              ADDS     r3,r1,#1              ;228
0007f6  d003              BEQ      |L1.2048|
0007f8  f8583021          LDR      r3,[r8,r1,LSL #2]     ;228
0007fc  4293              CMP      r3,r2                 ;228
0007fe  dd00              BLE      |L1.2050|
                  |L1.2048|
000800  4601              MOV      r1,r0                 ;229
                  |L1.2050|
000802  1c40              ADDS     r0,r0,#1              ;226
000804  2804              CMP      r0,#4                 ;226
000806  dbee              BLT      |L1.2022|
000808  2900              CMP      r1,#0                 ;235
00080a  db16              BLT      |L1.2106|
00080c  f809a001          STRB     r10,[r9,r1]           ;236
000810  f8580021          LDR      r0,[r8,r1,LSL #2]     ;237
000814  68f4              LDR      r4,[r6,#0xc]          ;237
000816  eb070b80          ADD      r11,r7,r0,LSL #2      ;237
00081a  4630              MOV      r0,r6                 ;237
00081c  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::get_maximumSize() const
000820  42a0              CMP      r0,r4                 ;237
000822  dd0a              BLE      |L1.2106|
000824  6b30              LDR      r0,[r6,#0x30]         ;237
000826  f8bb1000          LDRH     r1,[r11,#0]           ;237
00082a  eb000084          ADD      r0,r0,r4,LSL #2       ;237
00082e  8001              STRH     r1,[r0,#0]            ;237
000830  f8bb1002          LDRH     r1,[r11,#2]           ;237
000834  8041              STRH     r1,[r0,#2]            ;237
000836  1c61              ADDS     r1,r4,#1              ;237
000838  60f1              STR      r1,[r6,#0xc]          ;237
                  |L1.2106|
00083a  1c6d              ADDS     r5,r5,#1              ;224
00083c  2d04              CMP      r5,#4                 ;224
00083e  dbcf              BLT      |L1.2016|
000840  2000              MOVS     r0,#0                 ;246
000842  e41d              B        |L1.128|
;;;248      } // namespace Embedded
                          ENDP

                  |L1.2116|
                          DCD      _ZZN4Anki8Embedded5ArrayIsE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<short>::SetZero()::__PRETTY_FUNCTION__
                  |L1.2120|
000848  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
00084c  6f726574
000850  6563685c
000854  636f6d6d
000858  6f6e5c69
00085c  6e636c75
000860  64655c61
000864  6e6b692f
000868  636f6d6d
00086c  6f6e2f72
000870  6f626f74
000874  2f617272
000878  617932  
00087b  642e6800          DCB      "d.h",0
00087f  00                DCB      0
                  |L1.2176|
000880  41727261          DCB      "Array<Type> is not valid",0
000884  793c5479
000888  70653e20
00088c  6973206e
000890  6f742076
000894  616c6964
000898  00      
000899  00                DCB      0
00089a  00                DCB      0
00089b  00                DCB      0
                  |L1.2204|
00089c  41727261          DCB      "Array<Type>::SetZero",0
0008a0  793c5479
0008a4  70653e3a
0008a8  3a536574
0008ac  5a65726f
0008b0  00      
0008b1  00                DCB      0
0008b2  00                DCB      0
0008b3  00                DCB      0

                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki8Embedded21ExtractLaplacianPeaksERKNS0_15FixedLengthListINS0_5PointIsEEEERS4_NS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded21ExtractLaplacianPeaksERKNS0_15FixedLengthListINS0_5PointIsEEEERS4_NS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  __PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a457874          DCB      0x3a,0x45,0x78,0x74
000020  72616374          DCB      0x72,0x61,0x63,0x74
000024  4c61706c          DCB      0x4c,0x61,0x70,0x6c
000028  61636961          DCB      0x61,0x63,0x69,0x61
00002c  6e506561          DCB      0x6e,0x50,0x65,0x61
000030  6b732863          DCB      0x6b,0x73,0x28,0x63
000034  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000038  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00003c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000040  6d626564          DCB      0x6d,0x62,0x65,0x64
000044  6465643a          DCB      0x64,0x65,0x64,0x3a
000048  3a466978          DCB      0x3a,0x46,0x69,0x78
00004c  65644c65          DCB      0x65,0x64,0x4c,0x65
000050  6e677468          DCB      0x6e,0x67,0x74,0x68
000054  4c697374          DCB      0x4c,0x69,0x73,0x74
000058  3c416e6b          DCB      0x3c,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a506f69          DCB      0x3a,0x50,0x6f,0x69
00006c  6e743c73          DCB      0x6e,0x74,0x3c,0x73
000070  69676e65          DCB      0x69,0x67,0x6e,0x65
000074  64207368          DCB      0x64,0x20,0x73,0x68
000078  6f72743e          DCB      0x6f,0x72,0x74,0x3e
00007c  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000080  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000084  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000088  6d626564          DCB      0x6d,0x62,0x65,0x64
00008c  6465643a          DCB      0x64,0x65,0x64,0x3a
000090  3a466978          DCB      0x3a,0x46,0x69,0x78
000094  65644c65          DCB      0x65,0x64,0x4c,0x65
000098  6e677468          DCB      0x6e,0x67,0x74,0x68
00009c  4c697374          DCB      0x4c,0x69,0x73,0x74
0000a0  3c416e6b          DCB      0x3c,0x41,0x6e,0x6b
0000a4  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000a8  6d626564          DCB      0x6d,0x62,0x65,0x64
0000ac  6465643a          DCB      0x64,0x65,0x64,0x3a
0000b0  3a506f69          DCB      0x3a,0x50,0x6f,0x69
0000b4  6e743c73          DCB      0x6e,0x74,0x3c,0x73
0000b8  69676e65          DCB      0x69,0x67,0x6e,0x65
0000bc  64207368          DCB      0x64,0x20,0x73,0x68
0000c0  6f72743e          DCB      0x6f,0x72,0x74,0x3e
0000c4  3e20262c          DCB      0x3e,0x20,0x26,0x2c
0000c8  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000cc  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000d0  6d626564          DCB      0x6d,0x62,0x65,0x64
0000d4  6465643a          DCB      0x64,0x65,0x64,0x3a
0000d8  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
0000dc  6f727953          DCB      0x6f,0x72,0x79,0x53
0000e0  7461636b          DCB      0x74,0x61,0x63,0x6b
0000e4  29000000          DCB      0x29,0x00,0x00,0x00
0000e8  4c696e65          DCB      0x4c,0x69,0x6e,0x65
0000ec  61725365          DCB      0x61,0x72,0x53,0x65
0000f0  7175656e          DCB      0x71,0x75,0x65,0x6e
0000f4  63653c54          DCB      0x63,0x65,0x3c,0x54
0000f8  7970653e          DCB      0x79,0x70,0x65,0x3e
0000fc  3a3a636f          DCB      0x3a,0x3a,0x63,0x6f
000100  6d707574          DCB      0x6d,0x70,0x75,0x74
000104  6553697a          DCB      0x65,0x53,0x69,0x7a
000108  65000000          DCB      0x65,0x00,0x00,0x00
00010c  73697a65          DCB      0x73,0x69,0x7a,0x65
000110  20657374          DCB      0x20,0x65,0x73,0x74
000114  696d6174          DCB      0x69,0x6d,0x61,0x74
000118  696f6e20          DCB      0x69,0x6f,0x6e,0x20
00011c  6661696c          DCB      0x66,0x61,0x69,0x6c
000120  65640000          DCB      0x65,0x64,0x00,0x00
000124  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000128  6f726574          DCB      0x6f,0x72,0x65,0x74
00012c  6563685c          DCB      0x65,0x63,0x68,0x5c
000130  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000134  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000138  6e636c75          DCB      0x6e,0x63,0x6c,0x75
00013c  64655c61          DCB      0x64,0x65,0x5c,0x61
000140  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000144  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000148  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
00014c  6f626f74          DCB      0x6f,0x62,0x6f,0x74
000150  2f736571          DCB      0x2f,0x73,0x65,0x71
000154  75656e63          DCB      0x75,0x65,0x6e,0x63
000158  65732e68          DCB      0x65,0x73,0x2e,0x68
00015c  00000000          DCB      0x00,0x00,0x00,0x00
000160  41727261          DCB      0x41,0x72,0x72,0x61
000164  793c5479          DCB      0x79,0x3c,0x54,0x79
000168  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00016c  3a436f6d          DCB      0x3a,0x43,0x6f,0x6d
000170  70757465          DCB      0x70,0x75,0x74,0x65
000174  52657175          DCB      0x52,0x65,0x71,0x75
000178  69726564          DCB      0x69,0x72,0x65,0x64
00017c  53747269          DCB      0x53,0x74,0x72,0x69
000180  64650000          DCB      0x64,0x65,0x00,0x00
000184  496e7661          DCB      0x49,0x6e,0x76,0x61
000188  6c696420          DCB      0x6c,0x69,0x64,0x20
00018c  73697a65          DCB      0x73,0x69,0x7a,0x65
000190  00000000          DCB      0x00,0x00,0x00,0x00
000194  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000198  6f726574          DCB      0x6f,0x72,0x65,0x74
00019c  6563685c          DCB      0x65,0x63,0x68,0x5c
0001a0  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
0001a4  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
0001a8  6e636c75          DCB      0x6e,0x63,0x6c,0x75
0001ac  64655c61          DCB      0x64,0x65,0x5c,0x61
0001b0  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
0001b4  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
0001b8  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
0001bc  6f626f74          DCB      0x6f,0x62,0x6f,0x74
0001c0  2f617272          DCB      0x2f,0x61,0x72,0x72
0001c4  61793264          DCB      0x61,0x79,0x32,0x64
0001c8  2e680000          DCB      0x2e,0x68,0x00,0x00
0001cc  41727261          DCB      0x41,0x72,0x72,0x61
0001d0  793c5479          DCB      0x79,0x3c,0x54,0x79
0001d4  70653e3a          DCB      0x70,0x65,0x3e,0x3a
0001d8  3a676574          DCB      0x3a,0x67,0x65,0x74
0001dc  5f73697a          DCB      0x5f,0x73,0x69,0x7a
0001e0  65000000          DCB      0x65,0x00,0x00,0x00
0001e4  4e656761          DCB      0x4e,0x65,0x67,0x61
0001e8  74697665          DCB      0x74,0x69,0x76,0x65
0001ec  2064696d          DCB      0x20,0x64,0x69,0x6d
0001f0  656e7369          DCB      0x65,0x6e,0x73,0x69
0001f4  6f6e0000          DCB      0x6f,0x6e,0x00,0x00
0001f8  46697865          DCB      0x46,0x69,0x78,0x65
0001fc  64506f69          DCB      0x64,0x50,0x6f,0x69
000200  6e744172          DCB      0x6e,0x74,0x41,0x72
000204  7261793c          DCB      0x72,0x61,0x79,0x3c
000208  54797065          DCB      0x54,0x79,0x70,0x65
00020c  3e000000          DCB      0x3e,0x00,0x00,0x00
000210  6e756d46          DCB      0x6e,0x75,0x6d,0x46
000214  72616374          DCB      0x72,0x61,0x63,0x74
000218  696f6e61          DCB      0x69,0x6f,0x6e,0x61
00021c  6c426974          DCB      0x6c,0x42,0x69,0x74
000220  73206e75          DCB      0x73,0x20,0x6e,0x75
000224  6d626572          DCB      0x6d,0x62,0x65,0x72
000228  20697320          DCB      0x20,0x69,0x73,0x20
00022c  696e7661          DCB      0x69,0x6e,0x76,0x61
000230  6c696400          DCB      0x6c,0x69,0x64,0x00

                          AREA ||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIiEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<int>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L14.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L14.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L14.384|
000044  a25c              ADR      r2,|L14.440|
000046  a160              ADR      r1,|L14.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L14.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L14.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L14.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L14.384|
000080  a24d              ADR      r2,|L14.440|
000082  a157              ADR      r1,|L14.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L14.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L14.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L14.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L14.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L14.384|
0000c8  a251              ADR      r2,|L14.528|
0000ca  a156              ADR      r1,|L14.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L14.372|
                  |L14.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L14.384|
0000e0  a258              ADR      r2,|L14.580|
0000e2  a15f              ADR      r1,|L14.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L14.372|
                  |L14.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L14.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L14.384|
000110  a259              ADR      r2,|L14.632|
000112  a144              ADR      r1,|L14.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L14.372|
                  |L14.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L14.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L14.384|
00015a  a251              ADR      r2,|L14.672|
00015c  a140              ADR      r1,|L14.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L14.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L14.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L14.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L14.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L14.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L14.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L14.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L14.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L14.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L14.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L14.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L14.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L14.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L14.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.15||, COMGROUP=_ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_||, COMGROUP=_ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC2ERKNS0_14LinearSequenceIiEES6_bS6_S6_                  ; Alternate entry point ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1__sub_object(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
                  _ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_ PROC ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
;;;284    
;;;285        template<typename Type> ArraySliceLimits_in1_out1<Type>::ArraySliceLimits_in1_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;286          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;287          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;288          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed)
;;;289        {
;;;290          isValid = false;
;;;291    
;;;292          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;293    
;;;294          if(!in1_isTransposed) {
;;;295            if(rawOut1Limits.xSize == rawIn1Limits.xSize && rawOut1Limits.ySize == rawIn1Limits.ySize) {
;;;296              isValid = true;
;;;297              isSimpleIteration = true;
;;;298    
;;;299              this->in1Y = this->rawIn1Limits.yStart;
;;;300              this->out1Y = this->rawOut1Limits.yStart;
;;;301    
;;;302              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;303              this->in1_yInnerIncrement = 0;
;;;304            }
;;;305          } else { // if(!in1_isTransposed)
;;;306            if(rawOut1Limits.xSize == rawIn1Limits.ySize && rawOut1Limits.ySize == rawIn1Limits.xSize) {
;;;307              isValid = true;
;;;308              isSimpleIteration = false;
;;;309    
;;;310              this->in1X = this->rawIn1Limits.xStart;
;;;311              this->out1Y = this->rawOut1Limits.yStart;
;;;312    
;;;313              this->in1_xInnerIncrement = 0;
;;;314              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;315            }
;;;316          } // if(!in1_isTransposed) ... else
;;;317    
;;;318          if(!isValid) {
;;;319            AnkiError("ArraySliceLimits_in1_out1", "Subscripted assignment dimension mismatch");
;;;320            return;
;;;321          }
;;;322        } // ArraySliceLimits_in1_out1
;;;323    
000000  b570              PUSH     {r4-r6,lr}
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  e9dd5c06          LDRD     r5,r12,[sp,#0x18]
00000a  6828              LDR      r0,[r5,#0]
00000c  6160              STR      r0,[r4,#0x14]
00000e  f8dc0000          LDR      r0,[r12,#0]
000012  61a0              STR      r0,[r4,#0x18]
000014  f8dc6004          LDR      r6,[r12,#4]
000018  62a6              STR      r6,[r4,#0x28]
00001a  f8dc6008          LDR      r6,[r12,#8]
00001e  62e6              STR      r6,[r4,#0x2c]
000020  f8dcc000          LDR      r12,[r12,#0]
000024  f8c4c030          STR      r12,[r4,#0x30]
000028  f8d5c004          LDR      r12,[r5,#4]
00002c  f8c4c034          STR      r12,[r4,#0x34]
000030  f8d5c008          LDR      r12,[r5,#8]
000034  f8c4c038          STR      r12,[r4,#0x38]
000038  f8d5c000          LDR      r12,[r5,#0]
00003c  f8c4c03c          STR      r12,[r4,#0x3c]
000040  6855              LDR      r5,[r2,#4]
000042  6425              STR      r5,[r4,#0x40]
000044  6895              LDR      r5,[r2,#8]
000046  6465              STR      r5,[r4,#0x44]
000048  6812              LDR      r2,[r2,#0]
00004a  64a2              STR      r2,[r4,#0x48]
00004c  684a              LDR      r2,[r1,#4]
00004e  64e2              STR      r2,[r4,#0x4c]
000050  688a              LDR      r2,[r1,#8]
000052  6522              STR      r2,[r4,#0x50]
000054  6809              LDR      r1,[r1,#0]
000056  6561              STR      r1,[r4,#0x54]
000058  f04f0c00          MOV      r12,#0
00005c  f8843058          STRB     r3,[r4,#0x58]
000060  f884c000          STRB     r12,[r4,#0]
000064  6ae0              LDR      r0,[r4,#0x2c]
000066  61e0              STR      r0,[r4,#0x1c]
000068  6b22              LDR      r2,[r4,#0x30]
00006a  2001              MOVS     r0,#1
00006c  b18b              CBZ      r3,|L21.146|
00006e  428a              CMP      r2,r1
000070  d121              BNE      |L21.182|
000072  6ca2              LDR      r2,[r4,#0x48]
000074  6be1              LDR      r1,[r4,#0x3c]
000076  4291              CMP      r1,r2
000078  d11d              BNE      |L21.182|
00007a  7020              STRB     r0,[r4,#0]
00007c  f884c001          STRB     r12,[r4,#1]
000080  6c20              LDR      r0,[r4,#0x40]
000082  6120              STR      r0,[r4,#0x10]
000084  6b60              LDR      r0,[r4,#0x34]
000086  f8c4c020          STR      r12,[r4,#0x20]
00008a  6060              STR      r0,[r4,#4]
00008c  6d20              LDR      r0,[r4,#0x50]
00008e  6260              STR      r0,[r4,#0x24]
000090  e00e              B        |L21.176|
                  |L21.146|
000092  6ca3              LDR      r3,[r4,#0x48]
000094  429a              CMP      r2,r3
000096  bf04              ITT      EQ
000098  6be2              LDREQ    r2,[r4,#0x3c]
00009a  428a              CMPEQ    r2,r1
00009c  d10b              BNE      |L21.182|
00009e  7020              STRB     r0,[r4,#0]
0000a0  7060              STRB     r0,[r4,#1]
0000a2  6ce0              LDR      r0,[r4,#0x4c]
0000a4  60e0              STR      r0,[r4,#0xc]
0000a6  6b60              LDR      r0,[r4,#0x34]
0000a8  6060              STR      r0,[r4,#4]
0000aa  6c60              LDR      r0,[r4,#0x44]
0000ac  e9c40c08          STRD     r0,r12,[r4,#0x20]
                  |L21.176|
0000b0  b002              ADD      sp,sp,#8
0000b2  4620              MOV      r0,r4
0000b4  bd70              POP      {r4-r6,pc}
                  |L21.182|
0000b6  f240113f          MOV      r1,#0x13f
0000ba  4806              LDR      r0,|L21.212|
0000bc  e9cd0100          STRD     r0,r1,[sp,#0]
0000c0  a305              ADR      r3,|L21.216|
0000c2  a214              ADR      r2,|L21.276|
0000c4  a11e              ADR      r1,|L21.320|
0000c6  2005              MOVS     r0,#5
0000c8  f7fffffe          BL       _Anki_Log
0000cc  b002              ADD      sp,sp,#8
0000ce  4620              MOV      r0,r4
0000d0  bd70              POP      {r4-r6,pc}
                          ENDP

0000d2  0000              DCW      0x0000
                  |L21.212|
                          DCD      _ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)::__PRETTY_FUNCTION__
                  |L21.216|
0000d8  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/arrayS"
0000dc  6f726574
0000e0  6563685c
0000e4  636f6d6d
0000e8  6f6e5c69
0000ec  6e636c75
0000f0  64655c61
0000f4  6e6b692f
0000f8  636f6d6d
0000fc  6f6e2f72
000100  6f626f74
000104  2f617272
000108  617953  
00010b  6c696365          DCB      "lices.h",0
00010f  732e6800
000113  00                DCB      0
                  |L21.276|
000114  53756273          DCB      "Subscripted assignment dimension mismatch",0
000118  63726970
00011c  74656420
000120  61737369
000124  676e6d65
000128  6e742064
00012c  696d656e
000130  73696f6e
000134  206d6973
000138  6d617463
00013c  6800    
00013e  00                DCB      0
00013f  00                DCB      0
                  |L21.320|
000140  41727261          DCB      "ArraySliceLimits_in1_out1",0
000144  79536c69
000148  63654c69
00014c  6d697473
000150  5f696e31
000154  5f6f7574
000158  3100    
00015a  00                DCB      0
00015b  00                DCB      0

                          AREA ||area_number.22||, COMGROUP=_ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_, LINKORDER=||t._ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIsEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIsEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIsEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<short>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIsEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<short>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L28.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L28.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L28.384|
000044  a25c              ADR      r2,|L28.440|
000046  a160              ADR      r1,|L28.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L28.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0040              LSLS     r0,r0,#1
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L28.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L28.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L28.384|
000080  a24d              ADR      r2,|L28.440|
000082  a157              ADR      r1,|L28.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L28.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L28.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L28.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L28.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L28.384|
0000c8  a251              ADR      r2,|L28.528|
0000ca  a156              ADR      r1,|L28.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L28.372|
                  |L28.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L28.384|
0000e0  a258              ADR      r2,|L28.580|
0000e2  a15f              ADR      r1,|L28.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L28.372|
                  |L28.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L28.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L28.384|
000110  a259              ADR      r2,|L28.632|
000112  a144              ADR      r1,|L28.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L28.372|
                  |L28.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  0071              LSLS     r1,r6,#1
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L28.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L28.384|
00015a  a251              ADR      r2,|L28.672|
00015c  a140              ADR      r1,|L28.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L28.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L28.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIsEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<short>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L28.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L28.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L28.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L28.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIsE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<short>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L28.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L28.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIsE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<short>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L28.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L28.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L28.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L28.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L28.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L28.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.29||, COMGROUP=_ZN4Anki8Embedded5ArrayIsEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIsEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.29||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIsEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIsEclEiiii||, COMGROUP=_ZN4Anki8Embedded5ArrayIsEclEiiii, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded5ArrayIsEclEiiii PROC ; Anki::Embedded::Array<short>::operator ()(int, int, int, int)
;;;401    
;;;402        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX)
000000  b5f0              PUSH     {r4-r7,lr}
;;;403        {
000002  b099              SUB      sp,sp,#0x64
000004  4604              MOV      r4,r0
000006  e9dd671e          LDRD     r6,r7,[sp,#0x78]
;;;404          LinearSequence<s32> ySlice = IndexSequence<s32>(minY, 1, maxY, this->size[0]);
00000a  6808              LDR      r0,[r1,#0]
00000c  4694              MOV      r12,r2                ;403
00000e  460d              MOV      r5,r1                 ;403
000010  9000              STR      r0,[sp,#0]
000012  2201              MOVS     r2,#1
000014  4661              MOV      r1,r12
000016  a813              ADD      r0,sp,#0x4c
000018  f7fffffe          BL       _ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i ; Anki::Embedded::IndexSequence<int>(T1, T1, T1, int)
;;;405          LinearSequence<s32> xSlice = IndexSequence<s32>(minX, 1, maxX, this->size[1]);
00001c  6868              LDR      r0,[r5,#4]
00001e  9000              STR      r0,[sp,#0]
000020  463b              MOV      r3,r7
000022  2201              MOVS     r2,#1
000024  4631              MOV      r1,r6
000026  a816              ADD      r0,sp,#0x58
000028  f7fffffe          BL       _ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i ; Anki::Embedded::IndexSequence<int>(T1, T1, T1, int)
;;;406    
;;;407          ArraySlice<Type> slice(*this, ySlice, xSlice);
00002c  e895100e          LDM      r5,{r1-r3,r12}
000030  692d              LDR      r5,[r5,#0x10]
000032  f10d0e38          ADD      lr,sp,#0x38
000036  9512              STR      r5,[sp,#0x48]
000038  e8ae100e          STM      lr!,{r1-r3,r12}
00003c  a801              ADD      r0,sp,#4
00003e  aa13              ADD      r2,sp,#0x4c
000040  ab16              ADD      r3,sp,#0x58
000042  a90e              ADD      r1,sp,#0x38
000044  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIsEC1ERKNS0_5ArrayIsEERKNS0_14LinearSequenceIiEESA_ ; Anki::Embedded::ConstArraySlice<short>::ConstArraySlice(const Anki::Embedded::Array<short>&, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
000048  990e              LDR      r1,[sp,#0x38]
00004a  2900              CMP      r1,#0
00004c  bfc4              ITT      GT
00004e  990f              LDRGT    r1,[sp,#0x3c]
000050  2900              CMPGT    r1,#0
000052  dd17              BLE      |L35.132|
000054  e9dd120e          LDRD     r1,r2,[sp,#0x38]
000058  4351              MULS     r1,r2,r1
00005a  b199              CBZ      r1,|L35.132|
00005c  9b10              LDR      r3,[sp,#0x40]
00005e  9a12              LDR      r2,[sp,#0x48]
000060  2100              MOVS     r1,#0
000062  fb012103          MLA      r1,r1,r3,r2
                  |L35.102|
000066  f10d0e04          ADD      lr,sp,#4
00006a  6301              STR      r1,[r0,#0x30]
00006c  e8be10ef          LDM      lr!,{r0-r3,r5-r7,r12}
000070  e88410ef          STM      r4,{r0-r3,r5-r7,r12}
000074  ad09              ADD      r5,sp,#0x24
000076  3420              ADDS     r4,r4,#0x20
000078  e8b5100f          LDM      r5!,{r0-r3,r12}
00007c  e8a4100f          STM      r4!,{r0-r3,r12}
;;;408    
;;;409          return slice;
;;;410        }
000080  b019              ADD      sp,sp,#0x64
000082  bdf0              POP      {r4-r7,pc}
                  |L35.132|
000084  2100              MOVS     r1,#0
000086  e7ee              B        |L35.102|
;;;411    
                          ENDP


                          AREA ||area_number.36||, COMGROUP=_ZN4Anki8Embedded5ArrayIsEclEiiii, LINKORDER=||t._ZN4Anki8Embedded5ArrayIsEclEiiii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.36||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIsEclEiiii||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIsEclEiiii||, COMGROUP=_ZNK4Anki8Embedded5ArrayIsEclEiiii, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded5ArrayIsEclEiiii PROC ; Anki::Embedded::Array<short>::operator ()(int, int, int, int) const
;;;435    
;;;436        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const
000000  b5f0              PUSH     {r4-r7,lr}
;;;437        {
000002  b095              SUB      sp,sp,#0x54
000004  4604              MOV      r4,r0
000006  e9dd671a          LDRD     r6,r7,[sp,#0x68]
;;;438          LinearSequence<s32> ySlice = IndexSequence(minY, 1, maxY, this->size[0]);
00000a  6808              LDR      r0,[r1,#0]
00000c  4694              MOV      r12,r2                ;437
00000e  460d              MOV      r5,r1                 ;437
000010  9000              STR      r0,[sp,#0]
000012  2201              MOVS     r2,#1
000014  4661              MOV      r1,r12
000016  a811              ADD      r0,sp,#0x44
000018  f7fffffe          BL       _ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i ; Anki::Embedded::IndexSequence<int>(T1, T1, T1, int)
;;;439          LinearSequence<s32> xSlice = IndexSequence(minX, 1, maxX, this->size[1]);
00001c  6868              LDR      r0,[r5,#4]
00001e  9000              STR      r0,[sp,#0]
000020  463b              MOV      r3,r7
000022  2201              MOVS     r2,#1
000024  4631              MOV      r1,r6
000026  a80e              ADD      r0,sp,#0x38
000028  f7fffffe          BL       _ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i ; Anki::Embedded::IndexSequence<int>(T1, T1, T1, int)
00002c  e9dd0111          LDRD     r0,r1,[sp,#0x44]
000030  9a13              LDR      r2,[sp,#0x4c]
000032  9204              STR      r2,[sp,#0x10]
000034  e9cd0102          STRD     r0,r1,[sp,#8]
000038  e9dd010e          LDRD     r0,r1,[sp,#0x38]
00003c  9a10              LDR      r2,[sp,#0x40]
00003e  9207              STR      r2,[sp,#0x1c]
000040  e9cd0105          STRD     r0,r1,[sp,#0x14]
000044  e895100f          LDM      r5,{r0-r3,r12}
000048  f10d0e20          ADD      lr,sp,#0x20
00004c  e8ae100f          STM      lr!,{r0-r3,r12}
000050  682a              LDR      r2,[r5,#0]
000052  2a00              CMP      r2,#0
000054  bfc4              ITT      GT
000056  6869              LDRGT    r1,[r5,#4]
000058  2900              CMPGT    r1,#0
00005a  dd14              BLE      |L42.134|
00005c  fb02f001          MUL      r0,r2,r1
000060  b188              CBZ      r0,|L42.134|
000062  68aa              LDR      r2,[r5,#8]
000064  6928              LDR      r0,[r5,#0x10]
000066  2100              MOVS     r1,#0
000068  fb010002          MLA      r0,r1,r2,r0
                  |L42.108|
00006c  f10d0e08          ADD      lr,sp,#8
000070  900d              STR      r0,[sp,#0x34]
000072  e8be10ef          LDM      lr!,{r0-r3,r5-r7,r12}
000076  e88410ef          STM      r4,{r0-r3,r5-r7,r12}
00007a  ad0a              ADD      r5,sp,#0x28
00007c  3420              ADDS     r4,r4,#0x20
00007e  cd0f              LDM      r5!,{r0-r3}
000080  c40f              STM      r4!,{r0-r3}
;;;440    
;;;441          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;442    
;;;443          return slice;
;;;444        }
000082  b015              ADD      sp,sp,#0x54
000084  bdf0              POP      {r4-r7,pc}
                  |L42.134|
000086  2000              MOVS     r0,#0
000088  e7f0              B        |L42.108|
;;;445    
                          ENDP


                          AREA ||area_number.43||, COMGROUP=_ZNK4Anki8Embedded5ArrayIsEclEiiii, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIsEclEiiii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIsEclEiiii||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15ImageProcessing11Correlate1dIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EE||, COMGROUP=_ZN4Anki8Embedded15ImageProcessing11Correlate1dIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15ImageProcessing11Correlate1dIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EE PROC ; Anki::Embedded::ImageProcessing::Correlate1d<short, int, short>(const Anki::Embedded::FixedPointArray<T1>&, const Anki::Embedded::FixedPointArray<T1>&, Anki::Embedded::FixedPointArray<T3>&)
                  ||__tagsym$$noinline||
;;;652          // NOTE: uses a 32-bit accumulator, so be careful of overflows
;;;653          template<typename InType, typename IntermediateType, typename OutType> NO_INLINE Result Correlate1d(const FixedPointArray<InType> &in1, const FixedPointArray<InType> &in2, FixedPointArray<OutType> &out)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;654          {
000004  468a              MOV      r10,r1
000006  b088              SUB      sp,sp,#0x20
000008  4683              MOV      r11,r0
;;;655            const s32 outputLength = in1.get_size(1) + in2.get_size(1) - 1;
00000a  2101              MOVS     r1,#1
00000c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
000010  4604              MOV      r4,r0
000012  2101              MOVS     r1,#1
000014  4650              MOV      r0,r10
000016  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
00001a  4420              ADD      r0,r0,r4
00001c  f1a00801          SUB      r8,r0,#1
000020  4658              MOV      r0,r11
000022  9d0a              LDR      r5,[sp,#0x28]
000024  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
;;;656    
;;;657            AnkiConditionalErrorAndReturnValue(AreValid(in1, in2, out),
000028  4caa              LDR      r4,|L49.724|
00002a  b170              CBZ      r0,|L49.74|
00002c  4650              MOV      r0,r10
00002e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
000032  b150              CBZ      r0,|L49.74|
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
00003a  b130              CBZ      r0,|L49.74|
;;;658              RESULT_FAIL_INVALID_OBJECT, "Correlate1d", "Invalid objects");
;;;659    
;;;660            AnkiConditionalErrorAndReturnValue(in1.get_size(0) == 1 && in2.get_size(0) == 1 && out.get_size(0) == 1,
00003c  2100              MOVS     r1,#0
00003e  4658              MOV      r0,r11
000040  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
000044  2801              CMP      r0,#1
000046  d00f              BEQ      |L49.104|
000048  e01a              B        |L49.128|
                  |L49.74|
00004a  f2402091          MOV      r0,#0x291             ;657
00004e  e9cd4000          STRD     r4,r0,[sp,#0]         ;657
000052  a3a1              ADR      r3,|L49.728|
000054  a2b0              ADR      r2,|L49.792|
000056  a1b4              ADR      r1,|L49.808|
000058  2005              MOVS     r0,#5                 ;657
00005a  f7fffffe          BL       _Anki_Log
;;;661              RESULT_FAIL_INVALID_SIZE, "Correlate1d", "Arrays must be 1d and horizontal");
;;;662    
;;;663            AnkiConditionalErrorAndReturnValue(out.get_size(1) == outputLength,
;;;664              RESULT_FAIL_INVALID_SIZE, "Correlate1d", "Out must be the size of in1 + in2 - 1");
;;;665    
;;;666            AnkiConditionalErrorAndReturnValue(NotAliased(in1, in2, out),
;;;667              RESULT_FAIL_ALIASED_MEMORY, "Correlate1d", "in1, in2, and out must be in different memory locations");
;;;668    
;;;669            const InType * restrict pU;
;;;670            const InType * restrict pV;
;;;671            OutType * restrict pOut = out.Pointer(0,0);
;;;672    
;;;673            // To simplify things, u is the longer of the two,
;;;674            // and v is the shorter of the two
;;;675            s32 uLength;
;;;676            s32 vLength;
;;;677            if(in1.get_size(1) > in2.get_size(1)) {
;;;678              pU = in1.Pointer(0,0);
;;;679              pV = in2.Pointer(0,0);
;;;680              uLength = in1.get_size(1);
;;;681              vLength = in2.get_size(1);
;;;682            } else {
;;;683              pU = in2.Pointer(0,0);
;;;684              pV = in1.Pointer(0,0);
;;;685              uLength = in2.get_size(1);
;;;686              vLength = in1.get_size(1);
;;;687            }
;;;688    
;;;689            const s32 midStartIndex = vLength - 1;
;;;690            const s32 midEndIndex = midStartIndex + uLength - vLength;
;;;691    
;;;692            s32 shiftMagnitude;
;;;693            bool shiftRight;
;;;694            GetBitShiftDirectionAndMagnitude(in1.get_numFractionalBits(), in2.get_numFractionalBits(), out.get_numFractionalBits(), shiftMagnitude, shiftRight);
;;;695    
;;;696            s32 iOut = 0;
;;;697    
;;;698            // Filter the left part
;;;699            for(s32 x=0; x<midStartIndex; x++) {
;;;700              IntermediateType sum = 0;
;;;701              for(s32 xx=0; xx<=x; xx++) {
;;;702                const IntermediateType toAdd = static_cast<IntermediateType>(pU[xx] * pV[vLength-x+xx-1]);
;;;703                sum += toAdd;
;;;704              }
;;;705    
;;;706              if(shiftRight) {
;;;707                sum >>= shiftMagnitude;
;;;708              } else {
;;;709                sum <<= shiftMagnitude;
;;;710              }
;;;711    
;;;712              pOut[iOut++] = static_cast<OutType>(sum);
;;;713            }
;;;714    
;;;715            // Filter the middle part
;;;716            for(s32 x=midStartIndex; x<=midEndIndex; x++) {
;;;717              IntermediateType sum = 0;
;;;718              for(s32 xx=0; xx<vLength; xx++) {
;;;719                const IntermediateType toAdd = static_cast<IntermediateType>(pU[x+xx-midStartIndex] * pV[xx]);
;;;720                sum += toAdd;
;;;721              }
;;;722    
;;;723              if(shiftRight) {
;;;724                sum >>= shiftMagnitude;
;;;725              } else {
;;;726                sum <<= shiftMagnitude;
;;;727              }
;;;728    
;;;729              pOut[iOut++] = static_cast<OutType>(sum);
;;;730            }
;;;731    
;;;732            // Filter the right part
;;;733            for(s32 x=midEndIndex+1; x<outputLength; x++) {
;;;734              const s32 vEnd = outputLength - x;
;;;735              IntermediateType sum = 0;
;;;736              for(s32 xx=0; xx<vEnd; xx++) {
;;;737                const IntermediateType toAdd = static_cast<IntermediateType>(pU[x+xx-midStartIndex] * pV[xx]);
;;;738                sum += toAdd;
;;;739              }
;;;740    
;;;741              if(shiftRight) {
;;;742                sum >>= shiftMagnitude;
;;;743              } else {
;;;744                sum <<= shiftMagnitude;
;;;745              }
;;;746    
;;;747              pOut[iOut++] = static_cast<OutType>(sum);
;;;748            }
;;;749    
;;;750            return RESULT_OK;
;;;751          } // Result Correlate1d(const FixedPointArray<s32> &in1, const FixedPointArray<s32> &in2, FixedPointArray<s32> &out)
00005e  b00b              ADD      sp,sp,#0x2c
000060  f04f6080          MOV      r0,#0x4000000         ;657
000064  e8bd8ff0          POP      {r4-r11,pc}
                  |L49.104|
000068  2100              MOVS     r1,#0                 ;660
00006a  4650              MOV      r0,r10                ;660
00006c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
000070  2801              CMP      r0,#1                 ;660
000072  d105              BNE      |L49.128|
000074  2100              MOVS     r1,#0                 ;660
000076  980a              LDR      r0,[sp,#0x28]         ;660
000078  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
00007c  2801              CMP      r0,#1                 ;660
00007e  d00e              BEQ      |L49.158|
                  |L49.128|
000080  f44f7025          MOV      r0,#0x294             ;660
000084  e9cd4000          STRD     r4,r0,[sp,#0]         ;660
000088  a393              ADR      r3,|L49.728|
00008a  a2aa              ADR      r2,|L49.820|
00008c  a1a6              ADR      r1,|L49.808|
00008e  2005              MOVS     r0,#5                 ;660
000090  f7fffffe          BL       _Anki_Log
000094  b00b              ADD      sp,sp,#0x2c
000096  f04f60a0          MOV      r0,#0x5000000         ;660
00009a  e8bd8ff0          POP      {r4-r11,pc}
                  |L49.158|
00009e  2101              MOVS     r1,#1                 ;663
0000a0  980a              LDR      r0,[sp,#0x28]         ;663
0000a2  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
0000a6  4540              CMP      r0,r8                 ;663
0000a8  d00e              BEQ      |L49.200|
0000aa  f2402097          MOV      r0,#0x297             ;663
0000ae  e9cd4000          STRD     r4,r0,[sp,#0]         ;663
0000b2  a389              ADR      r3,|L49.728|
0000b4  a2a8              ADR      r2,|L49.856|
0000b6  a19c              ADR      r1,|L49.808|
0000b8  2005              MOVS     r0,#5                 ;663
0000ba  f7fffffe          BL       _Anki_Log
0000be  b00b              ADD      sp,sp,#0x2c
0000c0  f04f60a0          MOV      r0,#0x5000000         ;663
0000c4  e8bd8ff0          POP      {r4-r11,pc}
                  |L49.200|
0000c8  4658              MOV      r0,r11
0000ca  9d0a              LDR      r5,[sp,#0x28]
0000cc  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
0000d0  2800              CMP      r0,#0
0000d2  d04e              BEQ      |L49.370|
0000d4  4650              MOV      r0,r10                ;666
0000d6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
0000da  2800              CMP      r0,#0                 ;666
0000dc  d049              BEQ      |L49.370|
0000de  4628              MOV      r0,r5                 ;666
0000e0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
0000e4  2800              CMP      r0,#0                 ;666
0000e6  d044              BEQ      |L49.370|
0000e8  f8db0010          LDR      r0,[r11,#0x10]        ;666
0000ec  9003              STR      r0,[sp,#0xc]          ;666
0000ee  f8da0010          LDR      r0,[r10,#0x10]        ;666
0000f2  9004              STR      r0,[sp,#0x10]         ;666
0000f4  f8d5c010          LDR      r12,[r5,#0x10]        ;666
0000f8  2100              MOVS     r1,#0                 ;666
0000fa  aa03              ADD      r2,sp,#0xc            ;666
0000fc  f8cdc014          STR      r12,[sp,#0x14]        ;666
                  |L49.256|
000100  1c48              ADDS     r0,r1,#1              ;666
000102  2803              CMP      r0,#3                 ;666
000104  bfb8              IT       LT                    ;666
000106  f8523021          LDRLT    r3,[r2,r1,LSL #2]     ;666
00010a  da06              BGE      |L49.282|
                  |L49.268|
00010c  f8525020          LDR      r5,[r2,r0,LSL #2]     ;666
000110  42ab              CMP      r3,r5                 ;666
000112  d02e              BEQ      |L49.370|
000114  1c40              ADDS     r0,r0,#1              ;666
000116  2803              CMP      r0,#3                 ;666
000118  dbf8              BLT      |L49.268|
                  |L49.282|
00011a  1c49              ADDS     r1,r1,#1              ;666
00011c  2903              CMP      r1,#3                 ;666
00011e  dbef              BLT      |L49.256|
000120  990a              LDR      r1,[sp,#0x28]         ;666
000122  2000              MOVS     r0,#0                 ;671
000124  6889              LDR      r1,[r1,#8]            ;671
000126  fb00c701          MLA      r7,r0,r1,r12          ;671
00012a  2101              MOVS     r1,#1                 ;677
00012c  4658              MOV      r0,r11                ;677
00012e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
000132  4604              MOV      r4,r0                 ;677
000134  2101              MOVS     r1,#1                 ;677
000136  4650              MOV      r0,r10                ;677
000138  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
00013c  42a0              CMP      r0,r4                 ;677
00013e  f04f0000          MOV      r0,#0                 ;683
000142  da24              BGE      |L49.398|
000144  f8db2008          LDR      r2,[r11,#8]           ;677
000148  f8db1010          LDR      r1,[r11,#0x10]        ;677
00014c  fb001602          MLA      r6,r0,r2,r1           ;677
000150  f8da2008          LDR      r2,[r10,#8]           ;677
000154  f8da1010          LDR      r1,[r10,#0x10]        ;677
000158  fb001502          MLA      r5,r0,r2,r1           ;677
00015c  2101              MOVS     r1,#1                 ;680
00015e  4658              MOV      r0,r11                ;680
000160  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
000164  9000              STR      r0,[sp,#0]            ;681
000166  2101              MOVS     r1,#1                 ;681
000168  4650              MOV      r0,r10                ;681
00016a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
00016e  4681              MOV      r9,r0                 ;681
000170  e024              B        |L49.444|
                  |L49.370|
000172  f240209a          MOV      r0,#0x29a             ;666
000176  e9cd4000          STRD     r4,r0,[sp,#0]         ;666
00017a  a357              ADR      r3,|L49.728|
00017c  a280              ADR      r2,|L49.896|
00017e  a16a              ADR      r1,|L49.808|
000180  2005              MOVS     r0,#5                 ;666
000182  f7fffffe          BL       _Anki_Log
000186  b00b              ADD      sp,sp,#0x2c
000188  488b              LDR      r0,|L49.952|
00018a  e8bd8ff0          POP      {r4-r11,pc}
                  |L49.398|
00018e  f8da2008          LDR      r2,[r10,#8]
000192  f8da1010          LDR      r1,[r10,#0x10]
000196  fb001602          MLA      r6,r0,r2,r1
00019a  f8db2008          LDR      r2,[r11,#8]
00019e  f8db1010          LDR      r1,[r11,#0x10]
0001a2  2000              MOVS     r0,#0                 ;684
0001a4  fb001502          MLA      r5,r0,r2,r1           ;684
0001a8  2101              MOVS     r1,#1                 ;685
0001aa  4650              MOV      r0,r10                ;685
0001ac  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
0001b0  9000              STR      r0,[sp,#0]            ;686
0001b2  2101              MOVS     r1,#1                 ;686
0001b4  4658              MOV      r0,r11                ;686
0001b6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
0001ba  4681              MOV      r9,r0                 ;686
                  |L49.444|
0001bc  9800              LDR      r0,[sp,#0]            ;690
0001be  f1a90401          SUB      r4,r9,#1              ;689
0001c2  4420              ADD      r0,r0,r4              ;690
0001c4  eba00009          SUB      r0,r0,r9              ;690
0001c8  9001              STR      r0,[sp,#4]            ;690
0001ca  980a              LDR      r0,[sp,#0x28]         ;690
0001cc  f8da1014          LDR      r1,[r10,#0x14]        ;690
0001d0  ab06              ADD      r3,sp,#0x18           ;694
0001d2  6942              LDR      r2,[r0,#0x14]         ;694
0001d4  f8db0014          LDR      r0,[r11,#0x14]        ;694
0001d8  9300              STR      r3,[sp,#0]            ;694
0001da  ab02              ADD      r3,sp,#8              ;694
0001dc  f7fffffe          BL       _ZN4Anki8Embedded15ImageProcessing32GetBitShiftDirectionAndMagnitudeEiiiRiRb ; Anki::Embedded::ImageProcessing::GetBitShiftDirectionAndMagnitude(int, int, int, int&, bool&)
0001e0  2100              MOVS     r1,#0                 ;696
0001e2  460a              MOV      r2,r1                 ;699
0001e4  2c00              CMP      r4,#0                 ;699
0001e6  dd23              BLE      |L49.560|
                  |L49.488|
0001e8  2300              MOVS     r3,#0                 ;700
0001ea  4618              MOV      r0,r3                 ;701
0001ec  2a00              CMP      r2,#0                 ;701
0001ee  bfa8              IT       GE                    ;702
0001f0  eba90a02          SUBGE    r10,r9,r2             ;702
0001f4  db0d              BLT      |L49.530|
                  |L49.502|
0001f6  eb0a0b00          ADD      r11,r10,r0            ;702
0001fa  eb050b4b          ADD      r11,r5,r11,LSL #1     ;702
0001fe  f836c010          LDRH     r12,[r6,r0,LSL #1]    ;702
000202  f83bbc02          LDRH     r11,[r11,#-2]         ;702
000206  fb1cfc0b          SMULBB   r12,r12,r11           ;702
00020a  1c40              ADDS     r0,r0,#1              ;701
00020c  4463              ADD      r3,r3,r12             ;703
00020e  4282              CMP      r2,r0                 ;701
000210  daf1              BGE      |L49.502|
                  |L49.530|
000212  f89d0018          LDRB     r0,[sp,#0x18]         ;706
000216  2800              CMP      r0,#0                 ;706
000218  9802              LDR      r0,[sp,#8]            ;709
00021a  bf14              ITE      NE                    ;707
00021c  fa43f000          ASRNE    r0,r3,r0              ;707
000220  fa03f000          LSLEQ    r0,r3,r0              ;709
000224  f8270011          STRH     r0,[r7,r1,LSL #1]     ;712
000228  1c49              ADDS     r1,r1,#1              ;712
00022a  1c52              ADDS     r2,r2,#1              ;699
00022c  42a2              CMP      r2,r4                 ;699
00022e  dbdb              BLT      |L49.488|
                  |L49.560|
000230  9801              LDR      r0,[sp,#4]            ;716
000232  4623              MOV      r3,r4                 ;716
000234  4284              CMP      r4,r0                 ;716
000236  dc22              BGT      |L49.638|
                  |L49.568|
000238  2200              MOVS     r2,#0                 ;717
00023a  4610              MOV      r0,r2                 ;718
00023c  f1b90f00          CMP      r9,#0                 ;718
000240  dd0d              BLE      |L49.606|
                  |L49.578|
000242  eb030c00          ADD      r12,r3,r0             ;719
000246  ebac0c04          SUB      r12,r12,r4            ;719
00024a  f835a010          LDRH     r10,[r5,r0,LSL #1]    ;719
00024e  f836c01c          LDRH     r12,[r6,r12,LSL #1]   ;719
000252  fb1cfc0a          SMULBB   r12,r12,r10           ;719
000256  1c40              ADDS     r0,r0,#1              ;718
000258  4462              ADD      r2,r2,r12             ;720
00025a  4581              CMP      r9,r0                 ;718
00025c  dcf1              BGT      |L49.578|
                  |L49.606|
00025e  f89d0018          LDRB     r0,[sp,#0x18]         ;723
000262  2800              CMP      r0,#0                 ;723
000264  9802              LDR      r0,[sp,#8]            ;726
000266  bf14              ITE      NE                    ;724
000268  fa42f000          ASRNE    r0,r2,r0              ;724
00026c  fa02f000          LSLEQ    r0,r2,r0              ;726
000270  f8270011          STRH     r0,[r7,r1,LSL #1]     ;729
000274  9801              LDR      r0,[sp,#4]            ;716
000276  1c49              ADDS     r1,r1,#1              ;729
000278  1c5b              ADDS     r3,r3,#1              ;716
00027a  4283              CMP      r3,r0                 ;716
00027c  dddc              BLE      |L49.568|
                  |L49.638|
00027e  1c42              ADDS     r2,r0,#1              ;733
000280  4542              CMP      r2,r8                 ;733
000282  da23              BGE      |L49.716|
                  |L49.644|
000284  2300              MOVS     r3,#0                 ;735
000286  eba80c02          SUB      r12,r8,r2             ;734
00028a  4618              MOV      r0,r3                 ;736
00028c  f1bc0f00          CMP      r12,#0                ;736
000290  dd0d              BLE      |L49.686|
                  |L49.658|
000292  eb020900          ADD      r9,r2,r0              ;737
000296  eba90904          SUB      r9,r9,r4              ;737
00029a  f835a010          LDRH     r10,[r5,r0,LSL #1]    ;737
00029e  f8369019          LDRH     r9,[r6,r9,LSL #1]     ;737
0002a2  fb19f90a          SMULBB   r9,r9,r10             ;737
0002a6  1c40              ADDS     r0,r0,#1              ;736
0002a8  444b              ADD      r3,r3,r9              ;738
0002aa  4584              CMP      r12,r0                ;736
0002ac  dcf1              BGT      |L49.658|
                  |L49.686|
0002ae  f89d0018          LDRB     r0,[sp,#0x18]         ;741
0002b2  2800              CMP      r0,#0                 ;741
0002b4  9802              LDR      r0,[sp,#8]            ;744
0002b6  bf14              ITE      NE                    ;742
0002b8  fa43f000          ASRNE    r0,r3,r0              ;742
0002bc  fa03f000          LSLEQ    r0,r3,r0              ;744
0002c0  f8270011          STRH     r0,[r7,r1,LSL #1]     ;747
0002c4  1c49              ADDS     r1,r1,#1              ;747
0002c6  1c52              ADDS     r2,r2,#1              ;733
0002c8  4542              CMP      r2,r8                 ;733
0002ca  dbdb              BLT      |L49.644|
                  |L49.716|
0002cc  b00b              ADD      sp,sp,#0x2c
0002ce  2000              MOVS     r0,#0                 ;750
0002d0  e8bd8ff0          POP      {r4-r11,pc}
;;;752    
                          ENDP

                  |L49.724|
                          DCD      _ZZN4Anki8Embedded15ImageProcessing11Correlate1dIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::ImageProcessing::Correlate1d<short, int, short>(const Anki::Embedded::FixedPointArray<T1>&, const Anki::Embedded::FixedPointArray<T1>&, Anki::Embedded::FixedPointArray<T3>&)::__PRETTY_FUNCTION__
                  |L49.728|
0002d8  2e2e5c63          DCB      "..\\coretech\\vision\\include\\anki/vision/robot/imageP"
0002dc  6f726574
0002e0  6563685c
0002e4  76697369
0002e8  6f6e5c69
0002ec  6e636c75
0002f0  64655c61
0002f4  6e6b692f
0002f8  76697369
0002fc  6f6e2f72
000300  6f626f74
000304  2f696d61
000308  676550  
00030b  726f6365          DCB      "rocessing.h",0
00030f  7373696e
000313  672e6800
000317  00                DCB      0
                  |L49.792|
000318  496e7661          DCB      "Invalid objects",0
00031c  6c696420
000320  6f626a65
000324  63747300
                  |L49.808|
000328  436f7272          DCB      "Correlate1d",0
00032c  656c6174
000330  65316400
                  |L49.820|
000334  41727261          DCB      "Arrays must be 1d and horizontal",0
000338  7973206d
00033c  75737420
000340  62652031
000344  6420616e
000348  6420686f
00034c  72697a6f
000350  6e74616c
000354  00      
000355  00                DCB      0
000356  00                DCB      0
000357  00                DCB      0
                  |L49.856|
000358  4f757420          DCB      "Out must be the size of in1 + in2 - 1",0
00035c  6d757374
000360  20626520
000364  74686520
000368  73697a65
00036c  206f6620
000370  696e3120
000374  2b20696e
000378  32202d20
00037c  3100    
00037e  00                DCB      0
00037f  00                DCB      0
                  |L49.896|
000380  696e312c          DCB      "in1, in2, and out must be in different memory locations"
000384  20696e32
000388  2c20616e
00038c  64206f75
000390  74206d75
000394  73742062
000398  6520696e
00039c  20646966
0003a0  66657265
0003a4  6e74206d
0003a8  656d6f72
0003ac  79206c6f
0003b0  63617469
0003b4  6f6e73  
0003b7  00                DCB      0
                  |L49.952|
                          DCD      0x01000003

                          AREA ||area_number.50||, COMGROUP=_ZN4Anki8Embedded15ImageProcessing11Correlate1dIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EE, LINKORDER=||t._ZN4Anki8Embedded15ImageProcessing11Correlate1dIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.50||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15ImageProcessing11Correlate1dIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15ImageProcessing36Correlate1dCircularAndSameSizeOutputIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EENS0_11MemoryStackE||, COMGROUP=_ZN4Anki8Embedded15ImageProcessing36Correlate1dCircularAndSameSizeOutputIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EENS0_11MemoryStackE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15ImageProcessing36Correlate1dCircularAndSameSizeOutputIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EENS0_11MemoryStackE PROC ; Anki::Embedded::ImageProcessing::Correlate1dCircularAndSameSizeOutput<short, int, short>(const Anki::Embedded::FixedPointArray<T1>&, const Anki::Embedded::FixedPointArray<T1>&, Anki::Embedded::FixedPointArray<T3>&, Anki::Embedded::MemoryStack)
                  |symbol_number.84|
;;;752    
;;;753          template<typename InType, typename IntermediateType, typename OutType> NO_INLINE Result Correlate1dCircularAndSameSizeOutput(const FixedPointArray<InType> &image, const FixedPointArray<InType> &filter, FixedPointArray<OutType> &out, MemoryStack scratch)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;754          {
000004  4607              MOV      r7,r0
000006  b0e1              SUB      sp,sp,#0x184
000008  469b              MOV      r11,r3
00000a  4615              MOV      r5,r2
00000c  460e              MOV      r6,r1
;;;755            BeginBenchmark("Correlate1dCircularAndSameSizeOutput");
00000e  a0fb              ADR      r0,|L56.1020|
000010  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
;;;756    
;;;757            const s32 imageHeight = image.get_size(0);
000014  2100              MOVS     r1,#0
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
00001c  4682              MOV      r10,r0
;;;758            const s32 imageWidth = image.get_size(1);
00001e  2101              MOVS     r1,#1
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
;;;759    
;;;760            const s32 filterHeight = filter.get_size(0);
000026  9055              STR      r0,[sp,#0x154]
000028  2100              MOVS     r1,#0
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
000030  4681              MOV      r9,r0
;;;761            const s32 filterWidth = filter.get_size(1);
000032  2101              MOVS     r1,#1
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
00003a  4604              MOV      r4,r0
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
;;;762    
;;;763            AnkiConditionalErrorAndReturnValue(AreValid(image, filter, out),
000042  f8df83e0          LDR      r8,|L56.1060|
000046  b170              CBZ      r0,|L56.102|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
00004e  b150              CBZ      r0,|L56.102|
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
000056  b130              CBZ      r0,|L56.102|
;;;764              RESULT_FAIL_INVALID_OBJECT, "Correlate1dCircularAndSameSizeOutput", "Invalid objects");
;;;765    
;;;766            AnkiConditionalErrorAndReturnValue(imageHeight==1 && filterHeight==1 && out.get_size(0)==1,
000058  f1ba0f01          CMP      r10,#1
00005c  bf08              IT       EQ
00005e  f1b90f01          CMPEQ    r9,#1
000062  d00f              BEQ      |L56.132|
000064  e014              B        |L56.144|
                  |L56.102|
000066  f24020fb          MOV      r0,#0x2fb             ;763
00006a  e9cd8000          STRD     r8,r0,[sp,#0]         ;763
00006e  a3ee              ADR      r3,|L56.1064|
000070  a2fd              ADR      r2,|L56.1128|
000072  a1e2              ADR      r1,|L56.1020|
000074  2005              MOVS     r0,#5                 ;763
000076  f7fffffe          BL       _Anki_Log
;;;767              RESULT_FAIL_INVALID_SIZE, "Correlate1dCircularAndSameSizeOutput", "Arrays must be 1d and horizontal");
;;;768    
;;;769            AnkiConditionalErrorAndReturnValue(imageWidth > filterWidth,
;;;770              RESULT_FAIL_INVALID_SIZE, "Correlate1dCircularAndSameSizeOutput", "The image must be larger than the filter");
;;;771    
;;;772            AnkiConditionalErrorAndReturnValue(NotAliased(image, filter, out),
;;;773              RESULT_FAIL_ALIASED_MEMORY, "Correlate1dCircularAndSameSizeOutput", "in1, in2, and out must be in different memory locations");
;;;774    
;;;775            Array<InType> paddedImage(1, imageWidth + 2*(filterWidth-1), scratch);
;;;776    
;;;777            paddedImage(0,0,0,filterWidth-2).Set(image(0,0,-filterWidth+1,-1));
;;;778            paddedImage(0,0,filterWidth-1,filterWidth+imageWidth-2).Set(image);
;;;779            paddedImage(0,0,filterWidth+imageWidth-1,-1).Set(image(0,0,0,filterWidth-2));
;;;780    
;;;781            //const InType * restrict pImage = image.Pointer(0,0);
;;;782    
;;;783            //image.Print("image");
;;;784            //paddedImage.Print("paddedImage");
;;;785    
;;;786            //Matlab matlab(false);
;;;787            //matlab.PutArray(image, "image");
;;;788            //matlab.PutArray(paddedImage, "paddedImage");
;;;789    
;;;790            const InType * restrict pPaddedImage = paddedImage.Pointer(0,0);
;;;791            const InType * restrict pFilter = filter.Pointer(0,0);
;;;792            OutType * restrict pOut = out.Pointer(0,0);
;;;793    
;;;794            s32 shiftMagnitude;
;;;795            bool shiftRight;
;;;796            GetBitShiftDirectionAndMagnitude(image.get_numFractionalBits(), filter.get_numFractionalBits(), out.get_numFractionalBits(), shiftMagnitude, shiftRight);
;;;797    
;;;798            s32 shiftType = !!shiftMagnitude;
;;;799            if(shiftRight)
;;;800              shiftType = 2;
;;;801    
;;;802            const s32 filterHalfWidth = filterWidth >> 1;
;;;803    
;;;804            for(s32 x=0; x<imageWidth; x++) {
;;;805              IntermediateType sum = 0;
;;;806    
;;;807              if(sizeof(InType) == 4 && Flags::TypeCharacteristics<InType>::isSigned) {
;;;808                const s32 filterWidthSimdMax = RoundDown<s32>(filterWidth, 2);
;;;809                for(s32 xFilter=0; xFilter<filterWidthSimdMax; xFilter+=2) {
;;;810                  const s32 xImage = x - filterHalfWidth + filterWidth - 1 + xFilter;
;;;811    
;;;812                  const IntermediateType toAdd0 = static_cast<IntermediateType>(pPaddedImage[xImage] * pFilter[xFilter]);
;;;813                  const IntermediateType toAdd1 = static_cast<IntermediateType>(pPaddedImage[xImage+1] * pFilter[xFilter+1]);
;;;814    
;;;815                  sum += toAdd0 + toAdd1;
;;;816                }
;;;817    
;;;818                for(s32 xFilter=filterWidthSimdMax; xFilter<filterWidth; xFilter++) {
;;;819                  const s32 xImage = x - filterHalfWidth + filterWidth - 1 + xFilter;
;;;820                  const IntermediateType toAdd = static_cast<IntermediateType>(pPaddedImage[xImage] * pFilter[xFilter]);
;;;821                  sum += toAdd;
;;;822                }
;;;823              } else if(sizeof(InType) == 2 && Flags::TypeCharacteristics<InType>::isSigned) {
;;;824                //const s32 xImageOffset = x - filterHalfWidth + filterWidth - 1;
;;;825    
;;;826                s32 xImage = x - filterHalfWidth + filterWidth - 1;
;;;827    
;;;828                const s32 filterWidthSimdMax = RoundDown<s32>(filterWidth, 8);
;;;829                for(s32 xFilter=0; xFilter<filterWidthSimdMax; xFilter+=8, xImage+=8) {
;;;830                  //#if !defined(USE_ARM_ACCELERATION_IMAGE_PROCESSING)
;;;831                  const IntermediateType toAdd0 = static_cast<IntermediateType>(pPaddedImage[xImage]   * pFilter[xFilter]);
;;;832                  const IntermediateType toAdd1 = static_cast<IntermediateType>(pPaddedImage[xImage+1] * pFilter[xFilter+1]);
;;;833                  const IntermediateType toAdd2 = static_cast<IntermediateType>(pPaddedImage[xImage+2] * pFilter[xFilter+2]);
;;;834                  const IntermediateType toAdd3 = static_cast<IntermediateType>(pPaddedImage[xImage+3] * pFilter[xFilter+3]);
;;;835                  const IntermediateType toAdd4 = static_cast<IntermediateType>(pPaddedImage[xImage+4] * pFilter[xFilter+4]);
;;;836                  const IntermediateType toAdd5 = static_cast<IntermediateType>(pPaddedImage[xImage+5] * pFilter[xFilter+5]);
;;;837                  const IntermediateType toAdd6 = static_cast<IntermediateType>(pPaddedImage[xImage+6] * pFilter[xFilter+6]);
;;;838                  const IntermediateType toAdd7 = static_cast<IntermediateType>(pPaddedImage[xImage+7] * pFilter[xFilter+7]);
;;;839    
;;;840                  sum += toAdd0 + toAdd1 + toAdd2 + toAdd3 + toAdd4 + toAdd5 + toAdd6 + toAdd7;
;;;841                  //#else // #if !defined(USE_ARM_ACCELERATION_IMAGE_PROCESSING)
;;;842                  //              // TODO: make work for any template type, and so Keil doesn't merge loads
;;;843                  //              const u32 image01 = *reinterpret_cast<const u32*>(&pPaddedImage[xImage]);
;;;844                  //              const u32 image23 = *reinterpret_cast<const u32*>(&pPaddedImage[xImage + 2]);
;;;845                  //              const u32 image45 = *reinterpret_cast<const u32*>(&pPaddedImage[xImage + 4]);
;;;846                  //              const u32 image67 = *reinterpret_cast<const u32*>(&pPaddedImage[xImage + 6]);
;;;847                  //
;;;848                  //              const u32 filter01 = *reinterpret_cast<const u32*>(&pFilter[xFilter]);
;;;849                  //              const u32 filter23 = *reinterpret_cast<const u32*>(&pFilter[xFilter + 2]);
;;;850                  //              const u32 filter45 = *reinterpret_cast<const u32*>(&pFilter[xFilter + 4]);
;;;851                  //              const u32 filter67 = *reinterpret_cast<const u32*>(&pFilter[xFilter + 6]);
;;;852                  //
;;;853                  //              sum = __SMLAD(image01, filter01, sum);
;;;854                  //              sum = __SMLAD(image23, filter23, sum);
;;;855                  //              sum = __SMLAD(image45, filter45, sum);
;;;856                  //              sum = __SMLAD(image67, filter67, sum);
;;;857                  //#endif // #if !defined(USE_ARM_ACCELERATION_IMAGE_PROCESSING) ... #else
;;;858                }
;;;859    
;;;860                for(s32 xFilter=filterWidthSimdMax; xFilter<filterWidth; xFilter++) {
;;;861                  const s32 xImage = x - filterHalfWidth + filterWidth - 1 + xFilter;
;;;862                  const IntermediateType toAdd = static_cast<IntermediateType>(pPaddedImage[xImage] * pFilter[xFilter]);
;;;863                  sum += toAdd;
;;;864                }
;;;865              } else {
;;;866                for(s32 xFilter=0; xFilter<filterWidth; xFilter++) {
;;;867                  const s32 xImage = x - filterHalfWidth + filterWidth - 1 + xFilter;
;;;868                  const IntermediateType toAdd = static_cast<IntermediateType>(pPaddedImage[xImage] * pFilter[xFilter]);
;;;869                  sum += toAdd;
;;;870                }
;;;871              }
;;;872    
;;;873              if(shiftType == 2) {
;;;874                sum >>= shiftMagnitude;
;;;875              } else if(shiftType == 1) {
;;;876                sum <<= shiftMagnitude;
;;;877              }
;;;878    
;;;879              pOut[x] = static_cast<OutType>(sum);
;;;880            } // for(s32 x=0; x<imageWidth; x++)
;;;881    
;;;882            EndBenchmark("Correlate1dCircularAndSameSizeOutput");
;;;883    
;;;884            //CoreTechPrint("numLeft:%d numRight:%d numCenter:%d\n", numLeft, numRight, numCenter);
;;;885    
;;;886            return RESULT_OK;
;;;887          } // Result Correlate1dCircularAndSameSizeOutput(const FixedPointArray<s32> &in1, const FixedPointArray<s32> &in2, FixedPointArray<s32> &out)
00007a  b061              ADD      sp,sp,#0x184
00007c  f04f6080          MOV      r0,#0x4000000         ;763
000080  e8bd8ff0          POP      {r4-r11,pc}
                  |L56.132|
000084  2100              MOVS     r1,#0                 ;766
000086  4628              MOV      r0,r5                 ;766
000088  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
00008c  2801              CMP      r0,#1                 ;766
00008e  d00e              BEQ      |L56.174|
                  |L56.144|
000090  f24020fe          MOV      r0,#0x2fe             ;766
000094  e9cd8000          STRD     r8,r0,[sp,#0]         ;766
000098  a3e3              ADR      r3,|L56.1064|
00009a  a2f7              ADR      r2,|L56.1144|
00009c  a1d7              ADR      r1,|L56.1020|
00009e  2005              MOVS     r0,#5                 ;766
0000a0  f7fffffe          BL       _Anki_Log
0000a4  b061              ADD      sp,sp,#0x184
0000a6  f04f60a0          MOV      r0,#0x5000000         ;766
0000aa  e8bd8ff0          POP      {r4-r11,pc}
                  |L56.174|
0000ae  9855              LDR      r0,[sp,#0x154]        ;769
0000b0  42a0              CMP      r0,r4                 ;769
0000b2  dc0e              BGT      |L56.210|
0000b4  f2403001          MOV      r0,#0x301             ;769
0000b8  e9cd8000          STRD     r8,r0,[sp,#0]         ;769
0000bc  a3da              ADR      r3,|L56.1064|
0000be  a2f7              ADR      r2,|L56.1180|
0000c0  a1ce              ADR      r1,|L56.1020|
0000c2  2005              MOVS     r0,#5                 ;769
0000c4  f7fffffe          BL       _Anki_Log
0000c8  b061              ADD      sp,sp,#0x184
0000ca  f04f60a0          MOV      r0,#0x5000000         ;769
0000ce  e8bd8ff0          POP      {r4-r11,pc}
                  |L56.210|
0000d2  4638              MOV      r0,r7
0000d4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
0000d8  2800              CMP      r0,#0
0000da  f0008273          BEQ.W    |L56.1476|
0000de  4630              MOV      r0,r6                 ;772
0000e0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
0000e4  2800              CMP      r0,#0                 ;772
0000e6  f000826d          BEQ.W    |L56.1476|
0000ea  4628              MOV      r0,r5                 ;772
0000ec  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
0000f0  2800              CMP      r0,#0                 ;772
0000f2  f0008267          BEQ.W    |L56.1476|
0000f6  6938              LDR      r0,[r7,#0x10]         ;772
0000f8  9036              STR      r0,[sp,#0xd8]         ;772
0000fa  6930              LDR      r0,[r6,#0x10]         ;772
0000fc  9037              STR      r0,[sp,#0xdc]         ;772
0000fe  6928              LDR      r0,[r5,#0x10]         ;772
000100  2100              MOVS     r1,#0                 ;772
000102  aa36              ADD      r2,sp,#0xd8           ;772
000104  9038              STR      r0,[sp,#0xe0]         ;772
                  |L56.262|
000106  1c48              ADDS     r0,r1,#1              ;772
000108  2803              CMP      r0,#3                 ;772
00010a  bfb8              IT       LT                    ;772
00010c  f8523021          LDRLT    r3,[r2,r1,LSL #2]     ;772
000110  da07              BGE      |L56.290|
                  |L56.274|
000112  f852c020          LDR      r12,[r2,r0,LSL #2]    ;772
000116  4563              CMP      r3,r12                ;772
000118  f0008254          BEQ.W    |L56.1476|
00011c  1c40              ADDS     r0,r0,#1              ;772
00011e  2803              CMP      r0,#3                 ;772
000120  dbf7              BLT      |L56.274|
                  |L56.290|
000122  1c49              ADDS     r1,r1,#1              ;772
000124  2903              CMP      r1,#3                 ;772
000126  dbee              BLT      |L56.262|
000128  2300              MOVS     r3,#0                 ;775
00012a  461a              MOV      r2,r3                 ;775
00012c  2101              MOVS     r1,#1                 ;775
00012e  a85f              ADD      r0,sp,#0x17c          ;775
000130  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000134  6800              LDR      r0,[r0,#0]            ;775
000136  9000              STR      r0,[sp,#0]            ;775
000138  9855              LDR      r0,[sp,#0x154]        ;775
00013a  465b              MOV      r3,r11                ;775
00013c  eb000044          ADD      r0,r0,r4,LSL #1       ;775
000140  1e82              SUBS     r2,r0,#2              ;775
000142  2101              MOVS     r1,#1                 ;775
000144  a850              ADD      r0,sp,#0x140          ;775
000146  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIsEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<short>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00014a  2000              MOVS     r0,#0                 ;777
00014c  1ea1              SUBS     r1,r4,#2              ;777
00014e  e9cd0100          STRD     r0,r1,[sp,#0]         ;777
000152  4603              MOV      r3,r0                 ;777
000154  4602              MOV      r2,r0                 ;777
000156  9159              STR      r1,[sp,#0x164]        ;777
000158  a950              ADD      r1,sp,#0x140          ;777
00015a  a836              ADD      r0,sp,#0xd8           ;777
00015c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIsEclEiiii ; Anki::Embedded::Array<short>::operator ()(int, int, int, int)
000160  f10d0ed8          ADD      lr,sp,#0xd8           ;777
000164  e8be170f          LDM      lr!,{r0-r3,r8-r10,r12};777
000168  f10d0e3c          ADD      lr,sp,#0x3c           ;777
00016c  e8ae170f          STM      lr!,{r0-r3,r8-r10,r12};777
000170  f10d08f8          ADD      r8,sp,#0xf8           ;777
000174  e8b8100f          LDM      r8!,{r0-r3,r12}       ;777
000178  f10d085c          ADD      r8,sp,#0x5c           ;777
00017c  e8a8100f          STM      r8!,{r0-r3,r12}       ;777
000180  a80f              ADD      r0,sp,#0x3c           ;777
000182  a902              ADD      r1,sp,#8              ;777
000184  915b              STR      r1,[sp,#0x16c]        ;777
000186  905d              STR      r0,[sp,#0x174]        ;777
000188  f04f31ff          MOV      r1,#0xffffffff        ;777
00018c  f1c40001          RSB      r0,r4,#1              ;777
000190  e9cd0100          STRD     r0,r1,[sp,#0]         ;777
000194  2300              MOVS     r3,#0                 ;777
000196  461a              MOV      r2,r3                 ;777
000198  4639              MOV      r1,r7                 ;777
00019a  a844              ADD      r0,sp,#0x110          ;777
00019c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsEclEiiii ; Anki::Embedded::Array<short>::operator ()(int, int, int, int) const
0001a0  f50d7c88          ADD      r12,sp,#0x110         ;777
0001a4  e9dd1249          LDRD     r1,r2,[sp,#0x124]     ;777
0001a8  e8bc0f01          LDM      r12!,{r0,r8-r11}      ;777
0001ac  9b4b              LDR      r3,[sp,#0x12c]        ;777
0001ae  e9cd9a00          STRD     r9,r10,[sp,#0]        ;777
0001b2  e9dd9a4e          LDRD     r9,r10,[sp,#0x138]    ;777
0001b6  f8cdb170          STR      r11,[sp,#0x170]       ;777
0001ba  e9ddbc4c          LDRD     r11,r12,[sp,#0x130]   ;777
0001be  f8cda10c          STR      r10,[sp,#0x10c]       ;777
0001c2  f8cd9168          STR      r9,[sp,#0x168]        ;777
0001c6  e9dd9a00          LDRD     r9,r10,[sp,#0]        ;777
0001ca  f8cdb160          STR      r11,[sp,#0x160]       ;777
0001ce  f10d0e08          ADD      lr,sp,#8              ;777
0001d2  f8ddb170          LDR      r11,[sp,#0x170]       ;777
0001d6  9309              STR      r3,[sp,#0x24]         ;777
0001d8  e8ae0f01          STM      lr!,{r0,r8-r11}       ;777
0001dc  e9cd1207          STRD     r1,r2,[sp,#0x1c]      ;777
0001e0  f8dd9168          LDR      r9,[sp,#0x168]        ;777
0001e4  f8ddb160          LDR      r11,[sp,#0x160]       ;777
0001e8  f8dda10c          LDR      r10,[sp,#0x10c]       ;777
0001ec  e9cdbc0a          STRD     r11,r12,[sp,#0x28]    ;777
0001f0  e9cd9a0c          STRD     r9,r10,[sp,#0x30]     ;777
0001f4  2000              MOVS     r0,#0                 ;777
0001f6  f88d0038          STRB     r0,[sp,#0x38]         ;777
0001fa  2201              MOVS     r2,#1                 ;777
0001fc  995b              LDR      r1,[sp,#0x16c]        ;777
0001fe  985d              LDR      r0,[sp,#0x174]        ;777
000200  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEb ; Anki::Embedded::ArraySlice<short>::SetCast<short>(const Anki::Embedded::ConstArraySliceExpression<short>&, bool)
000204  9855              LDR      r0,[sp,#0x154]        ;778
000206  2300              MOVS     r3,#0                 ;778
000208  eb040b00          ADD      r11,r4,r0             ;778
00020c  f1ab0102          SUB      r1,r11,#2             ;778
000210  1e60              SUBS     r0,r4,#1              ;778
000212  e9cd0100          STRD     r0,r1,[sp,#0]         ;778
000216  461a              MOV      r2,r3                 ;778
000218  a950              ADD      r1,sp,#0x140          ;778
00021a  a836              ADD      r0,sp,#0xd8           ;778
00021c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIsEclEiiii ; Anki::Embedded::Array<short>::operator ()(int, int, int, int)
000220  f10d0ed8          ADD      lr,sp,#0xd8           ;778
000224  e8be170f          LDM      lr!,{r0-r3,r8-r10,r12};778
000228  f10d0e70          ADD      lr,sp,#0x70           ;778
00022c  e8ae170f          STM      lr!,{r0-r3,r8-r10,r12};778
000230  f10d08f8          ADD      r8,sp,#0xf8           ;778
000234  f50d7a86          ADD      r10,sp,#0x10c         ;778
000238  e8b8100f          LDM      r8!,{r0-r3,r12}       ;778
00023c  f10d0890          ADD      r8,sp,#0x90           ;778
000240  f04f0900          MOV      r9,#0                 ;778
000244  e8a8100f          STM      r8!,{r0-r3,r12}       ;778
000248  a81c              ADD      r0,sp,#0x70           ;778
00024a  9001              STR      r0,[sp,#4]            ;778
00024c  e897100f          LDM      r7,{r0-r3,r12}        ;778
000250  e8aa100f          STM      r10!,{r0-r3,r12}      ;778
000254  a843              ADD      r0,sp,#0x10c          ;778
000256  f10d0808          ADD      r8,sp,#8              ;778
00025a  4649              MOV      r1,r9                 ;778
00025c  9000              STR      r0,[sp,#0]            ;778
00025e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
000262  1e42              SUBS     r2,r0,#1              ;778
000264  f04f0a01          MOV      r10,#1                ;778
000268  2000              MOVS     r0,#0                 ;778
00026a  e9cd0a03          STRD     r0,r10,[sp,#0xc]      ;778
00026e  4651              MOV      r1,r10                ;778
000270  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
000274  9002              STR      r0,[sp,#8]            ;778
000276  2101              MOVS     r1,#1                 ;778
000278  9800              LDR      r0,[sp,#0]            ;778
00027a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi ; Anki::Embedded::Array<short>::get_size(int) const
00027e  1e42              SUBS     r2,r0,#1              ;778
000280  2000              MOVS     r0,#0                 ;778
000282  e9cd0a06          STRD     r0,r10,[sp,#0x18]     ;778
000286  4651              MOV      r1,r10                ;778
000288  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
00028c  f50d7a86          ADD      r10,sp,#0x10c         ;778
000290  9005              STR      r0,[sp,#0x14]         ;778
000292  e8ba100f          LDM      r10!,{r0-r3,r12}      ;778
000296  f10d0a20          ADD      r10,sp,#0x20          ;778
00029a  e8aa100f          STM      r10!,{r0-r3,r12}      ;778
00029e  9843              LDR      r0,[sp,#0x10c]        ;778
0002a0  2800              CMP      r0,#0                 ;778
0002a2  bfc4              ITT      GT                    ;778
0002a4  9844              LDRGT    r0,[sp,#0x110]        ;778
0002a6  2800              CMPGT    r0,#0                 ;778
0002a8  f340819c          BLE.W    |L56.1508|
0002ac  e9dd0143          LDRD     r0,r1,[sp,#0x10c]     ;778
0002b0  4348              MULS     r0,r1,r0              ;778
0002b2  2800              CMP      r0,#0                 ;778
0002b4  f0008196          BEQ.W    |L56.1508|
0002b8  9a45              LDR      r2,[sp,#0x114]        ;778
0002ba  9947              LDR      r1,[sp,#0x11c]        ;778
0002bc  2000              MOVS     r0,#0                 ;778
0002be  fb001002          MLA      r0,r0,r2,r1           ;778
                  |L56.706|
0002c2  900d              STR      r0,[sp,#0x34]         ;778
0002c4  f88d9038          STRB     r9,[sp,#0x38]         ;778
0002c8  2201              MOVS     r2,#1                 ;778
0002ca  4641              MOV      r1,r8                 ;778
0002cc  9801              LDR      r0,[sp,#4]            ;778
0002ce  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEb ; Anki::Embedded::ArraySlice<short>::SetCast<short>(const Anki::Embedded::ConstArraySliceExpression<short>&, bool)
0002d2  f04f31ff          MOV      r1,#0xffffffff        ;779
0002d6  f1ab0001          SUB      r0,r11,#1             ;779
0002da  e9cd0100          STRD     r0,r1,[sp,#0]         ;779
0002de  2300              MOVS     r3,#0                 ;779
0002e0  461a              MOV      r2,r3                 ;779
0002e2  a950              ADD      r1,sp,#0x140          ;779
0002e4  a836              ADD      r0,sp,#0xd8           ;779
0002e6  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIsEclEiiii ; Anki::Embedded::Array<short>::operator ()(int, int, int, int)
0002ea  f10d0ed8          ADD      lr,sp,#0xd8           ;779
0002ee  e8be170f          LDM      lr!,{r0-r3,r8-r10,r12};779
0002f2  f10d0ea4          ADD      lr,sp,#0xa4           ;779
0002f6  e8ae170f          STM      lr!,{r0-r3,r8-r10,r12};779
0002fa  f10d0af8          ADD      r10,sp,#0xf8          ;779
0002fe  e8ba100f          LDM      r10!,{r0-r3,r12}      ;779
000302  f10d0ac4          ADD      r10,sp,#0xc4          ;779
000306  e8aa100f          STM      r10!,{r0-r3,r12}      ;779
00030a  a829              ADD      r0,sp,#0xa4           ;779
00030c  a902              ADD      r1,sp,#8              ;779
00030e  905d              STR      r0,[sp,#0x174]        ;779
000310  915b              STR      r1,[sp,#0x16c]        ;779
000312  2000              MOVS     r0,#0                 ;779
000314  9959              LDR      r1,[sp,#0x164]        ;779
000316  4603              MOV      r3,r0                 ;779
000318  e9cd0100          STRD     r0,r1,[sp,#0]         ;779
00031c  4602              MOV      r2,r0                 ;779
00031e  4639              MOV      r1,r7                 ;779
000320  a844              ADD      r0,sp,#0x110          ;779
000322  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsEclEiiii ; Anki::Embedded::Array<short>::operator ()(int, int, int, int) const
000326  e9dda046          LDRD     r10,r0,[sp,#0x118]    ;779
00032a  e9dd1249          LDRD     r1,r2,[sp,#0x124]     ;779
00032e  e9dd8944          LDRD     r8,r9,[sp,#0x110]     ;779
000332  f8ddb120          LDR      r11,[sp,#0x120]       ;779
000336  9b4b              LDR      r3,[sp,#0x12c]        ;779
000338  f50d7e98          ADD      lr,sp,#0x130          ;779
00033c  f8cdb178          STR      r11,[sp,#0x178]       ;779
000340  f8cda170          STR      r10,[sp,#0x170]       ;779
000344  f8cd9000          STR      r9,[sp,#0]            ;779
000348  e8be1e00          LDM      lr!,{r9-r12}          ;779
00034c  f8cdb168          STR      r11,[sp,#0x168]       ;779
000350  f8ddb178          LDR      r11,[sp,#0x178]       ;779
000354  f8cda10c          STR      r10,[sp,#0x10c]       ;779
000358  f8cd9160          STR      r9,[sp,#0x160]        ;779
00035c  f8dda170          LDR      r10,[sp,#0x170]       ;779
000360  f8dd9000          LDR      r9,[sp,#0]            ;779
000364  9309              STR      r3,[sp,#0x24]         ;779
000366  e9cda004          STRD     r10,r0,[sp,#0x10]     ;779
00036a  f8cdb018          STR      r11,[sp,#0x18]        ;779
00036e  e9cd1207          STRD     r1,r2,[sp,#0x1c]      ;779
000372  e9cd8902          STRD     r8,r9,[sp,#8]         ;779
000376  a90a              ADD      r1,sp,#0x28           ;779
000378  f8dd9160          LDR      r9,[sp,#0x160]        ;779
00037c  f8ddb168          LDR      r11,[sp,#0x168]       ;779
000380  f8dda10c          LDR      r10,[sp,#0x10c]       ;779
000384  e8a11e00          STM      r1!,{r9-r12}          ;779
000388  2000              MOVS     r0,#0                 ;779
00038a  f88d0038          STRB     r0,[sp,#0x38]         ;779
00038e  2201              MOVS     r2,#1                 ;779
000390  995b              LDR      r1,[sp,#0x16c]        ;779
000392  985d              LDR      r0,[sp,#0x174]        ;779
000394  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEb ; Anki::Embedded::ArraySlice<short>::SetCast<short>(const Anki::Embedded::ConstArraySliceExpression<short>&, bool)
000398  9a52              LDR      r2,[sp,#0x148]        ;779
00039a  9954              LDR      r1,[sp,#0x150]        ;779
00039c  2000              MOVS     r0,#0                 ;779
00039e  fb001902          MLA      r9,r0,r2,r1           ;779
0003a2  68b2              LDR      r2,[r6,#8]            ;779
0003a4  6931              LDR      r1,[r6,#0x10]         ;779
0003a6  ab57              ADD      r3,sp,#0x15c          ;796
0003a8  fb001802          MLA      r8,r0,r2,r1           ;796
0003ac  68aa              LDR      r2,[r5,#8]            ;796
0003ae  6929              LDR      r1,[r5,#0x10]         ;796
0003b0  fb001002          MLA      r0,r0,r2,r1           ;796
0003b4  9039              STR      r0,[sp,#0xe4]         ;796
0003b6  696a              LDR      r2,[r5,#0x14]         ;796
0003b8  6971              LDR      r1,[r6,#0x14]         ;796
0003ba  6978              LDR      r0,[r7,#0x14]         ;796
0003bc  9300              STR      r3,[sp,#0]            ;796
0003be  ab56              ADD      r3,sp,#0x158          ;796
0003c0  f7fffffe          BL       _ZN4Anki8Embedded15ImageProcessing32GetBitShiftDirectionAndMagnitudeEiiiRiRb ; Anki::Embedded::ImageProcessing::GetBitShiftDirectionAndMagnitude(int, int, int, int&, bool&)
0003c4  9856              LDR      r0,[sp,#0x158]        ;798
0003c6  2800              CMP      r0,#0                 ;798
0003c8  bf18              IT       NE                    ;798
0003ca  2001              MOVNE    r0,#1                 ;798
0003cc  9036              STR      r0,[sp,#0xd8]         ;799
0003ce  f89d015c          LDRB     r0,[sp,#0x15c]        ;799
0003d2  2800              CMP      r0,#0                 ;799
0003d4  bf1c              ITT      NE                    ;800
0003d6  2002              MOVNE    r0,#2                 ;800
0003d8  9036              STRNE    r0,[sp,#0xd8]         ;800
0003da  1060              ASRS     r0,r4,#1              ;802
0003dc  903d              STR      r0,[sp,#0xf4]         ;804
0003de  9855              LDR      r0,[sp,#0x154]        ;804
0003e0  2500              MOVS     r5,#0                 ;804
0003e2  2800              CMP      r0,#0                 ;804
0003e4  dd70              BLE      |L56.1224|
0003e6  1fe0              SUBS     r0,r4,#7              ;799
0003e8  2108              MOVS     r1,#8                 ;828
0003ea  fb90f0f1          SDIV     r0,r0,r1              ;828
0003ee  00c0              LSLS     r0,r0,#3              ;828
0003f0  9038              STR      r0,[sp,#0xe0]         ;828
0003f2  fb94f0f1          SDIV     r0,r4,r1              ;828
0003f6  00c0              LSLS     r0,r0,#3              ;828
0003f8  9037              STR      r0,[sp,#0xdc]         ;828
                  |L56.1018|
0003fa  e066              B        |L56.1226|
                  |L56.1020|
0003fc  436f7272          DCB      "Correlate1dCircularAndSameSizeOutput",0
000400  656c6174
000404  65316443
000408  69726375
00040c  6c617241
000410  6e645361
000414  6d655369
000418  7a654f75
00041c  74707574
000420  00      
000421  00                DCB      0
000422  00                DCB      0
000423  00                DCB      0
                  |L56.1060|
                          DCD      _ZZN4Anki8Embedded15ImageProcessing36Correlate1dCircularAndSameSizeOutputIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EENS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::ImageProcessing::Correlate1dCircularAndSameSizeOutput<short, int, short>(const Anki::Embedded::FixedPointArray<T1>&, const Anki::Embedded::FixedPointArray<T1>&, Anki::Embedded::FixedPointArray<T3>&, Anki::Embedded::MemoryStack)::__PRETTY_FUNCTION__
                  |L56.1064|
000428  2e2e5c63          DCB      "..\\coretech\\vision\\include\\anki/vision/robot/imageP"
00042c  6f726574
000430  6563685c
000434  76697369
000438  6f6e5c69
00043c  6e636c75
000440  64655c61
000444  6e6b692f
000448  76697369
00044c  6f6e2f72
000450  6f626f74
000454  2f696d61
000458  676550  
00045b  726f6365          DCB      "rocessing.h",0
00045f  7373696e
000463  672e6800
000467  00                DCB      0
                  |L56.1128|
000468  496e7661          DCB      "Invalid objects",0
00046c  6c696420
000470  6f626a65
000474  63747300
                  |L56.1144|
000478  41727261          DCB      "Arrays must be 1d and horizontal",0
00047c  7973206d
000480  75737420
000484  62652031
000488  6420616e
00048c  6420686f
000490  72697a6f
000494  6e74616c
000498  00      
000499  00                DCB      0
00049a  00                DCB      0
00049b  00                DCB      0
                  |L56.1180|
00049c  54686520          DCB      "The image must be larger than the filter",0
0004a0  696d6167
0004a4  65206d75
0004a8  73742062
0004ac  65206c61
0004b0  72676572
0004b4  20746861
0004b8  6e207468
0004bc  65206669
0004c0  6c746572
0004c4  00      
0004c5  00                DCB      0
0004c6  00                DCB      0
0004c7  00                DCB      0
                  |L56.1224|
0004c8  e074              B        |L56.1460|
                  |L56.1226|
0004ca  993d              LDR      r1,[sp,#0xf4]         ;826
0004cc  2000              MOVS     r0,#0                 ;826
0004ce  1a69              SUBS     r1,r5,r1              ;826
0004d0  4421              ADD      r1,r1,r4              ;826
0004d2  f1a10c01          SUB      r12,r1,#1             ;826
0004d6  913c              STR      r1,[sp,#0xf0]         ;826
0004d8  2c00              CMP      r4,#0                 ;826
0004da  bfb4              ITE      LT                    ;826
0004dc  9e38              LDRLT    r6,[sp,#0xe0]         ;826
0004de  9e37              LDRGE    r6,[sp,#0xdc]         ;826
0004e0  2300              MOVS     r3,#0                 ;829
0004e2  2e00              CMP      r6,#0                 ;829
0004e4  dd45              BLE      |L56.1394|
                  |L56.1254|
0004e6  f839101c          LDRH     r1,[r9,r12,LSL #1]    ;831
0004ea  f8382013          LDRH     r2,[r8,r3,LSL #1]     ;831
0004ee  fb11f202          SMULBB   r2,r1,r2              ;831
0004f2  9200              STR      r2,[sp,#0]            ;832
0004f4  eb09024c          ADD      r2,r9,r12,LSL #1      ;832
0004f8  eb080143          ADD      r1,r8,r3,LSL #1       ;832
0004fc  8857              LDRH     r7,[r2,#2]            ;832
0004fe  f8b1a002          LDRH     r10,[r1,#2]           ;832
000502  fb17fe0a          SMULBB   lr,r7,r10             ;832
000506  f8cde004          STR      lr,[sp,#4]            ;833
00050a  8897              LDRH     r7,[r2,#4]            ;833
00050c  f8b1a004          LDRH     r10,[r1,#4]           ;833
000510  fb17fe0a          SMULBB   lr,r7,r10             ;833
000514  f8cde0ec          STR      lr,[sp,#0xec]         ;834
000518  88d7              LDRH     r7,[r2,#6]            ;834
00051a  f8b1a006          LDRH     r10,[r1,#6]           ;834
00051e  fb17fe0a          SMULBB   lr,r7,r10             ;834
000522  f8cde0e8          STR      lr,[sp,#0xe8]         ;835
000526  8917              LDRH     r7,[r2,#8]            ;835
000528  f8b1a008          LDRH     r10,[r1,#8]           ;835
00052c  fb17fb0a          SMULBB   r11,r7,r10            ;835
000530  8957              LDRH     r7,[r2,#0xa]          ;836
000532  f8b1a00a          LDRH     r10,[r1,#0xa]         ;836
000536  fb17fa0a          SMULBB   r10,r7,r10            ;836
00053a  8997              LDRH     r7,[r2,#0xc]          ;837
00053c  f8b1e00c          LDRH     lr,[r1,#0xc]          ;837
000540  fb17f70e          SMULBB   r7,r7,lr              ;837
000544  89d2              LDRH     r2,[r2,#0xe]          ;838
000546  89c9              LDRH     r1,[r1,#0xe]          ;838
000548  fb12f101          SMULBB   r1,r2,r1              ;838
00054c  e9dd2e00          LDRD     r2,lr,[sp,#0]         ;838
000550  4472              ADD      r2,r2,lr              ;840
000552  f8dde0ec          LDR      lr,[sp,#0xec]         ;840
000556  3308              ADDS     r3,r3,#8              ;829
000558  4472              ADD      r2,r2,lr              ;840
00055a  f8dde0e8          LDR      lr,[sp,#0xe8]         ;840
00055e  f10c0c08          ADD      r12,r12,#8            ;829
000562  4472              ADD      r2,r2,lr              ;840
000564  445a              ADD      r2,r2,r11             ;840
000566  4452              ADD      r2,r2,r10             ;840
000568  443a              ADD      r2,r2,r7              ;840
00056a  4411              ADD      r1,r1,r2              ;840
00056c  4408              ADD      r0,r0,r1              ;840
00056e  429e              CMP      r6,r3                 ;829
000570  dcb9              BGT      |L56.1254|
                  |L56.1394|
000572  42a6              CMP      r6,r4                 ;860
000574  da0c              BGE      |L56.1424|
                  |L56.1398|
000576  993c              LDR      r1,[sp,#0xf0]         ;861
000578  f8382016          LDRH     r2,[r8,r6,LSL #1]     ;862
00057c  4431              ADD      r1,r1,r6              ;861
00057e  1e49              SUBS     r1,r1,#1              ;861
000580  f8391011          LDRH     r1,[r9,r1,LSL #1]     ;862
000584  fb11f102          SMULBB   r1,r1,r2              ;862
000588  1c76              ADDS     r6,r6,#1              ;860
00058a  4408              ADD      r0,r0,r1              ;863
00058c  42a6              CMP      r6,r4                 ;860
00058e  dbf2              BLT      |L56.1398|
                  |L56.1424|
000590  9936              LDR      r1,[sp,#0xd8]         ;873
000592  2902              CMP      r1,#2                 ;873
000594  bf04              ITT      EQ                    ;874
000596  9956              LDREQ    r1,[sp,#0x158]        ;874
000598  4108              ASREQ    r0,r0,r1              ;874
00059a  d003              BEQ      |L56.1444|
00059c  2901              CMP      r1,#1                 ;875
00059e  bf04              ITT      EQ                    ;876
0005a0  9956              LDREQ    r1,[sp,#0x158]        ;876
0005a2  4088              LSLEQ    r0,r0,r1              ;876
                  |L56.1444|
0005a4  9939              LDR      r1,[sp,#0xe4]         ;879
0005a6  f8210015          STRH     r0,[r1,r5,LSL #1]     ;879
0005aa  9855              LDR      r0,[sp,#0x154]        ;804
0005ac  1c6d              ADDS     r5,r5,#1              ;804
0005ae  4285              CMP      r5,r0                 ;804
0005b0  f6ffaf23          BLT      |L56.1018|
                  |L56.1460|
0005b4  f2af10bc          ADR      r0,|L56.1020|
0005b8  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
0005bc  b061              ADD      sp,sp,#0x184
0005be  2000              MOVS     r0,#0                 ;886
0005c0  e8bd8ff0          POP      {r4-r11,pc}
                  |L56.1476|
0005c4  f44f7041          MOV      r0,#0x304             ;772
0005c8  f2af13a4          ADR      r3,|L56.1064|
0005cc  a206              ADR      r2,|L56.1512|
0005ce  f2af11d4          ADR      r1,|L56.1020|
0005d2  e9cd8000          STRD     r8,r0,[sp,#0]         ;772
0005d6  2005              MOVS     r0,#5                 ;772
0005d8  f7fffffe          BL       _Anki_Log
0005dc  b061              ADD      sp,sp,#0x184
0005de  4810              LDR      r0,|L56.1568|
0005e0  e8bd8ff0          POP      {r4-r11,pc}
                  |L56.1508|
0005e4  2000              MOVS     r0,#0
0005e6  e66c              B        |L56.706|
;;;888    
                          ENDP

                  |L56.1512|
0005e8  696e312c          DCB      "in1, in2, and out must be in different memory locations"
0005ec  20696e32
0005f0  2c20616e
0005f4  64206f75
0005f8  74206d75
0005fc  73742062
000600  6520696e
000604  20646966
000608  66657265
00060c  6e74206d
000610  656d6f72
000614  79206c6f
000618  63617469
00061c  6f6e73  
00061f  00                DCB      0
                  |L56.1568|
                          DCD      0x01000003

                          AREA ||area_number.57||, COMGROUP=_ZN4Anki8Embedded15ImageProcessing36Correlate1dCircularAndSameSizeOutputIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EENS0_11MemoryStackE, LINKORDER=||t._ZN4Anki8Embedded15ImageProcessing36Correlate1dCircularAndSameSizeOutputIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EENS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15ImageProcessing36Correlate1dCircularAndSameSizeOutputIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EENS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii PROC ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
;;;105    
;;;106        template<typename Type> s32 LinearSequence<Type>::computeSize(const Type start, const Type increment, const Type end)
000000  4290              CMP      r0,r2
;;;107        {
;;;108          if(start == end) {
;;;109            return 1;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;110          } else {
;;;111            if(ABS(increment) <= Flags::numeric_limits<Type>::epsilon()) {
;;;112              return 0;
;;;113            }
;;;114          }
;;;115    
;;;116          // 10:-1:12
;;;117          if(increment < 0 && start < end) {
;;;118            return 0;
;;;119          }
;;;120    
;;;121          // 12:1:10
;;;122          if(increment > 0 && start > end) {
;;;123            return 0;
;;;124          }
;;;125    
;;;126          const Type minLimit = MIN(start, end);
;;;127          const Type maxLimit = MAX(start, end);
;;;128          const Type incrementMagnitude = ABS(increment);
;;;129    
;;;130          const Type validRange = maxLimit - minLimit;
;;;131          const s32 size = (validRange+incrementMagnitude) / incrementMagnitude;
;;;132    
;;;133          AnkiConditionalErrorAndReturnValue(size >= 0,
;;;134            0, "LinearSequence<Type>::computeSize", "size estimation failed");
;;;135    
;;;136          return size;
;;;137        }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;107
00000a  2400              MOVS     r4,#0                 ;107
00000c  424b              RSBS     r3,r1,#0              ;111
00000e  b082              SUB      sp,sp,#8              ;107
000010  2900              CMP      r1,#0                 ;111
000012  bfac              ITE      GE                    ;111
000014  468c              MOVGE    r12,r1                ;111
000016  469c              MOVLT    r12,r3                ;111
000018  4564              CMP      r4,r12                ;111
00001a  da03              BGE      |L63.36|
00001c  2900              CMP      r1,#0                 ;117
00001e  da04              BGE      |L63.42|
000020  4290              CMP      r0,r2                 ;117
000022  da05              BGE      |L63.48|
                  |L63.36|
000024  b002              ADD      sp,sp,#8
000026  2000              MOVS     r0,#0                 ;123
000028  bd10              POP      {r4,pc}
                  |L63.42|
00002a  bf18              IT       NE                    ;122
00002c  4290              CMPNE    r0,r2                 ;122
00002e  dcf9              BGT      |L63.36|
                  |L63.48|
000030  4290              CMP      r0,r2                 ;126
000032  bfb4              ITE      LT                    ;126
000034  4684              MOVLT    r12,r0                ;126
000036  4694              MOVGE    r12,r2                ;126
000038  bfd8              IT       LE                    ;127
00003a  4610              MOVLE    r0,r2                 ;127
00003c  2900              CMP      r1,#0                 ;128
00003e  bfb8              IT       LT                    ;128
000040  4619              MOVLT    r1,r3                 ;128
000042  eba0000c          SUB      r0,r0,r12             ;130
000046  4408              ADD      r0,r0,r1              ;131
000048  fb90f0f1          SDIV     r0,r0,r1              ;131
00004c  2800              CMP      r0,#0                 ;133
00004e  bfa4              ITT      GE
000050  b002              ADDGE    sp,sp,#8
000052  bd10              POPGE    {r4,pc}
000054  2185              MOVS     r1,#0x85              ;133
000056  4807              LDR      r0,|L63.116|
000058  4b07              LDR      r3,|L63.120|
00005a  e9cd0100          STRD     r0,r1,[sp,#0]         ;133
00005e  f1a30218          SUB      r2,r3,#0x18           ;133
000062  f1a20124          SUB      r1,r2,#0x24           ;133
000066  2005              MOVS     r0,#5                 ;133
000068  f7fffffe          BL       _Anki_Log
00006c  b002              ADD      sp,sp,#8
00006e  2000              MOVS     r0,#0                 ;133
000070  bd10              POP      {r4,pc}
;;;138    
                          ENDP

000072  0000              DCW      0x0000
                  |L63.116|
                          DCD      _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
                  |L63.120|
                          DCD      ||.constdata||+0x124

                          AREA ||area_number.64||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii, LINKORDER=||t._ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.64||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<int>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L70.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L70.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.71||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.71||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListIiE8PushBackERKi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIiE8PushBackERKi, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15FixedLengthListIiE8PushBackERKi PROC ; Anki::Embedded::FixedLengthList<int>::PushBack(const int&)
;;;112    
;;;113        template<typename Type> Result FixedLengthList<Type>::PushBack(const Type &value)
000000  69c3              LDR      r3,[r0,#0x1c]
;;;114        {
;;;115          const s32 curSize = this->get_size();
;;;116    
;;;117          if(curSize >= this->get_maximumSize()) {
000002  68c2              LDR      r2,[r0,#0xc]
000004  4293              CMP      r3,r2
;;;118            return RESULT_FAIL_OUT_OF_MEMORY;
000006  bfdc              ITT      LE
000008  4804              LDRLE    r0,|L77.28|
;;;119          }
;;;120    
;;;121          *this->Pointer(curSize) = value;
;;;122    
;;;123          this->xSlice.size = curSize+1;
;;;124    
;;;125          return RESULT_OK;
;;;126        } // Result FixedLengthList<Type>::PushBack(const Type &value)
00000a  4770              BXLE     lr
00000c  6b03              LDR      r3,[r0,#0x30]         ;121
00000e  6809              LDR      r1,[r1,#0]            ;121
000010  f8431022          STR      r1,[r3,r2,LSL #2]     ;121
000014  1c51              ADDS     r1,r2,#1              ;123
000016  60c1              STR      r1,[r0,#0xc]          ;125
000018  2000              MOVS     r0,#0                 ;125
00001a  4770              BX       lr
;;;127    
                          ENDP

                  |L77.28|
                          DCD      0x01000001

                          AREA ||area_number.78||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIiE8PushBackERKi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListIiE8PushBackERKi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.78||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListIiE8PushBackERKi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<float>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L84.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L84.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L84.384|
000044  a25c              ADR      r2,|L84.440|
000046  a160              ADR      r1,|L84.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L84.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L84.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L84.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L84.384|
000080  a24d              ADR      r2,|L84.440|
000082  a157              ADR      r1,|L84.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L84.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L84.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L84.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L84.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L84.384|
0000c8  a251              ADR      r2,|L84.528|
0000ca  a156              ADR      r1,|L84.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L84.372|
                  |L84.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L84.384|
0000e0  a258              ADR      r2,|L84.580|
0000e2  a15f              ADR      r1,|L84.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L84.372|
                  |L84.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L84.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L84.384|
000110  a259              ADR      r2,|L84.632|
000112  a144              ADR      r1,|L84.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L84.372|
                  |L84.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L84.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L84.384|
00015a  a251              ADR      r2,|L84.672|
00015c  a140              ADR      r1,|L84.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L84.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L84.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L84.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L84.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L84.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L84.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L84.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L84.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L84.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L84.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L84.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L84.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L84.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L84.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.85||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.85||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15ConstArraySliceIsEC1ERKNS0_5ArrayIsEERKNS0_14LinearSequenceIiEESA_||, COMGROUP=_ZN4Anki8Embedded15ConstArraySliceIsEC1ERKNS0_5ArrayIsEERKNS0_14LinearSequenceIiEESA_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15ConstArraySliceIsEC2ERKNS0_5ArrayIsEERKNS0_14LinearSequenceIiEESA_                  ; Alternate entry point ; Anki::Embedded::ConstArraySlice<short>::ConstArraySlice__sub_object(const Anki::Embedded::Array<short>&, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
                  _ZN4Anki8Embedded15ConstArraySliceIsEC1ERKNS0_5ArrayIsEERKNS0_14LinearSequenceIiEESA_ PROC ; Anki::Embedded::ConstArraySlice<short>::ConstArraySlice(const Anki::Embedded::Array<short>&, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
;;;36     
;;;37         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;38           : ySlice(ySlice), xSlice(xSlice), array(array)
;;;39         {
;;;40           if(array.get_numElements() == 0) {
;;;41             this->constArrayData = NULL;
;;;42           } else {
;;;43             this->constArrayData = array.Pointer(0,0);
;;;44           }
;;;45         }
;;;46     
000000  b430              PUSH     {r4,r5}
000002  f8d2c000          LDR      r12,[r2,#0]
000006  6854              LDR      r4,[r2,#4]
000008  6892              LDR      r2,[r2,#8]
00000a  f8c0c000          STR      r12,[r0,#0]
00000e  e9c04201          STRD     r4,r2,[r0,#4]
000012  e9d32c00          LDRD     r2,r12,[r3,#0]
000016  689b              LDR      r3,[r3,#8]
000018  6143              STR      r3,[r0,#0x14]
00001a  e9c02c03          STRD     r2,r12,[r0,#0xc]
00001e  e891103c          LDM      r1,{r2-r5,r12}
000022  f8c0c028          STR      r12,[r0,#0x28]
000026  e9c02306          STRD     r2,r3,[r0,#0x18]
00002a  e9c04508          STRD     r4,r5,[r0,#0x20]
00002e  680b              LDR      r3,[r1,#0]
000030  2b00              CMP      r3,#0
000032  bfc4              ITT      GT
000034  684a              LDRGT    r2,[r1,#4]
000036  2a00              CMPGT    r2,#0
000038  dd09              BLE      |L91.78|
00003a  435a              MULS     r2,r3,r2
00003c  b13a              CBZ      r2,|L91.78|
00003e  690b              LDR      r3,[r1,#0x10]
000040  6889              LDR      r1,[r1,#8]
000042  2200              MOVS     r2,#0
000044  fb023101          MLA      r1,r2,r1,r3
                  |L91.72|
000048  62c1              STR      r1,[r0,#0x2c]
00004a  bc30              POP      {r4,r5}
00004c  4770              BX       lr
                  |L91.78|
00004e  2100              MOVS     r1,#0
000050  e7fa              B        |L91.72|
                          ENDP


                          AREA ||area_number.92||, COMGROUP=_ZN4Anki8Embedded15ConstArraySliceIsEC1ERKNS0_5ArrayIsEERKNS0_14LinearSequenceIiEESA_, LINKORDER=||t._ZN4Anki8Embedded15ConstArraySliceIsEC1ERKNS0_5ArrayIsEERKNS0_14LinearSequenceIiEESA_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.92||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15ConstArraySliceIsEC1ERKNS0_5ArrayIsEERKNS0_14LinearSequenceIiEESA_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i||, COMGROUP=_ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i PROC ; Anki::Embedded::IndexSequence<int>(T1, T1, T1, int)
;;;143    
;;;144        template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type increment, Type end, s32 arraySize)
000000  b510              PUSH     {r4,lr}
;;;145        {
000002  b084              SUB      sp,sp,#0x10
000004  4694              MOV      r12,r2
;;;146          // A negative value means (end-value)
;;;147          if(start < 0)
000006  9a06              LDR      r2,[sp,#0x18]
000008  4604              MOV      r4,r0                 ;145
00000a  2900              CMP      r1,#0
;;;148            start += arraySize;
00000c  bfb8              IT       LT
00000e  4411              ADDLT    r1,r2
;;;149    
;;;150          AnkiAssert(start >=0 && start < arraySize);
;;;151    
;;;152          // A negative value means (end-value)
;;;153          if(end < 0)
000010  2b00              CMP      r3,#0
;;;154            end += arraySize;
000012  bfb8              IT       LT
000014  4413              ADDLT    r3,r2
000016  e9cd1c01          STRD     r1,r12,[sp,#4]
00001a  4661              MOV      r1,r12
00001c  461a              MOV      r2,r3
00001e  9801              LDR      r0,[sp,#4]
000020  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
000024  9000              STR      r0,[sp,#0]
000026  e9dd1201          LDRD     r1,r2,[sp,#4]
;;;155    
;;;156          AnkiAssert(end >=0 && end < arraySize);
;;;157    
;;;158          LinearSequence<Type> sequence(start, increment, end);
;;;159    
;;;160          return sequence;
00002a  60a2              STR      r2,[r4,#8]
00002c  e9c40100          STRD     r0,r1,[r4,#0]
;;;161        }
000030  b004              ADD      sp,sp,#0x10
000032  bd10              POP      {r4,pc}
;;;162    
                          ENDP


                          AREA ||area_number.99||, COMGROUP=_ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i, LINKORDER=||t._ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.99||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIsE7IsValidEv||, COMGROUP=_ZNK4Anki8Embedded5ArrayIsE7IsValidEv, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded5ArrayIsE7IsValidEv PROC ; Anki::Embedded::Array<short>::IsValid() const
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
000000  6901              LDR      r1,[r0,#0x10]
;;;592        {
000002  b131              CBZ      r1,|L105.18|
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
000004  6801              LDR      r1,[r0,#0]
000006  2900              CMP      r1,#0
000008  bfa1              ITTTT    GE
00000a  6840              LDRGE    r0,[r0,#4]
00000c  2800              CMPGE    r0,#0
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
00000e  2001              MOVGE    r0,#1
;;;602        }
000010  4770              BXGE     lr
                  |L105.18|
000012  2000              MOVS     r0,#0                 ;598
000014  4770              BX       lr
;;;603    
                          ENDP


                          AREA ||area_number.106||, COMGROUP=_ZNK4Anki8Embedded5ArrayIsE7IsValidEv, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIsE7IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.106||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIsE7IsValidEv||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIsE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIsE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIsE8get_sizeEi PROC ; Anki::Embedded::Array<short>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L112.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L112.56|
00000e  4b0b              LDR      r3,|L112.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f1030250          ADD      r2,r3,#0x50
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L112.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L112.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIsE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<short>::get_size(int) const::__PRETTY_FUNCTION__
                  |L112.60|
                          DCD      ||.constdata||+0x194

                          AREA ||area_number.113||, COMGROUP=_ZNK4Anki8Embedded5ArrayIsE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIsE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.113||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIsE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE15get_maximumSizeEv||, COMGROUP=_ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE15get_maximumSizeEv, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE15get_maximumSizeEv PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::get_maximumSize() const
;;;169    
;;;170        template<typename Type> inline s32 FixedLengthList<Type>::get_maximumSize() const
000000  69c0              LDR      r0,[r0,#0x1c]
;;;171        {
;;;172          return this->array.get_size(1);
;;;173        } // s32 FixedLengthList<Type>::get_maximumSize() const
000002  4770              BX       lr
;;;174    
                          ENDP


                          AREA ||area_number.120||, COMGROUP=_ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE15get_maximumSizeEv, LINKORDER=||t._ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE15get_maximumSizeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.120||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE15get_maximumSizeEv||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEb||, COMGROUP=_ZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEb, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEb PROC ; Anki::Embedded::ArraySlice<short>::SetCast<short>(const Anki::Embedded::ConstArraySliceExpression<short>&, bool)
;;;110          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;111          template<typename InType> s32 SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  4607              MOV      r7,r0
000006  b0b1              SUB      sp,sp,#0xc4
000008  4692              MOV      r10,r2
00000a  460e              MOV      r6,r1
00000c  3018              ADDS     r0,r0,#0x18
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
000012  f8df8210          LDR      r8,|L126.548|
000016  2800              CMP      r0,#0
000018  d01a              BEQ      |L126.80|
00001a  f1060018          ADD      r0,r6,#0x18
00001e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIsE7IsValidEv ; Anki::Embedded::Array<short>::IsValid() const
000022  2800              CMP      r0,#0
000024  d014              BEQ      |L126.80|
000026  6ab8              LDR      r0,[r7,#0x28]
000028  6ab1              LDR      r1,[r6,#0x28]
00002a  f1070518          ADD      r5,r7,#0x18
00002e  f1060418          ADD      r4,r6,#0x18
000032  4288              CMP      r0,r1
000034  d119              BNE      |L126.106|
000036  20ac              MOVS     r0,#0xac
000038  e9cd8000          STRD     r8,r0,[sp,#0]
00003c  a37a              ADR      r3,|L126.552|
00003e  a289              ADR      r2,|L126.612|
000040  a194              ADR      r1,|L126.660|
000042  2005              MOVS     r0,#5
000044  f7fffffe          BL       _Anki_Log
000048  b031              ADD      sp,sp,#0xc4
00004a  2000              MOVS     r0,#0
00004c  e8bd8ff0          POP      {r4-r11,pc}
                  |L126.80|
000050  20a9              MOVS     r0,#0xa9
000052  e9cd8000          STRD     r8,r0,[sp,#0]
000056  a374              ADR      r3,|L126.552|
000058  a294              ADR      r2,|L126.684|
00005a  a18e              ADR      r1,|L126.660|
00005c  2005              MOVS     r0,#5
00005e  f7fffffe          BL       _Anki_Log
000062  b031              ADD      sp,sp,#0xc4
000064  2000              MOVS     r0,#0
000066  e8bd8ff0          POP      {r4-r11,pc}
                  |L126.106|
00006a  f107090c          ADD      r9,r7,#0xc
00006e  f8963030          LDRB     r3,[r6,#0x30]
000072  e9cd7900          STRD     r7,r9,[sp,#0]
000076  f106020c          ADD      r2,r6,#0xc
00007a  4693              MOV      r11,r2
00007c  4631              MOV      r1,r6
00007e  a802              ADD      r0,sp,#8
000080  f7fffffe          BL       _ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_ ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
000084  f89d0008          LDRB     r0,[sp,#8]
000088  b9b0              CBNZ     r0,|L126.184|
00008a  f1ba0f00          CMP      r10,#0
00008e  d064              BEQ      |L126.346|
000090  f8960030          LDRB     r0,[r6,#0x30]
000094  e9cd7900          STRD     r7,r9,[sp,#0]
000098  f0800301          EOR      r3,r0,#1
00009c  465a              MOV      r2,r11
00009e  4631              MOV      r1,r6
0000a0  a819              ADD      r0,sp,#0x64
0000a2  f7fffffe          BL       _ZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_ ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
0000a6  4601              MOV      r1,r0
0000a8  2259              MOVS     r2,#0x59
0000aa  a802              ADD      r0,sp,#8
0000ac  f7fffffe          BL       __aeabi_memcpy4
0000b0  f89d0008          LDRB     r0,[sp,#8]
0000b4  2800              CMP      r0,#0
0000b6  d043              BEQ      |L126.320|
                  |L126.184|
0000b8  f89d0009          LDRB     r0,[sp,#9]
0000bc  2800              CMP      r0,#0
0000be  f0008066          BEQ.W    |L126.398|
0000c2  9807              LDR      r0,[sp,#0x1c]
0000c4  2600              MOVS     r6,#0
0000c6  2800              CMP      r0,#0
0000c8  f34080a7          BLE.W    |L126.538|
                  |L126.204|
0000cc  9805              LDR      r0,[sp,#0x14]
0000ce  68a2              LDR      r2,[r4,#8]
0000d0  6921              LDR      r1,[r4,#0x10]
0000d2  68ab              LDR      r3,[r5,#8]
0000d4  fb001102          MLA      r1,r0,r2,r1
0000d8  9803              LDR      r0,[sp,#0xc]
0000da  692a              LDR      r2,[r5,#0x10]
0000dc  fb002203          MLA      r2,r0,r3,r2
0000e0  f89d0009          LDRB     r0,[sp,#9]
0000e4  2800              CMP      r0,#0
0000e6  bf19              ITTEE    NE
0000e8  9812              LDRNE    r0,[sp,#0x48]
0000ea  9006              STRNE    r0,[sp,#0x18]
0000ec  9815              LDREQ    r0,[sp,#0x54]
0000ee  9005              STREQ    r0,[sp,#0x14]
0000f0  980c              LDR      r0,[sp,#0x30]
0000f2  9004              STR      r0,[sp,#0x10]
0000f4  9b08              LDR      r3,[sp,#0x20]
0000f6  2000              MOVS     r0,#0
0000f8  2b00              CMP      r3,#0
0000fa  dd14              BLE      |L126.294|
                  |L126.252|
0000fc  9b06              LDR      r3,[sp,#0x18]
0000fe  f8ddc010          LDR      r12,[sp,#0x10]
000102  1c40              ADDS     r0,r0,#1
000104  f8313013          LDRH     r3,[r1,r3,LSL #1]
000108  f822301c          STRH     r3,[r2,r12,LSL #1]
00010c  f8ddc024          LDR      r12,[sp,#0x24]
000110  9b04              LDR      r3,[sp,#0x10]
000112  4463              ADD      r3,r3,r12
000114  9304              STR      r3,[sp,#0x10]
000116  f8ddc028          LDR      r12,[sp,#0x28]
00011a  9b06              LDR      r3,[sp,#0x18]
00011c  4463              ADD      r3,r3,r12
00011e  9306              STR      r3,[sp,#0x18]
000120  9b08              LDR      r3,[sp,#0x20]
000122  4283              CMP      r3,r0
000124  dcea              BGT      |L126.252|
                  |L126.294|
000126  f89d0009          LDRB     r0,[sp,#9]
00012a  2800              CMP      r0,#0
00012c  d022              BEQ      |L126.372|
00012e  9916              LDR      r1,[sp,#0x58]
000130  9805              LDR      r0,[sp,#0x14]
000132  4408              ADD      r0,r0,r1
000134  9005              STR      r0,[sp,#0x14]
000136  9910              LDR      r1,[sp,#0x40]
000138  9803              LDR      r0,[sp,#0xc]
00013a  4408              ADD      r0,r0,r1
00013c  9003              STR      r0,[sp,#0xc]
00013e  e021              B        |L126.388|
                  |L126.320|
000140  20b9              MOVS     r0,#0xb9
000142  e9cd8000          STRD     r8,r0,[sp,#0]
000146  a338              ADR      r3,|L126.552|
000148  a25c              ADR      r2,|L126.700|
00014a  a152              ADR      r1,|L126.660|
00014c  2005              MOVS     r0,#5
00014e  f7fffffe          BL       _Anki_Log
000152  b031              ADD      sp,sp,#0xc4
000154  2000              MOVS     r0,#0
000156  e8bd8ff0          POP      {r4-r11,pc}
                  |L126.346|
00015a  20bd              MOVS     r0,#0xbd
00015c  e9cd8000          STRD     r8,r0,[sp,#0]
000160  a331              ADR      r3,|L126.552|
000162  a256              ADR      r2,|L126.700|
000164  a14b              ADR      r1,|L126.660|
000166  2005              MOVS     r0,#5
000168  f7fffffe          BL       _Anki_Log
00016c  b031              ADD      sp,sp,#0xc4
00016e  2000              MOVS     r0,#0
000170  e8bd8ff0          POP      {r4-r11,pc}
                  |L126.372|
000174  9913              LDR      r1,[sp,#0x4c]
000176  9806              LDR      r0,[sp,#0x18]
000178  4408              ADD      r0,r0,r1
00017a  9006              STR      r0,[sp,#0x18]
00017c  9910              LDR      r1,[sp,#0x40]
00017e  9803              LDR      r0,[sp,#0xc]
000180  4408              ADD      r0,r0,r1
000182  9003              STR      r0,[sp,#0xc]
                  |L126.388|
000184  9807              LDR      r0,[sp,#0x1c]
000186  1c76              ADDS     r6,r6,#1
000188  42b0              CMP      r0,r6
00018a  dc9f              BGT      |L126.204|
00018c  e045              B        |L126.538|
                  |L126.398|
00018e  9807              LDR      r0,[sp,#0x1c]
000190  2300              MOVS     r3,#0
000192  2800              CMP      r0,#0
000194  dd41              BLE      |L126.538|
                  |L126.406|
000196  9803              LDR      r0,[sp,#0xc]
000198  68aa              LDR      r2,[r5,#8]
00019a  6929              LDR      r1,[r5,#0x10]
00019c  fb001c02          MLA      r12,r0,r2,r1
0001a0  f89d0009          LDRB     r0,[sp,#9]
0001a4  2800              CMP      r0,#0
0001a6  bf19              ITTEE    NE
0001a8  9812              LDRNE    r0,[sp,#0x48]
0001aa  9006              STRNE    r0,[sp,#0x18]
0001ac  9815              LDREQ    r0,[sp,#0x54]
0001ae  9005              STREQ    r0,[sp,#0x14]
0001b0  980c              LDR      r0,[sp,#0x30]
0001b2  9004              STR      r0,[sp,#0x10]
0001b4  9908              LDR      r1,[sp,#0x20]
0001b6  2000              MOVS     r0,#0
0001b8  2900              CMP      r1,#0
0001ba  dd16              BLE      |L126.490|
                  |L126.444|
0001bc  e9dd2105          LDRD     r2,r1,[sp,#0x14]
0001c0  68a7              LDR      r7,[r4,#8]
0001c2  6926              LDR      r6,[r4,#0x10]
0001c4  1c40              ADDS     r0,r0,#1
0001c6  fb026207          MLA      r2,r2,r7,r6
0001ca  f8321011          LDRH     r1,[r2,r1,LSL #1]
0001ce  9a04              LDR      r2,[sp,#0x10]
0001d0  f82c1012          STRH     r1,[r12,r2,LSL #1]
0001d4  9a09              LDR      r2,[sp,#0x24]
0001d6  9904              LDR      r1,[sp,#0x10]
0001d8  4411              ADD      r1,r1,r2
0001da  9104              STR      r1,[sp,#0x10]
0001dc  9a0b              LDR      r2,[sp,#0x2c]
0001de  9905              LDR      r1,[sp,#0x14]
0001e0  4411              ADD      r1,r1,r2
0001e2  9105              STR      r1,[sp,#0x14]
0001e4  9908              LDR      r1,[sp,#0x20]
0001e6  4281              CMP      r1,r0
0001e8  dce8              BGT      |L126.444|
                  |L126.490|
0001ea  f89d0009          LDRB     r0,[sp,#9]
0001ee  b140              CBZ      r0,|L126.514|
0001f0  9916              LDR      r1,[sp,#0x58]
0001f2  9805              LDR      r0,[sp,#0x14]
0001f4  4408              ADD      r0,r0,r1
0001f6  9005              STR      r0,[sp,#0x14]
0001f8  9910              LDR      r1,[sp,#0x40]
0001fa  9803              LDR      r0,[sp,#0xc]
0001fc  4408              ADD      r0,r0,r1
0001fe  9003              STR      r0,[sp,#0xc]
000200  e007              B        |L126.530|
                  |L126.514|
000202  9913              LDR      r1,[sp,#0x4c]
000204  9806              LDR      r0,[sp,#0x18]
000206  4408              ADD      r0,r0,r1
000208  9006              STR      r0,[sp,#0x18]
00020a  9910              LDR      r1,[sp,#0x40]
00020c  9803              LDR      r0,[sp,#0xc]
00020e  4408              ADD      r0,r0,r1
000210  9003              STR      r0,[sp,#0xc]
                  |L126.530|
000212  9807              LDR      r0,[sp,#0x1c]
000214  1c5b              ADDS     r3,r3,#1
000216  4298              CMP      r0,r3
000218  dcbd              BGT      |L126.406|
                  |L126.538|
00021a  9908              LDR      r1,[sp,#0x20]
00021c  b031              ADD      sp,sp,#0xc4
00021e  4348              MULS     r0,r1,r0
000220  e8bd8ff0          POP      {r4-r11,pc}
;;;112          //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;113    
;;;114          // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;115          // don't support the full ArraySlice type, and should be used with caution.
;;;116          Array<Type>& get_array();
;;;117    
;;;118        protected:
;;;119    
;;;120          // For speed, this is a direct pointer to the Array's protected data
;;;121          Type * arrayData;
;;;122        }; // template<typename Type> class ArraySlice
;;;123    
;;;124        // An ConstArraySliceExpression is like a ConstArraySlice, but can also be transposed
;;;125        // It may have other abilities in the future, but will probably always be const
;;;126        template<typename Type> class ConstArraySliceExpression : public ConstArraySlice<Type>
;;;127        {
;;;128        public:
;;;129          ConstArraySliceExpression();
;;;130    
;;;131          ConstArraySliceExpression(const Array<Type> input, bool isTransposed=false);
;;;132    
;;;133          ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed=false);
;;;134    
;;;135          ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed=false);
;;;136    
;;;137          // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;138          // This object isn't modified, but the returned object is.
;;;139          ConstArraySliceExpression<Type> Transpose() const;
;;;140    
;;;141          bool get_isTransposed() const;
;;;142    
;;;143        protected:
;;;144          bool isTransposed;
;;;145        };
;;;146    
;;;147        // To simplify the creation of kernels using an ArraySlice, and to aid the compiler optimizer,
;;;148        // an ArraySliceLimits can be initialized at the beginning of the function, then used as the
;;;149        // limits for the inner loops.
;;;150    
;;;151        // The suffix of in# and out# refer to the number of input and output matrices.
;;;152        // If output == 0, then the output is a scalar.
;;;153    
;;;154        template<typename Type> class ArraySliceSimpleLimits
;;;155        {
;;;156        public:
;;;157          Type xStart;
;;;158          Type xIncrement;
;;;159          s32  xSize;
;;;160    
;;;161          Type yStart;
;;;162          Type yIncrement;
;;;163          s32  ySize;
;;;164    
;;;165          ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;166        };
;;;167    
;;;168        // In1 and out0 is a special, ultra-simple case, for one matrix input and a scalar output
;;;169        template<typename Type> class ArraySliceLimits_in1_out0
;;;170        {
;;;171        public:
;;;172          // Was this ArraySliceLimits initialized?
;;;173          bool isValid;
;;;174    
;;;175          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;176    
;;;177          ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;178        };
;;;179    
;;;180        // One input, one output
;;;181        template<typename Type> class ArraySliceLimits_in1_out1
;;;182        {
;;;183        public:
;;;184          // Was this ArraySliceLimits initialized?
;;;185          bool isValid;
;;;186    
;;;187          // Can a simple (non-transposed) iteration be performed?
;;;188          bool isSimpleIteration;
;;;189    
;;;190          // These are the current values for the coordinates in the input and output images
;;;191          s32 out1Y;
;;;192          s32 out1X;
;;;193          s32 in1Y;
;;;194          s32 in1X;
;;;195    
;;;196          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;197          s32 ySize;
;;;198          s32 xSize;
;;;199    
;;;200          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;201          // incremented every iteration of the inner loop
;;;202          s32 out1_xInnerIncrement;
;;;203          s32 in1_xInnerIncrement;
;;;204          s32 in1_yInnerIncrement;
;;;205    
;;;206          ArraySliceLimits_in1_out1(
;;;207            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;208            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;209    
;;;210          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;211          inline void OuterIncrementTop();
;;;212    
;;;213          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;214          inline void OuterIncrementBottom();
;;;215    
;;;216        protected:
;;;217          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;218    
;;;219          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;220          bool in1_isTransposed;
;;;221        };
;;;222    
;;;223        // Two inputs, one output
;;;224        template<typename Type> class ArraySliceLimits_in2_out1
;;;225        {
;;;226        public:
;;;227          // Was this ArraySliceLimits initialized?
;;;228          bool isValid;
;;;229    
;;;230          // Can a simple (non-transposed) iteration be performed?
;;;231          bool isSimpleIteration;
;;;232    
;;;233          // These are the current values for the coordinates in the input and output images
;;;234          s32 out1Y;
;;;235          s32 out1X;
;;;236          s32 in1Y;
;;;237          s32 in1X;
;;;238          s32 in2Y;
;;;239          s32 in2X;
;;;240    
;;;241          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;242          s32 ySize;
;;;243          s32 xSize;
;;;244    
;;;245          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;246          // incremented every iteration of the inner loop
;;;247          s32 out1_xInnerIncrement;
;;;248          s32 in1_xInnerIncrement;
;;;249          s32 in1_yInnerIncrement;
;;;250          s32 in2_xInnerIncrement;
;;;251          s32 in2_yInnerIncrement;
;;;252    
;;;253          ArraySliceLimits_in2_out1(
;;;254            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;255            const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed,
;;;256            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;257    
;;;258          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;259          inline void OuterIncrementTop();
;;;260    
;;;261          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;262          inline void OuterIncrementBottom();
;;;263    
;;;264        protected:
;;;265          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;266    
;;;267          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;268          bool in1_isTransposed;
;;;269    
;;;270          ArraySliceSimpleLimits<Type> rawIn2Limits;
;;;271          bool in2_isTransposed;
;;;272        };
;;;273      } // namespace Embedded
;;;274    } // namespace Anki
;;;275    
;;;276    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         class SerializedBuffer;
;;;24     
;;;25         // A FixedLengthList is a list with a fixed maximum size, which is allocated at construction.
;;;26         template<typename Type> class FixedLengthList : public ArraySlice<Type>
;;;27         {
;;;28         public:
;;;29           FixedLengthList();
;;;30     
;;;31           // Constructor for a FixedLengthList, pointing to user-allocated data.
;;;32           FixedLengthList(s32 maximumSize, void * data, s32 dataLength, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;33     
;;;34           // Constructor for a FixedLengthList, pointing to user-allocated MemoryStack
;;;35           FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;36     
;;;37           bool IsValid() const;
;;;38     
;;;39           // Resize will use MemoryStack::Reallocate() to change the FixedLengthList's size. It only works if this
;;;40           // FixedLengthList was the last thing allocated. The reallocated memory will not be cleared
;;;41           //
;;;42           // WARNING:
;;;43           // This will not update any references to the memory, you must update all references manually.
;;;44           Result Resize(s32 maximumSize, MemoryStack &memory);
;;;45     
;;;46           Result PushBack(const Type &value);
;;;47     
;;;48           // Will act as a normal pop, except when the list is empty. Then subsequent
;;;49           // calls will keep returning the first value in the list.
;;;50           Type PopBack();
;;;51     
;;;52           // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
;;;53           inline void Clear();
;;;54     
;;;55           // Does this ever need to be declared explicitly?
;;;56           //FixedLengthList& operator= (const FixedLengthList & rightHandSide);
;;;57     
;;;58           // Pointer to the data, at a given location
;;;59           inline Type* Pointer(const s32 index);
;;;60           inline const Type* Pointer(const s32 index) const;
;;;61     
;;;62           // Use this operator for normal C-style vector indexing. For example, "list[5] = 6;" will set
;;;63           // the element in the fifth row and first column to 6. This is the same as "*list.Pointer(5) =
;;;64           // 6;"
;;;65           //
;;;66           // NOTE:
;;;67           // Using this in a inner loop may be less efficient than using an explicit pointer with a
;;;68           // restrict keyword (Though the runtime cost isn't nearly as large as the [] operator for the
;;;69           // Array class). For speeding up performance-critical inner loops, use something like: "Type *
;;;70           // restrict pList = list.Pointer(0);" outside the inner loop, then index
;;;71           // pList in the inner loop.
;;;72           inline const Type& operator[](const s32 index) const;
;;;73           inline Type& operator[](const s32 index);
;;;74     
;;;75           // Print out the contents of this FixedLengthList
;;;76           Result Print(const char * const variableName = "FixedLengthList", const s32 minIndex = 0, const s32 maxIndex = 0x7FFFFFE) const;
;;;77     
;;;78           // Set every element in the Array to zero, including the stride padding, but not including the optional fill patterns (if they exist)
;;;79           // Returns the number of bytes set to zero
;;;80           inline s32 SetZero();
;;;81     
;;;82           // Read in the input, then cast it to this object's type
;;;83           //
;;;84           // WARNING:
;;;85           // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;86           template<typename InType> s32 SetCast(const FixedLengthList<InType> &input, bool automaticTranspose=true);
;;;87           //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;88     
;;;89           // The maximum size is set at object construction
;;;90           inline s32 get_maximumSize() const;
;;;91     
;;;92           // The current size changes as the FixedLengthList is used
;;;93           inline s32 get_size() const;
;;;94     
;;;95           // Attempt to set the size to newSize. Returns the value that was actually set.
;;;96           s32 set_size(s32 newSize);
;;;97     
;;;98         protected:
;;;99           // TODO: make less hacky
;;;100          friend class SerializedBuffer;
;;;101        }; // class FixedLengthList
;;;102      } // namespace Embedded
;;;103    } //namespace Anki
;;;104    
;;;105    #endif // _ANKICORETECHEMBEDDED_COMMON_FIXEDLENGTHLIST_DECLARATIONS_H_
;;;19     
;;;20     namespace Anki
;;;21     {
;;;22       namespace Embedded
;;;23       {
;;;24         // A 1d, run-length encoded piece of a 2d component
;;;25         // The type is for storing the ID. u16 is enough for QVGA, but VGA and above need s32
;;;26         template<typename Type> class ConnectedComponentSegment
;;;27         {
;;;28         public:
;;;29           // xStart, xEnd, y use array indexes, meaning the first pixel is at (0,0), not (0.5,0.5) like true coordinates
;;;30           s16 xStart, xEnd, y;
;;;31           Type id;
;;;32     
;;;33           ConnectedComponentSegment();
;;;34     
;;;35           ConnectedComponentSegment(const s16 xStart, const s16 xEnd, const s16 y = -1, const Type id = 0);
;;;36     
;;;37           // Returns a positive s64 if a > b, a negative s64 is a < b, or zero if they are identical
;;;38           // The ordering of components is first by id (the ids are sorted in increasing value, but with zero at the end {1...MAX_VALUE,0}), then y, then xStart
;;;39           // TODO: Doublecheck that this is correct for corner cases
;;;40           static inline s64 Compare(const ConnectedComponentSegment<Type> &a, const ConnectedComponentSegment<Type> &b);
;;;41     
;;;42           void Print() const;
;;;43     
;;;44           bool operator== (const ConnectedComponentSegment &component2) const;
;;;45         }; // class ConnectedComponentSegment
;;;46     
;;;47         // Template for ConnectedComponents. See ConnectedComponents for documentation.
;;;48         template<typename Type> class ConnectedComponentsTemplate
;;;49         {
;;;50         public:
;;;51     
;;;52           static Result Extract1dComponents(const u8 * restrict binaryImageRow, const s16 binaryImageWidth, const s16 minComponentWidth, const s16 maxSkipDistance, FixedLengthList<ConnectedComponentSegment<Type> > &extractedComponents);
;;;53     
;;;54           ConnectedComponentsTemplate();
;;;55     
;;;56           ConnectedComponentsTemplate(const Type maxComponentSegments, const s16 maxImageWidth, MemoryStack &memory);
;;;57     
;;;58           Result Extract2dComponents_FullImage(const Array<u8> &binaryImage, const s16 minComponentWidth, const s16 maxSkipDistance, MemoryStack scratch);
;;;59     
;;;60           Result Extract2dComponents_PerRow_Initialize(MemoryStack &fastMemory, MemoryStack &slowerMemory, MemoryStack &slowestMemory);
;;;61           Result Extract2dComponents_PerRow_NextRow(const u8 * restrict binaryImageRow, const s32 imageWidth, const s16 whichRow, const s16 minComponentWidth, const s16 maxSkipDistance);
;;;62           Result Extract2dComponents_PerRow_Finalize();
;;;63     
;;;64           Result SortConnectedComponentSegments();
;;;65     
;;;66           Result SortConnectedComponentSegmentsById(MemoryStack scratch);
;;;67     
;;;68           Result CompressConnectedComponentSegmentIds(MemoryStack scratch);
;;;69     
;;;70           Result ComputeComponentSizes(FixedLengthList<s32> &componentSizes);
;;;71     
;;;72           Result ComputeComponentCentroids(FixedLengthList<Point<s16> > &componentCentroids, MemoryStack scratch);
;;;73     
;;;74           Result ComputeComponentBoundingBoxes(FixedLengthList<Rectangle<s16> > &componentBoundingBoxes);
;;;75     
;;;76           Result ComputeNumComponentSegmentsForEachId(FixedLengthList<s32> &numComponentSegments);
;;;77     
;;;78           Result InvalidateSmallOrLargeComponents(const s32 minimumNumPixels, const s32 maximumNumPixels, MemoryStack scratch);
;;;79     
;;;80           Result InvalidateSolidOrSparseComponents(const s32 sparseMultiplyThreshold, const s32 solidMultiplyThreshold, MemoryStack scratch);
;;;81     
;;;82           Result InvalidateFilledCenterComponents_shrunkRectangle(const s32 percentHorizontal, const s32 percentVertical, MemoryStack scratch);
;;;83     
;;;84           Result InvalidateFilledCenterComponents_hollowRows(const f32 minHollowRatio, MemoryStack scratch);
;;;85     
;;;86           Result PushBack(const ConnectedComponentSegment<Type> &value);
;;;87     
;;;88           // Note that this is a const-only accessor function. The ConnectedComponets class keeps a lot
;;;89           // of tabs on sorting and maximumId and such, so no one else should be directly modifying the
;;;90           // buffers.
;;;91           inline const ConnectedComponentSegment<Type>* Pointer(const s32 index) const;
;;;92           inline const ConnectedComponentSegment<Type>& operator[](const s32 index) const;
;;;93     
;;;94           bool IsValid() const;
;;;95     
;;;96           Result Print() const;
;;;97     
;;;98           Type get_maximumId() const;
;;;99     
;;;100          s32 get_size() const;
;;;101    
;;;102          bool get_isSortedInId() const;
;;;103          bool get_isSortedInY() const;
;;;104          bool get_isSortedInX() const;
;;;105    
;;;106        protected:
;;;107          enum State
;;;108          {
;;;109            STATE_INVALID,
;;;110            STATE_CONSTRUCTED,
;;;111            STATE_INITIALIZED,
;;;112            STATE_FINALIZED
;;;113          };
;;;114    
;;;115          FixedLengthList<ConnectedComponentSegment<Type> > components;
;;;116          FixedLengthList<ConnectedComponentSegment<Type> > currentComponents1d;
;;;117          FixedLengthList<ConnectedComponentSegment<Type> > previousComponents1d;
;;;118          FixedLengthList<ConnectedComponentSegment<Type> > newPreviousComponents1d;
;;;119          FixedLengthList<Type> equivalentComponents;
;;;120    
;;;121          State curState;
;;;122    
;;;123          bool isSortedInId;
;;;124          bool isSortedInY;
;;;125          bool isSortedInX;
;;;126    
;;;127          Type maximumId;
;;;128          s32 maxImageWidth;
;;;129          s32 maxComponentSegments;
;;;130    
;;;131          // Iterate through components, and update the maximum id
;;;132          Result FindMaximumId();
;;;133        }; // class ConnectedComponentsTemplate
;;;134    
;;;135        // A ConnectedComponents class holds a list of ConnectedComponentSegment<Type> objects
;;;136        // It can incrementally parse an input binary image per-row, updating its global list as it goes
;;;137        // It also contains various utilities to remove poor-quality components
;;;138        class ConnectedComponents
;;;139        {
;;;140        public:
;;;141    
;;;142          ConnectedComponents();
;;;143    
;;;144          // Constructor for a ConnectedComponents, pointing to user-allocated MemoryStack
;;;145          // The memory should remain valid for the entire life of the object
;;;146          ConnectedComponents(const s32 maxComponentSegments, const s16 maxImageWidth, MemoryStack &memory); //< This default constructor creates a u16 object
;;;147          ConnectedComponents(const s32 maxComponentSegments, const s16 maxImageWidth, const bool useU16, MemoryStack &memory);
;;;148    
;;;149          // Extract 2d connected components from binaryImage All extracted components are stored in a
;;;150          // single list of ComponentSegments
;;;151          Result Extract2dComponents_FullImage(const Array<u8> &binaryImage, const s16 minComponentWidth, const s16 maxSkipDistance, MemoryStack scratch);
;;;152    
;;;153          // Methods to parse an input binary image per-row, updating this object's global list as it goes
;;;154          //
;;;155          // WARNING:
;;;156          // The memory allocated in Extract2dComponents_PerRow_Initialize() must be valid until
;;;157          // Extract2dComponents_PerRow_Finalize() is called. It does not have to be in the same
;;;158          // location as the memory used by the constructor
;;;159          // Note: fastMemory and slowMemory can be the same object pointing to the same memory
;;;160          Result Extract2dComponents_PerRow_Initialize(MemoryStack &fastMemory, MemoryStack &slowerMemory, MemoryStack &slowestMemory);
;;;161          Result Extract2dComponents_PerRow_NextRow(const u8 * restrict binaryImageRow, const s32 imageWidth, const s16 whichRow, const s16 minComponentWidth, const s16 maxSkipDistance);
;;;162          Result Extract2dComponents_PerRow_Finalize();
;;;163    
;;;164          // Sort the components by id (the ids are sorted in increasing value, but with zero at the end {1...MAX_VALUE,0}), then y, then xStart
;;;165          // WARNING: This method is really slow if called first. If you have the memory available, call SortConnectedComponentSegmentsById() first.
;;;166          Result SortConnectedComponentSegments();
;;;167    
;;;168          // Sort the components by id. This will retain the original ordering as well, so if the
;;;169          // components are already sorted in y, the output of this method will be sorted in id and y.
;;;170          // Requires numValidComponentSegments*sizeof(ConnectedComponentSegment<u16>) bytes of scratch
;;;171          Result SortConnectedComponentSegmentsById(MemoryStack scratch);
;;;172    
;;;173          // The list of components may have unused ids. This function compresses the set of ids, so that
;;;174          // max(ids) == numberOfUniqueValues(ids). For example, the list of ids {0,4,5,7} would be
;;;175          // changed to {0,1,2,3}.
;;;176          //
;;;177          // For a ConnectedComponent that has a maximum id of N, this function requires
;;;178          // 3n + 1 bytes of scratch.
;;;179          //
;;;180          // TODO: If scratch usage is a bigger issue than computation time, this could be done with a bitmask
;;;181          Result CompressConnectedComponentSegmentIds(MemoryStack scratch);
;;;182    
;;;183          // Iterate through components, and compute the number of pixels for each component
;;;184          // componentSizes must be at least sizeof(s32)*(maximumdId+1) bytes
;;;185          // NOTE: this is probably inefficient, compared with interlacing the loops in a kernel
;;;186          Result ComputeComponentSizes(FixedLengthList<s32> &componentSizes);
;;;187    
;;;188          // Iterate through components, and compute the centroid of each component componentCentroids
;;;189          // must be at least sizeof(Point<s16>)*(maximumdId+1) bytes
;;;190          // NOTE: this is probably inefficient, compared with interlacing the loops in a kernel
;;;191          //
;;;192          // For a ConnectedComponent that has a maximum id of N, this function requires
;;;193          // 4n + 4 bytes of scratch.
;;;194          Result ComputeComponentCentroids(FixedLengthList<Point<s16> > &componentCentroids, MemoryStack scratch);
;;;195    
;;;196          // Iterate through components, and compute bounding box for each component
;;;197          // componentBoundingBoxes must be at least sizeof(Rectangle<s16>)*(maximumdId+1) bytes
;;;198          // NOTE: this is probably inefficient, compared with interlacing the loops in a kernel
;;;199          Result ComputeComponentBoundingBoxes(FixedLengthList<Rectangle<s16> > &componentBoundingBoxes);
;;;200    
;;;201          // Iterate through components, and compute the number of componentSegments that have each id
;;;202          // componentSizes must be at least sizeof(s32)*(maximumdId+1) bytes
;;;203          // NOTE: this is probably inefficient, compared with interlacing the loops in a kernel
;;;204          Result ComputeNumComponentSegmentsForEachId(FixedLengthList<s32> &numComponentSegments);
;;;205    
;;;206          // Goes through the list components, and computes the number of pixels for each.
;;;207          // For any componentId with less than minimumNumPixels pixels, all ConnectedComponentSegment<u16> with that id will have their ids set to zero
;;;208          //
;;;209          // For a ConnectedComponent that has a maximum id of N, this function requires
;;;210          // 4n + 4 bytes of scratch.
;;;211          Result InvalidateSmallOrLargeComponents(const s32 minimumNumPixels, const s32 maximumNumPixels, MemoryStack scratch);
;;;212    
;;;213          // Goes through the list components, and computes the "solidness", which is the ratio of
;;;214          // "numPixels / (boundingWidth*boundingHeight)". For any componentId with that is too solid or
;;;215          // sparse (opposite of solid), all ConnectedComponentSegment<u16> with that id will have their ids
;;;216          // set to zero
;;;217          //
;;;218          // The SQ26.5 parameter sparseMultiplyThreshold is set so that a component is invalid if
;;;219          // "sparseMultiplyThreshold*numPixels < boundingWidth*boundingHeight". A resonable value is
;;;220          // between 5<<5 = 160 and 100<<5 = 3200.
;;;221          //
;;;222          // The SQ26.5 parameter solidMultiplyThreshold is set so that a component is invalid if
;;;223          // "solidMultiplyThreshold*numPixels > boundingWidth*boundingHeight". A resonable value is
;;;224          // between 1.5*pow(2,5) = 48 and 5<<5 = 160.
;;;225          //
;;;226          // NOTE: This can overflow if the number of pixels is greater than 2^26 (a bit more Ultra-HD
;;;227          //       resolution)
;;;228          //
;;;229          // For a ConnectedComponent that has a maximum id of N, this function requires 8N + 8 bytes
;;;230          // of scratch.
;;;231          Result InvalidateSolidOrSparseComponents(const s32 sparseMultiplyThreshold, const s32 solidMultiplyThreshold, MemoryStack scratch);
;;;232    
;;;233          // If a component doesn't have a hollow center, it's not a fiducial. Based on a component's
;;;234          // centroid, and its maximum extent, this method makes sure no componentSegment is inside of
;;;235          // an inner rectangle. For example, take a component centered at (50,50), that is 20 pixels
;;;236          // wide and high. If percentHorizontal=0.5 and percentVertical=0.25, then no componentSegment
;;;237          // should intersect the rectangle between (40,45) and (60,55).
;;;238          //
;;;239          // percentHorizontal and percentVertical are SQ23.8,
;;;240          // and should range from (0.0, 1.0), non-inclusive
;;;241          //
;;;242          // For a ConnectedComponent that has a maximum id of N, this function requires 10N + 10 bytes
;;;243          // of scratch.
;;;244          Result InvalidateFilledCenterComponents_shrunkRectangle(const s32 percentHorizontal, const s32 percentVertical, MemoryStack scratch);
;;;245    
;;;246          // Go along each row of components. Find the maximum difference between the end of one
;;;247          // component and the start of the next. The amount of space in the center of a component is
;;;248          // approximated as the sum of the per-row max distances, divided by the number of filled pixels.
;;;249          //
;;;250          // For example:
;;;251          // If minHollowRatio==0.5, this means that a component must have at least half as many interior as exterior pixels.
;;;252          // If minHollowRatio==1.0, this means that a component must have at least an equal number of interior and exterior pixels.
;;;253          // If minHollowRatio==2.0, this means that a component must have at least twice as many interior as exterior pixels.
;;;254          // TODO: what is a reasonable value? 1.0?
;;;255          Result InvalidateFilledCenterComponents_hollowRows(const f32 minHollowRatio, MemoryStack scratch);
;;;256    
;;;257          bool IsValid() const;
;;;258    
;;;259          Result Print() const;
;;;260    
;;;261          s32 get_maximumId() const;
;;;262    
;;;263          s32 get_size() const;
;;;264    
;;;265          bool get_useU16() const;
;;;266    
;;;267          bool get_isSortedInId() const;
;;;268          bool get_isSortedInY() const;
;;;269          bool get_isSortedInX() const;
;;;270    
;;;271          const ConnectedComponentsTemplate<u16>* get_componentsU16() const;
;;;272          const ConnectedComponentsTemplate<s32>* get_componentsS32() const;
;;;273    
;;;274          ConnectedComponentsTemplate<u16>* get_componentsU16();
;;;275          ConnectedComponentsTemplate<s32>* get_componentsS32();
;;;276    
;;;277        protected:
;;;278          // Only one of these classes will be initialized, based on the constructor
;;;279          bool useU16;
;;;280          ConnectedComponentsTemplate<u16> componentsU16;
;;;281          ConnectedComponentsTemplate<s32> componentsS32;
;;;282        }; // class ConnectedComponents
;;;283      } // namespace Embedded
;;;284    } // namespace Anki
;;;285    
;;;286    #endif // _ANKICORETECHEMBEDDED_VISION_VISIONKERNELS_CONNECTEDCOMPONENTS_DECLARATIONS_H_
;;;16     
;;;17     #include "anki/common/types.h"
;;;1      /**
;;;18     #include "anki/common/robot/memory.h"
;;;1      /**
;;;19     #include "anki/common/robot/fixedLengthList.h"
;;;1      /**
;;;2      File: fixedLengthList.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of fixedLenghtList_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_H_
;;;14     
;;;15     #include "anki/common/robot/fixedLengthList_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;1      /**
;;;2      File: utilities.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of utilities_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;14     
;;;15     #include "anki/common/robot/utilities_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;17     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;2      * File: trig_fast.h
;;;3      *
;;;4      * Author: Kevin Yoon
;;;5      * Created: 22-OCT-2012
;;;6      *
;;;7      * Some trig functions to supplement incomplete math libraries on embedded targets.
;;;8      * Error of all functions is less than +/- 0.01.
;;;9      * For bettery accuracy, lookup tables should be regenerated with u16.
;;;10     *
;;;11     **/
;;;12     #ifndef _TRIG_FAST_H
;;;13     #define _TRIG_FAST_H
;;;14     
;;;15     // When USE_SMALL_LUT defined, a smaller lookup table is used to conserve space.
;;;16     // USE_INTERPOLATION is also automatically defined, since without it answers are probably too wrong to be useful.
;;;17     // If USE_SMALL_LUT is not defined, a large LUT is used.
;;;18     //#define USE_SMALL_LUT
;;;19     
;;;20     // When defined, interpolates between lookup values for higher accuracy.
;;;21     #define USE_INTERPOLATION
;;;22     
;;;23     // Arctangent function based on lookup table
;;;24     // returns answer in radians
;;;25     float atan_fast(float x);
;;;26     
;;;27     // Arcsine function based on lookup table
;;;28     // returns answer in radians
;;;29     float asin_fast(float x);
;;;30     
;;;31     // Arctangent function which uses atan_fast
;;;32     // returns answer in radians
;;;33     float atan2_fast(float y, float x);
;;;34     
;;;35     // Arctangent function which uses asin from math.h
;;;36     // Useful on embedded systems that don't include atan2 in math.h
;;;37     // More accurate than atan2_fast.
;;;38     // Nothing particularly fast about this implementation.
;;;39     // returns answer in radians
;;;40     float atan2_acc(float y, float x);
;;;41     
;;;42     #endif
;;;19     
;;;20     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;21     #include "opencv2/core/core.hpp"
;;;22     #endif
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         //template<typename Type> inline Type RoundUp(const Type number, const Type multiple)
;;;29     
;;;30         // void* and size_t is a special case, good for aligning pointers
;;;31         inline const void* RoundUp(const void* number, const size_t multiple)
;;;32         {
;;;33           const size_t numberT = reinterpret_cast<size_t>(number);
;;;34           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;35         }
;;;36     
;;;37         inline void* RoundUp(void* number, const size_t multiple)
;;;38         {
;;;39           const size_t numberT = reinterpret_cast<size_t>(number);
;;;40           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;41         }
;;;42     
;;;43         template<> inline u32 RoundUp(const u32 number, const u32 multiple)
;;;44         {
;;;45           return (number + (multiple-1)) & ~(multiple-1);
;;;46         }
;;;47     
;;;48         template<> inline s32 RoundUp(const s32 number, const s32 multiple)
;;;49         {
;;;50           if(number <= 0) {
;;;51             return multiple*( number/multiple );
;;;52           } else {
;;;53             return multiple*( (number-1)/multiple + 1 );
;;;54           }
;;;55         }
;;;56     
;;;57     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;58         template<> inline unsigned long RoundUp(const unsigned long number, const unsigned long multiple)
;;;59         {
;;;60           return (number + (multiple-1)) & ~(multiple-1);
;;;61         }
;;;62     #endif
;;;63     
;;;64         template<> inline u32 RoundDown(const u32 number, const u32 multiple)
;;;65         {
;;;66           return multiple * (number/multiple);
;;;67         }
;;;68     
;;;69         template<> inline s32 RoundDown(const s32 number, const s32 multiple)
;;;70         {
;;;71           if(number < 0) {
;;;72             return multiple * ((number-multiple+1) / multiple);
;;;73           } else {
;;;74             return multiple * (number/multiple);
;;;75           }
;;;76         }
;;;77     
;;;78     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;79         template<> inline unsigned long RoundDown(const unsigned long number, const unsigned long multiple)
;;;80         {
;;;81           return multiple * (number/multiple);
;;;82         }
;;;83     #endif
;;;84     
;;;85         template<typename Type> Type ApproximateExp(const Type exponent, const s32 numTerms)
;;;86         {
;;;87           AnkiAssert(numTerms > 2);
;;;88     
;;;89           const Type exponentAbs = ABS(exponent);
;;;90     
;;;91           Type sum = static_cast<Type>(1) + exponentAbs;
;;;92     
;;;93           Type numerator = static_cast<Type>(exponentAbs);
;;;94           Type denominator = static_cast<Type>(1);
;;;95           for(s32 i=2; i<=numTerms; i++) {
;;;96             numerator *= exponentAbs;
;;;97             denominator *= i;
;;;98     
;;;99             sum += numerator / denominator;
;;;100          }
;;;101    
;;;102          if(exponent < 0) {
;;;103            sum = static_cast<Type>(1) / sum;
;;;104          }
;;;105    
;;;106          return sum;
;;;107        }
;;;108    
;;;109        template<typename Type> void Swap(Type &a, Type &b)
;;;110        {
;;;111          const Type tmp = a;
;;;112          a = b;
;;;113          b = tmp;
;;;114        } // template<typename Type> Swap(Type a, Type b)
;;;115    
;;;116        template<typename Type> u32 BinaryStringToUnsignedNumber(const FixedLengthList<Type> &bits, bool firstBitIsLow)
;;;117        {
;;;118          u32 number = 0;
;;;119    
;;;120          const s32 numBits = bits.get_size();
;;;121    
;;;122          for(s32 bit=0; bit<numBits; bit++) {
;;;123            if(firstBitIsLow) {
;;;124              if(bit == 0) {
;;;125                number += bits[bit];
;;;126              } else {
;;;127                number += bits[bit] << bit;
;;;128              }
;;;129            } else {
;;;130              if(bit == (numBits-1)) {
;;;131                number += bits[bit];
;;;132              } else {
;;;133                number += bits[bit] << (numBits - bit - 1);
;;;134              }
;;;135            }
;;;136          }
;;;137    
;;;138          return number;
;;;139        }
;;;140    
;;;141        template<typename Type> Type Determinant2x2(const Type a, const Type b, const Type c, const Type d)
;;;142        {
;;;143          return a*d - b*c;
;;;144        }
;;;145    
;;;146        template<typename Type> Type Determinant3x3(const Type a, const Type b, const Type c, const Type d, const Type e, const Type f, const Type g, const Type h, const Type i)
;;;147        {
;;;148          return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
;;;149        }
;;;150    
;;;151        template<typename Type> void Invert3x3(Type &a, Type &b, Type &c, Type &d, Type &e, Type &f, Type &g, Type &h, Type &i)
;;;152        {
;;;153          const Type determinant = Determinant3x3(a,b,c,d,e,f,g,h,i);
;;;154          const Type determinantInverse = static_cast<Type>(1) / determinant;
;;;155    
;;;156          const Type A =  (e*i - f*h);
;;;157          const Type B = -(d*i - f*g);
;;;158          const Type C =  (d*h - e*g);
;;;159          const Type D = -(b*i - c*h);
;;;160          const Type E =  (a*i - c*g);
;;;161          const Type F = -(a*h - b*g);
;;;162          const Type G =  (b*f - c*e);
;;;163          const Type H = -(a*f - c*d);
;;;164          const Type I =  (a*e - b*d);
;;;165    
;;;166          a = A * determinantInverse;
;;;167          b = D * determinantInverse;
;;;168          c = G * determinantInverse;
;;;169          d = B * determinantInverse;
;;;170          e = E * determinantInverse;
;;;171          f = H * determinantInverse;
;;;172          g = C * determinantInverse;
;;;173          h = F * determinantInverse;
;;;174          i = I * determinantInverse;
;;;175        }
;;;176    
;;;177        template<typename Type> void Cart2Pol(const Type x, const Type y, Type &rho, Type &theta)
;;;178        {
;;;179          if (x==0 && y==0) {
;;;180            theta = 0;
;;;181            rho = 0;
;;;182          } else {
;;;183            theta = atan2f(y, x);
;;;184            rho = sqrtf(x*x + y*y);
;;;185          }
;;;186        }
;;;187    
;;;188        template<typename Type> void Pol2Cart(const Type rho, const Type theta, Type &x, Type &y)
;;;189        {
;;;190          x = rho * cosf(theta);
;;;191          y = rho * sinf(theta);
;;;192        }
;;;193    
;;;194        inline s32 FloorS32(f32 x)
;;;195        {
;;;196          return static_cast<s32>(floorf(x));
;;;197        }
;;;198    
;;;199        inline s32 CeilS32(f32 x)
;;;200        {
;;;201          return static_cast<s32>(ceilf(x));
;;;202        }
;;;203    
;;;204    #if !defined(__EDG__)
;;;205        // Some platforms may not round to zero correctly, so do the function calls
;;;206        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(floorf(v + 0.5f)) : 0; }
;;;207        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(floorf(v + 0.5f)) : 0; }
;;;208        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(floorf(v + 0.5f)) : static_cast<s32>(ceilf(v - 0.5f)); }
;;;209        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(floorf(v + 0.5f)) : static_cast<s64>(ceilf(v - 0.5f)); }
;;;210        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;211        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;212    
;;;213        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(floor(v + 0.5)) : 0; }
;;;214        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(floor(v + 0.5)) : 0; }
;;;215        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(floor(v + 0.5)) : static_cast<s32>(ceil(v - 0.5)); }
;;;216        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(floor(v + 0.5)) : static_cast<s64>(ceil(v - 0.5)); }
;;;217        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;218        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;219    #else
;;;220        // The M4 rounds to zero correctly, without the function calls
;;;221        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(v + 0.5f) : 0; }
;;;222        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(v + 0.5f) : 0; }
;;;223        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(v + 0.5f) : static_cast<s32>(v - 0.5f); }
;;;224        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(v + 0.5f) : static_cast<s64>(v - 0.5f); }
;;;225        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;226        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;227    
;;;228        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(v + 0.5) : 0; }
;;;229        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(v + 0.5) : 0; }
;;;230        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(v + 0.5) : static_cast<s32>(v - 0.5); }
;;;231        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(v + 0.5) : static_cast<s64>(v - 0.5); }
;;;232        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;233        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;234    #endif
;;;235    
;;;236        // Most cases of RoundIfInteger are from int-to-int or float-to-float, so just do a normal cast
;;;237        template<typename Type> inline Type RoundIfInteger(const u8  v) { return static_cast<Type>(v); }
;;;238        template<typename Type> inline Type RoundIfInteger(const s8  v) { return static_cast<Type>(v); }
;;;239        template<typename Type> inline Type RoundIfInteger(const u16 v) { return static_cast<Type>(v); }
;;;240        template<typename Type> inline Type RoundIfInteger(const s16 v) { return static_cast<Type>(v); }
;;;241        template<typename Type> inline Type RoundIfInteger(const u32 v) { return static_cast<Type>(v); }
;;;242        template<typename Type> inline Type RoundIfInteger(const s32 v) { return static_cast<Type>(v); }
;;;243        template<typename Type> inline Type RoundIfInteger(const u64 v) { return static_cast<Type>(v); }
;;;244        template<typename Type> inline Type RoundIfInteger(const s64 v) { return static_cast<Type>(v); }
;;;245        template<typename Type> inline Type RoundIfInteger(const f32 v) { return static_cast<Type>(v); }
;;;246        template<typename Type> inline Type RoundIfInteger(const f64 v) { return static_cast<Type>(v); }
;;;247    
;;;248        // Specialize for cases with float-to-int
;;;249        template<> inline u8  RoundIfInteger(const f32 v) { return static_cast<u8> (Round<s32>(v)); }
;;;250        template<> inline s8  RoundIfInteger(const f32 v) { return static_cast<s8> (Round<s32>(v)); }
;;;251        template<> inline u16 RoundIfInteger(const f32 v) { return static_cast<u16>(Round<s32>(v)); }
;;;252        template<> inline s16 RoundIfInteger(const f32 v) { return static_cast<s16>(Round<s32>(v)); }
;;;253        template<> inline u32 RoundIfInteger(const f32 v) { return static_cast<u32>(Round<u32>(v)); }
;;;254        template<> inline s32 RoundIfInteger(const f32 v) { return static_cast<s32>(Round<s32>(v)); }
;;;255        template<> inline u64 RoundIfInteger(const f32 v) { return static_cast<u64>(Round<u64>(v)); }
;;;256        template<> inline s64 RoundIfInteger(const f32 v) { return static_cast<s64>(Round<s64>(v)); }
;;;257    
;;;258        template<> inline u8  RoundIfInteger(const f64 v) { return static_cast<u8> (Round<s32>(v)); }
;;;259        template<> inline s8  RoundIfInteger(const f64 v) { return static_cast<s8> (Round<s32>(v)); }
;;;260        template<> inline u16 RoundIfInteger(const f64 v) { return static_cast<u16>(Round<s32>(v)); }
;;;261        template<> inline s16 RoundIfInteger(const f64 v) { return static_cast<s16>(Round<s32>(v)); }
;;;262        template<> inline u32 RoundIfInteger(const f64 v) { return static_cast<u32>(Round<u32>(v)); }
;;;263        template<> inline s32 RoundIfInteger(const f64 v) { return static_cast<s32>(Round<s32>(v)); }
;;;264        template<> inline u64 RoundIfInteger(const f64 v) { return static_cast<u64>(Round<u64>(v)); }
;;;265        template<> inline s64 RoundIfInteger(const f64 v) { return static_cast<s64>(Round<s64>(v)); }
;;;266    
;;;267        // Floats and complex data types aren't specialized
;;;268        template<typename Type> inline Type saturate_cast(const u8  v) { return static_cast<Type>(v); }
;;;269        template<typename Type> inline Type saturate_cast(const s8  v) { return static_cast<Type>(v); }
;;;270        template<typename Type> inline Type saturate_cast(const u16 v) { return static_cast<Type>(v); }
;;;271        template<typename Type> inline Type saturate_cast(const s16 v) { return static_cast<Type>(v); }
;;;272        template<typename Type> inline Type saturate_cast(const u32 v) { return static_cast<Type>(v); }
;;;273        template<typename Type> inline Type saturate_cast(const s32 v) { return static_cast<Type>(v); }
;;;274        template<typename Type> inline Type saturate_cast(const u64 v) { return static_cast<Type>(v); }
;;;275        template<typename Type> inline Type saturate_cast(const s64 v) { return static_cast<Type>(v); }
;;;276        template<typename Type> inline Type saturate_cast(const f32 v) { return static_cast<Type>(v); }
;;;277        template<typename Type> inline Type saturate_cast(const f64 v) { return static_cast<Type>(v); }
;;;278    
;;;279        // Most saturate_cast calls are explicitly specialized
;;;280        template<> inline u8  saturate_cast<u8> (const u8  v) { return v; }
;;;281        template<> inline u8  saturate_cast<u8> (const u16 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;282        template<> inline u8  saturate_cast<u8> (const u32 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;283        template<> inline u8  saturate_cast<u8> (const u64 v) { return (u8)             MIN((u64)u8_MAX, (u64)v); }
;;;284        template<> inline u8  saturate_cast<u8> (const s8  v) { return (u8)                              MAX((s32)0, (s32)v);  }
;;;285        template<> inline u8  saturate_cast<u8> (const s16 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;286        template<> inline u8  saturate_cast<u8> (const s32 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;287        template<> inline u8  saturate_cast<u8> (const s64 v) { return (u8)             MIN((s64)u8_MAX, MAX((s64)0, (s64)v)); }
;;;288        template<> inline u8  saturate_cast<u8> (const f32 v) { return (u8) Round<s32>( MIN((f32)u8_MAX, MAX((f32)0, (f32)v)) ); }
;;;289        template<> inline u8  saturate_cast<u8> (const f64 v) { return (u8) Round<s32>( MIN((f64)u8_MAX, MAX((f64)0, (f64)v)) ); }
;;;290    
;;;291        template<> inline s8  saturate_cast<s8> (const u8  v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;292        template<> inline s8  saturate_cast<s8> (const u16 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;293        template<> inline s8  saturate_cast<s8> (const u32 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;294        template<> inline s8  saturate_cast<s8> (const u64 v) { return (s8)             MIN((u64)s8_MAX, (u64)v); }
;;;295        template<> inline s8  saturate_cast<s8> (const s8  v) { return v; }
;;;296        template<> inline s8  saturate_cast<s8> (const s16 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;297        template<> inline s8  saturate_cast<s8> (const s32 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;298        template<> inline s8  saturate_cast<s8> (const s64 v) { return (s8)             MIN((s64)s8_MAX, MAX((s64)s8_MIN, (s64)v)); }
;;;299        template<> inline s8  saturate_cast<s8> (const f32 v) { return (s8) Round<s32>( MIN((f32)s8_MAX, MAX((f32)s8_MIN, (f32)v)) ); }
;;;300        template<> inline s8  saturate_cast<s8> (const f64 v) { return (s8) Round<s32>( MIN((f64)s8_MAX, MAX((f64)s8_MIN, (f64)v)) ); }
;;;301    
;;;302        template<> inline u16 saturate_cast<u16>(const u8  v) { return v; }
;;;303        template<> inline u16 saturate_cast<u16>(const u16 v) { return v; }
;;;304        template<> inline u16 saturate_cast<u16>(const u32 v) { return (u16)             MIN((u32)u16_MAX, (u32)v); }
;;;305        template<> inline u16 saturate_cast<u16>(const u64 v) { return (u16)             MIN((u64)u16_MAX, (u64)v); }
;;;306        template<> inline u16 saturate_cast<u16>(const s8  v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;307        template<> inline u16 saturate_cast<u16>(const s16 v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;308        template<> inline u16 saturate_cast<u16>(const s32 v) { return (u16)             MIN((s32)u16_MAX, MAX((s32)0, (s32)v)); }
;;;309        template<> inline u16 saturate_cast<u16>(const s64 v) { return (u16)             MIN((s64)u16_MAX, MAX((s64)0, (s64)v)); }
;;;310        template<> inline u16 saturate_cast<u16>(const f32 v) { return (u16) Round<s32>( MIN((f32)u16_MAX, MAX((f32)0, (f32)v)) ); }
;;;311        template<> inline u16 saturate_cast<u16>(const f64 v) { return (u16) Round<s32>( MIN((f64)u16_MAX, MAX((f64)0, (f64)v)) ); }
;;;312    
;;;313        template<> inline s16 saturate_cast<s16>(const u8  v) { return v; }
;;;314        template<> inline s16 saturate_cast<s16>(const u16 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;315        template<> inline s16 saturate_cast<s16>(const u32 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;316        template<> inline s16 saturate_cast<s16>(const u64 v) { return (s16)             MIN((u64)s16_MAX, (u64)v); }
;;;317        template<> inline s16 saturate_cast<s16>(const s8  v) { return v; }
;;;318        template<> inline s16 saturate_cast<s16>(const s16 v) { return v; }
;;;319        template<> inline s16 saturate_cast<s16>(const s32 v) { return (s16)             MIN((s32)s16_MAX, MAX((s32)s16_MIN, (s32)v)); }
;;;320        template<> inline s16 saturate_cast<s16>(const s64 v) { return (s16)             MIN((s64)s16_MAX, MAX((s64)s16_MIN, (s64)v)); }
;;;321        template<> inline s16 saturate_cast<s16>(const f32 v) { return (s16) Round<s32>( MIN((f32)s16_MAX, MAX((f32)s16_MIN, (f32)v)) ); }
;;;322        template<> inline s16 saturate_cast<s16>(const f64 v) { return (s16) Round<s32>( MIN((f64)s16_MAX, MAX((f64)s16_MIN, (f64)v)) ); }
;;;323    
;;;324        template<> inline u32 saturate_cast<u32>(const u8  v) { return v; }
;;;325        template<> inline u32 saturate_cast<u32>(const u16 v) { return v; }
;;;326        template<> inline u32 saturate_cast<u32>(const u32 v) { return v; }
;;;327        template<> inline u32 saturate_cast<u32>(const u64 v) { return (u32)             MIN((u64)u32_MAX, (u64)v); }
;;;328        template<> inline u32 saturate_cast<u32>(const s8  v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;329        template<> inline u32 saturate_cast<u32>(const s16 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;330        template<> inline u32 saturate_cast<u32>(const s32 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;331        template<> inline u32 saturate_cast<u32>(const s64 v) { return (u32)             MIN((s64)u32_MAX, MAX((s64)0, (s64)v)); }
;;;332        template<> inline u32 saturate_cast<u32>(const f32 v) { return (u32) (v > (f32)0xFFFFFF7F) ? 0xFFFFFFFF : Round<u32>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;333        template<> inline u32 saturate_cast<u32>(const f64 v) { return (u32) Round<u32>( MIN((f64)u32_MAX, MAX((f64)0, (f64)v)) ); }
;;;334    
;;;335        template<> inline s32 saturate_cast<s32>(const u8  v) { return v; }
;;;336        template<> inline s32 saturate_cast<s32>(const u16 v) { return v; }
;;;337        template<> inline s32 saturate_cast<s32>(const u32 v) { return (s32)             MIN((u32)s32_MAX, (u32)v); }
;;;338        template<> inline s32 saturate_cast<s32>(const u64 v) { return (s32)             MIN((u64)s32_MAX, (u64)v); }
;;;339        template<> inline s32 saturate_cast<s32>(const s8  v) { return v; }
;;;340        template<> inline s32 saturate_cast<s32>(const s16 v) { return v; }
;;;341        template<> inline s32 saturate_cast<s32>(const s32 v) { return v; }
;;;342        template<> inline s32 saturate_cast<s32>(const s64 v) { return (s32)             MIN((s64)s32_MAX, MAX((s64)s32_MIN, (s64)v)); }
;;;343        template<> inline s32 saturate_cast<s32>(const f32 v) { return (s32) (v > (f32)0x7FFFFFBF) ? 0x7FFFFFFF : Round<s32>(MAX((f32)s32_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;344        template<> inline s32 saturate_cast<s32>(const f64 v) { return (s32) Round<s32>( MIN((f64)s32_MAX, MAX((f64)s32_MIN, (f64)v)) ); }
;;;345    
;;;346        template<> inline u64 saturate_cast<u64>(const u8  v) { return v; }
;;;347        template<> inline u64 saturate_cast<u64>(const u16 v) { return v; }
;;;348        template<> inline u64 saturate_cast<u64>(const u32 v) { return v; }
;;;349        template<> inline u64 saturate_cast<u64>(const u64 v) { return v; }
;;;350        template<> inline u64 saturate_cast<u64>(const s8  v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;351        template<> inline u64 saturate_cast<u64>(const s16 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;352        template<> inline u64 saturate_cast<u64>(const s32 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;353        template<> inline u64 saturate_cast<u64>(const s64 v) { return (u64)                               MAX((s64)0, (s64)v);  }
;;;354        template<> inline u64 saturate_cast<u64>(const f32 v) { return (u64) (v > (f32)0XFFFFFF7FFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;355        template<> inline u64 saturate_cast<u64>(const f64 v) { return (u64) (v > (f64)0xFFFFFFFFFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f64)0, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;356    
;;;357        template<> inline s64 saturate_cast<s64>(const u8  v) { return v; }
;;;358        template<> inline s64 saturate_cast<s64>(const u16 v) { return v; }
;;;359        template<> inline s64 saturate_cast<s64>(const u32 v) { return v; }
;;;360        template<> inline s64 saturate_cast<s64>(const u64 v) { return (s64)             MIN((u64)s64_MAX, (u64)v); }
;;;361        template<> inline s64 saturate_cast<s64>(const s8  v) { return v; }
;;;362        template<> inline s64 saturate_cast<s64>(const s16 v) { return v; }
;;;363        template<> inline s64 saturate_cast<s64>(const s32 v) { return v; }
;;;364        template<> inline s64 saturate_cast<s64>(const s64 v) { return v; }
;;;365        template<> inline s64 saturate_cast<s64>(const f32 v) { return (s64) (v > (f32)0x7FFFFFBFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f32)s64_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;366        template<> inline s64 saturate_cast<s64>(const f64 v) { return (s64) (v > (f64)0x7FFFFFFFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f64)s64_MIN, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;367    
;;;368        template<> inline f32 saturate_cast(const f64 v) { return (f32) MIN((f64)FLT_MAX, MAX(-(f64)FLT_MAX, (f64)v)); }
;;;369      } // namespace Embedded
;;;370    } // namespace Anki
;;;371    
;;;372    #endif // _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;18     #include "anki/common/robot/memory.h"
;;;1      /**
;;;19     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;20     #include "anki/common/robot/geometry.h"
;;;1      /**
;;;2      File: geometry.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of geometry_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/geometry_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/memory.h"
;;;1      /**
;;;18     #include "anki/common/robot/matrix.h"
;;;1      /**
;;;2      File: matrix.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of matrix_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;14     
;;;15     #include "anki/common/robot/matrix_declarations.h"
;;;1      /**
;;;2      File: matrix_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various Matrix operations, such as matrix multiply and addition.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         namespace Matrix
;;;24         {
;;;25           // #pragma mark --- Declarations ---
;;;26     
;;;27           //
;;;28           // Simple matrix statistics
;;;29           //
;;;30     
;;;31           // Return the minimum element in this Array
;;;32           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat);
;;;33     
;;;34           // Return the maximum element in this Array
;;;35           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat);
;;;36     
;;;37           // Return the sum of every element in the Array
;;;38           template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat);
;;;39     
;;;40           // Return the mean of every element in the Array
;;;41           template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat);
;;;42     
;;;43           // Simultaneously compute the mean and variance of every element in the Array
;;;44           template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(const ConstArraySliceExpression<Array_Type> &mat,
;;;45             Accumulator_Type& mean, Accumulator_Type& var);
;;;46     
;;;47           //
;;;48           // Elementwise matrix operations
;;;49           //
;;;50     
;;;51           // Elementwise add two arrays. in1, in2, and out can be the same array
;;;52           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;53           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;54           template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;55     
;;;56           // Elementwise subtract two arrays. in1, in2, and out can be the same array
;;;57           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;58           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;59           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;60     
;;;61           // Elementwise multiply two arrays. in1, in2, and out can be the same array
;;;62           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;63           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;64           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;65     
;;;66           // Elementwise divide two arrays. in1, in2, and out can be the same array
;;;67           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;68           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;69           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;70     
;;;71           // Elementwise exponential on an array
;;;72           template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;73     
;;;74           // Elementwise square root on an array
;;;75           template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;76     
;;;77           //
;;;78           // Standard matrix operations
;;;79           //
;;;80     
;;;81           // Perform the matrix multiplication "out = in1 * in2"
;;;82           // Note that this is the naive O(n^3) Definition
;;;83           template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out);
;;;84     
;;;85           // Perform the matrix multiplication "out = in1 * in2'"
;;;86           // Note that this is the naive O(n^3) Definition
;;;87           // MultiplyTranspose has better access patterns than Multiply for certain types of arrays, so could be a lot faster (and easier to accelerate)
;;;88           template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out);
;;;89     
;;;90           //
;;;91           // Rotation Matrices
;;;92           //
;;;93     
;;;94           // TODO: Add other rotation-related math, like Rodrigues' formula, or Pose chaining...
;;;95     
;;;96           // Compute the three Euler angles from a given 3x3 Rotation Matrix.
;;;97           Result GetEulerAngles(const Array<f32>& R, f32& angle_x, f32& angle_y, f32& angle_z);
;;;98     
;;;99           //
;;;100          // Linear Algebra and Linear Solvers
;;;101          //
;;;102    
;;;103          // Compute the Cholesky-Banachiewicz decomposition, to return a lower-triangular matrix L such that A=L*L'
;;;104          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;105            Array<Type> &A_L,      //!< Input A Matrix and Output lower-triangular L matrix
;;;106            Array<Type> &Bt_Xt,    //!< Input B-transpose matrix and Output X-transpose solution
;;;107            bool realCholesky,     //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;108            bool &numericalFailure //!< If true, the solver failed because of numerical instability
;;;109            );
;;;110    
;;;111          // Compute the homography such that "transformedPoints = homography * originalPoints"
;;;112          //
;;;113          // WARNING: This uses the inhomogeneous solution and the Cholesky decomposition, therefore it
;;;114          //          will be incorrect if H_33 is zero, which happens in certain cases of lines at
;;;115          //          inifinty. For more details, see Multiple View Geometry 2nd Edition, Example 4.1
;;;116          template<typename Type> Result EstimateHomography(
;;;117            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;118            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;119            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;120            bool &numericalFailure, //!< Did the homography solver fail?
;;;121            MemoryStack scratch //!< Scratch memory
;;;122            );
;;;123    
;;;124          //template<typename InType, typename IntermediateType, typename OutType> Result CholeskyDecomposition(
;;;125          //  const Array<InType> &A,                    //!< Input A Matrix
;;;126          //  Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;127          //  Array<OutType> &L                          //!< Output lower-triangular L matrix
;;;128          //  );
;;;129    
;;;130          //template<typename InType, typename IntermediateType, typename OutType> Result SolveWithLowerTriangular(
;;;131          //  const Array<InType> &L,                          //!< Input lower-triangular L matrix (such as computed by CholeskyDecomposition)
;;;132          //  const Array<InType> &b,                          //!< Input b matrix
;;;133          //  const Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;134          //  Array<OutType> &x                                //!< Output x solution
;;;135          //  );
;;;136    
;;;137          // Solves Ax = b
;;;138          // Specifically, it uses SVD to minimize ||Ax - b||
;;;139          // Note that the A, b, and x matrices are transposed (this is because for large numbers of samples, transposed inputs are liable to be faster)
;;;140          //Result SolveLeastSquaresWithSVD_f32(Array<f32> &At, const Array<f32> &bt, Array<f32> &xt, MemoryStack scratch);
;;;141          //Result SolveLeastSquaresWithSVD_f64(Array<f64> &At, const Array<f64> &bt, Array<f64> &xt, MemoryStack scratch);
;;;142    
;;;143          //
;;;144          // Matrix structure operations
;;;145          //
;;;146    
;;;147          // matlab equivalent: out = reshape(in, [M,N]);
;;;148          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;149          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory);
;;;150    
;;;151          // matlab equivalent: out = in(:);
;;;152          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;153          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory);
;;;154    
;;;155          // Perform an immediate matrix transpose (unlike the lazy transpose of ArraySlice)
;;;156          // in and out must be different Array objects
;;;157          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out);
;;;158    
;;;159          // Rotate an array clockwise by 90, 180, or 270 degrees.
;;;160          // NOTE: Only works for a square matrix.
;;;161          // NOTE: In and out must be different arrays (unlike the interview question)
;;;162          template<typename InType, typename OutType> Result Rotate90( const Array<InType> &in, Array<OutType> &out);
;;;163          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out);
;;;164          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out);
;;;165    
;;;166          //
;;;167          // Misc matrix operations
;;;168          //
;;;169    
;;;170          // Works the same as the Matlab sort() for matrices.
;;;171          // InsertionSort(X) sorts each column of X in ascending order.
;;;172          // The minIndex and maxIndex are for the sortWhichDimension. maxIndex is automatically clipped to the size of the input Array.
;;;173          // NOTE: this currently uses insertion sort, so may be slow for large, badly-unsorted arrays
;;;174          template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;175    
;;;176          // Subsections less-than-or-equal-to insertionSortSize are sorted with insertion sort
;;;177          template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;178    
;;;179          // indexes must be allocated, but will be overwritten by InsertionSort()
;;;180          template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;181    
;;;182          template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;183    
;;;184          // For a square array, either:
;;;185          // 1. When lowerToUpper==true,  copies the lower (left)  triangle to the upper (right) triangle
;;;186          // 2. When lowerToUpper==false, copies the upper (right) triangle to the lower (left)  triangle
;;;187          // Functionally the same as OpenCV completeSymm()
;;;188          template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper = false);
;;;189    
;;;190          // There's probably no need to use these directly. Instead, use the normal Matrix:: operations, like Matrix::Add
;;;191          namespace Elementwise
;;;192          {
;;;193            template<typename InType, typename IntermediateType, typename OutType> class Add {
;;;194            public:
;;;195              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) + static_cast<IntermediateType>(value2));}
;;;196            };
;;;197    
;;;198            template<typename InType, typename IntermediateType, typename OutType> class Subtract {
;;;199            public:
;;;200              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) - static_cast<IntermediateType>(value2));}
;;;201            };
;;;202    
;;;203            template<typename InType, typename IntermediateType, typename OutType> class DotMultiply {
;;;204            public:
;;;205              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) * static_cast<IntermediateType>(value2));}
;;;206            };
;;;207    
;;;208            template<typename InType, typename IntermediateType, typename OutType> class DotDivide {
;;;209            public:
;;;210              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) / static_cast<IntermediateType>(value2));}
;;;211            };
;;;212    
;;;213            // Technically a unary operator, but we ignore the second parameter
;;;214            // TODO: if this is slow, make a unary version of ApplyOperation
;;;215            template<typename InType, typename IntermediateType, typename OutType> class Exp {
;;;216            public:
;;;217              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(expf(static_cast<IntermediateType>(value1)));}
;;;218            };
;;;219    
;;;220            template<typename InType, typename IntermediateType, typename OutType> class Sqrt {
;;;221            public:
;;;222              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(sqrtf(static_cast<IntermediateType>(value1)));}
;;;223            };
;;;224    
;;;225            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;226            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;227            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;228          } // namespace Elementwise
;;;229        } // namespace Matrix
;;;230      } // namespace Embedded
;;;231    } // namespace Anki
;;;232    
;;;233    #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;18     #include "anki/common/robot/memory.h"
;;;19     #include "anki/common/robot/errorHandling.h"
;;;20     #include "anki/common/robot/geometry.h"
;;;21     #include "anki/common/robot/utilities_c.h"
;;;22     #include "anki/common/robot/sequences.h"
;;;23     #include "anki/common/robot/matrix.h"
;;;24     #include "anki/common/robot/comparisons.h"
;;;25     
;;;26     #include "anki/common/shared/utilities_shared.h"
;;;27     
;;;28     #include "anki/common/robot/serialize_declarations.h"
;;;29     
;;;30     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;31     #include "opencv2/core/core.hpp"
;;;32     #include "opencv2/highgui/highgui.hpp"
;;;33     #include "opencv2/imgproc/imgproc.hpp"
;;;34     #include "opencv2/objdetect/objdetect.hpp"
;;;35     #endif
;;;36     
;;;37     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;38     #define ANKICORETECH_EMBEDDED_USE_MALLOC 1
;;;39     #define ANKICORETECH_EMBEDDED_USE_ZLIB 1
;;;40     #endif
;;;41     
;;;42     #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;43     #include "zlib.h"
;;;44     #endif
;;;45     
;;;46     namespace Anki
;;;47     {
;;;48       namespace Embedded
;;;49       {
;;;50         template<typename Type> class ArraySlice;
;;;51         template<typename Type> class ConstArraySlice;
;;;52         template<typename Type> class ConstArraySliceExpression;
;;;53     
;;;54         // #pragma mark --- Array Definitions ---
;;;55     
;;;56         template<typename Type> s32 Array<Type>::ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags)
;;;57         {
;;;58           AnkiConditionalErrorAndReturnValue(numCols >= 0,
;;;59             0, "Array<Type>::ComputeRequiredStride", "Invalid size");
;;;60     
;;;61           const s32 numColsCapped = MAX(numCols, 1);
;;;62     
;;;63           const s32 bufferRequired = static_cast<s32>(RoundUp<size_t>(sizeof(Type)*numColsCapped, MEMORY_ALIGNMENT));
;;;64     
;;;65           return bufferRequired;
;;;66         }
;;;67     
;;;68         template<typename Type> s32 Array<Type>::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags)
;;;69         {
;;;70           AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0,
;;;71             0, "Array<Type>::ComputeMinimumRequiredMemory", "Invalid size");
;;;72     
;;;73           const s32 numRowsCapped = MAX(numRows, 1);
;;;74     
;;;75           return numRowsCapped * Array<Type>::ComputeRequiredStride(numCols, flags);
;;;76         }
;;;77     
;;;78         template<typename Type> Array<Type>::Array()
;;;79         {
;;;80           InvalidateArray();
;;;81         }
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
;;;139        template<typename Type> Array<Type> Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;140        {
;;;141          Array<Type> newArray = Array<Type>();
;;;142    
;;;143    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;144          const cv::Mat cvImage = cv::imread(filename, CV_LOAD_IMAGE_GRAYSCALE);
;;;145    
;;;146          AnkiConditionalErrorAndReturnValue(cvImage.cols >= 0 && cvImage.rows >= 0,
;;;147            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;148    
;;;149          newArray = Array<Type>(cvImage.rows, cvImage.cols, memory);
;;;150    
;;;151          AnkiConditionalErrorAndReturnValue(newArray.IsValid(),
;;;152            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;153    
;;;154          const u8 * restrict pCvImage = cvImage.data;
;;;155    
;;;156          for(s32 y=0; y<cvImage.rows; y++) {
;;;157            Type * restrict pNewArray = newArray.Pointer(y, 0);
;;;158    
;;;159            for(s32 x=0; x<cvImage.cols; x++) {
;;;160              pNewArray[x] = static_cast<Type>(pCvImage[x]);
;;;161            }
;;;162    
;;;163            pCvImage += cvImage.step.buf[0];
;;;164          }
;;;165    #else
;;;166          AnkiError("Array<Type>::Array", "OpenCV is required to load an image from an image file");
;;;167    #endif
;;;168    
;;;169          return newArray;
;;;170        } // Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;171    
;;;172        template<typename Type> Array<Type> LoadBinaryArray_Generic(const char * filename, MemoryStack *scratch, MemoryStack *memory, void * allocatedBuffer, const s32 allocatedBufferLength)
;;;173        {
;;;174          u16  basicType_sizeOfType;
;;;175          bool basicType_isBasicType;
;;;176          bool basicType_isInteger;
;;;177          bool basicType_isSigned;
;;;178          bool basicType_isFloat;
;;;179          bool basicType_isString;
;;;180    
;;;181          Array<u8> rawArray = LoadBinaryArray_UnknownType(
;;;182            filename,
;;;183            scratch, memory,
;;;184            allocatedBuffer, allocatedBufferLength,
;;;185            basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString);
;;;186    
;;;187          // TODO: check that the types match
;;;188    
;;;189          Array<Type> newArray = *reinterpret_cast<Array<Type>*>( &rawArray );
;;;190    
;;;191          return newArray;
;;;192        } // / LoadBinaryArray_Generic()
;;;193    
;;;194        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;195        {
;;;196          return LoadBinaryArray_Generic<Type>(filename, &scratch, &memory, NULL, -1);
;;;197        } // Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;198    
;;;199        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength) //< allocatedBuffer must be freed manually
;;;200        {
;;;201          return LoadBinaryArray_Generic<Type>(filename, NULL, NULL, allocatedBuffer, allocatedBufferLength);
;;;202        } // LoadBinaryMalloc()
;;;203    
;;;204        template<typename Type> Result Array<Type>::SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const
;;;205        {
;;;206          AnkiConditionalErrorAndReturnValue(AreValid(*this, scratch) && filename,
;;;207            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::SaveBinary", "Invalid inputs");
;;;208    
;;;209          AnkiConditionalErrorAndReturnValue(compressionLevel >= 0 && compressionLevel <= 9,
;;;210            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::SaveBinary", "Invalid compression level");
;;;211    
;;;212          // If this is a string array, add the sizes of the null terminated strings (or zero otherwise)
;;;213          const s32 stringsLength = TotalArrayStringLengths<Type>(*this);
;;;214    
;;;215          const s32 serializedBufferLength = 4096 + ARRAY_FILE_HEADER_LENGTH + this->get_size(0) * this->get_stride() + stringsLength;
;;;216          void *buffer = scratch.Allocate(serializedBufferLength);
;;;217    
;;;218          AnkiConditionalErrorAndReturnValue(buffer,
;;;219            RESULT_FAIL_OUT_OF_MEMORY, "Array<Type>::SaveBinary", "Memory could not be allocated");
;;;220    
;;;221          SerializedBuffer toSave(buffer, serializedBufferLength);
;;;222    
;;;223          toSave.PushBack<Type>("Array", *this);
;;;224    
;;;225          s32 startIndex;
;;;226          u8 * bufferStart = reinterpret_cast<u8*>(toSave.get_memoryStack().get_validBufferStart(startIndex));
;;;227          const s32 validUsedBytes = toSave.get_memoryStack().get_usedBytes() - startIndex;
;;;228    
;;;229          // const s32 startDiff = static_cast<s32>( reinterpret_cast<size_t>(bufferStart) - reinterpret_cast<size_t>(toSave.get_memoryStack().get_buffer()) );
;;;230          // const s32 endDiff = toSave.get_memoryStack().get_totalBytes() - toSave.get_memoryStack().get_usedBytes();
;;;231    
;;;232          FILE *fp = fopen(filename, "wb");
;;;233    
;;;234          AnkiConditionalErrorAndReturnValue(fp,
;;;235            RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Could not open file %s", filename);
;;;236    
;;;237          if(compressionLevel > 0) {
;;;238    #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;239            char tmpTextHeader[ARRAY_FILE_HEADER_LENGTH+1];
;;;240            strncpy(tmpTextHeader, &ARRAY_FILE_HEADER[0], ARRAY_FILE_HEADER_LENGTH+1);
;;;241            snprintf(tmpTextHeader+ARRAY_FILE_HEADER_VALID_LENGTH+1, ARRAY_FILE_HEADER_LENGTH-ARRAY_FILE_HEADER_VALID_LENGTH, "z%s ", ZLIB_VERSION);
;;;242    
;;;243            const s32 originalLength = validUsedBytes + SERIALIZED_BUFFER_HEADER_LENGTH + SERIALIZED_BUFFER_FOOTER_LENGTH;
;;;244    
;;;245            uLongf compressedLength = 128 + saturate_cast<s32>(1.1 * originalLength);
;;;246    
;;;247            void * uncompressed = malloc(originalLength);
;;;248            void * compressed = malloc(compressedLength + 2*sizeof(s32));
;;;249    
;;;250            if(!uncompressed || !compressed) {
;;;251              if(uncompressed)
;;;252                free(uncompressed);
;;;253    
;;;254              if(compressed)
;;;255                free(compressed);
;;;256    
;;;257              AnkiError("Array<Type>::SaveBinary", "Out of memory");
;;;258    
;;;259              return RESULT_FAIL_OUT_OF_MEMORY;
;;;260            }
;;;261    
;;;262            // Copy the uncompressed data into one buffer
;;;263            {
;;;264              char * pUncompressed = reinterpret_cast<char*>(uncompressed);
;;;265    
;;;266              memcpy(pUncompressed, &SERIALIZED_BUFFER_HEADER[0], SERIALIZED_BUFFER_HEADER_LENGTH);
;;;267              pUncompressed += SERIALIZED_BUFFER_HEADER_LENGTH;
;;;268    
;;;269              memcpy(pUncompressed, bufferStart, validUsedBytes);
;;;270              pUncompressed += validUsedBytes;
;;;271    
;;;272              memcpy(pUncompressed, &SERIALIZED_BUFFER_FOOTER[0], SERIALIZED_BUFFER_FOOTER_LENGTH);
;;;273            }
;;;274    
;;;275            const s32 compressionResult = compress2(reinterpret_cast<Bytef*>(compressed) + 2*sizeof(s32), &compressedLength, reinterpret_cast<Bytef*>(uncompressed), originalLength, compressionLevel);
;;;276    
;;;277            if(compressionResult != Z_OK) {
;;;278              if(uncompressed)
;;;279                free(uncompressed);
;;;280    
;;;281              if(compressed)
;;;282                free(compressed);
;;;283    
;;;284              AnkiError("Array<Type>::SaveBinary", "Zlib error");
;;;285              return RESULT_FAIL_IO;
;;;286            }
;;;287    
;;;288            reinterpret_cast<s32*>(compressed)[0] = static_cast<s32>(originalLength);
;;;289            reinterpret_cast<s32*>(compressed)[1] = static_cast<s32>(compressedLength);
;;;290    
;;;291            const size_t bytesWrittenForTextHeader = fwrite(tmpTextHeader, 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;292    
;;;293            const size_t bytesWritten = fwrite(compressed, 1, compressedLength + 2*sizeof(s32), fp);
;;;294    
;;;295            if(uncompressed)
;;;296              free(uncompressed);
;;;297    
;;;298            if(compressed)
;;;299              free(compressed);
;;;300    
;;;301            AnkiConditionalErrorAndReturnValue(
;;;302              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;303              bytesWritten == (compressedLength + 2*sizeof(s32)),
;;;304              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;305    
;;;306    #else
;;;307            AnkiError("Array<Type>::SaveBinary", "Saving with compression requires zlib");
;;;308            return RESULT_FAIL;
;;;309    #endif
;;;310          } else {
;;;311            const size_t bytesWrittenForTextHeader = fwrite(&ARRAY_FILE_HEADER[0], 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;312    
;;;313            const size_t bytesWrittenForHeader = fwrite(&SERIALIZED_BUFFER_HEADER[0], 1, SERIALIZED_BUFFER_HEADER_LENGTH, fp);
;;;314    
;;;315            const size_t bytesWritten = fwrite(bufferStart, 1, validUsedBytes, fp);
;;;316    
;;;317            const size_t bytesWrittenForFooter = fwrite(&SERIALIZED_BUFFER_FOOTER[0], 1, SERIALIZED_BUFFER_FOOTER_LENGTH, fp);
;;;318    
;;;319            AnkiConditionalErrorAndReturnValue(
;;;320              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;321              bytesWrittenForHeader == SERIALIZED_BUFFER_HEADER_LENGTH &&
;;;322              bytesWritten == validUsedBytes &&
;;;323              bytesWrittenForFooter == SERIALIZED_BUFFER_FOOTER_LENGTH,
;;;324              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;325          }
;;;326    
;;;327          fclose(fp);
;;;328    
;;;329          return RESULT_OK;
;;;330        } // Array<Type>::SaveBinary(const char * filename, MemoryStack scratch)
;;;331    
;;;332        template<typename Type> const Type* Array<Type>::Pointer(const s32 index0, const s32 index1) const
;;;333        {
;;;334          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;335          AnkiAssert(this->IsValid());
;;;336    
;;;337          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride ) + index1;
;;;338        }
;;;339    
;;;340        template<typename Type> Type* Array<Type>::Pointer(const s32 index0, const s32 index1)
;;;341        {
;;;342          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;343          AnkiAssert(this->IsValid());
;;;344    
;;;345          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride ) + index1;
;;;346        }
;;;347    
;;;348        template<typename Type> inline const Type * Array<Type>::operator[](const s32 index0) const
;;;349        {
;;;350          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;351    
;;;352          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride );
;;;353        }
;;;354    
;;;355        template<typename Type> inline Type * Array<Type>::operator[](const s32 index0)
;;;356        {
;;;357          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;358    
;;;359          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride );
;;;360        }
;;;361    
;;;362        template<typename Type> const Type* Array<Type>::Pointer(const Point<s16> &point) const
;;;363        {
;;;364          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;365        }
;;;366    
;;;367        template<typename Type> Type* Array<Type>::Pointer(const Point<s16> &point)
;;;368        {
;;;369          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;370        }
;;;371    
;;;372        template<typename Type> const Type& Array<Type>::Element(const s32 elementIndex) const
;;;373        {
;;;374          const s32 index1 = elementIndex % size[1];
;;;375          const s32 index0 = (elementIndex - index1) / size[1];
;;;376    
;;;377          return *Pointer(index0, index1);
;;;378        }
;;;379    
;;;380        template<typename Type> Type& Array<Type>::Element(const s32 elementIndex)
;;;381        {
;;;382          const s32 index1 = elementIndex % size[1];
;;;383          const s32 index0 = (elementIndex - index1) / size[1];
;;;384    
;;;385          return *Pointer(index0, index1);
;;;386        }
;;;387    
;;;388        template<typename Type> ArraySlice<Type> Array<Type>::operator() ()
;;;389        {
;;;390          ArraySlice<Type> slice(*this);
;;;391    
;;;392          return slice;
;;;393        }
;;;394    
;;;395        template<typename Type> ArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;396        {
;;;397          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;398    
;;;399          return slice;
;;;400        }
;;;401    
;;;402        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX)
;;;403        {
;;;404          LinearSequence<s32> ySlice = IndexSequence<s32>(minY, 1, maxY, this->size[0]);
;;;405          LinearSequence<s32> xSlice = IndexSequence<s32>(minX, 1, maxX, this->size[1]);
;;;406    
;;;407          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;408    
;;;409          return slice;
;;;410        }
;;;411    
;;;412        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX)
;;;413        {
;;;414          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;415          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;416    
;;;417          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;418    
;;;419          return slice;
;;;420        }
;;;421    
;;;422        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() () const
;;;423        {
;;;424          ConstArraySlice<Type> slice(*this);
;;;425    
;;;426          return slice;
;;;427        }
;;;428    
;;;429        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const
;;;430        {
;;;431          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;432    
;;;433          return slice;
;;;434        }
;;;435    
;;;436        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const
;;;437        {
;;;438          LinearSequence<s32> ySlice = IndexSequence(minY, 1, maxY, this->size[0]);
;;;439          LinearSequence<s32> xSlice = IndexSequence(minX, 1, maxX, this->size[1]);
;;;440    
;;;441          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;442    
;;;443          return slice;
;;;444        }
;;;445    
;;;446        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const
;;;447        {
;;;448          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;449          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;450    
;;;451          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;452    
;;;453          return slice;
;;;454        }
;;;455    
;;;456        template<typename Type> ConstArraySliceExpression<Type> Array<Type>::Transpose() const
;;;457        {
;;;458          ConstArraySliceExpression<Type> expression(this->operator() ());
;;;459          expression.Transpose();
;;;460    
;;;461          return expression;
;;;462        }
;;;463    
;;;464    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;465        template<typename Type> s32 Array<Type>::Set(const cv::Mat_<Type> &in)
;;;466        {
;;;467          const s32 inHeight = in.rows;
;;;468          const s32 inWidth = in.cols;
;;;469    
;;;470          AnkiConditionalErrorAndReturnValue(inHeight != 0,
;;;471            0, "Array<Type>::Set", "input cv::Mat is invalid. If you use the release OpenCV libraries with the debug build, lots of things like file loading don't work.");
;;;472    
;;;473          const bool isColor = in.channels() == 3 || inWidth == this->size[1]*3;
;;;474    
;;;475          if(isColor) {
;;;476            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0],
;;;477              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;478          } else {
;;;479            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;480              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;481          }
;;;482    
;;;483          for(s32 y=0; y<this->size[0]; y++) {
;;;484            const Type * restrict pIn = reinterpret_cast<const Type*>(in.ptr(y,0));
;;;485            Type * restrict pThis = this->Pointer(y,0);
;;;486    
;;;487            // If grayscale, just copy. If color, convert to grayscale
;;;488            if(isColor) {
;;;489              for(s32 x=0; x<this->size[1]; x++) {
;;;490                pThis[x] = (pIn[3*x] + pIn[3*x + 1] + pIn[3*x + 2]) / 3;
;;;491              }
;;;492            } else {
;;;493              memcpy(pThis, pIn, inWidth*sizeof(Type));
;;;494            }
;;;495          }
;;;496    
;;;497          return this->size[0]*this->size[1];
;;;498        }
;;;499    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;500    
;;;501        template<typename Type> void Array<Type>::Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues, const bool fitImageToWindow) const
;;;502        {
;;;503    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;504          AnkiConditionalError(this->IsValid(), "Array<Type>::Show", "Array<Type> is not valid");
;;;505    
;;;506          if(fitImageToWindow) {
;;;507            cv::namedWindow(windowName, CV_WINDOW_NORMAL);
;;;508          } else {
;;;509            cv::namedWindow(windowName, CV_WINDOW_AUTOSIZE);
;;;510          }
;;;511    
;;;512          if(scaleValues) {
;;;513            cv::Mat_<f64> scaledArray;
;;;514    
;;;515            if(ArrayToCvMat(*this, &scaledArray) != RESULT_OK)
;;;516              return;
;;;517    
;;;518            const f64 minValue = Matrix::Min<Type>(*this);
;;;519            const f64 maxValue = Matrix::Max<Type>(*this);
;;;520            const f64 range = maxValue - minValue;
;;;521    
;;;522            scaledArray -= minValue;
;;;523            scaledArray /= range;
;;;524    
;;;525            cv::imshow(windowName, scaledArray);
;;;526          } else {
;;;527            cv::Mat_<Type> arrayCopy;
;;;528    
;;;529            if(ArrayToCvMat(*this, &arrayCopy) != RESULT_OK)
;;;530              return;
;;;531    
;;;532            cv::imshow(windowName, arrayCopy);
;;;533          }
;;;534    
;;;535          if(waitForKeypress) {
;;;536            cv::waitKey();
;;;537          }
;;;538    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;539        }
;;;540    
;;;541        template<typename Type> Result Array<Type>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;542        {
;;;543          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;544            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;545    
;;;546          CoreTechPrint(variableName);
;;;547          CoreTechPrint(":\n");
;;;548          for(s32 y=MAX(0,minY); y<MIN(maxY+1,size[0]); y++) {
;;;549            const Type * const pThisData = this->Pointer(y, 0);
;;;550            for(s32 x=MAX(0,minX); x<MIN(maxX+1,size[1]); x++) {
;;;551              pThisData[x].Print();
;;;552            }
;;;553            CoreTechPrint("\n");
;;;554          }
;;;555          CoreTechPrint("\n");
;;;556    
;;;557          return RESULT_OK;
;;;558        }
;;;559    
;;;560        template<typename Type> Result Array<Type>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;561        {
;;;562          return this->Print(variableName, minY, maxY, minX, maxX);
;;;563        }
;;;564    
;;;565        template<typename Type> bool Array<Type>::IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const
;;;566        {
;;;567          bool isSame = false;
;;;568          if(AreValid(*this, other)) {
;;;569            const s32 nrows = this->get_size(0);
;;;570            const s32 ncols = this->get_size(1);
;;;571    
;;;572            if(other.get_size(0)==nrows && other.get_size(1) == ncols) {
;;;573              isSame = true;
;;;574              for(s32 i=0; i<nrows && isSame; ++i) {
;;;575                const Type * restrict pThis  = this->Pointer(i,0);
;;;576                const Type * restrict pOther = other.Pointer(i,0);
;;;577    
;;;578                for(s32 j=0; j<ncols; ++j) {
;;;579                  if(!NEAR(pThis[j], pOther[j], epsilon)) {
;;;580                    isSame = false;
;;;581                    break;
;;;582                  }
;;;583                } // for j
;;;584              } // for i
;;;585            } // if sizes match
;;;586          } // if both valid
;;;587    
;;;588          return isSame;
;;;589        } // IsNearlyEqualTo()
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
;;;592        {
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
;;;602        }
;;;603    
;;;604        template<typename Type> Result Array<Type>::Resize(const s32 numRows, const s32 numCols, MemoryStack &memory)
;;;605        {
;;;606          AnkiConditionalErrorAndReturnValue(numCols > 0 && numRows > 0,
;;;607            RESULT_FAIL_INVALID_SIZE, "Array<Type>::Resize", "Invalid size");
;;;608    
;;;609          s32 numBytesAllocated = 0;
;;;610    
;;;611          this->data = reinterpret_cast<Type*>( AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, true) );
;;;612    
;;;613          // Don't clear the reallocated memory
;;;614          const bool clearMemory = this->flags.get_zeroAllocatedMemory();
;;;615          this->flags.set_zeroAllocatedMemory(false);
;;;616    
;;;617          const Result result = InitializeBuffer(numRows,
;;;618            numCols,
;;;619            this->data,
;;;620            numBytesAllocated,
;;;621            this->flags);
;;;622    
;;;623          this->flags.set_zeroAllocatedMemory(clearMemory);
;;;624    
;;;625          return result;
;;;626        }
;;;627    
;;;628        template<typename Type> s32 Array<Type>::SetZero()
;;;629        {
;;;630          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;631            0, "Array<Type>::SetZero", "Array<Type> is not valid");
;;;632    
;;;633          const s32 numBytes = this->get_size(0)*this->get_stride();
;;;634    
;;;635          memset(this->Pointer(0,0), 0, numBytes);
;;;636    
;;;637          return numBytes;
;;;638        }
;;;639    
;;;640        template<typename Type> s32 Array<Type>::Set(const Type value)
;;;641        {
;;;642          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;643            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;644    
;;;645          for(s32 y=0; y<size[0]; y++) {
;;;646            Type * restrict pThisData = Pointer(y, 0);
;;;647            for(s32 x=0; x<size[1]; x++) {
;;;648              pThisData[x] = value;
;;;649            }
;;;650          }
;;;651    
;;;652          return size[0]*size[1];
;;;653        }
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
;;;656        {
;;;657          return this->SetCast<Type>(in);
;;;658        }
;;;659    
;;;660        template<typename Type> template<typename InType> s32 Array<Type>::SetCast(const Array<InType> &in)
;;;661        {
;;;662          const s32 inHeight = in.get_size(0);
;;;663          const s32 inWidth = in.get_size(1);
;;;664    
;;;665          AnkiConditionalErrorAndReturnValue(AreValid(*this, in),
;;;666            0, "Array<Type>::Set", "Invalid objects");
;;;667    
;;;668          AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;669            0, "Array<Type>::Set", "Array sizes don't match");
;;;670    
;;;671          for(s32 y=0; y<size[0]; y++) {
;;;672            const InType * restrict pIn = in.Pointer(y, 0);
;;;673            Type * restrict pThisData = Pointer(y, 0);
;;;674    
;;;675            for(s32 x=0; x<size[1]; x++) {
;;;676              pThisData[x] = saturate_cast<Type>(pIn[x]);
;;;677            }
;;;678          }
;;;679    
;;;680          return size[0]*size[1];
;;;681        }
;;;682    
;;;683        template<typename InType> s32 SetCast(const InType * const values, const s32 numValues)
;;;684        {
;;;685          // This is a little tough to write a general case for, so this method should be specialized
;;;686          // for each relevant case
;;;687          AnkiAssert(false);
;;;688    
;;;689          return 0;
;;;690        }
;;;691    
;;;692        template<typename Type> s32 Array<Type>::Set(const Type * const values, const s32 numValues)
;;;693        {
;;;694          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;695            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;696    
;;;697          s32 numValuesSet = 0;
;;;698    
;;;699          for(s32 y=0; y<size[0]; y++) {
;;;700            u32 * restrict pThisData = reinterpret_cast<u32*>(Pointer(y, 0));
;;;701    
;;;702            const s32 numValuesThisRow = MAX(0, MIN(numValues - y*size[1], size[1]));
;;;703    
;;;704            if(numValuesThisRow > 0) {
;;;705              // For small data types, this may be too many bytes, but the stride padding should make
;;;706              // the writing okay (I think)
;;;707              const s32 numWordsToCopy = (sizeof(Type)*numValuesThisRow + 3) / 4;
;;;708    
;;;709              //memcpy(pThisData, values + y*size[1], numValuesThisRow*sizeof(Type));
;;;710              for(s32 x=0; x<numWordsToCopy; x++) {
;;;711                //AnkiAssert(reinterpret_cast<size_t>(values+y*size[1]) % 4 == 0);
;;;712                pThisData[x] = reinterpret_cast<const u32*>(values+y*size[1])[x];
;;;713              }
;;;714              numValuesSet += numValuesThisRow;
;;;715            }
;;;716    
;;;717            if(numValuesThisRow < size[1]) {
;;;718              memset(pThisData+numValuesThisRow*sizeof(Type), 0, (size[1]-numValuesThisRow)*sizeof(Type));
;;;719            }
;;;720          }
;;;721    
;;;722          return numValuesSet;
;;;723        }
;;;724    
;;;725        template<typename Type> Array<Type>& Array<Type>::operator= (const Array<Type> & rightHandSide)
;;;726        {
;;;727          this->size[0] = rightHandSide.size[0];
;;;728          this->size[1] = rightHandSide.size[1];
;;;729    
;;;730          this->stride = rightHandSide.stride;
;;;731          this->flags = rightHandSide.flags;
;;;732          this->data = rightHandSide.data;
;;;733    
;;;734          return *this;
;;;735        }
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
;;;738        {
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
;;;747    
;;;748        template<typename Type> s32 Array<Type>::get_stride() const
;;;749        {
;;;750          return stride;
;;;751        }
;;;752    
;;;753        template<typename Type> s32 Array<Type>::get_numElements() const
;;;754        {
;;;755          if(size[0] > 0 && size[1] > 0) {
;;;756            return size[0] * size[1];
;;;757          } else {
;;;758            return 0;
;;;759          }
;;;760        }
;;;761    
;;;762        template<typename Type> void* Array<Type>::get_buffer()
;;;763        {
;;;764          return data;
;;;765        }
;;;766    
;;;767        template<typename Type> const void* Array<Type>::get_buffer() const
;;;768        {
;;;769          return data;
;;;770        }
;;;771    
;;;772        template<typename Type> Flags::Buffer Array<Type>::get_flags() const
;;;773        {
;;;774          return flags;
;;;775        }
;;;776    
;;;777        template<typename Type> void* Array<Type>::AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate)
;;;778        {
;;;779          AnkiConditionalError(numRows >= 0 && stride > 0,
;;;780            "Array<Type>::AllocateBufferFromMemoryStack", "Invalid size");
;;;781    
;;;782          const s32 numRowsCapped = MAX(numRows, 1);
;;;783    
;;;784          this->stride = stride;
;;;785    
;;;786          const s32 numBytesRequested = numRowsCapped * this->stride;
;;;787    
;;;788          if(reAllocate) {
;;;789            return memory.Reallocate(this->data, numBytesRequested, numBytesAllocated);
;;;790          } else {
;;;791            return memory.Allocate(numBytesRequested, flags.get_zeroAllocatedMemory(), numBytesAllocated);
;;;792          }
;;;793        }
;;;794    
;;;795        template<typename Type> Result Array<Type>::InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags)
;;;796        {
;;;797          if(!rawData) {
;;;798            AnkiError("Anki.Array2d.initialize", "input data buffer is NULL");
;;;799            InvalidateArray();
;;;800            return RESULT_FAIL_UNINITIALIZED_MEMORY;
;;;801          }
;;;802    
;;;803          AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0 && dataLength >= MEMORY_ALIGNMENT,
;;;804            RESULT_FAIL_INVALID_SIZE, "Array<Type>::InitializeBuffer", "Negative dimension");
;;;805    
;;;806          AnkiConditionalErrorAndReturnValue(!flags.get_useBoundaryFillPatterns(),
;;;807            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::InitializeBuffer", "Fill patterns not supported for Array");
;;;808    
;;;809          this->flags = flags;
;;;810          this->size[0] = numRows;
;;;811          this->size[1] = numCols;
;;;812    
;;;813          // Initialize an empty array.
;;;814    
;;;815          this->data = reinterpret_cast<Type*>(rawData);
;;;816    
;;;817          const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData), MEMORY_ALIGNMENT) - reinterpret_cast<size_t>(rawData));
;;;818          const s32 requiredBytes = ComputeRequiredStride(numCols,flags)*numRows + extraAlignmentBytes;
;;;819    
;;;820          if(requiredBytes > dataLength) {
;;;821            AnkiError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
;;;822            InvalidateArray();
;;;823            return RESULT_FAIL_OUT_OF_MEMORY;
;;;824          }
;;;825    
;;;826          this->data = reinterpret_cast<Type*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
;;;827    
;;;828          //#if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;829          //      this->UpdateCvMatMirror(*this);
;;;830          //#endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;831    
;;;832          return RESULT_OK;
;;;833        } // Array<Type>::InitializeBuffer()
;;;834    
;;;835        // Set all the buffers and sizes to -1, to signal an invalid array
;;;836        template<typename Type> void Array<Type>::InvalidateArray()
;;;837        {
;;;838          this->size[0] = -1;
;;;839          this->size[1] = -1;
;;;840          this->stride = -1;
;;;841          this->data = NULL;
;;;842        } // void Array<Type>::InvalidateArray()
;;;843    
;;;844        template<typename Type> Result Array<Type>::PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX)  const
;;;845        {
;;;846          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;847            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;848    
;;;849          const s32 realMinX = MAX(0,minX);
;;;850          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;851          const s32 realMinY = MAX(0,minY);
;;;852          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;853    
;;;854          CoreTechPrint("%s type(int:%d,signed:%d,float:%d,sizeof:%d):\n", variableName, Flags::TypeCharacteristics<Type>::isInteger, Flags::TypeCharacteristics<Type>::isSigned, Flags::TypeCharacteristics<Type>::isFloat, sizeof(Type));
;;;855    
;;;856          for(s32 y=realMinY; y<realMaxY; y++) {
;;;857            const Type * const pThisData = this->Pointer(y, 0);
;;;858            for(s32 x=realMinX; x<realMaxX; x++) {
;;;859              if(Flags::TypeCharacteristics<Type>::isBasicType) {
;;;860                if(Flags::TypeCharacteristics<Type>::isInteger) {
;;;861                  CoreTechPrint("%d ", static_cast<s32>(pThisData[x]));
;;;862                } else {
;;;863                  if(version==1) {
;;;864                    CoreTechPrint("%f ", (float)pThisData[x]);
;;;865                  } else {
;;;866                    CoreTechPrint("%e ", (float)pThisData[x]);
;;;867                  }
;;;868                }
;;;869              } else {
;;;870                CoreTechPrint("! ");
;;;871              }
;;;872            }
;;;873            CoreTechPrint("\n");
;;;874          }
;;;875          CoreTechPrint("\n");
;;;876    
;;;877          return RESULT_OK;
;;;878        }
;;;879    
;;;880        template<typename Type> Result Array<Type>::PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;881        {
;;;882          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;883            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::PrintString", "Array<Type> is not valid");
;;;884    
;;;885          const s32 realMinX = MAX(0,minX);
;;;886          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;887          const s32 realMinY = MAX(0,minY);
;;;888          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;889    
;;;890          CoreTechPrint("%s:\n", variableName);
;;;891    
;;;892          for(s32 y=realMinY; y<realMaxY; y++) {
;;;893            const char * const * pThisData = this->Pointer(y, 0);
;;;894            for(s32 x=realMinX; x<realMaxX; x++) {
;;;895              const char * curString = pThisData[x];
;;;896              if(!curString) {
;;;897                CoreTechPrint("NULL, ");
;;;898              } else {
;;;899                CoreTechPrint("\"%s\", ", curString);
;;;900              }
;;;901            }
;;;902            CoreTechPrint("\n");
;;;903          }
;;;904          CoreTechPrint("\n");
;;;905    
;;;906          return RESULT_OK;
;;;907        }
;;;908    
;;;909        // #pragma mark --- FixedPointArray Definitions ---
;;;910    
;;;911        template<typename Type> FixedPointArray<Type>::FixedPointArray()
;;;912          : Array<Type>(), numFractionalBits(-1)
;;;913        {
;;;914        }
;;;915    
;;;916        template<typename Type> FixedPointArray<Type>::FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags)
;;;917          : Array<Type>(numRows, numCols, data, dataLength, flags), numFractionalBits(numFractionalBits)
;;;918        {
;;;919          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= (sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;920        }
;;;921    
;;;922        template<typename Type> FixedPointArray<Type>::FixedPointArray(s32 numRows, s32 numCols, s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags)
;;;923          : Array<Type>(numRows, numCols, memory, flags), numFractionalBits(numFractionalBits)
;;;924        {
;;;925          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= static_cast<s32>(sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;926        }
;;;927    
;;;928        template<typename Type> s32 FixedPointArray<Type>::get_numFractionalBits() const
;;;929        {
;;;930          return numFractionalBits;
;;;931        }
;;;932    
;;;933    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;934        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;935        {
;;;936          AnkiConditionalErrorAndReturnValue(in.IsValid() && out,
;;;937            RESULT_FAIL, "ArrayToCvMat", "This Array is invalid");
;;;938    
;;;939          out->refcount = NULL;
;;;940    
;;;941          // These two should be set, because if the Mat_ constructor was not called, these will not be initialized
;;;942          out->step.p = out->step.buf;
;;;943          out->size = &out->rows;
;;;944    
;;;945          *out = cv::Mat_<Type>(in.get_size(0), in.get_size(1), const_cast<Type*>(in.Pointer(0,0)), static_cast<size_t>(in.get_stride()));
;;;946    
;;;947          return RESULT_OK;
;;;948        } // template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;949    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;950    
;;;951        // #pragma mark --- Array Specializations ---
;;;952    
;;;953        template<> Result Array<bool>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;954        template<> Result Array<u8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;955        template<> Result Array<s8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;956        template<> Result Array<u16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;957        template<> Result Array<s16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;958        template<> Result Array<u32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;959        template<> Result Array<s32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;960        template<> Result Array<u64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;961        template<> Result Array<s64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;962        template<> Result Array<f32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;963        template<> Result Array<f64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;964        template<> Result Array<const char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;965        template<> Result Array<char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;966    
;;;967        template<> Result Array<f32>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;968        template<> Result Array<f64>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;969    
;;;970        template<> template<> s32 Array<u8>::SetCast(const s32 * const values, const s32 numValues);
;;;971        template<> template<> s32 Array<s16>::SetCast(const s32 * const values, const s32 numValues);
;;;972      } // namespace Embedded
;;;973    } //namespace Anki
;;;974    
;;;975    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;17     #include "anki/common/robot/arraySlices.h"
;;;1      /**
;;;2      File: arraySlices.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of arraySlices_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;14     
;;;15     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> ConstArraySlice<Type>::ConstArraySlice()
;;;23           : ySlice(LinearSequence<s32>()), xSlice(LinearSequence<s32>()), array(Array<Type>()), constArrayData(NULL)
;;;24         {
;;;25         }
;;;26     
;;;27         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array)
;;;28           : ySlice(LinearSequence<s32>(0,array.get_size(0)-1)), xSlice(LinearSequence<s32>(0,array.get_size(1)-1)), array(array)
;;;29         {
;;;30           if(array.get_numElements() == 0) {
;;;31             this->constArrayData = NULL;
;;;32           } else {
;;;33             this->constArrayData = array.Pointer(0,0);
;;;34           }
;;;35         }
;;;36     
;;;37         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;38           : ySlice(ySlice), xSlice(xSlice), array(array)
;;;39         {
;;;40           if(array.get_numElements() == 0) {
;;;41             this->constArrayData = NULL;
;;;42           } else {
;;;43             this->constArrayData = array.Pointer(0,0);
;;;44           }
;;;45         }
;;;46     
;;;47         template<typename Type> ConstArraySliceExpression<Type> ConstArraySlice<Type>::Transpose() const
;;;48         {
;;;49           ConstArraySliceExpression<Type> expression(*this, true);
;;;50     
;;;51           return expression;
;;;52         }
;;;53     
;;;54         template<typename Type> bool ConstArraySlice<Type>::IsValid() const
;;;55         {
;;;56           return this->array.IsValid();
;;;57         }
;;;58     
;;;59         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_ySlice() const
;;;60         {
;;;61           return ySlice;
;;;62         }
;;;63     
;;;64         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_xSlice() const
;;;65         {
;;;66           return xSlice;
;;;67         }
;;;68     
;;;69         template<typename Type> const Array<Type>& ConstArraySlice<Type>::get_array() const
;;;70         {
;;;71           return this->array;
;;;72         }
;;;73     
;;;74         template<typename Type> ArraySlice<Type>::ArraySlice()
;;;75           : ConstArraySlice<Type>(), arrayData(NULL)
;;;76         {
;;;77         }
;;;78     
;;;79         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array)
;;;80           : ConstArraySlice<Type>(array)
;;;81         {
;;;82           if(array.get_numElements() == 0) {
;;;83             this->arrayData = NULL;
;;;84           } else {
;;;85             this->arrayData = array.Pointer(0,0);
;;;86           }
;;;87         }
;;;88     
;;;89         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;90           : ConstArraySlice<Type>(array, ySlice, xSlice)
;;;91         {
;;;92           if(array.get_numElements() == 0) {
;;;93             this->arrayData = NULL;
;;;94           } else {
;;;95             this->arrayData = array.Pointer(0,0);
;;;96           }
;;;97         }
;;;98     
;;;99         template<typename Type> s32 ArraySlice<Type>::Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;100        {
;;;101          return this->SetCast<Type>(input, automaticTranspose);
;;;102        }
;;;103    
;;;104        template<typename Type> s32 ArraySlice<Type>::Set(const LinearSequence<Type> &input)
;;;105        {
;;;106          const Result result = input.Evaluate(*this);
;;;107          return (result==RESULT_OK) ? input.get_size() : 0;
;;;108        }
;;;109    
;;;110        template<typename Type> s32 ArraySlice<Type>::Set(const Type value)
;;;111        {
;;;112          Array<Type> &array = this->get_array();
;;;113    
;;;114          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;115            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;116    
;;;117          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;118    
;;;119          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;120            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;121    
;;;122          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;123            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;124            Type * restrict pMat = array.Pointer(y, 0);
;;;125    
;;;126            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;127              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;128              pMat[x] = value;
;;;129            }
;;;130          }
;;;131    
;;;132          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;133        }
;;;134    
;;;135        template<typename Type> s32 ArraySlice<Type>::Set(const Type * const values, const s32 numValues)
;;;136        {
;;;137          Array<Type> &array = this->get_array();
;;;138    
;;;139          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;140            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;141    
;;;142          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;143    
;;;144          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;145            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;146    
;;;147          AnkiConditionalErrorAndReturnValue(limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize == numValues,
;;;148            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;149    
;;;150          s32 ci = 0;
;;;151          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;152            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;153            Type * restrict pMat = array.Pointer(y, 0);
;;;154    
;;;155            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;156              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;157              pMat[x] = values[ci];
;;;158              ci++;
;;;159            }
;;;160          }
;;;161    
;;;162          AnkiAssert(ci == limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize);
;;;163    
;;;164          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;165        }
;;;166    
;;;167        template<typename Type> template<typename InType> s32 ArraySlice<Type>::SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;168        {
;;;169          AnkiConditionalErrorAndReturnValue(AreValid(*this, input),
;;;170            0, "ArraySlice<Type>::Set", "Invalid objects");
;;;171    
;;;172          AnkiConditionalErrorAndReturnValue(this->get_array().get_buffer() != input.get_array().get_buffer(),
;;;173            0, "ArraySlice<Type>::Set", "Arrays must be in different memory locations");
;;;174    
;;;175          ArraySliceLimits_in1_out1<s32> limits(
;;;176            input.get_ySlice(), input.get_xSlice(), input.get_isTransposed(),
;;;177            this->get_ySlice(), this->get_xSlice());
;;;178    
;;;179          if(!limits.isValid) {
;;;180            if(automaticTranspose) {
;;;181              // If we're allowed to transpose, give it another shot
;;;182              limits = ArraySliceLimits_in1_out1<s32> (input.get_ySlice(), input.get_xSlice(), !input.get_isTransposed(), this->get_ySlice(), this->get_xSlice());
;;;183    
;;;184              if(!limits.isValid) {
;;;185                AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;186                return 0;
;;;187              }
;;;188            } else {
;;;189              AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;190              return 0;
;;;191            }
;;;192          }
;;;193    
;;;194          Array<Type> &out1Array = this->get_array();
;;;195          const Array<InType> &in1Array = input.get_array();
;;;196    
;;;197          if(limits.isSimpleIteration) {
;;;198            // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;199    
;;;200            for(s32 y=0; y<limits.ySize; y++) {
;;;201              const InType * restrict pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;202              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;203    
;;;204              limits.OuterIncrementTop();
;;;205    
;;;206              for(s32 x=0; x<limits.xSize; x++) {
;;;207                pOut1[limits.out1X] = static_cast<Type>( pIn1[limits.in1X] );
;;;208    
;;;209                limits.out1X += limits.out1_xInnerIncrement;
;;;210                limits.in1X += limits.in1_xInnerIncrement;
;;;211              }
;;;212    
;;;213              limits.OuterIncrementBottom();
;;;214            }
;;;215          } else {
;;;216            for(s32 y=0; y<limits.ySize; y++) {
;;;217              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;218    
;;;219              limits.OuterIncrementTop();
;;;220    
;;;221              for(s32 x=0; x<limits.xSize; x++) {
;;;222                const InType pIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;223    
;;;224                pOut1[limits.out1X] = static_cast<Type>( pIn1 );
;;;225    
;;;226                limits.out1X += limits.out1_xInnerIncrement;
;;;227                limits.in1Y += limits.in1_yInnerIncrement;
;;;228              }
;;;229    
;;;230              limits.OuterIncrementBottom();
;;;231            }
;;;232          }
;;;233    
;;;234          return limits.ySize*limits.xSize;
;;;235        }
;;;236    
                          ENDP

                  |L126.548|
                          DCD      _ZZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySlice<short>::SetCast<short>(const Anki::Embedded::ConstArraySliceExpression<short>&, bool)::__PRETTY_FUNCTION__
                  |L126.552|
000228  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/arrayS"
00022c  6f726574
000230  6563685c
000234  636f6d6d
000238  6f6e5c69
00023c  6e636c75
000240  64655c61
000244  6e6b692f
000248  636f6d6d
00024c  6f6e2f72
000250  6f626f74
000254  2f617272
000258  617953  
00025b  6c696365          DCB      "lices.h",0
00025f  732e6800
000263  00                DCB      0
                  |L126.612|
000264  41727261          DCB      "Arrays must be in different memory locations",0
000268  7973206d
00026c  75737420
000270  62652069
000274  6e206469
000278  66666572
00027c  656e7420
000280  6d656d6f
000284  7279206c
000288  6f636174
00028c  696f6e73
000290  00      
000291  00                DCB      0
000292  00                DCB      0
000293  00                DCB      0
                  |L126.660|
000294  41727261          DCB      "ArraySlice<Type>::Set",0
000298  79536c69
00029c  63653c54
0002a0  7970653e
0002a4  3a3a5365
0002a8  7400    
0002aa  00                DCB      0
0002ab  00                DCB      0
                  |L126.684|
0002ac  496e7661          DCB      "Invalid objects",0
0002b0  6c696420
0002b4  6f626a65
0002b8  63747300
                  |L126.700|
0002bc  53756273          DCB      "Subscripted assignment dimension mismatch",0
0002c0  63726970
0002c4  74656420
0002c8  61737369
0002cc  676e6d65
0002d0  6e742064
0002d4  696d656e
0002d8  73696f6e
0002dc  206d6973
0002e0  6d617463
0002e4  6800    
0002e6  00                DCB      0
0002e7  00                DCB      0

                          AREA ||area_number.127||, COMGROUP=_ZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEb, LINKORDER=||t._ZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.127||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEb||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15FixedPointArrayIsEC2EiiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::FixedPointArray<short>::FixedPointArray__sub_object(int, int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::FixedPointArray<short>::FixedPointArray(int, int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;921    
;;;922        template<typename Type> FixedPointArray<Type>::FixedPointArray(s32 numRows, s32 numCols, s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags)
;;;923          : Array<Type>(numRows, numCols, memory, flags), numFractionalBits(numFractionalBits)
;;;924        {
;;;925          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= static_cast<s32>(sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;926        }
;;;927    
000000  b530              PUSH     {r4,r5,lr}
000002  b083              SUB      sp,sp,#0xc
000004  461c              MOV      r4,r3
000006  e9ddc306          LDRD     r12,r3,[sp,#0x18]
00000a  9300              STR      r3,[sp,#0]
00000c  4663              MOV      r3,r12
00000e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIsEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<short>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000012  4605              MOV      r5,r0
000014  6144              STR      r4,[r0,#0x14]
000016  2c11              CMP      r4,#0x11
000018  d30c              BCC      |L133.52|
00001a  f240319d          MOV      r1,#0x39d
00001e  4807              LDR      r0,|L133.60|
000020  4b07              LDR      r3,|L133.64|
000022  e9cd0100          STRD     r0,r1,[sp,#0]
000026  f103027c          ADD      r2,r3,#0x7c
00002a  f1a20118          SUB      r1,r2,#0x18
00002e  2005              MOVS     r0,#5
000030  f7fffffe          BL       _Anki_Log
                  |L133.52|
000034  b003              ADD      sp,sp,#0xc
000036  4628              MOV      r0,r5
000038  bd30              POP      {r4,r5,pc}
                          ENDP

00003a  0000              DCW      0x0000
                  |L133.60|
                          DCD      _ZZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::FixedPointArray<short>::FixedPointArray(int, int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L133.64|
                          DCD      ||.constdata||+0x194

                          AREA ||area_number.134||, COMGROUP=_ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.134||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||.constdata__ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
00001c  696e6561          DCB      0x69,0x6e,0x65,0x61
000020  72536571          DCB      0x72,0x53,0x65,0x71
000024  75656e63          DCB      0x75,0x65,0x6e,0x63
000028  653c5479          DCB      0x65,0x3c,0x54,0x79
00002c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000030  3a636f6d          DCB      0x3a,0x63,0x6f,0x6d
000034  70757465          DCB      0x70,0x75,0x74,0x65
000038  53697a65          DCB      0x53,0x69,0x7a,0x65
00003c  28547970          DCB      0x28,0x54,0x79,0x70
000040  652c2054          DCB      0x65,0x2c,0x20,0x54
000044  7970652c          DCB      0x79,0x70,0x65,0x2c
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  6529205b          DCB      0x65,0x29,0x20,0x5b
000050  77697468          DCB      0x77,0x69,0x74,0x68
000054  20547970          DCB      0x20,0x54,0x79,0x70
000058  65203d20          DCB      0x65,0x20,0x3d,0x20
00005c  7369676e          DCB      0x73,0x69,0x67,0x6e
000060  65642069          DCB      0x65,0x64,0x20,0x69
000064  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d207369          DCB      0x3d,0x20,0x73,0x69
000088  676e6564          DCB      0x67,0x6e,0x65,0x64
00008c  20696e74          DCB      0x20,0x69,0x6e,0x74
000090  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  7369676e          DCB      0x73,0x69,0x67,0x6e
0000bc  65642069          DCB      0x65,0x64,0x20,0x69
0000c0  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2073          DCB      0x20,0x3d,0x20,0x73
000094  69676e65          DCB      0x69,0x67,0x6e,0x65
000098  6420696e          DCB      0x64,0x20,0x69,0x6e
00009c  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  79536c69          DCB      0x79,0x53,0x6c,0x69
000018  63654c69          DCB      0x63,0x65,0x4c,0x69
00001c  6d697473          DCB      0x6d,0x69,0x74,0x73
000020  5f696e31          DCB      0x5f,0x69,0x6e,0x31
000024  5f6f7574          DCB      0x5f,0x6f,0x75,0x74
000028  313c5479          DCB      0x31,0x3c,0x54,0x79
00002c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000030  3a417272          DCB      0x3a,0x41,0x72,0x72
000034  6179536c          DCB      0x61,0x79,0x53,0x6c
000038  6963654c          DCB      0x69,0x63,0x65,0x4c
00003c  696d6974          DCB      0x69,0x6d,0x69,0x74
000040  735f696e          DCB      0x73,0x5f,0x69,0x6e
000044  315f6f75          DCB      0x31,0x5f,0x6f,0x75
000048  74312863          DCB      0x74,0x31,0x28,0x63
00004c  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000050  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000054  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000058  6d626564          DCB      0x6d,0x62,0x65,0x64
00005c  6465643a          DCB      0x64,0x65,0x64,0x3a
000060  3a4c696e          DCB      0x3a,0x4c,0x69,0x6e
000064  65617253          DCB      0x65,0x61,0x72,0x53
000068  65717565          DCB      0x65,0x71,0x75,0x65
00006c  6e63653c          DCB      0x6e,0x63,0x65,0x3c
000070  54797065          DCB      0x54,0x79,0x70,0x65
000074  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000078  20636f6e          DCB      0x20,0x63,0x6f,0x6e
00007c  73742041          DCB      0x73,0x74,0x20,0x41
000080  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000084  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000088  65646465          DCB      0x65,0x64,0x64,0x65
00008c  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
000090  696e6561          DCB      0x69,0x6e,0x65,0x61
000094  72536571          DCB      0x72,0x53,0x65,0x71
000098  75656e63          DCB      0x75,0x65,0x6e,0x63
00009c  653c5479          DCB      0x65,0x3c,0x54,0x79
0000a0  70653e20          DCB      0x70,0x65,0x3e,0x20
0000a4  262c2062          DCB      0x26,0x2c,0x20,0x62
0000a8  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
0000ac  20636f6e          DCB      0x20,0x63,0x6f,0x6e
0000b0  73742041          DCB      0x73,0x74,0x20,0x41
0000b4  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000b8  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000bc  65646465          DCB      0x65,0x64,0x64,0x65
0000c0  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
0000c4  696e6561          DCB      0x69,0x6e,0x65,0x61
0000c8  72536571          DCB      0x72,0x53,0x65,0x71
0000cc  75656e63          DCB      0x75,0x65,0x6e,0x63
0000d0  653c5479          DCB      0x65,0x3c,0x54,0x79
0000d4  70653e20          DCB      0x70,0x65,0x3e,0x20
0000d8  262c2063          DCB      0x26,0x2c,0x20,0x63
0000dc  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0000e0  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000e4  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000e8  6d626564          DCB      0x6d,0x62,0x65,0x64
0000ec  6465643a          DCB      0x64,0x65,0x64,0x3a
0000f0  3a4c696e          DCB      0x3a,0x4c,0x69,0x6e
0000f4  65617253          DCB      0x65,0x61,0x72,0x53
0000f8  65717565          DCB      0x65,0x71,0x75,0x65
0000fc  6e63653c          DCB      0x6e,0x63,0x65,0x3c
000100  54797065          DCB      0x54,0x79,0x70,0x65
000104  3e202629          DCB      0x3e,0x20,0x26,0x29
000108  205b7769          DCB      0x20,0x5b,0x77,0x69
00010c  74682054          DCB      0x74,0x68,0x20,0x54
000110  79706520          DCB      0x79,0x70,0x65,0x20
000114  3d207369          DCB      0x3d,0x20,0x73,0x69
000118  676e6564          DCB      0x67,0x6e,0x65,0x64
00011c  20696e74          DCB      0x20,0x69,0x6e,0x74
000120  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000088  6f61745d          DCB      0x6f,0x61,0x74,0x5d
00008c  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000bc  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2066          DCB      0x20,0x3d,0x20,0x66
000094  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000098  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIsEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIsEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIsEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<short>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d207369          DCB      0x3d,0x20,0x73,0x69
000088  676e6564          DCB      0x67,0x6e,0x65,0x64
00008c  2073686f          DCB      0x20,0x73,0x68,0x6f
000090  72745d00          DCB      0x72,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIsE7SetZeroEvE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIsE7SetZeroEvE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIsE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<short>::SetZero()::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  5365745a          DCB      0x53,0x65,0x74,0x5a
00002c  65726f28          DCB      0x65,0x72,0x6f,0x28
000030  29205b77          DCB      0x29,0x20,0x5b,0x77
000034  69746820          DCB      0x69,0x74,0x68,0x20
000038  54797065          DCB      0x54,0x79,0x70,0x65
00003c  203d2073          DCB      0x20,0x3d,0x20,0x73
000040  69676e65          DCB      0x69,0x67,0x6e,0x65
000044  64207368          DCB      0x64,0x20,0x73,0x68
000048  6f72745d          DCB      0x6f,0x72,0x74,0x5d
00004c  00                DCB      0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIsE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIsE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIsE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<short>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  7369676e          DCB      0x73,0x69,0x67,0x6e
000054  65642073          DCB      0x65,0x64,0x20,0x73
000058  686f7274          DCB      0x68,0x6f,0x72,0x74
00005c  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIsE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIsE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIsE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<short>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  7369676e          DCB      0x73,0x69,0x67,0x6e
0000bc  65642073          DCB      0x65,0x64,0x20,0x73
0000c0  686f7274          DCB      0x68,0x6f,0x72,0x74
0000c4  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIsE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIsE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIsE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<short>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2073          DCB      0x20,0x3d,0x20,0x73
000094  69676e65          DCB      0x69,0x67,0x6e,0x65
000098  64207368          DCB      0x64,0x20,0x73,0x68
00009c  6f72745d          DCB      0x6f,0x72,0x74,0x5d
0000a0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded10ArraySliceIsE7SetCastIsEEiRKNS0_25ConstArraySliceExpressionIsEEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySlice<short>::SetCast<short>(const Anki::Embedded::ConstArraySliceExpression<short>&, bool)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  536c6963          DCB      0x53,0x6c,0x69,0x63
000024  653c5479          DCB      0x65,0x3c,0x54,0x79
000028  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00002c  3a536574          DCB      0x3a,0x53,0x65,0x74
000030  43617374          DCB      0x43,0x61,0x73,0x74
000034  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000038  73742041          DCB      0x73,0x74,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a43          DCB      0x64,0x3a,0x3a,0x43
00004c  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000050  41727261          DCB      0x41,0x72,0x72,0x61
000054  79536c69          DCB      0x79,0x53,0x6c,0x69
000058  63654578          DCB      0x63,0x65,0x45,0x78
00005c  70726573          DCB      0x70,0x72,0x65,0x73
000060  73696f6e          DCB      0x73,0x69,0x6f,0x6e
000064  3c547970          DCB      0x3c,0x54,0x79,0x70
000068  653e2026          DCB      0x65,0x3e,0x20,0x26
00006c  2c20626f          DCB      0x2c,0x20,0x62,0x6f
000070  6f6c2920          DCB      0x6f,0x6c,0x29,0x20
000074  5b776974          DCB      0x5b,0x77,0x69,0x74
000078  6820496e          DCB      0x68,0x20,0x49,0x6e
00007c  54797065          DCB      0x54,0x79,0x70,0x65
000080  203d2073          DCB      0x20,0x3d,0x20,0x73
000084  69676e65          DCB      0x69,0x67,0x6e,0x65
000088  64207368          DCB      0x64,0x20,0x73,0x68
00008c  6f72742c          DCB      0x6f,0x72,0x74,0x2c
000090  20547970          DCB      0x20,0x54,0x79,0x70
000094  65203d20          DCB      0x65,0x20,0x3d,0x20
000098  7369676e          DCB      0x73,0x69,0x67,0x6e
00009c  65642073          DCB      0x65,0x64,0x20,0x73
0000a0  686f7274          DCB      0x68,0x6f,0x72,0x74
0000a4  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded15FixedPointArrayIsEC1EiiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::FixedPointArray<short>::FixedPointArray(int, int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  46697865          DCB      0x46,0x69,0x78,0x65
000014  64506f69          DCB      0x64,0x50,0x6f,0x69
000018  6e744172          DCB      0x6e,0x74,0x41,0x72
00001c  7261793c          DCB      0x72,0x61,0x79,0x3c
000020  54797065          DCB      0x54,0x79,0x70,0x65
000024  3e3a3a46          DCB      0x3e,0x3a,0x3a,0x46
000028  69786564          DCB      0x69,0x78,0x65,0x64
00002c  506f696e          DCB      0x50,0x6f,0x69,0x6e
000030  74417272          DCB      0x74,0x41,0x72,0x72
000034  61792873          DCB      0x61,0x79,0x28,0x73
000038  69676e65          DCB      0x69,0x67,0x6e,0x65
00003c  6420696e          DCB      0x64,0x20,0x69,0x6e
000040  742c2073          DCB      0x74,0x2c,0x20,0x73
000044  69676e65          DCB      0x69,0x67,0x6e,0x65
000048  6420696e          DCB      0x64,0x20,0x69,0x6e
00004c  742c2073          DCB      0x74,0x2c,0x20,0x73
000050  69676e65          DCB      0x69,0x67,0x6e,0x65
000054  6420696e          DCB      0x64,0x20,0x69,0x6e
000058  742c2041          DCB      0x74,0x2c,0x20,0x41
00005c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000060  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000064  65646465          DCB      0x65,0x64,0x64,0x65
000068  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00006c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000070  79537461          DCB      0x79,0x53,0x74,0x61
000074  636b2026          DCB      0x63,0x6b,0x20,0x26
000078  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00007c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000080  456d6265          DCB      0x45,0x6d,0x62,0x65
000084  64646564          DCB      0x64,0x64,0x65,0x64
000088  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00008c  6167733a          DCB      0x61,0x67,0x73,0x3a
000090  3a427566          DCB      0x3a,0x42,0x75,0x66
000094  66657229          DCB      0x66,0x65,0x72,0x29
000098  205b7769          DCB      0x20,0x5b,0x77,0x69
00009c  74682054          DCB      0x74,0x68,0x20,0x54
0000a0  79706520          DCB      0x79,0x70,0x65,0x20
0000a4  3d207369          DCB      0x3d,0x20,0x73,0x69
0000a8  676e6564          DCB      0x67,0x6e,0x65,0x64
0000ac  2073686f          DCB      0x20,0x73,0x68,0x6f
0000b0  72745d00          DCB      0x72,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded15ImageProcessing11Correlate1dIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded15ImageProcessing11Correlate1dIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded15ImageProcessing11Correlate1dIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::ImageProcessing::Correlate1d<short, int, short>(const Anki::Embedded::FixedPointArray<T1>&, const Anki::Embedded::FixedPointArray<T1>&, Anki::Embedded::FixedPointArray<T3>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a496d61          DCB      0x3a,0x49,0x6d,0x61
000020  67655072          DCB      0x67,0x65,0x50,0x72
000024  6f636573          DCB      0x6f,0x63,0x65,0x73
000028  73696e67          DCB      0x73,0x69,0x6e,0x67
00002c  3a3a436f          DCB      0x3a,0x3a,0x43,0x6f
000030  7272656c          DCB      0x72,0x72,0x65,0x6c
000034  61746531          DCB      0x61,0x74,0x65,0x31
000038  6428636f          DCB      0x64,0x28,0x63,0x6f
00003c  6e737420          DCB      0x6e,0x73,0x74,0x20
000040  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000044  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000048  62656464          DCB      0x62,0x65,0x64,0x64
00004c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000050  46697865          DCB      0x46,0x69,0x78,0x65
000054  64506f69          DCB      0x64,0x50,0x6f,0x69
000058  6e744172          DCB      0x6e,0x74,0x41,0x72
00005c  7261793c          DCB      0x72,0x61,0x79,0x3c
000060  54797065          DCB      0x54,0x79,0x70,0x65
000064  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000068  20636f6e          DCB      0x20,0x63,0x6f,0x6e
00006c  73742041          DCB      0x73,0x74,0x20,0x41
000070  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000074  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000078  65646465          DCB      0x65,0x64,0x64,0x65
00007c  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000080  69786564          DCB      0x69,0x78,0x65,0x64
000084  506f696e          DCB      0x50,0x6f,0x69,0x6e
000088  74417272          DCB      0x74,0x41,0x72,0x72
00008c  61793c54          DCB      0x61,0x79,0x3c,0x54
000090  7970653e          DCB      0x79,0x70,0x65,0x3e
000094  20262c20          DCB      0x20,0x26,0x2c,0x20
000098  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00009c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000a0  62656464          DCB      0x62,0x65,0x64,0x64
0000a4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000a8  46697865          DCB      0x46,0x69,0x78,0x65
0000ac  64506f69          DCB      0x64,0x50,0x6f,0x69
0000b0  6e744172          DCB      0x6e,0x74,0x41,0x72
0000b4  7261793c          DCB      0x72,0x61,0x79,0x3c
0000b8  4f757454          DCB      0x4f,0x75,0x74,0x54
0000bc  7970653e          DCB      0x79,0x70,0x65,0x3e
0000c0  20262920          DCB      0x20,0x26,0x29,0x20
0000c4  5b776974          DCB      0x5b,0x77,0x69,0x74
0000c8  6820496e          DCB      0x68,0x20,0x49,0x6e
0000cc  54797065          DCB      0x54,0x79,0x70,0x65
0000d0  203d2073          DCB      0x20,0x3d,0x20,0x73
0000d4  69676e65          DCB      0x69,0x67,0x6e,0x65
0000d8  64207368          DCB      0x64,0x20,0x73,0x68
0000dc  6f72742c          DCB      0x6f,0x72,0x74,0x2c
0000e0  20496e74          DCB      0x20,0x49,0x6e,0x74
0000e4  65726d65          DCB      0x65,0x72,0x6d,0x65
0000e8  64696174          DCB      0x64,0x69,0x61,0x74
0000ec  65547970          DCB      0x65,0x54,0x79,0x70
0000f0  65203d20          DCB      0x65,0x20,0x3d,0x20
0000f4  7369676e          DCB      0x73,0x69,0x67,0x6e
0000f8  65642069          DCB      0x65,0x64,0x20,0x69
0000fc  6e742c20          DCB      0x6e,0x74,0x2c,0x20
000100  4f757454          DCB      0x4f,0x75,0x74,0x54
000104  79706520          DCB      0x79,0x70,0x65,0x20
000108  3d207369          DCB      0x3d,0x20,0x73,0x69
00010c  676e6564          DCB      0x67,0x6e,0x65,0x64
000110  2073686f          DCB      0x20,0x73,0x68,0x6f
000114  72745d00          DCB      0x72,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded15ImageProcessing36Correlate1dCircularAndSameSizeOutputIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EENS0_11MemoryStackEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded15ImageProcessing36Correlate1dCircularAndSameSizeOutputIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EENS0_11MemoryStackEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded15ImageProcessing36Correlate1dCircularAndSameSizeOutputIsisEENS_6ResultERKNS0_15FixedPointArrayIT_EES8_RNS4_IT1_EENS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::ImageProcessing::Correlate1dCircularAndSameSizeOutput<short, int, short>(const Anki::Embedded::FixedPointArray<T1>&, const Anki::Embedded::FixedPointArray<T1>&, Anki::Embedded::FixedPointArray<T3>&, Anki::Embedded::MemoryStack)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a496d61          DCB      0x3a,0x49,0x6d,0x61
000020  67655072          DCB      0x67,0x65,0x50,0x72
000024  6f636573          DCB      0x6f,0x63,0x65,0x73
000028  73696e67          DCB      0x73,0x69,0x6e,0x67
00002c  3a3a436f          DCB      0x3a,0x3a,0x43,0x6f
000030  7272656c          DCB      0x72,0x72,0x65,0x6c
000034  61746531          DCB      0x61,0x74,0x65,0x31
000038  64436972          DCB      0x64,0x43,0x69,0x72
00003c  63756c61          DCB      0x63,0x75,0x6c,0x61
000040  72416e64          DCB      0x72,0x41,0x6e,0x64
000044  53616d65          DCB      0x53,0x61,0x6d,0x65
000048  53697a65          DCB      0x53,0x69,0x7a,0x65
00004c  4f757470          DCB      0x4f,0x75,0x74,0x70
000050  75742863          DCB      0x75,0x74,0x28,0x63
000054  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a466978          DCB      0x3a,0x46,0x69,0x78
00006c  6564506f          DCB      0x65,0x64,0x50,0x6f
000070  696e7441          DCB      0x69,0x6e,0x74,0x41
000074  72726179          DCB      0x72,0x72,0x61,0x79
000078  3c547970          DCB      0x3c,0x54,0x79,0x70
00007c  653e2026          DCB      0x65,0x3e,0x20,0x26
000080  2c20636f          DCB      0x2c,0x20,0x63,0x6f
000084  6e737420          DCB      0x6e,0x73,0x74,0x20
000088  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00008c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000090  62656464          DCB      0x62,0x65,0x64,0x64
000094  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000098  46697865          DCB      0x46,0x69,0x78,0x65
00009c  64506f69          DCB      0x64,0x50,0x6f,0x69
0000a0  6e744172          DCB      0x6e,0x74,0x41,0x72
0000a4  7261793c          DCB      0x72,0x61,0x79,0x3c
0000a8  54797065          DCB      0x54,0x79,0x70,0x65
0000ac  3e20262c          DCB      0x3e,0x20,0x26,0x2c
0000b0  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000b4  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000b8  6d626564          DCB      0x6d,0x62,0x65,0x64
0000bc  6465643a          DCB      0x64,0x65,0x64,0x3a
0000c0  3a466978          DCB      0x3a,0x46,0x69,0x78
0000c4  6564506f          DCB      0x65,0x64,0x50,0x6f
0000c8  696e7441          DCB      0x69,0x6e,0x74,0x41
0000cc  72726179          DCB      0x72,0x72,0x61,0x79
0000d0  3c4f7574          DCB      0x3c,0x4f,0x75,0x74
0000d4  54797065          DCB      0x54,0x79,0x70,0x65
0000d8  3e20262c          DCB      0x3e,0x20,0x26,0x2c
0000dc  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000e0  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000e4  6d626564          DCB      0x6d,0x62,0x65,0x64
0000e8  6465643a          DCB      0x64,0x65,0x64,0x3a
0000ec  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
0000f0  6f727953          DCB      0x6f,0x72,0x79,0x53
0000f4  7461636b          DCB      0x74,0x61,0x63,0x6b
0000f8  29205b77          DCB      0x29,0x20,0x5b,0x77
0000fc  69746820          DCB      0x69,0x74,0x68,0x20
000100  496e5479          DCB      0x49,0x6e,0x54,0x79
000104  7065203d          DCB      0x70,0x65,0x20,0x3d
000108  20736967          DCB      0x20,0x73,0x69,0x67
00010c  6e656420          DCB      0x6e,0x65,0x64,0x20
000110  73686f72          DCB      0x73,0x68,0x6f,0x72
000114  742c2049          DCB      0x74,0x2c,0x20,0x49
000118  6e746572          DCB      0x6e,0x74,0x65,0x72
00011c  6d656469          DCB      0x6d,0x65,0x64,0x69
000120  61746554          DCB      0x61,0x74,0x65,0x54
000124  79706520          DCB      0x79,0x70,0x65,0x20
000128  3d207369          DCB      0x3d,0x20,0x73,0x69
00012c  676e6564          DCB      0x67,0x6e,0x65,0x64
000130  20696e74          DCB      0x20,0x69,0x6e,0x74
000134  2c204f75          DCB      0x2c,0x20,0x4f,0x75
000138  74547970          DCB      0x74,0x54,0x79,0x70
00013c  65203d20          DCB      0x65,0x20,0x3d,0x20
000140  7369676e          DCB      0x73,0x69,0x67,0x6e
000144  65642073          DCB      0x65,0x64,0x20,0x73
000148  686f7274          DCB      0x68,0x6f,0x72,0x74
00014c  5d00              DCB      0x5d,0x00

;*** Start embedded assembler ***

#line 1 "..\\coretech\\vision\\robot\\src\\laplacianPeaks.cpp"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___18_laplacianPeaks_cpp_a0603c12___Z7__REV16j|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___18_laplacianPeaks_cpp_a0603c12___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___18_laplacianPeaks_cpp_a0603c12___Z7__REVSHi|
#line 144
|__asm___18_laplacianPeaks_cpp_a0603c12___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
