; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\lights.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\lights.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\lights.crf arm_hal\hal\lights.cpp]
                          THUMB

                          AREA ||i.TIM1_TRG_COM_TIM11_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM1_TRG_COM_TIM11_IRQHandler PROC
;;;145    // Please keep this code optimized - avoid function calls and loops
;;;146    extern "C" void TIM1_TRG_COM_TIM11_IRQHandler(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;147    {
;;;148      using namespace Anki::Cozmo::HAL;
;;;149      static ColorValue s_color[4];     // Cache the current color, since mid-cycle changes cause flicker
;;;150      static u8  s_which = 0;    // Which LED to light
;;;151      static u8  s_now   = 0;      // The current 'time' in the per-LED PWM cycle (0xff = full bright)
;;;152      const u8  NUM_COLOR_GPIO = NUM_COLOR_CHANNELS * 3;
;;;153      u32 howlong;
;;;154      u8 nexttime;
;;;155      u8 i;
;;;156      
;;;157      // If this is the end of the last LED, switch to the next LED
;;;158      if (0 == s_now)
000004  4b48              LDR      r3,|L1.296|
;;;159      {
;;;160        // Turn everything off
;;;161        GPIO_SET(  GPIO_EYE2nEN, PIN_EYE2nEN);
;;;162        GPIO_SET(  GPIO_EYE1nEN, PIN_EYE1nEN);
;;;163        for (i=0; i<NUM_COLOR_GPIO; ++i)
;;;164        { // Concatination hack
;;;165          GPIO_SET(RED_GPIO[i], RED_PIN[i]);
000006  4c4c              LDR      r4,|L1.312|
;;;166        }
;;;167    
;;;168        if (s_which == 0)
;;;169        {
;;;170          // Cache the new colors for this eye
;;;171          s_color[0] = m_channels[0];
;;;172          s_color[1] = m_channels[1];
;;;173          s_color[2] = m_channels[2];
;;;174          s_color[3] = m_channels[3];
;;;175          s_which = 1; // Next time do other eye.
;;;176          // Select eye 1
;;;177          GPIO_RESET(GPIO_EYE1nEN, PIN_EYE1nEN);
;;;178        }
;;;179        else
;;;180        {
;;;181          // Cache the colors for this eye
;;;182          s_color[0] = m_channels[4];
;;;183          s_color[1] = m_channels[5];
;;;184          s_color[2] = m_channels[6];
;;;185          s_color[3] = m_channels[7];
;;;186          s_which = 0; // Next time do other eye
;;;187          // Select eye 2
;;;188          GPIO_RESET(GPIO_EYE2nEN, PIN_EYE2nEN);
;;;189        }  
;;;190          
;;;191        s_now = 255;
;;;192        
;;;193        // Now, we have to wait ~70uS for the other eye's gate to turn off
;;;194        TIM11->SR = 0;        // Acknowledge interrupt
000008  4e48              LDR      r6,|L1.300|
00000a  785a              LDRB     r2,[r3,#1]            ;158  ; s_now
;;;195        TIM11->ARR = 1000;    // Next time to trigger is 78uS
00000c  4f48              LDR      r7,|L1.304|
;;;196        TIM11->CR1 = TIM_CR1_CEN | TIM_CR1_URS | TIM_CR1_OPM; // Fire off one pulse  
00000e  f8df9124          LDR      r9,|L1.308|
000012  f04f080d          MOV      r8,#0xd
000016  f04f0c00          MOV      r12,#0
00001a  f1a40530          SUB      r5,r4,#0x30           ;165
00001e  b31a              CBZ      r2,|L1.104|
;;;197        return;    
;;;198      }
;;;199    
;;;200      // If the LED is due to turn, turn it on - if not, see if it is next to turn on
;;;201      nexttime = 0;
000020  2100              MOVS     r1,#0
;;;202      for (i=0; i<NUM_COLOR_CHANNELS; ++i)
000022  4608              MOV      r0,r1
;;;203      {
;;;204        if (s_now == s_color[i].asLEDs[CH_BLUE])
;;;205          GPIO_RESET(BLU_GPIO[i], BLU_PIN[i]);
000024  f1040a20          ADD      r10,r4,#0x20
                  |L1.40|
000028  f8dfb110          LDR      r11,|L1.316|
00002c  f81b3020          LDRB     r3,[r11,r0,LSL #2]    ;204
000030  4293              CMP      r3,r2                 ;204
000032  bf38              IT       CC                    ;204
000034  4619              MOVCC    r1,r3                 ;204
000036  d107              BNE      |L1.72|
000038  f8dfe104          LDR      lr,|L1.320|
00003c  f83a3020          LDRH     r3,[r10,r0,LSL #2]
000040  f85ee020          LDR      lr,[lr,r0,LSL #2]
000044  f8ae301a          STRH     r3,[lr,#0x1a]
                  |L1.72|
;;;206        else if (s_color[i].asLEDs[CH_BLUE] < s_now)
;;;207          nexttime = s_color[i].asLEDs[CH_BLUE];
;;;208    
;;;209        if (s_now == s_color[i].asLEDs[CH_GREEN])
000048  eb0b0b80          ADD      r11,r11,r0,LSL #2
00004c  f89b3001          LDRB     r3,[r11,#1]
000050  4293              CMP      r3,r2
000052  d147              BNE      |L1.228|
;;;210          GPIO_RESET(GRN_GPIO[i], GRN_PIN[i]);
000054  f8dfe0f0          LDR      lr,|L1.328|
000058  4b3a              LDR      r3,|L1.324|
00005a  f85ee020          LDR      lr,[lr,r0,LSL #2]
00005e  f8333020          LDRH     r3,[r3,r0,LSL #2]
000062  f8ae301a          STRH     r3,[lr,#0x1a]
000066  e040              B        |L1.234|
                  |L1.104|
000068  4838              LDR      r0,|L1.332|
00006a  f44f5280          MOV      r2,#0x1000            ;161
00006e  8002              STRH     r2,[r0,#0]            ;161
000070  4837              LDR      r0,|L1.336|
000072  f44f4a80          MOV      r10,#0x4000           ;162
000076  f8a0a000          STRH     r10,[r0,#0]           ;162
00007a  f04f0000          MOV      r0,#0                 ;163
                  |L1.126|
00007e  f855b020          LDR      r11,[r5,r0,LSL #2]    ;165
000082  f8341020          LDRH     r1,[r4,r0,LSL #2]     ;165
000086  f8ab1018          STRH     r1,[r11,#0x18]        ;165
00008a  f1000001          ADD      r0,r0,#1              ;165
00008e  b2c0              UXTB     r0,r0                 ;163
000090  280c              CMP      r0,#0xc               ;163
000092  d3f4              BCC      |L1.126|
000094  7819              LDRB     r1,[r3,#0]            ;168  ; s_which
000096  4829              LDR      r0,|L1.316|
000098  b1b1              CBZ      r1,|L1.200|
00009a  6a01              LDR      r1,[r0,#0x20]         ;182  ; _ZN4Anki5Cozmo3HAL10m_channelsE
00009c  6001              STR      r1,[r0,#0]            ;183  ; s_color
00009e  6a41              LDR      r1,[r0,#0x24]         ;183  ; _ZN4Anki5Cozmo3HAL10m_channelsE
0000a0  6041              STR      r1,[r0,#4]            ;184  ; s_color
0000a2  6a81              LDR      r1,[r0,#0x28]         ;184  ; _ZN4Anki5Cozmo3HAL10m_channelsE
0000a4  6081              STR      r1,[r0,#8]            ;185  ; s_color
0000a6  6ac1              LDR      r1,[r0,#0x2c]         ;185  ; _ZN4Anki5Cozmo3HAL10m_channelsE
0000a8  60c1              STR      r1,[r0,#0xc]          ;186  ; s_color
0000aa  482a              LDR      r0,|L1.340|
0000ac  f883c000          STRB     r12,[r3,#0]           ;186
0000b0  8002              STRH     r2,[r0,#0]            ;188
                  |L1.178|
0000b2  20ff              MOVS     r0,#0xff              ;191
0000b4  7058              STRB     r0,[r3,#1]            ;191
0000b6  f8a6c000          STRH     r12,[r6,#0]           ;194
0000ba  f44f707a          MOV      r0,#0x3e8             ;195
0000be  6038              STR      r0,[r7,#0]            ;195
0000c0  f8a98000          STRH     r8,[r9,#0]            ;196
;;;211        else if (s_color[i].asLEDs[CH_GREEN] < s_now && s_color[i].asLEDs[CH_GREEN] > nexttime)
;;;212          nexttime = s_color[i].asLEDs[CH_GREEN];
;;;213    
;;;214        if (s_now == s_color[i].asLEDs[CH_RED])
;;;215          GPIO_RESET(RED_GPIO[i], RED_PIN[i]);
;;;216        else if (s_color[i].asLEDs[CH_RED] < s_now && s_color[i].asLEDs[CH_RED] > nexttime)
;;;217          nexttime = s_color[i].asLEDs[CH_RED];
;;;218      }
;;;219      // Figure out how many cycles to wait before the next color turns on
;;;220      // Gamma correction requires us to use the square of intensity here (linear PWM = RGB^2)
;;;221      howlong = (s_now * s_now) - (nexttime * nexttime);  // Keep all 16-bits, since 1 is a valid result
;;;222      s_now = nexttime;    // Next time we get an interrupt, now will be nexttime!
;;;223      
;;;224      // Schedule the next timer interrupt
;;;225      TIM11->SR = 0;        // Acknowledge interrupt
;;;226      TIM11->ARR = howlong; // Next time to trigger
;;;227      TIM11->CR1 = TIM_CR1_CEN | TIM_CR1_URS | TIM_CR1_OPM; // Fire off one pulse
;;;228    }
0000c4  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.200|
0000c8  6901              LDR      r1,[r0,#0x10]         ;171  ; _ZN4Anki5Cozmo3HAL10m_channelsE
0000ca  6001              STR      r1,[r0,#0]            ;172  ; s_color
0000cc  6941              LDR      r1,[r0,#0x14]         ;172  ; _ZN4Anki5Cozmo3HAL10m_channelsE
0000ce  6041              STR      r1,[r0,#4]            ;173  ; s_color
0000d0  6981              LDR      r1,[r0,#0x18]         ;173  ; _ZN4Anki5Cozmo3HAL10m_channelsE
0000d2  6081              STR      r1,[r0,#8]            ;174  ; s_color
0000d4  69c1              LDR      r1,[r0,#0x1c]         ;174  ; _ZN4Anki5Cozmo3HAL10m_channelsE
0000d6  60c1              STR      r1,[r0,#0xc]          ;175  ; s_color
0000d8  2001              MOVS     r0,#1                 ;175
0000da  7018              STRB     r0,[r3,#0]            ;175
0000dc  481e              LDR      r0,|L1.344|
0000de  f8a0a000          STRH     r10,[r0,#0]           ;177
0000e2  e7e6              B        |L1.178|
                  |L1.228|
0000e4  bf3c              ITT      CC                    ;211
0000e6  4299              CMPCC    r1,r3                 ;211
0000e8  4619              MOVCC    r1,r3                 ;211
                  |L1.234|
0000ea  f89b3002          LDRB     r3,[r11,#2]           ;214
0000ee  4293              CMP      r3,r2                 ;214
0000f0  d106              BNE      |L1.256|
0000f2  f855b020          LDR      r11,[r5,r0,LSL #2]    ;215
0000f6  f8343020          LDRH     r3,[r4,r0,LSL #2]     ;215
0000fa  f8ab301a          STRH     r3,[r11,#0x1a]        ;215
0000fe  e002              B        |L1.262|
                  |L1.256|
000100  bf3c              ITT      CC                    ;216
000102  4299              CMPCC    r1,r3                 ;216
000104  4619              MOVCC    r1,r3                 ;216
                  |L1.262|
000106  1c40              ADDS     r0,r0,#1              ;216
000108  b2c0              UXTB     r0,r0                 ;202
00010a  2804              CMP      r0,#4                 ;202
00010c  d38c              BCC      |L1.40|
00010e  4b06              LDR      r3,|L1.296|
000110  fb12f002          SMULBB   r0,r2,r2              ;221
000114  fb010011          MLS      r0,r1,r1,r0           ;221
000118  7059              STRB     r1,[r3,#1]            ;222
00011a  f8a6c000          STRH     r12,[r6,#0]           ;225
00011e  6038              STR      r0,[r7,#0]            ;226
000120  f8a98000          STRH     r8,[r9,#0]            ;227
000124  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L1.296|
                          DCD      ||.data||
                  |L1.300|
                          DCD      0x40014810
                  |L1.304|
                          DCD      0x4001482c
                  |L1.308|
                          DCD      0x40014800
                  |L1.312|
                          DCD      ||.constdata||+0x4c
                  |L1.316|
                          DCD      ||.bss||
                  |L1.320|
                          DCD      ||.constdata||+0x3c
                  |L1.324|
                          DCD      ||.constdata||+0x5c
                  |L1.328|
                          DCD      ||.constdata||+0x2c
                  |L1.332|
                          DCD      0x40020418
                  |L1.336|
                          DCD      0x40020818
                  |L1.340|
                          DCD      0x4002041a
                  |L1.344|
                          DCD      0x4002081a

                          AREA ||i._ZN4Anki5Cozmo3HAL10LightsInitEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo3HAL10LightsInitEv PROC ; Anki::Cozmo::HAL::LightsInit()
;;;60           // Initialize LED head/face light hardware
;;;61           void LightsInit()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;62           {
;;;63             int i;
;;;64     
;;;65             RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000004  2101              MOVS     r1,#1
000006  b084              SUB      sp,sp,#0x10           ;62
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;66             RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
00000e  2101              MOVS     r1,#1
000010  2002              MOVS     r0,#2
000012  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;67             RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
000016  2101              MOVS     r1,#1
000018  2004              MOVS     r0,#4
00001a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;68             
;;;69             // Leave the high side pins off until first LED is set
;;;70             for (i=0; i<NUM_EYEnEN; ++i)
;;;71             {
;;;72               GPIO_SET(EYEnEN_GPIO[i], EYEnEN_PIN[i]);
00001e  4e4f              LDR      r6,|L2.348|
000020  2000              MOVS     r0,#0                 ;70
000022  2401              MOVS     r4,#1                 ;65
000024  f1a60c08          SUB      r12,r6,#8
;;;73               PIN_OD(EYEnEN_GPIO[i], EYEnEN_SOURCE[i]);
000028  f1a60314          SUB      r3,r6,#0x14
;;;74               PIN_OUT(EYEnEN_GPIO[i], EYEnEN_SOURCE[i]);
00002c  2503              MOVS     r5,#3
                  |L2.46|
00002e  f85c2020          LDR      r2,[r12,r0,LSL #2]    ;72
000032  f8361020          LDRH     r1,[r6,r0,LSL #2]     ;72
000036  8311              STRH     r1,[r2,#0x18]         ;72
000038  f85c1020          LDR      r1,[r12,r0,LSL #2]    ;73
00003c  684a              LDR      r2,[r1,#4]            ;73
00003e  5c1f              LDRB     r7,[r3,r0]            ;73
000040  fa04f707          LSL      r7,r4,r7              ;73
000044  433a              ORRS     r2,r2,r7              ;73
000046  604a              STR      r2,[r1,#4]            ;73
000048  f85c1020          LDR      r1,[r12,r0,LSL #2]
00004c  680f              LDR      r7,[r1,#0]
00004e  5c1a              LDRB     r2,[r3,r0]
000050  0052              LSLS     r2,r2,#1
000052  fa05f802          LSL      r8,r5,r2
000056  ea270708          BIC      r7,r7,r8
00005a  fa04f202          LSL      r2,r4,r2
00005e  433a              ORRS     r2,r2,r7
000060  600a              STR      r2,[r1,#0]
000062  1c40              ADDS     r0,r0,#1
000064  2802              CMP      r0,#2                 ;70
000066  dbe2              BLT      |L2.46|
;;;75             }
;;;76     
;;;77             // Initialize all face LED colors to OFF
;;;78             // Low side drivers must be open drain to allow voltages > VDD
;;;79             // Above arrays concatinate so starting with red and indexing past it
;;;80             const int num_color_gpio = NUM_COLOR_CHANNELS * 3;
;;;81             for (i=0; i<num_color_gpio; ++i)
;;;82             {
;;;83               GPIO_SET(RED_GPIO[i], RED_PIN[i]);
000068  4e3d              LDR      r6,|L2.352|
00006a  2000              MOVS     r0,#0                 ;81
00006c  f1a60330          SUB      r3,r6,#0x30
;;;84               PIN_NOPULL(RED_GPIO[i], CLR_SOURCE[i]);
000070  f1030c60          ADD      r12,r3,#0x60
                  |L2.116|
000074  f8532020          LDR      r2,[r3,r0,LSL #2]     ;83
000078  f8361020          LDRH     r1,[r6,r0,LSL #2]     ;83
00007c  8311              STRH     r1,[r2,#0x18]         ;83
00007e  f8531020          LDR      r1,[r3,r0,LSL #2]
000082  68ca              LDR      r2,[r1,#0xc]
000084  f81c7000          LDRB     r7,[r12,r0]
000088  007f              LSLS     r7,r7,#1
00008a  fa05f707          LSL      r7,r5,r7
00008e  43ba              BICS     r2,r2,r7
000090  60ca              STR      r2,[r1,#0xc]
;;;85               PIN_OD(RED_GPIO[i], CLR_SOURCE[i]);
000092  f8531020          LDR      r1,[r3,r0,LSL #2]
000096  684a              LDR      r2,[r1,#4]
000098  f81c7000          LDRB     r7,[r12,r0]
00009c  fa04f707          LSL      r7,r4,r7
0000a0  433a              ORRS     r2,r2,r7
0000a2  604a              STR      r2,[r1,#4]
;;;86               PIN_OUT(RED_GPIO[i], CLR_SOURCE[i]);
0000a4  f8531020          LDR      r1,[r3,r0,LSL #2]
0000a8  680f              LDR      r7,[r1,#0]
0000aa  f81c2000          LDRB     r2,[r12,r0]
0000ae  0052              LSLS     r2,r2,#1
0000b0  fa05f802          LSL      r8,r5,r2
0000b4  ea270708          BIC      r7,r7,r8
0000b8  fa04f202          LSL      r2,r4,r2
0000bc  433a              ORRS     r2,r2,r7
0000be  600a              STR      r2,[r1,#0]
0000c0  1c40              ADDS     r0,r0,#1
0000c2  280c              CMP      r0,#0xc               ;81
0000c4  dbd6              BLT      |L2.116|
;;;87             }
;;;88     
;;;89             // IR LED is controlled by N-FET so positive polarity unlike everything else
;;;90             GPIO_RESET(GPIO_IRLED, PIN_IRLED);
0000c6  4827              LDR      r0,|L2.356|
0000c8  f44f5180          MOV      r1,#0x1000
0000cc  8341              STRH     r1,[r0,#0x1a]
;;;91             PIN_PULLDOWN(GPIO_IRLED, SOURCE_IRLED);
0000ce  68c1              LDR      r1,[r0,#0xc]
0000d0  f0217140          BIC      r1,r1,#0x3000000
0000d4  f0417100          ORR      r1,r1,#0x2000000
0000d8  60c1              STR      r1,[r0,#0xc]
;;;92             PIN_PP(GPIO_IRLED, SOURCE_IRLED);
0000da  6841              LDR      r1,[r0,#4]
0000dc  f4215180          BIC      r1,r1,#0x1000
0000e0  6041              STR      r1,[r0,#4]
;;;93             PIN_OUT(GPIO_IRLED, SOURCE_IRLED);
0000e2  6801              LDR      r1,[r0,#0]
0000e4  f0217140          BIC      r1,r1,#0x3000000
0000e8  f0417180          ORR      r1,r1,#0x1000000
0000ec  6001              STR      r1,[r0,#0]
;;;94     
;;;95             // Initialize timer to rapidly blink LEDs, simulating dimming
;;;96             NVIC_InitTypeDef NVIC_InitStructure;
;;;97             TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;98     
;;;99             RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM11, ENABLE);
0000ee  2101              MOVS     r1,#1
0000f0  0488              LSLS     r0,r1,#18
0000f2  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;100    
;;;101            // Set up clock to multiplex the LEDs - must keep above 100Hz to hide flicker
;;;102            // 98Hz = 90MHz/2 eyes/(255^2)/(Prescaler+1)
;;;103            TIM_TimeBaseStructure.TIM_Prescaler = 6;
0000f6  2006              MOVS     r0,#6
0000f8  f8ad0000          STRH     r0,[sp,#0]
;;;104            TIM_TimeBaseStructure.TIM_Period = 65535;
0000fc  f64f70ff          MOV      r0,#0xffff
;;;105            TIM_TimeBaseStructure.TIM_ClockDivision = 0;
000100  2700              MOVS     r7,#0
;;;106            TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;107            TIM_TimeBaseInit(TIM11, &TIM_TimeBaseStructure);
000102  4e19              LDR      r6,|L2.360|
000104  9001              STR      r0,[sp,#4]            ;105
000106  f8ad7008          STRH     r7,[sp,#8]            ;105
00010a  f8ad7002          STRH     r7,[sp,#2]            ;106
00010e  4669              MOV      r1,sp
000110  4630              MOV      r0,r6
000112  f7fffffe          BL       TIM_TimeBaseInit
;;;108    
;;;109            // Enable timer and interrupts
;;;110            TIM_SelectOnePulseMode(TIM11, TIM_OPMode_Single);
000116  2108              MOVS     r1,#8
000118  4630              MOV      r0,r6
00011a  f7fffffe          BL       TIM_SelectOnePulseMode
;;;111            TIM_ITConfig(TIM11, TIM_IT_Update, ENABLE);
00011e  2201              MOVS     r2,#1
000120  4611              MOV      r1,r2
000122  4630              MOV      r0,r6
000124  f7fffffe          BL       TIM_ITConfig
;;;112            TIM_Cmd(TIM11, ENABLE);
000128  2101              MOVS     r1,#1
00012a  4630              MOV      r0,r6
00012c  f7fffffe          BL       TIM_Cmd
;;;113            TIM11->CR1 |= TIM_CR1_URS;  // Prevent spurious interrupt when we touch EGR
000130  8831              LDRH     r1,[r6,#0]
000132  f0410104          ORR      r1,r1,#4
000136  8031              STRH     r1,[r6,#0]
;;;114            TIM11->EGR = TIM_PSCReloadMode_Immediate;
000138  480c              LDR      r0,|L2.364|
00013a  8004              STRH     r4,[r0,#0]
;;;115    
;;;116            // Route interrupt
;;;117            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00013c  f88d400f          STRB     r4,[sp,#0xf]
;;;118            NVIC_InitStructure.NVIC_IRQChannel = TIM1_TRG_COM_TIM11_IRQn;
000140  201a              MOVS     r0,#0x1a
000142  f88d000c          STRB     r0,[sp,#0xc]
;;;119            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
000146  f88d500d          STRB     r5,[sp,#0xd]
;;;120            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00014a  f88d700e          STRB     r7,[sp,#0xe]
;;;121            NVIC_Init(&NVIC_InitStructure);
00014e  a803              ADD      r0,sp,#0xc
000150  f7fffffe          BL       NVIC_Init
;;;122          }
000154  b004              ADD      sp,sp,#0x10
000156  e8bd81f0          POP      {r4-r8,pc}
;;;123    
                          ENDP

00015a  0000              DCW      0x0000
                  |L2.348|
                          DCD      ||.constdata||+0x14
                  |L2.352|
                          DCD      ||.constdata||+0x4c
                  |L2.356|
                          DCD      0x40020000
                  |L2.360|
                          DCD      0x40014800
                  |L2.364|
                          DCD      0x40014814

                          AREA ||i._ZN4Anki5Cozmo3HAL13SetHeadlightsEb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo3HAL13SetHeadlightsEb PROC ; Anki::Cozmo::HAL::SetHeadlights(bool)
;;;131          // Turn headlights on (true) and off (false)
;;;132          void SetHeadlights(bool state)
000000  4903              LDR      r1,|L3.16|
;;;133          {
;;;134            if (state)
;;;135              GPIO_SET(GPIO_IRLED, PIN_IRLED);
000002  f44f5280          MOV      r2,#0x1000
000006  2800              CMP      r0,#0                 ;134
000008  bf14              ITE      NE
00000a  830a              STRHNE   r2,[r1,#0x18]
;;;136            else
;;;137              GPIO_RESET(GPIO_IRLED, PIN_IRLED);
00000c  834a              STRHEQ   r2,[r1,#0x1a]
;;;138          }
00000e  4770              BX       lr
;;;139        }
                          ENDP

                  |L3.16|
                          DCD      0x40020000

                          AREA ||i._ZN4Anki5Cozmo3HAL6SetLEDENS0_5LEDIdEj||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo3HAL6SetLEDENS0_5LEDIdEj PROC ; Anki::Cozmo::HAL::SetLED(Anki::Cozmo::LEDId, unsigned)
;;;124          // Light up one of the eye LEDs to the specified 24-bit RGB color
;;;125          void SetLED(LEDId led_id, u32 color)
000000  2808              CMP      r0,#8
;;;126          {
;;;127            if (led_id < NUM_LEDS)  // Unsigned, so always >= 0
;;;128              m_channels[HW_CHANNELS[led_id]].asColor = color;
;;;129          }
000002  bf28              IT       CS
000004  4770              BXCS     lr
000006  4a03              LDR      r2,|L4.20|
000008  5c10              LDRB     r0,[r2,r0]            ;128
00000a  4a03              LDR      r2,|L4.24|
00000c  f8421020          STR      r1,[r2,r0,LSL #2]     ;128
000010  4770              BX       lr
;;;130    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      ||.constdata||+0x2
                  |L4.24|
                          DCD      ||.bss||+0x10

                          AREA ||i.__sti___10_lights_cpp_bdf0f37f||, CODE, READONLY, ALIGN=2

                  __sti___10_lights_cpp_bdf0f37f PROC
000000  4803              LDR      r0,|L5.16|
000002  ed9f0a02          VLDR     s0,|L5.12|
000006  ed800a01          VSTR     s0,[r0,#4]
00000a  4770              BX       lr
                          ENDP

                  |L5.12|
00000c  423df6f2          DCFS     0x423df6f2 ; 47.491157531738281
                  |L5.16|
                          DCD      ||.data||

                          AREA ||.ARM.exidx||, LINKORDER=||i.TIM1_TRG_COM_TIM11_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.TIM1_TRG_COM_TIM11_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.7||, LINKORDER=||i._ZN4Anki5Cozmo3HAL10LightsInitEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo3HAL10LightsInitEv||
                          DCD      0x00000001

                          AREA ||area_number.8||, LINKORDER=||i._ZN4Anki5Cozmo3HAL6SetLEDENS0_5LEDIdEj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo3HAL6SetLEDENS0_5LEDIdEj||
                          DCD      0x00000001

                          AREA ||area_number.9||, LINKORDER=||i._ZN4Anki5Cozmo3HAL13SetHeadlightsEb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo3HAL13SetHeadlightsEb||
                          DCD      0x00000001

                          AREA ||area_number.10||, LINKORDER=||i.__sti___10_lights_cpp_bdf0f37f||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___10_lights_cpp_bdf0f37f||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_color
                          %        16
                  _ZN4Anki5Cozmo3HAL10m_channelsE ; Anki::Cozmo::HAL::m_channels
                          %        32

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo3HAL13EYEnEN_SOURCEE ; Anki::Cozmo::HAL::EYEnEN_SOURCE
000000  0e0c              DCB      0x0e,0x0c
                  _ZN4Anki5Cozmo3HAL11HW_CHANNELSE ; Anki::Cozmo::HAL::HW_CHANNELS
000002  0203              DCB      0x02,0x03
000004  01000607          DCB      0x01,0x00,0x06,0x07
000008  05040000          DCB      0x05,0x04,0x00,0x00
                  _ZN4Anki5Cozmo3HAL11EYEnEN_GPIOE ; Anki::Cozmo::HAL::EYEnEN_GPIO
                          DCD      0x40020800
                          DCD      0x40020400
                  _ZN4Anki5Cozmo3HAL10EYEnEN_PINE ; Anki::Cozmo::HAL::EYEnEN_PIN
                          DCD      0x00004000
                          DCD      0x00001000
                  _ZN4Anki5Cozmo3HAL8RED_GPIOE ; Anki::Cozmo::HAL::RED_GPIO
                          DCD      0x40020400
                          DCD      0x40020400
                          DCD      0x40020400
                          DCD      0x40020000
                  _ZN4Anki5Cozmo3HAL8GRN_GPIOE ; Anki::Cozmo::HAL::GRN_GPIO
                          DCD      0x40020400
                          DCD      0x40020000
                          DCD      0x40020800
                          DCD      0x40020400
                  _ZN4Anki5Cozmo3HAL8BLU_GPIOE ; Anki::Cozmo::HAL::BLU_GPIO
                          DCD      0x40020400
                          DCD      0x40020000
                          DCD      0x40020400
                          DCD      0x40020400
                  _ZN4Anki5Cozmo3HAL7RED_PINE ; Anki::Cozmo::HAL::RED_PIN
                          DCD      0x00000002
                          DCD      0x00000001
                          DCD      0x00000200
                          DCD      0x00008000
                  _ZN4Anki5Cozmo3HAL7GRN_PINE ; Anki::Cozmo::HAL::GRN_PIN
                          DCD      0x00000400
                          DCD      0x00000080
                          DCD      0x00002000
                          DCD      0x00000008
                  _ZN4Anki5Cozmo3HAL7BLU_PINE ; Anki::Cozmo::HAL::BLU_PIN
                          DCD      0x00000004
                          DCD      0x00000040
                          DCD      0x00000100
                          DCD      0x00000010
                  _ZN4Anki5Cozmo3HAL10CLR_SOURCEE ; Anki::Cozmo::HAL::CLR_SOURCE
00007c  0100090f          DCB      0x01,0x00,0x09,0x0f
000080  0a070d03          DCB      0x0a,0x07,0x0d,0x03
000084  02060804          DCB      0x02,0x06,0x08,0x04

                          AREA ||.data||, DATA, ALIGN=2

                  s_which
000000  00                DCB      0x00
                  s_now
000001  000000            DCB      0x00,0x00,0x00
                  _ZN4Anki5Cozmo21ROBOT_BOUNDING_RADIUSE ; Anki::Cozmo::ROBOT_BOUNDING_RADIUS
                          DCD      0x00000000

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___10_lights_cpp_bdf0f37f

;*** Start embedded assembler ***

#line 1 "arm_hal\\hal\\lights.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_lights_cpp_bdf0f37f___Z7__REV16j|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___10_lights_cpp_bdf0f37f___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_lights_cpp_bdf0f37f___Z7__REVSHi|
#line 144
|__asm___10_lights_cpp_bdf0f37f___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
