; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\lucaskanade_sampledplanar6dof.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\lucaskanade_sampledplanar6dof.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\lucaskanade_sampledplanar6dof.crf ..\coretech\vision\robot\src\lucasKanade_SampledPlanar6dof.cpp]
                          THUMB

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof11UpdateTrackERKNS0_5ArrayIhEEiffhRbRiS8_S8_NS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof11UpdateTrackERKNS0_5ArrayIhEEiffhRbRiS8_S8_NS0_11MemoryStackE PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::UpdateTrack(const Anki::Embedded::Array<unsigned char>&, int, float, float, unsigned char, bool&, int&, int&, int&, Anki::Embedded::MemoryStack)
;;;1273   
;;;1274         Result LucasKanadeTracker_SampledPlanar6dof::UpdateTrack(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1275           const Array<u8> &nextImage,
;;;1276           const s32 maxIterations,
;;;1277           const f32 convergenceTolerance_angle,
;;;1278           const f32 convergenceTolerance_distance,
;;;1279           const u8 verify_maxPixelDifference,
;;;1280           bool &verify_converged,
;;;1281           s32 &verify_meanAbsoluteDifference,
;;;1282           s32 &verify_numInBounds,
;;;1283           s32 &verify_numSimilarPixels,
;;;1284           MemoryStack scratch)
;;;1285         {
000004  4604              MOV      r4,r0
000006  ed2d0b02          VPUSH    {d0}
;;;1286           Result lastResult;
;;;1287   
;;;1288           Transformations::PlanarTransformation_f32 previousTransformation(this->transformation.get_transformType(), scratch);
00000a  3018              ADDS     r0,r0,#0x18
00000c  ed2d8b02          VPUSH    {d8}                  ;1285
000010  b0a9              SUB      sp,sp,#0xa4           ;1285
000012  eeb08a60          VMOV.F32 s16,s1                ;1285
000016  e9dd873c          LDRD     r8,r7,[sp,#0xf0]      ;1285
00001a  eef08a40          VMOV.F32 s17,s0                ;1285
00001e  9d3a              LDR      r5,[sp,#0xe8]
000020  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3217get_transformTypeEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_transformType() const
000024  4601              MOV      r1,r0
000026  a803              ADD      r0,sp,#0xc
000028  9a3e              LDR      r2,[sp,#0xf8]
00002a  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERNS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32(Anki::Embedded::Transformations::TransformType, Anki::Embedded::MemoryStack&)
;;;1289   
;;;1290           for(s32 iScale=numPyramidLevels-1; iScale>=0; iScale--) {
00002e  6860              LDR      r0,[r4,#4]
000030  1e46              SUBS     r6,r0,#1
000032  2e00              CMP      r6,#0
000034  bfa4              ITT      GE
000036  f04f0900          MOVGE    r9,#0
;;;1291             verify_converged = false;
;;;1292   
;;;1293             previousTransformation.Set(this->transformation);
;;;1294   
;;;1295             BeginBenchmark("UpdateTrack.refineTranslation");
;;;1296             if((lastResult = IterativelyRefineTrack(nextImage, maxIterations, iScale, convergenceTolerance_angle, convergenceTolerance_distance, Transformations::TRANSFORM_TRANSLATION, verify_converged, scratch)) != RESULT_OK)
00003a  f44f7a00          MOVGE    r10,#0x200
00003e  db5d              BLT      |L1.252|
                  |L1.64|
000040  f8859000          STRB     r9,[r5,#0]            ;1291
000044  f1040118          ADD      r1,r4,#0x18           ;1293
000048  a803              ADD      r0,sp,#0xc            ;1293
00004a  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f323SetERKS2_ ; Anki::Embedded::Transformations::PlanarTransformation_f32::Set(const Anki::Embedded::Transformations::PlanarTransformation_f32&)
00004e  a035              ADR      r0,|L1.292|
000050  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
000054  a81b              ADD      r0,sp,#0x6c
000056  993e              LDR      r1,[sp,#0xf8]
000058  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00005c  f8cda000          STR      r10,[sp,#0]
000060  e9cd5001          STRD     r5,r0,[sp,#4]
000064  e9dd122e          LDRD     r1,r2,[sp,#0xb8]
000068  eef00a48          VMOV.F32 s1,s16
00006c  eeb00a68          VMOV.F32 s0,s17
000070  4633              MOV      r3,r6
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof22IterativelyRefineTrackERKNS0_5ArrayIhEEiiffNS0_15Transformations13TransformTypeERbNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack(const Anki::Embedded::Array<unsigned char>&, int, int, float, float, Anki::Embedded::Transformations::TransformType, bool&, Anki::Embedded::MemoryStack)
000078  2800              CMP      r0,#0
;;;1297               return lastResult;
;;;1298             EndBenchmark("UpdateTrack.refineTranslation");
;;;1299   
;;;1300             if(verify_converged) {
;;;1301               previousTransformation.Set(this->transformation);
;;;1302   
;;;1303               if(this->transformation.get_transformType() != Transformations::TRANSFORM_TRANSLATION) {
;;;1304                 BeginBenchmark("UpdateTrack.refineOther");
;;;1305                 if((lastResult = IterativelyRefineTrack(nextImage, maxIterations, iScale, convergenceTolerance_angle, convergenceTolerance_distance, this->transformation.get_transformType(), verify_converged, scratch)) != RESULT_OK)
;;;1306                   return lastResult;
;;;1307                 EndBenchmark("UpdateTrack.refineOther");
;;;1308   
;;;1309                 if(!verify_converged) {
;;;1310                   // If full refinement didn't converge stick with translation
;;;1311                   // only result
;;;1312                   this->transformation.Set(previousTransformation);
;;;1313                 }
;;;1314               }
;;;1315             } else {
;;;1316               // If translation update didn't converge, replace with previous
;;;1317               // transformation
;;;1318               this->transformation.Set(previousTransformation);
;;;1319             }
;;;1320           } // for(s32 iScale=numPyramidLevels; iScale>=0; iScale--)
;;;1321   
;;;1322           //DEBUG!!!
;;;1323           //verify_converged = true;
;;;1324   
;;;1325           lastResult = this->VerifyTrack_Projective(nextImage, verify_maxPixelDifference, verify_meanAbsoluteDifference, verify_numInBounds, verify_numSimilarPixels, scratch);
;;;1326   
;;;1327           return lastResult;
;;;1328         }
00007a  bf1f              ITTTT    NE
00007c  b029              ADDNE    sp,sp,#0xa4
00007e  ecbd8b02          VPOPNE   {d8}
000082  b006              ADDNE    sp,sp,#0x18
000084  e8bd8ff0          POPNE    {r4-r11,pc}
000088  a026              ADR      r0,|L1.292|
00008a  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
00008e  7828              LDRB     r0,[r5,#0]            ;1300
000090  2800              CMP      r0,#0                 ;1300
000092  d02c              BEQ      |L1.238|
000094  f1040118          ADD      r1,r4,#0x18           ;1301
000098  a803              ADD      r0,sp,#0xc            ;1301
00009a  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f323SetERKS2_ ; Anki::Embedded::Transformations::PlanarTransformation_f32::Set(const Anki::Embedded::Transformations::PlanarTransformation_f32&)
00009e  f1040018          ADD      r0,r4,#0x18           ;1303
0000a2  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3217get_transformTypeEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_transformType() const
0000a6  f5b07f00          CMP      r0,#0x200             ;1303
0000aa  d025              BEQ      |L1.248|
0000ac  a025              ADR      r0,|L1.324|
0000ae  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
0000b2  a822              ADD      r0,sp,#0x88           ;1305
0000b4  993e              LDR      r1,[sp,#0xf8]         ;1305
0000b6  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0000ba  4683              MOV      r11,r0                ;1305
0000bc  f1040018          ADD      r0,r4,#0x18           ;1305
0000c0  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3217get_transformTypeEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_transformType() const
0000c4  e9cd0500          STRD     r0,r5,[sp,#0]         ;1305
0000c8  f8cdb008          STR      r11,[sp,#8]           ;1305
0000cc  e9dd122e          LDRD     r1,r2,[sp,#0xb8]      ;1305
0000d0  eef00a48          VMOV.F32 s1,s16                ;1305
0000d4  eeb00a68          VMOV.F32 s0,s17                ;1305
0000d8  4633              MOV      r3,r6                 ;1305
0000da  4620              MOV      r0,r4                 ;1305
0000dc  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof22IterativelyRefineTrackERKNS0_5ArrayIhEEiiffNS0_15Transformations13TransformTypeERbNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack(const Anki::Embedded::Array<unsigned char>&, int, int, float, float, Anki::Embedded::Transformations::TransformType, bool&, Anki::Embedded::MemoryStack)
0000e0  2800              CMP      r0,#0                 ;1305
0000e2  d119              BNE      |L1.280|
0000e4  a017              ADR      r0,|L1.324|
0000e6  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
0000ea  7828              LDRB     r0,[r5,#0]            ;1309
0000ec  b920              CBNZ     r0,|L1.248|
                  |L1.238|
0000ee  a903              ADD      r1,sp,#0xc            ;1312
0000f0  f1040018          ADD      r0,r4,#0x18           ;1312
0000f4  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f323SetERKS2_ ; Anki::Embedded::Transformations::PlanarTransformation_f32::Set(const Anki::Embedded::Transformations::PlanarTransformation_f32&)
                  |L1.248|
0000f8  1e76              SUBS     r6,r6,#1              ;1290
0000fa  d5a1              BPL      |L1.64|
                  |L1.252|
0000fc  a814              ADD      r0,sp,#0x50           ;1325
0000fe  993e              LDR      r1,[sp,#0xf8]         ;1325
000100  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000104  f8cd8000          STR      r8,[sp,#0]            ;1325
000108  e9cd7001          STRD     r7,r0,[sp,#4]         ;1325
00010c  4620              MOV      r0,r4                 ;1325
00010e  9b3b              LDR      r3,[sp,#0xec]         ;1325
000110  9a30              LDR      r2,[sp,#0xc0]         ;1325
000112  992e              LDR      r1,[sp,#0xb8]         ;1325
000114  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof22VerifyTrack_ProjectiveERKNS0_5ArrayIhEEhRiS7_S7_NS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifyTrack_Projective(const Anki::Embedded::Array<unsigned char>&, unsigned char, int&, int&, int&, Anki::Embedded::MemoryStack)
                  |L1.280|
000118  b029              ADD      sp,sp,#0xa4
00011a  ecbd8b02          VPOP     {d8}
00011e  b006              ADD      sp,sp,#0x18
000120  e8bd8ff0          POP      {r4-r11,pc}
;;;1329   
                          ENDP

                  |L1.292|
000124  55706461          DCB      "UpdateTrack.refineTranslation",0
000128  74655472
00012c  61636b2e
000130  72656669
000134  6e655472
000138  616e736c
00013c  6174696f
000140  6e00    
000142  00                DCB      0
000143  00                DCB      0
                  |L1.324|
000144  55706461          DCB      "UpdateTrack.refineOther",0
000148  74655472
00014c  61636b2e
000150  72656669
000154  6e654f74
000158  68657200

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17ApproximateSelectERKNS0_5ArrayIfEEiiRiRNS3_IiEE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17ApproximateSelectERKNS0_5ArrayIfEEiiRiRNS3_IiEE PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::ApproximateSelect(const Anki::Embedded::Array<float>&, int, int, int&, Anki::Embedded::Array<int>&)
;;;2093   
;;;2094         Result LucasKanadeTracker_SampledPlanar6dof::ApproximateSelect(const Array<f32> &magnitudeVector, const s32 numBins, const s32 numToSelect, s32 &numSelected, Array<s32> &magnitudeIndexes)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;2095         {
000004  4604              MOV      r4,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  461d              MOV      r5,r3
00000c  4617              MOV      r7,r2
00000e  4689              MOV      r9,r1
;;;2096           const f32 maxMagnitude = Matrix::Max<f32>(magnitudeVector);
000010  e894110e          LDM      r4,{r1-r3,r8,r12}
000014  b093              SUB      sp,sp,#0x4c           ;2095
000016  a805              ADD      r0,sp,#0x14
000018  9e1c              LDR      r6,[sp,#0x70]
00001a  e88d110e          STM      sp,{r1-r3,r8,r12}
00001e  f04f0800          MOV      r8,#0
000022  4669              MOV      r1,sp
000024  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
000028  f8808030          STRB     r8,[r0,#0x30]
00002c  f7fffffe          BL       _ZN4Anki8Embedded6Matrix3MaxIfEET_RKNS0_25ConstArraySliceExpressionIS3_EE ; Anki::Embedded::Matrix::Max<float>(const Anki::Embedded::ConstArraySliceExpression<T1>&)
000030  eeb08a40          VMOV.F32 s16,s0
;;;2097   
;;;2098           const f32 magnitudeIncrement = maxMagnitude / static_cast<f32>(numBins);
000034  ee009a10          VMOV     s0,r9
;;;2099   
;;;2100           // For each threshold, count the number above the threshold
;;;2101           // If the number is low enough, copy the appropriate indexes and return
;;;2102   
;;;2103           const s32 numMagnitudes = magnitudeVector.get_size(1);
000038  2101              MOVS     r1,#1
00003a  4620              MOV      r0,r4
00003c  eeb80ac0          VCVT.F32.S32 s0,s0                 ;2098
000040  eec88a00          VDIV.F32 s17,s16,s0            ;2098
000044  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
;;;2104   
;;;2105           const f32 * restrict pMagnitudeVector = magnitudeVector.Pointer(0,0);
;;;2106   
;;;2107           numSelected = 0;
;;;2108   
;;;2109           f32 foundThreshold = -1.0f;
;;;2110           for(f32 threshold=0; threshold<maxMagnitude; threshold+=magnitudeIncrement) {
000048  eddf0a39          VLDR     s1,|L2.304|
00004c  2100              MOVS     r1,#0                 ;2105
00004e  68a3              LDR      r3,[r4,#8]            ;2105
000050  6922              LDR      r2,[r4,#0x10]         ;2105
000052  eef40ac8          VCMPE.F32 s1,s16
000056  eeff1a00          VMOV.F32 s3,#-1.00000000       ;2109
00005a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00005e  fb012403          MLA      r4,r1,r3,r2
000062  6029              STR      r1,[r5,#0]
000064  d21e              BCS      |L2.164|
                  |L2.102|
;;;2111             s32 numAbove = 0;
000066  f04f0c00          MOV      r12,#0
;;;2112             for(s32 i=0; i<numMagnitudes; i++) {
00006a  4661              MOV      r1,r12
00006c  2800              CMP      r0,#0
00006e  dd0d              BLE      |L2.140|
                  |L2.112|
;;;2113               if(pMagnitudeVector[i] > threshold) {
000070  eb040281          ADD      r2,r4,r1,LSL #2
000074  ed921a00          VLDR     s2,[r2,#0]
000078  eeb41ae0          VCMPE.F32 s2,s1
00007c  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;2114                 numAbove++;
000080  bfc8              IT       GT
000082  f10c0c01          ADDGT    r12,r12,#1
000086  1c49              ADDS     r1,r1,#1              ;2112
000088  4281              CMP      r1,r0                 ;2112
00008a  dbf1              BLT      |L2.112|
                  |L2.140|
;;;2115               }
;;;2116             }
;;;2117   
;;;2118             if(numAbove <= numToSelect) {
00008c  45bc              CMP      r12,r7
00008e  dc02              BGT      |L2.150|
;;;2119               foundThreshold = threshold;
000090  eef01a60          VMOV.F32 s3,s1
;;;2120               break;
000094  e006              B        |L2.164|
                  |L2.150|
000096  ee700aa8          VADD.F32 s1,s1,s17             ;2110
00009a  eef40ac8          VCMPE.F32 s1,s16                ;2110
00009e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;2110
0000a2  d3e0              BCC      |L2.102|
                  |L2.164|
;;;2121             }
;;;2122           }
;;;2123   
;;;2124           if(foundThreshold < -0.1f) {
0000a4  ee111a90          VMOV     r1,s3
0000a8  4a22              LDR      r2,|L2.308|
0000aa  428a              CMP      r2,r1
0000ac  d221              BCS      |L2.242|
0000ae  6930              LDR      r0,[r6,#0x10]
0000b0  b198              CBZ      r0,|L2.218|
0000b2  6830              LDR      r0,[r6,#0]
0000b4  2800              CMP      r0,#0
0000b6  bfa4              ITT      GE
0000b8  6870              LDRGE    r0,[r6,#4]
0000ba  2800              CMPGE    r0,#0
0000bc  db0d              BLT      |L2.218|
0000be  2100              MOVS     r1,#0
0000c0  4630              MOV      r0,r6
0000c2  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
0000c6  4601              MOV      r1,r0
0000c8  68b0              LDR      r0,[r6,#8]
0000ca  6933              LDR      r3,[r6,#0x10]
0000cc  4341              MULS     r1,r0,r1
0000ce  2200              MOVS     r2,#0
0000d0  fb023000          MLA      r0,r2,r0,r3
0000d4  f7fffffe          BL       __aeabi_memclr4
0000d8  e024              B        |L2.292|
                  |L2.218|
0000da  f2402176          MOV      r1,#0x276
0000de  4816              LDR      r0,|L2.312|
0000e0  e9cd0100          STRD     r0,r1,[sp,#0]
0000e4  a315              ADR      r3,|L2.316|
0000e6  a223              ADR      r2,|L2.372|
0000e8  a129              ADR      r1,|L2.400|
0000ea  2005              MOVS     r0,#5
0000ec  f7fffffe          BL       _Anki_Log
0000f0  e018              B        |L2.292|
                  |L2.242|
;;;2125             AnkiWarn("LucasKanadeTracker_SampledPlanar6dof::ApproximateSelect", "Could not find valid threshold");
;;;2126             magnitudeIndexes.SetZero();
;;;2127             return RESULT_OK;
;;;2128           }
;;;2129   
;;;2130           s32 * restrict pMagnitudeIndexes = magnitudeIndexes.Pointer(0,0);
0000f2  2100              MOVS     r1,#0
0000f4  68b3              LDR      r3,[r6,#8]
0000f6  6932              LDR      r2,[r6,#0x10]
;;;2131   
;;;2132           for(s32 i=0; i<numMagnitudes; i++) {
0000f8  2800              CMP      r0,#0
0000fa  fb012203          MLA      r2,r1,r3,r2
0000fe  dd11              BLE      |L2.292|
                  |L2.256|
;;;2133             if(pMagnitudeVector[i] > foundThreshold) {
000100  eb040381          ADD      r3,r4,r1,LSL #2
000104  ed930a00          VLDR     s0,[r3,#0]
000108  eeb40ae1          VCMPE.F32 s0,s3
00010c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000110  dd05              BLE      |L2.286|
;;;2134               pMagnitudeIndexes[numSelected] = i;
000112  682b              LDR      r3,[r5,#0]
000114  f8421023          STR      r1,[r2,r3,LSL #2]
;;;2135               numSelected++;
000118  682b              LDR      r3,[r5,#0]
00011a  1c5b              ADDS     r3,r3,#1
00011c  602b              STR      r3,[r5,#0]
                  |L2.286|
00011e  1c49              ADDS     r1,r1,#1              ;2132
000120  4281              CMP      r1,r0                 ;2132
000122  dbed              BLT      |L2.256|
                  |L2.292|
;;;2136             }
;;;2137           }
;;;2138   
;;;2139           return RESULT_OK;
;;;2140         } // ApproximateSelect()
000124  b013              ADD      sp,sp,#0x4c
000126  2000              MOVS     r0,#0                 ;2139
000128  ecbd8b02          VPOP     {d8}
00012c  e8bd83f0          POP      {r4-r9,pc}
;;;2141   
                          ENDP

                  |L2.304|
000130  00000000          DCFS     0x00000000 ; 0
                  |L2.308|
                          DCD      0xbdcccccd
                  |L2.312|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::SetZero()::__PRETTY_FUNCTION__
                  |L2.316|
00013c  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000140  6f726574
000144  6563685c
000148  636f6d6d
00014c  6f6e5c69
000150  6e636c75
000154  64655c61
000158  6e6b692f
00015c  636f6d6d
000160  6f6e2f72
000164  6f626f74
000168  2f617272
00016c  617932  
00016f  642e6800          DCB      "d.h",0
000173  00                DCB      0
                  |L2.372|
000174  41727261          DCB      "Array<Type> is not valid",0
000178  793c5479
00017c  70653e20
000180  6973206e
000184  6f742076
000188  616c6964
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L2.400|
000190  41727261          DCB      "Array<Type>::SetZero",0
000194  793c5479
000198  70653e3a
00019c  3a536574
0001a0  5a65726f
0001a4  00      
0001a5  00                DCB      0
0001a6  00                DCB      0
0001a7  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17ApproximateSelectERKNS0_5ArrayIfEEiiiRiRNS3_IiEE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17ApproximateSelectERKNS0_5ArrayIfEEiiiRiRNS3_IiEE PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::ApproximateSelect(const Anki::Embedded::Array<float>&, int, int, int, int&, Anki::Embedded::Array<int>&)
;;;2141   
;;;2142         Result LucasKanadeTracker_SampledPlanar6dof::ApproximateSelect(const Array<f32> &magnitudeImage, const s32 numBins, const s32 numRegions, const s32 numToSelect, s32 &numSelected, Array<s32> &magnitudeIndexes)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2143         {
000004  4606              MOV      r6,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  b0b3              SUB      sp,sp,#0xcc
;;;2144           //magnitudeImage.Show("magnitudeImage", false);
;;;2145   
;;;2146           // For each threshold, count the number above the threshold
;;;2147           // If the number is low enough, copy the appropriate indexes and return
;;;2148   
;;;2149           const s32 nrows = magnitudeImage.get_size(0);
00000c  2100              MOVS     r1,#0
00000e  e9dd8442          LDRD     r8,r4,[sp,#0x108]     ;2143
000012  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000016  4605              MOV      r5,r0
;;;2150           const s32 ncols = magnitudeImage.get_size(1);
000018  2101              MOVS     r1,#1
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
;;;2151   
;;;2152           AnkiConditionalErrorAndReturnValue(magnitudeIndexes.get_size(0)*magnitudeIndexes.get_size(1) == nrows*ncols, RESULT_FAIL_INVALID_SIZE, "LucasKanadeTracker_SampledPlanar6dof::ApproximateSelect()", "Size of magnitudeIndexes vector does not match size of magnitudeImage.\n");
000020  902c              STR      r0,[sp,#0xb0]
000022  2100              MOVS     r1,#0
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
00002a  4607              MOV      r7,r0
00002c  2101              MOVS     r1,#1
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
000034  fb07f100          MUL      r1,r7,r0
000038  982c              LDR      r0,[sp,#0xb0]
00003a  4368              MULS     r0,r5,r0
00003c  4281              CMP      r1,r0
00003e  d013              BEQ      |L3.104|
000040  489e              LDR      r0,|L3.700|
000042  f6400168          MOV      r1,#0x868
000046  e9cd0100          STRD     r0,r1,[sp,#0]
00004a  f2003269          ADD      r2,r0,#0x369
00004e  a39c              ADR      r3,|L3.704|
000050  a1ab              ADR      r1,|L3.768|
000052  2005              MOVS     r0,#5
000054  f7fffffe          BL       _Anki_Log
000058  f04f60a0          MOV      r0,#0x5000000
                  |L3.92|
;;;2153   
;;;2154           numSelected = 0;
;;;2155           s32 * restrict pMagnitudeIndexes = magnitudeIndexes.Pointer(0,0);
;;;2156   
;;;2157           const s32 regionRows = magnitudeImage.get_size(0) / numRegions;
;;;2158           const s32 regionCols = magnitudeImage.get_size(1) / numRegions;
;;;2159   
;;;2160           s32 numRegionsLeft = numRegions*numRegions;
;;;2161   
;;;2162           for(s32 i_region=0; i_region<numRegions; ++i_region) {
;;;2163             const s32 i_min = i_region * regionRows;
;;;2164             const s32 i_max = i_min + regionRows;
;;;2165   
;;;2166             for(s32 j_region=0; j_region<numRegions; ++j_region) {
;;;2167               const s32 j_min = j_region*regionCols;
;;;2168               const s32 j_max = j_min + regionCols;
;;;2169   
;;;2170               ConstArraySlice<f32> currentRegion = magnitudeImage(i_min, i_max-1, j_min, j_max-1);
;;;2171               const f32 maxMagnitude = Matrix::Max<f32>(currentRegion);
;;;2172               const f32 minMagnitude = 0.5f*maxMagnitude; // + Matrix::Min<f32>(currentRegion));
;;;2173   
;;;2174               if(maxMagnitude == minMagnitude) {
;;;2175                 // This would result in magnitudeIncrement==0 below
;;;2176                 continue;
;;;2177               }
;;;2178   
;;;2179               const f32 magnitudeIncrement = (maxMagnitude-minMagnitude) / static_cast<f32>(numBins);
;;;2180   
;;;2181               const s32 numToSelectThisRegion = (numToSelect-numSelected)/numRegionsLeft;
;;;2182               //const s32 numToSelectThisRegion = numToSelect / (numRegions*numRegions);
;;;2183   
;;;2184               f32 foundThreshold = -1.0f;
;;;2185               for(f32 threshold=minMagnitude; threshold<maxMagnitude; threshold+=magnitudeIncrement) {
;;;2186                 s32 numAbove = 0;
;;;2187                 for(s32 i=i_min; i<i_max; i++) {
;;;2188                   const f32 * restrict mag_i = magnitudeImage.Pointer(i,0);
;;;2189                   for(s32 j=j_min; j<j_max; j++) {
;;;2190                     if(mag_i[j] > threshold) {
;;;2191                       numAbove++;
;;;2192                     }
;;;2193                   }
;;;2194                 }
;;;2195   
;;;2196                 if(numAbove <= numToSelectThisRegion) {
;;;2197                   foundThreshold = threshold;
;;;2198                   break;
;;;2199                 }
;;;2200               } // for each threshold
;;;2201   
;;;2202               /*
;;;2203               if(foundThreshold < -0.1f) {
;;;2204               AnkiWarn("LucasKanadeTracker_SampledPlanar6dof::ApproximateSelect",
;;;2205               "Could not find valid threshold for region (%d,%d).", i_region, j_region);
;;;2206               magnitudeIndexes.SetZero();
;;;2207               return RESULT_OK;
;;;2208               }
;;;2209               */
;;;2210   
;;;2211               if(foundThreshold > 0.f) {
;;;2212                 s32 numSelectedThisRegion = 0;
;;;2213                 for(s32 i=i_min; i<i_max; i++) {
;;;2214                   const f32 * restrict mag_i = magnitudeImage.Pointer(i,0);
;;;2215   
;;;2216                   for(s32 j=j_min; j<j_max && numSelectedThisRegion < numToSelectThisRegion; j++) {
;;;2217                     if(mag_i[j] > foundThreshold) {
;;;2218                       pMagnitudeIndexes[numSelected++] = i*ncols + j;
;;;2219   
;;;2220                       ++numSelectedThisRegion;
;;;2221                     }
;;;2222                   }
;;;2223                 }
;;;2224   
;;;2225                 //AnkiWarn("ApproximateSelect", "Finished region (%d,%d), have %d selected.\n", i_region, j_region, numSelected);
;;;2226               } // if(foundThreshold > 0.f)
;;;2227   
;;;2228               --numRegionsLeft;
;;;2229             } // for j_region
;;;2230           } // for i_region
;;;2231   
;;;2232           return RESULT_OK;
;;;2233         }
00005c  b033              ADD      sp,sp,#0xcc
00005e  ecbd8b02          VPOP     {d8}
000062  b004              ADD      sp,sp,#0x10
000064  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.104|
000068  2500              MOVS     r5,#0                 ;2154
00006a  f8c85000          STR      r5,[r8,#0]            ;2154
00006e  68a1              LDR      r1,[r4,#8]            ;2154
000070  6920              LDR      r0,[r4,#0x10]         ;2154
000072  fb050a01          MLA      r10,r5,r1,r0          ;2154
000076  4629              MOV      r1,r5                 ;2157
000078  4630              MOV      r0,r6                 ;2157
00007a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00007e  9937              LDR      r1,[sp,#0xdc]         ;2157
000080  fb90f0f1          SDIV     r0,r0,r1              ;2157
000084  902a              STR      r0,[sp,#0xa8]         ;2158
000086  2101              MOVS     r1,#1                 ;2158
000088  4630              MOV      r0,r6                 ;2158
00008a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00008e  9937              LDR      r1,[sp,#0xdc]         ;2158
000090  fb90f0f1          SDIV     r0,r0,r1              ;2158
000094  9028              STR      r0,[sp,#0xa0]         ;2160
000096  fb01f001          MUL      r0,r1,r1              ;2160
00009a  9001              STR      r0,[sp,#4]            ;2162
00009c  2000              MOVS     r0,#0                 ;2162
00009e  902b              STR      r0,[sp,#0xac]         ;2162
0000a0  2900              CMP      r1,#0                 ;2162
0000a2  bfc4              ITT      GT                    ;2172
0000a4  eddf8aa5          VLDRGT   s17,|L3.828|
0000a8  ed9f8aa5          VLDRGT   s16,|L3.832|
0000ac  f3408103          BLE.W    |L3.694|
                  |L3.176|
0000b0  e9dd102a          LDRD     r1,r0,[sp,#0xa8]      ;2162
0000b4  4348              MULS     r0,r1,r0              ;2163
0000b6  1847              ADDS     r7,r0,r1              ;2164
0000b8  9029              STR      r0,[sp,#0xa4]         ;2166
0000ba  2000              MOVS     r0,#0                 ;2166
0000bc  9027              STR      r0,[sp,#0x9c]         ;2166
0000be  9837              LDR      r0,[sp,#0xdc]         ;2166
0000c0  2800              CMP      r0,#0                 ;2166
0000c2  f34080f1          BLE.W    |L3.680|
                  |L3.198|
0000c6  e9dd0127          LDRD     r0,r1,[sp,#0x9c]      ;2166
0000ca  fb00f901          MUL      r9,r0,r1              ;2167
0000ce  eb090501          ADD      r5,r9,r1              ;2168
0000d2  6830              LDR      r0,[r6,#0]            ;2168
0000d4  9000              STR      r0,[sp,#0]            ;2168
0000d6  1e7b              SUBS     r3,r7,#1              ;2170
0000d8  1e6c              SUBS     r4,r5,#1              ;2170
0000da  9929              LDR      r1,[sp,#0xa4]         ;2170
0000dc  2201              MOVS     r2,#1                 ;2170
0000de  a830              ADD      r0,sp,#0xc0           ;2170
0000e0  f7fffffe          BL       _ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i ; Anki::Embedded::IndexSequence<int>(T1, T1, T1, int)
0000e4  6870              LDR      r0,[r6,#4]            ;2170
0000e6  9000              STR      r0,[sp,#0]            ;2170
0000e8  4623              MOV      r3,r4                 ;2170
0000ea  2201              MOVS     r2,#1                 ;2170
0000ec  4649              MOV      r1,r9                 ;2170
0000ee  a82d              ADD      r0,sp,#0xb4           ;2170
0000f0  f7fffffe          BL       _ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i ; Anki::Embedded::IndexSequence<int>(T1, T1, T1, int)
0000f4  e9dd0130          LDRD     r0,r1,[sp,#0xc0]      ;2170
0000f8  9a32              LDR      r2,[sp,#0xc8]         ;2170
0000fa  9204              STR      r2,[sp,#0x10]         ;2170
0000fc  e9cd0102          STRD     r0,r1,[sp,#8]         ;2170
000100  e9dd012d          LDRD     r0,r1,[sp,#0xb4]      ;2170
000104  9a2f              LDR      r2,[sp,#0xbc]         ;2170
000106  9207              STR      r2,[sp,#0x1c]         ;2170
000108  e9cd0105          STRD     r0,r1,[sp,#0x14]      ;2170
00010c  e896100f          LDM      r6,{r0-r3,r12}        ;2170
000110  ac08              ADD      r4,sp,#0x20           ;2170
000112  e8a4100f          STM      r4!,{r0-r3,r12}       ;2170
000116  6831              LDR      r1,[r6,#0]            ;2170
000118  2900              CMP      r1,#0                 ;2170
00011a  bfc4              ITT      GT                    ;2170
00011c  6870              LDRGT    r0,[r6,#4]            ;2170
00011e  2800              CMPGT    r0,#0                 ;2170
000120  dd7e              BLE      |L3.544|
000122  4348              MULS     r0,r1,r0              ;2170
000124  2800              CMP      r0,#0                 ;2170
000126  d07f              BEQ      |L3.552|
000128  68b2              LDR      r2,[r6,#8]            ;2170
00012a  6931              LDR      r1,[r6,#0x10]         ;2170
00012c  2000              MOVS     r0,#0                 ;2170
00012e  fb001002          MLA      r0,r0,r2,r1           ;2170
                  |L3.306|
000132  900d              STR      r0,[sp,#0x34]         ;2170
000134  e9dd2304          LDRD     r2,r3,[sp,#0x10]      ;2170
000138  e9dd0102          LDRD     r0,r1,[sp,#8]         ;2170
00013c  e9dd4b07          LDRD     r4,r11,[sp,#0x1c]     ;2170
000140  f8dde024          LDR      lr,[sp,#0x24]         ;2170
000144  f8ddc018          LDR      r12,[sp,#0x18]        ;2170
000148  f8cde054          STR      lr,[sp,#0x54]         ;2170
00014c  f8cdc048          STR      r12,[sp,#0x48]        ;2170
000150  e9cd010e          STRD     r0,r1,[sp,#0x38]      ;2170
000154  e9cd2310          STRD     r2,r3,[sp,#0x40]      ;2170
000158  e9cd4b13          STRD     r4,r11,[sp,#0x4c]     ;2170
00015c  e9dd010a          LDRD     r0,r1,[sp,#0x28]      ;2170
000160  e9dd230c          LDRD     r2,r3,[sp,#0x30]      ;2170
000164  e9cd0116          STRD     r0,r1,[sp,#0x58]      ;2170
000168  a81a              ADD      r0,sp,#0x68           ;2171
00016a  9000              STR      r0,[sp,#0]            ;2171
00016c  2000              MOVS     r0,#0                 ;2171
00016e  9002              STR      r0,[sp,#8]            ;2171
000170  e9cd2318          STRD     r2,r3,[sp,#0x60]      ;2171
000174  e9dd010e          LDRD     r0,r1,[sp,#0x38]      ;2171
000178  e9dd2310          LDRD     r2,r3,[sp,#0x40]      ;2171
00017c  f8cde084          STR      lr,[sp,#0x84]         ;2171
000180  f8cdc078          STR      r12,[sp,#0x78]        ;2171
000184  e9cd011a          STRD     r0,r1,[sp,#0x68]      ;2171
000188  e9cd231c          STRD     r2,r3,[sp,#0x70]      ;2171
00018c  e9cd4b1f          STRD     r4,r11,[sp,#0x7c]     ;2171
000190  ac16              ADD      r4,sp,#0x58           ;2171
000192  cc0f              LDM      r4!,{r0-r3}           ;2171
000194  ac22              ADD      r4,sp,#0x88           ;2171
000196  c40f              STM      r4!,{r0-r3}           ;2171
000198  9802              LDR      r0,[sp,#8]            ;2171
00019a  f88d0098          STRB     r0,[sp,#0x98]         ;2171
00019e  9800              LDR      r0,[sp,#0]            ;2171
0001a0  f7fffffe          BL       _ZN4Anki8Embedded6Matrix3MaxIfEET_RKNS0_25ConstArraySliceExpressionIS3_EE ; Anki::Embedded::Matrix::Max<float>(const Anki::Embedded::ConstArraySliceExpression<T1>&)
0001a4  ee600a28          VMUL.F32 s1,s0,s17             ;2172
0001a8  eeb40a60          VCMP.F32 s0,s1                 ;2174
0001ac  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;2174
0001b0  d073              BEQ      |L3.666|
0001b2  9836              LDR      r0,[sp,#0xd8]         ;2179
0001b4  ee701a60          VSUB.F32 s3,s0,s1              ;2179
0001b8  ee010a10          VMOV     s2,r0                 ;2179
0001bc  f8d81000          LDR      r1,[r8,#0]            ;2181
0001c0  9838              LDR      r0,[sp,#0xe0]         ;2181
0001c2  eeb81ac1          VCVT.F32.S32 s2,s2                 ;2179
0001c6  1a41              SUBS     r1,r0,r1              ;2181
0001c8  9801              LDR      r0,[sp,#4]            ;2181
0001ca  eeb40ae0          VCMPE.F32 s0,s1                 ;2185
0001ce  ee812a81          VDIV.F32 s4,s3,s2              ;2179
0001d2  fb91fbf0          SDIV     r11,r1,r0             ;2181
0001d6  eef01a48          VMOV.F32 s3,s16                ;2184
0001da  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;2185
0001de  dd2c              BLE      |L3.570|
                  |L3.480|
0001e0  9929              LDR      r1,[sp,#0xa4]         ;2187
0001e2  2200              MOVS     r2,#0                 ;2186
0001e4  42b9              CMP      r1,r7                 ;2187
0001e6  bfbc              ITT      LT                    ;2187
0001e8  f8d6c010          LDRLT    r12,[r6,#0x10]        ;2187
0001ec  68b4              LDRLT    r4,[r6,#8]            ;2187
0001ee  da14              BGE      |L3.538|
                  |L3.496|
0001f0  fb01c304          MLA      r3,r1,r4,r12          ;2187
0001f4  4648              MOV      r0,r9                 ;2189
0001f6  45a9              CMP      r9,r5                 ;2189
0001f8  da0c              BGE      |L3.532|
                  |L3.506|
0001fa  eb030e80          ADD      lr,r3,r0,LSL #2       ;2190
0001fe  ed9e1a00          VLDR     s2,[lr,#0]            ;2190
000202  eeb41ae0          VCMPE.F32 s2,s1                 ;2190
000206  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;2190
00020a  bfc8              IT       GT                    ;2191
00020c  1c52              ADDGT    r2,r2,#1              ;2191
00020e  1c40              ADDS     r0,r0,#1              ;2189
000210  42a8              CMP      r0,r5                 ;2189
000212  dbf2              BLT      |L3.506|
                  |L3.532|
000214  1c49              ADDS     r1,r1,#1              ;2187
000216  42b9              CMP      r1,r7                 ;2187
000218  dbea              BLT      |L3.496|
                  |L3.538|
00021a  455a              CMP      r2,r11                ;2196
00021c  dc06              BGT      |L3.556|
00021e  e000              B        |L3.546|
                  |L3.544|
000220  e002              B        |L3.552|
                  |L3.546|
000222  eef01a60          VMOV.F32 s3,s1                 ;2197
000226  e008              B        |L3.570|
                  |L3.552|
000228  2000              MOVS     r0,#0                 ;2198
00022a  e782              B        |L3.306|
                  |L3.556|
00022c  ee700a82          VADD.F32 s1,s1,s4              ;2185
000230  eef40ac0          VCMPE.F32 s1,s0                 ;2185
000234  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;2185
000238  d3d2              BCC      |L3.480|
                  |L3.570|
00023a  eef51ac0          VCMPE.F32 s3,#0.0               ;2211
00023e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;2211
000242  dd27              BLE      |L3.660|
000244  9829              LDR      r0,[sp,#0xa4]         ;2213
000246  2100              MOVS     r1,#0                 ;2212
000248  4287              CMP      r7,r0                 ;2213
00024a  dd23              BLE      |L3.660|
                  |L3.588|
00024c  68b3              LDR      r3,[r6,#8]            ;2213
00024e  6932              LDR      r2,[r6,#0x10]         ;2213
000250  464c              MOV      r4,r9                 ;2216
000252  fb002e03          MLA      lr,r0,r3,r2           ;2216
000256  e016              B        |L3.646|
                  |L3.600|
000258  eb0e0284          ADD      r2,lr,r4,LSL #2       ;2217
00025c  ed920a00          VLDR     s0,[r2,#0]            ;2217
000260  eef41ac0          VCMPE.F32 s3,s0                 ;2217
000264  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;2217
000268  d20c              BCS      |L3.644|
00026a  9a2c              LDR      r2,[sp,#0xb0]         ;2218
00026c  fb004302          MLA      r3,r0,r2,r4           ;2218
000270  f8d82000          LDR      r2,[r8,#0]            ;2218
000274  ea4f0c82          LSL      r12,r2,#2             ;2218
000278  1c52              ADDS     r2,r2,#1              ;2218
00027a  f8c82000          STR      r2,[r8,#0]            ;2218
00027e  f84a300c          STR      r3,[r10,r12]          ;2218
000282  1c49              ADDS     r1,r1,#1              ;2220
                  |L3.644|
000284  1c64              ADDS     r4,r4,#1              ;2216
                  |L3.646|
000286  42ac              CMP      r4,r5                 ;2216
000288  bfb8              IT       LT                    ;2216
00028a  4559              CMPLT    r1,r11                ;2216
00028c  dbe4              BLT      |L3.600|
00028e  1c40              ADDS     r0,r0,#1              ;2213
000290  42b8              CMP      r0,r7                 ;2213
000292  dbdb              BLT      |L3.588|
                  |L3.660|
000294  9801              LDR      r0,[sp,#4]            ;2228
000296  1e40              SUBS     r0,r0,#1              ;2228
000298  9001              STR      r0,[sp,#4]            ;2228
                  |L3.666|
00029a  9827              LDR      r0,[sp,#0x9c]         ;2166
00029c  9937              LDR      r1,[sp,#0xdc]         ;2166
00029e  1c40              ADDS     r0,r0,#1              ;2166
0002a0  9027              STR      r0,[sp,#0x9c]         ;2166
0002a2  4288              CMP      r0,r1                 ;2166
0002a4  f6ffaf0f          BLT      |L3.198|
                  |L3.680|
0002a8  982b              LDR      r0,[sp,#0xac]         ;2162
0002aa  9937              LDR      r1,[sp,#0xdc]         ;2162
0002ac  1c40              ADDS     r0,r0,#1              ;2162
0002ae  902b              STR      r0,[sp,#0xac]         ;2162
0002b0  4288              CMP      r0,r1                 ;2162
0002b2  f6ffaefd          BLT      |L3.176|
                  |L3.694|
0002b6  2000              MOVS     r0,#0                 ;2232
0002b8  e6d0              B        |L3.92|
;;;2234       } // namespace TemplateTracker
                          ENDP

0002ba  0000              DCW      0x0000
                  |L3.700|
                          DCD      ||.constdata||+0x443
                  |L3.704|
0002c0  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\lucasKanade_SampledPl"
0002c4  6f726574
0002c8  6563685c
0002cc  76697369
0002d0  6f6e5c72
0002d4  6f626f74
0002d8  5c737263
0002dc  5c6c7563
0002e0  61734b61
0002e4  6e616465
0002e8  5f53616d
0002ec  706c6564
0002f0  506c    
0002f2  616e6172          DCB      "anar6dof.cpp",0
0002f6  36646f66
0002fa  2e637070
0002fe  00      
0002ff  00                DCB      0
                  |L3.768|
000300  4c756361          DCB      "LucasKanadeTracker_SampledPlanar6dof::ApproximateSelect"
000304  734b616e
000308  61646554
00030c  7261636b
000310  65725f53
000314  616d706c
000318  6564506c
00031c  616e6172
000320  36646f66
000324  3a3a4170
000328  70726f78
00032c  696d6174
000330  6553656c
000334  656374  
000337  282900            DCB      "()",0
00033a  00                DCB      0
00033b  00                DCB      0
                  |L3.828|
00033c  3f000000          DCFS     0x3f000000 ; 0.5
                  |L3.832|
000340  bf800000          DCFS     0xbf800000 ; -1

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17SetGainSchedulingEffff||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17SetGainSchedulingEffff PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::SetGainScheduling(float, float, float, float)
;;;1367   
;;;1368         void LucasKanadeTracker_SampledPlanar6dof::SetGainScheduling(const f32 zMin, const f32 zMax,
000000  ed801a22          VSTR     s2,[r0,#0x88]
;;;1369           const f32 KpMin, const f32 KpMax)
;;;1370         {
;;;1371           this->Kp_min = KpMin;
;;;1372           this->Kp_max = KpMax;
000004  edc01a23          VSTR     s3,[r0,#0x8c]
;;;1373           this->tz_min = zMin;
000008  ed800a24          VSTR     s0,[r0,#0x90]
;;;1374           this->tz_max = zMax;
00000c  edc00a25          VSTR     s1,[r0,#0x94]
;;;1375   
;;;1376           this->useGainScheduling = true;
000010  2101              MOVS     r1,#1
000012  f8801098          STRB     r1,[r0,#0x98]
;;;1377         }
000016  4770              BX       lr
;;;1378   
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof20UpdateTransformationENS0_11MemoryStackE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof20UpdateTransformationENS0_11MemoryStackE PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::UpdateTransformation(Anki::Embedded::MemoryStack)
;;;1163   
;;;1164         Result LucasKanadeTracker_SampledPlanar6dof::UpdateTransformation(MemoryStack scratch)
000000  b530              PUSH     {r4,r5,lr}
;;;1165         {
000002  b087              SUB      sp,sp,#0x1c
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;1166           // Compute the new homography from the new 6DoF parameters, and
;;;1167           // update the transformation object
;;;1168           Array<f32> newHomography = Array<f32>(3,3,scratch);
000008  2300              MOVS     r3,#0
00000a  461a              MOV      r2,r3
00000c  2101              MOVS     r1,#1
00000e  a806              ADD      r0,sp,#0x18
000010  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000014  6800              LDR      r0,[r0,#0]
000016  2203              MOVS     r2,#3
000018  9000              STR      r0,[sp,#0]
00001a  462b              MOV      r3,r5
00001c  4611              MOV      r1,r2
00001e  a801              ADD      r0,sp,#4
000020  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1169           this->GetRotationMatrix(newHomography, true);
000024  2201              MOVS     r2,#1
000026  a901              ADD      r1,sp,#4
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17GetRotationMatrixERNS0_5ArrayIfEEb ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetRotationMatrix(Anki::Embedded::Array<float>&, bool) const
00002e  9a03              LDR      r2,[sp,#0xc]
000030  9905              LDR      r1,[sp,#0x14]
;;;1170   
;;;1171           newHomography[0][0] *= this->focalLength_x;
000032  2000              MOVS     r0,#0
000034  fb001002          MLA      r0,r0,r2,r1
000038  edd40a1e          VLDR     s1,[r4,#0x78]
00003c  ed900a00          VLDR     s0,[r0,#0]
000040  ee200a20          VMUL.F32 s0,s0,s1
000044  ed800a00          VSTR     s0,[r0,#0]
000048  9a03              LDR      r2,[sp,#0xc]
00004a  9905              LDR      r1,[sp,#0x14]
;;;1172           newHomography[0][1] *= this->focalLength_x;
00004c  2000              MOVS     r0,#0
00004e  fb001002          MLA      r0,r0,r2,r1
000052  edd40a1e          VLDR     s1,[r4,#0x78]
000056  ed900a01          VLDR     s0,[r0,#4]
00005a  ee200a20          VMUL.F32 s0,s0,s1
00005e  ed800a01          VSTR     s0,[r0,#4]
;;;1173           newHomography[0][2] = this->focalLength_x*this->params6DoF.translation.x;// / initialImageScaleF32;
000062  ed940a1e          VLDR     s0,[r4,#0x78]
000066  edd40a2a          VLDR     s1,[r4,#0xa8]
00006a  9a03              LDR      r2,[sp,#0xc]
00006c  9905              LDR      r1,[sp,#0x14]
00006e  2000              MOVS     r0,#0
000070  fb001002          MLA      r0,r0,r2,r1
000074  ee200a20          VMUL.F32 s0,s0,s1
000078  ed800a02          VSTR     s0,[r0,#8]
00007c  9a03              LDR      r2,[sp,#0xc]
00007e  9905              LDR      r1,[sp,#0x14]
;;;1174   
;;;1175           newHomography[1][0] *= this->focalLength_y;
000080  2001              MOVS     r0,#1
000082  fb001002          MLA      r0,r0,r2,r1
000086  edd40a1f          VLDR     s1,[r4,#0x7c]
00008a  ed900a00          VLDR     s0,[r0,#0]
00008e  ee200a20          VMUL.F32 s0,s0,s1
000092  ed800a00          VSTR     s0,[r0,#0]
000096  9a03              LDR      r2,[sp,#0xc]
000098  9905              LDR      r1,[sp,#0x14]
;;;1176           newHomography[1][1] *= this->focalLength_y;
00009a  2001              MOVS     r0,#1
00009c  fb001002          MLA      r0,r0,r2,r1
0000a0  edd40a1f          VLDR     s1,[r4,#0x7c]
0000a4  ed900a01          VLDR     s0,[r0,#4]
0000a8  ee200a20          VMUL.F32 s0,s0,s1
0000ac  ed800a01          VSTR     s0,[r0,#4]
;;;1177           newHomography[1][2] = this->focalLength_y*this->params6DoF.translation.y;// / initialImageScaleF32;
0000b0  ed940a1f          VLDR     s0,[r4,#0x7c]
0000b4  edd40a2b          VLDR     s1,[r4,#0xac]
0000b8  9a03              LDR      r2,[sp,#0xc]
0000ba  9905              LDR      r1,[sp,#0x14]
0000bc  2001              MOVS     r0,#1
0000be  fb001002          MLA      r0,r0,r2,r1
0000c2  ee200a20          VMUL.F32 s0,s0,s1
0000c6  ed800a02          VSTR     s0,[r0,#8]
0000ca  9a03              LDR      r2,[sp,#0xc]
0000cc  9905              LDR      r1,[sp,#0x14]
;;;1178   
;;;1179           //newHomography[2][0] = newR[2][0];// * initialImageScaleF32;
;;;1180           //newHomography[2][1] = newR[2][1];// * initialImageScaleF32;
;;;1181           newHomography[2][2] = this->params6DoF.translation.z;
0000ce  2002              MOVS     r0,#2
0000d0  fb001002          MLA      r0,r0,r2,r1
0000d4  ed940a2c          VLDR     s0,[r4,#0xb0]
;;;1182   
;;;1183           Result result = this->transformation.set_homography(newHomography);
0000d8  a901              ADD      r1,sp,#4
0000da  ed800a02          VSTR     s0,[r0,#8]            ;1181
0000de  f1040018          ADD      r0,r4,#0x18
0000e2  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3214set_homographyERKNS0_5ArrayIfEE ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_homography(const Anki::Embedded::Array<float>&)
;;;1184   
;;;1185           return result;
;;;1186         }
0000e6  b007              ADD      sp,sp,#0x1c
0000e8  bd30              POP      {r4,r5,pc}
;;;1187   
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof22IterativelyRefineTrackERKNS0_5ArrayIhEEiiffNS0_15Transformations13TransformTypeERbNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof22IterativelyRefineTrackERKNS0_5ArrayIhEEiiffNS0_15Transformations13TransformTypeERbNS0_11MemoryStackE PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack(const Anki::Embedded::Array<unsigned char>&, int, int, float, float, Anki::Embedded::Transformations::TransformType, bool&, Anki::Embedded::MemoryStack)
;;;1329   
;;;1330         Result LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack(const Array<u8> &nextImage, const s32 maxIterations, const s32 whichScale, const f32 convergenceTolerance_angle, const f32 convergenceTolerance_distance, const Transformations::TransformType curTransformType, bool &verify_converged, MemoryStack scratch)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1331         {
000004  460d              MOV      r5,r1
000006  ed2d8b02          VPUSH    {d8}
00000a  b089              SUB      sp,sp,#0x24
00000c  4604              MOV      r4,r0
00000e  e9dd9814          LDRD     r9,r8,[sp,#0x50]
000012  eeb08a60          VMOV.F32 s16,s1
000016  eef08a40          VMOV.F32 s17,s0
00001a  469a              MOV      r10,r3
00001c  4693              MOV      r11,r2
;;;1332           const s32 nextImageHeight = nextImage.get_size(0);
00001e  2100              MOVS     r1,#0
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
;;;1333           const s32 nextImageWidth = nextImage.get_size(1);
000026  9000              STR      r0,[sp,#0]
000028  2101              MOVS     r1,#1
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000030  4607              MOV      r7,r0
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker26LucasKanadeTracker_Generic7IsValidEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_Generic::IsValid() const
;;;1334   
;;;1335           AnkiConditionalErrorAndReturnValue(this->IsValid() == true,
000038  4e5d              LDR      r6,|L6.432|
00003a  2800              CMP      r0,#0
00003c  d020              BEQ      |L6.128|
00003e  6928              LDR      r0,[r5,#0x10]
000040  2800              CMP      r0,#0
000042  d029              BEQ      |L6.152|
000044  6828              LDR      r0,[r5,#0]
000046  2800              CMP      r0,#0
000048  bfa4              ITT      GE
00004a  6868              LDRGE    r0,[r5,#4]
00004c  2800              CMPGE    r0,#0
00004e  db23              BLT      |L6.152|
;;;1336             RESULT_FAIL, "LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack", "This object is not initialized");
;;;1337   
;;;1338           AnkiConditionalErrorAndReturnValue(nextImage.IsValid(),
;;;1339             RESULT_FAIL_INVALID_OBJECT, "LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack", "nextImage is not valid");
;;;1340   
;;;1341           AnkiConditionalErrorAndReturnValue(maxIterations > 0 && maxIterations < 1000,
000050  f1bb0f00          CMP      r11,#0
000054  dd03              BLE      |L6.94|
000056  f5bb7f7a          CMP      r11,#0x3e8
00005a  f2c0802a          BLT.W    |L6.178|
                  |L6.94|
00005e  f240503d          MOV      r0,#0x53d
000062  e9cd6000          STRD     r6,r0,[sp,#0]
000066  a353              ADR      r3,|L6.436|
000068  a262              ADR      r2,|L6.500|
00006a  a171              ADR      r1,|L6.560|
00006c  2005              MOVS     r0,#5
00006e  f7fffffe          BL       _Anki_Log
000072  f04f7040          MOV      r0,#0x3000000
                  |L6.118|
;;;1342             RESULT_FAIL_INVALID_PARAMETER, "LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack", "maxIterations must be greater than zero and less than 1000");
;;;1343   
;;;1344           AnkiConditionalErrorAndReturnValue(whichScale >= 0 && whichScale < this->numPyramidLevels,
;;;1345             RESULT_FAIL_INVALID_PARAMETER, "LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack", "whichScale is invalid");
;;;1346   
;;;1347           AnkiConditionalErrorAndReturnValue(convergenceTolerance_angle > 0.0f && convergenceTolerance_distance > 0.0f,
;;;1348             RESULT_FAIL_INVALID_PARAMETER, "LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack", "convergenceTolerances must be greater than zero");
;;;1349   
;;;1350           AnkiConditionalErrorAndReturnValue(nextImageHeight == templateImageHeight && nextImageWidth == templateImageWidth,
;;;1351             RESULT_FAIL_INVALID_SIZE, "LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack", "nextImage must be the same size as the template");
;;;1352   
;;;1353           const s32 initialImageScaleS32 = BASE_IMAGE_WIDTH / nextImageWidth;
;;;1354           const s32 initialImagePowerS32 = Log2u32(static_cast<u32>(initialImageScaleS32));
;;;1355   
;;;1356           AnkiConditionalErrorAndReturnValue(((1<<initialImagePowerS32)*nextImageWidth) == BASE_IMAGE_WIDTH,
;;;1357             RESULT_FAIL_INVALID_SIZE, "LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack", "The templateImage must be a power of two smaller than BASE_IMAGE_WIDTH");
;;;1358   
;;;1359           if(curTransformType == Transformations::TRANSFORM_TRANSLATION) {
;;;1360             return IterativelyRefineTrack_Translation(nextImage, maxIterations, whichScale, convergenceTolerance_distance, verify_converged, scratch);
;;;1361           } else if(curTransformType == Transformations::TRANSFORM_PROJECTIVE) {
;;;1362             return IterativelyRefineTrack_Projective(nextImage, maxIterations, whichScale, convergenceTolerance_angle, convergenceTolerance_distance, verify_converged, scratch);
;;;1363           }
;;;1364   
;;;1365           return RESULT_FAIL;
;;;1366         } // Result LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack(const Array<u8> &nextImage, const s32 maxIterations, const s32 whichScale, const f32 convergenceTolerance, const TransformType curTransformType, bool &verify_converged, MemoryStack scratch)
000076  b009              ADD      sp,sp,#0x24
000078  ecbd8b02          VPOP     {d8}
00007c  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.128|
000080  f2405037          MOV      r0,#0x537             ;1335
000084  e9cd6000          STRD     r6,r0,[sp,#0]         ;1335
000088  a34a              ADR      r3,|L6.436|
00008a  a279              ADR      r2,|L6.624|
00008c  a168              ADR      r1,|L6.560|
00008e  2005              MOVS     r0,#5                 ;1335
000090  f7fffffe          BL       _Anki_Log
000094  2001              MOVS     r0,#1                 ;1335
000096  e7ee              B        |L6.118|
                  |L6.152|
000098  f240503a          MOV      r0,#0x53a             ;1338
00009c  e9cd6000          STRD     r6,r0,[sp,#0]         ;1338
0000a0  a344              ADR      r3,|L6.436|
0000a2  a27b              ADR      r2,|L6.656|
0000a4  a162              ADR      r1,|L6.560|
0000a6  2005              MOVS     r0,#5                 ;1338
0000a8  f7fffffe          BL       _Anki_Log
0000ac  f04f6080          MOV      r0,#0x4000000         ;1338
0000b0  e7e1              B        |L6.118|
                  |L6.178|
0000b2  f1ba0f00          CMP      r10,#0                ;1344
0000b6  bfa4              ITT      GE                    ;1344
0000b8  6860              LDRGE    r0,[r4,#4]            ;1344
0000ba  4550              CMPGE    r0,r10                ;1344
0000bc  dc0c              BGT      |L6.216|
0000be  f44f60a8          MOV      r0,#0x540             ;1344
0000c2  e9cd6000          STRD     r6,r0,[sp,#0]         ;1344
0000c6  a33b              ADR      r3,|L6.436|
0000c8  a277              ADR      r2,|L6.680|
0000ca  a159              ADR      r1,|L6.560|
0000cc  2005              MOVS     r0,#5                 ;1344
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f04f7040          MOV      r0,#0x3000000         ;1344
0000d6  e7ce              B        |L6.118|
                  |L6.216|
0000d8  eef58ac0          VCMPE.F32 s17,#0.0              ;1347
0000dc  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1347
0000e0  bf84              ITT      HI                    ;1347
0000e2  eeb58ac0          VCMPEHI.F32 s16,#0.0              ;1347
0000e6  eef1fa10          VMRSHI   APSR_nzcv,FPSCR       ;1347
0000ea  d80c              BHI      |L6.262|
0000ec  f2405043          MOV      r0,#0x543             ;1347
0000f0  e9cd6000          STRD     r6,r0,[sp,#0]         ;1347
0000f4  a32f              ADR      r3,|L6.436|
0000f6  a272              ADR      r2,|L6.704|
0000f8  a14d              ADR      r1,|L6.560|
0000fa  2005              MOVS     r0,#5                 ;1347
0000fc  f7fffffe          BL       _Anki_Log
000100  f04f7040          MOV      r0,#0x3000000         ;1347
000104  e7b7              B        |L6.118|
                  |L6.262|
000106  68a1              LDR      r1,[r4,#8]            ;1350
000108  9800              LDR      r0,[sp,#0]            ;1350
00010a  4281              CMP      r1,r0                 ;1350
00010c  bf04              ITT      EQ                    ;1350
00010e  68e0              LDREQ    r0,[r4,#0xc]          ;1350
000110  42b8              CMPEQ    r0,r7                 ;1350
000112  d00c              BEQ      |L6.302|
000114  f2405046          MOV      r0,#0x546             ;1350
000118  e9cd6000          STRD     r6,r0,[sp,#0]         ;1350
00011c  a325              ADR      r3,|L6.436|
00011e  a274              ADR      r2,|L6.752|
000120  a143              ADR      r1,|L6.560|
000122  2005              MOVS     r0,#5                 ;1350
000124  f7fffffe          BL       _Anki_Log
000128  f04f60a0          MOV      r0,#0x5000000         ;1350
00012c  e7a3              B        |L6.118|
                  |L6.302|
00012e  f44f70a0          MOV      r0,#0x140             ;1353
000132  fb90f0f7          SDIV     r0,r0,r7              ;1353
000136  f7fffffe          BL       Log2u32
00013a  fa07f000          LSL      r0,r7,r0              ;1356
00013e  f5b07fa0          CMP      r0,#0x140             ;1356
000142  d00c              BEQ      |L6.350|
000144  f240504c          MOV      r0,#0x54c             ;1356
000148  e9cd6000          STRD     r6,r0,[sp,#0]         ;1356
00014c  a319              ADR      r3,|L6.436|
00014e  4a74              LDR      r2,|L6.800|
000150  a137              ADR      r1,|L6.560|
000152  2005              MOVS     r0,#5                 ;1356
000154  f7fffffe          BL       _Anki_Log
000158  f04f60a0          MOV      r0,#0x5000000         ;1356
00015c  e78b              B        |L6.118|
                  |L6.350|
00015e  f5b97f00          CMP      r9,#0x200             ;1359
000162  d015              BEQ      |L6.400|
000164  f5b96f00          CMP      r9,#0x800             ;1361
000168  bf18              IT       NE                    ;1365
00016a  2001              MOVNE    r0,#1                 ;1365
00016c  d183              BNE      |L6.118|
00016e  a802              ADD      r0,sp,#8              ;1362
000170  9916              LDR      r1,[sp,#0x58]         ;1362
000172  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000176  e9cd8000          STRD     r8,r0,[sp,#0]         ;1362
00017a  eef00a48          VMOV.F32 s1,s16                ;1362
00017e  eeb00a68          VMOV.F32 s0,s17                ;1362
000182  4653              MOV      r3,r10                ;1362
000184  465a              MOV      r2,r11                ;1362
000186  4629              MOV      r1,r5                 ;1362
000188  4620              MOV      r0,r4                 ;1362
00018a  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof33IterativelyRefineTrack_ProjectiveERKNS0_5ArrayIhEEiiffRbNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Projective(const Anki::Embedded::Array<unsigned char>&, int, int, float, float, bool&, Anki::Embedded::MemoryStack)
00018e  e772              B        |L6.118|
                  |L6.400|
000190  a802              ADD      r0,sp,#8              ;1360
000192  9916              LDR      r1,[sp,#0x58]         ;1360
000194  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000198  e9cd8000          STRD     r8,r0,[sp,#0]         ;1360
00019c  eeb00a48          VMOV.F32 s0,s16                ;1360
0001a0  4653              MOV      r3,r10                ;1360
0001a2  465a              MOV      r2,r11                ;1360
0001a4  4629              MOV      r1,r5                 ;1360
0001a6  4620              MOV      r0,r4                 ;1360
0001a8  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof34IterativelyRefineTrack_TranslationERKNS0_5ArrayIhEEiifRbNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Translation(const Anki::Embedded::Array<unsigned char>&, int, int, float, bool&, Anki::Embedded::MemoryStack)
0001ac  e763              B        |L6.118|
;;;1367   
                          ENDP

0001ae  0000              DCW      0x0000
                  |L6.432|
                          DCD      ||.constdata||+0x32f
                  |L6.436|
0001b4  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\lucasKanade_SampledPl"
0001b8  6f726574
0001bc  6563685c
0001c0  76697369
0001c4  6f6e5c72
0001c8  6f626f74
0001cc  5c737263
0001d0  5c6c7563
0001d4  61734b61
0001d8  6e616465
0001dc  5f53616d
0001e0  706c6564
0001e4  506c    
0001e6  616e6172          DCB      "anar6dof.cpp",0
0001ea  36646f66
0001ee  2e637070
0001f2  00      
0001f3  00                DCB      0
                  |L6.500|
0001f4  6d617849          DCB      "maxIterations must be greater than zero and less than 1"
0001f8  74657261
0001fc  74696f6e
000200  73206d75
000204  73742062
000208  65206772
00020c  65617465
000210  72207468
000214  616e207a
000218  65726f20
00021c  616e6420
000220  6c657373
000224  20746861
000228  6e2031  
00022b  30303000          DCB      "000",0
00022f  00                DCB      0
                  |L6.560|
000230  4c756361          DCB      "LucasKanadeTracker_SampledPlanar6dof::IterativelyRefine"
000234  734b616e
000238  61646554
00023c  7261636b
000240  65725f53
000244  616d706c
000248  6564506c
00024c  616e6172
000250  36646f66
000254  3a3a4974
000258  65726174
00025c  6976656c
000260  79526566
000264  696e65  
000267  54726163          DCB      "Track",0
00026b  6b00    
00026d  00                DCB      0
00026e  00                DCB      0
00026f  00                DCB      0
                  |L6.624|
000270  54686973          DCB      "This object is not initialized",0
000274  206f626a
000278  65637420
00027c  6973206e
000280  6f742069
000284  6e697469
000288  616c697a
00028c  656400  
00028f  00                DCB      0
                  |L6.656|
000290  6e657874          DCB      "nextImage is not valid",0
000294  496d6167
000298  65206973
00029c  206e6f74
0002a0  2076616c
0002a4  696400  
0002a7  00                DCB      0
                  |L6.680|
0002a8  77686963          DCB      "whichScale is invalid",0
0002ac  68536361
0002b0  6c652069
0002b4  7320696e
0002b8  76616c69
0002bc  6400    
0002be  00                DCB      0
0002bf  00                DCB      0
                  |L6.704|
0002c0  636f6e76          DCB      "convergenceTolerances must be greater than zero",0
0002c4  65726765
0002c8  6e636554
0002cc  6f6c6572
0002d0  616e6365
0002d4  73206d75
0002d8  73742062
0002dc  65206772
0002e0  65617465
0002e4  72207468
0002e8  616e207a
0002ec  65726f00
                  |L6.752|
0002f0  6e657874          DCB      "nextImage must be the same size as the template",0
0002f4  496d6167
0002f8  65206d75
0002fc  73742062
000300  65207468
000304  65207361
000308  6d652073
00030c  697a6520
000310  61732074
000314  68652074
000318  656d706c
00031c  61746500
                  |L6.800|
                          DCD      ||.constdata||+0x968

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof22VerifyTrack_ProjectiveERKNS0_5ArrayIhEEhRiS7_S7_NS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof22VerifyTrack_ProjectiveERKNS0_5ArrayIhEEhRiS7_S7_NS0_11MemoryStackE PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifyTrack_Projective(const Anki::Embedded::Array<unsigned char>&, unsigned char, int&, int&, int&, Anki::Embedded::MemoryStack)
;;;1958   
;;;1959         Result LucasKanadeTracker_SampledPlanar6dof::VerifyTrack_Projective(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1960           const Array<u8> &nextImage,
;;;1961           const u8 verify_maxPixelDifference,
;;;1962           s32 &verify_meanAbsoluteDifference,
;;;1963           s32 &verify_numInBounds,
;;;1964           s32 &verify_numSimilarPixels,
;;;1965           MemoryStack scratch)
;;;1966         {
000004  460f              MOV      r7,r1
000006  ed2d8b04          VPUSH    {d8-d9}
00000a  b085              SUB      sp,sp,#0x14
00000c  4604              MOV      r4,r0
00000e  e9dd5616          LDRD     r5,r6,[sp,#0x58]
000012  4691              MOV      r9,r2
;;;1967           // This method is heavily based on Interp2_Projective
;;;1968           // The call would be like: Interp2_Projective<u8,u8>(nextImage, originalCoordinates, interpolationHomography, centerOffset, nextImageTransformed2d, INTERPOLATE_LINEAR, 0);
;;;1969           const s32 verify_maxPixelDifferenceS32 = verify_maxPixelDifference;
;;;1970   
;;;1971           const s32 nextImageHeight = nextImage.get_size(0);
000014  2100              MOVS     r1,#0
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00001c  ee080a90          VMOV     s17,r0
;;;1972           const s32 nextImageWidth = nextImage.get_size(1);
000020  2101              MOVS     r1,#1
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000028  4680              MOV      r8,r0
;;;1973   
;;;1974           const s32 initialImageScaleS32 = BASE_IMAGE_WIDTH / nextImageWidth;
00002a  f44f70a0          MOV      r0,#0x140
00002e  fb90f0f8          SDIV     r0,r0,r8
;;;1975           const f32 initialImageScaleF32 = static_cast<f32>(initialImageScaleS32);
000032  ee000a10          VMOV     s0,r0
;;;1976           const Point<f32> centerOffsetScaled = this->transformation.get_centerOffset(initialImageScaleF32);
000036  f1040118          ADD      r1,r4,#0x18
00003a  a802              ADD      r0,sp,#8
00003c  eeb88ac0          VCVT.F32.S32 s16,s0                ;1975
000040  eeb00a48          VMOV.F32 s0,s16
000044  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
;;;1977   
;;;1978           const f32 xyReferenceMin = 0.0f;
;;;1979           const f32 xReferenceMax = static_cast<f32>(nextImageWidth) - 1.0f;
000048  ee008a10          VMOV     s0,r8
00004c  eef79a00          VMOV.F32 s19,#1.00000000
;;;1980           const f32 yReferenceMax = static_cast<f32>(nextImageHeight) - 1.0f;
;;;1981   
;;;1982           const s32 numVerifySamples = this->verificationSamples.get_size();
;;;1983   
;;;1984           const Array<f32> &homography = this->transformation.get_homography();
000050  f1040018          ADD      r0,r4,#0x18
000054  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1979
000058  f8d48190          LDR      r8,[r4,#0x190]
00005c  ee309a69          VSUB.F32 s18,s0,s19            ;1979
000060  eeb80ae8          VCVT.F32.S32 s0,s17                ;1980
000064  ee708a69          VSUB.F32 s17,s0,s19            ;1980
000068  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
00006c  6882              LDR      r2,[r0,#8]
00006e  6901              LDR      r1,[r0,#0x10]
;;;1985           const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2] / initialImageScaleF32;
000070  2300              MOVS     r3,#0
000072  fb031002          MLA      r0,r3,r2,r1
000076  ed900a02          VLDR     s0,[r0,#8]
00007a  ed906a00          VLDR     s12,[r0,#0]
00007e  edd05a01          VLDR     s11,[r0,#4]
000082  ee805a08          VDIV.F32 s10,s0,s16
;;;1986           const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2] / initialImageScaleF32;
000086  2001              MOVS     r0,#1
000088  fb001002          MLA      r0,r0,r2,r1
00008c  ed900a02          VLDR     s0,[r0,#8]
000090  edd04a00          VLDR     s9,[r0,#0]
000094  ed904a01          VLDR     s8,[r0,#4]
;;;1987           const f32 h20 = homography[2][0] * initialImageScaleF32; const f32 h21 = homography[2][1] * initialImageScaleF32;
000098  2002              MOVS     r0,#2
00009a  fb001002          MLA      r0,r0,r2,r1
;;;1988           const f32 h22 = homography[2][2];
00009e  edd06a02          VLDR     s13,[r0,#8]
0000a2  eec03a08          VDIV.F32 s7,s0,s16             ;1986
0000a6  ed900a00          VLDR     s0,[r0,#0]            ;1987
0000aa  ee203a08          VMUL.F32 s6,s0,s16             ;1987
0000ae  ed900a01          VLDR     s0,[r0,#4]            ;1987
;;;1989   
;;;1990           verify_numInBounds = 0;
0000b2  2000              MOVS     r0,#0
;;;1991           verify_numSimilarPixels = 0;
0000b4  6028              STR      r0,[r5,#0]
0000b6  ee207a08          VMUL.F32 s14,s0,s16            ;1987
;;;1992           s32 totalGrayvalueDifference = 0;
0000ba  4684              MOV      r12,r0
;;;1993   
;;;1994           // TODO: make the x and y limits from 1 to end-2
;;;1995   
;;;1996           for(s32 iSample=0; iSample<numVerifySamples; iSample++) {
0000bc  6030              STR      r0,[r6,#0]
0000be  f1b80f00          CMP      r8,#0
0000c2  bfc8              IT       GT
0000c4  eddf2a4f          VLDRGT   s5,|L7.516|
0000c8  dd7c              BLE      |L7.452|
                  |L7.202|
0000ca  f8d411b4          LDR      r1,[r4,#0x1b4]
0000ce  eb000a40          ADD      r10,r0,r0,LSL #1
0000d2  4451              ADD      r1,r1,r10
;;;1997             const VerifySample curSample = this->verificationSamples[iSample];
0000d4  880a              LDRH     r2,[r1,#0]
0000d6  f8ad2000          STRH     r2,[sp,#0]
0000da  788a              LDRB     r2,[r1,#2]
0000dc  f88d2002          STRB     r2,[sp,#2]
;;;1998             const f32 yOriginal = static_cast<f32>(curSample.yCoordinate) * this->verifyCoordScalar;
0000e0  f99d1001          LDRSB    r1,[sp,#1]
0000e4  ee001a10          VMOV     s0,r1
;;;1999             const f32 xOriginal = static_cast<f32>(curSample.xCoordinate) * this->verifyCoordScalar;
0000e8  f99d1000          LDRSB    r1,[sp,#0]
0000ec  ee011a10          VMOV     s2,r1
0000f0  eef80ac0          VCVT.F32.S32 s1,s0                 ;1998
0000f4  ed940a1d          VLDR     s0,[r4,#0x74]         ;1998
0000f8  eeb81ac1          VCVT.F32.S32 s2,s2
0000fc  ee600a80          VMUL.F32 s1,s1,s0              ;1998
000100  ee210a00          VMUL.F32 s0,s2,s0
;;;2000   
;;;2001             const s32 verificationPixelValue = static_cast<s32>(curSample.grayvalue);
;;;2002   
;;;2003             // TODO: These two could be strength reduced
;;;2004             const f32 xTransformedRaw = h00*xOriginal + h01*yOriginal + h02;
000104  ee261a00          VMUL.F32 s2,s12,s0
000108  ee051aa0          VMLA.F32 s2,s11,s1
00010c  ee312a05          VADD.F32 s4,s2,s10
;;;2005             const f32 yTransformedRaw = h10*xOriginal + h11*yOriginal + h12;
000110  ee241a80          VMUL.F32 s2,s9,s0
;;;2006   
;;;2007             const f32 normalization = 1.f / (h20*xOriginal + h21*yOriginal + h22);
000114  ee230a00          VMUL.F32 s0,s6,s0
000118  ee041a20          VMLA.F32 s2,s8,s1              ;2005
00011c  ee070a20          VMLA.F32 s0,s14,s1
;;;2008   
;;;2009             const f32 xTransformed = (xTransformedRaw * normalization) + centerOffsetScaled.x;
000120  eddd0a02          VLDR     s1,[sp,#8]
000124  ee711a23          VADD.F32 s3,s2,s7              ;2005
000128  ee300a26          VADD.F32 s0,s0,s13             ;2007
00012c  ee891a80          VDIV.F32 s2,s19,s0             ;2007
;;;2010             const f32 yTransformed = (yTransformedRaw * normalization) + centerOffsetScaled.y;
000130  ed9d0a03          VLDR     s0,[sp,#0xc]
000134  ee420a01          VMLA.F32 s1,s4,s2              ;2009
000138  ee010a81          VMLA.F32 s0,s3,s2
;;;2011   
;;;2012   #if USE_LINEAR_INTERPOLATION_FOR_VERIFICATION
;;;2013             const f32 x0 = FLT_FLOOR(xTransformed);
;;;2014             const f32 x1 = ceilf(xTransformed); // x0 + 1.0f;
;;;2015   
;;;2016             const f32 y0 = FLT_FLOOR(yTransformed);
;;;2017             const f32 y1 = ceilf(yTransformed); // y0 + 1.0f;
;;;2018   
;;;2019             // If out of bounds, continue
;;;2020             if(x0 < xyReferenceMin || x1 > xReferenceMax || y0 < xyReferenceMin || y1 > yReferenceMax) {
;;;2021               continue;
;;;2022             }
;;;2023   
;;;2024             const f32 alphaX = xTransformed - x0;
;;;2025             const f32 alphaXinverse = 1 - alphaX;
;;;2026   
;;;2027             const f32 alphaY = yTransformed - y0;
;;;2028             const f32 alphaYinverse = 1.0f - alphaY;
;;;2029   
;;;2030             const s32 y0S32 = Round<s32>(y0);
;;;2031             const s32 y1S32 = Round<s32>(y1);
;;;2032             const s32 x0S32 = Round<s32>(x0);
;;;2033   
;;;2034             const u8 * restrict pReference_y0 = nextImage.Pointer(y0S32, x0S32);
;;;2035             const u8 * restrict pReference_y1 = nextImage.Pointer(y1S32, x0S32);
;;;2036   
;;;2037             const f32 pixelTL = *pReference_y0;
;;;2038             const f32 pixelTR = *(pReference_y0+1);
;;;2039             const f32 pixelBL = *pReference_y1;
;;;2040             const f32 pixelBR = *(pReference_y1+1);
;;;2041   
;;;2042             // Interpolate the value of this sample in the current image...
;;;2043             const s32 interpolatedPixelValue = Round<s32>(InterpolateBilinear2d<f32>(pixelTL, pixelTR, pixelBL, pixelBR, alphaY, alphaYinverse, alphaX, alphaXinverse));
;;;2044   
;;;2045   #else // No linear interpolation, just nearest pixel
;;;2046   
;;;2047             if(xTransformed < xyReferenceMin || xTransformed > xReferenceMax ||
00013c  eef50ac0          VCMPE.F32 s1,#0.0
000140  eef1fa10          VMRS     APSR_nzcv,FPSCR
000144  d349              BCC      |L7.474|
000146  eef40ac9          VCMPE.F32 s1,s18
00014a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00014e  dc44              BGT      |L7.474|
;;;2048               yTransformed < xyReferenceMin || yTransformed > yReferenceMax)
000150  eeb50ac0          VCMPE.F32 s0,#0.0
000154  eef1fa10          VMRS     APSR_nzcv,FPSCR
000158  d33f              BCC      |L7.474|
00015a  eeb40ae8          VCMPE.F32 s0,s17
00015e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000162  dc3a              BGT      |L7.474|
000164  eef50ac0          VCMPE.F32 s1,#0.0
000168  eef1fa10          VMRS     APSR_nzcv,FPSCR
00016c  bfcc              ITE      GT
00016e  ee700aa2          VADDGT.F32 s1,s1,s5
000172  ee700ae2          VSUBLE.F32 s1,s1,s5
000176  eefd0ae0          VCVT.S32.F32 s1,s1
00017a  eeb50ac0          VCMPE.F32 s0,#0.0
00017e  ee101a90          VMOV     r1,s1
000182  eef1fa10          VMRS     APSR_nzcv,FPSCR
000186  bfcc              ITE      GT
000188  ee300a22          VADDGT.F32 s0,s0,s5
00018c  ee300a62          VSUBLE.F32 s0,s0,s5
000190  eebd0ac0          VCVT.S32.F32 s0,s0
000194  f8d7e008          LDR      lr,[r7,#8]
000198  f8d7b010          LDR      r11,[r7,#0x10]
00019c  ee103a10          VMOV     r3,s0
0001a0  fb03b30e          MLA      r3,r3,lr,r11
;;;2049             {
;;;2050               // Out of bounds
;;;2051               continue;
;;;2052             }
;;;2053   
;;;2054             const s32 xS32 = Round<s32>(xTransformed);
;;;2055             const s32 yS32 = Round<s32>(yTransformed);
;;;2056   
;;;2057             // Lookup nearest pixel value in the current image...
;;;2058             const u8 * restrict pReference = nextImage.Pointer(yS32, xS32);
;;;2059   
;;;2060             const s32 interpolatedPixelValue = static_cast<s32>(*pReference);
0001a4  5c5b              LDRB     r3,[r3,r1]
;;;2061   
;;;2062   #endif // #if USE_LINEAR_INTERPOLATION_FOR_VERIFICATION
;;;2063   
;;;2064             verify_numInBounds++;
0001a6  6829              LDR      r1,[r5,#0]
0001a8  1c49              ADDS     r1,r1,#1
;;;2065   
;;;2066             // ...compare that value to the template sample
;;;2067             const s32 grayvalueDifference = ABS(interpolatedPixelValue - verificationPixelValue);
0001aa  6029              STR      r1,[r5,#0]
0001ac  1a99              SUBS     r1,r3,r2
0001ae  2900              CMP      r1,#0
0001b0  bfb8              IT       LT
0001b2  1ad1              SUBLT    r1,r2,r3
;;;2068   
;;;2069             // Keep track of the total difference
;;;2070             totalGrayvalueDifference += grayvalueDifference;
0001b4  448c              ADD      r12,r12,r1
;;;2071   
;;;2072             if(grayvalueDifference <= verify_maxPixelDifferenceS32) {
0001b6  4549              CMP      r1,r9
0001b8  dc02              BGT      |L7.448|
;;;2073               verify_numSimilarPixels++;
0001ba  6831              LDR      r1,[r6,#0]
0001bc  1c49              ADDS     r1,r1,#1
0001be  6031              STR      r1,[r6,#0]
                  |L7.448|
0001c0  2b00              CMP      r3,#0
0001c2  e000              B        |L7.454|
                  |L7.452|
0001c4  e00d              B        |L7.482|
                  |L7.454|
0001c6  bfb8              IT       LT
0001c8  2300              MOVLT    r3,#0
0001ca  db02              BLT      |L7.466|
0001cc  2bff              CMP      r3,#0xff
0001ce  bfc8              IT       GT
0001d0  23ff              MOVGT    r3,#0xff
                  |L7.466|
0001d2  f8d411b4          LDR      r1,[r4,#0x1b4]
0001d6  4451              ADD      r1,r1,r10
;;;2074             }
;;;2075   
;;;2076   #if UPDATE_VERIFICATION_SAMPLES_DURING_TRACKING
;;;2077             // Now that we're done using it, replace this verification sample
;;;2078             // with the value we read out.  If tracking is deemed a success by
;;;2079             // the caller, this will be the new verification value that gets
;;;2080             // used for the next tracker update.
;;;2081             this->verificationSamples[iSample].grayvalue = saturate_cast<u8>(interpolatedPixelValue);
0001d8  708b              STRB     r3,[r1,#2]
                  |L7.474|
0001da  1c40              ADDS     r0,r0,#1              ;1996
0001dc  4540              CMP      r0,r8                 ;1996
0001de  f6ffaf74          BLT      |L7.202|
                  |L7.482|
;;;2082   #endif
;;;2083           } // for(s32 iSample=0; iSample<numTemplateSamples; iSample++)
;;;2084   
;;;2085           if(verify_numInBounds > 0) {
0001e2  6828              LDR      r0,[r5,#0]
0001e4  2800              CMP      r0,#0
;;;2086             verify_meanAbsoluteDifference = totalGrayvalueDifference / verify_numInBounds;
0001e6  bfcc              ITE      GT
0001e8  fb9cf1f0          SDIVGT   r1,r12,r0
;;;2087           } else {
;;;2088             verify_meanAbsoluteDifference = s32_MAX;
0001ec  f06f4100          MVNLE    r1,#0x80000000
0001f0  980c              LDR      r0,[sp,#0x30]
;;;2089           }
;;;2090   
;;;2091           return RESULT_OK;
0001f2  6001              STR      r1,[r0,#0]
;;;2092         } // VerifyTrack_Projective()
0001f4  b005              ADD      sp,sp,#0x14
0001f6  2000              MOVS     r0,#0                 ;2091
0001f8  ecbd8b04          VPOP     {d8-d9}
0001fc  b004              ADD      sp,sp,#0x10
0001fe  e8bd8ff0          POP      {r4-r11,pc}
;;;2093   
                          ENDP

000202  0000              DCW      0x0000
                  |L7.516|
000204  3f000000          DCFS     0x3f000000 ; 0.5

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof25CreateVerificationSamplesERKNS0_5ArrayIhEERKNS0_14LinearSequenceIfEESA_fRiNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof25CreateVerificationSamplesERKNS0_5ArrayIhEERKNS0_14LinearSequenceIfEESA_fRiNS0_11MemoryStackE PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::CreateVerificationSamples(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::LinearSequence<float>&, const Anki::Embedded::LinearSequence<float>&, float, int&, Anki::Embedded::MemoryStack)
;;;1010   
;;;1011         Result LucasKanadeTracker_SampledPlanar6dof::CreateVerificationSamples(const Array<u8>& image,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1012           const LinearSequence<f32>& Xlocations,
;;;1013           const LinearSequence<f32>& Ylocations,
;;;1014           const f32 verifyCoordScalarInv,
;;;1015           s32& startIndex,
;;;1016           MemoryStack scratch)
;;;1017         {
000004  468b              MOV      r11,r1
000006  ed2d8b02          VPUSH    {d8}
00000a  b0b1              SUB      sp,sp,#0xc4
00000c  4680              MOV      r8,r0
00000e  e9dd4a3c          LDRD     r4,r10,[sp,#0xf0]
000012  f8d00190          LDR      r0,[r0,#0x190]
;;;1018           //static Matlab matlab(false);
;;;1019           //matlab.EvalStringEcho("figure, h_axes = axes; hold on");//, imshow(img), hold on");
;;;1020   
;;;1021           Result lastResult = RESULT_OK;
;;;1022   
;;;1023           AnkiConditionalErrorAndReturnValue(startIndex < this->verificationSamples.get_size(),
000016  6821              LDR      r1,[r4,#0]
000018  f8df921c          LDR      r9,|L8.568|
00001c  eeb08a40          VMOV.F32 s16,s0                ;1017
000020  4288              CMP      r0,r1
000022  dc11              BGT      |L8.72|
000024  f24030ff          MOV      r0,#0x3ff
000028  e9cd9000          STRD     r9,r0,[sp,#0]
00002c  a383              ADR      r3,|L8.572|
00002e  a293              ADR      r2,|L8.636|
000030  f209213e          ADD      r1,r9,#0x23e
000034  2005              MOVS     r0,#5
000036  f7fffffe          BL       _Anki_Log
00003a  f04f7040          MOV      r0,#0x3000000
                  |L8.62|
;;;1024             RESULT_FAIL_INVALID_PARAMETER,
;;;1025             "Result LucasKanadeTracker_SampledPlanar6dof::CreateVerificationSamples",
;;;1026             "Start index not valid.");
;;;1027   
;;;1028           Meshgrid<f32> verifyCoordinates(Xlocations, Ylocations);
;;;1029   
;;;1030           const s32 numSamplesX = verifyCoordinates.get_xGridVector().get_size();
;;;1031           const s32 numSamplesY = verifyCoordinates.get_yGridVector().get_size();
;;;1032   
;;;1033           Array<f32> verifyGrayscaleVector(1, numSamplesX*numSamplesY, scratch);
;;;1034           {
;;;1035             PUSH_MEMORY_STACK(scratch); // necessary?
;;;1036   
;;;1037             Array<f32> verifyImage(numSamplesY, numSamplesX, scratch);
;;;1038   
;;;1039             lastResult = Interp2_Projective<u8,f32>(image, verifyCoordinates,
;;;1040               this->transformation.get_homography(),
;;;1041               this->transformation.get_centerOffset(1.f),
;;;1042               verifyImage, INTERPOLATE_LINEAR);
;;;1043   
;;;1044             AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK, lastResult,
;;;1045               "LucasKanadeTracker_SampledPlanar6dof::CreateVerificationSamples",
;;;1046               "Interp2_Projective for verification image failed with code 0x%x", lastResult);
;;;1047   
;;;1048             // Turn verifyImage into a vector
;;;1049             lastResult = Matrix::Vectorize<f32,f32>(false, verifyImage, verifyGrayscaleVector);
;;;1050   
;;;1051             AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK, lastResult,
;;;1052               "LucasKanadeTracker_SampledPlanar6dof::CreateVerificationSamples",
;;;1053               "Matrix::Vectorize failed with code 0x%x", lastResult);
;;;1054           } // pop verifyImage
;;;1055   
;;;1056           Array<f32> yVerifyVector = verifyCoordinates.EvaluateY1(false, scratch);
;;;1057           Array<f32> xVerifyVector = verifyCoordinates.EvaluateX1(false, scratch);
;;;1058   
;;;1059           AnkiConditionalErrorAndReturnValue(xVerifyVector.IsValid(), RESULT_FAIL_MEMORY,
;;;1060             "LucasKanadeTracker_SampledPlanar6dof::CreateVerificationSamples",
;;;1061             "Failed to allocate xVerifyVector.");
;;;1062   
;;;1063           AnkiConditionalErrorAndReturnValue(yVerifyVector.IsValid(), RESULT_FAIL_MEMORY,
;;;1064             "LucasKanadeTracker_SampledPlanar6dof::CreateVerificationSamples",
;;;1065             "Failed to allocate yVerifyVector.");
;;;1066   
;;;1067           const f32 * restrict pYCoordinates = yVerifyVector.Pointer(0,0);
;;;1068           const f32 * restrict pXCoordinates = xVerifyVector.Pointer(0,0);
;;;1069           const f32 * restrict pGrayvalues   = verifyGrayscaleVector.Pointer(0,0);
;;;1070   
;;;1071           VerifySample * restrict pVerifySamples = this->verificationSamples.Pointer(0);
;;;1072   
;;;1073           for(s32 i=0; i<numSamplesX*numSamplesY; ++i)
;;;1074           {
;;;1075             VerifySample curVerifySample;
;;;1076             curVerifySample.xCoordinate = static_cast<s8>(pXCoordinates[i] * verifyCoordScalarInv);
;;;1077             curVerifySample.yCoordinate = static_cast<s8>(pYCoordinates[i] * verifyCoordScalarInv);
;;;1078             curVerifySample.grayvalue   = static_cast<u8>(pGrayvalues[i]);
;;;1079   
;;;1080             //matlab.EvalStringEcho("plot(%d, %d, 'ro');", curVerifySample.xCoordinate, curVerifySample.yCoordinate);
;;;1081   
;;;1082             pVerifySamples[startIndex + i] = curVerifySample;
;;;1083           }
;;;1084   
;;;1085           startIndex += numSamplesX*numSamplesY;
;;;1086   
;;;1087           //matlab.EvalStringEcho("set(h_axes, 'XLim', [-130 130], 'YLim', [-130 130]); grid on");
;;;1088   
;;;1089           return RESULT_OK;
;;;1090         } // CreateVerificationSamples()
00003e  b031              ADD      sp,sp,#0xc4
000040  ecbd8b02          VPOP     {d8}
000044  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.72|
000048  e9d20100          LDRD     r0,r1,[r2,#0]
00004c  f8d3c000          LDR      r12,[r3,#0]           ;1028
000050  685d              LDR      r5,[r3,#4]            ;1028
000052  ae04              ADD      r6,sp,#0x10           ;1028
000054  6892              LDR      r2,[r2,#8]            ;1028
000056  689b              LDR      r3,[r3,#8]            ;1028
000058  e8a61007          STM      r6!,{r0-r2,r12}       ;1028
00005c  e9cd5308          STRD     r5,r3,[sp,#0x20]      ;1028
000060  4607              MOV      r7,r0                 ;1028
000062  2300              MOVS     r3,#0                 ;1033
000064  4666              MOV      r6,r12                ;1033
000066  461a              MOV      r2,r3                 ;1033
000068  2101              MOVS     r1,#1                 ;1033
00006a  a82e              ADD      r0,sp,#0xb8           ;1033
00006c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000070  6800              LDR      r0,[r0,#0]            ;1033
000072  fb07f506          MUL      r5,r7,r6              ;1033
000076  9000              STR      r0,[sp,#0]            ;1033
000078  4653              MOV      r3,r10                ;1033
00007a  462a              MOV      r2,r5                 ;1033
00007c  2101              MOVS     r1,#1                 ;1033
00007e  a80f              ADD      r0,sp,#0x3c           ;1033
000080  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000084  4651              MOV      r1,r10                ;1035
000086  a81e              ADD      r0,sp,#0x78           ;1035
000088  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00008c  a91e              ADD      r1,sp,#0x78           ;1035
00008e  a825              ADD      r0,sp,#0x94           ;1035
000090  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000094  2300              MOVS     r3,#0                 ;1037
000096  461a              MOV      r2,r3                 ;1037
000098  2101              MOVS     r1,#1                 ;1037
00009a  a82f              ADD      r0,sp,#0xbc           ;1037
00009c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000a0  6800              LDR      r0,[r0,#0]            ;1037
0000a2  9000              STR      r0,[sp,#0]            ;1037
0000a4  ab25              ADD      r3,sp,#0x94           ;1037
0000a6  463a              MOV      r2,r7                 ;1037
0000a8  4631              MOV      r1,r6                 ;1037
0000aa  a80a              ADD      r0,sp,#0x28           ;1037
0000ac  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0000b0  eeb70a00          VMOV.F32 s0,#1.00000000        ;1039
0000b4  f1080118          ADD      r1,r8,#0x18           ;1039
0000b8  a82c              ADD      r0,sp,#0xb0           ;1039
0000ba  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
0000be  f1080018          ADD      r0,r8,#0x18           ;1039
0000c2  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
0000c6  2200              MOVS     r2,#0                 ;1039
0000c8  a90a              ADD      r1,sp,#0x28           ;1039
0000ca  ed9f0a72          VLDR     s0,|L8.660|
0000ce  e9cd1200          STRD     r1,r2,[sp,#0]         ;1041
0000d2  4602              MOV      r2,r0                 ;1041
0000d4  ab2c              ADD      r3,sp,#0xb0           ;1041
0000d6  a904              ADD      r1,sp,#0x10           ;1041
0000d8  4658              MOV      r0,r11                ;1041
0000da  f7fffffe          BL       _ZN4Anki8Embedded18Interp2_ProjectiveIhfEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_ ; Anki::Embedded::Interp2_Projective<unsigned char, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Meshgrid<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::Array<T2>&, Anki::Embedded::InterpolationType, T2)
0000de  ea5f0b00          MOVS     r11,r0                ;1041
0000e2  d00d              BEQ      |L8.256|
0000e4  f2404014          MOV      r0,#0x414             ;1044
0000e8  e9cd9000          STRD     r9,r0,[sp,#0]         ;1044
0000ec  a353              ADR      r3,|L8.572|
0000ee  a26a              ADR      r2,|L8.664|
0000f0  a179              ADR      r1,|L8.728|
0000f2  f8cdb008          STR      r11,[sp,#8]           ;1044
0000f6  2005              MOVS     r0,#5                 ;1044
0000f8  f7fffffe          BL       _Anki_Log
0000fc  4658              MOV      r0,r11                ;1044
0000fe  e79e              B        |L8.62|
                  |L8.256|
000100  aa0f              ADD      r2,sp,#0x3c           ;1049
000102  a90a              ADD      r1,sp,#0x28           ;1049
000104  2000              MOVS     r0,#0                 ;1049
000106  f7fffffe          BL       _ZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EE ; Anki::Embedded::Matrix::Vectorize<float, float>(bool, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
00010a  ea5f0b00          MOVS     r11,r0                ;1049
00010e  d00d              BEQ      |L8.300|
000110  f240401b          MOV      r0,#0x41b             ;1051
000114  e9cd9000          STRD     r9,r0,[sp,#0]         ;1051
000118  a348              ADR      r3,|L8.572|
00011a  a27f              ADR      r2,|L8.792|
00011c  a16e              ADR      r1,|L8.728|
00011e  f8cdb008          STR      r11,[sp,#8]           ;1051
000122  2005              MOVS     r0,#5                 ;1051
000124  f7fffffe          BL       _Anki_Log
000128  4658              MOV      r0,r11                ;1051
00012a  e788              B        |L8.62|
                  |L8.300|
00012c  2300              MOVS     r3,#0                 ;1056
00012e  461a              MOV      r2,r3                 ;1056
000130  2101              MOVS     r1,#1                 ;1056
000132  a803              ADD      r0,sp,#0xc            ;1056
000134  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000138  6800              LDR      r0,[r0,#0]            ;1056
00013a  9000              STR      r0,[sp,#0]            ;1056
00013c  4653              MOV      r3,r10                ;1056
00013e  2200              MOVS     r2,#0                 ;1056
000140  a904              ADD      r1,sp,#0x10           ;1056
000142  a814              ADD      r0,sp,#0x50           ;1056
000144  f7fffffe          BL       _ZNK4Anki8Embedded8MeshgridIfE10EvaluateY1EbRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Meshgrid<float>::EvaluateY1(bool, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer) const
000148  2300              MOVS     r3,#0                 ;1057
00014a  461a              MOV      r2,r3                 ;1057
00014c  2101              MOVS     r1,#1                 ;1057
00014e  a803              ADD      r0,sp,#0xc            ;1057
000150  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000154  6800              LDR      r0,[r0,#0]            ;1057
000156  9000              STR      r0,[sp,#0]            ;1057
000158  4653              MOV      r3,r10                ;1057
00015a  2200              MOVS     r2,#0                 ;1057
00015c  a904              ADD      r1,sp,#0x10           ;1057
00015e  a819              ADD      r0,sp,#0x64           ;1057
000160  f7fffffe          BL       _ZNK4Anki8Embedded8MeshgridIfE10EvaluateX1EbRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Meshgrid<float>::EvaluateX1(bool, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer) const
000164  a819              ADD      r0,sp,#0x64           ;1059
000166  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00016a  2800              CMP      r0,#0                 ;1059
00016c  d04a              BEQ      |L8.516|
00016e  a814              ADD      r0,sp,#0x50           ;1063
000170  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000174  2800              CMP      r0,#0                 ;1063
000176  d052              BEQ      |L8.542|
000178  2000              MOVS     r0,#0                 ;1067
00017a  9a16              LDR      r2,[sp,#0x58]         ;1067
00017c  9918              LDR      r1,[sp,#0x60]         ;1067
00017e  f8d881b4          LDR      r8,[r8,#0x1b4]        ;1067
000182  fb001902          MLA      r9,r0,r2,r1           ;1067
000186  9a1b              LDR      r2,[sp,#0x6c]         ;1067
000188  991d              LDR      r1,[sp,#0x74]         ;1067
00018a  2d00              CMP      r5,#0                 ;1073
00018c  fb001c02          MLA      r12,r0,r2,r1          ;1073
000190  9a11              LDR      r2,[sp,#0x44]         ;1073
000192  9913              LDR      r1,[sp,#0x4c]         ;1073
000194  fb001302          MLA      r3,r0,r2,r1           ;1073
000198  dd2e              BLE      |L8.504|
                  |L8.410|
00019a  eb0c0180          ADD      r1,r12,r0,LSL #2      ;1076
00019e  ed910a00          VLDR     s0,[r1,#0]            ;1076
0001a2  ee200a08          VMUL.F32 s0,s0,s16             ;1076
0001a6  eebd0ac0          VCVT.S32.F32 s0,s0                 ;1076
0001aa  ee101a10          VMOV     r1,s0                 ;1076
0001ae  f88d1000          STRB     r1,[sp,#0]            ;1076
0001b2  eb090180          ADD      r1,r9,r0,LSL #2       ;1077
0001b6  ed910a00          VLDR     s0,[r1,#0]            ;1077
0001ba  ee200a08          VMUL.F32 s0,s0,s16             ;1077
0001be  eebd0ac0          VCVT.S32.F32 s0,s0                 ;1077
0001c2  ee101a10          VMOV     r1,s0                 ;1077
0001c6  f88d1001          STRB     r1,[sp,#1]            ;1077
0001ca  eb030180          ADD      r1,r3,r0,LSL #2       ;1078
0001ce  ed910a00          VLDR     s0,[r1,#0]            ;1078
0001d2  eebc0ac0          VCVT.U32.F32 s0,s0                 ;1078
0001d6  ee101a10          VMOV     r1,s0                 ;1078
0001da  f88d1002          STRB     r1,[sp,#2]            ;1078
0001de  6822              LDR      r2,[r4,#0]            ;1082
0001e0  f8bda000          LDRH     r10,[sp,#0]           ;1082
0001e4  4402              ADD      r2,r2,r0              ;1082
0001e6  eb020242          ADD      r2,r2,r2,LSL #1       ;1082
0001ea  4442              ADD      r2,r2,r8              ;1082
0001ec  1c40              ADDS     r0,r0,#1              ;1073
0001ee  f8a2a000          STRH     r10,[r2,#0]           ;1082
0001f2  7091              STRB     r1,[r2,#2]            ;1082
0001f4  4285              CMP      r5,r0                 ;1073
0001f6  dcd0              BGT      |L8.410|
                  |L8.504|
0001f8  6820              LDR      r0,[r4,#0]            ;1085
0001fa  fb070006          MLA      r0,r7,r6,r0           ;1085
0001fe  6020              STR      r0,[r4,#0]            ;1089
000200  2000              MOVS     r0,#0                 ;1089
000202  e71c              B        |L8.62|
                  |L8.516|
000204  f2404023          MOV      r0,#0x423             ;1059
000208  e9cd9000          STRD     r9,r0,[sp,#0]         ;1059
00020c  a30b              ADR      r3,|L8.572|
00020e  a24c              ADR      r2,|L8.832|
000210  a131              ADR      r1,|L8.728|
000212  2005              MOVS     r0,#5                 ;1059
000214  f7fffffe          BL       _Anki_Log
000218  f04f7080          MOV      r0,#0x1000000         ;1059
00021c  e70f              B        |L8.62|
                  |L8.542|
00021e  f2404027          MOV      r0,#0x427             ;1063
000222  e9cd9000          STRD     r9,r0,[sp,#0]         ;1063
000226  a305              ADR      r3,|L8.572|
000228  a24e              ADR      r2,|L8.868|
00022a  a12b              ADR      r1,|L8.728|
00022c  2005              MOVS     r0,#5                 ;1063
00022e  f7fffffe          BL       _Anki_Log
000232  f04f7080          MOV      r0,#0x1000000         ;1063
000236  e702              B        |L8.62|
;;;1091   
                          ENDP

                  |L8.568|
                          DCD      ||.constdata||+0x526
                  |L8.572|
00023c  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\lucasKanade_SampledPl"
000240  6f726574
000244  6563685c
000248  76697369
00024c  6f6e5c72
000250  6f626f74
000254  5c737263
000258  5c6c7563
00025c  61734b61
000260  6e616465
000264  5f53616d
000268  706c6564
00026c  506c    
00026e  616e6172          DCB      "anar6dof.cpp",0
000272  36646f66
000276  2e637070
00027a  00      
00027b  00                DCB      0
                  |L8.636|
00027c  53746172          DCB      "Start index not valid.",0
000280  7420696e
000284  64657820
000288  6e6f7420
00028c  76616c69
000290  642e00  
000293  00                DCB      0
                  |L8.660|
000294  00000000          DCFS     0x00000000 ; 0
                  |L8.664|
000298  496e7465          DCB      "Interp2_Projective for verification image failed with c"
00029c  7270325f
0002a0  50726f6a
0002a4  65637469
0002a8  76652066
0002ac  6f722076
0002b0  65726966
0002b4  69636174
0002b8  696f6e20
0002bc  696d6167
0002c0  65206661
0002c4  696c6564
0002c8  20776974
0002cc  682063  
0002cf  6f646520          DCB      "ode 0x%x",0
0002d3  30782578
0002d7  00      
                  |L8.728|
0002d8  4c756361          DCB      "LucasKanadeTracker_SampledPlanar6dof::CreateVerificatio"
0002dc  734b616e
0002e0  61646554
0002e4  7261636b
0002e8  65725f53
0002ec  616d706c
0002f0  6564506c
0002f4  616e6172
0002f8  36646f66
0002fc  3a3a4372
000300  65617465
000304  56657269
000308  66696361
00030c  74696f  
00030f  6e53616d          DCB      "nSamples",0
000313  706c6573
000317  00      
                  |L8.792|
000318  4d617472          DCB      "Matrix::Vectorize failed with code 0x%x",0
00031c  69783a3a
000320  56656374
000324  6f72697a
000328  65206661
00032c  696c6564
000330  20776974
000334  6820636f
000338  64652030
00033c  78257800
                  |L8.832|
000340  4661696c          DCB      "Failed to allocate xVerifyVector.",0
000344  65642074
000348  6f20616c
00034c  6c6f6361
000350  74652078
000354  56657269
000358  66795665
00035c  63746f72
000360  2e00    
000362  00                DCB      0
000363  00                DCB      0
                  |L8.868|
000364  4661696c          DCB      "Failed to allocate yVerifyVector.",0
000368  65642074
00036c  6f20616c
000370  6c6f6361
000374  74652079
000378  56657269
00037c  66795665
000380  63746f72
000384  2e00    
000386  00                DCB      0
000387  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof28UpdateRotationAndTranslationERKNS0_5ArrayIfEERKNS0_6Point3IfEENS0_11MemoryStackE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof28UpdateRotationAndTranslationERKNS0_5ArrayIfEERKNS0_6Point3IfEENS0_11MemoryStackE PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::UpdateRotationAndTranslation(const Anki::Embedded::Array<float>&, const Anki::Embedded::Point3<float>&, Anki::Embedded::MemoryStack)
;;;1187   
;;;1188         Result LucasKanadeTracker_SampledPlanar6dof::UpdateRotationAndTranslation(const Array<f32>& R,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1189           const Point3<f32>& T,
;;;1190           MemoryStack scratch)
;;;1191         {
000002  4604              MOV      r4,r0
000004  461f              MOV      r7,r3
000006  4616              MOV      r6,r2
000008  f10403a4          ADD      r3,r4,#0xa4
;;;1192           Result lastResult = this->set_rotationAnglesFromMatrix(R);
00000c  4608              MOV      r0,r1
00000e  1f1a              SUBS     r2,r3,#4
000010  b087              SUB      sp,sp,#0x1c           ;1191
000012  1f11              SUBS     r1,r2,#4              ;1191
000014  f7fffffe          BL       _ZN4Anki8Embedded6Matrix14GetEulerAnglesERKNS0_5ArrayIfEERfS6_S6_ ; Anki::Embedded::Matrix::GetEulerAngles(const Anki::Embedded::Array<float>&, float&, float&, float&)
;;;1193   
;;;1194           if(lastResult == RESULT_OK) {
000018  2800              CMP      r0,#0
;;;1195             this->params6DoF.translation = T;
;;;1196             lastResult = this->UpdateTransformation(scratch);
;;;1197           }
;;;1198   
;;;1199           return lastResult;
;;;1200         }
00001a  bf1c              ITT      NE
00001c  b007              ADDNE    sp,sp,#0x1c
00001e  bdf0              POPNE    {r4-r7,pc}
000020  ed960a00          VLDR     s0,[r6,#0]
000024  4639              MOV      r1,r7                 ;1196
000026  ed840a2a          VSTR     s0,[r4,#0xa8]         ;1196
00002a  ed960a01          VLDR     s0,[r6,#4]            ;1196
00002e  4668              MOV      r0,sp                 ;1196
000030  ed840a2b          VSTR     s0,[r4,#0xac]         ;1196
000034  ed960a02          VLDR     s0,[r6,#8]            ;1196
000038  ed840a2c          VSTR     s0,[r4,#0xb0]         ;1196
00003c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000040  4601              MOV      r1,r0                 ;1196
000042  4620              MOV      r0,r4                 ;1196
000044  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof20UpdateTransformationENS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::UpdateTransformation(Anki::Embedded::MemoryStack)
000048  b007              ADD      sp,sp,#0x1c
00004a  bdf0              POP      {r4-r7,pc}
;;;1201   
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof28set_rotationAnglesFromMatrixERKNS0_5ArrayIfEE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof28set_rotationAnglesFromMatrixERKNS0_5ArrayIfEE PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::set_rotationAnglesFromMatrix(const Anki::Embedded::Array<float>&)
;;;1134         // rotation matrix
;;;1135         Result LucasKanadeTracker_SampledPlanar6dof::set_rotationAnglesFromMatrix(const Array<f32>& R)
000000  f10003a4          ADD      r3,r0,#0xa4
;;;1136         {
000004  468c              MOV      r12,r1
;;;1137           return Matrix::GetEulerAngles(R,
000006  1f1a              SUBS     r2,r3,#4
000008  1f11              SUBS     r1,r2,#4
00000a  4660              MOV      r0,r12
00000c  f7ffbffe          B.W      _ZN4Anki8Embedded6Matrix14GetEulerAnglesERKNS0_5ArrayIfEERfS6_S6_ ; Anki::Embedded::Matrix::GetEulerAngles(const Anki::Embedded::Array<float>&, float&, float&, float&)
;;;1138             this->params6DoF.angle_x,
;;;1139             this->params6DoF.angle_y,
;;;1140             this->params6DoF.angle_z);
;;;1141         } // set_rotationAnglesFromMatrix
;;;1142   
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof33IterativelyRefineTrack_ProjectiveERKNS0_5ArrayIhEEiiffRbNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof33IterativelyRefineTrack_ProjectiveERKNS0_5ArrayIhEEiiffRbNS0_11MemoryStackE PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Projective(const Anki::Embedded::Array<unsigned char>&, int, int, float, float, bool&, Anki::Embedded::MemoryStack)
;;;1633   
;;;1634         Result LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Projective(const Array<u8> &nextImage, const s32 maxIterations, const s32 whichScale, const f32 convergenceTolerance_angle, const f32 convergenceTolerance_distance, bool &verify_converged, MemoryStack scratch)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1635         {
000004  461d              MOV      r5,r3
000006  ed2d0b02          VPUSH    {d0}
00000a  460e              MOV      r6,r1
00000c  4604              MOV      r4,r0
00000e  ed2d8b10          VPUSH    {d8-d15}
000012  b0c5              SUB      sp,sp,#0x114
;;;1636           // This method is heavily based on Interp2_Projective
;;;1637           // The call would be like: Interp2_Projective<u8,u8>(nextImage, originalCoordinates, interpolationHomography, centerOffset, nextImageTransformed2d, INTERPOLATE_LINEAR, 0);
;;;1638   
;;;1639           Result lastResult;
;;;1640   
;;;1641           Array<f32> AWAt(6, 6, scratch);
000014  2300              MOVS     r3,#0
000016  eeb09a60          VMOV.F32 s18,s1                ;1635
00001a  eef08a40          VMOV.F32 s17,s0                ;1635
00001e  461a              MOV      r2,r3
000020  2101              MOVS     r1,#1
000022  a842              ADD      r0,sp,#0x108
000024  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000028  6800              LDR      r0,[r0,#0]
00002a  9000              STR      r0,[sp,#0]
00002c  2206              MOVS     r2,#6
00002e  4611              MOV      r1,r2
000030  a828              ADD      r0,sp,#0xa0
000032  9b65              LDR      r3,[sp,#0x194]
000034  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1642           Array<f32> b(1, 6, scratch);
000038  2300              MOVS     r3,#0
00003a  461a              MOV      r2,r3
00003c  2101              MOVS     r1,#1
00003e  a843              ADD      r0,sp,#0x10c
000040  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000044  6800              LDR      r0,[r0,#0]
000046  9000              STR      r0,[sp,#0]
000048  2206              MOVS     r2,#6
00004a  2101              MOVS     r1,#1
00004c  a823              ADD      r0,sp,#0x8c
00004e  9b65              LDR      r3,[sp,#0x194]
000050  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1643   
;;;1644           // These addresses should be known at compile time, so should be faster
;;;1645           //f32 AWAt_raw[6][6];
;;;1646           const s32 NUM_SYMMETRIC_ENTRIES = 21;
;;;1647           f32 AWAt_raw[NUM_SYMMETRIC_ENTRIES];
;;;1648           f32 b_raw[6];
;;;1649   
;;;1650           verify_converged = false;
000054  9864              LDR      r0,[sp,#0x190]
000056  2100              MOVS     r1,#0
000058  7001              STRB     r1,[r0,#0]
;;;1651   
;;;1652           // f32 minChange = 0.f;
;;;1653   
;;;1654           const s32 nextImageHeight = nextImage.get_size(0);
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000060  4680              MOV      r8,r0
;;;1655           const s32 nextImageWidth  = nextImage.get_size(1);
000062  2101              MOVS     r1,#1
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00006a  4607              MOV      r7,r0
;;;1656   
;;;1657           const f32 scale = static_cast<f32>(1 << whichScale);
00006c  2001              MOVS     r0,#1
00006e  40a8              LSLS     r0,r0,r5
000070  ee000a10          VMOV     s0,r0
;;;1658   
;;;1659           const s32 initialImageScaleS32 = BASE_IMAGE_WIDTH / nextImageWidth;
000074  f44f70a0          MOV      r0,#0x140
000078  fb90f0f7          SDIV     r0,r0,r7
00007c  eeb88ac0          VCVT.F32.S32 s16,s0                ;1657
;;;1660           const f32 initialImageScaleF32 = static_cast<f32>(initialImageScaleS32);
000080  ee000a10          VMOV     s0,r0
;;;1661   
;;;1662           const f32 oneOverTwoFiftyFive = 1.0f / 255.0f;
;;;1663           //const f32 scaleOverFiveTen = scale / (2.0f*255.0f);
;;;1664   
;;;1665           //const Point<f32>& centerOffset = this->transformation.get_centerOffset();
;;;1666           const Point<f32> centerOffsetScaled = this->transformation.get_centerOffset(initialImageScaleF32);
000084  f1040118          ADD      r1,r4,#0x18
000088  a83c              ADD      r0,sp,#0xf0
00008a  eef8aac0          VCVT.F32.S32 s21,s0                ;1660
00008e  eeb00a6a          VMOV.F32 s0,s21
000092  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
;;;1667   
;;;1668   #if COMPUTE_CONVERGENCE_FROM_CORNER_CHANGE
;;;1669           // Initialize with some very extreme coordinates
;;;1670           FixedLengthList<Quadrilateral<f32> > previousCorners(NUM_PREVIOUS_QUADS_TO_COMPARE, scratch);
;;;1671   
;;;1672           for(s32 i=0; i<NUM_PREVIOUS_QUADS_TO_COMPARE; i++) {
;;;1673             previousCorners[i] = Quadrilateral<f32>(Point<f32>(-1e10f,-1e10f), Point<f32>(-1e10f,-1e10f), Point<f32>(-1e10f,-1e10f), Point<f32>(-1e10f,-1e10f));
;;;1674           }
;;;1675   #endif
;;;1676   
;;;1677           const f32 xyReferenceMin = 0.0f;
;;;1678           const f32 xReferenceMax = static_cast<f32>(nextImageWidth - 1);
000096  1e78              SUBS     r0,r7,#1
000098  ee000a10          VMOV     s0,r0
;;;1679           const f32 yReferenceMax = static_cast<f32>(nextImageHeight - 1);
00009c  f1a80001          SUB      r0,r8,#1
0000a0  eb050185          ADD      r1,r5,r5,LSL #2
0000a4  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1678
0000a8  eb0101c5          ADD      r1,r1,r5,LSL #3       ;1678
0000ac  2d00              CMP      r5,#0                 ;1678
0000ae  ed8d0a41          VSTR     s0,[sp,#0x104]        ;1678
0000b2  ee000a10          VMOV     s0,r0
0000b6  eeb80ac0          VCVT.F32.S32 s0,s0
0000ba  ed8d0a40          VSTR     s0,[sp,#0x100]
0000be  f8d400e4          LDR      r0,[r4,#0xe4]
0000c2  eb000081          ADD      r0,r0,r1,LSL #2
;;;1680   
;;;1681           const TemplateSample * restrict pTemplateSamplePyramid = this->templateSamplePyramid[whichScale].Pointer(0);
0000c6  6b01              LDR      r1,[r0,#0x30]
0000c8  913f              STR      r1,[sp,#0xfc]
0000ca  bfa5              ITTET    GE
0000cc  6862              LDRGE    r2,[r4,#4]
0000ce  42aa              CMPGE    r2,r5
0000d0  2700              MOVLT    r7,#0
0000d2  68c7              LDRGE    r7,[r0,#0xc]
;;;1682   
;;;1683           const s32 numTemplateSamples = this->get_numTemplatePixels(whichScale);
;;;1684   
;;;1685   #if USE_INTENSITY_NORMALIZATION
;;;1686           const f32 curMean     = this->normalizationMean[whichScale];
;;;1687           const f32 curSigmaInv = this->normalizationSigmaInv[whichScale];
;;;1688   #endif
;;;1689   
;;;1690           for(s32 iteration=0; iteration<maxIterations; iteration++) {
0000d4  2000              MOVS     r0,#0
0000d6  900b              STR      r0,[sp,#0x2c]
0000d8  9859              LDR      r0,[sp,#0x164]
0000da  2800              CMP      r0,#0
0000dc  f34082f4          BLE.W    |L11.1736|
;;;1691             const Array<f32> &homography = this->transformation.get_homography();
;;;1692             const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2] / initialImageScaleF32;
;;;1693             const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2] / initialImageScaleF32;
;;;1694             const f32 h20 = homography[2][0] * initialImageScaleF32; const f32 h21 = homography[2][1] * initialImageScaleF32;
;;;1695             const f32 h22 = homography[2][2];
;;;1696   
;;;1697             //AWAt.SetZero();
;;;1698             //b.SetZero();
;;;1699   
;;;1700             // Start with the full AtA matrix for this scale. We will subtract out
;;;1701             // contributions from samples currently out of bounds.
;;;1702             s32 symIndex = 0;
;;;1703             for(s32 i=0; i<6; ++i) {
;;;1704               f32 * restrict AWAt_i = this->AtAPyramid[whichScale].Pointer(i,0);
;;;1705               for(s32 j=i; j<6; ++j) {
;;;1706                 AWAt_raw[symIndex++] = AWAt_i[j];
;;;1707               }
;;;1708   
;;;1709               b_raw[i] = 0;
;;;1710             }
;;;1711   
;;;1712             s32 numInBounds = 0;
;;;1713   
;;;1714             // TODO: make the x and y limits from 1 to end-2
;;;1715   
;;;1716             // DEBUG!!!
;;;1717             //Array<f32> xTransformedArray = Array<f32>(1,numTemplateSamples,scratch);
;;;1718             //Array<f32> yTransformedArray = Array<f32>(1,numTemplateSamples,scratch);
;;;1719             //Array<f32> debugStuff = Array<f32>(numTemplateSamples, 6, scratch);
;;;1720             //Array<f32> debugA = Array<f32>(numTemplateSamples,6,scratch);
;;;1721             //static Matlab matlab(false);
;;;1722             //matlab.PutArray(nextImage, "img");
;;;1723   
;;;1724             for(s32 iSample=0; iSample<numTemplateSamples; iSample++) {
;;;1725               const TemplateSample curSample = pTemplateSamplePyramid[iSample];
;;;1726               const f32 yOriginal = curSample.yCoordinate;
;;;1727               const f32 xOriginal = curSample.xCoordinate;
;;;1728   
;;;1729               // TODO: These two could be strength reduced
;;;1730               const f32 xTransformedRaw = h00*xOriginal + h01*yOriginal + h02;
;;;1731               const f32 yTransformedRaw = h10*xOriginal + h11*yOriginal + h12;
;;;1732   
;;;1733               const f32 normalization = 1.f / (h20*xOriginal + h21*yOriginal + h22);
;;;1734   
;;;1735               const f32 xTransformed = (xTransformedRaw * normalization) + centerOffsetScaled.x;
;;;1736               const f32 yTransformed = (yTransformedRaw * normalization) + centerOffsetScaled.y;
;;;1737   
;;;1738               // DEBUG!
;;;1739               //xTransformedArray[0][iSample] = xTransformed;
;;;1740               //yTransformedArray[0][iSample] = yTransformed;
;;;1741   
;;;1742               const f32 x0 = FLT_FLOOR(xTransformed);
;;;1743               const f32 x1 = ceilf(xTransformed); // x0 + 1.0f;
;;;1744   
;;;1745               const f32 y0 = FLT_FLOOR(yTransformed);
;;;1746               const f32 y1 = ceilf(yTransformed); // y0 + 1.0f;
;;;1747   
;;;1748               const f32* Arow = curSample.A;
;;;1749   
;;;1750               // If out of bounds, remove this sample's contribution from the
;;;1751               // AtA matrix
;;;1752               if(x0 < xyReferenceMin || x1 > xReferenceMax || y0 < xyReferenceMin || y1 > yReferenceMax) {
;;;1753                 AWAt_raw[0]  -= Arow[0] * Arow[0];
;;;1754                 AWAt_raw[1]  -= Arow[0] * Arow[1];
;;;1755                 AWAt_raw[2]  -= Arow[0] * Arow[2];
;;;1756                 AWAt_raw[3]  -= Arow[0] * Arow[3];
;;;1757                 AWAt_raw[4]  -= Arow[0] * Arow[4];
;;;1758                 AWAt_raw[5]  -= Arow[0] * Arow[5];
;;;1759   
;;;1760                 AWAt_raw[6]  -= Arow[1] * Arow[1];
;;;1761                 AWAt_raw[7]  -= Arow[1] * Arow[2];
;;;1762                 AWAt_raw[8]  -= Arow[1] * Arow[3];
;;;1763                 AWAt_raw[9]  -= Arow[1] * Arow[4];
;;;1764                 AWAt_raw[10] -= Arow[1] * Arow[5];
;;;1765   
;;;1766                 AWAt_raw[11] -= Arow[2] * Arow[2];
;;;1767                 AWAt_raw[12] -= Arow[2] * Arow[3];
;;;1768                 AWAt_raw[13] -= Arow[2] * Arow[4];
;;;1769                 AWAt_raw[14] -= Arow[2] * Arow[5];
;;;1770   
;;;1771                 AWAt_raw[15] -= Arow[3] * Arow[3];
;;;1772                 AWAt_raw[16] -= Arow[3] * Arow[4];
;;;1773                 AWAt_raw[17] -= Arow[3] * Arow[5];
;;;1774   
;;;1775                 AWAt_raw[18] -= Arow[4] * Arow[4];
;;;1776                 AWAt_raw[19] -= Arow[4] * Arow[5];
;;;1777   
;;;1778                 AWAt_raw[20] -= Arow[5] * Arow[5];
;;;1779   
;;;1780                 continue;
;;;1781               }
;;;1782   
;;;1783               numInBounds++;
;;;1784   
;;;1785               const f32 alphaX = xTransformed - x0;
;;;1786               const f32 alphaXinverse = 1.0f - alphaX;
;;;1787   
;;;1788               const f32 alphaY = yTransformed - y0;
;;;1789               const f32 alphaYinverse = 1.0f - alphaY;
;;;1790   
;;;1791               const s32 y0S32 = Round<s32>(y0);
;;;1792               const s32 y1S32 = Round<s32>(y1);
;;;1793               const s32 x0S32 = Round<s32>(x0);
;;;1794   
;;;1795               const u8 * restrict pReference_y0 = nextImage.Pointer(y0S32, x0S32);
;;;1796               const u8 * restrict pReference_y1 = nextImage.Pointer(y1S32, x0S32);
;;;1797   
;;;1798               const f32 pixelTL = *pReference_y0;
;;;1799               const f32 pixelTR = *(pReference_y0+1);
;;;1800               const f32 pixelBL = *pReference_y1;
;;;1801               const f32 pixelBR = *(pReference_y1+1);
;;;1802   
;;;1803               f32 interpolatedPixelF32 = InterpolateBilinear2d<f32>(pixelTL, pixelTR, pixelBL, pixelBR,
;;;1804                 alphaY, alphaYinverse, alphaX, alphaXinverse);
;;;1805   
;;;1806   #if USE_INTENSITY_NORMALIZATION
;;;1807               interpolatedPixelF32 = (interpolatedPixelF32 - curMean) * curSigmaInv;
;;;1808   #endif
;;;1809   
;;;1810               // DEBUG:
;;;1811               /*
;;;1812               debugStuff[iSample][0] = curSample.xCoordinate;
;;;1813               debugStuff[iSample][1] = curSample.yCoordinate;
;;;1814               debugStuff[iSample][2] = curSample.grayvalue;
;;;1815               debugStuff[iSample][3] = interpolatedPixelF32;
;;;1816               debugStuff[iSample][4] = curSample.xGradient;
;;;1817               debugStuff[iSample][5] = curSample.yGradient;
;;;1818               */
;;;1819   
;;;1820               //const u8 interpolatedPixel = static_cast<u8>(Round(interpolatedPixelF32));
;;;1821   
;;;1822               // This block is the non-interpolation part of the per-sample algorithm
;;;1823               {
;;;1824                 //CoreTechPrint("(%f,%f) ", xOriginal, yOriginal);
;;;1825   
;;;1826                 // This is the only stuff that depends on the current sample
;;;1827                 const f32 templatePixelValue = static_cast<f32>(curSample.grayvalue);
;;;1828   
;;;1829                 const f32 tGradientValue = oneOverTwoFiftyFive * (interpolatedPixelF32 - templatePixelValue);
;;;1830   
;;;1831                 /*
;;;1832                 for(s32 i=0; i<6; ++i) {
;;;1833                 debugA[iSample][i] = values[i];
;;;1834                 }
;;;1835                 */
;;;1836   
;;;1837                 for(s32 ia=0; ia<6; ia++) {
;;;1838                   b_raw[ia] += Arow[ia] * tGradientValue;
;;;1839                 }
;;;1840               }
;;;1841             } // for(s32 iSample=0; iSample<numTemplateSamples; iSample++)
;;;1842   
;;;1843             /*
;;;1844             if(numInBounds < 16) {
;;;1845             AnkiWarn("LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Projective", "Template drifted too far out of image.");
;;;1846             return RESULT_OK;
;;;1847             }
;;;1848             */
;;;1849   
;;;1850             // Get the symmetric entries back out of the "raw" matrix
;;;1851             symIndex = 0;
;;;1852             for(s32 ia=0; ia<6; ia++) {
;;;1853               f32 * restrict AWAt_ia = AWAt.Pointer(ia,0);
;;;1854               for(s32 ja=ia; ja<6; ja++) {
;;;1855                 AWAt_ia[ja] = AWAt_raw[symIndex++];
;;;1856               }
;;;1857               b[0][ia] = b_raw[ia];
;;;1858             }
;;;1859   
;;;1860             Matrix::MakeSymmetric(AWAt, false);
;;;1861   
;;;1862             //AWAt.Print("New AWAt");
;;;1863             //b.Print("New b");
;;;1864   
;;;1865             // DEBUG
;;;1866             //matlab.PutArray(xTransformedArray, "X");
;;;1867             //matlab.PutArray(yTransformedArray, "Y");
;;;1868             //matlab.EvalString("hold off, imagesc(img), axis image, hold on, "
;;;1869             //                    "plot(X,Y, 'rx'); colormap(gray), drawnow");
;;;1870             /* matlab.PutArray(debugStuff, "debugStuff");
;;;1871             std::string A_name("A_"); A_name += std::to_string(whichScale);
;;;1872             matlab.PutArray(debugA, A_name);
;;;1873             if(whichScale == 0) {
;;;1874             //matlab.EvalString("desktop, keyboard");
;;;1875             }
;;;1876             */
;;;1877   
;;;1878             bool numericalFailure;
;;;1879   
;;;1880             if((lastResult = Matrix::SolveLeastSquaresWithCholesky(AWAt, b, false, numericalFailure)) != RESULT_OK)
;;;1881               return lastResult;
;;;1882   
;;;1883             if(numericalFailure){
;;;1884               AnkiWarn("LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Projective", "numericalFailure");
;;;1885               return RESULT_OK;
;;;1886             }
;;;1887   
;;;1888             /*
;;;1889             CoreTechPrint("Raw angle update = (%f,%f,%f) degrees, Raw translation udpate = (%f,%f,%f)\n",
;;;1890             RAD_TO_DEG(b[0][0]), RAD_TO_DEG(b[0][1]), RAD_TO_DEG(b[0][2]),
;;;1891             b[0][3], b[0][4], b[0][5]);
;;;1892             */
;;;1893   
;;;1894             //b.Print("New update");
;;;1895   
;;;1896             // Update the 6DoF parameters
;;;1897             // Note: we are subtracting the update because we're using an _inverse_
;;;1898             // compositional LK tracking scheme.
;;;1899             const f32 Kp = this->GetCurrentGain();
;;;1900   
;;;1901             this->params6DoF.angle_x -= Kp * b[0][0];
;;;1902             this->params6DoF.angle_y -= Kp * b[0][1];
;;;1903             this->params6DoF.angle_z -= Kp * b[0][2];
;;;1904   
;;;1905             this->params6DoF.translation.x -= Kp * b[0][3];
;;;1906             this->params6DoF.translation.y -= Kp * b[0][4];
;;;1907             this->params6DoF.translation.z -= Kp * b[0][5];
;;;1908   
;;;1909             //this->transformation.Update(b, initialImageScaleF32, scratch, Transformations::TRANSFORM_PROJECTIVE);
;;;1910   
;;;1911             // Compute the new homography from the new 6DoF parameters
;;;1912             this->UpdateTransformation(scratch);
;;;1913   
;;;1914             //this->transformation.get_homography().Print("new transformation");
;;;1915   
;;;1916             // Check if we're done with iterations
;;;1917   #if COMPUTE_CONVERGENCE_FROM_CORNER_CHANGE
;;;1918             f32 minChange = UpdatePreviousCorners(transformation, previousCorners, scratch);
;;;1919   
;;;1920             if(minChange < convergenceTolerance * scale) {
;;;1921   #else
;;;1922             const f32 angleConvergenceTolerance = scale*convergenceTolerance_angle;
0000e0  ee280a28          VMUL.F32 s0,s16,s17
0000e4  eb050085          ADD      r0,r5,r5,LSL #2
0000e8  903e              STR      r0,[sp,#0xf8]
0000ea  ed8d0a09          VSTR     s0,[sp,#0x24]
;;;1923             const f32 transConvergenceTolerance = scale*convergenceTolerance_distance;
0000ee  ee280a09          VMUL.F32 s0,s16,s18
0000f2  eef7fa00          VMOV.F32 s31,#1.00000000       ;1733
0000f6  eeb6aa00          VMOV.F32 s20,#0.50000000       ;1733
0000fa  ed8d0a0a          VSTR     s0,[sp,#0x28]
                  |L11.254|
0000fe  f1040018          ADD      r0,r4,#0x18           ;1691
000102  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
000106  6882              LDR      r2,[r0,#8]            ;1691
000108  6901              LDR      r1,[r0,#0x10]         ;1691
00010a  2300              MOVS     r3,#0                 ;1692
00010c  fb031002          MLA      r0,r3,r2,r1           ;1692
000110  ed900a00          VLDR     s0,[r0,#0]            ;1692
000114  ed8d0a0c          VSTR     s0,[sp,#0x30]         ;1692
000118  ed900a01          VLDR     s0,[r0,#4]            ;1692
00011c  ed8d0a3b          VSTR     s0,[sp,#0xec]         ;1692
000120  edd00a02          VLDR     s1,[r0,#8]            ;1692
000124  2001              MOVS     r0,#1                 ;1693
000126  fb001002          MLA      r0,r0,r2,r1           ;1693
00012a  ee800aaa          VDIV.F32 s0,s1,s21             ;1692
00012e  ed8d0a2d          VSTR     s0,[sp,#0xb4]         ;1692
000132  ed900a02          VLDR     s0,[r0,#8]            ;1693
000136  ed90fa00          VLDR     s30,[r0,#0]           ;1693
00013a  edd0ea01          VLDR     s29,[r0,#4]           ;1693
00013e  ee80ea2a          VDIV.F32 s28,s0,s21            ;1693
000142  2002              MOVS     r0,#2                 ;1694
000144  fb001002          MLA      r0,r0,r2,r1           ;1694
000148  9b3e              LDR      r3,[sp,#0xf8]         ;1694
00014a  ed900a00          VLDR     s0,[r0,#0]            ;1694
00014e  edd0ca02          VLDR     s25,[r0,#8]           ;1695
000152  2200              MOVS     r2,#0                 ;1702
000154  ee60da2a          VMUL.F32 s27,s0,s21            ;1694
000158  ed900a01          VLDR     s0,[r0,#4]            ;1694
00015c  f8d40118          LDR      r0,[r4,#0x118]        ;1694
000160  4611              MOV      r1,r2                 ;1703
000162  ee20da2a          VMUL.F32 s26,s0,s21            ;1694
000166  eb000083          ADD      r0,r0,r3,LSL #2       ;1694
00016a  eddf0afe          VLDR     s1,|L11.1380|
00016e  f8d0c008          LDR      r12,[r0,#8]           ;1677
000172  6905              LDR      r5,[r0,#0x10]         ;1677
                  |L11.372|
000174  4608              MOV      r0,r1                 ;1705
000176  fb01530c          MLA      r3,r1,r12,r5          ;1705
00017a  2906              CMP      r1,#6                 ;1705
00017c  bfb8              IT       LT                    ;1647
00017e  f10d0934          ADDLT    r9,sp,#0x34           ;1647
000182  da0b              BGE      |L11.412|
                  |L11.388|
000184  eb030a80          ADD      r10,r3,r0,LSL #2      ;1706
000188  1c40              ADDS     r0,r0,#1              ;1705
00018a  ed9a0a00          VLDR     s0,[r10,#0]           ;1706
00018e  eb090a82          ADD      r10,r9,r2,LSL #2      ;1706
000192  1c52              ADDS     r2,r2,#1              ;1706
000194  ed8a0a00          VSTR     s0,[r10,#0]           ;1706
000198  2806              CMP      r0,#6                 ;1705
00019a  dbf3              BLT      |L11.388|
                  |L11.412|
00019c  a82e              ADD      r0,sp,#0xb8           ;1709
00019e  eb000081          ADD      r0,r0,r1,LSL #2       ;1709
0001a2  1c49              ADDS     r1,r1,#1              ;1703
0001a4  edc00a00          VSTR     s1,[r0,#0]            ;1709
0001a8  2906              CMP      r1,#6                 ;1703
0001aa  dbe3              BLT      |L11.372|
0001ac  2500              MOVS     r5,#0                 ;1724
0001ae  2f00              CMP      r7,#0                 ;1724
0001b0  bfc4              ITT      GT                    ;1735
0001b2  ed9dca3c          VLDRGT   s24,[sp,#0xf0]        ;1735
0001b6  edddba3d          VLDRGT   s23,[sp,#0xf4]        ;1736
0001ba  f3408168          BLE.W    |L11.1166|
                  |L11.446|
0001be  983f              LDR      r0,[sp,#0xfc]         ;1725
0001c0  eb0501c5          ADD      r1,r5,r5,LSL #3       ;1725
0001c4  eb000081          ADD      r0,r0,r1,LSL #2       ;1725
0001c8  eef09a4c          VMOV.F32 s19,s24               ;1733
0001cc  e8901f0e          LDM      r0,{r1-r3,r8-r12}     ;1725
0001d0  e88d1f0e          STM      sp,{r1-r3,r8-r12}     ;1725
0001d4  6a00              LDR      r0,[r0,#0x20]         ;1725
0001d6  9008              STR      r0,[sp,#0x20]         ;1730
0001d8  ee001a10          VMOV     s0,r1                 ;1727
0001dc  ed9d1a0c          VLDR     s2,[sp,#0x30]         ;1730
0001e0  ee002a90          VMOV     s1,r2                 ;1726
0001e4  eeb09a6b          VMOV.F32 s18,s23               ;1735
0001e8  ee611a00          VMUL.F32 s3,s2,s0              ;1730
0001ec  ed9d1a3b          VLDR     s2,[sp,#0xec]         ;1730
0001f0  ee411a20          VMLA.F32 s3,s2,s1              ;1730
0001f4  ed9d1a2d          VLDR     s2,[sp,#0xb4]         ;1730
0001f8  ee711a81          VADD.F32 s3,s3,s2              ;1730
0001fc  ee2f1a00          VMUL.F32 s2,s30,s0             ;1731
000200  ee2d0a80          VMUL.F32 s0,s27,s0             ;1733
000204  ee0e1aa0          VMLA.F32 s2,s29,s1             ;1731
000208  ee0d0a20          VMLA.F32 s0,s26,s1             ;1733
00020c  ee311a0e          VADD.F32 s2,s2,s28             ;1731
000210  ee700a2c          VADD.F32 s1,s0,s25             ;1733
000214  ee8f0aa0          VDIV.F32 s0,s31,s1             ;1733
000218  ee419a80          VMLA.F32 s19,s3,s0             ;1735
00021c  ee019a00          VMLA.F32 s18,s2,s0             ;1736
000220  ed9f8ad1          VLDR     s16,|L11.1384|
000224  ee390a88          VADD.F32 s0,s19,s16            ;1742
000228  f7fffffe          BL       __hardfp_floorf
00022c  eef08a40          VMOV.F32 s17,s0                ;1742
000230  eeb00a69          VMOV.F32 s0,s19                ;1743
000234  f7fffffe          BL       __hardfp_ceilf
000238  eeb0ba40          VMOV.F32 s22,s0                ;1743
00023c  ee390a08          VADD.F32 s0,s18,s16            ;1745
000240  f7fffffe          BL       __hardfp_floorf
000244  eeb08a40          VMOV.F32 s16,s0                ;1745
000248  eeb00a49          VMOV.F32 s0,s18                ;1746
00024c  f7fffffe          BL       __hardfp_ceilf
000250  eef58ac0          VCMPE.F32 s17,#0.0              ;1752
000254  aa03              ADD      r2,sp,#0xc            ;1748
000256  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1752
00025a  d312              BCC      |L11.642|
00025c  eddd0a41          VLDR     s1,[sp,#0x104]        ;1752
000260  eeb4bae0          VCMPE.F32 s22,s1                ;1752
000264  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1752
000268  dc0b              BGT      |L11.642|
00026a  eeb58ac0          VCMPE.F32 s16,#0.0              ;1752
00026e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1752
000272  d306              BCC      |L11.642|
000274  eddd0a40          VLDR     s1,[sp,#0x100]        ;1752
000278  eeb40ae0          VCMPE.F32 s0,s1                 ;1752
00027c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1752
000280  dd7e              BLE      |L11.896|
                  |L11.642|
000282  ed9d0a0d          VLDR     s0,[sp,#0x34]         ;1753
000286  eddd2a03          VLDR     s5,[sp,#0xc]          ;1753
00028a  ee020ae2          VMLS.F32 s0,s5,s5              ;1753
00028e  ed8d0a0d          VSTR     s0,[sp,#0x34]         ;1753
000292  ed9d0a0e          VLDR     s0,[sp,#0x38]         ;1754
000296  eddd1a04          VLDR     s3,[sp,#0x10]         ;1754
00029a  ee020ae1          VMLS.F32 s0,s5,s3              ;1754
00029e  ed8d0a0e          VSTR     s0,[sp,#0x38]         ;1754
0002a2  ed9d0a0f          VLDR     s0,[sp,#0x3c]         ;1755
0002a6  ed9d1a05          VLDR     s2,[sp,#0x14]         ;1755
0002aa  ee020ac1          VMLS.F32 s0,s5,s2              ;1755
0002ae  ed8d0a0f          VSTR     s0,[sp,#0x3c]         ;1755
0002b2  ed9d0a10          VLDR     s0,[sp,#0x40]         ;1756
0002b6  eddd0a06          VLDR     s1,[sp,#0x18]         ;1756
0002ba  ee020ae0          VMLS.F32 s0,s5,s1              ;1756
0002be  ed8d0a10          VSTR     s0,[sp,#0x40]         ;1756
0002c2  ed9d2a11          VLDR     s4,[sp,#0x44]         ;1757
0002c6  ed9d0a07          VLDR     s0,[sp,#0x1c]         ;1757
0002ca  ee022ac0          VMLS.F32 s4,s5,s0              ;1757
0002ce  ed8d2a11          VSTR     s4,[sp,#0x44]         ;1757
0002d2  ed9d3a12          VLDR     s6,[sp,#0x48]         ;1758
0002d6  ed9d2a08          VLDR     s4,[sp,#0x20]         ;1758
0002da  ee023ac2          VMLS.F32 s6,s5,s4              ;1758
0002de  ed8d3a12          VSTR     s6,[sp,#0x48]         ;1758
0002e2  eddd2a13          VLDR     s5,[sp,#0x4c]         ;1760
0002e6  ee412ae1          VMLS.F32 s5,s3,s3              ;1760
0002ea  edcd2a13          VSTR     s5,[sp,#0x4c]         ;1760
0002ee  eddd2a14          VLDR     s5,[sp,#0x50]         ;1761
0002f2  ee412ac1          VMLS.F32 s5,s3,s2              ;1761
0002f6  edcd2a14          VSTR     s5,[sp,#0x50]         ;1761
0002fa  eddd2a15          VLDR     s5,[sp,#0x54]         ;1762
0002fe  ee412ae0          VMLS.F32 s5,s3,s1              ;1762
000302  edcd2a15          VSTR     s5,[sp,#0x54]         ;1762
000306  eddd2a16          VLDR     s5,[sp,#0x58]         ;1763
00030a  ee412ac0          VMLS.F32 s5,s3,s0              ;1763
00030e  edcd2a16          VSTR     s5,[sp,#0x58]         ;1763
000312  eddd2a17          VLDR     s5,[sp,#0x5c]         ;1764
000316  ee412ac2          VMLS.F32 s5,s3,s4              ;1764
00031a  edcd2a17          VSTR     s5,[sp,#0x5c]         ;1764
00031e  eddd1a18          VLDR     s3,[sp,#0x60]         ;1766
000322  ee411a41          VMLS.F32 s3,s2,s2              ;1766
000326  edcd1a18          VSTR     s3,[sp,#0x60]         ;1766
00032a  eddd1a19          VLDR     s3,[sp,#0x64]         ;1767
00032e  ee411a60          VMLS.F32 s3,s2,s1              ;1767
000332  edcd1a19          VSTR     s3,[sp,#0x64]         ;1767
000336  eddd1a1a          VLDR     s3,[sp,#0x68]         ;1768
00033a  ee411a40          VMLS.F32 s3,s2,s0              ;1768
00033e  edcd1a1a          VSTR     s3,[sp,#0x68]         ;1768
000342  eddd1a1b          VLDR     s3,[sp,#0x6c]         ;1769
000346  ee411a42          VMLS.F32 s3,s2,s4              ;1769
00034a  edcd1a1b          VSTR     s3,[sp,#0x6c]         ;1769
00034e  ed9d1a1c          VLDR     s2,[sp,#0x70]         ;1771
000352  ee001ae0          VMLS.F32 s2,s1,s1              ;1771
000356  ed8d1a1c          VSTR     s2,[sp,#0x70]         ;1771
00035a  ed9d1a1d          VLDR     s2,[sp,#0x74]         ;1772
00035e  ee001ac0          VMLS.F32 s2,s1,s0              ;1772
000362  ed8d1a1d          VSTR     s2,[sp,#0x74]         ;1772
000366  ed9d1a1e          VLDR     s2,[sp,#0x78]         ;1773
00036a  ee001ac2          VMLS.F32 s2,s1,s4              ;1773
00036e  ed8d1a1e          VSTR     s2,[sp,#0x78]         ;1773
000372  eddd0a1f          VLDR     s1,[sp,#0x7c]         ;1775
000376  ee400a40          VMLS.F32 s1,s0,s0              ;1775
00037a  edcd0a1f          VSTR     s1,[sp,#0x7c]         ;1775
00037e  e000              B        |L11.898|
                  |L11.896|
000380  e00c              B        |L11.924|
                  |L11.898|
000382  eddd0a20          VLDR     s1,[sp,#0x80]         ;1776
000386  ee400a42          VMLS.F32 s1,s0,s4              ;1776
00038a  edcd0a20          VSTR     s1,[sp,#0x80]         ;1776
00038e  ed9d0a21          VLDR     s0,[sp,#0x84]         ;1778
000392  ee020a42          VMLS.F32 s0,s4,s4              ;1778
000396  ed8d0a21          VSTR     s0,[sp,#0x84]         ;1778
00039a  e074              B        |L11.1158|
                  |L11.924|
00039c  ee790ae8          VSUB.F32 s1,s19,s17            ;1785
0003a0  ee791a48          VSUB.F32 s3,s18,s16            ;1788
0003a4  eeb58ac0          VCMPE.F32 s16,#0.0              ;1788
0003a8  ee3f1ae0          VSUB.F32 s2,s31,s1             ;1786
0003ac  ee7f2ae1          VSUB.F32 s5,s31,s3             ;1789
0003b0  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1789
0003b4  bfcc              ITE      GT                    ;1789
0003b6  ee382a0a          VADDGT.F32 s4,s16,s20            ;1789
0003ba  ee382a4a          VSUBLE.F32 s4,s16,s20            ;1789
0003be  eebd2ac2          VCVT.S32.F32 s4,s4                 ;1789
0003c2  eeb50ac0          VCMPE.F32 s0,#0.0               ;1789
0003c6  ee121a10          VMOV     r1,s4                 ;1789
0003ca  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1789
0003ce  bfcc              ITE      GT                    ;1789
0003d0  ee300a0a          VADDGT.F32 s0,s0,s20             ;1789
0003d4  ee300a4a          VSUBLE.F32 s0,s0,s20             ;1789
0003d8  eebd0ac0          VCVT.S32.F32 s0,s0                 ;1789
0003dc  eef58ac0          VCMPE.F32 s17,#0.0              ;1789
0003e0  ee108a10          VMOV     r8,s0                 ;1789
0003e4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1789
0003e8  bfcc              ITE      GT                    ;1789
0003ea  ee380a8a          VADDGT.F32 s0,s17,s20            ;1789
0003ee  ee380aca          VSUBLE.F32 s0,s17,s20            ;1789
0003f2  eebd0ac0          VCVT.S32.F32 s0,s0                 ;1789
0003f6  f8d6c008          LDR      r12,[r6,#8]           ;1789
0003fa  6933              LDR      r3,[r6,#0x10]         ;1789
0003fc  ee100a10          VMOV     r0,s0                 ;1789
000400  fb01310c          MLA      r1,r1,r12,r3          ;1789
000404  fb08330c          MLA      r3,r8,r12,r3          ;1789
000408  4401              ADD      r1,r1,r0              ;1789
00040a  4418              ADD      r0,r0,r3              ;1789
00040c  780b              LDRB     r3,[r1,#0]            ;1798
00040e  7849              LDRB     r1,[r1,#1]            ;1799
000410  ee003a10          VMOV     s0,r3                 ;1798
000414  eef83a40          VCVT.F32.U32 s7,s0                 ;1798
000418  ee001a10          VMOV     s0,r1                 ;1799
00041c  7801              LDRB     r1,[r0,#0]            ;1800
00041e  7840              LDRB     r0,[r0,#1]            ;1801
000420  eeb83a40          VCVT.F32.U32 s6,s0                 ;1799
000424  ee001a10          VMOV     s0,r1                 ;1800
000428  ee613a23          VMUL.F32 s7,s2,s7              ;1800
00042c  eeb82a40          VCVT.F32.U32 s4,s0                 ;1800
000430  ee000a10          VMOV     s0,r0                 ;1801
000434  ee403a83          VMLA.F32 s7,s1,s6              ;1801
000438  f89d0008          LDRB     r0,[sp,#8]            ;1827
00043c  eeb80a40          VCVT.F32.U32 s0,s0                 ;1801
000440  ee211a02          VMUL.F32 s2,s2,s4              ;1801
000444  ee001a80          VMLA.F32 s2,s1,s0              ;1801
000448  ee220aa3          VMUL.F32 s0,s5,s7              ;1801
00044c  ee000a90          VMOV     s1,r0                 ;1827
000450  eef80a60          VCVT.F32.U32 s1,s1                 ;1827
000454  ee010a81          VMLA.F32 s0,s3,s2              ;1827
000458  ee700a60          VSUB.F32 s1,s0,s1              ;1829
00045c  ed9f0a43          VLDR     s0,|L11.1388|
000460  2000              MOVS     r0,#0                 ;1837
000462  ab2e              ADD      r3,sp,#0xb8           ;1648
000464  ee200a80          VMUL.F32 s0,s1,s0              ;1829
                  |L11.1128|
000468  eb030180          ADD      r1,r3,r0,LSL #2       ;1838
00046c  eb020c80          ADD      r12,r2,r0,LSL #2      ;1838
000470  edd10a00          VLDR     s1,[r1,#0]            ;1838
000474  ed9c1a00          VLDR     s2,[r12,#0]           ;1838
000478  1c40              ADDS     r0,r0,#1              ;1837
00047a  2806              CMP      r0,#6                 ;1837
00047c  ee410a00          VMLA.F32 s1,s2,s0              ;1838
000480  edc10a00          VSTR     s1,[r1,#0]            ;1838
000484  dbf0              BLT      |L11.1128|
                  |L11.1158|
000486  1c6d              ADDS     r5,r5,#1              ;1724
000488  42bd              CMP      r5,r7                 ;1724
00048a  f6ffae98          BLT      |L11.446|
                  |L11.1166|
00048e  2200              MOVS     r2,#0                 ;1851
000490  4611              MOV      r1,r2                 ;1852
000492  ab0d              ADD      r3,sp,#0x34           ;1647
000494  ad2e              ADD      r5,sp,#0xb8           ;1648
                  |L11.1174|
000496  f8ddc0a8          LDR      r12,[sp,#0xa8]        ;1648
00049a  982c              LDR      r0,[sp,#0xb0]         ;1648
00049c  2906              CMP      r1,#6                 ;1854
00049e  fb010c0c          MLA      r12,r1,r12,r0         ;1854
0004a2  4608              MOV      r0,r1                 ;1854
0004a4  da0b              BGE      |L11.1214|
                  |L11.1190|
0004a6  eb030882          ADD      r8,r3,r2,LSL #2       ;1855
0004aa  1c52              ADDS     r2,r2,#1              ;1855
0004ac  ed980a00          VLDR     s0,[r8,#0]            ;1855
0004b0  eb0c0880          ADD      r8,r12,r0,LSL #2      ;1855
0004b4  1c40              ADDS     r0,r0,#1              ;1854
0004b6  ed880a00          VSTR     s0,[r8,#0]            ;1855
0004ba  2806              CMP      r0,#6                 ;1854
0004bc  dbf3              BLT      |L11.1190|
                  |L11.1214|
0004be  f8ddc09c          LDR      r12,[sp,#0x9c]        ;1854
0004c2  f8dd8094          LDR      r8,[sp,#0x94]         ;1854
0004c6  2000              MOVS     r0,#0                 ;1857
0004c8  fb00c008          MLA      r0,r0,r8,r12          ;1857
0004cc  eb050c81          ADD      r12,r5,r1,LSL #2      ;1857
0004d0  eb000081          ADD      r0,r0,r1,LSL #2       ;1857
0004d4  ed9c0a00          VLDR     s0,[r12,#0]           ;1857
0004d8  1c49              ADDS     r1,r1,#1              ;1852
0004da  ed800a00          VSTR     s0,[r0,#0]            ;1857
0004de  2906              CMP      r1,#6                 ;1852
0004e0  dbd9              BLT      |L11.1174|
0004e2  2100              MOVS     r1,#0                 ;1860
0004e4  a828              ADD      r0,sp,#0xa0           ;1860
0004e6  f7fffffe          BL       _ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b ; Anki::Embedded::Matrix::MakeSymmetric<Anki::Embedded::Array<float>>(T1&, bool)
0004ea  ab22              ADD      r3,sp,#0x88           ;1880
0004ec  2200              MOVS     r2,#0                 ;1880
0004ee  a923              ADD      r1,sp,#0x8c           ;1880
0004f0  a828              ADD      r0,sp,#0xa0           ;1880
0004f2  f7fffffe          BL       _ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)
0004f6  2800              CMP      r0,#0                 ;1880
;;;1924   
;;;1925             if(fabs(b[0][0]) < angleConvergenceTolerance &&
;;;1926               fabs(b[0][1]) < angleConvergenceTolerance &&
;;;1927               fabs(b[0][2]) < angleConvergenceTolerance &&
;;;1928               fabs(b[0][3]) < transConvergenceTolerance &&
;;;1929               fabs(b[0][4]) < transConvergenceTolerance &&
;;;1930               fabs(b[0][5]) < transConvergenceTolerance)
;;;1931             {
;;;1932               /*
;;;1933               CoreTechPrint("Final params converged at scale %d: angles = (%f,%f,%f) "
;;;1934               "degrees, translation = (%f,%f,%f)\n",
;;;1935               whichScale,
;;;1936               RAD_TO_DEG(this->params6DoF.angle_x),
;;;1937               RAD_TO_DEG(this->params6DoF.angle_y),
;;;1938               RAD_TO_DEG(this->params6DoF.angle_z),
;;;1939               this->params6DoF.translation.x,
;;;1940               this->params6DoF.translation.y,
;;;1941               this->params6DoF.translation.z);
;;;1942               */
;;;1943   #endif
;;;1944   
;;;1945               //snprintf(this->resultMessageBuffer, RESULT_MSG_LENGTH,
;;;1946               //         "Converged at scale %f with minChange of %f\n", scale, minChange);
;;;1947   
;;;1948               verify_converged = true;
;;;1949               return RESULT_OK;
;;;1950             }
;;;1951           } // for(s32 iteration=0; iteration<maxIterations; iteration++)
;;;1952   
;;;1953           //snprintf(this->resultMessageBuffer, RESULT_MSG_LENGTH,
;;;1954           //         "Failed to converge at scale %f with minChange of %f\n", scale, minChange);
;;;1955   
;;;1956           return RESULT_OK;
;;;1957         } // Result LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Projective()
0004f8  bf1f              ITTTT    NE
0004fa  b045              ADDNE    sp,sp,#0x114
0004fc  ecbd8b10          VPOPNE   {d8-d15}
000500  b006              ADDNE    sp,sp,#0x18
000502  e8bd8ff0          POPNE    {r4-r11,pc}
000506  f89d0088          LDRB     r0,[sp,#0x88]         ;1883
00050a  2800              CMP      r0,#0                 ;1883
00050c  d17d              BNE      |L11.1546|
00050e  f8940098          LDRB     r0,[r4,#0x98]         ;1883
000512  2800              CMP      r0,#0                 ;1883
000514  bf08              IT       EQ                    ;1883
000516  ed9f0a16          VLDREQ   s0,|L11.1392|
00051a  d02d              BEQ      |L11.1400|
00051c  edd40a2c          VLDR     s1,[r4,#0xb0]         ;1883
000520  ed940a24          VLDR     s0,[r4,#0x90]         ;1883
000524  eef40ac0          VCMPE.F32 s1,s0                 ;1883
000528  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1883
00052c  bf98              IT       LS                    ;1883
00052e  ed940a22          VLDRLS   s0,[r4,#0x88]         ;1883
000532  d921              BLS      |L11.1400|
000534  ed941a25          VLDR     s2,[r4,#0x94]         ;1883
000538  eef40ac1          VCMPE.F32 s1,s2                 ;1883
00053c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1883
000540  bfa8              IT       GE                    ;1883
000542  ed940a23          VLDRGE   s0,[r4,#0x8c]         ;1883
000546  da17              BGE      |L11.1400|
000548  ee701ac0          VSUB.F32 s3,s1,s0              ;1883
00054c  ee310a40          VSUB.F32 s0,s2,s0              ;1883
000550  ed941a23          VLDR     s2,[r4,#0x8c]         ;1883
000554  eec10a80          VDIV.F32 s1,s3,s0              ;1883
000558  ed940a22          VLDR     s0,[r4,#0x88]         ;1883
00055c  ee311a40          VSUB.F32 s2,s2,s0              ;1883
000560  e008              B        |L11.1396|
000562  0000              DCW      0x0000
                  |L11.1380|
000564  00000000          DCFS     0x00000000 ; 0
                  |L11.1384|
000568  3727c5ac          DCFS     0x3727c5ac ; 9.9999997473787516e-06
                  |L11.1388|
00056c  3b808081          DCFS     0x3b808081 ; 0.0039215688593685627
                  |L11.1392|
000570  3e800000          DCFS     0x3e800000 ; 0.25
                  |L11.1396|
000574  ee000a81          VMLA.F32 s0,s1,s2              ;1883
                  |L11.1400|
000578  9a25              LDR      r2,[sp,#0x94]         ;1883
00057a  9927              LDR      r1,[sp,#0x9c]         ;1883
00057c  2000              MOVS     r0,#0                 ;1901
00057e  fb001002          MLA      r0,r0,r2,r1           ;1901
000582  edd40a27          VLDR     s1,[r4,#0x9c]         ;1901
000586  ed901a00          VLDR     s2,[r0,#0]            ;1901
00058a  2000              MOVS     r0,#0                 ;1902
00058c  ee400a41          VMLS.F32 s1,s0,s2              ;1901
000590  edc40a27          VSTR     s1,[r4,#0x9c]         ;1901
000594  9a25              LDR      r2,[sp,#0x94]         ;1901
000596  9927              LDR      r1,[sp,#0x9c]         ;1901
000598  edd40a28          VLDR     s1,[r4,#0xa0]         ;1902
00059c  fb001002          MLA      r0,r0,r2,r1           ;1902
0005a0  ed901a01          VLDR     s2,[r0,#4]            ;1902
0005a4  2000              MOVS     r0,#0                 ;1903
0005a6  ee400a41          VMLS.F32 s1,s0,s2              ;1902
0005aa  edc40a28          VSTR     s1,[r4,#0xa0]         ;1902
0005ae  9a25              LDR      r2,[sp,#0x94]         ;1902
0005b0  9927              LDR      r1,[sp,#0x9c]         ;1902
0005b2  edd40a29          VLDR     s1,[r4,#0xa4]         ;1903
0005b6  fb001002          MLA      r0,r0,r2,r1           ;1903
0005ba  ed901a02          VLDR     s2,[r0,#8]            ;1903
0005be  2000              MOVS     r0,#0                 ;1905
0005c0  ee400a41          VMLS.F32 s1,s0,s2              ;1903
0005c4  edc40a29          VSTR     s1,[r4,#0xa4]         ;1903
0005c8  9a25              LDR      r2,[sp,#0x94]         ;1903
0005ca  9927              LDR      r1,[sp,#0x9c]         ;1903
0005cc  edd40a2a          VLDR     s1,[r4,#0xa8]         ;1905
0005d0  fb001002          MLA      r0,r0,r2,r1           ;1905
0005d4  ed901a03          VLDR     s2,[r0,#0xc]          ;1905
0005d8  2000              MOVS     r0,#0                 ;1906
0005da  ee400a41          VMLS.F32 s1,s0,s2              ;1905
0005de  edc40a2a          VSTR     s1,[r4,#0xa8]         ;1905
0005e2  9a25              LDR      r2,[sp,#0x94]         ;1905
0005e4  9927              LDR      r1,[sp,#0x9c]         ;1905
0005e6  edd40a2b          VLDR     s1,[r4,#0xac]         ;1906
0005ea  fb001002          MLA      r0,r0,r2,r1           ;1906
0005ee  ed901a04          VLDR     s2,[r0,#0x10]         ;1906
0005f2  2000              MOVS     r0,#0                 ;1907
0005f4  ee400a41          VMLS.F32 s1,s0,s2              ;1906
0005f8  edc40a2b          VSTR     s1,[r4,#0xac]         ;1906
0005fc  9a25              LDR      r2,[sp,#0x94]         ;1906
0005fe  9927              LDR      r1,[sp,#0x9c]         ;1906
000600  fb001002          MLA      r0,r0,r2,r1           ;1906
000604  ed901a05          VLDR     s2,[r0,#0x14]         ;1907
000608  e000              B        |L11.1548|
                  |L11.1546|
00060a  e05d              B        |L11.1736|
                  |L11.1548|
00060c  edd40a2c          VLDR     s1,[r4,#0xb0]         ;1907
000610  a834              ADD      r0,sp,#0xd0           ;1912
000612  ee400a41          VMLS.F32 s1,s0,s2              ;1907
000616  edc40a2c          VSTR     s1,[r4,#0xb0]         ;1907
00061a  9965              LDR      r1,[sp,#0x194]        ;1912
00061c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000620  4601              MOV      r1,r0                 ;1912
000622  4620              MOV      r0,r4                 ;1912
000624  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof20UpdateTransformationENS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::UpdateTransformation(Anki::Embedded::MemoryStack)
000628  9a25              LDR      r2,[sp,#0x94]         ;1912
00062a  9927              LDR      r1,[sp,#0x9c]         ;1912
00062c  2000              MOVS     r0,#0                 ;1925
00062e  fb001002          MLA      r0,r0,r2,r1           ;1925
000632  ed9d0a09          VLDR     s0,[sp,#0x24]         ;1912
000636  ed901a00          VLDR     s2,[r0,#0]            ;1925
00063a  eddd0a0a          VLDR     s1,[sp,#0x28]         ;1912
00063e  eeb01ac1          VABS.F32 s2,s2                 ;1912
000642  eeb41ac0          VCMPE.F32 s2,s0                 ;1925
000646  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1925
00064a  d236              BCS      |L11.1722|
00064c  ed901a01          VLDR     s2,[r0,#4]            ;1926
000650  eeb01ac1          VABS.F32 s2,s2                 ;1926
000654  eeb41ac0          VCMPE.F32 s2,s0                 ;1926
000658  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1926
00065c  d22d              BCS      |L11.1722|
00065e  ed901a02          VLDR     s2,[r0,#8]            ;1927
000662  eeb01ac1          VABS.F32 s2,s2                 ;1927
000666  eeb41ac0          VCMPE.F32 s2,s0                 ;1927
00066a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1927
00066e  d224              BCS      |L11.1722|
000670  ed900a03          VLDR     s0,[r0,#0xc]          ;1928
000674  eeb00ac0          VABS.F32 s0,s0                 ;1928
000678  eeb40ae0          VCMPE.F32 s0,s1                 ;1928
00067c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1928
000680  d21b              BCS      |L11.1722|
000682  ed900a04          VLDR     s0,[r0,#0x10]         ;1929
000686  eeb00ac0          VABS.F32 s0,s0                 ;1929
00068a  eeb40ae0          VCMPE.F32 s0,s1                 ;1929
00068e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1929
000692  d212              BCS      |L11.1722|
000694  ed900a05          VLDR     s0,[r0,#0x14]         ;1930
000698  eeb00ac0          VABS.F32 s0,s0                 ;1930
00069c  eeb40ae0          VCMPE.F32 s0,s1                 ;1930
0006a0  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1930
0006a4  d209              BCS      |L11.1722|
0006a6  9964              LDR      r1,[sp,#0x190]        ;1948
0006a8  2001              MOVS     r0,#1                 ;1948
0006aa  7008              STRB     r0,[r1,#0]            ;1948
0006ac  2000              MOVS     r0,#0                 ;1949
                  |L11.1710|
0006ae  b045              ADD      sp,sp,#0x114
0006b0  ecbd8b10          VPOP     {d8-d15}
0006b4  b006              ADD      sp,sp,#0x18
0006b6  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.1722|
0006ba  980b              LDR      r0,[sp,#0x2c]         ;1690
0006bc  9959              LDR      r1,[sp,#0x164]        ;1690
0006be  1c40              ADDS     r0,r0,#1              ;1690
0006c0  900b              STR      r0,[sp,#0x2c]         ;1690
0006c2  4288              CMP      r0,r1                 ;1690
0006c4  f6ffad1b          BLT      |L11.254|
                  |L11.1736|
0006c8  2000              MOVS     r0,#0                 ;1956
0006ca  e7f0              B        |L11.1710|
;;;1958   
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof34IterativelyRefineTrack_TranslationERKNS0_5ArrayIhEEiifRbNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof34IterativelyRefineTrack_TranslationERKNS0_5ArrayIhEEiifRbNS0_11MemoryStackE PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Translation(const Anki::Embedded::Array<unsigned char>&, int, int, float, bool&, Anki::Embedded::MemoryStack)
;;;1400   
;;;1401         Result LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Translation(const Array<u8> &nextImage, const s32 maxIterations, const s32 whichScale, const f32 convergenceTolerance_distance, bool &verify_converged, MemoryStack scratch)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1402         {
000004  461d              MOV      r5,r3
000006  ed2d8b10          VPUSH    {d8-d15}
00000a  b0a9              SUB      sp,sp,#0xa4
00000c  4693              MOV      r11,r2
00000e  460e              MOV      r6,r1
000010  4604              MOV      r4,r0
;;;1403           // This method is heavily based on Interp2_Projective
;;;1404           // The call would be like: Interp2_Projective<u8,u8>(nextImage, originalCoordinates, interpolationHomography, centerOffset, nextImageTransformed2d, INTERPOLATE_LINEAR, 0);
;;;1405   
;;;1406           Result lastResult;
;;;1407   
;;;1408           Array<f32> AWAt(3, 3, scratch);
000012  2300              MOVS     r3,#0
000014  eef08a40          VMOV.F32 s17,s0                ;1402
000018  461a              MOV      r2,r3
00001a  2101              MOVS     r1,#1
00001c  a826              ADD      r0,sp,#0x98
00001e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000022  6800              LDR      r0,[r0,#0]
000024  9000              STR      r0,[sp,#0]
000026  2203              MOVS     r2,#3
000028  4611              MOV      r1,r2
00002a  a801              ADD      r0,sp,#4
00002c  9b43              LDR      r3,[sp,#0x10c]
00002e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1409           Array<f32> b(1, 3, scratch);
000032  2300              MOVS     r3,#0
000034  461a              MOV      r2,r3
000036  2101              MOVS     r1,#1
000038  a827              ADD      r0,sp,#0x9c
00003a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00003e  6800              LDR      r0,[r0,#0]
000040  9000              STR      r0,[sp,#0]
000042  2203              MOVS     r2,#3
000044  2101              MOVS     r1,#1
000046  a806              ADD      r0,sp,#0x18
000048  9b43              LDR      r3,[sp,#0x10c]
00004a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1410   
;;;1411           // Raw symmetric entries
;;;1412           // Addresses known at compile time, so should be faster
;;;1413           f32 AWAt00, AWAt01, AWAt02, AWAt11, AWAt12, AWAt22;
;;;1414           f32 b0, b1, b2;
;;;1415   
;;;1416           verify_converged = false;
00004e  9942              LDR      r1,[sp,#0x108]
000050  2000              MOVS     r0,#0
000052  7008              STRB     r0,[r1,#0]
;;;1417   
;;;1418           //f32 minChange = 0.f;
;;;1419   
;;;1420           const s32 nextImageHeight = nextImage.get_size(0);
000054  4601              MOV      r1,r0
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00005c  4680              MOV      r8,r0
;;;1421           const s32 nextImageWidth = nextImage.get_size(1);
00005e  2101              MOVS     r1,#1
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000066  4607              MOV      r7,r0
;;;1422   
;;;1423           const f32 scale = static_cast<f32>(1 << whichScale);
000068  2001              MOVS     r0,#1
00006a  40a8              LSLS     r0,r0,r5
00006c  ee000a10          VMOV     s0,r0
;;;1424   
;;;1425           const s32 initialImageScaleS32 = BASE_IMAGE_WIDTH / nextImageWidth;
000070  f44f70a0          MOV      r0,#0x140
000074  fb90f0f7          SDIV     r0,r0,r7
000078  eeb88ac0          VCVT.F32.S32 s16,s0                ;1423
;;;1426           const f32 initialImageScaleF32 = static_cast<f32>(initialImageScaleS32);
00007c  ee000a10          VMOV     s0,r0
;;;1427   
;;;1428           const f32 oneOverTwoFiftyFive = 1.0f / 255.0f;
;;;1429           //const f32 scaleOverFiveTen = scale / (2.0f*255.0f);
;;;1430   
;;;1431           //const Point<f32>& centerOffset = this->transformation.get_centerOffset();
;;;1432           const Point<f32> centerOffsetScaled = this->transformation.get_centerOffset(initialImageScaleF32);
000080  f1040118          ADD      r1,r4,#0x18
000084  a812              ADD      r0,sp,#0x48
000086  eeb8fac0          VCVT.F32.S32 s30,s0                ;1426
00008a  eeb00a4f          VMOV.F32 s0,s30
00008e  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
;;;1433   
;;;1434   #if COMPUTE_CONVERGENCE_FROM_CORNER_CHANGE
;;;1435           // Initialize with some very extreme coordinates
;;;1436           FixedLengthList<Quadrilateral<f32> > previousCorners(NUM_PREVIOUS_QUADS_TO_COMPARE, scratch);
;;;1437   
;;;1438           for(s32 i=0; i<NUM_PREVIOUS_QUADS_TO_COMPARE; i++) {
;;;1439             previousCorners[i] = Quadrilateral<f32>(Point<f32>(-1e10f,-1e10f), Point<f32>(-1e10f,-1e10f), Point<f32>(-1e10f,-1e10f), Point<f32>(-1e10f,-1e10f));
;;;1440           }
;;;1441   #endif
;;;1442   
;;;1443           const f32 xyReferenceMin = 0.f;
;;;1444           const f32 xReferenceMax = static_cast<f32>(nextImageWidth - 1);
000092  1e78              SUBS     r0,r7,#1
000094  ee000a10          VMOV     s0,r0
;;;1445           const f32 yReferenceMax = static_cast<f32>(nextImageHeight - 1);
000098  f1a80001          SUB      r0,r8,#1
00009c  eb050185          ADD      r1,r5,r5,LSL #2
0000a0  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1444
0000a4  eb0101c5          ADD      r1,r1,r5,LSL #3       ;1444
0000a8  2d00              CMP      r5,#0                 ;1444
0000aa  ed8d0a16          VSTR     s0,[sp,#0x58]         ;1444
0000ae  ee000a10          VMOV     s0,r0
0000b2  eeb80ac0          VCVT.F32.S32 s0,s0
0000b6  ed8d0a25          VSTR     s0,[sp,#0x94]
0000ba  f8d400e4          LDR      r0,[r4,#0xe4]
0000be  eb000081          ADD      r0,r0,r1,LSL #2
0000c2  f8d0a030          LDR      r10,[r0,#0x30]
0000c6  bfa5              ITTET    GE
0000c8  6862              LDRGE    r2,[r4,#4]
0000ca  42aa              CMPGE    r2,r5
0000cc  f04f0800          MOVLT    r8,#0
0000d0  f8d0800c          LDRGE    r8,[r0,#0xc]
;;;1446   
;;;1447           const TemplateSample * restrict pTemplateSamplePyramid = this->templateSamplePyramid[whichScale].Pointer(0);
;;;1448   
;;;1449           const s32 numTemplateSamples = this->get_numTemplatePixels(whichScale);
;;;1450   
;;;1451   #if USE_INTENSITY_NORMALIZATION
;;;1452           const f32 curMean     = this->normalizationMean[whichScale];
;;;1453           const f32 curSigmaInv = this->normalizationSigmaInv[whichScale];
;;;1454   #endif
;;;1455   
;;;1456           for(s32 iteration=0; iteration<maxIterations; iteration++) {
0000d4  f04f0900          MOV      r9,#0
0000d8  f1bb0f00          CMP      r11,#0
0000dc  f340824a          BLE.W    |L12.1396|
;;;1457             const Array<f32> &homography = this->transformation.get_homography();
;;;1458             const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2] / initialImageScaleF32;
;;;1459             const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2] / initialImageScaleF32;
;;;1460             const f32 h20 = homography[2][0] * initialImageScaleF32; const f32 h21 = homography[2][1] * initialImageScaleF32;
;;;1461             const f32 h22 = homography[2][2];
;;;1462   
;;;1463             //AWAt.SetZero();
;;;1464             //b.SetZero();
;;;1465   
;;;1466             // Start with the full (translation-only part of) AtA for this scale.
;;;1467             // We will subtract out contributions from samples currently out of bounds.
;;;1468             const Array<f32>& curAtA = this->AtAPyramid[whichScale];
;;;1469             AWAt00 = curAtA[0][0];
;;;1470             AWAt01 = curAtA[0][1];
;;;1471             AWAt02 = curAtA[0][2];
;;;1472             AWAt11 = curAtA[1][1];
;;;1473             AWAt12 = curAtA[1][2];
;;;1474             AWAt22 = curAtA[2][2];
;;;1475   
;;;1476             b0 = 0.f;
;;;1477             b1 = 0.f;
;;;1478             b2 = 0.f;
;;;1479   
;;;1480             s32 numInBounds = 0;
;;;1481   
;;;1482             // TODO: make the x and y limits from 1 to end-2
;;;1483   
;;;1484             for(s32 iSample=0; iSample<numTemplateSamples; iSample++) {
;;;1485               const TemplateSample curSample = pTemplateSamplePyramid[iSample];
;;;1486               const f32 yOriginal = curSample.yCoordinate;
;;;1487               const f32 xOriginal = curSample.xCoordinate;
;;;1488   
;;;1489               // TODO: These two could be strength reduced
;;;1490               const f32 xTransformedRaw = h00*xOriginal + h01*yOriginal + h02;
;;;1491               const f32 yTransformedRaw = h10*xOriginal + h11*yOriginal + h12;
;;;1492   
;;;1493               const f32 normalization = h20*xOriginal + h21*yOriginal + h22;
;;;1494   
;;;1495               const f32 xTransformed = (xTransformedRaw / normalization) + centerOffsetScaled.x;
;;;1496               const f32 yTransformed = (yTransformedRaw / normalization) + centerOffsetScaled.y;
;;;1497   
;;;1498               const f32 x0 = FLT_FLOOR(xTransformed);
;;;1499               const f32 x1 = ceilf(xTransformed); // x0 + 1.0f;
;;;1500   
;;;1501               const f32 y0 = FLT_FLOOR(yTransformed);
;;;1502               const f32 y1 = ceilf(yTransformed); // y0 + 1.0f;
;;;1503   
;;;1504               // NOTE: The three columns of A we need for translation-only
;;;1505               // update are the *last* three entries in the sample's A entries
;;;1506               const f32 A0 = curSample.A[3];
;;;1507               const f32 A1 = curSample.A[4];
;;;1508               const f32 A2 = curSample.A[5];
;;;1509   
;;;1510               // If out of bounds, subtract this sample's contribution from AtA
;;;1511               if(x0 < xyReferenceMin || x1 > xReferenceMax || y0 < xyReferenceMin || y1 > yReferenceMax) {
;;;1512                 //AWAt
;;;1513                 //  b
;;;1514                 AWAt00 -= A0*A0;
;;;1515                 AWAt01 -= A0*A1;
;;;1516                 AWAt02 -= A0*A2;
;;;1517                 AWAt11 -= A1*A1;
;;;1518                 AWAt12 -= A1*A2;
;;;1519                 AWAt22 -= A2*A2;
;;;1520                 continue;
;;;1521               }
;;;1522   
;;;1523               numInBounds++;
;;;1524   
;;;1525               const f32 alphaX = xTransformed - x0;
;;;1526               const f32 alphaXinverse = 1 - alphaX;
;;;1527   
;;;1528               const f32 alphaY = yTransformed - y0;
;;;1529               const f32 alphaYinverse = 1.0f - alphaY;
;;;1530   
;;;1531               const s32 y0S32 = Round<s32>(y0);
;;;1532               const s32 y1S32 = Round<s32>(y1);
;;;1533               const s32 x0S32 = Round<s32>(x0);
;;;1534   
;;;1535               const u8 * restrict pReference_y0 = nextImage.Pointer(y0S32, x0S32);
;;;1536               const u8 * restrict pReference_y1 = nextImage.Pointer(y1S32, x0S32);
;;;1537   
;;;1538               const f32 pixelTL = *pReference_y0;
;;;1539               const f32 pixelTR = *(pReference_y0+1);
;;;1540               const f32 pixelBL = *pReference_y1;
;;;1541               const f32 pixelBR = *(pReference_y1+1);
;;;1542   
;;;1543               f32 interpolatedPixelF32 = InterpolateBilinear2d<f32>(pixelTL, pixelTR, pixelBL, pixelBR,
;;;1544                 alphaY, alphaYinverse, alphaX, alphaXinverse);
;;;1545   
;;;1546   #if USE_INTENSITY_NORMALIZATION
;;;1547               interpolatedPixelF32 = (interpolatedPixelF32 - curMean) * curSigmaInv;
;;;1548   #endif
;;;1549   
;;;1550               //const u8 interpolatedPixel = static_cast<u8>(Round(interpolatedPixelF32));
;;;1551   
;;;1552               // This block is the non-interpolation part of the per-sample algorithm
;;;1553               {
;;;1554                 const f32 templatePixelValue = static_cast<f32>(curSample.grayvalue);
;;;1555                 //const f32 templatePixelValue = curSample.grayvalue;
;;;1556   
;;;1557                 const f32 tGradientValue = oneOverTwoFiftyFive * (interpolatedPixelF32 - templatePixelValue);
;;;1558   
;;;1559                 b0 += A0 * tGradientValue;
;;;1560                 b1 += A1 * tGradientValue;
;;;1561                 b2 += A2 * tGradientValue;
;;;1562               }
;;;1563             } // for(s32 iSample=0; iSample<numTemplateSamples; iSample++)
;;;1564             /*
;;;1565             if(numInBounds < 16) {
;;;1566             AnkiWarn("LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Translation", "Template drifted too far out of image.");
;;;1567             return RESULT_OK;
;;;1568             }
;;;1569             */
;;;1570             // Copy out the AtA results for this iteration and create the full
;;;1571             // symmetric matrix
;;;1572             AWAt[0][0] = AWAt00;
;;;1573             AWAt[0][1] = AWAt01;
;;;1574             AWAt[0][2] = AWAt02;
;;;1575             AWAt[1][1] = AWAt11;
;;;1576             AWAt[1][2] = AWAt12;
;;;1577             AWAt[2][2] = AWAt22;
;;;1578   
;;;1579             Matrix::MakeSymmetric(AWAt, false);
;;;1580   
;;;1581             b[0][0] = b0;
;;;1582             b[0][1] = b1;
;;;1583             b[0][2] = b2;
;;;1584   
;;;1585             //AWAt.Print("New AWAt");
;;;1586             //b.Print("New b");
;;;1587   
;;;1588             bool numericalFailure;
;;;1589   
;;;1590             if((lastResult = Matrix::SolveLeastSquaresWithCholesky(AWAt, b, false, numericalFailure)) != RESULT_OK)
;;;1591               return lastResult;
;;;1592   
;;;1593             if(numericalFailure){
;;;1594               AnkiWarn("LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Translation", "numericalFailure");
;;;1595               return RESULT_OK;
;;;1596             }
;;;1597   
;;;1598             const f32 Kp = this->GetCurrentGain();
;;;1599   
;;;1600             this->params6DoF.translation.x -= Kp * b[0][0];
;;;1601             this->params6DoF.translation.y -= Kp * b[0][1];
;;;1602             this->params6DoF.translation.z -= Kp * b[0][2];
;;;1603   
;;;1604             // Compute the new homography from the new 6DoF parameters
;;;1605             this->UpdateTransformation(scratch);
;;;1606   
;;;1607             //this->transformation.get_homography().Print("new transformation");
;;;1608   
;;;1609             // Check if we're done with iterations
;;;1610   #if COMPUTE_CONVERGENCE_FROM_CORNER_CHANGE
;;;1611             f32 minChange = UpdatePreviousCorners(transformation, previousCorners, scratch);
;;;1612   
;;;1613             if(minChange < convergenceTolerance * scale) {
;;;1614   #else
;;;1615             const f32 transConvergenceTolerance = scale*convergenceTolerance_distance;
0000e0  ee280a28          VMUL.F32 s0,s16,s17
0000e4  eb050085          ADD      r0,r5,r5,LSL #2
0000e8  9024              STR      r0,[sp,#0x90]
0000ea  eef6ea00          VMOV.F32 s29,#0.50000000
0000ee  ed8d0a23          VSTR     s0,[sp,#0x8c]
                  |L12.242|
0000f2  f1040018          ADD      r0,r4,#0x18           ;1457
0000f6  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
0000fa  6902              LDR      r2,[r0,#0x10]         ;1457
0000fc  6881              LDR      r1,[r0,#8]            ;1457
0000fe  2300              MOVS     r3,#0                 ;1458
000100  fb032001          MLA      r0,r3,r1,r2           ;1458
000104  ed900a00          VLDR     s0,[r0,#0]            ;1458
000108  ed8d0a22          VSTR     s0,[sp,#0x88]         ;1458
00010c  ed900a01          VLDR     s0,[r0,#4]            ;1458
000110  ed8d0a21          VSTR     s0,[sp,#0x84]         ;1458
000114  edd00a02          VLDR     s1,[r0,#8]            ;1458
000118  2001              MOVS     r0,#1                 ;1459
00011a  fb002001          MLA      r0,r0,r1,r2           ;1459
00011e  ee800a8f          VDIV.F32 s0,s1,s30             ;1458
000122  ed8d0a20          VSTR     s0,[sp,#0x80]         ;1458
000126  ed900a00          VLDR     s0,[r0,#0]            ;1459
00012a  ed8d0a1f          VSTR     s0,[sp,#0x7c]         ;1459
00012e  ed900a01          VLDR     s0,[r0,#4]            ;1459
000132  ed8d0a1e          VSTR     s0,[sp,#0x78]         ;1459
000136  edd00a02          VLDR     s1,[r0,#8]            ;1459
00013a  2002              MOVS     r0,#2                 ;1460
00013c  fb002001          MLA      r0,r0,r1,r2           ;1460
000140  ee800a8f          VDIV.F32 s0,s1,s30             ;1459
000144  ed8d0a1d          VSTR     s0,[sp,#0x74]         ;1459
000148  ed900a00          VLDR     s0,[r0,#0]            ;1460
00014c  ee200a0f          VMUL.F32 s0,s0,s30             ;1460
000150  ed8d0a1c          VSTR     s0,[sp,#0x70]         ;1460
000154  ed900a01          VLDR     s0,[r0,#4]            ;1460
000158  ee200a0f          VMUL.F32 s0,s0,s30             ;1460
00015c  ed8d0a1b          VSTR     s0,[sp,#0x6c]         ;1460
000160  ed900a02          VLDR     s0,[r0,#8]            ;1461
000164  ed8d0a1a          VSTR     s0,[sp,#0x68]         ;1461
000168  f8d41118          LDR      r1,[r4,#0x118]        ;1461
00016c  9824              LDR      r0,[sp,#0x90]         ;1461
00016e  eb010080          ADD      r0,r1,r0,LSL #2       ;1461
000172  6882              LDR      r2,[r0,#8]            ;1461
000174  6901              LDR      r1,[r0,#0x10]         ;1461
000176  fb031002          MLA      r0,r3,r2,r1           ;1461
00017a  ed90ea00          VLDR     s28,[r0,#0]           ;1469
00017e  edd0da01          VLDR     s27,[r0,#4]           ;1470
000182  ed90da02          VLDR     s26,[r0,#8]           ;1471
000186  2001              MOVS     r0,#1                 ;1472
000188  fb001002          MLA      r0,r0,r2,r1           ;1472
00018c  edd0ca01          VLDR     s25,[r0,#4]           ;1472
000190  ed90ca02          VLDR     s24,[r0,#8]           ;1473
000194  2002              MOVS     r0,#2                 ;1474
000196  fb001002          MLA      r0,r0,r2,r1           ;1474
00019a  edd0ba02          VLDR     s23,[r0,#8]           ;1474
00019e  eddf9af6          VLDR     s19,|L12.1400|
0001a2  2500              MOVS     r5,#0                 ;1484
0001a4  f1b80f00          CMP      r8,#0                 ;1484
0001a8  eeb0aa69          VMOV.F32 s20,s19               ;1476
0001ac  eeb09a69          VMOV.F32 s18,s19               ;1478
0001b0  dd7e              BLE      |L12.688|
0001b2  ed9d0a12          VLDR     s0,[sp,#0x48]         ;1495
0001b6  ed8d0a19          VSTR     s0,[sp,#0x64]         ;1495
0001ba  ed9d0a13          VLDR     s0,[sp,#0x4c]         ;1496
0001be  ed8d0a18          VSTR     s0,[sp,#0x60]         ;1496
                  |L12.450|
0001c2  eb0500c5          ADD      r0,r5,r5,LSL #3       ;1485
0001c6  eb0a0080          ADD      r0,r10,r0,LSL #2      ;1485
0001ca  ed900a06          VLDR     s0,[r0,#0x18]         ;1485
0001ce  ed901a00          VLDR     s2,[r0,#0]            ;1485
0001d2  edd01a01          VLDR     s3,[r0,#4]            ;1485
0001d6  6887              LDR      r7,[r0,#8]            ;1485
0001d8  edd0fa07          VLDR     s31,[r0,#0x1c]        ;1485
0001dc  ed8d0a00          VSTR     s0,[sp,#0]            ;1485
0001e0  edd00a08          VLDR     s1,[r0,#0x20]         ;1485
0001e4  edcd0a15          VSTR     s1,[sp,#0x54]         ;1485
0001e8  ed9d0a22          VLDR     s0,[sp,#0x88]         ;1490
0001ec  ee600a01          VMUL.F32 s1,s0,s2              ;1490
0001f0  ed9d0a21          VLDR     s0,[sp,#0x84]         ;1490
0001f4  ee400a21          VMLA.F32 s1,s0,s3              ;1490
0001f8  ed9d0a20          VLDR     s0,[sp,#0x80]         ;1490
0001fc  ee302a80          VADD.F32 s4,s1,s0              ;1490
000200  ed9d0a1f          VLDR     s0,[sp,#0x7c]         ;1491
000204  eddd0a1e          VLDR     s1,[sp,#0x78]         ;1491
000208  ee200a01          VMUL.F32 s0,s0,s2              ;1491
00020c  ee000aa1          VMLA.F32 s0,s1,s3              ;1491
000210  eddd0a1d          VLDR     s1,[sp,#0x74]         ;1491
000214  ee700a20          VADD.F32 s1,s0,s1              ;1491
000218  ed9d0a1c          VLDR     s0,[sp,#0x70]         ;1493
00021c  ee201a01          VMUL.F32 s2,s0,s2              ;1493
000220  ed9d0a1b          VLDR     s0,[sp,#0x6c]         ;1493
000224  ee001a21          VMLA.F32 s2,s0,s3              ;1493
000228  ed9d0a1a          VLDR     s0,[sp,#0x68]         ;1493
00022c  ee310a00          VADD.F32 s0,s2,s0              ;1493
000230  ed9d1a19          VLDR     s2,[sp,#0x64]         ;1495
000234  eec21a00          VDIV.F32 s3,s4,s0              ;1495
000238  ee31ba81          VADD.F32 s22,s3,s2             ;1495
00023c  ee801a80          VDIV.F32 s2,s1,s0              ;1496
000240  ed9d0a18          VLDR     s0,[sp,#0x60]         ;1496
000244  ee71aa00          VADD.F32 s21,s2,s0             ;1496
000248  ed9f8acc          VLDR     s16,|L12.1404|
00024c  ee3b0a08          VADD.F32 s0,s22,s16            ;1498
000250  f7fffffe          BL       __hardfp_floorf
000254  eef08a40          VMOV.F32 s17,s0                ;1498
000258  eeb00a4b          VMOV.F32 s0,s22                ;1499
00025c  f7fffffe          BL       __hardfp_ceilf
000260  ed8d0a14          VSTR     s0,[sp,#0x50]         ;1499
000264  ee3a0a88          VADD.F32 s0,s21,s16            ;1501
000268  f7fffffe          BL       __hardfp_floorf
00026c  eeb08a40          VMOV.F32 s16,s0                ;1501
000270  eeb00a6a          VMOV.F32 s0,s21                ;1502
000274  f7fffffe          BL       __hardfp_ceilf
000278  eeb01a40          VMOV.F32 s2,s0                 ;1502
00027c  ed9d0a00          VLDR     s0,[sp,#0]            ;1506
000280  eddd0a15          VLDR     s1,[sp,#0x54]         ;1508
000284  eef58ac0          VCMPE.F32 s17,#0.0              ;1511
000288  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1511
00028c  d316              BCC      |L12.700|
00028e  eddd1a14          VLDR     s3,[sp,#0x50]         ;1511
000292  ed9d2a16          VLDR     s4,[sp,#0x58]         ;1511
000296  eef41ac2          VCMPE.F32 s3,s4                 ;1511
00029a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1511
00029e  dc0d              BGT      |L12.700|
0002a0  eeb58ac0          VCMPE.F32 s16,#0.0              ;1511
0002a4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1511
0002a8  d308              BCC      |L12.700|
0002aa  eddd1a25          VLDR     s3,[sp,#0x94]         ;1511
0002ae  e000              B        |L12.690|
                  |L12.688|
0002b0  e014              B        |L12.732|
                  |L12.690|
0002b2  eeb41ae1          VCMPE.F32 s2,s3                 ;1511
0002b6  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1511
0002ba  dd64              BLE      |L12.902|
                  |L12.700|
0002bc  ee00ea40          VMLS.F32 s28,s0,s0             ;1514
0002c0  ee40da6f          VMLS.F32 s27,s0,s31            ;1515
0002c4  ee00da60          VMLS.F32 s26,s0,s1             ;1516
0002c8  ee4fcaef          VMLS.F32 s25,s31,s31           ;1517
0002cc  ee0fcae0          VMLS.F32 s24,s31,s1            ;1518
0002d0  ee40bae0          VMLS.F32 s23,s1,s1             ;1519
                  |L12.724|
0002d4  1c6d              ADDS     r5,r5,#1              ;1484
0002d6  4545              CMP      r5,r8                 ;1484
0002d8  f6ffaf73          BLT      |L12.450|
                  |L12.732|
0002dc  9a03              LDR      r2,[sp,#0xc]          ;1484
0002de  9905              LDR      r1,[sp,#0x14]         ;1484
0002e0  2000              MOVS     r0,#0                 ;1572
0002e2  fb001002          MLA      r0,r0,r2,r1           ;1572
0002e6  ed80ea00          VSTR     s28,[r0,#0]           ;1572
0002ea  9a03              LDR      r2,[sp,#0xc]          ;1572
0002ec  9905              LDR      r1,[sp,#0x14]         ;1572
0002ee  2000              MOVS     r0,#0                 ;1573
0002f0  fb001002          MLA      r0,r0,r2,r1           ;1573
0002f4  edc0da01          VSTR     s27,[r0,#4]           ;1573
0002f8  9a03              LDR      r2,[sp,#0xc]          ;1573
0002fa  9905              LDR      r1,[sp,#0x14]         ;1573
0002fc  2000              MOVS     r0,#0                 ;1574
0002fe  fb001002          MLA      r0,r0,r2,r1           ;1574
000302  ed80da02          VSTR     s26,[r0,#8]           ;1574
000306  9a03              LDR      r2,[sp,#0xc]          ;1574
000308  9905              LDR      r1,[sp,#0x14]         ;1574
00030a  2001              MOVS     r0,#1                 ;1575
00030c  fb001002          MLA      r0,r0,r2,r1           ;1575
000310  edc0ca01          VSTR     s25,[r0,#4]           ;1575
000314  9a03              LDR      r2,[sp,#0xc]          ;1575
000316  9905              LDR      r1,[sp,#0x14]         ;1575
000318  2001              MOVS     r0,#1                 ;1576
00031a  fb001002          MLA      r0,r0,r2,r1           ;1576
00031e  ed80ca02          VSTR     s24,[r0,#8]           ;1576
000322  9a03              LDR      r2,[sp,#0xc]          ;1576
000324  9905              LDR      r1,[sp,#0x14]         ;1576
000326  2002              MOVS     r0,#2                 ;1577
000328  fb001002          MLA      r0,r0,r2,r1           ;1577
00032c  2100              MOVS     r1,#0                 ;1579
00032e  edc0ba02          VSTR     s23,[r0,#8]           ;1577
000332  a801              ADD      r0,sp,#4              ;1579
000334  f7fffffe          BL       _ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b ; Anki::Embedded::Matrix::MakeSymmetric<Anki::Embedded::Array<float>>(T1&, bool)
000338  9a08              LDR      r2,[sp,#0x20]         ;1579
00033a  990a              LDR      r1,[sp,#0x28]         ;1579
00033c  2000              MOVS     r0,#0                 ;1581
00033e  fb001002          MLA      r0,r0,r2,r1           ;1581
000342  ab17              ADD      r3,sp,#0x5c           ;1590
000344  ed80aa00          VSTR     s20,[r0,#0]           ;1581
000348  9a08              LDR      r2,[sp,#0x20]         ;1581
00034a  990a              LDR      r1,[sp,#0x28]         ;1581
00034c  2000              MOVS     r0,#0                 ;1582
00034e  fb001002          MLA      r0,r0,r2,r1           ;1582
000352  edc09a01          VSTR     s19,[r0,#4]           ;1582
000356  9a08              LDR      r2,[sp,#0x20]         ;1582
000358  990a              LDR      r1,[sp,#0x28]         ;1582
00035a  2000              MOVS     r0,#0                 ;1583
00035c  fb001002          MLA      r0,r0,r2,r1           ;1583
000360  2200              MOVS     r2,#0                 ;1590
000362  ed809a02          VSTR     s18,[r0,#8]           ;1583
000366  a906              ADD      r1,sp,#0x18           ;1590
000368  a801              ADD      r0,sp,#4              ;1590
00036a  f7fffffe          BL       _ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)
00036e  2800              CMP      r0,#0                 ;1590
;;;1616   
;;;1617             if(fabs(b[0][0]) < transConvergenceTolerance &&
;;;1618               fabs(b[0][1]) < transConvergenceTolerance &&
;;;1619               fabs(b[0][2]) < transConvergenceTolerance)
;;;1620             {
;;;1621   #endif
;;;1622               verify_converged = true;
;;;1623               return RESULT_OK;
;;;1624             }
;;;1625           } // for(s32 iteration=0; iteration<maxIterations; iteration++)
;;;1626   
;;;1627           //CoreTechPrint("LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Translation() "
;;;1628           //       "failed to converge at scale %f with minChange = %f\n",
;;;1629           //       scale, minChange);
;;;1630   
;;;1631           return RESULT_OK;
;;;1632         } // Result LucasKanadeTracker_SampledPlanar6dof::IterativelyRefineTrack_Translation()
000370  bf1e              ITTT     NE
000372  b029              ADDNE    sp,sp,#0xa4
000374  ecbd8b10          VPOPNE   {d8-d15}
000378  e8bd8ff0          POPNE    {r4-r11,pc}
00037c  f89d005c          LDRB     r0,[sp,#0x5c]         ;1593
000380  2800              CMP      r0,#0                 ;1593
000382  d17b              BNE      |L12.1148|
000384  e06a              B        |L12.1116|
                  |L12.902|
000386  ee7b1a68          VSUB.F32 s3,s22,s17            ;1525
00038a  ee7a2ac8          VSUB.F32 s5,s21,s16            ;1528
00038e  eeb73a00          VMOV.F32 s6,#1.00000000        ;1526
000392  eeb58ac0          VCMPE.F32 s16,#0.0              ;1526
000396  ee332a61          VSUB.F32 s4,s6,s3              ;1526
00039a  ee733a62          VSUB.F32 s7,s6,s5              ;1529
00039e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1529
0003a2  bfcc              ITE      GT                    ;1529
0003a4  ee383a2e          VADDGT.F32 s6,s16,s29            ;1529
0003a8  ee383a6e          VSUBLE.F32 s6,s16,s29            ;1529
0003ac  eebd3ac3          VCVT.S32.F32 s6,s6                 ;1529
0003b0  eeb51ac0          VCMPE.F32 s2,#0.0               ;1529
0003b4  ee133a10          VMOV     r3,s6                 ;1529
0003b8  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1529
0003bc  bfcc              ITE      GT                    ;1529
0003be  ee311a2e          VADDGT.F32 s2,s2,s29             ;1529
0003c2  ee311a6e          VSUBLE.F32 s2,s2,s29             ;1529
0003c6  eebd1ac1          VCVT.S32.F32 s2,s2                 ;1529
0003ca  eef58ac0          VCMPE.F32 s17,#0.0              ;1529
0003ce  ee11ca10          VMOV     r12,s2                ;1529
0003d2  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1529
0003d6  bfcc              ITE      GT                    ;1529
0003d8  ee381aae          VADDGT.F32 s2,s17,s29            ;1529
0003dc  ee381aee          VSUBLE.F32 s2,s17,s29            ;1529
0003e0  eebd1ac1          VCVT.S32.F32 s2,s2                 ;1529
0003e4  68b2              LDR      r2,[r6,#8]            ;1529
0003e6  6931              LDR      r1,[r6,#0x10]         ;1529
0003e8  ee110a10          VMOV     r0,s2                 ;1529
0003ec  fb031302          MLA      r3,r3,r2,r1           ;1529
0003f0  fb0c1102          MLA      r1,r12,r2,r1          ;1529
0003f4  4403              ADD      r3,r3,r0              ;1529
0003f6  4408              ADD      r0,r0,r1              ;1529
0003f8  7819              LDRB     r1,[r3,#0]            ;1538
0003fa  ee011a10          VMOV     s2,r1                 ;1538
0003fe  7859              LDRB     r1,[r3,#1]            ;1539
000400  eeb84a41          VCVT.F32.U32 s8,s2                 ;1538
000404  ee011a10          VMOV     s2,r1                 ;1539
000408  7801              LDRB     r1,[r0,#0]            ;1540
00040a  7840              LDRB     r0,[r0,#1]            ;1541
00040c  eeb83a41          VCVT.F32.U32 s6,s2                 ;1539
000410  ee011a10          VMOV     s2,r1                 ;1540
000414  ee224a04          VMUL.F32 s8,s4,s8              ;1540
000418  eef84a41          VCVT.F32.U32 s9,s2                 ;1540
00041c  ee010a10          VMOV     s2,r0                 ;1541
000420  ee014a83          VMLA.F32 s8,s3,s6              ;1541
000424  b2f8              UXTB     r0,r7                 ;1541
000426  eeb81a41          VCVT.F32.U32 s2,s2                 ;1541
00042a  ee222a24          VMUL.F32 s4,s4,s9              ;1541
00042e  ee012a81          VMLA.F32 s4,s3,s2              ;1541
000432  ee231a84          VMUL.F32 s2,s7,s8              ;1541
000436  ee010a90          VMOV     s3,r0                 ;1554
00043a  eef81a61          VCVT.F32.U32 s3,s3                 ;1554
00043e  ee021a82          VMLA.F32 s2,s5,s4              ;1554
000442  ee711a61          VSUB.F32 s3,s2,s3              ;1557
000446  ed9f1a4e          VLDR     s2,|L12.1408|
00044a  ee211a81          VMUL.F32 s2,s3,s2              ;1557
00044e  ee00aa01          VMLA.F32 s20,s0,s2             ;1559
000452  ee4f9a81          VMLA.F32 s19,s31,s2            ;1560
000456  ee009a81          VMLA.F32 s18,s1,s2             ;1561
00045a  e73b              B        |L12.724|
                  |L12.1116|
00045c  f8940098          LDRB     r0,[r4,#0x98]         ;1561
000460  2800              CMP      r0,#0                 ;1561
000462  bf08              IT       EQ                    ;1561
000464  ed9f0a47          VLDREQ   s0,|L12.1412|
000468  d025              BEQ      |L12.1206|
00046a  edd40a2c          VLDR     s1,[r4,#0xb0]         ;1561
00046e  ed940a24          VLDR     s0,[r4,#0x90]         ;1561
000472  eef40ac0          VCMPE.F32 s1,s0                 ;1561
000476  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1561
00047a  e000              B        |L12.1150|
                  |L12.1148|
00047c  e07a              B        |L12.1396|
                  |L12.1150|
00047e  bf98              IT       LS                    ;1561
000480  ed940a22          VLDRLS   s0,[r4,#0x88]         ;1561
000484  d917              BLS      |L12.1206|
000486  ed941a25          VLDR     s2,[r4,#0x94]         ;1561
00048a  eef40ac1          VCMPE.F32 s1,s2                 ;1561
00048e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1561
000492  bfa8              IT       GE                    ;1561
000494  ed940a23          VLDRGE   s0,[r4,#0x8c]         ;1561
000498  da0d              BGE      |L12.1206|
00049a  ee701ac0          VSUB.F32 s3,s1,s0              ;1561
00049e  ee310a40          VSUB.F32 s0,s2,s0              ;1561
0004a2  ed941a23          VLDR     s2,[r4,#0x8c]         ;1561
0004a6  eec10a80          VDIV.F32 s1,s3,s0              ;1561
0004aa  ed940a22          VLDR     s0,[r4,#0x88]         ;1561
0004ae  ee311a40          VSUB.F32 s2,s2,s0              ;1561
0004b2  ee000a81          VMLA.F32 s0,s1,s2              ;1561
                  |L12.1206|
0004b6  9a08              LDR      r2,[sp,#0x20]         ;1561
0004b8  990a              LDR      r1,[sp,#0x28]         ;1561
0004ba  2000              MOVS     r0,#0                 ;1600
0004bc  fb001002          MLA      r0,r0,r2,r1           ;1600
0004c0  edd40a2a          VLDR     s1,[r4,#0xa8]         ;1600
0004c4  ed901a00          VLDR     s2,[r0,#0]            ;1600
0004c8  2000              MOVS     r0,#0                 ;1601
0004ca  ee400a41          VMLS.F32 s1,s0,s2              ;1600
0004ce  edc40a2a          VSTR     s1,[r4,#0xa8]         ;1600
0004d2  9a08              LDR      r2,[sp,#0x20]         ;1600
0004d4  990a              LDR      r1,[sp,#0x28]         ;1600
0004d6  edd40a2b          VLDR     s1,[r4,#0xac]         ;1601
0004da  fb001002          MLA      r0,r0,r2,r1           ;1601
0004de  ed901a01          VLDR     s2,[r0,#4]            ;1601
0004e2  2000              MOVS     r0,#0                 ;1602
0004e4  ee400a41          VMLS.F32 s1,s0,s2              ;1601
0004e8  edc40a2b          VSTR     s1,[r4,#0xac]         ;1601
0004ec  9a08              LDR      r2,[sp,#0x20]         ;1601
0004ee  990a              LDR      r1,[sp,#0x28]         ;1601
0004f0  edd40a2c          VLDR     s1,[r4,#0xb0]         ;1602
0004f4  fb001002          MLA      r0,r0,r2,r1           ;1602
0004f8  ed901a02          VLDR     s2,[r0,#8]            ;1602
0004fc  a80b              ADD      r0,sp,#0x2c           ;1605
0004fe  ee400a41          VMLS.F32 s1,s0,s2              ;1602
000502  edc40a2c          VSTR     s1,[r4,#0xb0]         ;1602
000506  9943              LDR      r1,[sp,#0x10c]        ;1605
000508  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00050c  4601              MOV      r1,r0                 ;1605
00050e  4620              MOV      r0,r4                 ;1605
000510  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof20UpdateTransformationENS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::UpdateTransformation(Anki::Embedded::MemoryStack)
000514  9a08              LDR      r2,[sp,#0x20]         ;1605
000516  990a              LDR      r1,[sp,#0x28]         ;1605
000518  2000              MOVS     r0,#0                 ;1617
00051a  fb001002          MLA      r0,r0,r2,r1           ;1617
00051e  ed9d0a23          VLDR     s0,[sp,#0x8c]         ;1605
000522  edd00a00          VLDR     s1,[r0,#0]            ;1617
000526  eef00ae0          VABS.F32 s1,s1                 ;1617
00052a  eef40ac0          VCMPE.F32 s1,s0                 ;1617
00052e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1617
000532  d21a              BCS      |L12.1386|
000534  edd00a01          VLDR     s1,[r0,#4]            ;1618
000538  eef00ae0          VABS.F32 s1,s1                 ;1618
00053c  eef40ac0          VCMPE.F32 s1,s0                 ;1618
000540  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1618
000544  d211              BCS      |L12.1386|
000546  edd00a02          VLDR     s1,[r0,#8]            ;1619
00054a  eef00ae0          VABS.F32 s1,s1                 ;1619
00054e  eef40ac0          VCMPE.F32 s1,s0                 ;1619
000552  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1619
000556  d208              BCS      |L12.1386|
000558  9942              LDR      r1,[sp,#0x108]        ;1622
00055a  2001              MOVS     r0,#1                 ;1622
00055c  7008              STRB     r0,[r1,#0]            ;1622
00055e  2000              MOVS     r0,#0                 ;1623
                  |L12.1376|
000560  b029              ADD      sp,sp,#0xa4
000562  ecbd8b10          VPOP     {d8-d15}
000566  e8bd8ff0          POP      {r4-r11,pc}
                  |L12.1386|
00056a  f1090901          ADD      r9,r9,#1              ;1456
00056e  45d9              CMP      r9,r11                ;1456
000570  f6ffadbf          BLT      |L12.242|
                  |L12.1396|
000574  2000              MOVS     r0,#0                 ;1631
000576  e7f3              B        |L12.1376|
                  |L12.1400|
000578  00000000          DCFS     0x00000000 ; 0
                  |L12.1404|
00057c  3727c5ac          DCFS     0x3727c5ac ; 9.9999997473787516e-06
                  |L12.1408|
000580  3b808081          DCFS     0x3b808081 ; 0.0039215688593685627
                  |L12.1412|
000584  3e800000          DCFS     0x3e800000 ; 0.25
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfiNS0_15Transformations13TransformTypeEifiifffffNS0_11MemoryStackERSD_SD_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC2ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfiNS0_15Transformations13TransformTypeEifiifffffNS0_11MemoryStackERSD_SD_                  ; Alternate entry point ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof__sub_object(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, float, int, Anki::Embedded::Transformations::TransformType, int, float, int, int, float, float, float, float, float, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack&, Anki::Embedded::MemoryStack)
                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfiNS0_15Transformations13TransformTypeEifiifffffNS0_11MemoryStackERSD_SD_ PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, float, int, Anki::Embedded::Transformations::TransformType, int, float, int, int, float, float, float, float, float, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack&, Anki::Embedded::MemoryStack)
;;;200    
;;;201          LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof(
;;;202            const Array<u8> &templateImage,
;;;203            const Quadrilateral<f32> &templateQuadIn,
;;;204            const f32 scaleTemplateRegionPercent,
;;;205            const s32 numPyramidLevels,
;;;206            const Transformations::TransformType transformType,
;;;207            const s32 numFiducialSquareSamples,
;;;208            const f32 fiducialSquareWidthFraction,
;;;209            const s32 maxSamplesAtBaseLevel,
;;;210            const s32 numSamplingRegions,
;;;211            const f32 focalLength_x,
;;;212            const f32 focalLength_y,
;;;213            const f32 camCenter_x,
;;;214            const f32 camCenter_y,
;;;215            const f32 templateWidth_mm,
;;;216            MemoryStack ccmMemory,
;;;217            MemoryStack &onchipScratch,
;;;218            MemoryStack offchipScratch)
;;;219            : LucasKanadeTracker_Generic(Transformations::TRANSFORM_PROJECTIVE, templateImage, templateQuadIn, scaleTemplateRegionPercent, numPyramidLevels, transformType, onchipScratch)
;;;220          {
;;;221            // Allocate all the
;;;222    
;;;223            //templateImage.Show("InitialImage", false);
;;;224    
;;;225            // Initialize calibration data
;;;226            this->focalLength_x = focalLength_x;
;;;227            this->focalLength_y = focalLength_y;
;;;228            this->camCenter_x   = camCenter_x;
;;;229            this->camCenter_y   = camCenter_y;
;;;230    
;;;231            // Start with gain scheduling off
;;;232            this->useGainScheduling = false;
;;;233    
;;;234            // Create a canonical 3D template to use.
;;;235            Point3<f32> template3d[4];
;;;236            const f32 templateHalfWidth = templateWidth_mm * 0.5f;
;;;237            template3d[0] = Point3<f32>(-templateHalfWidth, -templateHalfWidth, 0.f);
;;;238            template3d[1] = Point3<f32>(-templateHalfWidth,  templateHalfWidth, 0.f);
;;;239            template3d[2] = Point3<f32>( templateHalfWidth, -templateHalfWidth, 0.f);
;;;240            template3d[3] = Point3<f32>( templateHalfWidth,  templateHalfWidth, 0.f);
;;;241            Array<f32> R = Array<f32>(3,3,onchipScratch); // TODO: which scratch?
;;;242    
;;;243            // No matter the orientation of the incoming quad, we are always
;;;244            // assuming the canonical 3D marker created above is vertically oriented.
;;;245            // So, make this one vertically oriented too.
;;;246            // TODO: better way to accomplish this?  Feed in un-reordered corners from detected marker?
;;;247            Quadrilateral<f32> clockwiseQuad = templateQuadIn.ComputeClockwiseCorners<f32>();
;;;248            Quadrilateral<f32> templateQuad(clockwiseQuad[0], clockwiseQuad[3],
;;;249              clockwiseQuad[1], clockwiseQuad[2]);
;;;250    
;;;251            /*
;;;252            const Point<f32> diff03 = templateQuad[0] - templateQuad[3];
;;;253            const Point<f32> diff12 = templateQuad[1] - templateQuad[2];
;;;254            const f32 templateQuadDiagonal = MAX(diff03.Length(), diff12.Length()) / sqrtf(2.f);
;;;255            */
;;;256    
;;;257            // Compute the initial pose from the calibration, and the known physical
;;;258            // size of the template.  This gives us R matrix and T vector.
;;;259            // TODO: is single precision enough for the P3P::computePose call here?
;;;260    #if USE_OPENCV_ITERATIVE_POSE_INIT
;;;261            {
;;;262              cv::Vec3d cvRvec, cvTranslation;
;;;263    
;;;264              std::vector<cv::Point2f> cvImagePoints;
;;;265              std::vector<cv::Point3f> cvObjPoints;
;;;266    
;;;267              for(s32 i=0; i<4; ++i) {
;;;268                cvImagePoints.emplace_back(templateQuad[i].get_CvPoint_());
;;;269                cvObjPoints.emplace_back(template3d[i].get_CvPoint_());
;;;270              }
;;;271    
;;;272              Array<f32> calibMatrix = Array<f32>(3,3,onchipScratch);
;;;273              calibMatrix[0][0] = focalLength_x; calibMatrix[0][1] = 0.f;           calibMatrix[0][2] = camCenter_x;
;;;274              calibMatrix[1][0] = 0.f;           calibMatrix[1][1] = focalLength_y; calibMatrix[1][2] = camCenter_y;
;;;275              calibMatrix[2][0] = 0.f;           calibMatrix[2][1] = 0.f;           calibMatrix[2][2] = 1.f;
;;;276    
;;;277              cv::Mat distortionCoeffs; // TODO: currently empty, use radial distoration?
;;;278              cv::Mat calibMatrix_cvMat;
;;;279              calibMatrix.ArrayToCvMat(&calibMatrix_cvMat);
;;;280    
;;;281              cv::solvePnP(cvObjPoints, cvImagePoints,
;;;282                calibMatrix_cvMat, distortionCoeffs,
;;;283                cvRvec, cvTranslation,
;;;284                false, CV_ITERATIVE);
;;;285    
;;;286              //cv::Matx<float,3,3> cvRmat;
;;;287              cv::Mat cvRmat;
;;;288              cv::Rodrigues(cvRvec, cvRmat);
;;;289    
;;;290              cv::Matx<float,3,3> cvRmatx(cvRmat);
;;;291    
;;;292              for(s32 i=0; i<3; ++i) {
;;;293                for(s32 j=0; j<3; ++j) {
;;;294                  R[i][j] = cvRmatx(i,j); //cvRmat.at<float>(i, j);
;;;295                }
;;;296              }
;;;297    
;;;298              this->params6DoF.translation.x = cvTranslation[0];
;;;299              this->params6DoF.translation.y = cvTranslation[1];
;;;300              this->params6DoF.translation.z = cvTranslation[2];
;;;301            }
;;;302    #else
;;;303    
;;;304            P3P::computePose(templateQuad,
;;;305              template3d[0], template3d[1], template3d[2], template3d[3],
;;;306              this->focalLength_x, this->focalLength_y,
;;;307              this->camCenter_x,   this->camCenter_y,
;;;308              R, this->params6DoF.translation);
;;;309    
;;;310    #endif // #if USE_OPENCV_ITERATIVE_POSE_INIT
;;;311    
;;;312            /*
;;;313            R.Print("Initial R for tracker:", 0,3,0,3);
;;;314            CoreTechPrint("Initial T for tracker: ");
;;;315            this->params6DoF.translation.Print();
;;;316            CoreTechPrint("\n");
;;;317            */
;;;318    
;;;319            // Initialize 6DoF rotation angles
;;;320            const Result setR_result = this->set_rotationAnglesFromMatrix(R);
;;;321            AnkiConditionalErrorAndReturn(setR_result == RESULT_OK,
;;;322              "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;323              "Failed to set initial rotation angles.");
;;;324    
;;;325            // Initialize the homography from the 6DoF params
;;;326            Array<f32> initialHomography = Array<f32>(3,3,onchipScratch); // TODO: on-chip b/c this is permanent, right?
;;;327    
;;;328            initialHomography[0][0] = this->focalLength_x*R[0][0];
;;;329            initialHomography[0][1] = this->focalLength_x*R[0][1];
;;;330            initialHomography[0][2] = this->focalLength_x*this->params6DoF.translation.x;// / initialImageScaleF32;
;;;331    
;;;332            initialHomography[1][0] = this->focalLength_y*R[1][0];
;;;333            initialHomography[1][1] = this->focalLength_y*R[1][1];
;;;334            initialHomography[1][2] = this->focalLength_y*this->params6DoF.translation.y;// / initialImageScaleF32;
;;;335    
;;;336            initialHomography[2][0] = R[2][0];// * initialImageScaleF32;
;;;337            initialHomography[2][1] = R[2][1];// * initialImageScaleF32;
;;;338            initialHomography[2][2] = this->params6DoF.translation.z;
;;;339    
;;;340            // Note the center for this tracker is the camera's calibrated center
;;;341            Point<f32> centerOffset(this->camCenter_x, this->camCenter_y);
;;;342    
;;;343            // Note the initial corners for the transformation are the 3D template
;;;344            // corners, since the transformation in this case maps the 3D corners
;;;345            // into the image plane
;;;346            Quadrilateral<f32> initCorners(Point2f(template3d[0].x, template3d[0].y),
;;;347              Point2f(template3d[1].x, template3d[1].y),
;;;348              Point2f(template3d[2].x, template3d[2].y),
;;;349              Point2f(template3d[3].x, template3d[3].y));
;;;350    
;;;351            this->transformation = Transformations::PlanarTransformation_f32(Transformations::TRANSFORM_PROJECTIVE,
;;;352              initCorners, initialHomography, centerOffset,
;;;353              onchipScratch); // TODO: which scratch?
;;;354    
;;;355            // Important: we have to tell the transformation object that the input
;;;356            // points (the canonical 3D model corners) should remain zero-centered
;;;357            // and do not need to be recentered every time we apply the current
;;;358            // transformation to get the current quad.  This is unlike the other
;;;359            // trackers which are generally doing image-to-image transformations
;;;360            // instead of 3D-model-to-image transformations.
;;;361            this->transformation.set_initialPointsAreZeroCentered(true);
;;;362    
;;;363            // Need the partial derivatives at the initial conditions of
;;;364            // the rotation parameters:
;;;365            dR_dtheta_Struct dR_dtheta(params6DoF.angle_x,
;;;366              params6DoF.angle_y,
;;;367              params6DoF.angle_z);
;;;368    
;;;369            const s32 numSelectBins = 20;
;;;370    
;;;371            // TODO: Pass this in as a parameter/argument
;;;372            const s32 verifyGridSize = 16;
;;;373    
;;;374            Result lastResult;
;;;375    
;;;376            BeginBenchmark("LucasKanadeTracker_SampledPlanar6dof");
;;;377    
;;;378            this->templateSamplePyramid = FixedLengthList<FixedLengthList<TemplateSample> >(numPyramidLevels, onchipScratch);
;;;379            this->verificationSamples   = FixedLengthList<VerifySample>(verifyGridSize*verifyGridSize, onchipScratch);
;;;380            this->AtAPyramid            = FixedLengthList<Array<f32> >(numPyramidLevels, onchipScratch);
;;;381    
;;;382            AnkiConditionalErrorAndReturn(this->templateSamplePyramid.IsValid(),
;;;383              "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;384              "Unable to allocate templateSamplePyramid FixedLengthList.");
;;;385    
;;;386            AnkiConditionalErrorAndReturn(this->verificationSamples.IsValid(),
;;;387              "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;388              "Unable to allocate verificationSamples FixedLengthList.");
;;;389    
;;;390            AnkiConditionalErrorAndReturn(this->AtAPyramid.IsValid(),
;;;391              "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;392              "Unable to allocate AtAPyramid FixedLengthList.");
;;;393    
;;;394            this->templateSamplePyramid.set_size(numPyramidLevels);
;;;395            this->AtAPyramid.set_size(numPyramidLevels);
;;;396    
;;;397    #if USE_INTENSITY_NORMALIZATION
;;;398            this->normalizationMean     = FixedLengthList<f32>(numPyramidLevels, onchipScratch);
;;;399            this->normalizationSigmaInv = FixedLengthList<f32>(numPyramidLevels, onchipScratch);
;;;400            this->normalizationMean.set_size(numPyramidLevels);
;;;401            this->normalizationSigmaInv.set_size(numPyramidLevels);
;;;402    #endif
;;;403    
;;;404            //
;;;405            // Compute the samples (and their Jacobians) at each scale
;;;406            //
;;;407            for(s32 iScale=0; iScale<numPyramidLevels; iScale++)
;;;408            {
;;;409              const f32 scale = static_cast<f32>(1 << iScale);
;;;410    
;;;411              this->AtAPyramid[iScale] = Array<f32>(6,6,onchipScratch);
;;;412              Array<f32>& curAtA = this->AtAPyramid[iScale];
;;;413              AnkiConditionalErrorAndReturn(curAtA.IsValid(),
;;;414                "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;415                "Invalid AtA matrix at scale %d.\n", iScale);
;;;416              curAtA.SetZero();
;;;417    
;;;418              const s32 numFiducialSamplesAtScale = numFiducialSquareSamples >> iScale;
;;;419              const s32 numFiducialSamplesPerEdge = CeilS32(static_cast<f32>(numFiducialSamplesAtScale)/8.f);
;;;420              const s32 actualNumFiducialSamplesAtScale = numFiducialSamplesPerEdge * 8;
;;;421              u8 templateBrightValue, templateDarkValue;
;;;422    
;;;423              const HomographyStruct currentH(initialHomography, initialImageScaleF32);
;;;424    
;;;425              //
;;;426              // Samples from the interior of the fiducial
;;;427              //
;;;428              {
;;;429                // Note that template coordinates for this tracker are actually
;;;430                // coordinates on the 3d template, which get mapped into the image
;;;431                // by the homography
;;;432                const f32 halfWidth = scaleTemplateRegionPercent*templateHalfWidth;
;;;433                Meshgrid<f32> templateCoordinates = Meshgrid<f32>(Linspace(-halfWidth, halfWidth,
;;;434                  static_cast<s32>(FLT_FLOOR(this->templateRegionWidth/scale))),
;;;435                  Linspace(-halfWidth, halfWidth,
;;;436                  static_cast<s32>(FLT_FLOOR(this->templateRegionHeight/scale))));
;;;437    
;;;438                // Halve the sample at each subsequent level (not a quarter)
;;;439                const s32 maxPossibleLocations = templateCoordinates.get_numElements();
;;;440                const s32 curMaxSamples = MIN(maxPossibleLocations, maxSamplesAtBaseLevel >> iScale);
;;;441    
;;;442                this->templateSamplePyramid[iScale] = FixedLengthList<TemplateSample>(curMaxSamples + actualNumFiducialSamplesAtScale, onchipScratch);
;;;443                AnkiConditionalErrorAndReturn(this->templateSamplePyramid[iScale].IsValid(),
;;;444                  "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;445                  "Unable to allocate templateSamplePyramid[%d] FixedLengthList.", iScale);
;;;446    
;;;447                const s32 numPointsY = templateCoordinates.get_yGridVector().get_size();
;;;448                const s32 numPointsX = templateCoordinates.get_xGridVector().get_size();
;;;449    
;;;450                PUSH_MEMORY_STACK(offchipScratch);
;;;451                PUSH_MEMORY_STACK(onchipScratch);
;;;452    
;;;453                Array<u8>  grayscaleVector(1, numPointsX*numPointsY, offchipScratch);
;;;454                Array<f32> xGradientVector(1, numPointsX*numPointsY, offchipScratch);
;;;455                Array<f32> yGradientVector(1, numPointsX*numPointsY, offchipScratch);
;;;456                Array<s32> magnitudeIndexes(1, numPointsY*numPointsX, offchipScratch); // NOTE: u16 not enough for full 320x240
;;;457                s32 numSelected = 0;
;;;458                {
;;;459                  PUSH_MEMORY_STACK(offchipScratch);
;;;460    
;;;461                  Array<u8> templateImageAtScale(numPointsY, numPointsX, offchipScratch);
;;;462                  AnkiConditionalErrorAndReturn(templateImageAtScale.IsValid(),
;;;463                    "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;464                    "Out of memory allocating templateImageAtScale.\n");
;;;465    
;;;466                  if((lastResult = Interp2_Projective<u8,u8>(templateImage, templateCoordinates, transformation.get_homography(), this->transformation.get_centerOffset(initialImageScaleF32), templateImageAtScale, INTERPOLATE_LINEAR)) != RESULT_OK) {
;;;467                    AnkiError("LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof", "Interp2_Projective failed with code 0x%x", lastResult);
;;;468                    return;
;;;469                  }
;;;470    
;;;471                  if(numFiducialSamplesAtScale > 0) {
;;;472                    ConstArraySliceExpression<u8> temp = templateImageAtScale(0,-1,0,-1);
;;;473                    templateDarkValue   = Matrix::Min(temp);
;;;474                    templateBrightValue = Matrix::Max(temp);
;;;475                    AnkiConditionalErrorAndReturn(templateBrightValue > templateDarkValue,
;;;476                      "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;477                      "Bright value (%d) should be larger than dark value (%d).",
;;;478                      templateBrightValue, templateDarkValue);
;;;479                  }
;;;480    
;;;481    #if USE_INTENSITY_NORMALIZATION
;;;482                  // Compute the mean and standard deviation of the template for normalization
;;;483                  f32 tempVariance;
;;;484                  if((lastResult = Matrix::MeanAndVar<u8,f32>(templateImageAtScale, this->normalizationMean[iScale], tempVariance)) != RESULT_OK) {
;;;485                    AnkiError("LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof", "MeanAndVar failed with code 0x%x", lastResult);
;;;486                    return;
;;;487                  }
;;;488                  AnkiConditionalError(this->normalizationMean[iScale] < 0.f || this->normalizationMean[iScale] > 255.f,
;;;489                    "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;490                    "Template mean out of reasonable bounds [0,255] - was %.f\n", this->normalizationMean[iScale]);
;;;491                  AnkiConditionalError(tempVariance > 0.f,
;;;492                    "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;493                    "Template variance was zero or negative.");
;;;494                  this->normalizationSigmaInv[iScale] = 1.f/sqrtf(static_cast<f32>(tempVariance));
;;;495    #endif
;;;496    
;;;497                  // Compute X gradient image
;;;498                  Array<f32> templateImageXGradient(numPointsY, numPointsX, offchipScratch);
;;;499                  AnkiConditionalErrorAndReturn(templateImageXGradient.IsValid(),
;;;500                    "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;501                    "Out of memory allocating templateImageXGradient.\n");
;;;502                  if((lastResult = ImageProcessing::ComputeXGradient<u8,f32,f32>(templateImageAtScale, templateImageXGradient)) != RESULT_OK) {
;;;503                    AnkiError("LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof", "ComputeXGradient failed with code 0x%x", lastResult);
;;;504                    return;
;;;505                  }
;;;506    
;;;507                  // Compuate Y gradient image
;;;508                  Array<f32> templateImageYGradient(numPointsY, numPointsX, offchipScratch);
;;;509                  AnkiConditionalErrorAndReturn(templateImageYGradient.IsValid(),
;;;510                    "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;511                    "Out of memory allocating templateImageYGradient.\n");
;;;512                  if((lastResult = ImageProcessing::ComputeYGradient<u8,f32,f32>(templateImageAtScale, templateImageYGradient)) != RESULT_OK) {
;;;513                    AnkiError("LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof", "ComputeYGradient failed with code 0x%x", lastResult);
;;;514                    return;
;;;515                  }
;;;516    
;;;517                  const s32 numDesiredSamples = curMaxSamples;
;;;518    
;;;519                  if(numDesiredSamples < maxPossibleLocations)
;;;520                    // Using the computed gradients, find a set of the max values, and store them
;;;521                  {
;;;522                    PUSH_MEMORY_STACK(offchipScratch);
;;;523    
;;;524                    /*
;;;525                    Array<f32> magnitudeVector(1, numPointsY*numPointsX, offchipScratch);
;;;526                    AnkiConditionalErrorAndReturn(magnitudeVector.IsValid(),
;;;527                    "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;528                    "Out of memory allocating magnitudeVector.\n");
;;;529                    */
;;;530    
;;;531                    {
;;;532                      PUSH_MEMORY_STACK(offchipScratch);
;;;533    
;;;534                      Array<f32> magnitudeImage(numPointsY, numPointsX, offchipScratch);
;;;535                      AnkiConditionalErrorAndReturn(magnitudeImage.IsValid(),
;;;536                        "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;537                        "Out of memory allocating magnitudeImage.\n");
;;;538                      {
;;;539                        PUSH_MEMORY_STACK(offchipScratch);
;;;540    
;;;541                        Array<f32> tmpMagnitude(numPointsY, numPointsX, offchipScratch);
;;;542                        AnkiConditionalErrorAndReturn(tmpMagnitude.IsValid(),
;;;543                          "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;544                          "Out of memory allocating tmpMagnitude.\n");
;;;545    
;;;546                        Matrix::DotMultiply<f32,f32,f32>(templateImageXGradient, templateImageXGradient, tmpMagnitude);
;;;547                        Matrix::DotMultiply<f32,f32,f32>(templateImageYGradient, templateImageYGradient, magnitudeImage);
;;;548                        Matrix::Add<f32,f32,f32>(tmpMagnitude, magnitudeImage, magnitudeImage);
;;;549                      } // pop tmpMagnitude
;;;550    
;;;551                      //Matrix::Sqrt<f32,f32,f32>(magnitudeImage, magnitudeImage);
;;;552    
;;;553                      {
;;;554                        PUSH_MEMORY_STACK(offchipScratch);
;;;555    
;;;556                        // Rough non-local maxima suppression on magnitudes, to get more
;;;557                        // distributed samples, keeping the result in 2D image form
;;;558                        Array<bool> magnitudeImageNLMS(numPointsY, numPointsX, offchipScratch);
;;;559                        AnkiConditionalErrorAndReturn(magnitudeImageNLMS.IsValid(),
;;;560                          "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;561                          "Out of memory allocating magnitudeImageNLMS.\n");
;;;562                        magnitudeImageNLMS.SetZero();
;;;563                        s32 nonZeroCount = 0;
;;;564    #if SAMPLE_TOP_HALF_ONLY
;;;565                        for(s32 i=1; i<(numPointsY/2)-1; ++i) {
;;;566    #else
;;;567                        for(s32 i=1; i<numPointsY-1; ++i) {
;;;568    #endif
;;;569                          const f32 * restrict mag_iPrev = magnitudeImage.Pointer(i-1,0); // prev
;;;570                          const f32 * restrict mag_i     = magnitudeImage.Pointer(i,0);
;;;571                          const f32 * restrict mag_iNext = magnitudeImage.Pointer(i+1,0); // next
;;;572    
;;;573                          bool * restrict magNLMS_i = magnitudeImageNLMS.Pointer(i,0);
;;;574    
;;;575                          for(s32 j=1; j<numPointsX-1; ++j) {
;;;576                            const f32 mag      = mag_i[j];
;;;577                            const f32 magLeft  = mag_i[j-1];
;;;578                            const f32 magRight = mag_i[j+1];
;;;579                            const f32 magUp    = mag_iPrev[j];
;;;580                            const f32 magDown  = mag_iNext[j];
;;;581    
;;;582                            const f32 magUpLeft    = mag_iPrev[j-1];
;;;583                            const f32 magUpRight   = mag_iPrev[j+1];
;;;584                            const f32 magDownLeft  = mag_iNext[j-1];
;;;585                            const f32 magDownRight = mag_iNext[j+1];
;;;586    
;;;587                            if((mag > magLeft && mag > magRight) ||
;;;588                              (mag > magUp && mag > magDown) ||
;;;589                              (mag > magUpLeft && mag > magDownRight) ||
;;;590                              (mag > magUpRight && mag > magDownLeft))
;;;591                            {
;;;592                              magNLMS_i[j] = true; //mag_i[j];
;;;593                              ++nonZeroCount;
;;;594                            }
;;;595                          } // for(s32 j=1; j<numPointsX-1; ++j)
;;;596                        } // for(s32 i=1; i<numPointsY-1; ++i)
;;;597    
;;;598                        //magnitudeImage.Show("MagImage", false);
;;;599    
;;;600                        //if(nonZeroCount > numDesiredSamples) {
;;;601                        // After non-local maxima suppression, we still have enough
;;;602                        // non-zero magnitudes to do sampling, so actually loop back
;;;603                        // through the magnitude image and zero out the non-local
;;;604                        // maxima.
;;;605                        for(s32 i=1; i<numPointsY-1; ++i) {
;;;606                          f32 * restrict mag_i  = magnitudeImage.Pointer(i,0);
;;;607                          bool * restrict magNLMS_i = magnitudeImageNLMS.Pointer(i,0);
;;;608    
;;;609                          for(s32 j=1; j<numPointsX-1; ++j) {
;;;610                            if(!magNLMS_i[j]) {
;;;611                              mag_i[j] = 0.f;
;;;612                            }
;;;613                          }
;;;614                          //}
;;;615                        } // if(nonZeroCount > numDesiredSamples)
;;;616    
;;;617                        //magnitudeImage.Show("MagImageNLMS", false);
;;;618                      } // pop magnitudeImageNLMS
;;;619    
;;;620                      LucasKanadeTracker_SampledPlanar6dof::ApproximateSelect(magnitudeImage, numSelectBins, numSamplingRegions, numDesiredSamples, numSelected, magnitudeIndexes);
;;;621                    } // pop magnitudeImage
;;;622                  } else {
;;;623                    // There are fewer pixels than desired samples, so just use them
;;;624                    // all -- no need to sample.
;;;625                    s32 * restrict pIndex = magnitudeIndexes.Pointer(0,0);
;;;626                    for(s32 i=0; i<numPointsX*numPointsY; ++i) {
;;;627                      pIndex[i] = i;
;;;628                    }
;;;629                    numSelected = numPointsX*numPointsY;
;;;630                  } // if(numDesiredSamples < maxPossibleLocations)
;;;631    
;;;632                  // Vectorize template image grayvalues, and x/y gradients
;;;633                  if((lastResult = Matrix::Vectorize<f32,f32>(false, templateImageXGradient, xGradientVector)) != RESULT_OK) {
;;;634                    AnkiError("LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;635                      "Matrix::Vectorize failed with code 0x%x", lastResult);
;;;636                  }
;;;637    
;;;638                  if((lastResult = Matrix::Vectorize<f32,f32>(false, templateImageYGradient, yGradientVector)) != RESULT_OK) {
;;;639                    AnkiError("LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;640                      "Matrix::Vectorize failed with code 0x%x", lastResult);
;;;641                  }
;;;642    
;;;643                  if((lastResult = Matrix::Vectorize<u8,u8>(false, templateImageAtScale, grayscaleVector)) != RESULT_OK) {
;;;644                    AnkiError("LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;645                      "Matrix::Vectorize failed with code 0x%x", lastResult);
;;;646                  }
;;;647                } // pop templateImageAtScale, templateImageXGradient, and templateImageYGradient
;;;648    
;;;649                this->templateSamplePyramid[iScale].set_size(numSelected + actualNumFiducialSamplesAtScale);
;;;650    
;;;651                if(numSelected == 0) {
;;;652                  // Should this be an error?
;;;653                  AnkiWarn("LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;654                    "No samples found within given quad at scale %d.", iScale);
;;;655                }
;;;656                else {
;;;657                  const s32 numSamples = numSelected;
;;;658    
;;;659                  //const f32 t2 = GetTimeF32();
;;;660                  //CoreTechPrint("%f %f\n", t1-t0, t2-t1);
;;;661    
;;;662                  //{
;;;663                  //  Matlab matlab(false);
;;;664                  //  matlab.PutArray(magnitudeVector, "magnitudeVector");
;;;665                  //  matlab.PutArray(magnitudeIndexes, "magnitudeIndexes");
;;;666                  //}
;;;667    
;;;668                  Array<f32> yCoordinatesVector = templateCoordinates.EvaluateY1(false, offchipScratch);
;;;669                  Array<f32> xCoordinatesVector = templateCoordinates.EvaluateX1(false, offchipScratch);
;;;670    
;;;671                  const f32 * restrict pYCoordinates = yCoordinatesVector.Pointer(0,0);
;;;672                  const f32 * restrict pXCoordinates = xCoordinatesVector.Pointer(0,0);
;;;673                  const f32 * restrict pYGradientVector = yGradientVector.Pointer(0,0);
;;;674                  const f32 * restrict pXGradientVector = xGradientVector.Pointer(0,0);
;;;675                  const u8  * restrict pGrayscaleVector = grayscaleVector.Pointer(0,0);
;;;676                  const s32 * restrict pMagnitudeIndexes = magnitudeIndexes.Pointer(0,0);
;;;677    
;;;678                  // Fill in these interior samples starting after the on-fiducial samples, if any
;;;679                  // (even though those are actually filled in below)
;;;680                  TemplateSample * restrict pTemplateSamplePyramid = this->templateSamplePyramid[iScale].Pointer(actualNumFiducialSamplesAtScale);
;;;681    
;;;682    #if USE_INTENSITY_NORMALIZATION
;;;683                  const f32 curMean     = this->normalizationMean[iScale];
;;;684                  const f32 curSigmaInv = this->normalizationSigmaInv[iScale];
;;;685                  const f32 scaleOverFiveTen = (scale / (2.0f*255.0f)) * curSigmaInv;
;;;686    #else
;;;687                  const f32 scaleOverFiveTen = scale / (2.0f*255.0f);
;;;688    #endif
;;;689    
;;;690                  for(s32 iSample=0; iSample<numSamples; iSample++){
;;;691                    const s32 curIndex = pMagnitudeIndexes[iSample];
;;;692    
;;;693                    pTemplateSamplePyramid[iSample] = ComputeTemplateSample(pGrayscaleVector[curIndex],
;;;694                      pXCoordinates[curIndex],
;;;695                      pYCoordinates[curIndex],
;;;696                      scaleOverFiveTen * pXGradientVector[curIndex],
;;;697                      scaleOverFiveTen * pYGradientVector[curIndex],
;;;698                      currentH, dR_dtheta,
;;;699                      this->focalLength_x, this->focalLength_y, curAtA);
;;;700                  } // for each interior sample
;;;701                } // if/else numSelected==0
;;;702              } // samples from interior of fiducial
;;;703    
;;;704              //
;;;705              // Samples from the implicit fiducial edges
;;;706              //
;;;707              if(numFiducialSquareSamples > 0)
;;;708              {
;;;709                const u8 fiducialSampleGrayValue = (templateBrightValue + templateDarkValue)/2;
;;;710    
;;;711                const f32 contrast = static_cast<f32>(templateBrightValue - templateDarkValue);
;;;712                //const f32 derivMagnitude = (0.5f / 255.f) * contrast * templateQuadDiagonal; // NOTE: scale in numerator and denominator cancel
;;;713                const f32 derivMagnitude = (0.5f / 255.f) * contrast * scale;
;;;714    
;;;715                const f32 innerTemplateWidth = (1.f - 2.f*fiducialSquareWidthFraction) * templateWidth_mm;
;;;716                const f32 innerTemplateHalfWidth = 0.5f * innerTemplateWidth;
;;;717    
;;;718                // Get pointers for the chunk of the samples corresponding to each
;;;719                // edge, so that we can loop over them simultaneously
;;;720    
;;;721    #if SAMPLE_TOP_HALF_ONLY
;;;722                // If only sampling from top half, increment half as fast to use all
;;;723                // the samples on only one half.
;;;724                const f32 outerInc = 0.5f*templateWidth_mm / static_cast<f32>(numFiducialSamplesPerEdge-1);
;;;725                const f32 innerInc = 0.5f*innerTemplateWidth / static_cast<f32>(numFiducialSamplesPerEdge-1);
;;;726    
;;;727                // And concentrate twice as many samples on the top line (by
;;;728                // splitting in half and using "top" to point to the left side and
;;;729                // and "bottom" to point to the right)
;;;730                const f32 signFlip = -1.f;
;;;731    #else
;;;732                const f32 outerInc = templateWidth_mm / static_cast<f32>(numFiducialSamplesPerEdge-1);
;;;733                const f32 innerInc = innerTemplateWidth / static_cast<f32>(numFiducialSamplesPerEdge-1);
;;;734                const f32 signFlip = 1.f;
;;;735    #endif
;;;736                TemplateSample * restrict pOuterTop = this->templateSamplePyramid[iScale].Pointer(0);
;;;737                TemplateSample * restrict pOuterBtm = this->templateSamplePyramid[iScale].Pointer(1*numFiducialSamplesPerEdge);
;;;738                TemplateSample * restrict pInnerTop = this->templateSamplePyramid[iScale].Pointer(2*numFiducialSamplesPerEdge);
;;;739                TemplateSample * restrict pInnerBtm = this->templateSamplePyramid[iScale].Pointer(3*numFiducialSamplesPerEdge);
;;;740    
;;;741                TemplateSample * restrict pOuterLeft  = this->templateSamplePyramid[iScale].Pointer(4*numFiducialSamplesPerEdge);
;;;742                TemplateSample * restrict pOuterRight = this->templateSamplePyramid[iScale].Pointer(5*numFiducialSamplesPerEdge);
;;;743                TemplateSample * restrict pInnerLeft  = this->templateSamplePyramid[iScale].Pointer(6*numFiducialSamplesPerEdge);
;;;744                TemplateSample * restrict pInnerRight = this->templateSamplePyramid[iScale].Pointer(7*numFiducialSamplesPerEdge);
;;;745    
;;;746                f32 outer = -templateHalfWidth;
;;;747                f32 inner = -innerTemplateHalfWidth;
;;;748    
;;;749                // Top/Bottom Edges' Left Corners:
;;;750                pOuterTop[0] = ComputeTemplateSample(fiducialSampleGrayValue, outer, -templateHalfWidth,
;;;751                  -derivMagnitude, -derivMagnitude,
;;;752                  currentH, dR_dtheta,
;;;753                  this->focalLength_x, this->focalLength_y, curAtA);
;;;754    
;;;755                pInnerTop[0] = ComputeTemplateSample(fiducialSampleGrayValue, inner, -innerTemplateHalfWidth,
;;;756                  derivMagnitude, derivMagnitude,
;;;757                  currentH, dR_dtheta,
;;;758                  this->focalLength_x, this->focalLength_y, curAtA);
;;;759    
;;;760                pOuterBtm[0] = ComputeTemplateSample(fiducialSampleGrayValue, outer*signFlip, templateHalfWidth*signFlip,
;;;761                  -derivMagnitude, derivMagnitude*signFlip,
;;;762                  currentH, dR_dtheta,
;;;763                  this->focalLength_x, this->focalLength_y, curAtA);
;;;764    
;;;765                pInnerBtm[0] = ComputeTemplateSample(fiducialSampleGrayValue, inner*signFlip, innerTemplateHalfWidth*signFlip,
;;;766                  derivMagnitude, -derivMagnitude*signFlip,
;;;767                  currentH, dR_dtheta,
;;;768                  this->focalLength_x, this->focalLength_y, curAtA);
;;;769    
;;;770                // Left/Right Edges' Top Corners:
;;;771                pOuterLeft[0]  = ComputeTemplateSample(fiducialSampleGrayValue, -templateHalfWidth, outer,
;;;772                  -derivMagnitude, -derivMagnitude,
;;;773                  currentH, dR_dtheta,
;;;774                  this->focalLength_x, this->focalLength_y, curAtA);
;;;775    
;;;776                pOuterRight[0] = ComputeTemplateSample(fiducialSampleGrayValue, templateHalfWidth, outer,
;;;777                  derivMagnitude, -derivMagnitude,
;;;778                  currentH, dR_dtheta,
;;;779                  this->focalLength_x, this->focalLength_y, curAtA);
;;;780    
;;;781                pInnerLeft[0]  = ComputeTemplateSample(fiducialSampleGrayValue, -innerTemplateHalfWidth, inner,
;;;782                  derivMagnitude, derivMagnitude,
;;;783                  currentH, dR_dtheta,
;;;784                  this->focalLength_x, this->focalLength_y, curAtA);
;;;785    
;;;786                pInnerRight[0] = ComputeTemplateSample(fiducialSampleGrayValue, innerTemplateHalfWidth, inner,
;;;787                  -derivMagnitude, derivMagnitude,
;;;788                  currentH, dR_dtheta,
;;;789                  this->focalLength_x, this->focalLength_y, curAtA);
;;;790    
;;;791                // Interior of each edge (non-corners)
;;;792                outer += outerInc;
;;;793                inner += innerInc;
;;;794                for(s32 iSample=1; iSample<numFiducialSamplesPerEdge-1;
;;;795                  iSample++, outer+=outerInc, inner += innerInc)
;;;796                {
;;;797                  // Top / Bottom Edges
;;;798                  pOuterTop[iSample] = ComputeTemplateSample(fiducialSampleGrayValue, outer, -templateHalfWidth,
;;;799                    0.f, -derivMagnitude,
;;;800                    currentH, dR_dtheta,
;;;801                    this->focalLength_x, this->focalLength_y, curAtA);
;;;802    
;;;803                  pInnerTop[iSample] = ComputeTemplateSample(fiducialSampleGrayValue, inner, -innerTemplateHalfWidth,
;;;804                    0.f, derivMagnitude,
;;;805                    currentH, dR_dtheta,
;;;806                    this->focalLength_x, this->focalLength_y, curAtA);
;;;807    
;;;808                  pOuterBtm[iSample] = ComputeTemplateSample(fiducialSampleGrayValue, outer*signFlip, templateHalfWidth*signFlip,
;;;809                    0.f, derivMagnitude*signFlip,
;;;810                    currentH, dR_dtheta,
;;;811                    this->focalLength_x, this->focalLength_y, curAtA);
;;;812    
;;;813                  pInnerBtm[iSample] = ComputeTemplateSample(fiducialSampleGrayValue, inner*signFlip, innerTemplateHalfWidth*signFlip,
;;;814                    0.f, -derivMagnitude*signFlip,
;;;815                    currentH, dR_dtheta,
;;;816                    this->focalLength_x, this->focalLength_y, curAtA);
;;;817    
;;;818                  // Left / Right Edges
;;;819                  pOuterLeft[iSample]  = ComputeTemplateSample(fiducialSampleGrayValue, -templateHalfWidth, outer,
;;;820                    -derivMagnitude, 0.f,
;;;821                    currentH, dR_dtheta,
;;;822                    this->focalLength_x, this->focalLength_y, curAtA);
;;;823    
;;;824                  pOuterRight[iSample] = ComputeTemplateSample(fiducialSampleGrayValue, templateHalfWidth, outer,
;;;825                    derivMagnitude, 0.f,
;;;826                    currentH, dR_dtheta,
;;;827                    this->focalLength_x, this->focalLength_y, curAtA);
;;;828    
;;;829                  pInnerLeft[iSample]  = ComputeTemplateSample(fiducialSampleGrayValue, -innerTemplateHalfWidth, inner,
;;;830                    derivMagnitude, 0.f,
;;;831                    currentH, dR_dtheta,
;;;832                    this->focalLength_x, this->focalLength_y, curAtA);
;;;833    
;;;834                  pInnerRight[iSample] = ComputeTemplateSample(fiducialSampleGrayValue, innerTemplateHalfWidth, inner,
;;;835                    -derivMagnitude, 0.f,
;;;836                    currentH, dR_dtheta,
;;;837                    this->focalLength_x, this->focalLength_y, curAtA);
;;;838                } // for each interior point
;;;839    
;;;840                // Top/Bottom Edges' Right Corners:
;;;841    
;;;842                pInnerTop[numFiducialSamplesPerEdge-1] = ComputeTemplateSample(fiducialSampleGrayValue, inner, -innerTemplateHalfWidth,
;;;843                  -derivMagnitude, derivMagnitude,
;;;844                  currentH, dR_dtheta,
;;;845                  this->focalLength_x, this->focalLength_y, curAtA);
;;;846    
;;;847                pOuterTop[numFiducialSamplesPerEdge-1] = ComputeTemplateSample(fiducialSampleGrayValue, outer, -templateHalfWidth,
;;;848                  derivMagnitude, -derivMagnitude,
;;;849                  currentH, dR_dtheta,
;;;850                  this->focalLength_x, this->focalLength_y, curAtA);
;;;851    
;;;852                pInnerBtm[numFiducialSamplesPerEdge-1] = ComputeTemplateSample(fiducialSampleGrayValue, inner*signFlip, innerTemplateHalfWidth*signFlip,
;;;853                  -derivMagnitude, -derivMagnitude*signFlip,
;;;854                  currentH, dR_dtheta,
;;;855                  this->focalLength_x, this->focalLength_y, curAtA);
;;;856    
;;;857                pOuterBtm[numFiducialSamplesPerEdge-1] = ComputeTemplateSample(fiducialSampleGrayValue, outer*signFlip, templateHalfWidth*signFlip,
;;;858                  derivMagnitude, derivMagnitude*signFlip,
;;;859                  currentH, dR_dtheta,
;;;860                  this->focalLength_x, this->focalLength_y, curAtA);
;;;861    
;;;862                // Left / Right Edges' Bottom Corners
;;;863                pOuterLeft[numFiducialSamplesPerEdge-1]  = ComputeTemplateSample(fiducialSampleGrayValue, -templateHalfWidth, outer,
;;;864                  -derivMagnitude, derivMagnitude,
;;;865                  currentH, dR_dtheta,
;;;866                  this->focalLength_x, this->focalLength_y, curAtA);
;;;867    
;;;868                pOuterRight[numFiducialSamplesPerEdge-1] = ComputeTemplateSample(fiducialSampleGrayValue, templateHalfWidth, outer,
;;;869                  derivMagnitude, derivMagnitude,
;;;870                  currentH, dR_dtheta,
;;;871                  this->focalLength_x, this->focalLength_y, curAtA);
;;;872    
;;;873                pInnerLeft[numFiducialSamplesPerEdge-1]  = ComputeTemplateSample(fiducialSampleGrayValue, -innerTemplateHalfWidth, inner,
;;;874                  derivMagnitude, -derivMagnitude,
;;;875                  currentH, dR_dtheta,
;;;876                  this->focalLength_x, this->focalLength_y, curAtA);
;;;877    
;;;878                pInnerRight[numFiducialSamplesPerEdge-1] = ComputeTemplateSample(fiducialSampleGrayValue, innerTemplateHalfWidth, inner,
;;;879                  -derivMagnitude, -derivMagnitude,
;;;880                  currentH, dR_dtheta,
;;;881                  this->focalLength_x, this->focalLength_y, curAtA);
;;;882              } // if(numFiducialSquareSamples > 0)
;;;883    
;;;884              // All interior and fiducial square samples completed, each of which
;;;885              // has contributed to the upper triangle of the current AtA matrix
;;;886              // at this scale.  Need to fill in the lower triangle to make it
;;;887              // symmetric:
;;;888              Matrix::MakeSymmetric(curAtA);
;;;889            } // for each scale
;;;890    
;;;891            //
;;;892            // Create Verification Samples
;;;893            //
;;;894            {
;;;895              this->verificationSamples.set_size(verifyGridSize*verifyGridSize);
;;;896    
;;;897              const f32 verifyCoordScalarInv = static_cast<f32>(s8_MAX) / templateHalfWidth;
;;;898    
;;;899              // Store the scalar we need at tracking time to take the stored s8
;;;900              // coordinates into f32 values:
;;;901              this->verifyCoordScalar = 1.f / verifyCoordScalarInv;
;;;902    
;;;903              s32 interiorStartIndex;
;;;904              s32 interiorGridSize;
;;;905              f32 interiorHalfWidth;
;;;906    
;;;907              if(numFiducialSquareSamples > 0) {
;;;908                // Sample within fiducial, within neighboring interior gap, and the
;;;909                // rest from interior region
;;;910                interiorGridSize  = verifyGridSize - 4;
;;;911    
;;;912                interiorHalfWidth = 0.5f*templateWidth_mm*(1.f - 4.f*fiducialSquareWidthFraction);
;;;913    
;;;914                const f32 fiducialSquareCenter = 0.5f * (1.f - fiducialSquareWidthFraction)*templateWidth_mm;
;;;915                const f32 gapCenter = 0.5f * (1.f - 3.f*fiducialSquareWidthFraction)*templateWidth_mm;
;;;916                const f32 gapSidesStart = 0.5f * (1.f - 4.f*fiducialSquareWidthFraction)*templateWidth_mm;
;;;917    
;;;918                // Top/Bottom Bars of the Square
;;;919                interiorStartIndex = 0;
;;;920                lastResult = CreateVerificationSamples(templateImage,
;;;921                  Linspace(-fiducialSquareCenter, fiducialSquareCenter, verifyGridSize),
;;;922    #if SAMPLE_TOP_HALF_ONLY
;;;923                  Linspace(-fiducialSquareCenter, -fiducialSquareCenter, 1), // top line only
;;;924    #else
;;;925                  Linspace(-fiducialSquareCenter, fiducialSquareCenter, 2),
;;;926    #endif
;;;927                  verifyCoordScalarInv,
;;;928                  interiorStartIndex,
;;;929                  onchipScratch);
;;;930    
;;;931                AnkiConditionalErrorAndReturn(lastResult == RESULT_OK,
;;;932                  "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;933                  "CreateVerificationSamples for Top/Bottom Square Bars failed with code 0x%x", lastResult);
;;;934    
;;;935                // Left/Right Bars of the Square
;;;936                lastResult = CreateVerificationSamples(templateImage,
;;;937                  Linspace(-fiducialSquareCenter, fiducialSquareCenter, 2),
;;;938    #if SAMPLE_TOP_HALF_ONLY
;;;939                  Linspace(-gapCenter, 0.f, verifyGridSize-2),
;;;940    #else
;;;941                  Linspace(-gapCenter, gapCenter, verifyGridSize-2),
;;;942    #endif
;;;943                  verifyCoordScalarInv,
;;;944                  interiorStartIndex,
;;;945                  onchipScratch);
;;;946    
;;;947                AnkiConditionalErrorAndReturn(lastResult == RESULT_OK,
;;;948                  "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;949                  "CreateVerificationSamples for Left/Right Square Bars failed with code 0x%x", lastResult);
;;;950    
;;;951                // Top/Bottom Bars of the Gap
;;;952                lastResult = CreateVerificationSamples(templateImage,
;;;953                  Linspace(-gapCenter, gapCenter, verifyGridSize-2),
;;;954    #if SAMPLE_TOP_HALF_ONLY
;;;955                  Linspace(-gapCenter, -gapCenter, 1), // top line only
;;;956    #else
;;;957                  Linspace(-gapCenter, gapCenter, 2),
;;;958    #endif
;;;959                  verifyCoordScalarInv,
;;;960                  interiorStartIndex,
;;;961                  onchipScratch);
;;;962    
;;;963                AnkiConditionalErrorAndReturn(lastResult == RESULT_OK,
;;;964                  "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;965                  "CreateVerificationSamples for Top/Bottom Gap Bars failed with code 0x%x", lastResult);
;;;966    
;;;967                // Left/Right Bars of the Gap
;;;968                lastResult = CreateVerificationSamples(templateImage,
;;;969                  Linspace(-gapCenter, gapCenter, 2),
;;;970    #if SAMPLE_TOP_HALF_ONLY
;;;971                  Linspace(-gapSidesStart, 0.f, verifyGridSize-1),
;;;972    #else
;;;973                  Linspace(-gapSidesStart, gapSidesStart, verifyGridSize-4),
;;;974    #endif
;;;975                  verifyCoordScalarInv,
;;;976                  interiorStartIndex,
;;;977                  onchipScratch);
;;;978    
;;;979                AnkiConditionalErrorAndReturn(lastResult == RESULT_OK,
;;;980                  "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;981                  "CreateVerificationSamples for Left/Right Gap Bars failed with code 0x%x", lastResult);
;;;982              } else {
;;;983                // Use regular grid of samples
;;;984                interiorHalfWidth = scaleTemplateRegionPercent*templateHalfWidth;
;;;985                interiorGridSize  = verifyGridSize;
;;;986                interiorStartIndex = 0;
;;;987              }
;;;988    
;;;989              // Create the interior regular grid of samples
;;;990              lastResult = CreateVerificationSamples(templateImage,
;;;991                Linspace(-interiorHalfWidth, interiorHalfWidth, interiorGridSize),
;;;992    #if SAMPLE_TOP_HALF_ONLY
;;;993                Linspace(-interiorHalfWidth, 0.f, interiorGridSize),
;;;994    #else
;;;995                Linspace(-interiorHalfWidth, interiorHalfWidth, interiorGridSize),
;;;996    #endif
;;;997                verifyCoordScalarInv,
;;;998                interiorStartIndex,
;;;999                onchipScratch);
;;;1000   
;;;1001             AnkiConditionalErrorAndReturn(lastResult == RESULT_OK,
;;;1002               "LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof",
;;;1003               "CreateVerificationSamples failed with code 0x%x", lastResult);
;;;1004           } // create grid of verification samples
;;;1005   
;;;1006           this->isValid = true;
;;;1007   
;;;1008           EndBenchmark("LucasKanadeTracker_SampledPlanar6dof");
;;;1009         }
;;;1010   
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  4616              MOV      r6,r2
000006  ed2d0b08          VPUSH    {d0-d3}
00000a  ed2d8b10          VPUSH    {d8-d15}
00000e  f2ad5db4          SUB      sp,sp,#0x5b4
000012  eeb0ba43          VMOV.F32 s22,s6
000016  eef09a62          VMOV.F32 s19,s5
00001a  eeb09a42          VMOV.F32 s18,s4
00001e  eef08a61          VMOV.F32 s17,s3
000022  eeb08a41          VMOV.F32 s16,s2
000026  eeb0ca60          VMOV.F32 s24,s1
00002a  eef0ca40          VMOV.F32 s25,s0
00002e  f8dd1620          LDR      r1,[sp,#0x620]
000032  f8dd365c          LDR      r3,[sp,#0x65c]
000036  9100              STR      r1,[sp,#0]
000038  f8dd2648          LDR      r2,[sp,#0x648]
00003c  e9cd2301          STRD     r2,r3,[sp,#4]
000040  4633              MOV      r3,r6
000042  f44f6100          MOV      r1,#0x800
000046  f8dd2618          LDR      r2,[sp,#0x618]
00004a  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker26LucasKanadeTracker_GenericC1ENS0_15Transformations13TransformTypeERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfiS4_RNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_Generic::LucasKanadeTracker_Generic(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, float, int, Anki::Embedded::Transformations::TransformType, Anki::Embedded::MemoryStack&)
00004e  30a8              ADDS     r0,r0,#0xa8
000050  eddfbafe          VLDR     s23,|L13.1100|
000054  edc0ba00          VSTR     s23,[r0,#0]
000058  edc0ba01          VSTR     s23,[r0,#4]
00005c  edc0ba02          VSTR     s23,[r0,#8]
000060  300c              ADDS     r0,r0,#0xc
000062  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
000066  300c              ADDS     r0,r0,#0xc
000068  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
00006c  3018              ADDS     r0,r0,#0x18
00006e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000072  f04f34ff          MOV      r4,#0xffffffff
000076  f8404d0c          STR      r4,[r0,#-0xc]!
00007a  2500              MOVS     r5,#0
00007c  6044              STR      r4,[r0,#4]
00007e  6105              STR      r5,[r0,#0x10]
000080  6145              STR      r5,[r0,#0x14]
000082  6185              STR      r5,[r0,#0x18]
000084  f1a00718          SUB      r7,r0,#0x18
000088  6084              STR      r4,[r0,#8]
00008a  4629              MOV      r1,r5
00008c  4638              MOV      r0,r7
00008e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS1_INS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::set_size(int)
000092  f1070034          ADD      r0,r7,#0x34
000096  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
00009a  300c              ADDS     r0,r0,#0xc
00009c  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
0000a0  3018              ADDS     r0,r0,#0x18
0000a2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
0000a6  f8404d0c          STR      r4,[r0,#-0xc]!
0000aa  f1a00718          SUB      r7,r0,#0x18
0000ae  6044              STR      r4,[r0,#4]
0000b0  6105              STR      r5,[r0,#0x10]
0000b2  6145              STR      r5,[r0,#0x14]
0000b4  6185              STR      r5,[r0,#0x18]
0000b6  6084              STR      r4,[r0,#8]
0000b8  2100              MOVS     r1,#0
0000ba  4638              MOV      r0,r7
0000bc  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Array<float>>::set_size(int)
0000c0  f1070034          ADD      r0,r7,#0x34
0000c4  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIfEC1Ev ; Anki::Embedded::FixedLengthList<float>::FixedLengthList()
0000c8  3034              ADDS     r0,r0,#0x34
0000ca  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIfEC1Ev ; Anki::Embedded::FixedLengthList<float>::FixedLengthList()
0000ce  3034              ADDS     r0,r0,#0x34
0000d0  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
0000d4  300c              ADDS     r0,r0,#0xc
0000d6  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
0000da  3018              ADDS     r0,r0,#0x18
0000dc  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
0000e0  f8404d0c          STR      r4,[r0,#-0xc]!
0000e4  2100              MOVS     r1,#0
0000e6  6044              STR      r4,[r0,#4]
0000e8  6105              STR      r5,[r0,#0x10]
0000ea  6084              STR      r4,[r0,#8]
0000ec  6145              STR      r5,[r0,#0x14]
0000ee  f1a00418          SUB      r4,r0,#0x18
0000f2  6185              STR      r5,[r0,#0x18]
0000f4  4620              MOV      r0,r4
0000f6  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::set_size(int)
0000fa  f5a474c2          SUB      r4,r4,#0x184
0000fe  f1040278          ADD      r2,r4,#0x78
000102  2304              MOVS     r3,#4
000104  ec828a04          VSTM     r2,{s16-s19}
000108  220c              MOVS     r2,#0xc
00010a  a824              ADD      r0,sp,#0x90
00010c  f8845098          STRB     r5,[r4,#0x98]
000110  49cf              LDR      r1,|L13.1104|
000112  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
000116  eeb60a00          VMOV.F32 s0,#0.50000000
00011a  2300              MOVS     r3,#0
00011c  ee2b1a40          VNMUL.F32 s2,s22,s0
000120  ee6b0a40          VNMUL.F32 s1,s22,s0
000124  ee6b9a00          VMUL.F32 s19,s22,s0
000128  ed8d1a1a          VSTR     s2,[sp,#0x68]
00012c  edcd0a1b          VSTR     s1,[sp,#0x6c]
000130  edcdba1c          VSTR     s23,[sp,#0x70]
000134  ed8d1a24          VSTR     s2,[sp,#0x90]
000138  eddd0a1b          VLDR     s1,[sp,#0x6c]
00013c  ad24              ADD      r5,sp,#0x90
00013e  edcd0a25          VSTR     s1,[sp,#0x94]
000142  ee6b0a40          VNMUL.F32 s1,s22,s0
000146  edcdba26          VSTR     s23,[sp,#0x98]
00014a  ee2b0a40          VNMUL.F32 s0,s22,s0
00014e  edcd0a1a          VSTR     s1,[sp,#0x68]
000152  edcd9a1b          VSTR     s19,[sp,#0x6c]
000156  edcd0a27          VSTR     s1,[sp,#0x9c]
00015a  edcd9a28          VSTR     s19,[sp,#0xa0]
00015e  edcdba29          VSTR     s23,[sp,#0xa4]
000162  edcd9a1a          VSTR     s19,[sp,#0x68]
000166  ed8d0a1b          VSTR     s0,[sp,#0x6c]
00016a  edcd9a2a          VSTR     s19,[sp,#0xa8]
00016e  ed9d0a1b          VLDR     s0,[sp,#0x6c]
000172  461a              MOV      r2,r3
000174  ed8d0a2b          VSTR     s0,[sp,#0xac]
000178  edcdba2c          VSTR     s23,[sp,#0xb0]
00017c  edcd9a1b          VSTR     s19,[sp,#0x6c]
000180  ed9d0a1a          VLDR     s0,[sp,#0x68]
000184  2101              MOVS     r1,#1
000186  ed8d0a2d          VSTR     s0,[sp,#0xb4]
00018a  edcd9a2e          VSTR     s19,[sp,#0xb8]
00018e  edcdba2f          VSTR     s23,[sp,#0xbc]
000192  f20d504c          ADD      r0,sp,#0x54c
000196  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00019a  6800              LDR      r0,[r0,#0]
00019c  9000              STR      r0,[sp,#0]
00019e  2203              MOVS     r2,#3
0001a0  4611              MOV      r1,r2
0001a2  a891              ADD      r0,sp,#0x244
0001a4  f8dd365c          LDR      r3,[sp,#0x65c]
0001a8  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0001ac  4631              MOV      r1,r6
0001ae  a8ae              ADD      r0,sp,#0x2b8
0001b0  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeClockwiseCorners<float>() const
0001b4  a8b2              ADD      r0,sp,#0x2c8
0001b6  9000              STR      r0,[sp,#0]
0001b8  a9ae              ADD      r1,sp,#0x2b8
0001ba  abb0              ADD      r3,sp,#0x2c0
0001bc  aab4              ADD      r2,sp,#0x2d0
0001be  a8f8              ADD      r0,sp,#0x3e0
0001c0  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_ ; Anki::Embedded::Quadrilateral<float>::Quadrilateral(const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&)
0001c4  aa91              ADD      r2,sp,#0x244
0001c6  a82d              ADD      r0,sp,#0xb4
0001c8  e9cd0200          STRD     r0,r2,[sp,#0]
0001cc  f10401a8          ADD      r1,r4,#0xa8
0001d0  f1050318          ADD      r3,r5,#0x18
0001d4  f105020c          ADD      r2,r5,#0xc
0001d8  9102              STR      r1,[sp,#8]
0001da  f1040578          ADD      r5,r4,#0x78
0001de  a924              ADD      r1,sp,#0x90
0001e0  ec950a04          VLDM     r5,{s0-s3}
0001e4  a8f8              ADD      r0,sp,#0x3e0
0001e6  f7fffffe          BL       _ZN4Anki8Embedded3P3P11computePoseIfEENS_6ResultERKNS0_13QuadrilateralIT_EERKNS0_6Point3IS5_EESC_SC_SC_ffffRNS0_5ArrayIS5_EERSA_ ; Anki::Embedded::P3P::computePose<float>(const Anki::Embedded::Quadrilateral<T1>&, const Anki::Embedded::Point3<T1>&, const Anki::Embedded::Point3<T1>&, const Anki::Embedded::Point3<T1>&, const Anki::Embedded::Point3<T1>&, float, float, float, float, Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)
0001ea  f10403a4          ADD      r3,r4,#0xa4
0001ee  1f1a              SUBS     r2,r3,#4
0001f0  a891              ADD      r0,sp,#0x244
0001f2  1f11              SUBS     r1,r2,#4
0001f4  f7fffffe          BL       _ZN4Anki8Embedded6Matrix14GetEulerAnglesERKNS0_5ArrayIfEERfS6_S6_ ; Anki::Embedded::Matrix::GetEulerAngles(const Anki::Embedded::Array<float>&, float&, float&, float&)
0001f8  2800              CMP      r0,#0
0001fa  d013              BEQ      |L13.548|
0001fc  f2401141          MOV      r1,#0x141
000200  4894              LDR      r0,|L13.1108|
000202  e9cd0100          STRD     r0,r1,[sp,#0]
000206  f20071f4          ADD      r1,r0,#0x7f4
00020a  a393              ADR      r3,|L13.1112|
00020c  a2a2              ADR      r2,|L13.1176|
00020e  2005              MOVS     r0,#5
000210  f7fffffe          BL       _Anki_Log
000214  4620              MOV      r0,r4
                  |L13.534|
000216  f20d5db4          ADD      sp,sp,#0x5b4
00021a  ecbd8b10          VPOP     {d8-d15}
00021e  b00c              ADD      sp,sp,#0x30
000220  e8bd8ff0          POP      {r4-r11,pc}
                  |L13.548|
000224  2300              MOVS     r3,#0
000226  461a              MOV      r2,r3
000228  2101              MOVS     r1,#1
00022a  f20d504c          ADD      r0,sp,#0x54c
00022e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000232  6800              LDR      r0,[r0,#0]
000234  9000              STR      r0,[sp,#0]
000236  2203              MOVS     r2,#3
000238  4611              MOV      r1,r2
00023a  a896              ADD      r0,sp,#0x258
00023c  f8dd365c          LDR      r3,[sp,#0x65c]
000240  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000244  9a95              LDR      r2,[sp,#0x254]
000246  9993              LDR      r1,[sp,#0x24c]
000248  2000              MOVS     r0,#0
00024a  fb002001          MLA      r0,r0,r1,r2
00024e  edd40a1e          VLDR     s1,[r4,#0x78]
000252  ed900a00          VLDR     s0,[r0,#0]
000256  9a9a              LDR      r2,[sp,#0x268]
000258  9998              LDR      r1,[sp,#0x260]
00025a  2000              MOVS     r0,#0
00025c  ee200a20          VMUL.F32 s0,s0,s1
000260  fb002001          MLA      r0,r0,r1,r2
000264  ed800a00          VSTR     s0,[r0,#0]
000268  9a95              LDR      r2,[sp,#0x254]
00026a  9993              LDR      r1,[sp,#0x24c]
00026c  2000              MOVS     r0,#0
00026e  fb002001          MLA      r0,r0,r1,r2
000272  edd40a1e          VLDR     s1,[r4,#0x78]
000276  ed900a01          VLDR     s0,[r0,#4]
00027a  9a9a              LDR      r2,[sp,#0x268]
00027c  9998              LDR      r1,[sp,#0x260]
00027e  2000              MOVS     r0,#0
000280  ee200a20          VMUL.F32 s0,s0,s1
000284  fb002001          MLA      r0,r0,r1,r2
000288  ed800a01          VSTR     s0,[r0,#4]
00028c  ed940a1e          VLDR     s0,[r4,#0x78]
000290  edd40a2a          VLDR     s1,[r4,#0xa8]
000294  9a98              LDR      r2,[sp,#0x260]
000296  999a              LDR      r1,[sp,#0x268]
000298  2000              MOVS     r0,#0
00029a  fb001002          MLA      r0,r0,r2,r1
00029e  ee200a20          VMUL.F32 s0,s0,s1
0002a2  ed800a02          VSTR     s0,[r0,#8]
0002a6  9a93              LDR      r2,[sp,#0x24c]
0002a8  9995              LDR      r1,[sp,#0x254]
0002aa  2001              MOVS     r0,#1
0002ac  fb001002          MLA      r0,r0,r2,r1
0002b0  edd40a1f          VLDR     s1,[r4,#0x7c]
0002b4  ed900a00          VLDR     s0,[r0,#0]
0002b8  9a98              LDR      r2,[sp,#0x260]
0002ba  999a              LDR      r1,[sp,#0x268]
0002bc  2001              MOVS     r0,#1
0002be  ee200a20          VMUL.F32 s0,s0,s1
0002c2  fb001002          MLA      r0,r0,r2,r1
0002c6  ed800a00          VSTR     s0,[r0,#0]
0002ca  9a93              LDR      r2,[sp,#0x24c]
0002cc  9995              LDR      r1,[sp,#0x254]
0002ce  2001              MOVS     r0,#1
0002d0  fb001002          MLA      r0,r0,r2,r1
0002d4  edd40a1f          VLDR     s1,[r4,#0x7c]
0002d8  ed900a01          VLDR     s0,[r0,#4]
0002dc  9a98              LDR      r2,[sp,#0x260]
0002de  999a              LDR      r1,[sp,#0x268]
0002e0  2001              MOVS     r0,#1
0002e2  ee200a20          VMUL.F32 s0,s0,s1
0002e6  fb001002          MLA      r0,r0,r2,r1
0002ea  ed800a01          VSTR     s0,[r0,#4]
0002ee  ed940a1f          VLDR     s0,[r4,#0x7c]
0002f2  edd40a2b          VLDR     s1,[r4,#0xac]
0002f6  9a98              LDR      r2,[sp,#0x260]
0002f8  999a              LDR      r1,[sp,#0x268]
0002fa  2001              MOVS     r0,#1
0002fc  fb001002          MLA      r0,r0,r2,r1
000300  ee200a20          VMUL.F32 s0,s0,s1
000304  ed800a02          VSTR     s0,[r0,#8]
000308  9a93              LDR      r2,[sp,#0x24c]
00030a  9995              LDR      r1,[sp,#0x254]
00030c  2002              MOVS     r0,#2
00030e  fb001002          MLA      r0,r0,r2,r1
000312  9a98              LDR      r2,[sp,#0x260]
000314  ed900a00          VLDR     s0,[r0,#0]
000318  999a              LDR      r1,[sp,#0x268]
00031a  2002              MOVS     r0,#2
00031c  fb001002          MLA      r0,r0,r2,r1
000320  ed800a00          VSTR     s0,[r0,#0]
000324  2002              MOVS     r0,#2
000326  9a93              LDR      r2,[sp,#0x24c]
000328  9995              LDR      r1,[sp,#0x254]
00032a  ab20              ADD      r3,sp,#0x80
00032c  fb001002          MLA      r0,r0,r2,r1
000330  9a98              LDR      r2,[sp,#0x260]
000332  ed900a01          VLDR     s0,[r0,#4]
000336  999a              LDR      r1,[sp,#0x268]
000338  2002              MOVS     r0,#2
00033a  fb001002          MLA      r0,r0,r2,r1
00033e  ed800a01          VSTR     s0,[r0,#4]
000342  9a98              LDR      r2,[sp,#0x260]
000344  999a              LDR      r1,[sp,#0x268]
000346  2002              MOVS     r0,#2
000348  fb001002          MLA      r0,r0,r2,r1
00034c  ed940a2c          VLDR     s0,[r4,#0xb0]
000350  aa1e              ADD      r2,sp,#0x78
000352  ed800a02          VSTR     s0,[r0,#8]
000356  ed940a20          VLDR     s0,[r4,#0x80]
00035a  edd40a21          VLDR     s1,[r4,#0x84]
00035e  ed8d0a30          VSTR     s0,[sp,#0xc0]
000362  edcd0a31          VSTR     s1,[sp,#0xc4]
000366  ed9d0a2d          VLDR     s0,[sp,#0xb4]
00036a  eddd0a2e          VLDR     s1,[sp,#0xb8]
00036e  ed8d0a22          VSTR     s0,[sp,#0x88]
000372  edcd0a23          VSTR     s1,[sp,#0x8c]
000376  ed9d0a2a          VLDR     s0,[sp,#0xa8]
00037a  eddd0a2b          VLDR     s1,[sp,#0xac]
00037e  ed8d0a20          VSTR     s0,[sp,#0x80]
000382  edcd0a21          VSTR     s1,[sp,#0x84]
000386  ed9d0a27          VLDR     s0,[sp,#0x9c]
00038a  eddd0a28          VLDR     s1,[sp,#0xa0]
00038e  ed8d0a1e          VSTR     s0,[sp,#0x78]
000392  edcd0a1f          VSTR     s1,[sp,#0x7c]
000396  ed9d0a24          VLDR     s0,[sp,#0x90]
00039a  eddd0a25          VLDR     s1,[sp,#0x94]
00039e  ed8d0a18          VSTR     s0,[sp,#0x60]
0003a2  a822              ADD      r0,sp,#0x88
0003a4  edcd0a19          VSTR     s1,[sp,#0x64]
0003a8  9000              STR      r0,[sp,#0]
0003aa  a918              ADD      r1,sp,#0x60
0003ac  f50d6080          ADD      r0,sp,#0x400
0003b0  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_ ; Anki::Embedded::Quadrilateral<float>::Quadrilateral(const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&)
0003b4  f8dd165c          LDR      r1,[sp,#0x65c]
0003b8  a830              ADD      r0,sp,#0xc0
0003ba  e9cd0100          STRD     r0,r1,[sp,#0]
0003be  f1040518          ADD      r5,r4,#0x18
0003c2  ab96              ADD      r3,sp,#0x258
0003c4  f50d6280          ADD      r2,sp,#0x400
0003c8  f44f6100          MOV      r1,#0x800
0003cc  a8e7              ADD      r0,sp,#0x39c
0003ce  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
0003d2  7801              LDRB     r1,[r0,#0]
0003d4  7029              STRB     r1,[r5,#0]
0003d6  8841              LDRH     r1,[r0,#2]
0003d8  8069              STRH     r1,[r5,#2]
0003da  6842              LDR      r2,[r0,#4]
0003dc  606a              STR      r2,[r5,#4]
0003de  6882              LDR      r2,[r0,#8]
0003e0  60aa              STR      r2,[r5,#8]
0003e2  68c2              LDR      r2,[r0,#0xc]
0003e4  60ea              STR      r2,[r5,#0xc]
0003e6  6902              LDR      r2,[r0,#0x10]
0003e8  612a              STR      r2,[r5,#0x10]
0003ea  6942              LDR      r2,[r0,#0x14]
0003ec  f1050618          ADD      r6,r5,#0x18
0003f0  f1000c18          ADD      r12,r0,#0x18
0003f4  2100              MOVS     r1,#0
0003f6  616a              STR      r2,[r5,#0x14]
                  |L13.1016|
0003f8  eb0c02c1          ADD      r2,r12,r1,LSL #3
0003fc  eb0603c1          ADD      r3,r6,r1,LSL #3
000400  ed920a00          VLDR     s0,[r2,#0]
000404  1c49              ADDS     r1,r1,#1
000406  ed830a00          VSTR     s0,[r3,#0]
00040a  ed920a01          VLDR     s0,[r2,#4]
00040e  2904              CMP      r1,#4
000410  ed830a01          VSTR     s0,[r3,#4]
000414  dbf0              BLT      |L13.1016|
000416  f8901038          LDRB     r1,[r0,#0x38]
00041a  f8851038          STRB     r1,[r5,#0x38]
00041e  ed900a0f          VLDR     s0,[r0,#0x3c]
000422  2101              MOVS     r1,#1
000424  ed850a0f          VSTR     s0,[r5,#0x3c]
000428  ed900a10          VLDR     s0,[r0,#0x40]
00042c  f1040018          ADD      r0,r4,#0x18
000430  ed850a10          VSTR     s0,[r5,#0x40]
000434  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3232set_initialPointsAreZeroCenteredEb ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_initialPointsAreZeroCentered(bool)
000438  ed94aa27          VLDR     s20,[r4,#0x9c]
00043c  edd48a28          VLDR     s17,[r4,#0xa0]
000440  ed94da29          VLDR     s26,[r4,#0xa4]
000444  eeb00a4a          VMOV.F32 s0,s20
000448  e03a              B        |L13.1216|
00044a  0000              DCW      0x0000
                  |L13.1100|
00044c  00000000          DCFS     0x00000000 ; 0
                  |L13.1104|
                          DCD      _ZN4Anki8Embedded6Point3IfEC1Ev ; Anki::Embedded::Point3<float>::Point3()
                  |L13.1108|
                          DCD      ||.constdata||
                  |L13.1112|
000458  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\lucasKanade_SampledPl"
00045c  6f726574
000460  6563685c
000464  76697369
000468  6f6e5c72
00046c  6f626f74
000470  5c737263
000474  5c6c7563
000478  61734b61
00047c  6e616465
000480  5f53616d
000484  706c6564
000488  506c    
00048a  616e6172          DCB      "anar6dof.cpp",0
00048e  36646f66
000492  2e637070
000496  00      
000497  00                DCB      0
                  |L13.1176|
000498  4661696c          DCB      "Failed to set initial rotation angles.",0
00049c  65642074
0004a0  6f207365
0004a4  7420696e
0004a8  69746961
0004ac  6c20726f
0004b0  74617469
0004b4  6f6e2061
0004b8  6e676c65
0004bc  732e00  
0004bf  00                DCB      0
                  |L13.1216|
0004c0  f7fffffe          BL       __hardfp_sinf
0004c4  eeb09a40          VMOV.F32 s18,s0
0004c8  eeb00a68          VMOV.F32 s0,s17
0004cc  f7fffffe          BL       __hardfp_sinf
0004d0  eef0aa40          VMOV.F32 s21,s0
0004d4  eeb00a4d          VMOV.F32 s0,s26
0004d8  f7fffffe          BL       __hardfp_sinf
0004dc  eeb08a40          VMOV.F32 s16,s0
0004e0  eeb00a4a          VMOV.F32 s0,s20
0004e4  f7fffffe          BL       __hardfp_cosf
0004e8  eeb0aa40          VMOV.F32 s20,s0
0004ec  eeb00a68          VMOV.F32 s0,s17
0004f0  f7fffffe          BL       __hardfp_cosf
0004f4  eef08a40          VMOV.F32 s17,s0
0004f8  eeb00a4d          VMOV.F32 s0,s26
0004fc  f7fffffe          BL       __hardfp_cosf
000500  ee6a0a2a          VMUL.F32 s1,s20,s21
000504  ee201a80          VMUL.F32 s2,s1,s0
000508  ee091a48          VMLS.F32 s2,s18,s16
00050c  ed8d1a0d          VSTR     s2,[sp,#0x34]
000510  ee291a40          VNMUL.F32 s2,s18,s0
000514  ee001ac8          VMLS.F32 s2,s1,s16
000518  ee6a0a68          VNMUL.F32 s1,s20,s17
00051c  ed8d1a12          VSTR     s2,[sp,#0x48]
000520  edcd0a16          VSTR     s1,[sp,#0x58]
000524  ee6a0ac0          VNMUL.F32 s1,s21,s0
000528  ee281ac8          VNMUL.F32 s2,s17,s16
00052c  edcd0a0b          VSTR     s1,[sp,#0x2c]
000530  ee690a28          VMUL.F32 s1,s18,s17
000534  ee600a80          VMUL.F32 s1,s1,s0
000538  edcd0a0e          VSTR     s1,[sp,#0x38]
00053c  ee6a0a88          VMUL.F32 s1,s21,s16
000540  edcd0a10          VSTR     s1,[sp,#0x40]
000544  ee690a68          VNMUL.F32 s1,s18,s17
000548  ee600a88          VMUL.F32 s1,s1,s16
00054c  edcd0a13          VSTR     s1,[sp,#0x4c]
000550  ee690a2a          VMUL.F32 s1,s18,s21
000554  edcd8a15          VSTR     s17,[sp,#0x54]
000558  edcd0a17          VSTR     s1,[sp,#0x5c]
00055c  ed8d1a0c          VSTR     s2,[sp,#0x30]
000560  ee2a1a00          VMUL.F32 s2,s20,s0
000564  ee001ac8          VMLS.F32 s2,s1,s16
000568  ed8d1a0f          VSTR     s2,[sp,#0x3c]
00056c  ee281ac0          VNMUL.F32 s2,s17,s0
000570  ed8d1a11          VSTR     s2,[sp,#0x44]
000574  ee2a1a48          VNMUL.F32 s2,s20,s16
000578  ee001ac0          VMLS.F32 s2,s1,s0
00057c  ed8d1a14          VSTR     s2,[sp,#0x50]
000580  a0fe              ADR      r0,|L13.2428|
000582  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
000586  a83b              ADD      r0,sp,#0xec
000588  9002              STR      r0,[sp,#8]
00058a  f8dd0620          LDR      r0,[sp,#0x620]
00058e  9001              STR      r0,[sp,#4]
000590  2300              MOVS     r3,#0
000592  f10405b4          ADD      r5,r4,#0xb4
000596  461a              MOV      r2,r3
000598  2101              MOVS     r1,#1
00059a  f20d504c          ADD      r0,sp,#0x54c
00059e  f8dd665c          LDR      r6,[sp,#0x65c]
0005a2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0005a6  6800              LDR      r0,[r0,#0]
0005a8  9008              STR      r0,[sp,#0x20]
0005aa  9000              STR      r0,[sp,#0]
0005ac  4633              MOV      r3,r6
0005ae  2101              MOVS     r1,#1
0005b0  a803              ADD      r0,sp,#0xc
0005b2  9a01              LDR      r2,[sp,#4]
0005b4  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0005b8  e9d06700          LDRD     r6,r7,[r0,#0]
0005bc  e9d09802          LDRD     r9,r8,[r0,#8]
0005c0  2200              MOVS     r2,#0
0005c2  f8d0a010          LDR      r10,[r0,#0x10]
0005c6  4611              MOV      r1,r2
0005c8  a832              ADD      r0,sp,#0xc8
0005ca  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
0005ce  4683              MOV      r11,r0
0005d0  2200              MOVS     r2,#0
0005d2  4611              MOV      r1,r2
0005d4  a835              ADD      r0,sp,#0xd4
0005d6  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
0005da  e9db2300          LDRD     r2,r3,[r11,#0]
0005de  f8dbc008          LDR      r12,[r11,#8]
0005e2  f8cdc0f4          STR      r12,[sp,#0xf4]
0005e6  e9cd233b          STRD     r2,r3,[sp,#0xec]
0005ea  e9d02300          LDRD     r2,r3,[r0,#0]
0005ee  6880              LDR      r0,[r0,#8]
0005f0  a940              ADD      r1,sp,#0x100
0005f2  2e00              CMP      r6,#0
0005f4  e8a102c1          STM      r1!,{r0,r6,r7,r9}
0005f8  e9cd233e          STRD     r2,r3,[sp,#0xf8]
0005fc  e9cd8a44          STRD     r8,r10,[sp,#0x110]
000600  bfc8              IT       GT
000602  2f00              CMPGT    r7,#0
000604  f3408449          BLE.W    |L13.3738|
000608  fb06f007          MUL      r0,r6,r7
00060c  2800              CMP      r0,#0
00060e  bf1c              ITT      NE
000610  2000              MOVNE    r0,#0
000612  fb00a009          MLANE    r0,r0,r9,r10
000616  f0008440          BEQ.W    |L13.3738|
                  |L13.1562|
00061a  9046              STR      r0,[sp,#0x118]
00061c  2e00              CMP      r6,#0
00061e  bfc8              IT       GT
000620  2f00              CMPGT    r7,#0
000622  f340843d          BLE.W    |L13.3744|
000626  fb06f007          MUL      r0,r6,r7
00062a  2800              CMP      r0,#0
00062c  bf1c              ITT      NE
00062e  2000              MOVNE    r0,#0
000630  fb00a009          MLANE    r0,r0,r9,r10
000634  f0008434          BEQ.W    |L13.3744|
                  |L13.1592|
000638  9047              STR      r0,[sp,#0x11c]
00063a  2e00              CMP      r6,#0
00063c  bfc8              IT       GT
00063e  2f00              CMPGT    r7,#0
000640  f3408431          BLE.W    |L13.3750|
000644  fb06f007          MUL      r0,r6,r7
000648  2800              CMP      r0,#0
00064a  bf1c              ITT      NE
00064c  2000              MOVNE    r0,#0
00064e  fb00a009          MLANE    r0,r0,r9,r10
000652  f0008428          BEQ.W    |L13.3750|
                  |L13.1622|
000656  9047              STR      r0,[sp,#0x11c]
000658  a808              ADD      r0,sp,#0x20
00065a  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
00065e  2800              CMP      r0,#0
000660  bf12              ITEE     NE
000662  e9dd1001          LDRDNE   r1,r0,[sp,#4]
000666  2100              MOVEQ    r1,#0
000668  9802              LDREQ    r0,[sp,#8]
00066a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS1_INS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::set_size(int)
00066e  e9dd013b          LDRD     r0,r1,[sp,#0xec]
000672  46a8              MOV      r8,r5
000674  9a3d              LDR      r2,[sp,#0xf4]
000676  60aa              STR      r2,[r5,#8]
000678  e9c80100          STRD     r0,r1,[r8,#0]
00067c  e9dd013e          LDRD     r0,r1,[sp,#0xf8]
000680  9a40              LDR      r2,[sp,#0x100]
000682  616a              STR      r2,[r5,#0x14]
000684  e9c80103          STRD     r0,r1,[r8,#0xc]
000688  9841              LDR      r0,[sp,#0x104]
00068a  f8450f18          STR      r0,[r5,#0x18]!
00068e  9842              LDR      r0,[sp,#0x108]
000690  6068              STR      r0,[r5,#4]
000692  9843              LDR      r0,[sp,#0x10c]
000694  60a8              STR      r0,[r5,#8]
000696  9844              LDR      r0,[sp,#0x110]
000698  60e8              STR      r0,[r5,#0xc]
00069a  9845              LDR      r0,[sp,#0x114]
00069c  6128              STR      r0,[r5,#0x10]
00069e  9846              LDR      r0,[sp,#0x118]
0006a0  f8c8002c          STR      r0,[r8,#0x2c]
0006a4  9847              LDR      r0,[sp,#0x11c]
0006a6  f8c80030          STR      r0,[r8,#0x30]
0006aa  a848              ADD      r0,sp,#0x120
0006ac  9002              STR      r0,[sp,#8]
0006ae  f44f7080          MOV      r0,#0x100
0006b2  9001              STR      r0,[sp,#4]
0006b4  2300              MOVS     r3,#0
0006b6  f50475c2          ADD      r5,r4,#0x184
0006ba  461a              MOV      r2,r3
0006bc  2101              MOVS     r1,#1
0006be  f20d504c          ADD      r0,sp,#0x54c
0006c2  f8dd665c          LDR      r6,[sp,#0x65c]
0006c6  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0006ca  6800              LDR      r0,[r0,#0]
0006cc  9008              STR      r0,[sp,#0x20]
0006ce  9000              STR      r0,[sp,#0]
0006d0  4633              MOV      r3,r6
0006d2  2101              MOVS     r1,#1
0006d4  a803              ADD      r0,sp,#0xc
0006d6  9a01              LDR      r2,[sp,#4]
0006d8  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0006dc  e9d06700          LDRD     r6,r7,[r0,#0]
0006e0  e9d09802          LDRD     r9,r8,[r0,#8]
0006e4  2200              MOVS     r2,#0
0006e6  f8d0a010          LDR      r10,[r0,#0x10]
0006ea  4611              MOV      r1,r2
0006ec  a832              ADD      r0,sp,#0xc8
0006ee  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
0006f2  4683              MOV      r11,r0
0006f4  2200              MOVS     r2,#0
0006f6  4611              MOV      r1,r2
0006f8  a835              ADD      r0,sp,#0xd4
0006fa  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
0006fe  e9db2300          LDRD     r2,r3,[r11,#0]
000702  f8dbc008          LDR      r12,[r11,#8]
000706  f8cdc128          STR      r12,[sp,#0x128]
00070a  e9cd2348          STRD     r2,r3,[sp,#0x120]
00070e  6803              LDR      r3,[r0,#0]
000710  6842              LDR      r2,[r0,#4]
000712  6880              LDR      r0,[r0,#8]
000714  a94d              ADD      r1,sp,#0x134
000716  2e00              CMP      r6,#0
000718  e8a102c1          STM      r1!,{r0,r6,r7,r9}
00071c  e9cd324b          STRD     r3,r2,[sp,#0x12c]
000720  e9cd8a51          STRD     r8,r10,[sp,#0x144]
000724  bfc8              IT       GT
000726  2f00              CMPGT    r7,#0
000728  f34083c0          BLE.W    |L13.3756|
00072c  fb06f007          MUL      r0,r6,r7
000730  2800              CMP      r0,#0
000732  bf1c              ITT      NE
000734  2000              MOVNE    r0,#0
000736  fb00a009          MLANE    r0,r0,r9,r10
00073a  f00083b7          BEQ.W    |L13.3756|
                  |L13.1854|
00073e  9053              STR      r0,[sp,#0x14c]
000740  2e00              CMP      r6,#0
000742  bfc8              IT       GT
000744  2f00              CMPGT    r7,#0
000746  f34083b3          BLE.W    |L13.3760|
00074a  fb06f007          MUL      r0,r6,r7
00074e  2800              CMP      r0,#0
000750  bf1c              ITT      NE
000752  2000              MOVNE    r0,#0
000754  fb00a009          MLANE    r0,r0,r9,r10
000758  f00083aa          BEQ.W    |L13.3760|
                  |L13.1884|
00075c  9054              STR      r0,[sp,#0x150]
00075e  2e00              CMP      r6,#0
000760  bfc8              IT       GT
000762  2f00              CMPGT    r7,#0
000764  f34083a6          BLE.W    |L13.3764|
000768  fb06f007          MUL      r0,r6,r7
00076c  2800              CMP      r0,#0
00076e  bf1c              ITT      NE
000770  2000              MOVNE    r0,#0
000772  fb00a009          MLANE    r0,r0,r9,r10
000776  f000839d          BEQ.W    |L13.3764|
                  |L13.1914|
00077a  9054              STR      r0,[sp,#0x150]
00077c  a808              ADD      r0,sp,#0x20
00077e  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
000782  2800              CMP      r0,#0
000784  bf12              ITEE     NE
000786  e9dd1001          LDRDNE   r1,r0,[sp,#4]
00078a  2100              MOVEQ    r1,#0
00078c  9802              LDREQ    r0,[sp,#8]
00078e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::set_size(int)
000792  e9dd0148          LDRD     r0,r1,[sp,#0x120]
000796  46a8              MOV      r8,r5
000798  9a4a              LDR      r2,[sp,#0x128]
00079a  60aa              STR      r2,[r5,#8]
00079c  e9c80100          STRD     r0,r1,[r8,#0]
0007a0  e9dd014b          LDRD     r0,r1,[sp,#0x12c]
0007a4  9a4d              LDR      r2,[sp,#0x134]
0007a6  616a              STR      r2,[r5,#0x14]
0007a8  e9c80103          STRD     r0,r1,[r8,#0xc]
0007ac  984e              LDR      r0,[sp,#0x138]
0007ae  f8450f18          STR      r0,[r5,#0x18]!
0007b2  984f              LDR      r0,[sp,#0x13c]
0007b4  6068              STR      r0,[r5,#4]
0007b6  9850              LDR      r0,[sp,#0x140]
0007b8  60a8              STR      r0,[r5,#8]
0007ba  9851              LDR      r0,[sp,#0x144]
0007bc  60e8              STR      r0,[r5,#0xc]
0007be  9852              LDR      r0,[sp,#0x148]
0007c0  6128              STR      r0,[r5,#0x10]
0007c2  9853              LDR      r0,[sp,#0x14c]
0007c4  f8c8002c          STR      r0,[r8,#0x2c]
0007c8  9854              LDR      r0,[sp,#0x150]
0007ca  f8c80030          STR      r0,[r8,#0x30]
0007ce  a855              ADD      r0,sp,#0x154
0007d0  9002              STR      r0,[sp,#8]
0007d2  f8dd0620          LDR      r0,[sp,#0x620]
0007d6  9001              STR      r0,[sp,#4]
0007d8  2300              MOVS     r3,#0
0007da  f10405e8          ADD      r5,r4,#0xe8
0007de  461a              MOV      r2,r3
0007e0  2101              MOVS     r1,#1
0007e2  f20d504c          ADD      r0,sp,#0x54c
0007e6  f8dd665c          LDR      r6,[sp,#0x65c]
0007ea  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0007ee  6800              LDR      r0,[r0,#0]
0007f0  9008              STR      r0,[sp,#0x20]
0007f2  9000              STR      r0,[sp,#0]
0007f4  4633              MOV      r3,r6
0007f6  2101              MOVS     r1,#1
0007f8  a803              ADD      r0,sp,#0xc
0007fa  9a01              LDR      r2,[sp,#4]
0007fc  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000800  e9d06700          LDRD     r6,r7,[r0,#0]
000804  e9d09802          LDRD     r9,r8,[r0,#8]
000808  2200              MOVS     r2,#0
00080a  f8d0a010          LDR      r10,[r0,#0x10]
00080e  4611              MOV      r1,r2
000810  a832              ADD      r0,sp,#0xc8
000812  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000816  4683              MOV      r11,r0
000818  2200              MOVS     r2,#0
00081a  4611              MOV      r1,r2
00081c  a835              ADD      r0,sp,#0xd4
00081e  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000822  e9db2300          LDRD     r2,r3,[r11,#0]
000826  f8dbc008          LDR      r12,[r11,#8]
00082a  f8cdc15c          STR      r12,[sp,#0x15c]
00082e  e9cd2355          STRD     r2,r3,[sp,#0x154]
000832  6803              LDR      r3,[r0,#0]
000834  6842              LDR      r2,[r0,#4]
000836  6880              LDR      r0,[r0,#8]
000838  a95a              ADD      r1,sp,#0x168
00083a  2e00              CMP      r6,#0
00083c  e8a102c1          STM      r1!,{r0,r6,r7,r9}
000840  e9cd3258          STRD     r3,r2,[sp,#0x160]
000844  e9cd8a5e          STRD     r8,r10,[sp,#0x178]
000848  bfc8              IT       GT
00084a  2f00              CMPGT    r7,#0
00084c  f3408334          BLE.W    |L13.3768|
000850  fb06f007          MUL      r0,r6,r7
000854  2800              CMP      r0,#0
000856  bf1c              ITT      NE
000858  2000              MOVNE    r0,#0
00085a  fb00a009          MLANE    r0,r0,r9,r10
00085e  f000832b          BEQ.W    |L13.3768|
                  |L13.2146|
000862  9060              STR      r0,[sp,#0x180]
000864  2e00              CMP      r6,#0
000866  bfc8              IT       GT
000868  2f00              CMPGT    r7,#0
00086a  f3408327          BLE.W    |L13.3772|
00086e  fb06f007          MUL      r0,r6,r7
000872  2800              CMP      r0,#0
000874  bf1c              ITT      NE
000876  2000              MOVNE    r0,#0
000878  fb00a009          MLANE    r0,r0,r9,r10
00087c  f000831e          BEQ.W    |L13.3772|
                  |L13.2176|
000880  9061              STR      r0,[sp,#0x184]
000882  2e00              CMP      r6,#0
000884  bfc8              IT       GT
000886  2f00              CMPGT    r7,#0
000888  f340831a          BLE.W    |L13.3776|
00088c  fb06f007          MUL      r0,r6,r7
000890  2800              CMP      r0,#0
000892  bf1c              ITT      NE
000894  2000              MOVNE    r0,#0
000896  fb00a009          MLANE    r0,r0,r9,r10
00089a  f0008311          BEQ.W    |L13.3776|
                  |L13.2206|
00089e  9061              STR      r0,[sp,#0x184]
0008a0  a808              ADD      r0,sp,#0x20
0008a2  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0008a6  2800              CMP      r0,#0
0008a8  bf12              ITEE     NE
0008aa  e9dd1001          LDRDNE   r1,r0,[sp,#4]
0008ae  2100              MOVEQ    r1,#0
0008b0  9802              LDREQ    r0,[sp,#8]
0008b2  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Array<float>>::set_size(int)
0008b6  e9dd0155          LDRD     r0,r1,[sp,#0x154]
0008ba  46a8              MOV      r8,r5
0008bc  9a57              LDR      r2,[sp,#0x15c]
0008be  60aa              STR      r2,[r5,#8]
0008c0  e9c80100          STRD     r0,r1,[r8,#0]
0008c4  e9dd0158          LDRD     r0,r1,[sp,#0x160]
0008c8  9a5a              LDR      r2,[sp,#0x168]
0008ca  616a              STR      r2,[r5,#0x14]
0008cc  e9c80103          STRD     r0,r1,[r8,#0xc]
0008d0  985b              LDR      r0,[sp,#0x16c]
0008d2  f8450f18          STR      r0,[r5,#0x18]!
0008d6  985c              LDR      r0,[sp,#0x170]
0008d8  6068              STR      r0,[r5,#4]
0008da  985d              LDR      r0,[sp,#0x174]
0008dc  60a8              STR      r0,[r5,#8]
0008de  985e              LDR      r0,[sp,#0x178]
0008e0  60e8              STR      r0,[r5,#0xc]
0008e2  985f              LDR      r0,[sp,#0x17c]
0008e4  6128              STR      r0,[r5,#0x10]
0008e6  9860              LDR      r0,[sp,#0x180]
0008e8  f8c8002c          STR      r0,[r8,#0x2c]
0008ec  9861              LDR      r0,[sp,#0x184]
0008ee  f8c80030          STR      r0,[r8,#0x30]
0008f2  f8d430c0          LDR      r3,[r4,#0xc0]
0008f6  f8d410d0          LDR      r1,[r4,#0xd0]
0008fa  f10400b4          ADD      r0,r4,#0xb4
0008fe  428b              CMP      r3,r1
000900  f30082e0          BGT.W    |L13.3780|
000904  6a82              LDR      r2,[r0,#0x28]
000906  b12a              CBZ      r2,|L13.2324|
000908  6980              LDR      r0,[r0,#0x18]
00090a  2800              CMP      r0,#0
00090c  bfa4              ITT      GE
00090e  2900              CMPGE    r1,#0
000910  2001              MOVGE    r0,#1
000912  da00              BGE      |L13.2326|
                  |L13.2324|
000914  2000              MOVS     r0,#0
                  |L13.2326|
000916  2800              CMP      r0,#0
000918  f00082d4          BEQ.W    |L13.3780|
00091c  f8d42190          LDR      r2,[r4,#0x190]
000920  f8d411a0          LDR      r1,[r4,#0x1a0]
000924  f50470c2          ADD      r0,r4,#0x184
000928  428a              CMP      r2,r1
00092a  f30082db          BGT.W    |L13.3812|
00092e  6a82              LDR      r2,[r0,#0x28]
000930  b12a              CBZ      r2,|L13.2366|
000932  6980              LDR      r0,[r0,#0x18]
000934  2800              CMP      r0,#0
000936  bfa4              ITT      GE
000938  2900              CMPGE    r1,#0
00093a  2001              MOVGE    r0,#1
00093c  da00              BGE      |L13.2368|
                  |L13.2366|
00093e  2000              MOVS     r0,#0
                  |L13.2368|
000940  2800              CMP      r0,#0
000942  f00082cf          BEQ.W    |L13.3812|
000946  f8d420f4          LDR      r2,[r4,#0xf4]
00094a  f8d41104          LDR      r1,[r4,#0x104]
00094e  f10400e8          ADD      r0,r4,#0xe8
000952  428a              CMP      r2,r1
000954  f30082d4          BGT.W    |L13.3840|
000958  6a82              LDR      r2,[r0,#0x28]
00095a  b12a              CBZ      r2,|L13.2408|
00095c  6980              LDR      r0,[r0,#0x18]
00095e  2800              CMP      r0,#0
000960  bfa4              ITT      GE
000962  2900              CMPGE    r1,#0
000964  2001              MOVGE    r0,#1
000966  da00              BGE      |L13.2410|
                  |L13.2408|
000968  2000              MOVS     r0,#0
                  |L13.2410|
00096a  2800              CMP      r0,#0
00096c  f00082c8          BEQ.W    |L13.3840|
000970  f10400b4          ADD      r0,r4,#0xb4
000974  f8dd1620          LDR      r1,[sp,#0x620]
000978  e014              B        |L13.2468|
00097a  0000              DCW      0x0000
                  |L13.2428|
00097c  4c756361          DCB      "LucasKanadeTracker_SampledPlanar6dof",0
000980  734b616e
000984  61646554
000988  7261636b
00098c  65725f53
000990  616d706c
000994  6564506c
000998  616e6172
00099c  36646f66
0009a0  00      
0009a1  00                DCB      0
0009a2  00                DCB      0
0009a3  00                DCB      0
                  |L13.2468|
0009a4  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS1_INS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::set_size(int)
0009a8  f10400e8          ADD      r0,r4,#0xe8
0009ac  f8dd1620          LDR      r1,[sp,#0x620]
0009b0  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Array<float>>::set_size(int)
0009b4  f8dd0620          LDR      r0,[sp,#0x620]
0009b8  2700              MOVS     r7,#0
0009ba  2800              CMP      r0,#0
0009bc  f3428149          BLE.W    |L13.11346|
0009c0  eeb00a69          VMOV.F32 s0,s19
0009c4  eef00a00          VMOV.F32 s1,#2.00000000
0009c8  ee2cfa80          VMUL.F32 s30,s25,s0
0009cc  eeb70a00          VMOV.F32 s0,#1.00000000
0009d0  a876              ADD      r0,sp,#0x1d8
0009d2  ee0c0a60          VMLS.F32 s0,s24,s1
0009d6  eef60a00          VMOV.F32 s1,#0.50000000
0009da  90cd              STR      r0,[sp,#0x334]
0009dc  ee200a0b          VMUL.F32 s0,s0,s22
0009e0  ee20da20          VMUL.F32 s26,s0,s1
0009e4  eeb00a69          VMOV.F32 s0,s19
0009e8  eef18a40          VNEG.F32 s17,s0
0009ec  eeb19a4d          VNEG.F32 s18,s26
0009f0  eeb10a68          VNEG.F32 s0,s17
0009f4  ed8d0a6f          VSTR     s0,[sp,#0x1bc]
0009f8  eef1fa49          VNEG.F32 s31,s18
                  |L13.2556|
0009fc  2001              MOVS     r0,#1
0009fe  40b8              LSLS     r0,r0,r7
000a00  ee000a10          VMOV     s0,r0
000a04  f8d40118          LDR      r0,[r4,#0x118]
000a08  eb070687          ADD      r6,r7,r7,LSL #2
000a0c  eb000586          ADD      r5,r0,r6,LSL #2
000a10  2300              MOVS     r3,#0
000a12  eeb88ac0          VCVT.F32.S32 s16,s0
000a16  461a              MOV      r2,r3
000a18  2101              MOVS     r1,#1
000a1a  f20d509c          ADD      r0,sp,#0x59c
000a1e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000a22  6800              LDR      r0,[r0,#0]
000a24  9000              STR      r0,[sp,#0]
000a26  2206              MOVS     r2,#6
000a28  4611              MOV      r1,r2
000a2a  f50d60ae          ADD      r0,sp,#0x570
000a2e  f8dd365c          LDR      r3,[sp,#0x65c]
000a32  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000a36  6801              LDR      r1,[r0,#0]
000a38  6029              STR      r1,[r5,#0]
000a3a  6841              LDR      r1,[r0,#4]
000a3c  6069              STR      r1,[r5,#4]
000a3e  6881              LDR      r1,[r0,#8]
000a40  60a9              STR      r1,[r5,#8]
000a42  68c1              LDR      r1,[r0,#0xc]
000a44  60e9              STR      r1,[r5,#0xc]
000a46  6900              LDR      r0,[r0,#0x10]
000a48  6128              STR      r0,[r5,#0x10]
000a4a  f8d40118          LDR      r0,[r4,#0x118]
000a4e  eb000586          ADD      r5,r0,r6,LSL #2
000a52  6928              LDR      r0,[r5,#0x10]
000a54  2800              CMP      r0,#0
000a56  f0008261          BEQ.W    |L13.3868|
000a5a  6828              LDR      r0,[r5,#0]
000a5c  2800              CMP      r0,#0
000a5e  bfa4              ITT      GE
000a60  6868              LDRGE    r0,[r5,#4]
000a62  2800              CMPGE    r0,#0
000a64  f2c0825a          BLT.W    |L13.3868|
000a68  4628              MOV      r0,r5
000a6a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000a6e  2800              CMP      r0,#0
000a70  f00082d2          BEQ.W    |L13.4120|
000a74  2100              MOVS     r1,#0
000a76  4628              MOV      r0,r5
000a78  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000a7c  4601              MOV      r1,r0
000a7e  68a8              LDR      r0,[r5,#8]
000a80  f8d5c010          LDR      r12,[r5,#0x10]
000a84  4341              MULS     r1,r0,r1
000a86  2200              MOVS     r2,#0
000a88  fb02c000          MLA      r0,r2,r0,r12
000a8c  f7fffffe          BL       __aeabi_memclr4
                  |L13.2704|
000a90  f8dd064c          LDR      r0,[sp,#0x64c]
000a94  eef40a00          VMOV.F32 s1,#0.12500000
000a98  4138              ASRS     r0,r0,r7
000a9a  ee000a10          VMOV     s0,r0
000a9e  9006              STR      r0,[sp,#0x18]
000aa0  eeb80ac0          VCVT.F32.S32 s0,s0
000aa4  ee200a20          VMUL.F32 s0,s0,s1
000aa8  f7fffffe          BL       __hardfp_ceilf
000aac  eebd0ac0          VCVT.S32.F32 s0,s0
000ab0  eeb71a00          VMOV.F32 s2,#1.00000000
000ab4  999a              LDR      r1,[sp,#0x268]
000ab6  ee106a10          VMOV     r6,s0
000aba  2200              MOVS     r2,#0
000abc  eeb0aa69          VMOV.F32 s20,s19
000ac0  00f0              LSLS     r0,r6,#3
000ac2  f8cd0550          STR      r0,[sp,#0x550]
000ac6  ed940a1b          VLDR     s0,[r4,#0x6c]
000aca  9898              LDR      r0,[sp,#0x260]
000acc  eec10a00          VDIV.F32 s1,s2,s0
000ad0  fb021200          MLA      r2,r2,r0,r1
000ad4  ed921a00          VLDR     s2,[r2,#0]
000ad8  ed8d1a32          VSTR     s2,[sp,#0xc8]
000adc  ed921a01          VLDR     s2,[r2,#4]
000ae0  ed8d1a33          VSTR     s2,[sp,#0xcc]
000ae4  ed921a02          VLDR     s2,[r2,#8]
000ae8  2201              MOVS     r2,#1
000aea  fb021200          MLA      r2,r2,r0,r1
000aee  ee211a20          VMUL.F32 s2,s2,s1
000af2  ed8d1a34          VSTR     s2,[sp,#0xd0]
000af6  ed921a00          VLDR     s2,[r2,#0]
000afa  ed8d1a35          VSTR     s2,[sp,#0xd4]
000afe  ed921a01          VLDR     s2,[r2,#4]
000b02  ed8d1a36          VSTR     s2,[sp,#0xd8]
000b06  ed921a02          VLDR     s2,[r2,#8]
000b0a  2202              MOVS     r2,#2
000b0c  fb021000          MLA      r0,r2,r0,r1
000b10  ee610a20          VMUL.F32 s1,s2,s1
000b14  edcd0a37          VSTR     s1,[sp,#0xdc]
000b18  edd00a00          VLDR     s1,[r0,#0]
000b1c  ee600a80          VMUL.F32 s1,s1,s0
000b20  edcd0a38          VSTR     s1,[sp,#0xe0]
000b24  edd00a01          VLDR     s1,[r0,#4]
000b28  ee200a80          VMUL.F32 s0,s1,s0
000b2c  ed8d0a39          VSTR     s0,[sp,#0xe4]
000b30  ed900a02          VLDR     s0,[r0,#8]
000b34  ed8d0a3a          VSTR     s0,[sp,#0xe8]
000b38  edd40a05          VLDR     s1,[r4,#0x14]
000b3c  ee800a88          VDIV.F32 s0,s1,s16
000b40  eddfaaf9          VLDR     s21,|L13.3880|
000b44  ee300a2a          VADD.F32 s0,s0,s21
000b48  f7fffffe          BL       __hardfp_floorf
000b4c  eebd0ac0          VCVT.S32.F32 s0,s0
000b50  eef00a4f          VMOV.F32 s1,s30
000b54  4668              MOV      r0,sp
000b56  ee101a10          VMOV     r1,s0
000b5a  ee2c0aca          VNMUL.F32 s0,s25,s20
000b5e  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
000b62  e9dd8900          LDRD     r8,r9,[sp,#0]
000b66  edd40a04          VLDR     s1,[r4,#0x10]
000b6a  f8dda008          LDR      r10,[sp,#8]
000b6e  ee800a88          VDIV.F32 s0,s1,s16
000b72  ee300a2a          VADD.F32 s0,s0,s21
000b76  f7fffffe          BL       __hardfp_floorf
000b7a  eebd0ac0          VCVT.S32.F32 s0,s0
000b7e  eef00a4f          VMOV.F32 s1,s30
000b82  a803              ADD      r0,sp,#0xc
000b84  ee101a10          VMOV     r1,s0
000b88  ee2c0aca          VNMUL.F32 s0,s25,s20
000b8c  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
000b90  e9dd0103          LDRD     r0,r1,[sp,#0xc]
000b94  9a05              LDR      r2,[sp,#0x14]
000b96  f8cda340          STR      r10,[sp,#0x340]
000b9a  92d3              STR      r2,[sp,#0x34c]
000b9c  e9cd01d1          STRD     r0,r1,[sp,#0x344]
000ba0  e9cd89ce          STRD     r8,r9,[sp,#0x338]
000ba4  99d1              LDR      r1,[sp,#0x344]
000ba6  f8dd0650          LDR      r0,[sp,#0x650]
000baa  fb08f101          MUL      r1,r8,r1
000bae  4138              ASRS     r0,r0,r7
000bb0  91c0              STR      r1,[sp,#0x300]
000bb2  4288              CMP      r0,r1
000bb4  bfc8              IT       GT
000bb6  4608              MOVGT    r0,r1
000bb8  90c2              STR      r0,[sp,#0x308]
000bba  eb070087          ADD      r0,r7,r7,LSL #2
000bbe  eb0000c7          ADD      r0,r0,r7,LSL #3
000bc2  f8d410e4          LDR      r1,[r4,#0xe4]
000bc6  f8cd0548          STR      r0,[sp,#0x548]
000bca  eb010080          ADD      r0,r1,r0,LSL #2
000bce  9003              STR      r0,[sp,#0xc]
000bd0  a862              ADD      r0,sp,#0x188
000bd2  9002              STR      r0,[sp,#8]
000bd4  f8dd1550          LDR      r1,[sp,#0x550]
000bd8  98c2              LDR      r0,[sp,#0x308]
000bda  2300              MOVS     r3,#0
000bdc  4408              ADD      r0,r0,r1
000bde  9001              STR      r0,[sp,#4]
000be0  461a              MOV      r2,r3
000be2  2101              MOVS     r1,#1
000be4  f50d60b3          ADD      r0,sp,#0x598
000be8  f8dd865c          LDR      r8,[sp,#0x65c]
000bec  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000bf0  6800              LDR      r0,[r0,#0]
000bf2  9004              STR      r0,[sp,#0x10]
000bf4  9000              STR      r0,[sp,#0]
000bf6  4643              MOV      r3,r8
000bf8  2101              MOVS     r1,#1
000bfa  a870              ADD      r0,sp,#0x1c0
000bfc  9a01              LDR      r2,[sp,#4]
000bfe  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000c02  e9d0a102          LDRD     r10,r1,[r0,#8]
000c06  e9d08900          LDRD     r8,r9,[r0,#0]
000c0a  f8d0b010          LDR      r11,[r0,#0x10]
000c0e  2200              MOVS     r2,#0
000c10  9100              STR      r1,[sp,#0]
000c12  4611              MOV      r1,r2
000c14  a807              ADD      r0,sp,#0x1c
000c16  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000c1a  2200              MOVS     r2,#0
000c1c  9005              STR      r0,[sp,#0x14]
000c1e  4611              MOV      r1,r2
000c20  a875              ADD      r0,sp,#0x1d4
000c22  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000c26  4601              MOV      r1,r0
000c28  9805              LDR      r0,[sp,#0x14]
000c2a  f1b80f00          CMP      r8,#0
000c2e  e9d03c00          LDRD     r3,r12,[r0,#0]
000c32  6880              LDR      r0,[r0,#8]
000c34  9362              STR      r3,[sp,#0x188]
000c36  e9cdc063          STRD     r12,r0,[sp,#0x18c]
000c3a  e9d10300          LDRD     r0,r3,[r1,#0]
000c3e  6889              LDR      r1,[r1,#8]
000c40  9167              STR      r1,[sp,#0x19c]
000c42  e9cd0365          STRD     r0,r3,[sp,#0x194]
000c46  9900              LDR      r1,[sp,#0]
000c48  f8cdb1b0          STR      r11,[sp,#0x1b0]
000c4c  e9cda16a          STRD     r10,r1,[sp,#0x1a8]
000c50  e9cd8968          STRD     r8,r9,[sp,#0x1a0]
000c54  bfc8              IT       GT
000c56  f1b90f00          CMPGT    r9,#0
000c5a  f34081e9          BLE.W    |L13.4144|
000c5e  fb08f009          MUL      r0,r8,r9
000c62  2800              CMP      r0,#0
000c64  bf1c              ITT      NE
000c66  2000              MOVNE    r0,#0
000c68  fb00b00a          MLANE    r0,r0,r10,r11
000c6c  f00081e0          BEQ.W    |L13.4144|
                  |L13.3184|
000c70  906d              STR      r0,[sp,#0x1b4]
000c72  f1b80f00          CMP      r8,#0
000c76  bfc8              IT       GT
000c78  f1b90f00          CMPGT    r9,#0
000c7c  f34081da          BLE.W    |L13.4148|
000c80  fb08f009          MUL      r0,r8,r9
000c84  2800              CMP      r0,#0
000c86  bf1c              ITT      NE
000c88  2000              MOVNE    r0,#0
000c8a  fb00b00a          MLANE    r0,r0,r10,r11
000c8e  f00081d1          BEQ.W    |L13.4148|
                  |L13.3218|
000c92  906e              STR      r0,[sp,#0x1b8]
000c94  f1b80f00          CMP      r8,#0
000c98  bfc8              IT       GT
000c9a  f1b90f00          CMPGT    r9,#0
000c9e  f34081cb          BLE.W    |L13.4152|
000ca2  fb08f009          MUL      r0,r8,r9
000ca6  2800              CMP      r0,#0
000ca8  bf1c              ITT      NE
000caa  2000              MOVNE    r0,#0
000cac  fb00b00a          MLANE    r0,r0,r10,r11
000cb0  f00081c2          BEQ.W    |L13.4152|
                  |L13.3252|
000cb4  906e              STR      r0,[sp,#0x1b8]
000cb6  a804              ADD      r0,sp,#0x10
000cb8  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
000cbc  2800              CMP      r0,#0
000cbe  bf12              ITEE     NE
000cc0  e9dd1001          LDRDNE   r1,r0,[sp,#4]
000cc4  2100              MOVEQ    r1,#0
000cc6  9802              LDREQ    r0,[sp,#8]
000cc8  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>::set_size(int)
000ccc  e9dd0262          LDRD     r0,r2,[sp,#0x188]
000cd0  9903              LDR      r1,[sp,#0xc]
000cd2  9b64              LDR      r3,[sp,#0x190]
000cd4  608b              STR      r3,[r1,#8]
000cd6  e9c10200          STRD     r0,r2,[r1,#0]
000cda  e9dd0265          LDRD     r0,r2,[sp,#0x194]
000cde  9b67              LDR      r3,[sp,#0x19c]
000ce0  614b              STR      r3,[r1,#0x14]
000ce2  e9c10203          STRD     r0,r2,[r1,#0xc]
000ce6  9b68              LDR      r3,[sp,#0x1a0]
000ce8  618b              STR      r3,[r1,#0x18]
000cea  9b69              LDR      r3,[sp,#0x1a4]
000cec  61cb              STR      r3,[r1,#0x1c]
000cee  9b6a              LDR      r3,[sp,#0x1a8]
000cf0  620b              STR      r3,[r1,#0x20]
000cf2  9a6b              LDR      r2,[sp,#0x1ac]
000cf4  624a              STR      r2,[r1,#0x24]
000cf6  9b6c              LDR      r3,[sp,#0x1b0]
000cf8  628b              STR      r3,[r1,#0x28]
000cfa  986d              LDR      r0,[sp,#0x1b4]
000cfc  62c8              STR      r0,[r1,#0x2c]
000cfe  986e              LDR      r0,[sp,#0x1b8]
000d00  6308              STR      r0,[r1,#0x30]
000d02  f8d410e4          LDR      r1,[r4,#0xe4]
000d06  f8dd0548          LDR      r0,[sp,#0x548]
000d0a  eb010080          ADD      r0,r1,r0,LSL #2
000d0e  68c2              LDR      r2,[r0,#0xc]
000d10  69c1              LDR      r1,[r0,#0x1c]
000d12  428a              CMP      r2,r1
000d14  f3008192          BGT.W    |L13.4156|
000d18  6a82              LDR      r2,[r0,#0x28]
000d1a  b12a              CBZ      r2,|L13.3368|
000d1c  6980              LDR      r0,[r0,#0x18]
000d1e  2800              CMP      r0,#0
000d20  bfa4              ITT      GE
000d22  2900              CMPGE    r1,#0
000d24  2001              MOVGE    r0,#1
000d26  da00              BGE      |L13.3370|
                  |L13.3368|
000d28  2000              MOVS     r0,#0
                  |L13.3370|
000d2a  2800              CMP      r0,#0
000d2c  f0008186          BEQ.W    |L13.4156|
000d30  98ce              LDR      r0,[sp,#0x338]
000d32  99d1              LDR      r1,[sp,#0x344]
000d34  90ad              STR      r0,[sp,#0x2b4]
000d36  911d              STR      r1,[sp,#0x74]
000d38  f20d405c          ADD      r0,sp,#0x45c
000d3c  f8dd1660          LDR      r1,[sp,#0x660]
000d40  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000d44  f20d415c          ADD      r1,sp,#0x45c
000d48  a87d              ADD      r0,sp,#0x1f4
000d4a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000d4e  f50d608f          ADD      r0,sp,#0x478
000d52  f8dd165c          LDR      r1,[sp,#0x65c]
000d56  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000d5a  f50d618f          ADD      r1,sp,#0x478
000d5e  f20d5054          ADD      r0,sp,#0x554
000d62  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000d66  2300              MOVS     r3,#0
000d68  461a              MOV      r2,r3
000d6a  2101              MOVS     r1,#1
000d6c  f50d60b3          ADD      r0,sp,#0x598
000d70  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000d74  6800              LDR      r0,[r0,#0]
000d76  9000              STR      r0,[sp,#0]
000d78  991d              LDR      r1,[sp,#0x74]
000d7a  98ad              LDR      r0,[sp,#0x2b4]
000d7c  ab7d              ADD      r3,sp,#0x1f4
000d7e  fb00f201          MUL      r2,r0,r1
000d82  4690              MOV      r8,r2
000d84  2101              MOVS     r1,#1
000d86  f50d6084          ADD      r0,sp,#0x420
000d8a  92c1              STR      r2,[sp,#0x304]
000d8c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000d90  2300              MOVS     r3,#0
000d92  461a              MOV      r2,r3
000d94  2101              MOVS     r1,#1
000d96  f50d60b4          ADD      r0,sp,#0x5a0
000d9a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000d9e  6800              LDR      r0,[r0,#0]
000da0  9000              STR      r0,[sp,#0]
000da2  4642              MOV      r2,r8
000da4  ab7d              ADD      r3,sp,#0x1f4
000da6  2101              MOVS     r1,#1
000da8  f20d4034          ADD      r0,sp,#0x434
000dac  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000db0  2300              MOVS     r3,#0
000db2  461a              MOV      r2,r3
000db4  2101              MOVS     r1,#1
000db6  f20d50a4          ADD      r0,sp,#0x5a4
000dba  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000dbe  6800              LDR      r0,[r0,#0]
000dc0  9000              STR      r0,[sp,#0]
000dc2  4642              MOV      r2,r8
000dc4  ab7d              ADD      r3,sp,#0x1f4
000dc6  2101              MOVS     r1,#1
000dc8  f50d6089          ADD      r0,sp,#0x448
000dcc  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000dd0  2300              MOVS     r3,#0
000dd2  461a              MOV      r2,r3
000dd4  2101              MOVS     r1,#1
000dd6  f50d60b5          ADD      r0,sp,#0x5a8
000dda  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000dde  6800              LDR      r0,[r0,#0]
000de0  9000              STR      r0,[sp,#0]
000de2  991d              LDR      r1,[sp,#0x74]
000de4  98ad              LDR      r0,[sp,#0x2b4]
000de6  ab7d              ADD      r3,sp,#0x1f4
000de8  fb01f200          MUL      r2,r1,r0
000dec  2101              MOVS     r1,#1
000dee  a8e2              ADD      r0,sp,#0x388
000df0  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000df4  f04f0800          MOV      r8,#0
000df8  a97d              ADD      r1,sp,#0x1f4
000dfa  f20d4094          ADD      r0,sp,#0x494
000dfe  f8cd8544          STR      r8,[sp,#0x544]
000e02  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000e06  f20d4194          ADD      r1,sp,#0x494
000e0a  a8d4              ADD      r0,sp,#0x350
000e0c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000e10  2300              MOVS     r3,#0
000e12  461a              MOV      r2,r3
000e14  2101              MOVS     r1,#1
000e16  f20d5084          ADD      r0,sp,#0x584
000e1a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000e1e  6800              LDR      r0,[r0,#0]
000e20  9000              STR      r0,[sp,#0]
000e22  abd4              ADD      r3,sp,#0x350
000e24  a89b              ADD      r0,sp,#0x26c
000e26  9aad              LDR      r2,[sp,#0x2b4]
000e28  991d              LDR      r1,[sp,#0x74]
000e2a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000e2e  989f              LDR      r0,[sp,#0x27c]
000e30  2800              CMP      r0,#0
000e32  f0008112          BEQ.W    |L13.4186|
000e36  989b              LDR      r0,[sp,#0x26c]
000e38  2800              CMP      r0,#0
000e3a  bfa4              ITT      GE
000e3c  989c              LDRGE    r0,[sp,#0x270]
000e3e  2800              CMPGE    r0,#0
000e40  f2c0810b          BLT.W    |L13.4186|
000e44  ed940a1b          VLDR     s0,[r4,#0x6c]
000e48  f1040118          ADD      r1,r4,#0x18
000e4c  f50d60b1          ADD      r0,sp,#0x588
000e50  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
000e54  f1040018          ADD      r0,r4,#0x18
000e58  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
000e5c  2100              MOVS     r1,#0
000e5e  ab9b              ADD      r3,sp,#0x26c
000e60  e9cd3100          STRD     r3,r1,[sp,#0]
000e64  4602              MOV      r2,r0
000e66  9102              STR      r1,[sp,#8]
000e68  f50d63b1          ADD      r3,sp,#0x588
000e6c  a9ce              ADD      r1,sp,#0x338
000e6e  f8dd0618          LDR      r0,[sp,#0x618]
000e72  f7fffffe          BL       _ZN4Anki8Embedded18Interp2_ProjectiveIhhEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_ ; Anki::Embedded::Interp2_Projective<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Meshgrid<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::Array<T2>&, Anki::Embedded::InterpolationType, T2)
000e76  2800              CMP      r0,#0
000e78  f00080fd          BEQ.W    |L13.4214|
000e7c  492b              LDR      r1,|L13.3884|
000e7e  f24012d3          MOV      r2,#0x1d3
000e82  f6af232c          ADR      r3,|L13.1112|
000e86  9100              STR      r1,[sp,#0]
000e88  e9cd2001          STRD     r2,r0,[sp,#4]
000e8c  a228              ADR      r2,|L13.3888|
000e8e  f20171f4          ADD      r1,r1,#0x7f4
000e92  2005              MOVS     r0,#5
000e94  f7fffffe          BL       _Anki_Log
000e98  e0bb              B        |L13.4114|
                  |L13.3738|
000e9a  2000              MOVS     r0,#0
000e9c  f7ffbbbd          B        |L13.1562|
                  |L13.3744|
000ea0  2000              MOVS     r0,#0
000ea2  f7ffbbc9          B        |L13.1592|
                  |L13.3750|
000ea6  2000              MOVS     r0,#0
000ea8  f7ffbbd5          B        |L13.1622|
                  |L13.3756|
000eac  2000              MOVS     r0,#0
000eae  e446              B        |L13.1854|
                  |L13.3760|
000eb0  2000              MOVS     r0,#0
000eb2  e453              B        |L13.1884|
                  |L13.3764|
000eb4  2000              MOVS     r0,#0
000eb6  e460              B        |L13.1914|
                  |L13.3768|
000eb8  2000              MOVS     r0,#0
000eba  e4d2              B        |L13.2146|
                  |L13.3772|
000ebc  2000              MOVS     r0,#0
000ebe  e4df              B        |L13.2176|
                  |L13.3776|
000ec0  2000              MOVS     r0,#0
000ec2  e4ec              B        |L13.2206|
                  |L13.3780|
000ec4  4819              LDR      r0,|L13.3884|
000ec6  f44f71bf          MOV      r1,#0x17e
000eca  f6af2374          ADR      r3,|L13.1112|
000ece  e9cd0100          STRD     r0,r1,[sp,#0]
000ed2  f20071f4          ADD      r1,r0,#0x7f4
000ed6  a221              ADR      r2,|L13.3932|
000ed8  2005              MOVS     r0,#5
000eda  f7fffffe          BL       _Anki_Log
000ede  4620              MOV      r0,r4
000ee0  f7ffb999          B        |L13.534|
                  |L13.3812|
000ee4  4811              LDR      r0,|L13.3884|
000ee6  f44f71c1          MOV      r1,#0x182
000eea  f6af2394          ADR      r3,|L13.1112|
000eee  e9cd0100          STRD     r0,r1,[sp,#0]
000ef2  f20071f4          ADD      r1,r0,#0x7f4
000ef6  a228              ADR      r2,|L13.3992|
000ef8  2005              MOVS     r0,#5
000efa  f7fffffe          BL       _Anki_Log
000efe  e088              B        |L13.4114|
                  |L13.3840|
000f00  480a              LDR      r0,|L13.3884|
000f02  f44f71c3          MOV      r1,#0x186
000f06  f6af23b0          ADR      r3,|L13.1112|
000f0a  e9cd0100          STRD     r0,r1,[sp,#0]
000f0e  f20071f4          ADD      r1,r0,#0x7f4
000f12  a22f              ADR      r2,|L13.4048|
000f14  2005              MOVS     r0,#5
000f16  f7fffffe          BL       _Anki_Log
000f1a  e07a              B        |L13.4114|
                  |L13.3868|
000f1c  4803              LDR      r0,|L13.3884|
000f1e  f240119d          MOV      r1,#0x19d
000f22  f6af23cc          ADR      r3,|L13.1112|
000f26  e06b              B        |L13.4096|
                  |L13.3880|
000f28  3727c5ac          DCFS     0x3727c5ac ; 9.9999997473787516e-06
                  |L13.3884|
                          DCD      ||.constdata||
                  |L13.3888|
000f30  496e7465          DCB      "Interp2_Projective failed with code 0x%x",0
000f34  7270325f
000f38  50726f6a
000f3c  65637469
000f40  76652066
000f44  61696c65
000f48  64207769
000f4c  74682063
000f50  6f646520
000f54  30782578
000f58  00      
000f59  00                DCB      0
000f5a  00                DCB      0
000f5b  00                DCB      0
                  |L13.3932|
000f5c  556e6162          DCB      "Unable to allocate templateSamplePyramid FixedLengthLis"
000f60  6c652074
000f64  6f20616c
000f68  6c6f6361
000f6c  74652074
000f70  656d706c
000f74  61746553
000f78  616d706c
000f7c  65507972
000f80  616d6964
000f84  20466978
000f88  65644c65
000f8c  6e677468
000f90  4c6973  
000f93  742e00            DCB      "t.",0
000f96  00                DCB      0
000f97  00                DCB      0
                  |L13.3992|
000f98  556e6162          DCB      "Unable to allocate verificationSamples FixedLengthList."
000f9c  6c652074
000fa0  6f20616c
000fa4  6c6f6361
000fa8  74652076
000fac  65726966
000fb0  69636174
000fb4  696f6e53
000fb8  616d706c
000fbc  65732046
000fc0  69786564
000fc4  4c656e67
000fc8  74684c69
000fcc  73742e  
000fcf  00                DCB      0
                  |L13.4048|
000fd0  556e6162          DCB      "Unable to allocate AtAPyramid FixedLengthList.",0
000fd4  6c652074
000fd8  6f20616c
000fdc  6c6f6361
000fe0  74652041
000fe4  74415079
000fe8  72616d69
000fec  64204669
000ff0  7865644c
000ff4  656e6774
000ff8  684c6973
000ffc  742e00  
000fff  00                DCB      0
                  |L13.4096|
001000  e9cd0100          STRD     r0,r1,[sp,#0]
001004  f20071f4          ADD      r1,r0,#0x7f4
001008  a2df              ADR      r2,|L13.5000|
00100a  9702              STR      r7,[sp,#8]
00100c  2005              MOVS     r0,#5
00100e  f7fffffe          BL       _Anki_Log
                  |L13.4114|
001012  4620              MOV      r0,r4
001014  f7ffb8ff          B        |L13.534|
                  |L13.4120|
001018  f2402176          MOV      r1,#0x276
00101c  48e3              LDR      r0,|L13.5036|
00101e  e9cd0100          STRD     r0,r1,[sp,#0]
001022  a3e3              ADR      r3,|L13.5040|
001024  a2f0              ADR      r2,|L13.5096|
001026  a1f7              ADR      r1,|L13.5124|
001028  2005              MOVS     r0,#5
00102a  f7fffffe          BL       _Anki_Log
00102e  e52f              B        |L13.2704|
                  |L13.4144|
001030  2000              MOVS     r0,#0
001032  e61d              B        |L13.3184|
                  |L13.4148|
001034  2000              MOVS     r0,#0
001036  e62c              B        |L13.3218|
                  |L13.4152|
001038  2000              MOVS     r0,#0
00103a  e63b              B        |L13.3252|
                  |L13.4156|
00103c  48f7              LDR      r0,|L13.5148|
00103e  f24011bb          MOV      r1,#0x1bb
001042  f6af33ec          ADR      r3,|L13.1112|
001046  e9cd0100          STRD     r0,r1,[sp,#0]
00104a  f20071f4          ADD      r1,r0,#0x7f4
00104e  a2f4              ADR      r2,|L13.5152|
001050  9702              STR      r7,[sp,#8]
001052  2005              MOVS     r0,#5
001054  f7fffffe          BL       _Anki_Log
001058  e7db              B        |L13.4114|
                  |L13.4186|
00105a  48f0              LDR      r0,|L13.5148|
00105c  f44f71e7          MOV      r1,#0x1ce
001060  f6af430c          ADR      r3,|L13.1112|
001064  e9cd0100          STRD     r0,r1,[sp,#0]
001068  f20071f4          ADD      r1,r0,#0x7f4
00106c  a2fc              ADR      r2,|L13.5216|
00106e  2005              MOVS     r0,#5
001070  f7fffffe          BL       _Anki_Log
001074  e7cd              B        |L13.4114|
                  |L13.4214|
001076  9806              LDR      r0,[sp,#0x18]
001078  2800              CMP      r0,#0
00107a  f3408152          BLE.W    |L13.4898|
00107e  2100              MOVS     r1,#0
001080  989b              LDR      r0,[sp,#0x26c]
001082  1e4b              SUBS     r3,r1,#1
001084  9000              STR      r0,[sp,#0]
001086  4689              MOV      r9,r1
001088  4698              MOV      r8,r3
00108a  2201              MOVS     r2,#1
00108c  a804              ADD      r0,sp,#0x10
00108e  f7fffffe          BL       _ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i ; Anki::Embedded::IndexSequence<int>(T1, T1, T1, int)
001092  989c              LDR      r0,[sp,#0x270]
001094  9000              STR      r0,[sp,#0]
001096  4643              MOV      r3,r8
001098  2201              MOVS     r2,#1
00109a  4649              MOV      r1,r9
00109c  a801              ADD      r0,sp,#4
00109e  f7fffffe          BL       _ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i ; Anki::Embedded::IndexSequence<int>(T1, T1, T1, int)
0010a2  f50d781b          ADD      r8,sp,#0x26c
0010a6  e9dd9a04          LDRD     r9,r10,[sp,#0x10]
0010aa  e8b81007          LDM      r8!,{r0-r2,r12}
0010ae  e9cd9a84          STRD     r9,r10,[sp,#0x210]
0010b2  f8ddb018          LDR      r11,[sp,#0x18]
0010b6  9b9f              LDR      r3,[sp,#0x27c]
0010b8  f8cdb218          STR      r11,[sp,#0x218]
0010bc  e9dd9a01          LDRD     r9,r10,[sp,#4]
0010c0  f8ddb00c          LDR      r11,[sp,#0xc]
0010c4  f8cdb224          STR      r11,[sp,#0x224]
0010c8  f50d780a          ADD      r8,sp,#0x228
0010cc  938e              STR      r3,[sp,#0x238]
0010ce  e8a81007          STM      r8!,{r0-r2,r12}
0010d2  e9cd9a87          STRD     r9,r10,[sp,#0x21c]
0010d6  2800              CMP      r0,#0
0010d8  bfc8              IT       GT
0010da  2900              CMPGT    r1,#0
0010dc  f3408104          BLE.W    |L13.4840|
0010e0  fb00fc01          MUL      r12,r0,r1
0010e4  f1bc0f00          CMP      r12,#0
0010e8  bf1c              ITT      NE
0010ea  f04f0c00          MOVNE    r12,#0
0010ee  fb0c3c02          MLANE    r12,r12,r2,r3
0010f2  f00080f9          BEQ.W    |L13.4840|
                  |L13.4342|
0010f6  f8cdc23c          STR      r12,[sp,#0x23c]
0010fa  2800              CMP      r0,#0
0010fc  bfc8              IT       GT
0010fe  2900              CMPGT    r1,#0
001100  dd7e              BLE      |L13.4608|
001102  4348              MULS     r0,r1,r0
001104  2800              CMP      r0,#0
001106  bf1c              ITT      NE
001108  2000              MOVNE    r0,#0
00110a  fb003002          MLANE    r0,r0,r2,r3
00110e  d077              BEQ      |L13.4608|
                  |L13.4368|
001110  9090              STR      r0,[sp,#0x240]
001112  e9dd0186          LDRD     r0,r1,[sp,#0x218]
001116  e9dd3c8a          LDRD     r3,r12,[sp,#0x228]
00111a  e9dd8984          LDRD     r8,r9,[sp,#0x210]
00111e  aaa2              ADD      r2,sp,#0x288
001120  e8a20c03          STM      r2!,{r0,r1,r10,r11}
001124  e9cd3ca6          STRD     r3,r12,[sp,#0x298]
001128  e9cd89a0          STRD     r8,r9,[sp,#0x280]
00112c  f50d790c          ADD      r9,sp,#0x230
001130  e8b9100f          LDM      r9!,{r0-r3,r12}
001134  46c1              MOV      r9,r8
001136  f50d7828          ADD      r8,sp,#0x2a0
00113a  e8a8100f          STM      r8!,{r0-r3,r12}
00113e  e9dd23a5          LDRD     r2,r3,[sp,#0x294]
001142  e9dd01a2          LDRD     r0,r1,[sp,#0x288]
001146  f8ddb290          LDR      r11,[sp,#0x290]
00114a  f8dda284          LDR      r10,[sp,#0x284]
00114e  f8dd829c          LDR      r8,[sp,#0x29c]
001152  f8cdb014          STR      r11,[sp,#0x14]
001156  e9cd9a03          STRD     r9,r10,[sp,#0xc]
00115a  e9ddabaa          LDRD     r10,r11,[sp,#0x2a8]
00115e  e9dd9ca8          LDRD     r9,r12,[sp,#0x2a0]
001162  e9cd9a00          STRD     r9,r10,[sp,#0]
001166  f8cdb008          STR      r11,[sp,#8]
00116a  f04f0900          MOV      r9,#0
00116e  f8cd9018          STR      r9,[sp,#0x18]
001172  e9dd9a03          LDRD     r9,r10,[sp,#0xc]
001176  f8ddb014          LDR      r11,[sp,#0x14]
00117a  e9cd2375          STRD     r2,r3,[sp,#0x1d4]
00117e  f8cd81dc          STR      r8,[sp,#0x1dc]
001182  e9cd9a70          STRD     r9,r10,[sp,#0x1c0]
001186  f8cdb1d0          STR      r11,[sp,#0x1d0]
00118a  e9cd0172          STRD     r0,r1,[sp,#0x1c8]
00118e  e9dd9a01          LDRD     r9,r10,[sp,#4]
001192  f8ddb000          LDR      r11,[sp,#0]
001196  e9cd9a7a          STRD     r9,r10,[sp,#0x1e8]
00119a  e9cdbc78          STRD     r11,r12,[sp,#0x1e0]
00119e  997a              LDR      r1,[sp,#0x1e8]
0011a0  f8dd9018          LDR      r9,[sp,#0x18]
0011a4  98cd              LDR      r0,[sp,#0x334]
0011a6  f88d91f0          STRB     r9,[sp,#0x1f0]
0011aa  2900              CMP      r1,#0
0011ac  d07c              BEQ      |L13.4776|
0011ae  2b00              CMP      r3,#0
0011b0  bfa8              IT       GE
0011b2  f1b80f00          CMPGE    r8,#0
0011b6  db77              BLT      |L13.4776|
0011b8  2101              MOVS     r1,#1
0011ba  f88d1010          STRB     r1,[sp,#0x10]
0011be  9974              LDR      r1,[sp,#0x1d0]
0011c0  e9cd1205          STRD     r1,r2,[sp,#0x14]
0011c4  9973              LDR      r1,[sp,#0x1cc]
0011c6  9107              STR      r1,[sp,#0x1c]
0011c8  9971              LDR      r1,[sp,#0x1c4]
0011ca  9108              STR      r1,[sp,#0x20]
0011cc  9972              LDR      r1,[sp,#0x1c8]
0011ce  9109              STR      r1,[sp,#0x24]
0011d0  9970              LDR      r1,[sp,#0x1c0]
0011d2  9b7a              LDR      r3,[sp,#0x1e8]
0011d4  9a08              LDR      r2,[sp,#0x20]
0011d6  910a              STR      r1,[sp,#0x28]
0011d8  fb02320b          MLA      r2,r2,r11,r3
0011dc  9905              LDR      r1,[sp,#0x14]
0011de  2300              MOVS     r3,#0
0011e0  5c51              LDRB     r1,[r2,r1]
0011e2  9a0a              LDR      r2,[sp,#0x28]
0011e4  2a00              CMP      r2,#0
0011e6  bfc4              ITT      GT
0011e8  f8d09010          LDRGT    r9,[r0,#0x10]
0011ec  f8d08008          LDRGT    r8,[r0,#8]
0011f0  dd1c              BLE      |L13.4652|
                  |L13.4594|
0011f2  e9dd0208          LDRD     r0,r2,[sp,#0x20]
0011f6  fb030002          MLA      r0,r3,r2,r0
0011fa  fb009c08          MLA      r12,r0,r8,r9
0011fe  e000              B        |L13.4610|
                  |L13.4608|
001200  e075              B        |L13.4846|
                  |L13.4610|
001202  9a07              LDR      r2,[sp,#0x1c]
001204  2000              MOVS     r0,#0
001206  2a00              CMP      r2,#0
001208  dd0c              BLE      |L13.4644|
                  |L13.4618|
00120a  e9dd2a05          LDRD     r2,r10,[sp,#0x14]
00120e  fb00220a          MLA      r2,r0,r10,r2
001212  f81c2002          LDRB     r2,[r12,r2]
001216  428a              CMP      r2,r1
001218  bf98              IT       LS
00121a  4611              MOVLS    r1,r2
00121c  1c40              ADDS     r0,r0,#1
00121e  9a07              LDR      r2,[sp,#0x1c]
001220  4282              CMP      r2,r0
001222  dcf2              BGT      |L13.4618|
                  |L13.4644|
001224  980a              LDR      r0,[sp,#0x28]
001226  1c5b              ADDS     r3,r3,#1
001228  4298              CMP      r0,r3
00122a  dce2              BGT      |L13.4594|
                  |L13.4652|
00122c  f8cd153c          STR      r1,[sp,#0x53c]
001230  997a              LDR      r1,[sp,#0x1e8]
001232  98cd              LDR      r0,[sp,#0x334]
001234  2900              CMP      r1,#0
001236  d068              BEQ      |L13.4874|
001238  9976              LDR      r1,[sp,#0x1d8]
00123a  2900              CMP      r1,#0
00123c  bfa4              ITT      GE
00123e  9977              LDRGE    r1,[sp,#0x1dc]
001240  2900              CMPGE    r1,#0
001242  db62              BLT      |L13.4874|
001244  2101              MOVS     r1,#1
001246  f88d1008          STRB     r1,[sp,#8]
00124a  9974              LDR      r1,[sp,#0x1d0]
00124c  9103              STR      r1,[sp,#0xc]
00124e  9975              LDR      r1,[sp,#0x1d4]
001250  9104              STR      r1,[sp,#0x10]
001252  9973              LDR      r1,[sp,#0x1cc]
001254  9105              STR      r1,[sp,#0x14]
001256  9971              LDR      r1,[sp,#0x1c4]
001258  9106              STR      r1,[sp,#0x18]
00125a  9972              LDR      r1,[sp,#0x1c8]
00125c  9107              STR      r1,[sp,#0x1c]
00125e  9970              LDR      r1,[sp,#0x1c0]
001260  f8ddc1e0          LDR      r12,[sp,#0x1e0]
001264  9b7a              LDR      r3,[sp,#0x1e8]
001266  9a06              LDR      r2,[sp,#0x18]
001268  9108              STR      r1,[sp,#0x20]
00126a  fb02320c          MLA      r2,r2,r12,r3
00126e  9903              LDR      r1,[sp,#0xc]
001270  2300              MOVS     r3,#0
001272  5c51              LDRB     r1,[r2,r1]
001274  9a08              LDR      r2,[sp,#0x20]
001276  2a00              CMP      r2,#0
001278  bfc4              ITT      GT
00127a  f8d09010          LDRGT    r9,[r0,#0x10]
00127e  f8d08008          LDRGT    r8,[r0,#8]
001282  dd1c              BLE      |L13.4798|
                  |L13.4740|
001284  e9dd0206          LDRD     r0,r2,[sp,#0x18]
001288  fb030002          MLA      r0,r3,r2,r0
00128c  fb009c08          MLA      r12,r0,r8,r9
001290  9a05              LDR      r2,[sp,#0x14]
001292  2000              MOVS     r0,#0
001294  2a00              CMP      r2,#0
001296  dd0e              BLE      |L13.4790|
                  |L13.4760|
001298  e9dd2a03          LDRD     r2,r10,[sp,#0xc]
00129c  fb00220a          MLA      r2,r0,r10,r2
0012a0  f81c2002          LDRB     r2,[r12,r2]
0012a4  428a              CMP      r2,r1
0012a6  e000              B        |L13.4778|
                  |L13.4776|
0012a8  e023              B        |L13.4850|
                  |L13.4778|
0012aa  bf28              IT       CS
0012ac  4611              MOVCS    r1,r2
0012ae  1c40              ADDS     r0,r0,#1
0012b0  9a05              LDR      r2,[sp,#0x14]
0012b2  4282              CMP      r2,r0
0012b4  dcf0              BGT      |L13.4760|
                  |L13.4790|
0012b6  9808              LDR      r0,[sp,#0x20]
0012b8  1c5b              ADDS     r3,r3,#1
0012ba  4298              CMP      r0,r3
0012bc  dce2              BGT      |L13.4740|
                  |L13.4798|
0012be  f8dd053c          LDR      r0,[sp,#0x53c]
0012c2  f8cd1540          STR      r1,[sp,#0x540]
0012c6  4281              CMP      r1,r0
0012c8  d82b              BHI      |L13.4898|
0012ca  4a54              LDR      r2,|L13.5148|
0012cc  f24013db          MOV      r3,#0x1db
0012d0  9200              STR      r2,[sp,#0]
0012d2  9003              STR      r0,[sp,#0xc]
0012d4  e9cd3101          STRD     r3,r1,[sp,#4]
0012d8  f6af6384          ADR      r3,|L13.1112|
0012dc  a26c              ADR      r2,|L13.5264|
0012de  497b              LDR      r1,|L13.5324|
0012e0  2005              MOVS     r0,#5
0012e2  f7fffffe          BL       _Anki_Log
0012e6  e694              B        |L13.4114|
                  |L13.4840|
0012e8  f04f0c00          MOV      r12,#0
0012ec  e703              B        |L13.4342|
                  |L13.4846|
0012ee  2000              MOVS     r0,#0
0012f0  e70e              B        |L13.4368|
                  |L13.4850|
0012f2  2134              MOVS     r1,#0x34
0012f4  4876              LDR      r0,|L13.5328|
0012f6  e9cd0100          STRD     r0,r1,[sp,#0]
0012fa  a376              ADR      r3,|L13.5332|
0012fc  a23a              ADR      r2,|L13.5096|
0012fe  a183              ADR      r1,|L13.5388|
001300  2005              MOVS     r0,#5
001302  f7fffffe          BL       _Anki_Log
001306  2100              MOVS     r1,#0
001308  e790              B        |L13.4652|
                  |L13.4874|
00130a  214e              MOVS     r1,#0x4e
00130c  4882              LDR      r0,|L13.5400|
00130e  e9cd0100          STRD     r0,r1,[sp,#0]
001312  a370              ADR      r3,|L13.5332|
001314  a234              ADR      r2,|L13.5096|
001316  a181              ADR      r1,|L13.5404|
001318  2005              MOVS     r0,#5
00131a  f7fffffe          BL       _Anki_Log
00131e  2100              MOVS     r1,#0
001320  e7cd              B        |L13.4798|
                  |L13.4898|
001322  2300              MOVS     r3,#0
001324  461a              MOV      r2,r3
001326  2101              MOVS     r1,#1
001328  f20d5084          ADD      r0,sp,#0x584
00132c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
001330  6800              LDR      r0,[r0,#0]
001332  9000              STR      r0,[sp,#0]
001334  abd4              ADD      r3,sp,#0x350
001336  a8bb              ADD      r0,sp,#0x2ec
001338  9aad              LDR      r2,[sp,#0x2b4]
00133a  991d              LDR      r1,[sp,#0x74]
00133c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
001340  98bf              LDR      r0,[sp,#0x2fc]
001342  2800              CMP      r0,#0
001344  d01e              BEQ      |L13.4996|
001346  98bb              LDR      r0,[sp,#0x2ec]
001348  2800              CMP      r0,#0
00134a  bfa4              ITT      GE
00134c  98bc              LDRGE    r0,[sp,#0x2f0]
00134e  2800              CMPGE    r0,#0
001350  db18              BLT      |L13.4996|
001352  f50d7a1b          ADD      r10,sp,#0x26c
001356  f50d783b          ADD      r8,sp,#0x2ec
00135a  2100              MOVS     r1,#0
00135c  4650              MOV      r0,r10
00135e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
001362  9000              STR      r0,[sp,#0]
001364  2101              MOVS     r1,#1
001366  4650              MOV      r0,r10
001368  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00136c  4681              MOV      r9,r0
00136e  4641              MOV      r1,r8
001370  4650              MOV      r0,r10
001372  f7fffffe          BL       _ZN4Anki8Embedded8AreValidINS0_5ArrayIhEENS2_IfEEEEbRKT_RKT0_ ; Anki::Embedded::AreValid<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<float>>(const T1&, const T2&)
001376  2800              CMP      r0,#0
001378  d005              BEQ      |L13.4998|
00137a  4641              MOV      r1,r8
00137c  4650              MOV      r0,r10
00137e  f7fffffe          BL       _ZN4Anki8Embedded8AreValidINS0_5ArrayIhEENS2_IfEEEEbRKT_RKT0_ ; Anki::Embedded::AreValid<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<float>>(const T1&, const T2&)
001382  e0d1              B        |L13.5416|
                  |L13.4996|
001384  e150              B        |L13.5672|
                  |L13.4998|
001386  e15c              B        |L13.5698|
                  |L13.5000|
001388  496e7661          DCB      "Invalid AtA matrix at scale %d.\n",0
00138c  6c696420
001390  41744120
001394  6d617472
001398  69782061
00139c  74207363
0013a0  616c6520
0013a4  25642e0a
0013a8  00      
0013a9  00                DCB      0
0013aa  00                DCB      0
0013ab  00                DCB      0
                  |L13.5036|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::SetZero()::__PRETTY_FUNCTION__
                  |L13.5040|
0013b0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
0013b4  6f726574
0013b8  6563685c
0013bc  636f6d6d
0013c0  6f6e5c69
0013c4  6e636c75
0013c8  64655c61
0013cc  6e6b692f
0013d0  636f6d6d
0013d4  6f6e2f72
0013d8  6f626f74
0013dc  2f617272
0013e0  617932  
0013e3  642e6800          DCB      "d.h",0
0013e7  00                DCB      0
                  |L13.5096|
0013e8  41727261          DCB      "Array<Type> is not valid",0
0013ec  793c5479
0013f0  70653e20
0013f4  6973206e
0013f8  6f742076
0013fc  616c6964
001400  00      
001401  00                DCB      0
001402  00                DCB      0
001403  00                DCB      0
                  |L13.5124|
001404  41727261          DCB      "Array<Type>::SetZero",0
001408  793c5479
00140c  70653e3a
001410  3a536574
001414  5a65726f
001418  00      
001419  00                DCB      0
00141a  00                DCB      0
00141b  00                DCB      0
                  |L13.5148|
                          DCD      ||.constdata||
                  |L13.5152|
001420  556e6162          DCB      "Unable to allocate templateSamplePyramid[%d] FixedLengt"
001424  6c652074
001428  6f20616c
00142c  6c6f6361
001430  74652074
001434  656d706c
001438  61746553
00143c  616d706c
001440  65507972
001444  616d6964
001448  5b25645d
00144c  20466978
001450  65644c65
001454  6e6774  
001457  684c6973          DCB      "hList.",0
00145b  742e00  
00145e  00                DCB      0
00145f  00                DCB      0
                  |L13.5216|
001460  4f757420          DCB      "Out of memory allocating templateImageAtScale.\n",0
001464  6f66206d
001468  656d6f72
00146c  7920616c
001470  6c6f6361
001474  74696e67
001478  2074656d
00147c  706c6174
001480  65496d61
001484  67654174
001488  5363616c
00148c  652e0a00
                  |L13.5264|
001490  42726967          DCB      "Bright value (%d) should be larger than dark value (%d)"
001494  68742076
001498  616c7565
00149c  20282564
0014a0  29207368
0014a4  6f756c64
0014a8  20626520
0014ac  6c617267
0014b0  65722074
0014b4  68616e20
0014b8  6461726b
0014bc  2076616c
0014c0  75652028
0014c4  256429  
0014c7  2e00              DCB      ".",0
0014c9  00                DCB      0
0014ca  00                DCB      0
0014cb  00                DCB      0
                  |L13.5324|
                          DCD      ||.constdata||+0x7f4
                  |L13.5328|
                          DCD      _ZZN4Anki8Embedded6Matrix3MinIhEET_RKNS0_25ConstArraySliceExpressionIS3_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Min<unsigned char>(const Anki::Embedded::ConstArraySliceExpression<T1>&)::__PRETTY_FUNCTION__
                  |L13.5332|
0014d4  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
0014d8  6f726574
0014dc  6563685c
0014e0  636f6d6d
0014e4  6f6e5c69
0014e8  6e636c75
0014ec  64655c61
0014f0  6e6b692f
0014f4  636f6d6d
0014f8  6f6e2f72
0014fc  6f626f74
001500  2f6d6174
001504  726978  
001507  2e6800            DCB      ".h",0
00150a  00                DCB      0
00150b  00                DCB      0
                  |L13.5388|
00150c  4d617472          DCB      "Matrix::Min",0
001510  69783a3a
001514  4d696e00
                  |L13.5400|
                          DCD      _ZZN4Anki8Embedded6Matrix3MaxIhEET_RKNS0_25ConstArraySliceExpressionIS3_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Max<unsigned char>(const Anki::Embedded::ConstArraySliceExpression<T1>&)::__PRETTY_FUNCTION__
                  |L13.5404|
00151c  4d617472          DCB      "Matrix::Max",0
001520  69783a3a
001524  4d617800
                  |L13.5416|
001528  2800              CMP      r0,#0
00152a  d075              BEQ      |L13.5656|
00152c  2100              MOVS     r1,#0
00152e  4650              MOV      r0,r10
001530  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
001534  4683              MOV      r11,r0
001536  2100              MOVS     r1,#0
001538  4640              MOV      r0,r8
00153a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00153e  4583              CMP      r11,r0
001540  d16a              BNE      |L13.5656|
001542  2101              MOVS     r1,#1
001544  4650              MOV      r0,r10
001546  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00154a  4683              MOV      r11,r0
00154c  2101              MOVS     r1,#1
00154e  4640              MOV      r0,r8
001550  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
001554  4583              CMP      r11,r0
001556  d15f              BNE      |L13.5656|
001558  9800              LDR      r0,[sp,#0]
00155a  2201              MOVS     r2,#1
00155c  1e40              SUBS     r0,r0,#1
00155e  9001              STR      r0,[sp,#4]
001560  2801              CMP      r0,#1
001562  bfc8              IT       GT
001564  f1a90c01          SUBGT    r12,r9,#1
001568  dd30              BLE      |L13.5580|
                  |L13.5482|
00156a  f8da1008          LDR      r1,[r10,#8]
00156e  f8da0010          LDR      r0,[r10,#0x10]
001572  fb020b01          MLA      r11,r2,r1,r0
001576  f8d81008          LDR      r1,[r8,#8]
00157a  f8d80010          LDR      r0,[r8,#0x10]
00157e  fb020301          MLA      r3,r2,r1,r0
001582  2001              MOVS     r0,#1
001584  edc3ba00          VSTR     s23,[r3,#0]
001588  f1bc0f01          CMP      r12,#1
00158c  dd16              BLE      |L13.5564|
                  |L13.5518|
00158e  eb0b0100          ADD      r1,r11,r0
001592  f891e001          LDRB     lr,[r1,#1]
001596  f8111c01          LDRB     r1,[r1,#-1]
00159a  ee00ea10          VMOV     s0,lr
00159e  eef80a40          VCVT.F32.U32 s1,s0
0015a2  ee001a10          VMOV     s0,r1
0015a6  eb030180          ADD      r1,r3,r0,LSL #2
0015aa  1c40              ADDS     r0,r0,#1
0015ac  eeb80a40          VCVT.F32.U32 s0,s0
0015b0  4584              CMP      r12,r0
0015b2  ee300ac0          VSUB.F32 s0,s1,s0
0015b6  ed810a00          VSTR     s0,[r1,#0]
0015ba  dce8              BGT      |L13.5518|
                  |L13.5564|
0015bc  eb030089          ADD      r0,r3,r9,LSL #2
0015c0  1c52              ADDS     r2,r2,#1
0015c2  ed40ba01          VSTR     s23,[r0,#-4]
0015c6  9801              LDR      r0,[sp,#4]
0015c8  4282              CMP      r2,r0
0015ca  dbce              BLT      |L13.5482|
                  |L13.5580|
0015cc  f8d82008          LDR      r2,[r8,#8]
0015d0  f8d80010          LDR      r0,[r8,#0x10]
0015d4  2100              MOVS     r1,#0
0015d6  9b00              LDR      r3,[sp,#0]
0015d8  fb010102          MLA      r1,r1,r2,r0
0015dc  f1a30c01          SUB      r12,r3,#1
0015e0  fb0c0202          MLA      r2,r12,r2,r0
0015e4  2000              MOVS     r0,#0
0015e6  f1b90f00          CMP      r9,#0
0015ea  dd0a              BLE      |L13.5634|
                  |L13.5612|
0015ec  eb010380          ADD      r3,r1,r0,LSL #2
0015f0  edc3ba00          VSTR     s23,[r3,#0]
0015f4  eb020380          ADD      r3,r2,r0,LSL #2
0015f8  1c40              ADDS     r0,r0,#1
0015fa  edc3ba00          VSTR     s23,[r3,#0]
0015fe  4581              CMP      r9,r0
001600  dcf4              BGT      |L13.5612|
                  |L13.5634|
001602  2000              MOVS     r0,#0
                  |L13.5636|
001604  2800              CMP      r0,#0
001606  d036              BEQ      |L13.5750|
001608  49e1              LDR      r1,|L13.6544|
00160a  f24012f7          MOV      r2,#0x1f7
00160e  9100              STR      r1,[sp,#0]
001610  e9cd2001          STRD     r2,r0,[sp,#4]
001614  4bdf              LDR      r3,|L13.6548|
001616  e000              B        |L13.5658|
                  |L13.5656|
001618  e020              B        |L13.5724|
                  |L13.5658|
00161a  a2df              ADR      r2,|L13.6552|
00161c  f20171f4          ADD      r1,r1,#0x7f4
001620  2005              MOVS     r0,#5
001622  f7fffffe          BL       _Anki_Log
001626  e4f4              B        |L13.4114|
                  |L13.5672|
001628  f24011f3          MOV      r1,#0x1f3
00162c  48d8              LDR      r0,|L13.6544|
00162e  e9cd0100          STRD     r0,r1,[sp,#0]
001632  f20071f4          ADD      r1,r0,#0x7f4
001636  4bd7              LDR      r3,|L13.6548|
001638  a2e1              ADR      r2,|L13.6592|
00163a  2005              MOVS     r0,#5
00163c  f7fffffe          BL       _Anki_Log
001640  e4e7              B        |L13.4114|
                  |L13.5698|
001642  2134              MOVS     r1,#0x34
001644  48eb              LDR      r0,|L13.6644|
001646  e9cd0100          STRD     r0,r1,[sp,#0]
00164a  a3eb              ADR      r3,|L13.6648|
00164c  a2fa              ADR      r2,|L13.6712|
00164e  a1fe              ADR      r1,|L13.6728|
001650  2005              MOVS     r0,#5
001652  f7fffffe          BL       _Anki_Log
001656  f04f6080          MOV      r0,#0x4000000
00165a  e7d3              B        |L13.5636|
                  |L13.5724|
00165c  2137              MOVS     r1,#0x37
00165e  48e5              LDR      r0,|L13.6644|
001660  e9cd0100          STRD     r0,r1,[sp,#0]
001664  a3e4              ADR      r3,|L13.6648|
001666  a2fd              ADR      r2,|L13.6748|
001668  a1f7              ADR      r1,|L13.6728|
00166a  2005              MOVS     r0,#5
00166c  f7fffffe          BL       _Anki_Log
001670  f04f60a0          MOV      r0,#0x5000000
001674  e7c6              B        |L13.5636|
                  |L13.5750|
001676  2300              MOVS     r3,#0
001678  461a              MOV      r2,r3
00167a  2101              MOVS     r1,#1
00167c  f20d5084          ADD      r0,sp,#0x584
001680  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
001684  6800              LDR      r0,[r0,#0]
001686  9000              STR      r0,[sp,#0]
001688  abd4              ADD      r3,sp,#0x350
00168a  a8b6              ADD      r0,sp,#0x2d8
00168c  9aad              LDR      r2,[sp,#0x2b4]
00168e  991d              LDR      r1,[sp,#0x74]
001690  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
001694  98ba              LDR      r0,[sp,#0x2e8]
001696  b3d8              CBZ      r0,|L13.5904|
001698  98b6              LDR      r0,[sp,#0x2d8]
00169a  2800              CMP      r0,#0
00169c  bfa4              ITT      GE
00169e  98b7              LDRGE    r0,[sp,#0x2dc]
0016a0  2800              CMPGE    r0,#0
0016a2  db35              BLT      |L13.5904|
0016a4  f50d7a1b          ADD      r10,sp,#0x26c
0016a8  f50d7836          ADD      r8,sp,#0x2d8
0016ac  2100              MOVS     r1,#0
0016ae  4650              MOV      r0,r10
0016b0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0016b4  9000              STR      r0,[sp,#0]
0016b6  2101              MOVS     r1,#1
0016b8  4650              MOV      r0,r10
0016ba  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0016be  4681              MOV      r9,r0
0016c0  4641              MOV      r1,r8
0016c2  4650              MOV      r0,r10
0016c4  f7fffffe          BL       _ZN4Anki8Embedded8AreValidINS0_5ArrayIhEENS2_IfEEEEbRKT_RKT0_ ; Anki::Embedded::AreValid<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<float>>(const T1&, const T2&)
0016c8  2800              CMP      r0,#0
0016ca  d07d              BEQ      |L13.6088|
0016cc  4641              MOV      r1,r8
0016ce  4650              MOV      r0,r10
0016d0  f7fffffe          BL       _ZN4Anki8Embedded8AreValidINS0_5ArrayIhEENS2_IfEEEEbRKT_RKT0_ ; Anki::Embedded::AreValid<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<float>>(const T1&, const T2&)
0016d4  2800              CMP      r0,#0
0016d6  d078              BEQ      |L13.6090|
0016d8  2100              MOVS     r1,#0
0016da  4650              MOV      r0,r10
0016dc  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0016e0  4683              MOV      r11,r0
0016e2  2100              MOVS     r1,#0
0016e4  4640              MOV      r0,r8
0016e6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0016ea  4583              CMP      r11,r0
0016ec  d16d              BNE      |L13.6090|
0016ee  2101              MOVS     r1,#1
0016f0  4650              MOV      r0,r10
0016f2  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0016f6  4683              MOV      r11,r0
0016f8  2101              MOVS     r1,#1
0016fa  4640              MOV      r0,r8
0016fc  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
001700  4583              CMP      r11,r0
001702  d162              BNE      |L13.6090|
001704  9900              LDR      r1,[sp,#0]
001706  2001              MOVS     r0,#1
001708  1e49              SUBS     r1,r1,#1
00170a  9101              STR      r1,[sp,#4]
00170c  2901              CMP      r1,#1
00170e  e000              B        |L13.5906|
                  |L13.5904|
001710  e065              B        |L13.6110|
                  |L13.5906|
001712  bfc8              IT       GT
001714  f1a90101          SUBGT    r1,r9,#1
001718  dd34              BLE      |L13.6020|
                  |L13.5914|
00171a  1e42              SUBS     r2,r0,#1
00171c  f8dac010          LDR      r12,[r10,#0x10]
001720  f8da3008          LDR      r3,[r10,#8]
001724  f1000b01          ADD      r11,r0,#1
001728  fb02c203          MLA      r2,r2,r3,r12
00172c  fb0bc303          MLA      r3,r11,r3,r12
001730  f8d8c010          LDR      r12,[r8,#0x10]
001734  f8d8b008          LDR      r11,[r8,#8]
001738  2901              CMP      r1,#1
00173a  fb00cb0b          MLA      r11,r0,r11,r12
00173e  f04f0c01          MOV      r12,#1
001742  edcbba00          VSTR     s23,[r11,#0]
001746  dd15              BLE      |L13.6004|
                  |L13.5960|
001748  f813e00c          LDRB     lr,[r3,r12]
00174c  ee00ea10          VMOV     s0,lr
001750  f812e00c          LDRB     lr,[r2,r12]
001754  eef80a40          VCVT.F32.U32 s1,s0
001758  ee00ea10          VMOV     s0,lr
00175c  eb0b0e8c          ADD      lr,r11,r12,LSL #2
001760  f10c0c01          ADD      r12,r12,#1
001764  eeb80a40          VCVT.F32.U32 s0,s0
001768  4561              CMP      r1,r12
00176a  ee300ac0          VSUB.F32 s0,s1,s0
00176e  ed8e0a00          VSTR     s0,[lr,#0]
001772  dce9              BGT      |L13.5960|
                  |L13.6004|
001774  eb0b0289          ADD      r2,r11,r9,LSL #2
001778  1c40              ADDS     r0,r0,#1
00177a  ed42ba01          VSTR     s23,[r2,#-4]
00177e  9a01              LDR      r2,[sp,#4]
001780  4290              CMP      r0,r2
001782  dbca              BLT      |L13.5914|
                  |L13.6020|
001784  f8d82008          LDR      r2,[r8,#8]
001788  f8d80010          LDR      r0,[r8,#0x10]
00178c  2100              MOVS     r1,#0
00178e  9b00              LDR      r3,[sp,#0]
001790  fb010102          MLA      r1,r1,r2,r0
001794  1e5b              SUBS     r3,r3,#1
001796  fb030202          MLA      r2,r3,r2,r0
00179a  2000              MOVS     r0,#0
00179c  f1b90f00          CMP      r9,#0
0017a0  dd0a              BLE      |L13.6072|
                  |L13.6050|
0017a2  eb010380          ADD      r3,r1,r0,LSL #2
0017a6  edc3ba00          VSTR     s23,[r3,#0]
0017aa  eb020380          ADD      r3,r2,r0,LSL #2
0017ae  1c40              ADDS     r0,r0,#1
0017b0  edc3ba00          VSTR     s23,[r3,#0]
0017b4  4581              CMP      r9,r0
0017b6  dcf4              BGT      |L13.6050|
                  |L13.6072|
0017b8  2000              MOVS     r0,#0
                  |L13.6074|
0017ba  b3b8              CBZ      r0,|L13.6188|
0017bc  4974              LDR      r1,|L13.6544|
0017be  f2402201          MOV      r2,#0x201
0017c2  4b74              LDR      r3,|L13.6548|
0017c4  9100              STR      r1,[sp,#0]
0017c6  e001              B        |L13.6092|
                  |L13.6088|
0017c8  e016              B        |L13.6136|
                  |L13.6090|
0017ca  e022              B        |L13.6162|
                  |L13.6092|
0017cc  e9cd2001          STRD     r2,r0,[sp,#4]
0017d0  a2a8              ADR      r2,|L13.6772|
0017d2  f20171f4          ADD      r1,r1,#0x7f4
0017d6  2005              MOVS     r0,#5
0017d8  f7fffffe          BL       _Anki_Log
0017dc  e419              B        |L13.4114|
                  |L13.6110|
0017de  f24011fd          MOV      r1,#0x1fd
0017e2  486b              LDR      r0,|L13.6544|
0017e4  e9cd0100          STRD     r0,r1,[sp,#0]
0017e8  f20071f4          ADD      r1,r0,#0x7f4
0017ec  4b69              LDR      r3,|L13.6548|
0017ee  a2ab              ADR      r2,|L13.6812|
0017f0  2005              MOVS     r0,#5
0017f2  f7fffffe          BL       _Anki_Log
0017f6  e40c              B        |L13.4114|
                  |L13.6136|
0017f8  215a              MOVS     r1,#0x5a
0017fa  48b5              LDR      r0,|L13.6864|
0017fc  e9cd0100          STRD     r0,r1,[sp,#0]
001800  a37d              ADR      r3,|L13.6648|
001802  a28d              ADR      r2,|L13.6712|
001804  a1b3              ADR      r1,|L13.6868|
001806  2005              MOVS     r0,#5
001808  f7fffffe          BL       _Anki_Log
00180c  f04f6080          MOV      r0,#0x4000000
001810  e7d3              B        |L13.6074|
                  |L13.6162|
001812  215d              MOVS     r1,#0x5d
001814  48ae              LDR      r0,|L13.6864|
001816  e9cd0100          STRD     r0,r1,[sp,#0]
00181a  a377              ADR      r3,|L13.6648|
00181c  a28f              ADR      r2,|L13.6748|
00181e  a1ad              ADR      r1,|L13.6868|
001820  2005              MOVS     r0,#5
001822  f7fffffe          BL       _Anki_Log
001826  f04f60a0          MOV      r0,#0x5000000
00182a  e7c6              B        |L13.6074|
                  |L13.6188|
00182c  e7ff              B        |L13.6190|
                  |L13.6190|
00182e  98c2              LDR      r0,[sp,#0x308]
001830  99c0              LDR      r1,[sp,#0x300]
001832  907c              STR      r0,[sp,#0x1f0]
001834  4288              CMP      r0,r1
001836  f28083df          BGE.W    |L13.8184|
00183a  a9d4              ADD      r1,sp,#0x350
00183c  f50d6096          ADD      r0,sp,#0x4b0
001840  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
001844  f50d6196          ADD      r1,sp,#0x4b0
001848  f20d40cc          ADD      r0,sp,#0x4cc
00184c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
001850  f20d41cc          ADD      r1,sp,#0x4cc
001854  f50d609d          ADD      r0,sp,#0x4e8
001858  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00185c  f50d619d          ADD      r1,sp,#0x4e8
001860  a8db              ADD      r0,sp,#0x36c
001862  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
001866  2300              MOVS     r3,#0
001868  461a              MOV      r2,r3
00186a  2101              MOVS     r1,#1
00186c  f20d50ac          ADD      r0,sp,#0x5ac
001870  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
001874  6800              LDR      r0,[r0,#0]
001876  9000              STR      r0,[sp,#0]
001878  abdb              ADD      r3,sp,#0x36c
00187a  a870              ADD      r0,sp,#0x1c0
00187c  9aad              LDR      r2,[sp,#0x2b4]
00187e  991d              LDR      r1,[sp,#0x74]
001880  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
001884  9874              LDR      r0,[sp,#0x1d0]
001886  2800              CMP      r0,#0
001888  f0008234          BEQ.W    |L13.7412|
00188c  9870              LDR      r0,[sp,#0x1c0]
00188e  2800              CMP      r0,#0
001890  bfa4              ITT      GE
001892  9871              LDRGE    r0,[sp,#0x1c4]
001894  2800              CMPGE    r0,#0
001896  f2c0822d          BLT.W    |L13.7412|
00189a  a9db              ADD      r1,sp,#0x36c
00189c  f20d5004          ADD      r0,sp,#0x504
0018a0  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0018a4  f20d5104          ADD      r1,sp,#0x504
0018a8  f50d60a4          ADD      r0,sp,#0x520
0018ac  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0018b0  2300              MOVS     r3,#0
0018b2  461a              MOV      r2,r3
0018b4  2101              MOVS     r1,#1
0018b6  f50d60b6          ADD      r0,sp,#0x5b0
0018ba  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0018be  6800              LDR      r0,[r0,#0]
0018c0  9000              STR      r0,[sp,#0]
0018c2  f50d63a4          ADD      r3,sp,#0x520
0018c6  a875              ADD      r0,sp,#0x1d4
0018c8  9aad              LDR      r2,[sp,#0x2b4]
0018ca  991d              LDR      r1,[sp,#0x74]
0018cc  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0018d0  9879              LDR      r0,[sp,#0x1e4]
0018d2  2800              CMP      r0,#0
0018d4  f000821c          BEQ.W    |L13.7440|
0018d8  9875              LDR      r0,[sp,#0x1d4]
0018da  2800              CMP      r0,#0
0018dc  bfa4              ITT      GE
0018de  9876              LDRGE    r0,[sp,#0x1d8]
0018e0  2800              CMPGE    r0,#0
0018e2  f2c08215          BLT.W    |L13.7440|
0018e6  f50d793b          ADD      r9,sp,#0x2ec
0018ea  a884              ADD      r0,sp,#0x210
0018ec  e8b9110e          LDM      r9!,{r1-r3,r8,r12}
0018f0  e88d110e          STM      sp,{r1-r3,r8,r12}
0018f4  f04f0800          MOV      r8,#0
0018f8  4669              MOV      r1,sp
0018fa  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
0018fe  f8808030          STRB     r8,[r0,#0x30]
001902  f8cd0590          STR      r0,[sp,#0x590]
001906  aabb              ADD      r2,sp,#0x2ec
001908  a8a0              ADD      r0,sp,#0x280
00190a  e8b2130a          LDM      r2!,{r1,r3,r8,r9,r12}
00190e  e88d130a          STM      sp,{r1,r3,r8,r9,r12}
001912  f04f0800          MOV      r8,#0
001916  4669              MOV      r1,sp
001918  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
00191c  f8808030          STRB     r8,[r0,#0x30]
001920  f8cd0594          STR      r0,[sp,#0x594]
001924  ab75              ADD      r3,sp,#0x1d4
001926  a8c0              ADD      r0,sp,#0x300
001928  e8b31306          LDM      r3!,{r1,r2,r8,r9,r12}
00192c  e88d1306          STM      sp,{r1,r2,r8,r9,r12}
001930  4669              MOV      r1,sp
001932  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
001936  9900              LDR      r1,[sp,#0]
001938  2900              CMP      r1,#0
00193a  bfc4              ITT      GT
00193c  9901              LDRGT    r1,[sp,#4]
00193e  2900              CMPGT    r1,#0
001940  f34081f4          BLE.W    |L13.7468|
001944  e9dd1200          LDRD     r1,r2,[sp,#0]
001948  4351              MULS     r1,r2,r1
00194a  2900              CMP      r1,#0
00194c  f00081ee          BEQ.W    |L13.7468|
001950  9b02              LDR      r3,[sp,#8]
001952  9a04              LDR      r2,[sp,#0x10]
001954  2100              MOVS     r1,#0
001956  fb012103          MLA      r1,r1,r3,r2
                  |L13.6490|
00195a  6301              STR      r1,[r0,#0x30]
00195c  f1000108          ADD      r1,r0,#8
001960  e891100e          LDM      r1,{r1-r3,r12}
001964  e9d08906          LDRD     r8,r9,[r0,#0x18]
001968  e9d0ba00          LDRD     r11,r10,[r0,#0]
00196c  e9cdc800          STRD     r12,r8,[sp,#0]
001970  e9cdba7a          STRD     r11,r10,[sp,#0x1e8]
001974  e9d0ab08          LDRD     r10,r11,[r0,#0x20]
001978  f8d0c02c          LDR      r12,[r0,#0x2c]
00197c  f8d08028          LDR      r8,[r0,#0x28]
001980  6b00              LDR      r0,[r0,#0x30]
001982  e9cd8c08          STRD     r8,r12,[sp,#0x20]
001986  e9dd8c00          LDRD     r8,r12,[sp,#0]
00198a  f8cdb01c          STR      r11,[sp,#0x1c]
00198e  e0ab              B        |L13.6888|
                  |L13.6544|
                          DCD      ||.constdata||
                  |L13.6548|
                          DCD      ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfiNS0_15Transformations13TransformTypeEifiifffffNS0_11MemoryStackERSD_SD_||+0x458
                  |L13.6552|
001998  436f6d70          DCB      "ComputeXGradient failed with code 0x%x",0
00199c  75746558
0019a0  47726164
0019a4  69656e74
0019a8  20666169
0019ac  6c656420
0019b0  77697468
0019b4  20636f64
0019b8  65203078
0019bc  257800  
0019bf  00                DCB      0
                  |L13.6592|
0019c0  4f757420          DCB      "Out of memory allocating templateImageXGradient.\n",0
0019c4  6f66206d
0019c8  656d6f72
0019cc  7920616c
0019d0  6c6f6361
0019d4  74696e67
0019d8  2074656d
0019dc  706c6174
0019e0  65496d61
0019e4  67655847
0019e8  72616469
0019ec  656e742e
0019f0  0a00    
0019f2  00                DCB      0
0019f3  00                DCB      0
                  |L13.6644|
                          DCD      _ZZN4Anki8Embedded15ImageProcessing16ComputeXGradientIhffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::ImageProcessing::ComputeXGradient<unsigned char, float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T3>&)::__PRETTY_FUNCTION__
                  |L13.6648|
0019f8  2e2e5c63          DCB      "..\\coretech\\vision\\include\\anki/vision/robot/imageP"
0019fc  6f726574
001a00  6563685c
001a04  76697369
001a08  6f6e5c69
001a0c  6e636c75
001a10  64655c61
001a14  6e6b692f
001a18  76697369
001a1c  6f6e2f72
001a20  6f626f74
001a24  2f696d61
001a28  676550  
001a2b  726f6365          DCB      "rocessing.h",0
001a2f  7373696e
001a33  672e6800
001a37  00                DCB      0
                  |L13.6712|
001a38  496e7661          DCB      "Invalid objects",0
001a3c  6c696420
001a40  6f626a65
001a44  63747300
                  |L13.6728|
001a48  436f6d70          DCB      "ComputeXGradient",0
001a4c  75746558
001a50  47726164
001a54  69656e74
001a58  00      
001a59  00                DCB      0
001a5a  00                DCB      0
001a5b  00                DCB      0
                  |L13.6748|
001a5c  496d6167          DCB      "Image sizes don't match",0
001a60  65207369
001a64  7a657320
001a68  646f6e27
001a6c  74206d61
001a70  74636800
                  |L13.6772|
001a74  436f6d70          DCB      "ComputeYGradient failed with code 0x%x",0
001a78  75746559
001a7c  47726164
001a80  69656e74
001a84  20666169
001a88  6c656420
001a8c  77697468
001a90  20636f64
001a94  65203078
001a98  257800  
001a9b  00                DCB      0
                  |L13.6812|
001a9c  4f757420          DCB      "Out of memory allocating templateImageYGradient.\n",0
001aa0  6f66206d
001aa4  656d6f72
001aa8  7920616c
001aac  6c6f6361
001ab0  74696e67
001ab4  2074656d
001ab8  706c6174
001abc  65496d61
001ac0  67655947
001ac4  72616469
001ac8  656e742e
001acc  0a00    
001ace  00                DCB      0
001acf  00                DCB      0
                  |L13.6864|
                          DCD      _ZZN4Anki8Embedded15ImageProcessing16ComputeYGradientIhffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::ImageProcessing::ComputeYGradient<unsigned char, float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T3>&)::__PRETTY_FUNCTION__
                  |L13.6868|
001ad4  436f6d70          DCB      "ComputeYGradient",0
001ad8  75746559
001adc  47726164
001ae0  69656e74
001ae4  00      
001ae5  00                DCB      0
001ae6  00                DCB      0
001ae7  00                DCB      0
                  |L13.6888|
001ae8  900a              STR      r0,[sp,#0x28]
001aea  e88d110e          STM      sp,{r1-r3,r8,r12}
001aee  e9cd9a05          STRD     r9,r10,[sp,#0x14]
001af2  e9dd237a          LDRD     r2,r3,[sp,#0x1e8]
001af6  f8dd1594          LDR      r1,[sp,#0x594]
001afa  f8dd0590          LDR      r0,[sp,#0x590]
001afe  f7fffffe          BL       _ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_11DotMultiplyIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::DotMultiply<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, const Anki::Embedded::ConstArraySliceExpression<T1>&, Anki::Embedded::ArraySlice<T3>)
001b02  f50d7936          ADD      r9,sp,#0x2d8
001b06  a8a0              ADD      r0,sp,#0x280
001b08  e8b9110e          LDM      r9!,{r1-r3,r8,r12}
001b0c  e88d110e          STM      sp,{r1-r3,r8,r12}
001b10  f04f0800          MOV      r8,#0
001b14  4669              MOV      r1,sp
001b16  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
001b1a  f8808030          STRB     r8,[r0,#0x30]
001b1e  f8cd0590          STR      r0,[sp,#0x590]
001b22  f50d7936          ADD      r9,sp,#0x2d8
001b26  a884              ADD      r0,sp,#0x210
001b28  e8b9110e          LDM      r9!,{r1-r3,r8,r12}
001b2c  e88d110e          STM      sp,{r1-r3,r8,r12}
001b30  f04f0800          MOV      r8,#0
001b34  4669              MOV      r1,sp
001b36  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
001b3a  f8808030          STRB     r8,[r0,#0x30]
001b3e  f8cd0594          STR      r0,[sp,#0x594]
001b42  f50d79e0          ADD      r9,sp,#0x1c0
001b46  a8c0              ADD      r0,sp,#0x300
001b48  e8b9110e          LDM      r9!,{r1-r3,r8,r12}
001b4c  e88d110e          STM      sp,{r1-r3,r8,r12}
001b50  4669              MOV      r1,sp
001b52  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
001b56  9900              LDR      r1,[sp,#0]
001b58  2900              CMP      r1,#0
001b5a  bfc4              ITT      GT
001b5c  9901              LDRGT    r1,[sp,#4]
001b5e  2900              CMPGT    r1,#0
001b60  dd7e              BLE      |L13.7264|
001b62  e9dd1200          LDRD     r1,r2,[sp,#0]
001b66  4351              MULS     r1,r2,r1
001b68  2900              CMP      r1,#0
001b6a  d079              BEQ      |L13.7264|
001b6c  9b02              LDR      r3,[sp,#8]
001b6e  9a04              LDR      r2,[sp,#0x10]
001b70  2100              MOVS     r1,#0
001b72  fb012103          MLA      r1,r1,r3,r2
                  |L13.7030|
001b76  6301              STR      r1,[r0,#0x30]
001b78  e9d01205          LDRD     r1,r2,[r0,#0x14]
001b7c  e9d08903          LDRD     r8,r9,[r0,#0xc]
001b80  e9d0ba00          LDRD     r11,r10,[r0,#0]
001b84  f8d0c008          LDR      r12,[r0,#8]
001b88  69c3              LDR      r3,[r0,#0x1c]
001b8a  e9cdc800          STRD     r12,r8,[sp,#0]
001b8e  e9cdba7a          STRD     r11,r10,[sp,#0x1e8]
001b92  e9d0ab08          LDRD     r10,r11,[r0,#0x20]
001b96  f8d0c028          LDR      r12,[r0,#0x28]
001b9a  f8d0802c          LDR      r8,[r0,#0x2c]
001b9e  6b00              LDR      r0,[r0,#0x30]
001ba0  f8cd9008          STR      r9,[sp,#8]
001ba4  e9cd8009          STRD     r8,r0,[sp,#0x24]
001ba8  f10d080c          ADD      r8,sp,#0xc
001bac  e8a81c0e          STM      r8!,{r1-r3,r10-r12}
001bb0  e9dd237a          LDRD     r2,r3,[sp,#0x1e8]
001bb4  f8dd1594          LDR      r1,[sp,#0x594]
001bb8  f8dd0590          LDR      r0,[sp,#0x590]
001bbc  f7fffffe          BL       _ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_11DotMultiplyIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::DotMultiply<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, const Anki::Embedded::ConstArraySliceExpression<T1>&, Anki::Embedded::ArraySlice<T3>)
001bc0  f50d79ea          ADD      r9,sp,#0x1d4
001bc4  a8a0              ADD      r0,sp,#0x280
001bc6  e8b9110e          LDM      r9!,{r1-r3,r8,r12}
001bca  e88d110e          STM      sp,{r1-r3,r8,r12}
001bce  f04f0800          MOV      r8,#0
001bd2  4669              MOV      r1,sp
001bd4  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
001bd8  f8808030          STRB     r8,[r0,#0x30]
001bdc  f8cd0590          STR      r0,[sp,#0x590]
001be0  f50d79e0          ADD      r9,sp,#0x1c0
001be4  a884              ADD      r0,sp,#0x210
001be6  e8b9110e          LDM      r9!,{r1-r3,r8,r12}
001bea  e88d110e          STM      sp,{r1-r3,r8,r12}
001bee  f04f0800          MOV      r8,#0
001bf2  4669              MOV      r1,sp
001bf4  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
001bf8  f8808030          STRB     r8,[r0,#0x30]
001bfc  f8cd0594          STR      r0,[sp,#0x594]
001c00  f50d79e0          ADD      r9,sp,#0x1c0
001c04  a8c0              ADD      r0,sp,#0x300
001c06  e8b9110e          LDM      r9!,{r1-r3,r8,r12}
001c0a  e88d110e          STM      sp,{r1-r3,r8,r12}
001c0e  4669              MOV      r1,sp
001c10  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
001c14  9900              LDR      r1,[sp,#0]
001c16  2900              CMP      r1,#0
001c18  bfc4              ITT      GT
001c1a  9901              LDRGT    r1,[sp,#4]
001c1c  2900              CMPGT    r1,#0
001c1e  dd41              BLE      |L13.7332|
001c20  e9dd1200          LDRD     r1,r2,[sp,#0]
001c24  4351              MULS     r1,r2,r1
001c26  b3e9              CBZ      r1,|L13.7332|
001c28  9b02              LDR      r3,[sp,#8]
001c2a  9a04              LDR      r2,[sp,#0x10]
001c2c  2100              MOVS     r1,#0
001c2e  fb012103          MLA      r1,r1,r3,r2
                  |L13.7218|
001c32  6301              STR      r1,[r0,#0x30]
001c34  f1000110          ADD      r1,r0,#0x10
001c38  e9d09a02          LDRD     r9,r10,[r0,#8]
001c3c  e891010e          LDM      r1,{r1-r3,r8}
001c40  e9d0bc00          LDRD     r11,r12,[r0,#0]
001c44  e9cd9a00          STRD     r9,r10,[sp,#0]
001c48  e9cdbc7a          STRD     r11,r12,[sp,#0x1e8]
001c4c  e9d09a0a          LDRD     r9,r10,[r0,#0x28]
001c50  e9d0cb08          LDRD     r12,r11,[r0,#0x20]
001c54  6b00              LDR      r0,[r0,#0x30]
001c56  e9cda009          STRD     r10,r0,[sp,#0x24]
001c5a  f10d0a08          ADD      r10,sp,#8
001c5e  e000              B        |L13.7266|
                  |L13.7264|
001c60  e066              B        |L13.7472|
                  |L13.7266|
001c62  e8aa110e          STM      r10!,{r1-r3,r8,r12}
001c66  e9cdb907          STRD     r11,r9,[sp,#0x1c]
001c6a  e9dd237a          LDRD     r2,r3,[sp,#0x1e8]
001c6e  f8dd1594          LDR      r1,[sp,#0x594]
001c72  f8dd0590          LDR      r0,[sp,#0x590]
001c76  f7fffffe          BL       _ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_3AddIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::Add<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, const Anki::Embedded::ConstArraySliceExpression<T1>&, Anki::Embedded::ArraySlice<T3>)
001c7a  a9db              ADD      r1,sp,#0x36c
001c7c  a875              ADD      r0,sp,#0x1d4
001c7e  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
001c82  a975              ADD      r1,sp,#0x1d4
001c84  a884              ADD      r0,sp,#0x210
001c86  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
001c8a  981d              LDR      r0,[sp,#0x74]
001c8c  9008              STR      r0,[sp,#0x20]
001c8e  a884              ADD      r0,sp,#0x210
001c90  2300              MOVS     r3,#0
001c92  9000              STR      r0,[sp,#0]
001c94  f10d080c          ADD      r8,sp,#0xc
001c98  f8dd92b4          LDR      r9,[sp,#0x2b4]
001c9c  461a              MOV      r2,r3
001c9e  2101              MOVS     r1,#1
001ca0  a88d              ADD      r0,sp,#0x234
001ca2  e000              B        |L13.7334|
                  |L13.7332|
001ca4  e046              B        |L13.7476|
                  |L13.7334|
001ca6  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
001caa  6800              LDR      r0,[r0,#0]
001cac  9002              STR      r0,[sp,#8]
001cae  f108000c          ADD      r0,r8,#0xc
001cb2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
001cb6  f1a0080c          SUB      r8,r0,#0xc
001cba  f04f30ff          MOV      r0,#0xffffffff
001cbe  f8c80000          STR      r0,[r8,#0]
001cc2  f8c80004          STR      r0,[r8,#4]
001cc6  f8c80008          STR      r0,[r8,#8]
001cca  2000              MOVS     r0,#0
001ccc  f8c80010          STR      r0,[r8,#0x10]
001cd0  f1b90f00          CMP      r9,#0
001cd4  bfa4              ITT      GE
001cd6  9908              LDRGE    r1,[sp,#0x20]
001cd8  2900              CMPGE    r1,#0
001cda  da2d              BGE      |L13.7480|
001cdc  48ef              LDR      r0,|L13.8348|
001cde  217d              MOVS     r1,#0x7d
001ce0  f6af1334          ADR      r3,|L13.5040|
001ce4  e9cd0100          STRD     r0,r1,[sp,#0]
001ce8  a2ed              ADR      r2,|L13.8352|
001cea  a1f1              ADR      r1,|L13.8368|
001cec  2005              MOVS     r0,#5
001cee  f7fffffe          BL       _Anki_Log
001cf2  e082              B        |L13.7674|
                  |L13.7412|
001cf4  f2402117          MOV      r1,#0x217
001cf8  48f2              LDR      r0,|L13.8388|
001cfa  e9cd0100          STRD     r0,r1,[sp,#0]
001cfe  f20071f4          ADD      r1,r0,#0x7f4
001d02  4bf1              LDR      r3,|L13.8392|
001d04  a2f1              ADR      r2,|L13.8396|
001d06  2005              MOVS     r0,#5
001d08  f7fffffe          BL       _Anki_Log
001d0c  f7ffb981          B        |L13.4114|
                  |L13.7440|
001d10  f240211e          MOV      r1,#0x21e
001d14  48eb              LDR      r0,|L13.8388|
001d16  e9cd0100          STRD     r0,r1,[sp,#0]
001d1a  f20071f4          ADD      r1,r0,#0x7f4
001d1e  4bea              LDR      r3,|L13.8392|
001d20  a2f5              ADR      r2,|L13.8440|
001d22  2005              MOVS     r0,#5
001d24  f7fffffe          BL       _Anki_Log
001d28  f7ffb973          B        |L13.4114|
                  |L13.7468|
001d2c  2100              MOVS     r1,#0
001d2e  e614              B        |L13.6490|
                  |L13.7472|
001d30  2100              MOVS     r1,#0
001d32  e720              B        |L13.7030|
                  |L13.7476|
001d34  2100              MOVS     r1,#0
001d36  e77c              B        |L13.7218|
                  |L13.7480|
001d38  2000              MOVS     r0,#0
001d3a  468b              MOV      r11,r1
001d3c  9009              STR      r0,[sp,#0x24]
001d3e  f1b90f01          CMP      r9,#1
001d42  bfcc              ITE      GT
001d44  4648              MOVGT    r0,r9
001d46  2001              MOVLE    r0,#1
001d48  300f              ADDS     r0,r0,#0xf
001d4a  f0200a0f          BIC      r10,r0,#0xf
001d4e  9800              LDR      r0,[sp,#0]
001d50  908c              STR      r0,[sp,#0x230]
001d52  a809              ADD      r0,sp,#0x24
001d54  908b              STR      r0,[sp,#0x22c]
001d56  9802              LDR      r0,[sp,#8]
001d58  900a              STR      r0,[sp,#0x28]
001d5a  f1ba0f00          CMP      r10,#0
001d5e  dc0b              BGT      |L13.7544|
001d60  48ef              LDR      r0,|L13.8480|
001d62  f240310b          MOV      r1,#0x30b
001d66  f6af13b8          ADR      r3,|L13.5040|
001d6a  e9cd0100          STRD     r0,r1,[sp,#0]
001d6e  a2cc              ADR      r2,|L13.8352|
001d70  a1ec              ADR      r1,|L13.8484|
001d72  2005              MOVS     r0,#5
001d74  f7fffffe          BL       _Anki_Log
                  |L13.7544|
001d78  f1bb0f01          CMP      r11,#1
001d7c  bfd8              IT       LE
001d7e  f04f0b01          MOVLE    r11,#1
001d82  f8c8a008          STR      r10,[r8,#8]
001d86  fb0afa0b          MUL      r10,r10,r11
001d8a  a80a              ADD      r0,sp,#0x28
001d8c  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
001d90  4602              MOV      r2,r0
001d92  e9dd308b          LDRD     r3,r0,[sp,#0x22c]
001d96  4651              MOV      r1,r10
001d98  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
001d9c  e9ddb108          LDRD     r11,r1,[sp,#0x20]
001da0  9100              STR      r1,[sp,#0]
001da2  9902              LDR      r1,[sp,#8]
001da4  ea5f0a00          MOVS     r10,r0
001da8  910a              STR      r1,[sp,#0x28]
001daa  d00f              BEQ      |L13.7628|
001dac  9800              LDR      r0,[sp,#0]
001dae  2810              CMP      r0,#0x10
001db0  d241              BCS      |L13.7734|
001db2  48e7              LDR      r0,|L13.8528|
001db4  f2403123          MOV      r1,#0x323
001db8  f6af230c          ADR      r3,|L13.5040|
001dbc  e9cd0100          STRD     r0,r1,[sp,#0]
001dc0  a2e4              ADR      r2,|L13.8532|
001dc2  a1e9              ADR      r1,|L13.8552|
001dc4  2005              MOVS     r0,#5
001dc6  f7fffffe          BL       _Anki_Log
001dca  e016              B        |L13.7674|
                  |L13.7628|
001dcc  48e0              LDR      r0,|L13.8528|
001dce  f240311e          MOV      r1,#0x31e
001dd2  f6af2324          ADR      r3,|L13.5040|
001dd6  e9cd0100          STRD     r0,r1,[sp,#0]
001dda  a2eb              ADR      r2,|L13.8584|
001ddc  a1f1              ADR      r1,|L13.8612|
001dde  2005              MOVS     r0,#5
001de0  f7fffffe          BL       _Anki_Log
001de4  f04f30ff          MOV      r0,#0xffffffff
001de8  f8c80000          STR      r0,[r8,#0]
001dec  f8c80004          STR      r0,[r8,#4]
001df0  f8c80008          STR      r0,[r8,#8]
001df4  2000              MOVS     r0,#0
                  |L13.7670|
001df6  f8c80010          STR      r0,[r8,#0x10]
                  |L13.7674|
001dfa  9807              LDR      r0,[sp,#0x1c]
001dfc  b3e8              CBZ      r0,|L13.7802|
001dfe  9803              LDR      r0,[sp,#0xc]
001e00  2800              CMP      r0,#0
001e02  bfa4              ITT      GE
001e04  9804              LDRGE    r0,[sp,#0x10]
001e06  2800              CMPGE    r0,#0
001e08  db5c              BLT      |L13.7876|
001e0a  9905              LDR      r1,[sp,#0x14]
001e0c  9803              LDR      r0,[sp,#0xc]
001e0e  f8ddc014          LDR      r12,[sp,#0x14]
001e12  4341              MULS     r1,r0,r1
001e14  9a07              LDR      r2,[sp,#0x1c]
001e16  2000              MOVS     r0,#0
001e18  fb00200c          MLA      r0,r0,r12,r2
001e1c  f7fffffe          BL       __aeabi_memclr
001e20  981d              LDR      r0,[sp,#0x74]
001e22  2101              MOVS     r1,#1
001e24  1e8a              SUBS     r2,r1,#2
001e26  eb0070d0          ADD      r0,r0,r0,LSR #31
001e2a  eb020060          ADD      r0,r2,r0,ASR #1
001e2e  9000              STR      r0,[sp,#0]
001e30  98ad              LDR      r0,[sp,#0x2b4]
001e32  1e42              SUBS     r2,r0,#1
001e34  e0af              B        |L13.8086|
                  |L13.7734|
001e36  a80a              ADD      r0,sp,#0x28
001e38  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
001e3c  b160              CBZ      r0,|L13.7768|
001e3e  48c4              LDR      r0,|L13.8528|
001e40  f2403126          MOV      r1,#0x326
001e44  f6af2398          ADR      r3,|L13.5040|
001e48  e9cd0100          STRD     r0,r1,[sp,#0]
001e4c  a2db              ADR      r2,|L13.8636|
001e4e  a1c6              ADR      r1,|L13.8552|
001e50  2005              MOVS     r0,#5
001e52  f7fffffe          BL       _Anki_Log
001e56  e7d0              B        |L13.7674|
                  |L13.7768|
001e58  980a              LDR      r0,[sp,#0x28]
001e5a  e9c80a03          STRD     r0,r10,[r8,#0xc]
001e5e  f10a000f          ADD      r0,r10,#0xf
001e62  e9c8b900          STRD     r11,r9,[r8,#0]
001e66  f020000f          BIC      r0,r0,#0xf
001e6a  eba0000a          SUB      r0,r0,r10
001e6e  f1b90f01          CMP      r9,#1
001e72  bfd8              IT       LE
001e74  f04f0901          MOVLE    r9,#1
001e78  e000              B        |L13.7804|
                  |L13.7802|
001e7a  e023              B        |L13.7876|
                  |L13.7804|
001e7c  f109010f          ADD      r1,r9,#0xf
001e80  f021010f          BIC      r1,r1,#0xf
001e84  fb01010b          MLA      r1,r1,r11,r0
001e88  9a00              LDR      r2,[sp,#0]
001e8a  4291              CMP      r1,r2
001e8c  bfd8              IT       LE
001e8e  4450              ADDLE    r0,r0,r10
001e90  ddb1              BLE      |L13.7670|
001e92  48af              LDR      r0,|L13.8528|
001e94  f2403235          MOV      r2,#0x335
001e98  f6af23ec          ADR      r3,|L13.5040|
001e9c  e9cd0200          STRD     r0,r2,[sp,#0]
001ea0  9102              STR      r1,[sp,#8]
001ea2  a2d0              ADR      r2,|L13.8676|
001ea4  a1bf              ADR      r1,|L13.8612|
001ea6  2005              MOVS     r0,#5
001ea8  f7fffffe          BL       _Anki_Log
001eac  f04f30ff          MOV      r0,#0xffffffff
001eb0  f8c80000          STR      r0,[r8,#0]
001eb4  f8c80004          STR      r0,[r8,#4]
001eb8  f8c80008          STR      r0,[r8,#8]
001ebc  2000              MOVS     r0,#0
001ebe  f8c80010          STR      r0,[r8,#0x10]
001ec2  e79a              B        |L13.7674|
                  |L13.7876|
001ec4  f240212f          MOV      r1,#0x22f
001ec8  487e              LDR      r0,|L13.8388|
001eca  e9cd0100          STRD     r0,r1,[sp,#0]
001ece  f20071f4          ADD      r1,r0,#0x7f4
001ed2  4b7d              LDR      r3,|L13.8392|
001ed4  a2d3              ADR      r2,|L13.8740|
001ed6  2005              MOVS     r0,#5
001ed8  f7fffffe          BL       _Anki_Log
001edc  f7ffb899          B        |L13.4114|
                  |L13.7904|
001ee0  f8ddc1d0          LDR      r12,[sp,#0x1d0]
001ee4  f8dd81c8          LDR      r8,[sp,#0x1c8]
001ee8  1e48              SUBS     r0,r1,#1
001eea  fb00cb08          MLA      r11,r0,r8,r12
001eee  1c48              ADDS     r0,r1,#1
001ef0  fb00c908          MLA      r9,r0,r8,r12
001ef4  fb01ca08          MLA      r10,r1,r8,r12
001ef8  f8ddc014          LDR      r12,[sp,#0x14]
001efc  9807              LDR      r0,[sp,#0x1c]
001efe  fb01080c          MLA      r8,r1,r12,r0
001f02  2001              MOVS     r0,#1
001f04  2a01              CMP      r2,#1
001f06  dd45              BLE      |L13.8084|
                  |L13.7944|
001f08  eb0a0380          ADD      r3,r10,r0,LSL #2
001f0c  eb090c80          ADD      r12,r9,r0,LSL #2
001f10  ed930a00          VLDR     s0,[r3,#0]
001f14  ed134a01          VLDR     s8,[r3,#-4]
001f18  edd33a01          VLDR     s7,[r3,#4]
001f1c  eb0b0380          ADD      r3,r11,r0,LSL #2
001f20  eddc2a00          VLDR     s5,[r12,#0]
001f24  ed933a00          VLDR     s6,[r3,#0]
001f28  ed132a01          VLDR     s4,[r3,#-4]
001f2c  edd31a01          VLDR     s3,[r3,#4]
001f30  ed5c0a01          VLDR     s1,[r12,#-4]
001f34  ed9c1a01          VLDR     s2,[r12,#4]
001f38  eeb40ac4          VCMPE.F32 s0,s8
001f3c  eef1fa10          VMRS     APSR_nzcv,FPSCR
001f40  bfc4              ITT      GT
001f42  eeb40ae3          VCMPEGT.F32 s0,s7
001f46  eef1fa10          VMRSGT   APSR_nzcv,FPSCR
001f4a  dc1d              BGT      |L13.8072|
001f4c  eeb40ac3          VCMPE.F32 s0,s6
001f50  eef1fa10          VMRS     APSR_nzcv,FPSCR
001f54  bfc4              ITT      GT
001f56  eeb40ae2          VCMPEGT.F32 s0,s5
001f5a  eef1fa10          VMRSGT   APSR_nzcv,FPSCR
001f5e  dc13              BGT      |L13.8072|
001f60  eeb40ac2          VCMPE.F32 s0,s4
001f64  eef1fa10          VMRS     APSR_nzcv,FPSCR
001f68  bfc4              ITT      GT
001f6a  eeb40ac1          VCMPEGT.F32 s0,s2
001f6e  eef1fa10          VMRSGT   APSR_nzcv,FPSCR
001f72  dc09              BGT      |L13.8072|
001f74  eeb40ae1          VCMPE.F32 s0,s3
001f78  eef1fa10          VMRS     APSR_nzcv,FPSCR
001f7c  bfc4              ITT      GT
001f7e  eeb40ae0          VCMPEGT.F32 s0,s1
001f82  eef1fa10          VMRSGT   APSR_nzcv,FPSCR
001f86  dd02              BLE      |L13.8078|
                  |L13.8072|
001f88  2301              MOVS     r3,#1
001f8a  f8083000          STRB     r3,[r8,r0]
                  |L13.8078|
001f8e  1c40              ADDS     r0,r0,#1
001f90  4290              CMP      r0,r2
001f92  dbb9              BLT      |L13.7944|
                  |L13.8084|
001f94  1c49              ADDS     r1,r1,#1
                  |L13.8086|
001f96  9800              LDR      r0,[sp,#0]
001f98  4288              CMP      r0,r1
001f9a  dca1              BGT      |L13.7904|
001f9c  981d              LDR      r0,[sp,#0x74]
001f9e  2101              MOVS     r1,#1
001fa0  f1a00801          SUB      r8,r0,#1
001fa4  f1b80f01          CMP      r8,#1
001fa8  dd19              BLE      |L13.8158|
                  |L13.8106|
001faa  9b72              LDR      r3,[sp,#0x1c8]
001fac  9874              LDR      r0,[sp,#0x1d0]
001fae  fb010c03          MLA      r12,r1,r3,r0
001fb2  9b05              LDR      r3,[sp,#0x14]
001fb4  9807              LDR      r0,[sp,#0x1c]
001fb6  fb010303          MLA      r3,r1,r3,r0
001fba  2001              MOVS     r0,#1
001fbc  2a01              CMP      r2,#1
001fbe  dd0b              BLE      |L13.8152|
                  |L13.8128|
001fc0  f8139000          LDRB     r9,[r3,r0]
001fc4  f1b90f00          CMP      r9,#0
001fc8  bf04              ITT      EQ
001fca  eb0c0980          ADDEQ    r9,r12,r0,LSL #2
001fce  edc9ba00          VSTREQ   s23,[r9,#0]
001fd2  1c40              ADDS     r0,r0,#1
001fd4  4290              CMP      r0,r2
001fd6  dbf3              BLT      |L13.8128|
                  |L13.8152|
001fd8  1c49              ADDS     r1,r1,#1
001fda  4541              CMP      r1,r8
001fdc  dbe5              BLT      |L13.8106|
                  |L13.8158|
001fde  a9e2              ADD      r1,sp,#0x388
001fe0  f20d5044          ADD      r0,sp,#0x544
001fe4  e9cd0100          STRD     r0,r1,[sp,#0]
001fe8  2114              MOVS     r1,#0x14
001fea  a870              ADD      r0,sp,#0x1c0
001fec  9b7c              LDR      r3,[sp,#0x1f0]
001fee  f8dd2654          LDR      r2,[sp,#0x654]
001ff2  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17ApproximateSelectERKNS0_5ArrayIfEEiiiRiRNS3_IiEE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::ApproximateSelect(const Anki::Embedded::Array<float>&, int, int, int, int&, Anki::Embedded::Array<int>&)
001ff6  e00f              B        |L13.8216|
                  |L13.8184|
001ff8  9ae4              LDR      r2,[sp,#0x390]
001ffa  99e6              LDR      r1,[sp,#0x398]
001ffc  2000              MOVS     r0,#0
001ffe  fb001102          MLA      r1,r0,r2,r1
002002  9ac1              LDR      r2,[sp,#0x304]
002004  2a00              CMP      r2,#0
002006  dd05              BLE      |L13.8212|
                  |L13.8200|
002008  f8410020          STR      r0,[r1,r0,LSL #2]
00200c  9ac1              LDR      r2,[sp,#0x304]
00200e  1c40              ADDS     r0,r0,#1
002010  4282              CMP      r2,r0
002012  dcf9              BGT      |L13.8200|
                  |L13.8212|
002014  f8cd2544          STR      r2,[sp,#0x544]
                  |L13.8216|
002018  f20d4234          ADD      r2,sp,#0x434
00201c  a9bb              ADD      r1,sp,#0x2ec
00201e  2000              MOVS     r0,#0
002020  f7fffffe          BL       _ZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EE ; Anki::Embedded::Matrix::Vectorize<float, float>(bool, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
002024  b160              CBZ      r0,|L13.8256|
002026  4927              LDR      r1,|L13.8388|
002028  9100              STR      r1,[sp,#0]
00202a  f240227a          MOV      r2,#0x27a
00202e  e9cd2001          STRD     r2,r0,[sp,#4]
002032  4b25              LDR      r3,|L13.8392|
002034  a287              ADR      r2,|L13.8788|
002036  f20171f4          ADD      r1,r1,#0x7f4
00203a  2005              MOVS     r0,#5
00203c  f7fffffe          BL       _Anki_Log
                  |L13.8256|
002040  f50d6289          ADD      r2,sp,#0x448
002044  a9b6              ADD      r1,sp,#0x2d8
002046  2000              MOVS     r0,#0
002048  f7fffffe          BL       _ZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EE ; Anki::Embedded::Matrix::Vectorize<float, float>(bool, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
00204c  b160              CBZ      r0,|L13.8296|
00204e  491d              LDR      r1,|L13.8388|
002050  9100              STR      r1,[sp,#0]
002052  f240227f          MOV      r2,#0x27f
002056  e9cd2001          STRD     r2,r0,[sp,#4]
00205a  4b1b              LDR      r3,|L13.8392|
00205c  a27d              ADR      r2,|L13.8788|
00205e  f20171f4          ADD      r1,r1,#0x7f4
002062  2005              MOVS     r0,#5
002064  f7fffffe          BL       _Anki_Log
                  |L13.8296|
002068  f50d6984          ADD      r9,sp,#0x420
00206c  f50d781b          ADD      r8,sp,#0x26c
002070  2100              MOVS     r1,#0
002072  4648              MOV      r0,r9
002074  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
002078  2801              CMP      r0,#1
00207a  d00e              BEQ      |L13.8346|
00207c  487f              LDR      r0,|L13.8828|
00207e  f44f7129          MOV      r1,#0x2a4
002082  f6af33b0          ADR      r3,|L13.5332|
002086  e9cd0100          STRD     r0,r1,[sp,#0]
00208a  a27d              ADR      r2,|L13.8832|
00208c  a181              ADR      r1,|L13.8852|
00208e  2005              MOVS     r0,#5
002090  f7fffffe          BL       _Anki_Log
002094  f04f60a0          MOV      r0,#0x5000000
002098  e158              B        |L13.9036|
                  |L13.8346|
00209a  e101              B        |L13.8864|
                  |L13.8348|
                          DCD      _ZZN4Anki8Embedded5ArrayIbEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<bool>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L13.8352|
0020a0  496e7661          DCB      "Invalid size",0
0020a4  6c696420
0020a8  73697a65
0020ac  00      
0020ad  00                DCB      0
0020ae  00                DCB      0
0020af  00                DCB      0
                  |L13.8368|
0020b0  41727261          DCB      "Array<Type>::Array",0
0020b4  793c5479
0020b8  70653e3a
0020bc  3a417272
0020c0  617900  
0020c3  00                DCB      0
                  |L13.8388|
                          DCD      ||.constdata||
                  |L13.8392|
                          DCD      ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfiNS0_15Transformations13TransformTypeEifiifffffNS0_11MemoryStackERSD_SD_||+0x458
                  |L13.8396|
0020cc  4f757420          DCB      "Out of memory allocating magnitudeImage.\n",0
0020d0  6f66206d
0020d4  656d6f72
0020d8  7920616c
0020dc  6c6f6361
0020e0  74696e67
0020e4  206d6167
0020e8  6e697475
0020ec  6465496d
0020f0  6167652e
0020f4  0a00    
0020f6  00                DCB      0
0020f7  00                DCB      0
                  |L13.8440|
0020f8  4f757420          DCB      "Out of memory allocating tmpMagnitude.\n",0
0020fc  6f66206d
002100  656d6f72
002104  7920616c
002108  6c6f6361
00210c  74696e67
002110  20746d70
002114  4d61676e
002118  69747564
00211c  652e0a00
                  |L13.8480|
                          DCD      _ZZN4Anki8Embedded5ArrayIbE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<bool>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L13.8484|
002124  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
002128  793c5479
00212c  70653e3a
002130  3a416c6c
002134  6f636174
002138  65427566
00213c  66657246
002140  726f6d4d
002144  656d6f72
002148  79537461
00214c  636b00  
00214f  00                DCB      0
                  |L13.8528|
                          DCD      _ZZN4Anki8Embedded5ArrayIbE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<bool>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L13.8532|
002154  4e656761          DCB      "Negative dimension",0
002158  74697665
00215c  2064696d
002160  656e7369
002164  6f6e00  
002167  00                DCB      0
                  |L13.8552|
002168  41727261          DCB      "Array<Type>::InitializeBuffer",0
00216c  793c5479
002170  70653e3a
002174  3a496e69
002178  7469616c
00217c  697a6542
002180  75666665
002184  7200    
002186  00                DCB      0
002187  00                DCB      0
                  |L13.8584|
002188  696e7075          DCB      "input data buffer is NULL",0
00218c  74206461
002190  74612062
002194  75666665
002198  72206973
00219c  204e554c
0021a0  4c00    
0021a2  00                DCB      0
0021a3  00                DCB      0
                  |L13.8612|
0021a4  416e6b69          DCB      "Anki.Array2d.initialize",0
0021a8  2e417272
0021ac  61793264
0021b0  2e696e69
0021b4  7469616c
0021b8  697a6500
                  |L13.8636|
0021bc  46696c6c          DCB      "Fill patterns not supported for Array",0
0021c0  20706174
0021c4  7465726e
0021c8  73206e6f
0021cc  74207375
0021d0  70706f72
0021d4  74656420
0021d8  666f7220
0021dc  41727261
0021e0  7900    
0021e2  00                DCB      0
0021e3  00                DCB      0
                  |L13.8676|
0021e4  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0021e8  74206461
0021ec  74612062
0021f0  75666665
0021f4  72206973
0021f8  206e6f74
0021fc  206c6172
002200  67652065
002204  6e6f7567
002208  682e2025
00220c  64206279
002210  74657320
002214  69732072
002218  657175  
00221b  69726564          DCB      "ired.",0
00221f  2e00    
002221  00                DCB      0
002222  00                DCB      0
002223  00                DCB      0
                  |L13.8740|
002224  4f757420          DCB      "Out of memory allocating magnitudeImageNLMS.\n",0
002228  6f66206d
00222c  656d6f72
002230  7920616c
002234  6c6f6361
002238  74696e67
00223c  206d6167
002240  6e697475
002244  6465496d
002248  6167654e
00224c  4c4d532e
002250  0a00    
002252  00                DCB      0
002253  00                DCB      0
                  |L13.8788|
002254  4d617472          DCB      "Matrix::Vectorize failed with code 0x%x",0
002258  69783a3a
00225c  56656374
002260  6f72697a
002264  65206661
002268  696c6564
00226c  20776974
002270  6820636f
002274  64652030
002278  78257800
                  |L13.8828|
                          DCD      _ZZN4Anki8Embedded6Matrix9VectorizeIhhEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Vectorize<unsigned char, unsigned char>(bool, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L13.8832|
002280  4f757470          DCB      "Output is not 1xN",0
002284  75742069
002288  73206e6f
00228c  74203178
002290  4e00    
002292  00                DCB      0
002293  00                DCB      0
                  |L13.8852|
002294  56656374          DCB      "Vectorize",0
002298  6f72697a
00229c  6500    
00229e  00                DCB      0
00229f  00                DCB      0
                  |L13.8864|
0022a0  2100              MOVS     r1,#0
0022a2  4640              MOV      r0,r8
0022a4  f8cd9000          STR      r9,[sp,#0]
0022a8  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0022ac  4681              MOV      r9,r0
0022ae  2101              MOVS     r1,#1
0022b0  4640              MOV      r0,r8
0022b2  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0022b6  9002              STR      r0,[sp,#8]
0022b8  2100              MOVS     r1,#0
0022ba  9800              LDR      r0,[sp,#0]
0022bc  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0022c0  9001              STR      r0,[sp,#4]
0022c2  2101              MOVS     r1,#1
0022c4  9800              LDR      r0,[sp,#0]
0022c6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0022ca  4682              MOV      r10,r0
0022cc  9902              LDR      r1,[sp,#8]
0022ce  9801              LDR      r0,[sp,#4]
0022d0  fb09f101          MUL      r1,r9,r1
0022d4  fb00f00a          MUL      r0,r0,r10
0022d8  4281              CMP      r1,r0
0022da  d00e              BEQ      |L13.8954|
0022dc  48f4              LDR      r0,|L13.9904|
0022de  f44f711b          MOV      r1,#0x26c
0022e2  f6af6310          ADR      r3,|L13.5332|
0022e6  e9cd0100          STRD     r0,r1,[sp,#0]
0022ea  a2f2              ADR      r2,|L13.9908|
0022ec  a1fe              ADR      r1,|L13.9960|
0022ee  2005              MOVS     r0,#5
0022f0  f7fffffe          BL       _Anki_Log
0022f4  f04f60a0          MOV      r0,#0x5000000
0022f8  e028              B        |L13.9036|
                  |L13.8954|
0022fa  2200              MOVS     r2,#0
0022fc  9901              LDR      r1,[sp,#4]
0022fe  4610              MOV      r0,r2
002300  4613              MOV      r3,r2
002302  2900              CMP      r1,#0
002304  dd21              BLE      |L13.9034|
                  |L13.8966|
002306  9900              LDR      r1,[sp,#0]
002308  f8d1c010          LDR      r12,[r1,#0x10]
00230c  6889              LDR      r1,[r1,#8]
00230e  fb03ce01          MLA      lr,r3,r1,r12
002312  2100              MOVS     r1,#0
002314  f1ba0f00          CMP      r10,#0
002318  dd13              BLE      |L13.9026|
                  |L13.8986|
00231a  f8d8c010          LDR      r12,[r8,#0x10]
00231e  f8d89008          LDR      r9,[r8,#8]
002322  fb02cc09          MLA      r12,r2,r9,r12
002326  f81cc000          LDRB     r12,[r12,r0]
00232a  f80ec001          STRB     r12,[lr,r1]
00232e  f8ddc008          LDR      r12,[sp,#8]
002332  1c40              ADDS     r0,r0,#1
002334  4560              CMP      r0,r12
002336  bfa4              ITT      GE
002338  2000              MOVGE    r0,#0
00233a  1c52              ADDGE    r2,r2,#1
00233c  1c49              ADDS     r1,r1,#1
00233e  4551              CMP      r1,r10
002340  dbeb              BLT      |L13.8986|
                  |L13.9026|
002342  9901              LDR      r1,[sp,#4]
002344  1c5b              ADDS     r3,r3,#1
002346  428b              CMP      r3,r1
002348  dbdd              BLT      |L13.8966|
                  |L13.9034|
00234a  2000              MOVS     r0,#0
                  |L13.9036|
00234c  b168              CBZ      r0,|L13.9066|
00234e  49e8              LDR      r1,|L13.9968|
002350  f44f7221          MOV      r2,#0x284
002354  9100              STR      r1,[sp,#0]
002356  e9cd2001          STRD     r2,r0,[sp,#4]
00235a  4be6              LDR      r3,|L13.9972|
00235c  f2af120c          ADR      r2,|L13.8788|
002360  f20171f4          ADD      r1,r1,#0x7f4
002364  2005              MOVS     r0,#5
002366  f7fffffe          BL       _Anki_Log
                  |L13.9066|
00236a  f8d410e4          LDR      r1,[r4,#0xe4]
00236e  f8dd0548          LDR      r0,[sp,#0x548]
002372  f8dd2544          LDR      r2,[sp,#0x544]
002376  eb010180          ADD      r1,r1,r0,LSL #2
00237a  f8dd0550          LDR      r0,[sp,#0x550]
00237e  4410              ADD      r0,r0,r2
002380  69ca              LDR      r2,[r1,#0x1c]
002382  2800              CMP      r0,#0
002384  bfb4              ITE      LT
002386  2300              MOVLT    r3,#0
002388  4603              MOVGE    r3,r0
00238a  429a              CMP      r2,r3
00238c  bfb8              IT       LT
00238e  4610              MOVLT    r0,r2
002390  db02              BLT      |L13.9112|
002392  2800              CMP      r0,#0
002394  bfb8              IT       LT
002396  2000              MOVLT    r0,#0
                  |L13.9112|
002398  60c8              STR      r0,[r1,#0xc]
00239a  f8dd0544          LDR      r0,[sp,#0x544]
00239e  b3e0              CBZ      r0,|L13.9242|
0023a0  2300              MOVS     r3,#0
0023a2  900a              STR      r0,[sp,#0x28]
0023a4  461a              MOV      r2,r3
0023a6  2101              MOVS     r1,#1
0023a8  a887              ADD      r0,sp,#0x21c
0023aa  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0023ae  6800              LDR      r0,[r0,#0]
0023b0  9000              STR      r0,[sp,#0]
0023b2  ab7d              ADD      r3,sp,#0x1f4
0023b4  2200              MOVS     r2,#0
0023b6  a9ce              ADD      r1,sp,#0x338
0023b8  a870              ADD      r0,sp,#0x1c0
0023ba  f7fffffe          BL       _ZNK4Anki8Embedded8MeshgridIfE10EvaluateY1EbRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Meshgrid<float>::EvaluateY1(bool, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer) const
0023be  2300              MOVS     r3,#0
0023c0  461a              MOV      r2,r3
0023c2  2101              MOVS     r1,#1
0023c4  a887              ADD      r0,sp,#0x21c
0023c6  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0023ca  6800              LDR      r0,[r0,#0]
0023cc  9000              STR      r0,[sp,#0]
0023ce  ab7d              ADD      r3,sp,#0x1f4
0023d0  2200              MOVS     r2,#0
0023d2  a9ce              ADD      r1,sp,#0x338
0023d4  a875              ADD      r0,sp,#0x1d4
0023d6  f7fffffe          BL       _ZNK4Anki8Embedded8MeshgridIfE10EvaluateX1EbRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Meshgrid<float>::EvaluateX1(bool, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer) const
0023da  9b72              LDR      r3,[sp,#0x1c8]
0023dc  9974              LDR      r1,[sp,#0x1d0]
0023de  2000              MOVS     r0,#0
0023e0  fb001003          MLA      r0,r0,r3,r1
0023e4  901d              STR      r0,[sp,#0x74]
0023e6  9b77              LDR      r3,[sp,#0x1dc]
0023e8  9979              LDR      r1,[sp,#0x1e4]
0023ea  2000              MOVS     r0,#0
0023ec  fb001003          MLA      r0,r0,r3,r1
0023f0  907a              STR      r0,[sp,#0x1e8]
0023f2  f8dd3450          LDR      r3,[sp,#0x450]
0023f6  f8dd1458          LDR      r1,[sp,#0x458]
0023fa  2000              MOVS     r0,#0
0023fc  fb001003          MLA      r0,r0,r3,r1
002400  907b              STR      r0,[sp,#0x1ec]
002402  f8dd343c          LDR      r3,[sp,#0x43c]
002406  f8dd1444          LDR      r1,[sp,#0x444]
00240a  2000              MOVS     r0,#0
00240c  fb001003          MLA      r0,r0,r3,r1
002410  907c              STR      r0,[sp,#0x1f0]
002412  2000              MOVS     r0,#0
002414  f8dd3428          LDR      r3,[sp,#0x428]
002418  e000              B        |L13.9244|
                  |L13.9242|
00241a  e05e              B        |L13.9434|
                  |L13.9244|
00241c  f8dd1430          LDR      r1,[sp,#0x430]
002420  fb001003          MLA      r0,r0,r3,r1
002424  9084              STR      r0,[sp,#0x210]
002426  9be4              LDR      r3,[sp,#0x390]
002428  99e6              LDR      r1,[sp,#0x398]
00242a  2000              MOVS     r0,#0
00242c  fb001003          MLA      r0,r0,r3,r1
002430  9085              STR      r0,[sp,#0x214]
002432  f8d410e4          LDR      r1,[r4,#0xe4]
002436  f8dd0548          LDR      r0,[sp,#0x548]
00243a  eb010180          ADD      r1,r1,r0,LSL #2
00243e  f8dd0550          LDR      r0,[sp,#0x550]
002442  6b09              LDR      r1,[r1,#0x30]
002444  eb0000c0          ADD      r0,r0,r0,LSL #3
002448  eb010080          ADD      r0,r1,r0,LSL #2
00244c  ed9f0aaa          VLDR     s0,|L13.9976|
002450  9086              STR      r0,[sp,#0x218]
002452  980a              LDR      r0,[sp,#0x28]
002454  ee88aa00          VDIV.F32 s20,s16,s0
002458  f04f0800          MOV      r8,#0
00245c  2800              CMP      r0,#0
00245e  dd3c              BLE      |L13.9434|
                  |L13.9312|
002460  9885              LDR      r0,[sp,#0x214]
002462  997b              LDR      r1,[sp,#0x1ec]
002464  ab0b              ADD      r3,sp,#0x2c
002466  f8500028          LDR      r0,[r0,r8,LSL #2]
00246a  9500              STR      r5,[sp,#0]
00246c  eb010180          ADD      r1,r1,r0,LSL #2
002470  edd42a1f          VLDR     s5,[r4,#0x7c]
002474  ed910a00          VLDR     s0,[r1,#0]
002478  997c              LDR      r1,[sp,#0x1f0]
00247a  ed942a1e          VLDR     s4,[r4,#0x78]
00247e  eb010180          ADD      r1,r1,r0,LSL #2
002482  ee601a0a          VMUL.F32 s3,s0,s20
002486  ed910a00          VLDR     s0,[r1,#0]
00248a  991d              LDR      r1,[sp,#0x74]
00248c  aa32              ADD      r2,sp,#0xc8
00248e  eb010180          ADD      r1,r1,r0,LSL #2
002492  ee201a0a          VMUL.F32 s2,s0,s20
002496  edd10a00          VLDR     s1,[r1,#0]
00249a  997a              LDR      r1,[sp,#0x1e8]
00249c  eb010180          ADD      r1,r1,r0,LSL #2
0024a0  ed910a00          VLDR     s0,[r1,#0]
0024a4  9984              LDR      r1,[sp,#0x210]
0024a6  5c09              LDRB     r1,[r1,r0]
0024a8  a801              ADD      r0,sp,#4
0024aa  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
0024ae  9886              LDR      r0,[sp,#0x218]
0024b0  eb0801c8          ADD      r1,r8,r8,LSL #3
0024b4  eb000081          ADD      r0,r0,r1,LSL #2
0024b8  e9dd1201          LDRD     r1,r2,[sp,#4]
0024bc  e9dd3903          LDRD     r3,r9,[sp,#0xc]
0024c0  e9ddab05          LDRD     r10,r11,[sp,#0x14]
0024c4  e9ddce07          LDRD     r12,lr,[sp,#0x1c]
0024c8  e8805e0e          STM      r0,{r1-r3,r9-r12,lr}
0024cc  9909              LDR      r1,[sp,#0x24]
0024ce  6201              STR      r1,[r0,#0x20]
0024d0  980a              LDR      r0,[sp,#0x28]
0024d2  f1080801          ADD      r8,r8,#1
0024d6  4540              CMP      r0,r8
0024d8  dcc2              BGT      |L13.9312|
                  |L13.9434|
0024da  f8dd064c          LDR      r0,[sp,#0x64c]
0024de  2800              CMP      r0,#0
0024e0  f34083ad          BLE.W    |L13.11326|
0024e4  f8dd153c          LDR      r1,[sp,#0x53c]
0024e8  f8dd0540          LDR      r0,[sp,#0x540]
0024ec  4408              ADD      r0,r0,r1
0024ee  0840              LSRS     r0,r0,#1
0024f0  9070              STR      r0,[sp,#0x1c0]
0024f2  f8dd0540          LDR      r0,[sp,#0x540]
0024f6  1a40              SUBS     r0,r0,r1
0024f8  ee000a10          VMOV     s0,r0
0024fc  eeb80ac0          VCVT.F32.S32 s0,s0
002500  eddf0a7e          VLDR     s1,|L13.9980|
002504  1e70              SUBS     r0,r6,#1
002506  9003              STR      r0,[sp,#0xc]
002508  ee200a20          VMUL.F32 s0,s0,s1
00250c  eef00a69          VMOV.F32 s1,s19
002510  9004              STR      r0,[sp,#0x10]
002512  f8d410e4          LDR      r1,[r4,#0xe4]
002516  ee60da08          VMUL.F32 s27,s0,s16
00251a  ee000a10          VMOV     s0,r0
00251e  eb0608c6          ADD      r8,r6,r6,LSL #3
002522  eeb0ea69          VMOV.F32 s28,s19
002526  eeb80ac0          VCVT.F32.S32 s0,s0
00252a  eeb18a6d          VNEG.F32 s16,s27
00252e  ab0b              ADD      r3,sp,#0x2c
002530  aa32              ADD      r2,sp,#0xc8
002532  eec0aa80          VDIV.F32 s21,s1,s0
002536  ee000a10          VMOV     s0,r0
00253a  f8dd0548          LDR      r0,[sp,#0x548]
00253e  eef01a48          VMOV.F32 s3,s16
002542  eb010080          ADD      r0,r1,r0,LSL #2
002546  eeb80ac0          VCVT.F32.S32 s0,s0
00254a  6b00              LDR      r0,[r0,#0x30]
00254c  eeb01a48          VMOV.F32 s2,s16
002550  eb000188          ADD      r1,r0,r8,LSL #2
002554  9107              STR      r1,[sp,#0x1c]
002556  0071              LSLS     r1,r6,#1
002558  eb0101c1          ADD      r1,r1,r1,LSL #3
00255c  eb000181          ADD      r1,r0,r1,LSL #2
002560  911d              STR      r1,[sp,#0x74]
002562  eb060146          ADD      r1,r6,r6,LSL #1
002566  eb0101c1          ADD      r1,r1,r1,LSL #3
00256a  eb000181          ADD      r1,r0,r1,LSL #2
00256e  e9cd1008          STRD     r1,r0,[sp,#0x20]
002572  00b1              LSLS     r1,r6,#2
002574  eb0101c1          ADD      r1,r1,r1,LSL #3
002578  eb000181          ADD      r1,r0,r1,LSL #2
00257c  9106              STR      r1,[sp,#0x18]
00257e  eb060186          ADD      r1,r6,r6,LSL #2
002582  eb0101c1          ADD      r1,r1,r1,LSL #3
002586  eb000181          ADD      r1,r0,r1,LSL #2
00258a  9105              STR      r1,[sp,#0x14]
00258c  eb060146          ADD      r1,r6,r6,LSL #1
002590  ee8daa00          VDIV.F32 s20,s26,s0
002594  0049              LSLS     r1,r1,#1
002596  eb0101c1          ADD      r1,r1,r1,LSL #3
00259a  eb000181          ADD      r1,r0,r1,LSL #2
00259e  910a              STR      r1,[sp,#0x28]
0025a0  ebc601c6          RSB      r1,r6,r6,LSL #3
0025a4  eb0101c1          ADD      r1,r1,r1,LSL #3
0025a8  eb000081          ADD      r0,r0,r1,LSL #2
0025ac  e9cd5000          STRD     r5,r0,[sp,#0]
0025b0  edd42a1f          VLDR     s5,[r4,#0x7c]
0025b4  ed942a1e          VLDR     s4,[r4,#0x78]
0025b8  eef00a68          VMOV.F32 s1,s17
0025bc  eeb00a68          VMOV.F32 s0,s17
0025c0  a862              ADD      r0,sp,#0x188
0025c2  9970              LDR      r1,[sp,#0x1c0]
0025c4  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
0025c8  f50d7ec4          ADD      lr,sp,#0x188
0025cc  9809              LDR      r0,[sp,#0x24]
0025ce  e8be1e4e          LDM      lr!,{r1-r3,r6,r9-r12}
0025d2  e8801e4e          STM      r0,{r1-r3,r6,r9-r12}
0025d6  996a              LDR      r1,[sp,#0x1a8]
0025d8  6201              STR      r1,[r0,#0x20]
0025da  9500              STR      r5,[sp,#0]
0025dc  edd42a1f          VLDR     s5,[r4,#0x7c]
0025e0  ed942a1e          VLDR     s4,[r4,#0x78]
0025e4  ab0b              ADD      r3,sp,#0x2c
0025e6  aa32              ADD      r2,sp,#0xc8
0025e8  eef01a6d          VMOV.F32 s3,s27
0025ec  eeb01a6d          VMOV.F32 s2,s27
0025f0  eef00a49          VMOV.F32 s1,s18
0025f4  eeb00a49          VMOV.F32 s0,s18
0025f8  a862              ADD      r0,sp,#0x188
0025fa  9970              LDR      r1,[sp,#0x1c0]
0025fc  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002600  f50d7ec4          ADD      lr,sp,#0x188
002604  991d              LDR      r1,[sp,#0x74]
002606  e8be1e4d          LDM      lr!,{r0,r2,r3,r6,r9-r12}
00260a  e8811e4d          STM      r1,{r0,r2,r3,r6,r9-r12}
00260e  986a              LDR      r0,[sp,#0x1a8]
002610  6208              STR      r0,[r1,#0x20]
002612  9500              STR      r5,[sp,#0]
002614  edd42a1f          VLDR     s5,[r4,#0x7c]
002618  ed942a1e          VLDR     s4,[r4,#0x78]
00261c  ab0b              ADD      r3,sp,#0x2c
00261e  aa32              ADD      r2,sp,#0xc8
002620  eef01a48          VMOV.F32 s3,s16
002624  eeb01a48          VMOV.F32 s2,s16
002628  eef00a68          VMOV.F32 s1,s17
00262c  ed9d0a6f          VLDR     s0,[sp,#0x1bc]
002630  a862              ADD      r0,sp,#0x188
002632  9970              LDR      r1,[sp,#0x1c0]
002634  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002638  f50d7ec4          ADD      lr,sp,#0x188
00263c  e9dda066          LDRD     r10,r0,[sp,#0x198]
002640  e8be024c          LDM      lr!,{r2,r3,r6,r9}
002644  e9ddbc68          LDRD     r11,r12,[sp,#0x1a0]
002648  9907              LDR      r1,[sp,#0x1c]
00264a  eef01a6d          VMOV.F32 s3,s27
00264e  eeb01a6d          VMOV.F32 s2,s27
002652  e9c1a004          STRD     r10,r0,[r1,#0x10]
002656  e881024c          STM      r1,{r2,r3,r6,r9}
00265a  e9c1bc06          STRD     r11,r12,[r1,#0x18]
00265e  986a              LDR      r0,[sp,#0x1a8]
002660  6208              STR      r0,[r1,#0x20]
002662  9500              STR      r5,[sp,#0]
002664  edd42a1f          VLDR     s5,[r4,#0x7c]
002668  ed942a1e          VLDR     s4,[r4,#0x78]
00266c  ab0b              ADD      r3,sp,#0x2c
00266e  aa32              ADD      r2,sp,#0xc8
002670  eef00a49          VMOV.F32 s1,s18
002674  eeb00a6f          VMOV.F32 s0,s31
002678  a862              ADD      r0,sp,#0x188
00267a  9970              LDR      r1,[sp,#0x1c0]
00267c  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002680  f50d7ec4          ADD      lr,sp,#0x188
002684  e9dda066          LDRD     r10,r0,[sp,#0x198]
002688  e8be024c          LDM      lr!,{r2,r3,r6,r9}
00268c  e9ddbc68          LDRD     r11,r12,[sp,#0x1a0]
002690  9908              LDR      r1,[sp,#0x20]
002692  e9c1a004          STRD     r10,r0,[r1,#0x10]
002696  e881024c          STM      r1,{r2,r3,r6,r9}
00269a  e9c1bc06          STRD     r11,r12,[r1,#0x18]
00269e  986a              LDR      r0,[sp,#0x1a8]
0026a0  6208              STR      r0,[r1,#0x20]
0026a2  9500              STR      r5,[sp,#0]
0026a4  edd42a1f          VLDR     s5,[r4,#0x7c]
0026a8  ed942a1e          VLDR     s4,[r4,#0x78]
0026ac  ab0b              ADD      r3,sp,#0x2c
0026ae  e027              B        |L13.9984|
                  |L13.9904|
                          DCD      _ZZN4Anki8Embedded6Matrix7ReshapeIhhEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Reshape<unsigned char, unsigned char>(bool, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L13.9908|
0026b4  496e7075          DCB      "Input and Output matrices are incompatible sizes",0
0026b8  7420616e
0026bc  64204f75
0026c0  74707574
0026c4  206d6174
0026c8  72696365
0026cc  73206172
0026d0  6520696e
0026d4  636f6d70
0026d8  61746962
0026dc  6c652073
0026e0  697a6573
0026e4  00      
0026e5  00                DCB      0
0026e6  00                DCB      0
0026e7  00                DCB      0
                  |L13.9960|
0026e8  52657368          DCB      "Reshape",0
0026ec  61706500
                  |L13.9968|
                          DCD      ||.constdata||
                  |L13.9972|
                          DCD      ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfiNS0_15Transformations13TransformTypeEifiifffffNS0_11MemoryStackERSD_SD_||+0x458
                  |L13.9976|
0026f8  43ff0000          DCFS     0x43ff0000 ; 510
                  |L13.9980|
0026fc  3b008081          DCFS     0x3b008081 ; 0.0019607844296842813
                  |L13.9984|
002700  aa32              ADD      r2,sp,#0xc8
002702  eef01a48          VMOV.F32 s3,s16
002706  eeb01a48          VMOV.F32 s2,s16
00270a  eef00a68          VMOV.F32 s1,s17
00270e  eeb00a68          VMOV.F32 s0,s17
002712  a862              ADD      r0,sp,#0x188
002714  9970              LDR      r1,[sp,#0x1c0]
002716  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
00271a  f50d7ec4          ADD      lr,sp,#0x188
00271e  9906              LDR      r1,[sp,#0x18]
002720  e8be1e4d          LDM      lr!,{r0,r2,r3,r6,r9-r12}
002724  e8811e4d          STM      r1,{r0,r2,r3,r6,r9-r12}
002728  986a              LDR      r0,[sp,#0x1a8]
00272a  6208              STR      r0,[r1,#0x20]
00272c  9500              STR      r5,[sp,#0]
00272e  edd42a1f          VLDR     s5,[r4,#0x7c]
002732  ed942a1e          VLDR     s4,[r4,#0x78]
002736  ab0b              ADD      r3,sp,#0x2c
002738  aa32              ADD      r2,sp,#0xc8
00273a  eef01a48          VMOV.F32 s3,s16
00273e  eeb01a6d          VMOV.F32 s2,s27
002742  eef00a68          VMOV.F32 s1,s17
002746  eeb00a69          VMOV.F32 s0,s19
00274a  a862              ADD      r0,sp,#0x188
00274c  9970              LDR      r1,[sp,#0x1c0]
00274e  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002752  f50d7ec4          ADD      lr,sp,#0x188
002756  9905              LDR      r1,[sp,#0x14]
002758  e8be1e4d          LDM      lr!,{r0,r2,r3,r6,r9-r12}
00275c  e8811e4d          STM      r1,{r0,r2,r3,r6,r9-r12}
002760  986a              LDR      r0,[sp,#0x1a8]
002762  6208              STR      r0,[r1,#0x20]
002764  9500              STR      r5,[sp,#0]
002766  edd42a1f          VLDR     s5,[r4,#0x7c]
00276a  ed942a1e          VLDR     s4,[r4,#0x78]
00276e  ab0b              ADD      r3,sp,#0x2c
002770  aa32              ADD      r2,sp,#0xc8
002772  eef01a6d          VMOV.F32 s3,s27
002776  eeb01a6d          VMOV.F32 s2,s27
00277a  eef00a49          VMOV.F32 s1,s18
00277e  eeb00a49          VMOV.F32 s0,s18
002782  a862              ADD      r0,sp,#0x188
002784  9970              LDR      r1,[sp,#0x1c0]
002786  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
00278a  f50d7ec4          ADD      lr,sp,#0x188
00278e  990a              LDR      r1,[sp,#0x28]
002790  e8be1e4d          LDM      lr!,{r0,r2,r3,r6,r9-r12}
002794  e8811e4d          STM      r1,{r0,r2,r3,r6,r9-r12}
002798  986a              LDR      r0,[sp,#0x1a8]
00279a  6208              STR      r0,[r1,#0x20]
00279c  9500              STR      r5,[sp,#0]
00279e  edd42a1f          VLDR     s5,[r4,#0x7c]
0027a2  ed942a1e          VLDR     s4,[r4,#0x78]
0027a6  ab0b              ADD      r3,sp,#0x2c
0027a8  aa32              ADD      r2,sp,#0xc8
0027aa  eef01a6d          VMOV.F32 s3,s27
0027ae  eeb01a48          VMOV.F32 s2,s16
0027b2  eef00a49          VMOV.F32 s1,s18
0027b6  eeb00a4d          VMOV.F32 s0,s26
0027ba  a862              ADD      r0,sp,#0x188
0027bc  9970              LDR      r1,[sp,#0x1c0]
0027be  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
0027c2  f50d7ec4          ADD      lr,sp,#0x188
0027c6  e9ddb167          LDRD     r11,r1,[sp,#0x19c]
0027ca  e8be064c          LDM      lr!,{r2,r3,r6,r9,r10}
0027ce  9801              LDR      r0,[sp,#4]
0027d0  f8ddc1a4          LDR      r12,[sp,#0x1a4]
0027d4  ee3aeace          VSUB.F32 s28,s21,s28
0027d8  f8c0c01c          STR      r12,[r0,#0x1c]
0027dc  e9c0b105          STRD     r11,r1,[r0,#0x14]
0027e0  e880064c          STM      r0,{r2,r3,r6,r9,r10}
0027e4  996a              LDR      r1,[sp,#0x1a8]
0027e6  6201              STR      r1,[r0,#0x20]
0027e8  2001              MOVS     r0,#1
0027ea  9002              STR      r0,[sp,#8]
0027ec  ee79ea0a          VADD.F32 s29,s18,s20
0027f0  9804              LDR      r0,[sp,#0x10]
0027f2  2801              CMP      r0,#1
0027f4  dd7d              BLE      |L13.10482|
                  |L13.10230|
0027f6  9500              STR      r5,[sp,#0]
0027f8  edd42a1f          VLDR     s5,[r4,#0x7c]
0027fc  ed942a1e          VLDR     s4,[r4,#0x78]
002800  ab0b              ADD      r3,sp,#0x2c
002802  aa32              ADD      r2,sp,#0xc8
002804  eef01a48          VMOV.F32 s3,s16
002808  eeb01a6b          VMOV.F32 s2,s23
00280c  eef00a68          VMOV.F32 s1,s17
002810  eeb00a4e          VMOV.F32 s0,s28
002814  a862              ADD      r0,sp,#0x188
002816  9970              LDR      r1,[sp,#0x1c0]
002818  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
00281c  9802              LDR      r0,[sp,#8]
00281e  e9dd1262          LDRD     r1,r2,[sp,#0x188]
002822  eb0006c0          ADD      r6,r0,r0,LSL #3
002826  9809              LDR      r0,[sp,#0x24]
002828  e9dd3964          LDRD     r3,r9,[sp,#0x190]
00282c  e9ddab66          LDRD     r10,r11,[sp,#0x198]
002830  e9ddce68          LDRD     r12,lr,[sp,#0x1a0]
002834  eb000086          ADD      r0,r0,r6,LSL #2
002838  eef01a6d          VMOV.F32 s3,s27
00283c  e8805e0e          STM      r0,{r1-r3,r9-r12,lr}
002840  996a              LDR      r1,[sp,#0x1a8]
002842  6201              STR      r1,[r0,#0x20]
002844  9500              STR      r5,[sp,#0]
002846  edd42a1f          VLDR     s5,[r4,#0x7c]
00284a  ed942a1e          VLDR     s4,[r4,#0x78]
00284e  ab0b              ADD      r3,sp,#0x2c
002850  aa32              ADD      r2,sp,#0xc8
002852  eeb01a6b          VMOV.F32 s2,s23
002856  eef00a49          VMOV.F32 s1,s18
00285a  eeb00a6e          VMOV.F32 s0,s29
00285e  a862              ADD      r0,sp,#0x188
002860  9970              LDR      r1,[sp,#0x1c0]
002862  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002866  e9dd1262          LDRD     r1,r2,[sp,#0x188]
00286a  981d              LDR      r0,[sp,#0x74]
00286c  e9dd3964          LDRD     r3,r9,[sp,#0x190]
002870  e9ddab66          LDRD     r10,r11,[sp,#0x198]
002874  e9ddce68          LDRD     r12,lr,[sp,#0x1a0]
002878  eb000086          ADD      r0,r0,r6,LSL #2
00287c  eef01a48          VMOV.F32 s3,s16
002880  e8805e0e          STM      r0,{r1-r3,r9-r12,lr}
002884  996a              LDR      r1,[sp,#0x1a8]
002886  6201              STR      r1,[r0,#0x20]
002888  9500              STR      r5,[sp,#0]
00288a  edd42a1f          VLDR     s5,[r4,#0x7c]
00288e  ed942a1e          VLDR     s4,[r4,#0x78]
002892  ab0b              ADD      r3,sp,#0x2c
002894  aa32              ADD      r2,sp,#0xc8
002896  eeb01a6b          VMOV.F32 s2,s23
00289a  eef00a68          VMOV.F32 s1,s17
00289e  eeb10a4e          VNEG.F32 s0,s28
0028a2  a862              ADD      r0,sp,#0x188
0028a4  9970              LDR      r1,[sp,#0x1c0]
0028a6  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
0028aa  9807              LDR      r0,[sp,#0x1c]
0028ac  e9dd1262          LDRD     r1,r2,[sp,#0x188]
0028b0  e9dd3964          LDRD     r3,r9,[sp,#0x190]
0028b4  e9ddab66          LDRD     r10,r11,[sp,#0x198]
0028b8  e9ddce68          LDRD     r12,lr,[sp,#0x1a0]
0028bc  eb000086          ADD      r0,r0,r6,LSL #2
0028c0  eef01a6d          VMOV.F32 s3,s27
0028c4  e8805e0e          STM      r0,{r1-r3,r9-r12,lr}
0028c8  996a              LDR      r1,[sp,#0x1a8]
0028ca  6201              STR      r1,[r0,#0x20]
0028cc  9500              STR      r5,[sp,#0]
0028ce  edd42a1f          VLDR     s5,[r4,#0x7c]
0028d2  ed942a1e          VLDR     s4,[r4,#0x78]
0028d6  ab0b              ADD      r3,sp,#0x2c
0028d8  aa32              ADD      r2,sp,#0xc8
0028da  eeb01a6b          VMOV.F32 s2,s23
0028de  eef00a49          VMOV.F32 s1,s18
0028e2  eeb10a6e          VNEG.F32 s0,s29
0028e6  a862              ADD      r0,sp,#0x188
0028e8  9970              LDR      r1,[sp,#0x1c0]
0028ea  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
0028ee  9808              LDR      r0,[sp,#0x20]
0028f0  e000              B        |L13.10484|
                  |L13.10482|
0028f2  e09c              B        |L13.10798|
                  |L13.10484|
0028f4  e9dd1262          LDRD     r1,r2,[sp,#0x188]
0028f8  e9dd3964          LDRD     r3,r9,[sp,#0x190]
0028fc  e9ddab66          LDRD     r10,r11,[sp,#0x198]
002900  e9ddce68          LDRD     r12,lr,[sp,#0x1a0]
002904  eb000086          ADD      r0,r0,r6,LSL #2
002908  eef01a6b          VMOV.F32 s3,s23
00290c  e8805e0e          STM      r0,{r1-r3,r9-r12,lr}
002910  996a              LDR      r1,[sp,#0x1a8]
002912  6201              STR      r1,[r0,#0x20]
002914  9500              STR      r5,[sp,#0]
002916  edd42a1f          VLDR     s5,[r4,#0x7c]
00291a  ed942a1e          VLDR     s4,[r4,#0x78]
00291e  ab0b              ADD      r3,sp,#0x2c
002920  aa32              ADD      r2,sp,#0xc8
002922  eeb01a48          VMOV.F32 s2,s16
002926  eef00a4e          VMOV.F32 s1,s28
00292a  eeb00a68          VMOV.F32 s0,s17
00292e  a862              ADD      r0,sp,#0x188
002930  9970              LDR      r1,[sp,#0x1c0]
002932  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002936  e9dd1262          LDRD     r1,r2,[sp,#0x188]
00293a  9806              LDR      r0,[sp,#0x18]
00293c  e9dd3964          LDRD     r3,r9,[sp,#0x190]
002940  e9ddab66          LDRD     r10,r11,[sp,#0x198]
002944  e9ddce68          LDRD     r12,lr,[sp,#0x1a0]
002948  eb000086          ADD      r0,r0,r6,LSL #2
00294c  eef01a6b          VMOV.F32 s3,s23
002950  e8805e0e          STM      r0,{r1-r3,r9-r12,lr}
002954  996a              LDR      r1,[sp,#0x1a8]
002956  6201              STR      r1,[r0,#0x20]
002958  9500              STR      r5,[sp,#0]
00295a  edd42a1f          VLDR     s5,[r4,#0x7c]
00295e  ed942a1e          VLDR     s4,[r4,#0x78]
002962  ab0b              ADD      r3,sp,#0x2c
002964  aa32              ADD      r2,sp,#0xc8
002966  eeb01a6d          VMOV.F32 s2,s27
00296a  eef00a4e          VMOV.F32 s1,s28
00296e  eeb00a69          VMOV.F32 s0,s19
002972  a862              ADD      r0,sp,#0x188
002974  9970              LDR      r1,[sp,#0x1c0]
002976  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
00297a  e9dd1262          LDRD     r1,r2,[sp,#0x188]
00297e  9805              LDR      r0,[sp,#0x14]
002980  e9dd3964          LDRD     r3,r9,[sp,#0x190]
002984  e9ddab66          LDRD     r10,r11,[sp,#0x198]
002988  e9ddce68          LDRD     r12,lr,[sp,#0x1a0]
00298c  eb000086          ADD      r0,r0,r6,LSL #2
002990  eef01a6b          VMOV.F32 s3,s23
002994  e8805e0e          STM      r0,{r1-r3,r9-r12,lr}
002998  996a              LDR      r1,[sp,#0x1a8]
00299a  6201              STR      r1,[r0,#0x20]
00299c  9500              STR      r5,[sp,#0]
00299e  edd42a1f          VLDR     s5,[r4,#0x7c]
0029a2  ed942a1e          VLDR     s4,[r4,#0x78]
0029a6  ab0b              ADD      r3,sp,#0x2c
0029a8  aa32              ADD      r2,sp,#0xc8
0029aa  eeb01a6d          VMOV.F32 s2,s27
0029ae  eef00a6e          VMOV.F32 s1,s29
0029b2  eeb00a49          VMOV.F32 s0,s18
0029b6  a862              ADD      r0,sp,#0x188
0029b8  9970              LDR      r1,[sp,#0x1c0]
0029ba  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
0029be  e9dd1262          LDRD     r1,r2,[sp,#0x188]
0029c2  980a              LDR      r0,[sp,#0x28]
0029c4  e9dd3964          LDRD     r3,r9,[sp,#0x190]
0029c8  e9ddab66          LDRD     r10,r11,[sp,#0x198]
0029cc  e9ddce68          LDRD     r12,lr,[sp,#0x1a0]
0029d0  eb000086          ADD      r0,r0,r6,LSL #2
0029d4  eef01a6b          VMOV.F32 s3,s23
0029d8  e8805e0e          STM      r0,{r1-r3,r9-r12,lr}
0029dc  996a              LDR      r1,[sp,#0x1a8]
0029de  6201              STR      r1,[r0,#0x20]
0029e0  9500              STR      r5,[sp,#0]
0029e2  edd42a1f          VLDR     s5,[r4,#0x7c]
0029e6  ed942a1e          VLDR     s4,[r4,#0x78]
0029ea  ab0b              ADD      r3,sp,#0x2c
0029ec  aa32              ADD      r2,sp,#0xc8
0029ee  eeb01a48          VMOV.F32 s2,s16
0029f2  eef00a6e          VMOV.F32 s1,s29
0029f6  eeb00a4d          VMOV.F32 s0,s26
0029fa  a862              ADD      r0,sp,#0x188
0029fc  9970              LDR      r1,[sp,#0x1c0]
0029fe  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002a02  9801              LDR      r0,[sp,#4]
002a04  f50d7ec4          ADD      lr,sp,#0x188
002a08  eb000086          ADD      r0,r0,r6,LSL #2
002a0c  e8be1e4e          LDM      lr!,{r1-r3,r6,r9-r12}
002a10  e8801e4e          STM      r0,{r1-r3,r6,r9-r12}
002a14  996a              LDR      r1,[sp,#0x1a8]
002a16  6201              STR      r1,[r0,#0x20]
002a18  9802              LDR      r0,[sp,#8]
002a1a  ee3eea2a          VADD.F32 s28,s28,s21
002a1e  1c40              ADDS     r0,r0,#1
002a20  ee7eea8a          VADD.F32 s29,s29,s20
002a24  9903              LDR      r1,[sp,#0xc]
002a26  9002              STR      r0,[sp,#8]
002a28  4281              CMP      r1,r0
002a2a  f73faee4          BGT      |L13.10230|
                  |L13.10798|
002a2e  9500              STR      r5,[sp,#0]
002a30  edd42a1f          VLDR     s5,[r4,#0x7c]
002a34  ed942a1e          VLDR     s4,[r4,#0x78]
002a38  ab0b              ADD      r3,sp,#0x2c
002a3a  aa32              ADD      r2,sp,#0xc8
002a3c  eef01a6d          VMOV.F32 s3,s27
002a40  eeb01a48          VMOV.F32 s2,s16
002a44  eef00a49          VMOV.F32 s1,s18
002a48  eeb00a6e          VMOV.F32 s0,s29
002a4c  a862              ADD      r0,sp,#0x188
002a4e  9970              LDR      r1,[sp,#0x1c0]
002a50  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002a54  f50d7ec4          ADD      lr,sp,#0x188
002a58  981d              LDR      r0,[sp,#0x74]
002a5a  e8be1e4e          LDM      lr!,{r1-r3,r6,r9-r12}
002a5e  eb000088          ADD      r0,r0,r8,LSL #2
002a62  f1a00e24          SUB      lr,r0,#0x24
002a66  eef01a48          VMOV.F32 s3,s16
002a6a  e8ae1e4e          STM      lr!,{r1-r3,r6,r9-r12}
002a6e  996a              LDR      r1,[sp,#0x1a8]
002a70  f8401c04          STR      r1,[r0,#-4]
002a74  9500              STR      r5,[sp,#0]
002a76  edd42a1f          VLDR     s5,[r4,#0x7c]
002a7a  ed942a1e          VLDR     s4,[r4,#0x78]
002a7e  ab0b              ADD      r3,sp,#0x2c
002a80  aa32              ADD      r2,sp,#0xc8
002a82  eeb01a6d          VMOV.F32 s2,s27
002a86  eef00a68          VMOV.F32 s1,s17
002a8a  eeb00a4e          VMOV.F32 s0,s28
002a8e  a862              ADD      r0,sp,#0x188
002a90  9970              LDR      r1,[sp,#0x1c0]
002a92  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002a96  f50d7ec4          ADD      lr,sp,#0x188
002a9a  9809              LDR      r0,[sp,#0x24]
002a9c  e8be1e4e          LDM      lr!,{r1-r3,r6,r9-r12}
002aa0  eb000088          ADD      r0,r0,r8,LSL #2
002aa4  f1a00e24          SUB      lr,r0,#0x24
002aa8  eef01a6d          VMOV.F32 s3,s27
002aac  e8ae1e4e          STM      lr!,{r1-r3,r6,r9-r12}
002ab0  996a              LDR      r1,[sp,#0x1a8]
002ab2  f8401c04          STR      r1,[r0,#-4]
002ab6  9500              STR      r5,[sp,#0]
002ab8  edd42a1f          VLDR     s5,[r4,#0x7c]
002abc  ed942a1e          VLDR     s4,[r4,#0x78]
002ac0  ab0b              ADD      r3,sp,#0x2c
002ac2  aa32              ADD      r2,sp,#0xc8
002ac4  eeb01a48          VMOV.F32 s2,s16
002ac8  eef00a49          VMOV.F32 s1,s18
002acc  eeb10a6e          VNEG.F32 s0,s29
002ad0  a862              ADD      r0,sp,#0x188
002ad2  9970              LDR      r1,[sp,#0x1c0]
002ad4  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002ad8  f50d7ec4          ADD      lr,sp,#0x188
002adc  9808              LDR      r0,[sp,#0x20]
002ade  e8be1e4e          LDM      lr!,{r1-r3,r6,r9-r12}
002ae2  eb000088          ADD      r0,r0,r8,LSL #2
002ae6  f1a00e24          SUB      lr,r0,#0x24
002aea  eef01a48          VMOV.F32 s3,s16
002aee  e8ae1e4e          STM      lr!,{r1-r3,r6,r9-r12}
002af2  996a              LDR      r1,[sp,#0x1a8]
002af4  f8401c04          STR      r1,[r0,#-4]
002af8  9500              STR      r5,[sp,#0]
002afa  edd42a1f          VLDR     s5,[r4,#0x7c]
002afe  ed942a1e          VLDR     s4,[r4,#0x78]
002b02  ab0b              ADD      r3,sp,#0x2c
002b04  aa32              ADD      r2,sp,#0xc8
002b06  eeb01a6d          VMOV.F32 s2,s27
002b0a  eef00a68          VMOV.F32 s1,s17
002b0e  eeb10a4e          VNEG.F32 s0,s28
002b12  a862              ADD      r0,sp,#0x188
002b14  9970              LDR      r1,[sp,#0x1c0]
002b16  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002b1a  f50d7ec4          ADD      lr,sp,#0x188
002b1e  9807              LDR      r0,[sp,#0x1c]
002b20  e8be1e4e          LDM      lr!,{r1-r3,r6,r9-r12}
002b24  eb000088          ADD      r0,r0,r8,LSL #2
002b28  f1a00e24          SUB      lr,r0,#0x24
002b2c  eef01a6d          VMOV.F32 s3,s27
002b30  e8ae1e4e          STM      lr!,{r1-r3,r6,r9-r12}
002b34  996a              LDR      r1,[sp,#0x1a8]
002b36  f8401c04          STR      r1,[r0,#-4]
002b3a  9500              STR      r5,[sp,#0]
002b3c  edd42a1f          VLDR     s5,[r4,#0x7c]
002b40  ed942a1e          VLDR     s4,[r4,#0x78]
002b44  ab0b              ADD      r3,sp,#0x2c
002b46  aa32              ADD      r2,sp,#0xc8
002b48  eeb01a48          VMOV.F32 s2,s16
002b4c  eef00a4e          VMOV.F32 s1,s28
002b50  eeb00a68          VMOV.F32 s0,s17
002b54  a862              ADD      r0,sp,#0x188
002b56  9970              LDR      r1,[sp,#0x1c0]
002b58  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002b5c  f50d7ec4          ADD      lr,sp,#0x188
002b60  9806              LDR      r0,[sp,#0x18]
002b62  e8be1e4e          LDM      lr!,{r1-r3,r6,r9-r12}
002b66  eb000088          ADD      r0,r0,r8,LSL #2
002b6a  f1a00e24          SUB      lr,r0,#0x24
002b6e  eef01a6d          VMOV.F32 s3,s27
002b72  e8ae1e4e          STM      lr!,{r1-r3,r6,r9-r12}
002b76  996a              LDR      r1,[sp,#0x1a8]
002b78  f8401c04          STR      r1,[r0,#-4]
002b7c  9500              STR      r5,[sp,#0]
002b7e  edd42a1f          VLDR     s5,[r4,#0x7c]
002b82  ed942a1e          VLDR     s4,[r4,#0x78]
002b86  ab0b              ADD      r3,sp,#0x2c
002b88  aa32              ADD      r2,sp,#0xc8
002b8a  eeb01a6d          VMOV.F32 s2,s27
002b8e  eef00a4e          VMOV.F32 s1,s28
002b92  eeb00a69          VMOV.F32 s0,s19
002b96  a862              ADD      r0,sp,#0x188
002b98  9970              LDR      r1,[sp,#0x1c0]
002b9a  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002b9e  f50d7ec4          ADD      lr,sp,#0x188
002ba2  9805              LDR      r0,[sp,#0x14]
002ba4  e8be1e4e          LDM      lr!,{r1-r3,r6,r9-r12}
002ba8  eb000088          ADD      r0,r0,r8,LSL #2
002bac  f1a00e24          SUB      lr,r0,#0x24
002bb0  eef01a48          VMOV.F32 s3,s16
002bb4  e8ae1e4e          STM      lr!,{r1-r3,r6,r9-r12}
002bb8  996a              LDR      r1,[sp,#0x1a8]
002bba  f8401c04          STR      r1,[r0,#-4]
002bbe  9500              STR      r5,[sp,#0]
002bc0  edd42a1f          VLDR     s5,[r4,#0x7c]
002bc4  ed942a1e          VLDR     s4,[r4,#0x78]
002bc8  ab0b              ADD      r3,sp,#0x2c
002bca  aa32              ADD      r2,sp,#0xc8
002bcc  eeb01a6d          VMOV.F32 s2,s27
002bd0  eef00a6e          VMOV.F32 s1,s29
002bd4  eeb00a49          VMOV.F32 s0,s18
002bd8  a862              ADD      r0,sp,#0x188
002bda  9970              LDR      r1,[sp,#0x1c0]
002bdc  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002be0  f50d7ec4          ADD      lr,sp,#0x188
002be4  980a              LDR      r0,[sp,#0x28]
002be6  e8be1e4e          LDM      lr!,{r1-r3,r6,r9-r12}
002bea  eb000088          ADD      r0,r0,r8,LSL #2
002bee  f1a00e24          SUB      lr,r0,#0x24
002bf2  eef01a48          VMOV.F32 s3,s16
002bf6  e8ae1e4e          STM      lr!,{r1-r3,r6,r9-r12}
002bfa  996a              LDR      r1,[sp,#0x1a8]
002bfc  f8401c04          STR      r1,[r0,#-4]
002c00  9500              STR      r5,[sp,#0]
002c02  edd42a1f          VLDR     s5,[r4,#0x7c]
002c06  ed942a1e          VLDR     s4,[r4,#0x78]
002c0a  ab0b              ADD      r3,sp,#0x2c
002c0c  aa32              ADD      r2,sp,#0xc8
002c0e  eeb01a48          VMOV.F32 s2,s16
002c12  eef00a6e          VMOV.F32 s1,s29
002c16  eeb00a4d          VMOV.F32 s0,s26
002c1a  a802              ADD      r0,sp,#8
002c1c  9970              LDR      r1,[sp,#0x1c0]
002c1e  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
002c22  9801              LDR      r0,[sp,#4]
002c24  f10d0b08          ADD      r11,sp,#8
002c28  eb000088          ADD      r0,r0,r8,LSL #2
002c2c  e8bb174e          LDM      r11!,{r1-r3,r6,r8-r10,r12}
002c30  f1a00b24          SUB      r11,r0,#0x24
002c34  e8ab174e          STM      r11!,{r1-r3,r6,r8-r10,r12}
002c38  990a              LDR      r1,[sp,#0x28]
002c3a  f8401c04          STR      r1,[r0,#-4]
                  |L13.11326|
002c3e  2100              MOVS     r1,#0
002c40  4628              MOV      r0,r5
002c42  f7fffffe          BL       _ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b ; Anki::Embedded::Matrix::MakeSymmetric<Anki::Embedded::Array<float>>(T1&, bool)
002c46  f8dd0620          LDR      r0,[sp,#0x620]
002c4a  1c7f              ADDS     r7,r7,#1
002c4c  42b8              CMP      r0,r7
002c4e  f73daed5          BGT      |L13.2556|
                  |L13.11346|
002c52  f44f7180          MOV      r1,#0x100
002c56  f50470c2          ADD      r0,r4,#0x184
002c5a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::set_size(int)
002c5e  eeb00a69          VMOV.F32 s0,s19
002c62  eddf0abd          VLDR     s1,|L13.12120|
002c66  af0a              ADD      r7,sp,#0x28
002c68  ee80aa80          VDIV.F32 s20,s1,s0
002c6c  eef70a00          VMOV.F32 s1,#1.00000000
002c70  ee800a8a          VDIV.F32 s0,s1,s20
002c74  ed840a1d          VSTR     s0,[r4,#0x74]
002c78  f8dd064c          LDR      r0,[sp,#0x64c]
002c7c  2800              CMP      r0,#0
002c7e  dd7d              BLE      |L13.11644|
002c80  eeb11a00          VMOV.F32 s2,#4.00000000
002c84  eeb00a60          VMOV.F32 s0,s1
002c88  eef61a00          VMOV.F32 s3,#0.50000000
002c8c  ee0c0a41          VMLS.F32 s0,s24,s2
002c90  ee301acc          VSUB.F32 s2,s1,s24
002c94  2000              MOVS     r0,#0
002c96  900a              STR      r0,[sp,#0x28]
002c98  250c              MOVS     r5,#0xc
002c9a  ee211a21          VMUL.F32 s2,s2,s3
002c9e  ee698a80          VMUL.F32 s17,s19,s0
002ca2  ee200a21          VMUL.F32 s0,s0,s3
002ca6  a803              ADD      r0,sp,#0xc
002ca8  ee619a0b          VMUL.F32 s19,s2,s22
002cac  eeb01a08          VMOV.F32 s2,#3.00000000
002cb0  f8dd165c          LDR      r1,[sp,#0x65c]
002cb4  ee4c0a41          VMLS.F32 s1,s24,s2
002cb8  ee600aa1          VMUL.F32 s1,s1,s3
002cbc  ee60aa8b          VMUL.F32 s21,s1,s22
002cc0  ee20ba0b          VMUL.F32 s22,s0,s22
002cc4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
002cc8  eef10a69          VNEG.F32 s1,s19
002ccc  4606              MOV      r6,r0
002cce  eeb08a60          VMOV.F32 s16,s1
002cd2  2101              MOVS     r1,#1
002cd4  eeb09a60          VMOV.F32 s18,s1
002cd8  eeb00a48          VMOV.F32 s0,s16
002cdc  a87a              ADD      r0,sp,#0x1e8
002cde  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
002ce2  e9dd017a          LDRD     r0,r1,[sp,#0x1e8]
002ce6  e9cd0132          STRD     r0,r1,[sp,#0xc8]
002cea  9a7c              LDR      r2,[sp,#0x1f0]
002cec  9234              STR      r2,[sp,#0xd0]
002cee  2110              MOVS     r1,#0x10
002cf0  eef00a69          VMOV.F32 s1,s19
002cf4  eeb00a48          VMOV.F32 s0,s16
002cf8  a877              ADD      r0,sp,#0x1dc
002cfa  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
002cfe  e9dd0177          LDRD     r0,r1,[sp,#0x1dc]
002d02  9a79              LDR      r2,[sp,#0x1e4]
002d04  9065              STR      r0,[sp,#0x194]
002d06  e9cd1266          STRD     r1,r2,[sp,#0x198]
002d0a  e9cd7600          STRD     r7,r6,[sp,#0]
002d0e  eeb00a4a          VMOV.F32 s0,s20
002d12  ab32              ADD      r3,sp,#0xc8
002d14  aa65              ADD      r2,sp,#0x194
002d16  4620              MOV      r0,r4
002d18  f8dd1618          LDR      r1,[sp,#0x618]
002d1c  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof25CreateVerificationSamplesERKNS0_5ArrayIhEERKNS0_14LinearSequenceIfEESA_fRiNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::CreateVerificationSamples(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::LinearSequence<float>&, const Anki::Embedded::LinearSequence<float>&, float, int&, Anki::Embedded::MemoryStack)
002d20  b178              CBZ      r0,|L13.11586|
002d22  498e              LDR      r1,|L13.12124|
002d24  f24032a3          MOV      r2,#0x3a3
002d28  9100              STR      r1,[sp,#0]
002d2a  e9cd2001          STRD     r2,r0,[sp,#4]
002d2e  f5016204          ADD      r2,r1,#0x840
002d32  4b8b              LDR      r3,|L13.12128|
002d34  f20171f4          ADD      r1,r1,#0x7f4
002d38  2005              MOVS     r0,#5
002d3a  f7fffffe          BL       _Anki_Log
002d3e  f7feb968          B        |L13.4114|
                  |L13.11586|
002d42  a803              ADD      r0,sp,#0xc
002d44  f8dd165c          LDR      r1,[sp,#0x65c]
002d48  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
002d4c  eeb10a6a          VNEG.F32 s0,s21
002d50  4606              MOV      r6,r0
002d52  210e              MOVS     r1,#0xe
002d54  eef00a6b          VMOV.F32 s1,s23
002d58  eeb08a40          VMOV.F32 s16,s0
002d5c  a87a              ADD      r0,sp,#0x1e8
002d5e  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
002d62  e9dd017a          LDRD     r0,r1,[sp,#0x1e8]
002d66  9a7c              LDR      r2,[sp,#0x1f0]
002d68  9237              STR      r2,[sp,#0xdc]
002d6a  e9cd0135          STRD     r0,r1,[sp,#0xd4]
002d6e  2102              MOVS     r1,#2
002d70  eef00a69          VMOV.F32 s1,s19
002d74  eeb00a49          VMOV.F32 s0,s18
002d78  a877              ADD      r0,sp,#0x1dc
002d7a  e000              B        |L13.11646|
                  |L13.11644|
002d7c  e09f              B        |L13.11966|
                  |L13.11646|
002d7e  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
002d82  e9dd0177          LDRD     r0,r1,[sp,#0x1dc]
002d86  9a79              LDR      r2,[sp,#0x1e4]
002d88  9068              STR      r0,[sp,#0x1a0]
002d8a  e9cd1269          STRD     r1,r2,[sp,#0x1a4]
002d8e  e9cd7600          STRD     r7,r6,[sp,#0]
002d92  eeb00a4a          VMOV.F32 s0,s20
002d96  ab35              ADD      r3,sp,#0xd4
002d98  aa68              ADD      r2,sp,#0x1a0
002d9a  4620              MOV      r0,r4
002d9c  f8dd1618          LDR      r1,[sp,#0x618]
002da0  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof25CreateVerificationSamplesERKNS0_5ArrayIhEERKNS0_14LinearSequenceIfEESA_fRiNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::CreateVerificationSamples(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::LinearSequence<float>&, const Anki::Embedded::LinearSequence<float>&, float, int&, Anki::Embedded::MemoryStack)
002da4  b178              CBZ      r0,|L13.11718|
002da6  496d              LDR      r1,|L13.12124|
002da8  f24032b3          MOV      r2,#0x3b3
002dac  9100              STR      r1,[sp,#0]
002dae  e9cd2001          STRD     r2,r0,[sp,#4]
002db2  f601028c          ADD      r2,r1,#0x88c
002db6  4b6a              LDR      r3,|L13.12128|
002db8  f20171f4          ADD      r1,r1,#0x7f4
002dbc  2005              MOVS     r0,#5
002dbe  f7fffffe          BL       _Anki_Log
002dc2  f7feb926          B        |L13.4114|
                  |L13.11718|
002dc6  a803              ADD      r0,sp,#0xc
002dc8  f8dd165c          LDR      r1,[sp,#0x65c]
002dcc  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
002dd0  4606              MOV      r6,r0
002dd2  2101              MOVS     r1,#1
002dd4  eef00a48          VMOV.F32 s1,s16
002dd8  eeb00a48          VMOV.F32 s0,s16
002ddc  a87a              ADD      r0,sp,#0x1e8
002dde  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
002de2  e9dd017a          LDRD     r0,r1,[sp,#0x1e8]
002de6  9a7c              LDR      r2,[sp,#0x1f0]
002de8  9273              STR      r2,[sp,#0x1cc]
002dea  e9cd0171          STRD     r0,r1,[sp,#0x1c4]
002dee  210e              MOVS     r1,#0xe
002df0  eef00a6a          VMOV.F32 s1,s21
002df4  eeb00a48          VMOV.F32 s0,s16
002df8  a877              ADD      r0,sp,#0x1dc
002dfa  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
002dfe  e9dd0177          LDRD     r0,r1,[sp,#0x1dc]
002e02  9a79              LDR      r2,[sp,#0x1e4]
002e04  906e              STR      r0,[sp,#0x1b8]
002e06  e9cd126f          STRD     r1,r2,[sp,#0x1bc]
002e0a  e9cd7600          STRD     r7,r6,[sp,#0]
002e0e  eeb00a4a          VMOV.F32 s0,s20
002e12  ab71              ADD      r3,sp,#0x1c4
002e14  aa6e              ADD      r2,sp,#0x1b8
002e16  4620              MOV      r0,r4
002e18  f8dd1618          LDR      r1,[sp,#0x618]
002e1c  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof25CreateVerificationSamplesERKNS0_5ArrayIhEERKNS0_14LinearSequenceIfEESA_fRiNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::CreateVerificationSamples(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::LinearSequence<float>&, const Anki::Embedded::LinearSequence<float>&, float, int&, Anki::Embedded::MemoryStack)
002e20  b178              CBZ      r0,|L13.11842|
002e22  494e              LDR      r1,|L13.12124|
002e24  f24032c3          MOV      r2,#0x3c3
002e28  9100              STR      r1,[sp,#0]
002e2a  e9cd2001          STRD     r2,r0,[sp,#4]
002e2e  f60102d8          ADD      r2,r1,#0x8d8
002e32  4b4b              LDR      r3,|L13.12128|
002e34  f20171f4          ADD      r1,r1,#0x7f4
002e38  2005              MOVS     r0,#5
002e3a  f7fffffe          BL       _Anki_Log
002e3e  f7feb8e8          B        |L13.4114|
                  |L13.11842|
002e42  a803              ADD      r0,sp,#0xc
002e44  f8dd165c          LDR      r1,[sp,#0x65c]
002e48  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
002e4c  4606              MOV      r6,r0
002e4e  210f              MOVS     r1,#0xf
002e50  eef00a6b          VMOV.F32 s1,s23
002e54  eeb10a4b          VNEG.F32 s0,s22
002e58  a87a              ADD      r0,sp,#0x1e8
002e5a  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
002e5e  e9dd017a          LDRD     r0,r1,[sp,#0x1e8]
002e62  e9cd016b          STRD     r0,r1,[sp,#0x1ac]
002e66  9a7c              LDR      r2,[sp,#0x1f0]
002e68  926d              STR      r2,[sp,#0x1b4]
002e6a  2102              MOVS     r1,#2
002e6c  eef00a6a          VMOV.F32 s1,s21
002e70  eeb00a48          VMOV.F32 s0,s16
002e74  a877              ADD      r0,sp,#0x1dc
002e76  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
002e7a  e9dd0177          LDRD     r0,r1,[sp,#0x1dc]
002e7e  9a79              LDR      r2,[sp,#0x1e4]
002e80  9074              STR      r0,[sp,#0x1d0]
002e82  e9cd1275          STRD     r1,r2,[sp,#0x1d4]
002e86  e9cd7600          STRD     r7,r6,[sp,#0]
002e8a  eeb00a4a          VMOV.F32 s0,s20
002e8e  ab6b              ADD      r3,sp,#0x1ac
002e90  aa74              ADD      r2,sp,#0x1d0
002e92  4620              MOV      r0,r4
002e94  f8dd1618          LDR      r1,[sp,#0x618]
002e98  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof25CreateVerificationSamplesERKNS0_5ArrayIhEERKNS0_14LinearSequenceIfEESA_fRiNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::CreateVerificationSamples(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::LinearSequence<float>&, const Anki::Embedded::LinearSequence<float>&, float, int&, Anki::Embedded::MemoryStack)
002e9c  b1a0              CBZ      r0,|L13.11976|
002e9e  492f              LDR      r1,|L13.12124|
002ea0  f24032d3          MOV      r2,#0x3d3
002ea4  9100              STR      r1,[sp,#0]
002ea6  e9cd2001          STRD     r2,r0,[sp,#4]
002eaa  f5016212          ADD      r2,r1,#0x920
002eae  4b2c              LDR      r3,|L13.12128|
002eb0  f20171f4          ADD      r1,r1,#0x7f4
002eb4  2005              MOVS     r0,#5
002eb6  f7fffffe          BL       _Anki_Log
002eba  f7feb8aa          B        |L13.4114|
                  |L13.11966|
002ebe  ee6c8aa9          VMUL.F32 s17,s25,s19
002ec2  2510              MOVS     r5,#0x10
002ec4  2000              MOVS     r0,#0
002ec6  900a              STR      r0,[sp,#0x28]
                  |L13.11976|
002ec8  a87d              ADD      r0,sp,#0x1f4
002eca  f8dd165c          LDR      r1,[sp,#0x65c]
002ece  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
002ed2  eeb10a68          VNEG.F32 s0,s17
002ed6  4606              MOV      r6,r0
002ed8  4629              MOV      r1,r5
002eda  eef00a6b          VMOV.F32 s1,s23
002ede  eeb08a40          VMOV.F32 s16,s0
002ee2  a805              ADD      r0,sp,#0x14
002ee4  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
002ee8  e9dd0105          LDRD     r0,r1,[sp,#0x14]
002eec  9a07              LDR      r2,[sp,#0x1c]
002eee  9264              STR      r2,[sp,#0x190]
002ef0  e9cd0162          STRD     r0,r1,[sp,#0x188]
002ef4  4629              MOV      r1,r5
002ef6  eef00a68          VMOV.F32 s1,s17
002efa  eeb00a48          VMOV.F32 s0,s16
002efe  a802              ADD      r0,sp,#8
002f00  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
002f04  e9dd0102          LDRD     r0,r1,[sp,#8]
002f08  9a04              LDR      r2,[sp,#0x10]
002f0a  9038              STR      r0,[sp,#0xe0]
002f0c  e9cd1239          STRD     r1,r2,[sp,#0xe4]
002f10  e9cd7600          STRD     r7,r6,[sp,#0]
002f14  eeb00a4a          VMOV.F32 s0,s20
002f18  ab62              ADD      r3,sp,#0x188
002f1a  aa38              ADD      r2,sp,#0xe0
002f1c  4620              MOV      r0,r4
002f1e  f8dd1618          LDR      r1,[sp,#0x618]
002f22  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof25CreateVerificationSamplesERKNS0_5ArrayIhEERKNS0_14LinearSequenceIfEESA_fRiNS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::CreateVerificationSamples(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::LinearSequence<float>&, const Anki::Embedded::LinearSequence<float>&, float, int&, Anki::Embedded::MemoryStack)
002f26  b170              CBZ      r0,|L13.12102|
002f28  490c              LDR      r1,|L13.12124|
002f2a  9100              STR      r1,[sp,#0]
002f2c  f24032e9          MOV      r2,#0x3e9
002f30  e9cd2001          STRD     r2,r0,[sp,#4]
002f34  4b0a              LDR      r3,|L13.12128|
002f36  a20b              ADR      r2,|L13.12132|
002f38  f20171f4          ADD      r1,r1,#0x7f4
002f3c  2005              MOVS     r0,#5
002f3e  f7fffffe          BL       _Anki_Log
002f42  f7feb866          B        |L13.4114|
                  |L13.12102|
002f46  2001              MOVS     r0,#1
002f48  f8840070          STRB     r0,[r4,#0x70]
002f4c  4811              LDR      r0,|L13.12180|
002f4e  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
002f52  f7feb85e          B        |L13.4114|
                          ENDP

002f56  0000              DCW      0x0000
                  |L13.12120|
002f58  42fe0000          DCFS     0x42fe0000 ; 127
                  |L13.12124|
                          DCD      ||.constdata||
                  |L13.12128|
                          DCD      ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfiNS0_15Transformations13TransformTypeEifiifffffNS0_11MemoryStackERSD_SD_||+0x458
                  |L13.12132|
002f64  43726561          DCB      "CreateVerificationSamples failed with code 0x%x",0
002f68  74655665
002f6c  72696669
002f70  63617469
002f74  6f6e5361
002f78  6d706c65
002f7c  73206661
002f80  696c6564
002f84  20776974
002f88  6820636f
002f8c  64652030
002f90  78257800
                  |L13.12180|
                          DCD      ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfiNS0_15Transformations13TransformTypeEifiifffffNS0_11MemoryStackERSD_SD_||+0x97c

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1Ev||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC2Ev                  ; Alternate entry point ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof__sub_object()
                  _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1Ev PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof()
;;;50         {
;;;51           LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof()
;;;52             : LucasKanadeTracker_Generic(maxSupportedTransformType)
;;;53           {
;;;54           }
;;;55     
000000  b570              PUSH     {r4-r6,lr}
000002  8801              LDRH     r1,[r0,#0]
000004  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker26LucasKanadeTracker_GenericC1ENS0_15Transformations13TransformTypeE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_Generic::LucasKanadeTracker_Generic(Anki::Embedded::Transformations::TransformType)
000008  30a8              ADDS     r0,r0,#0xa8
00000a  ed9f0a2c          VLDR     s0,|L14.188|
00000e  ed800a00          VSTR     s0,[r0,#0]
000012  ed800a01          VSTR     s0,[r0,#4]
000016  ed800a02          VSTR     s0,[r0,#8]
00001a  300c              ADDS     r0,r0,#0xc
00001c  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
000020  300c              ADDS     r0,r0,#0xc
000022  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
000026  3018              ADDS     r0,r0,#0x18
000028  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00002c  f04f34ff          MOV      r4,#0xffffffff
000030  f8404d0c          STR      r4,[r0,#-0xc]!
000034  2500              MOVS     r5,#0
000036  6044              STR      r4,[r0,#4]
000038  6105              STR      r5,[r0,#0x10]
00003a  6145              STR      r5,[r0,#0x14]
00003c  6185              STR      r5,[r0,#0x18]
00003e  f1a00618          SUB      r6,r0,#0x18
000042  6084              STR      r4,[r0,#8]
000044  4629              MOV      r1,r5
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS1_INS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::set_size(int)
00004c  f1060034          ADD      r0,r6,#0x34
000050  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
000054  300c              ADDS     r0,r0,#0xc
000056  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
00005a  3018              ADDS     r0,r0,#0x18
00005c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000060  f8404d0c          STR      r4,[r0,#-0xc]!
000064  f1a00618          SUB      r6,r0,#0x18
000068  6044              STR      r4,[r0,#4]
00006a  6105              STR      r5,[r0,#0x10]
00006c  6145              STR      r5,[r0,#0x14]
00006e  6185              STR      r5,[r0,#0x18]
000070  6084              STR      r4,[r0,#8]
000072  2100              MOVS     r1,#0
000074  4630              MOV      r0,r6
000076  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Array<float>>::set_size(int)
00007a  f1060034          ADD      r0,r6,#0x34
00007e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIfEC1Ev ; Anki::Embedded::FixedLengthList<float>::FixedLengthList()
000082  3034              ADDS     r0,r0,#0x34
000084  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIfEC1Ev ; Anki::Embedded::FixedLengthList<float>::FixedLengthList()
000088  3034              ADDS     r0,r0,#0x34
00008a  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
00008e  300c              ADDS     r0,r0,#0xc
000090  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
000094  3018              ADDS     r0,r0,#0x18
000096  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00009a  f8404d0c          STR      r4,[r0,#-0xc]!
00009e  2100              MOVS     r1,#0
0000a0  6044              STR      r4,[r0,#4]
0000a2  6105              STR      r5,[r0,#0x10]
0000a4  6084              STR      r4,[r0,#8]
0000a6  6145              STR      r5,[r0,#0x14]
0000a8  f1a00418          SUB      r4,r0,#0x18
0000ac  6185              STR      r5,[r0,#0x18]
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::set_size(int)
0000b4  f5a470c2          SUB      r0,r4,#0x184
0000b8  bd70              POP      {r4-r6,pc}
                          ENDP

0000ba  0000              DCW      0x0000
                  |L14.188|
0000bc  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleXEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleXEv PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleX() const
;;;1148   
;;;1149         const f32& LucasKanadeTracker_SampledPlanar6dof::get_angleX() const
000000  309c              ADDS     r0,r0,#0x9c
;;;1150         {
;;;1151           return this->params6DoF.angle_x;
;;;1152         }
000002  4770              BX       lr
;;;1153   
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleYEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleYEv PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleY() const
;;;1153   
;;;1154         const f32& LucasKanadeTracker_SampledPlanar6dof::get_angleY() const
000000  30a0              ADDS     r0,r0,#0xa0
;;;1155         {
;;;1156           return this->params6DoF.angle_y;
;;;1157         }
000002  4770              BX       lr
;;;1158   
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleZEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleZEv PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleZ() const
;;;1158   
;;;1159         const f32& LucasKanadeTracker_SampledPlanar6dof::get_angleZ() const
000000  30a4              ADDS     r0,r0,#0xa4
;;;1160         {
;;;1161           return this->params6DoF.angle_z;
;;;1162         }
000002  4770              BX       lr
;;;1163   
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12ShowTemplateEPKcbb||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12ShowTemplateEPKcbb PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::ShowTemplate(const char*, bool, bool) const
;;;1201   
;;;1202         Result LucasKanadeTracker_SampledPlanar6dof::ShowTemplate(const char * windowName, const bool waitForKeypress, const bool fitImageToWindow) const
000000  2001              MOVS     r0,#1
;;;1203         {
;;;1204   #if !ANKICORETECH_EMBEDDED_USE_OPENCV
;;;1205           return RESULT_FAIL;
;;;1206   #else
;;;1207           //if(!this->IsValid())
;;;1208           //  return RESULT_FAIL;
;;;1209   
;;;1210           const s32 scratchSize = 10000000;
;;;1211           MemoryStack scratch(malloc(scratchSize), scratchSize);
;;;1212   
;;;1213           Array<u8> image(this->templateImageHeight, this->templateImageWidth, scratch);
;;;1214   
;;;1215           const Point<f32> centerOffset = this->transformation.get_centerOffset(1.0f);
;;;1216   
;;;1217           for(s32 iScale=0; iScale<numPyramidLevels; iScale++) {
;;;1218             const s32 numSamples = this->templateSamplePyramid[iScale].get_size();
;;;1219   
;;;1220             image.SetZero();
;;;1221   
;;;1222             const TemplateSample * restrict pTemplateSample = this->templateSamplePyramid[iScale].Pointer(0);
;;;1223   
;;;1224             for(s32 iSample=0; iSample<numSamples; iSample++) {
;;;1225               const TemplateSample curTemplateSample = pTemplateSample[iSample];
;;;1226   
;;;1227               const s32 curY = Round<s32>(curTemplateSample.yCoordinate + centerOffset.y);
;;;1228               const s32 curX = Round<s32>(curTemplateSample.xCoordinate + centerOffset.x);
;;;1229   
;;;1230               if(curX >= 0 && curY >= 0 && curX < this->templateImageWidth && curY < this->templateImageHeight) {
;;;1231                 image[curY][curX] = 255;
;;;1232               }
;;;1233             }
;;;1234   
;;;1235             char windowNameTotal[128];
;;;1236             snprintf(windowNameTotal, 128, "%s %d", windowName, iScale);
;;;1237   
;;;1238             if(fitImageToWindow) {
;;;1239               cv::namedWindow(windowNameTotal, CV_WINDOW_NORMAL);
;;;1240             } else {
;;;1241               cv::namedWindow(windowNameTotal, CV_WINDOW_AUTOSIZE);
;;;1242             }
;;;1243   
;;;1244             cv::Mat_<u8> image_cvMat;
;;;1245             ArrayToCvMat(image, &image_cvMat);
;;;1246             cv::imshow(windowNameTotal, image_cvMat);
;;;1247           }
;;;1248   
;;;1249           if(waitForKeypress)
;;;1250             cv::waitKey();
;;;1251   
;;;1252           return RESULT_OK;
;;;1253   #endif // #if !ANKICORETECH_EMBEDDED_USE_OPENCV
;;;1254         }
000002  4770              BX       lr
;;;1255   
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetCurrentGainEv||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetCurrentGainEv PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetCurrentGain() const
;;;1378   
;;;1379         f32 LucasKanadeTracker_SampledPlanar6dof::GetCurrentGain() const
000000  f8901098          LDRB     r1,[r0,#0x98]
;;;1380         {
;;;1381           if(this->useGainScheduling) {
000004  2900              CMP      r1,#0
;;;1382             f32 Kp;
;;;1383             if(this->params6DoF.translation.z <= this->tz_min) {
;;;1384               Kp = this->Kp_min;
;;;1385             }
;;;1386             else if(this->params6DoF.translation.z >= this->tz_max) {
;;;1387               Kp = this->Kp_max;
;;;1388             }
;;;1389             else {
;;;1390               Kp = (this->params6DoF.translation.z - this->tz_min)/(this->tz_max-this->tz_min)*(this->Kp_max-this->Kp_min) + this->Kp_min;
;;;1391             }
;;;1392   
;;;1393             AnkiAssert(Kp >= this->Kp_min && Kp <= this->Kp_max);
;;;1394             return Kp;
;;;1395           } else {
;;;1396             // TODO: make this a parameter
;;;1397             return 0.25f;
000006  bf04              ITT      EQ
000008  ed9f0a13          VLDREQ   s0,|L19.88|
;;;1398           }
;;;1399         }
00000c  4770              BXEQ     lr
00000e  edd00a2c          VLDR     s1,[r0,#0xb0]         ;1383
000012  ed900a24          VLDR     s0,[r0,#0x90]         ;1383
000016  eef40ac0          VCMPE.F32 s1,s0                 ;1383
00001a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1383
00001e  bf9c              ITT      LS                    ;1384
000020  ed900a22          VLDRLS   s0,[r0,#0x88]         ;1384
000024  4770              BXLS     lr
000026  ed901a25          VLDR     s2,[r0,#0x94]         ;1386
00002a  eef40ac1          VCMPE.F32 s1,s2                 ;1386
00002e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1386
000032  bfa4              ITT      GE                    ;1387
000034  ed900a23          VLDRGE   s0,[r0,#0x8c]         ;1387
000038  4770              BXGE     lr
00003a  ee701ac0          VSUB.F32 s3,s1,s0              ;1390
00003e  ee310a40          VSUB.F32 s0,s2,s0              ;1390
000042  ed901a23          VLDR     s2,[r0,#0x8c]         ;1390
000046  eec10a80          VDIV.F32 s1,s3,s0              ;1390
00004a  ed900a22          VLDR     s0,[r0,#0x88]         ;1390
00004e  ee311a40          VSUB.F32 s2,s2,s0              ;1390
000052  ee000a81          VMLA.F32 s0,s1,s2              ;1390
000056  4770              BX       lr
;;;1400   
                          ENDP

                  |L19.88|
000058  3e800000          DCFS     0x3e800000 ; 0.25

                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetTranslation() const
;;;1143         // Retrieve/update the current translation estimates of the tracker
;;;1144         const Point3<f32>& LucasKanadeTracker_SampledPlanar6dof::GetTranslation() const
000000  30a8              ADDS     r0,r0,#0xa8
;;;1145         {
;;;1146           return this->params6DoF.translation;
;;;1147         } // GetTranslation()
000002  4770              BX       lr
;;;1148   
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17GetRotationMatrixERNS0_5ArrayIfEEb||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17GetRotationMatrixERNS0_5ArrayIfEEb PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetRotationMatrix(Anki::Embedded::Array<float>&, bool) const
;;;1102         // R should already be allocated to be 3x3
;;;1103         Result LucasKanadeTracker_SampledPlanar6dof::GetRotationMatrix(Array<f32>& R,
000000  b570              PUSH     {r4-r6,lr}
;;;1104           bool skipLastColumn) const
;;;1105         {
000002  4605              MOV      r5,r0
000004  ed2d8b06          VPUSH    {d8-d10}
000008  b082              SUB      sp,sp,#8
00000a  4616              MOV      r6,r2
00000c  460c              MOV      r4,r1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000014  b158              CBZ      r0,|L21.46|
000016  2100              MOVS     r1,#0
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001e  2803              CMP      r0,#3
000020  d105              BNE      |L21.46|
000022  2101              MOVS     r1,#1
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00002a  2803              CMP      r0,#3
00002c  d010              BEQ      |L21.80|
                  |L21.46|
;;;1106           AnkiConditionalErrorAndReturnValue(AreEqualSize(3, 3, R), RESULT_FAIL_INVALID_SIZE,
00002e  f2404152          MOV      r1,#0x452
000032  4849              LDR      r0,|L21.344|
000034  e9cd0100          STRD     r0,r1,[sp,#0]
000038  a348              ADR      r3,|L21.348|
00003a  a258              ADR      r2,|L21.412|
00003c  a15e              ADR      r1,|L21.440|
00003e  2005              MOVS     r0,#5
000040  f7fffffe          BL       _Anki_Log
;;;1107             "LucasKanadeTracker_SampledPlanar6dof::GetRotationMatrix",
;;;1108             "R should be a 3x3 matrix.");
;;;1109   
;;;1110           const f32 cx = cosf(this->params6DoF.angle_x);
;;;1111           const f32 cy = cosf(this->params6DoF.angle_y);
;;;1112           const f32 cz = cosf(this->params6DoF.angle_z);
;;;1113           const f32 sx = sinf(this->params6DoF.angle_x);
;;;1114           const f32 sy = sinf(this->params6DoF.angle_y);
;;;1115           const f32 sz = sinf(this->params6DoF.angle_z);
;;;1116   
;;;1117           R[0][0] = cy*cz;
;;;1118           R[0][1] = cx*sz+sx*sy*cz;
;;;1119           R[1][0] = -cy*sz;
;;;1120           R[1][1] = cx*cz-sx*sy*sz;
;;;1121           R[2][0] = sy;
;;;1122           R[2][1] = -sx*cy;
;;;1123   
;;;1124           if(!skipLastColumn) {
;;;1125             R[0][2] = sx*sz-cx*sy*cz;
;;;1126             R[1][2] = sx*cz+cx*sy*sz;
;;;1127             R[2][2] = cx*cy;
;;;1128           }
;;;1129   
;;;1130           return RESULT_OK;
;;;1131         } // GetRotationMatrix()
000044  b002              ADD      sp,sp,#8
000046  f04f60a0          MOV      r0,#0x5000000         ;1106
00004a  ecbd8b06          VPOP     {d8-d10}
00004e  bd70              POP      {r4-r6,pc}
                  |L21.80|
000050  ed950a27          VLDR     s0,[r5,#0x9c]         ;1110
000054  f7fffffe          BL       __hardfp_cosf
000058  eef09a40          VMOV.F32 s19,s0                ;1110
00005c  ed950a28          VLDR     s0,[r5,#0xa0]         ;1111
000060  f7fffffe          BL       __hardfp_cosf
000064  eeb09a40          VMOV.F32 s18,s0                ;1111
000068  ed950a29          VLDR     s0,[r5,#0xa4]         ;1112
00006c  f7fffffe          BL       __hardfp_cosf
000070  eeb08a40          VMOV.F32 s16,s0                ;1112
000074  ed950a27          VLDR     s0,[r5,#0x9c]         ;1113
000078  f7fffffe          BL       __hardfp_sinf
00007c  eef08a40          VMOV.F32 s17,s0                ;1113
000080  ed950a28          VLDR     s0,[r5,#0xa0]         ;1114
000084  f7fffffe          BL       __hardfp_sinf
000088  eeb0aa40          VMOV.F32 s20,s0                ;1114
00008c  ed950a29          VLDR     s0,[r5,#0xa4]         ;1115
000090  f7fffffe          BL       __hardfp_sinf
000094  68a2              LDR      r2,[r4,#8]            ;1115
000096  6921              LDR      r1,[r4,#0x10]         ;1115
000098  2000              MOVS     r0,#0                 ;1117
00009a  fb001002          MLA      r0,r0,r2,r1           ;1117
00009e  ee690a08          VMUL.F32 s1,s18,s16            ;1117
0000a2  ee291a80          VMUL.F32 s2,s19,s0             ;1118
0000a6  edc00a00          VSTR     s1,[r0,#0]            ;1117
0000aa  ee680a8a          VMUL.F32 s1,s17,s20            ;1118
0000ae  68a2              LDR      r2,[r4,#8]            ;1118
0000b0  6921              LDR      r1,[r4,#0x10]         ;1118
0000b2  2000              MOVS     r0,#0                 ;1118
0000b4  ee001a88          VMLA.F32 s2,s1,s16             ;1118
0000b8  fb001002          MLA      r0,r0,r2,r1           ;1118
0000bc  ed801a01          VSTR     s2,[r0,#4]            ;1118
0000c0  68a2              LDR      r2,[r4,#8]            ;1118
0000c2  6921              LDR      r1,[r4,#0x10]         ;1118
0000c4  2001              MOVS     r0,#1                 ;1119
0000c6  fb001002          MLA      r0,r0,r2,r1           ;1119
0000ca  ee291a40          VNMUL.F32 s2,s18,s0             ;1119
0000ce  ed801a00          VSTR     s2,[r0,#0]            ;1119
0000d2  ee291a88          VMUL.F32 s2,s19,s16            ;1120
0000d6  68a2              LDR      r2,[r4,#8]            ;1120
0000d8  6921              LDR      r1,[r4,#0x10]         ;1120
0000da  2001              MOVS     r0,#1                 ;1120
0000dc  ee001ac0          VMLS.F32 s2,s1,s0              ;1120
0000e0  fb001002          MLA      r0,r0,r2,r1           ;1120
0000e4  ee680ac9          VNMUL.F32 s1,s17,s18            ;1122
0000e8  ed801a01          VSTR     s2,[r0,#4]            ;1120
0000ec  68a2              LDR      r2,[r4,#8]            ;1120
0000ee  6921              LDR      r1,[r4,#0x10]         ;1120
0000f0  2002              MOVS     r0,#2                 ;1121
0000f2  fb001002          MLA      r0,r0,r2,r1           ;1121
0000f6  ed80aa00          VSTR     s20,[r0,#0]           ;1121
0000fa  68a2              LDR      r2,[r4,#8]            ;1121
0000fc  6921              LDR      r1,[r4,#0x10]         ;1121
0000fe  2002              MOVS     r0,#2                 ;1122
000100  fb001002          MLA      r0,r0,r2,r1           ;1122
000104  edc00a01          VSTR     s1,[r0,#4]            ;1122
000108  bb06              CBNZ     r6,|L21.332|
00010a  ee281a80          VMUL.F32 s2,s17,s0             ;1125
00010e  ee690a8a          VMUL.F32 s1,s19,s20            ;1125
000112  68a2              LDR      r2,[r4,#8]            ;1125
000114  6921              LDR      r1,[r4,#0x10]         ;1125
000116  2000              MOVS     r0,#0                 ;1125
000118  ee001ac8          VMLS.F32 s2,s1,s16             ;1125
00011c  fb001002          MLA      r0,r0,r2,r1           ;1125
000120  ed801a02          VSTR     s2,[r0,#8]            ;1125
000124  ee281a88          VMUL.F32 s2,s17,s16            ;1126
000128  68a2              LDR      r2,[r4,#8]            ;1126
00012a  6921              LDR      r1,[r4,#0x10]         ;1126
00012c  2001              MOVS     r0,#1                 ;1126
00012e  ee001a80          VMLA.F32 s2,s1,s0              ;1126
000132  fb001002          MLA      r0,r0,r2,r1           ;1126
000136  ee290a89          VMUL.F32 s0,s19,s18            ;1127
00013a  ed801a02          VSTR     s2,[r0,#8]            ;1126
00013e  68a2              LDR      r2,[r4,#8]            ;1126
000140  6921              LDR      r1,[r4,#0x10]         ;1126
000142  2002              MOVS     r0,#2                 ;1127
000144  fb001002          MLA      r0,r0,r2,r1           ;1127
000148  ed800a02          VSTR     s0,[r0,#8]            ;1127
                  |L21.332|
00014c  b002              ADD      sp,sp,#8
00014e  2000              MOVS     r0,#0                 ;1130
000150  ecbd8b06          VPOP     {d8-d10}
000154  bd70              POP      {r4-r6,pc}
;;;1132   
                          ENDP

000156  0000              DCW      0x0000
                  |L21.344|
                          DCD      ||.constdata||+0x1b2
                  |L21.348|
00015c  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\lucasKanade_SampledPl"
000160  6f726574
000164  6563685c
000168  76697369
00016c  6f6e5c72
000170  6f626f74
000174  5c737263
000178  5c6c7563
00017c  61734b61
000180  6e616465
000184  5f53616d
000188  706c6564
00018c  506c    
00018e  616e6172          DCB      "anar6dof.cpp",0
000192  36646f66
000196  2e637070
00019a  00      
00019b  00                DCB      0
                  |L21.412|
00019c  52207368          DCB      "R should be a 3x3 matrix.",0
0001a0  6f756c64
0001a4  20626520
0001a8  61203378
0001ac  33206d61
0001b0  74726978
0001b4  2e00    
0001b6  00                DCB      0
0001b7  00                DCB      0
                  |L21.440|
0001b8  4c756361          DCB      "LucasKanadeTracker_SampledPlanar6dof::GetRotationMatrix"
0001bc  734b616e
0001c0  61646554
0001c4  7261636b
0001c8  65725f53
0001cc  616d706c
0001d0  6564506c
0001d4  616e6172
0001d8  36646f66
0001dc  3a3a4765
0001e0  74526f74
0001e4  6174696f
0001e8  6e4d6174
0001ec  726978  
0001ef  00                DCB      0

                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof19get_templateSamplesEi||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof19get_templateSamplesEi PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_templateSamples(int) const
;;;1091   
;;;1092         const FixedLengthList<LucasKanadeTracker_SampledPlanar6dof::TemplateSample>& LucasKanadeTracker_SampledPlanar6dof::get_templateSamples(const s32 atScale) const
000000  b530              PUSH     {r4,r5,lr}
;;;1093         {
000002  b083              SUB      sp,sp,#0xc
000004  1e0c              SUBS     r4,r1,#0
000006  4605              MOV      r5,r0
000008  db03              BLT      |L22.18|
;;;1094           AnkiConditionalError(atScale >=0 && atScale < this->templateSamplePyramid.get_size(),
00000a  f8d500c0          LDR      r0,[r5,#0xc0]
00000e  4284              CMP      r4,r0
000010  db0a              BLT      |L22.40|
                  |L22.18|
000012  f2404146          MOV      r1,#0x446
000016  4809              LDR      r0,|L22.60|
000018  e9cd0100          STRD     r0,r1,[sp,#0]
00001c  a308              ADR      r3,|L22.64|
00001e  a218              ADR      r2,|L22.128|
000020  a11f              ADR      r1,|L22.160|
000022  2005              MOVS     r0,#5
000024  f7fffffe          BL       _Anki_Log
                  |L22.40|
000028  eb040184          ADD      r1,r4,r4,LSL #2
00002c  f8d500e4          LDR      r0,[r5,#0xe4]
000030  eb0101c4          ADD      r1,r1,r4,LSL #3
;;;1095             "LucasKanadeTracker_SampledPlanar6dof::get_templateSamples()",
;;;1096             "Requested scale out of range.");
;;;1097   
;;;1098           return this->templateSamplePyramid[atScale];
;;;1099         }
000034  b003              ADD      sp,sp,#0xc
000036  eb000081          ADD      r0,r0,r1,LSL #2
00003a  bd30              POP      {r4,r5,pc}
;;;1100   
                          ENDP

                  |L22.60|
                          DCD      ||.constdata||+0x244
                  |L22.64|
000040  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\lucasKanade_SampledPl"
000044  6f726574
000048  6563685c
00004c  76697369
000050  6f6e5c72
000054  6f626f74
000058  5c737263
00005c  5c6c7563
000060  61734b61
000064  6e616465
000068  5f53616d
00006c  706c6564
000070  506c    
000072  616e6172          DCB      "anar6dof.cpp",0
000076  36646f66
00007a  2e637070
00007e  00      
00007f  00                DCB      0
                  |L22.128|
000080  52657175          DCB      "Requested scale out of range.",0
000084  65737465
000088  64207363
00008c  616c6520
000090  6f757420
000094  6f662072
000098  616e6765
00009c  2e00    
00009e  00                DCB      0
00009f  00                DCB      0
                  |L22.160|
0000a0  4c756361          DCB      "LucasKanadeTracker_SampledPlanar6dof::get_templateSampl"
0000a4  734b616e
0000a8  61646554
0000ac  7261636b
0000b0  65725f53
0000b4  616d706c
0000b8  6564506c
0000bc  616e6172
0000c0  36646f66
0000c4  3a3a6765
0000c8  745f7465
0000cc  6d706c61
0000d0  74655361
0000d4  6d706c  
0000d7  65732829          DCB      "es()",0
0000db  00      

                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof21get_numTemplatePixelsEi||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof21get_numTemplatePixelsEi PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_numTemplatePixels(int) const
;;;1265   
;;;1266         s32 LucasKanadeTracker_SampledPlanar6dof::get_numTemplatePixels(const s32 whichScale) const
000000  2900              CMP      r1,#0
;;;1267         {
;;;1268           if(whichScale < 0 || whichScale > this->numPyramidLevels)
000002  bfa7              ITTEE    GE
000004  6842              LDRGE    r2,[r0,#4]
000006  428a              CMPGE    r2,r1
;;;1269             return 0;
000008  2000              MOVLT    r0,#0
;;;1270   
;;;1271           return this->templateSamplePyramid[whichScale].get_size();
;;;1272         }
00000a  4770              BXLT     lr
00000c  f8d000e4          LDR      r0,[r0,#0xe4]
000010  eb010281          ADD      r2,r1,r1,LSL #2
000014  eb0201c1          ADD      r1,r2,r1,LSL #3
000018  eb000081          ADD      r0,r0,r1,LSL #2
00001c  68c0              LDR      r0,[r0,#0xc]
00001e  4770              BX       lr
;;;1273   
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof7IsValidEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof7IsValidEv PROC ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::IsValid() const
;;;1255   
;;;1256         bool LucasKanadeTracker_SampledPlanar6dof::IsValid() const
000000  b510              PUSH     {r4,lr}
;;;1257         {
;;;1258           if(!LucasKanadeTracker_Generic::IsValid())
000002  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker26LucasKanadeTracker_Generic7IsValidEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_Generic::IsValid() const
000006  2800              CMP      r0,#0
;;;1259             return false;
;;;1260   
;;;1261           // TODO: add more checks
;;;1262   
;;;1263           return true;
000008  bf18              IT       NE
00000a  2001              MOVNE    r0,#1
;;;1264         }
00000c  bd10              POP      {r4,pc}
;;;1265   
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1Ev||
                          DCD      0x00000001

                          AREA ||area_number.26||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof25CreateVerificationSamplesERKNS0_5ArrayIhEERKNS0_14LinearSequenceIfEESA_fRiNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.26||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof25CreateVerificationSamplesERKNS0_5ArrayIhEERKNS0_14LinearSequenceIfEESA_fRiNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.27||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17ApproximateSelectERKNS0_5ArrayIfEEiiiRiRNS3_IiEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.27||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17ApproximateSelectERKNS0_5ArrayIfEEiiiRiRNS3_IiEE||
                          DCD      0x00000001

                          AREA ||area_number.28||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof28set_rotationAnglesFromMatrixERKNS0_5ArrayIfEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof28set_rotationAnglesFromMatrixERKNS0_5ArrayIfEE||
                          DCD      0x00000001

                          AREA ||area_number.29||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfiNS0_15Transformations13TransformTypeEifiifffffNS0_11MemoryStackERSD_SD_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.29||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfiNS0_15Transformations13TransformTypeEifiifffffNS0_11MemoryStackERSD_SD_||
                          DCD      0x00000001

                          AREA ||area_number.30||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof22VerifyTrack_ProjectiveERKNS0_5ArrayIhEEhRiS7_S7_NS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.30||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof22VerifyTrack_ProjectiveERKNS0_5ArrayIhEEhRiS7_S7_NS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.31||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17GetRotationMatrixERNS0_5ArrayIfEEb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.31||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17GetRotationMatrixERNS0_5ArrayIfEEb||
                          DCD      0x00000001

                          AREA ||area_number.32||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof20UpdateTransformationENS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.32||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof20UpdateTransformationENS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.33||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetCurrentGainEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.33||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetCurrentGainEv||
                          DCD      0x00000001

                          AREA ||area_number.34||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof21get_numTemplatePixelsEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof21get_numTemplatePixelsEi||
                          DCD      0x00000001

                          AREA ||area_number.35||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof33IterativelyRefineTrack_ProjectiveERKNS0_5ArrayIhEEiiffRbNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.35||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof33IterativelyRefineTrack_ProjectiveERKNS0_5ArrayIhEEiiffRbNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.36||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof34IterativelyRefineTrack_TranslationERKNS0_5ArrayIhEEiifRbNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.36||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof34IterativelyRefineTrack_TranslationERKNS0_5ArrayIhEEiifRbNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.37||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof7IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.37||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof7IsValidEv||
                          DCD      0x00000001

                          AREA ||area_number.38||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof22IterativelyRefineTrackERKNS0_5ArrayIhEEiiffNS0_15Transformations13TransformTypeERbNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.38||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof22IterativelyRefineTrackERKNS0_5ArrayIhEEiiffNS0_15Transformations13TransformTypeERbNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.39||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof11UpdateTrackERKNS0_5ArrayIhEEiffhRbRiS8_S8_NS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof11UpdateTrackERKNS0_5ArrayIhEEiffhRbRiS8_S8_NS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.40||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof28UpdateRotationAndTranslationERKNS0_5ArrayIfEERKNS0_6Point3IfEENS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.40||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof28UpdateRotationAndTranslationERKNS0_5ArrayIfEERKNS0_6Point3IfEENS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.41||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv||
                          DCD      0x00000001

                          AREA ||area_number.42||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleXEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleXEv||
                          DCD      0x00000001

                          AREA ||area_number.43||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleYEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleYEv||
                          DCD      0x00000001

                          AREA ||area_number.44||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleZEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleZEv||
                          DCD      0x00000001

                          AREA ||area_number.45||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17SetGainSchedulingEffff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17SetGainSchedulingEffff||
                          DCD      0x00000001

                          AREA ||area_number.46||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12ShowTemplateEPKcbb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12ShowTemplateEPKcbb||
                          DCD      0x00000001

                          AREA ||area_number.47||, LINKORDER=||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof19get_templateSamplesEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof19get_templateSamplesEi||
                          DCD      0x00000001

                          AREA ||area_number.48||, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17ApproximateSelectERKNS0_5ArrayIfEEiiRiRNS3_IiEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.48||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17ApproximateSelectERKNS0_5ArrayIfEEiiRiRNS3_IiEE||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  __PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  54656d70          DCB      0x54,0x65,0x6d,0x70
000014  6c617465          DCB      0x6c,0x61,0x74,0x65
000018  54726163          DCB      0x54,0x72,0x61,0x63
00001c  6b65723a          DCB      0x6b,0x65,0x72,0x3a
000020  3a4c7563          DCB      0x3a,0x4c,0x75,0x63
000024  61734b61          DCB      0x61,0x73,0x4b,0x61
000028  6e616465          DCB      0x6e,0x61,0x64,0x65
00002c  54726163          DCB      0x54,0x72,0x61,0x63
000030  6b65725f          DCB      0x6b,0x65,0x72,0x5f
000034  53616d70          DCB      0x53,0x61,0x6d,0x70
000038  6c656450          DCB      0x6c,0x65,0x64,0x50
00003c  6c616e61          DCB      0x6c,0x61,0x6e,0x61
000040  7236646f          DCB      0x72,0x36,0x64,0x6f
000044  663a3a4c          DCB      0x66,0x3a,0x3a,0x4c
000048  75636173          DCB      0x75,0x63,0x61,0x73
00004c  4b616e61          DCB      0x4b,0x61,0x6e,0x61
000050  64655472          DCB      0x64,0x65,0x54,0x72
000054  61636b65          DCB      0x61,0x63,0x6b,0x65
000058  725f5361          DCB      0x72,0x5f,0x53,0x61
00005c  6d706c65          DCB      0x6d,0x70,0x6c,0x65
000060  64506c61          DCB      0x64,0x50,0x6c,0x61
000064  6e617236          DCB      0x6e,0x61,0x72,0x36
000068  646f6628          DCB      0x64,0x6f,0x66,0x28
00006c  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000070  7420416e          DCB      0x74,0x20,0x41,0x6e
000074  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000078  456d6265          DCB      0x45,0x6d,0x62,0x65
00007c  64646564          DCB      0x64,0x64,0x65,0x64
000080  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000084  7261793c          DCB      0x72,0x61,0x79,0x3c
000088  756e7369          DCB      0x75,0x6e,0x73,0x69
00008c  676e6564          DCB      0x67,0x6e,0x65,0x64
000090  20636861          DCB      0x20,0x63,0x68,0x61
000094  723e2026          DCB      0x72,0x3e,0x20,0x26
000098  2c20636f          DCB      0x2c,0x20,0x63,0x6f
00009c  6e737420          DCB      0x6e,0x73,0x74,0x20
0000a0  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000a4  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000a8  62656464          DCB      0x62,0x65,0x64,0x64
0000ac  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000b0  51756164          DCB      0x51,0x75,0x61,0x64
0000b4  72696c61          DCB      0x72,0x69,0x6c,0x61
0000b8  74657261          DCB      0x74,0x65,0x72,0x61
0000bc  6c3c666c          DCB      0x6c,0x3c,0x66,0x6c
0000c0  6f61743e          DCB      0x6f,0x61,0x74,0x3e
0000c4  20262c20          DCB      0x20,0x26,0x2c,0x20
0000c8  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000cc  742c2073          DCB      0x74,0x2c,0x20,0x73
0000d0  69676e65          DCB      0x69,0x67,0x6e,0x65
0000d4  6420696e          DCB      0x64,0x20,0x69,0x6e
0000d8  742c2041          DCB      0x74,0x2c,0x20,0x41
0000dc  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000e0  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000e4  65646465          DCB      0x65,0x64,0x64,0x65
0000e8  643a3a54          DCB      0x64,0x3a,0x3a,0x54
0000ec  72616e73          DCB      0x72,0x61,0x6e,0x73
0000f0  666f726d          DCB      0x66,0x6f,0x72,0x6d
0000f4  6174696f          DCB      0x61,0x74,0x69,0x6f
0000f8  6e733a3a          DCB      0x6e,0x73,0x3a,0x3a
0000fc  5472616e          DCB      0x54,0x72,0x61,0x6e
000100  73666f72          DCB      0x73,0x66,0x6f,0x72
000104  6d547970          DCB      0x6d,0x54,0x79,0x70
000108  652c2073          DCB      0x65,0x2c,0x20,0x73
00010c  69676e65          DCB      0x69,0x67,0x6e,0x65
000110  6420696e          DCB      0x64,0x20,0x69,0x6e
000114  742c2066          DCB      0x74,0x2c,0x20,0x66
000118  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
00011c  2c207369          DCB      0x2c,0x20,0x73,0x69
000120  676e6564          DCB      0x67,0x6e,0x65,0x64
000124  20696e74          DCB      0x20,0x69,0x6e,0x74
000128  2c207369          DCB      0x2c,0x20,0x73,0x69
00012c  676e6564          DCB      0x67,0x6e,0x65,0x64
000130  20696e74          DCB      0x20,0x69,0x6e,0x74
000134  2c20666c          DCB      0x2c,0x20,0x66,0x6c
000138  6f61742c          DCB      0x6f,0x61,0x74,0x2c
00013c  20666c6f          DCB      0x20,0x66,0x6c,0x6f
000140  61742c20          DCB      0x61,0x74,0x2c,0x20
000144  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000148  742c2066          DCB      0x74,0x2c,0x20,0x66
00014c  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000150  2c20666c          DCB      0x2c,0x20,0x66,0x6c
000154  6f61742c          DCB      0x6f,0x61,0x74,0x2c
000158  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00015c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000160  6d626564          DCB      0x6d,0x62,0x65,0x64
000164  6465643a          DCB      0x64,0x65,0x64,0x3a
000168  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00016c  6f727953          DCB      0x6f,0x72,0x79,0x53
000170  7461636b          DCB      0x74,0x61,0x63,0x6b
000174  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000178  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00017c  456d6265          DCB      0x45,0x6d,0x62,0x65
000180  64646564          DCB      0x64,0x64,0x65,0x64
000184  3a3a4d65          DCB      0x3a,0x3a,0x4d,0x65
000188  6d6f7279          DCB      0x6d,0x6f,0x72,0x79
00018c  53746163          DCB      0x53,0x74,0x61,0x63
000190  6b20262c          DCB      0x6b,0x20,0x26,0x2c
000194  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000198  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00019c  6d626564          DCB      0x6d,0x62,0x65,0x64
0001a0  6465643a          DCB      0x64,0x65,0x64,0x3a
0001a4  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
0001a8  6f727953          DCB      0x6f,0x72,0x79,0x53
0001ac  7461636b          DCB      0x74,0x61,0x63,0x6b
0001b0  2900              DCB      0x29,0x00
                  |symbol_number.243|
0001b2  416e              DCB      0x41,0x6e
0001b4  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0001b8  52657375          DCB      0x52,0x65,0x73,0x75
0001bc  6c742041          DCB      0x6c,0x74,0x20,0x41
0001c0  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0001c4  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0001c8  65646465          DCB      0x65,0x64,0x64,0x65
0001cc  643a3a54          DCB      0x64,0x3a,0x3a,0x54
0001d0  656d706c          DCB      0x65,0x6d,0x70,0x6c
0001d4  61746554          DCB      0x61,0x74,0x65,0x54
0001d8  7261636b          DCB      0x72,0x61,0x63,0x6b
0001dc  65723a3a          DCB      0x65,0x72,0x3a,0x3a
0001e0  4c756361          DCB      0x4c,0x75,0x63,0x61
0001e4  734b616e          DCB      0x73,0x4b,0x61,0x6e
0001e8  61646554          DCB      0x61,0x64,0x65,0x54
0001ec  7261636b          DCB      0x72,0x61,0x63,0x6b
0001f0  65725f53          DCB      0x65,0x72,0x5f,0x53
0001f4  616d706c          DCB      0x61,0x6d,0x70,0x6c
0001f8  6564506c          DCB      0x65,0x64,0x50,0x6c
0001fc  616e6172          DCB      0x61,0x6e,0x61,0x72
000200  36646f66          DCB      0x36,0x64,0x6f,0x66
000204  3a3a4765          DCB      0x3a,0x3a,0x47,0x65
000208  74526f74          DCB      0x74,0x52,0x6f,0x74
00020c  6174696f          DCB      0x61,0x74,0x69,0x6f
000210  6e4d6174          DCB      0x6e,0x4d,0x61,0x74
000214  72697828          DCB      0x72,0x69,0x78,0x28
000218  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00021c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000220  62656464          DCB      0x62,0x65,0x64,0x64
000224  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000228  41727261          DCB      0x41,0x72,0x72,0x61
00022c  793c666c          DCB      0x79,0x3c,0x66,0x6c
000230  6f61743e          DCB      0x6f,0x61,0x74,0x3e
000234  20262c20          DCB      0x20,0x26,0x2c,0x20
000238  626f6f6c          DCB      0x62,0x6f,0x6f,0x6c
00023c  2920636f          DCB      0x29,0x20,0x63,0x6f
000240  6e737400          DCB      0x6e,0x73,0x74,0x00
                  |symbol_number.244|
000244  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000248  7420416e          DCB      0x74,0x20,0x41,0x6e
00024c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000250  456d6265          DCB      0x45,0x6d,0x62,0x65
000254  64646564          DCB      0x64,0x64,0x65,0x64
000258  3a3a4669          DCB      0x3a,0x3a,0x46,0x69
00025c  7865644c          DCB      0x78,0x65,0x64,0x4c
000260  656e6774          DCB      0x65,0x6e,0x67,0x74
000264  684c6973          DCB      0x68,0x4c,0x69,0x73
000268  743c416e          DCB      0x74,0x3c,0x41,0x6e
00026c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000270  456d6265          DCB      0x45,0x6d,0x62,0x65
000274  64646564          DCB      0x64,0x64,0x65,0x64
000278  3a3a5465          DCB      0x3a,0x3a,0x54,0x65
00027c  6d706c61          DCB      0x6d,0x70,0x6c,0x61
000280  74655472          DCB      0x74,0x65,0x54,0x72
000284  61636b65          DCB      0x61,0x63,0x6b,0x65
000288  723a3a4c          DCB      0x72,0x3a,0x3a,0x4c
00028c  75636173          DCB      0x75,0x63,0x61,0x73
000290  4b616e61          DCB      0x4b,0x61,0x6e,0x61
000294  64655472          DCB      0x64,0x65,0x54,0x72
000298  61636b65          DCB      0x61,0x63,0x6b,0x65
00029c  725f5361          DCB      0x72,0x5f,0x53,0x61
0002a0  6d706c65          DCB      0x6d,0x70,0x6c,0x65
0002a4  64506c61          DCB      0x64,0x50,0x6c,0x61
0002a8  6e617236          DCB      0x6e,0x61,0x72,0x36
0002ac  646f663a          DCB      0x64,0x6f,0x66,0x3a
0002b0  3a54656d          DCB      0x3a,0x54,0x65,0x6d
0002b4  706c6174          DCB      0x70,0x6c,0x61,0x74
0002b8  6553616d          DCB      0x65,0x53,0x61,0x6d
0002bc  706c653e          DCB      0x70,0x6c,0x65,0x3e
0002c0  2026416e          DCB      0x20,0x26,0x41,0x6e
0002c4  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0002c8  456d6265          DCB      0x45,0x6d,0x62,0x65
0002cc  64646564          DCB      0x64,0x64,0x65,0x64
0002d0  3a3a5465          DCB      0x3a,0x3a,0x54,0x65
0002d4  6d706c61          DCB      0x6d,0x70,0x6c,0x61
0002d8  74655472          DCB      0x74,0x65,0x54,0x72
0002dc  61636b65          DCB      0x61,0x63,0x6b,0x65
0002e0  723a3a4c          DCB      0x72,0x3a,0x3a,0x4c
0002e4  75636173          DCB      0x75,0x63,0x61,0x73
0002e8  4b616e61          DCB      0x4b,0x61,0x6e,0x61
0002ec  64655472          DCB      0x64,0x65,0x54,0x72
0002f0  61636b65          DCB      0x61,0x63,0x6b,0x65
0002f4  725f5361          DCB      0x72,0x5f,0x53,0x61
0002f8  6d706c65          DCB      0x6d,0x70,0x6c,0x65
0002fc  64506c61          DCB      0x64,0x50,0x6c,0x61
000300  6e617236          DCB      0x6e,0x61,0x72,0x36
000304  646f663a          DCB      0x64,0x6f,0x66,0x3a
000308  3a676574          DCB      0x3a,0x67,0x65,0x74
00030c  5f74656d          DCB      0x5f,0x74,0x65,0x6d
000310  706c6174          DCB      0x70,0x6c,0x61,0x74
000314  6553616d          DCB      0x65,0x53,0x61,0x6d
000318  706c6573          DCB      0x70,0x6c,0x65,0x73
00031c  28736967          DCB      0x28,0x73,0x69,0x67
000320  6e656420          DCB      0x6e,0x65,0x64,0x20
000324  696e7429          DCB      0x69,0x6e,0x74,0x29
000328  20636f6e          DCB      0x20,0x63,0x6f,0x6e
00032c  737400            DCB      0x73,0x74,0x00
                  |symbol_number.245|
00032f  41                DCB      0x41
000330  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000334  3a526573          DCB      0x3a,0x52,0x65,0x73
000338  756c7420          DCB      0x75,0x6c,0x74,0x20
00033c  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000340  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000344  62656464          DCB      0x62,0x65,0x64,0x64
000348  65643a3a          DCB      0x65,0x64,0x3a,0x3a
00034c  54656d70          DCB      0x54,0x65,0x6d,0x70
000350  6c617465          DCB      0x6c,0x61,0x74,0x65
000354  54726163          DCB      0x54,0x72,0x61,0x63
000358  6b65723a          DCB      0x6b,0x65,0x72,0x3a
00035c  3a4c7563          DCB      0x3a,0x4c,0x75,0x63
000360  61734b61          DCB      0x61,0x73,0x4b,0x61
000364  6e616465          DCB      0x6e,0x61,0x64,0x65
000368  54726163          DCB      0x54,0x72,0x61,0x63
00036c  6b65725f          DCB      0x6b,0x65,0x72,0x5f
000370  53616d70          DCB      0x53,0x61,0x6d,0x70
000374  6c656450          DCB      0x6c,0x65,0x64,0x50
000378  6c616e61          DCB      0x6c,0x61,0x6e,0x61
00037c  7236646f          DCB      0x72,0x36,0x64,0x6f
000380  663a3a49          DCB      0x66,0x3a,0x3a,0x49
000384  74657261          DCB      0x74,0x65,0x72,0x61
000388  74697665          DCB      0x74,0x69,0x76,0x65
00038c  6c795265          DCB      0x6c,0x79,0x52,0x65
000390  66696e65          DCB      0x66,0x69,0x6e,0x65
000394  54726163          DCB      0x54,0x72,0x61,0x63
000398  6b28636f          DCB      0x6b,0x28,0x63,0x6f
00039c  6e737420          DCB      0x6e,0x73,0x74,0x20
0003a0  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0003a4  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0003a8  62656464          DCB      0x62,0x65,0x64,0x64
0003ac  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0003b0  41727261          DCB      0x41,0x72,0x72,0x61
0003b4  793c756e          DCB      0x79,0x3c,0x75,0x6e
0003b8  7369676e          DCB      0x73,0x69,0x67,0x6e
0003bc  65642063          DCB      0x65,0x64,0x20,0x63
0003c0  6861723e          DCB      0x68,0x61,0x72,0x3e
0003c4  20262c20          DCB      0x20,0x26,0x2c,0x20
0003c8  7369676e          DCB      0x73,0x69,0x67,0x6e
0003cc  65642069          DCB      0x65,0x64,0x20,0x69
0003d0  6e742c20          DCB      0x6e,0x74,0x2c,0x20
0003d4  7369676e          DCB      0x73,0x69,0x67,0x6e
0003d8  65642069          DCB      0x65,0x64,0x20,0x69
0003dc  6e742c20          DCB      0x6e,0x74,0x2c,0x20
0003e0  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0003e4  742c2066          DCB      0x74,0x2c,0x20,0x66
0003e8  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
0003ec  2c20416e          DCB      0x2c,0x20,0x41,0x6e
0003f0  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0003f4  456d6265          DCB      0x45,0x6d,0x62,0x65
0003f8  64646564          DCB      0x64,0x64,0x65,0x64
0003fc  3a3a5472          DCB      0x3a,0x3a,0x54,0x72
000400  616e7366          DCB      0x61,0x6e,0x73,0x66
000404  6f726d61          DCB      0x6f,0x72,0x6d,0x61
000408  74696f6e          DCB      0x74,0x69,0x6f,0x6e
00040c  733a3a54          DCB      0x73,0x3a,0x3a,0x54
000410  72616e73          DCB      0x72,0x61,0x6e,0x73
000414  666f726d          DCB      0x66,0x6f,0x72,0x6d
000418  54797065          DCB      0x54,0x79,0x70,0x65
00041c  2c20626f          DCB      0x2c,0x20,0x62,0x6f
000420  6f6c2026          DCB      0x6f,0x6c,0x20,0x26
000424  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000428  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00042c  456d6265          DCB      0x45,0x6d,0x62,0x65
000430  64646564          DCB      0x64,0x64,0x65,0x64
000434  3a3a4d65          DCB      0x3a,0x3a,0x4d,0x65
000438  6d6f7279          DCB      0x6d,0x6f,0x72,0x79
00043c  53746163          DCB      0x53,0x74,0x61,0x63
000440  6b2900            DCB      0x6b,0x29,0x00
                  |symbol_number.246|
000443  41                DCB      0x41
000444  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000448  3a526573          DCB      0x3a,0x52,0x65,0x73
00044c  756c7420          DCB      0x75,0x6c,0x74,0x20
000450  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000454  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000458  62656464          DCB      0x62,0x65,0x64,0x64
00045c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000460  54656d70          DCB      0x54,0x65,0x6d,0x70
000464  6c617465          DCB      0x6c,0x61,0x74,0x65
000468  54726163          DCB      0x54,0x72,0x61,0x63
00046c  6b65723a          DCB      0x6b,0x65,0x72,0x3a
000470  3a4c7563          DCB      0x3a,0x4c,0x75,0x63
000474  61734b61          DCB      0x61,0x73,0x4b,0x61
000478  6e616465          DCB      0x6e,0x61,0x64,0x65
00047c  54726163          DCB      0x54,0x72,0x61,0x63
000480  6b65725f          DCB      0x6b,0x65,0x72,0x5f
000484  53616d70          DCB      0x53,0x61,0x6d,0x70
000488  6c656450          DCB      0x6c,0x65,0x64,0x50
00048c  6c616e61          DCB      0x6c,0x61,0x6e,0x61
000490  7236646f          DCB      0x72,0x36,0x64,0x6f
000494  663a3a41          DCB      0x66,0x3a,0x3a,0x41
000498  7070726f          DCB      0x70,0x70,0x72,0x6f
00049c  78696d61          DCB      0x78,0x69,0x6d,0x61
0004a0  74655365          DCB      0x74,0x65,0x53,0x65
0004a4  6c656374          DCB      0x6c,0x65,0x63,0x74
0004a8  28636f6e          DCB      0x28,0x63,0x6f,0x6e
0004ac  73742041          DCB      0x73,0x74,0x20,0x41
0004b0  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0004b4  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0004b8  65646465          DCB      0x65,0x64,0x64,0x65
0004bc  643a3a41          DCB      0x64,0x3a,0x3a,0x41
0004c0  72726179          DCB      0x72,0x72,0x61,0x79
0004c4  3c666c6f          DCB      0x3c,0x66,0x6c,0x6f
0004c8  61743e20          DCB      0x61,0x74,0x3e,0x20
0004cc  262c2073          DCB      0x26,0x2c,0x20,0x73
0004d0  69676e65          DCB      0x69,0x67,0x6e,0x65
0004d4  6420696e          DCB      0x64,0x20,0x69,0x6e
0004d8  742c2073          DCB      0x74,0x2c,0x20,0x73
0004dc  69676e65          DCB      0x69,0x67,0x6e,0x65
0004e0  6420696e          DCB      0x64,0x20,0x69,0x6e
0004e4  742c2073          DCB      0x74,0x2c,0x20,0x73
0004e8  69676e65          DCB      0x69,0x67,0x6e,0x65
0004ec  6420696e          DCB      0x64,0x20,0x69,0x6e
0004f0  742c2073          DCB      0x74,0x2c,0x20,0x73
0004f4  69676e65          DCB      0x69,0x67,0x6e,0x65
0004f8  6420696e          DCB      0x64,0x20,0x69,0x6e
0004fc  7420262c          DCB      0x74,0x20,0x26,0x2c
000500  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000504  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000508  6d626564          DCB      0x6d,0x62,0x65,0x64
00050c  6465643a          DCB      0x64,0x65,0x64,0x3a
000510  3a417272          DCB      0x3a,0x41,0x72,0x72
000514  61793c73          DCB      0x61,0x79,0x3c,0x73
000518  69676e65          DCB      0x69,0x67,0x6e,0x65
00051c  6420696e          DCB      0x64,0x20,0x69,0x6e
000520  743e2026          DCB      0x74,0x3e,0x20,0x26
000524  2900              DCB      0x29,0x00
                  |symbol_number.247|
000526  416e              DCB      0x41,0x6e
000528  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00052c  52657375          DCB      0x52,0x65,0x73,0x75
000530  6c742041          DCB      0x6c,0x74,0x20,0x41
000534  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000538  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00053c  65646465          DCB      0x65,0x64,0x64,0x65
000540  643a3a54          DCB      0x64,0x3a,0x3a,0x54
000544  656d706c          DCB      0x65,0x6d,0x70,0x6c
000548  61746554          DCB      0x61,0x74,0x65,0x54
00054c  7261636b          DCB      0x72,0x61,0x63,0x6b
000550  65723a3a          DCB      0x65,0x72,0x3a,0x3a
000554  4c756361          DCB      0x4c,0x75,0x63,0x61
000558  734b616e          DCB      0x73,0x4b,0x61,0x6e
00055c  61646554          DCB      0x61,0x64,0x65,0x54
000560  7261636b          DCB      0x72,0x61,0x63,0x6b
000564  65725f53          DCB      0x65,0x72,0x5f,0x53
000568  616d706c          DCB      0x61,0x6d,0x70,0x6c
00056c  6564506c          DCB      0x65,0x64,0x50,0x6c
000570  616e6172          DCB      0x61,0x6e,0x61,0x72
000574  36646f66          DCB      0x36,0x64,0x6f,0x66
000578  3a3a4372          DCB      0x3a,0x3a,0x43,0x72
00057c  65617465          DCB      0x65,0x61,0x74,0x65
000580  56657269          DCB      0x56,0x65,0x72,0x69
000584  66696361          DCB      0x66,0x69,0x63,0x61
000588  74696f6e          DCB      0x74,0x69,0x6f,0x6e
00058c  53616d70          DCB      0x53,0x61,0x6d,0x70
000590  6c657328          DCB      0x6c,0x65,0x73,0x28
000594  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000598  7420416e          DCB      0x74,0x20,0x41,0x6e
00059c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0005a0  456d6265          DCB      0x45,0x6d,0x62,0x65
0005a4  64646564          DCB      0x64,0x64,0x65,0x64
0005a8  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
0005ac  7261793c          DCB      0x72,0x61,0x79,0x3c
0005b0  756e7369          DCB      0x75,0x6e,0x73,0x69
0005b4  676e6564          DCB      0x67,0x6e,0x65,0x64
0005b8  20636861          DCB      0x20,0x63,0x68,0x61
0005bc  723e2026          DCB      0x72,0x3e,0x20,0x26
0005c0  2c20636f          DCB      0x2c,0x20,0x63,0x6f
0005c4  6e737420          DCB      0x6e,0x73,0x74,0x20
0005c8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0005cc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0005d0  62656464          DCB      0x62,0x65,0x64,0x64
0005d4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0005d8  4c696e65          DCB      0x4c,0x69,0x6e,0x65
0005dc  61725365          DCB      0x61,0x72,0x53,0x65
0005e0  7175656e          DCB      0x71,0x75,0x65,0x6e
0005e4  63653c66          DCB      0x63,0x65,0x3c,0x66
0005e8  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
0005ec  3e20262c          DCB      0x3e,0x20,0x26,0x2c
0005f0  20636f6e          DCB      0x20,0x63,0x6f,0x6e
0005f4  73742041          DCB      0x73,0x74,0x20,0x41
0005f8  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0005fc  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000600  65646465          DCB      0x65,0x64,0x64,0x65
000604  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
000608  696e6561          DCB      0x69,0x6e,0x65,0x61
00060c  72536571          DCB      0x72,0x53,0x65,0x71
000610  75656e63          DCB      0x75,0x65,0x6e,0x63
000614  653c666c          DCB      0x65,0x3c,0x66,0x6c
000618  6f61743e          DCB      0x6f,0x61,0x74,0x3e
00061c  20262c20          DCB      0x20,0x26,0x2c,0x20
000620  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000624  742c2073          DCB      0x74,0x2c,0x20,0x73
000628  69676e65          DCB      0x69,0x67,0x6e,0x65
00062c  6420696e          DCB      0x64,0x20,0x69,0x6e
000630  7420262c          DCB      0x74,0x20,0x26,0x2c
000634  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000638  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00063c  6d626564          DCB      0x6d,0x62,0x65,0x64
000640  6465643a          DCB      0x64,0x65,0x64,0x3a
000644  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
000648  6f727953          DCB      0x6f,0x72,0x79,0x53
00064c  7461636b          DCB      0x74,0x61,0x63,0x6b
000650  29000000          DCB      0x29,0x00,0x00,0x00
000654  4c696e65          DCB      0x4c,0x69,0x6e,0x65
000658  61725365          DCB      0x61,0x72,0x53,0x65
00065c  7175656e          DCB      0x71,0x75,0x65,0x6e
000660  63653c54          DCB      0x63,0x65,0x3c,0x54
000664  7970653e          DCB      0x79,0x70,0x65,0x3e
000668  3a3a636f          DCB      0x3a,0x3a,0x63,0x6f
00066c  6d707574          DCB      0x6d,0x70,0x75,0x74
000670  6553697a          DCB      0x65,0x53,0x69,0x7a
000674  65000000          DCB      0x65,0x00,0x00,0x00
000678  73697a65          DCB      0x73,0x69,0x7a,0x65
00067c  20657374          DCB      0x20,0x65,0x73,0x74
000680  696d6174          DCB      0x69,0x6d,0x61,0x74
000684  696f6e20          DCB      0x69,0x6f,0x6e,0x20
000688  6661696c          DCB      0x66,0x61,0x69,0x6c
00068c  65640000          DCB      0x65,0x64,0x00,0x00
000690  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000694  6f726574          DCB      0x6f,0x72,0x65,0x74
000698  6563685c          DCB      0x65,0x63,0x68,0x5c
00069c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
0006a0  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
0006a4  6e636c75          DCB      0x6e,0x63,0x6c,0x75
0006a8  64655c61          DCB      0x64,0x65,0x5c,0x61
0006ac  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
0006b0  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
0006b4  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
0006b8  6f626f74          DCB      0x6f,0x62,0x6f,0x74
0006bc  2f736571          DCB      0x2f,0x73,0x65,0x71
0006c0  75656e63          DCB      0x75,0x65,0x6e,0x63
0006c4  65732e68          DCB      0x65,0x73,0x2e,0x68
0006c8  00000000          DCB      0x00,0x00,0x00,0x00
0006cc  41727261          DCB      0x41,0x72,0x72,0x61
0006d0  793c5479          DCB      0x79,0x3c,0x54,0x79
0006d4  70653e3a          DCB      0x70,0x65,0x3e,0x3a
0006d8  3a436f6d          DCB      0x3a,0x43,0x6f,0x6d
0006dc  70757465          DCB      0x70,0x75,0x74,0x65
0006e0  52657175          DCB      0x52,0x65,0x71,0x75
0006e4  69726564          DCB      0x69,0x72,0x65,0x64
0006e8  53747269          DCB      0x53,0x74,0x72,0x69
0006ec  64650000          DCB      0x64,0x65,0x00,0x00
0006f0  496e7661          DCB      0x49,0x6e,0x76,0x61
0006f4  6c696420          DCB      0x6c,0x69,0x64,0x20
0006f8  73697a65          DCB      0x73,0x69,0x7a,0x65
0006fc  00000000          DCB      0x00,0x00,0x00,0x00
000700  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000704  6f726574          DCB      0x6f,0x72,0x65,0x74
000708  6563685c          DCB      0x65,0x63,0x68,0x5c
00070c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000710  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000714  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000718  64655c61          DCB      0x64,0x65,0x5c,0x61
00071c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000720  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000724  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000728  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00072c  2f617272          DCB      0x2f,0x61,0x72,0x72
000730  61793264          DCB      0x61,0x79,0x32,0x64
000734  2e680000          DCB      0x2e,0x68,0x00,0x00
000738  41727261          DCB      0x41,0x72,0x72,0x61
00073c  793c5479          DCB      0x79,0x3c,0x54,0x79
000740  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000744  3a676574          DCB      0x3a,0x67,0x65,0x74
000748  5f73697a          DCB      0x5f,0x73,0x69,0x7a
00074c  65000000          DCB      0x65,0x00,0x00,0x00
000750  4e656761          DCB      0x4e,0x65,0x67,0x61
000754  74697665          DCB      0x74,0x69,0x76,0x65
000758  2064696d          DCB      0x20,0x64,0x69,0x6d
00075c  656e7369          DCB      0x65,0x6e,0x73,0x69
000760  6f6e0000          DCB      0x6f,0x6e,0x00,0x00
000764  52657375          DCB      0x52,0x65,0x73,0x75
000768  6c74204c          DCB      0x6c,0x74,0x20,0x4c
00076c  75636173          DCB      0x75,0x63,0x61,0x73
000770  4b616e61          DCB      0x4b,0x61,0x6e,0x61
000774  64655472          DCB      0x64,0x65,0x54,0x72
000778  61636b65          DCB      0x61,0x63,0x6b,0x65
00077c  725f5361          DCB      0x72,0x5f,0x53,0x61
000780  6d706c65          DCB      0x6d,0x70,0x6c,0x65
000784  64506c61          DCB      0x64,0x50,0x6c,0x61
000788  6e617236          DCB      0x6e,0x61,0x72,0x36
00078c  646f663a          DCB      0x64,0x6f,0x66,0x3a
000790  3a437265          DCB      0x3a,0x43,0x72,0x65
000794  61746556          DCB      0x61,0x74,0x65,0x56
000798  65726966          DCB      0x65,0x72,0x69,0x66
00079c  69636174          DCB      0x69,0x63,0x61,0x74
0007a0  696f6e53          DCB      0x69,0x6f,0x6e,0x53
0007a4  616d706c          DCB      0x61,0x6d,0x70,0x6c
0007a8  65730000          DCB      0x65,0x73,0x00,0x00
0007ac  53697a65          DCB      0x53,0x69,0x7a,0x65
0007b0  206f6620          DCB      0x20,0x6f,0x66,0x20
0007b4  6d61676e          DCB      0x6d,0x61,0x67,0x6e
0007b8  69747564          DCB      0x69,0x74,0x75,0x64
0007bc  65496e64          DCB      0x65,0x49,0x6e,0x64
0007c0  65786573          DCB      0x65,0x78,0x65,0x73
0007c4  20766563          DCB      0x20,0x76,0x65,0x63
0007c8  746f7220          DCB      0x74,0x6f,0x72,0x20
0007cc  646f6573          DCB      0x64,0x6f,0x65,0x73
0007d0  206e6f74          DCB      0x20,0x6e,0x6f,0x74
0007d4  206d6174          DCB      0x20,0x6d,0x61,0x74
0007d8  63682073          DCB      0x63,0x68,0x20,0x73
0007dc  697a6520          DCB      0x69,0x7a,0x65,0x20
0007e0  6f66206d          DCB      0x6f,0x66,0x20,0x6d
0007e4  61676e69          DCB      0x61,0x67,0x6e,0x69
0007e8  74756465          DCB      0x74,0x75,0x64,0x65
0007ec  496d6167          DCB      0x49,0x6d,0x61,0x67
0007f0  652e0a00          DCB      0x65,0x2e,0x0a,0x00
0007f4  4c756361          DCB      0x4c,0x75,0x63,0x61
0007f8  734b616e          DCB      0x73,0x4b,0x61,0x6e
0007fc  61646554          DCB      0x61,0x64,0x65,0x54
000800  7261636b          DCB      0x72,0x61,0x63,0x6b
000804  65725f53          DCB      0x65,0x72,0x5f,0x53
000808  616d706c          DCB      0x61,0x6d,0x70,0x6c
00080c  6564506c          DCB      0x65,0x64,0x50,0x6c
000810  616e6172          DCB      0x61,0x6e,0x61,0x72
000814  36646f66          DCB      0x36,0x64,0x6f,0x66
000818  3a3a4c75          DCB      0x3a,0x3a,0x4c,0x75
00081c  6361734b          DCB      0x63,0x61,0x73,0x4b
000820  616e6164          DCB      0x61,0x6e,0x61,0x64
000824  65547261          DCB      0x65,0x54,0x72,0x61
000828  636b6572          DCB      0x63,0x6b,0x65,0x72
00082c  5f53616d          DCB      0x5f,0x53,0x61,0x6d
000830  706c6564          DCB      0x70,0x6c,0x65,0x64
000834  506c616e          DCB      0x50,0x6c,0x61,0x6e
000838  61723664          DCB      0x61,0x72,0x36,0x64
00083c  6f660000          DCB      0x6f,0x66,0x00,0x00
000840  43726561          DCB      0x43,0x72,0x65,0x61
000844  74655665          DCB      0x74,0x65,0x56,0x65
000848  72696669          DCB      0x72,0x69,0x66,0x69
00084c  63617469          DCB      0x63,0x61,0x74,0x69
000850  6f6e5361          DCB      0x6f,0x6e,0x53,0x61
000854  6d706c65          DCB      0x6d,0x70,0x6c,0x65
000858  7320666f          DCB      0x73,0x20,0x66,0x6f
00085c  7220546f          DCB      0x72,0x20,0x54,0x6f
000860  702f426f          DCB      0x70,0x2f,0x42,0x6f
000864  74746f6d          DCB      0x74,0x74,0x6f,0x6d
000868  20537175          DCB      0x20,0x53,0x71,0x75
00086c  61726520          DCB      0x61,0x72,0x65,0x20
000870  42617273          DCB      0x42,0x61,0x72,0x73
000874  20666169          DCB      0x20,0x66,0x61,0x69
000878  6c656420          DCB      0x6c,0x65,0x64,0x20
00087c  77697468          DCB      0x77,0x69,0x74,0x68
000880  20636f64          DCB      0x20,0x63,0x6f,0x64
000884  65203078          DCB      0x65,0x20,0x30,0x78
000888  25780000          DCB      0x25,0x78,0x00,0x00
00088c  43726561          DCB      0x43,0x72,0x65,0x61
000890  74655665          DCB      0x74,0x65,0x56,0x65
000894  72696669          DCB      0x72,0x69,0x66,0x69
000898  63617469          DCB      0x63,0x61,0x74,0x69
00089c  6f6e5361          DCB      0x6f,0x6e,0x53,0x61
0008a0  6d706c65          DCB      0x6d,0x70,0x6c,0x65
0008a4  7320666f          DCB      0x73,0x20,0x66,0x6f
0008a8  72204c65          DCB      0x72,0x20,0x4c,0x65
0008ac  66742f52          DCB      0x66,0x74,0x2f,0x52
0008b0  69676874          DCB      0x69,0x67,0x68,0x74
0008b4  20537175          DCB      0x20,0x53,0x71,0x75
0008b8  61726520          DCB      0x61,0x72,0x65,0x20
0008bc  42617273          DCB      0x42,0x61,0x72,0x73
0008c0  20666169          DCB      0x20,0x66,0x61,0x69
0008c4  6c656420          DCB      0x6c,0x65,0x64,0x20
0008c8  77697468          DCB      0x77,0x69,0x74,0x68
0008cc  20636f64          DCB      0x20,0x63,0x6f,0x64
0008d0  65203078          DCB      0x65,0x20,0x30,0x78
0008d4  25780000          DCB      0x25,0x78,0x00,0x00
0008d8  43726561          DCB      0x43,0x72,0x65,0x61
0008dc  74655665          DCB      0x74,0x65,0x56,0x65
0008e0  72696669          DCB      0x72,0x69,0x66,0x69
0008e4  63617469          DCB      0x63,0x61,0x74,0x69
0008e8  6f6e5361          DCB      0x6f,0x6e,0x53,0x61
0008ec  6d706c65          DCB      0x6d,0x70,0x6c,0x65
0008f0  7320666f          DCB      0x73,0x20,0x66,0x6f
0008f4  7220546f          DCB      0x72,0x20,0x54,0x6f
0008f8  702f426f          DCB      0x70,0x2f,0x42,0x6f
0008fc  74746f6d          DCB      0x74,0x74,0x6f,0x6d
000900  20476170          DCB      0x20,0x47,0x61,0x70
000904  20426172          DCB      0x20,0x42,0x61,0x72
000908  73206661          DCB      0x73,0x20,0x66,0x61
00090c  696c6564          DCB      0x69,0x6c,0x65,0x64
000910  20776974          DCB      0x20,0x77,0x69,0x74
000914  6820636f          DCB      0x68,0x20,0x63,0x6f
000918  64652030          DCB      0x64,0x65,0x20,0x30
00091c  78257800          DCB      0x78,0x25,0x78,0x00
000920  43726561          DCB      0x43,0x72,0x65,0x61
000924  74655665          DCB      0x74,0x65,0x56,0x65
000928  72696669          DCB      0x72,0x69,0x66,0x69
00092c  63617469          DCB      0x63,0x61,0x74,0x69
000930  6f6e5361          DCB      0x6f,0x6e,0x53,0x61
000934  6d706c65          DCB      0x6d,0x70,0x6c,0x65
000938  7320666f          DCB      0x73,0x20,0x66,0x6f
00093c  72204c65          DCB      0x72,0x20,0x4c,0x65
000940  66742f52          DCB      0x66,0x74,0x2f,0x52
000944  69676874          DCB      0x69,0x67,0x68,0x74
000948  20476170          DCB      0x20,0x47,0x61,0x70
00094c  20426172          DCB      0x20,0x42,0x61,0x72
000950  73206661          DCB      0x73,0x20,0x66,0x61
000954  696c6564          DCB      0x69,0x6c,0x65,0x64
000958  20776974          DCB      0x20,0x77,0x69,0x74
00095c  6820636f          DCB      0x68,0x20,0x63,0x6f
000960  64652030          DCB      0x64,0x65,0x20,0x30
000964  78257800          DCB      0x78,0x25,0x78,0x00
000968  54686520          DCB      0x54,0x68,0x65,0x20
00096c  74656d70          DCB      0x74,0x65,0x6d,0x70
000970  6c617465          DCB      0x6c,0x61,0x74,0x65
000974  496d6167          DCB      0x49,0x6d,0x61,0x67
000978  65206d75          DCB      0x65,0x20,0x6d,0x75
00097c  73742062          DCB      0x73,0x74,0x20,0x62
000980  65206120          DCB      0x65,0x20,0x61,0x20
000984  706f7765          DCB      0x70,0x6f,0x77,0x65
000988  72206f66          DCB      0x72,0x20,0x6f,0x66
00098c  2074776f          DCB      0x20,0x74,0x77,0x6f
000990  20736d61          DCB      0x20,0x73,0x6d,0x61
000994  6c6c6572          DCB      0x6c,0x6c,0x65,0x72
000998  20746861          DCB      0x20,0x74,0x68,0x61
00099c  6e204241          DCB      0x6e,0x20,0x42,0x41
0009a0  53455f49          DCB      0x53,0x45,0x5f,0x49
0009a4  4d414745          DCB      0x4d,0x41,0x47,0x45
0009a8  5f574944          DCB      0x5f,0x57,0x49,0x44
0009ac  544800            DCB      0x54,0x48,0x00

                          AREA ||t._ZN4Anki8Embedded5PointIfEC1Ev||, COMGROUP=_ZN4Anki8Embedded5PointIfEC1Ev, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5PointIfEC2Ev                  ; Alternate entry point ; Anki::Embedded::Point<float>::Point__sub_object()
                  _ZN4Anki8Embedded5PointIfEC1Ev PROC ; Anki::Embedded::Point<float>::Point()
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
000000  ed9f0a03          VLDR     s0,|L152.16|
000004  ed800a00          VSTR     s0,[r0,#0]
000008  ed800a01          VSTR     s0,[r0,#4]
00000c  4770              BX       lr
                          ENDP

00000e  0000              DCW      0x0000
                  |L152.16|
000010  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.153||, COMGROUP=_ZN4Anki8Embedded5PointIfEC1Ev, LINKORDER=||t._ZN4Anki8Embedded5PointIfEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.153||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5PointIfEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIiEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<int>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L159.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L159.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L159.384|
000044  a25c              ADR      r2,|L159.440|
000046  a160              ADR      r1,|L159.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L159.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L159.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L159.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L159.384|
000080  a24d              ADR      r2,|L159.440|
000082  a157              ADR      r1,|L159.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L159.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L159.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L159.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L159.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L159.384|
0000c8  a251              ADR      r2,|L159.528|
0000ca  a156              ADR      r1,|L159.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L159.372|
                  |L159.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L159.384|
0000e0  a258              ADR      r2,|L159.580|
0000e2  a15f              ADR      r1,|L159.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L159.372|
                  |L159.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L159.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L159.384|
000110  a259              ADR      r2,|L159.632|
000112  a144              ADR      r1,|L159.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L159.372|
                  |L159.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L159.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L159.384|
00015a  a251              ADR      r2,|L159.672|
00015c  a140              ADR      r1,|L159.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L159.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L159.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L159.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L159.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L159.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L159.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L159.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L159.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L159.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L159.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L159.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L159.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L159.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L159.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.160||, COMGROUP=_ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.160||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_||, COMGROUP=_ZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC2ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_                  ; Alternate entry point ; Anki::Embedded::ArraySliceLimits_in2_out1<int>::ArraySliceLimits_in2_out1__sub_object(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
                  _ZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_ PROC ; Anki::Embedded::ArraySliceLimits_in2_out1<int>::ArraySliceLimits_in2_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
;;;347    
;;;348        template<typename Type> ArraySliceLimits_in2_out1<Type>::ArraySliceLimits_in2_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;349          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;350          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;351          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed),
;;;352          rawIn2Limits(in2_ySlice, in2_xSlice), in2_isTransposed(in2_isTransposed)
;;;353        {
;;;354          isValid = false;
;;;355    
;;;356          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;357          this->in1_yInnerIncrement = 0;
;;;358          this->in1_xInnerIncrement = 0;
;;;359          this->in2_yInnerIncrement = 0;
;;;360          this->in2_xInnerIncrement = 0;
;;;361    
;;;362          if(!in1_isTransposed && !in2_isTransposed) {
;;;363            const bool sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;364    
;;;365            if(sizesMatch) {
;;;366              isValid = true;
;;;367              isSimpleIteration = true;
;;;368    
;;;369              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;370              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;371    
;;;372              this->in1Y = this->rawIn1Limits.yStart;
;;;373              this->in2Y = this->rawIn2Limits.yStart;
;;;374              this->out1Y = this->rawOut1Limits.yStart;
;;;375            }
;;;376          } else { // if(!in1_isTransposed)
;;;377            isSimpleIteration = false;
;;;378    
;;;379            bool sizesMatch = false;
;;;380    
;;;381            if(in1_isTransposed && in2_isTransposed) {
;;;382              sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;383              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;384              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;385            } else if(in1_isTransposed) {
;;;386              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;387              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;388              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;389            } else if(in2_isTransposed) {
;;;390              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;391              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;392              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;393            } else {
;;;394              AnkiAssert(false); // should not be possible
;;;395            }
;;;396    
;;;397            if(!sizesMatch) {
;;;398              AnkiError("ArraySliceLimits_in2_out1", "Subscripted assignment dimension mismatch");
;;;399              return;
;;;400            }
;;;401    
;;;402            isValid = true;
;;;403    
;;;404            this->in1X = this->rawIn1Limits.xStart;
;;;405            this->in1Y = this->rawIn1Limits.yStart;
;;;406            this->in2X = this->rawIn2Limits.xStart;
;;;407            this->in2Y = this->rawIn2Limits.yStart;
;;;408    
;;;409            this->out1Y = this->rawOut1Limits.yStart;
;;;410          } // if(!in1_isTransposed) ... else
;;;411        } // ArraySliceLimits_in1_out1
;;;412    
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  b082              SUB      sp,sp,#8
000006  4604              MOV      r4,r0
000008  e9ddc00d          LDRD     r12,r0,[sp,#0x34]
00000c  e9dd650a          LDRD     r6,r5,[sp,#0x28]
000010  f8dd8030          LDR      r8,[sp,#0x30]
000014  f8dc7000          LDR      r7,[r12,#0]
000018  61e7              STR      r7,[r4,#0x1c]
00001a  6807              LDR      r7,[r0,#0]
00001c  6227              STR      r7,[r4,#0x20]
00001e  f8d09004          LDR      r9,[r0,#4]
000022  f8c49038          STR      r9,[r4,#0x38]
000026  f8d09008          LDR      r9,[r0,#8]
00002a  f8c4903c          STR      r9,[r4,#0x3c]
00002e  f8d09000          LDR      r9,[r0,#0]
000032  f8c49040          STR      r9,[r4,#0x40]
000036  f8dc9004          LDR      r9,[r12,#4]
00003a  f8c49044          STR      r9,[r4,#0x44]
00003e  f8dc9008          LDR      r9,[r12,#8]
000042  f8c49048          STR      r9,[r4,#0x48]
000046  f8dc9000          LDR      r9,[r12,#0]
00004a  f8c4904c          STR      r9,[r4,#0x4c]
00004e  f8d2a004          LDR      r10,[r2,#4]
000052  f8c4a050          STR      r10,[r4,#0x50]
000056  f8d2a008          LDR      r10,[r2,#8]
00005a  f8c4a054          STR      r10,[r4,#0x54]
00005e  f8d2a000          LDR      r10,[r2,#0]
000062  f8c4a058          STR      r10,[r4,#0x58]
000066  f8d1a004          LDR      r10,[r1,#4]
00006a  f8c4a05c          STR      r10,[r4,#0x5c]
00006e  f8d1a008          LDR      r10,[r1,#8]
000072  f8c4a060          STR      r10,[r4,#0x60]
000076  f8d1a000          LDR      r10,[r1,#0]
00007a  f8c4a064          STR      r10,[r4,#0x64]
00007e  f8843068          STRB     r3,[r4,#0x68]
000082  f8d5a004          LDR      r10,[r5,#4]
000086  f8c4a06c          STR      r10,[r4,#0x6c]
00008a  f8d5a008          LDR      r10,[r5,#8]
00008e  f8c4a070          STR      r10,[r4,#0x70]
000092  f8d5a000          LDR      r10,[r5,#0]
000096  f8c4a074          STR      r10,[r4,#0x74]
00009a  f8d6a004          LDR      r10,[r6,#4]
00009e  f8c4a078          STR      r10,[r4,#0x78]
0000a2  f8d6a008          LDR      r10,[r6,#8]
0000a6  f8c4a07c          STR      r10,[r4,#0x7c]
0000aa  f8d6a000          LDR      r10,[r6,#0]
0000ae  f8c4a080          STR      r10,[r4,#0x80]
0000b2  f04f0900          MOV      r9,#0
0000b6  f8848084          STRB     r8,[r4,#0x84]
0000ba  f8849000          STRB     r9,[r4,#0]
0000be  6be7              LDR      r7,[r4,#0x3c]
0000c0  f8c4902c          STR      r9,[r4,#0x2c]
0000c4  e9c47909          STRD     r7,r9,[r4,#0x24]
0000c8  f8c49034          STR      r9,[r4,#0x34]
0000cc  f8c49030          STR      r9,[r4,#0x30]
0000d0  ea530a08          ORRS     r10,r3,r8
0000d4  f04f0701          MOV      r7,#1
0000d8  d01a              BEQ      |L166.272|
0000da  f8849001          STRB     r9,[r4,#1]
0000de  ea130f08          TST      r3,r8
0000e2  d035              BEQ      |L166.336|
0000e4  6812              LDR      r2,[r2,#0]
0000e6  682b              LDR      r3,[r5,#0]
0000e8  429a              CMP      r2,r3
0000ea  bf04              ITT      EQ
0000ec  f8dc3000          LDREQ    r3,[r12,#0]
0000f0  429a              CMPEQ    r2,r3
0000f2  d107              BNE      |L166.260|
0000f4  6809              LDR      r1,[r1,#0]
0000f6  6832              LDR      r2,[r6,#0]
0000f8  4291              CMP      r1,r2
0000fa  bf02              ITTT     EQ
0000fc  6800              LDREQ    r0,[r0,#0]
0000fe  4281              CMPEQ    r1,r0
000100  2001              MOVEQ    r0,#1
000102  d000              BEQ      |L166.262|
                  |L166.260|
000104  2000              MOVS     r0,#0
                  |L166.262|
000106  6e21              LDR      r1,[r4,#0x60]
000108  62e1              STR      r1,[r4,#0x2c]
00010a  6fe1              LDR      r1,[r4,#0x7c]
00010c  6361              STR      r1,[r4,#0x34]
00010e  e04e              B        |L166.430|
                  |L166.272|
000110  6812              LDR      r2,[r2,#0]
000112  682b              LDR      r3,[r5,#0]
000114  429a              CMP      r2,r3
000116  bf04              ITT      EQ
000118  6800              LDREQ    r0,[r0,#0]
00011a  4282              CMPEQ    r2,r0
00011c  d108              BNE      |L166.304|
00011e  6808              LDR      r0,[r1,#0]
000120  6831              LDR      r1,[r6,#0]
000122  4288              CMP      r0,r1
000124  bf02              ITTT     EQ
000126  f8dc1000          LDREQ    r1,[r12,#0]
00012a  4288              CMPEQ    r0,r1
00012c  2001              MOVEQ    r0,#1
00012e  d000              BEQ      |L166.306|
                  |L166.304|
000130  2000              MOVS     r0,#0
                  |L166.306|
000132  2800              CMP      r0,#0
000134  d047              BEQ      |L166.454|
000136  7027              STRB     r7,[r4,#0]
000138  7067              STRB     r7,[r4,#1]
00013a  6d60              LDR      r0,[r4,#0x54]
00013c  62a0              STR      r0,[r4,#0x28]
00013e  6f20              LDR      r0,[r4,#0x70]
000140  6320              STR      r0,[r4,#0x30]
000142  6de0              LDR      r0,[r4,#0x5c]
000144  60e0              STR      r0,[r4,#0xc]
000146  6fa0              LDR      r0,[r4,#0x78]
000148  6160              STR      r0,[r4,#0x14]
00014a  6c60              LDR      r0,[r4,#0x44]
00014c  6060              STR      r0,[r4,#4]
00014e  e03a              B        |L166.454|
                  |L166.336|
000150  b1ab              CBZ      r3,|L166.382|
000152  6812              LDR      r2,[r2,#0]
000154  6833              LDR      r3,[r6,#0]
000156  429a              CMP      r2,r3
000158  bf04              ITT      EQ
00015a  f8dc3000          LDREQ    r3,[r12,#0]
00015e  429a              CMPEQ    r2,r3
000160  d107              BNE      |L166.370|
000162  6809              LDR      r1,[r1,#0]
000164  682a              LDR      r2,[r5,#0]
000166  4291              CMP      r1,r2
000168  bf02              ITTT     EQ
00016a  6800              LDREQ    r0,[r0,#0]
00016c  4281              CMPEQ    r1,r0
00016e  2001              MOVEQ    r0,#1
000170  d000              BEQ      |L166.372|
                  |L166.370|
000172  2000              MOVS     r0,#0
                  |L166.372|
000174  6e21              LDR      r1,[r4,#0x60]
000176  62e1              STR      r1,[r4,#0x2c]
000178  6f21              LDR      r1,[r4,#0x70]
00017a  6321              STR      r1,[r4,#0x30]
00017c  e017              B        |L166.430|
                  |L166.382|
00017e  f1b80f00          CMP      r8,#0
000182  d024              BEQ      |L166.462|
000184  6812              LDR      r2,[r2,#0]
000186  6833              LDR      r3,[r6,#0]
000188  429a              CMP      r2,r3
00018a  bf04              ITT      EQ
00018c  6800              LDREQ    r0,[r0,#0]
00018e  4282              CMPEQ    r2,r0
000190  d108              BNE      |L166.420|
000192  6808              LDR      r0,[r1,#0]
000194  6829              LDR      r1,[r5,#0]
000196  4288              CMP      r0,r1
000198  bf02              ITTT     EQ
00019a  f8dc1000          LDREQ    r1,[r12,#0]
00019e  4288              CMPEQ    r0,r1
0001a0  2001              MOVEQ    r0,#1
0001a2  d000              BEQ      |L166.422|
                  |L166.420|
0001a4  2000              MOVS     r0,#0
                  |L166.422|
0001a6  6d61              LDR      r1,[r4,#0x54]
0001a8  62a1              STR      r1,[r4,#0x28]
0001aa  6fe1              LDR      r1,[r4,#0x7c]
0001ac  6361              STR      r1,[r4,#0x34]
                  |L166.430|
0001ae  b170              CBZ      r0,|L166.462|
0001b0  7027              STRB     r7,[r4,#0]
0001b2  6d20              LDR      r0,[r4,#0x50]
0001b4  6120              STR      r0,[r4,#0x10]
0001b6  6de0              LDR      r0,[r4,#0x5c]
0001b8  60e0              STR      r0,[r4,#0xc]
0001ba  6ee0              LDR      r0,[r4,#0x6c]
0001bc  61a0              STR      r0,[r4,#0x18]
0001be  6fa0              LDR      r0,[r4,#0x78]
0001c0  6160              STR      r0,[r4,#0x14]
0001c2  6c60              LDR      r0,[r4,#0x44]
0001c4  6060              STR      r0,[r4,#4]
                  |L166.454|
0001c6  b002              ADD      sp,sp,#8
0001c8  4620              MOV      r0,r4
0001ca  e8bd87f0          POP      {r4-r10,pc}
                  |L166.462|
0001ce  f44f71c7          MOV      r1,#0x18e
0001d2  4806              LDR      r0,|L166.492|
0001d4  e9cd0100          STRD     r0,r1,[sp,#0]
0001d8  a305              ADR      r3,|L166.496|
0001da  a214              ADR      r2,|L166.556|
0001dc  a11e              ADR      r1,|L166.600|
0001de  2005              MOVS     r0,#5
0001e0  f7fffffe          BL       _Anki_Log
0001e4  b002              ADD      sp,sp,#8
0001e6  4620              MOV      r0,r4
0001e8  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

                  |L166.492|
                          DCD      _ZZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_E19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySliceLimits_in2_out1<int>::ArraySliceLimits_in2_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)::__PRETTY_FUNCTION__
                  |L166.496|
0001f0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/arrayS"
0001f4  6f726574
0001f8  6563685c
0001fc  636f6d6d
000200  6f6e5c69
000204  6e636c75
000208  64655c61
00020c  6e6b692f
000210  636f6d6d
000214  6f6e2f72
000218  6f626f74
00021c  2f617272
000220  617953  
000223  6c696365          DCB      "lices.h",0
000227  732e6800
00022b  00                DCB      0
                  |L166.556|
00022c  53756273          DCB      "Subscripted assignment dimension mismatch",0
000230  63726970
000234  74656420
000238  61737369
00023c  676e6d65
000240  6e742064
000244  696d656e
000248  73696f6e
00024c  206d6973
000250  6d617463
000254  6800    
000256  00                DCB      0
000257  00                DCB      0
                  |L166.600|
000258  41727261          DCB      "ArraySliceLimits_in2_out1",0
00025c  79536c69
000260  63654c69
000264  6d697473
000268  5f696e32
00026c  5f6f7574
000270  3100    
000272  00                DCB      0
000273  00                DCB      0

                          AREA ||area_number.167||, COMGROUP=_ZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_, LINKORDER=||t._ZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.167||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<float>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L173.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L173.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L173.384|
000044  a25c              ADR      r2,|L173.440|
000046  a160              ADR      r1,|L173.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L173.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L173.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L173.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L173.384|
000080  a24d              ADR      r2,|L173.440|
000082  a157              ADR      r1,|L173.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L173.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L173.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L173.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L173.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L173.384|
0000c8  a251              ADR      r2,|L173.528|
0000ca  a156              ADR      r1,|L173.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L173.372|
                  |L173.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L173.384|
0000e0  a258              ADR      r2,|L173.580|
0000e2  a15f              ADR      r1,|L173.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L173.372|
                  |L173.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L173.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L173.384|
000110  a259              ADR      r2,|L173.632|
000112  a144              ADR      r1,|L173.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L173.372|
                  |L173.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L173.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L173.384|
00015a  a251              ADR      r2,|L173.672|
00015c  a140              ADR      r1,|L173.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L173.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L173.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L173.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L173.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L173.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L173.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L173.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L173.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L173.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L173.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L173.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L173.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L173.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L173.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.174||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.174||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIhEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<unsigned char>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L180.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L180.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L180.384|
000044  a25c              ADR      r2,|L180.440|
000046  a160              ADR      r1,|L180.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L180.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  300f              ADDS     r0,r0,#0xf
000064  f020050f          BIC      r5,r0,#0xf
000068  a804              ADD      r0,sp,#0x10
00006a  e9cd0902          STRD     r0,r9,[sp,#8]
00006e  2d00              CMP      r5,#0
000070  dc0a              BGT      |L180.136|
000072  f240310b          MOV      r1,#0x30b
000076  4859              LDR      r0,|L180.476|
000078  e9cd0100          STRD     r0,r1,[sp,#0]
00007c  a340              ADR      r3,|L180.384|
00007e  a24e              ADR      r2,|L180.440|
000080  a157              ADR      r1,|L180.480|
000082  2005              MOVS     r0,#5
000084  f7fffffe          BL       _Anki_Log
                  |L180.136|
000088  4638              MOV      r0,r7
00008a  2f01              CMP      r7,#1
00008c  bfd8              IT       LE
00008e  2001              MOVLE    r0,#1
000090  60a5              STR      r5,[r4,#8]
000092  4345              MULS     r5,r0,r5
000094  a803              ADD      r0,sp,#0xc
000096  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009a  4602              MOV      r2,r0
00009c  4629              MOV      r1,r5
00009e  4640              MOV      r0,r8
0000a0  9b02              LDR      r3,[sp,#8]
0000a2  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a6  f8cd900c          STR      r9,[sp,#0xc]
0000aa  f8dd8010          LDR      r8,[sp,#0x10]
0000ae  f8df915c          LDR      r9,|L180.524|
0000b2  0005              MOVS     r5,r0
0000b4  d00e              BEQ      |L180.212|
0000b6  f1b80f10          CMP      r8,#0x10
0000ba  d21e              BCS      |L180.250|
0000bc  f2403023          MOV      r0,#0x323
0000c0  e9cd9000          STRD     r9,r0,[sp,#0]
0000c4  a32e              ADR      r3,|L180.384|
0000c6  a252              ADR      r2,|L180.528|
0000c8  a156              ADR      r1,|L180.548|
0000ca  2005              MOVS     r0,#5
0000cc  f7fffffe          BL       _Anki_Log
0000d0  f000b84f          B.W      |L180.370|
                  |L180.212|
0000d4  f240301e          MOV      r0,#0x31e
0000d8  e9cd9000          STRD     r9,r0,[sp,#0]
0000dc  a328              ADR      r3,|L180.384|
0000de  a259              ADR      r2,|L180.580|
0000e0  a15f              ADR      r1,|L180.608|
0000e2  2005              MOVS     r0,#5
0000e4  f7fffffe          BL       _Anki_Log
0000e8  f8c4b000          STR      r11,[r4,#0]
0000ec  f8c4b004          STR      r11,[r4,#4]
0000f0  f8c4b008          STR      r11,[r4,#8]
0000f4  f8c4a010          STR      r10,[r4,#0x10]
0000f8  e03b              B        |L180.370|
                  |L180.250|
0000fa  a803              ADD      r0,sp,#0xc
0000fc  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000100  2800              CMP      r0,#0
000102  d00a              BEQ      |L180.282|
000104  f2403026          MOV      r0,#0x326
000108  e9cd9000          STRD     r9,r0,[sp,#0]
00010c  a31c              ADR      r3,|L180.384|
00010e  a25a              ADR      r2,|L180.632|
000110  a144              ADR      r1,|L180.548|
000112  2005              MOVS     r0,#5
000114  f7fffffe          BL       _Anki_Log
000118  e02b              B        |L180.370|
                  |L180.282|
00011a  9903              LDR      r1,[sp,#0xc]
00011c  e9c41503          STRD     r1,r5,[r4,#0xc]
000120  f105000f          ADD      r0,r5,#0xf
000124  f020000f          BIC      r0,r0,#0xf
000128  e9c47600          STRD     r7,r6,[r4,#0]
00012c  1b40              SUBS     r0,r0,r5
00012e  2e01              CMP      r6,#1
000130  bfd8              IT       LE
000132  2601              MOVLE    r6,#1
000134  f106010f          ADD      r1,r6,#0xf
000138  f021010f          BIC      r1,r1,#0xf
00013c  fb010107          MLA      r1,r1,r7,r0
000140  4541              CMP      r1,r8
000142  bfdc              ITT      LE
000144  1829              ADDLE    r1,r5,r0
000146  6121              STRLE    r1,[r4,#0x10]
000148  dd13              BLE      |L180.370|
00014a  f2403035          MOV      r0,#0x335
00014e  f8cd9000          STR      r9,[sp,#0]
000152  e9cd0101          STRD     r0,r1,[sp,#4]
000156  a30a              ADR      r3,|L180.384|
000158  a251              ADR      r2,|L180.672|
00015a  a141              ADR      r1,|L180.608|
00015c  2005              MOVS     r0,#5
00015e  f7fffffe          BL       _Anki_Log
000162  f8c4b000          STR      r11,[r4,#0]
000166  f8c4b004          STR      r11,[r4,#4]
00016a  f8c4b008          STR      r11,[r4,#8]
00016e  f8c4a010          STR      r10,[r4,#0x10]
                  |L180.370|
000172  b005              ADD      sp,sp,#0x14
000174  4620              MOV      r0,r4
000176  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

00017a  0000              DCW      0x0000
                  |L180.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L180.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L180.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L180.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L180.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L180.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L180.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L180.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L180.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L180.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L180.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L180.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L180.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.181||, COMGROUP=_ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.181||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded8MeshgridIfE10EvaluateX1EbRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZNK4Anki8Embedded8MeshgridIfE10EvaluateX1EbRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded8MeshgridIfE10EvaluateX1EbRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Meshgrid<float>::EvaluateX1(bool, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer) const
;;;196    
;;;197        template<typename Type> Array<Type> Meshgrid<Type>::EvaluateX1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags) const
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;198        {
000004  460f              MOV      r7,r1
000006  4690              MOV      r8,r2
000008  b0a2              SUB      sp,sp,#0x88
00000a  6809              LDR      r1,[r1,#0]
;;;199          const s32 numRows = 1;
;;;200          const s32 numCols = this->xGridVector.get_size()*this->yGridVector.get_size();
00000c  68fa              LDR      r2,[r7,#0xc]
00000e  4606              MOV      r6,r0                 ;198
000010  982a              LDR      r0,[sp,#0xa8]         ;198
000012  434a              MULS     r2,r1,r2
;;;201    
;;;202          Array<Type> out(numRows, numCols, memory, flags);
000014  9000              STR      r0,[sp,#0]
000016  2101              MOVS     r1,#1
000018  a80f              ADD      r0,sp,#0x3c
00001a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00001e  e9dd0112          LDRD     r0,r1,[sp,#0x48]
000022  e9cd0100          STRD     r0,r1,[sp,#0]
;;;203    
;;;204          this->EvaluateX1(isOutColumnMajor, out);
000026  e9dd120f          LDRD     r1,r2,[sp,#0x3c]
00002a  a814              ADD      r0,sp,#0x50
00002c  9b11              LDR      r3,[sp,#0x44]
00002e  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEE ; Anki::Embedded::ArraySlice<float>::ArraySlice(Anki::Embedded::Array<float>)
000032  e890163e          LDM      r0,{r1-r5,r9,r10,r12}
000036  f10d0e08          ADD      lr,sp,#8
00003a  e8ae163e          STM      lr!,{r1-r5,r9,r10,r12}
00003e  f1000120          ADD      r1,r0,#0x20
000042  6b00              LDR      r0,[r0,#0x30]
000044  e891100e          LDM      r1,{r1-r3,r12}
000048  930c              STR      r3,[sp,#0x30]
00004a  e9cdc00d          STRD     r12,r0,[sp,#0x34]
00004e  e9cd120a          STRD     r1,r2,[sp,#0x28]
000052  683d              LDR      r5,[r7,#0]
000054  68fc              LDR      r4,[r7,#0xc]
000056  a808              ADD      r0,sp,#0x20
000058  fb05f904          MUL      r9,r5,r4
00005c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000060  0001              MOVS     r1,r0
000062  482f              LDR      r0,|L187.288|
000064  d010              BEQ      |L187.136|
000066  9902              LDR      r1,[sp,#8]
000068  2901              CMP      r1,#1
00006a  bf04              ITT      EQ
00006c  9905              LDREQ    r1,[sp,#0x14]
00006e  4549              CMPEQ    r1,r9
000070  d014              BEQ      |L187.156|
000072  f44f7180          MOV      r1,#0x100
000076  e9cd0100          STRD     r0,r1,[sp,#0]
00007a  a32a              ADR      r3,|L187.292|
00007c  a238              ADR      r2,|L187.352|
00007e  a141              ADR      r1,|L187.388|
000080  2005              MOVS     r0,#5
000082  f7fffffe          BL       _Anki_Log
000086  e042              B        |L187.270|
                  |L187.136|
000088  21fd              MOVS     r1,#0xfd
00008a  e9cd0100          STRD     r0,r1,[sp,#0]
00008e  a325              ADR      r3,|L187.292|
000090  a243              ADR      r2,|L187.416|
000092  a13c              ADR      r1,|L187.388|
000094  2005              MOVS     r0,#5
000096  f7fffffe          BL       _Anki_Log
00009a  e038              B        |L187.270|
                  |L187.156|
00009c  9803              LDR      r0,[sp,#0xc]
00009e  9a0a              LDR      r2,[sp,#0x28]
0000a0  990c              LDR      r1,[sp,#0x30]
0000a2  9b07              LDR      r3,[sp,#0x1c]
0000a4  fb001202          MLA      r2,r0,r2,r1
0000a8  edd70a01          VLDR     s1,[r7,#4]
0000ac  ed971a02          VLDR     s2,[r7,#8]
0000b0  9906              LDR      r1,[sp,#0x18]
0000b2  f1b80f00          CMP      r8,#0
0000b6  f04f0c00          MOV      r12,#0
0000ba  d013              BEQ      |L187.228|
0000bc  2d00              CMP      r5,#0
0000be  dd26              BLE      |L187.270|
                  |L187.192|
0000c0  2000              MOVS     r0,#0
0000c2  2c00              CMP      r4,#0
0000c4  dd07              BLE      |L187.214|
                  |L187.198|
0000c6  eb020781          ADD      r7,r2,r1,LSL #2
0000ca  1c40              ADDS     r0,r0,#1
0000cc  edc70a00          VSTR     s1,[r7,#0]
0000d0  4419              ADD      r1,r1,r3
0000d2  4284              CMP      r4,r0
0000d4  dcf7              BGT      |L187.198|
                  |L187.214|
0000d6  ee700a81          VADD.F32 s1,s1,s2
0000da  f10c0c01          ADD      r12,r12,#1
0000de  45ac              CMP      r12,r5
0000e0  dbee              BLT      |L187.192|
0000e2  e014              B        |L187.270|
                  |L187.228|
0000e4  2c00              CMP      r4,#0
0000e6  dd12              BLE      |L187.270|
                  |L187.232|
0000e8  2000              MOVS     r0,#0
0000ea  eeb00a60          VMOV.F32 s0,s1
0000ee  2d00              CMP      r5,#0
0000f0  dd09              BLE      |L187.262|
                  |L187.242|
0000f2  eb020781          ADD      r7,r2,r1,LSL #2
0000f6  1c40              ADDS     r0,r0,#1
0000f8  ed870a00          VSTR     s0,[r7,#0]
0000fc  ee300a01          VADD.F32 s0,s0,s2
000100  4419              ADD      r1,r1,r3
000102  4285              CMP      r5,r0
000104  dcf5              BGT      |L187.242|
                  |L187.262|
000106  f10c0c01          ADD      r12,r12,#1
00010a  45a4              CMP      r12,r4
00010c  dbec              BLT      |L187.232|
                  |L187.270|
00010e  ac0f              ADD      r4,sp,#0x3c
000110  e8b4100f          LDM      r4!,{r0-r3,r12}
000114  e8a6100f          STM      r6!,{r0-r3,r12}
;;;205    
;;;206          return out;
;;;207        }
000118  b022              ADD      sp,sp,#0x88
00011a  e8bd87f0          POP      {r4-r10,pc}
;;;208    
                          ENDP

00011e  0000              DCW      0x0000
                  |L187.288|
                          DCD      _ZZNK4Anki8Embedded8MeshgridIfE10EvaluateX1EbNS0_10ArraySliceIfEEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Meshgrid<float>::EvaluateX1(bool, Anki::Embedded::ArraySlice<float>) const::__PRETTY_FUNCTION__
                  |L187.292|
000124  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/sequen"
000128  6f726574
00012c  6563685c
000130  636f6d6d
000134  6f6e5c69
000138  6e636c75
00013c  64655c61
000140  6e6b692f
000144  636f6d6d
000148  6f6e2f72
00014c  6f626f74
000150  2f736571
000154  75656e  
000157  6365732e          DCB      "ces.h",0
00015b  6800    
00015d  00                DCB      0
00015e  00                DCB      0
00015f  00                DCB      0
                  |L187.352|
000160  41727261          DCB      "Array out is not the correct size",0
000164  79206f75
000168  74206973
00016c  206e6f74
000170  20746865
000174  20636f72
000178  72656374
00017c  2073697a
000180  6500    
000182  00                DCB      0
000183  00                DCB      0
                  |L187.388|
000184  4d657368          DCB      "Meshgrid<Type>::Evaluate",0
000188  67726964
00018c  3c547970
000190  653e3a3a
000194  4576616c
000198  75617465
00019c  00      
00019d  00                DCB      0
00019e  00                DCB      0
00019f  00                DCB      0
                  |L187.416|
0001a0  496e7661          DCB      "Invalid array",0
0001a4  6c696420
0001a8  61727261
0001ac  7900    
0001ae  00                DCB      0
0001af  00                DCB      0

                          AREA ||area_number.188||, COMGROUP=_ZNK4Anki8Embedded8MeshgridIfE10EvaluateX1EbRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZNK4Anki8Embedded8MeshgridIfE10EvaluateX1EbRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.188||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded8MeshgridIfE10EvaluateX1EbRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded8MeshgridIfE10EvaluateY1EbRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZNK4Anki8Embedded8MeshgridIfE10EvaluateY1EbRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded8MeshgridIfE10EvaluateY1EbRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Meshgrid<float>::EvaluateY1(bool, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer) const
;;;220    
;;;221        template<typename Type> Array<Type> Meshgrid<Type>::EvaluateY1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags) const
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;222        {
000004  460f              MOV      r7,r1
000006  4690              MOV      r8,r2
000008  b0a2              SUB      sp,sp,#0x88
00000a  6809              LDR      r1,[r1,#0]
;;;223          const s32 numRows = 1;
;;;224          const s32 numCols = this->xGridVector.get_size()*this->yGridVector.get_size();
00000c  68fa              LDR      r2,[r7,#0xc]
00000e  4606              MOV      r6,r0                 ;222
000010  982a              LDR      r0,[sp,#0xa8]         ;222
000012  434a              MULS     r2,r1,r2
;;;225    
;;;226          Array<Type> out(numRows, numCols, memory, flags);
000014  9000              STR      r0,[sp,#0]
000016  2101              MOVS     r1,#1
000018  a80f              ADD      r0,sp,#0x3c
00001a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00001e  e9dd0112          LDRD     r0,r1,[sp,#0x48]
000022  e9cd0100          STRD     r0,r1,[sp,#0]
;;;227    
;;;228          this->EvaluateY1(isOutColumnMajor, out);
000026  e9dd120f          LDRD     r1,r2,[sp,#0x3c]
00002a  a814              ADD      r0,sp,#0x50
00002c  9b11              LDR      r3,[sp,#0x44]
00002e  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEE ; Anki::Embedded::ArraySlice<float>::ArraySlice(Anki::Embedded::Array<float>)
000032  e890163e          LDM      r0,{r1-r5,r9,r10,r12}
000036  f10d0e08          ADD      lr,sp,#8
00003a  e8ae163e          STM      lr!,{r1-r5,r9,r10,r12}
00003e  f1000120          ADD      r1,r0,#0x20
000042  6b00              LDR      r0,[r0,#0x30]
000044  e891100e          LDM      r1,{r1-r3,r12}
000048  930c              STR      r3,[sp,#0x30]
00004a  e9cdc00d          STRD     r12,r0,[sp,#0x34]
00004e  e9cd120a          STRD     r1,r2,[sp,#0x28]
000052  683d              LDR      r5,[r7,#0]
000054  68fc              LDR      r4,[r7,#0xc]
000056  a808              ADD      r0,sp,#0x20
000058  fb05f904          MUL      r9,r5,r4
00005c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000060  0001              MOVS     r1,r0
000062  482f              LDR      r0,|L194.288|
000064  d010              BEQ      |L194.136|
000066  9902              LDR      r1,[sp,#8]
000068  2901              CMP      r1,#1
00006a  bf04              ITT      EQ
00006c  9905              LDREQ    r1,[sp,#0x14]
00006e  4549              CMPEQ    r1,r9
000070  d015              BEQ      |L194.158|
000072  f240116d          MOV      r1,#0x16d
000076  e9cd0100          STRD     r0,r1,[sp,#0]
00007a  a32a              ADR      r3,|L194.292|
00007c  a238              ADR      r2,|L194.352|
00007e  a141              ADR      r1,|L194.388|
000080  2005              MOVS     r0,#5
000082  f7fffffe          BL       _Anki_Log
000086  e043              B        |L194.272|
                  |L194.136|
000088  f44f71b5          MOV      r1,#0x16a
00008c  e9cd0100          STRD     r0,r1,[sp,#0]
000090  a324              ADR      r3,|L194.292|
000092  a243              ADR      r2,|L194.416|
000094  a13b              ADR      r1,|L194.388|
000096  2005              MOVS     r0,#5
000098  f7fffffe          BL       _Anki_Log
00009c  e038              B        |L194.272|
                  |L194.158|
00009e  9803              LDR      r0,[sp,#0xc]
0000a0  9a0a              LDR      r2,[sp,#0x28]
0000a2  990c              LDR      r1,[sp,#0x30]
0000a4  9b07              LDR      r3,[sp,#0x1c]
0000a6  fb001202          MLA      r2,r0,r2,r1
0000aa  edd70a04          VLDR     s1,[r7,#0x10]
0000ae  ed971a05          VLDR     s2,[r7,#0x14]
0000b2  9906              LDR      r1,[sp,#0x18]
0000b4  f1b80f00          CMP      r8,#0
0000b8  f04f0c00          MOV      r12,#0
0000bc  d015              BEQ      |L194.234|
0000be  2d00              CMP      r5,#0
0000c0  dd26              BLE      |L194.272|
                  |L194.194|
0000c2  2000              MOVS     r0,#0
0000c4  eeb00a60          VMOV.F32 s0,s1
0000c8  2c00              CMP      r4,#0
0000ca  dd09              BLE      |L194.224|
                  |L194.204|
0000cc  eb020781          ADD      r7,r2,r1,LSL #2
0000d0  1c40              ADDS     r0,r0,#1
0000d2  ed870a00          VSTR     s0,[r7,#0]
0000d6  ee300a01          VADD.F32 s0,s0,s2
0000da  4419              ADD      r1,r1,r3
0000dc  4284              CMP      r4,r0
0000de  dcf5              BGT      |L194.204|
                  |L194.224|
0000e0  f10c0c01          ADD      r12,r12,#1
0000e4  45ac              CMP      r12,r5
0000e6  dbec              BLT      |L194.194|
0000e8  e012              B        |L194.272|
                  |L194.234|
0000ea  2c00              CMP      r4,#0
0000ec  dd10              BLE      |L194.272|
                  |L194.238|
0000ee  2000              MOVS     r0,#0
0000f0  2d00              CMP      r5,#0
0000f2  dd07              BLE      |L194.260|
                  |L194.244|
0000f4  eb020781          ADD      r7,r2,r1,LSL #2
0000f8  1c40              ADDS     r0,r0,#1
0000fa  edc70a00          VSTR     s1,[r7,#0]
0000fe  4419              ADD      r1,r1,r3
000100  4285              CMP      r5,r0
000102  dcf7              BGT      |L194.244|
                  |L194.260|
000104  ee700a81          VADD.F32 s1,s1,s2
000108  f10c0c01          ADD      r12,r12,#1
00010c  45a4              CMP      r12,r4
00010e  dbee              BLT      |L194.238|
                  |L194.272|
000110  ac0f              ADD      r4,sp,#0x3c
000112  e8b4100f          LDM      r4!,{r0-r3,r12}
000116  e8a6100f          STM      r6!,{r0-r3,r12}
;;;229    
;;;230          return out;
;;;231        }
00011a  b022              ADD      sp,sp,#0x88
00011c  e8bd87f0          POP      {r4-r10,pc}
;;;232    
                          ENDP

                  |L194.288|
                          DCD      _ZZNK4Anki8Embedded8MeshgridIfE10EvaluateY1EbNS0_10ArraySliceIfEEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Meshgrid<float>::EvaluateY1(bool, Anki::Embedded::ArraySlice<float>) const::__PRETTY_FUNCTION__
                  |L194.292|
000124  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/sequen"
000128  6f726574
00012c  6563685c
000130  636f6d6d
000134  6f6e5c69
000138  6e636c75
00013c  64655c61
000140  6e6b692f
000144  636f6d6d
000148  6f6e2f72
00014c  6f626f74
000150  2f736571
000154  75656e  
000157  6365732e          DCB      "ces.h",0
00015b  6800    
00015d  00                DCB      0
00015e  00                DCB      0
00015f  00                DCB      0
                  |L194.352|
000160  41727261          DCB      "Array out is not the correct size",0
000164  79206f75
000168  74206973
00016c  206e6f74
000170  20746865
000174  20636f72
000178  72656374
00017c  2073697a
000180  6500    
000182  00                DCB      0
000183  00                DCB      0
                  |L194.388|
000184  4d657368          DCB      "Meshgrid<Type>::Evaluate",0
000188  67726964
00018c  3c547970
000190  653e3a3a
000194  4576616c
000198  75617465
00019c  00      
00019d  00                DCB      0
00019e  00                DCB      0
00019f  00                DCB      0
                  |L194.416|
0001a0  496e7661          DCB      "Invalid array",0
0001a4  6c696420
0001a8  61727261
0001ac  7900    
0001ae  00                DCB      0
0001af  00                DCB      0

                          AREA ||area_number.195||, COMGROUP=_ZNK4Anki8Embedded8MeshgridIfE10EvaluateY1EbRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZNK4Anki8Embedded8MeshgridIfE10EvaluateY1EbRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.195||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded8MeshgridIfE10EvaluateY1EbRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Array<float>>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L201.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L201.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.202||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.202||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L208.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L208.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.209||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.209||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListIfEC1Ev||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIfEC1Ev, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListIfEC2Ev                  ; Alternate entry point ; Anki::Embedded::FixedLengthList<float>::FixedLengthList__sub_object()
                  _ZN4Anki8Embedded15FixedLengthListIfEC1Ev PROC ; Anki::Embedded::FixedLengthList<float>::FixedLengthList()
;;;52     
;;;53         template<typename Type> FixedLengthList<Type>::FixedLengthList()
;;;54           : ArraySlice<Type>()
;;;55         {
;;;56           this->arrayData = NULL;
;;;57           this->set_size(0);
;;;58         } // FixedLengthList<Type>::FixedLengthList()
;;;59     
000000  b570              PUSH     {r4-r6,lr}
000002  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
000006  300c              ADDS     r0,r0,#0xc
000008  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Ev ; Anki::Embedded::LinearSequence<int>::LinearSequence()
00000c  3018              ADDS     r0,r0,#0x18
00000e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000012  f04f31ff          MOV      r1,#0xffffffff
000016  f8401d0c          STR      r1,[r0,#-0xc]!
00001a  f1a00418          SUB      r4,r0,#0x18
00001e  6041              STR      r1,[r0,#4]
000020  6081              STR      r1,[r0,#8]
000022  2100              MOVS     r1,#0
000024  6101              STR      r1,[r0,#0x10]
000026  6141              STR      r1,[r0,#0x14]
000028  460d              MOV      r5,r1
00002a  6181              STR      r1,[r0,#0x18]
00002c  2101              MOVS     r1,#1
00002e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000032  42a8              CMP      r0,r5
000034  da05              BGE      |L215.66|
000036  2101              MOVS     r1,#1
000038  f1040018          ADD      r0,r4,#0x18
00003c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000040  4605              MOV      r5,r0
                  |L215.66|
000042  4620              MOV      r0,r4
000044  60e5              STR      r5,[r4,#0xc]
000046  bd70              POP      {r4-r6,pc}
                          ENDP


                          AREA ||area_number.216||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIfEC1Ev, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListIfEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.216||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListIfEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS1_INS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS1_INS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS1_INS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L222.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L222.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.223||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS1_INS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS1_INS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.223||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS1_INS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i||, COMGROUP=_ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i PROC ; Anki::Embedded::Linspace<float>(T1, T1, int)
;;;162    
;;;163        template<typename Type> LinearSequence<Type> Linspace(const Type start, const Type end, const s32 size)
000000  b086              SUB      sp,sp,#0x18
000002  f04f32ff          MOV      r2,#0xffffffff
000006  eebf1a00          VMOV.F32 s2,#-1.00000000
00000a  9200              STR      r2,[sp,#0]
00000c  ed8d1a01          VSTR     s2,[sp,#4]
000010  ed8d1a02          VSTR     s2,[sp,#8]
;;;164        {
;;;165          Type increment;
;;;166    
;;;167          LinearSequence<Type> sequence;
;;;168    
;;;169          if(ABS(end-start) <= Flags::numeric_limits<Type>::epsilon()) {
000014  ee301ac0          VSUB.F32 s2,s1,s0
000018  ed9f2a2e          VLDR     s4,|L229.212|
00001c  eeb51ac0          VCMPE.F32 s2,#0.0
000020  eef1fa10          VMRS     APSR_nzcv,FPSCR
000024  bfac              ITE      GE
000026  eef01a41          VMOVGE.F32 s3,s2
00002a  ee701a60          VSUBLT.F32 s3,s0,s1
00002e  eef41ac2          VCMPE.F32 s3,s4
000032  eef1fa10          VMRS     APSR_nzcv,FPSCR
000036  d810              BHI      |L229.90|
000038  9103              STR      r1,[sp,#0xc]          ;164
;;;170            sequence = LinearSequence<Type>(start, 0, end, size);
00003a  eddf0a27          VLDR     s1,|L229.216|
00003e  ed8d0a04          VSTR     s0,[sp,#0x10]
000042  edcd0a05          VSTR     s1,[sp,#0x14]
000046  9100              STR      r1,[sp,#0]
000048  ed8d0a01          VSTR     s0,[sp,#4]
00004c  ee102a10          VMOV     r2,s0
000050  ee103a90          VMOV     r3,s1
000054  edcd0a02          VSTR     s1,[sp,#8]
;;;171          } else {
000058  e028              B        |L229.172|
                  |L229.90|
;;;172            if(size <= 0) {
;;;173              // Empty sequence
;;;174              sequence = LinearSequence<Type>(start, 1, end, 0);
00005a  eef71a00          VMOV.F32 s3,#1.00000000
00005e  2900              CMP      r1,#0                 ;172
000060  dc0d              BGT      |L229.126|
000062  2100              MOVS     r1,#0
000064  9103              STR      r1,[sp,#0xc]
000066  ed8d0a04          VSTR     s0,[sp,#0x10]
00006a  edcd1a05          VSTR     s3,[sp,#0x14]
00006e  9100              STR      r1,[sp,#0]
000070  ee102a10          VMOV     r2,s0
000074  ee113a90          VMOV     r3,s3
000078  ed8d0a01          VSTR     s0,[sp,#4]
;;;175            } else if(size == 1) {
00007c  e027              B        |L229.206|
                  |L229.126|
00007e  2901              CMP      r1,#1
000080  d019              BEQ      |L229.182|
;;;176              // If size == 1, match output with Matlab
;;;177              sequence = LinearSequence<Type>(end, 1, end, size);
;;;178            } else {
;;;179              increment = (end-start) / (size-1);
000082  1e4a              SUBS     r2,r1,#1
000084  ee002a90          VMOV     s1,r2
000088  9103              STR      r1,[sp,#0xc]
00008a  ed8d0a04          VSTR     s0,[sp,#0x10]
00008e  eef81ae0          VCVT.F32.S32 s3,s1
;;;180              sequence = LinearSequence<Type>(start, increment, end, size);
000092  ee102a10          VMOV     r2,s0
000096  eec10a21          VDIV.F32 s1,s2,s3              ;179
00009a  edcd0a05          VSTR     s1,[sp,#0x14]         ;179
00009e  ee103a90          VMOV     r3,s1
0000a2  9100              STR      r1,[sp,#0]
0000a4  ed8d0a01          VSTR     s0,[sp,#4]
0000a8  edcd0a02          VSTR     s1,[sp,#8]
                  |L229.172|
;;;181            }
;;;182          }
;;;183    
;;;184          return sequence;
0000ac  6083              STR      r3,[r0,#8]
0000ae  e9c01200          STRD     r1,r2,[r0,#0]
;;;185        }
0000b2  b006              ADD      sp,sp,#0x18
0000b4  4770              BX       lr
                  |L229.182|
0000b6  9103              STR      r1,[sp,#0xc]
0000b8  edcd0a04          VSTR     s1,[sp,#0x10]
0000bc  edcd1a05          VSTR     s3,[sp,#0x14]
0000c0  ee102a90          VMOV     r2,s1                 ;177
0000c4  ee113a90          VMOV     r3,s3                 ;177
0000c8  9100              STR      r1,[sp,#0]            ;177
0000ca  edcd0a01          VSTR     s1,[sp,#4]            ;177
                  |L229.206|
0000ce  edcd1a02          VSTR     s3,[sp,#8]            ;177
0000d2  e7eb              B        |L229.172|
;;;186    
                          ENDP

                  |L229.212|
0000d4  34000000          DCFS     0x34000000 ; 1.1920928955078125e-07
                  |L229.216|
0000d8  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.230||, COMGROUP=_ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i, LINKORDER=||t._ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.230||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EE PROC ; Anki::Embedded::Matrix::Vectorize<float, float>(bool, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
;;;673    
;;;674          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;675          {
000004  460c              MOV      r4,r1
000006  4681              MOV      r9,r0
000008  b082              SUB      sp,sp,#8
00000a  4615              MOV      r5,r2
;;;676            AnkiConditionalErrorAndReturnValue(out.get_size(0) == 1,
00000c  2100              MOVS     r1,#0
00000e  4610              MOV      r0,r2
000010  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000014  2801              CMP      r0,#1
000016  d00f              BEQ      |L236.56|
000018  f44f7129          MOV      r1,#0x2a4
00001c  4844              LDR      r0,|L236.304|
00001e  e9cd0100          STRD     r0,r1,[sp,#0]
000022  a344              ADR      r3,|L236.308|
000024  a251              ADR      r2,|L236.364|
000026  a156              ADR      r1,|L236.384|
000028  2005              MOVS     r0,#5
00002a  f7fffffe          BL       _Anki_Log
;;;677              RESULT_FAIL_INVALID_SIZE, "Vectorize", "Output is not 1xN");
;;;678    
;;;679            return Reshape<InType, OutType>(isColumnMajor, in, out);
;;;680          }
00002e  b002              ADD      sp,sp,#8
000030  f04f60a0          MOV      r0,#0x5000000         ;676
000034  e8bd87f0          POP      {r4-r10,pc}
                  |L236.56|
000038  2100              MOVS     r1,#0
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000040  4680              MOV      r8,r0
000042  2101              MOVS     r1,#1
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00004a  4607              MOV      r7,r0
00004c  2100              MOVS     r1,#0
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000054  4606              MOV      r6,r0
000056  2101              MOVS     r1,#1
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00005e  4601              MOV      r1,r0
000060  fb08f007          MUL      r0,r8,r7
000064  fb06f201          MUL      r2,r6,r1
000068  4290              CMP      r0,r2
00006a  d00f              BEQ      |L236.140|
00006c  f44f711b          MOV      r1,#0x26c
000070  4846              LDR      r0,|L236.396|
000072  e9cd0100          STRD     r0,r1,[sp,#0]
000076  a32f              ADR      r3,|L236.308|
000078  a245              ADR      r2,|L236.400|
00007a  a152              ADR      r1,|L236.452|
00007c  2005              MOVS     r0,#5
00007e  f7fffffe          BL       _Anki_Log
000082  b002              ADD      sp,sp,#8
000084  f04f60a0          MOV      r0,#0x5000000
000088  e8bd87f0          POP      {r4-r10,pc}
                  |L236.140|
00008c  2200              MOVS     r2,#0
00008e  4610              MOV      r0,r2
000090  f1b90f00          CMP      r9,#0
000094  4694              MOV      r12,r2
000096  d022              BEQ      |L236.222|
000098  2e00              CMP      r6,#0
00009a  dd44              BLE      |L236.294|
                  |L236.156|
00009c  68af              LDR      r7,[r5,#8]
00009e  692b              LDR      r3,[r5,#0x10]
0000a0  fb0c3a07          MLA      r10,r12,r7,r3
0000a4  2300              MOVS     r3,#0
0000a6  2900              CMP      r1,#0
0000a8  dd14              BLE      |L236.212|
                  |L236.170|
0000aa  f8d49008          LDR      r9,[r4,#8]
0000ae  6927              LDR      r7,[r4,#0x10]
0000b0  fb027709          MLA      r7,r2,r9,r7
0000b4  eb070780          ADD      r7,r7,r0,LSL #2
0000b8  1c52              ADDS     r2,r2,#1
0000ba  ed970a00          VLDR     s0,[r7,#0]
0000be  eb0a0783          ADD      r7,r10,r3,LSL #2
0000c2  4542              CMP      r2,r8
0000c4  ed870a00          VSTR     s0,[r7,#0]
0000c8  bfa4              ITT      GE
0000ca  2200              MOVGE    r2,#0
0000cc  1c40              ADDGE    r0,r0,#1
0000ce  1c5b              ADDS     r3,r3,#1
0000d0  428b              CMP      r3,r1
0000d2  dbea              BLT      |L236.170|
                  |L236.212|
0000d4  f10c0c01          ADD      r12,r12,#1
0000d8  45b4              CMP      r12,r6
0000da  dbdf              BLT      |L236.156|
0000dc  e023              B        |L236.294|
                  |L236.222|
0000de  2e00              CMP      r6,#0
0000e0  dd21              BLE      |L236.294|
                  |L236.226|
0000e2  f8d58008          LDR      r8,[r5,#8]
0000e6  692b              LDR      r3,[r5,#0x10]
0000e8  fb0c3a08          MLA      r10,r12,r8,r3
0000ec  2300              MOVS     r3,#0
0000ee  2900              CMP      r1,#0
0000f0  dd15              BLE      |L236.286|
                  |L236.242|
0000f2  f8d49008          LDR      r9,[r4,#8]
0000f6  f8d48010          LDR      r8,[r4,#0x10]
0000fa  fb028809          MLA      r8,r2,r9,r8
0000fe  eb080880          ADD      r8,r8,r0,LSL #2
000102  1c40              ADDS     r0,r0,#1
000104  ed980a00          VLDR     s0,[r8,#0]
000108  eb0a0883          ADD      r8,r10,r3,LSL #2
00010c  42b8              CMP      r0,r7
00010e  ed880a00          VSTR     s0,[r8,#0]
000112  bfa4              ITT      GE
000114  2000              MOVGE    r0,#0
000116  1c52              ADDGE    r2,r2,#1
000118  1c5b              ADDS     r3,r3,#1
00011a  428b              CMP      r3,r1
00011c  dbe9              BLT      |L236.242|
                  |L236.286|
00011e  f10c0c01          ADD      r12,r12,#1
000122  45b4              CMP      r12,r6
000124  dbdd              BLT      |L236.226|
                  |L236.294|
000126  b002              ADD      sp,sp,#8
000128  2000              MOVS     r0,#0
00012a  e8bd87f0          POP      {r4-r10,pc}
;;;681    
                          ENDP

00012e  0000              DCW      0x0000
                  |L236.304|
                          DCD      _ZZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Vectorize<float, float>(bool, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L236.308|
000134  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000138  6f726574
00013c  6563685c
000140  636f6d6d
000144  6f6e5c69
000148  6e636c75
00014c  64655c61
000150  6e6b692f
000154  636f6d6d
000158  6f6e2f72
00015c  6f626f74
000160  2f6d6174
000164  726978  
000167  2e6800            DCB      ".h",0
00016a  00                DCB      0
00016b  00                DCB      0
                  |L236.364|
00016c  4f757470          DCB      "Output is not 1xN",0
000170  75742069
000174  73206e6f
000178  74203178
00017c  4e00    
00017e  00                DCB      0
00017f  00                DCB      0
                  |L236.384|
000180  56656374          DCB      "Vectorize",0
000184  6f72697a
000188  6500    
00018a  00                DCB      0
00018b  00                DCB      0
                  |L236.396|
                          DCD      _ZZN4Anki8Embedded6Matrix7ReshapeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Reshape<float, float>(bool, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L236.400|
000190  496e7075          DCB      "Input and Output matrices are incompatible sizes",0
000194  7420616e
000198  64204f75
00019c  74707574
0001a0  206d6174
0001a4  72696365
0001a8  73206172
0001ac  6520696e
0001b0  636f6d70
0001b4  61746962
0001b8  6c652073
0001bc  697a6573
0001c0  00      
0001c1  00                DCB      0
0001c2  00                DCB      0
0001c3  00                DCB      0
                  |L236.452|
0001c4  52657368          DCB      "Reshape",0
0001c8  61706500

                          AREA ||area_number.237||, COMGROUP=_ZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.237||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded18Interp2_ProjectiveIhfEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_||, COMGROUP=_ZN4Anki8Embedded18Interp2_ProjectiveIhfEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded18Interp2_ProjectiveIhfEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_ PROC ; Anki::Embedded::Interp2_Projective<unsigned char, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Meshgrid<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::Array<T2>&, Anki::Embedded::InterpolationType, T2)
;;;273    
;;;274        template<typename InType, typename OutType> Result Interp2_Projective(const Array<InType> &reference, const Meshgrid<f32> &originalCoordinates, const Array<f32> &homography, const Point<f32> &centerOffset, Array<OutType> &out, const InterpolationType interpolationType, const OutType invalidValue)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;275        {
000004  4607              MOV      r7,r0
000006  ed2d0b02          VPUSH    {d0}
00000a  4699              MOV      r9,r3
;;;276          AnkiConditionalErrorAndReturnValue(interpolationType == INTERPOLATE_LINEAR,
00000c  4de7              LDR      r5,|L243.940|
00000e  4690              MOV      r8,r2                 ;275
000010  ed2d8b10          VPUSH    {d8-d15}              ;275
000014  b089              SUB      sp,sp,#0x24           ;275
000016  460e              MOV      r6,r1                 ;275
000018  e9dda028          LDRD     r10,r0,[sp,#0xa0]     ;275
00001c  2800              CMP      r0,#0
00001e  d011              BEQ      |L243.68|
000020  f44f708a          MOV      r0,#0x114
000024  e9cd5000          STRD     r5,r0,[sp,#0]
000028  a3e1              ADR      r3,|L243.944|
00002a  a2f0              ADR      r2,|L243.1004|
00002c  a1f9              ADR      r1,|L243.1044|
00002e  2005              MOVS     r0,#5
000030  f7fffffe          BL       _Anki_Log
000034  f04f7040          MOV      r0,#0x3000000
                  |L243.56|
;;;277            RESULT_FAIL_INVALID_PARAMETER, "Interp2_Projective", "Only INTERPOLATE_LINEAR is supported");
;;;278    
;;;279          AnkiConditionalErrorAndReturnValue(AreValid(reference, out),
;;;280            RESULT_FAIL_INVALID_OBJECT, "Interp2_Projective", "Invalid objects");
;;;281    
;;;282          AnkiConditionalErrorAndReturnValue(NotAliased(reference, out),
;;;283            RESULT_FAIL_ALIASED_MEMORY, "Interp2_Projective", "reference cannot be the same as out");
;;;284    
;;;285          //AnkiConditionalErrorAndReturnValue(FLT_NEAR(homography[2][2], 1.0f),
;;;286          //  RESULT_FAIL_INVALID_PARAMETER, "Interp2_Projective", "homography[2][2] should be 1.0");
;;;287    
;;;288          const s32 referenceHeight = reference.get_size(0);
;;;289          const s32 referenceWidth = reference.get_size(1);
;;;290    
;;;291          const s32 outHeight = out.get_size(0);
;;;292          const s32 outWidth = out.get_size(1);
;;;293    
;;;294          const bool isOutputOneDimensional = (out.get_size(0) == 1);
;;;295    
;;;296          const f32 xyReferenceMin = 0.0f;
;;;297          const f32 xReferenceMax = static_cast<f32>(referenceWidth) - 1.0f;
;;;298          const f32 yReferenceMax = static_cast<f32>(referenceHeight) - 1.0f;
;;;299    
;;;300          const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2];
;;;301          const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2];
;;;302          const f32 h20 = homography[2][0]; const f32 h21 = homography[2][1]; const f32 h22 = homography[2][2];
;;;303    
;;;304          const LinearSequence<f32> &yGridVector = originalCoordinates.get_yGridVector();
;;;305          const LinearSequence<f32> &xGridVector = originalCoordinates.get_xGridVector();
;;;306    
;;;307          const f32 yGridStart = yGridVector.get_start();
;;;308          const f32 xGridStart = xGridVector.get_start();
;;;309    
;;;310          const f32 yGridDelta = yGridVector.get_increment();
;;;311          const f32 xGridDelta = xGridVector.get_increment();
;;;312    
;;;313          const s32 yIterationMax = yGridVector.get_size();
;;;314          const s32 xIterationMax = xGridVector.get_size();
;;;315    
;;;316          // One last check, to see if the sizes match
;;;317          if(isOutputOneDimensional) {
;;;318            const s32 numOutputElements = outHeight * outWidth;
;;;319            const s32 numOriginalCoordinates = xGridVector.get_size() * yGridVector.get_size();
;;;320    
;;;321            AnkiConditionalErrorAndReturnValue(
;;;322              outWidth == numOutputElements &&
;;;323              numOriginalCoordinates == numOutputElements,
;;;324              RESULT_FAIL_INVALID_SIZE, "Interp2_Projective", "originalCoordinates is the wrong size");
;;;325          } else {
;;;326            AnkiConditionalErrorAndReturnValue(
;;;327              yGridVector.get_size() == outHeight &&
;;;328              xGridVector.get_size() == outWidth,
;;;329              RESULT_FAIL_INVALID_SIZE, "Interp2_Projective", "originalCoordinates is the wrong size");
;;;330          }
;;;331    
;;;332          OutType * restrict pOut = out.Pointer(0,0);
;;;333    
;;;334          if(isOutputOneDimensional) {
;;;335            // pOut is incremented at the top of the loop, so decrement it here
;;;336            pOut -= xIterationMax;
;;;337          }
;;;338    
;;;339          f32 yOriginal = yGridStart;
;;;340          for(s32 y=0; y<yIterationMax; y++) {
;;;341            if(isOutputOneDimensional) {
;;;342              // If the output is one dimensional, then we will do the next set of x iterations later on
;;;343              // the same output row
;;;344              pOut += xIterationMax;
;;;345            } else {
;;;346              pOut = out.Pointer(y,0);
;;;347            }
;;;348    
;;;349            f32 xOriginal = xGridStart;
;;;350    
;;;351            for(s32 x=0; x<xIterationMax; x++) {
;;;352              // TODO: These two could be strength reduced
;;;353              const f32 xTransformedRaw = h00*xOriginal + h01*yOriginal + h02;
;;;354              const f32 yTransformedRaw = h10*xOriginal + h11*yOriginal + h12;
;;;355    
;;;356              const f32 normalization = h20*xOriginal + h21*yOriginal + h22;
;;;357    
;;;358              const f32 xTransformed = (xTransformedRaw / normalization) + centerOffset.x;
;;;359              const f32 yTransformed = (yTransformedRaw / normalization) + centerOffset.y;
;;;360    
;;;361              xOriginal += xGridDelta;
;;;362    
;;;363              const f32 x0 = FLT_FLOOR(xTransformed);
;;;364              const f32 x1 = ceilf(xTransformed); // x0 + 1.0f;
;;;365    
;;;366              const f32 y0 = FLT_FLOOR(yTransformed);
;;;367              const f32 y1 = ceilf(yTransformed); // y0 + 1.0f;
;;;368    
;;;369              // If out of bounds, set as invalid and continue
;;;370              if(x0 < xyReferenceMin || x1 > xReferenceMax || y0 < xyReferenceMin || y1 > yReferenceMax) {
;;;371                pOut[x] = invalidValue;
;;;372                continue;
;;;373              }
;;;374    
;;;375              const f32 alphaX = xTransformed - x0;
;;;376              const f32 alphaXinverse = 1 - alphaX;
;;;377    
;;;378              const f32 alphaY = yTransformed - y0;
;;;379              const f32 alphaYinverse = 1.0f - alphaY;
;;;380    
;;;381              const s32 y0S32 = Round<s32>(y0);
;;;382              const s32 y1S32 = Round<s32>(y1);
;;;383              const s32 x0S32 = Round<s32>(x0);
;;;384    
;;;385              const InType * restrict pReference_y0 = reference.Pointer(y0S32, x0S32);
;;;386              const InType * restrict pReference_y1 = reference.Pointer(y1S32, x0S32);
;;;387    
;;;388              const f32 pixelTL = *pReference_y0;
;;;389              const f32 pixelTR = *(pReference_y0+1);
;;;390              const f32 pixelBL = *pReference_y1;
;;;391              const f32 pixelBR = *(pReference_y1+1);
;;;392    
;;;393              const f32 interpolatedPixelF32 = InterpolateBilinear2d<f32>(pixelTL, pixelTR, pixelBL, pixelBR, alphaY, alphaYinverse, alphaX, alphaXinverse);
;;;394    
;;;395              const OutType interpolatedPixel = RoundIfInteger<OutType>(interpolatedPixelF32);
;;;396    
;;;397              pOut[x] = interpolatedPixel;
;;;398            } // for(s32 x=0; x<xIterationMax; x++)
;;;399    
;;;400            yOriginal += yGridDelta;
;;;401          } // for(s32 y=0; y<yIterationMax; y++)
;;;402    
;;;403          return RESULT_OK;
;;;404        } // Interp2_Projective
000038  b009              ADD      sp,sp,#0x24
00003a  ecbd8b10          VPOP     {d8-d15}
00003e  b006              ADD      sp,sp,#0x18
000040  e8bd8ff0          POP      {r4-r11,pc}
                  |L243.68|
000044  4651              MOV      r1,r10                ;279
000046  4638              MOV      r0,r7                 ;279
000048  f7fffffe          BL       _ZN4Anki8Embedded8AreValidINS0_5ArrayIhEENS2_IfEEEEbRKT_RKT0_ ; Anki::Embedded::AreValid<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<float>>(const T1&, const T2&)
00004c  2800              CMP      r0,#0                 ;279
00004e  d07d              BEQ      |L243.332|
000050  4651              MOV      r1,r10                ;279
000052  4638              MOV      r0,r7                 ;279
000054  f7fffffe          BL       _ZN4Anki8Embedded8AreValidINS0_5ArrayIhEENS2_IfEEEEbRKT_RKT0_ ; Anki::Embedded::AreValid<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<float>>(const T1&, const T2&)
000058  2800              CMP      r0,#0                 ;279
00005a  f000809f          BEQ.W    |L243.412|
00005e  6938              LDR      r0,[r7,#0x10]         ;279
000060  9000              STR      r0,[sp,#0]            ;279
000062  f8da0010          LDR      r0,[r10,#0x10]        ;279
000066  2100              MOVS     r1,#0                 ;279
000068  466a              MOV      r2,sp                 ;279
00006a  9001              STR      r0,[sp,#4]            ;279
                  |L243.108|
00006c  1c48              ADDS     r0,r1,#1              ;279
00006e  2802              CMP      r0,#2                 ;279
000070  bfb8              IT       LT                    ;279
000072  f8523021          LDRLT    r3,[r2,r1,LSL #2]     ;279
000076  da07              BGE      |L243.136|
                  |L243.120|
000078  f852c020          LDR      r12,[r2,r0,LSL #2]    ;279
00007c  4563              CMP      r3,r12                ;279
00007e  f000808d          BEQ.W    |L243.412|
000082  1c40              ADDS     r0,r0,#1              ;279
000084  2802              CMP      r0,#2                 ;279
000086  dbf7              BLT      |L243.120|
                  |L243.136|
000088  1c49              ADDS     r1,r1,#1              ;279
00008a  2902              CMP      r1,#2                 ;279
00008c  dbee              BLT      |L243.108|
00008e  2100              MOVS     r1,#0                 ;288
000090  4638              MOV      r0,r7                 ;288
000092  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000096  ee080a10          VMOV     s16,r0                ;288
00009a  2101              MOVS     r1,#1                 ;289
00009c  4638              MOV      r0,r7                 ;289
00009e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000a2  ee080a90          VMOV     s17,r0                ;289
0000a6  2100              MOVS     r1,#0                 ;291
0000a8  4650              MOV      r0,r10                ;291
0000aa  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000ae  9001              STR      r0,[sp,#4]            ;292
0000b0  2101              MOVS     r1,#1                 ;292
0000b2  4650              MOV      r0,r10                ;292
0000b4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000b8  4604              MOV      r4,r0                 ;292
0000ba  2100              MOVS     r1,#0                 ;294
0000bc  4650              MOV      r0,r10                ;294
0000be  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000c2  2801              CMP      r0,#1                 ;294
0000c4  bf14              ITE      NE                    ;294
0000c6  f04f0b00          MOVNE    r11,#0                ;294
0000ca  f04f0b01          MOVEQ    r11,#1                ;294
0000ce  eeb80ae8          VCVT.F32.S32 s0,s17                ;297
0000d2  eef70a00          VMOV.F32 s1,#1.00000000        ;297
0000d6  2000              MOVS     r0,#0                 ;300
0000d8  ee300a60          VSUB.F32 s0,s0,s1              ;297
0000dc  ed8d0a07          VSTR     s0,[sp,#0x1c]         ;297
0000e0  eeb80ac8          VCVT.F32.S32 s0,s16                ;298
0000e4  ee300a60          VSUB.F32 s0,s0,s1              ;298
0000e8  ed8d0a06          VSTR     s0,[sp,#0x18]         ;298
0000ec  f8d82008          LDR      r2,[r8,#8]            ;298
0000f0  f8d81010          LDR      r1,[r8,#0x10]         ;298
0000f4  fb001002          MLA      r0,r0,r2,r1           ;298
0000f8  ed900a00          VLDR     s0,[r0,#0]            ;300
0000fc  ed8d0a05          VSTR     s0,[sp,#0x14]         ;300
000100  ed900a01          VLDR     s0,[r0,#4]            ;300
000104  ed8d0a04          VSTR     s0,[sp,#0x10]         ;300
000108  edd0fa02          VLDR     s31,[r0,#8]           ;300
00010c  2001              MOVS     r0,#1                 ;301
00010e  fb001002          MLA      r0,r0,r2,r1           ;301
000112  ed960a01          VLDR     s0,[r6,#4]            ;301
000116  ed90fa00          VLDR     s30,[r0,#0]           ;301
00011a  edd0ea01          VLDR     s29,[r0,#4]           ;301
00011e  ed90ea02          VLDR     s28,[r0,#8]           ;301
000122  2002              MOVS     r0,#2                 ;302
000124  fb001002          MLA      r0,r0,r2,r1           ;302
000128  edd68a04          VLDR     s17,[r6,#0x10]        ;302
00012c  edd0da00          VLDR     s27,[r0,#0]           ;302
000130  ed90da01          VLDR     s26,[r0,#4]           ;302
000134  edd0ca02          VLDR     s25,[r0,#8]           ;302
000138  ed8d0a03          VSTR     s0,[sp,#0xc]          ;308
00013c  ed960a05          VLDR     s0,[r6,#0x14]         ;308
000140  ed8d0a02          VSTR     s0,[sp,#8]            ;310
000144  ed96ca02          VLDR     s24,[r6,#8]           ;310
000148  68f0              LDR      r0,[r6,#0xc]          ;313
00014a  e000              B        |L243.334|
                  |L243.332|
00014c  e019              B        |L243.386|
                  |L243.334|
00014e  9000              STR      r0,[sp,#0]            ;313
000150  6836              LDR      r6,[r6,#0]            ;313
000152  9901              LDR      r1,[sp,#4]            ;317
000154  f1bb0f00          CMP      r11,#0                ;317
000158  d02c              BEQ      |L243.436|
00015a  4361              MULS     r1,r4,r1              ;318
00015c  4370              MULS     r0,r6,r0              ;319
00015e  428c              CMP      r4,r1                 ;321
000160  bf08              IT       EQ                    ;321
000162  4288              CMPEQ    r0,r1                 ;321
000164  f0008037          BEQ.W    |L243.470|
000168  f2401041          MOV      r0,#0x141             ;321
00016c  e9cd5000          STRD     r5,r0,[sp,#0]         ;321
000170  a38f              ADR      r3,|L243.944|
000172  a2ad              ADR      r2,|L243.1064|
000174  a1a7              ADR      r1,|L243.1044|
000176  2005              MOVS     r0,#5                 ;321
000178  f7fffffe          BL       _Anki_Log
00017c  f04f60a0          MOV      r0,#0x5000000         ;321
000180  e75a              B        |L243.56|
                  |L243.386|
000182  f2401017          MOV      r0,#0x117             ;279
000186  e9cd5000          STRD     r5,r0,[sp,#0]         ;279
00018a  a389              ADR      r3,|L243.944|
00018c  a2b0              ADR      r2,|L243.1104|
00018e  a1a1              ADR      r1,|L243.1044|
000190  2005              MOVS     r0,#5                 ;279
000192  f7fffffe          BL       _Anki_Log
000196  f04f6080          MOV      r0,#0x4000000         ;279
00019a  e74d              B        |L243.56|
                  |L243.412|
00019c  f44f708d          MOV      r0,#0x11a             ;282
0001a0  e9cd5000          STRD     r5,r0,[sp,#0]         ;282
0001a4  a382              ADR      r3,|L243.944|
0001a6  a2ae              ADR      r2,|L243.1120|
0001a8  a19a              ADR      r1,|L243.1044|
0001aa  2005              MOVS     r0,#5                 ;282
0001ac  f7fffffe          BL       _Anki_Log
0001b0  48b4              LDR      r0,|L243.1156|
0001b2  e741              B        |L243.56|
                  |L243.436|
0001b4  4288              CMP      r0,r1                 ;326
0001b6  bf08              IT       EQ                    ;326
0001b8  42a6              CMPEQ    r6,r4                 ;326
0001ba  d00c              BEQ      |L243.470|
0001bc  f44f70a3          MOV      r0,#0x146             ;326
0001c0  e9cd5000          STRD     r5,r0,[sp,#0]         ;326
0001c4  a37a              ADR      r3,|L243.944|
0001c6  a298              ADR      r2,|L243.1064|
0001c8  a192              ADR      r1,|L243.1044|
0001ca  2005              MOVS     r0,#5                 ;326
0001cc  f7fffffe          BL       _Anki_Log
0001d0  f04f60a0          MOV      r0,#0x5000000         ;326
0001d4  e730              B        |L243.56|
                  |L243.470|
0001d6  2000              MOVS     r0,#0                 ;332
0001d8  f8da2008          LDR      r2,[r10,#8]           ;332
0001dc  f8da1010          LDR      r1,[r10,#0x10]        ;332
0001e0  f1bb0f00          CMP      r11,#0                ;334
0001e4  fb001502          MLA      r5,r0,r2,r1           ;334
0001e8  bf18              IT       NE                    ;336
0001ea  eba50586          SUBNE    r5,r5,r6,LSL #2       ;336
0001ee  f04f0800          MOV      r8,#0                 ;340
0001f2  9800              LDR      r0,[sp,#0]            ;340
0001f4  2800              CMP      r0,#0                 ;340
0001f6  bfc8              IT       GT                    ;340
0001f8  ed9fbaa3          VLDRGT   s22,|L243.1160|
0001fc  dd76              BLE      |L243.748|
                  |L243.510|
0001fe  f1bb0f00          CMP      r11,#0                ;341
000202  bf18              IT       NE                    ;344
000204  eb050586          ADDNE    r5,r5,r6,LSL #2       ;344
000208  d105              BNE      |L243.534|
00020a  f8da1008          LDR      r1,[r10,#8]           ;341
00020e  f8da0010          LDR      r0,[r10,#0x10]        ;341
000212  fb080501          MLA      r5,r8,r1,r0           ;341
                  |L243.534|
000216  ed9d8a03          VLDR     s16,[sp,#0xc]         ;349
00021a  2400              MOVS     r4,#0                 ;351
00021c  2e00              CMP      r6,#0                 ;351
00021e  dd5c              BLE      |L243.730|
                  |L243.544|
000220  ed9d0a05          VLDR     s0,[sp,#0x14]         ;353
000224  ee600a08          VMUL.F32 s1,s0,s16             ;353
000228  ed9d0a04          VLDR     s0,[sp,#0x10]         ;353
00022c  ee400a28          VMLA.F32 s1,s0,s17             ;353
000230  ee2f0a08          VMUL.F32 s0,s30,s16            ;354
000234  ee0e0aa8          VMLA.F32 s0,s29,s17            ;354
000238  ee301aaf          VADD.F32 s2,s1,s31             ;353
00023c  ee700a0e          VADD.F32 s1,s0,s28             ;354
000240  ee2d0a88          VMUL.F32 s0,s27,s16            ;356
000244  ee388a0c          VADD.F32 s16,s16,s24           ;361
000248  ee0d0a28          VMLA.F32 s0,s26,s17            ;356
00024c  ee300a2c          VADD.F32 s0,s0,s25             ;356
000250  eec11a00          VDIV.F32 s3,s2,s0              ;358
000254  ed991a00          VLDR     s2,[r9,#0]            ;358
000258  ee71aa81          VADD.F32 s21,s3,s2             ;358
00025c  ee801a80          VDIV.F32 s2,s1,s0              ;359
000260  ed990a01          VLDR     s0,[r9,#4]            ;359
000264  ee31aa00          VADD.F32 s20,s2,s0             ;359
000268  ed9f9a88          VLDR     s18,|L243.1164|
00026c  ee3a0a89          VADD.F32 s0,s21,s18            ;363
000270  f7fffffe          BL       __hardfp_floorf
000274  eef09a40          VMOV.F32 s19,s0                ;363
000278  eeb00a6a          VMOV.F32 s0,s21                ;364
00027c  f7fffffe          BL       __hardfp_ceilf
000280  eef0ba40          VMOV.F32 s23,s0                ;364
000284  ee3a0a09          VADD.F32 s0,s20,s18            ;366
000288  f7fffffe          BL       __hardfp_floorf
00028c  eeb09a40          VMOV.F32 s18,s0                ;366
000290  eeb00a4a          VMOV.F32 s0,s20                ;367
000294  f7fffffe          BL       __hardfp_ceilf
000298  eef59ac0          VCMPE.F32 s19,#0.0              ;370
00029c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;370
0002a0  d312              BCC      |L243.712|
0002a2  eddd0a07          VLDR     s1,[sp,#0x1c]         ;370
0002a6  eef4bae0          VCMPE.F32 s23,s1                ;370
0002aa  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;370
0002ae  dc0b              BGT      |L243.712|
0002b0  eeb59ac0          VCMPE.F32 s18,#0.0              ;370
0002b4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;370
0002b8  d306              BCC      |L243.712|
0002ba  eddd0a06          VLDR     s1,[sp,#0x18]         ;370
0002be  eeb40ae0          VCMPE.F32 s0,s1                 ;370
0002c2  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;370
0002c6  dd13              BLE      |L243.752|
                  |L243.712|
0002c8  ed9d0a19          VLDR     s0,[sp,#0x64]         ;371
0002cc  eb050084          ADD      r0,r5,r4,LSL #2       ;371
0002d0  ed800a00          VSTR     s0,[r0,#0]            ;371
                  |L243.724|
0002d4  1c64              ADDS     r4,r4,#1              ;351
0002d6  42b4              CMP      r4,r6                 ;351
0002d8  dba2              BLT      |L243.544|
                  |L243.730|
0002da  ed9d0a02          VLDR     s0,[sp,#8]            ;400
0002de  9800              LDR      r0,[sp,#0]            ;340
0002e0  f1080801          ADD      r8,r8,#1              ;340
0002e4  ee788a80          VADD.F32 s17,s17,s0            ;400
0002e8  4580              CMP      r8,r0                 ;340
0002ea  db88              BLT      |L243.510|
                  |L243.748|
0002ec  2000              MOVS     r0,#0                 ;403
0002ee  e6a3              B        |L243.56|
                  |L243.752|
0002f0  ee7a0ae9          VSUB.F32 s1,s21,s19            ;375
0002f4  ee7a1a49          VSUB.F32 s3,s20,s18            ;378
0002f8  eeb72a00          VMOV.F32 s4,#1.00000000        ;376
0002fc  eeb59ac0          VCMPE.F32 s18,#0.0              ;376
000300  ee321a60          VSUB.F32 s2,s4,s1              ;376
000304  ee722a61          VSUB.F32 s5,s4,s3              ;379
000308  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;379
00030c  bfcc              ITE      GT                    ;379
00030e  ee392a0b          VADDGT.F32 s4,s18,s22            ;379
000312  ee392a4b          VSUBLE.F32 s4,s18,s22            ;379
000316  eebd2ac2          VCVT.S32.F32 s4,s4                 ;379
00031a  eeb50ac0          VCMPE.F32 s0,#0.0               ;379
00031e  ee123a10          VMOV     r3,s4                 ;379
000322  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;379
000326  bfcc              ITE      GT                    ;379
000328  ee300a0b          VADDGT.F32 s0,s0,s22             ;379
00032c  ee300a4b          VSUBLE.F32 s0,s0,s22             ;379
000330  eebd0ac0          VCVT.S32.F32 s0,s0                 ;379
000334  eef59ac0          VCMPE.F32 s19,#0.0              ;379
000338  ee10ca10          VMOV     r12,s0                ;379
00033c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;379
000340  bfcc              ITE      GT                    ;379
000342  ee390a8b          VADDGT.F32 s0,s19,s22            ;379
000346  ee390acb          VSUBLE.F32 s0,s19,s22            ;379
00034a  eebd0ac0          VCVT.S32.F32 s0,s0                 ;379
00034e  68ba              LDR      r2,[r7,#8]            ;379
000350  6939              LDR      r1,[r7,#0x10]         ;379
000352  ee100a10          VMOV     r0,s0                 ;379
000356  fb031302          MLA      r3,r3,r2,r1           ;379
00035a  fb0c1102          MLA      r1,r12,r2,r1          ;379
00035e  4403              ADD      r3,r3,r0              ;379
000360  4408              ADD      r0,r0,r1              ;379
000362  7819              LDRB     r1,[r3,#0]            ;388
000364  ee001a10          VMOV     s0,r1                 ;388
000368  7859              LDRB     r1,[r3,#1]            ;389
00036a  eeb83a40          VCVT.F32.U32 s6,s0                 ;388
00036e  ee001a10          VMOV     s0,r1                 ;389
000372  7801              LDRB     r1,[r0,#0]            ;390
000374  7840              LDRB     r0,[r0,#1]            ;391
000376  ee021a10          VMOV     s4,r1                 ;390
00037a  eeb80a40          VCVT.F32.U32 s0,s0                 ;389
00037e  ee213a03          VMUL.F32 s6,s2,s6              ;389
000382  eef83a42          VCVT.F32.U32 s7,s4                 ;390
000386  ee020a10          VMOV     s4,r0                 ;391
00038a  eb050084          ADD      r0,r5,r4,LSL #2       ;397
00038e  ee003a80          VMLA.F32 s6,s1,s0              ;397
000392  eeb82a42          VCVT.F32.U32 s4,s4                 ;391
000396  ee211a23          VMUL.F32 s2,s2,s7              ;391
00039a  ee001a82          VMLA.F32 s2,s1,s4              ;391
00039e  ee220a83          VMUL.F32 s0,s5,s6              ;391
0003a2  ee010a81          VMLA.F32 s0,s3,s2              ;391
0003a6  ed800a00          VSTR     s0,[r0,#0]            ;397
0003aa  e793              B        |L243.724|
                  |L243.940|
                          DCD      _ZZN4Anki8Embedded18Interp2_ProjectiveIhfEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_E19__PRETTY_FUNCTION__ ; Anki::Embedded::Interp2_Projective<unsigned char, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Meshgrid<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::Array<T2>&, Anki::Embedded::InterpolationType, T2)::__PRETTY_FUNCTION__
                  |L243.944|
0003b0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/interp"
0003b4  6f726574
0003b8  6563685c
0003bc  636f6d6d
0003c0  6f6e5c69
0003c4  6e636c75
0003c8  64655c61
0003cc  6e6b692f
0003d0  636f6d6d
0003d4  6f6e2f72
0003d8  6f626f74
0003dc  2f696e74
0003e0  657270  
0003e3  6f6c6174          DCB      "olate.h",0
0003e7  652e6800
0003eb  00                DCB      0
                  |L243.1004|
0003ec  4f6e6c79          DCB      "Only INTERPOLATE_LINEAR is supported",0
0003f0  20494e54
0003f4  4552504f
0003f8  4c415445
0003fc  5f4c494e
000400  45415220
000404  69732073
000408  7570706f
00040c  72746564
000410  00      
000411  00                DCB      0
000412  00                DCB      0
000413  00                DCB      0
                  |L243.1044|
000414  496e7465          DCB      "Interp2_Projective",0
000418  7270325f
00041c  50726f6a
000420  65637469
000424  766500  
000427  00                DCB      0
                  |L243.1064|
000428  6f726967          DCB      "originalCoordinates is the wrong size",0
00042c  696e616c
000430  436f6f72
000434  64696e61
000438  74657320
00043c  69732074
000440  68652077
000444  726f6e67
000448  2073697a
00044c  6500    
00044e  00                DCB      0
00044f  00                DCB      0
                  |L243.1104|
000450  496e7661          DCB      "Invalid objects",0
000454  6c696420
000458  6f626a65
00045c  63747300
                  |L243.1120|
000460  72656665          DCB      "reference cannot be the same as out",0
000464  72656e63
000468  65206361
00046c  6e6e6f74
000470  20626520
000474  74686520
000478  73616d65
00047c  20617320
000480  6f757400
                  |L243.1156|
                          DCD      0x01000003
                  |L243.1160|
000488  3f000000          DCFS     0x3f000000 ; 0.5
                  |L243.1164|
00048c  3727c5ac          DCFS     0x3727c5ac ; 9.9999997473787516e-06
                          ENDP


                          AREA ||area_number.244||, COMGROUP=_ZN4Anki8Embedded18Interp2_ProjectiveIhfEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_, LINKORDER=||t._ZN4Anki8Embedded18Interp2_ProjectiveIhfEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.244||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded18Interp2_ProjectiveIhfEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b||, COMGROUP=_ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b PROC ; Anki::Embedded::Matrix::MakeSymmetric<Anki::Embedded::Array<float>>(T1&, bool)
;;;1798   
;;;1799         template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1800         {
000002  460e              MOV      r6,r1
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
;;;1801           AnkiConditionalErrorAndReturnValue(arr.get_size(0) == arr.get_size(1),
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00000e  4604              MOV      r4,r0
000010  2101              MOVS     r1,#1
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000018  4284              CMP      r4,r0
00001a  d00e              BEQ      |L250.58|
00001c  f2407109          MOV      r1,#0x709
000020  481a              LDR      r0,|L250.140|
000022  e9cd0100          STRD     r0,r1,[sp,#0]
000026  a31a              ADR      r3,|L250.144|
000028  a227              ADR      r2,|L250.200|
00002a  a12e              ADR      r1,|L250.228|
00002c  2005              MOVS     r0,#5
00002e  f7fffffe          BL       _Anki_Log
;;;1802             RESULT_FAIL_INVALID_SIZE, "MakeSymmetric", "Input array must be square");
;;;1803   
;;;1804           const s32 arrHeight = arr.get_size(0);
;;;1805           for(s32 y = 0; y < arrHeight; y++)
;;;1806           {
;;;1807             const s32 x0 = lowerToUpper ? (y+1)     : 0;
;;;1808             const s32 x1 = lowerToUpper ? arrHeight : y;
;;;1809   
;;;1810             for(s32 x = x0; x < x1; x++) {
;;;1811               *arr.Pointer(y,x) = *arr.Pointer(x,y);
;;;1812             }
;;;1813           }
;;;1814   
;;;1815           return RESULT_OK;
;;;1816         } // template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
000032  b003              ADD      sp,sp,#0xc
000034  f04f60a0          MOV      r0,#0x5000000         ;1801
000038  bdf0              POP      {r4-r7,pc}
                  |L250.58|
00003a  2100              MOVS     r1,#0                 ;1804
00003c  4628              MOV      r0,r5                 ;1804
00003e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000042  1e01              SUBS     r1,r0,#0              ;1804
000044  f04f0300          MOV      r3,#0                 ;1805
000048  dd1c              BLE      |L250.132|
                  |L250.74|
00004a  2e00              CMP      r6,#0                 ;1807
00004c  bf15              ITETE    NE                    ;1807
00004e  1c5a              ADDNE    r2,r3,#1              ;1807
000050  2200              MOVEQ    r2,#0                 ;1807
000052  4608              MOVNE    r0,r1                 ;1808
000054  4618              MOVEQ    r0,r3                 ;1808
000056  4282              CMP      r2,r0                 ;1810
000058  da11              BGE      |L250.126|
                  |L250.90|
00005a  f8d5c010          LDR      r12,[r5,#0x10]        ;1810
00005e  68ac              LDR      r4,[r5,#8]            ;1810
000060  fb02c704          MLA      r7,r2,r4,r12          ;1810
000064  fb03cc04          MLA      r12,r3,r4,r12         ;1810
000068  eb070783          ADD      r7,r7,r3,LSL #2       ;1810
00006c  eb0c0c82          ADD      r12,r12,r2,LSL #2     ;1810
000070  ed970a00          VLDR     s0,[r7,#0]            ;1811
000074  1c52              ADDS     r2,r2,#1              ;1810
000076  ed8c0a00          VSTR     s0,[r12,#0]           ;1811
00007a  4282              CMP      r2,r0                 ;1810
00007c  dbed              BLT      |L250.90|
                  |L250.126|
00007e  1c5b              ADDS     r3,r3,#1              ;1805
000080  428b              CMP      r3,r1                 ;1805
000082  dbe2              BLT      |L250.74|
                  |L250.132|
000084  b003              ADD      sp,sp,#0xc
000086  2000              MOVS     r0,#0                 ;1815
000088  bdf0              POP      {r4-r7,pc}
;;;1817   
                          ENDP

00008a  0000              DCW      0x0000
                  |L250.140|
                          DCD      _ZZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_bE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::MakeSymmetric<Anki::Embedded::Array<float>>(T1&, bool)::__PRETTY_FUNCTION__
                  |L250.144|
000090  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000094  6f726574
000098  6563685c
00009c  636f6d6d
0000a0  6f6e5c69
0000a4  6e636c75
0000a8  64655c61
0000ac  6e6b692f
0000b0  636f6d6d
0000b4  6f6e2f72
0000b8  6f626f74
0000bc  2f6d6174
0000c0  726978  
0000c3  2e6800            DCB      ".h",0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L250.200|
0000c8  496e7075          DCB      "Input array must be square",0
0000cc  74206172
0000d0  72617920
0000d4  6d757374
0000d8  20626520
0000dc  73717561
0000e0  726500  
0000e3  00                DCB      0
                  |L250.228|
0000e4  4d616b65          DCB      "MakeSymmetric",0
0000e8  53796d6d
0000ec  65747269
0000f0  6300    
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||area_number.251||, COMGROUP=_ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b, LINKORDER=||t._ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.251||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_b||
                          DCD      0x00000001

                          AREA ||i._ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE||, COMGROUP=_ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE PROC ; Anki::Embedded::TemplateTracker::ComputeTemplateSample(unsigned char, float, float, float, float, const Anki::Embedded::TemplateTracker::HomographyStruct&, const Anki::Embedded::TemplateTracker::dR_dtheta_Struct&, float, float, Anki::Embedded::Array<float>&)
;;;118    
;;;119          inline LucasKanadeTracker_SampledPlanar6dof::TemplateSample ComputeTemplateSample(const u8 grayValue,
000000  b4f0              PUSH     {r4-r7}
;;;120            const f32 xOriginal, const f32 yOriginal,
;;;121            const f32 xGradient, const f32 yGradient,
;;;122            const HomographyStruct& H,
;;;123            const dR_dtheta_Struct& dR,
;;;124            const f32 focalLength_x, const f32 focalLength_y,
;;;125            Array<f32>& AtA)
;;;126          {
000002  ed2d8b06          VPUSH    {d8-d10}
000006  b089              SUB      sp,sp,#0x24
;;;127            LucasKanadeTracker_SampledPlanar6dof::TemplateSample curTemplateSample;
;;;128    
;;;129            curTemplateSample.grayvalue   = grayValue;
000008  9d13              LDR      r5,[sp,#0x4c]
00000a  f88d1008          STRB     r1,[sp,#8]
;;;130            curTemplateSample.xCoordinate = xOriginal;
00000e  ed8d0a00          VSTR     s0,[sp,#0]
;;;131            curTemplateSample.yCoordinate = yOriginal;
000012  edcd0a01          VSTR     s1,[sp,#4]
;;;132    
;;;133            const f32 xTransformedRaw = H.h00*xOriginal + H.h01*yOriginal + H.h02;
000016  ed923a00          VLDR     s6,[r2,#0]
00001a  edd23a01          VLDR     s7,[r2,#4]
;;;134            const f32 yTransformedRaw = H.h10*xOriginal + H.h11*yOriginal + H.h12;
;;;135    
;;;136            const f32 normalization = H.h20*xOriginal + H.h21*yOriginal + H.h22;
;;;137    
;;;138            const f32 invNorm = 1.f / normalization;
;;;139            const f32 invNormSq = invNorm *invNorm;
;;;140    
;;;141            const f32 dWu_dtx = focalLength_x * invNorm;
;;;142            //const f32 dWu_dty = 0.f;
;;;143            const f32 dWu_dtz = -xTransformedRaw * invNormSq;
;;;144    
;;;145            //const f32 dWv_dtx = 0.f;
;;;146            const f32 dWv_dty = focalLength_y * invNorm;
;;;147            const f32 dWv_dtz = -yTransformedRaw * invNormSq;
;;;148    
;;;149            const f32 r1thetaXterm = /*dr11_dthetaX*xOriginal +*/ dR.dr12_dthetaX*yOriginal;
;;;150            const f32 r1thetaYterm = dR.dr11_dthetaY*xOriginal + dR.dr12_dthetaY*yOriginal;
;;;151            const f32 r1thetaZterm = dR.dr11_dthetaZ*xOriginal + dR.dr12_dthetaZ*yOriginal;
;;;152    
;;;153            const f32 r2thetaXterm = /*dr21_dthetaX*xOriginal + */dR.dr22_dthetaX*yOriginal;
;;;154            const f32 r2thetaYterm = dR.dr21_dthetaY*xOriginal + dR.dr22_dthetaY*yOriginal;
;;;155            const f32 r2thetaZterm = dR.dr21_dthetaZ*xOriginal + dR.dr22_dthetaZ*yOriginal;
;;;156    
;;;157            const f32 r3thetaXterm = /*dr31_dthetaX*xOriginal + */dR.dr32_dthetaX*yOriginal;
;;;158            const f32 r3thetaYterm = dR.dr31_dthetaY*xOriginal + dR.dr32_dthetaY*yOriginal;
00001e  edd3aa0a          VLDR     s21,[r3,#0x28]
000022  ee233a00          VMUL.F32 s6,s6,s0              ;133
000026  ee033aa0          VMLA.F32 s6,s7,s1              ;133
00002a  edd23a02          VLDR     s7,[r2,#8]            ;133
00002e  ee335a23          VADD.F32 s10,s6,s7             ;133
000032  ed923a03          VLDR     s6,[r2,#0xc]          ;134
000036  edd23a04          VLDR     s7,[r2,#0x10]         ;134
00003a  ee233a00          VMUL.F32 s6,s6,s0              ;134
00003e  ee033aa0          VMLA.F32 s6,s7,s1              ;134
000042  edd23a05          VLDR     s7,[r2,#0x14]         ;134
000046  ee734a23          VADD.F32 s9,s6,s7              ;134
00004a  ed923a06          VLDR     s6,[r2,#0x18]         ;136
00004e  edd23a07          VLDR     s7,[r2,#0x1c]         ;136
000052  ee233a00          VMUL.F32 s6,s6,s0              ;136
000056  ee033aa0          VMLA.F32 s6,s7,s1              ;136
00005a  edd23a08          VLDR     s7,[r2,#0x20]         ;136
00005e  ee334a23          VADD.F32 s8,s6,s7              ;136
000062  eeb73a00          VMOV.F32 s6,#1.00000000        ;138
000066  eec33a04          VDIV.F32 s7,s6,s8              ;138
00006a  ee233aa3          VMUL.F32 s6,s7,s7              ;139
00006e  ee228a23          VMUL.F32 s16,s4,s7             ;141
000072  ee229aa3          VMUL.F32 s18,s5,s7             ;146
000076  edd33a02          VLDR     s7,[r3,#8]            ;149
00007a  ee657a43          VNMUL.F32 s15,s10,s6            ;143
00007e  ee648ac3          VNMUL.F32 s17,s9,s6             ;147
000082  ee23aaa0          VMUL.F32 s20,s7,s1             ;149
000086  edd33a00          VLDR     s7,[r3,#0]            ;150
00008a  ee237a80          VMUL.F32 s14,s7,s0             ;150
00008e  edd33a03          VLDR     s7,[r3,#0xc]          ;150
000092  ee037aa0          VMLA.F32 s14,s7,s1             ;150
000096  edd33a01          VLDR     s7,[r3,#4]            ;151
00009a  ee636a80          VMUL.F32 s13,s7,s0             ;151
00009e  edd33a04          VLDR     s7,[r3,#0x10]         ;151
0000a2  ee436aa0          VMLA.F32 s13,s7,s1             ;151
0000a6  edd33a07          VLDR     s7,[r3,#0x1c]         ;153
0000aa  ee639aa0          VMUL.F32 s19,s7,s1             ;153
0000ae  edd33a05          VLDR     s7,[r3,#0x14]         ;154
0000b2  ee236a80          VMUL.F32 s12,s7,s0             ;154
0000b6  edd33a08          VLDR     s7,[r3,#0x20]         ;154
0000ba  ee036aa0          VMLA.F32 s12,s7,s1             ;154
0000be  edd33a06          VLDR     s7,[r3,#0x18]         ;155
0000c2  ee635a80          VMUL.F32 s11,s7,s0             ;155
0000c6  edd33a09          VLDR     s7,[r3,#0x24]         ;155
0000ca  ee2a0a80          VMUL.F32 s0,s21,s0
0000ce  edd3aa0c          VLDR     s21,[r3,#0x30]
0000d2  ee435aa0          VMLA.F32 s11,s7,s1             ;155
0000d6  edd33a0b          VLDR     s7,[r3,#0x2c]         ;157
0000da  ee0a0aa0          VMLA.F32 s0,s21,s1
0000de  ee633aa0          VMUL.F32 s7,s7,s1              ;157
;;;159            //const f32 r3thetaZterm = dr31_dthetaZ*xOriginal + dr32_dthetaZ*yOriginal;
;;;160    
;;;161            const f32 dWu_dthetaX = (focalLength_x*normalization*r1thetaXterm -
0000e2  ee620a04          VMUL.F32 s1,s4,s8
0000e6  ee202a8a          VMUL.F32 s4,s1,s20
;;;162              r3thetaXterm*xTransformedRaw) * invNormSq;
;;;163    
;;;164            const f32 dWu_dthetaY = (focalLength_x*normalization*r1thetaYterm -
0000ea  ee207a87          VMUL.F32 s14,s1,s14
;;;165              r3thetaYterm*xTransformedRaw) * invNormSq;
;;;166    
;;;167            const f32 dWu_dthetaZ = (focalLength_x*normalization*r1thetaZterm
0000ee  ee600aa6          VMUL.F32 s1,s1,s13
0000f2  ee032ac5          VMLS.F32 s4,s7,s10             ;161
0000f6  ee007a45          VMLS.F32 s14,s0,s10            ;164
0000fa  ee606a83          VMUL.F32 s13,s1,s6
;;;168              /* - r3thetaZterm*xTransformedRaw*/) * invNormSq;
;;;169    
;;;170            const f32 dWv_dthetaX = (focalLength_y*normalization*r2thetaXterm -
0000fe  ee620a84          VMUL.F32 s1,s5,s8
000102  ee222a03          VMUL.F32 s4,s4,s6              ;161
000106  ee602aa9          VMUL.F32 s5,s1,s19
00010a  ee275a03          VMUL.F32 s10,s14,s6            ;164
00010e  ee432ae4          VMLS.F32 s5,s7,s9
;;;171              r3thetaXterm*yTransformedRaw) * invNormSq;
;;;172    
;;;173            const f32 dWv_dthetaY = (focalLength_y*normalization*r2thetaYterm -
000112  ee603a86          VMUL.F32 s7,s1,s12
;;;174              r3thetaYterm*yTransformedRaw) * invNormSq;
;;;175    
;;;176            const f32 dWv_dthetaZ = (focalLength_y*normalization*r2thetaZterm
000116  ee600aa5          VMUL.F32 s1,s1,s11
00011a  ee403a64          VMLS.F32 s7,s0,s9              ;173
00011e  ee622a83          VMUL.F32 s5,s5,s6              ;170
000122  ee230a83          VMUL.F32 s0,s7,s6              ;173
;;;177              /* - r3thetaZterm*yTransformedRaw*/) * invNormSq;
;;;178    
;;;179            // Store the row of the A (Jacobian) matrix for this sample:
;;;180            curTemplateSample.A[0] = xGradient*dWu_dthetaX + yGradient*dWv_dthetaX;
000126  ee212a02          VMUL.F32 s4,s2,s4
00012a  ee600a83          VMUL.F32 s1,s1,s6              ;176
;;;181            curTemplateSample.A[1] = xGradient*dWu_dthetaY + yGradient*dWv_dthetaY;
;;;182            curTemplateSample.A[2] = xGradient*dWu_dthetaZ + yGradient*dWv_dthetaZ;
;;;183            curTemplateSample.A[3] = xGradient*dWu_dtx /*+ yGradient*dWv_dtx*/;
;;;184            curTemplateSample.A[4] = /*xGradient*dWu_dty + */yGradient*dWv_dty;
;;;185            curTemplateSample.A[5] = xGradient*dWu_dtz + yGradient*dWv_dtz;
;;;186    
;;;187            // Store the full AtA matrix for when all the samples are within
;;;188            // image bounds
;;;189            // NOTE: the matrix is symmetric so we only need to compute and
;;;190            //       store the 21 upper triangle of unique entries
;;;191            for(s32 i=0; i<6; ++i) {
00012e  2200              MOVS     r2,#0
000130  46ec              MOV      r12,sp                ;127
000132  ee012aa2          VMLA.F32 s4,s3,s5              ;180
000136  ed8d2a03          VSTR     s4,[sp,#0xc]          ;180
00013a  ee212a05          VMUL.F32 s4,s2,s10             ;181
00013e  ee012a80          VMLA.F32 s4,s3,s0              ;181
000142  ee210a26          VMUL.F32 s0,s2,s13             ;182
000146  ee010aa0          VMLA.F32 s0,s3,s1              ;182
00014a  ed8d2a04          VSTR     s4,[sp,#0x10]         ;181
00014e  ed8d0a05          VSTR     s0,[sp,#0x14]         ;182
000152  ee210a08          VMUL.F32 s0,s2,s16             ;183
000156  ed8d0a06          VSTR     s0,[sp,#0x18]         ;183
00015a  ee210a89          VMUL.F32 s0,s3,s18             ;184
00015e  ed8d0a07          VSTR     s0,[sp,#0x1c]         ;184
000162  ee210a27          VMUL.F32 s0,s2,s15             ;185
000166  ee010aa8          VMLA.F32 s0,s3,s17             ;185
00016a  ed8d0a08          VSTR     s0,[sp,#0x20]         ;185
                  |L257.366|
00016e  68ab              LDR      r3,[r5,#8]            ;185
000170  6929              LDR      r1,[r5,#0x10]         ;185
;;;192              f32 * restrict AtA_i = AtA.Pointer(i,0);
;;;193              for(s32 j=i; j<6; ++j) {
000172  2a06              CMP      r2,#6
000174  fb021403          MLA      r4,r2,r3,r1
000178  4611              MOV      r1,r2
;;;194                AtA_i[j]  += curTemplateSample.A[i] * curTemplateSample.A[j];
00017a  bfbc              ITT      LT
00017c  eb0c0382          ADDLT    r3,r12,r2,LSL #2
000180  ed930a03          VLDRLT   s0,[r3,#0xc]
000184  da0e              BGE      |L257.420|
                  |L257.390|
000186  eb040381          ADD      r3,r4,r1,LSL #2
00018a  eb0c0681          ADD      r6,r12,r1,LSL #2
00018e  edd30a00          VLDR     s1,[r3,#0]
000192  ed961a03          VLDR     s2,[r6,#0xc]
000196  1c49              ADDS     r1,r1,#1              ;193
000198  2906              CMP      r1,#6                 ;193
00019a  ee400a01          VMLA.F32 s1,s0,s2
00019e  edc30a00          VSTR     s1,[r3,#0]
0001a2  dbf0              BLT      |L257.390|
                  |L257.420|
0001a4  1c52              ADDS     r2,r2,#1              ;191
0001a6  2a06              CMP      r2,#6                 ;191
0001a8  dbe1              BLT      |L257.366|
0001aa  e89d10fe          LDM      sp,{r1-r7,r12}        ;191
0001ae  e88010fe          STM      r0,{r1-r7,r12}        ;191
;;;195              }
;;;196            }
;;;197    
;;;198            return curTemplateSample;
0001b2  9908              LDR      r1,[sp,#0x20]
0001b4  6201              STR      r1,[r0,#0x20]
;;;199          } // ComputeTemplateSample()
0001b6  b009              ADD      sp,sp,#0x24
0001b8  ecbd8b06          VPOP     {d8-d10}
0001bc  bcf0              POP      {r4-r7}
0001be  4770              BX       lr
;;;200    
                          ENDP


                          AREA ||area_number.258||, COMGROUP=_ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE, LINKORDER=||i._ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.258||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15TemplateTracker21ComputeTemplateSampleEhffffRKNS1_16HomographyStructERKNS1_16dR_dtheta_StructEffRNS0_5ArrayIfEE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix3MaxIfEET_RKNS0_25ConstArraySliceExpressionIS3_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix3MaxIfEET_RKNS0_25ConstArraySliceExpressionIS3_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix3MaxIfEET_RKNS0_25ConstArraySliceExpressionIS3_EE PROC ; Anki::Embedded::Matrix::Max<float>(const Anki::Embedded::ConstArraySliceExpression<T1>&)
;;;73     
;;;74           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
000000  b570              PUSH     {r4-r6,lr}
;;;75           {
000002  4604              MOV      r4,r0
000004  f1000618          ADD      r6,r0,#0x18
000008  b08a              SUB      sp,sp,#0x28
;;;76             const Array<Type> &array = mat.get_array();
;;;77     
;;;78             AnkiConditionalErrorAndReturnValue(array.IsValid(),
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000010  2800              CMP      r0,#0
000012  d041              BEQ      |L264.152|
000014  2101              MOVS     r1,#1
000016  f88d1008          STRB     r1,[sp,#8]
00001a  6921              LDR      r1,[r4,#0x10]
00001c  9103              STR      r1,[sp,#0xc]
00001e  6961              LDR      r1,[r4,#0x14]
000020  9104              STR      r1,[sp,#0x10]
000022  68e0              LDR      r0,[r4,#0xc]
000024  9005              STR      r0,[sp,#0x14]
000026  6860              LDR      r0,[r4,#4]
000028  9006              STR      r0,[sp,#0x18]
00002a  68a0              LDR      r0,[r4,#8]
00002c  9007              STR      r0,[sp,#0x1c]
00002e  6820              LDR      r0,[r4,#0]
;;;79               0, "Matrix::Max", "Array<Type> is not valid");
;;;80     
;;;81             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;82     
;;;83             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;84               0, "Matrix::Max", "Limits is not valid");
;;;85     
;;;86             Type maxValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
000030  9008              STR      r0,[sp,#0x20]
000032  9906              LDR      r1,[sp,#0x18]
000034  6935              LDR      r5,[r6,#0x10]
000036  68b4              LDR      r4,[r6,#8]
000038  9803              LDR      r0,[sp,#0xc]
00003a  fb015104          MLA      r1,r1,r4,r5
00003e  eb010080          ADD      r0,r1,r0,LSL #2
;;;87             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
000042  2100              MOVS     r1,#0
000044  ed900a00          VLDR     s0,[r0,#0]            ;86
000048  9808              LDR      r0,[sp,#0x20]
00004a  2800              CMP      r0,#0
;;;88               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;89               const Type * restrict pMat = array.Pointer(y, 0);
;;;90     
;;;91               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;92                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;93                 maxValue = MAX(maxValue, pMat[x]);
;;;94               }
;;;95             }
;;;96     
;;;97             return maxValue;
;;;98           } // template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
00004c  bfdc              ITT      LE
00004e  b00a              ADDLE    sp,sp,#0x28
000050  bd70              POPLE    {r4-r6,pc}
                  |L264.82|
000052  e9dd0206          LDRD     r0,r2,[sp,#0x18]
000056  fb010002          MLA      r0,r1,r2,r0           ;88
00005a  fb005304          MLA      r3,r0,r4,r5           ;88
00005e  9a05              LDR      r2,[sp,#0x14]         ;91
000060  2000              MOVS     r0,#0                 ;91
000062  2a00              CMP      r2,#0                 ;91
000064  dd12              BLE      |L264.140|
                  |L264.102|
000066  e9dd2c03          LDRD     r2,r12,[sp,#0xc]      ;91
00006a  fb00220c          MLA      r2,r0,r12,r2          ;92
00006e  eb030282          ADD      r2,r3,r2,LSL #2       ;93
000072  edd20a00          VLDR     s1,[r2,#0]            ;93
000076  eef40ac0          VCMPE.F32 s1,s0                 ;93
00007a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;93
00007e  bf28              IT       CS                    ;93
000080  eeb00a60          VMOVCS.F32 s0,s1                 ;93
000084  1c40              ADDS     r0,r0,#1              ;91
000086  9a05              LDR      r2,[sp,#0x14]         ;91
000088  4282              CMP      r2,r0                 ;91
00008a  dcec              BGT      |L264.102|
                  |L264.140|
00008c  9808              LDR      r0,[sp,#0x20]         ;87
00008e  1c49              ADDS     r1,r1,#1              ;87
000090  4288              CMP      r0,r1                 ;87
000092  dcde              BGT      |L264.82|
000094  b00a              ADD      sp,sp,#0x28
000096  bd70              POP      {r4-r6,pc}
                  |L264.152|
000098  214e              MOVS     r1,#0x4e              ;78
00009a  4806              LDR      r0,|L264.180|
00009c  e9cd0100          STRD     r0,r1,[sp,#0]         ;78
0000a0  a305              ADR      r3,|L264.184|
0000a2  a213              ADR      r2,|L264.240|
0000a4  a119              ADR      r1,|L264.268|
0000a6  2005              MOVS     r0,#5                 ;78
0000a8  f7fffffe          BL       _Anki_Log
0000ac  b00a              ADD      sp,sp,#0x28
0000ae  ed9f0a1a          VLDR     s0,|L264.280|
0000b2  bd70              POP      {r4-r6,pc}
;;;99     
                          ENDP

                  |L264.180|
                          DCD      _ZZN4Anki8Embedded6Matrix3MaxIfEET_RKNS0_25ConstArraySliceExpressionIS3_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Max<float>(const Anki::Embedded::ConstArraySliceExpression<T1>&)::__PRETTY_FUNCTION__
                  |L264.184|
0000b8  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
0000bc  6f726574
0000c0  6563685c
0000c4  636f6d6d
0000c8  6f6e5c69
0000cc  6e636c75
0000d0  64655c61
0000d4  6e6b692f
0000d8  636f6d6d
0000dc  6f6e2f72
0000e0  6f626f74
0000e4  2f6d6174
0000e8  726978  
0000eb  2e6800            DCB      ".h",0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L264.240|
0000f0  41727261          DCB      "Array<Type> is not valid",0
0000f4  793c5479
0000f8  70653e20
0000fc  6973206e
000100  6f742076
000104  616c6964
000108  00      
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0
                  |L264.268|
00010c  4d617472          DCB      "Matrix::Max",0
000110  69783a3a
000114  4d617800
                  |L264.280|
000118  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.265||, COMGROUP=_ZN4Anki8Embedded6Matrix3MaxIfEET_RKNS0_25ConstArraySliceExpressionIS3_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix3MaxIfEET_RKNS0_25ConstArraySliceExpressionIS3_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.265||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix3MaxIfEET_RKNS0_25ConstArraySliceExpressionIS3_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded18Interp2_ProjectiveIhhEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_||, COMGROUP=_ZN4Anki8Embedded18Interp2_ProjectiveIhhEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded18Interp2_ProjectiveIhhEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_ PROC ; Anki::Embedded::Interp2_Projective<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Meshgrid<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::Array<T2>&, Anki::Embedded::InterpolationType, T2)
;;;273    
;;;274        template<typename InType, typename OutType> Result Interp2_Projective(const Array<InType> &reference, const Meshgrid<f32> &originalCoordinates, const Array<f32> &homography, const Point<f32> &centerOffset, Array<OutType> &out, const InterpolationType interpolationType, const OutType invalidValue)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;275        {
000004  4606              MOV      r6,r0
000006  ed2d8b10          VPUSH    {d8-d15}
00000a  b089              SUB      sp,sp,#0x24
00000c  469a              MOV      r10,r3
00000e  4691              MOV      r9,r2
000010  460f              MOV      r7,r1
000012  e9dd8022          LDRD     r8,r0,[sp,#0x88]
;;;276          AnkiConditionalErrorAndReturnValue(interpolationType == INTERPOLATE_LINEAR,
000016  4de2              LDR      r5,|L271.928|
000018  2800              CMP      r0,#0
00001a  d010              BEQ      |L271.62|
00001c  f44f708a          MOV      r0,#0x114
000020  e9cd5000          STRD     r5,r0,[sp,#0]
000024  a3df              ADR      r3,|L271.932|
000026  a2ee              ADR      r2,|L271.992|
000028  a1f7              ADR      r1,|L271.1032|
00002a  2005              MOVS     r0,#5
00002c  f7fffffe          BL       _Anki_Log
000030  f04f7040          MOV      r0,#0x3000000
                  |L271.52|
;;;277            RESULT_FAIL_INVALID_PARAMETER, "Interp2_Projective", "Only INTERPOLATE_LINEAR is supported");
;;;278    
;;;279          AnkiConditionalErrorAndReturnValue(AreValid(reference, out),
;;;280            RESULT_FAIL_INVALID_OBJECT, "Interp2_Projective", "Invalid objects");
;;;281    
;;;282          AnkiConditionalErrorAndReturnValue(NotAliased(reference, out),
;;;283            RESULT_FAIL_ALIASED_MEMORY, "Interp2_Projective", "reference cannot be the same as out");
;;;284    
;;;285          //AnkiConditionalErrorAndReturnValue(FLT_NEAR(homography[2][2], 1.0f),
;;;286          //  RESULT_FAIL_INVALID_PARAMETER, "Interp2_Projective", "homography[2][2] should be 1.0");
;;;287    
;;;288          const s32 referenceHeight = reference.get_size(0);
;;;289          const s32 referenceWidth = reference.get_size(1);
;;;290    
;;;291          const s32 outHeight = out.get_size(0);
;;;292          const s32 outWidth = out.get_size(1);
;;;293    
;;;294          const bool isOutputOneDimensional = (out.get_size(0) == 1);
;;;295    
;;;296          const f32 xyReferenceMin = 0.0f;
;;;297          const f32 xReferenceMax = static_cast<f32>(referenceWidth) - 1.0f;
;;;298          const f32 yReferenceMax = static_cast<f32>(referenceHeight) - 1.0f;
;;;299    
;;;300          const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2];
;;;301          const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2];
;;;302          const f32 h20 = homography[2][0]; const f32 h21 = homography[2][1]; const f32 h22 = homography[2][2];
;;;303    
;;;304          const LinearSequence<f32> &yGridVector = originalCoordinates.get_yGridVector();
;;;305          const LinearSequence<f32> &xGridVector = originalCoordinates.get_xGridVector();
;;;306    
;;;307          const f32 yGridStart = yGridVector.get_start();
;;;308          const f32 xGridStart = xGridVector.get_start();
;;;309    
;;;310          const f32 yGridDelta = yGridVector.get_increment();
;;;311          const f32 xGridDelta = xGridVector.get_increment();
;;;312    
;;;313          const s32 yIterationMax = yGridVector.get_size();
;;;314          const s32 xIterationMax = xGridVector.get_size();
;;;315    
;;;316          // One last check, to see if the sizes match
;;;317          if(isOutputOneDimensional) {
;;;318            const s32 numOutputElements = outHeight * outWidth;
;;;319            const s32 numOriginalCoordinates = xGridVector.get_size() * yGridVector.get_size();
;;;320    
;;;321            AnkiConditionalErrorAndReturnValue(
;;;322              outWidth == numOutputElements &&
;;;323              numOriginalCoordinates == numOutputElements,
;;;324              RESULT_FAIL_INVALID_SIZE, "Interp2_Projective", "originalCoordinates is the wrong size");
;;;325          } else {
;;;326            AnkiConditionalErrorAndReturnValue(
;;;327              yGridVector.get_size() == outHeight &&
;;;328              xGridVector.get_size() == outWidth,
;;;329              RESULT_FAIL_INVALID_SIZE, "Interp2_Projective", "originalCoordinates is the wrong size");
;;;330          }
;;;331    
;;;332          OutType * restrict pOut = out.Pointer(0,0);
;;;333    
;;;334          if(isOutputOneDimensional) {
;;;335            // pOut is incremented at the top of the loop, so decrement it here
;;;336            pOut -= xIterationMax;
;;;337          }
;;;338    
;;;339          f32 yOriginal = yGridStart;
;;;340          for(s32 y=0; y<yIterationMax; y++) {
;;;341            if(isOutputOneDimensional) {
;;;342              // If the output is one dimensional, then we will do the next set of x iterations later on
;;;343              // the same output row
;;;344              pOut += xIterationMax;
;;;345            } else {
;;;346              pOut = out.Pointer(y,0);
;;;347            }
;;;348    
;;;349            f32 xOriginal = xGridStart;
;;;350    
;;;351            for(s32 x=0; x<xIterationMax; x++) {
;;;352              // TODO: These two could be strength reduced
;;;353              const f32 xTransformedRaw = h00*xOriginal + h01*yOriginal + h02;
;;;354              const f32 yTransformedRaw = h10*xOriginal + h11*yOriginal + h12;
;;;355    
;;;356              const f32 normalization = h20*xOriginal + h21*yOriginal + h22;
;;;357    
;;;358              const f32 xTransformed = (xTransformedRaw / normalization) + centerOffset.x;
;;;359              const f32 yTransformed = (yTransformedRaw / normalization) + centerOffset.y;
;;;360    
;;;361              xOriginal += xGridDelta;
;;;362    
;;;363              const f32 x0 = FLT_FLOOR(xTransformed);
;;;364              const f32 x1 = ceilf(xTransformed); // x0 + 1.0f;
;;;365    
;;;366              const f32 y0 = FLT_FLOOR(yTransformed);
;;;367              const f32 y1 = ceilf(yTransformed); // y0 + 1.0f;
;;;368    
;;;369              // If out of bounds, set as invalid and continue
;;;370              if(x0 < xyReferenceMin || x1 > xReferenceMax || y0 < xyReferenceMin || y1 > yReferenceMax) {
;;;371                pOut[x] = invalidValue;
;;;372                continue;
;;;373              }
;;;374    
;;;375              const f32 alphaX = xTransformed - x0;
;;;376              const f32 alphaXinverse = 1 - alphaX;
;;;377    
;;;378              const f32 alphaY = yTransformed - y0;
;;;379              const f32 alphaYinverse = 1.0f - alphaY;
;;;380    
;;;381              const s32 y0S32 = Round<s32>(y0);
;;;382              const s32 y1S32 = Round<s32>(y1);
;;;383              const s32 x0S32 = Round<s32>(x0);
;;;384    
;;;385              const InType * restrict pReference_y0 = reference.Pointer(y0S32, x0S32);
;;;386              const InType * restrict pReference_y1 = reference.Pointer(y1S32, x0S32);
;;;387    
;;;388              const f32 pixelTL = *pReference_y0;
;;;389              const f32 pixelTR = *(pReference_y0+1);
;;;390              const f32 pixelBL = *pReference_y1;
;;;391              const f32 pixelBR = *(pReference_y1+1);
;;;392    
;;;393              const f32 interpolatedPixelF32 = InterpolateBilinear2d<f32>(pixelTL, pixelTR, pixelBL, pixelBR, alphaY, alphaYinverse, alphaX, alphaXinverse);
;;;394    
;;;395              const OutType interpolatedPixel = RoundIfInteger<OutType>(interpolatedPixelF32);
;;;396    
;;;397              pOut[x] = interpolatedPixel;
;;;398            } // for(s32 x=0; x<xIterationMax; x++)
;;;399    
;;;400            yOriginal += yGridDelta;
;;;401          } // for(s32 y=0; y<yIterationMax; y++)
;;;402    
;;;403          return RESULT_OK;
;;;404        } // Interp2_Projective
000034  b009              ADD      sp,sp,#0x24
000036  ecbd8b10          VPOP     {d8-d15}
00003a  e8bd8ff0          POP      {r4-r11,pc}
                  |L271.62|
00003e  6931              LDR      r1,[r6,#0x10]
000040  b1a9              CBZ      r1,|L271.110|
000042  6830              LDR      r0,[r6,#0]
000044  2800              CMP      r0,#0
000046  bfa4              ITT      GE
000048  6870              LDRGE    r0,[r6,#4]
00004a  2800              CMPGE    r0,#0
00004c  db0f              BLT      |L271.110|
00004e  f8d80010          LDR      r0,[r8,#0x10]
000052  b160              CBZ      r0,|L271.110|
000054  f8d82000          LDR      r2,[r8,#0]
000058  2a00              CMP      r2,#0
00005a  bfa4              ITT      GE
00005c  f8d82004          LDRGE    r2,[r8,#4]
000060  2a00              CMPGE    r2,#0
000062  db04              BLT      |L271.110|
000064  e9cd1000          STRD     r1,r0,[sp,#0]
000068  2100              MOVS     r1,#0
00006a  466a              MOV      r2,sp
00006c  e00c              B        |L271.136|
                  |L271.110|
00006e  f2401017          MOV      r0,#0x117             ;279
000072  e9cd5000          STRD     r5,r0,[sp,#0]         ;279
000076  a3cb              ADR      r3,|L271.932|
000078  a2e8              ADR      r2,|L271.1052|
00007a  a1e3              ADR      r1,|L271.1032|
00007c  2005              MOVS     r0,#5                 ;279
00007e  f7fffffe          BL       _Anki_Log
000082  f04f6080          MOV      r0,#0x4000000         ;279
000086  e7d5              B        |L271.52|
                  |L271.136|
000088  1c48              ADDS     r0,r1,#1              ;279
00008a  2802              CMP      r0,#2                 ;279
00008c  bfb8              IT       LT                    ;279
00008e  f8523021          LDRLT    r3,[r2,r1,LSL #2]     ;279
000092  da12              BGE      |L271.186|
                  |L271.148|
000094  f852c020          LDR      r12,[r2,r0,LSL #2]    ;279
000098  4563              CMP      r3,r12                ;279
00009a  d10b              BNE      |L271.180|
00009c  f44f708d          MOV      r0,#0x11a             ;282
0000a0  e9cd5000          STRD     r5,r0,[sp,#0]         ;282
0000a4  a3bf              ADR      r3,|L271.932|
0000a6  a2e1              ADR      r2,|L271.1068|
0000a8  a1d7              ADR      r1,|L271.1032|
0000aa  2005              MOVS     r0,#5                 ;282
0000ac  f7fffffe          BL       _Anki_Log
0000b0  48e7              LDR      r0,|L271.1104|
0000b2  e7bf              B        |L271.52|
                  |L271.180|
0000b4  1c40              ADDS     r0,r0,#1              ;282
0000b6  2802              CMP      r0,#2                 ;282
0000b8  dbec              BLT      |L271.148|
                  |L271.186|
0000ba  1c49              ADDS     r1,r1,#1              ;282
0000bc  2902              CMP      r1,#2                 ;282
0000be  dbe3              BLT      |L271.136|
0000c0  2100              MOVS     r1,#0                 ;288
0000c2  4630              MOV      r0,r6                 ;288
0000c4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000c8  ee080a10          VMOV     s16,r0                ;288
0000cc  2101              MOVS     r1,#1                 ;289
0000ce  4630              MOV      r0,r6                 ;289
0000d0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000d4  ee080a90          VMOV     s17,r0                ;289
0000d8  2100              MOVS     r1,#0                 ;291
0000da  4640              MOV      r0,r8                 ;291
0000dc  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000e0  9001              STR      r0,[sp,#4]            ;292
0000e2  2101              MOVS     r1,#1                 ;292
0000e4  4640              MOV      r0,r8                 ;292
0000e6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000ea  4604              MOV      r4,r0                 ;292
0000ec  2100              MOVS     r1,#0                 ;294
0000ee  4640              MOV      r0,r8                 ;294
0000f0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000f4  2801              CMP      r0,#1                 ;294
0000f6  bf14              ITE      NE                    ;294
0000f8  f04f0b00          MOVNE    r11,#0                ;294
0000fc  f04f0b01          MOVEQ    r11,#1                ;294
000100  eeb80ae8          VCVT.F32.S32 s0,s17                ;297
000104  eef70a00          VMOV.F32 s1,#1.00000000        ;297
000108  2000              MOVS     r0,#0                 ;300
00010a  ee300a60          VSUB.F32 s0,s0,s1              ;297
00010e  ed8d0a07          VSTR     s0,[sp,#0x1c]         ;297
000112  eeb80ac8          VCVT.F32.S32 s0,s16                ;298
000116  ee300a60          VSUB.F32 s0,s0,s1              ;298
00011a  ed8d0a06          VSTR     s0,[sp,#0x18]         ;298
00011e  f8d92010          LDR      r2,[r9,#0x10]         ;298
000122  f8d91008          LDR      r1,[r9,#8]            ;298
000126  fb002001          MLA      r0,r0,r1,r2           ;298
00012a  ed900a00          VLDR     s0,[r0,#0]            ;300
00012e  ed8d0a05          VSTR     s0,[sp,#0x14]         ;300
000132  ed900a01          VLDR     s0,[r0,#4]            ;300
000136  ed8d0a04          VSTR     s0,[sp,#0x10]         ;300
00013a  edd0fa02          VLDR     s31,[r0,#8]           ;300
00013e  2001              MOVS     r0,#1                 ;301
000140  fb002001          MLA      r0,r0,r1,r2           ;301
000144  ed970a01          VLDR     s0,[r7,#4]            ;301
000148  ed90fa00          VLDR     s30,[r0,#0]           ;301
00014c  edd0ea01          VLDR     s29,[r0,#4]           ;301
000150  ed90ea02          VLDR     s28,[r0,#8]           ;301
000154  2002              MOVS     r0,#2                 ;302
000156  fb002001          MLA      r0,r0,r1,r2           ;302
00015a  edd78a04          VLDR     s17,[r7,#0x10]        ;302
00015e  edd0da00          VLDR     s27,[r0,#0]           ;302
000162  ed90da01          VLDR     s26,[r0,#4]           ;302
000166  edd0ca02          VLDR     s25,[r0,#8]           ;302
00016a  ed8d0a03          VSTR     s0,[sp,#0xc]          ;308
00016e  ed970a05          VLDR     s0,[r7,#0x14]         ;308
000172  f1bb0f00          CMP      r11,#0                ;317
000176  ed8d0a02          VSTR     s0,[sp,#8]            ;310
00017a  ed97ca02          VLDR     s24,[r7,#8]           ;310
00017e  68f8              LDR      r0,[r7,#0xc]          ;313
000180  9000              STR      r0,[sp,#0]            ;313
000182  683f              LDR      r7,[r7,#0]            ;313
000184  9901              LDR      r1,[sp,#4]            ;317
000186  d012              BEQ      |L271.430|
000188  4361              MULS     r1,r4,r1              ;318
00018a  4378              MULS     r0,r7,r0              ;319
00018c  428c              CMP      r4,r1                 ;321
00018e  bf08              IT       EQ                    ;321
000190  4288              CMPEQ    r0,r1                 ;321
000192  d01d              BEQ      |L271.464|
000194  f2401041          MOV      r0,#0x141             ;321
000198  e9cd5000          STRD     r5,r0,[sp,#0]         ;321
00019c  a381              ADR      r3,|L271.932|
00019e  a2ad              ADR      r2,|L271.1108|
0001a0  a199              ADR      r1,|L271.1032|
0001a2  2005              MOVS     r0,#5                 ;321
0001a4  f7fffffe          BL       _Anki_Log
0001a8  f04f60a0          MOV      r0,#0x5000000         ;321
0001ac  e742              B        |L271.52|
                  |L271.430|
0001ae  4288              CMP      r0,r1                 ;326
0001b0  bf08              IT       EQ                    ;326
0001b2  42a7              CMPEQ    r7,r4                 ;326
0001b4  d00c              BEQ      |L271.464|
0001b6  f44f70a3          MOV      r0,#0x146             ;326
0001ba  e9cd5000          STRD     r5,r0,[sp,#0]         ;326
0001be  a379              ADR      r3,|L271.932|
0001c0  a2a4              ADR      r2,|L271.1108|
0001c2  a191              ADR      r1,|L271.1032|
0001c4  2005              MOVS     r0,#5                 ;326
0001c6  f7fffffe          BL       _Anki_Log
0001ca  f04f60a0          MOV      r0,#0x5000000         ;326
0001ce  e731              B        |L271.52|
                  |L271.464|
0001d0  2000              MOVS     r0,#0                 ;332
0001d2  f8d82008          LDR      r2,[r8,#8]            ;332
0001d6  f8d81010          LDR      r1,[r8,#0x10]         ;332
0001da  f1bb0f00          CMP      r11,#0                ;334
0001de  fb001502          MLA      r5,r0,r2,r1           ;334
0001e2  bf18              IT       NE                    ;336
0001e4  1bed              SUBNE    r5,r5,r7              ;336
0001e6  f04f0900          MOV      r9,#0                 ;340
0001ea  9800              LDR      r0,[sp,#0]            ;340
0001ec  2800              CMP      r0,#0                 ;340
0001ee  bfc8              IT       GT                    ;340
0001f0  ed9fbaa2          VLDRGT   s22,|L271.1148|
0001f4  dd7d              BLE      |L271.754|
                  |L271.502|
0001f6  f1bb0f00          CMP      r11,#0                ;341
0001fa  bf18              IT       NE                    ;344
0001fc  443d              ADDNE    r5,r7                 ;344
0001fe  d105              BNE      |L271.524|
000200  f8d81008          LDR      r1,[r8,#8]            ;341
000204  f8d80010          LDR      r0,[r8,#0x10]         ;341
000208  fb090501          MLA      r5,r9,r1,r0           ;341
                  |L271.524|
00020c  ed9d8a03          VLDR     s16,[sp,#0xc]         ;349
000210  2400              MOVS     r4,#0                 ;351
000212  2f00              CMP      r7,#0                 ;351
000214  dd6e              BLE      |L271.756|
                  |L271.534|
000216  ed9d0a05          VLDR     s0,[sp,#0x14]         ;353
00021a  eddd0a04          VLDR     s1,[sp,#0x10]         ;353
00021e  ee200a08          VMUL.F32 s0,s0,s16             ;353
000222  ee000aa8          VMLA.F32 s0,s1,s17             ;353
000226  ee301a2f          VADD.F32 s2,s0,s31             ;353
00022a  ee2f0a08          VMUL.F32 s0,s30,s16            ;354
00022e  ee0e0aa8          VMLA.F32 s0,s29,s17            ;354
000232  ee700a0e          VADD.F32 s1,s0,s28             ;354
000236  ee2d0a88          VMUL.F32 s0,s27,s16            ;356
00023a  ee388a0c          VADD.F32 s16,s16,s24           ;361
00023e  ee0d0a28          VMLA.F32 s0,s26,s17            ;356
000242  ee300a2c          VADD.F32 s0,s0,s25             ;356
000246  eec11a00          VDIV.F32 s3,s2,s0              ;358
00024a  ed9a1a00          VLDR     s2,[r10,#0]           ;358
00024e  ee71aa81          VADD.F32 s21,s3,s2             ;358
000252  ee801a80          VDIV.F32 s2,s1,s0              ;359
000256  ed9a0a01          VLDR     s0,[r10,#4]           ;359
00025a  ee31aa00          VADD.F32 s20,s2,s0             ;359
00025e  ed9f9a88          VLDR     s18,|L271.1152|
000262  ee3a0a89          VADD.F32 s0,s21,s18            ;363
000266  f7fffffe          BL       __hardfp_floorf
00026a  eef09a40          VMOV.F32 s19,s0                ;363
00026e  eeb00a6a          VMOV.F32 s0,s21                ;364
000272  f7fffffe          BL       __hardfp_ceilf
000276  eef0ba40          VMOV.F32 s23,s0                ;364
00027a  ee3a0a09          VADD.F32 s0,s20,s18            ;366
00027e  f7fffffe          BL       __hardfp_floorf
000282  eeb09a40          VMOV.F32 s18,s0                ;366
000286  eeb00a4a          VMOV.F32 s0,s20                ;367
00028a  f7fffffe          BL       __hardfp_ceilf
00028e  eef59ac0          VCMPE.F32 s19,#0.0              ;370
000292  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;370
000296  d312              BCC      |L271.702|
000298  eddd0a07          VLDR     s1,[sp,#0x1c]         ;370
00029c  eef4bae0          VCMPE.F32 s23,s1                ;370
0002a0  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;370
0002a4  dc0b              BGT      |L271.702|
0002a6  eeb59ac0          VCMPE.F32 s18,#0.0              ;370
0002aa  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;370
0002ae  d306              BCC      |L271.702|
0002b0  eddd0a06          VLDR     s1,[sp,#0x18]         ;370
0002b4  eeb40ae0          VCMPE.F32 s0,s1                 ;370
0002b8  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;370
0002bc  dd01              BLE      |L271.706|
                  |L271.702|
0002be  9824              LDR      r0,[sp,#0x90]         ;372
0002c0  e05d              B        |L271.894|
                  |L271.706|
0002c2  ee7a0ae9          VSUB.F32 s1,s21,s19            ;375
0002c6  ee3a1a49          VSUB.F32 s2,s20,s18            ;378
0002ca  eeb72a00          VMOV.F32 s4,#1.00000000        ;376
0002ce  eeb59ac0          VCMPE.F32 s18,#0.0              ;376
0002d2  ee721a60          VSUB.F32 s3,s4,s1              ;376
0002d6  ee722a41          VSUB.F32 s5,s4,s2              ;379
0002da  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;379
0002de  bfcc              ITE      GT                    ;379
0002e0  ee392a0b          VADDGT.F32 s4,s18,s22            ;379
0002e4  ee392a4b          VSUBLE.F32 s4,s18,s22            ;379
0002e8  eebd2ac2          VCVT.S32.F32 s4,s4                 ;379
0002ec  ee123a10          VMOV     r3,s4                 ;379
0002f0  e001              B        |L271.758|
                  |L271.754|
0002f2  e053              B        |L271.924|
                  |L271.756|
0002f4  e048              B        |L271.904|
                  |L271.758|
0002f6  eeb50ac0          VCMPE.F32 s0,#0.0               ;379
0002fa  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;379
0002fe  bfcc              ITE      GT                    ;379
000300  ee300a0b          VADDGT.F32 s0,s0,s22             ;379
000304  ee300a4b          VSUBLE.F32 s0,s0,s22             ;379
000308  eebd0ac0          VCVT.S32.F32 s0,s0                 ;379
00030c  eef59ac0          VCMPE.F32 s19,#0.0              ;379
000310  ee10ca10          VMOV     r12,s0                ;379
000314  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;379
000318  bfcc              ITE      GT                    ;379
00031a  ee390a8b          VADDGT.F32 s0,s19,s22            ;379
00031e  ee390acb          VSUBLE.F32 s0,s19,s22            ;379
000322  eebd0ac0          VCVT.S32.F32 s0,s0                 ;379
000326  68b2              LDR      r2,[r6,#8]            ;379
000328  6930              LDR      r0,[r6,#0x10]         ;379
00032a  ee101a10          VMOV     r1,s0                 ;379
00032e  fb030302          MLA      r3,r3,r2,r0           ;379
000332  fb0c0002          MLA      r0,r12,r2,r0          ;379
000336  440b              ADD      r3,r3,r1              ;379
000338  4408              ADD      r0,r0,r1              ;379
00033a  7819              LDRB     r1,[r3,#0]            ;388
00033c  ee001a10          VMOV     s0,r1                 ;388
000340  7859              LDRB     r1,[r3,#1]            ;389
000342  eeb83a40          VCVT.F32.U32 s6,s0                 ;388
000346  ee001a10          VMOV     s0,r1                 ;389
00034a  7801              LDRB     r1,[r0,#0]            ;390
00034c  7840              LDRB     r0,[r0,#1]            ;391
00034e  eef83a40          VCVT.F32.U32 s7,s0                 ;389
000352  ee001a10          VMOV     s0,r1                 ;390
000356  ee213a83          VMUL.F32 s6,s3,s6              ;390
00035a  eeb82a40          VCVT.F32.U32 s4,s0                 ;390
00035e  ee000a10          VMOV     s0,r0                 ;391
000362  ee003aa3          VMLA.F32 s6,s1,s7              ;391
000366  eeb80a40          VCVT.F32.U32 s0,s0                 ;391
00036a  ee611a82          VMUL.F32 s3,s3,s4              ;391
00036e  ee401a80          VMLA.F32 s3,s1,s0              ;391
000372  ee220a83          VMUL.F32 s0,s5,s6              ;391
000376  ee010a21          VMLA.F32 s0,s2,s3              ;391
00037a  f7fffffe          BL       _ZN4Anki8Embedded5RoundIiEET_f ; Anki::Embedded::Round<int>(float)
                  |L271.894|
00037e  5528              STRB     r0,[r5,r4]            ;397
000380  1c64              ADDS     r4,r4,#1              ;351
000382  42bc              CMP      r4,r7                 ;351
000384  f6ffaf47          BLT      |L271.534|
                  |L271.904|
000388  ed9d0a02          VLDR     s0,[sp,#8]            ;400
00038c  9800              LDR      r0,[sp,#0]            ;340
00038e  f1090901          ADD      r9,r9,#1              ;340
000392  ee788a80          VADD.F32 s17,s17,s0            ;400
000396  4581              CMP      r9,r0                 ;340
000398  f6ffaf2d          BLT      |L271.502|
                  |L271.924|
00039c  2000              MOVS     r0,#0                 ;403
00039e  e649              B        |L271.52|
                  |L271.928|
                          DCD      _ZZN4Anki8Embedded18Interp2_ProjectiveIhhEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_E19__PRETTY_FUNCTION__ ; Anki::Embedded::Interp2_Projective<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Meshgrid<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::Array<T2>&, Anki::Embedded::InterpolationType, T2)::__PRETTY_FUNCTION__
                  |L271.932|
0003a4  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/interp"
0003a8  6f726574
0003ac  6563685c
0003b0  636f6d6d
0003b4  6f6e5c69
0003b8  6e636c75
0003bc  64655c61
0003c0  6e6b692f
0003c4  636f6d6d
0003c8  6f6e2f72
0003cc  6f626f74
0003d0  2f696e74
0003d4  657270  
0003d7  6f6c6174          DCB      "olate.h",0
0003db  652e6800
0003df  00                DCB      0
                  |L271.992|
0003e0  4f6e6c79          DCB      "Only INTERPOLATE_LINEAR is supported",0
0003e4  20494e54
0003e8  4552504f
0003ec  4c415445
0003f0  5f4c494e
0003f4  45415220
0003f8  69732073
0003fc  7570706f
000400  72746564
000404  00      
000405  00                DCB      0
000406  00                DCB      0
000407  00                DCB      0
                  |L271.1032|
000408  496e7465          DCB      "Interp2_Projective",0
00040c  7270325f
000410  50726f6a
000414  65637469
000418  766500  
00041b  00                DCB      0
                  |L271.1052|
00041c  496e7661          DCB      "Invalid objects",0
000420  6c696420
000424  6f626a65
000428  63747300
                  |L271.1068|
00042c  72656665          DCB      "reference cannot be the same as out",0
000430  72656e63
000434  65206361
000438  6e6e6f74
00043c  20626520
000440  74686520
000444  73616d65
000448  20617320
00044c  6f757400
                  |L271.1104|
                          DCD      0x01000003
                  |L271.1108|
000454  6f726967          DCB      "originalCoordinates is the wrong size",0
000458  696e616c
00045c  436f6f72
000460  64696e61
000464  74657320
000468  69732074
00046c  68652077
000470  726f6e67
000474  2073697a
000478  6500    
00047a  00                DCB      0
00047b  00                DCB      0
                  |L271.1148|
00047c  3f000000          DCFS     0x3f000000 ; 0.5
                  |L271.1152|
000480  3727c5ac          DCFS     0x3727c5ac ; 9.9999997473787516e-06
                          ENDP


                          AREA ||area_number.272||, COMGROUP=_ZN4Anki8Embedded18Interp2_ProjectiveIhhEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_, LINKORDER=||t._ZN4Anki8Embedded18Interp2_ProjectiveIhhEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.272||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded18Interp2_ProjectiveIhhEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb||, COMGROUP=_ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb PROC ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)
;;;352    
;;;353          template<typename Type> Result SolveLeastSquaresWithCholesky(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;354            Array<Type> &A_L,       //!< Input A Matrix and Output lower-triangular L matrix
;;;355            Array<Type> &Bt_Xt,     //!< Input B-transpose matrix and Output X-transpose solution
;;;356            bool realCholesky,      //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;357            bool &numericalFailure  //!< If true, the solver failed because of numerical instability
;;;358            )
;;;359          {
000004  460e              MOV      r6,r1
000006  ed2d8b02          VPUSH    {d8}
00000a  b083              SUB      sp,sp,#0xc
00000c  4699              MOV      r9,r3
00000e  4604              MOV      r4,r0
;;;360            const s32 matrixHeight = A_L.get_size(0);
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000016  4605              MOV      r5,r0
;;;361            const s32 numSamples = Bt_Xt.get_size(0);
000018  2100              MOVS     r1,#0
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000020  4607              MOV      r7,r0
;;;362    
;;;363            numericalFailure = false;
000022  2000              MOVS     r0,#0
000024  f8890000          STRB     r0,[r9,#0]
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
;;;364    
;;;365            AnkiConditionalErrorAndReturnValue(AreValid(A_L, Bt_Xt),
00002e  f8df8258          LDR      r8,|L278.648|
000032  2800              CMP      r0,#0
000034  d01c              BEQ      |L278.112|
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00003c  2800              CMP      r0,#0
00003e  d017              BEQ      |L278.112|
;;;366              RESULT_FAIL_INVALID_OBJECT, "CholeskyDecomposition", "Invalid objects");
;;;367    
;;;368            AnkiConditionalErrorAndReturnValue(matrixHeight == A_L.get_size(1),
000040  2101              MOVS     r1,#1
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000048  42a8              CMP      r0,r5
00004a  d01e              BEQ      |L278.138|
00004c  f44f70b8          MOV      r0,#0x170
000050  e9cd8000          STRD     r8,r0,[sp,#0]
000054  a38d              ADR      r3,|L278.652|
000056  a29b              ADR      r2,|L278.708|
000058  a19f              ADR      r1,|L278.728|
00005a  2005              MOVS     r0,#5
00005c  f7fffffe          BL       _Anki_Log
000060  f04f60a0          MOV      r0,#0x5000000
                  |L278.100|
;;;369              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "A_L is not square");
;;;370    
;;;371            AnkiConditionalErrorAndReturnValue(Bt_Xt.get_size(1) == matrixHeight,
;;;372              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "Xt and Bt are the wrong sizes");
;;;373    
;;;374            // TODO: check if symmetric and positive-definite
;;;375    
;;;376            const Type minStableValue = Anki::Embedded::Flags::numeric_limits<Type>::epsilon();
;;;377    
;;;378            for(s32 i = 0; i < matrixHeight; i++) {
;;;379              // First, compute the non-diagonal values
;;;380              // This uses the results from the diagonal inverse computation from previous iterations of i
;;;381              Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;382    
;;;383              for(s32 j = 0; j < i; j++) {
;;;384                Type * restrict pAL_yj = A_L.Pointer(j, 0);
;;;385    
;;;386                Type sum = pAL_yi[j];
;;;387                for(s32 k = 0; k < j; k++) {
;;;388                  const Type value1 = pAL_yi[k];
;;;389                  const Type value2 = pAL_yj[k];
;;;390                  sum -= value1*value2;
;;;391                }
;;;392    
;;;393                pAL_yi[j] = sum*pAL_yj[j];
;;;394              } // for(s32 j = 0; j < i; j++)
;;;395    
;;;396              // Second, compute the inverse of the diagonal
;;;397              {
;;;398                Type sum = pAL_yi[i];
;;;399                for(s32 k = 0; k < i; k++) {
;;;400                  const Type value = pAL_yi[k];
;;;401                  sum -= value*value;
;;;402                }
;;;403    
;;;404                if(sum < minStableValue) {
;;;405                  numericalFailure = true;
;;;406                  return RESULT_OK;
;;;407                }
;;;408    
;;;409                // TODO: change this f32 square root to f64 if Type==f64
;;;410                const Type sumRoot = static_cast<Type>(sqrtf(static_cast<f32>(sum)));
;;;411                pAL_yi[i] = static_cast<Type>(1) / sumRoot;
;;;412              }
;;;413            } // for(s32 i = 0; i < m; i++)
;;;414    
;;;415            // Solve L*y = b via forward substitution
;;;416            for(s32 i = 0; i < matrixHeight; i++) {
;;;417              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;418              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;419    
;;;420              for(s32 j = 0; j < numSamples; j++) {
;;;421                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;422    
;;;423                Type sum = pBX_yj[i];
;;;424                for(s32 k = 0; k < i; k++) {
;;;425                  const Type value1 = pAL_yi[k];
;;;426                  const Type value2 = pBX_yj[k];
;;;427                  sum -= value1*value2;
;;;428                }
;;;429    
;;;430                pBX_yj[i] = sum*pAL_yi[i];
;;;431              }
;;;432            }
;;;433    
;;;434            // Solve L'*X = Y via back substitution
;;;435            for(s32 i = matrixHeight-1; i >= 0; i--) {
;;;436              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;437              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;438    
;;;439              for(s32 j = 0; j < numSamples; j++) {
;;;440                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;441    
;;;442                Type sum = pBX_yj[i];
;;;443                for(s32 k = matrixHeight-1; k > i; k-- ) {
;;;444                  const Type value1 = A_L[k][i];
;;;445                  const Type value2 = pBX_yj[k];
;;;446                  sum -= value1*value2;
;;;447                }
;;;448    
;;;449                pBX_yj[i] = sum*pAL_yi[i];
;;;450              }
;;;451            }
;;;452    
;;;453            if(realCholesky) {
;;;454              // Invert the diagonal values of L, and set upper triangular to zero
;;;455              for(s32 i = 0; i < matrixHeight; i++) {
;;;456                Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;457    
;;;458                pAL_yi[i] = static_cast<Type>(1) / pAL_yi[i];
;;;459    
;;;460                for(s32 j = i+1; j < matrixHeight; j++) {
;;;461                  pAL_yi[j] = 0;
;;;462                }
;;;463              }
;;;464            }
;;;465    
;;;466            return RESULT_OK;
;;;467          } // SolveLeastSquaresWithCholesky()
000064  b003              ADD      sp,sp,#0xc
000066  ecbd8b02          VPOP     {d8}
00006a  b004              ADD      sp,sp,#0x10
00006c  e8bd8ff0          POP      {r4-r11,pc}
                  |L278.112|
000070  f240106d          MOV      r0,#0x16d             ;365
000074  e9cd8000          STRD     r8,r0,[sp,#0]         ;365
000078  a384              ADR      r3,|L278.652|
00007a  a29d              ADR      r2,|L278.752|
00007c  a196              ADR      r1,|L278.728|
00007e  2005              MOVS     r0,#5                 ;365
000080  f7fffffe          BL       _Anki_Log
000084  f04f6080          MOV      r0,#0x4000000         ;365
000088  e7ec              B        |L278.100|
                  |L278.138|
00008a  2101              MOVS     r1,#1                 ;371
00008c  4630              MOV      r0,r6                 ;371
00008e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000092  42a8              CMP      r0,r5                 ;371
000094  d00c              BEQ      |L278.176|
000096  f2401073          MOV      r0,#0x173             ;371
00009a  e9cd8000          STRD     r8,r0,[sp,#0]         ;371
00009e  a37b              ADR      r3,|L278.652|
0000a0  a297              ADR      r2,|L278.768|
0000a2  a18d              ADR      r1,|L278.728|
0000a4  2005              MOVS     r0,#5                 ;371
0000a6  f7fffffe          BL       _Anki_Log
0000aa  f04f60a0          MOV      r0,#0x5000000         ;371
0000ae  e7d9              B        |L278.100|
                  |L278.176|
0000b0  eddf8a9b          VLDR     s17,|L278.800|
0000b4  f04f0800          MOV      r8,#0                 ;378
0000b8  eeb78a00          VMOV.F32 s16,#1.00000000       ;411
0000bc  2d00              CMP      r5,#0                 ;378
0000be  dd58              BLE      |L278.370|
                  |L278.192|
0000c0  68a1              LDR      r1,[r4,#8]            ;378
0000c2  6920              LDR      r0,[r4,#0x10]         ;378
0000c4  2200              MOVS     r2,#0                 ;383
0000c6  fb080101          MLA      r1,r8,r1,r0           ;383
0000ca  f1b80f00          CMP      r8,#0                 ;383
0000ce  dd22              BLE      |L278.278|
                  |L278.208|
0000d0  68a3              LDR      r3,[r4,#8]            ;383
0000d2  6920              LDR      r0,[r4,#0x10]         ;383
0000d4  eb010c82          ADD      r12,r1,r2,LSL #2      ;386
0000d8  fb020303          MLA      r3,r2,r3,r0           ;386
0000dc  ed9c0a00          VLDR     s0,[r12,#0]           ;386
0000e0  2000              MOVS     r0,#0                 ;387
0000e2  2a00              CMP      r2,#0                 ;387
0000e4  dd0c              BLE      |L278.256|
                  |L278.230|
0000e6  eb010a80          ADD      r10,r1,r0,LSL #2      ;388
0000ea  ed9a1a00          VLDR     s2,[r10,#0]           ;388
0000ee  eb030a80          ADD      r10,r3,r0,LSL #2      ;389
0000f2  1c40              ADDS     r0,r0,#1              ;387
0000f4  edda0a00          VLDR     s1,[r10,#0]           ;389
0000f8  4282              CMP      r2,r0                 ;387
0000fa  ee010a60          VMLS.F32 s0,s2,s1              ;390
0000fe  dcf2              BGT      |L278.230|
                  |L278.256|
000100  eb030082          ADD      r0,r3,r2,LSL #2       ;393
000104  1c52              ADDS     r2,r2,#1              ;383
000106  edd00a00          VLDR     s1,[r0,#0]            ;393
00010a  4542              CMP      r2,r8                 ;383
00010c  ee200a80          VMUL.F32 s0,s1,s0              ;393
000110  ed8c0a00          VSTR     s0,[r12,#0]           ;393
000114  dbdc              BLT      |L278.208|
                  |L278.278|
000116  eb010a88          ADD      r10,r1,r8,LSL #2      ;398
00011a  2000              MOVS     r0,#0                 ;399
00011c  ed9a0a00          VLDR     s0,[r10,#0]           ;398
000120  f1b80f00          CMP      r8,#0                 ;399
000124  dd08              BLE      |L278.312|
                  |L278.294|
000126  eb010280          ADD      r2,r1,r0,LSL #2       ;400
00012a  1c40              ADDS     r0,r0,#1              ;399
00012c  edd20a00          VLDR     s1,[r2,#0]            ;400
000130  4580              CMP      r8,r0                 ;399
000132  ee000ae0          VMLS.F32 s0,s1,s1              ;401
000136  dcf6              BGT      |L278.294|
                  |L278.312|
000138  eef48ac0          VCMPE.F32 s17,s0                ;404
00013c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;404
000140  dd04              BLE      |L278.332|
000142  2001              MOVS     r0,#1                 ;405
000144  f8890000          STRB     r0,[r9,#0]            ;405
000148  2000              MOVS     r0,#0                 ;406
00014a  e78b              B        |L278.100|
                  |L278.332|
00014c  eef10ac0          VSQRT.F32 s1,s0                 ;410
000150  eef40a60          VCMP.F32 s1,s1                 ;410
000154  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;410
000158  d003              BEQ      |L278.354|
00015a  f7fffffe          BL       __hardfp_sqrtf
00015e  eef00a40          VMOV.F32 s1,s0                 ;410
                  |L278.354|
000162  f1080801          ADD      r8,r8,#1              ;378
000166  ee880a20          VDIV.F32 s0,s16,s1             ;411
00016a  45a8              CMP      r8,r5                 ;378
00016c  ed8a0a00          VSTR     s0,[r10,#0]           ;411
000170  dba6              BLT      |L278.192|
                  |L278.370|
000172  2100              MOVS     r1,#0                 ;416
000174  2d00              CMP      r5,#0                 ;416
000176  dd2d              BLE      |L278.468|
                  |L278.376|
000178  68a2              LDR      r2,[r4,#8]            ;416
00017a  6920              LDR      r0,[r4,#0x10]         ;416
00017c  fb010c02          MLA      r12,r1,r2,r0          ;416
000180  2200              MOVS     r2,#0                 ;420
000182  2f00              CMP      r7,#0                 ;420
000184  bfc8              IT       GT                    ;430
000186  eb0c0981          ADDGT    r9,r12,r1,LSL #2      ;430
00018a  dd20              BLE      |L278.462|
                  |L278.396|
00018c  68b3              LDR      r3,[r6,#8]            ;420
00018e  6930              LDR      r0,[r6,#0x10]         ;420
000190  fb020303          MLA      r3,r2,r3,r0           ;420
000194  eb030881          ADD      r8,r3,r1,LSL #2       ;423
000198  2000              MOVS     r0,#0                 ;424
00019a  ed980a00          VLDR     s0,[r8,#0]            ;423
00019e  2900              CMP      r1,#0                 ;424
0001a0  dd0c              BLE      |L278.444|
                  |L278.418|
0001a2  eb0c0a80          ADD      r10,r12,r0,LSL #2     ;425
0001a6  ed9a1a00          VLDR     s2,[r10,#0]           ;425
0001aa  eb030a80          ADD      r10,r3,r0,LSL #2      ;426
0001ae  1c40              ADDS     r0,r0,#1              ;424
0001b0  edda0a00          VLDR     s1,[r10,#0]           ;426
0001b4  4281              CMP      r1,r0                 ;424
0001b6  ee010a60          VMLS.F32 s0,s2,s1              ;427
0001ba  dcf2              BGT      |L278.418|
                  |L278.444|
0001bc  edd90a00          VLDR     s1,[r9,#0]            ;430
0001c0  1c52              ADDS     r2,r2,#1              ;420
0001c2  42ba              CMP      r2,r7                 ;420
0001c4  ee200a80          VMUL.F32 s0,s1,s0              ;430
0001c8  ed880a00          VSTR     s0,[r8,#0]            ;430
0001cc  dbde              BLT      |L278.396|
                  |L278.462|
0001ce  1c49              ADDS     r1,r1,#1              ;416
0001d0  42a9              CMP      r1,r5                 ;416
0001d2  dbd1              BLT      |L278.376|
                  |L278.468|
0001d4  1e69              SUBS     r1,r5,#1              ;435
0001d6  d433              BMI      |L278.576|
                  |L278.472|
0001d8  68a2              LDR      r2,[r4,#8]            ;435
0001da  6920              LDR      r0,[r4,#0x10]         ;435
0001dc  fb010002          MLA      r0,r1,r2,r0           ;435
0001e0  2200              MOVS     r2,#0                 ;439
0001e2  2f00              CMP      r7,#0                 ;439
0001e4  bfc8              IT       GT                    ;449
0001e6  eb000a81          ADDGT    r10,r0,r1,LSL #2      ;449
0001ea  dd27              BLE      |L278.572|
                  |L278.492|
0001ec  68b3              LDR      r3,[r6,#8]            ;439
0001ee  6930              LDR      r0,[r6,#0x10]         ;439
0001f0  fb020303          MLA      r3,r2,r3,r0           ;439
0001f4  eb030981          ADD      r9,r3,r1,LSL #2       ;442
0001f8  1e68              SUBS     r0,r5,#1              ;443
0001fa  ed990a00          VLDR     s0,[r9,#0]            ;442
0001fe  4288              CMP      r0,r1                 ;443
000200  bfc4              ITT      GT                    ;443
000202  f8d4c010          LDRGT    r12,[r4,#0x10]        ;443
000206  f8d48008          LDRGT    r8,[r4,#8]            ;443
00020a  dd0e              BLE      |L278.554|
                  |L278.524|
00020c  fb00cb08          MLA      r11,r0,r8,r12         ;443
000210  eb0b0b81          ADD      r11,r11,r1,LSL #2     ;444
000214  ed9b1a00          VLDR     s2,[r11,#0]           ;444
000218  eb030b80          ADD      r11,r3,r0,LSL #2      ;445
00021c  1e40              SUBS     r0,r0,#1              ;443
00021e  eddb0a00          VLDR     s1,[r11,#0]           ;445
000222  4288              CMP      r0,r1                 ;443
000224  ee010a60          VMLS.F32 s0,s2,s1              ;446
000228  dcf0              BGT      |L278.524|
                  |L278.554|
00022a  edda0a00          VLDR     s1,[r10,#0]           ;449
00022e  1c52              ADDS     r2,r2,#1              ;439
000230  4297              CMP      r7,r2                 ;439
000232  ee200a80          VMUL.F32 s0,s1,s0              ;449
000236  ed890a00          VSTR     s0,[r9,#0]            ;449
00023a  dcd7              BGT      |L278.492|
                  |L278.572|
00023c  1e49              SUBS     r1,r1,#1              ;435
00023e  d5cb              BPL      |L278.472|
                  |L278.576|
000240  9807              LDR      r0,[sp,#0x1c]         ;453
000242  2800              CMP      r0,#0                 ;453
000244  bf1c              ITT      NE                    ;455
000246  2100              MOVNE    r1,#0                 ;455
000248  2d00              CMPNE    r5,#0                 ;455
00024a  bfc8              IT       GT                    ;461
00024c  ed9f0a35          VLDRGT   s0,|L278.804|
000250  dd18              BLE      |L278.644|
                  |L278.594|
000252  68a2              LDR      r2,[r4,#8]            ;453
000254  6920              LDR      r0,[r4,#0x10]         ;453
000256  fb010202          MLA      r2,r1,r2,r0           ;453
00025a  eb020081          ADD      r0,r2,r1,LSL #2       ;458
00025e  edd00a00          VLDR     s1,[r0,#0]            ;458
000262  ee881a20          VDIV.F32 s2,s16,s1             ;458
000266  ed801a00          VSTR     s2,[r0,#0]            ;458
00026a  1c48              ADDS     r0,r1,#1              ;460
00026c  4285              CMP      r5,r0                 ;460
00026e  dd06              BLE      |L278.638|
                  |L278.624|
000270  eb020380          ADD      r3,r2,r0,LSL #2       ;461
000274  1c40              ADDS     r0,r0,#1              ;460
000276  ed830a00          VSTR     s0,[r3,#0]            ;461
00027a  4285              CMP      r5,r0                 ;460
00027c  dcf8              BGT      |L278.624|
                  |L278.638|
00027e  1c49              ADDS     r1,r1,#1              ;455
000280  42a9              CMP      r1,r5                 ;455
000282  dbe6              BLT      |L278.594|
                  |L278.644|
000284  2000              MOVS     r0,#0                 ;466
000286  e6ed              B        |L278.100|
;;;468    
                          ENDP

                  |L278.648|
                          DCD      _ZZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)::__PRETTY_FUNCTION__
                  |L278.652|
00028c  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000290  6f726574
000294  6563685c
000298  636f6d6d
00029c  6f6e5c69
0002a0  6e636c75
0002a4  64655c61
0002a8  6e6b692f
0002ac  636f6d6d
0002b0  6f6e2f72
0002b4  6f626f74
0002b8  2f6d6174
0002bc  726978  
0002bf  2e6800            DCB      ".h",0
0002c2  00                DCB      0
0002c3  00                DCB      0
                  |L278.708|
0002c4  415f4c20          DCB      "A_L is not square",0
0002c8  6973206e
0002cc  6f742073
0002d0  71756172
0002d4  6500    
0002d6  00                DCB      0
0002d7  00                DCB      0
                  |L278.728|
0002d8  43686f6c          DCB      "CholeskyDecomposition",0
0002dc  65736b79
0002e0  4465636f
0002e4  6d706f73
0002e8  6974696f
0002ec  6e00    
0002ee  00                DCB      0
0002ef  00                DCB      0
                  |L278.752|
0002f0  496e7661          DCB      "Invalid objects",0
0002f4  6c696420
0002f8  6f626a65
0002fc  63747300
                  |L278.768|
000300  58742061          DCB      "Xt and Bt are the wrong sizes",0
000304  6e642042
000308  74206172
00030c  65207468
000310  65207772
000314  6f6e6720
000318  73697a65
00031c  7300    
00031e  00                DCB      0
00031f  00                DCB      0
                  |L278.800|
000320  34000000          DCFS     0x34000000 ; 1.1920928955078125e-07
                  |L278.804|
000324  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.279||, COMGROUP=_ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb, LINKORDER=||t._ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.279||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Ev||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Ev, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded14LinearSequenceIiEC2Ev                  ; Alternate entry point ; Anki::Embedded::LinearSequence<int>::LinearSequence__sub_object()
                  _ZN4Anki8Embedded14LinearSequenceIiEC1Ev PROC ; Anki::Embedded::LinearSequence<int>::LinearSequence()
;;;24     
;;;25         template<typename Type> LinearSequence<Type>::LinearSequence()
;;;26           : size(-1), start(-1), increment(static_cast<Type>(-1))
;;;27         {
;;;28           this->size = -1;
;;;29         }
;;;30     
000000  f04f31ff          MOV      r1,#0xffffffff
000004  6001              STR      r1,[r0,#0]
000006  6041              STR      r1,[r0,#4]
000008  6081              STR      r1,[r0,#8]
00000a  4770              BX       lr
                          ENDP


                          AREA ||area_number.286||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Ev, LINKORDER=||t._ZN4Anki8Embedded14LinearSequenceIiEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.286||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Eii, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded14LinearSequenceIiEC2Eii                  ; Alternate entry point ; Anki::Embedded::LinearSequence<int>::LinearSequence__sub_object(int, int)
                  _ZN4Anki8Embedded14LinearSequenceIiEC1Eii PROC ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
;;;30     
;;;31         template<typename Type> LinearSequence<Type>::LinearSequence(const Type start, const Type end)
;;;32           : start(start), increment(1)
;;;33         {
;;;34           this->size = computeSize(this->start, this->increment, end);
;;;35         }
;;;36     
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4608              MOV      r0,r1
000006  2101              MOVS     r1,#1
000008  e9c40101          STRD     r0,r1,[r4,#4]
00000c  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
000010  6020              STR      r0,[r4,#0]
000012  4620              MOV      r0,r4
000014  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||area_number.293||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Eii, LINKORDER=||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.293||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIiE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIiE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi PROC ; Anki::Embedded::Array<int>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L299.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L299.56|
00000e  4b0b              LDR      r3,|L299.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f1030250          ADD      r2,r3,#0x50
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L299.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L299.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::get_size(int) const::__PRETTY_FUNCTION__
                  |L299.60|
                          DCD      ||.constdata||+0x700

                          AREA ||area_number.300||, COMGROUP=_ZNK4Anki8Embedded5ArrayIiE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIiE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.300||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIiE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Point3IfEC1Ev||, COMGROUP=_ZN4Anki8Embedded6Point3IfEC1Ev, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Point3IfEC2Ev                  ; Alternate entry point ; Anki::Embedded::Point3<float>::Point3__sub_object()
                  _ZN4Anki8Embedded6Point3IfEC1Ev PROC ; Anki::Embedded::Point3<float>::Point3()
;;;145    
;;;146        template<typename Type> Point3<Type>::Point3()
;;;147          : x(static_cast<Type>(0)), y(static_cast<Type>(0)), z(static_cast<Type>(0))
;;;148        {
;;;149        }
;;;150    
000000  ed9f0a04          VLDR     s0,|L306.20|
000004  ed800a00          VSTR     s0,[r0,#0]
000008  ed800a01          VSTR     s0,[r0,#4]
00000c  ed800a02          VSTR     s0,[r0,#8]
000010  4770              BX       lr
                          ENDP

000012  0000              DCW      0x0000
                  |L306.20|
000014  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.307||, COMGROUP=_ZN4Anki8Embedded6Point3IfEC1Ev, LINKORDER=||t._ZN4Anki8Embedded6Point3IfEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.307||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Point3IfEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i||, COMGROUP=_ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i PROC ; Anki::Embedded::IndexSequence<int>(T1, T1, T1, int)
;;;143    
;;;144        template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type increment, Type end, s32 arraySize)
000000  b510              PUSH     {r4,lr}
;;;145        {
000002  b084              SUB      sp,sp,#0x10
000004  4694              MOV      r12,r2
;;;146          // A negative value means (end-value)
;;;147          if(start < 0)
000006  9a06              LDR      r2,[sp,#0x18]
000008  4604              MOV      r4,r0                 ;145
00000a  2900              CMP      r1,#0
;;;148            start += arraySize;
00000c  bfb8              IT       LT
00000e  4411              ADDLT    r1,r2
;;;149    
;;;150          AnkiAssert(start >=0 && start < arraySize);
;;;151    
;;;152          // A negative value means (end-value)
;;;153          if(end < 0)
000010  2b00              CMP      r3,#0
;;;154            end += arraySize;
000012  bfb8              IT       LT
000014  4413              ADDLT    r3,r2
000016  e9cd1c01          STRD     r1,r12,[sp,#4]
00001a  4661              MOV      r1,r12
00001c  461a              MOV      r2,r3
00001e  9801              LDR      r0,[sp,#4]
000020  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
000024  9000              STR      r0,[sp,#0]
000026  e9dd1201          LDRD     r1,r2,[sp,#4]
;;;155    
;;;156          AnkiAssert(end >=0 && end < arraySize);
;;;157    
;;;158          LinearSequence<Type> sequence(start, increment, end);
;;;159    
;;;160          return sequence;
00002a  60a2              STR      r2,[r4,#8]
00002c  e9c40100          STRD     r0,r1,[r4,#0]
;;;161        }
000030  b004              ADD      sp,sp,#0x10
000032  bd10              POP      {r4,pc}
;;;162    
                          ENDP


                          AREA ||area_number.314||, COMGROUP=_ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i, LINKORDER=||t._ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.314||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded13IndexSequenceIiEENS0_14LinearSequenceIT_EES3_S3_S3_i||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIfE7IsValidEv||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE7IsValidEv, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded5ArrayIfE7IsValidEv PROC ; Anki::Embedded::Array<float>::IsValid() const
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
000000  6901              LDR      r1,[r0,#0x10]
;;;592        {
000002  b131              CBZ      r1,|L320.18|
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
000004  6801              LDR      r1,[r0,#0]
000006  2900              CMP      r1,#0
000008  bfa1              ITTTT    GE
00000a  6840              LDRGE    r0,[r0,#4]
00000c  2800              CMPGE    r0,#0
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
00000e  2001              MOVGE    r0,#1
;;;602        }
000010  4770              BXGE     lr
                  |L320.18|
000012  2000              MOVS     r0,#0                 ;598
000014  4770              BX       lr
;;;603    
                          ENDP


                          AREA ||area_number.321||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE7IsValidEv, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIfE7IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.321||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIfE7IsValidEv||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi PROC ; Anki::Embedded::Array<float>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L327.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L327.56|
00000e  4b0b              LDR      r3,|L327.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f1030250          ADD      r2,r3,#0x50
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L327.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L327.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::get_size(int) const::__PRETTY_FUNCTION__
                  |L327.60|
                          DCD      ||.constdata||+0x700

                          AREA ||area_number.328||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.328||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_||, COMGROUP=_ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded13QuadrilateralIfEC2ERKNS0_5PointIfEES6_S6_S6_                  ; Alternate entry point ; Anki::Embedded::Quadrilateral<float>::Quadrilateral__sub_object(const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&)
                  _ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_ PROC ; Anki::Embedded::Quadrilateral<float>::Quadrilateral(const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&)
;;;412    
;;;413        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Point<Type> &corner1, const Point<Type> &corner2, const Point<Type> &corner3, const Point<Type> &corner4)
;;;414        {
;;;415          corners[0] = corner1;
;;;416          corners[1] = corner2;
;;;417          corners[2] = corner3;
;;;418          corners[3] = corner4;
;;;419        }
;;;420    
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  461d              MOV      r5,r3
000006  4616              MOV      r6,r2
000008  460f              MOV      r7,r1
00000a  2304              MOVS     r3,#4
00000c  2208              MOVS     r2,#8
00000e  4913              LDR      r1,|L334.92|
000010  9c06              LDR      r4,[sp,#0x18]
000012  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
000016  ed970a00          VLDR     s0,[r7,#0]
00001a  ed800a00          VSTR     s0,[r0,#0]
00001e  ed970a01          VLDR     s0,[r7,#4]
000022  ed800a01          VSTR     s0,[r0,#4]
000026  ed960a00          VLDR     s0,[r6,#0]
00002a  ed800a02          VSTR     s0,[r0,#8]
00002e  ed960a01          VLDR     s0,[r6,#4]
000032  ed800a03          VSTR     s0,[r0,#0xc]
000036  ed950a00          VLDR     s0,[r5,#0]
00003a  ed800a04          VSTR     s0,[r0,#0x10]
00003e  ed950a01          VLDR     s0,[r5,#4]
000042  ed800a05          VSTR     s0,[r0,#0x14]
000046  ed940a00          VLDR     s0,[r4,#0]
00004a  ed800a06          VSTR     s0,[r0,#0x18]
00004e  ed940a01          VLDR     s0,[r4,#4]
000052  ed800a07          VSTR     s0,[r0,#0x1c]
000056  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

00005a  0000              DCW      0x0000
                  |L334.92|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()

                          AREA ||area_number.335||, COMGROUP=_ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_, LINKORDER=||t._ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.335||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv PROC ; Anki::Embedded::Quadrilateral<float>::ComputeClockwiseCorners<float>() const
;;;268          // Warning: This may give weird results for non-convex quadrilaterals
;;;269          template<typename OutType> Quadrilateral<OutType> ComputeClockwiseCorners() const;
000000  b5f0              PUSH     {r4-r7,lr}
000002  460d              MOV      r5,r1
000004  ed2d8b04          VPUSH    {d8-d9}
000008  b0c1              SUB      sp,sp,#0x104
00000a  4607              MOV      r7,r0
00000c  2201              MOVS     r2,#1
00000e  2300              MOVS     r3,#0
000010  4611              MOV      r1,r2
000012  a833              ADD      r0,sp,#0xcc
000014  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000018  6803              LDR      r3,[r0,#0]
00001a  2280              MOVS     r2,#0x80
00001c  a902              ADD      r1,sp,#8
00001e  a822              ADD      r0,sp,#0x88
000020  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
000024  2300              MOVS     r3,#0
000026  461a              MOV      r2,r3
000028  2101              MOVS     r1,#1
00002a  a83e              ADD      r0,sp,#0xf8
00002c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000030  6800              LDR      r0,[r0,#0]
000032  9000              STR      r0,[sp,#0]
000034  ab22              ADD      r3,sp,#0x88
000036  2204              MOVS     r2,#4
000038  2101              MOVS     r1,#1
00003a  a829              ADD      r0,sp,#0xa4
00003c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000040  2300              MOVS     r3,#0
000042  461a              MOV      r2,r3
000044  2101              MOVS     r1,#1
000046  a83f              ADD      r0,sp,#0xfc
000048  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00004c  6800              LDR      r0,[r0,#0]
00004e  9000              STR      r0,[sp,#0]
000050  ab22              ADD      r3,sp,#0x88
000052  2204              MOVS     r2,#4
000054  2101              MOVS     r1,#1
000056  a82e              ADD      r0,sp,#0xb8
000058  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00005c  aa34              ADD      r2,sp,#0xd0
00005e  4628              MOV      r0,r5
000060  ed9f9a56          VLDR     s18,|L341.444|
000064  2300              MOVS     r3,#0
000066  ed8d9a34          VSTR     s18,[sp,#0xd0]
00006a  ed8d9a35          VSTR     s18,[sp,#0xd4]
                  |L341.110|
00006e  eb0001c3          ADD      r1,r0,r3,LSL #3
000072  ed920a00          VLDR     s0,[r2,#0]
000076  edd10a00          VLDR     s1,[r1,#0]
00007a  1c5b              ADDS     r3,r3,#1
00007c  2b04              CMP      r3,#4
00007e  ee300a20          VADD.F32 s0,s0,s1
000082  ed820a00          VSTR     s0,[r2,#0]
000086  ed920a01          VLDR     s0,[r2,#4]
00008a  edd10a01          VLDR     s1,[r1,#4]
00008e  ee300a20          VADD.F32 s0,s0,s1
000092  ed820a01          VSTR     s0,[r2,#4]
000096  dbea              BLT      |L341.110|
000098  edd20a00          VLDR     s1,[r2,#0]
00009c  eeb50a00          VMOV.F32 s0,#0.25000000
0000a0  2400              MOVS     r4,#0
0000a2  ee600a80          VMUL.F32 s1,s1,s0
0000a6  edc20a00          VSTR     s1,[r2,#0]
0000aa  edd20a01          VLDR     s1,[r2,#4]
0000ae  ee200a80          VMUL.F32 s0,s1,s0
0000b2  ed820a01          VSTR     s0,[r2,#4]
                  |L341.182|
0000b6  eb0501c4          ADD      r1,r5,r4,LSL #3
0000ba  eddd0a34          VLDR     s1,[sp,#0xd0]
0000be  ed910a00          VLDR     s0,[r1,#0]
0000c2  2000              MOVS     r0,#0
0000c4  9a2b              LDR      r2,[sp,#0xac]
0000c6  ee708a60          VSUB.F32 s17,s0,s1
0000ca  ed910a01          VLDR     s0,[r1,#4]
0000ce  eddd0a35          VLDR     s1,[sp,#0xd4]
0000d2  992d              LDR      r1,[sp,#0xb4]
0000d4  eef58ac0          VCMPE.F32 s17,#0.0
0000d8  ee308a60          VSUB.F32 s16,s0,s1
0000dc  fb001002          MLA      r0,r0,r2,r1
0000e0  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000e4  eb000684          ADD      r6,r0,r4,LSL #2
0000e8  bf02              ITTT     EQ
0000ea  eeb58ac0          VCMPEEQ.F32 s16,#0.0
0000ee  eef1fa10          VMRSEQ   APSR_nzcv,FPSCR
0000f2  ed869a00          VSTREQ   s18,[r6,#0]
0000f6  d016              BEQ      |L341.294|
0000f8  eef00a68          VMOV.F32 s1,s17
0000fc  eeb00a48          VMOV.F32 s0,s16
000100  f7fffffe          BL       __hardfp_atan2f
000104  ee680aa8          VMUL.F32 s1,s17,s17
000108  ed860a00          VSTR     s0,[r6,#0]
00010c  ee480a08          VMLA.F32 s1,s16,s16
000110  eeb10ae0          VSQRT.F32 s0,s1
000114  eeb40a40          VCMP.F32 s0,s0
000118  eef1fa10          VMRS     APSR_nzcv,FPSCR
00011c  bf1c              ITT      NE
00011e  eeb00a60          VMOVNE.F32 s0,s1
000122  f7fffffe          BLNE     __hardfp_sqrtf
                  |L341.294|
000126  1c64              ADDS     r4,r4,#1
000128  2c04              CMP      r4,#4
00012a  dbc4              BLT      |L341.182|
00012c  4824              LDR      r0,|L341.448|
00012e  2400              MOVS     r4,#0
000130  e9cd4000          STRD     r4,r0,[sp,#0]
000134  2301              MOVS     r3,#1
000136  461a              MOV      r2,r3
000138  a92e              ADD      r1,sp,#0xb8
00013a  a829              ADD      r0,sp,#0xa4
00013c  f7fffffe          BL       _ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)
000140  9930              LDR      r1,[sp,#0xc0]
000142  9832              LDR      r0,[sp,#0xc8]
000144  f10d0cf0          ADD      r12,sp,#0xf0
000148  fb040001          MLA      r0,r4,r1,r0
00014c  ab3a              ADD      r3,sp,#0xe8
00014e  68c1              LDR      r1,[r0,#0xc]
000150  aa38              ADD      r2,sp,#0xe0
000152  eb0501c1          ADD      r1,r5,r1,LSL #3
000156  ed910a00          VLDR     s0,[r1,#0]
00015a  edd10a01          VLDR     s1,[r1,#4]
00015e  ed8d0a3c          VSTR     s0,[sp,#0xf0]
000162  edcd0a3d          VSTR     s1,[sp,#0xf4]
000166  6881              LDR      r1,[r0,#8]
000168  eb0501c1          ADD      r1,r5,r1,LSL #3
00016c  ed910a00          VLDR     s0,[r1,#0]
000170  edd10a01          VLDR     s1,[r1,#4]
000174  ed8d0a3a          VSTR     s0,[sp,#0xe8]
000178  edcd0a3b          VSTR     s1,[sp,#0xec]
00017c  6841              LDR      r1,[r0,#4]
00017e  eb0501c1          ADD      r1,r5,r1,LSL #3
000182  ed910a00          VLDR     s0,[r1,#0]
000186  edd10a01          VLDR     s1,[r1,#4]
00018a  ed8d0a38          VSTR     s0,[sp,#0xe0]
00018e  edcd0a39          VSTR     s1,[sp,#0xe4]
000192  6800              LDR      r0,[r0,#0]
000194  a936              ADD      r1,sp,#0xd8
000196  eb0500c0          ADD      r0,r5,r0,LSL #3
00019a  ed900a00          VLDR     s0,[r0,#0]
00019e  edd00a01          VLDR     s1,[r0,#4]
0001a2  ed8d0a36          VSTR     s0,[sp,#0xd8]
0001a6  edcd0a37          VSTR     s1,[sp,#0xdc]
0001aa  4638              MOV      r0,r7
0001ac  f8cdc000          STR      r12,[sp,#0]
0001b0  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_ ; Anki::Embedded::Quadrilateral<float>::Quadrilateral(const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&)
0001b4  b041              ADD      sp,sp,#0x104
0001b6  ecbd8b04          VPOP     {d8-d9}
0001ba  bdf0              POP      {r4-r7,pc}
;;;270    
;;;271          template<typename OutType> Quadrilateral<OutType> ComputeRotatedCorners(const f32 radians) const;
;;;272    
;;;273          bool IsConvex() const;
;;;274    
;;;275          bool operator== (const Quadrilateral<Type> &quad2) const;
;;;276    
;;;277          Quadrilateral<Type> operator+ (const Quadrilateral<Type> &quad2) const;
;;;278    
;;;279          Quadrilateral<Type> operator- (const Quadrilateral<Type> &quad2) const;
;;;280    
;;;281          inline Quadrilateral<Type>& operator= (const Quadrilateral<Type> &quad2);
;;;282    
;;;283          // Keeping this explicit to avoid accidental setting of quads of
;;;284          // different types
;;;285          template<typename InType> void SetCast(const Quadrilateral<InType> &quad2);
;;;286    
;;;287          inline const Point<Type>& operator[] (const s32 index) const;
;;;288          inline Point<Type>& operator[] (const s32 index);
;;;289        }; // class Quadrilateral<Type>
;;;290      } // namespace Embedded
;;;291    } // namespace Anki
;;;292    
;;;293    #endif // _ANKICORETECHEMBEDDED_COMMON_POINT_DECLARATIONS_H_
;;;20     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;21     #include "anki/common/robot/sequences_declarations.h"
;;;1      /**
;;;2      File: sequences_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      A Sequence is a mathematically-defined, ordered list. The sequence classes allow for operations on sequences, without requiring them to be explicitly evaluated.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/flags_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> class Array;
;;;23         template<typename Type> class FixedLengthList;
;;;24         template<typename Type> class ArraySlice;
;;;25         class MemoryStack;
;;;26     
;;;27         // #pragma mark --- Class Declarations ---
;;;28         template<typename Type> class Sequence
;;;29         {
;;;30         }; // class Sequence
;;;31     
;;;32         // A LinearSequence is like the result of a call to Matlab's linspace() It has a start, end, and
;;;33         // increment. It does not explicitly compute the values in the sequence, so does not require
;;;34         // much memory.
;;;35         //
;;;36         // WARNING:
;;;37         // The "end" of a LinearSequence is computed automatically, and is less-than-or-equal-to the
;;;38         // requested end.
;;;39         template<typename Type> class LinearSequence : public Sequence<Type>
;;;40         {
;;;41         public:
;;;42     
;;;43           LinearSequence();
;;;44     
;;;45           // Matlab equivalent: start:end
;;;46           LinearSequence(const Type start, const Type end);
;;;47     
;;;48           // Matlab equivalent: start:increment:end
;;;49           LinearSequence(const Type start, const Type increment, const Type end);
;;;50     
;;;51           // No Matlab equivalent
;;;52           // NOTE: end is unused. It is just present to prevent confusion with the other polymorphic constructors
;;;53           LinearSequence(const Type start, const Type increment, const Type end, const s32 size);
;;;54     
;;;55           // Explicitly evaluate each element of the sequence, and put the results in an Array.
;;;56           Array<Type> Evaluate(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;57           Result Evaluate(ArraySlice<Type> out) const;
;;;58     
;;;59           Type get_start() const;
;;;60     
;;;61           // NOTE: The increment is meaningless for LinearSequences of size 0 or 1.
;;;62           Type get_increment() const;
;;;63     
;;;64           // Note: End it not computed, as it is tempting to use it as a loop condition, but it is not safe
;;;65           // Type get_end() const;
;;;66     
;;;67           // Matlab equivalent: length(start:increment:end)
;;;68           s32 get_size() const;
;;;69     
;;;70         protected:
;;;71           // For speed, FixedLengthList is allowed to access protected members, instead of having to
;;;72           // construct a new LinearSequence every time an element is popped or pushed
;;;73           template<typename FixedLengthListType> friend class FixedLengthList;
;;;74     
;;;75           s32 size;
;;;76     
;;;77           Type start;
;;;78           Type increment;
;;;79     
;;;80           static s32 computeSize(const Type start, const Type increment, const Type end);
;;;81         }; // class LinearSequence
;;;82     
;;;83         // IndexSequence creates the input for slicing an Array
;;;84         // If start or end is less than 0, it is equivalent to (end+value)
;;;85         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type end, s32 arraySize);
;;;86         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type increment, Type end, s32 arraySize);
;;;87         LinearSequence<s32> IndexSequence(s32 arraySize); // Internally, it sets start==0, end=arraySize-1, like the Matlab colon operator array(:,:)
;;;88     
;;;89         // Linspace only works correctly for f32 and f64. To prevent misusage, trying ints will give a linker error.
;;;90         template<typename Type> LinearSequence<Type> Linspace(const Type start, const Type end, const s32 size);
;;;91     
;;;92         // These do not link, as they are unsafe
;;;93         template<> LinearSequence<u8> Linspace(const u8 start, const u8 end, const s32 size);
;;;94         template<> LinearSequence<s8> Linspace(const s8 start, const s8 end, const s32 size);
;;;95         template<> LinearSequence<u16> Linspace(const u16 start, const u16 end, const s32 size);
;;;96         template<> LinearSequence<s16> Linspace(const s16 start, const s16 end, const s32 size);
;;;97         template<> LinearSequence<u32> Linspace(const u32 start, const u32 end, const s32 size);
;;;98         template<> LinearSequence<s32> Linspace(const s32 start, const s32 end, const s32 size);
;;;99         template<> LinearSequence<u64> Linspace(const u64 start, const u64 end, const s32 size);
;;;100        template<> LinearSequence<s64> Linspace(const s64 start, const s64 end, const s32 size);
;;;101    
;;;102        // TODO: Logspace
;;;103        //template<typename Type> class Logspace : public Sequence<Type>
;;;104        //{
;;;105        //public:
;;;106        //protected:
;;;107        //};
;;;108    
;;;109        // A Meshgrid is like the result of a call to Matlab's meshgrid(). It is made of two
;;;110        // LinearSequence objects, so does not require much memory.
;;;111        template<typename Type> class Meshgrid
;;;112        {
;;;113        public:
;;;114          Meshgrid();
;;;115    
;;;116          // Matlab equivalent: meshgrid(xGridVector, yGridVector)
;;;117          Meshgrid(const LinearSequence<Type> xGridVector, const LinearSequence<Type> yGridVector);
;;;118    
;;;119          // Allocate an Array, and evaluate this Meshgrid object
;;;120          //
;;;121          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;122          // The first suffix X or Y is for the xGrid vs yGrid
;;;123          // The second suffix 1 or 2 is for 1D vs 2D output
;;;124          Array<Type> EvaluateX1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;125          Array<Type> EvaluateX2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;126          Array<Type> EvaluateY1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;127          Array<Type> EvaluateY2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;128    
;;;129          // Evaluate this Meshgrid object into a pre-allocated Array
;;;130          //
;;;131          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;132          Result EvaluateX1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;133          Result EvaluateX2(ArraySlice<Type> out) const;
;;;134          Result EvaluateY1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;135          Result EvaluateY2(ArraySlice<Type> out) const;
;;;136    
;;;137          s32 get_numElements() const;
;;;138    
;;;139          inline const LinearSequence<Type>& get_xGridVector() const;
;;;140    
;;;141          inline const LinearSequence<Type>& get_yGridVector() const;
;;;142    
;;;143        protected:
;;;144          LinearSequence<Type> xGridVector;
;;;145          LinearSequence<Type> yGridVector;
;;;146        };
;;;147      } // namespace Embedded
;;;148    } //namespace Anki
;;;149    
;;;150    #endif // #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;22     
;;;23     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;24     namespace cv
;;;25     {
;;;26       class Mat;
;;;27       template<typename Type> class Mat_;
;;;28     }
;;;29     #endif
;;;30     
;;;31     namespace Anki
;;;32     {
;;;33       namespace Embedded
;;;34       {
;;;35         template<typename Type> class ArraySlice;
;;;36         template<typename Type> class ConstArraySlice;
;;;37         template<typename Type> class ConstArraySliceExpression;
;;;38     
;;;39         const s32 ARRAY_FILE_HEADER_LENGTH = 32;
;;;40         const s32 ARRAY_FILE_HEADER_VALID_LENGTH = 14; //< How many characters are not spaces
;;;41         const char ARRAY_FILE_HEADER[ARRAY_FILE_HEADER_LENGTH+1] = "\x89" "AnkiEArray1.2                  ";
;;;42     
;;;43         // #pragma mark --- Array Class Declaration ---
;;;44     
;;;45         template<typename Type> class Array
;;;46         {
;;;47         public:
;;;48     
;;;49           // The stride is the "numCols*sizeof(Type)" rounded up by 16, plus any boundary padding
;;;50           static s32 ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags);
;;;51     
;;;52           // The minimum required memory is the size of a stride, times the number of rows
;;;53           static s32 ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags);
;;;54     
;;;55           // Initializes Array as invalid
;;;56           Array();
;;;57     
;;;58           // Constructor for a Array, pointing to user-allocated MemoryStack. This is the preferred
;;;59           // method for creating a new Array.
;;;60           //
;;;61           // Flags::Buffer.isFullyAllocated doesn't do anything
;;;62           Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;63     
;;;64           // Constructor for a Array, pointing to user-allocated data. This type of array is more
;;;65           // restrictive than most matrix libraries. For example, it may make it hard to convert from
;;;66           // OpenCV::Mat to Array, though the reverse is trivial.
;;;67           //
;;;68           // If following are true, then the contents of data will not be modified, and it will work as
;;;69           // a normal buffer without extra zeros as stride padding:
;;;70           // 1. (numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0
;;;71           // 2. reinterpret_cast<size_t>(data) % MEMORY_ALIGNMENT == 0
;;;72           // 3. numRows*numCols*sizeof(Type) <= dataLength
;;;73           //
;;;74           // If Flags::Buffer.isFullyAllocated == true, then the input data buffer's stride must be a
;;;75           // simple multiple
;;;76           Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags=Flags::Buffer(false,false,true));
;;;77     
;;;78           // Load an image from file. Requires OpenCV;
;;;79           static Array<Type> LoadImage(const char * filename, MemoryStack &memory);
;;;80     
;;;81           // Load or save an array saved as a debugStream.
;;;82           // compressionLevel can be from 0 (uncompressed) to 9 (most compressed). If OpenCV is not used, it must be zero.
;;;83           static Array<Type> LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory);
;;;84           static Array<Type> LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength); //< allocatedBuffer must be allocated and freed manually
;;;85           Result SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const;
;;;86     
;;;87           // Pointer to the data, at a given (y,x) location
;;;88           //
;;;89           // NOTE:
;;;90           // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;91           // inner loop, like: "Type * restrict pArray = Array.Pointer(5);", then index
;;;92           // pArray in the inner loop.
;;;93           inline const Type* Pointer(const s32 index0, const s32 index1) const;
;;;94           inline Type* Pointer(const s32 index0, const s32 index1);
;;;95     
;;;96           // Use this operator for normal C-style 2d matrix indexing. For example, "array[5][0] = 6;"
;;;97           // will set the element in the fifth row and first column to 6. This is the same as
;;;98           // "array.Pointer(5)[0] = 6;"
;;;99           //
;;;100          // NOTE:
;;;101          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;102          // inner loop, like: "Type * restrict pArray = Array[5];", then index
;;;103          // pArray in the inner loop.
;;;104          inline const Type * operator[](const s32 index0) const;
;;;105          inline Type * operator[](const s32 index0);
;;;106    
;;;107          // Pointer to the data, at a given (y,x) location
;;;108          //
;;;109          // NOTE:
;;;110          // The default order of coordinates for the Point() constructor is (x,y). So for example,
;;;111          // access Array[5][3] via Array.Pointer(Point<s16>(3,5))
;;;112          //
;;;113          // NOTE:
;;;114          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;115          // inner loop, like: "Type * restrict pArray = Array.Pointer(Point<s16>(5,0));", then index
;;;116          // pArray in the inner loop.
;;;117          inline const Type* Pointer(const Point<s16> &point) const;
;;;118          inline Type* Pointer(const Point<s16> &point);
;;;119    
;;;120          // Get the ith element, like Matlab's 1D indexing of a 2D array.
;;;121          // For example, the 5th element of Arrays of size (1,6) and (6,1) is the same;
;;;122          const Type& Element(const s32 elementIndex) const;
;;;123          Type& Element(const s32 elementIndex);
;;;124    
;;;125          // Return a slice accessor for this array, like the Matlab expression "array(1:5, 2:3:5)"
;;;126          //
;;;127          // NOTE:
;;;128          // If min or max is less than 0, it is equivalent to (end+value). For example, "Array(0,-1,3,5)"
;;;129          // is the same as "Array(0,arrayHeight-1,3,5)"
;;;130          ArraySlice<Type> operator() ();
;;;131          ArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;132          ArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX);
;;;133          ArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX);
;;;134          ConstArraySlice<Type> operator() () const;
;;;135          ConstArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const;
;;;136          ConstArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const;
;;;137          ConstArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const;
;;;138    
;;;139          // ArraySlice Transpose doesn't modify the data, it just sets an "isTransposed" flag.
;;;140          // Anything that uses ArraySliceExpression respects this flag. This doesn't include things
;;;141          // like Matrix::Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out) for example.
;;;142          ConstArraySliceExpression<Type> Transpose() const;
;;;143    
;;;144    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;145          // Copies the OpenCV Mat. If needed, it converts from color to grayscale by averaging the color channels.
;;;146          s32 Set(const cv::Mat_<Type> &in);
;;;147    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;148    
;;;149          // Use the simple OpenCV gui to display this array as an image
;;;150          // Does nothing is OpenCV is not available
;;;151          void Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues=false, const bool fitImageToWindow=false) const;
;;;152    
;;;153          // Print out the contents of this Array
;;;154          //
;;;155          // NOTE:
;;;156          // * If the min X or Y is less than zero, it will be treated as zero
;;;157          // * If the max X or Y is greater than the size of the array minus one, it will be treated as
;;;158          //   the size of the array minus one
;;;159          Result Print(const char * const variableName = "Array", const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;160          Result PrintAlternate(const char * const variableName = "Array", const s32 version=2, const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;161    
;;;162          // Checks if this array is equal to another array, up to some allowable
;;;163          // per-element varation, epsilon. If the arrays are not the same size,
;;;164          // false is returned.
;;;165          bool IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const;
;;;166    
;;;167          // Checks the basic parameters of this Array, and if it is allocated.
;;;168          bool IsValid() const;
;;;169    
;;;170          // Resize will use MemoryStack::Reallocate() to change the Array's size. It only works if this
;;;171          // Array was the last thing allocated. The reallocated memory will not be cleared
;;;172          //
;;;173          // WARNING:
;;;174          // This will not update any references to the memory, you must update all references manually.
;;;175          Result Resize(const s32 numRows, const s32 numCols, MemoryStack &memory);
;;;176    
;;;177          // Set every element in the Array to zero, including the stride padding.
;;;178          // Returns the number of bytes set to zero
;;;179          s32 SetZero();
;;;180    
;;;181          // Set every element in the Array to this value
;;;182          // Returns the number of values set
;;;183          s32 Set(const Type value);
;;;184    
;;;185          // Elementwise copies the input Array into this array. No memory is allocated.
;;;186          s32 Set(const Array<Type> &in);
;;;187    
;;;188          // Copy values to this Array.
;;;189          // If the input array does not contain enough elements, the remainder of this Array will be filled with zeros.
;;;190          // Returns the number of values set (not counting extra zeros)
;;;191          s32 Set(const Type * const values, const s32 numValues);
;;;192    
;;;193          // Read in the input, then cast it to this object's type
;;;194          //
;;;195          // WARNING:
;;;196          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;197          template<typename InType> s32 SetCast(const Array<InType> &in);
;;;198          template<typename InType> s32 SetCast(const InType * const values, const s32 numValues);
;;;199    
;;;200          // This is a shallow copy. There's no reference counting. Updating the data of one array will
;;;201          // update that of others (because they point to the same location in memory).
;;;202          // However, Resizing or other operations on one array won't update the others.
;;;203          Array& operator= (const Array & rightHandSide);
;;;204    
;;;205          // Similar to Matlabs size(matrix, dimension), and dimension is in {0,1}
;;;206          s32 get_size(s32 dimension) const;
;;;207    
;;;208          // Get the stride, which is the number of bytes between an element at (n,m) and an element at (n+1,m)
;;;209          s32 get_stride() const;
;;;210    
;;;211          // just size[0] * size[1]
;;;212          s32 get_numElements() const;
;;;213    
;;;214          // Return the flags that were used when this object was constructed.
;;;215          Flags::Buffer get_flags() const;
;;;216    
;;;217          // Equivalent to Pointer(0,0)
;;;218          //
;;;219          // These are for very low-level access to the buffers. Probably you want to be using one of
;;;220          // the Pointer() accessor methods instead of these.
;;;221          void* get_buffer();
;;;222          const void* get_buffer() const;
;;;223    
;;;224        protected:
;;;225          static const s32 HEADER_LENGTH = 8;
;;;226          static const s32 FOOTER_LENGTH = 8;
;;;227    
;;;228          s32 size[2];
;;;229          s32 stride;
;;;230          Flags::Buffer flags;
;;;231    
;;;232          Type * data;
;;;233    
;;;234          // Basic allocation method
;;;235          void* AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate);
;;;236    
;;;237          // Performs checks and sets appropriate parameters for this object
;;;238          Result InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags);
;;;239    
;;;240          // Set all the buffers and sizes to zero, to signal an invalid array
;;;241          void InvalidateArray();
;;;242    
;;;243          // If this object's Type is a basic type, this method prints out this object.
;;;244          Result PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;245    
;;;246          // If this object's Type is a string, this method prints out this object.
;;;247          Result PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;248        }; // class Array
;;;249    
;;;250        // #pragma mark --- FixedPointArray Class Declaration ---
;;;251    
;;;252        template<typename Type> class FixedPointArray : public Array<Type>
;;;253        {
;;;254        public:
;;;255          FixedPointArray();
;;;256    
;;;257          // Same as Array() constructor
;;;258          // This is the preferred method for constructing an FixedPointArray
;;;259          FixedPointArray(const s32 numRows, const s32 numCols, const s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;260    
;;;261          // Same as Array() constructor
;;;262          // This is the advanced method for constructing an FixedPointArray
;;;263          FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;264    
;;;265          s32 get_numFractionalBits() const;
;;;266    
;;;267        protected:
;;;268          s32 numFractionalBits;
;;;269        };
;;;270    
;;;271        // If you don't know the type of the Array you're loading, use this function directly, then cast it based on the read parameters
;;;272        Array<u8> LoadBinaryArray_UnknownType(
;;;273          const char * filename,
;;;274          MemoryStack *scratch,
;;;275          MemoryStack *memory,
;;;276          void * allocatedBuffer,
;;;277          const s32 allocatedBufferLength,
;;;278          u16  &basicType_sizeOfType,
;;;279          bool &basicType_isBasicType,
;;;280          bool &basicType_isInteger,
;;;281          bool &basicType_isSigned,
;;;282          bool &basicType_isFloat,
;;;283          bool &basicType_isString
;;;284          );
;;;285    
;;;286    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;287        // Returns a cv::Mat that mirrors the data in the input Array.
;;;288        // WARNING: If you copy the cv::Mat or assign it incorrectly, it will no longer mirror the input Array
;;;289        // WARNING: This const_casts the input array, so you can unsafely modify it via the output cv::Mat
;;;290        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out);
;;;291    #endif
;;;292      } // namespace Embedded
;;;293    } //namespace Anki
;;;294    
;;;295    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_DECLARATIONS_H_
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;1      /**
;;;2      File: utilities.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of utilities_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;14     
;;;15     #include "anki/common/robot/utilities_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;17     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;2      * File: trig_fast.h
;;;3      *
;;;4      * Author: Kevin Yoon
;;;5      * Created: 22-OCT-2012
;;;6      *
;;;7      * Some trig functions to supplement incomplete math libraries on embedded targets.
;;;8      * Error of all functions is less than +/- 0.01.
;;;9      * For bettery accuracy, lookup tables should be regenerated with u16.
;;;10     *
;;;11     **/
;;;12     #ifndef _TRIG_FAST_H
;;;13     #define _TRIG_FAST_H
;;;14     
;;;15     // When USE_SMALL_LUT defined, a smaller lookup table is used to conserve space.
;;;16     // USE_INTERPOLATION is also automatically defined, since without it answers are probably too wrong to be useful.
;;;17     // If USE_SMALL_LUT is not defined, a large LUT is used.
;;;18     //#define USE_SMALL_LUT
;;;19     
;;;20     // When defined, interpolates between lookup values for higher accuracy.
;;;21     #define USE_INTERPOLATION
;;;22     
;;;23     // Arctangent function based on lookup table
;;;24     // returns answer in radians
;;;25     float atan_fast(float x);
;;;26     
;;;27     // Arcsine function based on lookup table
;;;28     // returns answer in radians
;;;29     float asin_fast(float x);
;;;30     
;;;31     // Arctangent function which uses atan_fast
;;;32     // returns answer in radians
;;;33     float atan2_fast(float y, float x);
;;;34     
;;;35     // Arctangent function which uses asin from math.h
;;;36     // Useful on embedded systems that don't include atan2 in math.h
;;;37     // More accurate than atan2_fast.
;;;38     // Nothing particularly fast about this implementation.
;;;39     // returns answer in radians
;;;40     float atan2_acc(float y, float x);
;;;41     
;;;42     #endif
;;;19     
;;;20     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;21     #include "opencv2/core/core.hpp"
;;;22     #endif
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         //template<typename Type> inline Type RoundUp(const Type number, const Type multiple)
;;;29     
;;;30         // void* and size_t is a special case, good for aligning pointers
;;;31         inline const void* RoundUp(const void* number, const size_t multiple)
;;;32         {
;;;33           const size_t numberT = reinterpret_cast<size_t>(number);
;;;34           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;35         }
;;;36     
;;;37         inline void* RoundUp(void* number, const size_t multiple)
;;;38         {
;;;39           const size_t numberT = reinterpret_cast<size_t>(number);
;;;40           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;41         }
;;;42     
;;;43         template<> inline u32 RoundUp(const u32 number, const u32 multiple)
;;;44         {
;;;45           return (number + (multiple-1)) & ~(multiple-1);
;;;46         }
;;;47     
;;;48         template<> inline s32 RoundUp(const s32 number, const s32 multiple)
;;;49         {
;;;50           if(number <= 0) {
;;;51             return multiple*( number/multiple );
;;;52           } else {
;;;53             return multiple*( (number-1)/multiple + 1 );
;;;54           }
;;;55         }
;;;56     
;;;57     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;58         template<> inline unsigned long RoundUp(const unsigned long number, const unsigned long multiple)
;;;59         {
;;;60           return (number + (multiple-1)) & ~(multiple-1);
;;;61         }
;;;62     #endif
;;;63     
;;;64         template<> inline u32 RoundDown(const u32 number, const u32 multiple)
;;;65         {
;;;66           return multiple * (number/multiple);
;;;67         }
;;;68     
;;;69         template<> inline s32 RoundDown(const s32 number, const s32 multiple)
;;;70         {
;;;71           if(number < 0) {
;;;72             return multiple * ((number-multiple+1) / multiple);
;;;73           } else {
;;;74             return multiple * (number/multiple);
;;;75           }
;;;76         }
;;;77     
;;;78     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;79         template<> inline unsigned long RoundDown(const unsigned long number, const unsigned long multiple)
;;;80         {
;;;81           return multiple * (number/multiple);
;;;82         }
;;;83     #endif
;;;84     
;;;85         template<typename Type> Type ApproximateExp(const Type exponent, const s32 numTerms)
;;;86         {
;;;87           AnkiAssert(numTerms > 2);
;;;88     
;;;89           const Type exponentAbs = ABS(exponent);
;;;90     
;;;91           Type sum = static_cast<Type>(1) + exponentAbs;
;;;92     
;;;93           Type numerator = static_cast<Type>(exponentAbs);
;;;94           Type denominator = static_cast<Type>(1);
;;;95           for(s32 i=2; i<=numTerms; i++) {
;;;96             numerator *= exponentAbs;
;;;97             denominator *= i;
;;;98     
;;;99             sum += numerator / denominator;
;;;100          }
;;;101    
;;;102          if(exponent < 0) {
;;;103            sum = static_cast<Type>(1) / sum;
;;;104          }
;;;105    
;;;106          return sum;
;;;107        }
;;;108    
;;;109        template<typename Type> void Swap(Type &a, Type &b)
;;;110        {
;;;111          const Type tmp = a;
;;;112          a = b;
;;;113          b = tmp;
;;;114        } // template<typename Type> Swap(Type a, Type b)
;;;115    
;;;116        template<typename Type> u32 BinaryStringToUnsignedNumber(const FixedLengthList<Type> &bits, bool firstBitIsLow)
;;;117        {
;;;118          u32 number = 0;
;;;119    
;;;120          const s32 numBits = bits.get_size();
;;;121    
;;;122          for(s32 bit=0; bit<numBits; bit++) {
;;;123            if(firstBitIsLow) {
;;;124              if(bit == 0) {
;;;125                number += bits[bit];
;;;126              } else {
;;;127                number += bits[bit] << bit;
;;;128              }
;;;129            } else {
;;;130              if(bit == (numBits-1)) {
;;;131                number += bits[bit];
;;;132              } else {
;;;133                number += bits[bit] << (numBits - bit - 1);
;;;134              }
;;;135            }
;;;136          }
;;;137    
;;;138          return number;
;;;139        }
;;;140    
;;;141        template<typename Type> Type Determinant2x2(const Type a, const Type b, const Type c, const Type d)
;;;142        {
;;;143          return a*d - b*c;
;;;144        }
;;;145    
;;;146        template<typename Type> Type Determinant3x3(const Type a, const Type b, const Type c, const Type d, const Type e, const Type f, const Type g, const Type h, const Type i)
;;;147        {
;;;148          return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
;;;149        }
;;;150    
;;;151        template<typename Type> void Invert3x3(Type &a, Type &b, Type &c, Type &d, Type &e, Type &f, Type &g, Type &h, Type &i)
;;;152        {
;;;153          const Type determinant = Determinant3x3(a,b,c,d,e,f,g,h,i);
;;;154          const Type determinantInverse = static_cast<Type>(1) / determinant;
;;;155    
;;;156          const Type A =  (e*i - f*h);
;;;157          const Type B = -(d*i - f*g);
;;;158          const Type C =  (d*h - e*g);
;;;159          const Type D = -(b*i - c*h);
;;;160          const Type E =  (a*i - c*g);
;;;161          const Type F = -(a*h - b*g);
;;;162          const Type G =  (b*f - c*e);
;;;163          const Type H = -(a*f - c*d);
;;;164          const Type I =  (a*e - b*d);
;;;165    
;;;166          a = A * determinantInverse;
;;;167          b = D * determinantInverse;
;;;168          c = G * determinantInverse;
;;;169          d = B * determinantInverse;
;;;170          e = E * determinantInverse;
;;;171          f = H * determinantInverse;
;;;172          g = C * determinantInverse;
;;;173          h = F * determinantInverse;
;;;174          i = I * determinantInverse;
;;;175        }
;;;176    
;;;177        template<typename Type> void Cart2Pol(const Type x, const Type y, Type &rho, Type &theta)
;;;178        {
;;;179          if (x==0 && y==0) {
;;;180            theta = 0;
;;;181            rho = 0;
;;;182          } else {
;;;183            theta = atan2f(y, x);
;;;184            rho = sqrtf(x*x + y*y);
;;;185          }
;;;186        }
;;;187    
;;;188        template<typename Type> void Pol2Cart(const Type rho, const Type theta, Type &x, Type &y)
;;;189        {
;;;190          x = rho * cosf(theta);
;;;191          y = rho * sinf(theta);
;;;192        }
;;;193    
;;;194        inline s32 FloorS32(f32 x)
;;;195        {
;;;196          return static_cast<s32>(floorf(x));
;;;197        }
;;;198    
;;;199        inline s32 CeilS32(f32 x)
;;;200        {
;;;201          return static_cast<s32>(ceilf(x));
;;;202        }
;;;203    
;;;204    #if !defined(__EDG__)
;;;205        // Some platforms may not round to zero correctly, so do the function calls
;;;206        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(floorf(v + 0.5f)) : 0; }
;;;207        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(floorf(v + 0.5f)) : 0; }
;;;208        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(floorf(v + 0.5f)) : static_cast<s32>(ceilf(v - 0.5f)); }
;;;209        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(floorf(v + 0.5f)) : static_cast<s64>(ceilf(v - 0.5f)); }
;;;210        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;211        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;212    
;;;213        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(floor(v + 0.5)) : 0; }
;;;214        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(floor(v + 0.5)) : 0; }
;;;215        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(floor(v + 0.5)) : static_cast<s32>(ceil(v - 0.5)); }
;;;216        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(floor(v + 0.5)) : static_cast<s64>(ceil(v - 0.5)); }
;;;217        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;218        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;219    #else
;;;220        // The M4 rounds to zero correctly, without the function calls
;;;221        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(v + 0.5f) : 0; }
;;;222        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(v + 0.5f) : 0; }
;;;223        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(v + 0.5f) : static_cast<s32>(v - 0.5f); }
;;;224        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(v + 0.5f) : static_cast<s64>(v - 0.5f); }
;;;225        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;226        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;227    
;;;228        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(v + 0.5) : 0; }
;;;229        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(v + 0.5) : 0; }
;;;230        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(v + 0.5) : static_cast<s32>(v - 0.5); }
;;;231        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(v + 0.5) : static_cast<s64>(v - 0.5); }
;;;232        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;233        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;234    #endif
;;;235    
;;;236        // Most cases of RoundIfInteger are from int-to-int or float-to-float, so just do a normal cast
;;;237        template<typename Type> inline Type RoundIfInteger(const u8  v) { return static_cast<Type>(v); }
;;;238        template<typename Type> inline Type RoundIfInteger(const s8  v) { return static_cast<Type>(v); }
;;;239        template<typename Type> inline Type RoundIfInteger(const u16 v) { return static_cast<Type>(v); }
;;;240        template<typename Type> inline Type RoundIfInteger(const s16 v) { return static_cast<Type>(v); }
;;;241        template<typename Type> inline Type RoundIfInteger(const u32 v) { return static_cast<Type>(v); }
;;;242        template<typename Type> inline Type RoundIfInteger(const s32 v) { return static_cast<Type>(v); }
;;;243        template<typename Type> inline Type RoundIfInteger(const u64 v) { return static_cast<Type>(v); }
;;;244        template<typename Type> inline Type RoundIfInteger(const s64 v) { return static_cast<Type>(v); }
;;;245        template<typename Type> inline Type RoundIfInteger(const f32 v) { return static_cast<Type>(v); }
;;;246        template<typename Type> inline Type RoundIfInteger(const f64 v) { return static_cast<Type>(v); }
;;;247    
;;;248        // Specialize for cases with float-to-int
;;;249        template<> inline u8  RoundIfInteger(const f32 v) { return static_cast<u8> (Round<s32>(v)); }
;;;250        template<> inline s8  RoundIfInteger(const f32 v) { return static_cast<s8> (Round<s32>(v)); }
;;;251        template<> inline u16 RoundIfInteger(const f32 v) { return static_cast<u16>(Round<s32>(v)); }
;;;252        template<> inline s16 RoundIfInteger(const f32 v) { return static_cast<s16>(Round<s32>(v)); }
;;;253        template<> inline u32 RoundIfInteger(const f32 v) { return static_cast<u32>(Round<u32>(v)); }
;;;254        template<> inline s32 RoundIfInteger(const f32 v) { return static_cast<s32>(Round<s32>(v)); }
;;;255        template<> inline u64 RoundIfInteger(const f32 v) { return static_cast<u64>(Round<u64>(v)); }
;;;256        template<> inline s64 RoundIfInteger(const f32 v) { return static_cast<s64>(Round<s64>(v)); }
;;;257    
;;;258        template<> inline u8  RoundIfInteger(const f64 v) { return static_cast<u8> (Round<s32>(v)); }
;;;259        template<> inline s8  RoundIfInteger(const f64 v) { return static_cast<s8> (Round<s32>(v)); }
;;;260        template<> inline u16 RoundIfInteger(const f64 v) { return static_cast<u16>(Round<s32>(v)); }
;;;261        template<> inline s16 RoundIfInteger(const f64 v) { return static_cast<s16>(Round<s32>(v)); }
;;;262        template<> inline u32 RoundIfInteger(const f64 v) { return static_cast<u32>(Round<u32>(v)); }
;;;263        template<> inline s32 RoundIfInteger(const f64 v) { return static_cast<s32>(Round<s32>(v)); }
;;;264        template<> inline u64 RoundIfInteger(const f64 v) { return static_cast<u64>(Round<u64>(v)); }
;;;265        template<> inline s64 RoundIfInteger(const f64 v) { return static_cast<s64>(Round<s64>(v)); }
;;;266    
;;;267        // Floats and complex data types aren't specialized
;;;268        template<typename Type> inline Type saturate_cast(const u8  v) { return static_cast<Type>(v); }
;;;269        template<typename Type> inline Type saturate_cast(const s8  v) { return static_cast<Type>(v); }
;;;270        template<typename Type> inline Type saturate_cast(const u16 v) { return static_cast<Type>(v); }
;;;271        template<typename Type> inline Type saturate_cast(const s16 v) { return static_cast<Type>(v); }
;;;272        template<typename Type> inline Type saturate_cast(const u32 v) { return static_cast<Type>(v); }
;;;273        template<typename Type> inline Type saturate_cast(const s32 v) { return static_cast<Type>(v); }
;;;274        template<typename Type> inline Type saturate_cast(const u64 v) { return static_cast<Type>(v); }
;;;275        template<typename Type> inline Type saturate_cast(const s64 v) { return static_cast<Type>(v); }
;;;276        template<typename Type> inline Type saturate_cast(const f32 v) { return static_cast<Type>(v); }
;;;277        template<typename Type> inline Type saturate_cast(const f64 v) { return static_cast<Type>(v); }
;;;278    
;;;279        // Most saturate_cast calls are explicitly specialized
;;;280        template<> inline u8  saturate_cast<u8> (const u8  v) { return v; }
;;;281        template<> inline u8  saturate_cast<u8> (const u16 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;282        template<> inline u8  saturate_cast<u8> (const u32 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;283        template<> inline u8  saturate_cast<u8> (const u64 v) { return (u8)             MIN((u64)u8_MAX, (u64)v); }
;;;284        template<> inline u8  saturate_cast<u8> (const s8  v) { return (u8)                              MAX((s32)0, (s32)v);  }
;;;285        template<> inline u8  saturate_cast<u8> (const s16 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;286        template<> inline u8  saturate_cast<u8> (const s32 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;287        template<> inline u8  saturate_cast<u8> (const s64 v) { return (u8)             MIN((s64)u8_MAX, MAX((s64)0, (s64)v)); }
;;;288        template<> inline u8  saturate_cast<u8> (const f32 v) { return (u8) Round<s32>( MIN((f32)u8_MAX, MAX((f32)0, (f32)v)) ); }
;;;289        template<> inline u8  saturate_cast<u8> (const f64 v) { return (u8) Round<s32>( MIN((f64)u8_MAX, MAX((f64)0, (f64)v)) ); }
;;;290    
;;;291        template<> inline s8  saturate_cast<s8> (const u8  v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;292        template<> inline s8  saturate_cast<s8> (const u16 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;293        template<> inline s8  saturate_cast<s8> (const u32 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;294        template<> inline s8  saturate_cast<s8> (const u64 v) { return (s8)             MIN((u64)s8_MAX, (u64)v); }
;;;295        template<> inline s8  saturate_cast<s8> (const s8  v) { return v; }
;;;296        template<> inline s8  saturate_cast<s8> (const s16 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;297        template<> inline s8  saturate_cast<s8> (const s32 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;298        template<> inline s8  saturate_cast<s8> (const s64 v) { return (s8)             MIN((s64)s8_MAX, MAX((s64)s8_MIN, (s64)v)); }
;;;299        template<> inline s8  saturate_cast<s8> (const f32 v) { return (s8) Round<s32>( MIN((f32)s8_MAX, MAX((f32)s8_MIN, (f32)v)) ); }
;;;300        template<> inline s8  saturate_cast<s8> (const f64 v) { return (s8) Round<s32>( MIN((f64)s8_MAX, MAX((f64)s8_MIN, (f64)v)) ); }
;;;301    
;;;302        template<> inline u16 saturate_cast<u16>(const u8  v) { return v; }
;;;303        template<> inline u16 saturate_cast<u16>(const u16 v) { return v; }
;;;304        template<> inline u16 saturate_cast<u16>(const u32 v) { return (u16)             MIN((u32)u16_MAX, (u32)v); }
;;;305        template<> inline u16 saturate_cast<u16>(const u64 v) { return (u16)             MIN((u64)u16_MAX, (u64)v); }
;;;306        template<> inline u16 saturate_cast<u16>(const s8  v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;307        template<> inline u16 saturate_cast<u16>(const s16 v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;308        template<> inline u16 saturate_cast<u16>(const s32 v) { return (u16)             MIN((s32)u16_MAX, MAX((s32)0, (s32)v)); }
;;;309        template<> inline u16 saturate_cast<u16>(const s64 v) { return (u16)             MIN((s64)u16_MAX, MAX((s64)0, (s64)v)); }
;;;310        template<> inline u16 saturate_cast<u16>(const f32 v) { return (u16) Round<s32>( MIN((f32)u16_MAX, MAX((f32)0, (f32)v)) ); }
;;;311        template<> inline u16 saturate_cast<u16>(const f64 v) { return (u16) Round<s32>( MIN((f64)u16_MAX, MAX((f64)0, (f64)v)) ); }
;;;312    
;;;313        template<> inline s16 saturate_cast<s16>(const u8  v) { return v; }
;;;314        template<> inline s16 saturate_cast<s16>(const u16 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;315        template<> inline s16 saturate_cast<s16>(const u32 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;316        template<> inline s16 saturate_cast<s16>(const u64 v) { return (s16)             MIN((u64)s16_MAX, (u64)v); }
;;;317        template<> inline s16 saturate_cast<s16>(const s8  v) { return v; }
;;;318        template<> inline s16 saturate_cast<s16>(const s16 v) { return v; }
;;;319        template<> inline s16 saturate_cast<s16>(const s32 v) { return (s16)             MIN((s32)s16_MAX, MAX((s32)s16_MIN, (s32)v)); }
;;;320        template<> inline s16 saturate_cast<s16>(const s64 v) { return (s16)             MIN((s64)s16_MAX, MAX((s64)s16_MIN, (s64)v)); }
;;;321        template<> inline s16 saturate_cast<s16>(const f32 v) { return (s16) Round<s32>( MIN((f32)s16_MAX, MAX((f32)s16_MIN, (f32)v)) ); }
;;;322        template<> inline s16 saturate_cast<s16>(const f64 v) { return (s16) Round<s32>( MIN((f64)s16_MAX, MAX((f64)s16_MIN, (f64)v)) ); }
;;;323    
;;;324        template<> inline u32 saturate_cast<u32>(const u8  v) { return v; }
;;;325        template<> inline u32 saturate_cast<u32>(const u16 v) { return v; }
;;;326        template<> inline u32 saturate_cast<u32>(const u32 v) { return v; }
;;;327        template<> inline u32 saturate_cast<u32>(const u64 v) { return (u32)             MIN((u64)u32_MAX, (u64)v); }
;;;328        template<> inline u32 saturate_cast<u32>(const s8  v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;329        template<> inline u32 saturate_cast<u32>(const s16 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;330        template<> inline u32 saturate_cast<u32>(const s32 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;331        template<> inline u32 saturate_cast<u32>(const s64 v) { return (u32)             MIN((s64)u32_MAX, MAX((s64)0, (s64)v)); }
;;;332        template<> inline u32 saturate_cast<u32>(const f32 v) { return (u32) (v > (f32)0xFFFFFF7F) ? 0xFFFFFFFF : Round<u32>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;333        template<> inline u32 saturate_cast<u32>(const f64 v) { return (u32) Round<u32>( MIN((f64)u32_MAX, MAX((f64)0, (f64)v)) ); }
;;;334    
;;;335        template<> inline s32 saturate_cast<s32>(const u8  v) { return v; }
;;;336        template<> inline s32 saturate_cast<s32>(const u16 v) { return v; }
;;;337        template<> inline s32 saturate_cast<s32>(const u32 v) { return (s32)             MIN((u32)s32_MAX, (u32)v); }
;;;338        template<> inline s32 saturate_cast<s32>(const u64 v) { return (s32)             MIN((u64)s32_MAX, (u64)v); }
;;;339        template<> inline s32 saturate_cast<s32>(const s8  v) { return v; }
;;;340        template<> inline s32 saturate_cast<s32>(const s16 v) { return v; }
;;;341        template<> inline s32 saturate_cast<s32>(const s32 v) { return v; }
;;;342        template<> inline s32 saturate_cast<s32>(const s64 v) { return (s32)             MIN((s64)s32_MAX, MAX((s64)s32_MIN, (s64)v)); }
;;;343        template<> inline s32 saturate_cast<s32>(const f32 v) { return (s32) (v > (f32)0x7FFFFFBF) ? 0x7FFFFFFF : Round<s32>(MAX((f32)s32_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;344        template<> inline s32 saturate_cast<s32>(const f64 v) { return (s32) Round<s32>( MIN((f64)s32_MAX, MAX((f64)s32_MIN, (f64)v)) ); }
;;;345    
;;;346        template<> inline u64 saturate_cast<u64>(const u8  v) { return v; }
;;;347        template<> inline u64 saturate_cast<u64>(const u16 v) { return v; }
;;;348        template<> inline u64 saturate_cast<u64>(const u32 v) { return v; }
;;;349        template<> inline u64 saturate_cast<u64>(const u64 v) { return v; }
;;;350        template<> inline u64 saturate_cast<u64>(const s8  v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;351        template<> inline u64 saturate_cast<u64>(const s16 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;352        template<> inline u64 saturate_cast<u64>(const s32 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;353        template<> inline u64 saturate_cast<u64>(const s64 v) { return (u64)                               MAX((s64)0, (s64)v);  }
;;;354        template<> inline u64 saturate_cast<u64>(const f32 v) { return (u64) (v > (f32)0XFFFFFF7FFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;355        template<> inline u64 saturate_cast<u64>(const f64 v) { return (u64) (v > (f64)0xFFFFFFFFFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f64)0, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;356    
;;;357        template<> inline s64 saturate_cast<s64>(const u8  v) { return v; }
;;;358        template<> inline s64 saturate_cast<s64>(const u16 v) { return v; }
;;;359        template<> inline s64 saturate_cast<s64>(const u32 v) { return v; }
;;;360        template<> inline s64 saturate_cast<s64>(const u64 v) { return (s64)             MIN((u64)s64_MAX, (u64)v); }
;;;361        template<> inline s64 saturate_cast<s64>(const s8  v) { return v; }
;;;362        template<> inline s64 saturate_cast<s64>(const s16 v) { return v; }
;;;363        template<> inline s64 saturate_cast<s64>(const s32 v) { return v; }
;;;364        template<> inline s64 saturate_cast<s64>(const s64 v) { return v; }
;;;365        template<> inline s64 saturate_cast<s64>(const f32 v) { return (s64) (v > (f32)0x7FFFFFBFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f32)s64_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;366        template<> inline s64 saturate_cast<s64>(const f64 v) { return (s64) (v > (f64)0x7FFFFFFFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f64)s64_MIN, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;367    
;;;368        template<> inline f32 saturate_cast(const f64 v) { return (f32) MIN((f64)FLT_MAX, MAX(-(f64)FLT_MAX, (f64)v)); }
;;;369      } // namespace Embedded
;;;370    } // namespace Anki
;;;371    
;;;372    #endif // _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;18     #include "anki/common/robot/memory.h"
;;;1      /**
;;;19     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;20     #include "anki/common/robot/geometry.h"
;;;1      /**
;;;2      File: geometry.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of geometry_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/geometry_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/memory.h"
;;;1      /**
;;;18     #include "anki/common/robot/matrix.h"
;;;1      /**
;;;2      File: matrix.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of matrix_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;14     
;;;15     #include "anki/common/robot/matrix_declarations.h"
;;;1      /**
;;;2      File: matrix_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various Matrix operations, such as matrix multiply and addition.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;2      File: arraySlices_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      An array slice is a sub-array of an Array object.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Class Declarations ---
;;;23     
;;;24         template<typename Type> class ConstArraySlice;
;;;25         template<typename Type> class ArraySlice;
;;;26         template<typename Type> class ConstArraySliceExpression;
;;;27     
;;;28         // An ArraySlice is a simple indexing wrapper on top of an Array. The slice of an Array could be
;;;29         // a sub-rectangle of an array and/or skip every n-th element.
;;;30         //
;;;31         // For example, Array(0,3,-1,1,2,4) is the same as Matlab's array(1:3:end, 2:2:5).
;;;32         // (The Array indexing starts from zero vs Matlab's one, hence the different numbers).
;;;33         //
;;;34         // TODO: support non-int indexes
;;;35         // TODO: is there a better way of doing this than a completely different class, different only
;;;36         //       by const?
;;;37         template<typename Type> class ConstArraySlice
;;;38         {
;;;39         public:
;;;40           ConstArraySlice();
;;;41     
;;;42           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;43           ConstArraySlice(const Array<Type> &array);
;;;44     
;;;45           // It's probably easier to call array.operator() than this constructor directly
;;;46           ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;47     
;;;48           // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;49           ConstArraySliceExpression<Type> Transpose() const;
;;;50     
;;;51           bool IsValid() const;
;;;52     
;;;53           const LinearSequence<s32>& get_ySlice() const;
;;;54     
;;;55           const LinearSequence<s32>& get_xSlice() const;
;;;56     
;;;57           // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;58           // don't support the full ArraySlice type, and should be used with caution.
;;;59           const Array<Type>& get_array() const;
;;;60     
;;;61         protected:
;;;62           LinearSequence<s32> ySlice;
;;;63           LinearSequence<s32> xSlice;
;;;64     
;;;65           Array<Type> array;
;;;66     
;;;67           // For speed, this is a direct pointer to the Array's protected data
;;;68           const Type * constArrayData;
;;;69         }; // template<typename Type> class ArraySlice
;;;70     
;;;71         // A non-const version of ConstArraySlice, see ConstArraySlice for details
;;;72         //
;;;73         // WARNING: A "const ArraySlice" doesn't have a const Array. Only ConstArraySlice has a const
;;;74         //          Array. This allows for implicit conversion to non-const function parameters.
;;;75         template<typename Type> class ArraySlice : public ConstArraySlice<Type>
;;;76         {
;;;77         public:
;;;78           ArraySlice();
;;;79     
;;;80           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;81           // The Array parameter is not a reference, to allow for implicit conversion
;;;82           ArraySlice(Array<Type> array);
;;;83     
;;;84           // It's probably easier to call array.operator() than this constructor directly
;;;85           // The Array parameter is not a reference, to allow for implicit conversion
;;;86           ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;87     
;;;88           // If automaticTranspose==true, then you can set a MxN slice with a NxM input.
;;;89           // Matlab allows this for vectors, though this method will also work for
;;;90           // arbitrary-sized arrays.
;;;91           s32 Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
;;;92     
;;;93           // Explicitly evaluate the input LinearSequence into this ArraySlice
;;;94           s32 Set(const LinearSequence<Type> &input);
;;;95     
;;;96           // Set all values of this slice to the given value.
;;;97           //
;;;98           // For example, "array(0,-1,1,4).Set(5);" is the same as
;;;99           // Matlab's "array(1:end, 2:5) = 5;"
;;;100          s32 Set(const Type value);
;;;101    
;;;102          // Copy values to this ArraySlice.
;;;103          // numValues must be equal to the number of values in this slice
;;;104          // Returns the number of values set
;;;105          s32 Set(const Type * const values, const s32 numValues);
;;;106    
;;;107          // Read in the input, then cast it to this object's type
;;;108          //
;;;109          // WARNING:
;;;110          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;111          template<typename InType> s32 SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
;;;112          //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;113    
;;;114          // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;115          // don't support the full ArraySlice type, and should be used with caution.
;;;116          Array<Type>& get_array();
;;;117    
;;;118        protected:
;;;119    
;;;120          // For speed, this is a direct pointer to the Array's protected data
;;;121          Type * arrayData;
;;;122        }; // template<typename Type> class ArraySlice
;;;123    
;;;124        // An ConstArraySliceExpression is like a ConstArraySlice, but can also be transposed
;;;125        // It may have other abilities in the future, but will probably always be const
;;;126        template<typename Type> class ConstArraySliceExpression : public ConstArraySlice<Type>
;;;127        {
;;;128        public:
;;;129          ConstArraySliceExpression();
;;;130    
;;;131          ConstArraySliceExpression(const Array<Type> input, bool isTransposed=false);
;;;132    
;;;133          ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed=false);
;;;134    
;;;135          ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed=false);
;;;136    
;;;137          // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;138          // This object isn't modified, but the returned object is.
;;;139          ConstArraySliceExpression<Type> Transpose() const;
;;;140    
;;;141          bool get_isTransposed() const;
;;;142    
;;;143        protected:
;;;144          bool isTransposed;
;;;145        };
;;;146    
;;;147        // To simplify the creation of kernels using an ArraySlice, and to aid the compiler optimizer,
;;;148        // an ArraySliceLimits can be initialized at the beginning of the function, then used as the
;;;149        // limits for the inner loops.
;;;150    
;;;151        // The suffix of in# and out# refer to the number of input and output matrices.
;;;152        // If output == 0, then the output is a scalar.
;;;153    
;;;154        template<typename Type> class ArraySliceSimpleLimits
;;;155        {
;;;156        public:
;;;157          Type xStart;
;;;158          Type xIncrement;
;;;159          s32  xSize;
;;;160    
;;;161          Type yStart;
;;;162          Type yIncrement;
;;;163          s32  ySize;
;;;164    
;;;165          ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;166        };
;;;167    
;;;168        // In1 and out0 is a special, ultra-simple case, for one matrix input and a scalar output
;;;169        template<typename Type> class ArraySliceLimits_in1_out0
;;;170        {
;;;171        public:
;;;172          // Was this ArraySliceLimits initialized?
;;;173          bool isValid;
;;;174    
;;;175          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;176    
;;;177          ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;178        };
;;;179    
;;;180        // One input, one output
;;;181        template<typename Type> class ArraySliceLimits_in1_out1
;;;182        {
;;;183        public:
;;;184          // Was this ArraySliceLimits initialized?
;;;185          bool isValid;
;;;186    
;;;187          // Can a simple (non-transposed) iteration be performed?
;;;188          bool isSimpleIteration;
;;;189    
;;;190          // These are the current values for the coordinates in the input and output images
;;;191          s32 out1Y;
;;;192          s32 out1X;
;;;193          s32 in1Y;
;;;194          s32 in1X;
;;;195    
;;;196          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;197          s32 ySize;
;;;198          s32 xSize;
;;;199    
;;;200          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;201          // incremented every iteration of the inner loop
;;;202          s32 out1_xInnerIncrement;
;;;203          s32 in1_xInnerIncrement;
;;;204          s32 in1_yInnerIncrement;
;;;205    
;;;206          ArraySliceLimits_in1_out1(
;;;207            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;208            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;209    
;;;210          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;211          inline void OuterIncrementTop();
;;;212    
;;;213          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;214          inline void OuterIncrementBottom();
;;;215    
;;;216        protected:
;;;217          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;218    
;;;219          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;220          bool in1_isTransposed;
;;;221        };
;;;222    
;;;223        // Two inputs, one output
;;;224        template<typename Type> class ArraySliceLimits_in2_out1
;;;225        {
;;;226        public:
;;;227          // Was this ArraySliceLimits initialized?
;;;228          bool isValid;
;;;229    
;;;230          // Can a simple (non-transposed) iteration be performed?
;;;231          bool isSimpleIteration;
;;;232    
;;;233          // These are the current values for the coordinates in the input and output images
;;;234          s32 out1Y;
;;;235          s32 out1X;
;;;236          s32 in1Y;
;;;237          s32 in1X;
;;;238          s32 in2Y;
;;;239          s32 in2X;
;;;240    
;;;241          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;242          s32 ySize;
;;;243          s32 xSize;
;;;244    
;;;245          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;246          // incremented every iteration of the inner loop
;;;247          s32 out1_xInnerIncrement;
;;;248          s32 in1_xInnerIncrement;
;;;249          s32 in1_yInnerIncrement;
;;;250          s32 in2_xInnerIncrement;
;;;251          s32 in2_yInnerIncrement;
;;;252    
;;;253          ArraySliceLimits_in2_out1(
;;;254            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;255            const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed,
;;;256            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;257    
;;;258          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;259          inline void OuterIncrementTop();
;;;260    
;;;261          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;262          inline void OuterIncrementBottom();
;;;263    
;;;264        protected:
;;;265          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;266    
;;;267          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;268          bool in1_isTransposed;
;;;269    
;;;270          ArraySliceSimpleLimits<Type> rawIn2Limits;
;;;271          bool in2_isTransposed;
;;;272        };
;;;273      } // namespace Embedded
;;;274    } // namespace Anki
;;;275    
;;;276    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         namespace Matrix
;;;24         {
;;;25           // #pragma mark --- Declarations ---
;;;26     
;;;27           //
;;;28           // Simple matrix statistics
;;;29           //
;;;30     
;;;31           // Return the minimum element in this Array
;;;32           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat);
;;;33     
;;;34           // Return the maximum element in this Array
;;;35           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat);
;;;36     
;;;37           // Return the sum of every element in the Array
;;;38           template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat);
;;;39     
;;;40           // Return the mean of every element in the Array
;;;41           template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat);
;;;42     
;;;43           // Simultaneously compute the mean and variance of every element in the Array
;;;44           template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(const ConstArraySliceExpression<Array_Type> &mat,
;;;45             Accumulator_Type& mean, Accumulator_Type& var);
;;;46     
;;;47           //
;;;48           // Elementwise matrix operations
;;;49           //
;;;50     
;;;51           // Elementwise add two arrays. in1, in2, and out can be the same array
;;;52           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;53           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;54           template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;55     
;;;56           // Elementwise subtract two arrays. in1, in2, and out can be the same array
;;;57           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;58           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;59           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;60     
;;;61           // Elementwise multiply two arrays. in1, in2, and out can be the same array
;;;62           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;63           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;64           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;65     
;;;66           // Elementwise divide two arrays. in1, in2, and out can be the same array
;;;67           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;68           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;69           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;70     
;;;71           // Elementwise exponential on an array
;;;72           template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;73     
;;;74           // Elementwise square root on an array
;;;75           template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;76     
;;;77           //
;;;78           // Standard matrix operations
;;;79           //
;;;80     
;;;81           // Perform the matrix multiplication "out = in1 * in2"
;;;82           // Note that this is the naive O(n^3) Definition
;;;83           template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out);
;;;84     
;;;85           // Perform the matrix multiplication "out = in1 * in2'"
;;;86           // Note that this is the naive O(n^3) Definition
;;;87           // MultiplyTranspose has better access patterns than Multiply for certain types of arrays, so could be a lot faster (and easier to accelerate)
;;;88           template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out);
;;;89     
;;;90           //
;;;91           // Rotation Matrices
;;;92           //
;;;93     
;;;94           // TODO: Add other rotation-related math, like Rodrigues' formula, or Pose chaining...
;;;95     
;;;96           // Compute the three Euler angles from a given 3x3 Rotation Matrix.
;;;97           Result GetEulerAngles(const Array<f32>& R, f32& angle_x, f32& angle_y, f32& angle_z);
;;;98     
;;;99           //
;;;100          // Linear Algebra and Linear Solvers
;;;101          //
;;;102    
;;;103          // Compute the Cholesky-Banachiewicz decomposition, to return a lower-triangular matrix L such that A=L*L'
;;;104          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;105            Array<Type> &A_L,      //!< Input A Matrix and Output lower-triangular L matrix
;;;106            Array<Type> &Bt_Xt,    //!< Input B-transpose matrix and Output X-transpose solution
;;;107            bool realCholesky,     //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;108            bool &numericalFailure //!< If true, the solver failed because of numerical instability
;;;109            );
;;;110    
;;;111          // Compute the homography such that "transformedPoints = homography * originalPoints"
;;;112          //
;;;113          // WARNING: This uses the inhomogeneous solution and the Cholesky decomposition, therefore it
;;;114          //          will be incorrect if H_33 is zero, which happens in certain cases of lines at
;;;115          //          inifinty. For more details, see Multiple View Geometry 2nd Edition, Example 4.1
;;;116          template<typename Type> Result EstimateHomography(
;;;117            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;118            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;119            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;120            bool &numericalFailure, //!< Did the homography solver fail?
;;;121            MemoryStack scratch //!< Scratch memory
;;;122            );
;;;123    
;;;124          //template<typename InType, typename IntermediateType, typename OutType> Result CholeskyDecomposition(
;;;125          //  const Array<InType> &A,                    //!< Input A Matrix
;;;126          //  Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;127          //  Array<OutType> &L                          //!< Output lower-triangular L matrix
;;;128          //  );
;;;129    
;;;130          //template<typename InType, typename IntermediateType, typename OutType> Result SolveWithLowerTriangular(
;;;131          //  const Array<InType> &L,                          //!< Input lower-triangular L matrix (such as computed by CholeskyDecomposition)
;;;132          //  const Array<InType> &b,                          //!< Input b matrix
;;;133          //  const Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;134          //  Array<OutType> &x                                //!< Output x solution
;;;135          //  );
;;;136    
;;;137          // Solves Ax = b
;;;138          // Specifically, it uses SVD to minimize ||Ax - b||
;;;139          // Note that the A, b, and x matrices are transposed (this is because for large numbers of samples, transposed inputs are liable to be faster)
;;;140          //Result SolveLeastSquaresWithSVD_f32(Array<f32> &At, const Array<f32> &bt, Array<f32> &xt, MemoryStack scratch);
;;;141          //Result SolveLeastSquaresWithSVD_f64(Array<f64> &At, const Array<f64> &bt, Array<f64> &xt, MemoryStack scratch);
;;;142    
;;;143          //
;;;144          // Matrix structure operations
;;;145          //
;;;146    
;;;147          // matlab equivalent: out = reshape(in, [M,N]);
;;;148          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;149          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory);
;;;150    
;;;151          // matlab equivalent: out = in(:);
;;;152          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;153          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory);
;;;154    
;;;155          // Perform an immediate matrix transpose (unlike the lazy transpose of ArraySlice)
;;;156          // in and out must be different Array objects
;;;157          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out);
;;;158    
;;;159          // Rotate an array clockwise by 90, 180, or 270 degrees.
;;;160          // NOTE: Only works for a square matrix.
;;;161          // NOTE: In and out must be different arrays (unlike the interview question)
;;;162          template<typename InType, typename OutType> Result Rotate90( const Array<InType> &in, Array<OutType> &out);
;;;163          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out);
;;;164          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out);
;;;165    
;;;166          //
;;;167          // Misc matrix operations
;;;168          //
;;;169    
;;;170          // Works the same as the Matlab sort() for matrices.
;;;171          // InsertionSort(X) sorts each column of X in ascending order.
;;;172          // The minIndex and maxIndex are for the sortWhichDimension. maxIndex is automatically clipped to the size of the input Array.
;;;173          // NOTE: this currently uses insertion sort, so may be slow for large, badly-unsorted arrays
;;;174          template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;175    
;;;176          // Subsections less-than-or-equal-to insertionSortSize are sorted with insertion sort
;;;177          template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;178    
;;;179          // indexes must be allocated, but will be overwritten by InsertionSort()
;;;180          template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;181    
;;;182          template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;183    
;;;184          // For a square array, either:
;;;185          // 1. When lowerToUpper==true,  copies the lower (left)  triangle to the upper (right) triangle
;;;186          // 2. When lowerToUpper==false, copies the upper (right) triangle to the lower (left)  triangle
;;;187          // Functionally the same as OpenCV completeSymm()
;;;188          template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper = false);
;;;189    
;;;190          // There's probably no need to use these directly. Instead, use the normal Matrix:: operations, like Matrix::Add
;;;191          namespace Elementwise
;;;192          {
;;;193            template<typename InType, typename IntermediateType, typename OutType> class Add {
;;;194            public:
;;;195              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) + static_cast<IntermediateType>(value2));}
;;;196            };
;;;197    
;;;198            template<typename InType, typename IntermediateType, typename OutType> class Subtract {
;;;199            public:
;;;200              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) - static_cast<IntermediateType>(value2));}
;;;201            };
;;;202    
;;;203            template<typename InType, typename IntermediateType, typename OutType> class DotMultiply {
;;;204            public:
;;;205              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) * static_cast<IntermediateType>(value2));}
;;;206            };
;;;207    
;;;208            template<typename InType, typename IntermediateType, typename OutType> class DotDivide {
;;;209            public:
;;;210              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) / static_cast<IntermediateType>(value2));}
;;;211            };
;;;212    
;;;213            // Technically a unary operator, but we ignore the second parameter
;;;214            // TODO: if this is slow, make a unary version of ApplyOperation
;;;215            template<typename InType, typename IntermediateType, typename OutType> class Exp {
;;;216            public:
;;;217              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(expf(static_cast<IntermediateType>(value1)));}
;;;218            };
;;;219    
;;;220            template<typename InType, typename IntermediateType, typename OutType> class Sqrt {
;;;221            public:
;;;222              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(sqrtf(static_cast<IntermediateType>(value1)));}
;;;223            };
;;;224    
;;;225            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;226            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;227            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;228          } // namespace Elementwise
;;;229        } // namespace Matrix
;;;230      } // namespace Embedded
;;;231    } // namespace Anki
;;;232    
;;;233    #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;18     #include "anki/common/robot/memory.h"
;;;19     #include "anki/common/robot/errorHandling.h"
;;;20     #include "anki/common/robot/geometry.h"
;;;21     #include "anki/common/robot/utilities_c.h"
;;;22     #include "anki/common/robot/sequences.h"
;;;23     #include "anki/common/robot/matrix.h"
;;;24     #include "anki/common/robot/comparisons.h"
;;;25     
;;;26     #include "anki/common/shared/utilities_shared.h"
;;;27     
;;;28     #include "anki/common/robot/serialize_declarations.h"
;;;29     
;;;30     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;31     #include "opencv2/core/core.hpp"
;;;32     #include "opencv2/highgui/highgui.hpp"
;;;33     #include "opencv2/imgproc/imgproc.hpp"
;;;34     #include "opencv2/objdetect/objdetect.hpp"
;;;35     #endif
;;;36     
;;;37     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;38     #define ANKICORETECH_EMBEDDED_USE_MALLOC 1
;;;39     #define ANKICORETECH_EMBEDDED_USE_ZLIB 1
;;;40     #endif
;;;41     
;;;42     #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;43     #include "zlib.h"
;;;44     #endif
;;;45     
;;;46     namespace Anki
;;;47     {
;;;48       namespace Embedded
;;;49       {
;;;50         template<typename Type> class ArraySlice;
;;;51         template<typename Type> class ConstArraySlice;
;;;52         template<typename Type> class ConstArraySliceExpression;
;;;53     
;;;54         // #pragma mark --- Array Definitions ---
;;;55     
;;;56         template<typename Type> s32 Array<Type>::ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags)
;;;57         {
;;;58           AnkiConditionalErrorAndReturnValue(numCols >= 0,
;;;59             0, "Array<Type>::ComputeRequiredStride", "Invalid size");
;;;60     
;;;61           const s32 numColsCapped = MAX(numCols, 1);
;;;62     
;;;63           const s32 bufferRequired = static_cast<s32>(RoundUp<size_t>(sizeof(Type)*numColsCapped, MEMORY_ALIGNMENT));
;;;64     
;;;65           return bufferRequired;
;;;66         }
;;;67     
;;;68         template<typename Type> s32 Array<Type>::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags)
;;;69         {
;;;70           AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0,
;;;71             0, "Array<Type>::ComputeMinimumRequiredMemory", "Invalid size");
;;;72     
;;;73           const s32 numRowsCapped = MAX(numRows, 1);
;;;74     
;;;75           return numRowsCapped * Array<Type>::ComputeRequiredStride(numCols, flags);
;;;76         }
;;;77     
;;;78         template<typename Type> Array<Type>::Array()
;;;79         {
;;;80           InvalidateArray();
;;;81         }
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
;;;139        template<typename Type> Array<Type> Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;140        {
;;;141          Array<Type> newArray = Array<Type>();
;;;142    
;;;143    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;144          const cv::Mat cvImage = cv::imread(filename, CV_LOAD_IMAGE_GRAYSCALE);
;;;145    
;;;146          AnkiConditionalErrorAndReturnValue(cvImage.cols >= 0 && cvImage.rows >= 0,
;;;147            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;148    
;;;149          newArray = Array<Type>(cvImage.rows, cvImage.cols, memory);
;;;150    
;;;151          AnkiConditionalErrorAndReturnValue(newArray.IsValid(),
;;;152            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;153    
;;;154          const u8 * restrict pCvImage = cvImage.data;
;;;155    
;;;156          for(s32 y=0; y<cvImage.rows; y++) {
;;;157            Type * restrict pNewArray = newArray.Pointer(y, 0);
;;;158    
;;;159            for(s32 x=0; x<cvImage.cols; x++) {
;;;160              pNewArray[x] = static_cast<Type>(pCvImage[x]);
;;;161            }
;;;162    
;;;163            pCvImage += cvImage.step.buf[0];
;;;164          }
;;;165    #else
;;;166          AnkiError("Array<Type>::Array", "OpenCV is required to load an image from an image file");
;;;167    #endif
;;;168    
;;;169          return newArray;
;;;170        } // Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;171    
;;;172        template<typename Type> Array<Type> LoadBinaryArray_Generic(const char * filename, MemoryStack *scratch, MemoryStack *memory, void * allocatedBuffer, const s32 allocatedBufferLength)
;;;173        {
;;;174          u16  basicType_sizeOfType;
;;;175          bool basicType_isBasicType;
;;;176          bool basicType_isInteger;
;;;177          bool basicType_isSigned;
;;;178          bool basicType_isFloat;
;;;179          bool basicType_isString;
;;;180    
;;;181          Array<u8> rawArray = LoadBinaryArray_UnknownType(
;;;182            filename,
;;;183            scratch, memory,
;;;184            allocatedBuffer, allocatedBufferLength,
;;;185            basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString);
;;;186    
;;;187          // TODO: check that the types match
;;;188    
;;;189          Array<Type> newArray = *reinterpret_cast<Array<Type>*>( &rawArray );
;;;190    
;;;191          return newArray;
;;;192        } // / LoadBinaryArray_Generic()
;;;193    
;;;194        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;195        {
;;;196          return LoadBinaryArray_Generic<Type>(filename, &scratch, &memory, NULL, -1);
;;;197        } // Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;198    
;;;199        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength) //< allocatedBuffer must be freed manually
;;;200        {
;;;201          return LoadBinaryArray_Generic<Type>(filename, NULL, NULL, allocatedBuffer, allocatedBufferLength);
;;;202        } // LoadBinaryMalloc()
;;;203    
;;;204        template<typename Type> Result Array<Type>::SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const
;;;205        {
;;;206          AnkiConditionalErrorAndReturnValue(AreValid(*this, scratch) && filename,
;;;207            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::SaveBinary", "Invalid inputs");
;;;208    
;;;209          AnkiConditionalErrorAndReturnValue(compressionLevel >= 0 && compressionLevel <= 9,
;;;210            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::SaveBinary", "Invalid compression level");
;;;211    
;;;212          // If this is a string array, add the sizes of the null terminated strings (or zero otherwise)
;;;213          const s32 stringsLength = TotalArrayStringLengths<Type>(*this);
;;;214    
;;;215          const s32 serializedBufferLength = 4096 + ARRAY_FILE_HEADER_LENGTH + this->get_size(0) * this->get_stride() + stringsLength;
;;;216          void *buffer = scratch.Allocate(serializedBufferLength);
;;;217    
;;;218          AnkiConditionalErrorAndReturnValue(buffer,
;;;219            RESULT_FAIL_OUT_OF_MEMORY, "Array<Type>::SaveBinary", "Memory could not be allocated");
;;;220    
;;;221          SerializedBuffer toSave(buffer, serializedBufferLength);
;;;222    
;;;223          toSave.PushBack<Type>("Array", *this);
;;;224    
;;;225          s32 startIndex;
;;;226          u8 * bufferStart = reinterpret_cast<u8*>(toSave.get_memoryStack().get_validBufferStart(startIndex));
;;;227          const s32 validUsedBytes = toSave.get_memoryStack().get_usedBytes() - startIndex;
;;;228    
;;;229          // const s32 startDiff = static_cast<s32>( reinterpret_cast<size_t>(bufferStart) - reinterpret_cast<size_t>(toSave.get_memoryStack().get_buffer()) );
;;;230          // const s32 endDiff = toSave.get_memoryStack().get_totalBytes() - toSave.get_memoryStack().get_usedBytes();
;;;231    
;;;232          FILE *fp = fopen(filename, "wb");
;;;233    
;;;234          AnkiConditionalErrorAndReturnValue(fp,
;;;235            RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Could not open file %s", filename);
;;;236    
;;;237          if(compressionLevel > 0) {
;;;238    #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;239            char tmpTextHeader[ARRAY_FILE_HEADER_LENGTH+1];
;;;240            strncpy(tmpTextHeader, &ARRAY_FILE_HEADER[0], ARRAY_FILE_HEADER_LENGTH+1);
;;;241            snprintf(tmpTextHeader+ARRAY_FILE_HEADER_VALID_LENGTH+1, ARRAY_FILE_HEADER_LENGTH-ARRAY_FILE_HEADER_VALID_LENGTH, "z%s ", ZLIB_VERSION);
;;;242    
;;;243            const s32 originalLength = validUsedBytes + SERIALIZED_BUFFER_HEADER_LENGTH + SERIALIZED_BUFFER_FOOTER_LENGTH;
;;;244    
;;;245            uLongf compressedLength = 128 + saturate_cast<s32>(1.1 * originalLength);
;;;246    
;;;247            void * uncompressed = malloc(originalLength);
;;;248            void * compressed = malloc(compressedLength + 2*sizeof(s32));
;;;249    
;;;250            if(!uncompressed || !compressed) {
;;;251              if(uncompressed)
;;;252                free(uncompressed);
;;;253    
;;;254              if(compressed)
;;;255                free(compressed);
;;;256    
;;;257              AnkiError("Array<Type>::SaveBinary", "Out of memory");
;;;258    
;;;259              return RESULT_FAIL_OUT_OF_MEMORY;
;;;260            }
;;;261    
;;;262            // Copy the uncompressed data into one buffer
;;;263            {
;;;264              char * pUncompressed = reinterpret_cast<char*>(uncompressed);
;;;265    
;;;266              memcpy(pUncompressed, &SERIALIZED_BUFFER_HEADER[0], SERIALIZED_BUFFER_HEADER_LENGTH);
;;;267              pUncompressed += SERIALIZED_BUFFER_HEADER_LENGTH;
;;;268    
;;;269              memcpy(pUncompressed, bufferStart, validUsedBytes);
;;;270              pUncompressed += validUsedBytes;
;;;271    
;;;272              memcpy(pUncompressed, &SERIALIZED_BUFFER_FOOTER[0], SERIALIZED_BUFFER_FOOTER_LENGTH);
;;;273            }
;;;274    
;;;275            const s32 compressionResult = compress2(reinterpret_cast<Bytef*>(compressed) + 2*sizeof(s32), &compressedLength, reinterpret_cast<Bytef*>(uncompressed), originalLength, compressionLevel);
;;;276    
;;;277            if(compressionResult != Z_OK) {
;;;278              if(uncompressed)
;;;279                free(uncompressed);
;;;280    
;;;281              if(compressed)
;;;282                free(compressed);
;;;283    
;;;284              AnkiError("Array<Type>::SaveBinary", "Zlib error");
;;;285              return RESULT_FAIL_IO;
;;;286            }
;;;287    
;;;288            reinterpret_cast<s32*>(compressed)[0] = static_cast<s32>(originalLength);
;;;289            reinterpret_cast<s32*>(compressed)[1] = static_cast<s32>(compressedLength);
;;;290    
;;;291            const size_t bytesWrittenForTextHeader = fwrite(tmpTextHeader, 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;292    
;;;293            const size_t bytesWritten = fwrite(compressed, 1, compressedLength + 2*sizeof(s32), fp);
;;;294    
;;;295            if(uncompressed)
;;;296              free(uncompressed);
;;;297    
;;;298            if(compressed)
;;;299              free(compressed);
;;;300    
;;;301            AnkiConditionalErrorAndReturnValue(
;;;302              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;303              bytesWritten == (compressedLength + 2*sizeof(s32)),
;;;304              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;305    
;;;306    #else
;;;307            AnkiError("Array<Type>::SaveBinary", "Saving with compression requires zlib");
;;;308            return RESULT_FAIL;
;;;309    #endif
;;;310          } else {
;;;311            const size_t bytesWrittenForTextHeader = fwrite(&ARRAY_FILE_HEADER[0], 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;312    
;;;313            const size_t bytesWrittenForHeader = fwrite(&SERIALIZED_BUFFER_HEADER[0], 1, SERIALIZED_BUFFER_HEADER_LENGTH, fp);
;;;314    
;;;315            const size_t bytesWritten = fwrite(bufferStart, 1, validUsedBytes, fp);
;;;316    
;;;317            const size_t bytesWrittenForFooter = fwrite(&SERIALIZED_BUFFER_FOOTER[0], 1, SERIALIZED_BUFFER_FOOTER_LENGTH, fp);
;;;318    
;;;319            AnkiConditionalErrorAndReturnValue(
;;;320              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;321              bytesWrittenForHeader == SERIALIZED_BUFFER_HEADER_LENGTH &&
;;;322              bytesWritten == validUsedBytes &&
;;;323              bytesWrittenForFooter == SERIALIZED_BUFFER_FOOTER_LENGTH,
;;;324              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;325          }
;;;326    
;;;327          fclose(fp);
;;;328    
;;;329          return RESULT_OK;
;;;330        } // Array<Type>::SaveBinary(const char * filename, MemoryStack scratch)
;;;331    
;;;332        template<typename Type> const Type* Array<Type>::Pointer(const s32 index0, const s32 index1) const
;;;333        {
;;;334          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;335          AnkiAssert(this->IsValid());
;;;336    
;;;337          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride ) + index1;
;;;338        }
;;;339    
;;;340        template<typename Type> Type* Array<Type>::Pointer(const s32 index0, const s32 index1)
;;;341        {
;;;342          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;343          AnkiAssert(this->IsValid());
;;;344    
;;;345          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride ) + index1;
;;;346        }
;;;347    
;;;348        template<typename Type> inline const Type * Array<Type>::operator[](const s32 index0) const
;;;349        {
;;;350          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;351    
;;;352          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride );
;;;353        }
;;;354    
;;;355        template<typename Type> inline Type * Array<Type>::operator[](const s32 index0)
;;;356        {
;;;357          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;358    
;;;359          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride );
;;;360        }
;;;361    
;;;362        template<typename Type> const Type* Array<Type>::Pointer(const Point<s16> &point) const
;;;363        {
;;;364          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;365        }
;;;366    
;;;367        template<typename Type> Type* Array<Type>::Pointer(const Point<s16> &point)
;;;368        {
;;;369          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;370        }
;;;371    
;;;372        template<typename Type> const Type& Array<Type>::Element(const s32 elementIndex) const
;;;373        {
;;;374          const s32 index1 = elementIndex % size[1];
;;;375          const s32 index0 = (elementIndex - index1) / size[1];
;;;376    
;;;377          return *Pointer(index0, index1);
;;;378        }
;;;379    
;;;380        template<typename Type> Type& Array<Type>::Element(const s32 elementIndex)
;;;381        {
;;;382          const s32 index1 = elementIndex % size[1];
;;;383          const s32 index0 = (elementIndex - index1) / size[1];
;;;384    
;;;385          return *Pointer(index0, index1);
;;;386        }
;;;387    
;;;388        template<typename Type> ArraySlice<Type> Array<Type>::operator() ()
;;;389        {
;;;390          ArraySlice<Type> slice(*this);
;;;391    
;;;392          return slice;
;;;393        }
;;;394    
;;;395        template<typename Type> ArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;396        {
;;;397          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;398    
;;;399          return slice;
;;;400        }
;;;401    
;;;402        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX)
;;;403        {
;;;404          LinearSequence<s32> ySlice = IndexSequence<s32>(minY, 1, maxY, this->size[0]);
;;;405          LinearSequence<s32> xSlice = IndexSequence<s32>(minX, 1, maxX, this->size[1]);
;;;406    
;;;407          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;408    
;;;409          return slice;
;;;410        }
;;;411    
;;;412        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX)
;;;413        {
;;;414          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;415          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;416    
;;;417          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;418    
;;;419          return slice;
;;;420        }
;;;421    
;;;422        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() () const
;;;423        {
;;;424          ConstArraySlice<Type> slice(*this);
;;;425    
;;;426          return slice;
;;;427        }
;;;428    
;;;429        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const
;;;430        {
;;;431          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;432    
;;;433          return slice;
;;;434        }
;;;435    
;;;436        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const
;;;437        {
;;;438          LinearSequence<s32> ySlice = IndexSequence(minY, 1, maxY, this->size[0]);
;;;439          LinearSequence<s32> xSlice = IndexSequence(minX, 1, maxX, this->size[1]);
;;;440    
;;;441          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;442    
;;;443          return slice;
;;;444        }
;;;445    
;;;446        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const
;;;447        {
;;;448          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;449          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;450    
;;;451          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;452    
;;;453          return slice;
;;;454        }
;;;455    
;;;456        template<typename Type> ConstArraySliceExpression<Type> Array<Type>::Transpose() const
;;;457        {
;;;458          ConstArraySliceExpression<Type> expression(this->operator() ());
;;;459          expression.Transpose();
;;;460    
;;;461          return expression;
;;;462        }
;;;463    
;;;464    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;465        template<typename Type> s32 Array<Type>::Set(const cv::Mat_<Type> &in)
;;;466        {
;;;467          const s32 inHeight = in.rows;
;;;468          const s32 inWidth = in.cols;
;;;469    
;;;470          AnkiConditionalErrorAndReturnValue(inHeight != 0,
;;;471            0, "Array<Type>::Set", "input cv::Mat is invalid. If you use the release OpenCV libraries with the debug build, lots of things like file loading don't work.");
;;;472    
;;;473          const bool isColor = in.channels() == 3 || inWidth == this->size[1]*3;
;;;474    
;;;475          if(isColor) {
;;;476            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0],
;;;477              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;478          } else {
;;;479            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;480              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;481          }
;;;482    
;;;483          for(s32 y=0; y<this->size[0]; y++) {
;;;484            const Type * restrict pIn = reinterpret_cast<const Type*>(in.ptr(y,0));
;;;485            Type * restrict pThis = this->Pointer(y,0);
;;;486    
;;;487            // If grayscale, just copy. If color, convert to grayscale
;;;488            if(isColor) {
;;;489              for(s32 x=0; x<this->size[1]; x++) {
;;;490                pThis[x] = (pIn[3*x] + pIn[3*x + 1] + pIn[3*x + 2]) / 3;
;;;491              }
;;;492            } else {
;;;493              memcpy(pThis, pIn, inWidth*sizeof(Type));
;;;494            }
;;;495          }
;;;496    
;;;497          return this->size[0]*this->size[1];
;;;498        }
;;;499    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;500    
;;;501        template<typename Type> void Array<Type>::Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues, const bool fitImageToWindow) const
;;;502        {
;;;503    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;504          AnkiConditionalError(this->IsValid(), "Array<Type>::Show", "Array<Type> is not valid");
;;;505    
;;;506          if(fitImageToWindow) {
;;;507            cv::namedWindow(windowName, CV_WINDOW_NORMAL);
;;;508          } else {
;;;509            cv::namedWindow(windowName, CV_WINDOW_AUTOSIZE);
;;;510          }
;;;511    
;;;512          if(scaleValues) {
;;;513            cv::Mat_<f64> scaledArray;
;;;514    
;;;515            if(ArrayToCvMat(*this, &scaledArray) != RESULT_OK)
;;;516              return;
;;;517    
;;;518            const f64 minValue = Matrix::Min<Type>(*this);
;;;519            const f64 maxValue = Matrix::Max<Type>(*this);
;;;520            const f64 range = maxValue - minValue;
;;;521    
;;;522            scaledArray -= minValue;
;;;523            scaledArray /= range;
;;;524    
;;;525            cv::imshow(windowName, scaledArray);
;;;526          } else {
;;;527            cv::Mat_<Type> arrayCopy;
;;;528    
;;;529            if(ArrayToCvMat(*this, &arrayCopy) != RESULT_OK)
;;;530              return;
;;;531    
;;;532            cv::imshow(windowName, arrayCopy);
;;;533          }
;;;534    
;;;535          if(waitForKeypress) {
;;;536            cv::waitKey();
;;;537          }
;;;538    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;539        }
;;;540    
;;;541        template<typename Type> Result Array<Type>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;542        {
;;;543          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;544            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;545    
;;;546          CoreTechPrint(variableName);
;;;547          CoreTechPrint(":\n");
;;;548          for(s32 y=MAX(0,minY); y<MIN(maxY+1,size[0]); y++) {
;;;549            const Type * const pThisData = this->Pointer(y, 0);
;;;550            for(s32 x=MAX(0,minX); x<MIN(maxX+1,size[1]); x++) {
;;;551              pThisData[x].Print();
;;;552            }
;;;553            CoreTechPrint("\n");
;;;554          }
;;;555          CoreTechPrint("\n");
;;;556    
;;;557          return RESULT_OK;
;;;558        }
;;;559    
;;;560        template<typename Type> Result Array<Type>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;561        {
;;;562          return this->Print(variableName, minY, maxY, minX, maxX);
;;;563        }
;;;564    
;;;565        template<typename Type> bool Array<Type>::IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const
;;;566        {
;;;567          bool isSame = false;
;;;568          if(AreValid(*this, other)) {
;;;569            const s32 nrows = this->get_size(0);
;;;570            const s32 ncols = this->get_size(1);
;;;571    
;;;572            if(other.get_size(0)==nrows && other.get_size(1) == ncols) {
;;;573              isSame = true;
;;;574              for(s32 i=0; i<nrows && isSame; ++i) {
;;;575                const Type * restrict pThis  = this->Pointer(i,0);
;;;576                const Type * restrict pOther = other.Pointer(i,0);
;;;577    
;;;578                for(s32 j=0; j<ncols; ++j) {
;;;579                  if(!NEAR(pThis[j], pOther[j], epsilon)) {
;;;580                    isSame = false;
;;;581                    break;
;;;582                  }
;;;583                } // for j
;;;584              } // for i
;;;585            } // if sizes match
;;;586          } // if both valid
;;;587    
;;;588          return isSame;
;;;589        } // IsNearlyEqualTo()
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
;;;592        {
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
;;;602        }
;;;603    
;;;604        template<typename Type> Result Array<Type>::Resize(const s32 numRows, const s32 numCols, MemoryStack &memory)
;;;605        {
;;;606          AnkiConditionalErrorAndReturnValue(numCols > 0 && numRows > 0,
;;;607            RESULT_FAIL_INVALID_SIZE, "Array<Type>::Resize", "Invalid size");
;;;608    
;;;609          s32 numBytesAllocated = 0;
;;;610    
;;;611          this->data = reinterpret_cast<Type*>( AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, true) );
;;;612    
;;;613          // Don't clear the reallocated memory
;;;614          const bool clearMemory = this->flags.get_zeroAllocatedMemory();
;;;615          this->flags.set_zeroAllocatedMemory(false);
;;;616    
;;;617          const Result result = InitializeBuffer(numRows,
;;;618            numCols,
;;;619            this->data,
;;;620            numBytesAllocated,
;;;621            this->flags);
;;;622    
;;;623          this->flags.set_zeroAllocatedMemory(clearMemory);
;;;624    
;;;625          return result;
;;;626        }
;;;627    
;;;628        template<typename Type> s32 Array<Type>::SetZero()
;;;629        {
;;;630          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;631            0, "Array<Type>::SetZero", "Array<Type> is not valid");
;;;632    
;;;633          const s32 numBytes = this->get_size(0)*this->get_stride();
;;;634    
;;;635          memset(this->Pointer(0,0), 0, numBytes);
;;;636    
;;;637          return numBytes;
;;;638        }
;;;639    
;;;640        template<typename Type> s32 Array<Type>::Set(const Type value)
;;;641        {
;;;642          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;643            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;644    
;;;645          for(s32 y=0; y<size[0]; y++) {
;;;646            Type * restrict pThisData = Pointer(y, 0);
;;;647            for(s32 x=0; x<size[1]; x++) {
;;;648              pThisData[x] = value;
;;;649            }
;;;650          }
;;;651    
;;;652          return size[0]*size[1];
;;;653        }
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
;;;656        {
;;;657          return this->SetCast<Type>(in);
;;;658        }
;;;659    
;;;660        template<typename Type> template<typename InType> s32 Array<Type>::SetCast(const Array<InType> &in)
;;;661        {
;;;662          const s32 inHeight = in.get_size(0);
;;;663          const s32 inWidth = in.get_size(1);
;;;664    
;;;665          AnkiConditionalErrorAndReturnValue(AreValid(*this, in),
;;;666            0, "Array<Type>::Set", "Invalid objects");
;;;667    
;;;668          AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;669            0, "Array<Type>::Set", "Array sizes don't match");
;;;670    
;;;671          for(s32 y=0; y<size[0]; y++) {
;;;672            const InType * restrict pIn = in.Pointer(y, 0);
;;;673            Type * restrict pThisData = Pointer(y, 0);
;;;674    
;;;675            for(s32 x=0; x<size[1]; x++) {
;;;676              pThisData[x] = saturate_cast<Type>(pIn[x]);
;;;677            }
;;;678          }
;;;679    
;;;680          return size[0]*size[1];
;;;681        }
;;;682    
;;;683        template<typename InType> s32 SetCast(const InType * const values, const s32 numValues)
;;;684        {
;;;685          // This is a little tough to write a general case for, so this method should be specialized
;;;686          // for each relevant case
;;;687          AnkiAssert(false);
;;;688    
;;;689          return 0;
;;;690        }
;;;691    
;;;692        template<typename Type> s32 Array<Type>::Set(const Type * const values, const s32 numValues)
;;;693        {
;;;694          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;695            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;696    
;;;697          s32 numValuesSet = 0;
;;;698    
;;;699          for(s32 y=0; y<size[0]; y++) {
;;;700            u32 * restrict pThisData = reinterpret_cast<u32*>(Pointer(y, 0));
;;;701    
;;;702            const s32 numValuesThisRow = MAX(0, MIN(numValues - y*size[1], size[1]));
;;;703    
;;;704            if(numValuesThisRow > 0) {
;;;705              // For small data types, this may be too many bytes, but the stride padding should make
;;;706              // the writing okay (I think)
;;;707              const s32 numWordsToCopy = (sizeof(Type)*numValuesThisRow + 3) / 4;
;;;708    
;;;709              //memcpy(pThisData, values + y*size[1], numValuesThisRow*sizeof(Type));
;;;710              for(s32 x=0; x<numWordsToCopy; x++) {
;;;711                //AnkiAssert(reinterpret_cast<size_t>(values+y*size[1]) % 4 == 0);
;;;712                pThisData[x] = reinterpret_cast<const u32*>(values+y*size[1])[x];
;;;713              }
;;;714              numValuesSet += numValuesThisRow;
;;;715            }
;;;716    
;;;717            if(numValuesThisRow < size[1]) {
;;;718              memset(pThisData+numValuesThisRow*sizeof(Type), 0, (size[1]-numValuesThisRow)*sizeof(Type));
;;;719            }
;;;720          }
;;;721    
;;;722          return numValuesSet;
;;;723        }
;;;724    
;;;725        template<typename Type> Array<Type>& Array<Type>::operator= (const Array<Type> & rightHandSide)
;;;726        {
;;;727          this->size[0] = rightHandSide.size[0];
;;;728          this->size[1] = rightHandSide.size[1];
;;;729    
;;;730          this->stride = rightHandSide.stride;
;;;731          this->flags = rightHandSide.flags;
;;;732          this->data = rightHandSide.data;
;;;733    
;;;734          return *this;
;;;735        }
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
;;;738        {
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
;;;747    
;;;748        template<typename Type> s32 Array<Type>::get_stride() const
;;;749        {
;;;750          return stride;
;;;751        }
;;;752    
;;;753        template<typename Type> s32 Array<Type>::get_numElements() const
;;;754        {
;;;755          if(size[0] > 0 && size[1] > 0) {
;;;756            return size[0] * size[1];
;;;757          } else {
;;;758            return 0;
;;;759          }
;;;760        }
;;;761    
;;;762        template<typename Type> void* Array<Type>::get_buffer()
;;;763        {
;;;764          return data;
;;;765        }
;;;766    
;;;767        template<typename Type> const void* Array<Type>::get_buffer() const
;;;768        {
;;;769          return data;
;;;770        }
;;;771    
;;;772        template<typename Type> Flags::Buffer Array<Type>::get_flags() const
;;;773        {
;;;774          return flags;
;;;775        }
;;;776    
;;;777        template<typename Type> void* Array<Type>::AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate)
;;;778        {
;;;779          AnkiConditionalError(numRows >= 0 && stride > 0,
;;;780            "Array<Type>::AllocateBufferFromMemoryStack", "Invalid size");
;;;781    
;;;782          const s32 numRowsCapped = MAX(numRows, 1);
;;;783    
;;;784          this->stride = stride;
;;;785    
;;;786          const s32 numBytesRequested = numRowsCapped * this->stride;
;;;787    
;;;788          if(reAllocate) {
;;;789            return memory.Reallocate(this->data, numBytesRequested, numBytesAllocated);
;;;790          } else {
;;;791            return memory.Allocate(numBytesRequested, flags.get_zeroAllocatedMemory(), numBytesAllocated);
;;;792          }
;;;793        }
;;;794    
;;;795        template<typename Type> Result Array<Type>::InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags)
;;;796        {
;;;797          if(!rawData) {
;;;798            AnkiError("Anki.Array2d.initialize", "input data buffer is NULL");
;;;799            InvalidateArray();
;;;800            return RESULT_FAIL_UNINITIALIZED_MEMORY;
;;;801          }
;;;802    
;;;803          AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0 && dataLength >= MEMORY_ALIGNMENT,
;;;804            RESULT_FAIL_INVALID_SIZE, "Array<Type>::InitializeBuffer", "Negative dimension");
;;;805    
;;;806          AnkiConditionalErrorAndReturnValue(!flags.get_useBoundaryFillPatterns(),
;;;807            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::InitializeBuffer", "Fill patterns not supported for Array");
;;;808    
;;;809          this->flags = flags;
;;;810          this->size[0] = numRows;
;;;811          this->size[1] = numCols;
;;;812    
;;;813          // Initialize an empty array.
;;;814    
;;;815          this->data = reinterpret_cast<Type*>(rawData);
;;;816    
;;;817          const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData), MEMORY_ALIGNMENT) - reinterpret_cast<size_t>(rawData));
;;;818          const s32 requiredBytes = ComputeRequiredStride(numCols,flags)*numRows + extraAlignmentBytes;
;;;819    
;;;820          if(requiredBytes > dataLength) {
;;;821            AnkiError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
;;;822            InvalidateArray();
;;;823            return RESULT_FAIL_OUT_OF_MEMORY;
;;;824          }
;;;825    
;;;826          this->data = reinterpret_cast<Type*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
;;;827    
;;;828          //#if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;829          //      this->UpdateCvMatMirror(*this);
;;;830          //#endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;831    
;;;832          return RESULT_OK;
;;;833        } // Array<Type>::InitializeBuffer()
;;;834    
;;;835        // Set all the buffers and sizes to -1, to signal an invalid array
;;;836        template<typename Type> void Array<Type>::InvalidateArray()
;;;837        {
;;;838          this->size[0] = -1;
;;;839          this->size[1] = -1;
;;;840          this->stride = -1;
;;;841          this->data = NULL;
;;;842        } // void Array<Type>::InvalidateArray()
;;;843    
;;;844        template<typename Type> Result Array<Type>::PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX)  const
;;;845        {
;;;846          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;847            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;848    
;;;849          const s32 realMinX = MAX(0,minX);
;;;850          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;851          const s32 realMinY = MAX(0,minY);
;;;852          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;853    
;;;854          CoreTechPrint("%s type(int:%d,signed:%d,float:%d,sizeof:%d):\n", variableName, Flags::TypeCharacteristics<Type>::isInteger, Flags::TypeCharacteristics<Type>::isSigned, Flags::TypeCharacteristics<Type>::isFloat, sizeof(Type));
;;;855    
;;;856          for(s32 y=realMinY; y<realMaxY; y++) {
;;;857            const Type * const pThisData = this->Pointer(y, 0);
;;;858            for(s32 x=realMinX; x<realMaxX; x++) {
;;;859              if(Flags::TypeCharacteristics<Type>::isBasicType) {
;;;860                if(Flags::TypeCharacteristics<Type>::isInteger) {
;;;861                  CoreTechPrint("%d ", static_cast<s32>(pThisData[x]));
;;;862                } else {
;;;863                  if(version==1) {
;;;864                    CoreTechPrint("%f ", (float)pThisData[x]);
;;;865                  } else {
;;;866                    CoreTechPrint("%e ", (float)pThisData[x]);
;;;867                  }
;;;868                }
;;;869              } else {
;;;870                CoreTechPrint("! ");
;;;871              }
;;;872            }
;;;873            CoreTechPrint("\n");
;;;874          }
;;;875          CoreTechPrint("\n");
;;;876    
;;;877          return RESULT_OK;
;;;878        }
;;;879    
;;;880        template<typename Type> Result Array<Type>::PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;881        {
;;;882          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;883            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::PrintString", "Array<Type> is not valid");
;;;884    
;;;885          const s32 realMinX = MAX(0,minX);
;;;886          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;887          const s32 realMinY = MAX(0,minY);
;;;888          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;889    
;;;890          CoreTechPrint("%s:\n", variableName);
;;;891    
;;;892          for(s32 y=realMinY; y<realMaxY; y++) {
;;;893            const char * const * pThisData = this->Pointer(y, 0);
;;;894            for(s32 x=realMinX; x<realMaxX; x++) {
;;;895              const char * curString = pThisData[x];
;;;896              if(!curString) {
;;;897                CoreTechPrint("NULL, ");
;;;898              } else {
;;;899                CoreTechPrint("\"%s\", ", curString);
;;;900              }
;;;901            }
;;;902            CoreTechPrint("\n");
;;;903          }
;;;904          CoreTechPrint("\n");
;;;905    
;;;906          return RESULT_OK;
;;;907        }
;;;908    
;;;909        // #pragma mark --- FixedPointArray Definitions ---
;;;910    
;;;911        template<typename Type> FixedPointArray<Type>::FixedPointArray()
;;;912          : Array<Type>(), numFractionalBits(-1)
;;;913        {
;;;914        }
;;;915    
;;;916        template<typename Type> FixedPointArray<Type>::FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags)
;;;917          : Array<Type>(numRows, numCols, data, dataLength, flags), numFractionalBits(numFractionalBits)
;;;918        {
;;;919          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= (sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;920        }
;;;921    
;;;922        template<typename Type> FixedPointArray<Type>::FixedPointArray(s32 numRows, s32 numCols, s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags)
;;;923          : Array<Type>(numRows, numCols, memory, flags), numFractionalBits(numFractionalBits)
;;;924        {
;;;925          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= static_cast<s32>(sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;926        }
;;;927    
;;;928        template<typename Type> s32 FixedPointArray<Type>::get_numFractionalBits() const
;;;929        {
;;;930          return numFractionalBits;
;;;931        }
;;;932    
;;;933    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;934        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;935        {
;;;936          AnkiConditionalErrorAndReturnValue(in.IsValid() && out,
;;;937            RESULT_FAIL, "ArrayToCvMat", "This Array is invalid");
;;;938    
;;;939          out->refcount = NULL;
;;;940    
;;;941          // These two should be set, because if the Mat_ constructor was not called, these will not be initialized
;;;942          out->step.p = out->step.buf;
;;;943          out->size = &out->rows;
;;;944    
;;;945          *out = cv::Mat_<Type>(in.get_size(0), in.get_size(1), const_cast<Type*>(in.Pointer(0,0)), static_cast<size_t>(in.get_stride()));
;;;946    
;;;947          return RESULT_OK;
;;;948        } // template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;949    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;950    
;;;951        // #pragma mark --- Array Specializations ---
;;;952    
;;;953        template<> Result Array<bool>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;954        template<> Result Array<u8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;955        template<> Result Array<s8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;956        template<> Result Array<u16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;957        template<> Result Array<s16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;958        template<> Result Array<u32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;959        template<> Result Array<s32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;960        template<> Result Array<u64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;961        template<> Result Array<s64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;962        template<> Result Array<f32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;963        template<> Result Array<f64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;964        template<> Result Array<const char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;965        template<> Result Array<char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;966    
;;;967        template<> Result Array<f32>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;968        template<> Result Array<f64>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;969    
;;;970        template<> template<> s32 Array<u8>::SetCast(const s32 * const values, const s32 numValues);
;;;971        template<> template<> s32 Array<s16>::SetCast(const s32 * const values, const s32 numValues);
;;;972      } // namespace Embedded
;;;973    } //namespace Anki
;;;974    
;;;975    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;17     #include "anki/common/robot/arraySlices.h"
;;;1      /**
;;;2      File: arraySlices.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of arraySlices_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;14     
;;;15     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> ConstArraySlice<Type>::ConstArraySlice()
;;;23           : ySlice(LinearSequence<s32>()), xSlice(LinearSequence<s32>()), array(Array<Type>()), constArrayData(NULL)
;;;24         {
;;;25         }
;;;26     
;;;27         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array)
;;;28           : ySlice(LinearSequence<s32>(0,array.get_size(0)-1)), xSlice(LinearSequence<s32>(0,array.get_size(1)-1)), array(array)
;;;29         {
;;;30           if(array.get_numElements() == 0) {
;;;31             this->constArrayData = NULL;
;;;32           } else {
;;;33             this->constArrayData = array.Pointer(0,0);
;;;34           }
;;;35         }
;;;36     
;;;37         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;38           : ySlice(ySlice), xSlice(xSlice), array(array)
;;;39         {
;;;40           if(array.get_numElements() == 0) {
;;;41             this->constArrayData = NULL;
;;;42           } else {
;;;43             this->constArrayData = array.Pointer(0,0);
;;;44           }
;;;45         }
;;;46     
;;;47         template<typename Type> ConstArraySliceExpression<Type> ConstArraySlice<Type>::Transpose() const
;;;48         {
;;;49           ConstArraySliceExpression<Type> expression(*this, true);
;;;50     
;;;51           return expression;
;;;52         }
;;;53     
;;;54         template<typename Type> bool ConstArraySlice<Type>::IsValid() const
;;;55         {
;;;56           return this->array.IsValid();
;;;57         }
;;;58     
;;;59         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_ySlice() const
;;;60         {
;;;61           return ySlice;
;;;62         }
;;;63     
;;;64         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_xSlice() const
;;;65         {
;;;66           return xSlice;
;;;67         }
;;;68     
;;;69         template<typename Type> const Array<Type>& ConstArraySlice<Type>::get_array() const
;;;70         {
;;;71           return this->array;
;;;72         }
;;;73     
;;;74         template<typename Type> ArraySlice<Type>::ArraySlice()
;;;75           : ConstArraySlice<Type>(), arrayData(NULL)
;;;76         {
;;;77         }
;;;78     
;;;79         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array)
;;;80           : ConstArraySlice<Type>(array)
;;;81         {
;;;82           if(array.get_numElements() == 0) {
;;;83             this->arrayData = NULL;
;;;84           } else {
;;;85             this->arrayData = array.Pointer(0,0);
;;;86           }
;;;87         }
;;;88     
;;;89         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;90           : ConstArraySlice<Type>(array, ySlice, xSlice)
;;;91         {
;;;92           if(array.get_numElements() == 0) {
;;;93             this->arrayData = NULL;
;;;94           } else {
;;;95             this->arrayData = array.Pointer(0,0);
;;;96           }
;;;97         }
;;;98     
;;;99         template<typename Type> s32 ArraySlice<Type>::Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;100        {
;;;101          return this->SetCast<Type>(input, automaticTranspose);
;;;102        }
;;;103    
;;;104        template<typename Type> s32 ArraySlice<Type>::Set(const LinearSequence<Type> &input)
;;;105        {
;;;106          const Result result = input.Evaluate(*this);
;;;107          return (result==RESULT_OK) ? input.get_size() : 0;
;;;108        }
;;;109    
;;;110        template<typename Type> s32 ArraySlice<Type>::Set(const Type value)
;;;111        {
;;;112          Array<Type> &array = this->get_array();
;;;113    
;;;114          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;115            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;116    
;;;117          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;118    
;;;119          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;120            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;121    
;;;122          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;123            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;124            Type * restrict pMat = array.Pointer(y, 0);
;;;125    
;;;126            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;127              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;128              pMat[x] = value;
;;;129            }
;;;130          }
;;;131    
;;;132          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;133        }
;;;134    
;;;135        template<typename Type> s32 ArraySlice<Type>::Set(const Type * const values, const s32 numValues)
;;;136        {
;;;137          Array<Type> &array = this->get_array();
;;;138    
;;;139          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;140            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;141    
;;;142          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;143    
;;;144          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;145            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;146    
;;;147          AnkiConditionalErrorAndReturnValue(limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize == numValues,
;;;148            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;149    
;;;150          s32 ci = 0;
;;;151          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;152            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;153            Type * restrict pMat = array.Pointer(y, 0);
;;;154    
;;;155            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;156              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;157              pMat[x] = values[ci];
;;;158              ci++;
;;;159            }
;;;160          }
;;;161    
;;;162          AnkiAssert(ci == limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize);
;;;163    
;;;164          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;165        }
;;;166    
;;;167        template<typename Type> template<typename InType> s32 ArraySlice<Type>::SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;168        {
;;;169          AnkiConditionalErrorAndReturnValue(AreValid(*this, input),
;;;170            0, "ArraySlice<Type>::Set", "Invalid objects");
;;;171    
;;;172          AnkiConditionalErrorAndReturnValue(this->get_array().get_buffer() != input.get_array().get_buffer(),
;;;173            0, "ArraySlice<Type>::Set", "Arrays must be in different memory locations");
;;;174    
;;;175          ArraySliceLimits_in1_out1<s32> limits(
;;;176            input.get_ySlice(), input.get_xSlice(), input.get_isTransposed(),
;;;177            this->get_ySlice(), this->get_xSlice());
;;;178    
;;;179          if(!limits.isValid) {
;;;180            if(automaticTranspose) {
;;;181              // If we're allowed to transpose, give it another shot
;;;182              limits = ArraySliceLimits_in1_out1<s32> (input.get_ySlice(), input.get_xSlice(), !input.get_isTransposed(), this->get_ySlice(), this->get_xSlice());
;;;183    
;;;184              if(!limits.isValid) {
;;;185                AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;186                return 0;
;;;187              }
;;;188            } else {
;;;189              AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;190              return 0;
;;;191            }
;;;192          }
;;;193    
;;;194          Array<Type> &out1Array = this->get_array();
;;;195          const Array<InType> &in1Array = input.get_array();
;;;196    
;;;197          if(limits.isSimpleIteration) {
;;;198            // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;199    
;;;200            for(s32 y=0; y<limits.ySize; y++) {
;;;201              const InType * restrict pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;202              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;203    
;;;204              limits.OuterIncrementTop();
;;;205    
;;;206              for(s32 x=0; x<limits.xSize; x++) {
;;;207                pOut1[limits.out1X] = static_cast<Type>( pIn1[limits.in1X] );
;;;208    
;;;209                limits.out1X += limits.out1_xInnerIncrement;
;;;210                limits.in1X += limits.in1_xInnerIncrement;
;;;211              }
;;;212    
;;;213              limits.OuterIncrementBottom();
;;;214            }
;;;215          } else {
;;;216            for(s32 y=0; y<limits.ySize; y++) {
;;;217              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;218    
;;;219              limits.OuterIncrementTop();
;;;220    
;;;221              for(s32 x=0; x<limits.xSize; x++) {
;;;222                const InType pIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;223    
;;;224                pOut1[limits.out1X] = static_cast<Type>( pIn1 );
;;;225    
;;;226                limits.out1X += limits.out1_xInnerIncrement;
;;;227                limits.in1Y += limits.in1_yInnerIncrement;
;;;228              }
;;;229    
;;;230              limits.OuterIncrementBottom();
;;;231            }
;;;232          }
;;;233    
;;;234          return limits.ySize*limits.xSize;
;;;235        }
;;;236    
;;;237        template<typename Type> Array<Type>& ArraySlice<Type>::get_array()
;;;238        {
;;;239          return this->array;
;;;240        }
;;;241    
;;;242        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression()
;;;243          : ConstArraySlice<Type>(), isTransposed(false)
;;;244        {
;;;245        }
;;;246    
;;;247        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const Array<Type> input, bool isTransposed)
;;;248          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;249        {
;;;250        }
;;;251    
;;;252        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed)
;;;253          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;254        {
;;;255        }
;;;256    
;;;257        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed)
;;;258          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;259        {
;;;260        }
;;;261    
;;;262        template<typename Type> ConstArraySliceExpression<Type> ConstArraySliceExpression<Type>::Transpose() const
;;;263        {
;;;264          ConstArraySliceExpression<Type> expression(*this, !this->get_isTransposed());
;;;265    
;;;266          return expression;
;;;267        }
;;;268    
;;;269        template<typename Type> bool ConstArraySliceExpression<Type>::get_isTransposed() const
;;;270        {
;;;271          return isTransposed;
;;;272        }
;;;273    
;;;274        template<typename Type> ArraySliceSimpleLimits<Type>::ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;275          : xStart(in1_xSlice.get_start()), xIncrement(in1_xSlice.get_increment()), xSize(in1_xSlice.get_size()),
;;;276          yStart(in1_ySlice.get_start()), yIncrement(in1_ySlice.get_increment()), ySize(in1_ySlice.get_size())
;;;277        {
;;;278        }
;;;279    
;;;280        template<typename Type> ArraySliceLimits_in1_out0<Type>::ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;281          : isValid(true), rawIn1Limits(in1_ySlice, in1_xSlice)
;;;282        {
;;;283        } // ArraySliceLimits_in1_out0
;;;284    
;;;285        template<typename Type> ArraySliceLimits_in1_out1<Type>::ArraySliceLimits_in1_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;286          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;287          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;288          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed)
;;;289        {
;;;290          isValid = false;
;;;291    
;;;292          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;293    
;;;294          if(!in1_isTransposed) {
;;;295            if(rawOut1Limits.xSize == rawIn1Limits.xSize && rawOut1Limits.ySize == rawIn1Limits.ySize) {
;;;296              isValid = true;
;;;297              isSimpleIteration = true;
;;;298    
;;;299              this->in1Y = this->rawIn1Limits.yStart;
;;;300              this->out1Y = this->rawOut1Limits.yStart;
;;;301    
;;;302              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;303              this->in1_yInnerIncrement = 0;
;;;304            }
;;;305          } else { // if(!in1_isTransposed)
;;;306            if(rawOut1Limits.xSize == rawIn1Limits.ySize && rawOut1Limits.ySize == rawIn1Limits.xSize) {
;;;307              isValid = true;
;;;308              isSimpleIteration = false;
;;;309    
;;;310              this->in1X = this->rawIn1Limits.xStart;
;;;311              this->out1Y = this->rawOut1Limits.yStart;
;;;312    
;;;313              this->in1_xInnerIncrement = 0;
;;;314              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;315            }
;;;316          } // if(!in1_isTransposed) ... else
;;;317    
;;;318          if(!isValid) {
;;;319            AnkiError("ArraySliceLimits_in1_out1", "Subscripted assignment dimension mismatch");
;;;320            return;
;;;321          }
;;;322        } // ArraySliceLimits_in1_out1
;;;323    
;;;324        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;325        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;326        {
;;;327          if(isSimpleIteration) {
;;;328            this->in1X = this->rawIn1Limits.xStart;
;;;329            this->out1X = this->rawOut1Limits.xStart;
;;;330          } else { // if(isSimpleIteration)
;;;331            this->in1Y = this->rawIn1Limits.yStart;
;;;332            this->out1X = this->rawOut1Limits.xStart;
;;;333          } // if(isSimpleIteration) ... else
;;;334        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;335    
;;;336        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;337        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;338        {
;;;339          if(isSimpleIteration) {
;;;340            this->in1Y += this->rawIn1Limits.yIncrement;
;;;341            this->out1Y += this->rawOut1Limits.yIncrement;
;;;342          } else { // if(isSimpleIteration)
;;;343            this->in1X += this->rawIn1Limits.xIncrement;
;;;344            this->out1Y += this->rawOut1Limits.yIncrement;
;;;345          } // if(isSimpleIteration) ... else
;;;346        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;347    
;;;348        template<typename Type> ArraySliceLimits_in2_out1<Type>::ArraySliceLimits_in2_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;349          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;350          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;351          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed),
;;;352          rawIn2Limits(in2_ySlice, in2_xSlice), in2_isTransposed(in2_isTransposed)
;;;353        {
;;;354          isValid = false;
;;;355    
;;;356          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;357          this->in1_yInnerIncrement = 0;
;;;358          this->in1_xInnerIncrement = 0;
;;;359          this->in2_yInnerIncrement = 0;
;;;360          this->in2_xInnerIncrement = 0;
;;;361    
;;;362          if(!in1_isTransposed && !in2_isTransposed) {
;;;363            const bool sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;364    
;;;365            if(sizesMatch) {
;;;366              isValid = true;
;;;367              isSimpleIteration = true;
;;;368    
;;;369              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;370              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;371    
;;;372              this->in1Y = this->rawIn1Limits.yStart;
;;;373              this->in2Y = this->rawIn2Limits.yStart;
;;;374              this->out1Y = this->rawOut1Limits.yStart;
;;;375            }
;;;376          } else { // if(!in1_isTransposed)
;;;377            isSimpleIteration = false;
;;;378    
;;;379            bool sizesMatch = false;
;;;380    
;;;381            if(in1_isTransposed && in2_isTransposed) {
;;;382              sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;383              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;384              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;385            } else if(in1_isTransposed) {
;;;386              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;387              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;388              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;389            } else if(in2_isTransposed) {
;;;390              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;391              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;392              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;393            } else {
;;;394              AnkiAssert(false); // should not be possible
;;;395            }
;;;396    
;;;397            if(!sizesMatch) {
;;;398              AnkiError("ArraySliceLimits_in2_out1", "Subscripted assignment dimension mismatch");
;;;399              return;
;;;400            }
;;;401    
;;;402            isValid = true;
;;;403    
;;;404            this->in1X = this->rawIn1Limits.xStart;
;;;405            this->in1Y = this->rawIn1Limits.yStart;
;;;406            this->in2X = this->rawIn2Limits.xStart;
;;;407            this->in2Y = this->rawIn2Limits.yStart;
;;;408    
;;;409            this->out1Y = this->rawOut1Limits.yStart;
;;;410          } // if(!in1_isTransposed) ... else
;;;411        } // ArraySliceLimits_in1_out1
;;;412    
;;;413        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;414        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;415        {
;;;416          if(isSimpleIteration) {
;;;417            this->out1X = this->rawOut1Limits.xStart;
;;;418            this->in1X = this->rawIn1Limits.xStart;
;;;419            this->in2X = this->rawIn2Limits.xStart;
;;;420          } else { // if(isSimpleIteration)
;;;421            this->out1X = this->rawOut1Limits.xStart;
;;;422    
;;;423            if(in1_isTransposed) {
;;;424              this->in1Y = this->rawIn1Limits.yStart;
;;;425            } else {
;;;426              this->in1X = this->rawIn1Limits.xStart;
;;;427            }
;;;428    
;;;429            if(in2_isTransposed) {
;;;430              this->in2Y = this->rawIn2Limits.yStart;
;;;431            } else {
;;;432              this->in2X = this->rawIn2Limits.xStart;
;;;433            }
;;;434          } // if(isSimpleIteration) ... else
;;;435        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;436    
;;;437        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;438        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;439        {
;;;440          if(isSimpleIteration) {
;;;441            this->in1Y += this->rawIn1Limits.yIncrement;
;;;442            this->in2Y += this->rawIn2Limits.yIncrement;
;;;443            this->out1Y += this->rawOut1Limits.yIncrement;
;;;444          } else { // if(isSimpleIteration)
;;;445            this->out1Y += this->rawOut1Limits.yIncrement;
;;;446    
;;;447            if(in1_isTransposed) {
;;;448              this->in1X += this->rawIn1Limits.xIncrement;
;;;449            } else {
;;;450              this->in1Y += this->rawIn1Limits.yIncrement;
;;;451            }
;;;452    
;;;453            if(in2_isTransposed) {
;;;454              this->in2X += this->rawIn2Limits.xIncrement;
;;;455            } else {
;;;456              this->in2Y += this->rawIn2Limits.yIncrement;
;;;457            }
;;;458          } // if(isSimpleIteration) ... else
;;;459        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;460      } // namespace Embedded
;;;461    } // namespace Anki
;;;462    
;;;463    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;19     #include "anki/common/robot/benchmarking.h"
;;;1      /**
;;;2      File: benchmarkins.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Low-overhead benchmarking, based on a list of start and end events.
;;;7      
;;;8      The basic use of this benchmarking utility is as follows:
;;;9      1. InitBenchmarking()
;;;10     2. At the beginning of the section you want to benchmark, put BeginBenchmark("event type");
;;;11     3. At the end of the section you want to benchmark, put EndBenchmark("event type");
;;;12     4. When you're done running the program, call PrintBenchmarkResults() to print the results
;;;13     
;;;14     Copyright Anki, Inc. 2013
;;;15     For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;16     **/
;;;17     
;;;18     #ifndef _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;19     #define _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     
;;;21     #include "anki/common/robot/config.h"
;;;1      /**
;;;22     #include "anki/common/robot/fixedLengthList_declarations.h"
;;;1      /**
;;;2      File: fixedLengthList_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      A FixedLengthList is like a std::vector, but has a fixed maximum size. This maximum is allocated at contruction.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         class SerializedBuffer;
;;;24     
;;;25         // A FixedLengthList is a list with a fixed maximum size, which is allocated at construction.
;;;26         template<typename Type> class FixedLengthList : public ArraySlice<Type>
;;;27         {
;;;28         public:
;;;29           FixedLengthList();
;;;30     
;;;31           // Constructor for a FixedLengthList, pointing to user-allocated data.
;;;32           FixedLengthList(s32 maximumSize, void * data, s32 dataLength, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;33     
;;;34           // Constructor for a FixedLengthList, pointing to user-allocated MemoryStack
;;;35           FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;36     
;;;37           bool IsValid() const;
;;;38     
;;;39           // Resize will use MemoryStack::Reallocate() to change the FixedLengthList's size. It only works if this
;;;40           // FixedLengthList was the last thing allocated. The reallocated memory will not be cleared
;;;41           //
;;;42           // WARNING:
;;;43           // This will not update any references to the memory, you must update all references manually.
;;;44           Result Resize(s32 maximumSize, MemoryStack &memory);
;;;45     
;;;46           Result PushBack(const Type &value);
;;;47     
;;;48           // Will act as a normal pop, except when the list is empty. Then subsequent
;;;49           // calls will keep returning the first value in the list.
;;;50           Type PopBack();
;;;51     
;;;52           // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
;;;53           inline void Clear();
;;;54     
;;;55           // Does this ever need to be declared explicitly?
;;;56           //FixedLengthList& operator= (const FixedLengthList & rightHandSide);
;;;57     
;;;58           // Pointer to the data, at a given location
;;;59           inline Type* Pointer(const s32 index);
;;;60           inline const Type* Pointer(const s32 index) const;
;;;61     
;;;62           // Use this operator for normal C-style vector indexing. For example, "list[5] = 6;" will set
;;;63           // the element in the fifth row and first column to 6. This is the same as "*list.Pointer(5) =
;;;64           // 6;"
;;;65           //
;;;66           // NOTE:
;;;67           // Using this in a inner loop may be less efficient than using an explicit pointer with a
;;;68           // restrict keyword (Though the runtime cost isn't nearly as large as the [] operator for the
;;;69           // Array class). For speeding up performance-critical inner loops, use something like: "Type *
;;;70           // restrict pList = list.Pointer(0);" outside the inner loop, then index
;;;71           // pList in the inner loop.
;;;72           inline const Type& operator[](const s32 index) const;
;;;73           inline Type& operator[](const s32 index);
;;;74     
;;;75           // Print out the contents of this FixedLengthList
;;;76           Result Print(const char * const variableName = "FixedLengthList", const s32 minIndex = 0, const s32 maxIndex = 0x7FFFFFE) const;
;;;77     
;;;78           // Set every element in the Array to zero, including the stride padding, but not including the optional fill patterns (if they exist)
;;;79           // Returns the number of bytes set to zero
;;;80           inline s32 SetZero();
;;;81     
;;;82           // Read in the input, then cast it to this object's type
;;;83           //
;;;84           // WARNING:
;;;85           // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;86           template<typename InType> s32 SetCast(const FixedLengthList<InType> &input, bool automaticTranspose=true);
;;;87           //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;88     
;;;89           // The maximum size is set at object construction
;;;90           inline s32 get_maximumSize() const;
;;;91     
;;;92           // The current size changes as the FixedLengthList is used
;;;93           inline s32 get_size() const;
;;;94     
;;;95           // Attempt to set the size to newSize. Returns the value that was actually set.
;;;96           s32 set_size(s32 newSize);
;;;97     
;;;98         protected:
;;;99           // TODO: make less hacky
;;;100          friend class SerializedBuffer;
;;;101        }; // class FixedLengthList
;;;102      } // namespace Embedded
;;;103    } //namespace Anki
;;;104    
;;;105    #endif // _ANKICORETECHEMBEDDED_COMMON_FIXEDLENGTHLIST_DECLARATIONS_H_
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         const s32 MAX_BENCHMARK_EVENTS = 16000;
;;;29     
;;;30         typedef struct BenchmarkElement
;;;31         {
;;;32           // All times in microseconds, on all platforms
;;;33     
;;;34           static const s32 NAME_LENGTH = 64;
;;;35     
;;;36           // Inclusive includes all the time for all sub-benchmarks
;;;37           u32 inclusive_mean;
;;;38           u32 inclusive_min;
;;;39           u32 inclusive_max;
;;;40           u32 inclusive_total;
;;;41     
;;;42           // Exclusive does not include sub-benchmarks
;;;43           u32 exclusive_mean;
;;;44           u32 exclusive_min;
;;;45           u32 exclusive_max;
;;;46           u32 exclusive_total;
;;;47     
;;;48           // How many times was this element's name benchmarked?
;;;49           u32 numEvents;
;;;50     
;;;51           char name[BenchmarkElement::NAME_LENGTH];
;;;52     
;;;53           BenchmarkElement(const char * name);
;;;54     
;;;55           // Print with CoreTechPrint()
;;;56           void Print(const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;57     
;;;58           // Like snprintf(). Returns the number of characters printed, not including the final null byte.
;;;59           s32 Snprint(char * buffer, const s32 bufferLength, const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;60         } BenchmarkElement;
;;;61     
;;;62         typedef struct ShowBenchmarkParameters
;;;63         {
;;;64           char name[BenchmarkElement::NAME_LENGTH];
;;;65           bool showExclusiveTime;
;;;66           u8 red, green, blue;
;;;67     
;;;68           ShowBenchmarkParameters(
;;;69             const char * name,
;;;70             const bool showExclusiveTime,
;;;71             const u8 *color); //< Color is {R,G,B}
;;;72         } ShowBenchmarkParameters;
;;;73     
;;;74         // Call this before doing any benchmarking, to clear the buffer of benchmarkEvents.
;;;75         // Can be called multiple times.
;;;76         void InitBenchmarking();
;;;77     
;;;78         // Use these functions to add a new event to the list. These functions are very fast.
;;;79         //
;;;80         // WARNING: name must be in globally available memory
;;;81         //
;;;82         // WARNING: the character string must be less than BenchmarkElement::NAME_LENGTH bytes
;;;83         //
;;;84         // WARNING: Using the same name for different benchmark events
;;;85         //
;;;86         // WARNING: nesting BeginBenchmark() and EndBenchmark() events that have the same name won't work.
;;;87         // This is okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("b"); EndBenchmark("a");
;;;88         // This is not okay: BeginBenchmark("a"); BeginBenchmark("a"); EndBenchmark("a"); EndBenchmark("a");
;;;89         // This is not okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("a"); EndBenchmark("b");
;;;90         void BeginBenchmark(const char *name);
;;;91         void EndBenchmark(const char *name);
;;;92     
;;;93         // Compile all the benchmark events that were recorded
;;;94         FixedLengthList<BenchmarkElement> ComputeBenchmarkResults(MemoryStack &memory);
;;;95     
;;;96         // CoreTechPrint() the benchmark results
;;;97         // WARNING: This doesn't work well with multi-threaded programs
;;;98         Result PrintBenchmarkResults(const FixedLengthList<BenchmarkElement> &results, const bool verbose=true, const bool microseconds=true);
;;;99     
;;;100        // Compile and print out all the benchmark events that were recorded
;;;101        Result ComputeAndPrintBenchmarkResults(const bool verbose, const bool microseconds, MemoryStack scratch);
;;;102    
;;;103        // Use OpenCV to display a running benchmark
;;;104        // Requires a "TotalTime" benchmark event
;;;105        // namesToDisplay can be 11 or less names
;;;106        Result ShowBenchmarkResults(
;;;107          const FixedLengthList<BenchmarkElement> &results,
;;;108          const FixedLengthList<ShowBenchmarkParameters> &namesToDisplay,
;;;109          const f32 pixelsPerMillisecond,
;;;110          const s32 imageHeight,
;;;111          const s32 imageWidth);
;;;112    
;;;113        s32 GetNameIndex(const char * name, const FixedLengthList<BenchmarkElement> &outputResults);
;;;114      } // namespace Embedded
;;;115    } // namespace Anki
;;;116    
;;;117    #endif // _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     #include "anki/common/robot/comparisons.h"
;;;1      /**
;;;2      File: comparisons.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of comparisons_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;14     
;;;15     #include "anki/common/robot/comparisons_declarations.h"
;;;1      /**
;;;2      File: comparisons_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various elementwise tests, to ensure that the data of two Arrays is equal.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Declarations ---
;;;23         // Check every element of this array against the input array. If the arrays are different
;;;24         // sizes, uninitialized, or if any element is more different than the threshold, then
;;;25         // return false.
;;;26         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold = static_cast<Type>(0.0001));
;;;27     
;;;28         // Check every element of this array against the input array. If the arrays are different
;;;29         // sizes or uninitialized, return false. The percentThreshold is between 0.0 and 1.0. To
;;;30         // return false, an element must fail both thresholds. The percent threshold fails if an
;;;31         // element is more than a percentage different than its matching element (calulated from the
;;;32         // maximum of the two).
;;;33         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold = 0.01, const double absoluteThreshold = 0.0001);
;;;34     
;;;35         // If any of the input objects are not valid, then return false
;;;36         // NOTE: the objects must have an IsValid() method
;;;37         template<typename Type1> bool AreValid(const Type1 &object1);
;;;38         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2);
;;;39         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;40         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;41         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;42         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;43         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;44         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;45         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;46     
;;;47         // If the objects have different sizes or are uninitialized, then return false.
;;;48         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;49         template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2);
;;;50         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;51         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;52         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;53         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;54         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;55         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;56         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;57     
;;;58         // Check sizes against an input height and width
;;;59         template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1);
;;;60         template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2);
;;;61         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;62         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;63         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;64         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;65         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;66         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;67         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;68     
;;;69         // If the Arrays are aliased (pointing to the same location in memory) or uninitialized, then return false
;;;70         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;71         template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2);
;;;72         template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;73         template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;74         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;75         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;76         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;77         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;78         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;79       } // namespace Embedded
;;;80     } // namespace Anki
;;;81     
;;;82     #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark
;;;23     
;;;24         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold)
;;;25         {
;;;26           if(!AreEqualSize(array1, array2))
;;;27             return false;
;;;28     
;;;29           const s32 height = array1.get_size(0);
;;;30           const s32 width = array1.get_size(1);
;;;31     
;;;32           for(s32 y=0; y<height; y++) {
;;;33             const Type * const pArray1 = array1.Pointer(y, 0);
;;;34             const Type * const pArray2 = array2.Pointer(y, 0);
;;;35             for(s32 x=0; x<width; x++) {
;;;36               if(pArray1[x] > pArray2[x]) {
;;;37                 if((pArray1[x] - pArray2[x]) > threshold)
;;;38                   return false;
;;;39               } else {
;;;40                 if((pArray2[x] - pArray1[x]) > threshold)
;;;41                   return false;
;;;42               }
;;;43             }
;;;44           }
;;;45     
;;;46           return true;
;;;47         }
;;;48     
;;;49         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold, const double absoluteThreshold)
;;;50         {
;;;51           if(!AreEqualSize(array1, array2))
;;;52             return false;
;;;53     
;;;54           const s32 height = array1.get_size(0);
;;;55           const s32 width = array1.get_size(1);
;;;56     
;;;57           for(s32 y=0; y<height; y++) {
;;;58             const Type * const pArray1 = array1.Pointer(y, 0);
;;;59             const Type * const pArray2 = array2.Pointer(y, 0);
;;;60             for(s32 x=0; x<width; x++) {
;;;61               const double value1 = static_cast<double>(pArray1[x]);
;;;62               const double value2 = static_cast<double>(pArray2[x]);
;;;63               const double percentThresholdValue = percentThreshold * MAX(value1,value2);
;;;64     
;;;65               if(fabs(value1 - value2) > percentThresholdValue && fabs(value1 - value2) > absoluteThreshold)
;;;66                 return false;
;;;67             }
;;;68           }
;;;69     
;;;70           return true;
;;;71         }
;;;72     
;;;73         template<typename Type1> bool AreValid(const Type1 &object1)
;;;74         {
;;;75           if(!object1.IsValid())
;;;76             return false;
;;;77     
;;;78           return true;
;;;79         }
;;;80     
;;;81         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2)
;;;82         {
;;;83           if(!object1.IsValid() || !object2.IsValid())
;;;84             return false;
;;;85     
;;;86           return true;
;;;87         }
;;;88     
;;;89         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;90         {
;;;91           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid())
;;;92             return false;
;;;93     
;;;94           return true;
;;;95         }
;;;96     
;;;97         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;98         {
;;;99           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid())
;;;100            return false;
;;;101    
;;;102          return true;
;;;103        }
;;;104    
;;;105        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;106        {
;;;107          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid())
;;;108            return false;
;;;109    
;;;110          return true;
;;;111        }
;;;112    
;;;113        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;114        {
;;;115          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid())
;;;116            return false;
;;;117    
;;;118          return true;
;;;119        }
;;;120    
;;;121        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;122        {
;;;123          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid())
;;;124            return false;
;;;125    
;;;126          return true;
;;;127        }
;;;128    
;;;129        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;130        {
;;;131          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid())
;;;132            return false;
;;;133    
;;;134          return true;
;;;135        }
;;;136    
;;;137        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;138        {
;;;139          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid() || !object9.IsValid())
;;;140            return false;
;;;141    
;;;142          return true;
;;;143        }
;;;144    
;;;145        template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2)
;;;146        {
;;;147          if(!AreValid(object1, object2))
;;;148            return false;
;;;149    
;;;150          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1))
;;;151            return false;
;;;152    
;;;153          return true;
;;;154        }
;;;155    
;;;156        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;157        {
;;;158          if(!AreValid(object1, object2, object3))
;;;159            return false;
;;;160    
;;;161          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;162            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1))
;;;163            return false;
;;;164    
;;;165          return true;
;;;166        }
;;;167    
;;;168        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;169        {
;;;170          if(!AreValid(object1, object2, object3, object4))
;;;171            return false;
;;;172    
;;;173          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;174            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;175            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1))
;;;176            return false;
;;;177    
;;;178          return true;
;;;179        }
;;;180    
;;;181        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;182        {
;;;183          if(!AreValid(object1, object2, object3, object4, object5))
;;;184            return false;
;;;185    
;;;186          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;187            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;188            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;189            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1))
;;;190            return false;
;;;191    
;;;192          return true;
;;;193        }
;;;194    
;;;195        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;196        {
;;;197          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;198            return false;
;;;199    
;;;200          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;201            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;202            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;203            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;204            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1))
;;;205            return false;
;;;206    
;;;207          return true;
;;;208        }
;;;209    
;;;210        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;211        {
;;;212          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;213            return false;
;;;214    
;;;215          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;216            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;217            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;218            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;219            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;220            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1))
;;;221            return false;
;;;222    
;;;223          return true;
;;;224        }
;;;225    
;;;226        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;227        {
;;;228          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;229            return false;
;;;230    
;;;231          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;232            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;233            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;234            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;235            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;236            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;237            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1))
;;;238            return false;
;;;239    
;;;240          return true;
;;;241        }
;;;242    
;;;243        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;244        {
;;;245          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;246            return false;
;;;247    
;;;248          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;249            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;250            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;251            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;252            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;253            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;254            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1) ||
;;;255            object1.get_size(0) != object9.get_size(0) || object1.get_size(1) != object9.get_size(1))
;;;256            return false;
;;;257    
;;;258          return true;
;;;259        }
;;;260    
;;;261        template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1)
;;;262        {
;;;263          if(!AreValid(object1))
;;;264            return false;
;;;265    
;;;266          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;267            return false;
;;;268    
;;;269          return true;
;;;270        }
;;;271    
;;;272        template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2)
;;;273        {
;;;274          if(!AreValid(object1, object2))
;;;275            return false;
;;;276    
;;;277          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;278            return false;
;;;279    
;;;280          return AreEqualSize(object1, object2);
;;;281        }
;;;282    
;;;283        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;284        {
;;;285          if(!AreValid(object1, object2, object3))
;;;286            return false;
;;;287    
;;;288          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;289            return false;
;;;290    
;;;291          return AreEqualSize(object1, object2, object3);
;;;292        }
;;;293    
;;;294        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;295        {
;;;296          if(!AreValid(object1, object2, object3, object4))
;;;297            return false;
;;;298    
;;;299          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;300            return false;
;;;301    
;;;302          return AreEqualSize(object1, object2, object3, object4);
;;;303        }
;;;304    
;;;305        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;306        {
;;;307          if(!AreValid(object1, object2, object3, object4, object5))
;;;308            return false;
;;;309    
;;;310          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;311            return false;
;;;312    
;;;313          return AreEqualSize(object1, object2, object3, object4, object5);
;;;314        }
;;;315    
;;;316        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;317        {
;;;318          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;319            return false;
;;;320    
;;;321          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;322            return false;
;;;323    
;;;324          return AreEqualSize(object1, object2, object3, object4, object5, object6);
;;;325        }
;;;326    
;;;327        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;328        {
;;;329          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;330            return false;
;;;331    
;;;332          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;333            return false;
;;;334    
;;;335          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7);
;;;336        }
;;;337    
;;;338        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;339        {
;;;340          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;341            return false;
;;;342    
;;;343          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;344            return false;
;;;345    
;;;346          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8);
;;;347        }
;;;348    
;;;349        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;350        {
;;;351          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;352            return false;
;;;353    
;;;354          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;355            return false;
;;;356    
;;;357          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8, object9);
;;;358        }
;;;359    
;;;360        template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2)
;;;361        {
;;;362          if(!AreValid(object1, object2))
;;;363            return false;
;;;364    
;;;365          const size_t bufferPointers[] = {
;;;366            reinterpret_cast<size_t>(object1.get_buffer()),
;;;367            reinterpret_cast<size_t>(object2.get_buffer())};
;;;368    
;;;369          for(s32 i=0; i<2; i++) {
;;;370            for(s32 j=i+1; j<2; j++) {
;;;371              if(bufferPointers[i] == bufferPointers[j])
;;;372                return false;
;;;373            }
;;;374          }
;;;375    
;;;376          return true;
;;;377        }
;;;378    
;;;379        template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;380        {
;;;381          if(!AreValid(object1, object2, object3))
;;;382            return false;
;;;383    
;;;384          const size_t bufferPointers[] = {
;;;385            reinterpret_cast<size_t>(object1.get_buffer()),
;;;386            reinterpret_cast<size_t>(object2.get_buffer()),
;;;387            reinterpret_cast<size_t>(object3.get_buffer())};
;;;388    
;;;389          for(s32 i=0; i<3; i++) {
;;;390            for(s32 j=i+1; j<3; j++) {
;;;391              if(bufferPointers[i] == bufferPointers[j])
;;;392                return false;
;;;393            }
;;;394          }
;;;395    
;;;396          return true;
;;;397        }
;;;398    
;;;399        template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;400        {
;;;401          if(!AreValid(object1, object2, object3, object4))
;;;402            return false;
;;;403    
;;;404          const size_t bufferPointers[] = {
;;;405            reinterpret_cast<size_t>(object1.get_buffer()),
;;;406            reinterpret_cast<size_t>(object2.get_buffer()),
;;;407            reinterpret_cast<size_t>(object3.get_buffer()),
;;;408            reinterpret_cast<size_t>(object4.get_buffer())};
;;;409    
;;;410          for(s32 i=0; i<4; i++) {
;;;411            for(s32 j=i+1; j<4; j++) {
;;;412              if(bufferPointers[i] == bufferPointers[j])
;;;413                return false;
;;;414            }
;;;415          }
;;;416    
;;;417          return true;
;;;418        }
;;;419    
;;;420        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;421        {
;;;422          if(!AreValid(object1, object2, object3, object4, object5))
;;;423            return false;
;;;424    
;;;425          const size_t bufferPointers[] = {
;;;426            reinterpret_cast<size_t>(object1.get_buffer()),
;;;427            reinterpret_cast<size_t>(object2.get_buffer()),
;;;428            reinterpret_cast<size_t>(object3.get_buffer()),
;;;429            reinterpret_cast<size_t>(object4.get_buffer()),
;;;430            reinterpret_cast<size_t>(object5.get_buffer())};
;;;431    
;;;432          for(s32 i=0; i<5; i++) {
;;;433            for(s32 j=i+1; j<5; j++) {
;;;434              if(bufferPointers[i] == bufferPointers[j])
;;;435                return false;
;;;436            }
;;;437          }
;;;438    
;;;439          return true;
;;;440        }
;;;441    
;;;442        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;443        {
;;;444          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;445            return false;
;;;446    
;;;447          const size_t bufferPointers[] = {
;;;448            reinterpret_cast<size_t>(object1.get_buffer()),
;;;449            reinterpret_cast<size_t>(object2.get_buffer()),
;;;450            reinterpret_cast<size_t>(object3.get_buffer()),
;;;451            reinterpret_cast<size_t>(object4.get_buffer()),
;;;452            reinterpret_cast<size_t>(object5.get_buffer()),
;;;453            reinterpret_cast<size_t>(object6.get_buffer())};
;;;454    
;;;455          for(s32 i=0; i<6; i++) {
;;;456            for(s32 j=i+1; j<6; j++) {
;;;457              if(bufferPointers[i] == bufferPointers[j])
;;;458                return false;
;;;459            }
;;;460          }
;;;461    
;;;462          return true;
;;;463        }
;;;464    
;;;465        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;466        {
;;;467          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;468            return false;
;;;469    
;;;470          const size_t bufferPointers[] = {
;;;471            reinterpret_cast<size_t>(object1.get_buffer()),
;;;472            reinterpret_cast<size_t>(object2.get_buffer()),
;;;473            reinterpret_cast<size_t>(object3.get_buffer()),
;;;474            reinterpret_cast<size_t>(object4.get_buffer()),
;;;475            reinterpret_cast<size_t>(object5.get_buffer()),
;;;476            reinterpret_cast<size_t>(object6.get_buffer()),
;;;477            reinterpret_cast<size_t>(object7.get_buffer())};
;;;478    
;;;479          for(s32 i=0; i<7; i++) {
;;;480            for(s32 j=i+1; j<7; j++) {
;;;481              if(bufferPointers[i] == bufferPointers[j])
;;;482                return false;
;;;483            }
;;;484          }
;;;485    
;;;486          return true;
;;;487        }
;;;488    
;;;489        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;490        {
;;;491          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;492            return false;
;;;493    
;;;494          const size_t bufferPointers[] = {
;;;495            reinterpret_cast<size_t>(object1.get_buffer()),
;;;496            reinterpret_cast<size_t>(object2.get_buffer()),
;;;497            reinterpret_cast<size_t>(object3.get_buffer()),
;;;498            reinterpret_cast<size_t>(object4.get_buffer()),
;;;499            reinterpret_cast<size_t>(object5.get_buffer()),
;;;500            reinterpret_cast<size_t>(object6.get_buffer()),
;;;501            reinterpret_cast<size_t>(object7.get_buffer()),
;;;502            reinterpret_cast<size_t>(object8.get_buffer())};
;;;503    
;;;504          for(s32 i=0; i<8; i++) {
;;;505            for(s32 j=i+1; j<8; j++) {
;;;506              if(bufferPointers[i] == bufferPointers[j])
;;;507                return false;
;;;508            }
;;;509          }
;;;510    
;;;511          return true;
;;;512        }
;;;513    
;;;514        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;515        {
;;;516          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;517            return false;
;;;518    
;;;519          const size_t bufferPointers[] = {
;;;520            reinterpret_cast<size_t>(object1.get_buffer()),
;;;521            reinterpret_cast<size_t>(object2.get_buffer()),
;;;522            reinterpret_cast<size_t>(object3.get_buffer()),
;;;523            reinterpret_cast<size_t>(object4.get_buffer()),
;;;524            reinterpret_cast<size_t>(object5.get_buffer()),
;;;525            reinterpret_cast<size_t>(object6.get_buffer()),
;;;526            reinterpret_cast<size_t>(object7.get_buffer()),
;;;527            reinterpret_cast<size_t>(object8.get_buffer()),
;;;528            reinterpret_cast<size_t>(object9.get_buffer()) };
;;;529    
;;;530          for(s32 i=0; i<9; i++) {
;;;531            for(s32 j=i+1; j<9; j++) {
;;;532              if(bufferPointers[i] == bufferPointers[j])
;;;533                return false;
;;;534            }
;;;535          }
;;;536    
;;;537          return true;
;;;538        }
;;;539      } // namespace Embedded
;;;540    } // namespace Anki
;;;541    
;;;542    #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26         namespace Matrix
;;;27         {
;;;28           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;29           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;30           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;31           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;32     
;;;33           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;34           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;35           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;36           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;37     
;;;38           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;39           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;40           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;41           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;42     
;;;43           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;44           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;45           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;46           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;47     
;;;48           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;49           {
;;;50             const Array<Type> &array = mat.get_array();
;;;51     
;;;52             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;53               0, "Matrix::Min", "Array<Type> is not valid");
;;;54     
;;;55             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;56     
;;;57             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;58               0, "Matrix::Min", "Limits is not valid");
;;;59     
;;;60             Type minValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;61             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;62               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;63               const Type * restrict pMat = array.Pointer(y, 0);
;;;64     
;;;65               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;66                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;67                 minValue = MIN(minValue, pMat[x]);
;;;68               }
;;;69             }
;;;70     
;;;71             return minValue;
;;;72           } // template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;73     
;;;74           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;75           {
;;;76             const Array<Type> &array = mat.get_array();
;;;77     
;;;78             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;79               0, "Matrix::Max", "Array<Type> is not valid");
;;;80     
;;;81             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;82     
;;;83             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;84               0, "Matrix::Max", "Limits is not valid");
;;;85     
;;;86             Type maxValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;87             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;88               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;89               const Type * restrict pMat = array.Pointer(y, 0);
;;;90     
;;;91               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;92                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;93                 maxValue = MAX(maxValue, pMat[x]);
;;;94               }
;;;95             }
;;;96     
;;;97             return maxValue;
;;;98           } // template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;99     
;;;100          template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat)
;;;101          {
;;;102            const Array<Array_Type> &array = mat.get_array();
;;;103    
;;;104            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;105              0, "Matrix::Sum", "Array<Type> is not valid");
;;;106    
;;;107            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;108    
;;;109            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;110              0, "Matrix::Sum", "Limits is not valid");
;;;111    
;;;112            Accumulator_Type sum = 0;
;;;113            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;114              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;115              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;116    
;;;117              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;118                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;119                sum += pMat[x];
;;;120              }
;;;121            }
;;;122    
;;;123            return sum;
;;;124          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;125    
;;;126          template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;127          {
;;;128            const Accumulator_Type sum = Sum<Array_Type,Accumulator_Type>(mat);
;;;129            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;130            const Array_Type mean = static_cast<Array_Type>(sum / numElements);
;;;131    
;;;132            return mean;
;;;133          } // template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;134    
;;;135          template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(
;;;136            const ConstArraySliceExpression<Array_Type> &mat,
;;;137            Accumulator_Type& mean,
;;;138            Accumulator_Type& var)
;;;139          {
;;;140            const Array<Array_Type> &array = mat.get_array();
;;;141    
;;;142            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;143              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Array<Type> is not valid");
;;;144    
;;;145            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;146    
;;;147            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;148              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Limits is not valid");
;;;149    
;;;150            Accumulator_Type sum = 0;
;;;151            Accumulator_Type sumSq = 0;
;;;152            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;153              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;154              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;155    
;;;156              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;157                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;158                const Accumulator_Type val = static_cast<Accumulator_Type>(pMat[x]);
;;;159                sum   += val;
;;;160                sumSq += val*val;
;;;161              }
;;;162            }
;;;163    
;;;164            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;165    
;;;166            mean = sum / numElements;                  // mean = E[x]
;;;167            var  = (sumSq / numElements) - (mean*mean);  // var  = E[x^2] - E[x]^2
;;;168    
;;;169            return RESULT_OK;
;;;170          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;171    
;;;172          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;173          {
;;;174            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;175          } // template<typename Type> Result Add(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;176    
;;;177          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;178          {
;;;179            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;180          }
;;;181    
;;;182          template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;183          {
;;;184            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;185          }
;;;186    
;;;187          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;188          {
;;;189            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;190          } // template<typename Type> Result Subtract(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;191    
;;;192          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;193          {
;;;194            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;195          }
;;;196    
;;;197          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;198          {
;;;199            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;200          }
;;;201    
;;;202          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;203          {
;;;204            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;205          } // template<typename Type> Result DotMultiply(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;206    
;;;207          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;208          {
;;;209            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;210          }
;;;211    
;;;212          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;213          {
;;;214            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;215          }
;;;216    
;;;217          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;218          {
;;;219            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;220          } // template<typename Type> Result DotDivide(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;221    
;;;222          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;223          {
;;;224            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;225          }
;;;226    
;;;227          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;228          {
;;;229            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;230          }
;;;231    
;;;232          template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;233          {
;;;234            return Elementwise::ApplyOperation<InType, Elementwise::Exp<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;235          } // template<typename Type> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;236    
;;;237          template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;238          {
;;;239            return Elementwise::ApplyOperation<InType, Elementwise::Sqrt<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;240          }
;;;241    
;;;242          template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;243          {
;;;244            const s32 in1Height = in1.get_size(0);
;;;245            const s32 in1Width = in1.get_size(1);
;;;246    
;;;247            const s32 in2Height = in2.get_size(0);
;;;248            const s32 in2Width = in2.get_size(1);
;;;249            const s32 in2Stride = in2.get_stride();
;;;250    
;;;251            AnkiConditionalErrorAndReturnValue(in1Width == in2Height,
;;;252              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;253    
;;;254            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2Width, out),
;;;255              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;256    
;;;257            for(s32 y1=0; y1<in1Height; y1++) {
;;;258              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;259              OutType * restrict pOut = out.Pointer(y1, 0);
;;;260    
;;;261              for(s32 x2=0; x2<in2Width; x2++) {
;;;262                const u8 * restrict pIn2 = reinterpret_cast<const u8*>(in2.Pointer(0, x2));
;;;263    
;;;264                OutType accumulator = 0;
;;;265    
;;;266                s32 y2;
;;;267                for(y2=0; y2<in2Height-3; y2+=4) {
;;;268                  const InType in1_0 = pIn1[y2];
;;;269                  const InType in1_1 = pIn1[y2+1];
;;;270                  const InType in1_2 = pIn1[y2+2];
;;;271                  const InType in1_3 = pIn1[y2+3];
;;;272    
;;;273                  const InType in2_0 = *reinterpret_cast<const InType*>(pIn2);
;;;274                  const InType in2_1 = *reinterpret_cast<const InType*>(pIn2 + in2Stride);
;;;275                  const InType in2_2 = *reinterpret_cast<const InType*>(pIn2 + 2*in2Stride);
;;;276                  const InType in2_3 = *reinterpret_cast<const InType*>(pIn2 + 3*in2Stride);
;;;277    
;;;278                  accumulator +=
;;;279                    in1_0 * in2_0 +
;;;280                    in1_1 * in2_1 +
;;;281                    in1_2 * in2_2 +
;;;282                    in1_3 * in2_3;
;;;283    
;;;284                  pIn2 += 4*in2Stride;
;;;285                }
;;;286    
;;;287                for(; y2<in2Height; y2++) {
;;;288                  accumulator += pIn1[y2] * (*reinterpret_cast<const InType*>(pIn2));
;;;289    
;;;290                  pIn2 += in2Stride;
;;;291                }
;;;292    
;;;293                pOut[x2] = accumulator;
;;;294              }
;;;295            }
;;;296    
;;;297            return RESULT_OK;
;;;298          } // template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;299    
;;;300          template<typename InType, typename OutType> NO_INLINE Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;301          {
;;;302            const s32 in1Height = in1.get_size(0);
;;;303            const s32 in1Width = in1.get_size(1);
;;;304    
;;;305            const s32 in2TransposedHeight = in2Transposed.get_size(0);
;;;306            const s32 in2TransposedWidth = in2Transposed.get_size(1);
;;;307    
;;;308            AnkiConditionalErrorAndReturnValue(in1Width == in2TransposedWidth,
;;;309              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;310    
;;;311            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2TransposedHeight, out),
;;;312              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;313    
;;;314            for(s32 y1=0; y1<in1Height; y1++)
;;;315            {
;;;316              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;317    
;;;318              for(s32 y2=0; y2<in2TransposedHeight; y2++) {
;;;319                const InType * restrict pIn2 = in2Transposed.Pointer(y2, 0);
;;;320    
;;;321                OutType accumulator = 0;
;;;322    
;;;323                s32 x;
;;;324                for(x=0; x<in2TransposedWidth-3; x+=4) {
;;;325                  const InType in1_0 = pIn1[x];
;;;326                  const InType in1_1 = pIn1[x+1];
;;;327                  const InType in1_2 = pIn1[x+2];
;;;328                  const InType in1_3 = pIn1[x+3];
;;;329    
;;;330                  const InType in2_0 = pIn2[x];
;;;331                  const InType in2_1 = pIn2[x+1];
;;;332                  const InType in2_2 = pIn2[x+2];
;;;333                  const InType in2_3 = pIn2[x+3];
;;;334    
;;;335                  accumulator +=
;;;336                    in1_0 * in2_0 +
;;;337                    in1_1 * in2_1 +
;;;338                    in1_2 * in2_2 +
;;;339                    in1_3 * in2_3;
;;;340                }
;;;341    
;;;342                for(; x<in2TransposedWidth; x++) {
;;;343                  accumulator += pIn1[x] * pIn2[x];
;;;344                }
;;;345    
;;;346                *out.Pointer(y1, y2) = accumulator;
;;;347              }
;;;348            }
;;;349    
;;;350            return RESULT_OK;
;;;351          } // template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;352    
;;;353          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;354            Array<Type> &A_L,       //!< Input A Matrix and Output lower-triangular L matrix
;;;355            Array<Type> &Bt_Xt,     //!< Input B-transpose matrix and Output X-transpose solution
;;;356            bool realCholesky,      //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;357            bool &numericalFailure  //!< If true, the solver failed because of numerical instability
;;;358            )
;;;359          {
;;;360            const s32 matrixHeight = A_L.get_size(0);
;;;361            const s32 numSamples = Bt_Xt.get_size(0);
;;;362    
;;;363            numericalFailure = false;
;;;364    
;;;365            AnkiConditionalErrorAndReturnValue(AreValid(A_L, Bt_Xt),
;;;366              RESULT_FAIL_INVALID_OBJECT, "CholeskyDecomposition", "Invalid objects");
;;;367    
;;;368            AnkiConditionalErrorAndReturnValue(matrixHeight == A_L.get_size(1),
;;;369              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "A_L is not square");
;;;370    
;;;371            AnkiConditionalErrorAndReturnValue(Bt_Xt.get_size(1) == matrixHeight,
;;;372              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "Xt and Bt are the wrong sizes");
;;;373    
;;;374            // TODO: check if symmetric and positive-definite
;;;375    
;;;376            const Type minStableValue = Anki::Embedded::Flags::numeric_limits<Type>::epsilon();
;;;377    
;;;378            for(s32 i = 0; i < matrixHeight; i++) {
;;;379              // First, compute the non-diagonal values
;;;380              // This uses the results from the diagonal inverse computation from previous iterations of i
;;;381              Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;382    
;;;383              for(s32 j = 0; j < i; j++) {
;;;384                Type * restrict pAL_yj = A_L.Pointer(j, 0);
;;;385    
;;;386                Type sum = pAL_yi[j];
;;;387                for(s32 k = 0; k < j; k++) {
;;;388                  const Type value1 = pAL_yi[k];
;;;389                  const Type value2 = pAL_yj[k];
;;;390                  sum -= value1*value2;
;;;391                }
;;;392    
;;;393                pAL_yi[j] = sum*pAL_yj[j];
;;;394              } // for(s32 j = 0; j < i; j++)
;;;395    
;;;396              // Second, compute the inverse of the diagonal
;;;397              {
;;;398                Type sum = pAL_yi[i];
;;;399                for(s32 k = 0; k < i; k++) {
;;;400                  const Type value = pAL_yi[k];
;;;401                  sum -= value*value;
;;;402                }
;;;403    
;;;404                if(sum < minStableValue) {
;;;405                  numericalFailure = true;
;;;406                  return RESULT_OK;
;;;407                }
;;;408    
;;;409                // TODO: change this f32 square root to f64 if Type==f64
;;;410                const Type sumRoot = static_cast<Type>(sqrtf(static_cast<f32>(sum)));
;;;411                pAL_yi[i] = static_cast<Type>(1) / sumRoot;
;;;412              }
;;;413            } // for(s32 i = 0; i < m; i++)
;;;414    
;;;415            // Solve L*y = b via forward substitution
;;;416            for(s32 i = 0; i < matrixHeight; i++) {
;;;417              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;418              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;419    
;;;420              for(s32 j = 0; j < numSamples; j++) {
;;;421                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;422    
;;;423                Type sum = pBX_yj[i];
;;;424                for(s32 k = 0; k < i; k++) {
;;;425                  const Type value1 = pAL_yi[k];
;;;426                  const Type value2 = pBX_yj[k];
;;;427                  sum -= value1*value2;
;;;428                }
;;;429    
;;;430                pBX_yj[i] = sum*pAL_yi[i];
;;;431              }
;;;432            }
;;;433    
;;;434            // Solve L'*X = Y via back substitution
;;;435            for(s32 i = matrixHeight-1; i >= 0; i--) {
;;;436              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;437              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;438    
;;;439              for(s32 j = 0; j < numSamples; j++) {
;;;440                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;441    
;;;442                Type sum = pBX_yj[i];
;;;443                for(s32 k = matrixHeight-1; k > i; k-- ) {
;;;444                  const Type value1 = A_L[k][i];
;;;445                  const Type value2 = pBX_yj[k];
;;;446                  sum -= value1*value2;
;;;447                }
;;;448    
;;;449                pBX_yj[i] = sum*pAL_yi[i];
;;;450              }
;;;451            }
;;;452    
;;;453            if(realCholesky) {
;;;454              // Invert the diagonal values of L, and set upper triangular to zero
;;;455              for(s32 i = 0; i < matrixHeight; i++) {
;;;456                Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;457    
;;;458                pAL_yi[i] = static_cast<Type>(1) / pAL_yi[i];
;;;459    
;;;460                for(s32 j = i+1; j < matrixHeight; j++) {
;;;461                  pAL_yi[j] = 0;
;;;462                }
;;;463              }
;;;464            }
;;;465    
;;;466            return RESULT_OK;
;;;467          } // SolveLeastSquaresWithCholesky()
;;;468    
;;;469          template<typename Type> NO_INLINE Result EstimateHomography(
;;;470            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;471            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;472            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;473            bool &numericalFailure, //!< Did the homography solver fail?
;;;474            MemoryStack scratch //!< Scratch memory
;;;475            )
;;;476          {
;;;477            const Type MAX_SOLVE_DISTANCE = static_cast<Type>(0.1);
;;;478    
;;;479            //BeginBenchmark("EstimateHomography_init");
;;;480    
;;;481            const s32 numPoints = originalPoints.get_size();
;;;482    
;;;483            AnkiConditionalErrorAndReturnValue(AreValid(originalPoints, transformedPoints, homography, scratch),
;;;484              RESULT_FAIL_INVALID_OBJECT, "EstimateHomography", "Invalid objects");
;;;485    
;;;486            AnkiConditionalErrorAndReturnValue(transformedPoints.get_size() == numPoints && numPoints >= 4,
;;;487              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "originalPoints and transformedPoints must be the same size, and have at least four points apiece.");
;;;488    
;;;489            AnkiConditionalErrorAndReturnValue(AreEqualSize(3, 3, homography),
;;;490              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "homography must be 3x3");
;;;491    
;;;492            homography.SetZero();
;;;493            homography[0][0] = 1;
;;;494            homography[1][1] = 1;
;;;495            homography[2][2] = 1;
;;;496    
;;;497            Array<Type> A(8, 2*numPoints, scratch);
;;;498            Array<Type> bt(1, 2*numPoints, scratch);
;;;499    
;;;500            const Point<Type> * const pOriginalPoints = originalPoints.Pointer(0);
;;;501            const Point<Type> * const pTransformedPoints = transformedPoints.Pointer(0);
;;;502    
;;;503            Type * restrict pBt = bt.Pointer(0,0);
;;;504    
;;;505            //EndBenchmark("EstimateHomography_init");
;;;506    
;;;507            //BeginBenchmark("EstimateHomography_a&b");
;;;508    
;;;509            for(s32 i=0; i<numPoints; i++) {
;;;510              Type * restrict A_y1 = A.Pointer(2*i, 0);
;;;511              Type * restrict A_y2 = A.Pointer(2*i + 1, 0);
;;;512    
;;;513              const Type xi = pOriginalPoints[i].x;
;;;514              const Type yi = pOriginalPoints[i].y;
;;;515    
;;;516              const Type xp = pTransformedPoints[i].x;
;;;517              const Type yp = pTransformedPoints[i].y;
;;;518    
;;;519              A_y1[0] = 0;  A_y1[1] = 0;  A_y1[2] = 0; A_y1[3] = -xi; A_y1[4] = -yi; A_y1[5] = -1; A_y1[6] = xi*yp;  A_y1[7] = yi*yp;
;;;520              A_y2[0] = xi; A_y2[1] = yi; A_y2[2] = 1; A_y2[3] = 0;   A_y2[4] = 0;   A_y2[5] = 0;  A_y2[6] = -xi*xp; A_y2[7] = -yi*xp;
;;;521    
;;;522              pBt[2*i] = -yp;
;;;523              pBt[2*i + 1] = xp;
;;;524            }
;;;525    
;;;526            //EndBenchmark("EstimateHomography_a&b");
;;;527    
;;;528            //BeginBenchmark("EstimateHomography_At");
;;;529    
;;;530            Array<Type> At(2*numPoints, 8, scratch);
;;;531    
;;;532            Matrix::Transpose(A, At);
;;;533    
;;;534            //EndBenchmark("EstimateHomography_At");
;;;535    
;;;536            //BeginBenchmark("EstimateHomography_AtA");
;;;537    
;;;538            Array<Type> AtA(8, 8, scratch, Flags::Buffer(false,false,false));
;;;539            Array<Type> Atb(8, 1, scratch, Flags::Buffer(false,false,false));
;;;540    
;;;541            Matrix::Multiply(At, A, AtA);
;;;542    
;;;543            //EndBenchmark("EstimateHomography_AtA");
;;;544    
;;;545            //BeginBenchmark("EstimateHomography_Atb");
;;;546    
;;;547            Matrix::MultiplyTranspose(At, bt, Atb);
;;;548    
;;;549            //EndBenchmark("EstimateHomography_Atb");
;;;550    
;;;551            //BeginBenchmark("EstimateHomography_transposeAtb");
;;;552    
;;;553            Array<Type> Atbt(1, 8, scratch);
;;;554    
;;;555            Matrix::Transpose(Atb, Atbt);
;;;556    
;;;557            //EndBenchmark("EstimateHomography_transposeAtb");
;;;558    
;;;559            //BeginBenchmark("EstimateHomography_cholesky");
;;;560    
;;;561            const Result choleskyResult = SolveLeastSquaresWithCholesky(AtA, Atbt, false, numericalFailure);
;;;562    
;;;563            AnkiConditionalErrorAndReturnValue(choleskyResult == RESULT_OK,
;;;564              choleskyResult, "EstimateHomography", "SolveLeastSquaresWithCholesky failed");
;;;565    
;;;566            if(numericalFailure){
;;;567              AnkiWarn("EstimateHomography", "numericalFailure");
;;;568              return RESULT_OK;
;;;569            }
;;;570    
;;;571            Type * restrict pAtbt = Atbt.Pointer(0,0);
;;;572    
;;;573            homography[0][0] = pAtbt[0]; homography[0][1] = pAtbt[1]; homography[0][2] = pAtbt[2];
;;;574            homography[1][0] = pAtbt[3]; homography[1][1] = pAtbt[4]; homography[1][2] = pAtbt[5];
;;;575            homography[2][0] = pAtbt[6]; homography[2][1] = pAtbt[7]; homography[2][2] = static_cast<Type>(1);
;;;576    
;;;577            // Check that the solution is fairly close
;;;578            // TODO: make work for numPoints != 4
;;;579            if(numPoints == 4) {
;;;580              Array<Type> point1(3,1,scratch);
;;;581              Array<Type> point1Warped(3,1,scratch);
;;;582              for(s32 iPoint=0; iPoint<numPoints; iPoint++) {
;;;583                point1[0][0] = originalPoints[iPoint].x;
;;;584                point1[1][0] = originalPoints[iPoint].y;
;;;585                point1[2][0] = 1;
;;;586    
;;;587                Matrix::Multiply(homography, point1, point1Warped);
;;;588                point1Warped[0][0] /= point1Warped[2][0];
;;;589                point1Warped[1][0] /= point1Warped[2][0];
;;;590    
;;;591                const Type distance = sqrtf(powf(static_cast<f32>(transformedPoints[iPoint].x) - static_cast<f32>(point1Warped[0][0]), 2.0f) + powf(static_cast<f32>(transformedPoints[iPoint].y) - static_cast<f32>(point1Warped[1][0]), 2.0f));
;;;592    
;;;593                if(distance > MAX_SOLVE_DISTANCE) {
;;;594                  AnkiWarn("EstimateHomography", "Poor solution precision");
;;;595    
;;;596                  numericalFailure = true;
;;;597    
;;;598                  homography.SetZero();
;;;599                  homography[0][0] = 1;
;;;600                  homography[1][1] = 1;
;;;601                  homography[2][2] = 1;
;;;602    
;;;603                  return RESULT_OK;
;;;604                }
;;;605              }
;;;606            }
;;;607            //EndBenchmark("EstimateHomography_cholesky");
;;;608    
;;;609            return RESULT_OK;
;;;610          } // EstimateHomography()
;;;611    
;;;612          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;613          {
;;;614            const s32 inHeight = in.get_size(0);
;;;615            const s32 inWidth = in.get_size(1);
;;;616    
;;;617            const s32 outHeight = out.get_size(0);
;;;618            const s32 outWidth = out.get_size(1);
;;;619    
;;;620            AnkiConditionalErrorAndReturnValue((inHeight*inWidth) == (outHeight*outWidth),
;;;621              RESULT_FAIL_INVALID_SIZE, "Reshape", "Input and Output matrices are incompatible sizes");
;;;622    
;;;623            s32 inIndexY = 0;
;;;624            s32 inIndexX = 0;
;;;625    
;;;626            if(isColumnMajor) {
;;;627              for(s32 y = 0; y < outHeight; y++)
;;;628              {
;;;629                OutType * const pOut = out.Pointer(y,0);
;;;630    
;;;631                for(s32 x = 0; x < outWidth; x++) {
;;;632                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;633    
;;;634                  pOut[x] = static_cast<OutType>(curIn);
;;;635    
;;;636                  inIndexY++;
;;;637                  if(inIndexY >= inHeight) {
;;;638                    inIndexY = 0;
;;;639                    inIndexX++;
;;;640                  }
;;;641                }
;;;642              }
;;;643            } else { // if(isColumnMajor)
;;;644              for(s32 y = 0; y < outHeight; y++)
;;;645              {
;;;646                OutType * const pOut = out.Pointer(y,0);
;;;647    
;;;648                for(s32 x = 0; x < outWidth; x++) {
;;;649                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;650    
;;;651                  pOut[x] = static_cast<OutType>(curIn);
;;;652    
;;;653                  inIndexX++;
;;;654                  if(inIndexX >= inWidth) {
;;;655                    inIndexX = 0;
;;;656                    inIndexY++;
;;;657                  }
;;;658                }
;;;659              }
;;;660            } // if(isColumnMajor) ... else
;;;661    
;;;662            return RESULT_OK;
;;;663          } // Reshape()
;;;664    
;;;665          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory)
;;;666          {
;;;667            Array<OutType> out(newHeight, newWidth, memory);
;;;668    
;;;669            Reshape<InType, OutType>(isColumnMajor, in, out);
;;;670    
;;;671            return out;
;;;672          }
;;;673    
;;;674          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;675          {
;;;676            AnkiConditionalErrorAndReturnValue(out.get_size(0) == 1,
;;;677              RESULT_FAIL_INVALID_SIZE, "Vectorize", "Output is not 1xN");
;;;678    
;;;679            return Reshape<InType, OutType>(isColumnMajor, in, out);
;;;680          }
;;;681    
;;;682          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory)
;;;683          {
;;;684            const s32 inHeight = in.get_size(0);
;;;685            const s32 inWidth = in.get_size(1);
;;;686    
;;;687            Array<OutType> out(1, inHeight*inWidth, memory);
;;;688    
;;;689            Vectorize<InType, OutType>(isColumnMajor, in, out);
;;;690    
;;;691            return out;
;;;692          }
;;;693    
;;;694          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out)
;;;695          {
;;;696            const s32 inHeight = in.get_size(0);
;;;697            const s32 inWidth = in.get_size(1);
;;;698    
;;;699            const s32 outStride = out.get_stride();
;;;700    
;;;701            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;702              RESULT_FAIL_INVALID_OBJECT, "Transpose", "Invalid objects");
;;;703    
;;;704            AnkiConditionalErrorAndReturnValue(AreEqualSize(in.get_size(1), in.get_size(0), out),
;;;705              RESULT_FAIL_INVALID_SIZE, "Transpose", "out is not the correct size");
;;;706    
;;;707            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;708              RESULT_FAIL_ALIASED_MEMORY, "Transpose", "in and out cannot be the same array");
;;;709    
;;;710            for(s32 yIn=0; yIn<inHeight; yIn++) {
;;;711              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;712              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0,yIn));
;;;713    
;;;714              s32 xIn;
;;;715              s32 outOffset0 = 0;
;;;716    
;;;717              for(xIn=0; xIn<inWidth-1; xIn+=2) {
;;;718                const InType in0 = pIn[xIn];
;;;719                const InType in1 = pIn[xIn+1];
;;;720    
;;;721                const s32 outOffset1 = outOffset0 + outStride;
;;;722    
;;;723                *reinterpret_cast<OutType*>(pOut + outOffset0) = static_cast<OutType>(in0);
;;;724                *reinterpret_cast<OutType*>(pOut + outOffset1) = static_cast<OutType>(in1);
;;;725    
;;;726                outOffset0 += 2*outStride;
;;;727              }
;;;728    
;;;729              for(; xIn<inWidth; xIn++) {
;;;730                *out.Pointer(xIn,yIn) = static_cast<OutType>(pIn[xIn]);
;;;731              }
;;;732            }
;;;733    
;;;734            return RESULT_OK;
;;;735          } // Transpose()
;;;736    
;;;737          template<typename InType, typename OutType> Result Rotate90(const Array<InType> &in, Array<OutType> &out)
;;;738          {
;;;739            const s32 arrWidth = in.get_size(1);
;;;740    
;;;741            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;742              RESULT_FAIL_INVALID_OBJECT, "Rotate90", "Invalid objects");
;;;743    
;;;744            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;745              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;746    
;;;747            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;748              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;749    
;;;750            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;751              RESULT_FAIL_ALIASED_MEMORY, "Rotate90", "in and out cannot be the same array");
;;;752    
;;;753            const s32 outStride = out.get_stride();
;;;754    
;;;755            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;756              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;757              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0, arrWidth-yIn-1));
;;;758    
;;;759              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;760                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;761    
;;;762                pOut += outStride;
;;;763              }
;;;764            }
;;;765    
;;;766            return RESULT_OK;
;;;767          } // Rotate90()
;;;768    
;;;769          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out)
;;;770          {
;;;771            const s32 arrWidth = in.get_size(1);
;;;772    
;;;773            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;774              RESULT_FAIL_INVALID_OBJECT, "Rotate180", "Invalid objects");
;;;775    
;;;776            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;777              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;778    
;;;779            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;780              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;781    
;;;782            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;783              RESULT_FAIL_ALIASED_MEMORY, "Rotate180", "in and out cannot be the same array");
;;;784    
;;;785            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;786              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;787              OutType * restrict pOut = out.Pointer(arrWidth-yIn-1, 0);
;;;788    
;;;789              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;790                pOut[arrWidth-xIn-1] = static_cast<OutType>(pIn[xIn]);
;;;791              }
;;;792            }
;;;793    
;;;794            return RESULT_OK;
;;;795          } // Rotate180()
;;;796    
;;;797          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out)
;;;798          {
;;;799            const s32 arrWidth = in.get_size(1);
;;;800    
;;;801            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;802              RESULT_FAIL_INVALID_OBJECT, "Rotate270", "Invalid objects");
;;;803    
;;;804            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;805              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;806    
;;;807            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;808              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;809    
;;;810            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;811              RESULT_FAIL_ALIASED_MEMORY, "Rotate270", "in and out cannot be the same array");
;;;812    
;;;813            const s32 outStride = out.get_stride();
;;;814    
;;;815            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;816              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;817              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(arrWidth-1, yIn));
;;;818    
;;;819              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;820                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;821    
;;;822                pOut -= outStride;
;;;823              }
;;;824            }
;;;825    
;;;826            return RESULT_OK;
;;;827          } // Rotate270()
;;;828    
;;;829          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;830          {
;;;831            const s32 arrWidth = arr.get_size(1);
;;;832    
;;;833            for(s32 x=0; x<arrWidth; x++) {
;;;834              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;835                const Type valueToInsert = arr[y][x];
;;;836    
;;;837                s32 holePosition = y;
;;;838    
;;;839                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;840                  arr[holePosition][x] = arr[holePosition-1][x];
;;;841                  holePosition--;
;;;842                }
;;;843    
;;;844                arr[holePosition][x] = valueToInsert;
;;;845              }
;;;846            } // for(s32 x=0; x<arrWidth; x++)
;;;847          } // InsertionSort_sortAscendingDimension0()
;;;848    
;;;849          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;850          {
;;;851            const s32 arrWidth = arr.get_size(1);
;;;852    
;;;853            for(s32 x=0; x<arrWidth; x++) {
;;;854              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;855                const Type valueToInsert = arr[y][x];
;;;856    
;;;857                s32 holePosition = y;
;;;858    
;;;859                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;860                  arr[holePosition][x] = arr[holePosition-1][x];
;;;861                  holePosition--;
;;;862                }
;;;863    
;;;864                arr[holePosition][x] = valueToInsert;
;;;865              }
;;;866            } // for(s32 x=0; x<arrWidth; x++)
;;;867          } // InsertionSort_sortDescendingDimension0
;;;868    
;;;869          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;870          {
;;;871            const s32 arrHeight = arr.get_size(0);
;;;872    
;;;873            for(s32 y=0; y<arrHeight; y++) {
;;;874              Type * const pArr = arr[y];
;;;875    
;;;876              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;877                const Type valueToInsert = pArr[x];
;;;878    
;;;879                s32 holePosition = x;
;;;880    
;;;881                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;882                  pArr[holePosition] = pArr[holePosition-1];
;;;883                  holePosition--;
;;;884                }
;;;885    
;;;886                pArr[holePosition] = valueToInsert;
;;;887              }
;;;888            } // for(s32 x=0; x<arrWidth; x++)
;;;889          } // InsertionSort_sortAscendingDimension1()
;;;890    
;;;891          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;892          {
;;;893            const s32 arrHeight = arr.get_size(0);
;;;894    
;;;895            for(s32 y=0; y<arrHeight; y++) {
;;;896              Type * const pArr = arr[y];
;;;897    
;;;898              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;899                const Type valueToInsert = pArr[x];
;;;900    
;;;901                s32 holePosition = x;
;;;902    
;;;903                while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;904                  pArr[holePosition] = pArr[holePosition-1];
;;;905                  holePosition--;
;;;906                }
;;;907    
;;;908                pArr[holePosition] = valueToInsert;
;;;909              }
;;;910            } // for(s32 x=0; x<arrWidth; x++)
;;;911          } // InsertionSort_sortAscendingDimension1()
;;;912    
;;;913          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;914          {
;;;915            const s32 arrWidth = arr.get_size(1);
;;;916    
;;;917            for(s32 x=0; x<arrWidth; x++) {
;;;918              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;919                const Type valueToInsert = arr[y][x];
;;;920                const s32 indexToInsert = indexes[y][x];
;;;921    
;;;922                s32 holePosition = y;
;;;923    
;;;924                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;925                  arr[holePosition][x] = arr[holePosition-1][x];
;;;926                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;927                  holePosition--;
;;;928                }
;;;929    
;;;930                arr[holePosition][x] = valueToInsert;
;;;931                indexes[holePosition][x] = indexToInsert;
;;;932              }
;;;933            } // for(s32 x=0; x<arrWidth; x++)
;;;934          } // InsertionSort_sortAscendingDimension0()
;;;935    
;;;936          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;937          {
;;;938            const s32 arrWidth = arr.get_size(1);
;;;939    
;;;940            for(s32 x=0; x<arrWidth; x++) {
;;;941              indexes[0][x] = 0;
;;;942    
;;;943              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;944                const Type valueToInsert = arr[y][x];
;;;945                const s32 indexToInsert = indexes[y][x];
;;;946    
;;;947                s32 holePosition = y;
;;;948    
;;;949                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;950                  arr[holePosition][x] = arr[holePosition-1][x];
;;;951                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;952                  holePosition--;
;;;953                }
;;;954    
;;;955                arr[holePosition][x] = valueToInsert;
;;;956                indexes[holePosition][x] = indexToInsert;
;;;957              }
;;;958            } // for(s32 x=0; x<arrWidth; x++)
;;;959          } // InsertionSort_sortDescendingDimension0()
;;;960    
;;;961          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;962          {
;;;963            const s32 arrHeight = arr.get_size(0);
;;;964    
;;;965            for(s32 y=0; y<arrHeight; y++) {
;;;966              Type * const pArr = arr[y];
;;;967              s32 * const pIndexes = indexes[y];
;;;968    
;;;969              pIndexes[0] = 0;
;;;970    
;;;971              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;972                const Type valueToInsert = pArr[x];
;;;973                const s32 indexToInsert = pIndexes[x];
;;;974    
;;;975                s32 holePosition = x;
;;;976    
;;;977                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;978                  pArr[holePosition] = pArr[holePosition-1];
;;;979                  pIndexes[holePosition] = pIndexes[holePosition-1];
;;;980                  holePosition--;
;;;981                }
;;;982    
;;;983                pArr[holePosition] = valueToInsert;
;;;984                pIndexes[holePosition] = indexToInsert;
;;;985              }
;;;986            } // for(s32 x=0; x<arrWidth; x++)
;;;987          } // InsertionSort_sortAscendingDimension1()
;;;988    
;;;989          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;990          {
;;;991            const s32 arrHeight = arr.get_size(0);
;;;992    
;;;993            for(s32 y=0; y<arrHeight; y++) {
;;;994              Type * const pArr = arr[y];
;;;995              s32 * const pIndexes = indexes[y];
;;;996    
;;;997              pIndexes[0] = 0;
;;;998    
;;;999              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;1000               const Type valueToInsert = pArr[x];
;;;1001               const s32 indexToInsert = pIndexes[x];
;;;1002   
;;;1003               s32 holePosition = x;
;;;1004   
;;;1005               while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;1006                 pArr[holePosition] = pArr[holePosition-1];
;;;1007                 pIndexes[holePosition] = pIndexes[holePosition-1];
;;;1008                 holePosition--;
;;;1009               }
;;;1010   
;;;1011               pArr[holePosition] = valueToInsert;
;;;1012               pIndexes[holePosition] = indexToInsert;
;;;1013             }
;;;1014           } // for(s32 x=0; x<arrWidth; x++)
;;;1015         } // InsertionSort_sortDescendingDimension1()
;;;1016   
;;;1017         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1018         {
;;;1019           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1020             return;
;;;1021           }
;;;1022   
;;;1023           // Select the median value of the first, middle, and last elements as the pivot
;;;1024           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1025   
;;;1026           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1027   
;;;1028           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1029             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1030   
;;;1031           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1032             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1033   
;;;1034           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x))
;;;1035             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1036   
;;;1037           // Search from the beginning to before the moved pivot
;;;1038           s32 i = trueMinIndex;
;;;1039           s32 j = trueMaxIndex - 2;
;;;1040   
;;;1041           if(i >= j) {
;;;1042             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1043             // NOTE: This really means your insertionSortSize value is too low
;;;1044             return;
;;;1045           }
;;;1046   
;;;1047           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1048   
;;;1049           const Type pivot = *arr.Pointer(midIndex, x);
;;;1050   
;;;1051           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1052   
;;;1053           // Main partitioning loop
;;;1054           while(true) {
;;;1055             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1056             while(*arr.Pointer(i,x) < pivot) {
;;;1057               i++;
;;;1058             }
;;;1059   
;;;1060             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1061             while(*arr.Pointer(j,x) > pivot) {
;;;1062               j--;
;;;1063             }
;;;1064   
;;;1065             if(i < j) {
;;;1066               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1067               i++;
;;;1068               j--;
;;;1069             } else {
;;;1070               break;
;;;1071             }
;;;1072           }
;;;1073   
;;;1074           // Replace the pivot
;;;1075           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1076   
;;;1077           // Recurse
;;;1078           QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1079   
;;;1080           QuickSort_sortAscendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1081         } // QuickSort_sortAscendingDimension0
;;;1082   
;;;1083         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1084         {
;;;1085           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1086             return;
;;;1087           }
;;;1088   
;;;1089           // Select the median value of the first, middle, and last elements as the pivot
;;;1090           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1091   
;;;1092           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1093   
;;;1094           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1095             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1096   
;;;1097           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1098             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1099   
;;;1100           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x))
;;;1101             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1102   
;;;1103           // Search from the beginning to before the moved pivot
;;;1104           s32 i = trueMinIndex;
;;;1105           s32 j = trueMaxIndex - 2;
;;;1106   
;;;1107           if(i >= j) {
;;;1108             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1109             // NOTE: This really means your insertionSortSize value is too low
;;;1110             return;
;;;1111           }
;;;1112   
;;;1113           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1114   
;;;1115           const Type pivot = *arr.Pointer(midIndex, x);
;;;1116   
;;;1117           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1118   
;;;1119           // Main partitioning loop
;;;1120           while(true) {
;;;1121             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1122             while(*arr.Pointer(i,x) > pivot) {
;;;1123               i++;
;;;1124             }
;;;1125   
;;;1126             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1127             while(*arr.Pointer(j,x) < pivot) {
;;;1128               j--;
;;;1129             }
;;;1130   
;;;1131             if(i < j) {
;;;1132               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1133               i++;
;;;1134               j--;
;;;1135             } else {
;;;1136               break;
;;;1137             }
;;;1138           }
;;;1139   
;;;1140           // Replace the pivot
;;;1141           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1142   
;;;1143           // Recurse
;;;1144           QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1145   
;;;1146           QuickSort_sortDescendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1147         } // QuickSort_sortDescendingDimension0
;;;1148   
;;;1149         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1150         {
;;;1151           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1152             return;
;;;1153           }
;;;1154   
;;;1155           Type * restrict pArr = arr.Pointer(y,0);
;;;1156   
;;;1157           // Select the median value of the first, middle, and last elements as the pivot
;;;1158           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1159   
;;;1160           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1161   
;;;1162           if(pArr[midIndex] < pArr[trueMinIndex])
;;;1163             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1164   
;;;1165           if(pArr[trueMaxIndex] < pArr[trueMinIndex])
;;;1166             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1167   
;;;1168           if(pArr[trueMaxIndex] < pArr[midIndex])
;;;1169             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1170   
;;;1171           // Search from the beginning to before the moved pivot
;;;1172           s32 i = trueMinIndex;
;;;1173           s32 j = trueMaxIndex - 2;
;;;1174   
;;;1175           if(i >= j) {
;;;1176             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1177             // NOTE: This really means your insertionSortSize value is too low
;;;1178             return;
;;;1179           }
;;;1180   
;;;1181           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1182   
;;;1183           const Type pivot = pArr[midIndex];
;;;1184   
;;;1185           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1186   
;;;1187           // Main partitioning loop
;;;1188           while(true) {
;;;1189             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1190             while(pArr[i] < pivot) {
;;;1191               i++;
;;;1192             }
;;;1193   
;;;1194             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1195             while(pArr[j] > pivot) {
;;;1196               j--;
;;;1197             }
;;;1198   
;;;1199             if(i < j) {
;;;1200               Swap<Type>(pArr[i], pArr[j]);
;;;1201               i++;
;;;1202               j--;
;;;1203             } else {
;;;1204               break;
;;;1205             }
;;;1206           }
;;;1207   
;;;1208           // Replace the pivot
;;;1209           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1210   
;;;1211           // Recurse
;;;1212           QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1213   
;;;1214           QuickSort_sortAscendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1215         } // QuickSort_sortAscendingDimension1
;;;1216   
;;;1217         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1218         {
;;;1219           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1220             return;
;;;1221           }
;;;1222   
;;;1223           Type * restrict pArr = arr.Pointer(y,0);
;;;1224   
;;;1225           // Select the median value of the first, middle, and last elements as the pivot
;;;1226           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1227   
;;;1228           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1229   
;;;1230           if(pArr[midIndex] < pArr[trueMaxIndex])
;;;1231             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1232   
;;;1233           if(pArr[trueMinIndex] < pArr[trueMaxIndex])
;;;1234             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1235   
;;;1236           if(pArr[trueMinIndex] < pArr[midIndex])
;;;1237             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1238   
;;;1239           // Search from the beginning to before the moved pivot
;;;1240           s32 i = trueMinIndex;
;;;1241           s32 j = trueMaxIndex - 2;
;;;1242   
;;;1243           if(i >= j) {
;;;1244             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1245             // NOTE: This really means your insertionSortSize value is too low
;;;1246             return;
;;;1247           }
;;;1248   
;;;1249           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1250   
;;;1251           const Type pivot = pArr[midIndex];
;;;1252   
;;;1253           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1254   
;;;1255           // Main partitioning loop
;;;1256           while(true) {
;;;1257             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1258             while(pArr[i] > pivot) {
;;;1259               i++;
;;;1260             }
;;;1261   
;;;1262             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1263             while(pArr[j] < pivot) {
;;;1264               j--;
;;;1265             }
;;;1266   
;;;1267             if(i < j) {
;;;1268               Swap<Type>(pArr[i], pArr[j]);
;;;1269               i++;
;;;1270               j--;
;;;1271             } else {
;;;1272               break;
;;;1273             }
;;;1274           }
;;;1275   
;;;1276           // Replace the pivot
;;;1277           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1278   
;;;1279           // Recurse
;;;1280           QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1281   
;;;1282           QuickSort_sortDescendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1283         } // QuickSort_sortDescendingDimension1
;;;1284   
;;;1285         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1286         {
;;;1287           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1288             return;
;;;1289           }
;;;1290   
;;;1291           // Select the median value of the first, middle, and last elements as the pivot
;;;1292           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1293   
;;;1294           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1295   
;;;1296           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1297             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1298             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1299           }
;;;1300   
;;;1301           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1302             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1303             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1304           }
;;;1305   
;;;1306           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1307             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1308             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(midIndex, x));
;;;1309           }
;;;1310   
;;;1311           // Search from the beginning to before the moved pivot
;;;1312           s32 i = trueMinIndex;
;;;1313           s32 j = trueMaxIndex - 2;
;;;1314   
;;;1315           if(i >= j) {
;;;1316             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1317             // NOTE: This really means your insertionSortSize value is too low
;;;1318             return;
;;;1319           }
;;;1320   
;;;1321           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1322   
;;;1323           const Type pivot = *arr.Pointer(midIndex, x);
;;;1324   
;;;1325           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1326           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1327   
;;;1328           // Main partitioning loop
;;;1329           while(true) {
;;;1330             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1331             while(*arr.Pointer(i,x) < pivot) {
;;;1332               i++;
;;;1333             }
;;;1334   
;;;1335             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1336             while(*arr.Pointer(j,x) > pivot) {
;;;1337               j--;
;;;1338             }
;;;1339   
;;;1340             if(i < j) {
;;;1341               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1342               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1343               i++;
;;;1344               j--;
;;;1345             } else {
;;;1346               break;
;;;1347             }
;;;1348           }
;;;1349   
;;;1350           // Replace the pivot
;;;1351           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1352           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1353   
;;;1354           // Recurse
;;;1355           QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1356   
;;;1357           QuickSort_sortAscendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1358         } // QuickSort_sortAscendingDimension0
;;;1359   
;;;1360         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1361         {
;;;1362           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1363             return;
;;;1364           }
;;;1365   
;;;1366           // Select the median value of the first, middle, and last elements as the pivot
;;;1367           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1368   
;;;1369           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1370   
;;;1371           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1372             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1373             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1374           }
;;;1375   
;;;1376           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1377             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1378             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1379           }
;;;1380   
;;;1381           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1382             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1383             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(midIndex, x));
;;;1384           }
;;;1385   
;;;1386           // Search from the beginning to before the moved pivot
;;;1387           s32 i = trueMinIndex;
;;;1388           s32 j = trueMaxIndex - 2;
;;;1389   
;;;1390           if(i >= j) {
;;;1391             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1392             // NOTE: This really means your insertionSortSize value is too low
;;;1393             return;
;;;1394           }
;;;1395   
;;;1396           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1397   
;;;1398           const Type pivot = *arr.Pointer(midIndex, x);
;;;1399   
;;;1400           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1401           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1402   
;;;1403           // Main partitioning loop
;;;1404           while(true) {
;;;1405             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1406             while(*arr.Pointer(i,x) > pivot) {
;;;1407               i++;
;;;1408             }
;;;1409   
;;;1410             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1411             while(*arr.Pointer(j,x) < pivot) {
;;;1412               j--;
;;;1413             }
;;;1414   
;;;1415             if(i < j) {
;;;1416               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1417               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1418               i++;
;;;1419               j--;
;;;1420             } else {
;;;1421               break;
;;;1422             }
;;;1423           }
;;;1424   
;;;1425           // Replace the pivot
;;;1426           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1427           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1428   
;;;1429           // Recurse
;;;1430           QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1431   
;;;1432           QuickSort_sortDescendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1433         } // QuickSort_sortDescendingDimension0
;;;1434   
;;;1435         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1436         {
;;;1437           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1438             return;
;;;1439           }
;;;1440   
;;;1441           Type * restrict pArr = arr.Pointer(y,0);
;;;1442           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1443   
;;;1444           // Select the median value of the first, middle, and last elements as the pivot
;;;1445           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1446   
;;;1447           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1448   
;;;1449           if(pArr[midIndex] < pArr[trueMinIndex]) {
;;;1450             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1451             Swap<s32>(pIndexes[midIndex], pIndexes[trueMinIndex]);
;;;1452           }
;;;1453   
;;;1454           if(pArr[trueMaxIndex] < pArr[trueMinIndex]) {
;;;1455             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1456             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[trueMinIndex]);
;;;1457           }
;;;1458   
;;;1459           if(pArr[trueMaxIndex] < pArr[midIndex]) {
;;;1460             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1461             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[midIndex]);
;;;1462           }
;;;1463   
;;;1464           // Search from the beginning to before the moved pivot
;;;1465           s32 i = trueMinIndex;
;;;1466           s32 j = trueMaxIndex - 2;
;;;1467   
;;;1468           if(i >= j) {
;;;1469             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1470             // NOTE: This really means your insertionSortSize value is too low
;;;1471             return;
;;;1472           }
;;;1473   
;;;1474           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1475   
;;;1476           const Type pivot = pArr[midIndex];
;;;1477   
;;;1478           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1479           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1480   
;;;1481           // Main partitioning loop
;;;1482           while(true) {
;;;1483             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1484             while(pArr[i] < pivot) {
;;;1485               i++;
;;;1486             }
;;;1487   
;;;1488             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1489             while(pArr[j] > pivot) {
;;;1490               j--;
;;;1491             }
;;;1492   
;;;1493             if(i < j) {
;;;1494               Swap<Type>(pArr[i], pArr[j]);
;;;1495               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1496               i++;
;;;1497               j--;
;;;1498             } else {
;;;1499               break;
;;;1500             }
;;;1501           }
;;;1502   
;;;1503           // Replace the pivot
;;;1504           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1505           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1506   
;;;1507           // Recurse
;;;1508           QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1509   
;;;1510           QuickSort_sortAscendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1511         } // QuickSort_sortAscendingDimension1
;;;1512   
;;;1513         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1514         {
;;;1515           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1516             return;
;;;1517           }
;;;1518   
;;;1519           Type * restrict pArr = arr.Pointer(y,0);
;;;1520           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1521   
;;;1522           // Select the median value of the first, middle, and last elements as the pivot
;;;1523           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1524   
;;;1525           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1526   
;;;1527           if(pArr[midIndex] < pArr[trueMaxIndex]) {
;;;1528             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1529             Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex]);
;;;1530           }
;;;1531   
;;;1532           if(pArr[trueMinIndex] < pArr[trueMaxIndex]) {
;;;1533             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1534             Swap<s32>(pIndexes[trueMinIndex], pIndexes[trueMaxIndex]);
;;;1535           }
;;;1536   
;;;1537           if(pArr[trueMinIndex] < pArr[midIndex]) {
;;;1538             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1539             Swap<s32>(pIndexes[trueMinIndex], pIndexes[midIndex]);
;;;1540           }
;;;1541   
;;;1542           // Search from the beginning to before the moved pivot
;;;1543           s32 i = trueMinIndex;
;;;1544           s32 j = trueMaxIndex - 2;
;;;1545   
;;;1546           if(i >= j) {
;;;1547             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1548             // NOTE: This really means your insertionSortSize value is too low
;;;1549             return;
;;;1550           }
;;;1551   
;;;1552           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1553   
;;;1554           const Type pivot = pArr[midIndex];
;;;1555   
;;;1556           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1557           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1558   
;;;1559           // Main partitioning loop
;;;1560           while(true) {
;;;1561             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1562             while(pArr[i] > pivot) {
;;;1563               i++;
;;;1564             }
;;;1565   
;;;1566             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1567             while(pArr[j] < pivot) {
;;;1568               j--;
;;;1569             }
;;;1570   
;;;1571             if(i < j) {
;;;1572               Swap<Type>(pArr[i], pArr[j]);
;;;1573               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1574               i++;
;;;1575               j--;
;;;1576             } else {
;;;1577               break;
;;;1578             }
;;;1579           }
;;;1580   
;;;1581           // Replace the pivot
;;;1582           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1583           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1584   
;;;1585           // Recurse
;;;1586           QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1587   
;;;1588           QuickSort_sortDescendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1589         } // QuickSort_sortDescendingDimension1
;;;1590   
;;;1591         template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1592         {
;;;1593           // const s32 arrHeight = arr.get_size(0);
;;;1594           // const s32 arrWidth = arr.get_size(1);
;;;1595   
;;;1596           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1597             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1598   
;;;1599           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1600             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1601   
;;;1602           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1603           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1604   
;;;1605           if(sortWhichDimension == 0) {
;;;1606             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1607             if(sortAscending) {
;;;1608               InsertionSort_sortAscendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1609             } else { // if(sortAscending)
;;;1610               InsertionSort_sortDescendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1611             } // if(sortAscending) ... else
;;;1612           } else { // sortWhichDimension == 1
;;;1613             if(sortAscending) {
;;;1614               InsertionSort_sortAscendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1615             } else { // if(sortAscending)
;;;1616               InsertionSort_sortDescendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1617             } // if(sortAscending) ... else
;;;1618           } // if(sortWhichDimension == 0) ... else
;;;1619   
;;;1620           return RESULT_OK;
;;;1621         } // InsertionSort()
;;;1622   
;;;1623         template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1624         {
;;;1625           const s32 arrHeight = arr.get_size(0);
;;;1626           const s32 arrWidth = arr.get_size(1);
;;;1627   
;;;1628           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1629             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1630   
;;;1631           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1632             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1633   
;;;1634           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1635             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1636   
;;;1637           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1638           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1639   
;;;1640           if(sortWhichDimension == 0) {
;;;1641             for(s32 y=0; y<arrHeight; y++) {
;;;1642               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1643               for(s32 x=0; x<arrWidth; x++) {
;;;1644                 pIndexes[x] = y;
;;;1645               }
;;;1646             }
;;;1647   
;;;1648             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1649             if(sortAscending) {
;;;1650               InsertionSort_sortAscendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1651             } else { // if(sortAscending)
;;;1652               InsertionSort_sortDescendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1653             } // if(sortAscending) ... else
;;;1654           } else { // sortWhichDimension == 1
;;;1655             for(s32 y=0; y<arrHeight; y++) {
;;;1656               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1657               for(s32 x=0; x<arrWidth; x++) {
;;;1658                 pIndexes[x] = x;
;;;1659               }
;;;1660             }
;;;1661   
;;;1662             if(sortAscending) {
;;;1663               InsertionSort_sortAscendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1664             } else { // if(sortAscending)
;;;1665               InsertionSort_sortDescendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1666             } // if(sortAscending) ... else
;;;1667           } // if(sortWhichDimension == 0) ... else
;;;1668   
;;;1669           return RESULT_OK;
;;;1670         } // InsertionSort()
;;;1671   
;;;1672         template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1673         {
;;;1674           const s32 arrHeight = arr.get_size(0);
;;;1675           const s32 arrWidth = arr.get_size(1);
;;;1676   
;;;1677           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1678             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1679   
;;;1680           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1681             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1682   
;;;1683           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1684             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1685   
;;;1686           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1687           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1688   
;;;1689           if(sortWhichDimension == 0) {
;;;1690             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1691             if(sortAscending) {
;;;1692               for(s32 x=0; x<arrWidth; x++) {
;;;1693                 QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1694               }
;;;1695   
;;;1696               if(insertionSortSize > 1)
;;;1697                 InsertionSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1698             } else { // if(sortAscending)
;;;1699               for(s32 x=0; x<arrWidth; x++) {
;;;1700                 QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1701               }
;;;1702   
;;;1703               if(insertionSortSize > 1)
;;;1704                 InsertionSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1705             } // if(sortAscending) ... else
;;;1706           } else { // sortWhichDimension == 1
;;;1707             if(sortAscending) {
;;;1708               for(s32 y=0; y<arrHeight; y++) {
;;;1709                 QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1710               }
;;;1711   
;;;1712               if(insertionSortSize > 1)
;;;1713                 InsertionSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1714             } else { // if(sortAscending)
;;;1715               for(s32 y=0; y<arrHeight; y++) {
;;;1716                 QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1717               }
;;;1718   
;;;1719               if(insertionSortSize > 1)
;;;1720                 InsertionSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1721             } // if(sortAscending) ... else
;;;1722           } // if(sortWhichDimension == 0) ... else
;;;1723   
;;;1724           return RESULT_OK;
;;;1725         } // QuickSort()
;;;1726   
;;;1727         template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1728         {
;;;1729           const s32 arrHeight = arr.get_size(0);
;;;1730           const s32 arrWidth = arr.get_size(1);
;;;1731   
;;;1732           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1733             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1734   
;;;1735           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1736             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1737   
;;;1738           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1739             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1740   
;;;1741           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1742             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1743   
;;;1744           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1745           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1746   
;;;1747           if(sortWhichDimension == 0) {
;;;1748             for(s32 y=0; y<arrHeight; y++) {
;;;1749               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1750               for(s32 x=0; x<arrWidth; x++) {
;;;1751                 pIndexes[x] = y;
;;;1752               }
;;;1753             }
;;;1754   
;;;1755             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1756             if(sortAscending) {
;;;1757               for(s32 x=0; x<arrWidth; x++) {
;;;1758                 QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1759               }
;;;1760   
;;;1761               if(insertionSortSize > 1)
;;;1762                 InsertionSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1763             } else { // if(sortAscending)
;;;1764               for(s32 x=0; x<arrWidth; x++) {
;;;1765                 QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1766               }
;;;1767   
;;;1768               if(insertionSortSize > 1)
;;;1769                 InsertionSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1770             } // if(sortAscending) ... else
;;;1771           } else { // sortWhichDimension == 1
;;;1772             for(s32 y=0; y<arrHeight; y++) {
;;;1773               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1774               for(s32 x=0; x<arrWidth; x++) {
;;;1775                 pIndexes[x] = x;
;;;1776               }
;;;1777             }
;;;1778   
;;;1779             if(sortAscending) {
;;;1780               for(s32 y=0; y<arrHeight; y++) {
;;;1781                 QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1782               }
;;;1783   
;;;1784               if(insertionSortSize > 1)
;;;1785                 InsertionSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1786             } else { // if(sortAscending)
;;;1787               for(s32 y=0; y<arrHeight; y++) {
;;;1788                 QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1789               }
;;;1790   
;;;1791               if(insertionSortSize > 1)
;;;1792                 InsertionSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1793             } // if(sortAscending) ... else
;;;1794           } // if(sortWhichDimension == 0) ... else
;;;1795   
;;;1796           return RESULT_OK;
;;;1797         } // QuickSort()
;;;1798   
;;;1799         template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1800         {
;;;1801           AnkiConditionalErrorAndReturnValue(arr.get_size(0) == arr.get_size(1),
;;;1802             RESULT_FAIL_INVALID_SIZE, "MakeSymmetric", "Input array must be square");
;;;1803   
;;;1804           const s32 arrHeight = arr.get_size(0);
;;;1805           for(s32 y = 0; y < arrHeight; y++)
;;;1806           {
;;;1807             const s32 x0 = lowerToUpper ? (y+1)     : 0;
;;;1808             const s32 x1 = lowerToUpper ? arrHeight : y;
;;;1809   
;;;1810             for(s32 x = x0; x < x1; x++) {
;;;1811               *arr.Pointer(y,x) = *arr.Pointer(x,y);
;;;1812             }
;;;1813           }
;;;1814   
;;;1815           return RESULT_OK;
;;;1816         } // template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1817   
;;;1818         namespace Elementwise
;;;1819         {
;;;1820           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1821           {
;;;1822             const Array<InType> &in1Array = in1.get_array();
;;;1823             const Array<InType> &in2Array = in2.get_array();
;;;1824             Array<OutType> &out1Array = out.get_array();
;;;1825   
;;;1826             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, in2Array, out1Array),
;;;1827               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1828   
;;;1829             ArraySliceLimits_in2_out1<s32> limits(
;;;1830               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1831               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1832               out.get_ySlice(), out.get_xSlice());
;;;1833   
;;;1834             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1835               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1836   
;;;1837             if(limits.isSimpleIteration) {
;;;1838               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1839   
;;;1840               for(s32 y=0; y<limits.ySize; y++) {
;;;1841                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1842                 const InType * const pIn2 = in2Array.Pointer(limits.in2Y, 0);
;;;1843                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1844   
;;;1845                 limits.OuterIncrementTop();
;;;1846   
;;;1847                 for(s32 x=0; x<limits.xSize; x++) {
;;;1848                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], pIn2[limits.in2X]);
;;;1849   
;;;1850                   limits.in1X += limits.in1_xInnerIncrement;
;;;1851                   limits.in2X += limits.in2_xInnerIncrement;
;;;1852                   limits.out1X += limits.out1_xInnerIncrement;
;;;1853                 }
;;;1854   
;;;1855                 limits.OuterIncrementBottom();
;;;1856               }
;;;1857             } else { // if(limits.isSimpleIteration)
;;;1858               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1859   
;;;1860               for(s32 y=0; y<limits.ySize; y++) {
;;;1861                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1862   
;;;1863                 limits.OuterIncrementTop();
;;;1864   
;;;1865                 for(s32 x=0; x<limits.xSize; x++) {
;;;1866                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1867                   const InType valIn2 = *in2Array.Pointer(limits.in2Y, limits.in2X);
;;;1868   
;;;1869                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, valIn2);
;;;1870   
;;;1871                   limits.in1X += limits.in1_xInnerIncrement;
;;;1872                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1873                   limits.in2X += limits.in2_xInnerIncrement;
;;;1874                   limits.in2Y += limits.in2_yInnerIncrement;
;;;1875                   limits.out1X += limits.out1_xInnerIncrement;
;;;1876                 }
;;;1877   
;;;1878                 limits.OuterIncrementBottom();
;;;1879               }
;;;1880             } //   if(limits.isSimpleIteration)  ... else
;;;1881   
;;;1882             return RESULT_OK;
;;;1883           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1884   
;;;1885           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1886           {
;;;1887             const Array<InType> &in1Array = in1.get_array();
;;;1888             Array<OutType> &out1Array = out.get_array();
;;;1889   
;;;1890             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, out1Array),
;;;1891               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1892   
;;;1893             ArraySliceLimits_in1_out1<s32> limits(
;;;1894               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1895               out.get_ySlice(), out.get_xSlice());
;;;1896   
;;;1897             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1898               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1899   
;;;1900             if(limits.isSimpleIteration) {
;;;1901               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1902   
;;;1903               for(s32 y=0; y<limits.ySize; y++) {
;;;1904                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1905                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1906   
;;;1907                 limits.OuterIncrementTop();
;;;1908   
;;;1909                 for(s32 x=0; x<limits.xSize; x++) {
;;;1910                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], value2);
;;;1911   
;;;1912                   limits.in1X += limits.in1_xInnerIncrement;
;;;1913                   limits.out1X += limits.out1_xInnerIncrement;
;;;1914                 }
;;;1915   
;;;1916                 limits.OuterIncrementBottom();
;;;1917               }
;;;1918             } else { // if(limits.isSimpleIteration)
;;;1919               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1920   
;;;1921               for(s32 y=0; y<limits.ySize; y++) {
;;;1922                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1923   
;;;1924                 limits.OuterIncrementTop();
;;;1925   
;;;1926                 for(s32 x=0; x<limits.xSize; x++) {
;;;1927                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1928   
;;;1929                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, value2);
;;;1930   
;;;1931                   limits.in1X += limits.in1_xInnerIncrement;
;;;1932                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1933                   limits.out1X += limits.out1_xInnerIncrement;
;;;1934                 }
;;;1935   
;;;1936                 limits.OuterIncrementBottom();
;;;1937               }
;;;1938             } //   if(limits.isSimpleIteration)  ... else
;;;1939   
;;;1940             return RESULT_OK;
;;;1941           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1942   
;;;1943           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1944           {
;;;1945             const Array<InType> &in2Array = in2.get_array();
;;;1946             Array<OutType> &out1Array = out.get_array();
;;;1947   
;;;1948             AnkiConditionalErrorAndReturnValue(AreValid(in2Array, out1Array),
;;;1949               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1950   
;;;1951             ArraySliceLimits_in1_out1<s32> limits(
;;;1952               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1953               out.get_ySlice(), out.get_xSlice());
;;;1954   
;;;1955             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1956               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1957   
;;;1958             if(limits.isSimpleIteration) {
;;;1959               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1960   
;;;1961               for(s32 y=0; y<limits.ySize; y++) {
;;;1962                 const InType * const pIn2 = in2Array.Pointer(limits.in1Y, 0);
;;;1963                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1964   
;;;1965                 limits.OuterIncrementTop();
;;;1966   
;;;1967                 for(s32 x=0; x<limits.xSize; x++) {
;;;1968                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, pIn2[limits.in1X]);
;;;1969   
;;;1970                   limits.in1X += limits.in1_xInnerIncrement;
;;;1971                   limits.out1X += limits.out1_xInnerIncrement;
;;;1972                 }
;;;1973   
;;;1974                 limits.OuterIncrementBottom();
;;;1975               }
;;;1976             } else { // if(limits.isSimpleIteration)
;;;1977               // If either input is transposed, then we will do an inefficent loop iteration
;;;1978   
;;;1979               for(s32 y=0; y<limits.ySize; y++) {
;;;1980                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1981   
;;;1982                 limits.OuterIncrementTop();
;;;1983   
;;;1984                 for(s32 x=0; x<limits.xSize; x++) {
;;;1985                   const InType valIn2 = *in2Array.Pointer(limits.in1Y, limits.in1X);
;;;1986   
;;;1987                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, valIn2);
;;;1988   
;;;1989                   limits.in1X += limits.in1_xInnerIncrement;
;;;1990                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1991                   limits.out1X += limits.out1_xInnerIncrement;
;;;1992                 }
;;;1993   
;;;1994                 limits.OuterIncrementBottom();
;;;1995               }
;;;1996             } //   if(limits.isSimpleIteration)  ... else
;;;1997   
;;;1998             return RESULT_OK;
;;;1999           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;2000         } // namespace Elementwise
;;;2001       } // namespace Matrix
;;;2002     } // namespace Embedded
;;;2003   } // namespace Anki
;;;2004   
;;;2005   #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;19     
;;;20     #include "anki/common/shared/utilities_shared.h"
;;;1      /**
;;;2      File: utilities_shared.h
;;;3      Author: Kevin Yoon
;;;4      Created: 2014
;;;5      
;;;6      Copyright Anki, Inc. 2014
;;;7      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;8      **/
;;;9      
;;;10     #ifndef _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;11     #define _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;12     
;;;13     #include <stdarg.h>
;;;1      /* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
;;;14     
;;;15     namespace Anki
;;;16     {
;;;17       // For printing throughout Coretech libraries.
;;;18       // Calls printf() by default, but can be made to use an externally
;;;19       // defined function via SetCoreTechPrintFunctionPtr().
;;;20       int CoreTechPrint(const char * format, ...);
;;;21       int CoreTechPrint(const char * format, va_list argList);
;;;22     
;;;23       // Sets the function pointer that CoreTechPrint() uses.
;;;24       // Convenient for on-robot print which could be more complex
;;;25       // than just printf().
;;;26       void SetCoreTechPrintFunctionPtr( int (*fp)(const char * format, va_list) );
;;;27     } // namespace Anki
;;;28     
;;;29     #endif // _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26     #if 0
;;;27     #pragma mark --- 2D Point Implementations ---
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
;;;34         template<typename Type> Point<Type>::Point(const Type x, const Type y)
;;;35           : x(x), y(y)
;;;36         {
;;;37         }
;;;38     
;;;39         template<typename Type> Point<Type>::Point(const Point<Type>& pt)
;;;40           : x(pt.x), y(pt.y)
;;;41         {
;;;42         }
;;;43     
;;;44     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;45         template<typename Type> Point<Type>::Point(const cv::Point_<Type>& pt)
;;;46           : x(pt.x), y(pt.y)
;;;47         {
;;;48         }
;;;49     #endif
;;;50     
;;;51     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;52         template<typename Type> cv::Point_<Type> Point<Type>::get_CvPoint_() const
;;;53         {
;;;54           return cv::Point_<Type>(x,y);
;;;55         }
;;;56     #endif
;;;57     
;;;58         template<typename Type> template<typename InType> void Point<Type>::SetCast(const Point<InType> &in)
;;;59         {
;;;60           this->x = saturate_cast<Type>(in.x);
;;;61           this->y = saturate_cast<Type>(in.y);
;;;62         }
;;;63     
;;;64         template<typename Type> void Point<Type>::Print() const
;;;65         {
;;;66           CoreTechPrint("(%d,%d) ", this->x, this->y);
;;;67         }
;;;68     
;;;69         template<typename Type> bool Point<Type>::operator== (const Point<Type> &point2) const
;;;70         {
;;;71           if(this->x == point2.x && this->y == point2.y)
;;;72             return true;
;;;73     
;;;74           return false;
;;;75         }
;;;76     
;;;77         template<typename Type> Point<Type> Point<Type>::operator+ (const Point<Type> &point2) const
;;;78         {
;;;79           return Point<Type>(this->x+point2.x, this->y+point2.y);
;;;80         }
;;;81     
;;;82         template<typename Type> Point<Type> Point<Type>::operator- (const Point<Type> &point2) const
;;;83         {
;;;84           return Point<Type>(this->x-point2.x, this->y-point2.y);
;;;85         }
;;;86     
;;;87         template<typename Type> Point<Type> Point<Type>::operator- () const
;;;88         {
;;;89           return Point<Type>(-this->x, -this->y);
;;;90         }
;;;91     
;;;92         template<typename Type> Point<Type>& Point<Type>::operator*= (const Type value)
;;;93         {
;;;94           this->x *= value;
;;;95           this->y *= value;
;;;96           return *this;
;;;97         }
;;;98     
;;;99         template<typename Type> Point<Type>& Point<Type>::operator-= (const Type value)
;;;100        {
;;;101          this->x -= value;
;;;102          this->y -= value;
;;;103          return *this;
;;;104        }
;;;105    
;;;106        template<typename Type> Point<Type>& Point<Type>::operator+= (const Point<Type> &point2)
;;;107        {
;;;108          this->x += point2.x;
;;;109          this->y += point2.y;
;;;110          return *this;
;;;111        }
;;;112    
;;;113        template<typename Type> Point<Type>& Point<Type>::operator-= (const Point<Type> &point2)
;;;114        {
;;;115          this->x -= point2.x;
;;;116          this->y -= point2.y;
;;;117          return *this;
;;;118        }
;;;119    
;;;120        template<typename Type> inline Point<Type>& Point<Type>::operator= (const Point<Type> &point2)
;;;121        {
;;;122          this->x = point2.x;
;;;123          this->y = point2.y;
;;;124    
;;;125          return *this;
;;;126        }
;;;127    
;;;128        template<typename Type> f32 Point<Type>::Dist(const Point<Type> &point2) const
;;;129        {
;;;130          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) + (this->y - point2.y)*(this->y - point2.y));
;;;131        }
;;;132    
;;;133        template<typename Type> f32 Point<Type>::Length() const
;;;134        {
;;;135          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y)));
;;;136        }
;;;137    
;;;138        // #pragma mark --- Point Specializations ---
;;;139        template<> void Point<f32>::Print() const;
;;;140        template<> void Point<f64>::Print() const;
;;;141    
;;;142    #if 0
;;;143    #pragma mark --- 3D Point Implementations ---
;;;144    #endif
;;;145    
;;;146        template<typename Type> Point3<Type>::Point3()
;;;147          : x(static_cast<Type>(0)), y(static_cast<Type>(0)), z(static_cast<Type>(0))
;;;148        {
;;;149        }
;;;150    
;;;151        template<typename Type> Point3<Type>::Point3(const Type x, const Type y, const Type z)
;;;152          : x(x), y(y), z(z)
;;;153        {
;;;154        }
;;;155    
;;;156        template<typename Type> Point3<Type>::Point3(const Point3<Type>& pt)
;;;157          : x(pt.x), y(pt.y), z(pt.z)
;;;158        {
;;;159        }
;;;160    
;;;161    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;162        template<typename Type> Point3<Type>::Point3(const cv::Point3_<Type>& pt)
;;;163          : x(pt.x), y(pt.y), z(pt.z)
;;;164        {
;;;165        }
;;;166    #endif
;;;167    
;;;168    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;169        template<typename Type> cv::Point3_<Type> Point3<Type>::get_CvPoint_() const
;;;170        {
;;;171          return cv::Point3_<Type>(x,y,z);
;;;172        }
;;;173    #endif
;;;174    
;;;175        template<typename Type> void Point3<Type>::Print() const
;;;176        {
;;;177          CoreTechPrint("(%d,%d,%d) ", this->x, this->y, this->z);
;;;178        }
;;;179    
;;;180        template<typename Type> bool Point3<Type>::operator== (const Point3<Type> &point2) const
;;;181        {
;;;182          if(this->x == point2.x && this->y == point2.y && this->z == point2.z)
;;;183            return true;
;;;184    
;;;185          return false;
;;;186        }
;;;187    
;;;188        template<typename Type> Point3<Type> Point3<Type>::operator+ (const Point3<Type> &point2) const
;;;189        {
;;;190          return Point3<Type>(this->x+point2.x, this->y+point2.y, this->z+point2.z);
;;;191        }
;;;192    
;;;193        template<typename Type> Point3<Type> Point3<Type>::operator- (const Point3<Type> &point2) const
;;;194        {
;;;195          return Point3<Type>(this->x-point2.x, this->y-point2.y, this->z-point2.z);
;;;196        }
;;;197    
;;;198        template<typename Type> Point3<Type> Point3<Type>::operator- () const
;;;199        {
;;;200          return Point3<Type>(-this->x, -this->y, -this->z);
;;;201        }
;;;202    
;;;203        template<typename Type> Point3<Type>& Point3<Type>::operator*= (const Type value)
;;;204        {
;;;205          this->x *= value;
;;;206          this->y *= value;
;;;207          this->z *= value;
;;;208          return *this;
;;;209        }
;;;210    
;;;211        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Type value)
;;;212        {
;;;213          this->x -= value;
;;;214          this->y -= value;
;;;215          this->z -= value;
;;;216          return *this;
;;;217        }
;;;218    
;;;219        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Point3<Type> &point2)
;;;220        {
;;;221          this->x -= point2.x;
;;;222          this->y -= point2.y;
;;;223          this->z -= point2.z;
;;;224          return *this;
;;;225        }
;;;226    
;;;227        template<typename Type> inline Point3<Type>& Point3<Type>::operator= (const Point3<Type> &point2)
;;;228        {
;;;229          this->x = point2.x;
;;;230          this->y = point2.y;
;;;231          this->z = point2.z;
;;;232          return *this;
;;;233        }
;;;234    
;;;235        template<typename Type> f32 Point3<Type>::Dist(const Point3<Type> &point2) const
;;;236        {
;;;237          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) +
;;;238            (this->y - point2.y)*(this->y - point2.y) +
;;;239            (this->z - point2.z)*(this->z - point2.z));
;;;240        }
;;;241    
;;;242        template<typename Type> f32 Point3<Type>::Length() const
;;;243        {
;;;244          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y) + (this->z*this->z)));
;;;245        }
;;;246    
;;;247        template<typename Type> f32 Point3<Type>::MakeUnitLength()
;;;248        {
;;;249          const f32 L = this->Length();
;;;250          if(L != 0) {
;;;251            this->operator*=(1.f / L);
;;;252          }
;;;253          return L;
;;;254        }
;;;255    
;;;256        template<typename Type>
;;;257        Type DotProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;258        {
;;;259          return (point1.x*point2.x) + (point1.y*point2.y) + (point1.z*point2.z);
;;;260        }
;;;261    
;;;262        template<typename Type>
;;;263        Point3<Type> CrossProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;264        {
;;;265          return Point3<Type>(-point2.y*point1.z + point1.y*point2.z,
;;;266            point2.x*point1.z - point1.x*point2.z,
;;;267            -point2.x*point1.y + point1.x*point2.y);
;;;268        }
;;;269    
;;;270        template<typename Type>
;;;271        Point3<Type> operator* (const Array<Type>& M, const Point3<Type>& p)
;;;272        {
;;;273          // Matrix M must be 3x3
;;;274          AnkiAssert(AreEqualSize(3, 3, M));
;;;275    
;;;276          return Point3<Type>(M[0][0]*p.x + M[0][1]*p.y + M[0][2]*p.z,
;;;277            M[1][0]*p.x + M[1][1]*p.y + M[1][2]*p.z,
;;;278            M[2][0]*p.x + M[2][1]*p.y + M[2][2]*p.z);
;;;279        }
;;;280    
;;;281        // #pragma mark --- Point Specializations ---
;;;282        template<> void Point3<f32>::Print() const;
;;;283        template<> void Point3<f64>::Print() const;
;;;284    
;;;285    #if 0
;;;286    #pragma mark --- Pose Implementations ---
;;;287    #endif
;;;288    
;;;289        template<typename Type>
;;;290        Result ComputePoseDiff(const Array<Type>& R1, const Point3<Type>& T1,
;;;291          const Array<Type>& R2, const Point3<Type>& T2,
;;;292          Array<Type>& Rdiff, Point3<Type>& Tdiff,
;;;293          MemoryStack scratch)
;;;294        {
;;;295          // All the rotation matrices should be 3x3
;;;296          AnkiAssert(AreEqualSize(3, 3, R1));
;;;297          AnkiAssert(AreEqualSize(3, 3, R2));
;;;298          AnkiAssert(AreEqualSize(3, 3, Rdiff));
;;;299    
;;;300          Array<Type> invR1 = Array<Type>(3,3,scratch);
;;;301          Matrix::Transpose(R1, invR1);
;;;302    
;;;303          Matrix::Multiply(invR1, R2, Rdiff);
;;;304          Tdiff = invR1 * (T2 - T1);
;;;305    
;;;306          return RESULT_OK;
;;;307        }
;;;308    
;;;309    #if 0
;;;310    #pragma mark --- Rectangle Implementations ---
;;;311    #endif
;;;312    
;;;313        template<typename Type> Rectangle<Type>::Rectangle()
;;;314          : left(static_cast<Type>(0)), right(static_cast<Type>(0)), top(static_cast<Type>(0)), bottom(static_cast<Type>(0))
;;;315        {
;;;316        }
;;;317    
;;;318        template<typename Type> Rectangle<Type>::Rectangle(const Type left, const Type right, const Type top, const Type bottom)
;;;319          : left(left), right(right), top(top), bottom(bottom)
;;;320        {
;;;321        }
;;;322    
;;;323        template<typename Type> Rectangle<Type>::Rectangle(const Rectangle<Type>& rect)
;;;324          : left(rect.left), right(rect.right), top(rect.top), bottom(rect.bottom)
;;;325        {
;;;326        }
;;;327    
;;;328        template<typename Type> void Rectangle<Type>::Print() const
;;;329        {
;;;330          CoreTechPrint("(%d,%d)->(%d,%d) ", this->left, this->top, this->right, this->bottom);
;;;331        }
;;;332    
;;;333        template<typename Type> template<typename OutType> Point<OutType> Rectangle<Type>::ComputeCenter() const
;;;334        {
;;;335          Point<OutType> center(
;;;336            (static_cast<OutType>(this->left) + static_cast<OutType>(this->right)) / 2,
;;;337            (static_cast<OutType>(this->top) + static_cast<OutType>(this->bottom)) / 2);
;;;338    
;;;339          return center;
;;;340        }
;;;341    
;;;342        template<typename Type> template<typename OutType> Rectangle<OutType> Rectangle<Type>::ComputeScaledRectangle(const f32 scalePercent) const
;;;343        {
;;;344          const f32 width = static_cast<f32>(this->get_width());
;;;345          const f32 height = static_cast<f32>(this->get_height());
;;;346    
;;;347          const f32 scaledWidth = width * scalePercent;
;;;348          const f32 scaledHeight = height * scalePercent;
;;;349    
;;;350          const f32 dx2 = (scaledWidth - width) / 2.0f;
;;;351          const f32 dy2 = (scaledHeight - height) / 2.0f;
;;;352    
;;;353          Rectangle<OutType> scaledRect(
;;;354            static_cast<OutType>( static_cast<f32>(this->left)   - dx2 ),
;;;355            static_cast<OutType>( static_cast<f32>(this->right)  + dx2 ),
;;;356            static_cast<OutType>( static_cast<f32>(this->top)    - dy2 ),
;;;357            static_cast<OutType>( static_cast<f32>(this->bottom) + dy2 ));
;;;358    
;;;359          return scaledRect;
;;;360        }
;;;361    
;;;362        template<typename Type> bool Rectangle<Type>::operator== (const Rectangle<Type> &rectangle2) const
;;;363        {
;;;364          if(this->left == rectangle2.left && this->top == rectangle2.top && this->right == rectangle2.right && this->bottom == rectangle2.bottom)
;;;365            return true;
;;;366    
;;;367          return false;
;;;368        }
;;;369    
;;;370        template<typename Type> Rectangle<Type> Rectangle<Type>::operator+ (const Rectangle<Type> &rectangle2) const
;;;371        {
;;;372          return Rectangle<Type>(this->top+rectangle2.top, this->bottom+rectangle2.bottom, this->left+rectangle2.left, this->right+rectangle2.right);
;;;373        }
;;;374    
;;;375        template<typename Type> Rectangle<Type> Rectangle<Type>::operator- (const Rectangle<Type> &rectangle2) const
;;;376        {
;;;377          return Rectangle<Type>(this->top-rectangle2.top, this->bottom-rectangle2.bottom, this->left-rectangle2.left, this->right-rectangle2.right);
;;;378        }
;;;379    
;;;380        template<typename Type> inline Rectangle<Type>& Rectangle<Type>::operator= (const Rectangle<Type> &rect2)
;;;381        {
;;;382          this->left = rect2.left;
;;;383          this->right = rect2.right;
;;;384          this->top = rect2.top;
;;;385          this->bottom = rect2.bottom;
;;;386    
;;;387          return *this;
;;;388        }
;;;389    
;;;390        template<typename Type> Type Rectangle<Type>::get_width() const
;;;391        {
;;;392          return right - left;
;;;393        }
;;;394    
;;;395        template<typename Type> Type Rectangle<Type>::get_height() const
;;;396        {
;;;397          return bottom - top;
;;;398        }
;;;399    
;;;400        // #pragma mark --- Rectangle Specializations ---
;;;401        template<> void Rectangle<f32>::Print() const;
;;;402        template<> void Rectangle<f64>::Print() const;
;;;403    
;;;404        // #pragma mark --- Quadrilateral Definitions ---
;;;405    
;;;406        template<typename Type> Quadrilateral<Type>::Quadrilateral()
;;;407        {
;;;408          for(s32 i=0; i<4; i++) {
;;;409            corners[i] = Point<Type>();
;;;410          }
;;;411        }
;;;412    
;;;413        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Point<Type> &corner1, const Point<Type> &corner2, const Point<Type> &corner3, const Point<Type> &corner4)
;;;414        {
;;;415          corners[0] = corner1;
;;;416          corners[1] = corner2;
;;;417          corners[2] = corner3;
;;;418          corners[3] = corner4;
;;;419        }
;;;420    
;;;421        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Quadrilateral<Type>& quad2)
;;;422        {
;;;423          for(s32 i=0; i<4; i++) {
;;;424            this->corners[i] = quad2.corners[i];
;;;425          }
;;;426        }
;;;427    
;;;428        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Rectangle<Type>& rect)
;;;429        {
;;;430          this->corners[0].x = rect.left;   this->corners[0].y = rect.top;
;;;431          this->corners[1].x = rect.right;  this->corners[1].y = rect.top;
;;;432          this->corners[2].x = rect.left;   this->corners[2].y = rect.bottom;
;;;433          this->corners[3].x = rect.right;  this->corners[3].y = rect.bottom;
;;;434        }
;;;435    
;;;436        template<typename Type> void Quadrilateral<Type>::Print() const
;;;437        {
;;;438          CoreTechPrint("{(%d,%d), (%d,%d), (%d,%d), (%d,%d)} ",
;;;439            this->corners[0].x, this->corners[0].y,
;;;440            this->corners[1].x, this->corners[1].y,
;;;441            this->corners[2].x, this->corners[2].y,
;;;442            this->corners[3].x, this->corners[3].y);
;;;443        }
;;;444    
;;;445        template<typename Type> template<typename OutType> Point<OutType> Quadrilateral<Type>::ComputeCenter() const
;;;446        {
;;;447          Point<OutType> center(0, 0);
;;;448    
;;;449          for(s32 i=0; i<4; i++) {
;;;450            center.x += static_cast<OutType>(this->corners[i].x);
;;;451            center.y += static_cast<OutType>(this->corners[i].y);
;;;452          }
;;;453    
;;;454          center.x /= 4;
;;;455          center.y /= 4;
;;;456    
;;;457          return center;
;;;458        }
;;;459    
;;;460        template<typename Type> template<typename OutType> Rectangle<OutType> Quadrilateral<Type>::ComputeBoundingRectangle() const
;;;461        {
;;;462          Rectangle<OutType> boundingRect(
;;;463            static_cast<OutType>(this->corners[0].x),
;;;464            static_cast<OutType>(this->corners[0].x),
;;;465            static_cast<OutType>(this->corners[0].y),
;;;466            static_cast<OutType>(this->corners[0].y));
;;;467    
;;;468          // Initialize the template rectangle to the bounding box of the given
;;;469          // quadrilateral
;;;470          for(s32 i=1; i<4; ++i) {
;;;471            boundingRect.left   = MIN(boundingRect.left,   static_cast<OutType>(this->corners[i].x));
;;;472            boundingRect.right  = MAX(boundingRect.right,  static_cast<OutType>(this->corners[i].x));
;;;473            boundingRect.top    = MIN(boundingRect.top,    static_cast<OutType>(this->corners[i].y));
;;;474            boundingRect.bottom = MAX(boundingRect.bottom, static_cast<OutType>(this->corners[i].y));
;;;475          }
;;;476    
;;;477          return boundingRect;
;;;478        }
;;;479    
;;;480        template<typename Type> template<typename OutType> Quadrilateral<OutType> Quadrilateral<Type>::ComputeClockwiseCorners() const
;;;481        {
;;;482          char tmpBuffer[128];
;;;483          MemoryStack scratch(tmpBuffer, 128);
;;;484    
;;;485          Array<f32> thetas(1,4,scratch);
;;;486          Array<s32> indexes(1,4,scratch);
;;;487          Point<f32> center = this->ComputeCenter<f32>();
;;;488    
;;;489          for(s32 i=0; i<4; i++) {
;;;490            f32 rho = 0.0f;
;;;491    
;;;492            Cart2Pol<f32>(
;;;493              static_cast<f32>(this->corners[i].x) - center.x,
;;;494              static_cast<f32>(this->corners[i].y) - center.y,
;;;495              rho, thetas[0][i]);
;;;496          }
;;;497    
;;;498          Matrix::InsertionSort(thetas, indexes, 1);
;;;499    
;;;500          const Quadrilateral<OutType> sortedQuad(
;;;501            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][0]].x), static_cast<OutType>(this->corners[indexes[0][0]].y)),
;;;502            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][1]].x), static_cast<OutType>(this->corners[indexes[0][1]].y)),
;;;503            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][2]].x), static_cast<OutType>(this->corners[indexes[0][2]].y)),
;;;504            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][3]].x), static_cast<OutType>(this->corners[indexes[0][3]].y)));
;;;505    
;;;506          return sortedQuad;
;;;507        }
;;;508    
                          ENDP

                  |L341.444|
0001bc  00000000          DCFS     0x00000000 ; 0
                  |L341.448|
                          DCD      0x07fffffe

                          AREA ||area_number.342||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv, LINKORDER=||t._ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.342||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi PROC ; Anki::Embedded::Array<unsigned char>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L348.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L348.56|
00000e  4b0b              LDR      r3,|L348.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f1030250          ADD      r2,r3,#0x50
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L348.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L348.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::get_size(int) const::__PRETTY_FUNCTION__
                  |L348.60|
                          DCD      ||.constdata||+0x700

                          AREA ||area_number.349||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.349||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE||, COMGROUP=_ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15ConstArraySliceIfEC2ERKNS0_5ArrayIfEE                  ; Alternate entry point ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice__sub_object(const Anki::Embedded::Array<float>&)
                  _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE PROC ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
;;;26     
;;;27         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array)
;;;28           : ySlice(LinearSequence<s32>(0,array.get_size(0)-1)), xSlice(LinearSequence<s32>(0,array.get_size(1)-1)), array(array)
;;;29         {
;;;30           if(array.get_numElements() == 0) {
;;;31             this->constArrayData = NULL;
;;;32           } else {
;;;33             this->constArrayData = array.Pointer(0,0);
;;;34           }
;;;35         }
;;;36     
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
000006  2100              MOVS     r1,#0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00000e  1e42              SUBS     r2,r0,#1
000010  2100              MOVS     r1,#0
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000018  4605              MOV      r5,r0
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000022  1e42              SUBS     r2,r0,#1
000024  2100              MOVS     r1,#0
000026  f105000c          ADD      r0,r5,#0xc
00002a  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00002e  e894102e          LDM      r4,{r1-r3,r5,r12}
000032  380c              SUBS     r0,r0,#0xc
000034  f1000618          ADD      r6,r0,#0x18
000038  e8a6102e          STM      r6!,{r1-r3,r5,r12}
00003c  6821              LDR      r1,[r4,#0]
00003e  2900              CMP      r1,#0
000040  bfc4              ITT      GT
000042  6862              LDRGT    r2,[r4,#4]
000044  2a00              CMPGT    r2,#0
000046  dd08              BLE      |L355.90|
000048  4351              MULS     r1,r2,r1
00004a  b131              CBZ      r1,|L355.90|
00004c  68a3              LDR      r3,[r4,#8]
00004e  6922              LDR      r2,[r4,#0x10]
000050  2100              MOVS     r1,#0
000052  fb012103          MLA      r1,r1,r3,r2
                  |L355.86|
000056  62c1              STR      r1,[r0,#0x2c]
000058  bd70              POP      {r4-r6,pc}
                  |L355.90|
00005a  2100              MOVS     r1,#0
00005c  e7fb              B        |L355.86|
                          ENDP


                          AREA ||area_number.356||, COMGROUP=_ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE, LINKORDER=||t._ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.356||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEE||, COMGROUP=_ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEE, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded10ArraySliceIfEC2ENS0_5ArrayIfEE                  ; Alternate entry point ; Anki::Embedded::ArraySlice<float>::ArraySlice__sub_object(Anki::Embedded::Array<float>)
                  _ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEE PROC ; Anki::Embedded::ArraySlice<float>::ArraySlice(Anki::Embedded::Array<float>)
;;;78     
;;;79         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array)
;;;80           : ConstArraySlice<Type>(array)
;;;81         {
;;;82           if(array.get_numElements() == 0) {
;;;83             this->arrayData = NULL;
;;;84           } else {
;;;85             this->arrayData = array.Pointer(0,0);
;;;86           }
;;;87         }
;;;88     
000000  b40f              PUSH     {r0-r3}
000002  b510              PUSH     {r4,lr}
000004  a903              ADD      r1,sp,#0xc
000006  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
00000a  9903              LDR      r1,[sp,#0xc]
00000c  2900              CMP      r1,#0
00000e  bfc4              ITT      GT
000010  9904              LDRGT    r1,[sp,#0x10]
000012  2900              CMPGT    r1,#0
000014  dd0c              BLE      |L362.48|
000016  e9dd1203          LDRD     r1,r2,[sp,#0xc]
00001a  4351              MULS     r1,r2,r1
00001c  b141              CBZ      r1,|L362.48|
00001e  9b05              LDR      r3,[sp,#0x14]
000020  9a07              LDR      r2,[sp,#0x1c]
000022  2100              MOVS     r1,#0
000024  fb012103          MLA      r1,r1,r3,r2
                  |L362.40|
000028  6301              STR      r1,[r0,#0x30]
00002a  bc10              POP      {r4}
00002c  f85dfb14          LDR      pc,[sp],#0x14
                  |L362.48|
000030  2100              MOVS     r1,#0
000032  e7f9              B        |L362.40|
                          ENDP


                          AREA ||area_number.363||, COMGROUP=_ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEE, LINKORDER=||t._ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.363||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L369.86|
00003a  217d              MOVS     r1,#0x7d
00003c  4851              LDR      r0,|L369.388|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a351              ADR      r3,|L369.392|
000044  a25e              ADR      r2,|L369.448|
000046  a162              ADR      r1,|L369.464|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L369.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  eb0000c0          ADD      r0,r0,r0,LSL #3
000066  0080              LSLS     r0,r0,#2
000068  300f              ADDS     r0,r0,#0xf
00006a  f020050f          BIC      r5,r0,#0xf
00006e  a804              ADD      r0,sp,#0x10
000070  e9cd0902          STRD     r0,r9,[sp,#8]
000074  2d00              CMP      r5,#0
000076  dc0a              BGT      |L369.142|
000078  f240310b          MOV      r1,#0x30b
00007c  4859              LDR      r0,|L369.484|
00007e  e9cd0100          STRD     r0,r1,[sp,#0]
000082  a341              ADR      r3,|L369.392|
000084  a24e              ADR      r2,|L369.448|
000086  a158              ADR      r1,|L369.488|
000088  2005              MOVS     r0,#5
00008a  f7fffffe          BL       _Anki_Log
                  |L369.142|
00008e  4638              MOV      r0,r7
000090  2f01              CMP      r7,#1
000092  bfd8              IT       LE
000094  2001              MOVLE    r0,#1
000096  60a5              STR      r5,[r4,#8]
000098  4345              MULS     r5,r0,r5
00009a  a803              ADD      r0,sp,#0xc
00009c  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
0000a0  4602              MOV      r2,r0
0000a2  4629              MOV      r1,r5
0000a4  4640              MOV      r0,r8
0000a6  9b02              LDR      r3,[sp,#8]
0000a8  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000ac  f8cd900c          STR      r9,[sp,#0xc]
0000b0  f8dd8010          LDR      r8,[sp,#0x10]
0000b4  f8df915c          LDR      r9,|L369.532|
0000b8  0005              MOVS     r5,r0
0000ba  d00e              BEQ      |L369.218|
0000bc  f1b80f10          CMP      r8,#0x10
0000c0  d21e              BCS      |L369.256|
0000c2  f2403023          MOV      r0,#0x323
0000c6  e9cd9000          STRD     r9,r0,[sp,#0]
0000ca  a32f              ADR      r3,|L369.392|
0000cc  a252              ADR      r2,|L369.536|
0000ce  a157              ADR      r1,|L369.556|
0000d0  2005              MOVS     r0,#5
0000d2  f7fffffe          BL       _Anki_Log
0000d6  f000b851          B.W      |L369.380|
                  |L369.218|
0000da  f240301e          MOV      r0,#0x31e
0000de  e9cd9000          STRD     r9,r0,[sp,#0]
0000e2  a329              ADR      r3,|L369.392|
0000e4  a259              ADR      r2,|L369.588|
0000e6  a160              ADR      r1,|L369.616|
0000e8  2005              MOVS     r0,#5
0000ea  f7fffffe          BL       _Anki_Log
0000ee  f8c4b000          STR      r11,[r4,#0]
0000f2  f8c4b004          STR      r11,[r4,#4]
0000f6  f8c4b008          STR      r11,[r4,#8]
0000fa  f8c4a010          STR      r10,[r4,#0x10]
0000fe  e03d              B        |L369.380|
                  |L369.256|
000100  a803              ADD      r0,sp,#0xc
000102  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000106  2800              CMP      r0,#0
000108  d00a              BEQ      |L369.288|
00010a  f2403026          MOV      r0,#0x326
00010e  e9cd9000          STRD     r9,r0,[sp,#0]
000112  a31d              ADR      r3,|L369.392|
000114  a25a              ADR      r2,|L369.640|
000116  a145              ADR      r1,|L369.556|
000118  2005              MOVS     r0,#5
00011a  f7fffffe          BL       _Anki_Log
00011e  e02d              B        |L369.380|
                  |L369.288|
000120  9903              LDR      r1,[sp,#0xc]
000122  e9c41503          STRD     r1,r5,[r4,#0xc]
000126  f105000f          ADD      r0,r5,#0xf
00012a  f020000f          BIC      r0,r0,#0xf
00012e  e9c47600          STRD     r7,r6,[r4,#0]
000132  1b40              SUBS     r0,r0,r5
000134  2e01              CMP      r6,#1
000136  bfd8              IT       LE
000138  2601              MOVLE    r6,#1
00013a  eb0601c6          ADD      r1,r6,r6,LSL #3
00013e  0089              LSLS     r1,r1,#2
000140  310f              ADDS     r1,r1,#0xf
000142  f021010f          BIC      r1,r1,#0xf
000146  fb010107          MLA      r1,r1,r7,r0
00014a  4541              CMP      r1,r8
00014c  bfdc              ITT      LE
00014e  1829              ADDLE    r1,r5,r0
000150  6121              STRLE    r1,[r4,#0x10]
000152  dd13              BLE      |L369.380|
000154  f2403035          MOV      r0,#0x335
000158  f8cd9000          STR      r9,[sp,#0]
00015c  e9cd0101          STRD     r0,r1,[sp,#4]
000160  a309              ADR      r3,|L369.392|
000162  a251              ADR      r2,|L369.680|
000164  a140              ADR      r1,|L369.616|
000166  2005              MOVS     r0,#5
000168  f7fffffe          BL       _Anki_Log
00016c  f8c4b000          STR      r11,[r4,#0]
000170  f8c4b004          STR      r11,[r4,#4]
000174  f8c4b008          STR      r11,[r4,#8]
000178  f8c4a010          STR      r10,[r4,#0x10]
                  |L369.380|
00017c  b005              ADD      sp,sp,#0x14
00017e  4620              MOV      r0,r4
000180  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L369.388|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L369.392|
000188  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
00018c  6f726574
000190  6563685c
000194  636f6d6d
000198  6f6e5c69
00019c  6e636c75
0001a0  64655c61
0001a4  6e6b692f
0001a8  636f6d6d
0001ac  6f6e2f72
0001b0  6f626f74
0001b4  2f617272
0001b8  617932  
0001bb  642e6800          DCB      "d.h",0
0001bf  00                DCB      0
                  |L369.448|
0001c0  496e7661          DCB      "Invalid size",0
0001c4  6c696420
0001c8  73697a65
0001cc  00      
0001cd  00                DCB      0
0001ce  00                DCB      0
0001cf  00                DCB      0
                  |L369.464|
0001d0  41727261          DCB      "Array<Type>::Array",0
0001d4  793c5479
0001d8  70653e3a
0001dc  3a417272
0001e0  617900  
0001e3  00                DCB      0
                  |L369.484|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L369.488|
0001e8  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001ec  793c5479
0001f0  70653e3a
0001f4  3a416c6c
0001f8  6f636174
0001fc  65427566
000200  66657246
000204  726f6d4d
000208  656d6f72
00020c  79537461
000210  636b00  
000213  00                DCB      0
                  |L369.532|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L369.536|
000218  4e656761          DCB      "Negative dimension",0
00021c  74697665
000220  2064696d
000224  656e7369
000228  6f6e00  
00022b  00                DCB      0
                  |L369.556|
00022c  41727261          DCB      "Array<Type>::InitializeBuffer",0
000230  793c5479
000234  70653e3a
000238  3a496e69
00023c  7469616c
000240  697a6542
000244  75666665
000248  7200    
00024a  00                DCB      0
00024b  00                DCB      0
                  |L369.588|
00024c  696e7075          DCB      "input data buffer is NULL",0
000250  74206461
000254  74612062
000258  75666665
00025c  72206973
000260  204e554c
000264  4c00    
000266  00                DCB      0
000267  00                DCB      0
                  |L369.616|
000268  416e6b69          DCB      "Anki.Array2d.initialize",0
00026c  2e417272
000270  61793264
000274  2e696e69
000278  7469616c
00027c  697a6500
                  |L369.640|
000280  46696c6c          DCB      "Fill patterns not supported for Array",0
000284  20706174
000288  7465726e
00028c  73206e6f
000290  74207375
000294  70706f72
000298  74656420
00029c  666f7220
0002a0  41727261
0002a4  7900    
0002a6  00                DCB      0
0002a7  00                DCB      0
                  |L369.680|
0002a8  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002ac  74206461
0002b0  74612062
0002b4  75666665
0002b8  72206973
0002bc  206e6f74
0002c0  206c6172
0002c4  67652065
0002c8  6e6f7567
0002cc  682e2025
0002d0  64206279
0002d4  74657320
0002d8  69732072
0002dc  657175  
0002df  69726564          DCB      "ired.",0
0002e3  2e00    
0002e5  00                DCB      0
0002e6  00                DCB      0
0002e7  00                DCB      0

                          AREA ||area_number.370||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.370||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L376.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L376.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.377||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.377||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS1_IfEEEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L383.86|
00003a  217d              MOVS     r1,#0x7d
00003c  4851              LDR      r0,|L383.388|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a351              ADR      r3,|L383.392|
000044  a25e              ADR      r2,|L383.448|
000046  a162              ADR      r1,|L383.464|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L383.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  eb000080          ADD      r0,r0,r0,LSL #2
000066  0080              LSLS     r0,r0,#2
000068  300f              ADDS     r0,r0,#0xf
00006a  f020050f          BIC      r5,r0,#0xf
00006e  a804              ADD      r0,sp,#0x10
000070  e9cd0902          STRD     r0,r9,[sp,#8]
000074  2d00              CMP      r5,#0
000076  dc0a              BGT      |L383.142|
000078  f240310b          MOV      r1,#0x30b
00007c  4859              LDR      r0,|L383.484|
00007e  e9cd0100          STRD     r0,r1,[sp,#0]
000082  a341              ADR      r3,|L383.392|
000084  a24e              ADR      r2,|L383.448|
000086  a158              ADR      r1,|L383.488|
000088  2005              MOVS     r0,#5
00008a  f7fffffe          BL       _Anki_Log
                  |L383.142|
00008e  4638              MOV      r0,r7
000090  2f01              CMP      r7,#1
000092  bfd8              IT       LE
000094  2001              MOVLE    r0,#1
000096  60a5              STR      r5,[r4,#8]
000098  4345              MULS     r5,r0,r5
00009a  a803              ADD      r0,sp,#0xc
00009c  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
0000a0  4602              MOV      r2,r0
0000a2  4629              MOV      r1,r5
0000a4  4640              MOV      r0,r8
0000a6  9b02              LDR      r3,[sp,#8]
0000a8  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000ac  f8cd900c          STR      r9,[sp,#0xc]
0000b0  f8dd8010          LDR      r8,[sp,#0x10]
0000b4  f8df915c          LDR      r9,|L383.532|
0000b8  0005              MOVS     r5,r0
0000ba  d00e              BEQ      |L383.218|
0000bc  f1b80f10          CMP      r8,#0x10
0000c0  d21e              BCS      |L383.256|
0000c2  f2403023          MOV      r0,#0x323
0000c6  e9cd9000          STRD     r9,r0,[sp,#0]
0000ca  a32f              ADR      r3,|L383.392|
0000cc  a252              ADR      r2,|L383.536|
0000ce  a157              ADR      r1,|L383.556|
0000d0  2005              MOVS     r0,#5
0000d2  f7fffffe          BL       _Anki_Log
0000d6  f000b851          B.W      |L383.380|
                  |L383.218|
0000da  f240301e          MOV      r0,#0x31e
0000de  e9cd9000          STRD     r9,r0,[sp,#0]
0000e2  a329              ADR      r3,|L383.392|
0000e4  a259              ADR      r2,|L383.588|
0000e6  a160              ADR      r1,|L383.616|
0000e8  2005              MOVS     r0,#5
0000ea  f7fffffe          BL       _Anki_Log
0000ee  f8c4b000          STR      r11,[r4,#0]
0000f2  f8c4b004          STR      r11,[r4,#4]
0000f6  f8c4b008          STR      r11,[r4,#8]
0000fa  f8c4a010          STR      r10,[r4,#0x10]
0000fe  e03d              B        |L383.380|
                  |L383.256|
000100  a803              ADD      r0,sp,#0xc
000102  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000106  2800              CMP      r0,#0
000108  d00a              BEQ      |L383.288|
00010a  f2403026          MOV      r0,#0x326
00010e  e9cd9000          STRD     r9,r0,[sp,#0]
000112  a31d              ADR      r3,|L383.392|
000114  a25a              ADR      r2,|L383.640|
000116  a145              ADR      r1,|L383.556|
000118  2005              MOVS     r0,#5
00011a  f7fffffe          BL       _Anki_Log
00011e  e02d              B        |L383.380|
                  |L383.288|
000120  9903              LDR      r1,[sp,#0xc]
000122  e9c41503          STRD     r1,r5,[r4,#0xc]
000126  f105000f          ADD      r0,r5,#0xf
00012a  f020000f          BIC      r0,r0,#0xf
00012e  e9c47600          STRD     r7,r6,[r4,#0]
000132  1b40              SUBS     r0,r0,r5
000134  2e01              CMP      r6,#1
000136  bfd8              IT       LE
000138  2601              MOVLE    r6,#1
00013a  eb060186          ADD      r1,r6,r6,LSL #2
00013e  0089              LSLS     r1,r1,#2
000140  310f              ADDS     r1,r1,#0xf
000142  f021010f          BIC      r1,r1,#0xf
000146  fb010107          MLA      r1,r1,r7,r0
00014a  4541              CMP      r1,r8
00014c  bfdc              ITT      LE
00014e  1829              ADDLE    r1,r5,r0
000150  6121              STRLE    r1,[r4,#0x10]
000152  dd13              BLE      |L383.380|
000154  f2403035          MOV      r0,#0x335
000158  f8cd9000          STR      r9,[sp,#0]
00015c  e9cd0101          STRD     r0,r1,[sp,#4]
000160  a309              ADR      r3,|L383.392|
000162  a251              ADR      r2,|L383.680|
000164  a140              ADR      r1,|L383.616|
000166  2005              MOVS     r0,#5
000168  f7fffffe          BL       _Anki_Log
00016c  f8c4b000          STR      r11,[r4,#0]
000170  f8c4b004          STR      r11,[r4,#4]
000174  f8c4b008          STR      r11,[r4,#8]
000178  f8c4a010          STR      r10,[r4,#0x10]
                  |L383.380|
00017c  b005              ADD      sp,sp,#0x14
00017e  4620              MOV      r0,r4
000180  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L383.388|
                          DCD      _ZZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L383.392|
000188  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
00018c  6f726574
000190  6563685c
000194  636f6d6d
000198  6f6e5c69
00019c  6e636c75
0001a0  64655c61
0001a4  6e6b692f
0001a8  636f6d6d
0001ac  6f6e2f72
0001b0  6f626f74
0001b4  2f617272
0001b8  617932  
0001bb  642e6800          DCB      "d.h",0
0001bf  00                DCB      0
                  |L383.448|
0001c0  496e7661          DCB      "Invalid size",0
0001c4  6c696420
0001c8  73697a65
0001cc  00      
0001cd  00                DCB      0
0001ce  00                DCB      0
0001cf  00                DCB      0
                  |L383.464|
0001d0  41727261          DCB      "Array<Type>::Array",0
0001d4  793c5479
0001d8  70653e3a
0001dc  3a417272
0001e0  617900  
0001e3  00                DCB      0
                  |L383.484|
                          DCD      _ZZN4Anki8Embedded5ArrayINS1_IfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L383.488|
0001e8  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001ec  793c5479
0001f0  70653e3a
0001f4  3a416c6c
0001f8  6f636174
0001fc  65427566
000200  66657246
000204  726f6d4d
000208  656d6f72
00020c  79537461
000210  636b00  
000213  00                DCB      0
                  |L383.532|
                          DCD      _ZZN4Anki8Embedded5ArrayINS1_IfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L383.536|
000218  4e656761          DCB      "Negative dimension",0
00021c  74697665
000220  2064696d
000224  656e7369
000228  6f6e00  
00022b  00                DCB      0
                  |L383.556|
00022c  41727261          DCB      "Array<Type>::InitializeBuffer",0
000230  793c5479
000234  70653e3a
000238  3a496e69
00023c  7469616c
000240  697a6542
000244  75666665
000248  7200    
00024a  00                DCB      0
00024b  00                DCB      0
                  |L383.588|
00024c  696e7075          DCB      "input data buffer is NULL",0
000250  74206461
000254  74612062
000258  75666665
00025c  72206973
000260  204e554c
000264  4c00    
000266  00                DCB      0
000267  00                DCB      0
                  |L383.616|
000268  416e6b69          DCB      "Anki.Array2d.initialize",0
00026c  2e417272
000270  61793264
000274  2e696e69
000278  7469616c
00027c  697a6500
                  |L383.640|
000280  46696c6c          DCB      "Fill patterns not supported for Array",0
000284  20706174
000288  7465726e
00028c  73206e6f
000290  74207375
000294  70706f72
000298  74656420
00029c  666f7220
0002a0  41727261
0002a4  7900    
0002a6  00                DCB      0
0002a7  00                DCB      0
                  |L383.680|
0002a8  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002ac  74206461
0002b0  74612062
0002b4  75666665
0002b8  72206973
0002bc  206e6f74
0002c0  206c6172
0002c4  67652065
0002c8  6e6f7567
0002cc  682e2025
0002d0  64206279
0002d4  74657320
0002d8  69732072
0002dc  657175  
0002df  69726564          DCB      "ired.",0
0002e3  2e00    
0002e5  00                DCB      0
0002e6  00                DCB      0
0002e7  00                DCB      0

                          AREA ||area_number.384||, COMGROUP=_ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.384||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||i._ZN4Anki8Embedded5RoundIiEET_f||, COMGROUP=_ZN4Anki8Embedded5RoundIiEET_f, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded5RoundIiEET_f PROC ; Anki::Embedded::Round<int>(float)
;;;222        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(v + 0.5f) : 0; }
;;;223        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(v + 0.5f) : static_cast<s32>(v - 0.5f); }
000000  eeb50ac0          VCMPE.F32 s0,#0.0
000004  eef60a00          VMOV.F32 s1,#0.50000000
000008  eef1fa10          VMRS     APSR_nzcv,FPSCR
00000c  dd06              BLE      |L390.28|
00000e  ee300a20          VADD.F32 s0,s0,s1
000012  eebd0ac0          VCVT.S32.F32 s0,s0
000016  ee100a10          VMOV     r0,s0
00001a  4770              BX       lr
                  |L390.28|
00001c  ee300a60          VSUB.F32 s0,s0,s1
000020  eebd0ac0          VCVT.S32.F32 s0,s0
000024  ee100a10          VMOV     r0,s0
000028  4770              BX       lr
;;;224        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(v + 0.5f) : static_cast<s64>(v - 0.5f); }
                          ENDP


                          AREA ||area_number.391||, COMGROUP=_ZN4Anki8Embedded5RoundIiEET_f, LINKORDER=||i._ZN4Anki8Embedded5RoundIiEET_f||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.391||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded5RoundIiEET_f||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded8AreValidINS0_5ArrayIhEENS2_IfEEEEbRKT_RKT0_||, COMGROUP=_ZN4Anki8Embedded8AreValidINS0_5ArrayIhEENS2_IfEEEEbRKT_RKT0_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded8AreValidINS0_5ArrayIhEENS2_IfEEEEbRKT_RKT0_ PROC ; Anki::Embedded::AreValid<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<float>>(const T1&, const T2&)
;;;80     
;;;81         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2)
000000  b510              PUSH     {r4,lr}
;;;82         {
000002  6902              LDR      r2,[r0,#0x10]
000004  b162              CBZ      r2,|L397.32|
000006  6802              LDR      r2,[r0,#0]
000008  2a00              CMP      r2,#0
00000a  bfa4              ITT      GE
00000c  6840              LDRGE    r0,[r0,#4]
00000e  2800              CMPGE    r0,#0
000010  db06              BLT      |L397.32|
;;;83           if(!object1.IsValid() || !object2.IsValid())
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000018  2800              CMP      r0,#0
;;;84             return false;
;;;85     
;;;86           return true;
00001a  bf1c              ITT      NE
00001c  2001              MOVNE    r0,#1
;;;87         }
00001e  bd10              POPNE    {r4,pc}
                  |L397.32|
000020  2000              MOVS     r0,#0                 ;84
000022  bd10              POP      {r4,pc}
;;;88     
                          ENDP


                          AREA ||area_number.398||, COMGROUP=_ZN4Anki8Embedded8AreValidINS0_5ArrayIhEENS2_IfEEEEbRKT_RKT0_, LINKORDER=||t._ZN4Anki8Embedded8AreValidINS0_5ArrayIhEENS2_IfEEEEbRKT_RKT0_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.398||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded8AreValidINS0_5ArrayIhEENS2_IfEEEEbRKT_RKT0_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_3AddIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_3AddIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_3AddIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE PROC ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::Add<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, const Anki::Embedded::ConstArraySliceExpression<T1>&, Anki::Embedded::ArraySlice<T3>)
;;;1819         {
;;;1820           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
000000  b40f              PUSH     {r0-r3}
;;;1821           {
000002  e92d47f0          PUSH     {r4-r10,lr}
000006  b0a8              SUB      sp,sp,#0xa0
000008  4607              MOV      r7,r0
00000a  f1000518          ADD      r5,r0,#0x18
00000e  4688              MOV      r8,r1
000010  f1010418          ADD      r4,r1,#0x18
000014  ae38              ADD      r6,sp,#0xe0
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
;;;1822             const Array<InType> &in1Array = in1.get_array();
;;;1823             const Array<InType> &in2Array = in2.get_array();
;;;1824             Array<OutType> &out1Array = out.get_array();
;;;1825   
;;;1826             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, in2Array, out1Array),
00001c  f8df92e4          LDR      r9,|L404.772|
000020  2800              CMP      r0,#0
000022  d07d              BEQ      |L404.288|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00002a  2800              CMP      r0,#0
00002c  d078              BEQ      |L404.288|
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000034  2800              CMP      r0,#0
000036  d073              BEQ      |L404.288|
000038  f8981030          LDRB     r1,[r8,#0x30]
00003c  f8973030          LDRB     r3,[r7,#0x30]
;;;1827               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1828   
;;;1829             ArraySliceLimits_in2_out1<s32> limits(
000040  a832              ADD      r0,sp,#0xc8
000042  e9cd1002          STRD     r1,r0,[sp,#8]
000046  f1080c0c          ADD      r12,r8,#0xc
00004a  e9cd8c00          STRD     r8,r12,[sp,#0]
00004e  f10d0ad4          ADD      r10,sp,#0xd4
000052  f107020c          ADD      r2,r7,#0xc
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  4639              MOV      r1,r7
00005c  a806              ADD      r0,sp,#0x18
00005e  f7fffffe          BL       _ZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_ ; Anki::Embedded::ArraySliceLimits_in2_out1<int>::ArraySliceLimits_in2_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
;;;1830               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1831               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1832               out.get_ySlice(), out.get_xSlice());
;;;1833   
;;;1834             AnkiConditionalErrorAndReturnValue(limits.isValid,
000062  f89d0018          LDRB     r0,[sp,#0x18]
000066  2800              CMP      r0,#0
000068  d06f              BEQ      |L404.330|
;;;1835               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1836   
;;;1837             if(limits.isSimpleIteration) {
00006a  f89d0019          LDRB     r0,[sp,#0x19]
00006e  2800              CMP      r0,#0
000070  f00080b8          BEQ.W    |L404.484|
;;;1838               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1839   
;;;1840               for(s32 y=0; y<limits.ySize; y++) {
000074  980d              LDR      r0,[sp,#0x34]
000076  2700              MOVS     r7,#0
000078  2800              CMP      r0,#0
00007a  f3408112          BLE.W    |L404.674|
                  |L404.126|
00007e  9809              LDR      r0,[sp,#0x24]
000080  68aa              LDR      r2,[r5,#8]
000082  6929              LDR      r1,[r5,#0x10]
000084  68a3              LDR      r3,[r4,#8]
000086  fb001102          MLA      r1,r0,r2,r1
00008a  980b              LDR      r0,[sp,#0x2c]
00008c  6922              LDR      r2,[r4,#0x10]
00008e  f8d6c008          LDR      r12,[r6,#8]
000092  fb002203          MLA      r2,r0,r3,r2
000096  9807              LDR      r0,[sp,#0x1c]
000098  6933              LDR      r3,[r6,#0x10]
00009a  fb00330c          MLA      r3,r0,r12,r3
00009e  f89d0019          LDRB     r0,[sp,#0x19]
0000a2  2800              CMP      r0,#0
0000a4  9814              LDR      r0,[sp,#0x50]
0000a6  9008              STR      r0,[sp,#0x20]
0000a8  d06e              BEQ      |L404.392|
0000aa  981a              LDR      r0,[sp,#0x68]
0000ac  900a              STR      r0,[sp,#0x28]
0000ae  9821              LDR      r0,[sp,#0x84]
0000b0  900c              STR      r0,[sp,#0x30]
                  |L404.178|
;;;1841                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1842                 const InType * const pIn2 = in2Array.Pointer(limits.in2Y, 0);
;;;1843                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1844   
;;;1845                 limits.OuterIncrementTop();
;;;1846   
;;;1847                 for(s32 x=0; x<limits.xSize; x++) {
0000b2  f8ddc038          LDR      r12,[sp,#0x38]
0000b6  2000              MOVS     r0,#0
0000b8  f1bc0f00          CMP      r12,#0
0000bc  dd2d              BLE      |L404.282|
                  |L404.190|
;;;1848                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], pIn2[limits.in2X]);
0000be  f8ddc028          LDR      r12,[sp,#0x28]
0000c2  1c40              ADDS     r0,r0,#1              ;1847
0000c4  eb010c8c          ADD      r12,r1,r12,LSL #2
0000c8  eddc0a00          VLDR     s1,[r12,#0]
0000cc  f8ddc030          LDR      r12,[sp,#0x30]
0000d0  eb020c8c          ADD      r12,r2,r12,LSL #2
0000d4  ed9c0a00          VLDR     s0,[r12,#0]
0000d8  f8ddc020          LDR      r12,[sp,#0x20]
0000dc  ee300a80          VADD.F32 s0,s1,s0
0000e0  eb030c8c          ADD      r12,r3,r12,LSL #2
0000e4  ed8c0a00          VSTR     s0,[r12,#0]
;;;1849   
;;;1850                   limits.in1X += limits.in1_xInnerIncrement;
0000e8  f8ddc028          LDR      r12,[sp,#0x28]
0000ec  f8dd8040          LDR      r8,[sp,#0x40]
0000f0  44c4              ADD      r12,r12,r8
;;;1851                   limits.in2X += limits.in2_xInnerIncrement;
0000f2  f8cdc028          STR      r12,[sp,#0x28]
0000f6  f8ddc030          LDR      r12,[sp,#0x30]
0000fa  f8dd8048          LDR      r8,[sp,#0x48]
0000fe  44c4              ADD      r12,r12,r8
;;;1852                   limits.out1X += limits.out1_xInnerIncrement;
000100  f8cdc030          STR      r12,[sp,#0x30]
000104  f8ddc020          LDR      r12,[sp,#0x20]
000108  f8dd803c          LDR      r8,[sp,#0x3c]
00010c  44c4              ADD      r12,r12,r8
00010e  f8cdc020          STR      r12,[sp,#0x20]        ;1847
000112  f8ddc038          LDR      r12,[sp,#0x38]        ;1847
000116  4584              CMP      r12,r0                ;1847
000118  dcd1              BGT      |L404.190|
                  |L404.282|
00011a  f89d0019          LDRB     r0,[sp,#0x19]         ;1847
00011e  e000              B        |L404.290|
                  |L404.288|
000120  e014              B        |L404.332|
                  |L404.290|
000122  2800              CMP      r0,#0                 ;1847
000124  d041              BEQ      |L404.426|
000126  991e              LDR      r1,[sp,#0x78]         ;1847
000128  9809              LDR      r0,[sp,#0x24]         ;1847
00012a  4408              ADD      r0,r0,r1              ;1847
00012c  9009              STR      r0,[sp,#0x24]         ;1847
00012e  9925              LDR      r1,[sp,#0x94]         ;1847
000130  980b              LDR      r0,[sp,#0x2c]         ;1847
000132  4408              ADD      r0,r0,r1              ;1847
000134  900b              STR      r0,[sp,#0x2c]         ;1847
000136  9918              LDR      r1,[sp,#0x60]         ;1847
000138  9807              LDR      r0,[sp,#0x1c]         ;1847
00013a  4408              ADD      r0,r0,r1              ;1847
00013c  9007              STR      r0,[sp,#0x1c]         ;1847
                  |L404.318|
00013e  980d              LDR      r0,[sp,#0x34]         ;1840
000140  1c7f              ADDS     r7,r7,#1              ;1840
000142  42b8              CMP      r0,r7                 ;1840
000144  dc9b              BGT      |L404.126|
000146  f000b8ac          B.W      |L404.674|
                  |L404.330|
00014a  e010              B        |L404.366|
                  |L404.332|
00014c  f2407022          MOV      r0,#0x722             ;1826
000150  e9cd9000          STRD     r9,r0,[sp,#0]         ;1826
000154  a36c              ADR      r3,|L404.776|
000156  a27a              ADR      r2,|L404.832|
000158  a17d              ADR      r1,|L404.848|
00015a  2005              MOVS     r0,#5                 ;1826
00015c  f7fffffe          BL       _Anki_Log
000160  f04f6080          MOV      r0,#0x4000000         ;1826
                  |L404.356|
;;;1853                 }
;;;1854   
;;;1855                 limits.OuterIncrementBottom();
;;;1856               }
;;;1857             } else { // if(limits.isSimpleIteration)
;;;1858               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1859   
;;;1860               for(s32 y=0; y<limits.ySize; y++) {
;;;1861                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1862   
;;;1863                 limits.OuterIncrementTop();
;;;1864   
;;;1865                 for(s32 x=0; x<limits.xSize; x++) {
;;;1866                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1867                   const InType valIn2 = *in2Array.Pointer(limits.in2Y, limits.in2X);
;;;1868   
;;;1869                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, valIn2);
;;;1870   
;;;1871                   limits.in1X += limits.in1_xInnerIncrement;
;;;1872                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1873                   limits.in2X += limits.in2_xInnerIncrement;
;;;1874                   limits.in2Y += limits.in2_yInnerIncrement;
;;;1875                   limits.out1X += limits.out1_xInnerIncrement;
;;;1876                 }
;;;1877   
;;;1878                 limits.OuterIncrementBottom();
;;;1879               }
;;;1880             } //   if(limits.isSimpleIteration)  ... else
;;;1881   
;;;1882             return RESULT_OK;
;;;1883           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
000164  b028              ADD      sp,sp,#0xa0
000166  e8bd07f0          POP      {r4-r10}
00016a  f85dfb14          LDR      pc,[sp],#0x14
                  |L404.366|
00016e  f240702a          MOV      r0,#0x72a             ;1834
000172  e9cd9000          STRD     r9,r0,[sp,#0]         ;1834
000176  a364              ADR      r3,|L404.776|
000178  a27e              ADR      r2,|L404.884|
00017a  a175              ADR      r1,|L404.848|
00017c  2005              MOVS     r0,#5                 ;1834
00017e  f7fffffe          BL       _Anki_Log
000182  f04f6080          MOV      r0,#0x4000000         ;1834
000186  e7ed              B        |L404.356|
                  |L404.392|
000188  f89d0080          LDRB     r0,[sp,#0x80]         ;1834
00018c  2800              CMP      r0,#0                 ;1834
00018e  bf19              ITTEE    NE                    ;1834
000190  981d              LDRNE    r0,[sp,#0x74]         ;1834
000192  9009              STRNE    r0,[sp,#0x24]         ;1834
000194  981a              LDREQ    r0,[sp,#0x68]         ;1834
000196  900a              STREQ    r0,[sp,#0x28]         ;1834
000198  f89d009c          LDRB     r0,[sp,#0x9c]         ;1834
00019c  2800              CMP      r0,#0                 ;1834
00019e  bf19              ITTEE    NE                    ;1834
0001a0  9824              LDRNE    r0,[sp,#0x90]         ;1834
0001a2  900b              STRNE    r0,[sp,#0x2c]         ;1834
0001a4  9821              LDREQ    r0,[sp,#0x84]         ;1834
0001a6  900c              STREQ    r0,[sp,#0x30]         ;1834
0001a8  e783              B        |L404.178|
                  |L404.426|
0001aa  9918              LDR      r1,[sp,#0x60]         ;1834
0001ac  9807              LDR      r0,[sp,#0x1c]         ;1834
0001ae  4408              ADD      r0,r0,r1              ;1834
0001b0  9007              STR      r0,[sp,#0x1c]         ;1834
0001b2  f89d0080          LDRB     r0,[sp,#0x80]         ;1834
0001b6  2800              CMP      r0,#0                 ;1834
0001b8  bf19              ITTEE    NE                    ;1834
0001ba  991b              LDRNE    r1,[sp,#0x6c]         ;1834
0001bc  980a              LDRNE    r0,[sp,#0x28]         ;1834
0001be  991e              LDREQ    r1,[sp,#0x78]         ;1834
0001c0  9809              LDREQ    r0,[sp,#0x24]         ;1834
0001c2  4408              ADD      r0,r0,r1              ;1834
0001c4  bf14              ITE      NE                    ;1834
0001c6  900a              STRNE    r0,[sp,#0x28]         ;1834
0001c8  9009              STREQ    r0,[sp,#0x24]         ;1834
0001ca  f89d009c          LDRB     r0,[sp,#0x9c]         ;1834
0001ce  2800              CMP      r0,#0                 ;1834
0001d0  bf19              ITTEE    NE                    ;1834
0001d2  9922              LDRNE    r1,[sp,#0x88]         ;1834
0001d4  980c              LDRNE    r0,[sp,#0x30]         ;1834
0001d6  9925              LDREQ    r1,[sp,#0x94]         ;1834
0001d8  980b              LDREQ    r0,[sp,#0x2c]         ;1834
0001da  4408              ADD      r0,r0,r1              ;1834
0001dc  bf14              ITE      NE                    ;1834
0001de  900c              STRNE    r0,[sp,#0x30]         ;1834
0001e0  900b              STREQ    r0,[sp,#0x2c]         ;1834
0001e2  e7ac              B        |L404.318|
                  |L404.484|
0001e4  980d              LDR      r0,[sp,#0x34]         ;1860
0001e6  2300              MOVS     r3,#0                 ;1860
0001e8  2800              CMP      r0,#0                 ;1860
0001ea  dd5a              BLE      |L404.674|
                  |L404.492|
0001ec  9807              LDR      r0,[sp,#0x1c]         ;1860
0001ee  68b2              LDR      r2,[r6,#8]            ;1860
0001f0  6931              LDR      r1,[r6,#0x10]         ;1860
0001f2  fb001c02          MLA      r12,r0,r2,r1          ;1860
0001f6  f89d0019          LDRB     r0,[sp,#0x19]         ;1860
0001fa  2800              CMP      r0,#0                 ;1860
0001fc  9814              LDR      r0,[sp,#0x50]         ;1860
0001fe  9008              STR      r0,[sp,#0x20]         ;1860
000200  d051              BEQ      |L404.678|
000202  981a              LDR      r0,[sp,#0x68]         ;1860
000204  900a              STR      r0,[sp,#0x28]         ;1860
000206  9821              LDR      r0,[sp,#0x84]         ;1860
000208  900c              STR      r0,[sp,#0x30]         ;1860
                  |L404.522|
00020a  990e              LDR      r1,[sp,#0x38]         ;1865
00020c  2000              MOVS     r0,#0                 ;1865
00020e  2900              CMP      r1,#0                 ;1865
000210  dd34              BLE      |L404.636|
                  |L404.530|
000212  e9dd2109          LDRD     r2,r1,[sp,#0x24]      ;1865
000216  f8d58008          LDR      r8,[r5,#8]            ;1865
00021a  692f              LDR      r7,[r5,#0x10]         ;1865
00021c  1c40              ADDS     r0,r0,#1              ;1865
00021e  fb027208          MLA      r2,r2,r8,r7           ;1865
000222  eb020181          ADD      r1,r2,r1,LSL #2       ;1865
000226  f8d48008          LDR      r8,[r4,#8]            ;1865
00022a  ed910a00          VLDR     s0,[r1,#0]            ;1866
00022e  e9dd210b          LDRD     r2,r1,[sp,#0x2c]      ;1866
000232  6927              LDR      r7,[r4,#0x10]         ;1866
000234  fb027208          MLA      r2,r2,r8,r7           ;1866
000238  eb020181          ADD      r1,r2,r1,LSL #2       ;1866
00023c  edd10a00          VLDR     s1,[r1,#0]            ;1867
000240  9908              LDR      r1,[sp,#0x20]         ;1869
000242  ee300a20          VADD.F32 s0,s0,s1              ;1869
000246  eb0c0181          ADD      r1,r12,r1,LSL #2      ;1869
00024a  ed810a00          VSTR     s0,[r1,#0]            ;1869
00024e  9a10              LDR      r2,[sp,#0x40]         ;1871
000250  990a              LDR      r1,[sp,#0x28]         ;1871
000252  4411              ADD      r1,r1,r2              ;1871
000254  910a              STR      r1,[sp,#0x28]         ;1872
000256  9a11              LDR      r2,[sp,#0x44]         ;1872
000258  9909              LDR      r1,[sp,#0x24]         ;1872
00025a  4411              ADD      r1,r1,r2              ;1872
00025c  9109              STR      r1,[sp,#0x24]         ;1873
00025e  9a12              LDR      r2,[sp,#0x48]         ;1873
000260  990c              LDR      r1,[sp,#0x30]         ;1873
000262  4411              ADD      r1,r1,r2              ;1873
000264  910c              STR      r1,[sp,#0x30]         ;1874
000266  9a13              LDR      r2,[sp,#0x4c]         ;1874
000268  990b              LDR      r1,[sp,#0x2c]         ;1874
00026a  4411              ADD      r1,r1,r2              ;1874
00026c  910b              STR      r1,[sp,#0x2c]         ;1875
00026e  9a0f              LDR      r2,[sp,#0x3c]         ;1875
000270  9908              LDR      r1,[sp,#0x20]         ;1875
000272  4411              ADD      r1,r1,r2              ;1875
000274  9108              STR      r1,[sp,#0x20]         ;1865
000276  990e              LDR      r1,[sp,#0x38]         ;1865
000278  4281              CMP      r1,r0                 ;1865
00027a  dcca              BGT      |L404.530|
                  |L404.636|
00027c  f89d0019          LDRB     r0,[sp,#0x19]         ;1865
000280  b310              CBZ      r0,|L404.712|
000282  991e              LDR      r1,[sp,#0x78]         ;1865
000284  9809              LDR      r0,[sp,#0x24]         ;1865
000286  4408              ADD      r0,r0,r1              ;1865
000288  9009              STR      r0,[sp,#0x24]         ;1865
00028a  9925              LDR      r1,[sp,#0x94]         ;1865
00028c  980b              LDR      r0,[sp,#0x2c]         ;1865
00028e  4408              ADD      r0,r0,r1              ;1865
000290  900b              STR      r0,[sp,#0x2c]         ;1865
000292  9918              LDR      r1,[sp,#0x60]         ;1865
000294  9807              LDR      r0,[sp,#0x1c]         ;1865
000296  4408              ADD      r0,r0,r1              ;1865
000298  9007              STR      r0,[sp,#0x1c]         ;1865
                  |L404.666|
00029a  980d              LDR      r0,[sp,#0x34]         ;1860
00029c  1c5b              ADDS     r3,r3,#1              ;1860
00029e  4298              CMP      r0,r3                 ;1860
0002a0  dca4              BGT      |L404.492|
                  |L404.674|
0002a2  2000              MOVS     r0,#0                 ;1882
0002a4  e75e              B        |L404.356|
                  |L404.678|
0002a6  f89d0080          LDRB     r0,[sp,#0x80]         ;1882
0002aa  2800              CMP      r0,#0                 ;1882
0002ac  bf19              ITTEE    NE                    ;1882
0002ae  981d              LDRNE    r0,[sp,#0x74]         ;1882
0002b0  9009              STRNE    r0,[sp,#0x24]         ;1882
0002b2  981a              LDREQ    r0,[sp,#0x68]         ;1882
0002b4  900a              STREQ    r0,[sp,#0x28]         ;1882
0002b6  f89d009c          LDRB     r0,[sp,#0x9c]         ;1882
0002ba  2800              CMP      r0,#0                 ;1882
0002bc  bf19              ITTEE    NE                    ;1882
0002be  9824              LDRNE    r0,[sp,#0x90]         ;1882
0002c0  900b              STRNE    r0,[sp,#0x2c]         ;1882
0002c2  9821              LDREQ    r0,[sp,#0x84]         ;1882
0002c4  900c              STREQ    r0,[sp,#0x30]         ;1882
0002c6  e7a0              B        |L404.522|
                  |L404.712|
0002c8  9918              LDR      r1,[sp,#0x60]         ;1882
0002ca  9807              LDR      r0,[sp,#0x1c]         ;1882
0002cc  4408              ADD      r0,r0,r1              ;1882
0002ce  9007              STR      r0,[sp,#0x1c]         ;1882
0002d0  f89d0080          LDRB     r0,[sp,#0x80]         ;1882
0002d4  2800              CMP      r0,#0                 ;1882
0002d6  bf19              ITTEE    NE                    ;1882
0002d8  991b              LDRNE    r1,[sp,#0x6c]         ;1882
0002da  980a              LDRNE    r0,[sp,#0x28]         ;1882
0002dc  991e              LDREQ    r1,[sp,#0x78]         ;1882
0002de  9809              LDREQ    r0,[sp,#0x24]         ;1882
0002e0  4408              ADD      r0,r0,r1              ;1882
0002e2  bf14              ITE      NE                    ;1882
0002e4  900a              STRNE    r0,[sp,#0x28]         ;1882
0002e6  9009              STREQ    r0,[sp,#0x24]         ;1882
0002e8  f89d009c          LDRB     r0,[sp,#0x9c]         ;1882
0002ec  2800              CMP      r0,#0                 ;1882
0002ee  bf19              ITTEE    NE                    ;1882
0002f0  9922              LDRNE    r1,[sp,#0x88]         ;1882
0002f2  980c              LDRNE    r0,[sp,#0x30]         ;1882
0002f4  9925              LDREQ    r1,[sp,#0x94]         ;1882
0002f6  980b              LDREQ    r0,[sp,#0x2c]         ;1882
0002f8  4408              ADD      r0,r0,r1              ;1882
0002fa  bf14              ITE      NE                    ;1882
0002fc  900c              STRNE    r0,[sp,#0x30]         ;1882
0002fe  900b              STREQ    r0,[sp,#0x2c]         ;1882
000300  e7cb              B        |L404.666|
;;;1884   
                          ENDP

000302  0000              DCW      0x0000
                  |L404.772|
                          DCD      _ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_3AddIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::Add<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, const Anki::Embedded::ConstArraySliceExpression<T1>&, Anki::Embedded::ArraySlice<T3>)::__PRETTY_FUNCTION__
                  |L404.776|
000308  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
00030c  6f726574
000310  6563685c
000314  636f6d6d
000318  6f6e5c69
00031c  6e636c75
000320  64655c61
000324  6e6b692f
000328  636f6d6d
00032c  6f6e2f72
000330  6f626f74
000334  2f6d6174
000338  726978  
00033b  2e6800            DCB      ".h",0
00033e  00                DCB      0
00033f  00                DCB      0
                  |L404.832|
000340  496e7661          DCB      "Invalid objects",0
000344  6c696420
000348  6f626a65
00034c  63747300
                  |L404.848|
000350  4d617472          DCB      "Matrix::Elementwise::ApplyOperation",0
000354  69783a3a
000358  456c656d
00035c  656e7477
000360  6973653a
000364  3a417070
000368  6c794f70
00036c  65726174
000370  696f6e00
                  |L404.884|
000374  4c696d69          DCB      "Limits is not valid",0
000378  74732069
00037c  73206e6f
000380  74207661
000384  6c696400

                          AREA ||area_number.405||, COMGROUP=_ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_3AddIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_3AddIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.405||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_3AddIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_11DotMultiplyIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_11DotMultiplyIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_11DotMultiplyIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE PROC ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::DotMultiply<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, const Anki::Embedded::ConstArraySliceExpression<T1>&, Anki::Embedded::ArraySlice<T3>)
;;;1819         {
;;;1820           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
000000  b40f              PUSH     {r0-r3}
;;;1821           {
000002  e92d47f0          PUSH     {r4-r10,lr}
000006  b0a8              SUB      sp,sp,#0xa0
000008  4607              MOV      r7,r0
00000a  f1000518          ADD      r5,r0,#0x18
00000e  4688              MOV      r8,r1
000010  f1010418          ADD      r4,r1,#0x18
000014  ae38              ADD      r6,sp,#0xe0
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
;;;1822             const Array<InType> &in1Array = in1.get_array();
;;;1823             const Array<InType> &in2Array = in2.get_array();
;;;1824             Array<OutType> &out1Array = out.get_array();
;;;1825   
;;;1826             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, in2Array, out1Array),
00001c  f8df92e4          LDR      r9,|L411.772|
000020  2800              CMP      r0,#0
000022  d07d              BEQ      |L411.288|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00002a  2800              CMP      r0,#0
00002c  d078              BEQ      |L411.288|
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000034  2800              CMP      r0,#0
000036  d073              BEQ      |L411.288|
000038  f8981030          LDRB     r1,[r8,#0x30]
00003c  f8973030          LDRB     r3,[r7,#0x30]
;;;1827               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1828   
;;;1829             ArraySliceLimits_in2_out1<s32> limits(
000040  a832              ADD      r0,sp,#0xc8
000042  e9cd1002          STRD     r1,r0,[sp,#8]
000046  f1080c0c          ADD      r12,r8,#0xc
00004a  e9cd8c00          STRD     r8,r12,[sp,#0]
00004e  f10d0ad4          ADD      r10,sp,#0xd4
000052  f107020c          ADD      r2,r7,#0xc
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  4639              MOV      r1,r7
00005c  a806              ADD      r0,sp,#0x18
00005e  f7fffffe          BL       _ZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_ ; Anki::Embedded::ArraySliceLimits_in2_out1<int>::ArraySliceLimits_in2_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
;;;1830               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1831               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1832               out.get_ySlice(), out.get_xSlice());
;;;1833   
;;;1834             AnkiConditionalErrorAndReturnValue(limits.isValid,
000062  f89d0018          LDRB     r0,[sp,#0x18]
000066  2800              CMP      r0,#0
000068  d06f              BEQ      |L411.330|
;;;1835               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1836   
;;;1837             if(limits.isSimpleIteration) {
00006a  f89d0019          LDRB     r0,[sp,#0x19]
00006e  2800              CMP      r0,#0
000070  f00080b8          BEQ.W    |L411.484|
;;;1838               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1839   
;;;1840               for(s32 y=0; y<limits.ySize; y++) {
000074  980d              LDR      r0,[sp,#0x34]
000076  2700              MOVS     r7,#0
000078  2800              CMP      r0,#0
00007a  f3408112          BLE.W    |L411.674|
                  |L411.126|
00007e  9809              LDR      r0,[sp,#0x24]
000080  68aa              LDR      r2,[r5,#8]
000082  6929              LDR      r1,[r5,#0x10]
000084  68a3              LDR      r3,[r4,#8]
000086  fb001102          MLA      r1,r0,r2,r1
00008a  980b              LDR      r0,[sp,#0x2c]
00008c  6922              LDR      r2,[r4,#0x10]
00008e  f8d6c008          LDR      r12,[r6,#8]
000092  fb002203          MLA      r2,r0,r3,r2
000096  9807              LDR      r0,[sp,#0x1c]
000098  6933              LDR      r3,[r6,#0x10]
00009a  fb00330c          MLA      r3,r0,r12,r3
00009e  f89d0019          LDRB     r0,[sp,#0x19]
0000a2  2800              CMP      r0,#0
0000a4  9814              LDR      r0,[sp,#0x50]
0000a6  9008              STR      r0,[sp,#0x20]
0000a8  d06e              BEQ      |L411.392|
0000aa  981a              LDR      r0,[sp,#0x68]
0000ac  900a              STR      r0,[sp,#0x28]
0000ae  9821              LDR      r0,[sp,#0x84]
0000b0  900c              STR      r0,[sp,#0x30]
                  |L411.178|
;;;1841                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1842                 const InType * const pIn2 = in2Array.Pointer(limits.in2Y, 0);
;;;1843                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1844   
;;;1845                 limits.OuterIncrementTop();
;;;1846   
;;;1847                 for(s32 x=0; x<limits.xSize; x++) {
0000b2  f8ddc038          LDR      r12,[sp,#0x38]
0000b6  2000              MOVS     r0,#0
0000b8  f1bc0f00          CMP      r12,#0
0000bc  dd2d              BLE      |L411.282|
                  |L411.190|
;;;1848                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], pIn2[limits.in2X]);
0000be  f8ddc028          LDR      r12,[sp,#0x28]
0000c2  1c40              ADDS     r0,r0,#1              ;1847
0000c4  eb010c8c          ADD      r12,r1,r12,LSL #2
0000c8  eddc0a00          VLDR     s1,[r12,#0]
0000cc  f8ddc030          LDR      r12,[sp,#0x30]
0000d0  eb020c8c          ADD      r12,r2,r12,LSL #2
0000d4  ed9c0a00          VLDR     s0,[r12,#0]
0000d8  f8ddc020          LDR      r12,[sp,#0x20]
0000dc  ee200a80          VMUL.F32 s0,s1,s0
0000e0  eb030c8c          ADD      r12,r3,r12,LSL #2
0000e4  ed8c0a00          VSTR     s0,[r12,#0]
;;;1849   
;;;1850                   limits.in1X += limits.in1_xInnerIncrement;
0000e8  f8ddc028          LDR      r12,[sp,#0x28]
0000ec  f8dd8040          LDR      r8,[sp,#0x40]
0000f0  44c4              ADD      r12,r12,r8
;;;1851                   limits.in2X += limits.in2_xInnerIncrement;
0000f2  f8cdc028          STR      r12,[sp,#0x28]
0000f6  f8ddc030          LDR      r12,[sp,#0x30]
0000fa  f8dd8048          LDR      r8,[sp,#0x48]
0000fe  44c4              ADD      r12,r12,r8
;;;1852                   limits.out1X += limits.out1_xInnerIncrement;
000100  f8cdc030          STR      r12,[sp,#0x30]
000104  f8ddc020          LDR      r12,[sp,#0x20]
000108  f8dd803c          LDR      r8,[sp,#0x3c]
00010c  44c4              ADD      r12,r12,r8
00010e  f8cdc020          STR      r12,[sp,#0x20]        ;1847
000112  f8ddc038          LDR      r12,[sp,#0x38]        ;1847
000116  4584              CMP      r12,r0                ;1847
000118  dcd1              BGT      |L411.190|
                  |L411.282|
00011a  f89d0019          LDRB     r0,[sp,#0x19]         ;1847
00011e  e000              B        |L411.290|
                  |L411.288|
000120  e014              B        |L411.332|
                  |L411.290|
000122  2800              CMP      r0,#0                 ;1847
000124  d041              BEQ      |L411.426|
000126  991e              LDR      r1,[sp,#0x78]         ;1847
000128  9809              LDR      r0,[sp,#0x24]         ;1847
00012a  4408              ADD      r0,r0,r1              ;1847
00012c  9009              STR      r0,[sp,#0x24]         ;1847
00012e  9925              LDR      r1,[sp,#0x94]         ;1847
000130  980b              LDR      r0,[sp,#0x2c]         ;1847
000132  4408              ADD      r0,r0,r1              ;1847
000134  900b              STR      r0,[sp,#0x2c]         ;1847
000136  9918              LDR      r1,[sp,#0x60]         ;1847
000138  9807              LDR      r0,[sp,#0x1c]         ;1847
00013a  4408              ADD      r0,r0,r1              ;1847
00013c  9007              STR      r0,[sp,#0x1c]         ;1847
                  |L411.318|
00013e  980d              LDR      r0,[sp,#0x34]         ;1840
000140  1c7f              ADDS     r7,r7,#1              ;1840
000142  42b8              CMP      r0,r7                 ;1840
000144  dc9b              BGT      |L411.126|
000146  f000b8ac          B.W      |L411.674|
                  |L411.330|
00014a  e010              B        |L411.366|
                  |L411.332|
00014c  f2407022          MOV      r0,#0x722             ;1826
000150  e9cd9000          STRD     r9,r0,[sp,#0]         ;1826
000154  a36c              ADR      r3,|L411.776|
000156  a27a              ADR      r2,|L411.832|
000158  a17d              ADR      r1,|L411.848|
00015a  2005              MOVS     r0,#5                 ;1826
00015c  f7fffffe          BL       _Anki_Log
000160  f04f6080          MOV      r0,#0x4000000         ;1826
                  |L411.356|
;;;1853                 }
;;;1854   
;;;1855                 limits.OuterIncrementBottom();
;;;1856               }
;;;1857             } else { // if(limits.isSimpleIteration)
;;;1858               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1859   
;;;1860               for(s32 y=0; y<limits.ySize; y++) {
;;;1861                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1862   
;;;1863                 limits.OuterIncrementTop();
;;;1864   
;;;1865                 for(s32 x=0; x<limits.xSize; x++) {
;;;1866                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1867                   const InType valIn2 = *in2Array.Pointer(limits.in2Y, limits.in2X);
;;;1868   
;;;1869                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, valIn2);
;;;1870   
;;;1871                   limits.in1X += limits.in1_xInnerIncrement;
;;;1872                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1873                   limits.in2X += limits.in2_xInnerIncrement;
;;;1874                   limits.in2Y += limits.in2_yInnerIncrement;
;;;1875                   limits.out1X += limits.out1_xInnerIncrement;
;;;1876                 }
;;;1877   
;;;1878                 limits.OuterIncrementBottom();
;;;1879               }
;;;1880             } //   if(limits.isSimpleIteration)  ... else
;;;1881   
;;;1882             return RESULT_OK;
;;;1883           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
000164  b028              ADD      sp,sp,#0xa0
000166  e8bd07f0          POP      {r4-r10}
00016a  f85dfb14          LDR      pc,[sp],#0x14
                  |L411.366|
00016e  f240702a          MOV      r0,#0x72a             ;1834
000172  e9cd9000          STRD     r9,r0,[sp,#0]         ;1834
000176  a364              ADR      r3,|L411.776|
000178  a27e              ADR      r2,|L411.884|
00017a  a175              ADR      r1,|L411.848|
00017c  2005              MOVS     r0,#5                 ;1834
00017e  f7fffffe          BL       _Anki_Log
000182  f04f6080          MOV      r0,#0x4000000         ;1834
000186  e7ed              B        |L411.356|
                  |L411.392|
000188  f89d0080          LDRB     r0,[sp,#0x80]         ;1834
00018c  2800              CMP      r0,#0                 ;1834
00018e  bf19              ITTEE    NE                    ;1834
000190  981d              LDRNE    r0,[sp,#0x74]         ;1834
000192  9009              STRNE    r0,[sp,#0x24]         ;1834
000194  981a              LDREQ    r0,[sp,#0x68]         ;1834
000196  900a              STREQ    r0,[sp,#0x28]         ;1834
000198  f89d009c          LDRB     r0,[sp,#0x9c]         ;1834
00019c  2800              CMP      r0,#0                 ;1834
00019e  bf19              ITTEE    NE                    ;1834
0001a0  9824              LDRNE    r0,[sp,#0x90]         ;1834
0001a2  900b              STRNE    r0,[sp,#0x2c]         ;1834
0001a4  9821              LDREQ    r0,[sp,#0x84]         ;1834
0001a6  900c              STREQ    r0,[sp,#0x30]         ;1834
0001a8  e783              B        |L411.178|
                  |L411.426|
0001aa  9918              LDR      r1,[sp,#0x60]         ;1834
0001ac  9807              LDR      r0,[sp,#0x1c]         ;1834
0001ae  4408              ADD      r0,r0,r1              ;1834
0001b0  9007              STR      r0,[sp,#0x1c]         ;1834
0001b2  f89d0080          LDRB     r0,[sp,#0x80]         ;1834
0001b6  2800              CMP      r0,#0                 ;1834
0001b8  bf19              ITTEE    NE                    ;1834
0001ba  991b              LDRNE    r1,[sp,#0x6c]         ;1834
0001bc  980a              LDRNE    r0,[sp,#0x28]         ;1834
0001be  991e              LDREQ    r1,[sp,#0x78]         ;1834
0001c0  9809              LDREQ    r0,[sp,#0x24]         ;1834
0001c2  4408              ADD      r0,r0,r1              ;1834
0001c4  bf14              ITE      NE                    ;1834
0001c6  900a              STRNE    r0,[sp,#0x28]         ;1834
0001c8  9009              STREQ    r0,[sp,#0x24]         ;1834
0001ca  f89d009c          LDRB     r0,[sp,#0x9c]         ;1834
0001ce  2800              CMP      r0,#0                 ;1834
0001d0  bf19              ITTEE    NE                    ;1834
0001d2  9922              LDRNE    r1,[sp,#0x88]         ;1834
0001d4  980c              LDRNE    r0,[sp,#0x30]         ;1834
0001d6  9925              LDREQ    r1,[sp,#0x94]         ;1834
0001d8  980b              LDREQ    r0,[sp,#0x2c]         ;1834
0001da  4408              ADD      r0,r0,r1              ;1834
0001dc  bf14              ITE      NE                    ;1834
0001de  900c              STRNE    r0,[sp,#0x30]         ;1834
0001e0  900b              STREQ    r0,[sp,#0x2c]         ;1834
0001e2  e7ac              B        |L411.318|
                  |L411.484|
0001e4  980d              LDR      r0,[sp,#0x34]         ;1860
0001e6  2300              MOVS     r3,#0                 ;1860
0001e8  2800              CMP      r0,#0                 ;1860
0001ea  dd5a              BLE      |L411.674|
                  |L411.492|
0001ec  9807              LDR      r0,[sp,#0x1c]         ;1860
0001ee  68b2              LDR      r2,[r6,#8]            ;1860
0001f0  6931              LDR      r1,[r6,#0x10]         ;1860
0001f2  fb001c02          MLA      r12,r0,r2,r1          ;1860
0001f6  f89d0019          LDRB     r0,[sp,#0x19]         ;1860
0001fa  2800              CMP      r0,#0                 ;1860
0001fc  9814              LDR      r0,[sp,#0x50]         ;1860
0001fe  9008              STR      r0,[sp,#0x20]         ;1860
000200  d051              BEQ      |L411.678|
000202  981a              LDR      r0,[sp,#0x68]         ;1860
000204  900a              STR      r0,[sp,#0x28]         ;1860
000206  9821              LDR      r0,[sp,#0x84]         ;1860
000208  900c              STR      r0,[sp,#0x30]         ;1860
                  |L411.522|
00020a  990e              LDR      r1,[sp,#0x38]         ;1865
00020c  2000              MOVS     r0,#0                 ;1865
00020e  2900              CMP      r1,#0                 ;1865
000210  dd34              BLE      |L411.636|
                  |L411.530|
000212  e9dd2109          LDRD     r2,r1,[sp,#0x24]      ;1865
000216  f8d58008          LDR      r8,[r5,#8]            ;1865
00021a  692f              LDR      r7,[r5,#0x10]         ;1865
00021c  1c40              ADDS     r0,r0,#1              ;1865
00021e  fb027208          MLA      r2,r2,r8,r7           ;1865
000222  eb020181          ADD      r1,r2,r1,LSL #2       ;1865
000226  f8d48008          LDR      r8,[r4,#8]            ;1865
00022a  ed910a00          VLDR     s0,[r1,#0]            ;1866
00022e  e9dd210b          LDRD     r2,r1,[sp,#0x2c]      ;1866
000232  6927              LDR      r7,[r4,#0x10]         ;1866
000234  fb027208          MLA      r2,r2,r8,r7           ;1866
000238  eb020181          ADD      r1,r2,r1,LSL #2       ;1866
00023c  edd10a00          VLDR     s1,[r1,#0]            ;1867
000240  9908              LDR      r1,[sp,#0x20]         ;1869
000242  ee200a20          VMUL.F32 s0,s0,s1              ;1869
000246  eb0c0181          ADD      r1,r12,r1,LSL #2      ;1869
00024a  ed810a00          VSTR     s0,[r1,#0]            ;1869
00024e  9a10              LDR      r2,[sp,#0x40]         ;1871
000250  990a              LDR      r1,[sp,#0x28]         ;1871
000252  4411              ADD      r1,r1,r2              ;1871
000254  910a              STR      r1,[sp,#0x28]         ;1872
000256  9a11              LDR      r2,[sp,#0x44]         ;1872
000258  9909              LDR      r1,[sp,#0x24]         ;1872
00025a  4411              ADD      r1,r1,r2              ;1872
00025c  9109              STR      r1,[sp,#0x24]         ;1873
00025e  9a12              LDR      r2,[sp,#0x48]         ;1873
000260  990c              LDR      r1,[sp,#0x30]         ;1873
000262  4411              ADD      r1,r1,r2              ;1873
000264  910c              STR      r1,[sp,#0x30]         ;1874
000266  9a13              LDR      r2,[sp,#0x4c]         ;1874
000268  990b              LDR      r1,[sp,#0x2c]         ;1874
00026a  4411              ADD      r1,r1,r2              ;1874
00026c  910b              STR      r1,[sp,#0x2c]         ;1875
00026e  9a0f              LDR      r2,[sp,#0x3c]         ;1875
000270  9908              LDR      r1,[sp,#0x20]         ;1875
000272  4411              ADD      r1,r1,r2              ;1875
000274  9108              STR      r1,[sp,#0x20]         ;1865
000276  990e              LDR      r1,[sp,#0x38]         ;1865
000278  4281              CMP      r1,r0                 ;1865
00027a  dcca              BGT      |L411.530|
                  |L411.636|
00027c  f89d0019          LDRB     r0,[sp,#0x19]         ;1865
000280  b310              CBZ      r0,|L411.712|
000282  991e              LDR      r1,[sp,#0x78]         ;1865
000284  9809              LDR      r0,[sp,#0x24]         ;1865
000286  4408              ADD      r0,r0,r1              ;1865
000288  9009              STR      r0,[sp,#0x24]         ;1865
00028a  9925              LDR      r1,[sp,#0x94]         ;1865
00028c  980b              LDR      r0,[sp,#0x2c]         ;1865
00028e  4408              ADD      r0,r0,r1              ;1865
000290  900b              STR      r0,[sp,#0x2c]         ;1865
000292  9918              LDR      r1,[sp,#0x60]         ;1865
000294  9807              LDR      r0,[sp,#0x1c]         ;1865
000296  4408              ADD      r0,r0,r1              ;1865
000298  9007              STR      r0,[sp,#0x1c]         ;1865
                  |L411.666|
00029a  980d              LDR      r0,[sp,#0x34]         ;1860
00029c  1c5b              ADDS     r3,r3,#1              ;1860
00029e  4298              CMP      r0,r3                 ;1860
0002a0  dca4              BGT      |L411.492|
                  |L411.674|
0002a2  2000              MOVS     r0,#0                 ;1882
0002a4  e75e              B        |L411.356|
                  |L411.678|
0002a6  f89d0080          LDRB     r0,[sp,#0x80]         ;1882
0002aa  2800              CMP      r0,#0                 ;1882
0002ac  bf19              ITTEE    NE                    ;1882
0002ae  981d              LDRNE    r0,[sp,#0x74]         ;1882
0002b0  9009              STRNE    r0,[sp,#0x24]         ;1882
0002b2  981a              LDREQ    r0,[sp,#0x68]         ;1882
0002b4  900a              STREQ    r0,[sp,#0x28]         ;1882
0002b6  f89d009c          LDRB     r0,[sp,#0x9c]         ;1882
0002ba  2800              CMP      r0,#0                 ;1882
0002bc  bf19              ITTEE    NE                    ;1882
0002be  9824              LDRNE    r0,[sp,#0x90]         ;1882
0002c0  900b              STRNE    r0,[sp,#0x2c]         ;1882
0002c2  9821              LDREQ    r0,[sp,#0x84]         ;1882
0002c4  900c              STREQ    r0,[sp,#0x30]         ;1882
0002c6  e7a0              B        |L411.522|
                  |L411.712|
0002c8  9918              LDR      r1,[sp,#0x60]         ;1882
0002ca  9807              LDR      r0,[sp,#0x1c]         ;1882
0002cc  4408              ADD      r0,r0,r1              ;1882
0002ce  9007              STR      r0,[sp,#0x1c]         ;1882
0002d0  f89d0080          LDRB     r0,[sp,#0x80]         ;1882
0002d4  2800              CMP      r0,#0                 ;1882
0002d6  bf19              ITTEE    NE                    ;1882
0002d8  991b              LDRNE    r1,[sp,#0x6c]         ;1882
0002da  980a              LDRNE    r0,[sp,#0x28]         ;1882
0002dc  991e              LDREQ    r1,[sp,#0x78]         ;1882
0002de  9809              LDREQ    r0,[sp,#0x24]         ;1882
0002e0  4408              ADD      r0,r0,r1              ;1882
0002e2  bf14              ITE      NE                    ;1882
0002e4  900a              STRNE    r0,[sp,#0x28]         ;1882
0002e6  9009              STREQ    r0,[sp,#0x24]         ;1882
0002e8  f89d009c          LDRB     r0,[sp,#0x9c]         ;1882
0002ec  2800              CMP      r0,#0                 ;1882
0002ee  bf19              ITTEE    NE                    ;1882
0002f0  9922              LDRNE    r1,[sp,#0x88]         ;1882
0002f2  980c              LDRNE    r0,[sp,#0x30]         ;1882
0002f4  9925              LDREQ    r1,[sp,#0x94]         ;1882
0002f6  980b              LDREQ    r0,[sp,#0x2c]         ;1882
0002f8  4408              ADD      r0,r0,r1              ;1882
0002fa  bf14              ITE      NE                    ;1882
0002fc  900c              STRNE    r0,[sp,#0x30]         ;1882
0002fe  900b              STREQ    r0,[sp,#0x2c]         ;1882
000300  e7cb              B        |L411.666|
;;;1884   
                          ENDP

000302  0000              DCW      0x0000
                  |L411.772|
                          DCD      _ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_11DotMultiplyIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::DotMultiply<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, const Anki::Embedded::ConstArraySliceExpression<T1>&, Anki::Embedded::ArraySlice<T3>)::__PRETTY_FUNCTION__
                  |L411.776|
000308  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
00030c  6f726574
000310  6563685c
000314  636f6d6d
000318  6f6e5c69
00031c  6e636c75
000320  64655c61
000324  6e6b692f
000328  636f6d6d
00032c  6f6e2f72
000330  6f626f74
000334  2f6d6174
000338  726978  
00033b  2e6800            DCB      ".h",0
00033e  00                DCB      0
00033f  00                DCB      0
                  |L411.832|
000340  496e7661          DCB      "Invalid objects",0
000344  6c696420
000348  6f626a65
00034c  63747300
                  |L411.848|
000350  4d617472          DCB      "Matrix::Elementwise::ApplyOperation",0
000354  69783a3a
000358  456c656d
00035c  656e7477
000360  6973653a
000364  3a417070
000368  6c794f70
00036c  65726174
000370  696f6e00
                  |L411.884|
000374  4c696d69          DCB      "Limits is not valid",0
000378  74732069
00037c  73206e6f
000380  74207661
000384  6c696400

                          AREA ||area_number.412||, COMGROUP=_ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_11DotMultiplyIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_11DotMultiplyIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.412||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_11DotMultiplyIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L418.86|
00003a  217d              MOVS     r1,#0x7d
00003c  4850              LDR      r0,|L418.384|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a350              ADR      r3,|L418.388|
000044  a25d              ADR      r2,|L418.444|
000046  a161              ADR      r1,|L418.460|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L418.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  eb000040          ADD      r0,r0,r0,LSL #1
000066  300f              ADDS     r0,r0,#0xf
000068  f020050f          BIC      r5,r0,#0xf
00006c  a804              ADD      r0,sp,#0x10
00006e  e9cd0902          STRD     r0,r9,[sp,#8]
000072  2d00              CMP      r5,#0
000074  dc0a              BGT      |L418.140|
000076  f240310b          MOV      r1,#0x30b
00007a  4859              LDR      r0,|L418.480|
00007c  e9cd0100          STRD     r0,r1,[sp,#0]
000080  a340              ADR      r3,|L418.388|
000082  a24e              ADR      r2,|L418.444|
000084  a157              ADR      r1,|L418.484|
000086  2005              MOVS     r0,#5
000088  f7fffffe          BL       _Anki_Log
                  |L418.140|
00008c  4638              MOV      r0,r7
00008e  2f01              CMP      r7,#1
000090  bfd8              IT       LE
000092  2001              MOVLE    r0,#1
000094  60a5              STR      r5,[r4,#8]
000096  4345              MULS     r5,r0,r5
000098  a803              ADD      r0,sp,#0xc
00009a  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009e  4602              MOV      r2,r0
0000a0  4629              MOV      r1,r5
0000a2  4640              MOV      r0,r8
0000a4  9b02              LDR      r3,[sp,#8]
0000a6  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000aa  f8cd900c          STR      r9,[sp,#0xc]
0000ae  f8dd8010          LDR      r8,[sp,#0x10]
0000b2  f8df915c          LDR      r9,|L418.528|
0000b6  0005              MOVS     r5,r0
0000b8  d00e              BEQ      |L418.216|
0000ba  f1b80f10          CMP      r8,#0x10
0000be  d21e              BCS      |L418.254|
0000c0  f2403023          MOV      r0,#0x323
0000c4  e9cd9000          STRD     r9,r0,[sp,#0]
0000c8  a32e              ADR      r3,|L418.388|
0000ca  a252              ADR      r2,|L418.532|
0000cc  a156              ADR      r1,|L418.552|
0000ce  2005              MOVS     r0,#5
0000d0  f7fffffe          BL       _Anki_Log
0000d4  f000b850          B.W      |L418.376|
                  |L418.216|
0000d8  f240301e          MOV      r0,#0x31e
0000dc  e9cd9000          STRD     r9,r0,[sp,#0]
0000e0  a328              ADR      r3,|L418.388|
0000e2  a259              ADR      r2,|L418.584|
0000e4  a15f              ADR      r1,|L418.612|
0000e6  2005              MOVS     r0,#5
0000e8  f7fffffe          BL       _Anki_Log
0000ec  f8c4b000          STR      r11,[r4,#0]
0000f0  f8c4b004          STR      r11,[r4,#4]
0000f4  f8c4b008          STR      r11,[r4,#8]
0000f8  f8c4a010          STR      r10,[r4,#0x10]
0000fc  e03c              B        |L418.376|
                  |L418.254|
0000fe  a803              ADD      r0,sp,#0xc
000100  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000104  2800              CMP      r0,#0
000106  d00a              BEQ      |L418.286|
000108  f2403026          MOV      r0,#0x326
00010c  e9cd9000          STRD     r9,r0,[sp,#0]
000110  a31c              ADR      r3,|L418.388|
000112  a25a              ADR      r2,|L418.636|
000114  a144              ADR      r1,|L418.552|
000116  2005              MOVS     r0,#5
000118  f7fffffe          BL       _Anki_Log
00011c  e02c              B        |L418.376|
                  |L418.286|
00011e  9903              LDR      r1,[sp,#0xc]
000120  e9c41503          STRD     r1,r5,[r4,#0xc]
000124  f105000f          ADD      r0,r5,#0xf
000128  f020000f          BIC      r0,r0,#0xf
00012c  e9c47600          STRD     r7,r6,[r4,#0]
000130  1b40              SUBS     r0,r0,r5
000132  2e01              CMP      r6,#1
000134  bfd8              IT       LE
000136  2601              MOVLE    r6,#1
000138  eb060146          ADD      r1,r6,r6,LSL #1
00013c  310f              ADDS     r1,r1,#0xf
00013e  f021010f          BIC      r1,r1,#0xf
000142  fb010107          MLA      r1,r1,r7,r0
000146  4541              CMP      r1,r8
000148  bfdc              ITT      LE
00014a  1829              ADDLE    r1,r5,r0
00014c  6121              STRLE    r1,[r4,#0x10]
00014e  dd13              BLE      |L418.376|
000150  f2403035          MOV      r0,#0x335
000154  f8cd9000          STR      r9,[sp,#0]
000158  e9cd0101          STRD     r0,r1,[sp,#4]
00015c  a309              ADR      r3,|L418.388|
00015e  a251              ADR      r2,|L418.676|
000160  a140              ADR      r1,|L418.612|
000162  2005              MOVS     r0,#5
000164  f7fffffe          BL       _Anki_Log
000168  f8c4b000          STR      r11,[r4,#0]
00016c  f8c4b004          STR      r11,[r4,#4]
000170  f8c4b008          STR      r11,[r4,#8]
000174  f8c4a010          STR      r10,[r4,#0x10]
                  |L418.376|
000178  b005              ADD      sp,sp,#0x14
00017a  4620              MOV      r0,r4
00017c  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L418.384|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L418.388|
000184  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000188  6f726574
00018c  6563685c
000190  636f6d6d
000194  6f6e5c69
000198  6e636c75
00019c  64655c61
0001a0  6e6b692f
0001a4  636f6d6d
0001a8  6f6e2f72
0001ac  6f626f74
0001b0  2f617272
0001b4  617932  
0001b7  642e6800          DCB      "d.h",0
0001bb  00                DCB      0
                  |L418.444|
0001bc  496e7661          DCB      "Invalid size",0
0001c0  6c696420
0001c4  73697a65
0001c8  00      
0001c9  00                DCB      0
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L418.460|
0001cc  41727261          DCB      "Array<Type>::Array",0
0001d0  793c5479
0001d4  70653e3a
0001d8  3a417272
0001dc  617900  
0001df  00                DCB      0
                  |L418.480|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L418.484|
0001e4  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e8  793c5479
0001ec  70653e3a
0001f0  3a416c6c
0001f4  6f636174
0001f8  65427566
0001fc  66657246
000200  726f6d4d
000204  656d6f72
000208  79537461
00020c  636b00  
00020f  00                DCB      0
                  |L418.528|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L418.532|
000214  4e656761          DCB      "Negative dimension",0
000218  74697665
00021c  2064696d
000220  656e7369
000224  6f6e00  
000227  00                DCB      0
                  |L418.552|
000228  41727261          DCB      "Array<Type>::InitializeBuffer",0
00022c  793c5479
000230  70653e3a
000234  3a496e69
000238  7469616c
00023c  697a6542
000240  75666665
000244  7200    
000246  00                DCB      0
000247  00                DCB      0
                  |L418.584|
000248  696e7075          DCB      "input data buffer is NULL",0
00024c  74206461
000250  74612062
000254  75666665
000258  72206973
00025c  204e554c
000260  4c00    
000262  00                DCB      0
000263  00                DCB      0
                  |L418.612|
000264  416e6b69          DCB      "Anki.Array2d.initialize",0
000268  2e417272
00026c  61793264
000270  2e696e69
000274  7469616c
000278  697a6500
                  |L418.636|
00027c  46696c6c          DCB      "Fill patterns not supported for Array",0
000280  20706174
000284  7465726e
000288  73206e6f
00028c  74207375
000290  70706f72
000294  74656420
000298  666f7220
00029c  41727261
0002a0  7900    
0002a2  00                DCB      0
0002a3  00                DCB      0
                  |L418.676|
0002a4  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a8  74206461
0002ac  74612062
0002b0  75666665
0002b4  72206973
0002b8  206e6f74
0002bc  206c6172
0002c0  67652065
0002c4  6e6f7567
0002c8  682e2025
0002cc  64206279
0002d0  74657320
0002d4  69732072
0002d8  657175  
0002db  69726564          DCB      "ired.",0
0002df  2e00    
0002e1  00                DCB      0
0002e2  00                DCB      0
0002e3  00                DCB      0

                          AREA ||area_number.419||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.419||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L425.86|
00003a  217d              MOVS     r1,#0x7d
00003c  4850              LDR      r0,|L425.384|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a350              ADR      r3,|L425.388|
000044  a25d              ADR      r2,|L425.444|
000046  a161              ADR      r1,|L425.460|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L425.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  2134              MOVS     r1,#0x34
000064  4348              MULS     r0,r1,r0
000066  300f              ADDS     r0,r0,#0xf
000068  f020050f          BIC      r5,r0,#0xf
00006c  a804              ADD      r0,sp,#0x10
00006e  e9cd0902          STRD     r0,r9,[sp,#8]
000072  2d00              CMP      r5,#0
000074  dc0a              BGT      |L425.140|
000076  f240310b          MOV      r1,#0x30b
00007a  4859              LDR      r0,|L425.480|
00007c  e9cd0100          STRD     r0,r1,[sp,#0]
000080  a340              ADR      r3,|L425.388|
000082  a24e              ADR      r2,|L425.444|
000084  a157              ADR      r1,|L425.484|
000086  2005              MOVS     r0,#5
000088  f7fffffe          BL       _Anki_Log
                  |L425.140|
00008c  4638              MOV      r0,r7
00008e  2f01              CMP      r7,#1
000090  bfd8              IT       LE
000092  2001              MOVLE    r0,#1
000094  60a5              STR      r5,[r4,#8]
000096  4345              MULS     r5,r0,r5
000098  a803              ADD      r0,sp,#0xc
00009a  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009e  4602              MOV      r2,r0
0000a0  4629              MOV      r1,r5
0000a2  4640              MOV      r0,r8
0000a4  9b02              LDR      r3,[sp,#8]
0000a6  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000aa  f8cd900c          STR      r9,[sp,#0xc]
0000ae  f8dd8010          LDR      r8,[sp,#0x10]
0000b2  f8df915c          LDR      r9,|L425.528|
0000b6  0005              MOVS     r5,r0
0000b8  d00e              BEQ      |L425.216|
0000ba  f1b80f10          CMP      r8,#0x10
0000be  d21e              BCS      |L425.254|
0000c0  f2403023          MOV      r0,#0x323
0000c4  e9cd9000          STRD     r9,r0,[sp,#0]
0000c8  a32e              ADR      r3,|L425.388|
0000ca  a252              ADR      r2,|L425.532|
0000cc  a156              ADR      r1,|L425.552|
0000ce  2005              MOVS     r0,#5
0000d0  f7fffffe          BL       _Anki_Log
0000d4  f000b850          B.W      |L425.376|
                  |L425.216|
0000d8  f240301e          MOV      r0,#0x31e
0000dc  e9cd9000          STRD     r9,r0,[sp,#0]
0000e0  a328              ADR      r3,|L425.388|
0000e2  a259              ADR      r2,|L425.584|
0000e4  a15f              ADR      r1,|L425.612|
0000e6  2005              MOVS     r0,#5
0000e8  f7fffffe          BL       _Anki_Log
0000ec  f8c4b000          STR      r11,[r4,#0]
0000f0  f8c4b004          STR      r11,[r4,#4]
0000f4  f8c4b008          STR      r11,[r4,#8]
0000f8  f8c4a010          STR      r10,[r4,#0x10]
0000fc  e03c              B        |L425.376|
                  |L425.254|
0000fe  a803              ADD      r0,sp,#0xc
000100  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000104  2800              CMP      r0,#0
000106  d00a              BEQ      |L425.286|
000108  f2403026          MOV      r0,#0x326
00010c  e9cd9000          STRD     r9,r0,[sp,#0]
000110  a31c              ADR      r3,|L425.388|
000112  a25a              ADR      r2,|L425.636|
000114  a144              ADR      r1,|L425.552|
000116  2005              MOVS     r0,#5
000118  f7fffffe          BL       _Anki_Log
00011c  e02c              B        |L425.376|
                  |L425.286|
00011e  9903              LDR      r1,[sp,#0xc]
000120  e9c41503          STRD     r1,r5,[r4,#0xc]
000124  f105000f          ADD      r0,r5,#0xf
000128  f020000f          BIC      r0,r0,#0xf
00012c  e9c47600          STRD     r7,r6,[r4,#0]
000130  1b40              SUBS     r0,r0,r5
000132  2e01              CMP      r6,#1
000134  bfd8              IT       LE
000136  2601              MOVLE    r6,#1
000138  2134              MOVS     r1,#0x34
00013a  4371              MULS     r1,r6,r1
00013c  310f              ADDS     r1,r1,#0xf
00013e  f021010f          BIC      r1,r1,#0xf
000142  fb010107          MLA      r1,r1,r7,r0
000146  4541              CMP      r1,r8
000148  bfdc              ITT      LE
00014a  1829              ADDLE    r1,r5,r0
00014c  6121              STRLE    r1,[r4,#0x10]
00014e  dd13              BLE      |L425.376|
000150  f2403035          MOV      r0,#0x335
000154  f8cd9000          STR      r9,[sp,#0]
000158  e9cd0101          STRD     r0,r1,[sp,#4]
00015c  a309              ADR      r3,|L425.388|
00015e  a251              ADR      r2,|L425.676|
000160  a140              ADR      r1,|L425.612|
000162  2005              MOVS     r0,#5
000164  f7fffffe          BL       _Anki_Log
000168  f8c4b000          STR      r11,[r4,#0]
00016c  f8c4b004          STR      r11,[r4,#4]
000170  f8c4b008          STR      r11,[r4,#8]
000174  f8c4a010          STR      r10,[r4,#0x10]
                  |L425.376|
000178  b005              ADD      sp,sp,#0x14
00017a  4620              MOV      r0,r4
00017c  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L425.384|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L425.388|
000184  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000188  6f726574
00018c  6563685c
000190  636f6d6d
000194  6f6e5c69
000198  6e636c75
00019c  64655c61
0001a0  6e6b692f
0001a4  636f6d6d
0001a8  6f6e2f72
0001ac  6f626f74
0001b0  2f617272
0001b4  617932  
0001b7  642e6800          DCB      "d.h",0
0001bb  00                DCB      0
                  |L425.444|
0001bc  496e7661          DCB      "Invalid size",0
0001c0  6c696420
0001c4  73697a65
0001c8  00      
0001c9  00                DCB      0
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L425.460|
0001cc  41727261          DCB      "Array<Type>::Array",0
0001d0  793c5479
0001d4  70653e3a
0001d8  3a417272
0001dc  617900  
0001df  00                DCB      0
                  |L425.480|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L425.484|
0001e4  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e8  793c5479
0001ec  70653e3a
0001f0  3a416c6c
0001f4  6f636174
0001f8  65427566
0001fc  66657246
000200  726f6d4d
000204  656d6f72
000208  79537461
00020c  636b00  
00020f  00                DCB      0
                  |L425.528|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L425.532|
000214  4e656761          DCB      "Negative dimension",0
000218  74697665
00021c  2064696d
000220  656e7369
000224  6f6e00  
000227  00                DCB      0
                  |L425.552|
000228  41727261          DCB      "Array<Type>::InitializeBuffer",0
00022c  793c5479
000230  70653e3a
000234  3a496e69
000238  7469616c
00023c  697a6542
000240  75666665
000244  7200    
000246  00                DCB      0
000247  00                DCB      0
                  |L425.584|
000248  696e7075          DCB      "input data buffer is NULL",0
00024c  74206461
000250  74612062
000254  75666665
000258  72206973
00025c  204e554c
000260  4c00    
000262  00                DCB      0
000263  00                DCB      0
                  |L425.612|
000264  416e6b69          DCB      "Anki.Array2d.initialize",0
000268  2e417272
00026c  61793264
000270  2e696e69
000274  7469616c
000278  697a6500
                  |L425.636|
00027c  46696c6c          DCB      "Fill patterns not supported for Array",0
000280  20706174
000284  7465726e
000288  73206e6f
00028c  74207375
000290  70706f72
000294  74656420
000298  666f7220
00029c  41727261
0002a0  7900    
0002a2  00                DCB      0
0002a3  00                DCB      0
                  |L425.676|
0002a4  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a8  74206461
0002ac  74612062
0002b0  75666665
0002b4  72206973
0002b8  206e6f74
0002bc  206c6172
0002c0  67652065
0002c4  6e6f7567
0002c8  682e2025
0002cc  64206279
0002d0  74657320
0002d4  69732072
0002d8  657175  
0002db  69726564          DCB      "ired.",0
0002df  2e00    
0002e1  00                DCB      0
0002e2  00                DCB      0
0002e3  00                DCB      0

                          AREA ||area_number.426||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.426||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii PROC ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
;;;105    
;;;106        template<typename Type> s32 LinearSequence<Type>::computeSize(const Type start, const Type increment, const Type end)
000000  4290              CMP      r0,r2
;;;107        {
;;;108          if(start == end) {
;;;109            return 1;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;110          } else {
;;;111            if(ABS(increment) <= Flags::numeric_limits<Type>::epsilon()) {
;;;112              return 0;
;;;113            }
;;;114          }
;;;115    
;;;116          // 10:-1:12
;;;117          if(increment < 0 && start < end) {
;;;118            return 0;
;;;119          }
;;;120    
;;;121          // 12:1:10
;;;122          if(increment > 0 && start > end) {
;;;123            return 0;
;;;124          }
;;;125    
;;;126          const Type minLimit = MIN(start, end);
;;;127          const Type maxLimit = MAX(start, end);
;;;128          const Type incrementMagnitude = ABS(increment);
;;;129    
;;;130          const Type validRange = maxLimit - minLimit;
;;;131          const s32 size = (validRange+incrementMagnitude) / incrementMagnitude;
;;;132    
;;;133          AnkiConditionalErrorAndReturnValue(size >= 0,
;;;134            0, "LinearSequence<Type>::computeSize", "size estimation failed");
;;;135    
;;;136          return size;
;;;137        }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;107
00000a  2400              MOVS     r4,#0                 ;107
00000c  424b              RSBS     r3,r1,#0              ;111
00000e  b082              SUB      sp,sp,#8              ;107
000010  2900              CMP      r1,#0                 ;111
000012  bfac              ITE      GE                    ;111
000014  468c              MOVGE    r12,r1                ;111
000016  469c              MOVLT    r12,r3                ;111
000018  4564              CMP      r4,r12                ;111
00001a  da03              BGE      |L432.36|
00001c  2900              CMP      r1,#0                 ;117
00001e  da04              BGE      |L432.42|
000020  4290              CMP      r0,r2                 ;117
000022  da05              BGE      |L432.48|
                  |L432.36|
000024  b002              ADD      sp,sp,#8
000026  2000              MOVS     r0,#0                 ;123
000028  bd10              POP      {r4,pc}
                  |L432.42|
00002a  bf18              IT       NE                    ;122
00002c  4290              CMPNE    r0,r2                 ;122
00002e  dcf9              BGT      |L432.36|
                  |L432.48|
000030  4290              CMP      r0,r2                 ;126
000032  bfb4              ITE      LT                    ;126
000034  4684              MOVLT    r12,r0                ;126
000036  4694              MOVGE    r12,r2                ;126
000038  bfd8              IT       LE                    ;127
00003a  4610              MOVLE    r0,r2                 ;127
00003c  2900              CMP      r1,#0                 ;128
00003e  bfb8              IT       LT                    ;128
000040  4619              MOVLT    r1,r3                 ;128
000042  eba0000c          SUB      r0,r0,r12             ;130
000046  4408              ADD      r0,r0,r1              ;131
000048  fb90f0f1          SDIV     r0,r0,r1              ;131
00004c  2800              CMP      r0,#0                 ;133
00004e  bfa4              ITT      GE
000050  b002              ADDGE    sp,sp,#8
000052  bd10              POPGE    {r4,pc}
000054  2185              MOVS     r1,#0x85              ;133
000056  4807              LDR      r0,|L432.116|
000058  4b07              LDR      r3,|L432.120|
00005a  e9cd0100          STRD     r0,r1,[sp,#0]         ;133
00005e  f1a30218          SUB      r2,r3,#0x18           ;133
000062  f1a20124          SUB      r1,r2,#0x24           ;133
000066  2005              MOVS     r0,#5                 ;133
000068  f7fffffe          BL       _Anki_Log
00006c  b002              ADD      sp,sp,#8
00006e  2000              MOVS     r0,#0                 ;133
000070  bd10              POP      {r4,pc}
;;;138    
                          ENDP

000072  0000              DCW      0x0000
                  |L432.116|
                          DCD      _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
                  |L432.120|
                          DCD      ||.constdata||+0x690

                          AREA ||area_number.433||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii, LINKORDER=||t._ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.433||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||, COMGROUP=_ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii PROC ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)
;;;1622   
;;;1623         template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1624         {
000004  b083              SUB      sp,sp,#0xc
000006  460c              MOV      r4,r1
000008  e9dd9810          LDRD     r9,r8,[sp,#0x40]
00000c  4693              MOV      r11,r2
00000e  4606              MOV      r6,r0
;;;1625           const s32 arrHeight = arr.get_size(0);
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000016  4607              MOV      r7,r0
;;;1626           const s32 arrWidth = arr.get_size(1);
000018  2101              MOVS     r1,#1
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000020  4605              MOV      r5,r0
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000028  2800              CMP      r0,#0
00002a  bf1c              ITT      NE
00002c  6920              LDRNE    r0,[r4,#0x10]
00002e  2800              CMPNE    r0,#0
;;;1627   
;;;1628           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
000030  d01b              BEQ      |L439.106|
000032  6820              LDR      r0,[r4,#0]
000034  2800              CMP      r0,#0
000036  bfa4              ITT      GE
000038  6860              LDRGE    r0,[r4,#4]
00003a  2800              CMPGE    r0,#0
00003c  db15              BLT      |L439.106|
;;;1629             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1630   
;;;1631           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
00003e  f1bb0f00          CMP      r11,#0
000042  bf18              IT       NE
000044  f1bb0f01          CMPNE    r11,#1
000048  d01f              BEQ      |L439.138|
00004a  f240615f          MOV      r1,#0x65f
00004e  48e5              LDR      r0,|L439.996|
000050  e9cd0100          STRD     r0,r1,[sp,#0]
000054  a3e4              ADR      r3,|L439.1000|
000056  a2f2              ADR      r2,|L439.1056|
000058  a1fb              ADR      r1,|L439.1096|
00005a  2005              MOVS     r0,#5
00005c  f7fffffe          BL       _Anki_Log
;;;1632             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1633   
;;;1634           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1635             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1636   
;;;1637           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1638           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1639   
;;;1640           if(sortWhichDimension == 0) {
;;;1641             for(s32 y=0; y<arrHeight; y++) {
;;;1642               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1643               for(s32 x=0; x<arrWidth; x++) {
;;;1644                 pIndexes[x] = y;
;;;1645               }
;;;1646             }
;;;1647   
;;;1648             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1649             if(sortAscending) {
;;;1650               InsertionSort_sortAscendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1651             } else { // if(sortAscending)
;;;1652               InsertionSort_sortDescendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1653             } // if(sortAscending) ... else
;;;1654           } else { // sortWhichDimension == 1
;;;1655             for(s32 y=0; y<arrHeight; y++) {
;;;1656               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1657               for(s32 x=0; x<arrWidth; x++) {
;;;1658                 pIndexes[x] = x;
;;;1659               }
;;;1660             }
;;;1661   
;;;1662             if(sortAscending) {
;;;1663               InsertionSort_sortAscendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1664             } else { // if(sortAscending)
;;;1665               InsertionSort_sortDescendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1666             } // if(sortAscending) ... else
;;;1667           } // if(sortWhichDimension == 0) ... else
;;;1668   
;;;1669           return RESULT_OK;
;;;1670         } // InsertionSort()
000060  b007              ADD      sp,sp,#0x1c
000062  f04f7040          MOV      r0,#0x3000000         ;1631
000066  e8bd8ff0          POP      {r4-r11,pc}
                  |L439.106|
00006a  f240615c          MOV      r1,#0x65c             ;1628
00006e  48dd              LDR      r0,|L439.996|
000070  e9cd0100          STRD     r0,r1,[sp,#0]         ;1628
000074  a3dc              ADR      r3,|L439.1000|
000076  a2f6              ADR      r2,|L439.1104|
000078  a1f3              ADR      r1,|L439.1096|
00007a  2005              MOVS     r0,#5                 ;1628
00007c  f7fffffe          BL       _Anki_Log
000080  b007              ADD      sp,sp,#0x1c
000082  f04f6080          MOV      r0,#0x4000000         ;1628
000086  e8bd8ff0          POP      {r4-r11,pc}
                  |L439.138|
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000090  2800              CMP      r0,#0
000092  bf1c              ITT      NE
000094  6920              LDRNE    r0,[r4,#0x10]
000096  2800              CMPNE    r0,#0
000098  d02d              BEQ      |L439.246|
00009a  6820              LDR      r0,[r4,#0]            ;1634
00009c  2800              CMP      r0,#0                 ;1634
00009e  bfa4              ITT      GE                    ;1634
0000a0  6860              LDRGE    r0,[r4,#4]            ;1634
0000a2  2800              CMPGE    r0,#0                 ;1634
0000a4  db27              BLT      |L439.246|
0000a6  2100              MOVS     r1,#0                 ;1634
0000a8  4630              MOV      r0,r6                 ;1634
0000aa  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000ae  4682              MOV      r10,r0                ;1634
0000b0  2100              MOVS     r1,#0                 ;1634
0000b2  4620              MOV      r0,r4                 ;1634
0000b4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
0000b8  4582              CMP      r10,r0                ;1634
0000ba  d11c              BNE      |L439.246|
0000bc  2101              MOVS     r1,#1                 ;1634
0000be  4630              MOV      r0,r6                 ;1634
0000c0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000c4  4682              MOV      r10,r0                ;1634
0000c6  2101              MOVS     r1,#1                 ;1634
0000c8  4620              MOV      r0,r4                 ;1634
0000ca  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIiE8get_sizeEi ; Anki::Embedded::Array<int>::get_size(int) const
0000ce  4582              CMP      r10,r0                ;1634
0000d0  d111              BNE      |L439.246|
0000d2  4659              MOV      r1,r11                ;1637
0000d4  4630              MOV      r0,r6                 ;1637
0000d6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000da  1e41              SUBS     r1,r0,#1              ;1637
0000dc  f1b90f00          CMP      r9,#0                 ;1637
0000e0  bfcc              ITE      GT                    ;1637
0000e2  4648              MOVGT    r0,r9                 ;1637
0000e4  2000              MOVLE    r0,#0                 ;1637
0000e6  4281              CMP      r1,r0                 ;1637
0000e8  dd15              BLE      |L439.278|
0000ea  f1b90f00          CMP      r9,#0                 ;1637
0000ee  bfd8              IT       LE                    ;1637
0000f0  f04f0900          MOVLE    r9,#0                 ;1637
0000f4  e015              B        |L439.290|
                  |L439.246|
0000f6  f2406162          MOV      r1,#0x662             ;1634
0000fa  48ba              LDR      r0,|L439.996|
0000fc  e9cd0100          STRD     r0,r1,[sp,#0]         ;1634
000100  a3b9              ADR      r3,|L439.1000|
000102  a2d8              ADR      r2,|L439.1124|
000104  a1d0              ADR      r1,|L439.1096|
000106  2005              MOVS     r0,#5                 ;1634
000108  f7fffffe          BL       _Anki_Log
00010c  b007              ADD      sp,sp,#0x1c
00010e  f04f60a0          MOV      r0,#0x5000000         ;1634
000112  e8bd8ff0          POP      {r4-r11,pc}
                  |L439.278|
000116  4659              MOV      r1,r11                ;1637
000118  4630              MOV      r0,r6                 ;1637
00011a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00011e  f1a00901          SUB      r9,r0,#1              ;1637
                  |L439.290|
000122  4659              MOV      r1,r11                ;1638
000124  4630              MOV      r0,r6                 ;1638
000126  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00012a  1e41              SUBS     r1,r0,#1              ;1638
00012c  f1b80f00          CMP      r8,#0                 ;1638
000130  bfcc              ITE      GT                    ;1638
000132  4640              MOVGT    r0,r8                 ;1638
000134  2000              MOVLE    r0,#0                 ;1638
000136  4281              CMP      r1,r0                 ;1638
000138  dd05              BLE      |L439.326|
00013a  f1b80f00          CMP      r8,#0                 ;1638
00013e  bfd8              IT       LE                    ;1638
000140  f04f0800          MOVLE    r8,#0                 ;1638
000144  e005              B        |L439.338|
                  |L439.326|
000146  4659              MOV      r1,r11                ;1638
000148  4630              MOV      r0,r6                 ;1638
00014a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00014e  f1a00801          SUB      r8,r0,#1              ;1638
                  |L439.338|
000152  f04f0a00          MOV      r10,#0                ;1638
000156  f1bb0f00          CMP      r11,#0                ;1640
00015a  4651              MOV      r1,r10                ;1655
00015c  d035              BEQ      |L439.458|
00015e  2f00              CMP      r7,#0                 ;1655
000160  dd0e              BLE      |L439.384|
                  |L439.354|
000162  68a2              LDR      r2,[r4,#8]            ;1655
000164  6920              LDR      r0,[r4,#0x10]         ;1655
000166  fb010202          MLA      r2,r1,r2,r0           ;1655
00016a  2000              MOVS     r0,#0                 ;1657
00016c  2d00              CMP      r5,#0                 ;1657
00016e  dd04              BLE      |L439.378|
                  |L439.368|
000170  f8420020          STR      r0,[r2,r0,LSL #2]     ;1658
000174  1c40              ADDS     r0,r0,#1              ;1657
000176  4285              CMP      r5,r0                 ;1657
000178  dcfa              BGT      |L439.368|
                  |L439.378|
00017a  1c49              ADDS     r1,r1,#1              ;1655
00017c  42b9              CMP      r1,r7                 ;1655
00017e  dbf0              BLT      |L439.354|
                  |L439.384|
000180  9806              LDR      r0,[sp,#0x18]         ;1662
000182  f04f0100          MOV      r1,#0                 ;1662
000186  2800              CMP      r0,#0                 ;1662
000188  4630              MOV      r0,r6                 ;1662
00018a  f000810d          BEQ.W    |L439.936|
00018e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000192  f1b00b00          SUBS     r11,r0,#0             ;1662
000196  f04f0500          MOV      r5,#0                 ;1662
00019a  f3408198          BLE.W    |L439.1230|
                  |L439.414|
00019e  68b1              LDR      r1,[r6,#8]            ;1662
0001a0  6930              LDR      r0,[r6,#0x10]         ;1662
0001a2  f1090201          ADD      r2,r9,#1              ;1662
0001a6  fb050c01          MLA      r12,r5,r1,r0          ;1662
0001aa  68a1              LDR      r1,[r4,#8]            ;1662
0001ac  6920              LDR      r0,[r4,#0x10]         ;1662
0001ae  4542              CMP      r2,r8                 ;1662
0001b0  fb050301          MLA      r3,r5,r1,r0           ;1662
0001b4  f8c3a000          STR      r10,[r3,#0]           ;1662
0001b8  dc75              BGT      |L439.678|
                  |L439.442|
0001ba  eb0c0082          ADD      r0,r12,r2,LSL #2      ;1662
0001be  f8537022          LDR      r7,[r3,r2,LSL #2]     ;1662
0001c2  edd00a00          VLDR     s1,[r0,#0]            ;1662
0001c6  4611              MOV      r1,r2                 ;1662
0001c8  e0d4              B        |L439.884|
                  |L439.458|
0001ca  2f00              CMP      r7,#0                 ;1641
0001cc  dd0e              BLE      |L439.492|
                  |L439.462|
0001ce  68a2              LDR      r2,[r4,#8]            ;1641
0001d0  6920              LDR      r0,[r4,#0x10]         ;1641
0001d2  fb010202          MLA      r2,r1,r2,r0           ;1641
0001d6  2000              MOVS     r0,#0                 ;1643
0001d8  2d00              CMP      r5,#0                 ;1643
0001da  dd04              BLE      |L439.486|
                  |L439.476|
0001dc  f8421020          STR      r1,[r2,r0,LSL #2]     ;1644
0001e0  1c40              ADDS     r0,r0,#1              ;1643
0001e2  4285              CMP      r5,r0                 ;1643
0001e4  dcfa              BGT      |L439.476|
                  |L439.486|
0001e6  1c49              ADDS     r1,r1,#1              ;1641
0001e8  42b9              CMP      r1,r7                 ;1641
0001ea  dbf0              BLT      |L439.462|
                  |L439.492|
0001ec  9806              LDR      r0,[sp,#0x18]         ;1649
0001ee  f04f0101          MOV      r1,#1                 ;1649
0001f2  2800              CMP      r0,#0                 ;1649
0001f4  4630              MOV      r0,r6                 ;1649
0001f6  d057              BEQ      |L439.680|
0001f8  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0001fc  1e07              SUBS     r7,r0,#0              ;1649
0001fe  f04f0200          MOV      r2,#0                 ;1649
000202  dd4f              BLE      |L439.676|
                  |L439.516|
000204  f1090001          ADD      r0,r9,#1              ;1649
000208  4540              CMP      r0,r8                 ;1649
00020a  dc48              BGT      |L439.670|
                  |L439.524|
00020c  68b3              LDR      r3,[r6,#8]            ;1649
00020e  6931              LDR      r1,[r6,#0x10]         ;1649
000210  fb001103          MLA      r1,r0,r3,r1           ;1649
000214  eb010182          ADD      r1,r1,r2,LSL #2       ;1649
000218  68a3              LDR      r3,[r4,#8]            ;1649
00021a  edd10a00          VLDR     s1,[r1,#0]            ;1649
00021e  6921              LDR      r1,[r4,#0x10]         ;1649
000220  fb001103          MLA      r1,r0,r3,r1           ;1649
000224  f8515022          LDR      r5,[r1,r2,LSL #2]     ;1649
000228  4601              MOV      r1,r0                 ;1649
00022a  e013              B        |L439.596|
                  |L439.556|
00022c  fb01330c          MLA      r3,r1,r12,r3          ;1649
000230  eb030382          ADD      r3,r3,r2,LSL #2       ;1649
000234  f1a10a01          SUB      r10,r1,#1             ;1649
000238  ed830a00          VSTR     s0,[r3,#0]            ;1649
00023c  f8d4c008          LDR      r12,[r4,#8]           ;1649
000240  6923              LDR      r3,[r4,#0x10]         ;1649
000242  fb0a3a0c          MLA      r10,r10,r12,r3        ;1649
000246  fb01330c          MLA      r3,r1,r12,r3          ;1649
00024a  f85aa022          LDR      r10,[r10,r2,LSL #2]   ;1649
00024e  f843a022          STR      r10,[r3,r2,LSL #2]    ;1649
000252  1e49              SUBS     r1,r1,#1              ;1649
                  |L439.596|
000254  4549              CMP      r1,r9                 ;1649
000256  dd0f              BLE      |L439.632|
000258  f8d6c008          LDR      r12,[r6,#8]           ;1649
00025c  6933              LDR      r3,[r6,#0x10]         ;1649
00025e  f1a10a01          SUB      r10,r1,#1             ;1649
000262  fb0a3a0c          MLA      r10,r10,r12,r3        ;1649
000266  eb0a0a82          ADD      r10,r10,r2,LSL #2     ;1649
00026a  ed9a0a00          VLDR     s0,[r10,#0]           ;1649
00026e  eeb40ae0          VCMPE.F32 s0,s1                 ;1649
000272  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1649
000276  dcd9              BGT      |L439.556|
                  |L439.632|
000278  f8d6c008          LDR      r12,[r6,#8]           ;1649
00027c  6933              LDR      r3,[r6,#0x10]         ;1649
00027e  1c40              ADDS     r0,r0,#1              ;1649
000280  fb01330c          MLA      r3,r1,r12,r3          ;1649
000284  eb030382          ADD      r3,r3,r2,LSL #2       ;1649
000288  4540              CMP      r0,r8                 ;1649
00028a  edc30a00          VSTR     s1,[r3,#0]            ;1649
00028e  f8d4c008          LDR      r12,[r4,#8]           ;1649
000292  6923              LDR      r3,[r4,#0x10]         ;1649
000294  fb01310c          MLA      r1,r1,r12,r3          ;1649
000298  f8415022          STR      r5,[r1,r2,LSL #2]     ;1649
00029c  ddb6              BLE      |L439.524|
                  |L439.670|
00029e  1c52              ADDS     r2,r2,#1              ;1649
0002a0  42ba              CMP      r2,r7                 ;1649
0002a2  dbaf              BLT      |L439.516|
                  |L439.676|
0002a4  e113              B        |L439.1230|
                  |L439.678|
0002a6  e07a              B        |L439.926|
                  |L439.680|
0002a8  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0002ac  f1b00b00          SUBS     r11,r0,#0             ;1649
0002b0  f04f0200          MOV      r2,#0                 ;1649
0002b4  dd54              BLE      |L439.864|
                  |L439.694|
0002b6  68a3              LDR      r3,[r4,#8]            ;1649
0002b8  6921              LDR      r1,[r4,#0x10]         ;1649
0002ba  2000              MOVS     r0,#0                 ;1649
0002bc  fb001003          MLA      r0,r0,r3,r1           ;1649
0002c0  f840a022          STR      r10,[r0,r2,LSL #2]    ;1649
0002c4  f1090001          ADD      r0,r9,#1              ;1649
0002c8  4540              CMP      r0,r8                 ;1649
0002ca  dc46              BGT      |L439.858|
                  |L439.716|
0002cc  68b3              LDR      r3,[r6,#8]            ;1649
0002ce  6931              LDR      r1,[r6,#0x10]         ;1649
0002d0  fb001103          MLA      r1,r0,r3,r1           ;1649
0002d4  eb010182          ADD      r1,r1,r2,LSL #2       ;1649
0002d8  68a3              LDR      r3,[r4,#8]            ;1649
0002da  edd10a00          VLDR     s1,[r1,#0]            ;1649
0002de  6921              LDR      r1,[r4,#0x10]         ;1649
0002e0  fb001103          MLA      r1,r0,r3,r1           ;1649
0002e4  f8517022          LDR      r7,[r1,r2,LSL #2]     ;1649
0002e8  4601              MOV      r1,r0                 ;1649
0002ea  e012              B        |L439.786|
                  |L439.748|
0002ec  fb01330c          MLA      r3,r1,r12,r3          ;1649
0002f0  eb030382          ADD      r3,r3,r2,LSL #2       ;1649
0002f4  1e4d              SUBS     r5,r1,#1              ;1649
0002f6  ed830a00          VSTR     s0,[r3,#0]            ;1649
0002fa  f8d4c008          LDR      r12,[r4,#8]           ;1649
0002fe  6923              LDR      r3,[r4,#0x10]         ;1649
000300  fb05350c          MLA      r5,r5,r12,r3          ;1649
000304  fb01330c          MLA      r3,r1,r12,r3          ;1649
000308  f8555022          LDR      r5,[r5,r2,LSL #2]     ;1649
00030c  f8435022          STR      r5,[r3,r2,LSL #2]     ;1649
000310  1e49              SUBS     r1,r1,#1              ;1649
                  |L439.786|
000312  4549              CMP      r1,r9                 ;1649
000314  dd0e              BLE      |L439.820|
000316  f8d6c008          LDR      r12,[r6,#8]           ;1649
00031a  6933              LDR      r3,[r6,#0x10]         ;1649
00031c  1e4d              SUBS     r5,r1,#1              ;1649
00031e  fb05350c          MLA      r5,r5,r12,r3          ;1649
000322  eb050582          ADD      r5,r5,r2,LSL #2       ;1649
000326  ed950a00          VLDR     s0,[r5,#0]            ;1649
00032a  eeb40ae0          VCMPE.F32 s0,s1                 ;1649
00032e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1649
000332  d3db              BCC      |L439.748|
                  |L439.820|
000334  f8d6c008          LDR      r12,[r6,#8]           ;1649
000338  6933              LDR      r3,[r6,#0x10]         ;1649
00033a  1c40              ADDS     r0,r0,#1              ;1649
00033c  fb01330c          MLA      r3,r1,r12,r3          ;1649
000340  eb030382          ADD      r3,r3,r2,LSL #2       ;1649
000344  4540              CMP      r0,r8                 ;1649
000346  edc30a00          VSTR     s1,[r3,#0]            ;1649
00034a  f8d4c008          LDR      r12,[r4,#8]           ;1649
00034e  6923              LDR      r3,[r4,#0x10]         ;1649
000350  fb01310c          MLA      r1,r1,r12,r3          ;1649
000354  f8417022          STR      r7,[r1,r2,LSL #2]     ;1649
000358  ddb8              BLE      |L439.716|
                  |L439.858|
00035a  1c52              ADDS     r2,r2,#1              ;1649
00035c  455a              CMP      r2,r11                ;1649
00035e  dbaa              BLT      |L439.694|
                  |L439.864|
000360  e0b5              B        |L439.1230|
                  |L439.866|
000362  ed800a00          VSTR     s0,[r0,#0]            ;1649
000366  eb030081          ADD      r0,r3,r1,LSL #2       ;1649
00036a  f8500c04          LDR      r0,[r0,#-4]           ;1649
00036e  f8430021          STR      r0,[r3,r1,LSL #2]     ;1649
000372  1e49              SUBS     r1,r1,#1              ;1649
                  |L439.884|
000374  4549              CMP      r1,r9                 ;1649
000376  dd08              BLE      |L439.906|
000378  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1649
00037c  ed100a01          VLDR     s0,[r0,#-4]           ;1649
000380  eeb40ae0          VCMPE.F32 s0,s1                 ;1649
000384  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1649
000388  dceb              BGT      |L439.866|
                  |L439.906|
00038a  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1649
00038e  1c52              ADDS     r2,r2,#1              ;1649
000390  edc00a00          VSTR     s1,[r0,#0]            ;1649
000394  f8437021          STR      r7,[r3,r1,LSL #2]     ;1649
000398  4542              CMP      r2,r8                 ;1649
00039a  f77faf0e          BLE      |L439.442|
                  |L439.926|
00039e  1c6d              ADDS     r5,r5,#1              ;1649
0003a0  455d              CMP      r5,r11                ;1649
0003a2  f6ffaefc          BLT      |L439.414|
0003a6  e092              B        |L439.1230|
                  |L439.936|
0003a8  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0003ac  f1b00b00          SUBS     r11,r0,#0             ;1649
0003b0  f04f0500          MOV      r5,#0                 ;1649
0003b4  dd15              BLE      |L439.994|
                  |L439.950|
0003b6  68b1              LDR      r1,[r6,#8]            ;1649
0003b8  6930              LDR      r0,[r6,#0x10]         ;1649
0003ba  f1090201          ADD      r2,r9,#1              ;1649
0003be  fb050c01          MLA      r12,r5,r1,r0          ;1649
0003c2  68a1              LDR      r1,[r4,#8]            ;1649
0003c4  6920              LDR      r0,[r4,#0x10]         ;1649
0003c6  4542              CMP      r2,r8                 ;1649
0003c8  fb050301          MLA      r3,r5,r1,r0           ;1649
0003cc  f8c3a000          STR      r10,[r3,#0]           ;1649
0003d0  dc79              BGT      |L439.1222|
                  |L439.978|
0003d2  eb0c0082          ADD      r0,r12,r2,LSL #2      ;1649
0003d6  f8537022          LDR      r7,[r3,r2,LSL #2]     ;1649
0003da  edd00a00          VLDR     s1,[r0,#0]            ;1649
0003de  4611              MOV      r1,r2                 ;1649
0003e0  e05d              B        |L439.1182|
                  |L439.994|
0003e2  e074              B        |L439.1230|
                  |L439.996|
                          DCD      _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::__PRETTY_FUNCTION__
                  |L439.1000|
0003e8  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
0003ec  6f726574
0003f0  6563685c
0003f4  636f6d6d
0003f8  6f6e5c69
0003fc  6e636c75
000400  64655c61
000404  6e6b692f
000408  636f6d6d
00040c  6f6e2f72
000410  6f626f74
000414  2f6d6174
000418  726978  
00041b  2e6800            DCB      ".h",0
00041e  00                DCB      0
00041f  00                DCB      0
                  |L439.1056|
000420  736f7274          DCB      "sortWhichDimension must be zero or one",0
000424  57686963
000428  6844696d
00042c  656e7369
000430  6f6e206d
000434  75737420
000438  6265207a
00043c  65726f20
000440  6f72206f
000444  6e6500  
000447  00                DCB      0
                  |L439.1096|
000448  536f7274          DCB      "Sort",0
00044c  00      
00044d  00                DCB      0
00044e  00                DCB      0
00044f  00                DCB      0
                  |L439.1104|
000450  4f626a65          DCB      "Objects are invalid",0
000454  63747320
000458  61726520
00045c  696e7661
000460  6c696400
                  |L439.1124|
000464  696e6465          DCB      "indexes must be the same size as arr",0
000468  78657320
00046c  6d757374
000470  20626520
000474  74686520
000478  73616d65
00047c  2073697a
000480  65206173
000484  20617272
000488  00      
000489  00                DCB      0
00048a  00                DCB      0
00048b  00                DCB      0
                  |L439.1164|
00048c  ed800a00          VSTR     s0,[r0,#0]            ;1649
000490  eb030081          ADD      r0,r3,r1,LSL #2       ;1649
000494  f8500c04          LDR      r0,[r0,#-4]           ;1649
000498  f8430021          STR      r0,[r3,r1,LSL #2]     ;1649
00049c  1e49              SUBS     r1,r1,#1              ;1649
                  |L439.1182|
00049e  4549              CMP      r1,r9                 ;1649
0004a0  dd08              BLE      |L439.1204|
0004a2  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1649
0004a6  ed100a01          VLDR     s0,[r0,#-4]           ;1649
0004aa  eeb40ae0          VCMPE.F32 s0,s1                 ;1649
0004ae  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1649
0004b2  d3eb              BCC      |L439.1164|
                  |L439.1204|
0004b4  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1649
0004b8  1c52              ADDS     r2,r2,#1              ;1649
0004ba  edc00a00          VSTR     s1,[r0,#0]            ;1649
0004be  f8437021          STR      r7,[r3,r1,LSL #2]     ;1649
0004c2  4542              CMP      r2,r8                 ;1649
0004c4  dd85              BLE      |L439.978|
                  |L439.1222|
0004c6  1c6d              ADDS     r5,r5,#1              ;1649
0004c8  455d              CMP      r5,r11                ;1649
0004ca  f6ffaf74          BLT      |L439.950|
                  |L439.1230|
0004ce  b007              ADD      sp,sp,#0x1c
0004d0  2000              MOVS     r0,#0                 ;1669
0004d2  e8bd8ff0          POP      {r4-r11,pc}
;;;1671   
                          ENDP


                          AREA ||area_number.440||, COMGROUP=_ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii, LINKORDER=||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.440||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||
                          DCD      0x00000001

                          AREA ||.constdata__ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
00001c  696e6561          DCB      0x69,0x6e,0x65,0x61
000020  72536571          DCB      0x72,0x53,0x65,0x71
000024  75656e63          DCB      0x75,0x65,0x6e,0x63
000028  653c5479          DCB      0x65,0x3c,0x54,0x79
00002c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000030  3a636f6d          DCB      0x3a,0x63,0x6f,0x6d
000034  70757465          DCB      0x70,0x75,0x74,0x65
000038  53697a65          DCB      0x53,0x69,0x7a,0x65
00003c  28547970          DCB      0x28,0x54,0x79,0x70
000040  652c2054          DCB      0x65,0x2c,0x20,0x54
000044  7970652c          DCB      0x79,0x70,0x65,0x2c
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  6529205b          DCB      0x65,0x29,0x20,0x5b
000050  77697468          DCB      0x77,0x69,0x74,0x68
000054  20547970          DCB      0x20,0x54,0x79,0x70
000058  65203d20          DCB      0x65,0x20,0x3d,0x20
00005c  7369676e          DCB      0x73,0x69,0x67,0x6e
000060  65642069          DCB      0x65,0x64,0x20,0x69
000064  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d207369          DCB      0x3d,0x20,0x73,0x69
000088  676e6564          DCB      0x67,0x6e,0x65,0x64
00008c  20696e74          DCB      0x20,0x69,0x6e,0x74
000090  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE7SetZeroEvE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE7SetZeroEvE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::SetZero()::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  5365745a          DCB      0x53,0x65,0x74,0x5a
00002c  65726f28          DCB      0x65,0x72,0x6f,0x28
000030  29205b77          DCB      0x29,0x20,0x5b,0x77
000034  69746820          DCB      0x69,0x74,0x68,0x20
000038  54797065          DCB      0x54,0x79,0x70,0x65
00003c  203d2073          DCB      0x20,0x3d,0x20,0x73
000040  69676e65          DCB      0x69,0x67,0x6e,0x65
000044  6420696e          DCB      0x64,0x20,0x69,0x6e
000048  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  7369676e          DCB      0x73,0x69,0x67,0x6e
000054  65642069          DCB      0x65,0x64,0x20,0x69
000058  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  7369676e          DCB      0x73,0x69,0x67,0x6e
0000bc  65642069          DCB      0x65,0x64,0x20,0x69
0000c0  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2073          DCB      0x20,0x3d,0x20,0x73
000094  69676e65          DCB      0x69,0x67,0x6e,0x65
000098  6420696e          DCB      0x64,0x20,0x69,0x6e
00009c  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_E19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_E19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded25ArraySliceLimits_in2_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_bS6_S6_E19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySliceLimits_in2_out1<int>::ArraySliceLimits_in2_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  79536c69          DCB      0x79,0x53,0x6c,0x69
000018  63654c69          DCB      0x63,0x65,0x4c,0x69
00001c  6d697473          DCB      0x6d,0x69,0x74,0x73
000020  5f696e32          DCB      0x5f,0x69,0x6e,0x32
000024  5f6f7574          DCB      0x5f,0x6f,0x75,0x74
000028  313c5479          DCB      0x31,0x3c,0x54,0x79
00002c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000030  3a417272          DCB      0x3a,0x41,0x72,0x72
000034  6179536c          DCB      0x61,0x79,0x53,0x6c
000038  6963654c          DCB      0x69,0x63,0x65,0x4c
00003c  696d6974          DCB      0x69,0x6d,0x69,0x74
000040  735f696e          DCB      0x73,0x5f,0x69,0x6e
000044  325f6f75          DCB      0x32,0x5f,0x6f,0x75
000048  74312863          DCB      0x74,0x31,0x28,0x63
00004c  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000050  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000054  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000058  6d626564          DCB      0x6d,0x62,0x65,0x64
00005c  6465643a          DCB      0x64,0x65,0x64,0x3a
000060  3a4c696e          DCB      0x3a,0x4c,0x69,0x6e
000064  65617253          DCB      0x65,0x61,0x72,0x53
000068  65717565          DCB      0x65,0x71,0x75,0x65
00006c  6e63653c          DCB      0x6e,0x63,0x65,0x3c
000070  54797065          DCB      0x54,0x79,0x70,0x65
000074  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000078  20636f6e          DCB      0x20,0x63,0x6f,0x6e
00007c  73742041          DCB      0x73,0x74,0x20,0x41
000080  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000084  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000088  65646465          DCB      0x65,0x64,0x64,0x65
00008c  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
000090  696e6561          DCB      0x69,0x6e,0x65,0x61
000094  72536571          DCB      0x72,0x53,0x65,0x71
000098  75656e63          DCB      0x75,0x65,0x6e,0x63
00009c  653c5479          DCB      0x65,0x3c,0x54,0x79
0000a0  70653e20          DCB      0x70,0x65,0x3e,0x20
0000a4  262c2062          DCB      0x26,0x2c,0x20,0x62
0000a8  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
0000ac  20636f6e          DCB      0x20,0x63,0x6f,0x6e
0000b0  73742041          DCB      0x73,0x74,0x20,0x41
0000b4  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000b8  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000bc  65646465          DCB      0x65,0x64,0x64,0x65
0000c0  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
0000c4  696e6561          DCB      0x69,0x6e,0x65,0x61
0000c8  72536571          DCB      0x72,0x53,0x65,0x71
0000cc  75656e63          DCB      0x75,0x65,0x6e,0x63
0000d0  653c5479          DCB      0x65,0x3c,0x54,0x79
0000d4  70653e20          DCB      0x70,0x65,0x3e,0x20
0000d8  262c2063          DCB      0x26,0x2c,0x20,0x63
0000dc  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0000e0  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000e4  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000e8  6d626564          DCB      0x6d,0x62,0x65,0x64
0000ec  6465643a          DCB      0x64,0x65,0x64,0x3a
0000f0  3a4c696e          DCB      0x3a,0x4c,0x69,0x6e
0000f4  65617253          DCB      0x65,0x61,0x72,0x53
0000f8  65717565          DCB      0x65,0x71,0x75,0x65
0000fc  6e63653c          DCB      0x6e,0x63,0x65,0x3c
000100  54797065          DCB      0x54,0x79,0x70,0x65
000104  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000108  20626f6f          DCB      0x20,0x62,0x6f,0x6f
00010c  6c2c2063          DCB      0x6c,0x2c,0x20,0x63
000110  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000114  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000118  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00011c  6d626564          DCB      0x6d,0x62,0x65,0x64
000120  6465643a          DCB      0x64,0x65,0x64,0x3a
000124  3a4c696e          DCB      0x3a,0x4c,0x69,0x6e
000128  65617253          DCB      0x65,0x61,0x72,0x53
00012c  65717565          DCB      0x65,0x71,0x75,0x65
000130  6e63653c          DCB      0x6e,0x63,0x65,0x3c
000134  54797065          DCB      0x54,0x79,0x70,0x65
000138  3e20262c          DCB      0x3e,0x20,0x26,0x2c
00013c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000140  73742041          DCB      0x73,0x74,0x20,0x41
000144  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000148  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00014c  65646465          DCB      0x65,0x64,0x64,0x65
000150  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
000154  696e6561          DCB      0x69,0x6e,0x65,0x61
000158  72536571          DCB      0x72,0x53,0x65,0x71
00015c  75656e63          DCB      0x75,0x65,0x6e,0x63
000160  653c5479          DCB      0x65,0x3c,0x54,0x79
000164  70653e20          DCB      0x70,0x65,0x3e,0x20
000168  2629205b          DCB      0x26,0x29,0x20,0x5b
00016c  77697468          DCB      0x77,0x69,0x74,0x68
000170  20547970          DCB      0x20,0x54,0x79,0x70
000174  65203d20          DCB      0x65,0x20,0x3d,0x20
000178  7369676e          DCB      0x73,0x69,0x67,0x6e
00017c  65642069          DCB      0x65,0x64,0x20,0x69
000180  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000088  6f61745d          DCB      0x6f,0x61,0x74,0x5d
00008c  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::SetZero()::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  5365745a          DCB      0x53,0x65,0x74,0x5a
00002c  65726f28          DCB      0x65,0x72,0x6f,0x28
000030  29205b77          DCB      0x29,0x20,0x5b,0x77
000034  69746820          DCB      0x69,0x74,0x68,0x20
000038  54797065          DCB      0x54,0x79,0x70,0x65
00003c  203d2066          DCB      0x20,0x3d,0x20,0x66
000040  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000044  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000054  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000bc  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2066          DCB      0x20,0x3d,0x20,0x66
000094  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000098  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20756e          DCB      0x3d,0x20,0x75,0x6e
000088  7369676e          DCB      0x73,0x69,0x67,0x6e
00008c  65642063          DCB      0x65,0x64,0x20,0x63
000090  6861725d          DCB      0x68,0x61,0x72,0x5d
000094  00                DCB      0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  756e7369          DCB      0x75,0x6e,0x73,0x69
000054  676e6564          DCB      0x67,0x6e,0x65,0x64
000058  20636861          DCB      0x20,0x63,0x68,0x61
00005c  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  756e7369          DCB      0x75,0x6e,0x73,0x69
0000bc  676e6564          DCB      0x67,0x6e,0x65,0x64
0000c0  20636861          DCB      0x20,0x63,0x68,0x61
0000c4  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2075          DCB      0x20,0x3d,0x20,0x75
000094  6e736967          DCB      0x6e,0x73,0x69,0x67
000098  6e656420          DCB      0x6e,0x65,0x64,0x20
00009c  63686172          DCB      0x63,0x68,0x61,0x72
0000a0  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIbEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIbEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIbEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<bool>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20626f          DCB      0x3d,0x20,0x62,0x6f
000088  6f6c5d00          DCB      0x6f,0x6c,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIbE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIbE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIbE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<bool>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  626f6f6c          DCB      0x62,0x6f,0x6f,0x6c
0000bc  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIbE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIbE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIbE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<bool>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2062          DCB      0x20,0x3d,0x20,0x62
000094  6f6f6c5d          DCB      0x6f,0x6f,0x6c,0x5d
000098  00                DCB      0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded8MeshgridIfE10EvaluateX1EbNS0_10ArraySliceIfEEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded8MeshgridIfE10EvaluateX1EbNS0_10ArraySliceIfEEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded8MeshgridIfE10EvaluateX1EbNS0_10ArraySliceIfEEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Meshgrid<float>::EvaluateX1(bool, Anki::Embedded::ArraySlice<float>) const::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6573          DCB      0x3a,0x4d,0x65,0x73
000020  68677269          DCB      0x68,0x67,0x72,0x69
000024  643c5479          DCB      0x64,0x3c,0x54,0x79
000028  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00002c  3a457661          DCB      0x3a,0x45,0x76,0x61
000030  6c756174          DCB      0x6c,0x75,0x61,0x74
000034  65583128          DCB      0x65,0x58,0x31,0x28
000038  626f6f6c          DCB      0x62,0x6f,0x6f,0x6c
00003c  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000040  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000044  456d6265          DCB      0x45,0x6d,0x62,0x65
000048  64646564          DCB      0x64,0x64,0x65,0x64
00004c  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000050  72617953          DCB      0x72,0x61,0x79,0x53
000054  6c696365          DCB      0x6c,0x69,0x63,0x65
000058  3c547970          DCB      0x3c,0x54,0x79,0x70
00005c  653e2920          DCB      0x65,0x3e,0x29,0x20
000060  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000064  74205b77          DCB      0x74,0x20,0x5b,0x77
000068  69746820          DCB      0x69,0x74,0x68,0x20
00006c  54797065          DCB      0x54,0x79,0x70,0x65
000070  203d2066          DCB      0x20,0x3d,0x20,0x66
000074  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000078  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded8MeshgridIfE10EvaluateY1EbNS0_10ArraySliceIfEEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded8MeshgridIfE10EvaluateY1EbNS0_10ArraySliceIfEEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded8MeshgridIfE10EvaluateY1EbNS0_10ArraySliceIfEEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Meshgrid<float>::EvaluateY1(bool, Anki::Embedded::ArraySlice<float>) const::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6573          DCB      0x3a,0x4d,0x65,0x73
000020  68677269          DCB      0x68,0x67,0x72,0x69
000024  643c5479          DCB      0x64,0x3c,0x54,0x79
000028  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00002c  3a457661          DCB      0x3a,0x45,0x76,0x61
000030  6c756174          DCB      0x6c,0x75,0x61,0x74
000034  65593128          DCB      0x65,0x59,0x31,0x28
000038  626f6f6c          DCB      0x62,0x6f,0x6f,0x6c
00003c  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000040  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000044  456d6265          DCB      0x45,0x6d,0x62,0x65
000048  64646564          DCB      0x64,0x64,0x65,0x64
00004c  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000050  72617953          DCB      0x72,0x61,0x79,0x53
000054  6c696365          DCB      0x6c,0x69,0x63,0x65
000058  3c547970          DCB      0x3c,0x54,0x79,0x70
00005c  653e2920          DCB      0x65,0x3e,0x29,0x20
000060  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000064  74205b77          DCB      0x74,0x20,0x5b,0x77
000068  69746820          DCB      0x69,0x74,0x68,0x20
00006c  54797065          DCB      0x54,0x79,0x70,0x65
000070  203d2066          DCB      0x20,0x3d,0x20,0x66
000074  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000078  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a5465          DCB      0x3a,0x3a,0x54,0x65
000098  6d706c61          DCB      0x6d,0x70,0x6c,0x61
00009c  74655472          DCB      0x74,0x65,0x54,0x72
0000a0  61636b65          DCB      0x61,0x63,0x6b,0x65
0000a4  723a3a4c          DCB      0x72,0x3a,0x3a,0x4c
0000a8  75636173          DCB      0x75,0x63,0x61,0x73
0000ac  4b616e61          DCB      0x4b,0x61,0x6e,0x61
0000b0  64655472          DCB      0x64,0x65,0x54,0x72
0000b4  61636b65          DCB      0x61,0x63,0x6b,0x65
0000b8  725f5361          DCB      0x72,0x5f,0x53,0x61
0000bc  6d706c65          DCB      0x6d,0x70,0x6c,0x65
0000c0  64506c61          DCB      0x64,0x50,0x6c,0x61
0000c4  6e617236          DCB      0x6e,0x61,0x72,0x36
0000c8  646f663a          DCB      0x64,0x6f,0x66,0x3a
0000cc  3a54656d          DCB      0x3a,0x54,0x65,0x6d
0000d0  706c6174          DCB      0x70,0x6c,0x61,0x74
0000d4  6553616d          DCB      0x65,0x53,0x61,0x6d
0000d8  706c655d          DCB      0x70,0x6c,0x65,0x5d
0000dc  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  54656d70          DCB      0x54,0x65,0x6d,0x70
0000cc  6c617465          DCB      0x6c,0x61,0x74,0x65
0000d0  54726163          DCB      0x54,0x72,0x61,0x63
0000d4  6b65723a          DCB      0x6b,0x65,0x72,0x3a
0000d8  3a4c7563          DCB      0x3a,0x4c,0x75,0x63
0000dc  61734b61          DCB      0x61,0x73,0x4b,0x61
0000e0  6e616465          DCB      0x6e,0x61,0x64,0x65
0000e4  54726163          DCB      0x54,0x72,0x61,0x63
0000e8  6b65725f          DCB      0x6b,0x65,0x72,0x5f
0000ec  53616d70          DCB      0x53,0x61,0x6d,0x70
0000f0  6c656450          DCB      0x6c,0x65,0x64,0x50
0000f4  6c616e61          DCB      0x6c,0x61,0x6e,0x61
0000f8  7236646f          DCB      0x72,0x36,0x64,0x6f
0000fc  663a3a54          DCB      0x66,0x3a,0x3a,0x54
000100  656d706c          DCB      0x65,0x6d,0x70,0x6c
000104  61746553          DCB      0x61,0x74,0x65,0x53
000108  616d706c          DCB      0x61,0x6d,0x70,0x6c
00010c  655d00            DCB      0x65,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a54          DCB      0x64,0x3a,0x3a,0x54
0000a4  656d706c          DCB      0x65,0x6d,0x70,0x6c
0000a8  61746554          DCB      0x61,0x74,0x65,0x54
0000ac  7261636b          DCB      0x72,0x61,0x63,0x6b
0000b0  65723a3a          DCB      0x65,0x72,0x3a,0x3a
0000b4  4c756361          DCB      0x4c,0x75,0x63,0x61
0000b8  734b616e          DCB      0x73,0x4b,0x61,0x6e
0000bc  61646554          DCB      0x61,0x64,0x65,0x54
0000c0  7261636b          DCB      0x72,0x61,0x63,0x6b
0000c4  65725f53          DCB      0x65,0x72,0x5f,0x53
0000c8  616d706c          DCB      0x61,0x6d,0x70,0x6c
0000cc  6564506c          DCB      0x65,0x64,0x50,0x6c
0000d0  616e6172          DCB      0x61,0x6e,0x61,0x72
0000d4  36646f66          DCB      0x36,0x64,0x6f,0x66
0000d8  3a3a5465          DCB      0x3a,0x3a,0x54,0x65
0000dc  6d706c61          DCB      0x6d,0x70,0x6c,0x61
0000e0  74655361          DCB      0x74,0x65,0x53,0x61
0000e4  6d706c65          DCB      0x6d,0x70,0x6c,0x65
0000e8  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000098  7261793c          DCB      0x72,0x61,0x79,0x3c
00009c  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000a0  743e5d00          DCB      0x74,0x3e,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS1_IfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS1_IfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS1_IfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  41727261          DCB      0x41,0x72,0x72,0x61
0000cc  793c666c          DCB      0x79,0x3c,0x66,0x6c
0000d0  6f61743e          DCB      0x6f,0x61,0x74,0x3e
0000d4  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS1_IfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS1_IfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS1_IfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a41          DCB      0x64,0x3a,0x3a,0x41
0000a4  72726179          DCB      0x72,0x72,0x61,0x79
0000a8  3c666c6f          DCB      0x3c,0x66,0x6c,0x6f
0000ac  61743e5d          DCB      0x61,0x74,0x3e,0x5d
0000b0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a4669          DCB      0x3a,0x3a,0x46,0x69
000098  7865644c          DCB      0x78,0x65,0x64,0x4c
00009c  656e6774          DCB      0x65,0x6e,0x67,0x74
0000a0  684c6973          DCB      0x68,0x4c,0x69,0x73
0000a4  743c416e          DCB      0x74,0x3c,0x41,0x6e
0000a8  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0000ac  456d6265          DCB      0x45,0x6d,0x62,0x65
0000b0  64646564          DCB      0x64,0x64,0x65,0x64
0000b4  3a3a5465          DCB      0x3a,0x3a,0x54,0x65
0000b8  6d706c61          DCB      0x6d,0x70,0x6c,0x61
0000bc  74655472          DCB      0x74,0x65,0x54,0x72
0000c0  61636b65          DCB      0x61,0x63,0x6b,0x65
0000c4  723a3a4c          DCB      0x72,0x3a,0x3a,0x4c
0000c8  75636173          DCB      0x75,0x63,0x61,0x73
0000cc  4b616e61          DCB      0x4b,0x61,0x6e,0x61
0000d0  64655472          DCB      0x64,0x65,0x54,0x72
0000d4  61636b65          DCB      0x61,0x63,0x6b,0x65
0000d8  725f5361          DCB      0x72,0x5f,0x53,0x61
0000dc  6d706c65          DCB      0x6d,0x70,0x6c,0x65
0000e0  64506c61          DCB      0x64,0x50,0x6c,0x61
0000e4  6e617236          DCB      0x6e,0x61,0x72,0x36
0000e8  646f663a          DCB      0x64,0x6f,0x66,0x3a
0000ec  3a54656d          DCB      0x3a,0x54,0x65,0x6d
0000f0  706c6174          DCB      0x70,0x6c,0x61,0x74
0000f4  6553616d          DCB      0x65,0x53,0x61,0x6d
0000f8  706c653e          DCB      0x70,0x6c,0x65,0x3e
0000fc  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  46697865          DCB      0x46,0x69,0x78,0x65
0000cc  644c656e          DCB      0x64,0x4c,0x65,0x6e
0000d0  6774684c          DCB      0x67,0x74,0x68,0x4c
0000d4  6973743c          DCB      0x69,0x73,0x74,0x3c
0000d8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000dc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000e0  62656464          DCB      0x62,0x65,0x64,0x64
0000e4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000e8  54656d70          DCB      0x54,0x65,0x6d,0x70
0000ec  6c617465          DCB      0x6c,0x61,0x74,0x65
0000f0  54726163          DCB      0x54,0x72,0x61,0x63
0000f4  6b65723a          DCB      0x6b,0x65,0x72,0x3a
0000f8  3a4c7563          DCB      0x3a,0x4c,0x75,0x63
0000fc  61734b61          DCB      0x61,0x73,0x4b,0x61
000100  6e616465          DCB      0x6e,0x61,0x64,0x65
000104  54726163          DCB      0x54,0x72,0x61,0x63
000108  6b65725f          DCB      0x6b,0x65,0x72,0x5f
00010c  53616d70          DCB      0x53,0x61,0x6d,0x70
000110  6c656450          DCB      0x6c,0x65,0x64,0x50
000114  6c616e61          DCB      0x6c,0x61,0x6e,0x61
000118  7236646f          DCB      0x72,0x36,0x64,0x6f
00011c  663a3a54          DCB      0x66,0x3a,0x3a,0x54
000120  656d706c          DCB      0x65,0x6d,0x70,0x6c
000124  61746553          DCB      0x61,0x74,0x65,0x53
000128  616d706c          DCB      0x61,0x6d,0x70,0x6c
00012c  653e5d00          DCB      0x65,0x3e,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_15FixedLengthListINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14TemplateSampleEEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::FixedLengthList<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::TemplateSample>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a46          DCB      0x64,0x3a,0x3a,0x46
0000a4  69786564          DCB      0x69,0x78,0x65,0x64
0000a8  4c656e67          DCB      0x4c,0x65,0x6e,0x67
0000ac  74684c69          DCB      0x74,0x68,0x4c,0x69
0000b0  73743c41          DCB      0x73,0x74,0x3c,0x41
0000b4  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000b8  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000bc  65646465          DCB      0x65,0x64,0x64,0x65
0000c0  643a3a54          DCB      0x64,0x3a,0x3a,0x54
0000c4  656d706c          DCB      0x65,0x6d,0x70,0x6c
0000c8  61746554          DCB      0x61,0x74,0x65,0x54
0000cc  7261636b          DCB      0x72,0x61,0x63,0x6b
0000d0  65723a3a          DCB      0x65,0x72,0x3a,0x3a
0000d4  4c756361          DCB      0x4c,0x75,0x63,0x61
0000d8  734b616e          DCB      0x73,0x4b,0x61,0x6e
0000dc  61646554          DCB      0x61,0x64,0x65,0x54
0000e0  7261636b          DCB      0x72,0x61,0x63,0x6b
0000e4  65725f53          DCB      0x65,0x72,0x5f,0x53
0000e8  616d706c          DCB      0x61,0x6d,0x70,0x6c
0000ec  6564506c          DCB      0x65,0x64,0x50,0x6c
0000f0  616e6172          DCB      0x61,0x6e,0x61,0x72
0000f4  36646f66          DCB      0x36,0x64,0x6f,0x66
0000f8  3a3a5465          DCB      0x3a,0x3a,0x54,0x65
0000fc  6d706c61          DCB      0x6d,0x70,0x6c,0x61
000100  74655361          DCB      0x74,0x65,0x53,0x61
000104  6d706c65          DCB      0x6d,0x70,0x6c,0x65
000108  3e5d00            DCB      0x3e,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a5465          DCB      0x3a,0x3a,0x54,0x65
000098  6d706c61          DCB      0x6d,0x70,0x6c,0x61
00009c  74655472          DCB      0x74,0x65,0x54,0x72
0000a0  61636b65          DCB      0x61,0x63,0x6b,0x65
0000a4  723a3a4c          DCB      0x72,0x3a,0x3a,0x4c
0000a8  75636173          DCB      0x75,0x63,0x61,0x73
0000ac  4b616e61          DCB      0x4b,0x61,0x6e,0x61
0000b0  64655472          DCB      0x64,0x65,0x54,0x72
0000b4  61636b65          DCB      0x61,0x63,0x6b,0x65
0000b8  725f5361          DCB      0x72,0x5f,0x53,0x61
0000bc  6d706c65          DCB      0x6d,0x70,0x6c,0x65
0000c0  64506c61          DCB      0x64,0x50,0x6c,0x61
0000c4  6e617236          DCB      0x6e,0x61,0x72,0x36
0000c8  646f663a          DCB      0x64,0x6f,0x66,0x3a
0000cc  3a566572          DCB      0x3a,0x56,0x65,0x72
0000d0  69667953          DCB      0x69,0x66,0x79,0x53
0000d4  616d706c          DCB      0x61,0x6d,0x70,0x6c
0000d8  655d00            DCB      0x65,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  54656d70          DCB      0x54,0x65,0x6d,0x70
0000cc  6c617465          DCB      0x6c,0x61,0x74,0x65
0000d0  54726163          DCB      0x54,0x72,0x61,0x63
0000d4  6b65723a          DCB      0x6b,0x65,0x72,0x3a
0000d8  3a4c7563          DCB      0x3a,0x4c,0x75,0x63
0000dc  61734b61          DCB      0x61,0x73,0x4b,0x61
0000e0  6e616465          DCB      0x6e,0x61,0x64,0x65
0000e4  54726163          DCB      0x54,0x72,0x61,0x63
0000e8  6b65725f          DCB      0x6b,0x65,0x72,0x5f
0000ec  53616d70          DCB      0x53,0x61,0x6d,0x70
0000f0  6c656450          DCB      0x6c,0x65,0x64,0x50
0000f4  6c616e61          DCB      0x6c,0x61,0x6e,0x61
0000f8  7236646f          DCB      0x72,0x36,0x64,0x6f
0000fc  663a3a56          DCB      0x66,0x3a,0x3a,0x56
000100  65726966          DCB      0x65,0x72,0x69,0x66
000104  7953616d          DCB      0x79,0x53,0x61,0x6d
000108  706c655d          DCB      0x70,0x6c,0x65,0x5d
00010c  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof12VerifySampleEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::VerifySample>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a54          DCB      0x64,0x3a,0x3a,0x54
0000a4  656d706c          DCB      0x65,0x6d,0x70,0x6c
0000a8  61746554          DCB      0x61,0x74,0x65,0x54
0000ac  7261636b          DCB      0x72,0x61,0x63,0x6b
0000b0  65723a3a          DCB      0x65,0x72,0x3a,0x3a
0000b4  4c756361          DCB      0x4c,0x75,0x63,0x61
0000b8  734b616e          DCB      0x73,0x4b,0x61,0x6e
0000bc  61646554          DCB      0x61,0x64,0x65,0x54
0000c0  7261636b          DCB      0x72,0x61,0x63,0x6b
0000c4  65725f53          DCB      0x65,0x72,0x5f,0x53
0000c8  616d706c          DCB      0x61,0x6d,0x70,0x6c
0000cc  6564506c          DCB      0x65,0x64,0x50,0x6c
0000d0  616e6172          DCB      0x61,0x6e,0x61,0x72
0000d4  36646f66          DCB      0x36,0x64,0x6f,0x66
0000d8  3a3a5665          DCB      0x3a,0x3a,0x56,0x65
0000dc  72696679          DCB      0x72,0x69,0x66,0x79
0000e0  53616d70          DCB      0x53,0x61,0x6d,0x70
0000e4  6c655d00          DCB      0x6c,0x65,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_11DotMultiplyIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_11DotMultiplyIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_11DotMultiplyIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::DotMultiply<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, const Anki::Embedded::ConstArraySliceExpression<T1>&, Anki::Embedded::ArraySlice<T3>)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a456c65          DCB      0x3a,0x45,0x6c,0x65
000028  6d656e74          DCB      0x6d,0x65,0x6e,0x74
00002c  77697365          DCB      0x77,0x69,0x73,0x65
000030  3a3a4170          DCB      0x3a,0x3a,0x41,0x70
000034  706c794f          DCB      0x70,0x6c,0x79,0x4f
000038  70657261          DCB      0x70,0x65,0x72,0x61
00003c  74696f6e          DCB      0x74,0x69,0x6f,0x6e
000040  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000044  73742041          DCB      0x73,0x74,0x20,0x41
000048  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00004c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000050  65646465          DCB      0x65,0x64,0x64,0x65
000054  643a3a43          DCB      0x64,0x3a,0x3a,0x43
000058  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
00005c  41727261          DCB      0x41,0x72,0x72,0x61
000060  79536c69          DCB      0x79,0x53,0x6c,0x69
000064  63654578          DCB      0x63,0x65,0x45,0x78
000068  70726573          DCB      0x70,0x72,0x65,0x73
00006c  73696f6e          DCB      0x73,0x69,0x6f,0x6e
000070  3c547970          DCB      0x3c,0x54,0x79,0x70
000074  653e2026          DCB      0x65,0x3e,0x20,0x26
000078  2c20636f          DCB      0x2c,0x20,0x63,0x6f
00007c  6e737420          DCB      0x6e,0x73,0x74,0x20
000080  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000084  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000088  62656464          DCB      0x62,0x65,0x64,0x64
00008c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000090  436f6e73          DCB      0x43,0x6f,0x6e,0x73
000094  74417272          DCB      0x74,0x41,0x72,0x72
000098  6179536c          DCB      0x61,0x79,0x53,0x6c
00009c  69636545          DCB      0x69,0x63,0x65,0x45
0000a0  78707265          DCB      0x78,0x70,0x72,0x65
0000a4  7373696f          DCB      0x73,0x73,0x69,0x6f
0000a8  6e3c5479          DCB      0x6e,0x3c,0x54,0x79
0000ac  70653e20          DCB      0x70,0x65,0x3e,0x20
0000b0  262c2041          DCB      0x26,0x2c,0x20,0x41
0000b4  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000b8  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000bc  65646465          DCB      0x65,0x64,0x64,0x65
0000c0  643a3a41          DCB      0x64,0x3a,0x3a,0x41
0000c4  72726179          DCB      0x72,0x72,0x61,0x79
0000c8  536c6963          DCB      0x53,0x6c,0x69,0x63
0000cc  653c4f75          DCB      0x65,0x3c,0x4f,0x75
0000d0  74547970          DCB      0x74,0x54,0x79,0x70
0000d4  653e2920          DCB      0x65,0x3e,0x29,0x20
0000d8  5b776974          DCB      0x5b,0x77,0x69,0x74
0000dc  6820496e          DCB      0x68,0x20,0x49,0x6e
0000e0  54797065          DCB      0x54,0x79,0x70,0x65
0000e4  203d2066          DCB      0x20,0x3d,0x20,0x66
0000e8  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
0000ec  2c204f70          DCB      0x2c,0x20,0x4f,0x70
0000f0  65726174          DCB      0x65,0x72,0x61,0x74
0000f4  6f72203d          DCB      0x6f,0x72,0x20,0x3d
0000f8  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000fc  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000100  6d626564          DCB      0x6d,0x62,0x65,0x64
000104  6465643a          DCB      0x64,0x65,0x64,0x3a
000108  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
00010c  7269783a          DCB      0x72,0x69,0x78,0x3a
000110  3a456c65          DCB      0x3a,0x45,0x6c,0x65
000114  6d656e74          DCB      0x6d,0x65,0x6e,0x74
000118  77697365          DCB      0x77,0x69,0x73,0x65
00011c  3a3a446f          DCB      0x3a,0x3a,0x44,0x6f
000120  744d756c          DCB      0x74,0x4d,0x75,0x6c
000124  7469706c          DCB      0x74,0x69,0x70,0x6c
000128  793c666c          DCB      0x79,0x3c,0x66,0x6c
00012c  6f61742c          DCB      0x6f,0x61,0x74,0x2c
000130  20666c6f          DCB      0x20,0x66,0x6c,0x6f
000134  61742c20          DCB      0x61,0x74,0x2c,0x20
000138  666c6f61          DCB      0x66,0x6c,0x6f,0x61
00013c  743e2c20          DCB      0x74,0x3e,0x2c,0x20
000140  4f757454          DCB      0x4f,0x75,0x74,0x54
000144  79706520          DCB      0x79,0x70,0x65,0x20
000148  3d20666c          DCB      0x3d,0x20,0x66,0x6c
00014c  6f61745d          DCB      0x6f,0x61,0x74,0x5d
000150  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_3AddIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_3AddIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_3AddIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EESB_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::Add<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, const Anki::Embedded::ConstArraySliceExpression<T1>&, Anki::Embedded::ArraySlice<T3>)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a456c65          DCB      0x3a,0x45,0x6c,0x65
000028  6d656e74          DCB      0x6d,0x65,0x6e,0x74
00002c  77697365          DCB      0x77,0x69,0x73,0x65
000030  3a3a4170          DCB      0x3a,0x3a,0x41,0x70
000034  706c794f          DCB      0x70,0x6c,0x79,0x4f
000038  70657261          DCB      0x70,0x65,0x72,0x61
00003c  74696f6e          DCB      0x74,0x69,0x6f,0x6e
000040  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000044  73742041          DCB      0x73,0x74,0x20,0x41
000048  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00004c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000050  65646465          DCB      0x65,0x64,0x64,0x65
000054  643a3a43          DCB      0x64,0x3a,0x3a,0x43
000058  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
00005c  41727261          DCB      0x41,0x72,0x72,0x61
000060  79536c69          DCB      0x79,0x53,0x6c,0x69
000064  63654578          DCB      0x63,0x65,0x45,0x78
000068  70726573          DCB      0x70,0x72,0x65,0x73
00006c  73696f6e          DCB      0x73,0x69,0x6f,0x6e
000070  3c547970          DCB      0x3c,0x54,0x79,0x70
000074  653e2026          DCB      0x65,0x3e,0x20,0x26
000078  2c20636f          DCB      0x2c,0x20,0x63,0x6f
00007c  6e737420          DCB      0x6e,0x73,0x74,0x20
000080  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000084  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000088  62656464          DCB      0x62,0x65,0x64,0x64
00008c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000090  436f6e73          DCB      0x43,0x6f,0x6e,0x73
000094  74417272          DCB      0x74,0x41,0x72,0x72
000098  6179536c          DCB      0x61,0x79,0x53,0x6c
00009c  69636545          DCB      0x69,0x63,0x65,0x45
0000a0  78707265          DCB      0x78,0x70,0x72,0x65
0000a4  7373696f          DCB      0x73,0x73,0x69,0x6f
0000a8  6e3c5479          DCB      0x6e,0x3c,0x54,0x79
0000ac  70653e20          DCB      0x70,0x65,0x3e,0x20
0000b0  262c2041          DCB      0x26,0x2c,0x20,0x41
0000b4  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000b8  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000bc  65646465          DCB      0x65,0x64,0x64,0x65
0000c0  643a3a41          DCB      0x64,0x3a,0x3a,0x41
0000c4  72726179          DCB      0x72,0x72,0x61,0x79
0000c8  536c6963          DCB      0x53,0x6c,0x69,0x63
0000cc  653c4f75          DCB      0x65,0x3c,0x4f,0x75
0000d0  74547970          DCB      0x74,0x54,0x79,0x70
0000d4  653e2920          DCB      0x65,0x3e,0x29,0x20
0000d8  5b776974          DCB      0x5b,0x77,0x69,0x74
0000dc  6820496e          DCB      0x68,0x20,0x49,0x6e
0000e0  54797065          DCB      0x54,0x79,0x70,0x65
0000e4  203d2066          DCB      0x20,0x3d,0x20,0x66
0000e8  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
0000ec  2c204f70          DCB      0x2c,0x20,0x4f,0x70
0000f0  65726174          DCB      0x65,0x72,0x61,0x74
0000f4  6f72203d          DCB      0x6f,0x72,0x20,0x3d
0000f8  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000fc  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000100  6d626564          DCB      0x6d,0x62,0x65,0x64
000104  6465643a          DCB      0x64,0x65,0x64,0x3a
000108  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
00010c  7269783a          DCB      0x72,0x69,0x78,0x3a
000110  3a456c65          DCB      0x3a,0x45,0x6c,0x65
000114  6d656e74          DCB      0x6d,0x65,0x6e,0x74
000118  77697365          DCB      0x77,0x69,0x73,0x65
00011c  3a3a4164          DCB      0x3a,0x3a,0x41,0x64
000120  643c666c          DCB      0x64,0x3c,0x66,0x6c
000124  6f61742c          DCB      0x6f,0x61,0x74,0x2c
000128  20666c6f          DCB      0x20,0x66,0x6c,0x6f
00012c  61742c20          DCB      0x61,0x74,0x2c,0x20
000130  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000134  743e2c20          DCB      0x74,0x3e,0x2c,0x20
000138  4f757454          DCB      0x4f,0x75,0x74,0x54
00013c  79706520          DCB      0x79,0x70,0x65,0x20
000140  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000144  6f61745d          DCB      0x6f,0x61,0x74,0x5d
000148  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a496e73          DCB      0x3a,0x49,0x6e,0x73
000028  65727469          DCB      0x65,0x72,0x74,0x69
00002c  6f6e536f          DCB      0x6f,0x6e,0x53,0x6f
000030  72742841          DCB      0x72,0x74,0x28,0x41
000034  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000038  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00003c  65646465          DCB      0x65,0x64,0x64,0x65
000040  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000044  72726179          DCB      0x72,0x72,0x61,0x79
000048  3c547970          DCB      0x3c,0x54,0x79,0x70
00004c  653e2026          DCB      0x65,0x3e,0x20,0x26
000050  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000054  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000058  456d6265          DCB      0x45,0x6d,0x62,0x65
00005c  64646564          DCB      0x64,0x64,0x65,0x64
000060  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000064  7261793c          DCB      0x72,0x61,0x79,0x3c
000068  7369676e          DCB      0x73,0x69,0x67,0x6e
00006c  65642069          DCB      0x65,0x64,0x20,0x69
000070  6e743e20          DCB      0x6e,0x74,0x3e,0x20
000074  262c2073          DCB      0x26,0x2c,0x20,0x73
000078  69676e65          DCB      0x69,0x67,0x6e,0x65
00007c  6420696e          DCB      0x64,0x20,0x69,0x6e
000080  742c2062          DCB      0x74,0x2c,0x20,0x62
000084  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
000088  20736967          DCB      0x20,0x73,0x69,0x67
00008c  6e656420          DCB      0x6e,0x65,0x64,0x20
000090  696e742c          DCB      0x69,0x6e,0x74,0x2c
000094  20736967          DCB      0x20,0x73,0x69,0x67
000098  6e656420          DCB      0x6e,0x65,0x64,0x20
00009c  696e7429          DCB      0x69,0x6e,0x74,0x29
0000a0  205b7769          DCB      0x20,0x5b,0x77,0x69
0000a4  74682054          DCB      0x74,0x68,0x20,0x54
0000a8  79706520          DCB      0x79,0x70,0x65,0x20
0000ac  3d20666c          DCB      0x3d,0x20,0x66,0x6c
0000b0  6f61745d          DCB      0x6f,0x61,0x74,0x5d
0000b4  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix3MinIhEET_RKNS0_25ConstArraySliceExpressionIS3_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix3MinIhEET_RKNS0_25ConstArraySliceExpressionIS3_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix3MinIhEET_RKNS0_25ConstArraySliceExpressionIS3_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Min<unsigned char>(const Anki::Embedded::ConstArraySliceExpression<T1>&)::__PRETTY_FUNCTION__
000000  54797065          DCB      0x54,0x79,0x70,0x65
000004  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000008  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00000c  6d626564          DCB      0x6d,0x62,0x65,0x64
000010  6465643a          DCB      0x64,0x65,0x64,0x3a
000014  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000018  7269783a          DCB      0x72,0x69,0x78,0x3a
00001c  3a4d696e          DCB      0x3a,0x4d,0x69,0x6e
000020  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000024  73742041          DCB      0x73,0x74,0x20,0x41
000028  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00002c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000030  65646465          DCB      0x65,0x64,0x64,0x65
000034  643a3a43          DCB      0x64,0x3a,0x3a,0x43
000038  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
00003c  41727261          DCB      0x41,0x72,0x72,0x61
000040  79536c69          DCB      0x79,0x53,0x6c,0x69
000044  63654578          DCB      0x63,0x65,0x45,0x78
000048  70726573          DCB      0x70,0x72,0x65,0x73
00004c  73696f6e          DCB      0x73,0x69,0x6f,0x6e
000050  3c547970          DCB      0x3c,0x54,0x79,0x70
000054  653e2026          DCB      0x65,0x3e,0x20,0x26
000058  29205b77          DCB      0x29,0x20,0x5b,0x77
00005c  69746820          DCB      0x69,0x74,0x68,0x20
000060  54797065          DCB      0x54,0x79,0x70,0x65
000064  203d2075          DCB      0x20,0x3d,0x20,0x75
000068  6e736967          DCB      0x6e,0x73,0x69,0x67
00006c  6e656420          DCB      0x6e,0x65,0x64,0x20
000070  63686172          DCB      0x63,0x68,0x61,0x72
000074  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix3MaxIhEET_RKNS0_25ConstArraySliceExpressionIS3_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix3MaxIhEET_RKNS0_25ConstArraySliceExpressionIS3_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix3MaxIhEET_RKNS0_25ConstArraySliceExpressionIS3_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Max<unsigned char>(const Anki::Embedded::ConstArraySliceExpression<T1>&)::__PRETTY_FUNCTION__
000000  54797065          DCB      0x54,0x79,0x70,0x65
000004  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000008  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00000c  6d626564          DCB      0x6d,0x62,0x65,0x64
000010  6465643a          DCB      0x64,0x65,0x64,0x3a
000014  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000018  7269783a          DCB      0x72,0x69,0x78,0x3a
00001c  3a4d6178          DCB      0x3a,0x4d,0x61,0x78
000020  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000024  73742041          DCB      0x73,0x74,0x20,0x41
000028  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00002c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000030  65646465          DCB      0x65,0x64,0x64,0x65
000034  643a3a43          DCB      0x64,0x3a,0x3a,0x43
000038  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
00003c  41727261          DCB      0x41,0x72,0x72,0x61
000040  79536c69          DCB      0x79,0x53,0x6c,0x69
000044  63654578          DCB      0x63,0x65,0x45,0x78
000048  70726573          DCB      0x70,0x72,0x65,0x73
00004c  73696f6e          DCB      0x73,0x69,0x6f,0x6e
000050  3c547970          DCB      0x3c,0x54,0x79,0x70
000054  653e2026          DCB      0x65,0x3e,0x20,0x26
000058  29205b77          DCB      0x29,0x20,0x5b,0x77
00005c  69746820          DCB      0x69,0x74,0x68,0x20
000060  54797065          DCB      0x54,0x79,0x70,0x65
000064  203d2075          DCB      0x20,0x3d,0x20,0x75
000068  6e736967          DCB      0x6e,0x73,0x69,0x67
00006c  6e656420          DCB      0x6e,0x65,0x64,0x20
000070  63686172          DCB      0x63,0x68,0x61,0x72
000074  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix9VectorizeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Vectorize<float, float>(bool, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a566563          DCB      0x3a,0x56,0x65,0x63
000028  746f7269          DCB      0x74,0x6f,0x72,0x69
00002c  7a652862          DCB      0x7a,0x65,0x28,0x62
000030  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
000034  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000038  73742041          DCB      0x73,0x74,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00004c  72726179          DCB      0x72,0x72,0x61,0x79
000050  3c547970          DCB      0x3c,0x54,0x79,0x70
000054  653e2026          DCB      0x65,0x3e,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
00006c  7261793c          DCB      0x72,0x61,0x79,0x3c
000070  4f757454          DCB      0x4f,0x75,0x74,0x54
000074  7970653e          DCB      0x79,0x70,0x65,0x3e
000078  20262920          DCB      0x20,0x26,0x29,0x20
00007c  5b776974          DCB      0x5b,0x77,0x69,0x74
000080  6820496e          DCB      0x68,0x20,0x49,0x6e
000084  54797065          DCB      0x54,0x79,0x70,0x65
000088  203d2066          DCB      0x20,0x3d,0x20,0x66
00008c  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000090  2c204f75          DCB      0x2c,0x20,0x4f,0x75
000094  74547970          DCB      0x74,0x54,0x79,0x70
000098  65203d20          DCB      0x65,0x20,0x3d,0x20
00009c  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000a0  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix9VectorizeIhhEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix9VectorizeIhhEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix9VectorizeIhhEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Vectorize<unsigned char, unsigned char>(bool, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a566563          DCB      0x3a,0x56,0x65,0x63
000028  746f7269          DCB      0x74,0x6f,0x72,0x69
00002c  7a652862          DCB      0x7a,0x65,0x28,0x62
000030  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
000034  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000038  73742041          DCB      0x73,0x74,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00004c  72726179          DCB      0x72,0x72,0x61,0x79
000050  3c547970          DCB      0x3c,0x54,0x79,0x70
000054  653e2026          DCB      0x65,0x3e,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
00006c  7261793c          DCB      0x72,0x61,0x79,0x3c
000070  4f757454          DCB      0x4f,0x75,0x74,0x54
000074  7970653e          DCB      0x79,0x70,0x65,0x3e
000078  20262920          DCB      0x20,0x26,0x29,0x20
00007c  5b776974          DCB      0x5b,0x77,0x69,0x74
000080  6820496e          DCB      0x68,0x20,0x49,0x6e
000084  54797065          DCB      0x54,0x79,0x70,0x65
000088  203d2075          DCB      0x20,0x3d,0x20,0x75
00008c  6e736967          DCB      0x6e,0x73,0x69,0x67
000090  6e656420          DCB      0x6e,0x65,0x64,0x20
000094  63686172          DCB      0x63,0x68,0x61,0x72
000098  2c204f75          DCB      0x2c,0x20,0x4f,0x75
00009c  74547970          DCB      0x74,0x54,0x79,0x70
0000a0  65203d20          DCB      0x65,0x20,0x3d,0x20
0000a4  756e7369          DCB      0x75,0x6e,0x73,0x69
0000a8  676e6564          DCB      0x67,0x6e,0x65,0x64
0000ac  20636861          DCB      0x20,0x63,0x68,0x61
0000b0  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_bE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_bE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix13MakeSymmetricINS0_5ArrayIfEEEENS_6ResultERT_bE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::MakeSymmetric<Anki::Embedded::Array<float>>(T1&, bool)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a4d616b          DCB      0x3a,0x4d,0x61,0x6b
000028  6553796d          DCB      0x65,0x53,0x79,0x6d
00002c  6d657472          DCB      0x6d,0x65,0x74,0x72
000030  69632854          DCB      0x69,0x63,0x28,0x54
000034  79706520          DCB      0x79,0x70,0x65,0x20
000038  262c2062          DCB      0x26,0x2c,0x20,0x62
00003c  6f6f6c29          DCB      0x6f,0x6f,0x6c,0x29
000040  205b7769          DCB      0x20,0x5b,0x77,0x69
000044  74682054          DCB      0x74,0x68,0x20,0x54
000048  79706520          DCB      0x79,0x70,0x65,0x20
00004c  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000050  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000054  456d6265          DCB      0x45,0x6d,0x62,0x65
000058  64646564          DCB      0x64,0x64,0x65,0x64
00005c  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000060  7261793c          DCB      0x72,0x61,0x79,0x3c
000064  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000068  743e5d00          DCB      0x74,0x3e,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a536f6c          DCB      0x3a,0x53,0x6f,0x6c
000028  76654c65          DCB      0x76,0x65,0x4c,0x65
00002c  61737453          DCB      0x61,0x73,0x74,0x53
000030  71756172          DCB      0x71,0x75,0x61,0x72
000034  65735769          DCB      0x65,0x73,0x57,0x69
000038  74684368          DCB      0x74,0x68,0x43,0x68
00003c  6f6c6573          DCB      0x6f,0x6c,0x65,0x73
000040  6b792841          DCB      0x6b,0x79,0x28,0x41
000044  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000048  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00004c  65646465          DCB      0x65,0x64,0x64,0x65
000050  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000054  72726179          DCB      0x72,0x72,0x61,0x79
000058  3c547970          DCB      0x3c,0x54,0x79,0x70
00005c  653e2026          DCB      0x65,0x3e,0x20,0x26
000060  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000064  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000068  456d6265          DCB      0x45,0x6d,0x62,0x65
00006c  64646564          DCB      0x64,0x64,0x65,0x64
000070  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000074  7261793c          DCB      0x72,0x61,0x79,0x3c
000078  54797065          DCB      0x54,0x79,0x70,0x65
00007c  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000080  20626f6f          DCB      0x20,0x62,0x6f,0x6f
000084  6c2c2062          DCB      0x6c,0x2c,0x20,0x62
000088  6f6f6c20          DCB      0x6f,0x6f,0x6c,0x20
00008c  2629205b          DCB      0x26,0x29,0x20,0x5b
000090  77697468          DCB      0x77,0x69,0x74,0x68
000094  20547970          DCB      0x20,0x54,0x79,0x70
000098  65203d20          DCB      0x65,0x20,0x3d,0x20
00009c  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000a0  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix3MaxIfEET_RKNS0_25ConstArraySliceExpressionIS3_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix3MaxIfEET_RKNS0_25ConstArraySliceExpressionIS3_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix3MaxIfEET_RKNS0_25ConstArraySliceExpressionIS3_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Max<float>(const Anki::Embedded::ConstArraySliceExpression<T1>&)::__PRETTY_FUNCTION__
000000  54797065          DCB      0x54,0x79,0x70,0x65
000004  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000008  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00000c  6d626564          DCB      0x6d,0x62,0x65,0x64
000010  6465643a          DCB      0x64,0x65,0x64,0x3a
000014  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000018  7269783a          DCB      0x72,0x69,0x78,0x3a
00001c  3a4d6178          DCB      0x3a,0x4d,0x61,0x78
000020  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000024  73742041          DCB      0x73,0x74,0x20,0x41
000028  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00002c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000030  65646465          DCB      0x65,0x64,0x64,0x65
000034  643a3a43          DCB      0x64,0x3a,0x3a,0x43
000038  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
00003c  41727261          DCB      0x41,0x72,0x72,0x61
000040  79536c69          DCB      0x79,0x53,0x6c,0x69
000044  63654578          DCB      0x63,0x65,0x45,0x78
000048  70726573          DCB      0x70,0x72,0x65,0x73
00004c  73696f6e          DCB      0x73,0x69,0x6f,0x6e
000050  3c547970          DCB      0x3c,0x54,0x79,0x70
000054  653e2026          DCB      0x65,0x3e,0x20,0x26
000058  29205b77          DCB      0x29,0x20,0x5b,0x77
00005c  69746820          DCB      0x69,0x74,0x68,0x20
000060  54797065          DCB      0x54,0x79,0x70,0x65
000064  203d2066          DCB      0x20,0x3d,0x20,0x66
000068  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
00006c  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix7ReshapeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix7ReshapeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix7ReshapeIffEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Reshape<float, float>(bool, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a526573          DCB      0x3a,0x52,0x65,0x73
000028  68617065          DCB      0x68,0x61,0x70,0x65
00002c  28626f6f          DCB      0x28,0x62,0x6f,0x6f
000030  6c2c2063          DCB      0x6c,0x2c,0x20,0x63
000034  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000038  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00003c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000040  6d626564          DCB      0x6d,0x62,0x65,0x64
000044  6465643a          DCB      0x64,0x65,0x64,0x3a
000048  3a417272          DCB      0x3a,0x41,0x72,0x72
00004c  61793c54          DCB      0x61,0x79,0x3c,0x54
000050  7970653e          DCB      0x79,0x70,0x65,0x3e
000054  20262c20          DCB      0x20,0x26,0x2c,0x20
000058  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00005c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000060  62656464          DCB      0x62,0x65,0x64,0x64
000064  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000068  41727261          DCB      0x41,0x72,0x72,0x61
00006c  793c4f75          DCB      0x79,0x3c,0x4f,0x75
000070  74547970          DCB      0x74,0x54,0x79,0x70
000074  653e2026          DCB      0x65,0x3e,0x20,0x26
000078  29205b77          DCB      0x29,0x20,0x5b,0x77
00007c  69746820          DCB      0x69,0x74,0x68,0x20
000080  496e5479          DCB      0x49,0x6e,0x54,0x79
000084  7065203d          DCB      0x70,0x65,0x20,0x3d
000088  20666c6f          DCB      0x20,0x66,0x6c,0x6f
00008c  61742c20          DCB      0x61,0x74,0x2c,0x20
000090  4f757454          DCB      0x4f,0x75,0x74,0x54
000094  79706520          DCB      0x79,0x70,0x65,0x20
000098  3d20666c          DCB      0x3d,0x20,0x66,0x6c
00009c  6f61745d          DCB      0x6f,0x61,0x74,0x5d
0000a0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix7ReshapeIhhEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix7ReshapeIhhEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix7ReshapeIhhEENS_6ResultEbRKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Reshape<unsigned char, unsigned char>(bool, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a526573          DCB      0x3a,0x52,0x65,0x73
000028  68617065          DCB      0x68,0x61,0x70,0x65
00002c  28626f6f          DCB      0x28,0x62,0x6f,0x6f
000030  6c2c2063          DCB      0x6c,0x2c,0x20,0x63
000034  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000038  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00003c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000040  6d626564          DCB      0x6d,0x62,0x65,0x64
000044  6465643a          DCB      0x64,0x65,0x64,0x3a
000048  3a417272          DCB      0x3a,0x41,0x72,0x72
00004c  61793c54          DCB      0x61,0x79,0x3c,0x54
000050  7970653e          DCB      0x79,0x70,0x65,0x3e
000054  20262c20          DCB      0x20,0x26,0x2c,0x20
000058  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00005c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000060  62656464          DCB      0x62,0x65,0x64,0x64
000064  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000068  41727261          DCB      0x41,0x72,0x72,0x61
00006c  793c4f75          DCB      0x79,0x3c,0x4f,0x75
000070  74547970          DCB      0x74,0x54,0x79,0x70
000074  653e2026          DCB      0x65,0x3e,0x20,0x26
000078  29205b77          DCB      0x29,0x20,0x5b,0x77
00007c  69746820          DCB      0x69,0x74,0x68,0x20
000080  496e5479          DCB      0x49,0x6e,0x54,0x79
000084  7065203d          DCB      0x70,0x65,0x20,0x3d
000088  20756e73          DCB      0x20,0x75,0x6e,0x73
00008c  69676e65          DCB      0x69,0x67,0x6e,0x65
000090  64206368          DCB      0x64,0x20,0x63,0x68
000094  61722c20          DCB      0x61,0x72,0x2c,0x20
000098  4f757454          DCB      0x4f,0x75,0x74,0x54
00009c  79706520          DCB      0x79,0x70,0x65,0x20
0000a0  3d20756e          DCB      0x3d,0x20,0x75,0x6e
0000a4  7369676e          DCB      0x73,0x69,0x67,0x6e
0000a8  65642063          DCB      0x65,0x64,0x20,0x63
0000ac  6861725d          DCB      0x68,0x61,0x72,0x5d
0000b0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded15ImageProcessing16ComputeXGradientIhffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT1_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded15ImageProcessing16ComputeXGradientIhffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT1_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded15ImageProcessing16ComputeXGradientIhffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::ImageProcessing::ComputeXGradient<unsigned char, float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T3>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a496d61          DCB      0x3a,0x49,0x6d,0x61
000020  67655072          DCB      0x67,0x65,0x50,0x72
000024  6f636573          DCB      0x6f,0x63,0x65,0x73
000028  73696e67          DCB      0x73,0x69,0x6e,0x67
00002c  3a3a436f          DCB      0x3a,0x3a,0x43,0x6f
000030  6d707574          DCB      0x6d,0x70,0x75,0x74
000034  65584772          DCB      0x65,0x58,0x47,0x72
000038  61646965          DCB      0x61,0x64,0x69,0x65
00003c  6e742863          DCB      0x6e,0x74,0x28,0x63
000040  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000044  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000048  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00004c  6d626564          DCB      0x6d,0x62,0x65,0x64
000050  6465643a          DCB      0x64,0x65,0x64,0x3a
000054  3a417272          DCB      0x3a,0x41,0x72,0x72
000058  61793c54          DCB      0x61,0x79,0x3c,0x54
00005c  7970653e          DCB      0x79,0x70,0x65,0x3e
000060  20262c20          DCB      0x20,0x26,0x2c,0x20
000064  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000068  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00006c  62656464          DCB      0x62,0x65,0x64,0x64
000070  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000074  41727261          DCB      0x41,0x72,0x72,0x61
000078  793c4f75          DCB      0x79,0x3c,0x4f,0x75
00007c  74547970          DCB      0x74,0x54,0x79,0x70
000080  653e2026          DCB      0x65,0x3e,0x20,0x26
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  496e5479          DCB      0x49,0x6e,0x54,0x79
000090  7065203d          DCB      0x70,0x65,0x20,0x3d
000094  20756e73          DCB      0x20,0x75,0x6e,0x73
000098  69676e65          DCB      0x69,0x67,0x6e,0x65
00009c  64206368          DCB      0x64,0x20,0x63,0x68
0000a0  61722c20          DCB      0x61,0x72,0x2c,0x20
0000a4  496e7465          DCB      0x49,0x6e,0x74,0x65
0000a8  726d6564          DCB      0x72,0x6d,0x65,0x64
0000ac  69617465          DCB      0x69,0x61,0x74,0x65
0000b0  54797065          DCB      0x54,0x79,0x70,0x65
0000b4  203d2066          DCB      0x20,0x3d,0x20,0x66
0000b8  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
0000bc  2c204f75          DCB      0x2c,0x20,0x4f,0x75
0000c0  74547970          DCB      0x74,0x54,0x79,0x70
0000c4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000c8  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000cc  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded15ImageProcessing16ComputeYGradientIhffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT1_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded15ImageProcessing16ComputeYGradientIhffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT1_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded15ImageProcessing16ComputeYGradientIhffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::ImageProcessing::ComputeYGradient<unsigned char, float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T3>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a496d61          DCB      0x3a,0x49,0x6d,0x61
000020  67655072          DCB      0x67,0x65,0x50,0x72
000024  6f636573          DCB      0x6f,0x63,0x65,0x73
000028  73696e67          DCB      0x73,0x69,0x6e,0x67
00002c  3a3a436f          DCB      0x3a,0x3a,0x43,0x6f
000030  6d707574          DCB      0x6d,0x70,0x75,0x74
000034  65594772          DCB      0x65,0x59,0x47,0x72
000038  61646965          DCB      0x61,0x64,0x69,0x65
00003c  6e742863          DCB      0x6e,0x74,0x28,0x63
000040  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000044  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000048  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00004c  6d626564          DCB      0x6d,0x62,0x65,0x64
000050  6465643a          DCB      0x64,0x65,0x64,0x3a
000054  3a417272          DCB      0x3a,0x41,0x72,0x72
000058  61793c54          DCB      0x61,0x79,0x3c,0x54
00005c  7970653e          DCB      0x79,0x70,0x65,0x3e
000060  20262c20          DCB      0x20,0x26,0x2c,0x20
000064  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000068  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00006c  62656464          DCB      0x62,0x65,0x64,0x64
000070  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000074  41727261          DCB      0x41,0x72,0x72,0x61
000078  793c4f75          DCB      0x79,0x3c,0x4f,0x75
00007c  74547970          DCB      0x74,0x54,0x79,0x70
000080  653e2026          DCB      0x65,0x3e,0x20,0x26
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  496e5479          DCB      0x49,0x6e,0x54,0x79
000090  7065203d          DCB      0x70,0x65,0x20,0x3d
000094  20756e73          DCB      0x20,0x75,0x6e,0x73
000098  69676e65          DCB      0x69,0x67,0x6e,0x65
00009c  64206368          DCB      0x64,0x20,0x63,0x68
0000a0  61722c20          DCB      0x61,0x72,0x2c,0x20
0000a4  496e7465          DCB      0x49,0x6e,0x74,0x65
0000a8  726d6564          DCB      0x72,0x6d,0x65,0x64
0000ac  69617465          DCB      0x69,0x61,0x74,0x65
0000b0  54797065          DCB      0x54,0x79,0x70,0x65
0000b4  203d2066          DCB      0x20,0x3d,0x20,0x66
0000b8  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
0000bc  2c204f75          DCB      0x2c,0x20,0x4f,0x75
0000c0  74547970          DCB      0x74,0x54,0x79,0x70
0000c4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000c8  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000cc  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded18Interp2_ProjectiveIhhEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_E19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded18Interp2_ProjectiveIhhEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_E19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded18Interp2_ProjectiveIhhEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_E19__PRETTY_FUNCTION__ ; Anki::Embedded::Interp2_Projective<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Meshgrid<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::Array<T2>&, Anki::Embedded::InterpolationType, T2)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a496e74          DCB      0x3a,0x49,0x6e,0x74
000020  65727032          DCB      0x65,0x72,0x70,0x32
000024  5f50726f          DCB      0x5f,0x50,0x72,0x6f
000028  6a656374          DCB      0x6a,0x65,0x63,0x74
00002c  69766528          DCB      0x69,0x76,0x65,0x28
000030  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000034  7420416e          DCB      0x74,0x20,0x41,0x6e
000038  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00003c  456d6265          DCB      0x45,0x6d,0x62,0x65
000040  64646564          DCB      0x64,0x64,0x65,0x64
000044  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000048  7261793c          DCB      0x72,0x61,0x79,0x3c
00004c  54797065          DCB      0x54,0x79,0x70,0x65
000050  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000054  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000058  73742041          DCB      0x73,0x74,0x20,0x41
00005c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000060  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000064  65646465          DCB      0x65,0x64,0x64,0x65
000068  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00006c  65736867          DCB      0x65,0x73,0x68,0x67
000070  7269643c          DCB      0x72,0x69,0x64,0x3c
000074  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000078  743e2026          DCB      0x74,0x3e,0x20,0x26
00007c  2c20636f          DCB      0x2c,0x20,0x63,0x6f
000080  6e737420          DCB      0x6e,0x73,0x74,0x20
000084  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000088  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00008c  62656464          DCB      0x62,0x65,0x64,0x64
000090  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000094  41727261          DCB      0x41,0x72,0x72,0x61
000098  793c666c          DCB      0x79,0x3c,0x66,0x6c
00009c  6f61743e          DCB      0x6f,0x61,0x74,0x3e
0000a0  20262c20          DCB      0x20,0x26,0x2c,0x20
0000a4  636f6e73          DCB      0x63,0x6f,0x6e,0x73
0000a8  7420416e          DCB      0x74,0x20,0x41,0x6e
0000ac  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0000b0  456d6265          DCB      0x45,0x6d,0x62,0x65
0000b4  64646564          DCB      0x64,0x64,0x65,0x64
0000b8  3a3a506f          DCB      0x3a,0x3a,0x50,0x6f
0000bc  696e743c          DCB      0x69,0x6e,0x74,0x3c
0000c0  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000c4  743e2026          DCB      0x74,0x3e,0x20,0x26
0000c8  2c20416e          DCB      0x2c,0x20,0x41,0x6e
0000cc  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0000d0  456d6265          DCB      0x45,0x6d,0x62,0x65
0000d4  64646564          DCB      0x64,0x64,0x65,0x64
0000d8  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
0000dc  7261793c          DCB      0x72,0x61,0x79,0x3c
0000e0  4f757454          DCB      0x4f,0x75,0x74,0x54
0000e4  7970653e          DCB      0x79,0x70,0x65,0x3e
0000e8  20262c20          DCB      0x20,0x26,0x2c,0x20
0000ec  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000f0  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000f4  62656464          DCB      0x62,0x65,0x64,0x64
0000f8  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000fc  496e7465          DCB      0x49,0x6e,0x74,0x65
000100  72706f6c          DCB      0x72,0x70,0x6f,0x6c
000104  6174696f          DCB      0x61,0x74,0x69,0x6f
000108  6e547970          DCB      0x6e,0x54,0x79,0x70
00010c  652c204f          DCB      0x65,0x2c,0x20,0x4f
000110  75745479          DCB      0x75,0x74,0x54,0x79
000114  70652920          DCB      0x70,0x65,0x29,0x20
000118  5b776974          DCB      0x5b,0x77,0x69,0x74
00011c  6820496e          DCB      0x68,0x20,0x49,0x6e
000120  54797065          DCB      0x54,0x79,0x70,0x65
000124  203d2075          DCB      0x20,0x3d,0x20,0x75
000128  6e736967          DCB      0x6e,0x73,0x69,0x67
00012c  6e656420          DCB      0x6e,0x65,0x64,0x20
000130  63686172          DCB      0x63,0x68,0x61,0x72
000134  2c204f75          DCB      0x2c,0x20,0x4f,0x75
000138  74547970          DCB      0x74,0x54,0x79,0x70
00013c  65203d20          DCB      0x65,0x20,0x3d,0x20
000140  756e7369          DCB      0x75,0x6e,0x73,0x69
000144  676e6564          DCB      0x67,0x6e,0x65,0x64
000148  20636861          DCB      0x20,0x63,0x68,0x61
00014c  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded18Interp2_ProjectiveIhfEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_E19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded18Interp2_ProjectiveIhfEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_E19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded18Interp2_ProjectiveIhfEENS_6ResultERKNS0_5ArrayIT_EERKNS0_8MeshgridIfEERKNS3_IfEERKNS0_5PointIfEERNS3_IT0_EENS0_17InterpolationTypeESJ_E19__PRETTY_FUNCTION__ ; Anki::Embedded::Interp2_Projective<unsigned char, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Meshgrid<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::Array<T2>&, Anki::Embedded::InterpolationType, T2)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a496e74          DCB      0x3a,0x49,0x6e,0x74
000020  65727032          DCB      0x65,0x72,0x70,0x32
000024  5f50726f          DCB      0x5f,0x50,0x72,0x6f
000028  6a656374          DCB      0x6a,0x65,0x63,0x74
00002c  69766528          DCB      0x69,0x76,0x65,0x28
000030  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000034  7420416e          DCB      0x74,0x20,0x41,0x6e
000038  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00003c  456d6265          DCB      0x45,0x6d,0x62,0x65
000040  64646564          DCB      0x64,0x64,0x65,0x64
000044  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000048  7261793c          DCB      0x72,0x61,0x79,0x3c
00004c  54797065          DCB      0x54,0x79,0x70,0x65
000050  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000054  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000058  73742041          DCB      0x73,0x74,0x20,0x41
00005c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000060  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000064  65646465          DCB      0x65,0x64,0x64,0x65
000068  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00006c  65736867          DCB      0x65,0x73,0x68,0x67
000070  7269643c          DCB      0x72,0x69,0x64,0x3c
000074  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000078  743e2026          DCB      0x74,0x3e,0x20,0x26
00007c  2c20636f          DCB      0x2c,0x20,0x63,0x6f
000080  6e737420          DCB      0x6e,0x73,0x74,0x20
000084  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000088  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00008c  62656464          DCB      0x62,0x65,0x64,0x64
000090  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000094  41727261          DCB      0x41,0x72,0x72,0x61
000098  793c666c          DCB      0x79,0x3c,0x66,0x6c
00009c  6f61743e          DCB      0x6f,0x61,0x74,0x3e
0000a0  20262c20          DCB      0x20,0x26,0x2c,0x20
0000a4  636f6e73          DCB      0x63,0x6f,0x6e,0x73
0000a8  7420416e          DCB      0x74,0x20,0x41,0x6e
0000ac  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0000b0  456d6265          DCB      0x45,0x6d,0x62,0x65
0000b4  64646564          DCB      0x64,0x64,0x65,0x64
0000b8  3a3a506f          DCB      0x3a,0x3a,0x50,0x6f
0000bc  696e743c          DCB      0x69,0x6e,0x74,0x3c
0000c0  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000c4  743e2026          DCB      0x74,0x3e,0x20,0x26
0000c8  2c20416e          DCB      0x2c,0x20,0x41,0x6e
0000cc  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0000d0  456d6265          DCB      0x45,0x6d,0x62,0x65
0000d4  64646564          DCB      0x64,0x64,0x65,0x64
0000d8  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
0000dc  7261793c          DCB      0x72,0x61,0x79,0x3c
0000e0  4f757454          DCB      0x4f,0x75,0x74,0x54
0000e4  7970653e          DCB      0x79,0x70,0x65,0x3e
0000e8  20262c20          DCB      0x20,0x26,0x2c,0x20
0000ec  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000f0  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000f4  62656464          DCB      0x62,0x65,0x64,0x64
0000f8  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000fc  496e7465          DCB      0x49,0x6e,0x74,0x65
000100  72706f6c          DCB      0x72,0x70,0x6f,0x6c
000104  6174696f          DCB      0x61,0x74,0x69,0x6f
000108  6e547970          DCB      0x6e,0x54,0x79,0x70
00010c  652c204f          DCB      0x65,0x2c,0x20,0x4f
000110  75745479          DCB      0x75,0x74,0x54,0x79
000114  70652920          DCB      0x70,0x65,0x29,0x20
000118  5b776974          DCB      0x5b,0x77,0x69,0x74
00011c  6820496e          DCB      0x68,0x20,0x49,0x6e
000120  54797065          DCB      0x54,0x79,0x70,0x65
000124  203d2075          DCB      0x20,0x3d,0x20,0x75
000128  6e736967          DCB      0x6e,0x73,0x69,0x67
00012c  6e656420          DCB      0x6e,0x65,0x64,0x20
000130  63686172          DCB      0x63,0x68,0x61,0x72
000134  2c204f75          DCB      0x2c,0x20,0x4f,0x75
000138  74547970          DCB      0x74,0x54,0x79,0x70
00013c  65203d20          DCB      0x65,0x20,0x3d,0x20
000140  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000144  745d00            DCB      0x74,0x5d,0x00

;*** Start embedded assembler ***

#line 1 "..\\coretech\\vision\\robot\\src\\lucasKanade_SampledPlanar6dof.cpp"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___33_lucasKanade_SampledPlanar6dof_cpp_957a344d___Z7__REV16j|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___33_lucasKanade_SampledPlanar6dof_cpp_957a344d___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___33_lucasKanade_SampledPlanar6dof_cpp_957a344d___Z7__REVSHi|
#line 144
|__asm___33_lucasKanade_SampledPlanar6dof_cpp_957a344d___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
