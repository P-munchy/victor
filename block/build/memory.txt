; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\memory.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\memory.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\memory.crf ..\coretech\common\robot\src\memory.cpp]
                          THUMB

                          AREA ||i._ZN4Anki8Embedded11MemoryStack10ReallocateEPvi||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded11MemoryStack10ReallocateEPvi PROC ; Anki::Embedded::MemoryStack::Reallocate(void*, int)
;;;116    
;;;117        void* MemoryStack::Reallocate(void* memoryLocation, s32 numBytesRequested)
000000  b508              PUSH     {r3,lr}
;;;118        {
;;;119          s32 numBytesAllocated = -1;
000002  f04f33ff          MOV      r3,#0xffffffff
;;;120          return MemoryStack::Reallocate(memoryLocation, numBytesRequested, numBytesAllocated);
000006  9300              STR      r3,[sp,#0]
000008  466b              MOV      r3,sp
00000a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack10ReallocateEPviRi ; Anki::Embedded::MemoryStack::Reallocate(void*, int, int&)
;;;121        }
00000e  bd08              POP      {r3,pc}
;;;122    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded11MemoryStack10ReallocateEPviRi||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded11MemoryStack10ReallocateEPviRi PROC ; Anki::Embedded::MemoryStack::Reallocate(void*, int, int&)
;;;122    
;;;123        void* MemoryStack::Reallocate(void* memoryLocation, s32 numBytesRequested, s32 &numBytesAllocated)
000000  b5f0              PUSH     {r4-r7,lr}
;;;124        {
000002  4604              MOV      r4,r0
000004  b083              SUB      sp,sp,#0xc
;;;125          numBytesAllocated = 0;
000006  2000              MOVS     r0,#0
;;;126    
;;;127          AnkiConditionalErrorAndReturnValue(memoryLocation == lastAllocatedMemory, NULL, "Anki.MemoryStack.Reallocate", "The requested memory is not at the end of the stack");
000008  6018              STR      r0,[r3,#0]
00000a  6920              LDR      r0,[r4,#0x10]
00000c  461d              MOV      r5,r3                 ;124
00000e  4616              MOV      r6,r2                 ;124
000010  4288              CMP      r0,r1
000012  d00c              BEQ      |L2.46|
000014  217f              MOVS     r1,#0x7f
000016  4816              LDR      r0,|L2.112|
000018  e9cd0100          STRD     r0,r1,[sp,#0]
00001c  a315              ADR      r3,|L2.116|
00001e  a21f              ADR      r2,|L2.156|
000020  a12b              ADR      r1,|L2.208|
000022  2005              MOVS     r0,#5
000024  f7fffffe          BL       _Anki_Log
;;;128    
;;;129          // Don't clear the reallocated memory
;;;130          const bool clearMemory = this->flags.get_zeroAllocatedMemory();
;;;131          this->flags.set_zeroAllocatedMemory(false);
;;;132    
;;;133          this->usedBytes = usedBytesBeforeLastAllocation;
;;;134    
;;;135          void *segmentMemory = Allocate(numBytesRequested, numBytesAllocated);
;;;136    
;;;137          this->flags.set_zeroAllocatedMemory(clearMemory);
;;;138    
;;;139          return segmentMemory;
;;;140        }
000028  b003              ADD      sp,sp,#0xc
00002a  2000              MOVS     r0,#0                 ;127
00002c  bdf0              POP      {r4-r7,pc}
                  |L2.46|
00002e  f1040018          ADD      r0,r4,#0x18           ;130
000032  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
000036  4607              MOV      r7,r0                 ;130
000038  2100              MOVS     r1,#0                 ;131
00003a  f1040018          ADD      r0,r4,#0x18           ;131
00003e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6Buffer23set_zeroAllocatedMemoryEb ; Anki::Embedded::Flags::Buffer::set_zeroAllocatedMemory(bool)
000042  68e0              LDR      r0,[r4,#0xc]          ;133
000044  60a0              STR      r0,[r4,#8]            ;133
000046  69a0              LDR      r0,[r4,#0x18]         ;133
000048  9000              STR      r0,[sp,#0]            ;133
00004a  4668              MOV      r0,sp                 ;133
00004c  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
000050  4602              MOV      r2,r0                 ;133
000052  462b              MOV      r3,r5                 ;133
000054  4631              MOV      r1,r6                 ;133
000056  4620              MOV      r0,r4                 ;133
000058  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
00005c  4605              MOV      r5,r0                 ;135
00005e  4639              MOV      r1,r7                 ;137
000060  f1040018          ADD      r0,r4,#0x18           ;137
000064  f7fffffe          BL       _ZN4Anki8Embedded5Flags6Buffer23set_zeroAllocatedMemoryEb ; Anki::Embedded::Flags::Buffer::set_zeroAllocatedMemory(bool)
000068  b003              ADD      sp,sp,#0xc
00006a  4628              MOV      r0,r5                 ;139
00006c  bdf0              POP      {r4-r7,pc}
;;;141    
                          ENDP

00006e  0000              DCW      0x0000
                  |L2.112|
                          DCD      ||.constdata||+0xa8
                  |L2.116|
000074  2e2e5c63          DCB      "..\\coretech\\common\\robot\\src\\memory.cpp",0
000078  6f726574
00007c  6563685c
000080  636f6d6d
000084  6f6e5c72
000088  6f626f74
00008c  5c737263
000090  5c6d656d
000094  6f72792e
000098  63707000
                  |L2.156|
00009c  54686520          DCB      "The requested memory is not at the end of the stack",0
0000a0  72657175
0000a4  65737465
0000a8  64206d65
0000ac  6d6f7279
0000b0  20697320
0000b4  6e6f7420
0000b8  61742074
0000bc  68652065
0000c0  6e64206f
0000c4  66207468
0000c8  65207374
0000cc  61636b00
                  |L2.208|
0000d0  416e6b69          DCB      "Anki.MemoryStack.Reallocate",0
0000d4  2e4d656d
0000d8  6f727953
0000dc  7461636b
0000e0  2e526561
0000e4  6c6c6f63
0000e8  61746500

                          AREA ||i._ZN4Anki8Embedded11MemoryStack10get_bufferEv||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded11MemoryStack10get_bufferEv PROC ; Anki::Embedded::MemoryStack::get_buffer()
;;;226    
;;;227        void* MemoryStack::get_buffer()
000000  6800              LDR      r0,[r0,#0]
;;;228        {
;;;229          return buffer;
;;;230        }
000002  4770              BX       lr
;;;231    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded11MemoryStack20get_validBufferStartERi||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded11MemoryStack20get_validBufferStartERi PROC ; Anki::Embedded::MemoryStack::get_validBufferStart(int&)
;;;248    
;;;249        void* MemoryStack::get_validBufferStart(s32 &firstValidIndex)
000000  6802              LDR      r2,[r0,#0]
;;;250        {
;;;251          const size_t bufferSizeT = reinterpret_cast<size_t>(this->buffer);
;;;252          firstValidIndex = static_cast<s32>( RoundUp<size_t>(bufferSizeT+MemoryStack::HEADER_LENGTH, MEMORY_ALIGNMENT) - MemoryStack::HEADER_LENGTH - bufferSizeT );
000002  f1020317          ADD      r3,r2,#0x17
000006  f023030f          BIC      r3,r3,#0xf
00000a  1a9a              SUBS     r2,r3,r2
00000c  3a08              SUBS     r2,r2,#8
;;;253    
;;;254          void * validStart = reinterpret_cast<char*>(this->buffer) + firstValidIndex;
00000e  600a              STR      r2,[r1,#0]
000010  6800              LDR      r0,[r0,#0]
000012  4410              ADD      r0,r0,r2
;;;255    
;;;256          return validStart;
;;;257        }
000014  4770              BX       lr
;;;258    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded11MemoryStack20get_validBufferStartEv||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded11MemoryStack20get_validBufferStartEv PROC ; Anki::Embedded::MemoryStack::get_validBufferStart()
;;;236    
;;;237        void* MemoryStack::get_validBufferStart()
000000  6800              LDR      r0,[r0,#0]
;;;238        {
000002  b081              SUB      sp,sp,#4
000004  f1000117          ADD      r1,r0,#0x17
000008  f021010f          BIC      r1,r1,#0xf
00000c  1a09              SUBS     r1,r1,r0
00000e  3908              SUBS     r1,r1,#8
000010  9100              STR      r1,[sp,#0]
000012  4408              ADD      r0,r0,r1
;;;239          s32 firstValidIndex;
;;;240          return this->get_validBufferStart(firstValidIndex);
;;;241        }
000014  b001              ADD      sp,sp,#4
000016  4770              BX       lr
;;;242    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded11MemoryStack8AllocateEi||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded11MemoryStack8AllocateEi PROC ; Anki::Embedded::MemoryStack::Allocate(int)
;;;57     
;;;58         void* MemoryStack::Allocate(const s32 numBytesRequested)
000000  b570              PUSH     {r4-r6,lr}
;;;59         {
000002  b082              SUB      sp,sp,#8
;;;60           s32 numBytesAllocated = -1;
000004  f04f32ff          MOV      r2,#0xffffffff
000008  4604              MOV      r4,r0                 ;59
00000a  9200              STR      r2,[sp,#0]            ;59
00000c  6980              LDR      r0,[r0,#0x18]         ;59
00000e  9001              STR      r0,[sp,#4]            ;59
;;;61           return this->Allocate(numBytesRequested, numBytesAllocated);
000010  460d              MOV      r5,r1
000012  466e              MOV      r6,sp
000014  a801              ADD      r0,sp,#4
000016  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00001a  4602              MOV      r2,r0
00001c  4633              MOV      r3,r6
00001e  4629              MOV      r1,r5
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
;;;62         }
000026  b002              ADD      sp,sp,#8
000028  bd70              POP      {r4-r6,pc}
;;;63     
                          ENDP


                          AREA ||i._ZN4Anki8Embedded11MemoryStack8AllocateEiRi||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded11MemoryStack8AllocateEiRi PROC ; Anki::Embedded::MemoryStack::Allocate(int, int&)
;;;63     
;;;64         void* MemoryStack::Allocate(s32 numBytesRequested, s32 &numBytesAllocated)
000000  b5f8              PUSH     {r3-r7,lr}
;;;65         {
000002  4604              MOV      r4,r0
000004  6980              LDR      r0,[r0,#0x18]
;;;66           return this->Allocate(numBytesRequested, this->get_flags().get_zeroAllocatedMemory(), numBytesAllocated);
000006  9000              STR      r0,[sp,#0]
000008  4615              MOV      r5,r2                 ;65
00000a  460e              MOV      r6,r1                 ;65
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
000012  4602              MOV      r2,r0
000014  462b              MOV      r3,r5
000016  4631              MOV      r1,r6
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
;;;67         }
00001e  bdf8              POP      {r3-r7,pc}
;;;68     
                          ENDP


                          AREA ||i._ZN4Anki8Embedded11MemoryStack8AllocateEibRi||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded11MemoryStack8AllocateEibRi PROC ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
;;;68     
;;;69         void* MemoryStack::Allocate(const s32 numBytesRequested, const bool zeroAllocatedMemory, s32 &numBytesAllocated)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;70         {
000004  b083              SUB      sp,sp,#0xc
;;;71           numBytesAllocated = 0;
000006  f04f0c00          MOV      r12,#0
;;;72     
;;;73           AnkiConditionalErrorAndReturnValue(numBytesRequested > 0, NULL, "Anki.MemoryStack.Allocate", "numBytesRequested > 0");
00000a  f8df80e0          LDR      r8,|L8.236|
00000e  f8c3c000          STR      r12,[r3,#0]
000012  2900              CMP      r1,#0
000014  dc0c              BGT      |L8.48|
000016  2049              MOVS     r0,#0x49
000018  e9cd8000          STRD     r8,r0,[sp,#0]
00001c  a334              ADR      r3,|L8.240|
00001e  a23e              ADR      r2,|L8.280|
000020  a143              ADR      r1,|L8.304|
000022  2005              MOVS     r0,#5
000024  f7fffffe          BL       _Anki_Log
;;;74           AnkiConditionalErrorAndReturnValue(numBytesRequested <= 0x3FFFFFFF, NULL, "Anki.MemoryStack.Allocate", "numBytesRequested <= 0x3FFFFFFF");
;;;75     
;;;76           char * const bufferNextFree = static_cast<char*>(buffer) + usedBytes;
;;;77     
;;;78           // Get the pointer locations for header, data, and footer
;;;79           // The header doesn't have to be aligned, but it should be right before the start of the segmentMemory
;;;80           // The footer is aligned for free, because the allocated memory starts aligned, and has an aligned stride
;;;81           char * const segmentMemory = reinterpret_cast<char*>( RoundUp<size_t>(reinterpret_cast<size_t>(bufferNextFree)+HEADER_LENGTH, MEMORY_ALIGNMENT) );
;;;82           u32  * const segmentHeader = reinterpret_cast<u32*> ( reinterpret_cast<size_t>(segmentMemory) - HEADER_LENGTH );
;;;83           const u32 numBytesRequestedRounded = RoundUp<u32>(numBytesRequested, MEMORY_ALIGNMENT);
;;;84           u32  * const segmentFooter = reinterpret_cast<u32*> (segmentMemory+numBytesRequestedRounded);
;;;85     
;;;86           const s32 requestedBytes = static_cast<s32>( reinterpret_cast<size_t>(segmentFooter) + FOOTER_LENGTH - reinterpret_cast<size_t>(bufferNextFree) );
;;;87     
;;;88           AnkiConditionalErrorAndReturnValue((usedBytes+requestedBytes) <= totalBytes, NULL, "Anki.MemoryStack.Allocate", "Ran out of scratch space");
;;;89     
;;;90           // Is this possible?
;;;91           AnkiConditionalErrorAndReturnValue(static_cast<u32>(reinterpret_cast<size_t>(segmentFooter) - reinterpret_cast<size_t>(segmentMemory)) == numBytesRequestedRounded,
;;;92             NULL, "Anki.MemoryStack.Allocate", "Odd error");
;;;93     
;;;94           // Next, add the header for this block
;;;95           segmentHeader[0] = numBytesRequestedRounded;
;;;96           segmentHeader[1] = FILL_PATTERN_START;
;;;97           segmentFooter[0] = FILL_PATTERN_END;
;;;98     
;;;99           // For Reallocate()
;;;100          usedBytesBeforeLastAllocation = usedBytes;
;;;101          lastAllocatedMemory = segmentMemory;
;;;102    
;;;103          usedBytes += requestedBytes;
;;;104    
;;;105          numBytesAllocated = numBytesRequestedRounded;
;;;106    
;;;107          if(zeroAllocatedMemory)
;;;108            memset(segmentMemory, 0, numBytesRequestedRounded);
;;;109    
;;;110    #ifdef DISPLAY_USED_BYTES
;;;111          CoreTechPrint("%d) Used %d bytes\n", id, usedBytes);
;;;112    #endif
;;;113    
;;;114          return segmentMemory;
;;;115        }
000028  b003              ADD      sp,sp,#0xc
00002a  2000              MOVS     r0,#0                 ;73
00002c  e8bd83f0          POP      {r4-r9,pc}
                  |L8.48|
000030  f1b14f80          CMP      r1,#0x40000000        ;74
000034  db0c              BLT      |L8.80|
000036  204a              MOVS     r0,#0x4a              ;74
000038  e9cd8000          STRD     r8,r0,[sp,#0]         ;74
00003c  a32c              ADR      r3,|L8.240|
00003e  a243              ADR      r2,|L8.332|
000040  a13b              ADR      r1,|L8.304|
000042  2005              MOVS     r0,#5                 ;74
000044  f7fffffe          BL       _Anki_Log
000048  b003              ADD      sp,sp,#0xc
00004a  2000              MOVS     r0,#0                 ;74
00004c  e8bd83f0          POP      {r4-r9,pc}
                  |L8.80|
000050  f8d0c000          LDR      r12,[r0,#0]           ;76
000054  6887              LDR      r7,[r0,#8]            ;76
000056  310f              ADDS     r1,r1,#0xf            ;82
000058  eb0c0607          ADD      r6,r12,r7             ;76
00005c  f1060c17          ADD      r12,r6,#0x17          ;81
000060  f02c040f          BIC      r4,r12,#0xf           ;81
000064  f021010f          BIC      r1,r1,#0xf            ;81
000068  eb040c01          ADD      r12,r4,r1             ;84
00006c  ebac0606          SUB      r6,r12,r6             ;86
000070  1d36              ADDS     r6,r6,#4              ;86
000072  f8d09004          LDR      r9,[r0,#4]            ;88
000076  4437              ADD      r7,r7,r6              ;88
000078  f1a40508          SUB      r5,r4,#8              ;82
00007c  45b9              CMP      r9,r7                 ;88
00007e  da0c              BGE      |L8.154|
000080  2058              MOVS     r0,#0x58              ;88
000082  e9cd8000          STRD     r8,r0,[sp,#0]         ;88
000086  a31a              ADR      r3,|L8.240|
000088  a238              ADR      r2,|L8.364|
00008a  a129              ADR      r1,|L8.304|
00008c  2005              MOVS     r0,#5                 ;88
00008e  f7fffffe          BL       _Anki_Log
000092  b003              ADD      sp,sp,#0xc
000094  2000              MOVS     r0,#0                 ;88
000096  e8bd83f0          POP      {r4-r9,pc}
                  |L8.154|
00009a  ebac0704          SUB      r7,r12,r4             ;91
00009e  428f              CMP      r7,r1                 ;91
0000a0  d00c              BEQ      |L8.188|
0000a2  205b              MOVS     r0,#0x5b              ;91
0000a4  e9cd8000          STRD     r8,r0,[sp,#0]         ;91
0000a8  a311              ADR      r3,|L8.240|
0000aa  a237              ADR      r2,|L8.392|
0000ac  a120              ADR      r1,|L8.304|
0000ae  2005              MOVS     r0,#5                 ;91
0000b0  f7fffffe          BL       _Anki_Log
0000b4  b003              ADD      sp,sp,#0xc
0000b6  2000              MOVS     r0,#0                 ;91
0000b8  e8bd83f0          POP      {r4-r9,pc}
                  |L8.188|
0000bc  4f35              LDR      r7,|L8.404|
0000be  2a00              CMP      r2,#0                 ;107
0000c0  e9c51700          STRD     r1,r7,[r5,#0]         ;96
0000c4  4d34              LDR      r5,|L8.408|
0000c6  f8cc5000          STR      r5,[r12,#0]           ;100
0000ca  f8d0c008          LDR      r12,[r0,#8]           ;100
0000ce  e9c0c403          STRD     r12,r4,[r0,#0xc]      ;100
0000d2  44b4              ADD      r12,r12,r6            ;103
0000d4  f8c0c008          STR      r12,[r0,#8]           ;105
0000d8  6019              STR      r1,[r3,#0]            ;107
0000da  bf1c              ITT      NE                    ;108
0000dc  4620              MOVNE    r0,r4                 ;108
0000de  f7fffffe          BLNE     __aeabi_memclr
0000e2  4620              MOV      r0,r4                 ;114
0000e4  b003              ADD      sp,sp,#0xc
0000e6  e8bd83f0          POP      {r4-r9,pc}
;;;116    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L8.236|
                          DCD      ||.constdata||+0x5c
                  |L8.240|
0000f0  2e2e5c63          DCB      "..\\coretech\\common\\robot\\src\\memory.cpp",0
0000f4  6f726574
0000f8  6563685c
0000fc  636f6d6d
000100  6f6e5c72
000104  6f626f74
000108  5c737263
00010c  5c6d656d
000110  6f72792e
000114  63707000
                  |L8.280|
000118  6e756d42          DCB      "numBytesRequested > 0",0
00011c  79746573
000120  52657175
000124  65737465
000128  64203e20
00012c  3000    
00012e  00                DCB      0
00012f  00                DCB      0
                  |L8.304|
000130  416e6b69          DCB      "Anki.MemoryStack.Allocate",0
000134  2e4d656d
000138  6f727953
00013c  7461636b
000140  2e416c6c
000144  6f636174
000148  6500    
00014a  00                DCB      0
00014b  00                DCB      0
                  |L8.332|
00014c  6e756d42          DCB      "numBytesRequested <= 0x3FFFFFFF",0
000150  79746573
000154  52657175
000158  65737465
00015c  64203c3d
000160  20307833
000164  46464646
000168  46464600
                  |L8.364|
00016c  52616e20          DCB      "Ran out of scratch space",0
000170  6f757420
000174  6f662073
000178  63726174
00017c  63682073
000180  70616365
000184  00      
000185  00                DCB      0
000186  00                DCB      0
000187  00                DCB      0
                  |L8.392|
000188  4f646420          DCB      "Odd error",0
00018c  6572726f
000190  7200    
000192  00                DCB      0
000193  00                DCB      0
                  |L8.404|
                          DCD      0xff01fe02
                  |L8.408|
                          DCD      0x03ff04fe

                          AREA ||i._ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded11MemoryStackC2EPviNS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::MemoryStack::MemoryStack__sub_object(void*, int, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE PROC ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
;;;26     
;;;27         MemoryStack::MemoryStack(void *buffer, s32 bufferLength, Flags::Buffer flags)
;;;28           : buffer(buffer), totalBytes(bufferLength), usedBytes(0), usedBytesBeforeLastAllocation(0), lastAllocatedMemory(NULL), flags(flags)
;;;29         {
;;;30           AnkiAssert(flags.get_useBoundaryFillPatterns());
;;;31     
;;;32           if(flags.get_isFullyAllocated()) {
;;;33             AnkiConditionalErrorAndReturn((reinterpret_cast<size_t>(buffer)+MemoryStack::HEADER_LENGTH)%MEMORY_ALIGNMENT == 0,
;;;34               "MemoryStack::MemoryStack", "If fully allocated, the %dth byte of the buffer must be %d byte aligned", MemoryStack::HEADER_LENGTH, MEMORY_ALIGNMENT);
;;;35     
;;;36             this->usedBytes = this->totalBytes;
;;;37           }
;;;38     
;;;39           static s32 maxId = 0;
;;;40     
;;;41           this->id = maxId;
;;;42           maxId++;
;;;43     
;;;44           AnkiConditionalError(buffer, "Anki.MemoryStack.MemoryStack", "Buffer must be allocated");
;;;45           AnkiConditionalError(bufferLength <= 0x3FFFFFFF, "Anki.MemoryStack.MemoryStack", "Maximum size of a MemoryStack is 2^30 - 1");
;;;46           AnkiConditionalError(MEMORY_ALIGNMENT == 16, "Anki.MemoryStack.MemoryStack", "Currently, only MEMORY_ALIGNMENT == 16 is supported");
;;;47         }
;;;48     
000000  b5ff              PUSH     {r0-r7,lr}
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  6001              STR      r1,[r0,#0]
000008  2000              MOVS     r0,#0
00000a  e9c42001          STRD     r2,r0,[r4,#4]
00000e  60e0              STR      r0,[r4,#0xc]
000010  6120              STR      r0,[r4,#0x10]
000012  9808              LDR      r0,[sp,#0x20]
000014  61a0              STR      r0,[r4,#0x18]
000016  4616              MOV      r6,r2
000018  460d              MOV      r5,r1
00001a  a808              ADD      r0,sp,#0x20
00001c  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
000020  4f1c              LDR      r7,|L9.148|
000022  2800              CMP      r0,#0
000024  d017              BEQ      |L9.86|
000026  f1050008          ADD      r0,r5,#8
00002a  f0100f0f          TST      r0,#0xf
00002e  bf04              ITT      EQ
000030  6860              LDREQ    r0,[r4,#4]
000032  60a0              STREQ    r0,[r4,#8]
000034  d00f              BEQ      |L9.86|
000036  2010              MOVS     r0,#0x10
000038  9003              STR      r0,[sp,#0xc]
00003a  2108              MOVS     r1,#8
00003c  2221              MOVS     r2,#0x21
00003e  9700              STR      r7,[sp,#0]
000040  e9cd2101          STRD     r2,r1,[sp,#4]
000044  a314              ADR      r3,|L9.152|
000046  4a1e              LDR      r2,|L9.192|
000048  a11e              ADR      r1,|L9.196|
00004a  2005              MOVS     r0,#5
00004c  f7fffffe          BL       _Anki_Log
000050  b009              ADD      sp,sp,#0x24
000052  4620              MOV      r0,r4
000054  bdf0              POP      {r4-r7,pc}
                  |L9.86|
000056  4922              LDR      r1,|L9.224|
000058  6808              LDR      r0,[r1,#0]  ; maxId
00005a  6160              STR      r0,[r4,#0x14]
00005c  1c40              ADDS     r0,r0,#1
00005e  6008              STR      r0,[r1,#0]  ; maxId
000060  b945              CBNZ     r5,|L9.116|
000062  202c              MOVS     r0,#0x2c
000064  e9cd7000          STRD     r7,r0,[sp,#0]
000068  a30b              ADR      r3,|L9.152|
00006a  a21e              ADR      r2,|L9.228|
00006c  a124              ADR      r1,|L9.256|
00006e  2005              MOVS     r0,#5
000070  f7fffffe          BL       _Anki_Log
                  |L9.116|
000074  f1b64f80          CMP      r6,#0x40000000
000078  db08              BLT      |L9.140|
00007a  202d              MOVS     r0,#0x2d
00007c  e9cd7000          STRD     r7,r0,[sp,#0]
000080  a305              ADR      r3,|L9.152|
000082  a227              ADR      r2,|L9.288|
000084  a11e              ADR      r1,|L9.256|
000086  2005              MOVS     r0,#5
000088  f7fffffe          BL       _Anki_Log
                  |L9.140|
00008c  b009              ADD      sp,sp,#0x24
00008e  4620              MOV      r0,r4
000090  bdf0              POP      {r4-r7,pc}
                          ENDP

000092  0000              DCW      0x0000
                  |L9.148|
                          DCD      ||.constdata||
                  |L9.152|
000098  2e2e5c63          DCB      "..\\coretech\\common\\robot\\src\\memory.cpp",0
00009c  6f726574
0000a0  6563685c
0000a4  636f6d6d
0000a8  6f6e5c72
0000ac  6f626f74
0000b0  5c737263
0000b4  5c6d656d
0000b8  6f72792e
0000bc  63707000
                  |L9.192|
                          DCD      ||.conststring||
                  |L9.196|
0000c4  4d656d6f          DCB      "MemoryStack::MemoryStack",0
0000c8  72795374
0000cc  61636b3a
0000d0  3a4d656d
0000d4  6f727953
0000d8  7461636b
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L9.224|
                          DCD      ||.data||
                  |L9.228|
0000e4  42756666          DCB      "Buffer must be allocated",0
0000e8  6572206d
0000ec  75737420
0000f0  62652061
0000f4  6c6c6f63
0000f8  61746564
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L9.256|
000100  416e6b69          DCB      "Anki.MemoryStack.MemoryStack",0
000104  2e4d656d
000108  6f727953
00010c  7461636b
000110  2e4d656d
000114  6f727953
000118  7461636b
00011c  00      
00011d  00                DCB      0
00011e  00                DCB      0
00011f  00                DCB      0
                  |L9.288|
000120  4d617869          DCB      "Maximum size of a MemoryStack is 2^30 - 1",0
000124  6d756d20
000128  73697a65
00012c  206f6620
000130  61204d65
000134  6d6f7279
000138  53746163
00013c  6b206973
000140  20325e33
000144  30202d20
000148  3100    
00014a  00                DCB      0
00014b  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded11MemoryStackC1ERKS1_||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded11MemoryStackC2ERKS1_                  ; Alternate entry point ; Anki::Embedded::MemoryStack::MemoryStack__sub_object(const Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded11MemoryStackC1ERKS1_ PROC ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
;;;48     
;;;49         MemoryStack::MemoryStack(const MemoryStack& ms)
;;;50           : buffer(ms.buffer), totalBytes(ms.totalBytes), usedBytes(ms.usedBytes), usedBytesBeforeLastAllocation(ms.usedBytesBeforeLastAllocation), lastAllocatedMemory(ms.lastAllocatedMemory), id(ms.id), flags(ms.flags)
;;;51         {
;;;52           AnkiConditionalWarn(ms.buffer, "Anki.MemoryStack.MemoryStack", "Buffer must be allocated");
;;;53           AnkiConditionalWarn(ms.totalBytes <= 0x3FFFFFFF, "Anki.MemoryStack.MemoryStack", "Maximum size of a MemoryStack is 2^30 - 1");
;;;54           AnkiConditionalWarn(MEMORY_ALIGNMENT == 16, "Anki.MemoryStack.MemoryStack", "Currently, only MEMORY_ALIGNMENT == 16 is supported");
;;;55           AnkiConditionalWarn(ms.totalBytes >= ms.usedBytes, "Anki.MemoryStack.MemoryStack", "Buffer is using more bytes than it has. Try running IsValid() to test for memory corruption.");
;;;56         }
;;;57     
000000  680a              LDR      r2,[r1,#0]
000002  6002              STR      r2,[r0,#0]
000004  684a              LDR      r2,[r1,#4]
000006  6042              STR      r2,[r0,#4]
000008  688a              LDR      r2,[r1,#8]
00000a  6082              STR      r2,[r0,#8]
00000c  68ca              LDR      r2,[r1,#0xc]
00000e  60c2              STR      r2,[r0,#0xc]
000010  690a              LDR      r2,[r1,#0x10]
000012  6102              STR      r2,[r0,#0x10]
000014  694a              LDR      r2,[r1,#0x14]
000016  6142              STR      r2,[r0,#0x14]
000018  6989              LDR      r1,[r1,#0x18]
00001a  6181              STR      r1,[r0,#0x18]
00001c  4770              BX       lr
                          ENDP


                          AREA ||i._ZN4Anki8Embedded11MemoryStackC1Ev||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded11MemoryStackC2Ev                  ; Alternate entry point ; Anki::Embedded::MemoryStack::MemoryStack__sub_object()
                  _ZN4Anki8Embedded11MemoryStackC1Ev PROC ; Anki::Embedded::MemoryStack::MemoryStack()
;;;21       {
;;;22         MemoryStack::MemoryStack()
;;;23           : buffer(NULL)
;;;24         {
;;;25         }
;;;26     
000000  b510              PUSH     {r4,lr}
000002  2100              MOVS     r1,#0
000004  f8401b18          STR      r1,[r0],#0x18
000008  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00000c  3818              SUBS     r0,r0,#0x18
00000e  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i._ZN4Anki8Embedded19MemoryStackIterator10get_memoryEv||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded19MemoryStackIterator10get_memoryEv PROC ; Anki::Embedded::MemoryStackIterator::get_memory()
;;;360    
;;;361        MemoryStack& MemoryStackIterator::get_memory()
000000  6840              LDR      r0,[r0,#4]
;;;362        {
;;;363          return const_cast<MemoryStack&>(memory);
;;;364        }
000002  4770              BX       lr
;;;365    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded19MemoryStackIterator7GetNextERib||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded19MemoryStackIterator7GetNextERib PROC ; Anki::Embedded::MemoryStackIterator::GetNext(int&, bool)
;;;351    
;;;352        void * MemoryStackIterator::GetNext(s32 &segmentLength, const bool requireFillPatternMatch)
000000  f7ffbffe          B.W      _ZN4Anki8Embedded24MemoryStackConstIterator7GetNextERib ; Anki::Embedded::MemoryStackConstIterator::GetNext(int&, bool)
;;;353        {
;;;354          // To avoid code duplication, we'll use the const version of GetNext(), though our MemoryStack is not const
;;;355    
;;;356          const void * segment = MemoryStackConstIterator::GetNext(segmentLength, requireFillPatternMatch);
;;;357    
;;;358          return const_cast<void*>(segment);
;;;359        }
;;;360    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded19MemoryStackIteratorC1ERNS0_11MemoryStackE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded19MemoryStackIteratorC2ERNS0_11MemoryStackE                  ; Alternate entry point ; Anki::Embedded::MemoryStackIterator::MemoryStackIterator__sub_object(Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded19MemoryStackIteratorC1ERNS0_11MemoryStackE PROC ; Anki::Embedded::MemoryStackIterator::MemoryStackIterator(Anki::Embedded::MemoryStack&)
;;;346    
;;;347        MemoryStackIterator::MemoryStackIterator(MemoryStack &memory)
;;;348          : MemoryStackConstIterator(memory)
;;;349        {
;;;350        }
;;;351    
000000  6041              STR      r1,[r0,#4]
000002  6809              LDR      r1,[r1,#0]
000004  f1010217          ADD      r2,r1,#0x17
000008  f022020f          BIC      r2,r2,#0xf
00000c  1a51              SUBS     r1,r2,r1
00000e  3908              SUBS     r1,r1,#8
000010  6001              STR      r1,[r0,#0]
000012  4770              BX       lr
                          ENDP


                          AREA ||i._ZN4Anki8Embedded24MemoryStackConstIterator7GetNextERib||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded24MemoryStackConstIterator7GetNextERib PROC ; Anki::Embedded::MemoryStackConstIterator::GetNext(int&, bool)
;;;301    
;;;302        const void * MemoryStackConstIterator::GetNext(s32 &segmentLength, const bool requireFillPatternMatch)
000000  b5f0              PUSH     {r4-r7,lr}
;;;303        {
000002  4604              MOV      r4,r0
000004  b087              SUB      sp,sp,#0x1c
;;;304          segmentLength = 0;
000006  2000              MOVS     r0,#0
000008  6008              STR      r0,[r1,#0]
00000a  6860              LDR      r0,[r4,#4]
00000c  4615              MOV      r5,r2                 ;303
00000e  460f              MOV      r7,r1                 ;303
000010  6980              LDR      r0,[r0,#0x18]         ;303
000012  9000              STR      r0,[sp,#0]            ;303
000014  2610              MOVS     r6,#0x10              ;303
000016  4668              MOV      r0,sp                 ;303
000018  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
00001c  2800              CMP      r0,#0                 ;303
00001e  bf18              IT       NE                    ;303
000020  261c              MOVNE    r6,#0x1c              ;303
000022  6860              LDR      r0,[r4,#4]            ;303
000024  6821              LDR      r1,[r4,#0]            ;303
000026  6882              LDR      r2,[r0,#8]            ;303
000028  198b              ADDS     r3,r1,r6              ;303
00002a  429a              CMP      r2,r3                 ;303
00002c  f340806e          BLE.W    |L15.268|
000030  6800              LDR      r0,[r0,#0]            ;303
;;;305    
;;;306          if(!this->HasNext()) {
;;;307            return NULL;
;;;308          }
;;;309    
;;;310          const char * const bufferCharStar = reinterpret_cast<const char*>(memory.get_buffer());
;;;311          const size_t bufferSizeT = reinterpret_cast<size_t>(memory.get_buffer());
;;;312    
;;;313          // Get the start of the next valid segment
;;;314          this->index = static_cast<s32>( RoundUp<size_t>(bufferSizeT+this->index+MemoryStack::HEADER_LENGTH, MEMORY_ALIGNMENT) - MemoryStack::HEADER_LENGTH - bufferSizeT );
000032  f1000208          ADD      r2,r0,#8
000036  4411              ADD      r1,r1,r2
000038  310f              ADDS     r1,r1,#0xf
00003a  f021010f          BIC      r1,r1,#0xf
00003e  1a09              SUBS     r1,r1,r0
000040  3908              SUBS     r1,r1,#8
;;;315    
;;;316          // A segment's size should only be multiples of MEMORY_ALIGNMENT, but check to be sure
;;;317          segmentLength = reinterpret_cast<const u32*>(bufferCharStar+this->index)[0];
000042  6021              STR      r1,[r4,#0]
000044  5843              LDR      r3,[r0,r1]
;;;318          const s32 roundedSegmentLength = RoundUp<s32>(segmentLength, MEMORY_ALIGNMENT);
000046  2110              MOVS     r1,#0x10
000048  603b              STR      r3,[r7,#0]
00004a  2b00              CMP      r3,#0
00004c  461a              MOV      r2,r3
00004e  bfc8              IT       GT
000050  1e52              SUBGT    r2,r2,#1
000052  fb92f1f1          SDIV     r1,r2,r1
000056  bfc8              IT       GT
000058  1c49              ADDGT    r1,r1,#1
00005a  0109              LSLS     r1,r1,#4
;;;319    
;;;320          AnkiConditionalErrorAndReturnValue(segmentLength == roundedSegmentLength, NULL, "Anki.MemoryStackConstIterator.GetNext", "The segmentLength is not a multiple of MEMORY_ALIGNMENT (%x!=%x)", segmentLength, roundedSegmentLength);
00005c  4e30              LDR      r6,|L15.288|
00005e  428b              CMP      r3,r1
000060  d00e              BEQ      |L15.128|
000062  9103              STR      r1,[sp,#0xc]
000064  f44f70a0          MOV      r0,#0x140
000068  9600              STR      r6,[sp,#0]
00006a  e9cd0301          STRD     r0,r3,[sp,#4]
00006e  a32d              ADR      r3,|L15.292|
000070  4a36              LDR      r2,|L15.332|
000072  a137              ADR      r1,|L15.336|
000074  2005              MOVS     r0,#5
000076  f7fffffe          BL       _Anki_Log
;;;321    
;;;322          // Check if the segment end is beyond the end of the buffer (NOTE: this is not conservative enough, though errors should be caught later)
;;;323          AnkiConditionalErrorAndReturnValue(segmentLength <= (memory.get_usedBytes()-this->index-MemoryStack::HEADER_LENGTH-MemoryStack::FOOTER_LENGTH), NULL, "Anki.MemoryStackConstIterator.GetNext", "The segment end is beyond the end of the buffer. segmentLength=%d (0x%x) usedBytes=%d all=%d", segmentLength, segmentLength, memory.get_usedBytes(), (memory.get_usedBytes()-this->index-MemoryStack::HEADER_LENGTH-MemoryStack::FOOTER_LENGTH));
;;;324    
;;;325          if(requireFillPatternMatch) {
;;;326            const u32 segmentHeader = reinterpret_cast<const u32*>(bufferCharStar+this->index)[1];
;;;327    
;;;328            AnkiConditionalErrorAndReturnValue(segmentHeader == MemoryStack::FILL_PATTERN_START, NULL, "Anki.MemoryStackConstIterator.GetNext", "segmentHeader == FILL_PATTERN_START (%x!=%x)", segmentHeader, MemoryStack::FILL_PATTERN_START);
;;;329    
;;;330            const u32 segmentFooter = reinterpret_cast<const u32*>(bufferCharStar+this->index+MemoryStack::HEADER_LENGTH+segmentLength)[0];
;;;331    
;;;332            AnkiConditionalErrorAndReturnValue(segmentFooter == MemoryStack::FILL_PATTERN_END, NULL, "Anki.MemoryStackConstIterator.GetNext", "segmentFooter == FILL_PATTERN_END (%x != %x)", segmentFooter, MemoryStack::FILL_PATTERN_END);
;;;333          }
;;;334    
;;;335          const void * segmentToReturn = reinterpret_cast<const void*>(bufferCharStar + this->index + MemoryStack::HEADER_LENGTH);
;;;336    
;;;337          this->index += MemoryStack::HEADER_LENGTH + segmentLength + MemoryStack::FOOTER_LENGTH;
;;;338    
;;;339          return segmentToReturn;
;;;340        }
00007a  b007              ADD      sp,sp,#0x1c
00007c  2000              MOVS     r0,#0                 ;320
00007e  bdf0              POP      {r4-r7,pc}
                  |L15.128|
000080  6861              LDR      r1,[r4,#4]
000082  688a              LDR      r2,[r1,#8]            ;323
000084  6821              LDR      r1,[r4,#0]            ;323
000086  eba20c01          SUB      r12,r2,r1             ;323
00008a  f1ac070c          SUB      r7,r12,#0xc           ;323
00008e  429f              CMP      r7,r3                 ;323
000090  da0e              BGE      |L15.176|
000092  9705              STR      r7,[sp,#0x14]         ;323
000094  9302              STR      r3,[sp,#8]            ;323
000096  e9cd3203          STRD     r3,r2,[sp,#0xc]       ;323
00009a  f2401043          MOV      r0,#0x143             ;323
00009e  e9cd6000          STRD     r6,r0,[sp,#0]         ;323
0000a2  a320              ADR      r3,|L15.292|
0000a4  4a34              LDR      r2,|L15.376|
0000a6  a12a              ADR      r1,|L15.336|
0000a8  2005              MOVS     r0,#5                 ;323
0000aa  f7fffffe          BL       _Anki_Log
0000ae  e02d              B        |L15.268|
                  |L15.176|
0000b0  2d00              CMP      r5,#0                 ;325
0000b2  d02e              BEQ      |L15.274|
0000b4  1d02              ADDS     r2,r0,#4              ;326
0000b6  f8dfc0c4          LDR      r12,|L15.380|
0000ba  588a              LDR      r2,[r1,r2]            ;326
0000bc  4562              CMP      r2,r12                ;328
0000be  d00f              BEQ      |L15.224|
0000c0  f44f70a4          MOV      r0,#0x148             ;328
0000c4  f8cdc00c          STR      r12,[sp,#0xc]         ;328
0000c8  9600              STR      r6,[sp,#0]            ;328
0000ca  e9cd0201          STRD     r0,r2,[sp,#4]         ;328
0000ce  a315              ADR      r3,|L15.292|
0000d0  a22b              ADR      r2,|L15.384|
0000d2  a11f              ADR      r1,|L15.336|
0000d4  2005              MOVS     r0,#5                 ;328
0000d6  f7fffffe          BL       _Anki_Log
0000da  b007              ADD      sp,sp,#0x1c
0000dc  2000              MOVS     r0,#0                 ;328
0000de  bdf0              POP      {r4-r7,pc}
                  |L15.224|
0000e0  18ca              ADDS     r2,r1,r3              ;330
0000e2  f1000c08          ADD      r12,r0,#8             ;330
0000e6  f852200c          LDR      r2,[r2,r12]           ;330
0000ea  f8dfc0c4          LDR      r12,|L15.432|
0000ee  4562              CMP      r2,r12                ;332
0000f0  d00f              BEQ      |L15.274|
0000f2  f44f70a6          MOV      r0,#0x14c             ;332
0000f6  f8cdc00c          STR      r12,[sp,#0xc]         ;332
0000fa  9600              STR      r6,[sp,#0]            ;332
0000fc  e9cd0201          STRD     r0,r2,[sp,#4]         ;332
000100  a308              ADR      r3,|L15.292|
000102  a22c              ADR      r2,|L15.436|
000104  a112              ADR      r1,|L15.336|
000106  2005              MOVS     r0,#5                 ;332
000108  f7fffffe          BL       _Anki_Log
                  |L15.268|
00010c  b007              ADD      sp,sp,#0x1c
00010e  2000              MOVS     r0,#0                 ;332
000110  bdf0              POP      {r4-r7,pc}
                  |L15.274|
000112  3008              ADDS     r0,r0,#8
000114  4408              ADD      r0,r0,r1              ;335
000116  4419              ADD      r1,r1,r3              ;337
000118  310c              ADDS     r1,r1,#0xc            ;337
00011a  6021              STR      r1,[r4,#0]            ;337
00011c  b007              ADD      sp,sp,#0x1c
00011e  bdf0              POP      {r4-r7,pc}
;;;341    
                          ENDP

                  |L15.288|
                          DCD      ||.constdata||+0x12a
                  |L15.292|
000124  2e2e5c63          DCB      "..\\coretech\\common\\robot\\src\\memory.cpp",0
000128  6f726574
00012c  6563685c
000130  636f6d6d
000134  6f6e5c72
000138  6f626f74
00013c  5c737263
000140  5c6d656d
000144  6f72792e
000148  63707000
                  |L15.332|
                          DCD      ||.conststring||+0x94
                  |L15.336|
000150  416e6b69          DCB      "Anki.MemoryStackConstIterator.GetNext",0
000154  2e4d656d
000158  6f727953
00015c  7461636b
000160  436f6e73
000164  74497465
000168  7261746f
00016c  722e4765
000170  744e6578
000174  7400    
000176  00                DCB      0
000177  00                DCB      0
                  |L15.376|
                          DCD      ||.conststring||+0xd8
                  |L15.380|
                          DCD      0xff01fe02
                  |L15.384|
000180  7365676d          DCB      "segmentHeader == FILL_PATTERN_START (%x!=%x)",0
000184  656e7448
000188  65616465
00018c  72203d3d
000190  2046494c
000194  4c5f5041
000198  54544552
00019c  4e5f5354
0001a0  41525420
0001a4  28257821
0001a8  3d257829
0001ac  00      
0001ad  00                DCB      0
0001ae  00                DCB      0
0001af  00                DCB      0
                  |L15.432|
                          DCD      0x03ff04fe
                  |L15.436|
0001b4  7365676d          DCB      "segmentFooter == FILL_PATTERN_END (%x != %x)",0
0001b8  656e7446
0001bc  6f6f7465
0001c0  72203d3d
0001c4  2046494c
0001c8  4c5f5041
0001cc  54544552
0001d0  4e5f454e
0001d4  44202825
0001d8  7820213d
0001dc  20257829
0001e0  00      
0001e1  00                DCB      0
0001e2  00                DCB      0
0001e3  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded24MemoryStackConstIteratorC1ERKNS0_11MemoryStackE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded24MemoryStackConstIteratorC2ERKNS0_11MemoryStackE                  ; Alternate entry point ; Anki::Embedded::MemoryStackConstIterator::MemoryStackConstIterator__sub_object(const Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded24MemoryStackConstIteratorC1ERKNS0_11MemoryStackE PROC ; Anki::Embedded::MemoryStackConstIterator::MemoryStackConstIterator(const Anki::Embedded::MemoryStack&)
;;;278    
;;;279        MemoryStackConstIterator::MemoryStackConstIterator(const MemoryStack &memory)
;;;280          : memory(memory)
;;;281        {
;;;282          const size_t bufferSizeT = reinterpret_cast<size_t>(memory.get_buffer());
;;;283    
;;;284          this->index = static_cast<s32>( RoundUp<size_t>(bufferSizeT+MemoryStack::HEADER_LENGTH, MEMORY_ALIGNMENT) - MemoryStack::HEADER_LENGTH - bufferSizeT );
;;;285        }
;;;286    
000000  6041              STR      r1,[r0,#4]
000002  6809              LDR      r1,[r1,#0]
000004  f1010217          ADD      r2,r1,#0x17
000008  f022020f          BIC      r2,r2,#0xf
00000c  1a51              SUBS     r1,r2,r1
00000e  3908              SUBS     r1,r1,#8
000010  6001              STR      r1,[r0,#0]
000012  4770              BX       lr
                          ENDP


                          AREA ||i._ZN4Anki8Embedded33MemoryStackReconstructingIterator10get_memoryEv||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded33MemoryStackReconstructingIterator10get_memoryEv PROC ; Anki::Embedded::MemoryStackReconstructingIterator::get_memory()
;;;453    
;;;454        MemoryStack& MemoryStackReconstructingIterator::get_memory()
000000  6840              LDR      r0,[r0,#4]
;;;455        {
;;;456          return const_cast<MemoryStack&>(memory);
;;;457        }
000002  4770              BX       lr
;;;458      } // namespace Embedded
                          ENDP


                          AREA ||i._ZN4Anki8Embedded33MemoryStackReconstructingIterator7GetNextERiS2_||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded33MemoryStackReconstructingIterator7GetNextERiS2_ PROC ; Anki::Embedded::MemoryStackReconstructingIterator::GetNext(int&, int&)
;;;444    
;;;445        void * MemoryStackReconstructingIterator::GetNext(s32 &trueSegmentLength, s32 &reportedSegmentLength)
000000  b530              PUSH     {r4,r5,lr}
;;;446        {
000002  b083              SUB      sp,sp,#0xc
000004  460d              MOV      r5,r1
000006  4613              MOV      r3,r2
000008  4604              MOV      r4,r0
00000a  466a              MOV      r2,sp
00000c  a901              ADD      r1,sp,#4
00000e  f7fffffe          BL       _ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator7HasNextERiS2_S2_ ; Anki::Embedded::MemoryStackReconstructingConstIterator::HasNext(int&, int&, int&) const
000012  0001              MOVS     r1,r0
000014  e9dd2000          LDRD     r2,r0,[sp,#0]
000018  eba20300          SUB      r3,r2,r0
00001c  f1030301          ADD      r3,r3,#1
000020  602b              STR      r3,[r5,#0]
000022  bf02              ITTT     EQ
000024  2000              MOVEQ    r0,#0
;;;447          // To avoid code duplication, we'll use the const version of GetNext(), though our MemoryStack is not const
;;;448    
;;;449          const void * segment = MemoryStackReconstructingConstIterator::GetNext(trueSegmentLength, reportedSegmentLength);
;;;450    
;;;451          return const_cast<void*>(segment);
;;;452        }
000026  b003              ADDEQ    sp,sp,#0xc
000028  bd30              POPEQ    {r4,r5,pc}
00002a  6861              LDR      r1,[r4,#4]
00002c  6809              LDR      r1,[r1,#0]
00002e  4408              ADD      r0,r0,r1
000030  f1020108          ADD      r1,r2,#8
000034  6021              STR      r1,[r4,#0]
000036  b003              ADD      sp,sp,#0xc
000038  bd30              POP      {r4,r5,pc}
;;;453    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded33MemoryStackReconstructingIteratorC1ERNS0_11MemoryStackE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded33MemoryStackReconstructingIteratorC2ERNS0_11MemoryStackE                  ; Alternate entry point ; Anki::Embedded::MemoryStackReconstructingIterator::MemoryStackReconstructingIterator__sub_object(Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded33MemoryStackReconstructingIteratorC1ERNS0_11MemoryStackE PROC ; Anki::Embedded::MemoryStackReconstructingIterator::MemoryStackReconstructingIterator(Anki::Embedded::MemoryStack&)
;;;439    
;;;440        MemoryStackReconstructingIterator::MemoryStackReconstructingIterator(MemoryStack &memory)
;;;441          : MemoryStackReconstructingConstIterator(memory)
;;;442        {
;;;443        }
;;;444    
000000  6041              STR      r1,[r0,#4]
000002  2100              MOVS     r1,#0
000004  6001              STR      r1,[r0,#0]
000006  4770              BX       lr
                          ENDP


                          AREA ||i._ZN4Anki8Embedded38MemoryStackReconstructingConstIterator7GetNextERiS2_||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded38MemoryStackReconstructingConstIterator7GetNextERiS2_ PROC ; Anki::Embedded::MemoryStackReconstructingConstIterator::GetNext(int&, int&)
;;;413    
;;;414        const void * MemoryStackReconstructingConstIterator::GetNext(s32 &trueSegmentLength, s32 &reportedSegmentLength)
000000  b530              PUSH     {r4,r5,lr}
;;;415        {
000002  b083              SUB      sp,sp,#0xc
000004  460d              MOV      r5,r1
;;;416          s32 startIndex;
;;;417          s32 endIndex;
;;;418    
;;;419          const bool hasNext = HasNext(startIndex, endIndex, reportedSegmentLength);
000006  4613              MOV      r3,r2
000008  4604              MOV      r4,r0                 ;415
00000a  466a              MOV      r2,sp
00000c  a901              ADD      r1,sp,#4
00000e  f7fffffe          BL       _ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator7HasNextERiS2_S2_ ; Anki::Embedded::MemoryStackReconstructingConstIterator::HasNext(int&, int&, int&) const
000012  e9dd2300          LDRD     r2,r3,[sp,#0]
;;;420    
;;;421          trueSegmentLength = endIndex - startIndex + 1;
000016  1ad1              SUBS     r1,r2,r3
000018  1c49              ADDS     r1,r1,#1
;;;422    
;;;423          if(!hasNext)
00001a  6029              STR      r1,[r5,#0]
00001c  2800              CMP      r0,#0
;;;424            return NULL;
;;;425    
;;;426          const u8 * bufferCharStar = reinterpret_cast<const u8*>(this->memory.get_buffer());
;;;427    
;;;428          const void * segmentToReturn = reinterpret_cast<const void*>(bufferCharStar + startIndex);
;;;429    
;;;430          this->index = endIndex + 2*sizeof(u32);
;;;431    
;;;432          return segmentToReturn;
;;;433        }
00001e  bf04              ITT      EQ
000020  b003              ADDEQ    sp,sp,#0xc
000022  bd30              POPEQ    {r4,r5,pc}
000024  6860              LDR      r0,[r4,#4]
000026  f1020108          ADD      r1,r2,#8              ;430
00002a  6800              LDR      r0,[r0,#0]            ;430
00002c  6021              STR      r1,[r4,#0]            ;430
00002e  b003              ADD      sp,sp,#0xc
000030  4418              ADD      r0,r0,r3              ;428
000032  bd30              POP      {r4,r5,pc}
;;;434    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded38MemoryStackReconstructingConstIteratorC1ERKNS0_11MemoryStackE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded38MemoryStackReconstructingConstIteratorC2ERKNS0_11MemoryStackE                  ; Alternate entry point ; Anki::Embedded::MemoryStackReconstructingConstIterator::MemoryStackReconstructingConstIterator__sub_object(const Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded38MemoryStackReconstructingConstIteratorC1ERKNS0_11MemoryStackE PROC ; Anki::Embedded::MemoryStackReconstructingConstIterator::MemoryStackReconstructingConstIterator(const Anki::Embedded::MemoryStack&)
;;;365    
;;;366        MemoryStackReconstructingConstIterator::MemoryStackReconstructingConstIterator(const MemoryStack &memory)
;;;367          : memory(memory)
;;;368        {
;;;369          this->index = 0;
;;;370        }
;;;371    
000000  6041              STR      r1,[r0,#4]
000002  2100              MOVS     r1,#0
000004  6001              STR      r1,[r0,#0]
000006  4770              BX       lr
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded11MemoryStack10get_bufferEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded11MemoryStack10get_bufferEv PROC ; Anki::Embedded::MemoryStack::get_buffer() const
;;;231    
;;;232        const void* MemoryStack::get_buffer() const
000000  6800              LDR      r0,[r0,#0]
;;;233        {
;;;234          return buffer;
;;;235        }
000002  4770              BX       lr
;;;236    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded11MemoryStack13get_usedBytesEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded11MemoryStack13get_usedBytesEv PROC ; Anki::Embedded::MemoryStack::get_usedBytes() const
;;;221    
;;;222        s32 MemoryStack::get_usedBytes() const
000000  6880              LDR      r0,[r0,#8]
;;;223        {
;;;224          return usedBytes;
;;;225        }
000002  4770              BX       lr
;;;226    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded11MemoryStack14get_totalBytesEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded11MemoryStack14get_totalBytesEv PROC ; Anki::Embedded::MemoryStack::get_totalBytes() const
;;;216    
;;;217        s32 MemoryStack::get_totalBytes() const
000000  6840              LDR      r0,[r0,#4]
;;;218        {
;;;219          return totalBytes;
;;;220        }
000002  4770              BX       lr
;;;221    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded11MemoryStack20get_validBufferStartERi||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded11MemoryStack20get_validBufferStartERi PROC ; Anki::Embedded::MemoryStack::get_validBufferStart(int&) const
;;;258    
;;;259        const void* MemoryStack::get_validBufferStart(s32 &firstValidIndex) const
000000  6802              LDR      r2,[r0,#0]
;;;260        {
;;;261          const size_t bufferSizeT = reinterpret_cast<size_t>(this->buffer);
;;;262          firstValidIndex = static_cast<s32>( RoundUp<size_t>(bufferSizeT+MemoryStack::HEADER_LENGTH, MEMORY_ALIGNMENT) - MemoryStack::HEADER_LENGTH - bufferSizeT );
000002  f1020317          ADD      r3,r2,#0x17
000006  f023030f          BIC      r3,r3,#0xf
00000a  1a9a              SUBS     r2,r3,r2
00000c  3a08              SUBS     r2,r2,#8
;;;263    
;;;264          const void * validStart = reinterpret_cast<const char*>(this->buffer) + firstValidIndex;
00000e  600a              STR      r2,[r1,#0]
000010  6800              LDR      r0,[r0,#0]
000012  4410              ADD      r0,r0,r2
;;;265    
;;;266          return validStart;
;;;267        }
000014  4770              BX       lr
;;;268    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded11MemoryStack20get_validBufferStartEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded11MemoryStack20get_validBufferStartEv PROC ; Anki::Embedded::MemoryStack::get_validBufferStart() const
;;;242    
;;;243        const void* MemoryStack::get_validBufferStart() const
000000  6800              LDR      r0,[r0,#0]
;;;244        {
000002  b081              SUB      sp,sp,#4
000004  f1000117          ADD      r1,r0,#0x17
000008  f021010f          BIC      r1,r1,#0xf
00000c  1a09              SUBS     r1,r1,r0
00000e  3908              SUBS     r1,r1,#8
000010  9100              STR      r1,[sp,#0]
000012  4408              ADD      r0,r0,r1
;;;245          s32 firstValidIndex;
;;;246          return this->get_validBufferStart(firstValidIndex);
;;;247        }
000014  b001              ADD      sp,sp,#4
000016  4770              BX       lr
;;;248    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded11MemoryStack32ComputeLargestPossibleAllocationEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded11MemoryStack32ComputeLargestPossibleAllocationEv PROC ; Anki::Embedded::MemoryStack::ComputeLargestPossibleAllocation() const
;;;193    
;;;194        s32 MemoryStack::ComputeLargestPossibleAllocation() const
000000  6802              LDR      r2,[r0,#0]
;;;195        {
;;;196          const size_t bufferNextFree = reinterpret_cast<size_t>(buffer) + usedBytes;
000002  6881              LDR      r1,[r0,#8]
;;;197          const size_t bufferNextFreePlusHeaderAndAlignment = RoundUp<size_t>(bufferNextFree+HEADER_LENGTH, MEMORY_ALIGNMENT);
;;;198          const size_t bufferEnd = reinterpret_cast<size_t>(buffer) + totalBytes;
000004  6840              LDR      r0,[r0,#4]
000006  4411              ADD      r1,r1,r2              ;196
000008  3117              ADDS     r1,r1,#0x17           ;196
00000a  f021010f          BIC      r1,r1,#0xf            ;196
00000e  4410              ADD      r0,r0,r2
;;;199    
;;;200          // Make sure the next start point isn't past the end of the buffer (done in this way because of unsigned arithmetic)
;;;201          if( (bufferNextFreePlusHeaderAndAlignment+FOOTER_LENGTH+MEMORY_ALIGNMENT) > bufferEnd )
000010  f1010214          ADD      r2,r1,#0x14
000014  4282              CMP      r2,r0
;;;202            return 0;
000016  bf84              ITT      HI
000018  2000              MOVHI    r0,#0
;;;203    
;;;204          // The RoundDown handles the requirement for all memory blocks to be multiples of MEMORY_ALIGNMENT
;;;205          const s32 maxFreeSpace = static_cast<s32>( RoundDown<size_t>(bufferEnd - bufferNextFreePlusHeaderAndAlignment - FOOTER_LENGTH, MEMORY_ALIGNMENT) );
;;;206    
;;;207          return maxFreeSpace;
;;;208        }
00001a  4770              BXHI     lr
00001c  1a40              SUBS     r0,r0,r1              ;205
00001e  1f01              SUBS     r1,r0,#4              ;205
000020  2010              MOVS     r0,#0x10              ;205
000022  fbb1f0f0          UDIV     r0,r1,r0              ;205
000026  0100              LSLS     r0,r0,#4              ;205
000028  4770              BX       lr
;;;209    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded11MemoryStack5PrintEv||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded11MemoryStack5PrintEv PROC ; Anki::Embedded::MemoryStack::Print() const
;;;209    
;;;210        Result MemoryStack::Print() const
000000  b530              PUSH     {r4,r5,lr}
000002  6883              LDR      r3,[r0,#8]
000004  6801              LDR      r1,[r0,#0]
;;;211        {
000006  b083              SUB      sp,sp,#0xc
000008  18ca              ADDS     r2,r1,r3
00000a  3217              ADDS     r2,r2,#0x17
00000c  f0220c0f          BIC      r12,r2,#0xf
000010  6842              LDR      r2,[r0,#4]
000012  f10c0514          ADD      r5,r12,#0x14
000016  188c              ADDS     r4,r1,r2
000018  42a5              CMP      r5,r4
00001a  bf88              IT       HI
00001c  f04f0c00          MOVHI    r12,#0
000020  d809              BHI      |L28.54|
000022  eba40c0c          SUB      r12,r4,r12
000026  f1ac0404          SUB      r4,r12,#4
00002a  f04f0c10          MOV      r12,#0x10
00002e  fbb4fcfc          UDIV     r12,r4,r12
000032  ea4f1c0c          LSL      r12,r12,#4
                  |L28.54|
000036  e9cdc100          STRD     r12,r1,[sp,#0]
;;;212          const s32 maxAllocationBytes = ComputeLargestPossibleAllocation();
;;;213          CoreTechPrint("(id:%d totalBytes:%d usedBytes:%d maxAllocationBytes:%d bufferLocation:%d) ", id, totalBytes, usedBytes, maxAllocationBytes, buffer);
00003a  6941              LDR      r1,[r0,#0x14]
00003c  4802              LDR      r0,|L28.72|
00003e  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;214          return RESULT_OK;
;;;215        }
000042  b003              ADD      sp,sp,#0xc
000044  2000              MOVS     r0,#0                 ;214
000046  bd30              POP      {r4,r5,pc}
;;;216    
                          ENDP

                  |L28.72|
                          DCD      ||.conststring||+0x48

                          AREA ||i._ZNK4Anki8Embedded11MemoryStack6get_idEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded11MemoryStack6get_idEv PROC ; Anki::Embedded::MemoryStack::get_id() const
;;;268    
;;;269        s32 MemoryStack::get_id() const
000000  6940              LDR      r0,[r0,#0x14]
;;;270        {
;;;271          return id;
;;;272        }
000002  4770              BX       lr
;;;273    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded11MemoryStack7IsValidEv||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded11MemoryStack7IsValidEv PROC ; Anki::Embedded::MemoryStack::IsValid() const
;;;141    
;;;142        bool MemoryStack::IsValid() const
000000  b500              PUSH     {lr}
;;;143        {
;;;144          AnkiConditionalErrorAndReturnValue(buffer != NULL, false, "Anki.MemoryStack.IsValid", "buffer is not allocated");
000002  6801              LDR      r1,[r0,#0]
000004  b083              SUB      sp,sp,#0xc            ;143
000006  2900              CMP      r1,#0
;;;145    
;;;146          AnkiConditionalWarnAndReturnValue(usedBytes <= totalBytes, false, "Anki.MemoryStack.IsValid", "usedBytes is greater than totalBytes");
;;;147          AnkiConditionalWarnAndReturnValue(usedBytes >= 0 && totalBytes >= 0, false, "Anki.MemoryStack.IsValid", "usedBytes or totalBytes is less than zero");
;;;148    
;;;149          if(usedBytes == 0)
000008  bf1f              ITTTT    NE
00000a  6880              LDRNE    r0,[r0,#8]
;;;150            return true;
;;;151    
;;;152    #if ANKI_DEBUG_LEVEL >= ANKI_DEBUG_ERRORS_AND_WARNS
;;;153          const size_t LOOP_MAX = 1000000;
;;;154          const char * const bufferCharStar = reinterpret_cast<const char*>(buffer);
;;;155          const size_t bufferSizeT = reinterpret_cast<size_t>(buffer);
;;;156    
;;;157          s32 index = static_cast<s32>( RoundUp<size_t>(bufferSizeT+HEADER_LENGTH, MEMORY_ALIGNMENT) - HEADER_LENGTH - bufferSizeT );
;;;158    
;;;159          for(size_t i=0; (i<MIN(LOOP_MAX,totalBytes)) && (index<usedBytes); i++) {
;;;160            index = static_cast<s32>( RoundUp<size_t>(bufferSizeT+index+HEADER_LENGTH, MEMORY_ALIGNMENT) - HEADER_LENGTH - bufferSizeT );
;;;161    
;;;162            // A segment's size should only be multiples of MEMORY_ALIGNMENT, but check to be sure
;;;163            const s32 segmentLength = reinterpret_cast<const u32*>(bufferCharStar+index)[0];
;;;164            const s32 roundedSegmentLength = RoundUp<s32>(segmentLength, MEMORY_ALIGNMENT);
;;;165            AnkiConditionalWarnAndReturnValue(segmentLength == roundedSegmentLength, false, "Anki.MemoryStack.IsValid", "The segmentLength is not a multiple of MEMORY_ALIGNMENT");
;;;166    
;;;167            // Check if the segment end is beyond the end of the buffer (NOTE: this is not conservative enough, though errors should be caught later)
;;;168            AnkiConditionalWarnAndReturnValue(segmentLength <= (usedBytes-index-HEADER_LENGTH-FOOTER_LENGTH), false, "Anki.MemoryStack.IsValid", "The segment end is beyond the end of the buffer");
;;;169    
;;;170            const u32 segmentHeader = reinterpret_cast<const u32*>(bufferCharStar+index)[1];
;;;171    
;;;172            AnkiConditionalWarnAndReturnValue(segmentHeader == FILL_PATTERN_START, false, "Anki.MemoryStack.IsValid", "segmentHeader == FILL_PATTERN_START");
;;;173    
;;;174            const u32 segmentFooter = reinterpret_cast<const u32*>(bufferCharStar+index+HEADER_LENGTH+segmentLength)[0];
;;;175    
;;;176            AnkiConditionalWarnAndReturnValue(segmentFooter == FILL_PATTERN_END, false, "Anki.MemoryStack.IsValid", "segmentFooter == FILL_PATTERN_END");
;;;177    
;;;178            index += HEADER_LENGTH + segmentLength + FOOTER_LENGTH;
;;;179          }
;;;180    
;;;181          if(index == usedBytes) {
;;;182            return true;
;;;183          } else if(index == LOOP_MAX){
;;;184            AnkiError("Anki.MemoryStack.IsValid", "Infinite while loop");
;;;185            return false;
;;;186          } else {
;;;187            AnkiError("Anki.MemoryStack.IsValid", "Loop exited at an incorrect position, probably due to corruption");
;;;188            return false;
;;;189          }
;;;190    #endif // #if ANKI_DEBUG_LEVEL >= ANKI_DEBUG_ERRORS_AND_WARNS
;;;191          return true;
00000c  2001              MOVNE    r0,#1
;;;192        }
00000e  b003              ADDNE    sp,sp,#0xc
000010  bd00              POPNE    {pc}
000012  2190              MOVS     r1,#0x90              ;144
000014  4805              LDR      r0,|L30.44|
000016  e9cd0100          STRD     r0,r1,[sp,#0]         ;144
00001a  a305              ADR      r3,|L30.48|
00001c  a20e              ADR      r2,|L30.88|
00001e  a114              ADR      r1,|L30.112|
000020  2005              MOVS     r0,#5                 ;144
000022  f7fffffe          BL       _Anki_Log
000026  b003              ADD      sp,sp,#0xc
000028  2000              MOVS     r0,#0                 ;144
00002a  bd00              POP      {pc}
;;;193    
                          ENDP

                  |L30.44|
                          DCD      ||.constdata||+0xf8
                  |L30.48|
000030  2e2e5c63          DCB      "..\\coretech\\common\\robot\\src\\memory.cpp",0
000034  6f726574
000038  6563685c
00003c  636f6d6d
000040  6f6e5c72
000044  6f626f74
000048  5c737263
00004c  5c6d656d
000050  6f72792e
000054  63707000
                  |L30.88|
000058  62756666          DCB      "buffer is not allocated",0
00005c  65722069
000060  73206e6f
000064  7420616c
000068  6c6f6361
00006c  74656400
                  |L30.112|
000070  416e6b69          DCB      "Anki.MemoryStack.IsValid",0
000074  2e4d656d
000078  6f727953
00007c  7461636b
000080  2e497356
000084  616c6964
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i._ZNK4Anki8Embedded11MemoryStack9get_flagsEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded11MemoryStack9get_flagsEv PROC ; Anki::Embedded::MemoryStack::get_flags() const
;;;273    
;;;274        Flags::Buffer MemoryStack::get_flags() const
000000  6980              LDR      r0,[r0,#0x18]
;;;275        {
;;;276          return flags;
;;;277        }
000002  4770              BX       lr
;;;278    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded24MemoryStackConstIterator10get_memoryEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded24MemoryStackConstIterator10get_memoryEv PROC ; Anki::Embedded::MemoryStackConstIterator::get_memory() const
;;;341    
;;;342        const MemoryStack& MemoryStackConstIterator::get_memory() const
000000  6840              LDR      r0,[r0,#4]
;;;343        {
;;;344          return memory;
;;;345        }
000002  4770              BX       lr
;;;346    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded24MemoryStackConstIterator7HasNextEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded24MemoryStackConstIterator7HasNextEv PROC ; Anki::Embedded::MemoryStackConstIterator::HasNext() const
;;;286    
;;;287        bool MemoryStackConstIterator::HasNext() const
000000  b538              PUSH     {r3-r5,lr}
;;;288        {
000002  4604              MOV      r4,r0
;;;289          // TODO: These extra bytes are a bit of a hack for the SerializedBuffer case.
;;;290          // I think index should match the used bytes exactly, but seems to be a bit short.
;;;291          s32 extraBytes = MEMORY_ALIGNMENT;
;;;292          if(this->memory.get_flags().get_useBoundaryFillPatterns()) {
000004  6840              LDR      r0,[r0,#4]
000006  2510              MOVS     r5,#0x10              ;291
000008  6980              LDR      r0,[r0,#0x18]         ;291
00000a  9000              STR      r0,[sp,#0]
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000012  2800              CMP      r0,#0
;;;293            extraBytes += MemoryStack::HEADER_LENGTH + MemoryStack::FOOTER_LENGTH;
000014  bf18              IT       NE
000016  251c              MOVNE    r5,#0x1c
000018  6860              LDR      r0,[r4,#4]
;;;294          }
;;;295    
;;;296          if((this->index + extraBytes) < memory.get_usedBytes())
00001a  6821              LDR      r1,[r4,#0]
00001c  6880              LDR      r0,[r0,#8]
00001e  4429              ADD      r1,r1,r5
000020  4288              CMP      r0,r1
;;;297            return true;
000022  bfcc              ITE      GT
000024  2001              MOVGT    r0,#1
;;;298          else
;;;299            return false;
000026  2000              MOVLE    r0,#0
;;;300        }
000028  bd38              POP      {r3-r5,pc}
;;;301    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator10get_memoryEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator10get_memoryEv PROC ; Anki::Embedded::MemoryStackReconstructingConstIterator::get_memory() const
;;;434    
;;;435        const MemoryStack& MemoryStackReconstructingConstIterator::get_memory() const
000000  6840              LDR      r0,[r0,#4]
;;;436        {
;;;437          return memory;
;;;438        }
000002  4770              BX       lr
;;;439    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator7HasNextERiS2_S2_||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator7HasNextERiS2_S2_ PROC ; Anki::Embedded::MemoryStackReconstructingConstIterator::HasNext(int&, int&, int&) const
;;;380    
;;;381        bool MemoryStackReconstructingConstIterator::HasNext(s32 &startIndex, s32 &endIndex, s32 &reportedLength) const
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;382        {
000004  4605              MOV      r5,r0
;;;383          const u8 * curBufferPointer = reinterpret_cast<const u8*>(memory.get_buffer()) + this->index;
000006  6840              LDR      r0,[r0,#4]
000008  4616              MOV      r6,r2                 ;382
00000a  460c              MOV      r4,r1                 ;382
00000c  6802              LDR      r2,[r0,#0]
00000e  6829              LDR      r1,[r5,#0]
000010  6880              LDR      r0,[r0,#8]
000012  b082              SUB      sp,sp,#8              ;382
;;;384          const s32 curBufferLength = memory.get_usedBytes() - this->index;
000014  eba00901          SUB      r9,r0,r1
;;;385    
;;;386          // These must be copied, or the Keil compiler gets confused
;;;387          u32 fillPatternStartU32 = MemoryStack::FILL_PATTERN_START;
000018  481e              LDR      r0,|L35.148|
00001a  1857              ADDS     r7,r2,r1              ;383
;;;388          u32 fillPatternEndU32 = MemoryStack::FILL_PATTERN_END;
00001c  9000              STR      r0,[sp,#0]
00001e  481e              LDR      r0,|L35.152|
000020  4698              MOV      r8,r3                 ;382
;;;389    
;;;390          const u8 * fillPatternStartU8p = reinterpret_cast<const u8*>(&fillPatternStartU32);
;;;391          const u8 * fillPatternEndU8p = reinterpret_cast<const u8*>(&fillPatternEndU32);
;;;392    
;;;393          startIndex = FindBytePattern(curBufferPointer, curBufferLength, fillPatternStartU8p, sizeof(u32));
000022  9001              STR      r0,[sp,#4]
000024  466a              MOV      r2,sp                 ;390
000026  f10d0a04          ADD      r10,sp,#4             ;391
00002a  2304              MOVS     r3,#4
00002c  4649              MOV      r1,r9
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       _ZN4Anki8Embedded15FindBytePatternEPKviPKhi ; Anki::Embedded::FindBytePattern(const void*, int, const unsigned char*, int)
;;;394          endIndex = FindBytePattern(curBufferPointer+startIndex, curBufferLength-startIndex, fillPatternEndU8p, sizeof(u32));
000034  eba90100          SUB      r1,r9,r0
000038  6020              STR      r0,[r4,#0]
00003a  4438              ADD      r0,r0,r7
00003c  2304              MOVS     r3,#4
00003e  4652              MOV      r2,r10
000040  f7fffffe          BL       _ZN4Anki8Embedded15FindBytePatternEPKviPKhi ; Anki::Embedded::FindBytePattern(const void*, int, const unsigned char*, int)
;;;395    
;;;396          reportedLength = -1;
000044  6030              STR      r0,[r6,#0]
000046  f04f30ff          MOV      r0,#0xffffffff
;;;397    
;;;398          if(startIndex >= 0) {
00004a  f8c80000          STR      r0,[r8,#0]
00004e  6820              LDR      r0,[r4,#0]
000050  2800              CMP      r0,#0
000052  db1a              BLT      |L35.138|
;;;399            reportedLength = *reinterpret_cast<const u32*>(curBufferPointer + startIndex - sizeof(u32));
000054  1f39              SUBS     r1,r7,#4
000056  5840              LDR      r0,[r0,r1]
;;;400    
;;;401            if(endIndex >= 0) {
000058  f8c80000          STR      r0,[r8,#0]
00005c  6830              LDR      r0,[r6,#0]
00005e  2800              CMP      r0,#0
000060  db0e              BLT      |L35.128|
;;;402              endIndex += this->index + startIndex - 1;
000062  6829              LDR      r1,[r5,#0]
000064  4408              ADD      r0,r0,r1
000066  6821              LDR      r1,[r4,#0]
000068  1e49              SUBS     r1,r1,#1
00006a  4408              ADD      r0,r0,r1
;;;403              startIndex += this->index + sizeof(u32);
00006c  6030              STR      r0,[r6,#0]
00006e  6820              LDR      r0,[r4,#0]
000070  6829              LDR      r1,[r5,#0]
000072  4408              ADD      r0,r0,r1
000074  1d00              ADDS     r0,r0,#4
;;;404    
;;;405              return true;
000076  6020              STR      r0,[r4,#0]
;;;406            } else {
;;;407              startIndex += this->index + sizeof(u32);
;;;408            }
;;;409          }
;;;410    
;;;411          return false;
;;;412        }
000078  b002              ADD      sp,sp,#8
00007a  2001              MOVS     r0,#1                 ;405
00007c  e8bd87f0          POP      {r4-r10,pc}
                  |L35.128|
000080  6820              LDR      r0,[r4,#0]            ;407
000082  6829              LDR      r1,[r5,#0]            ;407
000084  4408              ADD      r0,r0,r1              ;407
000086  1d00              ADDS     r0,r0,#4              ;407
000088  6020              STR      r0,[r4,#0]            ;407
                  |L35.138|
00008a  b002              ADD      sp,sp,#8
00008c  2000              MOVS     r0,#0                 ;411
00008e  e8bd87f0          POP      {r4-r10,pc}
;;;413    
                          ENDP

000092  0000              DCW      0x0000
                  |L35.148|
                          DCD      0xff01fe02
                  |L35.152|
                          DCD      0x03ff04fe

                          AREA ||i._ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator7HasNextEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator7HasNextEv PROC ; Anki::Embedded::MemoryStackReconstructingConstIterator::HasNext() const
;;;371    
;;;372        bool MemoryStackReconstructingConstIterator::HasNext() const
000000  b500              PUSH     {lr}
;;;373        {
000002  b083              SUB      sp,sp,#0xc
;;;374          s32 startIndex;
;;;375          s32 endIndex;
;;;376          s32 reportedLength;
;;;377    
;;;378          return HasNext(startIndex, endIndex, reportedLength);
000004  ab02              ADD      r3,sp,#8
000006  aa01              ADD      r2,sp,#4
000008  4669              MOV      r1,sp
00000a  f7fffffe          BL       _ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator7HasNextERiS2_S2_ ; Anki::Embedded::MemoryStackReconstructingConstIterator::HasNext(int&, int&, int&) const
;;;379        }
00000e  b003              ADD      sp,sp,#0xc
000010  bd00              POP      {pc}
;;;380    
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki8Embedded11MemoryStackC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded11MemoryStackC1Ev||
                          DCD      0x00000001

                          AREA ||area_number.38||, LINKORDER=||i._ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.38||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||area_number.39||, LINKORDER=||i._ZN4Anki8Embedded11MemoryStackC1ERKS1_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded11MemoryStackC1ERKS1_||
                          DCD      0x00000001

                          AREA ||area_number.40||, LINKORDER=||i._ZNK4Anki8Embedded11MemoryStack9get_flagsEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.40||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded11MemoryStack9get_flagsEv||
                          DCD      0x00000001

                          AREA ||area_number.41||, LINKORDER=||i._ZN4Anki8Embedded11MemoryStack8AllocateEibRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded11MemoryStack8AllocateEibRi||
                          DCD      0x00000001

                          AREA ||area_number.42||, LINKORDER=||i._ZN4Anki8Embedded11MemoryStack8AllocateEiRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded11MemoryStack8AllocateEiRi||
                          DCD      0x00000001

                          AREA ||area_number.43||, LINKORDER=||i._ZN4Anki8Embedded11MemoryStack8AllocateEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded11MemoryStack8AllocateEi||
                          DCD      0x00000001

                          AREA ||area_number.44||, LINKORDER=||i._ZN4Anki8Embedded11MemoryStack10ReallocateEPviRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded11MemoryStack10ReallocateEPviRi||
                          DCD      0x00000001

                          AREA ||area_number.45||, LINKORDER=||i._ZN4Anki8Embedded11MemoryStack10ReallocateEPvi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded11MemoryStack10ReallocateEPvi||
                          DCD      0x00000001

                          AREA ||area_number.46||, LINKORDER=||i._ZNK4Anki8Embedded11MemoryStack7IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded11MemoryStack7IsValidEv||
                          DCD      0x00000001

                          AREA ||area_number.47||, LINKORDER=||i._ZNK4Anki8Embedded11MemoryStack32ComputeLargestPossibleAllocationEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded11MemoryStack32ComputeLargestPossibleAllocationEv||
                          DCD      0x00000001

                          AREA ||area_number.48||, LINKORDER=||i._ZNK4Anki8Embedded11MemoryStack5PrintEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.48||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded11MemoryStack5PrintEv||
                          DCD      0x00000001

                          AREA ||area_number.49||, LINKORDER=||i._ZNK4Anki8Embedded11MemoryStack14get_totalBytesEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.49||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded11MemoryStack14get_totalBytesEv||
                          DCD      0x00000001

                          AREA ||area_number.50||, LINKORDER=||i._ZNK4Anki8Embedded11MemoryStack13get_usedBytesEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.50||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded11MemoryStack13get_usedBytesEv||
                          DCD      0x00000001

                          AREA ||area_number.51||, LINKORDER=||i._ZN4Anki8Embedded11MemoryStack10get_bufferEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded11MemoryStack10get_bufferEv||
                          DCD      0x00000001

                          AREA ||area_number.52||, LINKORDER=||i._ZNK4Anki8Embedded11MemoryStack10get_bufferEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.52||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded11MemoryStack10get_bufferEv||
                          DCD      0x00000001

                          AREA ||area_number.53||, LINKORDER=||i._ZN4Anki8Embedded11MemoryStack20get_validBufferStartERi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded11MemoryStack20get_validBufferStartERi||
                          DCD      0x00000001

                          AREA ||area_number.54||, LINKORDER=||i._ZN4Anki8Embedded11MemoryStack20get_validBufferStartEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.54||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded11MemoryStack20get_validBufferStartEv||
                          DCD      0x00000001

                          AREA ||area_number.55||, LINKORDER=||i._ZNK4Anki8Embedded11MemoryStack20get_validBufferStartERi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.55||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded11MemoryStack20get_validBufferStartERi||
                          DCD      0x00000001

                          AREA ||area_number.56||, LINKORDER=||i._ZNK4Anki8Embedded11MemoryStack20get_validBufferStartEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.56||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded11MemoryStack20get_validBufferStartEv||
                          DCD      0x00000001

                          AREA ||area_number.57||, LINKORDER=||i._ZNK4Anki8Embedded11MemoryStack6get_idEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded11MemoryStack6get_idEv||
                          DCD      0x00000001

                          AREA ||area_number.58||, LINKORDER=||i._ZN4Anki8Embedded24MemoryStackConstIteratorC1ERKNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded24MemoryStackConstIteratorC1ERKNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.59||, LINKORDER=||i._ZNK4Anki8Embedded24MemoryStackConstIterator7HasNextEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.59||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded24MemoryStackConstIterator7HasNextEv||
                          DCD      0x00000001

                          AREA ||area_number.60||, LINKORDER=||i._ZN4Anki8Embedded24MemoryStackConstIterator7GetNextERib||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded24MemoryStackConstIterator7GetNextERib||
                          DCD      0x00000001

                          AREA ||area_number.61||, LINKORDER=||i._ZNK4Anki8Embedded24MemoryStackConstIterator10get_memoryEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.61||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded24MemoryStackConstIterator10get_memoryEv||
                          DCD      0x00000001

                          AREA ||area_number.62||, LINKORDER=||i._ZN4Anki8Embedded19MemoryStackIteratorC1ERNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.62||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded19MemoryStackIteratorC1ERNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.63||, LINKORDER=||i._ZN4Anki8Embedded19MemoryStackIterator7GetNextERib||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.63||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded19MemoryStackIterator7GetNextERib||
                          DCD      0x00000001

                          AREA ||area_number.64||, LINKORDER=||i._ZN4Anki8Embedded19MemoryStackIterator10get_memoryEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.64||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded19MemoryStackIterator10get_memoryEv||
                          DCD      0x00000001

                          AREA ||area_number.65||, LINKORDER=||i._ZN4Anki8Embedded38MemoryStackReconstructingConstIteratorC1ERKNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.65||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded38MemoryStackReconstructingConstIteratorC1ERKNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.66||, LINKORDER=||i._ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator7HasNextERiS2_S2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.66||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator7HasNextERiS2_S2_||
                          DCD      0x00000001

                          AREA ||area_number.67||, LINKORDER=||i._ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator7HasNextEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.67||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator7HasNextEv||
                          DCD      0x00000001

                          AREA ||area_number.68||, LINKORDER=||i._ZN4Anki8Embedded38MemoryStackReconstructingConstIterator7GetNextERiS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.68||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded38MemoryStackReconstructingConstIterator7GetNextERiS2_||
                          DCD      0x00000001

                          AREA ||area_number.69||, LINKORDER=||i._ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator10get_memoryEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.69||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded38MemoryStackReconstructingConstIterator10get_memoryEv||
                          DCD      0x00000001

                          AREA ||area_number.70||, LINKORDER=||i._ZN4Anki8Embedded33MemoryStackReconstructingIteratorC1ERNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.70||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded33MemoryStackReconstructingIteratorC1ERNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.71||, LINKORDER=||i._ZN4Anki8Embedded33MemoryStackReconstructingIterator7GetNextERiS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.71||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded33MemoryStackReconstructingIterator7GetNextERiS2_||
                          DCD      0x00000001

                          AREA ||area_number.72||, LINKORDER=||i._ZN4Anki8Embedded33MemoryStackReconstructingIterator10get_memoryEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.72||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded33MemoryStackReconstructingIterator10get_memoryEv||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  4d656d6f          DCB      0x4d,0x65,0x6d,0x6f
000014  72795374          DCB      0x72,0x79,0x53,0x74
000018  61636b3a          DCB      0x61,0x63,0x6b,0x3a
00001c  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
000020  6f727953          DCB      0x6f,0x72,0x79,0x53
000024  7461636b          DCB      0x74,0x61,0x63,0x6b
000028  28766f69          DCB      0x28,0x76,0x6f,0x69
00002c  64202a2c          DCB      0x64,0x20,0x2a,0x2c
000030  20736967          DCB      0x20,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e742c          DCB      0x69,0x6e,0x74,0x2c
00003c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000040  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000044  6d626564          DCB      0x6d,0x62,0x65,0x64
000048  6465643a          DCB      0x64,0x65,0x64,0x3a
00004c  3a466c61          DCB      0x3a,0x46,0x6c,0x61
000050  67733a3a          DCB      0x67,0x73,0x3a,0x3a
000054  42756666          DCB      0x42,0x75,0x66,0x66
000058  65722900          DCB      0x65,0x72,0x29,0x00
                  |symbol_number.86|
00005c  766f6964          DCB      0x76,0x6f,0x69,0x64
000060  202a416e          DCB      0x20,0x2a,0x41,0x6e
000064  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000068  456d6265          DCB      0x45,0x6d,0x62,0x65
00006c  64646564          DCB      0x64,0x64,0x65,0x64
000070  3a3a4d65          DCB      0x3a,0x3a,0x4d,0x65
000074  6d6f7279          DCB      0x6d,0x6f,0x72,0x79
000078  53746163          DCB      0x53,0x74,0x61,0x63
00007c  6b3a3a41          DCB      0x6b,0x3a,0x3a,0x41
000080  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000084  61746528          DCB      0x61,0x74,0x65,0x28
000088  7369676e          DCB      0x73,0x69,0x67,0x6e
00008c  65642069          DCB      0x65,0x64,0x20,0x69
000090  6e742c20          DCB      0x6e,0x74,0x2c,0x20
000094  626f6f6c          DCB      0x62,0x6f,0x6f,0x6c
000098  2c207369          DCB      0x2c,0x20,0x73,0x69
00009c  676e6564          DCB      0x67,0x6e,0x65,0x64
0000a0  20696e74          DCB      0x20,0x69,0x6e,0x74
0000a4  20262900          DCB      0x20,0x26,0x29,0x00
                  |symbol_number.87|
0000a8  766f6964          DCB      0x76,0x6f,0x69,0x64
0000ac  202a416e          DCB      0x20,0x2a,0x41,0x6e
0000b0  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0000b4  456d6265          DCB      0x45,0x6d,0x62,0x65
0000b8  64646564          DCB      0x64,0x64,0x65,0x64
0000bc  3a3a4d65          DCB      0x3a,0x3a,0x4d,0x65
0000c0  6d6f7279          DCB      0x6d,0x6f,0x72,0x79
0000c4  53746163          DCB      0x53,0x74,0x61,0x63
0000c8  6b3a3a52          DCB      0x6b,0x3a,0x3a,0x52
0000cc  65616c6c          DCB      0x65,0x61,0x6c,0x6c
0000d0  6f636174          DCB      0x6f,0x63,0x61,0x74
0000d4  6528766f          DCB      0x65,0x28,0x76,0x6f
0000d8  6964202a          DCB      0x69,0x64,0x20,0x2a
0000dc  2c207369          DCB      0x2c,0x20,0x73,0x69
0000e0  676e6564          DCB      0x67,0x6e,0x65,0x64
0000e4  20696e74          DCB      0x20,0x69,0x6e,0x74
0000e8  2c207369          DCB      0x2c,0x20,0x73,0x69
0000ec  676e6564          DCB      0x67,0x6e,0x65,0x64
0000f0  20696e74          DCB      0x20,0x69,0x6e,0x74
0000f4  20262900          DCB      0x20,0x26,0x29,0x00
                  |symbol_number.88|
0000f8  626f6f6c          DCB      0x62,0x6f,0x6f,0x6c
0000fc  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000100  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000104  6d626564          DCB      0x6d,0x62,0x65,0x64
000108  6465643a          DCB      0x64,0x65,0x64,0x3a
00010c  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
000110  6f727953          DCB      0x6f,0x72,0x79,0x53
000114  7461636b          DCB      0x74,0x61,0x63,0x6b
000118  3a3a4973          DCB      0x3a,0x3a,0x49,0x73
00011c  56616c69          DCB      0x56,0x61,0x6c,0x69
000120  64282920          DCB      0x64,0x28,0x29,0x20
000124  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000128  7400              DCB      0x74,0x00
                  |symbol_number.89|
00012a  636f              DCB      0x63,0x6f
00012c  6e737420          DCB      0x6e,0x73,0x74,0x20
000130  766f6964          DCB      0x76,0x6f,0x69,0x64
000134  202a416e          DCB      0x20,0x2a,0x41,0x6e
000138  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00013c  456d6265          DCB      0x45,0x6d,0x62,0x65
000140  64646564          DCB      0x64,0x64,0x65,0x64
000144  3a3a4d65          DCB      0x3a,0x3a,0x4d,0x65
000148  6d6f7279          DCB      0x6d,0x6f,0x72,0x79
00014c  53746163          DCB      0x53,0x74,0x61,0x63
000150  6b436f6e          DCB      0x6b,0x43,0x6f,0x6e
000154  73744974          DCB      0x73,0x74,0x49,0x74
000158  65726174          DCB      0x65,0x72,0x61,0x74
00015c  6f723a3a          DCB      0x6f,0x72,0x3a,0x3a
000160  4765744e          DCB      0x47,0x65,0x74,0x4e
000164  65787428          DCB      0x65,0x78,0x74,0x28
000168  7369676e          DCB      0x73,0x69,0x67,0x6e
00016c  65642069          DCB      0x65,0x64,0x20,0x69
000170  6e742026          DCB      0x6e,0x74,0x20,0x26
000174  2c20626f          DCB      0x2c,0x20,0x62,0x6f
000178  6f6c2900          DCB      0x6f,0x6c,0x29,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  49662066          DCB      "If fully allocated, the %dth byte of the buffer must be"
000004  756c6c79
000008  20616c6c
00000c  6f636174
000010  65642c20
000014  74686520
000018  25647468
00001c  20627974
000020  65206f66
000024  20746865
000028  20627566
00002c  66657220
000030  6d757374
000034  206265  
000037  20256420          DCB      " %d byte aligned",0
00003b  62797465
00003f  20616c69
000043  676e6564
000047  00      
000048  2869643a          DCB      "(id:%d totalBytes:%d usedBytes:%d maxAllocationBytes:%d"
00004c  25642074
000050  6f74616c
000054  42797465
000058  733a2564
00005c  20757365
000060  64427974
000064  65733a25
000068  64206d61
00006c  78416c6c
000070  6f636174
000074  696f6e42
000078  79746573
00007c  3a2564  
00007f  20627566          DCB      " bufferLocation:%d) ",0
000083  6665724c
000087  6f636174
00008b  696f6e3a
00008f  25642920
000093  00      
000094  54686520          DCB      "The segmentLength is not a multiple of MEMORY_ALIGNMENT"
000098  7365676d
00009c  656e744c
0000a0  656e6774
0000a4  68206973
0000a8  206e6f74
0000ac  2061206d
0000b0  756c7469
0000b4  706c6520
0000b8  6f66204d
0000bc  454d4f52
0000c0  595f414c
0000c4  49474e4d
0000c8  454e54  
0000cb  20282578          DCB      " (%x!=%x)",0
0000cf  213d2578
0000d3  2900    
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
0000d8  54686520          DCB      "The segment end is beyond the end of the buffer. segmen"
0000dc  7365676d
0000e0  656e7420
0000e4  656e6420
0000e8  69732062
0000ec  65796f6e
0000f0  64207468
0000f4  6520656e
0000f8  64206f66
0000fc  20746865
000100  20627566
000104  6665722e
000108  20736567
00010c  6d656e  
00010f  744c656e          DCB      "tLength=%d (0x%x) usedBytes=%d all=%d",0
000113  6774683d
000117  25642028
00011b  30782578
00011f  29207573
000123  65644279
000127  7465733d
00012b  25642061
00012f  6c6c3d25
000133  6400    

                          AREA ||.data||, DATA, ALIGN=2

                  maxId
                          DCD      0x00000000
