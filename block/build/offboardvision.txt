; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\offboardvision.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\offboardvision.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DANKICORETECH_EMBEDDED_USE_HEATSHRINK -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\offboardvision.crf supervisor\src\offboardVision.cpp]
                          THUMB

                          AREA ||i._ZN4Anki5Cozmo3HAL17USBGetNextMessageEPh||, CODE, READONLY, ALIGN=1

                  _ZN4Anki5Cozmo3HAL17USBGetNextMessageEPh PROC ; Anki::Cozmo::HAL::USBGetNextMessage(unsigned char*)
;;;159        // hardware vs. simulator either.
;;;160        Messages::ID HAL::USBGetNextMessage(u8 *buffer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;161        {
000004  4606              MOV      r6,r0
;;;162          // Note that this is looking for a packet that starts with a 4-byte
;;;163          // header plus a message ID byte.  Unlike the packets we are sending
;;;164          // out with USBSendFrame and USBSendMessage, there is no footer.
;;;165          
;;;166          Messages::ID retVal = Messages::NO_MESSAGE_ID;
000006  2400              MOVS     r4,#0
;;;167          
;;;168          //PRINT("USBGetNextPacket(): %d bytes available to read.\n", USBGetNumBytesToRead());
;;;169          
;;;170          // We need there to be at least 5 bytes: 4 for the USB packet header, and
;;;171          // 1 for the msgID
;;;172          if(USBGetNumBytesToRead() > 5)
000008  f7fffffe          BL       _ZN4Anki5Cozmo3HAL20USBGetNumBytesToReadEv ; Anki::Cozmo::HAL::USBGetNumBytesToRead()
00000c  2805              CMP      r0,#5
00000e  d916              BLS      |L1.62|
;;;173          {
;;;174            // Peek at the next four bytes to see if we have a header waiting
;;;175            if(USBPeekChar(0) == USB_PACKET_HEADER[0] &&
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       _ZN4Anki5Cozmo3HAL11USBPeekCharEj ; Anki::Cozmo::HAL::USBPeekChar(unsigned)
000016  28be              CMP      r0,#0xbe
000018  d10e              BNE      |L1.56|
;;;176               USBPeekChar(1) == USB_PACKET_HEADER[1] &&
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       _ZN4Anki5Cozmo3HAL11USBPeekCharEj ; Anki::Cozmo::HAL::USBPeekChar(unsigned)
000020  28ef              CMP      r0,#0xef
000022  d109              BNE      |L1.56|
;;;177               USBPeekChar(2) == USB_PACKET_HEADER[2] &&
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       _ZN4Anki5Cozmo3HAL11USBPeekCharEj ; Anki::Cozmo::HAL::USBPeekChar(unsigned)
00002a  28f0              CMP      r0,#0xf0
00002c  d104              BNE      |L1.56|
;;;178               USBPeekChar(3) == USB_PACKET_HEADER[3])
00002e  2003              MOVS     r0,#3
000030  f7fffffe          BL       _ZN4Anki5Cozmo3HAL11USBPeekCharEj ; Anki::Cozmo::HAL::USBPeekChar(unsigned)
000034  28ff              CMP      r0,#0xff
000036  d005              BEQ      |L1.68|
                  |L1.56|
;;;179            {
;;;180              // We have a header, so next byte (which we know is availale since
;;;181              // we had 5 bytes to read above) will be the message ID.  We can
;;;182              // then look up the size of the incoming message to see if we have it
;;;183              // all available.
;;;184              Messages::ID msgID = static_cast<Messages::ID>(USBPeekChar(4));
;;;185              const u8 size = Messages::GetSize(msgID);
;;;186              
;;;187              // Check to see if we have the whole message (plus ID) available
;;;188              // (note that GetNumBytesToRead() will be including the header, so
;;;189              //  we have to add 5 to size, which only includes the message
;;;190              //  itself, not the header bytes or ID byte)
;;;191              if(USBGetNumBytesToRead() >= (size + 5) )
;;;192              {
;;;193                // If we got here, we're going to read out the whole message into
;;;194                // the return buffer.  First, though, get rid of the header
;;;195                // bytes.
;;;196                
;;;197                // Toss the 4 header bytes and 1 msgID byte
;;;198                USBGetChar(); // BE
;;;199                USBGetChar(); // EF
;;;200                USBGetChar(); // F0
;;;201                USBGetChar(); // FF
;;;202                USBGetChar(); // msgID
;;;203                
;;;204                // Read out the message
;;;205                for(u8 i=0; i<size; ++i) {
;;;206                  buffer[i] = USBGetChar();
;;;207                }
;;;208                
;;;209                // Now that we've gotten a whole packet out, return the msg ID
;;;210                retVal = msgID;
;;;211                
;;;212              } // if enough bytes available
;;;213            } // if valid header
;;;214            else {
;;;215              // If we got here, we've got at least 4 bytes available, but they
;;;216              // are not a valid header, so toss the first one as garbage, so we
;;;217              // at least keep moving through what's available on subsequent calls
;;;218              // (Note that we could just be off by one, with the 4 available bytes
;;;219              //  being 0xXX, 0xBE, 0xEF, 0xF0, so we just want to toss that first
;;;220              //  0xXX byte, so that the next time around we will get 0xBEEFF0FF)
;;;221              USBGetChar();
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10USBGetCharEj ; Anki::Cozmo::HAL::USBGetChar(unsigned)
                  |L1.62|
;;;222            }
;;;223          } // if at least 5 bytes available
;;;224          
;;;225          return retVal;
00003e  4620              MOV      r0,r4
;;;226          
;;;227        } // USBGetNextMessage()
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L1.68|
000044  2004              MOVS     r0,#4                 ;184
000046  f7fffffe          BL       _ZN4Anki5Cozmo3HAL11USBPeekCharEj ; Anki::Cozmo::HAL::USBPeekChar(unsigned)
00004a  b2c7              UXTB     r7,r0                 ;184
00004c  4638              MOV      r0,r7                 ;185
00004e  f7fffffe          BL       _ZN4Anki5Cozmo8Messages7GetSizeENS1_2IDE ; Anki::Cozmo::Messages::GetSize(Anki::Cozmo::Messages::ID)
000052  4605              MOV      r5,r0                 ;185
000054  f7fffffe          BL       _ZN4Anki5Cozmo3HAL20USBGetNumBytesToReadEv ; Anki::Cozmo::HAL::USBGetNumBytesToRead()
000058  1d69              ADDS     r1,r5,#5              ;191
00005a  4288              CMP      r0,r1                 ;191
00005c  d3ef              BCC      |L1.62|
00005e  2000              MOVS     r0,#0                 ;198
000060  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10USBGetCharEj ; Anki::Cozmo::HAL::USBGetChar(unsigned)
000064  2000              MOVS     r0,#0                 ;199
000066  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10USBGetCharEj ; Anki::Cozmo::HAL::USBGetChar(unsigned)
00006a  2000              MOVS     r0,#0                 ;200
00006c  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10USBGetCharEj ; Anki::Cozmo::HAL::USBGetChar(unsigned)
000070  2000              MOVS     r0,#0                 ;201
000072  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10USBGetCharEj ; Anki::Cozmo::HAL::USBGetChar(unsigned)
000076  2000              MOVS     r0,#0                 ;202
000078  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10USBGetCharEj ; Anki::Cozmo::HAL::USBGetChar(unsigned)
00007c  2400              MOVS     r4,#0                 ;205
00007e  2d00              CMP      r5,#0                 ;205
000080  d907              BLS      |L1.146|
                  |L1.130|
000082  2000              MOVS     r0,#0                 ;206
000084  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10USBGetCharEj ; Anki::Cozmo::HAL::USBGetChar(unsigned)
000088  5530              STRB     r0,[r6,r4]            ;206
00008a  1c60              ADDS     r0,r4,#1              ;205
00008c  b2c4              UXTB     r4,r0                 ;205
00008e  42a5              CMP      r5,r4                 ;205
000090  d8f7              BHI      |L1.130|
                  |L1.146|
000092  463c              MOV      r4,r7                 ;210
000094  e7d3              B        |L1.62|
;;;228        
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki5Cozmo3HAL17USBGetNextMessageEPh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo3HAL17USBGetNextMessageEPh||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  _ZN4Anki5Cozmo17USB_PACKET_HEADERE ; Anki::Cozmo::USB_PACKET_HEADER
000000  beeff0ff          DCB      0xbe,0xef,0xf0,0xff
