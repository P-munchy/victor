; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\offboardvisionsystem.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\offboardvisionsystem.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\offboardvisionsystem.crf supervisor\src\offboardVisionSystem.cpp]
                          THUMB

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem12StopTrackingEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem12StopTrackingEv PROC ; Anki::Cozmo::VisionSystem::StopTracking()
;;;1190         
;;;1191         void StopTracking()
000000  b084              SUB      sp,sp,#0x10
;;;1192         {
;;;1193           SetMarkerToTrack(Vision::MARKER_UNKNOWN, 0.f, true);
000002  20fd              MOVS     r0,#0xfd
000004  490d              LDR      r1,|L1.60|
000006  f88d0008          STRB     r0,[sp,#8]
00000a  eebf0a00          VMOV.F32 s0,#-1.00000000
00000e  eddf0a0a          VLDR     s1,|L1.56|
000012  ed8d0a01          VSTR     s0,[sp,#4]
000016  7008              STRB     r0,[r1,#0]
000018  edc10a01          VSTR     s1,[r1,#4]
00001c  ed810a02          VSTR     s0,[r1,#8]
000020  eddd0a01          VLDR     s1,[sp,#4]
000024  2201              MOVS     r2,#1
000026  edc10a03          VSTR     s1,[r1,#0xc]
00002a  ed810a04          VSTR     s0,[r1,#0x10]
00002e  750a              STRB     r2,[r1,#0x14]
000030  4903              LDR      r1,|L1.64|
000032  710a              STRB     r2,[r1,#4]
;;;1194         }
000034  b004              ADD      sp,sp,#0x10
000036  4770              BX       lr
;;;1195         
                          ENDP

                  |L1.56|
000038  00000000          DCFS     0x00000000 ; 0
                  |L1.60|
                          DCD      ||.bss||+0x1404
                  |L1.64|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem12TakeSnapshotENS_8Embedded9RectangleIiEEiRNS2_5ArrayIhEERb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem12TakeSnapshotENS_8Embedded9RectangleIiEEiRNS2_5ArrayIhEERb PROC ; Anki::Cozmo::VisionSystem::TakeSnapshot(Anki::Embedded::Rectangle<int>, int, Anki::Embedded::Array<unsigned char>&, bool&)
;;;1370         
;;;1371         Result TakeSnapshot(const Embedded::Rectangle<s32> roi, const s32 subsample,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1372                             Embedded::Array<u8>& snapshot, bool& readyFlag)
;;;1373         {
;;;1374           if(!isWaitingOnSnapshot_)
000004  4c3d              LDR      r4,|L2.252|
000006  4684              MOV      r12,r0                ;1373
000008  b088              SUB      sp,sp,#0x20           ;1373
00000a  7b20              LDRB     r0,[r4,#0xc]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754720isWaitingOnSnapshot_E
00000c  461d              MOV      r5,r3                 ;1373
00000e  2800              CMP      r0,#0
000010  f0408070          BNE.W    |L2.244|
;;;1375           {
;;;1376             snapshotROI_ = roi;
000014  483a              LDR      r0,|L2.256|
000016  f8dc3000          LDR      r3,[r12,#0]
;;;1377             
;;;1378             snapshotSubsample_ = subsample;
;;;1379             AnkiConditionalErrorAndReturnValue(snapshotSubsample_ >= 1,
00001a  4e3a              LDR      r6,|L2.260|
00001c  6003              STR      r3,[r0,#0]
00001e  f8dc3004          LDR      r3,[r12,#4]
000022  6043              STR      r3,[r0,#4]
000024  f8dc3008          LDR      r3,[r12,#8]
000028  6083              STR      r3,[r0,#8]
00002a  f8dc300c          LDR      r3,[r12,#0xc]
00002e  60c3              STR      r3,[r0,#0xc]          ;1378
000030  6421              STR      r1,[r4,#0x40]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754718snapshotSubsample_E
000032  2901              CMP      r1,#1
000034  da0f              BGE      |L2.86|
000036  f2405063          MOV      r0,#0x563
00003a  9600              STR      r6,[sp,#0]
00003c  e9cd0101          STRD     r0,r1,[sp,#4]
000040  a331              ADR      r3,|L2.264|
000042  a23b              ADR      r2,|L2.304|
000044  a145              ADR      r1,|L2.348|
000046  2005              MOVS     r0,#5
000048  f7fffffe          BL       _Anki_Log
;;;1380                                                RESULT_FAIL_INVALID_PARAMETER,
;;;1381                                                "VisionSystem::TakeSnapshot()",
;;;1382                                                "Subsample must be >= 1. %d was specified!\n", snapshotSubsample_);
;;;1383   
;;;1384             snapshot_ = &snapshot;
;;;1385             
;;;1386             AnkiConditionalErrorAndReturnValue(snapshot_ != NULL, RESULT_FAIL_INVALID_OBJECT,
;;;1387                                                "VisionSystem::TakeSnapshot()", "NULL snapshot pointer!\n");
;;;1388             
;;;1389             AnkiConditionalErrorAndReturnValue(snapshot_->IsValid(),
;;;1390                                                RESULT_FAIL_INVALID_OBJECT,
;;;1391                                                "VisionSystem::TakeSnapshot()", "Invalid snapshot array!\n");
;;;1392             
;;;1393             const s32 nrowsSnap = snapshot_->get_size(0);
;;;1394             const s32 ncolsSnap = snapshot_->get_size(1);
;;;1395             
;;;1396             AnkiConditionalErrorAndReturnValue(nrowsSnap*snapshotSubsample_ == snapshotROI_.get_height() &&
;;;1397                                                ncolsSnap*snapshotSubsample_ == snapshotROI_.get_width(),
;;;1398                                                RESULT_FAIL_INVALID_SIZE,
;;;1399                                                "VisionSystem::TakeSnapshot()",
;;;1400                                                "Snapshot ROI size (%dx%d) subsampled by %d doesn't match snapshot array size (%dx%d)!\n",
;;;1401                                                snapshotROI_.get_height(), snapshotROI_.get_width(), snapshotSubsample_, nrowsSnap, ncolsSnap);
;;;1402             
;;;1403             isSnapshotReady_ = &readyFlag;
;;;1404             
;;;1405             AnkiConditionalErrorAndReturnValue(isSnapshotReady_ != NULL,
;;;1406                                                RESULT_FAIL_INVALID_OBJECT,
;;;1407                                                "VisionSystem::TakeSnapshot()",
;;;1408                                                "NULL isSnapshotReady pointer!\n");
;;;1409           
;;;1410             isWaitingOnSnapshot_ = true;
;;;1411             
;;;1412           } // if !isWaitingOnSnapshot_
;;;1413           
;;;1414           return RESULT_OK;
;;;1415         } // TakeSnapshot()
00004c  b008              ADD      sp,sp,#0x20
00004e  f04f7040          MOV      r0,#0x3000000         ;1379
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L2.86|
000056  6462              STR      r2,[r4,#0x44]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff75479snapshot_E
000058  6910              LDR      r0,[r2,#0x10]
00005a  2800              CMP      r0,#0
00005c  d038              BEQ      |L2.208|
00005e  6810              LDR      r0,[r2,#0]            ;1386
000060  2800              CMP      r0,#0                 ;1386
000062  db35              BLT      |L2.208|
000064  6850              LDR      r0,[r2,#4]            ;1386
000066  2800              CMP      r0,#0                 ;1386
000068  db32              BLT      |L2.208|
00006a  2100              MOVS     r1,#0                 ;1393
00006c  4610              MOV      r0,r2                 ;1393
00006e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000072  4607              MOV      r7,r0                 ;1393
000074  2101              MOVS     r1,#1                 ;1394
000076  6c60              LDR      r0,[r4,#0x44]         ;1394  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff75479snapshot_E
000078  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00007c  4b20              LDR      r3,|L2.256|
00007e  e9d32102          LDRD     r2,r1,[r3,#8]         ;1394
000082  1a8a              SUBS     r2,r1,r2              ;1394
000084  6c21              LDR      r1,[r4,#0x40]         ;1396  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754718snapshotSubsample_E
000086  fb07fc01          MUL      r12,r7,r1             ;1396
00008a  4562              CMP      r2,r12                ;1396
00008c  d107              BNE      |L2.158|
00008e  e9d38c00          LDRD     r8,r12,[r3,#0]        ;1396
000092  ebac0c08          SUB      r12,r12,r8            ;1396
000096  fb00f801          MUL      r8,r0,r1              ;1396
00009a  45c4              CMP      r12,r8                ;1396
00009c  d027              BEQ      |L2.238|
                  |L2.158|
00009e  f8d3c004          LDR      r12,[r3,#4]           ;1396
0000a2  681b              LDR      r3,[r3,#0]            ;1396
0000a4  e9cd7005          STRD     r7,r0,[sp,#0x14]      ;1396
0000a8  ebac0303          SUB      r3,r12,r3             ;1396
0000ac  9600              STR      r6,[sp,#0]            ;1396
0000ae  e9cd3103          STRD     r3,r1,[sp,#0xc]       ;1396
0000b2  f2405074          MOV      r0,#0x574             ;1396
0000b6  e9cd0201          STRD     r0,r2,[sp,#4]         ;1396
0000ba  a313              ADR      r3,|L2.264|
0000bc  4a2f              LDR      r2,|L2.380|
0000be  a127              ADR      r1,|L2.348|
0000c0  2005              MOVS     r0,#5                 ;1396
0000c2  f7fffffe          BL       _Anki_Log
0000c6  b008              ADD      sp,sp,#0x20
0000c8  f04f60a0          MOV      r0,#0x5000000         ;1396
0000cc  e8bd81f0          POP      {r4-r8,pc}
                  |L2.208|
0000d0  f240506d          MOV      r0,#0x56d             ;1389
0000d4  e9cd6000          STRD     r6,r0,[sp,#0]         ;1389
0000d8  a30b              ADR      r3,|L2.264|
0000da  a229              ADR      r2,|L2.384|
0000dc  a11f              ADR      r1,|L2.348|
0000de  2005              MOVS     r0,#5                 ;1389
0000e0  f7fffffe          BL       _Anki_Log
0000e4  b008              ADD      sp,sp,#0x20
0000e6  f04f6080          MOV      r0,#0x4000000         ;1389
0000ea  e8bd81f0          POP      {r4-r8,pc}
                  |L2.238|
0000ee  2001              MOVS     r0,#1                 ;1410
0000f0  63e5              STR      r5,[r4,#0x3c]         ;1410  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754716isSnapshotReady_E
0000f2  7320              STRB     r0,[r4,#0xc]          ;1410
                  |L2.244|
0000f4  b008              ADD      sp,sp,#0x20
0000f6  2000              MOVS     r0,#0                 ;1414
0000f8  e8bd81f0          POP      {r4-r8,pc}
;;;1416         
                          ENDP

                  |L2.252|
                          DCD      ||.data||
                  |L2.256|
                          DCD      ||.bss||+0x15b8
                  |L2.260|
                          DCD      ||.constdata||+0x1df
                  |L2.264|
000108  73757065          DCB      "supervisor\\src\\offboardVisionSystem.cpp",0
00010c  72766973
000110  6f725c73
000114  72635c6f
000118  6666626f
00011c  61726456
000120  6973696f
000124  6e537973
000128  74656d2e
00012c  63707000
                  |L2.304|
000130  53756273          DCB      "Subsample must be >= 1. %d was specified!\n",0
000134  616d706c
000138  65206d75
00013c  73742062
000140  65203e3d
000144  20312e20
000148  25642077
00014c  61732073
000150  70656369
000154  66696564
000158  210a00  
00015b  00                DCB      0
                  |L2.348|
00015c  56697369          DCB      "VisionSystem::TakeSnapshot()",0
000160  6f6e5379
000164  7374656d
000168  3a3a5461
00016c  6b65536e
000170  61707368
000174  6f742829
000178  00      
000179  00                DCB      0
00017a  00                DCB      0
00017b  00                DCB      0
                  |L2.380|
                          DCD      ||.conststring||
                  |L2.384|
000180  496e7661          DCB      "Invalid snapshot array!\n",0
000184  6c696420
000188  736e6170
00018c  73686f74
000190  20617272
000194  6179210a
000198  00      
000199  00                DCB      0
00019a  00                DCB      0
00019b  00                DCB      0

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv PROC ; Anki::Cozmo::VisionSystem::VisionMemory::ResetBuffers()
;;;94             // WARNING: ResetBuffers should be used with caution
;;;95             static Result ResetBuffers()
000000  b570              PUSH     {r4-r6,lr}
;;;96             {
000002  b096              SUB      sp,sp,#0x58
;;;97               ccmScratch_     = MemoryStack(ccmBuffer, CCM_BUFFER_SIZE);
000004  2201              MOVS     r2,#1
000006  2300              MOVS     r3,#0
000008  4611              MOV      r1,r2
00000a  a814              ADD      r0,sp,#0x50
00000c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000010  6803              LDR      r3,[r0,#0]
000012  f2413288          MOV      r2,#0x1388
000016  491f              LDR      r1,|L3.148|
000018  a80d              ADD      r0,sp,#0x34
00001a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
00001e  e890107d          LDM      r0,{r0,r2-r6,r12}
000022  491d              LDR      r1,|L3.152|
000024  e881107d          STM      r1,{r0,r2-r6,r12}
;;;98     
;;;99               if(!ccmScratch_.IsValid()) {
000028  4608              MOV      r0,r1
00002a  f7fffffe          BL       _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
00002e  2800              CMP      r0,#0
000030  d02a              BEQ      |L3.136|
;;;100                PRINT("Error: InitializeScratchBuffers\n");
;;;101                return RESULT_FAIL;
;;;102              }
;;;103    
;;;104              markers_ = FixedLengthList<VisionMarker>(VisionMemory::MAX_MARKERS, ccmScratch_);
000032  2300              MOVS     r3,#0
000034  4d19              LDR      r5,|L3.156|
000036  461a              MOV      r2,r3
000038  2101              MOVS     r1,#1
00003a  a814              ADD      r0,sp,#0x50
00003c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000040  6803              LDR      r3,[r0,#0]
000042  f1a5021c          SUB      r2,r5,#0x1c
000046  2164              MOVS     r1,#0x64
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00004e  e9d01200          LDRD     r1,r2,[r0,#0]
000052  6883              LDR      r3,[r0,#8]
000054  60ab              STR      r3,[r5,#8]
000056  e9c51200          STRD     r1,r2,[r5,#0]
00005a  e9d01203          LDRD     r1,r2,[r0,#0xc]
00005e  6943              LDR      r3,[r0,#0x14]
000060  616b              STR      r3,[r5,#0x14]
000062  e9c51203          STRD     r1,r2,[r5,#0xc]
000066  6981              LDR      r1,[r0,#0x18]
000068  61a9              STR      r1,[r5,#0x18]
00006a  69c1              LDR      r1,[r0,#0x1c]
00006c  61e9              STR      r1,[r5,#0x1c]
00006e  6a01              LDR      r1,[r0,#0x20]
000070  6229              STR      r1,[r5,#0x20]
000072  6a41              LDR      r1,[r0,#0x24]
000074  6269              STR      r1,[r5,#0x24]
000076  6a81              LDR      r1,[r0,#0x28]
000078  62a9              STR      r1,[r5,#0x28]
00007a  6ac1              LDR      r1,[r0,#0x2c]
00007c  62e9              STR      r1,[r5,#0x2c]
00007e  6b00              LDR      r0,[r0,#0x30]
;;;105    
;;;106              return RESULT_OK;
000080  6328              STR      r0,[r5,#0x30]
;;;107            }
000082  b016              ADD      sp,sp,#0x58
000084  2000              MOVS     r0,#0                 ;106
000086  bd70              POP      {r4-r6,pc}
                  |L3.136|
000088  a005              ADR      r0,|L3.160|
00008a  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
00008e  b016              ADD      sp,sp,#0x58
000090  2001              MOVS     r0,#1                 ;101
000092  bd70              POP      {r4-r6,pc}
;;;108    
                          ENDP

                  |L3.148|
                          DCD      ||.bss||
                  |L3.152|
                          DCD      ||.bss||+0x1388
                  |L3.156|
                          DCD      ||.bss||+0x13a4
                  |L3.160|
0000a0  4572726f          DCB      "Error: InitializeScratchBuffers\n",0
0000a4  723a2049
0000a8  6e697469
0000ac  616c697a
0000b0  65536372
0000b4  61746368
0000b8  42756666
0000bc  6572730a
0000c0  00      
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem14GetVerticalFOVEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem14GetVerticalFOVEv PROC ; Anki::Cozmo::VisionSystem::GetVerticalFOV()
;;;1070   
;;;1071         f32 GetVerticalFOV() {
000000  4801              LDR      r0,|L4.8|
;;;1072           return headCamFOV_ver_;
000002  ed900a0a          VLDR     s0,[r0,#0x28]
;;;1073         }
000006  4770              BX       lr
;;;1074   
                          ENDP

                  |L4.8|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem16DownsampleHelperERKNS_8Embedded5ArrayIhEERS4_NS2_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem16DownsampleHelperERKNS_8Embedded5ArrayIhEERS4_NS2_11MemoryStackE PROC ; Anki::Cozmo::VisionSystem::DownsampleHelper(const Anki::Embedded::Array<unsigned char>&, Anki::Embedded::Array<unsigned char>&, Anki::Embedded::MemoryStack)
;;;1032   
;;;1033         u32 DownsampleHelper(const Array<u8>& in,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1034           Array<u8>& out,
;;;1035           MemoryStack scratch)
;;;1036         {
000004  460c              MOV      r4,r1
000006  b088              SUB      sp,sp,#0x20
000008  4617              MOV      r7,r2
00000a  4605              MOV      r5,r0
;;;1037           const s32 inWidth  = in.get_size(1);
00000c  2101              MOVS     r1,#1
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000012  4606              MOV      r6,r0
;;;1038           //const s32 inHeight = in.get_size(0);
;;;1039   
;;;1040           const s32 outWidth  = out.get_size(1);
000014  2101              MOVS     r1,#1
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
;;;1041           //const s32 outHeight = out.get_size(0);
;;;1042   
;;;1043           const u32 downsampleFactor = inWidth / outWidth;
00001c  fb96f6f0          SDIV     r6,r6,r0
;;;1044   
;;;1045           const u32 downsamplePower = Log2u32(downsampleFactor);
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       Log2u32
000026  ea5f0800          MOVS     r8,r0
;;;1046   
;;;1047           if(downsamplePower > 0) {
00002a  d00a              BEQ      |L5.66|
;;;1048             //PRINT("Downsampling [%d x %d] frame by %d.\n", inWidth, inHeight, (1 << downsamplePower));
;;;1049   
;;;1050             ImageProcessing::DownsampleByPowerOfTwo<u8,u32,u8>(in,
00002c  4639              MOV      r1,r7
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000034  4603              MOV      r3,r0
000036  4622              MOV      r2,r4
000038  4641              MOV      r1,r8
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       _ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)
;;;1051               downsamplePower,
;;;1052               out,
;;;1053               scratch);
;;;1054           } else {
000040  e055              B        |L5.238|
                  |L5.66|
000042  2100              MOVS     r1,#0
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00004a  4607              MOV      r7,r0
00004c  2101              MOVS     r1,#1
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000054  4602              MOV      r2,r0
000056  4b28              LDR      r3,|L5.248|
000058  6920              LDR      r0,[r4,#0x10]
00005a  b318              CBZ      r0,|L5.164|
00005c  6820              LDR      r0,[r4,#0]
00005e  2800              CMP      r0,#0
000060  bfa4              ITT      GE
000062  6861              LDRGE    r1,[r4,#4]
000064  2900              CMPGE    r1,#0
000066  db1d              BLT      |L5.164|
000068  f8d5c010          LDR      r12,[r5,#0x10]
00006c  f1bc0f00          CMP      r12,#0
000070  d018              BEQ      |L5.164|
000072  f8d5c000          LDR      r12,[r5,#0]
000076  f1bc0f00          CMP      r12,#0
00007a  bfa4              ITT      GE
00007c  f8d5c004          LDRGE    r12,[r5,#4]
000080  f1bc0f00          CMPGE    r12,#0
000084  db0e              BLT      |L5.164|
000086  42b8              CMP      r0,r7
000088  bf08              IT       EQ
00008a  4291              CMPEQ    r1,r2
00008c  d015              BEQ      |L5.186|
00008e  f44f7027          MOV      r0,#0x29c
000092  e9cd3000          STRD     r3,r0,[sp,#0]
000096  4b19              LDR      r3,|L5.252|
000098  4a19              LDR      r2,|L5.256|
00009a  491a              LDR      r1,|L5.260|
00009c  2005              MOVS     r0,#5
00009e  f7fffffe          BL       _Anki_Log
0000a2  e024              B        |L5.238|
                  |L5.164|
0000a4  f2402099          MOV      r0,#0x299
0000a8  e9cd3000          STRD     r3,r0,[sp,#0]
0000ac  4b13              LDR      r3,|L5.252|
0000ae  4a16              LDR      r2,|L5.264|
0000b0  4914              LDR      r1,|L5.260|
0000b2  2005              MOVS     r0,#5
0000b4  f7fffffe          BL       _Anki_Log
0000b8  e019              B        |L5.238|
                  |L5.186|
0000ba  2100              MOVS     r1,#0
0000bc  2800              CMP      r0,#0
0000be  dd16              BLE      |L5.238|
                  |L5.192|
0000c0  68aa              LDR      r2,[r5,#8]
0000c2  6928              LDR      r0,[r5,#0x10]
0000c4  fb010c02          MLA      r12,r1,r2,r0
0000c8  68a2              LDR      r2,[r4,#8]
0000ca  6920              LDR      r0,[r4,#0x10]
0000cc  fb010302          MLA      r3,r1,r2,r0
0000d0  6862              LDR      r2,[r4,#4]
0000d2  2000              MOVS     r0,#0
0000d4  2a00              CMP      r2,#0
0000d6  dd06              BLE      |L5.230|
                  |L5.216|
0000d8  f81c2000          LDRB     r2,[r12,r0]
0000dc  541a              STRB     r2,[r3,r0]
0000de  6862              LDR      r2,[r4,#4]
0000e0  1c40              ADDS     r0,r0,#1
0000e2  4282              CMP      r2,r0
0000e4  dcf8              BGT      |L5.216|
                  |L5.230|
0000e6  6820              LDR      r0,[r4,#0]
0000e8  1c49              ADDS     r1,r1,#1
0000ea  4288              CMP      r0,r1
0000ec  dce8              BGT      |L5.192|
                  |L5.238|
;;;1055             // No need to downsample, just copy the buffer
;;;1056             out.Set(in);
;;;1057           }
;;;1058   
;;;1059           return downsampleFactor;
;;;1060         }
0000ee  b008              ADD      sp,sp,#0x20
0000f0  4630              MOV      r0,r6                 ;1059
0000f2  e8bd81f0          POP      {r4-r8,pc}
;;;1061   
                          ENDP

0000f6  0000              DCW      0x0000
                  |L5.248|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
                  |L5.252|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs_1 ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::string (instance 3)
                  |L5.256|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs_2 ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::string (instance 4)
                  |L5.260|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::string
                  |L5.264|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs_0 ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::string (instance 2)

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem16GetHorizontalFOVEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem16GetHorizontalFOVEv PROC ; Anki::Cozmo::VisionSystem::GetHorizontalFOV()
;;;1074   
;;;1075         f32 GetHorizontalFOV() {
000000  4801              LDR      r0,|L6.8|
;;;1076           return headCamFOV_hor_;
000002  ed900a0b          VLDR     s0,[r0,#0x2c]
;;;1077         }
000006  4770              BX       lr
;;;1078   
                          ENDP

                  |L6.8|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem16SetImageSendModeENS0_15ImageSendMode_tENS_6Vision16CameraResolutionE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem16SetImageSendModeENS0_15ImageSendMode_tENS_6Vision16CameraResolutionE PROC ; Anki::Cozmo::VisionSystem::SetImageSendMode(Anki::Cozmo::ImageSendMode_t, Anki::Vision::CameraResolution)
;;;408    
;;;409          void SetImageSendMode(ImageSendMode_t mode, Vision::CameraResolution res)
000000  2907              CMP      r1,#7
;;;410          {
;;;411            if (res == Vision::CAMERA_RES_QVGA ||
;;;412              res == Vision::CAMERA_RES_QQVGA ||
000002  bf18              IT       NE
000004  2908              CMPNE    r1,#8
000006  d003              BEQ      |L7.16|
;;;413              res == Vision::CAMERA_RES_QQQVGA ||
000008  2909              CMP      r1,#9
;;;414              res == Vision::CAMERA_RES_QQQQVGA) {
00000a  bf1c              ITT      NE
00000c  290a              CMPNE    r1,#0xa
;;;415                imageSendMode_ = mode;
;;;416                nextSendImageResolution_ = res;
;;;417            }
;;;418          }
00000e  4770              BXNE     lr
                  |L7.16|
000010  4a01              LDR      r2,|L7.24|
000012  7150              STRB     r0,[r2,#5]            ;415
000014  7191              STRB     r1,[r2,#6]            ;416
000016  4770              BX       lr
;;;419    
                          ENDP

                  |L7.24|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfRKNS_8Embedded5PointIfEEfb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfRKNS_8Embedded5PointIfEEfb PROC ; Anki::Cozmo::VisionSystem::SetMarkerToTrack(const Anki::Vision::MarkerType&, float, const Anki::Embedded::Point<float>&, float, bool)
;;;1168   
;;;1169         Result SetMarkerToTrack(const Vision::MarkerType& markerTypeToTrack,
000000  4b0a              LDR      r3,|L8.44|
;;;1170                                 const f32 markerWidth_mm,
;;;1171                                 const Point2f& atImageCenter,
;;;1172                                 const f32 imageSearchRadius,
;;;1173                                 const bool checkAngleX)
;;;1174         {
;;;1175           newMarkerToTrack_.type              = markerTypeToTrack;
000002  7800              LDRB     r0,[r0,#0]
000004  7018              STRB     r0,[r3,#0]
;;;1176           newMarkerToTrack_.width_mm          = markerWidth_mm;
000006  ed830a01          VSTR     s0,[r3,#4]
00000a  ed910a00          VLDR     s0,[r1,#0]
;;;1177           newMarkerToTrack_.imageCenter       = atImageCenter;
;;;1178           newMarkerToTrack_.imageSearchRadius = imageSearchRadius;
;;;1179           newMarkerToTrack_.checkAngleX       = checkAngleX;
;;;1180           
;;;1181           // Next call to Update(), we will call UpdateMarkerToTrack() and
;;;1182           // actually replace the current markerToTrack_ with the one set here.
;;;1183           newMarkerToTrackWasProvided_ = true;
00000e  2001              MOVS     r0,#1
000010  ed830a02          VSTR     s0,[r3,#8]
000014  ed910a01          VLDR     s0,[r1,#4]
000018  4905              LDR      r1,|L8.48|
00001a  ed830a03          VSTR     s0,[r3,#0xc]
00001e  edc30a04          VSTR     s1,[r3,#0x10]         ;1178
000022  751a              STRB     r2,[r3,#0x14]         ;1179
000024  7108              STRB     r0,[r1,#4]
;;;1184           
;;;1185           // Send a message up to basestation vision to start tracking:
;;;1186           //HAL::RadioSendMessage(<#const Messages::ID msgID#>, <#const void *buffer#>)
;;;1187           
;;;1188           return RESULT_OK;
000026  2000              MOVS     r0,#0
;;;1189         }
000028  4770              BX       lr
;;;1190         
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      ||.bss||+0x1404
                  |L8.48|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfb PROC ; Anki::Cozmo::VisionSystem::SetMarkerToTrack(const Anki::Vision::MarkerType&, float, bool)
;;;1158   
;;;1159         Result SetMarkerToTrack(const Vision::MarkerType& markerTypeToTrack,
000000  b082              SUB      sp,sp,#8
;;;1160                                 const f32 markerWidth_mm,
;;;1161                                 const bool checkAngleX)
;;;1162         {
;;;1163           const Point2f imageCenter(-1.f, -1.f);
000002  eeff0a00          VMOV.F32 s1,#-1.00000000
000006  edcd0a00          VSTR     s1,[sp,#0]
00000a  4a0b              LDR      r2,|L9.56|
00000c  edcd0a01          VSTR     s1,[sp,#4]
000010  7800              LDRB     r0,[r0,#0]
000012  7010              STRB     r0,[r2,#0]
000014  ed820a01          VSTR     s0,[r2,#4]
000018  edc20a02          VSTR     s1,[r2,#8]
00001c  ed9d0a01          VLDR     s0,[sp,#4]
000020  2001              MOVS     r0,#1
000022  ed820a03          VSTR     s0,[r2,#0xc]
000026  edc20a04          VSTR     s1,[r2,#0x10]
00002a  7511              STRB     r1,[r2,#0x14]
00002c  4903              LDR      r1,|L9.60|
00002e  7108              STRB     r0,[r1,#4]
000030  2000              MOVS     r0,#0
;;;1164           const f32     searchRadius = -1.f;
;;;1165           return SetMarkerToTrack(markerTypeToTrack, markerWidth_mm,
;;;1166             imageCenter, searchRadius, checkAngleX);
;;;1167         }
000032  b002              ADD      sp,sp,#8
000034  4770              BX       lr
;;;1168   
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
                          DCD      ||.bss||+0x1404
                  |L9.60|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem19GetVisionMarkerPoseERKNS_8Embedded12VisionMarkerEbRNS2_5ArrayIfEERNS2_6Point3IfEE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem19GetVisionMarkerPoseERKNS_8Embedded12VisionMarkerEbRNS2_5ArrayIfEERNS2_6Point3IfEE PROC ; Anki::Cozmo::VisionSystem::GetVisionMarkerPose(const Anki::Embedded::VisionMarker&, bool, Anki::Embedded::Array<float>&, Anki::Embedded::Point3<float>&)
;;;1349   
;;;1350         Result GetVisionMarkerPose(const Embedded::VisionMarker& marker,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1351           const bool ignoreOrientation,
;;;1352           Embedded::Array<f32>&  rotation,
;;;1353           Embedded::Point3<f32>& translation)
;;;1354         {
000004  b094              SUB      sp,sp,#0x50
000006  461e              MOV      r6,r3
000008  4617              MOV      r7,r2
00000a  460c              MOV      r4,r1
00000c  4680              MOV      r8,r0
;;;1355           Quadrilateral<f32> sortedQuad;
00000e  a804              ADD      r0,sp,#0x10
000010  2304              MOVS     r3,#4
000012  2208              MOVS     r2,#8
000014  492d              LDR      r1,|L10.204|
000016  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
00001a  ed9f0a2d          VLDR     s0,|L10.208|
00001e  f04f0c00          MOV      r12,#0
                  |L10.34|
000022  ed8d0a00          VSTR     s0,[sp,#0]
000026  ed8d0a01          VSTR     s0,[sp,#4]
00002a  eb0002cc          ADD      r2,r0,r12,LSL #3
00002e  eddd0a00          VLDR     s1,[sp,#0]
000032  f10c0c01          ADD      r12,r12,#1
000036  edc20a00          VSTR     s1,[r2,#0]
00003a  eddd0a01          VLDR     s1,[sp,#4]
00003e  f1bc0f04          CMP      r12,#4
000042  edc20a01          VSTR     s1,[r2,#4]
000046  dbec              BLT      |L10.34|
;;;1356           if(ignoreOrientation) {
000048  2c00              CMP      r4,#0
;;;1357             sortedQuad = marker.corners.ComputeClockwiseCorners<f32>();
;;;1358           } else {
;;;1359             sortedQuad = marker.corners;
00004a  bf04              ITT      EQ
00004c  a804              ADDEQ    r0,sp,#0x10
00004e  f04f0c00          MOVEQ    r12,#0
000052  d016              BEQ      |L10.130|
000054  ac04              ADD      r4,sp,#0x10           ;1357
000056  4641              MOV      r1,r8                 ;1357
000058  a80c              ADD      r0,sp,#0x30           ;1357
00005a  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeClockwiseCorners<float>() const
00005e  ab0c              ADD      r3,sp,#0x30           ;1357
000060  2000              MOVS     r0,#0                 ;1357
                  |L10.98|
000062  eb0301c0          ADD      r1,r3,r0,LSL #3       ;1357
000066  eb0402c0          ADD      r2,r4,r0,LSL #3       ;1357
00006a  ed910a00          VLDR     s0,[r1,#0]            ;1357
00006e  1c40              ADDS     r0,r0,#1              ;1357
000070  ed820a00          VSTR     s0,[r2,#0]            ;1357
000074  ed910a01          VLDR     s0,[r1,#4]            ;1357
000078  2804              CMP      r0,#4                 ;1357
00007a  ed820a01          VSTR     s0,[r2,#4]            ;1357
00007e  dbf0              BLT      |L10.98|
000080  e010              B        |L10.164|
                  |L10.130|
000082  eb0804cc          ADD      r4,r8,r12,LSL #3      ;1357
000086  eb0005cc          ADD      r5,r0,r12,LSL #3      ;1357
00008a  ed940a00          VLDR     s0,[r4,#0]            ;1357
00008e  f10c0c01          ADD      r12,r12,#1            ;1357
000092  ed850a00          VSTR     s0,[r5,#0]            ;1357
000096  ed940a01          VLDR     s0,[r4,#4]            ;1357
00009a  f1bc0f04          CMP      r12,#4                ;1357
00009e  ed850a01          VSTR     s0,[r5,#4]            ;1357
0000a2  dbee              BLT      |L10.130|
                  |L10.164|
;;;1360           }
;;;1361   
;;;1362           return P3P::computePose(sortedQuad,
0000a4  480b              LDR      r0,|L10.212|
0000a6  e9cd0700          STRD     r0,r7,[sp,#0]
0000aa  480b              LDR      r0,|L10.216|
0000ac  9602              STR      r6,[sp,#8]
0000ae  6a40              LDR      r0,[r0,#0x24]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754712headCamInfo_E
0000b0  ec900a04          VLDM     r0,{s0-s3}
0000b4  4809              LDR      r0,|L10.220|
0000b6  f1000318          ADD      r3,r0,#0x18
0000ba  f100020c          ADD      r2,r0,#0xc
0000be  4601              MOV      r1,r0
0000c0  a804              ADD      r0,sp,#0x10
0000c2  f7fffffe          BL       _ZN4Anki8Embedded3P3P11computePoseIfEENS_6ResultERKNS0_13QuadrilateralIT_EERKNS0_6Point3IS5_EESC_SC_SC_ffffRNS0_5ArrayIS5_EERSA_ ; Anki::Embedded::P3P::computePose<float>(const Anki::Embedded::Quadrilateral<T1>&, const Anki::Embedded::Point3<T1>&, const Anki::Embedded::Point3<T1>&, const Anki::Embedded::Point3<T1>&, const Anki::Embedded::Point3<T1>&, float, float, float, float, Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)
;;;1363             canonicalMarker3d_[0], canonicalMarker3d_[1],
;;;1364             canonicalMarker3d_[2], canonicalMarker3d_[3],
;;;1365             headCamInfo_->focalLength_x, headCamInfo_->focalLength_y,
;;;1366             headCamInfo_->center_x, headCamInfo_->center_y,
;;;1367             rotation, translation);
;;;1368         } // GetVisionMarkerPose()
0000c6  b014              ADD      sp,sp,#0x50
0000c8  e8bd81f0          POP      {r4-r8,pc}
;;;1369         
                          ENDP

                  |L10.204|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()
                  |L10.208|
0000d0  00000000          DCFS     0x00000000 ; 0
                  |L10.212|
                          DCD      ||.bss||+0x1460
                  |L10.216|
                          DCD      ||.data||
                  |L10.220|
                          DCD      ||.bss||+0x143c

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem19SetFaceDetectParamsEfiiiii||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem19SetFaceDetectParamsEfiiiii PROC ; Anki::Cozmo::VisionSystem::SetFaceDetectParams(float, int, int, int, int, int)
;;;1727         
;;;1728         void SetFaceDetectParams(const f32 scaleFactor,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1729                                  const s32 minNeighbors,
;;;1730                                  const s32 minObjectHeight,
;;;1731                                  const s32 minObjectWidth,
;;;1732                                  const s32 maxObjectHeight,
;;;1733                                  const s32 maxObjectWidth)
;;;1734         {
000004  4604              MOV      r4,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  461f              MOV      r7,r3
00000c  4616              MOV      r6,r2
00000e  460d              MOV      r5,r1
000010  eeb08a40          VMOV.F32 s16,s0
;;;1735           PRINT("Updated VisionSystem FaceDetect params\n");
000014  a00a              ADR      r0,|L11.64|
000016  f8dd8020          LDR      r8,[sp,#0x20]
00001a  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;1736           faceDetectionParameters_.scaleFactor = scaleFactor;
00001e  ee180a10          VMOV     r0,s16
000022  f7fffffe          BL       __aeabi_f2d
000026  f8dfc040          LDR      r12,|L11.104|
00002a  e9cc0104          STRD     r0,r1,[r12,#0x10]
00002e  f10c0c18          ADD      r12,r12,#0x18
000032  e88c01f0          STM      r12,{r4-r8}
;;;1737           faceDetectionParameters_.minNeighbors = minNeighbors;
;;;1738           faceDetectionParameters_.minHeight = minObjectHeight;
;;;1739           faceDetectionParameters_.minWidth = minObjectWidth;
;;;1740           faceDetectionParameters_.maxHeight = maxObjectHeight;
;;;1741           faceDetectionParameters_.maxWidth = maxObjectWidth;
;;;1742         }
000036  ecbd8b02          VPOP     {d8}
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1743         
                          ENDP

00003e  0000              DCW      0x0000
                  |L11.64|
000040  55706461          DCB      "Updated VisionSystem FaceDetect params\n",0
000044  74656420
000048  56697369
00004c  6f6e5379
000050  7374656d
000054  20466163
000058  65446574
00005c  65637420
000060  70617261
000064  6d730a00
                  |L11.104|
                          DCD      ||.bss||+0x1588

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem19StartDetectingFacesEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem19StartDetectingFacesEv PROC ; Anki::Cozmo::VisionSystem::StartDetectingFaces()
;;;1195         
;;;1196         Result StartDetectingFaces()
000000  4902              LDR      r1,|L12.12|
;;;1197         {
;;;1198           mode_ = VISION_MODE_DETECTING_FACES;
000002  2004              MOVS     r0,#4
000004  7208              STRB     r0,[r1,#8]
;;;1199           return RESULT_OK;
000006  2000              MOVS     r0,#0
;;;1200         }
000008  4770              BX       lr
;;;1201   
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem20GetCameraCalibrationEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem20GetCameraCalibrationEv PROC ; Anki::Cozmo::VisionSystem::GetCameraCalibration()
;;;1061   
;;;1062         const HAL::CameraInfo* GetCameraCalibration() {
000000  4801              LDR      r0,|L13.8|
;;;1063           // TODO: is just returning the pointer to HAL's camera info struct kosher?
;;;1064           return headCamInfo_;
000002  6a40              LDR      r0,[r0,#0x24]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754712headCamInfo_E
;;;1065         }
000004  4770              BX       lr
;;;1066   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem21GetObservedMarkerListEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem21GetObservedMarkerListEv PROC ; Anki::Cozmo::VisionSystem::GetObservedMarkerList()
;;;1201   
;;;1202         const Embedded::FixedLengthList<Embedded::VisionMarker>& GetObservedMarkerList()
000000  4800              LDR      r0,|L14.4|
;;;1203         {
;;;1204           return VisionMemory::markers_;
;;;1205         } // GetObservedMarkerList()
000002  4770              BX       lr
;;;1206   
                          ENDP

                  |L14.4|
                          DCD      ||.bss||+0x13a4

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded5ArrayIfEERKNS2_6Point3IfEERS4_RS8_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded5ArrayIfEERKNS2_6Point3IfEERS4_RS8_ PROC ; Anki::Cozmo::VisionSystem::GetWithRespectToRobot(const Anki::Embedded::Array<float>&, const Anki::Embedded::Point3<float>&, Anki::Embedded::Array<float>&, Anki::Embedded::Point3<float>&)
;;;1328   
;;;1329         Result GetWithRespectToRobot(const Embedded::Array<f32>&  rotationWrtCamera,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1330           const Embedded::Point3<f32>& translationWrtCamera,
;;;1331           Embedded::Array<f32>&        rotationWrtRobot,
;;;1332           Embedded::Point3<f32>&       translationWrtRobot)
;;;1333         {
000004  4690              MOV      r8,r2
000006  ed2d8b02          VPUSH    {d8}
00000a  b08d              SUB      sp,sp,#0x34
00000c  4606              MOV      r6,r0
00000e  eddf8a7f          VLDR     s17,|L15.524|
;;;1334           Point3<f32> TcamWrtRobot;
;;;1335   
;;;1336           Result lastResult;
;;;1337           if((lastResult = GetCamPoseWrtRobot(RcamWrtRobot_, TcamWrtRobot)) != RESULT_OK) {
000012  a907              ADD      r1,sp,#0x1c
000014  edcd8a07          VSTR     s17,[sp,#0x1c]
000018  edcd8a08          VSTR     s17,[sp,#0x20]
00001c  edcd8a09          VSTR     s17,[sp,#0x24]
000020  487b              LDR      r0,|L15.528|
000022  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)
000026  2800              CMP      r0,#0
;;;1338             return lastResult;
;;;1339           }
;;;1340   
;;;1341           if((lastResult = Matrix::Multiply(RcamWrtRobot_, rotationWrtCamera, rotationWrtRobot)) != RESULT_OK) {
;;;1342             return lastResult;
;;;1343           }
;;;1344   
;;;1345           translationWrtRobot = RcamWrtRobot_*translationWrtCamera + TcamWrtRobot;
;;;1346   
;;;1347           return RESULT_OK;
;;;1348         }
000028  bf1f              ITTTT    NE
00002a  b00d              ADDNE    sp,sp,#0x34
00002c  ecbd8b02          VPOPNE   {d8}
000030  b004              ADDNE    sp,sp,#0x10
000032  e8bd8ff0          POPNE    {r4-r11,pc}
000036  4876              LDR      r0,|L15.528|
000038  2100              MOVS     r1,#0                 ;1341
00003a  9000              STR      r0,[sp,#0]            ;1341
00003c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000040  9001              STR      r0,[sp,#4]            ;1341
000042  2101              MOVS     r1,#1                 ;1341
000044  9800              LDR      r0,[sp,#0]            ;1341
000046  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00004a  4681              MOV      r9,r0                 ;1341
00004c  2100              MOVS     r1,#0                 ;1341
00004e  4630              MOV      r0,r6                 ;1341
000050  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000054  4605              MOV      r5,r0                 ;1341
000056  2101              MOVS     r1,#1                 ;1341
000058  4630              MOV      r0,r6                 ;1341
00005a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00005e  f8dfa1b4          LDR      r10,|L15.532|
000062  68b4              LDR      r4,[r6,#8]            ;1341
000064  4607              MOV      r7,r0                 ;1341
000066  f04f6ba0          MOV      r11,#0x5000000        ;1341
00006a  45a9              CMP      r9,r5                 ;1341
00006c  d00a              BEQ      |L15.132|
00006e  f44f7085          MOV      r0,#0x10a             ;1341
000072  e9cda000          STRD     r10,r0,[sp,#0]        ;1341
000076  4b68              LDR      r3,|L15.536|
000078  4a68              LDR      r2,|L15.540|
00007a  4969              LDR      r1,|L15.544|
00007c  2005              MOVS     r0,#5                 ;1341
00007e  f7fffffe          BL       _Anki_Log
000082  e085              B        |L15.400|
                  |L15.132|
000084  f8d80010          LDR      r0,[r8,#0x10]         ;1341
000088  f8dd9004          LDR      r9,[sp,#4]            ;1341
00008c  2800              CMP      r0,#0                 ;1341
00008e  d07c              BEQ      |L15.394|
000090  f8d80000          LDR      r0,[r8,#0]            ;1341
000094  2800              CMP      r0,#0                 ;1341
000096  bfa4              ITT      GE                    ;1341
000098  f8d80004          LDRGE    r0,[r8,#4]            ;1341
00009c  2800              CMPGE    r0,#0                 ;1341
00009e  db74              BLT      |L15.394|
0000a0  2100              MOVS     r1,#0                 ;1341
0000a2  4640              MOV      r0,r8                 ;1341
0000a4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000a8  4548              CMP      r0,r9                 ;1341
0000aa  d16e              BNE      |L15.394|
0000ac  2101              MOVS     r1,#1                 ;1341
0000ae  4640              MOV      r0,r8                 ;1341
0000b0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000b4  42b8              CMP      r0,r7                 ;1341
0000b6  d168              BNE      |L15.394|
0000b8  9801              LDR      r0,[sp,#4]            ;1341
0000ba  2200              MOVS     r2,#0                 ;1341
0000bc  2800              CMP      r0,#0                 ;1341
0000be  bfc4              ITT      GT                    ;1341
0000c0  1eeb              SUBGT    r3,r5,#3              ;1341
0000c2  eb040c44          ADDGT    r12,r4,r4,LSL #1      ;1341
0000c6  dd5f              BLE      |L15.392|
                  |L15.200|
0000c8  9800              LDR      r0,[sp,#0]            ;1341
0000ca  f8d89008          LDR      r9,[r8,#8]            ;1341
0000ce  6901              LDR      r1,[r0,#0x10]         ;1341
0000d0  6880              LDR      r0,[r0,#8]            ;1341
0000d2  fb021100          MLA      r1,r2,r0,r1           ;1341
0000d6  f8d80010          LDR      r0,[r8,#0x10]         ;1341
0000da  fb020e09          MLA      lr,r2,r9,r0           ;1341
0000de  2000              MOVS     r0,#0                 ;1341
0000e0  2f00              CMP      r7,#0                 ;1341
0000e2  dd4d              BLE      |L15.384|
                  |L15.228|
0000e4  f8d6b008          LDR      r11,[r6,#8]           ;1341
0000e8  f8d6a010          LDR      r10,[r6,#0x10]        ;1341
0000ec  f04f0900          MOV      r9,#0                 ;1341
0000f0  fb09a90b          MLA      r9,r9,r11,r10         ;1341
0000f4  eb090980          ADD      r9,r9,r0,LSL #2       ;1341
0000f8  eeb08a68          VMOV.F32 s16,s17               ;1341
0000fc  f04f0a00          MOV      r10,#0                ;1341
000100  2b00              CMP      r3,#0                 ;1341
000102  dd27              BLE      |L15.340|
                  |L15.260|
000104  eb010b8a          ADD      r11,r1,r10,LSL #2     ;1341
000108  edd92a00          VLDR     s5,[r9,#0]            ;1341
00010c  eddb3a00          VLDR     s7,[r11,#0]           ;1341
000110  ed9b2a01          VLDR     s4,[r11,#4]           ;1341
000114  ed9b3a02          VLDR     s6,[r11,#8]           ;1341
000118  eddb0a03          VLDR     s1,[r11,#0xc]         ;1341
00011c  eb090b04          ADD      r11,r9,r4             ;1341
000120  ee632aa2          VMUL.F32 s5,s7,s5              ;1341
000124  eddb1a00          VLDR     s3,[r11,#0]           ;1341
000128  eb090b44          ADD      r11,r9,r4,LSL #1      ;1341
00012c  f10a0a04          ADD      r10,r10,#4            ;1341
000130  ee422a21          VMLA.F32 s5,s4,s3              ;1341
000134  ed9b1a00          VLDR     s2,[r11,#0]           ;1341
000138  eb0c0b09          ADD      r11,r12,r9            ;1341
00013c  eb090984          ADD      r9,r9,r4,LSL #2       ;1341
000140  ed9b0a00          VLDR     s0,[r11,#0]           ;1341
000144  4553              CMP      r3,r10                ;1341
000146  ee432a01          VMLA.F32 s5,s6,s2              ;1341
00014a  ee402a80          VMLA.F32 s5,s1,s0              ;1341
00014e  ee328a88          VADD.F32 s16,s5,s16            ;1341
000152  dcd7              BGT      |L15.260|
                  |L15.340|
000154  45aa              CMP      r10,r5                ;1341
000156  da0c              BGE      |L15.370|
                  |L15.344|
000158  eb010b8a          ADD      r11,r1,r10,LSL #2     ;1341
00015c  edd90a00          VLDR     s1,[r9,#0]            ;1341
000160  ed9b0a00          VLDR     s0,[r11,#0]           ;1341
000164  f10a0a01          ADD      r10,r10,#1            ;1341
000168  44a1              ADD      r9,r9,r4              ;1341
00016a  ee008a20          VMLA.F32 s16,s0,s1             ;1341
00016e  45aa              CMP      r10,r5                ;1341
000170  dbf2              BLT      |L15.344|
                  |L15.370|
000172  eb0e0980          ADD      r9,lr,r0,LSL #2       ;1341
000176  1c40              ADDS     r0,r0,#1              ;1341
000178  ed898a00          VSTR     s16,[r9,#0]           ;1341
00017c  42b8              CMP      r0,r7                 ;1341
00017e  dbb1              BLT      |L15.228|
                  |L15.384|
000180  9801              LDR      r0,[sp,#4]            ;1341
000182  1c52              ADDS     r2,r2,#1              ;1341
000184  4282              CMP      r2,r0                 ;1341
000186  db9f              BLT      |L15.200|
                  |L15.392|
000188  e000              B        |L15.396|
                  |L15.394|
00018a  e033              B        |L15.500|
                  |L15.396|
00018c  f04f0b00          MOV      r11,#0                ;1341
                  |L15.400|
000190  ea5f000b          MOVS     r0,r11                ;1341
000194  d128              BNE      |L15.488|
000196  ad0a              ADD      r5,sp,#0x28           ;1345
000198  491d              LDR      r1,|L15.528|
00019a  a802              ADD      r0,sp,#8              ;1345
00019c  9c12              LDR      r4,[sp,#0x48]         ;1345
00019e  9a10              LDR      r2,[sp,#0x40]         ;1345
0001a0  f7fffffe          BL       _ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_ ; Anki::Embedded::operator *<float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Point3<T1>&)
0001a4  ed9d0a04          VLDR     s0,[sp,#0x10]         ;1345
0001a8  eddd0a09          VLDR     s1,[sp,#0x24]         ;1345
0001ac  eddd1a07          VLDR     s3,[sp,#0x1c]         ;1345
0001b0  4628              MOV      r0,r5                 ;1345
0001b2  ee301a20          VADD.F32 s2,s0,s1              ;1345
0001b6  ed9d0a03          VLDR     s0,[sp,#0xc]          ;1345
0001ba  eddd0a08          VLDR     s1,[sp,#0x20]         ;1345
0001be  ee700a20          VADD.F32 s1,s0,s1              ;1345
0001c2  ed9d0a02          VLDR     s0,[sp,#8]            ;1345
0001c6  ee300a21          VADD.F32 s0,s0,s3              ;1345
0001ca  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
0001ce  ed9d0a0a          VLDR     s0,[sp,#0x28]         ;1345
0001d2  2000              MOVS     r0,#0                 ;1347
0001d4  ed840a00          VSTR     s0,[r4,#0]            ;1347
0001d8  ed9d0a0b          VLDR     s0,[sp,#0x2c]         ;1347
0001dc  ed840a01          VSTR     s0,[r4,#4]            ;1347
0001e0  ed9d0a0c          VLDR     s0,[sp,#0x30]         ;1347
0001e4  ed840a02          VSTR     s0,[r4,#8]            ;1347
                  |L15.488|
0001e8  b00d              ADD      sp,sp,#0x34
0001ea  ecbd8b02          VPOP     {d8}
0001ee  b004              ADD      sp,sp,#0x10
0001f0  e8bd8ff0          POP      {r4-r11,pc}
                  |L15.500|
0001f4  f240100d          MOV      r0,#0x10d
0001f8  e9cda000          STRD     r10,r0,[sp,#0]
0001fc  4b06              LDR      r3,|L15.536|
0001fe  4a09              LDR      r2,|L15.548|
000200  4907              LDR      r1,|L15.544|
000202  2005              MOVS     r0,#5
000204  f7fffffe          BL       _Anki_Log
000208  e7c2              B        |L15.400|
;;;1349   
                          ENDP

00020a  0000              DCW      0x0000
                  |L15.524|
00020c  00000000          DCFS     0x00000000 ; 0
                  |L15.528|
                          DCD      ||.bss||+0x13d8
                  |L15.532|
                          DCD      _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L15.536|
                          DCD      _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs_1 ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::string (instance 3)
                  |L15.540|
                          DCD      _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs_0 ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::string (instance 2)
                  |L15.544|
                          DCD      _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::string
                  |L15.548|
                          DCD      _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs_2 ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::string (instance 4)

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded6Point3IfEERS4_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded6Point3IfEERS4_ PROC ; Anki::Cozmo::VisionSystem::GetWithRespectToRobot(const Anki::Embedded::Point3<float>&, Anki::Embedded::Point3<float>&)
;;;1313   
;;;1314         Result GetWithRespectToRobot(const Embedded::Point3<f32>& pointWrtCamera,
000000  b570              PUSH     {r4-r6,lr}
;;;1315           Embedded::Point3<f32>&       pointWrtRobot)
;;;1316         {
000002  b08c              SUB      sp,sp,#0x30
000004  ed9f0a1d          VLDR     s0,|L16.124|
000008  460c              MOV      r4,r1
00000a  ed8d0a05          VSTR     s0,[sp,#0x14]
00000e  4606              MOV      r6,r0
000010  ed8d0a06          VSTR     s0,[sp,#0x18]
000014  ed8d0a07          VSTR     s0,[sp,#0x1c]
;;;1317           Point3<f32> TcamWrtRobot;
;;;1318   
;;;1319           Result lastResult;
;;;1320           if((lastResult = GetCamPoseWrtRobot(RcamWrtRobot_, TcamWrtRobot)) != RESULT_OK) {
000018  a905              ADD      r1,sp,#0x14
00001a  4819              LDR      r0,|L16.128|
00001c  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)
000020  2800              CMP      r0,#0
;;;1321             return lastResult;
;;;1322           }
;;;1323   
;;;1324           pointWrtRobot = RcamWrtRobot_*pointWrtCamera + TcamWrtRobot;
;;;1325   
;;;1326           return RESULT_OK;
;;;1327         }
000022  bf1c              ITT      NE
000024  b00c              ADDNE    sp,sp,#0x30
000026  bd70              POPNE    {r4-r6,pc}
000028  ad08              ADD      r5,sp,#0x20           ;1324
00002a  4632              MOV      r2,r6                 ;1324
00002c  4914              LDR      r1,|L16.128|
00002e  4668              MOV      r0,sp                 ;1324
000030  f7fffffe          BL       _ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_ ; Anki::Embedded::operator *<float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Point3<T1>&)
000034  ed9d0a02          VLDR     s0,[sp,#8]            ;1324
000038  eddd0a07          VLDR     s1,[sp,#0x1c]         ;1324
00003c  eddd1a05          VLDR     s3,[sp,#0x14]         ;1324
000040  4628              MOV      r0,r5                 ;1324
000042  ee301a20          VADD.F32 s2,s0,s1              ;1324
000046  ed9d0a01          VLDR     s0,[sp,#4]            ;1324
00004a  eddd0a06          VLDR     s1,[sp,#0x18]         ;1324
00004e  ee700a20          VADD.F32 s1,s0,s1              ;1324
000052  ed9d0a00          VLDR     s0,[sp,#0]            ;1324
000056  ee300a21          VADD.F32 s0,s0,s3              ;1324
00005a  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
00005e  ed9d0a08          VLDR     s0,[sp,#0x20]         ;1324
000062  2000              MOVS     r0,#0                 ;1326
000064  ed840a00          VSTR     s0,[r4,#0]            ;1326
000068  ed9d0a09          VLDR     s0,[sp,#0x24]         ;1326
00006c  ed840a01          VSTR     s0,[r4,#4]            ;1326
000070  ed9d0a0a          VLDR     s0,[sp,#0x28]         ;1326
000074  ed840a02          VSTR     s0,[r4,#8]            ;1326
000078  b00c              ADD      sp,sp,#0x30
00007a  bd70              POP      {r4-r6,pc}
;;;1328   
                          ENDP

                  |L16.124|
00007c  00000000          DCFS     0x00000000 ; 0
                  |L16.128|
                          DCD      ||.bss||+0x13d8

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem22DownsampleAndSendImageERKNS_8Embedded5ArrayIhEE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem22DownsampleAndSendImageERKNS_8Embedded5ArrayIhEE PROC ; Anki::Cozmo::VisionSystem::DownsampleAndSendImage(const Anki::Embedded::Array<unsigned char>&)
;;;474          
;;;475          void DownsampleAndSendImage(const Array<u8> &img)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;476          {
;;;477            // If limiting framerate and the buffer is not empty, then silently fail and return
;;;478            if(wifiCamera_limitFramerate) {
000004  4c47              LDR      r4,|L17.292|
000006  4682              MOV      r10,r0                ;476
000008  f2ad4d14          SUB      sp,sp,#0x414          ;476
00000c  78e0              LDRB     r0,[r4,#3]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754725wifiCamera_limitFramerateE
00000e  b158              CBZ      r0,|L17.40|
;;;479              const int freeSpace = HAL::UARTGetFreeSpace();
000010  f7fffffe          BL       _ZN4Anki5Cozmo3HAL16UARTGetFreeSpaceEv ; Anki::Cozmo::HAL::UARTGetFreeSpace()
000014  4605              MOV      r5,r0
;;;480              const int bufferSize = HAL::UARTGetWriteBufferSize();
000016  f7fffffe          BL       _ZN4Anki5Cozmo3HAL22UARTGetWriteBufferSizeEv ; Anki::Cozmo::HAL::UARTGetWriteBufferSize()
00001a  1f40              SUBS     r0,r0,#5
;;;481              
;;;482              if(freeSpace < (bufferSize-5))  // Hack, case of off-by-some errors
00001c  4285              CMP      r5,r0
;;;483                return;
;;;484            }
;;;485          
;;;486            // Only downsample if normal capture res is QVGA
;;;487            if (imageSendMode_ != ISM_OFF && captureResolution_ == Vision::CAMERA_RES_QVGA) {
;;;488              
;;;489              // Time to send frame?
;;;490              static u8 streamFrameCnt = 0;
;;;491              if (imageSendMode_ == ISM_STREAM && streamFrameCnt++ != IMG_STREAM_SKIP_FRAMES) {
;;;492                return;
;;;493              }
;;;494              streamFrameCnt = 0;
;;;495              
;;;496              
;;;497              static u32 imgID = 0;
;;;498    
;;;499              // Downsample and split into image chunk message
;;;500              const u32 xRes = Vision::CameraResInfo[nextSendImageResolution_].width;
;;;501              const u32 yRes = Vision::CameraResInfo[nextSendImageResolution_].height;
;;;502    
;;;503              const u32 xSkip = 320 / xRes;
;;;504              const u32 ySkip = 240 / yRes;
;;;505    
;;;506              const u32 numTotalBytes = xRes*yRes;
;;;507    
;;;508              Messages::ImageChunk m;
;;;509              // TODO: pass this in so it corresponds to actual frame capture time instead of send time
;;;510              m.frameTimeStamp = HAL::GetTimeStamp();
;;;511              m.resolution = nextSendImageResolution_;
;;;512              m.imageId = ++imgID;
;;;513              m.chunkId = 0;
;;;514              m.chunkSize = IMAGE_CHUNK_SIZE;
;;;515              m.imageChunkCount = ceilf((f32)numTotalBytes / IMAGE_CHUNK_SIZE);
;;;516              m.imageEncoding = 0;
;;;517    
;;;518              u32 totalByteCnt = 0;
;;;519              u32 chunkByteCnt = 0;
;;;520    
;;;521              //PRINT("Downsample: from %d x %d  to  %d x %d\n", img.get_size(1), img.get_size(0), xRes, yRes);
;;;522    
;;;523              u32 dataY = 0;
;;;524              for (u32 y = 0; y < 240; y += ySkip, dataY++)
;;;525              {
;;;526                const u8* restrict rowPtr = img.Pointer(y, 0);
;;;527    
;;;528                u32 dataX = 0;
;;;529                for (u32 x = 0; x < 320; x += xSkip, dataX++)
;;;530                {
;;;531                  m.data[chunkByteCnt] = rowPtr[x];
;;;532                  ++chunkByteCnt;
;;;533                  ++totalByteCnt;
;;;534    
;;;535                  if (chunkByteCnt == IMAGE_CHUNK_SIZE) {
;;;536                    //PRINT("Sending image chunk %d\n", m.chunkId);
;;;537                    HAL::RadioSendMessage(GET_MESSAGE_ID(Messages::ImageChunk), &m);
;;;538                    ++m.chunkId;
;;;539                    chunkByteCnt = 0;
;;;540                  } else if (totalByteCnt == numTotalBytes) {
;;;541                    // This should be the last message!
;;;542                    //PRINT("Sending LAST image chunk %d\n", m.chunkId);
;;;543                    m.chunkSize = chunkByteCnt;
;;;544                    HAL::RadioSendMessage(GET_MESSAGE_ID(Messages::ImageChunk), &m);
;;;545                  }
;;;546                }
;;;547              }
;;;548    
;;;549              // Turn off image sending if sending single image only.
;;;550              if (imageSendMode_ == ISM_SINGLE_SHOT) {
;;;551                imageSendMode_ = ISM_OFF;
;;;552              }
;;;553            }
;;;554          }
00001e  bfbc              ITT      LT
000020  f20d4d14          ADDLT    sp,sp,#0x414
000024  e8bd8ff0          POPLT    {r4-r11,pc}
                  |L17.40|
000028  7960              LDRB     r0,[r4,#5]            ;487  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754714imageSendMode_E
00002a  2800              CMP      r0,#0                 ;487
00002c  d06b              BEQ      |L17.262|
00002e  7ae1              LDRB     r1,[r4,#0xb]          ;487  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754718captureResolution_E
000030  2907              CMP      r1,#7                 ;487
000032  d168              BNE      |L17.262|
000034  2801              CMP      r0,#1                 ;491
000036  d104              BNE      |L17.66|
000038  79e0              LDRB     r0,[r4,#7]            ;491  ; streamFrameCnt
00003a  1c41              ADDS     r1,r0,#1              ;491
00003c  71e1              STRB     r1,[r4,#7]            ;491
00003e  2802              CMP      r0,#2                 ;491
000040  d161              BNE      |L17.262|
                  |L17.66|
000042  4c38              LDR      r4,|L17.292|
000044  2500              MOVS     r5,#0                 ;494
000046  4a38              LDR      r2,|L17.296|
000048  71e5              STRB     r5,[r4,#7]            ;494
00004a  79a1              LDRB     r1,[r4,#6]            ;500  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754724nextSendImageResolution_E
00004c  f8320021          LDRH     r0,[r2,r1,LSL #2]     ;500
000050  eb020181          ADD      r1,r2,r1,LSL #2       ;501
000054  f44f72a0          MOV      r2,#0x140             ;503
000058  fbb2f9f0          UDIV     r9,r2,r0              ;503
00005c  8849              LDRH     r1,[r1,#2]            ;501
00005e  22f0              MOVS     r2,#0xf0              ;504
000060  fbb2f2f1          UDIV     r2,r2,r1              ;504
000064  fb00f801          MUL      r8,r0,r1              ;506
000068  f8cd2410          STR      r2,[sp,#0x410]        ;510
00006c  f7fffffe          BL       _ZN4Anki5Cozmo3HAL12GetTimeStampEv ; Anki::Cozmo::HAL::GetTimeStamp()
000070  9001              STR      r0,[sp,#4]            ;511
000072  79a0              LDRB     r0,[r4,#6]            ;511  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754724nextSendImageResolution_E
000074  f88d000d          STRB     r0,[sp,#0xd]          ;511
000078  6a20              LDR      r0,[r4,#0x20]         ;512  ; imgID
00007a  ee008a10          VMOV     s0,r8                 ;515
00007e  1c40              ADDS     r0,r0,#1              ;512
000080  6220              STR      r0,[r4,#0x20]         ;512  ; imgID
000082  eeb80a40          VCVT.F32.U32 s0,s0                 ;515
000086  eddf0a29          VLDR     s1,|L17.300|
00008a  9000              STR      r0,[sp,#0]            ;513
00008c  f44f6080          MOV      r0,#0x400             ;514
000090  f88d500c          STRB     r5,[sp,#0xc]          ;513
000094  f8ad0008          STRH     r0,[sp,#8]            ;514
000098  ee200a20          VMUL.F32 s0,s0,s1              ;515
00009c  f7fffffe          BL       __hardfp_ceilf
0000a0  eebc0ac0          VCVT.U32.F32 s0,s0                 ;515
0000a4  2600              MOVS     r6,#0                 ;518
0000a6  4634              MOV      r4,r6                 ;519
0000a8  ee100a10          VMOV     r0,s0                 ;515
0000ac  4637              MOV      r7,r6                 ;524
0000ae  f88d000b          STRB     r0,[sp,#0xb]          ;515
0000b2  f88d500a          STRB     r5,[sp,#0xa]          ;516
                  |L17.182|
0000b6  f8da1008          LDR      r1,[r10,#8]           ;516
0000ba  f8da0010          LDR      r0,[r10,#0x10]        ;516
0000be  2500              MOVS     r5,#0                 ;529
0000c0  fb070b01          MLA      r11,r7,r1,r0          ;529
                  |L17.196|
0000c4  eb0d0004          ADD      r0,sp,r4              ;531
0000c8  f81b1005          LDRB     r1,[r11,r5]           ;531
0000cc  1c64              ADDS     r4,r4,#1              ;531
0000ce  1c76              ADDS     r6,r6,#1              ;531
0000d0  7381              STRB     r1,[r0,#0xe]          ;531
0000d2  f5b46f80          CMP      r4,#0x400             ;535
0000d6  d01a              BEQ      |L17.270|
0000d8  4546              CMP      r6,r8                 ;540
0000da  d105              BNE      |L17.232|
0000dc  f8ad4008          STRH     r4,[sp,#8]            ;543
0000e0  4669              MOV      r1,sp                 ;544
0000e2  2048              MOVS     r0,#0x48              ;544
0000e4  f7fffffe          BL       _ZN4Anki5Cozmo3HAL16RadioSendMessageENS0_8Messages2IDEPKv ; Anki::Cozmo::HAL::RadioSendMessage(Anki::Cozmo::Messages::ID, const void*)
                  |L17.232|
0000e8  444d              ADD      r5,r5,r9              ;529
0000ea  f5b57fa0          CMP      r5,#0x140             ;529
0000ee  d3e9              BCC      |L17.196|
0000f0  f8dd0410          LDR      r0,[sp,#0x410]        ;524
0000f4  4407              ADD      r7,r7,r0              ;524
0000f6  2ff0              CMP      r7,#0xf0              ;524
0000f8  d3dd              BCC      |L17.182|
0000fa  480a              LDR      r0,|L17.292|
0000fc  7941              LDRB     r1,[r0,#5]            ;550  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754714imageSendMode_E
0000fe  2902              CMP      r1,#2                 ;550
000100  bf04              ITT      EQ                    ;551
000102  2100              MOVEQ    r1,#0                 ;551
000104  7141              STRBEQ   r1,[r0,#5]            ;551
                  |L17.262|
000106  f20d4d14          ADD      sp,sp,#0x414
00010a  e8bd8ff0          POP      {r4-r11,pc}
                  |L17.270|
00010e  4669              MOV      r1,sp                 ;537
000110  2048              MOVS     r0,#0x48              ;537
000112  f7fffffe          BL       _ZN4Anki5Cozmo3HAL16RadioSendMessageENS0_8Messages2IDEPKv ; Anki::Cozmo::HAL::RadioSendMessage(Anki::Cozmo::Messages::ID, const void*)
000116  f89d000c          LDRB     r0,[sp,#0xc]          ;538
00011a  1c40              ADDS     r0,r0,#1              ;538
00011c  f88d000c          STRB     r0,[sp,#0xc]          ;538
000120  2400              MOVS     r4,#0                 ;539
000122  e7e1              B        |L17.232|
;;;555    
                          ENDP

                  |L17.292|
                          DCD      ||.data||
                  |L17.296|
                          DCD      ||.constdata||
                  |L17.300|
00012c  3a800000          DCFS     0x3a800000 ; 0.0009765625

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem22GetFaceDetectionParamsEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem22GetFaceDetectionParamsEv PROC ; Anki::Cozmo::VisionSystem::GetFaceDetectionParams()
;;;1078   
;;;1079         const FaceDetectionParameters& GetFaceDetectionParams() {
000000  4800              LDR      r0,|L18.4|
;;;1080           return faceDetectionParameters_;
;;;1081         }
000002  4770              BX       lr
;;;1082         
                          ENDP

                  |L18.4|
                          DCD      ||.bss||+0x1588

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem22GetTrackingMarkerWidthEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem22GetTrackingMarkerWidthEv PROC ; Anki::Cozmo::VisionSystem::GetTrackingMarkerWidth()
;;;1066   
;;;1067         f32 GetTrackingMarkerWidth() {
000000  4801              LDR      r0,|L19.8|
;;;1068           return markerToTrack_.width_mm;
000002  ed900a01          VLDR     s0,[r0,#4]
;;;1069         }
000006  4770              BX       lr
;;;1070   
                          ENDP

                  |L19.8|
                          DCD      ||.bss||+0x13ec

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem28GetVisionMarkerPoseNearestToERKNS_8Embedded6Point3IfEERKNS_6Vision10MarkerTypeEfRNS2_5ArrayIfEERS4_Rb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem28GetVisionMarkerPoseNearestToERKNS_8Embedded6Point3IfEERKNS_6Vision10MarkerTypeEfRNS2_5ArrayIfEERS4_Rb PROC ; Anki::Cozmo::VisionSystem::GetVisionMarkerPoseNearestTo(const Anki::Embedded::Point3<float>&, const Anki::Vision::MarkerType&, float, Anki::Embedded::Array<float>&, Anki::Embedded::Point3<float>&, bool&)
;;;1206   
;;;1207         Result GetVisionMarkerPoseNearestTo(const Embedded::Point3<f32>&  atPosition,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1208           const Vision::MarkerType&     withType,
;;;1209           const f32                     maxDistance_mm,
;;;1210           Embedded::Array<f32>&         rotationWrtRobot,
;;;1211           Embedded::Point3<f32>&        translationWrtRobot,
;;;1212           bool&                         markerFound)
;;;1213         {
000004  4607              MOV      r7,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  b0c5              SUB      sp,sp,#0x114
00000c  f8df91e8          LDR      r9,|L20.504|
;;;1214           using namespace Embedded;
;;;1215   
;;;1216           Result lastResult = RESULT_OK;
;;;1217           markerFound = false;
000010  f8dd8140          LDR      r8,[sp,#0x140]
000014  2000              MOVS     r0,#0
000016  461e              MOV      r6,r3                 ;1213
000018  f8880000          STRB     r0,[r8,#0]
;;;1218   
;;;1219           if(VisionMemory::markers_.get_size() > 0)
00001c  f8d9000c          LDR      r0,[r9,#0xc]
000020  4692              MOV      r10,r2                ;1213
000022  eeb08a40          VMOV.F32 s16,s0                ;1213
000026  460d              MOV      r5,r1                 ;1213
000028  2800              CMP      r0,#0
00002a  f34080c4          BLE.W    |L20.438|
;;;1220           {
;;;1221             FixedLengthList<VisionMarker*> markersWithType(VisionMemory::markers_.get_size(),
00002e  2300              MOVS     r3,#0
000030  461a              MOV      r2,r3
000032  2101              MOVS     r1,#1
000034  a80f              ADD      r0,sp,#0x3c
000036  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00003a  6803              LDR      r3,[r0,#0]
00003c  f8d9100c          LDR      r1,[r9,#0xc]
000040  f1a9021c          SUB      r2,r9,#0x1c
000044  a802              ADD      r0,sp,#8
000046  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker*>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00004a  9905              LDR      r1,[sp,#0x14]
00004c  9809              LDR      r0,[sp,#0x24]
;;;1222               VisionMemory::ccmScratch_);
;;;1223   
;;;1224             AnkiConditionalErrorAndReturnValue(markersWithType.IsValid(),
00004e  f8dfb1ac          LDR      r11,|L20.508|
000052  4281              CMP      r1,r0
000054  dc7d              BGT      |L20.338|
000056  980c              LDR      r0,[sp,#0x30]
000058  b130              CBZ      r0,|L20.104|
00005a  9808              LDR      r0,[sp,#0x20]
00005c  2800              CMP      r0,#0
00005e  bfa3              ITTTE    GE
000060  9809              LDRGE    r0,[sp,#0x24]
000062  2800              CMPGE    r0,#0
000064  2001              MOVGE    r0,#1
000066  2000              MOVLT    r0,#0
                  |L20.104|
000068  2800              CMP      r0,#0
00006a  d072              BEQ      |L20.338|
;;;1225               RESULT_FAIL_MEMORY,
;;;1226               "GetVisionMarkerPoseNearestTo",
;;;1227               "Failed to allocate markersWithType FixedLengthList.");
;;;1228   
;;;1229             // Find all markers with specified type
;;;1230             s32 numFound = 0;
00006c  2400              MOVS     r4,#0
;;;1231             VisionMarker  * restrict pMarker = VisionMemory::markers_.Pointer(0);
;;;1232             VisionMarker* * restrict pMarkerWithType = markersWithType.Pointer(0);
;;;1233   
;;;1234             for(s32 i=0; i<VisionMemory::markers_.get_size(); ++i)
00006e  f8d9100c          LDR      r1,[r9,#0xc]
000072  f8d93030          LDR      r3,[r9,#0x30]
000076  9a0e              LDR      r2,[sp,#0x38]
000078  4620              MOV      r0,r4
00007a  2900              CMP      r1,#0
00007c  dd13              BLE      |L20.166|
                  |L20.126|
;;;1235             {
;;;1236               if(pMarker[i].markerType == withType) {
00007e  eb000140          ADD      r1,r0,r0,LSL #1
000082  eb0101c0          ADD      r1,r1,r0,LSL #3
000086  eb030181          ADD      r1,r3,r1,LSL #2
00008a  f895e000          LDRB     lr,[r5,#0]
00008e  f891c020          LDRB     r12,[r1,#0x20]
000092  45f4              CMP      r12,lr
;;;1237                 pMarkerWithType[numFound++] = pMarker + i;
000094  bf04              ITT      EQ
000096  f8421024          STREQ    r1,[r2,r4,LSL #2]
00009a  1c64              ADDEQ    r4,r4,#1
00009c  1c40              ADDS     r0,r0,#1
00009e  f8d9100c          LDR      r1,[r9,#0xc]          ;1234
0000a2  4281              CMP      r1,r0                 ;1234
0000a4  dceb              BGT      |L20.126|
                  |L20.166|
;;;1238               }
;;;1239             }
;;;1240             markersWithType.set_size(numFound);
0000a6  4621              MOV      r1,r4
0000a8  a802              ADD      r0,sp,#8
0000aa  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker*>::set_size(int)
;;;1241   
;;;1242             // If any were found, find the one that is closest to the specified
;;;1243             // 3D point and within the specified max distance
;;;1244             if(numFound > 0) {
0000ae  2c00              CMP      r4,#0
0000b0  dd7e              BLE      |L20.432|
;;;1245               // Create a little MemoryStack for allocating temporary
;;;1246               // rotation matrix
;;;1247               const s32 SCRATCH_BUFFER_SIZE = 128;
;;;1248               char scratchBuffer[SCRATCH_BUFFER_SIZE];
;;;1249               MemoryStack scratch(scratchBuffer, SCRATCH_BUFFER_SIZE);
0000b2  2201              MOVS     r2,#1
0000b4  2300              MOVS     r3,#0
0000b6  4611              MOV      r1,r2
0000b8  a842              ADD      r0,sp,#0x108
0000ba  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000be  6803              LDR      r3,[r0,#0]
0000c0  2280              MOVS     r2,#0x80
0000c2  a910              ADD      r1,sp,#0x40
0000c4  a835              ADD      r0,sp,#0xd4
0000c6  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
0000ca  eddf0a4d          VLDR     s1,|L20.512|
;;;1250   
;;;1251               // Create temporary pose storage (wrt camera)
;;;1252               Point3<f32> translationWrtCamera;
;;;1253               Array<f32> rotationWrtCamera(3,3,scratch);
0000ce  2300              MOVS     r3,#0
0000d0  edcd0a3c          VSTR     s1,[sp,#0xf0]
0000d4  edcd0a3d          VSTR     s1,[sp,#0xf4]
0000d8  edcd0a3e          VSTR     s1,[sp,#0xf8]
0000dc  461a              MOV      r2,r3
0000de  2101              MOVS     r1,#1
0000e0  a843              ADD      r0,sp,#0x10c
0000e2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000e6  6800              LDR      r0,[r0,#0]
0000e8  2203              MOVS     r2,#3
0000ea  9000              STR      r0,[sp,#0]
0000ec  ab35              ADD      r3,sp,#0xd4
0000ee  4611              MOV      r1,r2
0000f0  a830              ADD      r0,sp,#0xc0
0000f2  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0000f6  9834              LDR      r0,[sp,#0xd0]
0000f8  2800              CMP      r0,#0
0000fa  d070              BEQ      |L20.478|
0000fc  9830              LDR      r0,[sp,#0xc0]
0000fe  2800              CMP      r0,#0
000100  bfa4              ITT      GE
000102  9831              LDRGE    r0,[sp,#0xc4]
000104  2800              CMPGE    r0,#0
000106  db6a              BLT      |L20.478|
000108  f8dd9038          LDR      r9,[sp,#0x38]         ;1221
;;;1254               AnkiConditionalErrorAndReturnValue(rotationWrtCamera.IsValid(),
;;;1255                 RESULT_FAIL_MEMORY,
;;;1256                 "GetVisionMarkerPoseNearestTo",
;;;1257                 "Failed to allocate rotationWrtCamera Array.");
;;;1258   
;;;1259               VisionMarker* const* restrict pMarkerWithType = markersWithType.Pointer(0);
;;;1260   
;;;1261               f32 closestDistance = maxDistance_mm;
;;;1262   
;;;1263               for(s32 i=0; i<numFound; ++i) {
00010c  2500              MOVS     r5,#0
00010e  f04f0b01          MOV      r11,#1                ;1221
                  |L20.274|
;;;1264                 // Compute this marker's pose WRT camera
;;;1265                 if((lastResult = GetVisionMarkerPose(*(pMarkerWithType[i]), true,
000112  f8590025          LDR      r0,[r9,r5,LSL #2]
000116  ab3c              ADD      r3,sp,#0xf0
000118  aa30              ADD      r2,sp,#0xc0
00011a  2101              MOVS     r1,#1
00011c  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem19GetVisionMarkerPoseERKNS_8Embedded12VisionMarkerEbRNS2_5ArrayIfEERNS2_6Point3IfEE ; Anki::Cozmo::VisionSystem::GetVisionMarkerPose(const Anki::Embedded::VisionMarker&, bool, Anki::Embedded::Array<float>&, Anki::Embedded::Point3<float>&)
000120  2800              CMP      r0,#0
;;;1266                   rotationWrtCamera, translationWrtCamera)) != RESULT_OK) {
;;;1267                     return lastResult;
;;;1268                 }
;;;1269   
;;;1270                 // Convert it to pose WRT robot
;;;1271                 if((lastResult = GetWithRespectToRobot(rotationWrtCamera, translationWrtCamera,
;;;1272                   rotationWrtRobot, translationWrtRobot)) != RESULT_OK) {
;;;1273                     return lastResult;
;;;1274                 }
;;;1275   
;;;1276                 // See how far it is from the specified position
;;;1277                 const f32 currentDistance = (translationWrtRobot - atPosition).Length();
;;;1278                 if(currentDistance < closestDistance) {
;;;1279                   closestDistance = currentDistance;
;;;1280                   markerFound = true;
;;;1281                 }
;;;1282               } // for each marker with type
;;;1283             } // if numFound > 0
;;;1284           } // if(VisionMemory::markers_.get_size() > 0)
;;;1285   
;;;1286           return RESULT_OK;
;;;1287         } // GetVisionMarkerPoseNearestTo()
000122  bf1e              ITTT     NE
000124  b045              ADDNE    sp,sp,#0x114
000126  ecbd8b02          VPOPNE   {d8}
00012a  e8bd8ff0          POPNE    {r4-r11,pc}
00012e  4633              MOV      r3,r6                 ;1271
000130  4652              MOV      r2,r10                ;1271
000132  a93c              ADD      r1,sp,#0xf0           ;1271
000134  a830              ADD      r0,sp,#0xc0           ;1271
000136  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded5ArrayIfEERKNS2_6Point3IfEERS4_RS8_ ; Anki::Cozmo::VisionSystem::GetWithRespectToRobot(const Anki::Embedded::Array<float>&, const Anki::Embedded::Point3<float>&, Anki::Embedded::Array<float>&, Anki::Embedded::Point3<float>&)
00013a  2800              CMP      r0,#0                 ;1271
00013c  d13c              BNE      |L20.440|
00013e  ed960a02          VLDR     s0,[r6,#8]            ;1271
000142  edd70a02          VLDR     s1,[r7,#8]            ;1271
000146  a83f              ADD      r0,sp,#0xfc           ;1277
000148  ee301a60          VSUB.F32 s2,s0,s1              ;1277
00014c  ed960a01          VLDR     s0,[r6,#4]            ;1277
000150  e000              B        |L20.340|
                  |L20.338|
000152  e036              B        |L20.450|
                  |L20.340|
000154  edd70a01          VLDR     s1,[r7,#4]            ;1277
000158  edd71a00          VLDR     s3,[r7,#0]            ;1277
00015c  ee700a60          VSUB.F32 s1,s0,s1              ;1277
000160  ed960a00          VLDR     s0,[r6,#0]            ;1277
000164  ee300a61          VSUB.F32 s0,s0,s3              ;1277
000168  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
00016c  ed9d0a3f          VLDR     s0,[sp,#0xfc]         ;1277
000170  ee600a00          VMUL.F32 s1,s0,s0              ;1277
000174  ed9d0a40          VLDR     s0,[sp,#0x100]        ;1277
000178  ee400a00          VMLA.F32 s1,s0,s0              ;1277
00017c  ed9d0a41          VLDR     s0,[sp,#0x104]        ;1277
000180  ee400a00          VMLA.F32 s1,s0,s0              ;1277
000184  eeb10ae0          VSQRT.F32 s0,s1                 ;1277
000188  eeb40a40          VCMP.F32 s0,s0                 ;1277
00018c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1277
000190  bf1c              ITT      NE                    ;1277
000192  eeb00a60          VMOVNE.F32 s0,s1                 ;1277
000196  f7fffffe          BLNE     __hardfp_sqrtf
00019a  eeb40ac8          VCMPE.F32 s0,s16                ;1278
00019e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1278
0001a2  bf3c              ITT      CC                    ;1279
0001a4  eeb08a40          VMOVCC.F32 s16,s0                ;1279
0001a8  f888b000          STRBCC   r11,[r8,#0]           ;1280
0001ac  1c6d              ADDS     r5,r5,#1              ;1280
0001ae  e000              B        |L20.434|
                  |L20.432|
0001b0  e001              B        |L20.438|
                  |L20.434|
0001b2  42a5              CMP      r5,r4                 ;1263
0001b4  dbad              BLT      |L20.274|
                  |L20.438|
0001b6  2000              MOVS     r0,#0                 ;1286
                  |L20.440|
0001b8  b045              ADD      sp,sp,#0x114
0001ba  ecbd8b02          VPOP     {d8}
0001be  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.450|
0001c2  f44f6099          MOV      r0,#0x4c8             ;1224
0001c6  e9cdb000          STRD     r11,r0,[sp,#0]        ;1224
0001ca  a30e              ADR      r3,|L20.516|
0001cc  a217              ADR      r2,|L20.556|
0001ce  a124              ADR      r1,|L20.608|
0001d0  2005              MOVS     r0,#5                 ;1224
0001d2  f7fffffe          BL       _Anki_Log
0001d6  f04f7080          MOV      r0,#0x1000000         ;1224
0001da  e7ed              B        |L20.440|
0001dc  e7ff              B        |L20.478|
                  |L20.478|
0001de  f24040e6          MOV      r0,#0x4e6             ;1254
0001e2  e9cdb000          STRD     r11,r0,[sp,#0]        ;1254
0001e6  a307              ADR      r3,|L20.516|
0001e8  a225              ADR      r2,|L20.640|
0001ea  a11d              ADR      r1,|L20.608|
0001ec  2005              MOVS     r0,#5                 ;1254
0001ee  f7fffffe          BL       _Anki_Log
0001f2  f04f7080          MOV      r0,#0x1000000         ;1254
0001f6  e7df              B        |L20.440|
;;;1288   
                          ENDP

                  |L20.504|
                          DCD      ||.bss||+0x13a4
                  |L20.508|
                          DCD      ||.constdata||+0x6e
                  |L20.512|
000200  00000000          DCFS     0x00000000 ; 0
                  |L20.516|
000204  73757065          DCB      "supervisor\\src\\offboardVisionSystem.cpp",0
000208  72766973
00020c  6f725c73
000210  72635c6f
000214  6666626f
000218  61726456
00021c  6973696f
000220  6e537973
000224  74656d2e
000228  63707000
                  |L20.556|
00022c  4661696c          DCB      "Failed to allocate markersWithType FixedLengthList.",0
000230  65642074
000234  6f20616c
000238  6c6f6361
00023c  7465206d
000240  61726b65
000244  72735769
000248  74685479
00024c  70652046
000250  69786564
000254  4c656e67
000258  74684c69
00025c  73742e00
                  |L20.608|
000260  47657456          DCB      "GetVisionMarkerPoseNearestTo",0
000264  6973696f
000268  6e4d6172
00026c  6b657250
000270  6f73654e
000274  65617265
000278  7374546f
00027c  00      
00027d  00                DCB      0
00027e  00                DCB      0
00027f  00                DCB      0
                  |L20.640|
000280  4661696c          DCB      "Failed to allocate rotationWrtCamera Array.",0
000284  65642074
000288  6f20616c
00028c  6c6f6361
000290  74652072
000294  6f746174
000298  696f6e57
00029c  72744361
0002a0  6d657261
0002a4  20417272
0002a8  61792e00

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713MarkerToTrack5ClearEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713MarkerToTrack5ClearEv PROC ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
;;;240    
;;;241            void MarkerToTrack::Clear() {
000000  b082              SUB      sp,sp,#8
;;;242              type        = Anki::Vision::MARKER_UNKNOWN;
000002  21fd              MOVS     r1,#0xfd
;;;243              width_mm    = 0;
000004  ed9f0a0c          VLDR     s0,|L21.56|
000008  7001              STRB     r1,[r0,#0]            ;242
00000a  ed800a01          VSTR     s0,[r0,#4]
;;;244              imageCenter = Point2f(-1.f, -1.f);
00000e  eebf0a00          VMOV.F32 s0,#-1.00000000
000012  ed8d0a00          VSTR     s0,[sp,#0]
000016  ed8d0a01          VSTR     s0,[sp,#4]
00001a  eddd0a00          VLDR     s1,[sp,#0]
;;;245              imageSearchRadius = -1.f;
;;;246              checkAngleX = true;
00001e  2101              MOVS     r1,#1
000020  edc00a02          VSTR     s1,[r0,#8]
000024  eddd0a01          VLDR     s1,[sp,#4]
000028  edc00a03          VSTR     s1,[r0,#0xc]
00002c  ed800a04          VSTR     s0,[r0,#0x10]         ;245
000030  7501              STRB     r1,[r0,#0x14]
;;;247            }
000032  b002              ADD      sp,sp,#8
000034  4770              BX       lr
;;;248    
                          ENDP

000036  0000              DCW      0x0000
                  |L21.56|
000038  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem4InitEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem4InitEv PROC ; Anki::Cozmo::VisionSystem::Init()
;;;1082         
;;;1083         Result Init()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1084         {
;;;1085           Result result = RESULT_OK;
;;;1086   
;;;1087           if(!isInitialized_) {
000004  4d4e              LDR      r5,|L22.320|
000006  f04f0800          MOV      r8,#0                 ;1085
00000a  ed2d8b02          VPUSH    {d8}                  ;1084
00000e  b08c              SUB      sp,sp,#0x30           ;1084
000010  7828              LDRB     r0,[r5,#0]  ; isInitialized_
000012  2800              CMP      r0,#0
000014  d17d              BNE      |L22.274|
;;;1088             captureResolution_ = Vision::CAMERA_RES_QVGA;
000016  2007              MOVS     r0,#7
000018  72e8              STRB     r0,[r5,#0xb]
;;;1089   
;;;1090             // WARNING: the order of these initializations matter!
;;;1091   
;;;1092             //
;;;1093             // Initialize the VisionSystem's state (i.e. its "private member variables")
;;;1094             //
;;;1095   
;;;1096             mode_                      = VISION_MODE_DEFAULT;
00001a  2701              MOVS     r7,#1
00001c  722f              STRB     r7,[r5,#8]
;;;1097             markerToTrack_.Clear();
00001e  4849              LDR      r0,|L22.324|
000020  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713MarkerToTrack5ClearEv ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
;;;1098             numTrackFailures_          = 0;
000024  2600              MOVS     r6,#0
;;;1099   
;;;1100             wasCalledOnce_             = false;
000026  63ae              STR      r6,[r5,#0x38]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754717numTrackFailures_E
000028  726e              STRB     r6,[r5,#9]
;;;1101             havePreviousRobotState_    = false;
00002a  72ae              STRB     r6,[r5,#0xa]
;;;1102   
;;;1103             headCamInfo_ = HAL::GetHeadCamInfo();
00002c  f7fffffe          BL       _ZN4Anki5Cozmo3HAL14GetHeadCamInfoEv ; Anki::Cozmo::HAL::GetHeadCamInfo()
000030  6268              STR      r0,[r5,#0x24]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754712headCamInfo_E
000032  0004              MOVS     r4,r0
;;;1104             if(headCamInfo_ == NULL) {
000034  d07f              BEQ      |L22.310|
;;;1105               PRINT("Initialize() - HeadCam Info pointer is NULL!\n");
;;;1106               return RESULT_FAIL;
;;;1107             }
;;;1108   
;;;1109             // Compute FOV from focal length (currently used for tracker prediciton)
;;;1110             headCamFOV_ver_ = 2.f * atanf(static_cast<f32>(headCamInfo_->nrows) /
000036  8aa0              LDRH     r0,[r4,#0x14]
000038  eeb08a00          VMOV.F32 s16,#2.00000000
00003c  ee000a10          VMOV     s0,r0
000040  eef80a40          VCVT.F32.U32 s1,s0
000044  ed940a01          VLDR     s0,[r4,#4]
000048  ee201a08          VMUL.F32 s2,s0,s16
00004c  ee800a81          VDIV.F32 s0,s1,s2
000050  f7fffffe          BL       __hardfp_atanf
000054  ee200a08          VMUL.F32 s0,s0,s16
000058  ed850a0a          VSTR     s0,[r5,#0x28]
;;;1111               (2.f * headCamInfo_->focalLength_y));
;;;1112             headCamFOV_hor_ = 2.f * atanf(static_cast<f32>(headCamInfo_->ncols) /
00005c  8ae0              LDRH     r0,[r4,#0x16]
00005e  ee000a10          VMOV     s0,r0
000062  eef80a40          VCVT.F32.U32 s1,s0
000066  ed940a00          VLDR     s0,[r4,#0]
00006a  ee201a08          VMUL.F32 s2,s0,s16
00006e  ee800a81          VDIV.F32 s0,s1,s2
000072  f7fffffe          BL       __hardfp_atanf
000076  ee200a08          VMUL.F32 s0,s0,s16
;;;1113               (2.f * headCamInfo_->focalLength_x));
;;;1114   
;;;1115             exposureTime_ = 0.2f; // TODO: pick a reasonable start value
;;;1116             frameNumber = 0;
;;;1117   
;;;1118             detectionParameters_.Initialize();
00007a  4834              LDR      r0,|L22.332|
00007c  ed850a0b          VSTR     s0,[r5,#0x2c]         ;1112
000080  ed9f0a31          VLDR     s0,|L22.328|
000084  ed850a0c          VSTR     s0,[r5,#0x30]         ;1115
000088  636e              STR      r6,[r5,#0x34]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754711frameNumberE
00008a  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem31DetectFiducialMarkersParameters10InitializeEv ; Anki::Cozmo::VisionSystem::DetectFiducialMarkersParameters::Initialize()
;;;1119             trackerParameters_.Initialize();
00008e  4830              LDR      r0,|L22.336|
000090  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem17TrackerParameters10InitializeEv ; Anki::Cozmo::VisionSystem::TrackerParameters::Initialize()
;;;1120             faceDetectionParameters_.Initialize();
000094  482f              LDR      r0,|L22.340|
000096  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem23FaceDetectionParameters10InitializeEv ; Anki::Cozmo::VisionSystem::FaceDetectionParameters::Initialize()
00009a  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv ; Anki::Cozmo::VisionSystem::VisionMemory::ResetBuffers()
;;;1121   
;;;1122             Simulator::Initialize();
;;;1123   
;;;1124   #ifdef RUN_SIMPLE_TRACKING_TEST
;;;1125             Anki::Cozmo::VisionSystem::SetMarkerToTrack(Vision::MARKER_FIRE, DEFAULT_BLOCK_MARKER_WIDTH_MM);
;;;1126   #endif
;;;1127   
;;;1128             result = VisionMemory::Initialize();
;;;1129             if(result != RESULT_OK) { return result; }
00009e  2800              CMP      r0,#0
;;;1130   
;;;1131             result = DebugStream::Initialize();
;;;1132             if(result != RESULT_OK) { return result; }
;;;1133   
;;;1134             // XXX: result = MatlabVisualization::Initialize();
;;;1135             // XXX: if(result != RESULT_OK) { return result; }
;;;1136   
;;;1137   #if USE_MATLAB_TRACKER || USE_MATLAB_DETECTOR
;;;1138             result = MatlabVisionProcessor::Initialize();
;;;1139             if(result != RESULT_OK) { return result; }
;;;1140   #endif
;;;1141   
;;;1142             RcamWrtRobot_ = Array<f32>(3,3,VisionMemory::ccmScratch_);
;;;1143             
;;;1144             markerToTrack_.Clear();
;;;1145             newMarkerToTrack_.Clear();
;;;1146             newMarkerToTrackWasProvided_ = false;
;;;1147   
;;;1148             isWaitingOnSnapshot_ = false;
;;;1149             isSnapshotReady_ = NULL;
;;;1150             snapshotROI_ = Rectangle<s32>(-1, -1, -1, -1);
;;;1151             snapshot_ = NULL;
;;;1152             
;;;1153             isInitialized_ = true;
;;;1154           }
;;;1155   
;;;1156           return result;
;;;1157         }
0000a0  bf1e              ITTT     NE
0000a2  b00c              ADDNE    sp,sp,#0x30
0000a4  ecbd8b02          VPOPNE   {d8}
0000a8  e8bd81f0          POPNE    {r4-r8,pc}
0000ac  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem11DebugStream10InitializeEv ; Anki::Cozmo::VisionSystem::DebugStream::Initialize()
0000b0  ea5f0800          MOVS     r8,r0                 ;1131
0000b4  d13a              BNE      |L22.300|
0000b6  2300              MOVS     r3,#0                 ;1142
0000b8  4c27              LDR      r4,|L22.344|
0000ba  461a              MOV      r2,r3                 ;1142
0000bc  2101              MOVS     r1,#1                 ;1142
0000be  a801              ADD      r0,sp,#4              ;1142
0000c0  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000c4  6800              LDR      r0,[r0,#0]            ;1142
0000c6  2203              MOVS     r2,#3                 ;1142
0000c8  9000              STR      r0,[sp,#0]            ;1142
0000ca  f1a40350          SUB      r3,r4,#0x50           ;1142
0000ce  4611              MOV      r1,r2                 ;1142
0000d0  a806              ADD      r0,sp,#0x18           ;1142
0000d2  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0000d6  6801              LDR      r1,[r0,#0]            ;1142
0000d8  6021              STR      r1,[r4,#0]            ;1142
0000da  6841              LDR      r1,[r0,#4]            ;1142
0000dc  6061              STR      r1,[r4,#4]            ;1142
0000de  6881              LDR      r1,[r0,#8]            ;1142
0000e0  60a1              STR      r1,[r4,#8]            ;1142
0000e2  68c1              LDR      r1,[r0,#0xc]          ;1142
0000e4  60e1              STR      r1,[r4,#0xc]          ;1142
0000e6  6900              LDR      r0,[r0,#0x10]         ;1142
0000e8  6120              STR      r0,[r4,#0x10]         ;1144
0000ea  f1040014          ADD      r0,r4,#0x14           ;1144
0000ee  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713MarkerToTrack5ClearEv ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
0000f2  f104002c          ADD      r0,r4,#0x2c           ;1145
0000f6  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713MarkerToTrack5ClearEv ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
0000fa  712e              STRB     r6,[r5,#4]            ;1146
0000fc  732e              STRB     r6,[r5,#0xc]          ;1148
0000fe  f04f3cff          MOV      r12,#0xffffffff       ;1150
000102  63ee              STR      r6,[r5,#0x3c]         ;1150  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754716isSnapshotReady_E
000104  e9cdcc04          STRD     r12,r12,[sp,#0x10]    ;1150
000108  e9cdcc02          STRD     r12,r12,[sp,#8]       ;1150
00010c  f50470f0          ADD      r0,r4,#0x1e0          ;1150
000110  e001              B        |L22.278|
                  |L22.274|
000112  e00a              B        |L22.298|
000114  e00f              B        |L22.310|
                  |L22.278|
000116  f8c0c000          STR      r12,[r0,#0]           ;1150
00011a  9903              LDR      r1,[sp,#0xc]          ;1150
00011c  6041              STR      r1,[r0,#4]            ;1150
00011e  9904              LDR      r1,[sp,#0x10]         ;1150
000120  6081              STR      r1,[r0,#8]            ;1150
000122  9905              LDR      r1,[sp,#0x14]         ;1150
000124  60c1              STR      r1,[r0,#0xc]          ;1151
000126  646e              STR      r6,[r5,#0x44]         ;1153  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff75479snapshot_E
000128  702f              STRB     r7,[r5,#0]            ;1153
                  |L22.298|
00012a  4640              MOV      r0,r8                 ;1156
                  |L22.300|
00012c  b00c              ADD      sp,sp,#0x30
00012e  ecbd8b02          VPOP     {d8}
000132  e8bd81f0          POP      {r4-r8,pc}
                  |L22.310|
000136  a009              ADR      r0,|L22.348|
000138  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
00013c  2001              MOVS     r0,#1                 ;1106
00013e  e7f5              B        |L22.300|
;;;1158   
                          ENDP

                  |L22.320|
                          DCD      ||.data||
                  |L22.324|
                          DCD      ||.bss||+0x13ec
                  |L22.328|
000148  3e4ccccd          DCFS     0x3e4ccccd ; 0.20000000298023224
                  |L22.332|
                          DCD      ||.bss||+0x14e4
                  |L22.336|
                          DCD      ||.bss||+0x1544
                  |L22.340|
                          DCD      ||.bss||+0x1588
                  |L22.344|
                          DCD      ||.bss||+0x13d8
                  |L22.348|
00015c  496e6974          DCB      "Initialize() - HeadCam Info pointer is NULL!\n",0
000160  69616c69
000164  7a652829
000168  202d2048
00016c  65616443
000170  616d2049
000174  6e666f20
000178  706f696e
00017c  74657220
000180  6973204e
000184  554c4c21
000188  0a00    
00018a  00                DCB      0
00018b  00                DCB      0

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem6UpdateENS0_8Messages10RobotStateE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem6UpdateENS0_8Messages10RobotStateE PROC ; Anki::Cozmo::VisionSystem::Update(Anki::Cozmo::Messages::RobotState)
;;;1614         // This is the regular Update() call
;;;1615         Result Update(const Messages::RobotState robotState)
000000  b40f              PUSH     {r0-r3}
;;;1616         {
000002  e92d4ff0          PUSH     {r4-r11,lr}
000006  ed2d8b04          VPUSH    {d8-d9}
00000a  b08b              SUB      sp,sp,#0x2c
;;;1617           Result lastResult = RESULT_OK;
;;;1618   
;;;1619           // This should be called from elsewhere first, but calling it again won't hurt
;;;1620           Init();
00000c  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem4InitEv ; Anki::Cozmo::VisionSystem::Init()
;;;1621   
;;;1622           frameNumber++;
000010  4889              LDR      r0,|L23.568|
000012  6b41              LDR      r1,[r0,#0x34]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754711frameNumberE
000014  1c49              ADDS     r1,r1,#1
;;;1623   
;;;1624           // no-op on real hardware
;;;1625           if(!Simulator::IsFrameReady()) {
;;;1626             return RESULT_OK;
;;;1627           }
;;;1628           
;;;1629           // Make sure that we send the robot state message associated with the
;;;1630           // image we are about to process.
;;;1631           Messages::SendRobotStateMsg(&robotState);
000016  6341              STR      r1,[r0,#0x34]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754711frameNumberE
000018  a818              ADD      r0,sp,#0x60
00001a  f7fffffe          BL       _ZN4Anki5Cozmo8Messages17SendRobotStateMsgEPKNS1_10RobotStateE ; Anki::Cozmo::Messages::SendRobotStateMsg(const Anki::Cozmo::Messages::RobotState*)
00001e  f10d0860          ADD      r8,sp,#0x60
;;;1632           
;;;1633           UpdateRobotState(robotState);
000022  f10d0e80          ADD      lr,sp,#0x80
000026  e898100e          LDM      r8,{r1-r3,r12}        ;1631
00002a  f10d0870          ADD      r8,sp,#0x70           ;1631
00002e  4883              LDR      r0,|L23.572|
000030  e89800f0          LDM      r8,{r4-r7}            ;1631
000034  9709              STR      r7,[sp,#0x24]
000036  e9cd5607          STRD     r5,r6,[sp,#0x1c]
00003a  e89e0fe0          LDM      lr,{r5-r11}
00003e  e88d0fe0          STM      sp,{r5-r11}
000042  f100056c          ADD      r5,r0,#0x6c
000046  30a8              ADDS     r0,r0,#0xa8
000048  e8954fe0          LDM      r5,{r5-r11,lr}
00004c  e8804fe0          STM      r0,{r5-r11,lr}
000050  381c              SUBS     r0,r0,#0x1c
000052  e8900fe0          LDM      r0,{r5-r11}
000056  303c              ADDS     r0,r0,#0x3c
000058  e8800fe0          STM      r0,{r5-r11}
00005c  e9dd5607          LDRD     r5,r6,[sp,#0x1c]
000060  385c              SUBS     r0,r0,#0x5c
000062  9f09              LDR      r7,[sp,#0x24]
000064  e8a0100e          STM      r0!,{r1-r3,r12}
000068  c0f0              STM      r0!,{r4-r7}
00006a  e89d0fe0          LDM      sp,{r5-r11}
00006e  e8800fe0          STM      r0,{r5-r11}
000072  4f71              LDR      r7,|L23.568|
000074  7a78              LDRB     r0,[r7,#9]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754714wasCalledOnce_E
000076  2800              CMP      r0,#0
000078  f04f0001          MOV      r0,#1
00007c  bf14              ITE      NE
00007e  72b8              STRBNE   r0,[r7,#0xa]
000080  7278              STRBEQ   r0,[r7,#9]
000082  7938              LDRB     r0,[r7,#4]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754728newMarkerToTrackWasProvided_E
000084  2800              CMP      r0,#0
000086  d07d              BEQ      |L23.388|
000088  2001              MOVS     r0,#1
00008a  7238              STRB     r0,[r7,#8]
00008c  486c              LDR      r0,|L23.576|
00008e  f04f0800          MOV      r8,#0
000092  f1000218          ADD      r2,r0,#0x18
000096  f8c78038          STR      r8,[r7,#0x38]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754717numTrackFailures_E
00009a  7811              LDRB     r1,[r2,#0]
00009c  7001              STRB     r1,[r0,#0]
00009e  ed920a01          VLDR     s0,[r2,#4]
0000a2  ed800a01          VSTR     s0,[r0,#4]
0000a6  ed920a02          VLDR     s0,[r2,#8]
0000aa  ed800a02          VSTR     s0,[r0,#8]
0000ae  ed920a03          VLDR     s0,[r2,#0xc]
0000b2  ed800a03          VSTR     s0,[r0,#0xc]
0000b6  ed920a04          VLDR     s0,[r2,#0x10]
0000ba  ed800a04          VSTR     s0,[r0,#0x10]
0000be  7d11              LDRB     r1,[r2,#0x14]
0000c0  7501              STRB     r1,[r0,#0x14]
0000c2  7801              LDRB     r1,[r0,#0]
0000c4  29fd              CMP      r1,#0xfd
0000c6  d075              BEQ      |L23.436|
0000c8  ed908a01          VLDR     s16,[r0,#4]
0000cc  eeb58ac0          VCMPE.F32 s16,#0.0
0000d0  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000d4  d80d              BHI      |L23.242|
0000d6  f2401179          MOV      r1,#0x179
0000da  485a              LDR      r0,|L23.580|
0000dc  e9cd0100          STRD     r0,r1,[sp,#0]
0000e0  a359              ADR      r3,|L23.584|
0000e2  a263              ADR      r2,|L23.624|
0000e4  a16a              ADR      r1,|L23.656|
0000e6  2005              MOVS     r0,#5
0000e8  f7fffffe          BL       _Anki_Log
0000ec  f04f7440          MOV      r4,#0x3000000
0000f0  e066              B        |L23.448|
                  |L23.242|
0000f2  eef68a00          VMOV.F32 s17,#0.50000000
0000f6  4c6f              LDR      r4,|L23.692|
0000f8  ee289a28          VMUL.F32 s18,s16,s17
0000fc  eddf9a6e          VLDR     s19,|L23.696|
;;;1634           
;;;1635           // If SetMarkerToTrack() was called by main() during previous Update(),
;;;1636           // actually swap in the new marker now.
;;;1637           lastResult = UpdateMarkerToTrack();
;;;1638           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK, lastResult,
;;;1639                                              "VisionSystem::Update()", "UpdateMarkerToTrack failed.\n");
;;;1640   
;;;1641           // Use the timestamp of passed-in robot state as our frame capture's
;;;1642           // timestamp.  This is not totally correct, since the image will be
;;;1643           // grabbed some (trivial?) number of cycles later, once we get to the
;;;1644           // CameraGetFrame() calls below.  But this enforces, for now, that we
;;;1645           // always send a RobotState message off to basestation with a matching
;;;1646           // timestamp to every VisionMarker message.
;;;1647           //const TimeStamp_t imageTimeStamp = HAL::GetTimeStamp();
;;;1648           const TimeStamp_t imageTimeStamp = robotState.timestamp;
;;;1649   
;;;1650           if(mode_ == VISION_MODE_IDLE) {
;;;1651             // Nothing to do, unless a snapshot was requested
;;;1652             
;;;1653           }
;;;1654           else if(mode_ == VISION_MODE_LOOKING_FOR_MARKERS) {
;;;1655             Simulator::SetDetectionReadyTime(); // no-op on real hardware
;;;1656   
;;;1657             VisionMemory::ResetBuffers();
;;;1658   
;;;1659             assert(false); while(true); // XXX: Implement me for offboard version!
;;;1660   
;;;1661           } else if(mode_ == VISION_MODE_TRACKING) {
;;;1662             Simulator::SetTrackingReadyTime(); // no-op on real hardware
;;;1663   
;;;1664             //
;;;1665             // Capture image for tracking
;;;1666             //
;;;1667   
;;;1668             assert(false); while(true); // XXX: Implement me for offboard version!
;;;1669   
;;;1670           } else if(mode_ == VISION_MODE_DETECTING_FACES) {
;;;1671             Simulator::SetFaceDetectionReadyTime();
;;;1672             
;;;1673             VisionMemory::ResetBuffers();
;;;1674             
;;;1675             AnkiConditionalErrorAndReturnValue(faceDetectionParameters_.isInitialized, RESULT_FAIL,
;;;1676                                                "VisionSystem::Update::FaceDetectionParametersNotInitialized",
;;;1677                                                "Face detection parameters not initialized before Update() in DETECTING_FACES mode.\n");
;;;1678             
;;;1679             assert(false); while(true); // XXX: Implement me for offboard version!
;;;1680   
;;;1681           } else if(mode_ == VISION_MODE_SEND_IMAGES_TO_BASESTATION) {
;;;1682   
;;;1683             Simulator::SetSendWifiImageReadyTime();
;;;1684   
;;;1685             VisionMemory::ResetBuffers();
;;;1686                       
;;;1687             assert(false); while(true); // XXX: Implement me for offboard version!
;;;1688             
;;;1689           } else {
;;;1690             PRINT("VisionSystem::Update(): unknown mode = %d.", mode_);
;;;1691             return RESULT_FAIL;
;;;1692           } // if(converged)
;;;1693   
;;;1694           return lastResult;
;;;1695         } // Update() [Real]
000100  ee680a68          VNMUL.F32 s1,s16,s17
000104  ee280a68          VNMUL.F32 s0,s16,s17
000108  eeb01a69          VMOV.F32 s2,s19
00010c  a802              ADD      r0,sp,#8
00010e  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
000112  ed900a00          VLDR     s0,[r0,#0]
000116  f104060c          ADD      r6,r4,#0xc
00011a  ed840a00          VSTR     s0,[r4,#0]
00011e  ed900a01          VLDR     s0,[r0,#4]
000122  eeb01a69          VMOV.F32 s2,s19
000126  ed840a01          VSTR     s0,[r4,#4]
00012a  ed900a02          VLDR     s0,[r0,#8]
00012e  eef00a49          VMOV.F32 s1,s18
000132  ed840a02          VSTR     s0,[r4,#8]
000136  ee280a68          VNMUL.F32 s0,s16,s17
00013a  a802              ADD      r0,sp,#8
00013c  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
000140  ed900a00          VLDR     s0,[r0,#0]
000144  f1040518          ADD      r5,r4,#0x18
000148  ed860a00          VSTR     s0,[r6,#0]
00014c  ed900a01          VLDR     s0,[r0,#4]
000150  eeb01a69          VMOV.F32 s2,s19
000154  ed860a01          VSTR     s0,[r6,#4]
000158  ed900a02          VLDR     s0,[r0,#8]
00015c  ee680a68          VNMUL.F32 s1,s16,s17
000160  ed860a02          VSTR     s0,[r6,#8]
000164  eeb00a49          VMOV.F32 s0,s18
000168  a802              ADD      r0,sp,#8
00016a  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
00016e  ed900a00          VLDR     s0,[r0,#0]
000172  ed850a00          VSTR     s0,[r5,#0]
000176  ed900a01          VLDR     s0,[r0,#4]
00017a  ed850a01          VSTR     s0,[r5,#4]
00017e  ed900a02          VLDR     s0,[r0,#8]
000182  e000              B        |L23.390|
                  |L23.388|
000184  e01b              B        |L23.446|
                  |L23.390|
000186  ed850a02          VSTR     s0,[r5,#8]
00018a  eeb01a69          VMOV.F32 s2,s19
00018e  eef00a49          VMOV.F32 s1,s18
000192  eeb00a49          VMOV.F32 s0,s18
000196  a802              ADD      r0,sp,#8
000198  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
00019c  ed900a00          VLDR     s0,[r0,#0]
0001a0  ed840a09          VSTR     s0,[r4,#0x24]
0001a4  ed900a01          VLDR     s0,[r0,#4]
0001a8  ed840a0a          VSTR     s0,[r4,#0x28]
0001ac  ed900a02          VLDR     s0,[r0,#8]
0001b0  ed840a0b          VSTR     s0,[r4,#0x2c]
                  |L23.436|
0001b4  4841              LDR      r0,|L23.700|
0001b6  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713MarkerToTrack5ClearEv ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
0001ba  f8878004          STRB     r8,[r7,#4]
                  |L23.446|
0001be  2400              MOVS     r4,#0
                  |L23.448|
0001c0  4d3f              LDR      r5,|L23.704|
0001c2  b18c              CBZ      r4,|L23.488|
0001c4  f2406066          MOV      r0,#0x666             ;1638
0001c8  e9cd5000          STRD     r5,r0,[sp,#0]         ;1638
0001cc  a31e              ADR      r3,|L23.584|
0001ce  a23d              ADR      r2,|L23.708|
0001d0  a144              ADR      r1,|L23.740|
0001d2  2005              MOVS     r0,#5                 ;1638
0001d4  f7fffffe          BL       _Anki_Log
0001d8  4620              MOV      r0,r4                 ;1638
                  |L23.474|
0001da  b00b              ADD      sp,sp,#0x2c
0001dc  ecbd8b04          VPOP     {d8-d9}
0001e0  e8bd0ff0          POP      {r4-r11}
0001e4  f85dfb14          LDR      pc,[sp],#0x14
                  |L23.488|
0001e8  7a39              LDRB     r1,[r7,#8]            ;1650  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff75475mode_E
0001ea  2900              CMP      r1,#0                 ;1650
0001ec  bf08              IT       EQ                    ;1694
0001ee  4620              MOVEQ    r0,r4                 ;1694
0001f0  d0f3              BEQ      |L23.474|
0001f2  2902              CMP      r1,#2                 ;1654
0001f4  d01c              BEQ      |L23.560|
0001f6  2903              CMP      r1,#3                 ;1661
0001f8  d00d              BEQ      |L23.534|
0001fa  2904              CMP      r1,#4                 ;1670
0001fc  d006              BEQ      |L23.524|
0001fe  2901              CMP      r1,#1                 ;1681
000200  d016              BEQ      |L23.560|
000202  a03e              ADR      r0,|L23.764|
000204  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
                  |L23.520|
000208  2001              MOVS     r0,#1                 ;1691
00020a  e7e6              B        |L23.474|
                  |L23.524|
00020c  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv ; Anki::Cozmo::VisionSystem::VisionMemory::ResetBuffers()
000210  4845              LDR      r0,|L23.808|
000212  7800              LDRB     r0,[r0,#0]            ;1675  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754724faceDetectionParameters_E
000214  b108              CBZ      r0,|L23.538|
                  |L23.534|
000216  f7fffffe          BL       abort
                  |L23.538|
00021a  f240608b          MOV      r0,#0x68b             ;1675
00021e  e9cd5000          STRD     r5,r0,[sp,#0]         ;1675
000222  a309              ADR      r3,|L23.584|
000224  4a41              LDR      r2,|L23.812|
000226  a142              ADR      r1,|L23.816|
000228  2005              MOVS     r0,#5                 ;1675
00022a  f7fffffe          BL       _Anki_Log
00022e  e7eb              B        |L23.520|
                  |L23.560|
000230  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv ; Anki::Cozmo::VisionSystem::VisionMemory::ResetBuffers()
000234  f7fffffe          BL       abort
;;;1696   
                          ENDP

                  |L23.568|
                          DCD      ||.data||
                  |L23.572|
                          DCD      ||.bss||+0x1400
                  |L23.576|
                          DCD      ||.bss||+0x13ec
                  |L23.580|
                          DCD      ||.constdata||+0x30
                  |L23.584|
000248  73757065          DCB      "supervisor\\src\\offboardVisionSystem.cpp",0
00024c  72766973
000250  6f725c73
000254  72635c6f
000258  6666626f
00025c  61726456
000260  6973696f
000264  6e537973
000268  74656d2e
00026c  63707000
                  |L23.624|
000270  496e7661          DCB      "Invalid marker width specified.",0
000274  6c696420
000278  6d61726b
00027c  65722077
000280  69647468
000284  20737065
000288  63696669
00028c  65642e00
                  |L23.656|
000290  56697369          DCB      "VisionSystem::UpdateMarkerToTrack()",0
000294  6f6e5379
000298  7374656d
00029c  3a3a5570
0002a0  64617465
0002a4  4d61726b
0002a8  6572546f
0002ac  54726163
0002b0  6b282900
                  |L23.692|
                          DCD      ||.bss||+0x143c
                  |L23.696|
0002b8  00000000          DCFS     0x00000000 ; 0
                  |L23.700|
                          DCD      ||.bss||+0x1404
                  |L23.704|
                          DCD      ||.constdata||+0x277
                  |L23.708|
0002c4  55706461          DCB      "UpdateMarkerToTrack failed.\n",0
0002c8  74654d61
0002cc  726b6572
0002d0  546f5472
0002d4  61636b20
0002d8  6661696c
0002dc  65642e0a
0002e0  00      
0002e1  00                DCB      0
0002e2  00                DCB      0
0002e3  00                DCB      0
                  |L23.740|
0002e4  56697369          DCB      "VisionSystem::Update()",0
0002e8  6f6e5379
0002ec  7374656d
0002f0  3a3a5570
0002f4  64617465
0002f8  282900  
0002fb  00                DCB      0
                  |L23.764|
0002fc  56697369          DCB      "VisionSystem::Update(): unknown mode = %d.",0
000300  6f6e5379
000304  7374656d
000308  3a3a5570
00030c  64617465
000310  28293a20
000314  756e6b6e
000318  6f776e20
00031c  6d6f6465
000320  203d2025
000324  642e00  
000327  00                DCB      0
                  |L23.808|
                          DCD      ||.bss||+0x1588
                  |L23.812|
                          DCD      ||.conststring||+0x58
                  |L23.816|
000330  56697369          DCB      "VisionSystem::Update::FaceDetectionParametersNotInitial"
000334  6f6e5379
000338  7374656d
00033c  3a3a5570
000340  64617465
000344  3a3a4661
000348  63654465
00034c  74656374
000350  696f6e50
000354  6172616d
000358  65746572
00035c  734e6f74
000360  496e6974
000364  69616c  
000367  697a6564          DCB      "ized",0
00036b  00      

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem9SetParamsEbfiffhfb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem9SetParamsEbfiffhfb PROC ; Anki::Cozmo::VisionSystem::SetParams(bool, float, int, float, float, unsigned char, float, bool)
;;;1699         
;;;1700         void SetParams(const bool autoExposureOn,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1701                        const f32 exposureTime,
;;;1702                        const s32 integerCountsIncrement,
;;;1703                        const f32 minExposureTime,
;;;1704                        const f32 maxExposureTime,
;;;1705                        const u8 highValue,
;;;1706                        const f32 percentileToMakeHigh,
;;;1707                        const bool limitFramerate)
;;;1708         {
;;;1709           autoExposure_enabled = autoExposureOn;
000004  f8dfc098          LDR      r12,|L24.160|
000008  4692              MOV      r10,r2                ;1708
00000a  ed2d8b04          VPUSH    {d8-d9}               ;1708
00000e  b08b              SUB      sp,sp,#0x2c           ;1708
000010  468b              MOV      r11,r1                ;1708
000012  f88c0001          STRB     r0,[r12,#1]
;;;1710           exposureTime_ = exposureTime;
000016  9001              STR      r0,[sp,#4]
000018  ed8c0a0c          VSTR     s0,[r12,#0x30]
;;;1711           autoExposure_integerCountsIncrement = integerCountsIncrement;
;;;1712           autoExposure_minExposureTime = minExposureTime;
00001c  f8cc1010          STR      r1,[r12,#0x10]  ; _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754735autoExposure_integerCountsIncrementE
000020  edcc0a05          VSTR     s1,[r12,#0x14]
;;;1713           autoExposure_maxExposureTime = maxExposureTime;
000024  ed8c1a06          VSTR     s2,[r12,#0x18]
;;;1714           autoExposure_highValue = highValue;
000028  f88c2002          STRB     r2,[r12,#2]
;;;1715           autoExposure_percentileToMakeHigh = percentileToMakeHigh;
00002c  edcc1a07          VSTR     s3,[r12,#0x1c]
000030  eeb08a40          VMOV.F32 s16,s0                ;1712
000034  eef08a60          VMOV.F32 s17,s1                ;1712
000038  eeb09a41          VMOV.F32 s18,s2                ;1713
;;;1716           wifiCamera_limitFramerate = limitFramerate;
00003c  f88c3003          STRB     r3,[r12,#3]
;;;1717           
;;;1718           PRINT("Changed VisionSystem params: autoExposureOn d exposureTime %f integerCountsInc %d, minExpTime %f, maxExpTime %f, highVal %d, percToMakeHigh %f\n",
000040  ee110a90          VMOV     r0,s3
000044  f7fffffe          BL       __aeabi_f2d
000048  4680              MOV      r8,r0
00004a  eeb01a49          VMOV.F32 s2,s18
00004e  4689              MOV      r9,r1
000050  ee110a10          VMOV     r0,s2
000054  f7fffffe          BL       __aeabi_f2d
000058  4606              MOV      r6,r0
00005a  eef00a68          VMOV.F32 s1,s17
00005e  460f              MOV      r7,r1
000060  ee100a90          VMOV     r0,s1
000064  f7fffffe          BL       __aeabi_f2d
000068  4604              MOV      r4,r0
00006a  eeb00a48          VMOV.F32 s0,s16
00006e  460d              MOV      r5,r1
000070  ee100a10          VMOV     r0,s0
000074  f7fffffe          BL       __aeabi_f2d
000078  ec410b10          VMOV     d0,r0,r1
00007c  a902              ADD      r1,sp,#8
00007e  f8cdb000          STR      r11,[sp,#0]
000082  e88104f0          STM      r1,{r4-r7,r10}
000086  ec532b10          VMOV     r2,r3,d0
00008a  e9cd8908          STRD     r8,r9,[sp,#0x20]
00008e  4805              LDR      r0,|L24.164|
000090  9901              LDR      r1,[sp,#4]
000092  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;1719                 autoExposure_enabled,
;;;1720                 exposureTime_,
;;;1721                 autoExposure_integerCountsIncrement,
;;;1722                 autoExposure_minExposureTime,
;;;1723                 autoExposure_maxExposureTime,
;;;1724                 autoExposure_highValue,
;;;1725                 autoExposure_percentileToMakeHigh);
;;;1726         }
000096  b00b              ADD      sp,sp,#0x2c
000098  ecbd8b04          VPOP     {d8-d9}
00009c  e8bd8ff0          POP      {r4-r11,pc}
;;;1727         
                          ENDP

                  |L24.160|
                          DCD      ||.data||
                  |L24.164|
                          DCD      ||.conststring||+0xac

                          AREA ||i.__sti___24_offboardVisionSystem_cpp_b6ff7547||, CODE, READONLY, ALIGN=2

                  __sti___24_offboardVisionSystem_cpp_b6ff7547 PROC
000000  b530              PUSH     {r4,r5,lr}
000002  4837              LDR      r0,|L25.224|
000004  ed9f0a35          VLDR     s0,|L25.220|
000008  ed2d8b02          VPUSH    {d8}
00000c  b083              SUB      sp,sp,#0xc
00000e  ed800a12          VSTR     s0,[r0,#0x48]
000012  4834              LDR      r0,|L25.228|
000014  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1Ev ; Anki::Embedded::MemoryStack::MemoryStack()
000018  4833              LDR      r0,|L25.232|
00001a  f04f34ff          MOV      r4,#0xffffffff
00001e  2500              MOVS     r5,#0
000020  6004              STR      r4,[r0,#0]
000022  6044              STR      r4,[r0,#4]
000024  6084              STR      r4,[r0,#8]
000026  60c4              STR      r4,[r0,#0xc]
000028  6104              STR      r4,[r0,#0x10]
00002a  6144              STR      r4,[r0,#0x14]
00002c  3024              ADDS     r0,r0,#0x24
00002e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000032  f8404d0c          STR      r4,[r0,#-0xc]!
000036  2100              MOVS     r1,#0
000038  6044              STR      r4,[r0,#4]
00003a  6084              STR      r4,[r0,#8]
00003c  f8405f10          STR      r5,[r0,#0x10]!
000040  6045              STR      r5,[r0,#4]
000042  6085              STR      r5,[r0,#8]
000044  3828              SUBS     r0,r0,#0x28
000046  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>::set_size(int)
00004a  4828              LDR      r0,|L25.236|
00004c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000050  f8404d0c          STR      r4,[r0,#-0xc]!
000054  ed9f8a27          VLDR     s16,|L25.244|
000058  6044              STR      r4,[r0,#4]
00005a  6105              STR      r5,[r0,#0x10]
00005c  6084              STR      r4,[r0,#8]
00005e  4824              LDR      r0,|L25.240|
000060  ed808a02          VSTR     s16,[r0,#8]
000064  ed808a03          VSTR     s16,[r0,#0xc]
000068  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713MarkerToTrack5ClearEv ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
00006c  4822              LDR      r0,|L25.248|
00006e  ed808a02          VSTR     s16,[r0,#8]
000072  ed808a03          VSTR     s16,[r0,#0xc]
000076  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713MarkerToTrack5ClearEv ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
00007a  4820              LDR      r0,|L25.252|
00007c  2304              MOVS     r3,#4
00007e  2208              MOVS     r2,#8
000080  491f              LDR      r1,|L25.256|
000082  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
000086  2100              MOVS     r1,#0
                  |L25.136|
000088  ed8d8a00          VSTR     s16,[sp,#0]
00008c  ed8d8a01          VSTR     s16,[sp,#4]
000090  eb0002c1          ADD      r2,r0,r1,LSL #3
000094  ed9d0a00          VLDR     s0,[sp,#0]
000098  1c49              ADDS     r1,r1,#1
00009a  ed820a00          VSTR     s0,[r2,#0]
00009e  ed9d0a01          VLDR     s0,[sp,#4]
0000a2  2904              CMP      r1,#4
0000a4  ed820a01          VSTR     s0,[r2,#4]
0000a8  dbee              BLT      |L25.136|
0000aa  2304              MOVS     r3,#4
0000ac  220c              MOVS     r2,#0xc
0000ae  4915              LDR      r1,|L25.260|
0000b0  4815              LDR      r0,|L25.264|
0000b2  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
0000b6  4815              LDR      r0,|L25.268|
0000b8  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem31DetectFiducialMarkersParametersC1Ev ; Anki::Cozmo::VisionSystem::DetectFiducialMarkersParameters::DetectFiducialMarkersParameters()
0000bc  4814              LDR      r0,|L25.272|
0000be  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem17TrackerParametersC1Ev ; Anki::Cozmo::VisionSystem::TrackerParameters::TrackerParameters()
0000c2  4814              LDR      r0,|L25.276|
0000c4  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem23FaceDetectionParametersC1Ev ; Anki::Cozmo::VisionSystem::FaceDetectionParameters::FaceDetectionParameters()
0000c8  4813              LDR      r0,|L25.280|
0000ca  6005              STR      r5,[r0,#0]
0000cc  6045              STR      r5,[r0,#4]
0000ce  6085              STR      r5,[r0,#8]
0000d0  60c5              STR      r5,[r0,#0xc]
0000d2  b003              ADD      sp,sp,#0xc
0000d4  ecbd8b02          VPOP     {d8}
0000d8  bd30              POP      {r4,r5,pc}
                          ENDP

0000da  0000              DCW      0x0000
                  |L25.220|
0000dc  423df6f2          DCFS     0x423df6f2 ; 47.491157531738281
                  |L25.224|
                          DCD      ||.data||
                  |L25.228|
                          DCD      ||.bss||+0x1388
                  |L25.232|
                          DCD      ||.bss||+0x13a4
                  |L25.236|
                          DCD      ||.bss||+0x13e4
                  |L25.240|
                          DCD      ||.bss||+0x13ec
                  |L25.244|
0000f4  00000000          DCFS     0x00000000 ; 0
                  |L25.248|
                          DCD      ||.bss||+0x1404
                  |L25.252|
                          DCD      ||.bss||+0x141c
                  |L25.256|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()
                  |L25.260|
                          DCD      _ZN4Anki8Embedded6Point3IfEC1Ev ; Anki::Embedded::Point3<float>::Point3()
                  |L25.264|
                          DCD      ||.bss||+0x143c
                  |L25.268|
                          DCD      ||.bss||+0x14e4
                  |L25.272|
                          DCD      ||.bss||+0x1544
                  |L25.276|
                          DCD      ||.bss||+0x1588
                  |L25.280|
                          DCD      ||.bss||+0x15b8

                          AREA ||t._ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE PROC ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)
;;;1289         template<typename PRECISION>
;;;1290         static Result GetCamPoseWrtRobot(Array<PRECISION>& RcamWrtRobot,
000000  b530              PUSH     {r4,r5,lr}
;;;1291           Point3<PRECISION>& TcamWrtRobot)
;;;1292         {
000002  460d              MOV      r5,r1
000004  ed2d8b02          VPUSH    {d8}
000008  b083              SUB      sp,sp,#0xc
00000a  4604              MOV      r4,r0
;;;1293           AnkiConditionalErrorAndReturnValue(RcamWrtRobot.get_size(0)==3 &&
00000c  2100              MOVS     r1,#0
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000012  2803              CMP      r0,#3
000014  d105              BNE      |L26.34|
000016  2101              MOVS     r1,#1
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001e  2803              CMP      r0,#3
000020  d010              BEQ      |L26.68|
                  |L26.34|
000022  f240510d          MOV      r1,#0x50d
000026  483f              LDR      r0,|L26.292|
000028  e9cd0100          STRD     r0,r1,[sp,#0]
00002c  4b3e              LDR      r3,|L26.296|
00002e  4a3f              LDR      r2,|L26.300|
000030  493f              LDR      r1,|L26.304|
000032  2005              MOVS     r0,#5
000034  f7fffffe          BL       _Anki_Log
;;;1294             RcamWrtRobot.get_size(1)==3,
;;;1295             RESULT_FAIL_INVALID_SIZE,
;;;1296             "VisionSystem::GetCamPoseWrtRobot",
;;;1297             "Rotation matrix must already be 3x3.");
;;;1298   
;;;1299           const f32 headAngle = HeadController::GetAngleRad();
;;;1300           const f32 cosH = cosf(headAngle);
;;;1301           const f32 sinH = sinf(headAngle);
;;;1302   
;;;1303           RcamWrtRobot[0][0] = 0;  RcamWrtRobot[0][1] = sinH;  RcamWrtRobot[0][2] = cosH;
;;;1304           RcamWrtRobot[1][0] = -1; RcamWrtRobot[1][1] = 0;     RcamWrtRobot[1][2] = 0;
;;;1305           RcamWrtRobot[2][0] = 0;  RcamWrtRobot[2][1] = -cosH; RcamWrtRobot[2][2] = sinH;
;;;1306   
;;;1307           TcamWrtRobot.x = HEAD_CAM_POSITION[0]*cosH - HEAD_CAM_POSITION[2]*sinH + NECK_JOINT_POSITION[0];
;;;1308           TcamWrtRobot.y = 0;
;;;1309           TcamWrtRobot.z = HEAD_CAM_POSITION[2]*cosH + HEAD_CAM_POSITION[0]*sinH + NECK_JOINT_POSITION[2];
;;;1310   
;;;1311           return RESULT_OK;
;;;1312         }
000038  b003              ADD      sp,sp,#0xc
00003a  f04f60a0          MOV      r0,#0x5000000         ;1293
00003e  ecbd8b02          VPOP     {d8}
000042  bd30              POP      {r4,r5,pc}
                  |L26.68|
000044  f7fffffe          BL       _ZN4Anki5Cozmo14HeadController11GetAngleRadEv ; Anki::Cozmo::HeadController::GetAngleRad()
000048  eef08a40          VMOV.F32 s17,s0                ;1299
00004c  f7fffffe          BL       __hardfp_cosf
000050  eeb08a40          VMOV.F32 s16,s0                ;1300
000054  eeb00a68          VMOV.F32 s0,s17                ;1301
000058  f7fffffe          BL       __hardfp_sinf
00005c  68a2              LDR      r2,[r4,#8]            ;1301
00005e  6921              LDR      r1,[r4,#0x10]         ;1301
000060  2000              MOVS     r0,#0                 ;1303
000062  fb001002          MLA      r0,r0,r2,r1           ;1303
000066  eddf0a33          VLDR     s1,|L26.308|
00006a  eebf1a00          VMOV.F32 s2,#-1.00000000       ;1304
00006e  edc00a00          VSTR     s1,[r0,#0]            ;1303
000072  68a2              LDR      r2,[r4,#8]            ;1303
000074  6921              LDR      r1,[r4,#0x10]         ;1303
000076  2000              MOVS     r0,#0                 ;1303
000078  fb001002          MLA      r0,r0,r2,r1           ;1303
00007c  eef91a08          VMOV.F32 s3,#-6.00000000       ;1307
000080  ed800a01          VSTR     s0,[r0,#4]            ;1303
000084  68a2              LDR      r2,[r4,#8]            ;1303
000086  6921              LDR      r1,[r4,#0x10]         ;1303
000088  2000              MOVS     r0,#0                 ;1303
00008a  fb001002          MLA      r0,r0,r2,r1           ;1303
00008e  eefa2a0a          VMOV.F32 s5,#-13.00000000      ;1307
000092  ed808a02          VSTR     s16,[r0,#8]           ;1303
000096  68a2              LDR      r2,[r4,#8]            ;1303
000098  6921              LDR      r1,[r4,#0x10]         ;1303
00009a  2001              MOVS     r0,#1                 ;1304
00009c  fb001002          MLA      r0,r0,r2,r1           ;1304
0000a0  ed801a00          VSTR     s2,[r0,#0]            ;1304
0000a4  68a2              LDR      r2,[r4,#8]            ;1304
0000a6  6921              LDR      r1,[r4,#0x10]         ;1304
0000a8  2001              MOVS     r0,#1                 ;1304
0000aa  fb001002          MLA      r0,r0,r2,r1           ;1304
0000ae  eeb11a48          VNEG.F32 s2,s16                ;1305
0000b2  edc00a01          VSTR     s1,[r0,#4]            ;1304
0000b6  68a2              LDR      r2,[r4,#8]            ;1304
0000b8  6921              LDR      r1,[r4,#0x10]         ;1304
0000ba  2001              MOVS     r0,#1                 ;1304
0000bc  fb001002          MLA      r0,r0,r2,r1           ;1304
0000c0  edc00a02          VSTR     s1,[r0,#8]            ;1304
0000c4  68a2              LDR      r2,[r4,#8]            ;1304
0000c6  6921              LDR      r1,[r4,#0x10]         ;1304
0000c8  2002              MOVS     r0,#2                 ;1305
0000ca  fb001002          MLA      r0,r0,r2,r1           ;1305
0000ce  edc00a00          VSTR     s1,[r0,#0]            ;1305
0000d2  68a2              LDR      r2,[r4,#8]            ;1305
0000d4  6921              LDR      r1,[r4,#0x10]         ;1305
0000d6  2002              MOVS     r0,#2                 ;1305
0000d8  fb001002          MLA      r0,r0,r2,r1           ;1305
0000dc  ed801a01          VSTR     s2,[r0,#4]            ;1305
0000e0  ed9f1a15          VLDR     s2,|L26.312|
0000e4  68a2              LDR      r2,[r4,#8]            ;1307
0000e6  6921              LDR      r1,[r4,#0x10]         ;1307
0000e8  ee282a01          VMUL.F32 s4,s16,s2             ;1307
0000ec  2002              MOVS     r0,#2                 ;1305
0000ee  fb001002          MLA      r0,r0,r2,r1           ;1305
0000f2  ee002a61          VMLS.F32 s4,s0,s3              ;1307
0000f6  ed800a02          VSTR     s0,[r0,#8]            ;1305
0000fa  2000              MOVS     r0,#0                 ;1311
0000fc  ee322a22          VADD.F32 s4,s4,s5              ;1307
000100  ed852a00          VSTR     s4,[r5,#0]            ;1307
000104  edc50a01          VSTR     s1,[r5,#4]            ;1308
000108  ee680a21          VMUL.F32 s1,s16,s3             ;1309
00010c  ee400a01          VMLA.F32 s1,s0,s2              ;1309
000110  ed9f0a0a          VLDR     s0,|L26.316|
000114  ee300a80          VADD.F32 s0,s1,s0              ;1309
000118  ed850a02          VSTR     s0,[r5,#8]            ;1309
00011c  b003              ADD      sp,sp,#0xc
00011e  ecbd8b02          VPOP     {d8}
000122  bd30              POP      {r4,r5,pc}
;;;1313   
                          ENDP

                  |L26.292|
                          DCD      ||.constdata||+0x14c
                  |L26.296|
                          DCD      _ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEEs_1 ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)::string (instance 3)
                  |L26.300|
                          DCD      _ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEEs_0 ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)::string (instance 2)
                  |L26.304|
                          DCD      _ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEEs ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)::string
                  |L26.308|
000134  00000000          DCFS     0x00000000 ; 0
                  |L26.312|
000138  4099999a          DCFS     0x4099999a ; 4.8000001907348633
                  |L26.316|
00013c  423ecccd          DCFS     0x423ecccd ; 47.700000762939453

                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv||
                          DCD      0x00000001

                          AREA ||area_number.28||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem16SetImageSendModeENS0_15ImageSendMode_tENS_6Vision16CameraResolutionE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem16SetImageSendModeENS0_15ImageSendMode_tENS_6Vision16CameraResolutionE||
                          DCD      0x00000001

                          AREA ||area_number.29||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem22DownsampleAndSendImageERKNS_8Embedded5ArrayIhEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.29||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem22DownsampleAndSendImageERKNS_8Embedded5ArrayIhEE||
                          DCD      0x00000001

                          AREA ||area_number.30||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem16DownsampleHelperERKNS_8Embedded5ArrayIhEERS4_NS2_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.30||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem16DownsampleHelperERKNS_8Embedded5ArrayIhEERS4_NS2_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.31||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem20GetCameraCalibrationEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.31||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem20GetCameraCalibrationEv||
                          DCD      0x00000001

                          AREA ||area_number.32||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem22GetTrackingMarkerWidthEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.32||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem22GetTrackingMarkerWidthEv||
                          DCD      0x00000001

                          AREA ||area_number.33||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem14GetVerticalFOVEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.33||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem14GetVerticalFOVEv||
                          DCD      0x00000001

                          AREA ||area_number.34||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem16GetHorizontalFOVEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem16GetHorizontalFOVEv||
                          DCD      0x00000001

                          AREA ||area_number.35||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem22GetFaceDetectionParamsEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.35||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem22GetFaceDetectionParamsEv||
                          DCD      0x00000001

                          AREA ||area_number.36||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem4InitEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.36||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem4InitEv||
                          DCD      0x00000001

                          AREA ||area_number.37||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfRKNS_8Embedded5PointIfEEfb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.37||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfRKNS_8Embedded5PointIfEEfb||
                          DCD      0x00000001

                          AREA ||area_number.38||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.38||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfb||
                          DCD      0x00000001

                          AREA ||area_number.39||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem12StopTrackingEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem12StopTrackingEv||
                          DCD      0x00000001

                          AREA ||area_number.40||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem19StartDetectingFacesEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.40||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem19StartDetectingFacesEv||
                          DCD      0x00000001

                          AREA ||area_number.41||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem21GetObservedMarkerListEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem21GetObservedMarkerListEv||
                          DCD      0x00000001

                          AREA ||area_number.42||, LINKORDER=||t._ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE||
                          DCD      0x00000001

                          AREA ||area_number.43||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded5ArrayIfEERKNS2_6Point3IfEERS4_RS8_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded5ArrayIfEERKNS2_6Point3IfEERS4_RS8_||
                          DCD      0x00000001

                          AREA ||area_number.44||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem19GetVisionMarkerPoseERKNS_8Embedded12VisionMarkerEbRNS2_5ArrayIfEERNS2_6Point3IfEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem19GetVisionMarkerPoseERKNS_8Embedded12VisionMarkerEbRNS2_5ArrayIfEERNS2_6Point3IfEE||
                          DCD      0x00000001

                          AREA ||area_number.45||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem28GetVisionMarkerPoseNearestToERKNS_8Embedded6Point3IfEERKNS_6Vision10MarkerTypeEfRNS2_5ArrayIfEERS4_Rb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem28GetVisionMarkerPoseNearestToERKNS_8Embedded6Point3IfEERKNS_6Vision10MarkerTypeEfRNS2_5ArrayIfEERS4_Rb||
                          DCD      0x00000001

                          AREA ||area_number.46||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded6Point3IfEERS4_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded6Point3IfEERS4_||
                          DCD      0x00000001

                          AREA ||area_number.47||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem12TakeSnapshotENS_8Embedded9RectangleIiEEiRNS2_5ArrayIhEERb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem12TakeSnapshotENS_8Embedded9RectangleIiEEiRNS2_5ArrayIhEERb||
                          DCD      0x00000001

                          AREA ||area_number.48||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem6UpdateENS0_8Messages10RobotStateE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.48||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem6UpdateENS0_8Messages10RobotStateE||
                          DCD      0x00000001

                          AREA ||area_number.49||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem9SetParamsEbfiffhfb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.49||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem9SetParamsEbfiffhfb||
                          DCD      0x00000001

                          AREA ||area_number.50||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem19SetFaceDetectParamsEfiiiii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.50||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem19SetFaceDetectParamsEfiiiii||
                          DCD      0x00000001

                          AREA ||area_number.51||, LINKORDER=||i.__sti___24_offboardVisionSystem_cpp_b6ff7547||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___24_offboardVisionSystem_cpp_b6ff7547||
                          DCD      0x00000001

                          AREA ||area_number.52||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713MarkerToTrack5ClearEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.52||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713MarkerToTrack5ClearEv||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  _ZN4Anki5Cozmo12VisionSystem12VisionMemory9ccmBufferE ; Anki::Cozmo::VisionSystem::VisionMemory::ccmBuffer
                          %        5000
                  _ZN4Anki5Cozmo12VisionSystem12VisionMemory11ccmScratch_E ; Anki::Cozmo::VisionSystem::VisionMemory::ccmScratch_
                          %        28
                  _ZN4Anki5Cozmo12VisionSystem12VisionMemory8markers_E ; Anki::Cozmo::VisionSystem::VisionMemory::markers_
                          %        52
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713RcamWrtRobot_E ; Anki::Cozmo::VisionSystem::<unnamed>::RcamWrtRobot_
                          %        20
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754714markerToTrack_E ; Anki::Cozmo::VisionSystem::<unnamed>::markerToTrack_
                          %        24
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754717newMarkerToTrack_E ; Anki::Cozmo::VisionSystem::<unnamed>::newMarkerToTrack_
                          %        24
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713trackingQuad_E ; Anki::Cozmo::VisionSystem::<unnamed>::trackingQuad_
                          %        32
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754718canonicalMarker3d_E ; Anki::Cozmo::VisionSystem::<unnamed>::canonicalMarker3d_
                          %        48
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754711robotState_E ; Anki::Cozmo::VisionSystem::<unnamed>::robotState_
                          %        60
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754715prevRobotState_E ; Anki::Cozmo::VisionSystem::<unnamed>::prevRobotState_
                          %        60
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754720detectionParameters_E ; Anki::Cozmo::VisionSystem::<unnamed>::detectionParameters_
                          %        96
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754718trackerParameters_E ; Anki::Cozmo::VisionSystem::<unnamed>::trackerParameters_
                          %        68
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754724faceDetectionParameters_E ; Anki::Cozmo::VisionSystem::<unnamed>::faceDetectionParameters_
                          %        48
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754712snapshotROI_E ; Anki::Cozmo::VisionSystem::<unnamed>::snapshotROI_
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  _ZN4Anki6Vision13CameraResInfoE ; Anki::Vision::CameraResInfo
000000  0c800960          DCW      0x0c80,0x0960
000004  08000600          DCW      0x0800,0x0600
000008  064004b0          DCW      0x0640,0x04b0
00000c  050003c0          DCW      0x0500,0x03c0
000010  04000300          DCW      0x0400,0x0300
000014  03200258          DCW      0x0320,0x0258
000018  028001e0          DCW      0x0280,0x01e0
00001c  014000f0          DCW      0x0140,0x00f0
000020  00a00078          DCW      0x00a0,0x0078
000024  0050003c          DCW      0x0050,0x003c
000028  0028001e          DCW      0x0028,0x001e
00002c  00100010          DCW      0x0010,0x0010
                  __PRETTY_FUNCTION__
000030  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000034  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000038  73756c74          DCB      0x73,0x75,0x6c,0x74
00003c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000040  693a3a43          DCB      0x69,0x3a,0x3a,0x43
000044  6f7a6d6f          DCB      0x6f,0x7a,0x6d,0x6f
000048  3a3a5669          DCB      0x3a,0x3a,0x56,0x69
00004c  73696f6e          DCB      0x73,0x69,0x6f,0x6e
000050  53797374          DCB      0x53,0x79,0x73,0x74
000054  656d3a3a          DCB      0x65,0x6d,0x3a,0x3a
000058  55706461          DCB      0x55,0x70,0x64,0x61
00005c  74654d61          DCB      0x74,0x65,0x4d,0x61
000060  726b6572          DCB      0x72,0x6b,0x65,0x72
000064  546f5472          DCB      0x54,0x6f,0x54,0x72
000068  61636b28          DCB      0x61,0x63,0x6b,0x28
00006c  2900              DCB      0x29,0x00
                  |symbol_number.313|
00006e  416e              DCB      0x41,0x6e
000070  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000074  52657375          DCB      0x52,0x65,0x73,0x75
000078  6c742041          DCB      0x6c,0x74,0x20,0x41
00007c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000080  3a436f7a          DCB      0x3a,0x43,0x6f,0x7a
000084  6d6f3a3a          DCB      0x6d,0x6f,0x3a,0x3a
000088  56697369          DCB      0x56,0x69,0x73,0x69
00008c  6f6e5379          DCB      0x6f,0x6e,0x53,0x79
000090  7374656d          DCB      0x73,0x74,0x65,0x6d
000094  3a3a4765          DCB      0x3a,0x3a,0x47,0x65
000098  74566973          DCB      0x74,0x56,0x69,0x73
00009c  696f6e4d          DCB      0x69,0x6f,0x6e,0x4d
0000a0  61726b65          DCB      0x61,0x72,0x6b,0x65
0000a4  72506f73          DCB      0x72,0x50,0x6f,0x73
0000a8  654e6561          DCB      0x65,0x4e,0x65,0x61
0000ac  72657374          DCB      0x72,0x65,0x73,0x74
0000b0  546f2863          DCB      0x54,0x6f,0x28,0x63
0000b4  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0000b8  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000bc  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000c0  6d626564          DCB      0x6d,0x62,0x65,0x64
0000c4  6465643a          DCB      0x64,0x65,0x64,0x3a
0000c8  3a506f69          DCB      0x3a,0x50,0x6f,0x69
0000cc  6e74333c          DCB      0x6e,0x74,0x33,0x3c
0000d0  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000d4  743e2026          DCB      0x74,0x3e,0x20,0x26
0000d8  2c20636f          DCB      0x2c,0x20,0x63,0x6f
0000dc  6e737420          DCB      0x6e,0x73,0x74,0x20
0000e0  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000e4  3a3a5669          DCB      0x3a,0x3a,0x56,0x69
0000e8  73696f6e          DCB      0x73,0x69,0x6f,0x6e
0000ec  3a3a4d61          DCB      0x3a,0x3a,0x4d,0x61
0000f0  726b6572          DCB      0x72,0x6b,0x65,0x72
0000f4  54797065          DCB      0x54,0x79,0x70,0x65
0000f8  20262c20          DCB      0x20,0x26,0x2c,0x20
0000fc  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000100  742c2041          DCB      0x74,0x2c,0x20,0x41
000104  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000108  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00010c  65646465          DCB      0x65,0x64,0x64,0x65
000110  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000114  72726179          DCB      0x72,0x72,0x61,0x79
000118  3c666c6f          DCB      0x3c,0x66,0x6c,0x6f
00011c  61743e20          DCB      0x61,0x74,0x3e,0x20
000120  262c2041          DCB      0x26,0x2c,0x20,0x41
000124  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000128  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00012c  65646465          DCB      0x65,0x64,0x64,0x65
000130  643a3a50          DCB      0x64,0x3a,0x3a,0x50
000134  6f696e74          DCB      0x6f,0x69,0x6e,0x74
000138  333c666c          DCB      0x33,0x3c,0x66,0x6c
00013c  6f61743e          DCB      0x6f,0x61,0x74,0x3e
000140  20262c20          DCB      0x20,0x26,0x2c,0x20
000144  626f6f6c          DCB      0x62,0x6f,0x6f,0x6c
000148  20262900          DCB      0x20,0x26,0x29,0x00
                  _ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEE19__PRETTY_FUNCTION__ ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)::__PRETTY_FUNCTION__
00014c  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000150  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000154  73756c74          DCB      0x73,0x75,0x6c,0x74
000158  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00015c  693a3a43          DCB      0x69,0x3a,0x3a,0x43
000160  6f7a6d6f          DCB      0x6f,0x7a,0x6d,0x6f
000164  3a3a5669          DCB      0x3a,0x3a,0x56,0x69
000168  73696f6e          DCB      0x73,0x69,0x6f,0x6e
00016c  53797374          DCB      0x53,0x79,0x73,0x74
000170  656d3a3a          DCB      0x65,0x6d,0x3a,0x3a
000174  47657443          DCB      0x47,0x65,0x74,0x43
000178  616d506f          DCB      0x61,0x6d,0x50,0x6f
00017c  73655772          DCB      0x73,0x65,0x57,0x72
000180  74526f62          DCB      0x74,0x52,0x6f,0x62
000184  6f742841          DCB      0x6f,0x74,0x28,0x41
000188  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00018c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000190  65646465          DCB      0x65,0x64,0x64,0x65
000194  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000198  72726179          DCB      0x72,0x72,0x61,0x79
00019c  3c547970          DCB      0x3c,0x54,0x79,0x70
0001a0  653e2026          DCB      0x65,0x3e,0x20,0x26
0001a4  2c20416e          DCB      0x2c,0x20,0x41,0x6e
0001a8  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0001ac  456d6265          DCB      0x45,0x6d,0x62,0x65
0001b0  64646564          DCB      0x64,0x64,0x65,0x64
0001b4  3a3a506f          DCB      0x3a,0x3a,0x50,0x6f
0001b8  696e7433          DCB      0x69,0x6e,0x74,0x33
0001bc  3c547970          DCB      0x3c,0x54,0x79,0x70
0001c0  653e2026          DCB      0x65,0x3e,0x20,0x26
0001c4  29205b77          DCB      0x29,0x20,0x5b,0x77
0001c8  69746820          DCB      0x69,0x74,0x68,0x20
0001cc  50524543          DCB      0x50,0x52,0x45,0x43
0001d0  4953494f          DCB      0x49,0x53,0x49,0x4f
0001d4  4e203d20          DCB      0x4e,0x20,0x3d,0x20
0001d8  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0001dc  745d00            DCB      0x74,0x5d,0x00
                  |symbol_number.314|
0001df  41                DCB      0x41
0001e0  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0001e4  3a526573          DCB      0x3a,0x52,0x65,0x73
0001e8  756c7420          DCB      0x75,0x6c,0x74,0x20
0001ec  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0001f0  3a3a436f          DCB      0x3a,0x3a,0x43,0x6f
0001f4  7a6d6f3a          DCB      0x7a,0x6d,0x6f,0x3a
0001f8  3a566973          DCB      0x3a,0x56,0x69,0x73
0001fc  696f6e53          DCB      0x69,0x6f,0x6e,0x53
000200  79737465          DCB      0x79,0x73,0x74,0x65
000204  6d3a3a54          DCB      0x6d,0x3a,0x3a,0x54
000208  616b6553          DCB      0x61,0x6b,0x65,0x53
00020c  6e617073          DCB      0x6e,0x61,0x70,0x73
000210  686f7428          DCB      0x68,0x6f,0x74,0x28
000214  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000218  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00021c  62656464          DCB      0x62,0x65,0x64,0x64
000220  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000224  52656374          DCB      0x52,0x65,0x63,0x74
000228  616e676c          DCB      0x61,0x6e,0x67,0x6c
00022c  653c7369          DCB      0x65,0x3c,0x73,0x69
000230  676e6564          DCB      0x67,0x6e,0x65,0x64
000234  20696e74          DCB      0x20,0x69,0x6e,0x74
000238  3e2c2073          DCB      0x3e,0x2c,0x20,0x73
00023c  69676e65          DCB      0x69,0x67,0x6e,0x65
000240  6420696e          DCB      0x64,0x20,0x69,0x6e
000244  742c2041          DCB      0x74,0x2c,0x20,0x41
000248  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00024c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000250  65646465          DCB      0x65,0x64,0x64,0x65
000254  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000258  72726179          DCB      0x72,0x72,0x61,0x79
00025c  3c756e73          DCB      0x3c,0x75,0x6e,0x73
000260  69676e65          DCB      0x69,0x67,0x6e,0x65
000264  64206368          DCB      0x64,0x20,0x63,0x68
000268  61723e20          DCB      0x61,0x72,0x3e,0x20
00026c  262c2062          DCB      0x26,0x2c,0x20,0x62
000270  6f6f6c20          DCB      0x6f,0x6f,0x6c,0x20
000274  262900            DCB      0x26,0x29,0x00
                  |symbol_number.315|
000277  41                DCB      0x41
000278  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00027c  3a526573          DCB      0x3a,0x52,0x65,0x73
000280  756c7420          DCB      0x75,0x6c,0x74,0x20
000284  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000288  3a3a436f          DCB      0x3a,0x3a,0x43,0x6f
00028c  7a6d6f3a          DCB      0x7a,0x6d,0x6f,0x3a
000290  3a566973          DCB      0x3a,0x56,0x69,0x73
000294  696f6e53          DCB      0x69,0x6f,0x6e,0x53
000298  79737465          DCB      0x79,0x73,0x74,0x65
00029c  6d3a3a55          DCB      0x6d,0x3a,0x3a,0x55
0002a0  70646174          DCB      0x70,0x64,0x61,0x74
0002a4  6528416e          DCB      0x65,0x28,0x41,0x6e
0002a8  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0002ac  436f7a6d          DCB      0x43,0x6f,0x7a,0x6d
0002b0  6f3a3a4d          DCB      0x6f,0x3a,0x3a,0x4d
0002b4  65737361          DCB      0x65,0x73,0x73,0x61
0002b8  6765733a          DCB      0x67,0x65,0x73,0x3a
0002bc  3a526f62          DCB      0x3a,0x52,0x6f,0x62
0002c0  6f745374          DCB      0x6f,0x74,0x53,0x74
0002c4  61746529          DCB      0x61,0x74,0x65,0x29
0002c8  00                DCB      0x00

                          AREA ||area_number.57||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.constdata||
                  _ZN4Anki5Cozmo19NECK_JOINT_POSITIONE ; Anki::Cozmo::NECK_JOINT_POSITION
000000  c1500000          DCFS     0xc1500000 ; -13
000004  00000000          DCFS     0x00000000 ; 0
000008  423ecccd          DCFS     0x423ecccd ; 47.700000762939453

                          AREA ||area_number.58||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.constdata||
                  _ZN4Anki5Cozmo17HEAD_CAM_POSITIONE ; Anki::Cozmo::HEAD_CAM_POSITION
000000  4099999a          DCFS     0x4099999a ; 4.8000001907348633
000004  00000000          DCFS     0x00000000 ; 0
000008  c0c00000          DCFS     0xc0c00000 ; -6

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  536e6170          DCB      "Snapshot ROI size (%dx%d) subsampled by %d doesn't matc"
000004  73686f74
000008  20524f49
00000c  2073697a
000010  65202825
000014  64782564
000018  29207375
00001c  6273616d
000020  706c6564
000024  20627920
000028  25642064
00002c  6f65736e
000030  2774206d
000034  617463  
000037  6820736e          DCB      "h snapshot array size (%dx%d)!\n",0
00003b  61707368
00003f  6f742061
000043  72726179
000047  2073697a
00004b  65202825
00004f  64782564
000053  29210a00
000057  00                DCB      0
000058  46616365          DCB      "Face detection parameters not initialized before Update"
00005c  20646574
000060  65637469
000064  6f6e2070
000068  6172616d
00006c  65746572
000070  73206e6f
000074  7420696e
000078  69746961
00007c  6c697a65
000080  64206265
000084  666f7265
000088  20557064
00008c  617465  
00008f  28292069          DCB      "() in DETECTING_FACES mode.\n",0
000093  6e204445
000097  54454354
00009b  494e475f
00009f  46414345
0000a3  53206d6f
0000a7  64652e0a
0000ab  00      
0000ac  4368616e          DCB      "Changed VisionSystem params: autoExposureOn d exposureT"
0000b0  67656420
0000b4  56697369
0000b8  6f6e5379
0000bc  7374656d
0000c0  20706172
0000c4  616d733a
0000c8  20617574
0000cc  6f457870
0000d0  6f737572
0000d4  654f6e20
0000d8  64206578
0000dc  706f7375
0000e0  726554  
0000e3  696d6520          DCB      "ime %f integerCountsInc %d, minExpTime %f, maxExpTime %"
0000e7  25662069
0000eb  6e746567
0000ef  6572436f
0000f3  756e7473
0000f7  496e6320
0000fb  25642c20
0000ff  6d696e45
000103  78705469
000107  6d652025
00010b  662c206d
00010f  61784578
000113  7054696d
000117  652025  
00011a  662c2068          DCB      "f, highVal %d, percToMakeHigh %f\n",0
00011e  69676856
000122  616c2025
000126  642c2070
00012a  65726354
00012e  6f4d616b
000132  65486967
000136  68202566
00013a  0a00    

                          AREA ||.data||, DATA, ALIGN=2

                  isInitialized_
000000  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754720autoExposure_enabledE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_enabled
000001  01                DCB      0x01
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754722autoExposure_highValueE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_highValue
000002  fa                DCB      0xfa
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754725wifiCamera_limitFramerateE ; Anki::Cozmo::VisionSystem::<unnamed>::wifiCamera_limitFramerate
000003  01                DCB      0x01
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754728newMarkerToTrackWasProvided_E ; Anki::Cozmo::VisionSystem::<unnamed>::newMarkerToTrackWasProvided_
000004  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754714imageSendMode_E ; Anki::Cozmo::VisionSystem::<unnamed>::imageSendMode_
000005  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754724nextSendImageResolution_E ; Anki::Cozmo::VisionSystem::<unnamed>::nextSendImageResolution_
000006  0c                DCB      0x0c
                  streamFrameCnt
000007  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff75475mode_E ; Anki::Cozmo::VisionSystem::<unnamed>::mode_
000008  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754714wasCalledOnce_E ; Anki::Cozmo::VisionSystem::<unnamed>::wasCalledOnce_
000009  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754723havePreviousRobotState_E ; Anki::Cozmo::VisionSystem::<unnamed>::havePreviousRobotState_
00000a  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754718captureResolution_E ; Anki::Cozmo::VisionSystem::<unnamed>::captureResolution_
00000b  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754720isWaitingOnSnapshot_E ; Anki::Cozmo::VisionSystem::<unnamed>::isWaitingOnSnapshot_
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754735autoExposure_integerCountsIncrementE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_integerCountsIncrement
                          DCD      0x00000003
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754728autoExposure_minExposureTimeE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_minExposureTime
000014  3ca3d70a          DCFS     0x3ca3d70a ; 0.019999999552965164
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754728autoExposure_maxExposureTimeE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_maxExposureTime
000018  3f000000          DCFS     0x3f000000 ; 0.5
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754733autoExposure_percentileToMakeHighE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_percentileToMakeHigh
00001c  3f733333          DCFS     0x3f733333 ; 0.94999998807907104
                  imgID
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754712headCamInfo_E ; Anki::Cozmo::VisionSystem::<unnamed>::headCamInfo_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754715headCamFOV_ver_E ; Anki::Cozmo::VisionSystem::<unnamed>::headCamFOV_ver_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754715headCamFOV_hor_E ; Anki::Cozmo::VisionSystem::<unnamed>::headCamFOV_hor_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754713exposureTime_E ; Anki::Cozmo::VisionSystem::<unnamed>::exposureTime_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754711frameNumberE ; Anki::Cozmo::VisionSystem::<unnamed>::frameNumber
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754717numTrackFailures_E ; Anki::Cozmo::VisionSystem::<unnamed>::numTrackFailures_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754716isSnapshotReady_E ; Anki::Cozmo::VisionSystem::<unnamed>::isSnapshotReady_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff754718snapshotSubsample_E ; Anki::Cozmo::VisionSystem::<unnamed>::snapshotSubsample_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem48_GLOBAL__N__24_offboardVisionSystem_cpp_b6ff75479snapshot_E ; Anki::Cozmo::VisionSystem::<unnamed>::snapshot_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo21ROBOT_BOUNDING_RADIUSE ; Anki::Cozmo::ROBOT_BOUNDING_RADIUS
                          DCD      0x00000000

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___24_offboardVisionSystem_cpp_b6ff7547

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a416c6c          DCB      0x3a,0x41,0x6c,0x6c
000010  6f636174          DCB      0x6f,0x63,0x61,0x74
000014  65427566          DCB      0x65,0x42,0x75,0x66
000018  66657246          DCB      0x66,0x65,0x72,0x46
00001c  726f6d4d          DCB      0x72,0x6f,0x6d,0x4d
000020  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000024  79537461          DCB      0x79,0x53,0x74,0x61
000028  636b00            DCB      0x63,0x6b,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0 ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1 ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs ; Anki::Embedded::Array<float>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a436f6d          DCB      0x3a,0x43,0x6f,0x6d
000010  70757465          DCB      0x70,0x75,0x74,0x65
000014  52657175          DCB      0x52,0x65,0x71,0x75
000018  69726564          DCB      0x69,0x72,0x65,0x64
00001c  53747269          DCB      0x53,0x74,0x72,0x69
000020  646500            DCB      0x64,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<float>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<float>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  2e417272          DCB      0x2e,0x41,0x72,0x72
000008  61793264          DCB      0x61,0x79,0x32,0x64
00000c  2e696e69          DCB      0x2e,0x69,0x6e,0x69
000010  7469616c          DCB      0x74,0x69,0x61,0x6c
000014  697a6500          DCB      0x69,0x7a,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  696e7075          DCB      0x69,0x6e,0x70,0x75
000004  74206461          DCB      0x74,0x20,0x64,0x61
000008  74612062          DCB      0x74,0x61,0x20,0x62
00000c  75666665          DCB      0x75,0x66,0x66,0x65
000010  72206973          DCB      0x72,0x20,0x69,0x73
000014  204e554c          DCB      0x20,0x4e,0x55,0x4c
000018  4c00              DCB      0x4c,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2 ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 4)
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a496e69          DCB      0x3a,0x49,0x6e,0x69
000010  7469616c          DCB      0x74,0x69,0x61,0x6c
000014  697a6542          DCB      0x69,0x7a,0x65,0x42
000018  75666665          DCB      0x75,0x66,0x66,0x65
00001c  7200              DCB      0x72,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3 ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 5)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4 ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 6)
000000  46696c6c          DCB      0x46,0x69,0x6c,0x6c
000004  20706174          DCB      0x20,0x70,0x61,0x74
000008  7465726e          DCB      0x74,0x65,0x72,0x6e
00000c  73206e6f          DCB      0x73,0x20,0x6e,0x6f
000010  74207375          DCB      0x74,0x20,0x73,0x75
000014  70706f72          DCB      0x70,0x70,0x6f,0x72
000018  74656420          DCB      0x74,0x65,0x64,0x20
00001c  666f7220          DCB      0x66,0x6f,0x72,0x20
000020  41727261          DCB      0x41,0x72,0x72,0x61
000024  7900              DCB      0x79,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5 ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 7)
000000  496e7075          DCB      0x49,0x6e,0x70,0x75
000004  74206461          DCB      0x74,0x20,0x64,0x61
000008  74612062          DCB      0x74,0x61,0x20,0x62
00000c  75666665          DCB      0x75,0x66,0x66,0x65
000010  72206973          DCB      0x72,0x20,0x69,0x73
000014  206e6f74          DCB      0x20,0x6e,0x6f,0x74
000018  206c6172          DCB      0x20,0x6c,0x61,0x72
00001c  67652065          DCB      0x67,0x65,0x20,0x65
000020  6e6f7567          DCB      0x6e,0x6f,0x75,0x67
000024  682e2025          DCB      0x68,0x2e,0x20,0x25
000028  64206279          DCB      0x64,0x20,0x62,0x79
00002c  74657320          DCB      0x74,0x65,0x73,0x20
000030  69732072          DCB      0x69,0x73,0x20,0x72
000034  65717569          DCB      0x65,0x71,0x75,0x69
000038  7265642e          DCB      0x72,0x65,0x64,0x2e
00003c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a417272          DCB      0x3a,0x41,0x72,0x72
000010  617900            DCB      0x61,0x79,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a416c6c          DCB      0x3a,0x41,0x6c,0x6c
000010  6f636174          DCB      0x6f,0x63,0x61,0x74
000014  65427566          DCB      0x65,0x42,0x75,0x66
000018  66657246          DCB      0x66,0x65,0x72,0x46
00001c  726f6d4d          DCB      0x72,0x6f,0x6d,0x4d
000020  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000024  79537461          DCB      0x79,0x53,0x74,0x61
000028  636b00            DCB      0x63,0x6b,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0 ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1 ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs ; Anki::Embedded::Array<unsigned char>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a436f6d          DCB      0x3a,0x43,0x6f,0x6d
000010  70757465          DCB      0x70,0x75,0x74,0x65
000014  52657175          DCB      0x52,0x65,0x71,0x75
000018  69726564          DCB      0x69,0x72,0x65,0x64
00001c  53747269          DCB      0x53,0x74,0x72,0x69
000020  646500            DCB      0x64,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<unsigned char>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<unsigned char>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  2e417272          DCB      0x2e,0x41,0x72,0x72
000008  61793264          DCB      0x61,0x79,0x32,0x64
00000c  2e696e69          DCB      0x2e,0x69,0x6e,0x69
000010  7469616c          DCB      0x74,0x69,0x61,0x6c
000014  697a6500          DCB      0x69,0x7a,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  696e7075          DCB      0x69,0x6e,0x70,0x75
000004  74206461          DCB      0x74,0x20,0x64,0x61
000008  74612062          DCB      0x74,0x61,0x20,0x62
00000c  75666665          DCB      0x75,0x66,0x66,0x65
000010  72206973          DCB      0x72,0x20,0x69,0x73
000014  204e554c          DCB      0x20,0x4e,0x55,0x4c
000018  4c00              DCB      0x4c,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2 ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 4)
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a496e69          DCB      0x3a,0x49,0x6e,0x69
000010  7469616c          DCB      0x74,0x69,0x61,0x6c
000014  697a6542          DCB      0x69,0x7a,0x65,0x42
000018  75666665          DCB      0x75,0x66,0x66,0x65
00001c  7200              DCB      0x72,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3 ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 5)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4 ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 6)
000000  46696c6c          DCB      0x46,0x69,0x6c,0x6c
000004  20706174          DCB      0x20,0x70,0x61,0x74
000008  7465726e          DCB      0x74,0x65,0x72,0x6e
00000c  73206e6f          DCB      0x73,0x20,0x6e,0x6f
000010  74207375          DCB      0x74,0x20,0x73,0x75
000014  70706f72          DCB      0x70,0x70,0x6f,0x72
000018  74656420          DCB      0x74,0x65,0x64,0x20
00001c  666f7220          DCB      0x66,0x6f,0x72,0x20
000020  41727261          DCB      0x41,0x72,0x72,0x61
000024  7900              DCB      0x79,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5 ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 7)
000000  496e7075          DCB      0x49,0x6e,0x70,0x75
000004  74206461          DCB      0x74,0x20,0x64,0x61
000008  74612062          DCB      0x74,0x61,0x20,0x62
00000c  75666665          DCB      0x75,0x66,0x66,0x65
000010  72206973          DCB      0x72,0x20,0x69,0x73
000014  206e6f74          DCB      0x20,0x6e,0x6f,0x74
000018  206c6172          DCB      0x20,0x6c,0x61,0x72
00001c  67652065          DCB      0x67,0x65,0x20,0x65
000020  6e6f7567          DCB      0x6e,0x6f,0x75,0x67
000024  682e2025          DCB      0x68,0x2e,0x20,0x25
000028  64206279          DCB      0x64,0x20,0x62,0x79
00002c  74657320          DCB      0x74,0x65,0x73,0x20
000030  69732072          DCB      0x69,0x73,0x20,0x72
000034  65717569          DCB      0x65,0x71,0x75,0x69
000038  7265642e          DCB      0x72,0x65,0x64,0x2e
00003c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a417272          DCB      0x3a,0x41,0x72,0x72
000010  617900            DCB      0x61,0x79,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiEs||, COMGROUP=_ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiEs ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::string
000000  4c696e65          DCB      0x4c,0x69,0x6e,0x65
000004  61725365          DCB      0x61,0x72,0x53,0x65
000008  7175656e          DCB      0x71,0x75,0x65,0x6e
00000c  63653c54          DCB      0x63,0x65,0x3c,0x54
000010  7970653e          DCB      0x79,0x70,0x65,0x3e
000014  3a3a636f          DCB      0x3a,0x3a,0x63,0x6f
000018  6d707574          DCB      0x6d,0x70,0x75,0x74
00001c  6553697a          DCB      0x65,0x53,0x69,0x7a
000020  6500              DCB      0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiEs_0||, COMGROUP=_ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiEs_0 ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::string (instance 2)
000000  73697a65          DCB      0x73,0x69,0x7a,0x65
000004  20657374          DCB      0x20,0x65,0x73,0x74
000008  696d6174          DCB      0x69,0x6d,0x61,0x74
00000c  696f6e20          DCB      0x69,0x6f,0x6e,0x20
000010  6661696c          DCB      0x66,0x61,0x69,0x6c
000014  656400            DCB      0x65,0x64,0x00

                          AREA ||.data__ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiEs_1||, COMGROUP=_ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiEs_1 ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f736571          DCB      0x2f,0x73,0x65,0x71
000030  75656e63          DCB      0x75,0x65,0x6e,0x63
000034  65732e68          DCB      0x65,0x73,0x2e,0x68
000038  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a536574          DCB      0x3a,0x53,0x65,0x74
000010  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs_0 ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  6f626a65          DCB      0x6f,0x62,0x6a,0x65
00000c  63747300          DCB      0x63,0x74,0x73,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs_1 ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs_2||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs_2, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEEs_2 ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::string (instance 4)
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  79207369          DCB      0x79,0x20,0x73,0x69
000008  7a657320          DCB      0x7a,0x65,0x73,0x20
00000c  646f6e27          DCB      0x64,0x6f,0x6e,0x27
000010  74206d61          DCB      0x74,0x20,0x6d,0x61
000014  74636800          DCB      0x74,0x63,0x68,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiEs||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiEs, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiEs ; Anki::Embedded::Array<unsigned char>::get_size(int) const::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a676574          DCB      0x3a,0x67,0x65,0x74
000010  5f73697a          DCB      0x5f,0x73,0x69,0x7a
000014  6500              DCB      0x65,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiEs_0||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiEs_0, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiEs_0 ; Anki::Embedded::Array<unsigned char>::get_size(int) const::string (instance 2)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiEs_1||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiEs_1, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiEs_1 ; Anki::Embedded::Array<unsigned char>::get_size(int) const::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayINS0_12VisionMarkerEE8get_sizeEiEs||, COMGROUP=_ZZNK4Anki8Embedded5ArrayINS0_12VisionMarkerEE8get_sizeEiEs, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayINS0_12VisionMarkerEE8get_sizeEiEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::get_size(int) const::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a676574          DCB      0x3a,0x67,0x65,0x74
000010  5f73697a          DCB      0x5f,0x73,0x69,0x7a
000014  6500              DCB      0x65,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayINS0_12VisionMarkerEE8get_sizeEiEs_0||, COMGROUP=_ZZNK4Anki8Embedded5ArrayINS0_12VisionMarkerEE8get_sizeEiEs_0, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayINS0_12VisionMarkerEE8get_sizeEiEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::get_size(int) const::string (instance 2)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayINS0_12VisionMarkerEE8get_sizeEiEs_1||, COMGROUP=_ZZNK4Anki8Embedded5ArrayINS0_12VisionMarkerEE8get_sizeEiEs_1, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayINS0_12VisionMarkerEE8get_sizeEiEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::get_size(int) const::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a416c6c          DCB      0x3a,0x41,0x6c,0x6c
000010  6f636174          DCB      0x6f,0x63,0x61,0x74
000014  65427566          DCB      0x65,0x42,0x75,0x66
000018  66657246          DCB      0x66,0x65,0x72,0x46
00001c  726f6d4d          DCB      0x72,0x6f,0x6d,0x4d
000020  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000024  79537461          DCB      0x79,0x53,0x74,0x61
000028  636b00            DCB      0x63,0x6b,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a436f6d          DCB      0x3a,0x43,0x6f,0x6d
000010  70757465          DCB      0x70,0x75,0x74,0x65
000014  52657175          DCB      0x52,0x65,0x71,0x75
000018  69726564          DCB      0x69,0x72,0x65,0x64
00001c  53747269          DCB      0x53,0x74,0x72,0x69
000020  646500            DCB      0x64,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  2e417272          DCB      0x2e,0x41,0x72,0x72
000008  61793264          DCB      0x61,0x79,0x32,0x64
00000c  2e696e69          DCB      0x2e,0x69,0x6e,0x69
000010  7469616c          DCB      0x74,0x69,0x61,0x6c
000014  697a6500          DCB      0x69,0x7a,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  696e7075          DCB      0x69,0x6e,0x70,0x75
000004  74206461          DCB      0x74,0x20,0x64,0x61
000008  74612062          DCB      0x74,0x61,0x20,0x62
00000c  75666665          DCB      0x75,0x66,0x66,0x65
000010  72206973          DCB      0x72,0x20,0x69,0x73
000014  204e554c          DCB      0x20,0x4e,0x55,0x4c
000018  4c00              DCB      0x4c,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 4)
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a496e69          DCB      0x3a,0x49,0x6e,0x69
000010  7469616c          DCB      0x74,0x69,0x61,0x6c
000014  697a6542          DCB      0x69,0x7a,0x65,0x42
000018  75666665          DCB      0x75,0x66,0x66,0x65
00001c  7200              DCB      0x72,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 5)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 6)
000000  46696c6c          DCB      0x46,0x69,0x6c,0x6c
000004  20706174          DCB      0x20,0x70,0x61,0x74
000008  7465726e          DCB      0x74,0x65,0x72,0x6e
00000c  73206e6f          DCB      0x73,0x20,0x6e,0x6f
000010  74207375          DCB      0x74,0x20,0x73,0x75
000014  70706f72          DCB      0x70,0x70,0x6f,0x72
000018  74656420          DCB      0x74,0x65,0x64,0x20
00001c  666f7220          DCB      0x66,0x6f,0x72,0x20
000020  41727261          DCB      0x41,0x72,0x72,0x61
000024  7900              DCB      0x79,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 7)
000000  496e7075          DCB      0x49,0x6e,0x70,0x75
000004  74206461          DCB      0x74,0x20,0x64,0x61
000008  74612062          DCB      0x74,0x61,0x20,0x62
00000c  75666665          DCB      0x75,0x66,0x66,0x65
000010  72206973          DCB      0x72,0x20,0x69,0x73
000014  206e6f74          DCB      0x20,0x6e,0x6f,0x74
000018  206c6172          DCB      0x20,0x6c,0x61,0x72
00001c  67652065          DCB      0x67,0x65,0x20,0x65
000020  6e6f7567          DCB      0x6e,0x6f,0x75,0x67
000024  682e2025          DCB      0x68,0x2e,0x20,0x25
000028  64206279          DCB      0x64,0x20,0x62,0x79
00002c  74657320          DCB      0x74,0x65,0x73,0x20
000030  69732072          DCB      0x69,0x73,0x20,0x72
000034  65717569          DCB      0x65,0x71,0x75,0x69
000038  7265642e          DCB      0x72,0x65,0x64,0x2e
00003c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a417272          DCB      0x3a,0x41,0x72,0x72
000010  617900            DCB      0x61,0x79,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs ; Anki::Embedded::Array<unsigned>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a416c6c          DCB      0x3a,0x41,0x6c,0x6c
000010  6f636174          DCB      0x6f,0x63,0x61,0x74
000014  65427566          DCB      0x65,0x42,0x75,0x66
000018  66657246          DCB      0x66,0x65,0x72,0x46
00001c  726f6d4d          DCB      0x72,0x6f,0x6d,0x4d
000020  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000024  79537461          DCB      0x79,0x53,0x74,0x61
000028  636b00            DCB      0x63,0x6b,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0 ; Anki::Embedded::Array<unsigned>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1 ; Anki::Embedded::Array<unsigned>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs ; Anki::Embedded::Array<unsigned>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a436f6d          DCB      0x3a,0x43,0x6f,0x6d
000010  70757465          DCB      0x70,0x75,0x74,0x65
000014  52657175          DCB      0x52,0x65,0x71,0x75
000018  69726564          DCB      0x69,0x72,0x65,0x64
00001c  53747269          DCB      0x53,0x74,0x72,0x69
000020  646500            DCB      0x64,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<unsigned>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<unsigned>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  2e417272          DCB      0x2e,0x41,0x72,0x72
000008  61793264          DCB      0x61,0x79,0x32,0x64
00000c  2e696e69          DCB      0x2e,0x69,0x6e,0x69
000010  7469616c          DCB      0x74,0x69,0x61,0x6c
000014  697a6500          DCB      0x69,0x7a,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  696e7075          DCB      0x69,0x6e,0x70,0x75
000004  74206461          DCB      0x74,0x20,0x64,0x61
000008  74612062          DCB      0x74,0x61,0x20,0x62
00000c  75666665          DCB      0x75,0x66,0x66,0x65
000010  72206973          DCB      0x72,0x20,0x69,0x73
000014  204e554c          DCB      0x20,0x4e,0x55,0x4c
000018  4c00              DCB      0x4c,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2 ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 4)
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a496e69          DCB      0x3a,0x49,0x6e,0x69
000010  7469616c          DCB      0x74,0x69,0x61,0x6c
000014  697a6542          DCB      0x69,0x7a,0x65,0x42
000018  75666665          DCB      0x75,0x66,0x66,0x65
00001c  7200              DCB      0x72,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3 ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 5)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4 ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 6)
000000  46696c6c          DCB      0x46,0x69,0x6c,0x6c
000004  20706174          DCB      0x20,0x70,0x61,0x74
000008  7465726e          DCB      0x74,0x65,0x72,0x6e
00000c  73206e6f          DCB      0x73,0x20,0x6e,0x6f
000010  74207375          DCB      0x74,0x20,0x73,0x75
000014  70706f72          DCB      0x70,0x70,0x6f,0x72
000018  74656420          DCB      0x74,0x65,0x64,0x20
00001c  666f7220          DCB      0x66,0x6f,0x72,0x20
000020  41727261          DCB      0x41,0x72,0x72,0x61
000024  7900              DCB      0x79,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5 ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 7)
000000  496e7075          DCB      0x49,0x6e,0x70,0x75
000004  74206461          DCB      0x74,0x20,0x64,0x61
000008  74612062          DCB      0x74,0x61,0x20,0x62
00000c  75666665          DCB      0x75,0x66,0x66,0x65
000010  72206973          DCB      0x72,0x20,0x69,0x73
000014  206e6f74          DCB      0x20,0x6e,0x6f,0x74
000018  206c6172          DCB      0x20,0x6c,0x61,0x72
00001c  67652065          DCB      0x67,0x65,0x20,0x65
000020  6e6f7567          DCB      0x6e,0x6f,0x75,0x67
000024  682e2025          DCB      0x68,0x2e,0x20,0x25
000028  64206279          DCB      0x64,0x20,0x62,0x79
00002c  74657320          DCB      0x74,0x65,0x73,0x20
000030  69732072          DCB      0x69,0x73,0x20,0x72
000034  65717569          DCB      0x65,0x71,0x75,0x69
000038  7265642e          DCB      0x72,0x65,0x64,0x2e
00003c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs ; Anki::Embedded::Array<unsigned>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a417272          DCB      0x3a,0x41,0x72,0x72
000010  617900            DCB      0x61,0x79,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<unsigned>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<unsigned>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIjE8get_sizeEiEs||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIjE8get_sizeEiEs, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIjE8get_sizeEiEs ; Anki::Embedded::Array<unsigned>::get_size(int) const::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a676574          DCB      0x3a,0x67,0x65,0x74
000010  5f73697a          DCB      0x5f,0x73,0x69,0x7a
000014  6500              DCB      0x65,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIjE8get_sizeEiEs_0||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIjE8get_sizeEiEs_0, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIjE8get_sizeEiEs_0 ; Anki::Embedded::Array<unsigned>::get_size(int) const::string (instance 2)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIjE8get_sizeEiEs_1||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIjE8get_sizeEiEs_1, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIjE8get_sizeEiEs_1 ; Anki::Embedded::Array<unsigned>::get_size(int) const::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE7SetZeroEvEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE7SetZeroEvEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE7SetZeroEvEs ; Anki::Embedded::Array<unsigned>::SetZero()::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a536574          DCB      0x3a,0x53,0x65,0x74
000010  5a65726f          DCB      0x5a,0x65,0x72,0x6f
000014  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE7SetZeroEvEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE7SetZeroEvEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE7SetZeroEvEs_0 ; Anki::Embedded::Array<unsigned>::SetZero()::string (instance 2)
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e20          DCB      0x70,0x65,0x3e,0x20
00000c  6973206e          DCB      0x69,0x73,0x20,0x6e
000010  6f742076          DCB      0x6f,0x74,0x20,0x76
000014  616c6964          DCB      0x61,0x6c,0x69,0x64
000018  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIjE7SetZeroEvEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE7SetZeroEvEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE7SetZeroEvEs_1 ; Anki::Embedded::Array<unsigned>::SetZero()::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs||, COMGROUP=_ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::string
000000  446f776e          DCB      0x44,0x6f,0x77,0x6e
000004  73616d70          DCB      0x73,0x61,0x6d,0x70
000008  6c654279          DCB      0x6c,0x65,0x42,0x79
00000c  46616374          DCB      0x46,0x61,0x63,0x74
000010  6f7200            DCB      0x6f,0x72,0x00

                          AREA ||.data__ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_0||, COMGROUP=_ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_0 ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  6f626a65          DCB      0x6f,0x62,0x6a,0x65
00000c  63747300          DCB      0x63,0x74,0x73,0x00

                          AREA ||.data__ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_1||, COMGROUP=_ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_1 ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  76697369          DCB      0x76,0x69,0x73,0x69
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  76697369          DCB      0x76,0x69,0x73,0x69
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f696d61          DCB      0x2f,0x69,0x6d,0x61
000030  67655072          DCB      0x67,0x65,0x50,0x72
000034  6f636573          DCB      0x6f,0x63,0x65,0x73
000038  73696e67          DCB      0x73,0x69,0x6e,0x67
00003c  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_2||, COMGROUP=_ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_2, DATA, ALIGN=0

                  _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_2 ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::string (instance 4)
000000  73697a65          DCB      0x73,0x69,0x7a,0x65
000004  286f7574          DCB      0x28,0x6f,0x75,0x74
000008  29206973          DCB      0x29,0x20,0x69,0x73
00000c  206e6f74          DCB      0x20,0x6e,0x6f,0x74
000010  20657175          DCB      0x20,0x65,0x71,0x75
000014  616c2074          DCB      0x61,0x6c,0x20,0x74
000018  6f207369          DCB      0x6f,0x20,0x73,0x69
00001c  7a652869          DCB      0x7a,0x65,0x28,0x69
000020  6e29203e          DCB      0x6e,0x29,0x20,0x3e
000024  3e20646f          DCB      0x3e,0x20,0x64,0x6f
000028  776e7361          DCB      0x77,0x6e,0x73,0x61
00002c  6d706c65          DCB      0x6d,0x70,0x6c,0x65
000030  46616374          DCB      0x46,0x61,0x63,0x74
000034  6f7200            DCB      0x6f,0x72,0x00

                          AREA ||.data__ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_3||, COMGROUP=_ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_3, DATA, ALIGN=0

                  _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_3 ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::string (instance 5)
000000  54686520          DCB      0x54,0x68,0x65,0x20
000004  77696474          DCB      0x77,0x69,0x64,0x74
000008  68206f66          DCB      0x68,0x20,0x6f,0x66
00000c  20746865          DCB      0x20,0x74,0x68,0x65
000010  20696e20          DCB      0x20,0x69,0x6e,0x20
000014  41727261          DCB      0x41,0x72,0x72,0x61
000018  79206d75          DCB      0x79,0x20,0x6d,0x75
00001c  73742062          DCB      0x73,0x74,0x20,0x62
000020  65206120          DCB      0x65,0x20,0x61,0x20
000024  6d756c74          DCB      0x6d,0x75,0x6c,0x74
000028  69706c65          DCB      0x69,0x70,0x6c,0x65
00002c  206f6620          DCB      0x20,0x6f,0x66,0x20
000030  666f7572          DCB      0x66,0x6f,0x75,0x72
000034  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a416c6c          DCB      0x3a,0x41,0x6c,0x6c
000010  6f636174          DCB      0x6f,0x63,0x61,0x74
000014  65427566          DCB      0x65,0x42,0x75,0x66
000018  66657246          DCB      0x66,0x65,0x72,0x46
00001c  726f6d4d          DCB      0x72,0x6f,0x6d,0x4d
000020  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000024  79537461          DCB      0x79,0x53,0x74,0x61
000028  636b00            DCB      0x63,0x6b,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a436f6d          DCB      0x3a,0x43,0x6f,0x6d
000010  70757465          DCB      0x70,0x75,0x74,0x65
000014  52657175          DCB      0x52,0x65,0x71,0x75
000018  69726564          DCB      0x69,0x72,0x65,0x64
00001c  53747269          DCB      0x53,0x74,0x72,0x69
000020  646500            DCB      0x64,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  2e417272          DCB      0x2e,0x41,0x72,0x72
000008  61793264          DCB      0x61,0x79,0x32,0x64
00000c  2e696e69          DCB      0x2e,0x69,0x6e,0x69
000010  7469616c          DCB      0x74,0x69,0x61,0x6c
000014  697a6500          DCB      0x69,0x7a,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  696e7075          DCB      0x69,0x6e,0x70,0x75
000004  74206461          DCB      0x74,0x20,0x64,0x61
000008  74612062          DCB      0x74,0x61,0x20,0x62
00000c  75666665          DCB      0x75,0x66,0x66,0x65
000010  72206973          DCB      0x72,0x20,0x69,0x73
000014  204e554c          DCB      0x20,0x4e,0x55,0x4c
000018  4c00              DCB      0x4c,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 4)
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a496e69          DCB      0x3a,0x49,0x6e,0x69
000010  7469616c          DCB      0x74,0x69,0x61,0x6c
000014  697a6542          DCB      0x69,0x7a,0x65,0x42
000018  75666665          DCB      0x75,0x66,0x66,0x65
00001c  7200              DCB      0x72,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 5)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 6)
000000  46696c6c          DCB      0x46,0x69,0x6c,0x6c
000004  20706174          DCB      0x20,0x70,0x61,0x74
000008  7465726e          DCB      0x74,0x65,0x72,0x6e
00000c  73206e6f          DCB      0x73,0x20,0x6e,0x6f
000010  74207375          DCB      0x74,0x20,0x73,0x75
000014  70706f72          DCB      0x70,0x70,0x6f,0x72
000018  74656420          DCB      0x74,0x65,0x64,0x20
00001c  666f7220          DCB      0x66,0x6f,0x72,0x20
000020  41727261          DCB      0x41,0x72,0x72,0x61
000024  7900              DCB      0x79,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 7)
000000  496e7075          DCB      0x49,0x6e,0x70,0x75
000004  74206461          DCB      0x74,0x20,0x64,0x61
000008  74612062          DCB      0x74,0x61,0x20,0x62
00000c  75666665          DCB      0x75,0x66,0x66,0x65
000010  72206973          DCB      0x72,0x20,0x69,0x73
000014  206e6f74          DCB      0x20,0x6e,0x6f,0x74
000018  206c6172          DCB      0x20,0x6c,0x61,0x72
00001c  67652065          DCB      0x67,0x65,0x20,0x65
000020  6e6f7567          DCB      0x6e,0x6f,0x75,0x67
000024  682e2025          DCB      0x68,0x2e,0x20,0x25
000028  64206279          DCB      0x64,0x20,0x62,0x79
00002c  74657320          DCB      0x74,0x65,0x73,0x20
000030  69732072          DCB      0x69,0x73,0x20,0x72
000034  65717569          DCB      0x65,0x71,0x75,0x69
000038  7265642e          DCB      0x72,0x65,0x64,0x2e
00003c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a417272          DCB      0x3a,0x41,0x72,0x72
000010  617900            DCB      0x61,0x79,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE8get_sizeEiEs||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE8get_sizeEiEs, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE8get_sizeEiEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::get_size(int) const::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a676574          DCB      0x3a,0x67,0x65,0x74
000010  5f73697a          DCB      0x5f,0x73,0x69,0x7a
000014  6500              DCB      0x65,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE8get_sizeEiEs_0||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE8get_sizeEiEs_0, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE8get_sizeEiEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::get_size(int) const::string (instance 2)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE8get_sizeEiEs_1||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE8get_sizeEiEs_1, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE8get_sizeEiEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::get_size(int) const::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiEs||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiEs, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiEs ; Anki::Embedded::Array<float>::get_size(int) const::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a676574          DCB      0x3a,0x67,0x65,0x74
000010  5f73697a          DCB      0x5f,0x73,0x69,0x7a
000014  6500              DCB      0x65,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiEs_0||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiEs_0, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiEs_0 ; Anki::Embedded::Array<float>::get_size(int) const::string (instance 2)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiEs_1||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiEs_1, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiEs_1 ; Anki::Embedded::Array<float>::get_size(int) const::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEEs||, COMGROUP=_ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEEs, DATA, ALIGN=0

                  _ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEEs ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)::string
000000  56697369          DCB      0x56,0x69,0x73,0x69
000004  6f6e5379          DCB      0x6f,0x6e,0x53,0x79
000008  7374656d          DCB      0x73,0x74,0x65,0x6d
00000c  3a3a4765          DCB      0x3a,0x3a,0x47,0x65
000010  7443616d          DCB      0x74,0x43,0x61,0x6d
000014  506f7365          DCB      0x50,0x6f,0x73,0x65
000018  57727452          DCB      0x57,0x72,0x74,0x52
00001c  6f626f74          DCB      0x6f,0x62,0x6f,0x74
000020  00                DCB      0x00

                          AREA ||.data__ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEEs_0||, COMGROUP=_ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEEs_0, DATA, ALIGN=0

                  _ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEEs_0 ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)::string (instance 2)
000000  526f7461          DCB      0x52,0x6f,0x74,0x61
000004  74696f6e          DCB      0x74,0x69,0x6f,0x6e
000008  206d6174          DCB      0x20,0x6d,0x61,0x74
00000c  72697820          DCB      0x72,0x69,0x78,0x20
000010  6d757374          DCB      0x6d,0x75,0x73,0x74
000014  20616c72          DCB      0x20,0x61,0x6c,0x72
000018  65616479          DCB      0x65,0x61,0x64,0x79
00001c  20626520          DCB      0x20,0x62,0x65,0x20
000020  3378332e          DCB      0x33,0x78,0x33,0x2e
000024  00                DCB      0x00

                          AREA ||.data__ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEEs_1||, COMGROUP=_ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEEs_1, DATA, ALIGN=0

                  _ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEEs_1 ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)::string (instance 3)
000000  73757065          DCB      0x73,0x75,0x70,0x65
000004  72766973          DCB      0x72,0x76,0x69,0x73
000008  6f725c73          DCB      0x6f,0x72,0x5c,0x73
00000c  72635c6f          DCB      0x72,0x63,0x5c,0x6f
000010  6666626f          DCB      0x66,0x66,0x62,0x6f
000014  61726456          DCB      0x61,0x72,0x64,0x56
000018  6973696f          DCB      0x69,0x73,0x69,0x6f
00001c  6e537973          DCB      0x6e,0x53,0x79,0x73
000020  74656d2e          DCB      0x74,0x65,0x6d,0x2e
000024  63707000          DCB      0x63,0x70,0x70,0x00

                          AREA ||.data__ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs||, COMGROUP=_ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::string
000000  4d756c74          DCB      0x4d,0x75,0x6c,0x74
000004  69706c79          DCB      0x69,0x70,0x6c,0x79
000008  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs_0||, COMGROUP=_ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs_0 ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::string (instance 2)
000000  496e7075          DCB      0x49,0x6e,0x70,0x75
000004  74206d61          DCB      0x74,0x20,0x6d,0x61
000008  74726963          DCB      0x74,0x72,0x69,0x63
00000c  65732061          DCB      0x65,0x73,0x20,0x61
000010  72652069          DCB      0x72,0x65,0x20,0x69
000014  6e636f6d          DCB      0x6e,0x63,0x6f,0x6d
000018  70617469          DCB      0x70,0x61,0x74,0x69
00001c  626c6520          DCB      0x62,0x6c,0x65,0x20
000020  73697a65          DCB      0x73,0x69,0x7a,0x65
000024  7300              DCB      0x73,0x00

                          AREA ||.data__ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs_1||, COMGROUP=_ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs_1 ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f6d6174          DCB      0x2f,0x6d,0x61,0x74
000030  7269782e          DCB      0x72,0x69,0x78,0x2e
000034  6800              DCB      0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs_2||, COMGROUP=_ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs_2, DATA, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEEs_2 ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::string (instance 4)
000000  496e7075          DCB      0x49,0x6e,0x70,0x75
000004  7420616e          DCB      0x74,0x20,0x61,0x6e
000008  64204f75          DCB      0x64,0x20,0x4f,0x75
00000c  74707574          DCB      0x74,0x70,0x75,0x74
000010  206d6174          DCB      0x20,0x6d,0x61,0x74
000014  72696365          DCB      0x72,0x69,0x63,0x65
000018  73206172          DCB      0x73,0x20,0x61,0x72
00001c  6520696e          DCB      0x65,0x20,0x69,0x6e
000020  636f6d70          DCB      0x63,0x6f,0x6d,0x70
000024  61746962          DCB      0x61,0x74,0x69,0x62
000028  6c652073          DCB      0x6c,0x65,0x20,0x73
00002c  697a6573          DCB      0x69,0x7a,0x65,0x73
000030  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a416c6c          DCB      0x3a,0x41,0x6c,0x6c
000010  6f636174          DCB      0x6f,0x63,0x61,0x74
000014  65427566          DCB      0x65,0x42,0x75,0x66
000018  66657246          DCB      0x66,0x65,0x72,0x46
00001c  726f6d4d          DCB      0x72,0x6f,0x6d,0x4d
000020  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000024  79537461          DCB      0x79,0x53,0x74,0x61
000028  636b00            DCB      0x63,0x6b,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0 ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1 ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs ; Anki::Embedded::Array<int>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a436f6d          DCB      0x3a,0x43,0x6f,0x6d
000010  70757465          DCB      0x70,0x75,0x74,0x65
000014  52657175          DCB      0x52,0x65,0x71,0x75
000018  69726564          DCB      0x69,0x72,0x65,0x64
00001c  53747269          DCB      0x53,0x74,0x72,0x69
000020  646500            DCB      0x64,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<int>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<int>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  2e417272          DCB      0x2e,0x41,0x72,0x72
000008  61793264          DCB      0x61,0x79,0x32,0x64
00000c  2e696e69          DCB      0x2e,0x69,0x6e,0x69
000010  7469616c          DCB      0x74,0x69,0x61,0x6c
000014  697a6500          DCB      0x69,0x7a,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  696e7075          DCB      0x69,0x6e,0x70,0x75
000004  74206461          DCB      0x74,0x20,0x64,0x61
000008  74612062          DCB      0x74,0x61,0x20,0x62
00000c  75666665          DCB      0x75,0x66,0x66,0x65
000010  72206973          DCB      0x72,0x20,0x69,0x73
000014  204e554c          DCB      0x20,0x4e,0x55,0x4c
000018  4c00              DCB      0x4c,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2 ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 4)
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a496e69          DCB      0x3a,0x49,0x6e,0x69
000010  7469616c          DCB      0x74,0x69,0x61,0x6c
000014  697a6542          DCB      0x69,0x7a,0x65,0x42
000018  75666665          DCB      0x75,0x66,0x66,0x65
00001c  7200              DCB      0x72,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3 ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 5)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4 ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 6)
000000  46696c6c          DCB      0x46,0x69,0x6c,0x6c
000004  20706174          DCB      0x20,0x70,0x61,0x74
000008  7465726e          DCB      0x74,0x65,0x72,0x6e
00000c  73206e6f          DCB      0x73,0x20,0x6e,0x6f
000010  74207375          DCB      0x74,0x20,0x73,0x75
000014  70706f72          DCB      0x70,0x70,0x6f,0x72
000018  74656420          DCB      0x74,0x65,0x64,0x20
00001c  666f7220          DCB      0x66,0x6f,0x72,0x20
000020  41727261          DCB      0x41,0x72,0x72,0x61
000024  7900              DCB      0x79,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5 ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 7)
000000  496e7075          DCB      0x49,0x6e,0x70,0x75
000004  74206461          DCB      0x74,0x20,0x64,0x61
000008  74612062          DCB      0x74,0x61,0x20,0x62
00000c  75666665          DCB      0x75,0x66,0x66,0x65
000010  72206973          DCB      0x72,0x20,0x69,0x73
000014  206e6f74          DCB      0x20,0x6e,0x6f,0x74
000018  206c6172          DCB      0x20,0x6c,0x61,0x72
00001c  67652065          DCB      0x67,0x65,0x20,0x65
000020  6e6f7567          DCB      0x6e,0x6f,0x75,0x67
000024  682e2025          DCB      0x68,0x2e,0x20,0x25
000028  64206279          DCB      0x64,0x20,0x62,0x79
00002c  74657320          DCB      0x74,0x65,0x73,0x20
000030  69732072          DCB      0x69,0x73,0x20,0x72
000034  65717569          DCB      0x65,0x71,0x75,0x69
000038  7265642e          DCB      0x72,0x65,0x64,0x2e
00003c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a417272          DCB      0x3a,0x41,0x72,0x72
000010  617900            DCB      0x61,0x79,0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 2)
000000  496e7661          DCB      0x49,0x6e,0x76,0x61
000004  6c696420          DCB      0x6c,0x69,0x64,0x20
000008  73697a65          DCB      0x73,0x69,0x7a,0x65
00000c  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiEs||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiEs, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiEs ; Anki::Embedded::Array<int>::get_size(int) const::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a676574          DCB      0x3a,0x67,0x65,0x74
000010  5f73697a          DCB      0x5f,0x73,0x69,0x7a
000014  6500              DCB      0x65,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiEs_0||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiEs_0, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiEs_0 ; Anki::Embedded::Array<int>::get_size(int) const::string (instance 2)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiEs_1||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiEs_1, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIiE8get_sizeEiEs_1 ; Anki::Embedded::Array<int>::get_size(int) const::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs||, COMGROUP=_ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs, DATA, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::string
000000  536f7274          DCB      0x53,0x6f,0x72,0x74
000004  00                DCB      0x00

                          AREA ||.data__ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_0||, COMGROUP=_ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_0, DATA, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_0 ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::string (instance 2)
000000  4f626a65          DCB      0x4f,0x62,0x6a,0x65
000004  63747320          DCB      0x63,0x74,0x73,0x20
000008  61726520          DCB      0x61,0x72,0x65,0x20
00000c  696e7661          DCB      0x69,0x6e,0x76,0x61
000010  6c696400          DCB      0x6c,0x69,0x64,0x00

                          AREA ||.data__ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_1||, COMGROUP=_ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_1, DATA, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_1 ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f6d6174          DCB      0x2f,0x6d,0x61,0x74
000030  7269782e          DCB      0x72,0x69,0x78,0x2e
000034  6800              DCB      0x68,0x00

                          AREA ||.data__ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_2||, COMGROUP=_ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_2, DATA, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_2 ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::string (instance 4)
000000  736f7274          DCB      0x73,0x6f,0x72,0x74
000004  57686963          DCB      0x57,0x68,0x69,0x63
000008  6844696d          DCB      0x68,0x44,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e206d          DCB      0x6f,0x6e,0x20,0x6d
000014  75737420          DCB      0x75,0x73,0x74,0x20
000018  6265207a          DCB      0x62,0x65,0x20,0x7a
00001c  65726f20          DCB      0x65,0x72,0x6f,0x20
000020  6f72206f          DCB      0x6f,0x72,0x20,0x6f
000024  6e6500            DCB      0x6e,0x65,0x00

                          AREA ||.data__ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_3||, COMGROUP=_ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_3, DATA, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_3 ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::string (instance 5)
000000  696e6465          DCB      0x69,0x6e,0x64,0x65
000004  78657320          DCB      0x78,0x65,0x73,0x20
000008  6d757374          DCB      0x6d,0x75,0x73,0x74
00000c  20626520          DCB      0x20,0x62,0x65,0x20
000010  74686520          DCB      0x74,0x68,0x65,0x20
000014  73616d65          DCB      0x73,0x61,0x6d,0x65
000018  2073697a          DCB      0x20,0x73,0x69,0x7a
00001c  65206173          DCB      0x65,0x20,0x61,0x73
000020  20617272          DCB      0x20,0x61,0x72,0x72
000024  00                DCB      0x00

                          AREA ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Eii, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded14LinearSequenceIiEC2Eii                  ; Alternate entry point ; Anki::Embedded::LinearSequence<int>::LinearSequence__sub_object(int, int)
                  _ZN4Anki8Embedded14LinearSequenceIiEC1Eii PROC ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
;;;30     
;;;31         template<typename Type> LinearSequence<Type>::LinearSequence(const Type start, const Type end)
;;;32           : start(start), increment(1)
;;;33         {
;;;34           this->size = computeSize(this->start, this->increment, end);
;;;35         }
;;;36     
000000  b530              PUSH     {r4,r5,lr}
000002  4604              MOV      r4,r0
000004  2301              MOVS     r3,#1
000006  b083              SUB      sp,sp,#0xc
000008  e9c41301          STRD     r1,r3,[r4,#4]
00000c  4291              CMP      r1,r2
00000e  d017              BEQ      |L450.64|
000010  2500              MOVS     r5,#0
000012  429d              CMP      r5,r3
000014  da01              BGE      |L450.26|
000016  4291              CMP      r1,r2
000018  dd01              BLE      |L450.30|
                  |L450.26|
00001a  462b              MOV      r3,r5
00001c  e010              B        |L450.64|
                  |L450.30|
00001e  1a50              SUBS     r0,r2,r1
000020  1c40              ADDS     r0,r0,#1
000022  fb90f3f3          SDIV     r3,r0,r3
000026  2b00              CMP      r3,#0
000028  da0a              BGE      |L450.64|
00002a  2185              MOVS     r1,#0x85
00002c  4806              LDR      r0,|L450.72|
00002e  e9cd0100          STRD     r0,r1,[sp,#0]
000032  4b06              LDR      r3,|L450.76|
000034  4a06              LDR      r2,|L450.80|
000036  4907              LDR      r1,|L450.84|
000038  2005              MOVS     r0,#5
00003a  f7fffffe          BL       _Anki_Log
00003e  462b              MOV      r3,r5
                  |L450.64|
000040  6023              STR      r3,[r4,#0]
000042  b003              ADD      sp,sp,#0xc
000044  4620              MOV      r0,r4
000046  bd30              POP      {r4,r5,pc}
                          ENDP

                  |L450.72|
                          DCD      _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
                  |L450.76|
                          DCD      _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiEs_1 ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::string (instance 3)
                  |L450.80|
                          DCD      _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiEs_0 ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::string (instance 2)
                  |L450.84|
                          DCD      _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiEs ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::string

                          AREA ||area_number.451||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Eii, LINKORDER=||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.451||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<float>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L457.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484e              LDR      r0,|L457.376|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  4b4e              LDR      r3,|L457.380|
000044  4a4e              LDR      r2,|L457.384|
000046  494f              LDR      r1,|L457.388|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L457.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L457.138|
000074  f240310b          MOV      r1,#0x30b
000078  4843              LDR      r0,|L457.392|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  4b43              LDR      r3,|L457.396|
000080  4a43              LDR      r2,|L457.400|
000082  4944              LDR      r1,|L457.404|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L457.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df90e4          LDR      r9,|L457.408|
0000b4  0005              MOVS     r5,r0
0000b6  d00d              BEQ      |L457.212|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21d              BCS      |L457.250|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  4b35              LDR      r3,|L457.412|
0000c8  4a35              LDR      r2,|L457.416|
0000ca  4936              LDR      r1,|L457.420|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  e04d              B        |L457.368|
                  |L457.212|
0000d4  f240301e          MOV      r0,#0x31e
0000d8  e9cd9000          STRD     r9,r0,[sp,#0]
0000dc  4b2f              LDR      r3,|L457.412|
0000de  4a32              LDR      r2,|L457.424|
0000e0  4932              LDR      r1,|L457.428|
0000e2  2005              MOVS     r0,#5
0000e4  f7fffffe          BL       _Anki_Log
0000e8  f8c4b000          STR      r11,[r4,#0]
0000ec  f8c4b004          STR      r11,[r4,#4]
0000f0  f8c4b008          STR      r11,[r4,#8]
0000f4  f8c4a010          STR      r10,[r4,#0x10]
0000f8  e03a              B        |L457.368|
                  |L457.250|
0000fa  a803              ADD      r0,sp,#0xc
0000fc  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000100  b150              CBZ      r0,|L457.280|
000102  f2403026          MOV      r0,#0x326
000106  e9cd9000          STRD     r9,r0,[sp,#0]
00010a  4b24              LDR      r3,|L457.412|
00010c  4a28              LDR      r2,|L457.432|
00010e  4925              LDR      r1,|L457.420|
000110  2005              MOVS     r0,#5
000112  f7fffffe          BL       _Anki_Log
000116  e02b              B        |L457.368|
                  |L457.280|
000118  9903              LDR      r1,[sp,#0xc]
00011a  e9c41503          STRD     r1,r5,[r4,#0xc]
00011e  f105000f          ADD      r0,r5,#0xf
000122  f020000f          BIC      r0,r0,#0xf
000126  e9c47600          STRD     r7,r6,[r4,#0]
00012a  1b40              SUBS     r0,r0,r5
00012c  2e01              CMP      r6,#1
00012e  bfd8              IT       LE
000130  2601              MOVLE    r6,#1
000132  00b1              LSLS     r1,r6,#2
000134  310f              ADDS     r1,r1,#0xf
000136  f021010f          BIC      r1,r1,#0xf
00013a  fb010107          MLA      r1,r1,r7,r0
00013e  4541              CMP      r1,r8
000140  bfdc              ITT      LE
000142  1829              ADDLE    r1,r5,r0
000144  6121              STRLE    r1,[r4,#0x10]
000146  dd13              BLE      |L457.368|
000148  f2403035          MOV      r0,#0x335
00014c  f8cd9000          STR      r9,[sp,#0]
000150  e9cd0101          STRD     r0,r1,[sp,#4]
000154  4b11              LDR      r3,|L457.412|
000156  4a17              LDR      r2,|L457.436|
000158  4914              LDR      r1,|L457.428|
00015a  2005              MOVS     r0,#5
00015c  f7fffffe          BL       _Anki_Log
000160  f8c4b000          STR      r11,[r4,#0]
000164  f8c4b004          STR      r11,[r4,#4]
000168  f8c4b008          STR      r11,[r4,#8]
00016c  f8c4a010          STR      r10,[r4,#0x10]
                  |L457.368|
000170  b005              ADD      sp,sp,#0x14
000172  4620              MOV      r0,r4
000174  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L457.376|
                          DCD      _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L457.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 3)
                  |L457.384|
                          DCD      _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 2)
                  |L457.388|
                          DCD      _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string
                  |L457.392|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L457.396|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1 ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 3)
                  |L457.400|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0 ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 2)
                  |L457.404|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string
                  |L457.408|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L457.412|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 3)
                  |L457.416|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3 ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 5)
                  |L457.420|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2 ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 4)
                  |L457.424|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 2)
                  |L457.428|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string
                  |L457.432|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4 ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 6)
                  |L457.436|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5 ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 7)

                          AREA ||area_number.458||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.458||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE||, COMGROUP=_ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE PROC ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)
;;;560    
;;;561          template<typename InType, typename IntermediateType, typename OutType> Result DownsampleByPowerOfTwo(const Array<InType> &in, const s32 downsamplePower, Array<OutType> &out, MemoryStack scratch)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;562          {
000004  4688              MOV      r8,r1
000006  b095              SUB      sp,sp,#0x54
000008  4682              MOV      r10,r0
;;;563            const s32 largeHeight = in.get_size(0);
00000a  2100              MOVS     r1,#0
00000c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000010  4604              MOV      r4,r0
;;;564            const s32 largeWidth = in.get_size(1);
000012  2101              MOVS     r1,#1
000014  4650              MOV      r0,r10
000016  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00001a  4681              MOV      r9,r0
;;;565    
;;;566            const s32 smallHeight = largeHeight >> downsamplePower;
00001c  fa44f008          ASR      r0,r4,r8
;;;567            const s32 smallWidth = largeWidth >> downsamplePower;
;;;568    
;;;569            const s32 downsampleFactor = 1 << downsamplePower;
000020  900e              STR      r0,[sp,#0x38]
000022  2001              MOVS     r0,#1
000024  fa00f508          LSL      r5,r0,r8
000028  f8da1010          LDR      r1,[r10,#0x10]
00002c  fa49f708          ASR      r7,r9,r8              ;567
000030  9818              LDR      r0,[sp,#0x60]         ;567
000032  2900              CMP      r1,#0                 ;567
000034  d040              BEQ      |L464.184|
000036  f8da1000          LDR      r1,[r10,#0]           ;567
00003a  2900              CMP      r1,#0                 ;567
00003c  bfa4              ITT      GE                    ;567
00003e  f8da1004          LDRGE    r1,[r10,#4]           ;567
000042  2900              CMPGE    r1,#0                 ;567
000044  db38              BLT      |L464.184|
000046  9917              LDR      r1,[sp,#0x5c]         ;567
000048  6909              LDR      r1,[r1,#0x10]         ;567
00004a  2900              CMP      r1,#0                 ;567
00004c  d034              BEQ      |L464.184|
00004e  9917              LDR      r1,[sp,#0x5c]         ;567
000050  6809              LDR      r1,[r1,#0]            ;567
000052  2900              CMP      r1,#0                 ;567
000054  db30              BLT      |L464.184|
000056  9917              LDR      r1,[sp,#0x5c]         ;567
000058  6849              LDR      r1,[r1,#4]            ;567
00005a  2900              CMP      r1,#0                 ;567
00005c  db2c              BLT      |L464.184|
00005e  f7fffffe          BL       _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
000062  b348              CBZ      r0,|L464.184|
000064  9c17              LDR      r4,[sp,#0x5c]         ;567
000066  9e0e              LDR      r6,[sp,#0x38]         ;567
;;;570    
;;;571            AnkiConditionalErrorAndReturnValue(AreValid(in, out , scratch),
;;;572              RESULT_FAIL_INVALID_OBJECT, "DownsampleByFactor", "Invalid objects");
;;;573    
;;;574            AnkiConditionalErrorAndReturnValue(AreEqualSize(smallHeight, smallWidth, out),
000068  46bb              MOV      r11,r7
00006a  6920              LDR      r0,[r4,#0x10]
00006c  b3a0              CBZ      r0,|L464.216|
00006e  6820              LDR      r0,[r4,#0]
000070  2800              CMP      r0,#0
000072  bfa4              ITT      GE
000074  6860              LDRGE    r0,[r4,#4]
000076  2800              CMPGE    r0,#0
000078  db2f              BLT      |L464.218|
00007a  2100              MOVS     r1,#0
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000082  42b0              CMP      r0,r6
000084  d129              BNE      |L464.218|
000086  2101              MOVS     r1,#1
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00008e  4558              CMP      r0,r11
000090  d123              BNE      |L464.218|
;;;575              RESULT_FAIL_INVALID_SIZE, "DownsampleByFactor", "size(out) is not equal to size(in) >> downsampleFactor");
;;;576    
;;;577            AnkiConditionalErrorAndReturnValue(largeWidth % 4 == 0,
000092  f0190f03          TST      r9,#3
000096  d030              BEQ      |L464.250|
000098  f2402141          MOV      r1,#0x241
00009c  48fd              LDR      r0,|L464.1172|
00009e  e9cd0100          STRD     r0,r1,[sp,#0]
0000a2  4bfd              LDR      r3,|L464.1176|
0000a4  4afd              LDR      r2,|L464.1180|
0000a6  49fe              LDR      r1,|L464.1184|
0000a8  2005              MOVS     r0,#5
0000aa  f7fffffe          BL       _Anki_Log
;;;578              RESULT_FAIL_INVALID_SIZE, "DownsampleByFactor", "The width of the in Array must be a multiple of four");
;;;579    
;;;580            Array<InType> inRow(1, largeWidth, scratch);
;;;581            Array<IntermediateType> accumulator(1, largeWidth >> downsamplePower, scratch);
;;;582    
;;;583            InType * restrict pInRow = inRow.Pointer(0,0);
;;;584            IntermediateType * restrict pAccumulator = accumulator.Pointer(0,0);
;;;585    
;;;586            const s32 numWordsToCopy = (sizeof(InType)*largeWidth) >> 2; // If the input in stride is not a multiple of four, this will be too small
;;;587    
;;;588            const s32 normalizationShift = 2*downsamplePower;
;;;589    
;;;590            for(s32 ySmall=0; ySmall<smallHeight; ySmall++) {
;;;591              accumulator.SetZero();
;;;592    
;;;593              // Accumulate a block of "largeWidth X downsampleFactor" pixels into a "smallWidth X 1" buffer
;;;594              for(s32 yp=0; yp<downsampleFactor; yp++) {
;;;595                const s32 yLarge = (ySmall << downsamplePower) + yp; // The actual row of the input image
;;;596    
;;;597                const InType * restrict pIn = in.Pointer(yLarge, 0);
;;;598    
;;;599                // First, copy a row from in to the temporary buffer
;;;600                // TODO: DMA may be faster
;;;601                for(s32 i=0; i<numWordsToCopy; i++) {
;;;602                  AnkiAssert(reinterpret_cast<size_t>(pIn) % 4 == 0);
;;;603                  reinterpret_cast<u32*>(pInRow)[i] = reinterpret_cast<const u32*>(pIn)[i];
;;;604                }
;;;605    
;;;606                // Next, accumulate into the accumulator
;;;607                for(s32 xSmall=0; xSmall<smallWidth; xSmall++) {
;;;608                  for(s32 xp=0; xp<downsampleFactor; xp++) {
;;;609                    const s32 xLarge = (xSmall << downsamplePower) + xp; // The actual column of the input image
;;;610    
;;;611                    pAccumulator[xSmall] += static_cast<IntermediateType>(pInRow[xLarge]);
;;;612                  } // for(s32 xp=0; xp<downsampleFactor; xp++)
;;;613                } // for(s32 xSmall=0; xSmall<smallWidth; xSmall++)
;;;614              } // for(s32 yp=0; yp<downsampleFactor; yp++)
;;;615    
;;;616              // Convert the sums to averages
;;;617              OutType * restrict pOut = out.Pointer(ySmall, 0);
;;;618              for(s32 xSmall=0; xSmall<smallWidth; xSmall++) {
;;;619                pOut[xSmall] = static_cast<OutType>(pAccumulator[xSmall] >> normalizationShift);
;;;620              } // for(s32 xSmall=0; xSmall<smallWidth; xSmall++)
;;;621            } // for(s32 ySmall=0; ySmall<smallHeight; ySmall++)
;;;622    
;;;623            return RESULT_OK;
;;;624          }
0000ae  b019              ADD      sp,sp,#0x64
0000b0  f04f60a0          MOV      r0,#0x5000000         ;577
0000b4  e8bd8ff0          POP      {r4-r11,pc}
                  |L464.184|
0000b8  f240213b          MOV      r1,#0x23b             ;571
0000bc  48f5              LDR      r0,|L464.1172|
0000be  e9cd0100          STRD     r0,r1,[sp,#0]         ;571
0000c2  4bf5              LDR      r3,|L464.1176|
0000c4  4af7              LDR      r2,|L464.1188|
0000c6  49f6              LDR      r1,|L464.1184|
0000c8  2005              MOVS     r0,#5                 ;571
0000ca  f7fffffe          BL       _Anki_Log
0000ce  b019              ADD      sp,sp,#0x64
0000d0  f04f6080          MOV      r0,#0x4000000         ;571
0000d4  e8bd8ff0          POP      {r4-r11,pc}
                  |L464.216|
0000d8  e7ff              B        |L464.218|
                  |L464.218|
0000da  f240213e          MOV      r1,#0x23e             ;574
0000de  48ed              LDR      r0,|L464.1172|
0000e0  e9cd0100          STRD     r0,r1,[sp,#0]         ;574
0000e4  4bec              LDR      r3,|L464.1176|
0000e6  4af0              LDR      r2,|L464.1192|
0000e8  49ed              LDR      r1,|L464.1184|
0000ea  2005              MOVS     r0,#5                 ;574
0000ec  f7fffffe          BL       _Anki_Log
0000f0  b019              ADD      sp,sp,#0x64
0000f2  f04f60a0          MOV      r0,#0x5000000         ;574
0000f6  e8bd8ff0          POP      {r4-r11,pc}
                  |L464.250|
0000fa  2001              MOVS     r0,#1                 ;580
0000fc  9010              STR      r0,[sp,#0x40]         ;580
0000fe  2300              MOVS     r3,#0                 ;580
000100  4601              MOV      r1,r0                 ;580
000102  ac09              ADD      r4,sp,#0x24           ;580
000104  461a              MOV      r2,r3                 ;580
000106  a813              ADD      r0,sp,#0x4c           ;580
000108  f8ddb060          LDR      r11,[sp,#0x60]        ;580
00010c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000110  6800              LDR      r0,[r0,#0]            ;580
000112  9002              STR      r0,[sp,#8]            ;580
000114  f104000c          ADD      r0,r4,#0xc            ;580
000118  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00011c  f1a0040c          SUB      r4,r0,#0xc            ;580
000120  f04f30ff          MOV      r0,#0xffffffff        ;580
000124  6020              STR      r0,[r4,#0]            ;580
000126  6060              STR      r0,[r4,#4]            ;580
000128  60a0              STR      r0,[r4,#8]            ;580
00012a  2000              MOVS     r0,#0                 ;580
00012c  6120              STR      r0,[r4,#0x10]         ;580
00012e  f1b90f00          CMP      r9,#0                 ;580
000132  da0a              BGE      |L464.330|
000134  217d              MOVS     r1,#0x7d              ;580
000136  48dd              LDR      r0,|L464.1196|
000138  e9cd0100          STRD     r0,r1,[sp,#0]         ;580
00013c  4bdc              LDR      r3,|L464.1200|
00013e  4add              LDR      r2,|L464.1204|
000140  49dd              LDR      r1,|L464.1208|
000142  2005              MOVS     r0,#5                 ;580
000144  f7fffffe          BL       _Anki_Log
000148  e04e              B        |L464.488|
                  |L464.330|
00014a  2000              MOVS     r0,#0                 ;580
00014c  9008              STR      r0,[sp,#0x20]         ;580
00014e  4648              MOV      r0,r9                 ;580
000150  f1b90f01          CMP      r9,#1                 ;580
000154  bfd8              IT       LE                    ;580
000156  2001              MOVLE    r0,#1                 ;580
000158  300f              ADDS     r0,r0,#0xf            ;580
00015a  f020060f          BIC      r6,r0,#0xf            ;580
00015e  a808              ADD      r0,sp,#0x20           ;580
000160  9011              STR      r0,[sp,#0x44]         ;580
000162  9802              LDR      r0,[sp,#8]            ;580
000164  900f              STR      r0,[sp,#0x3c]         ;580
000166  2e00              CMP      r6,#0                 ;580
000168  dc0a              BGT      |L464.384|
00016a  f240310b          MOV      r1,#0x30b             ;580
00016e  48d3              LDR      r0,|L464.1212|
000170  e9cd0100          STRD     r0,r1,[sp,#0]         ;580
000174  4bd2              LDR      r3,|L464.1216|
000176  4ad3              LDR      r2,|L464.1220|
000178  49d3              LDR      r1,|L464.1224|
00017a  2005              MOVS     r0,#5                 ;580
00017c  f7fffffe          BL       _Anki_Log
                  |L464.384|
000180  a80f              ADD      r0,sp,#0x3c           ;580
000182  60a6              STR      r6,[r4,#8]            ;580
000184  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
000188  4602              MOV      r2,r0                 ;580
00018a  4631              MOV      r1,r6                 ;580
00018c  4658              MOV      r0,r11                ;580
00018e  9b11              LDR      r3,[sp,#0x44]         ;580
000190  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
000194  0006              MOVS     r6,r0                 ;580
000196  9808              LDR      r0,[sp,#0x20]         ;580
000198  9000              STR      r0,[sp,#0]            ;580
00019a  9910              LDR      r1,[sp,#0x40]         ;580
00019c  9802              LDR      r0,[sp,#8]            ;580
00019e  46cb              MOV      r11,r9                ;580
0001a0  9101              STR      r1,[sp,#4]            ;580
0001a2  900f              STR      r0,[sp,#0x3c]         ;580
0001a4  d00e              BEQ      |L464.452|
0001a6  9800              LDR      r0,[sp,#0]            ;580
0001a8  2810              CMP      r0,#0x10              ;580
0001aa  d246              BCS      |L464.570|
0001ac  f2403123          MOV      r1,#0x323             ;580
0001b0  48c6              LDR      r0,|L464.1228|
0001b2  e9cd0100          STRD     r0,r1,[sp,#0]         ;580
0001b6  4bc6              LDR      r3,|L464.1232|
0001b8  4ac6              LDR      r2,|L464.1236|
0001ba  49c7              LDR      r1,|L464.1240|
0001bc  2005              MOVS     r0,#5                 ;580
0001be  f7fffffe          BL       _Anki_Log
0001c2  e011              B        |L464.488|
                  |L464.452|
0001c4  f240311e          MOV      r1,#0x31e             ;580
0001c8  48c0              LDR      r0,|L464.1228|
0001ca  e9cd0100          STRD     r0,r1,[sp,#0]         ;580
0001ce  4bc0              LDR      r3,|L464.1232|
0001d0  4ac2              LDR      r2,|L464.1244|
0001d2  49c3              LDR      r1,|L464.1248|
0001d4  2005              MOVS     r0,#5                 ;580
0001d6  f7fffffe          BL       _Anki_Log
0001da  f04f30ff          MOV      r0,#0xffffffff        ;580
0001de  6020              STR      r0,[r4,#0]            ;580
0001e0  6060              STR      r0,[r4,#4]            ;580
0001e2  60a0              STR      r0,[r4,#8]            ;580
0001e4  2000              MOVS     r0,#0                 ;580
                  |L464.486|
0001e6  6120              STR      r0,[r4,#0x10]         ;580
                  |L464.488|
0001e8  2001              MOVS     r0,#1                 ;581
0001ea  9010              STR      r0,[sp,#0x40]         ;581
0001ec  9818              LDR      r0,[sp,#0x60]         ;581
0001ee  2300              MOVS     r3,#0                 ;581
0001f0  9000              STR      r0,[sp,#0]            ;581
0001f2  ac03              ADD      r4,sp,#0xc            ;581
0001f4  46bb              MOV      r11,r7                ;581
0001f6  461a              MOV      r2,r3                 ;581
0001f8  2101              MOVS     r1,#1                 ;581
0001fa  a814              ADD      r0,sp,#0x50           ;581
0001fc  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000200  6800              LDR      r0,[r0,#0]            ;581
000202  9002              STR      r0,[sp,#8]            ;581
000204  f104000c          ADD      r0,r4,#0xc            ;581
000208  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00020c  f1a0040c          SUB      r4,r0,#0xc            ;581
000210  f04f30ff          MOV      r0,#0xffffffff        ;581
000214  6020              STR      r0,[r4,#0]            ;581
000216  6060              STR      r0,[r4,#4]            ;581
000218  60a0              STR      r0,[r4,#8]            ;581
00021a  2000              MOVS     r0,#0                 ;581
00021c  6120              STR      r0,[r4,#0x10]         ;581
00021e  f1bb0f00          CMP      r11,#0                ;581
000222  da4a              BGE      |L464.698|
000224  217d              MOVS     r1,#0x7d              ;581
000226  48af              LDR      r0,|L464.1252|
000228  e9cd0100          STRD     r0,r1,[sp,#0]         ;581
00022c  4bae              LDR      r3,|L464.1256|
00022e  4aaf              LDR      r2,|L464.1260|
000230  49af              LDR      r1,|L464.1264|
000232  2005              MOVS     r0,#5                 ;581
000234  f7fffffe          BL       _Anki_Log
000238  e090              B        |L464.860|
                  |L464.570|
00023a  a80f              ADD      r0,sp,#0x3c           ;581
00023c  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000240  b158              CBZ      r0,|L464.602|
000242  f2403126          MOV      r1,#0x326             ;581
000246  48a1              LDR      r0,|L464.1228|
000248  e9cd0100          STRD     r0,r1,[sp,#0]         ;581
00024c  4ba0              LDR      r3,|L464.1232|
00024e  4aa9              LDR      r2,|L464.1268|
000250  49a1              LDR      r1,|L464.1240|
000252  2005              MOVS     r0,#5                 ;581
000254  f7fffffe          BL       _Anki_Log
000258  e7c6              B        |L464.488|
                  |L464.602|
00025a  980f              LDR      r0,[sp,#0x3c]         ;581
00025c  60e0              STR      r0,[r4,#0xc]          ;581
00025e  9801              LDR      r0,[sp,#4]            ;581
000260  6126              STR      r6,[r4,#0x10]         ;581
000262  e9c40b00          STRD     r0,r11,[r4,#0]        ;581
000266  f106000f          ADD      r0,r6,#0xf            ;581
00026a  f020000f          BIC      r0,r0,#0xf            ;581
00026e  1b80              SUBS     r0,r0,r6              ;581
000270  f1bb0f01          CMP      r11,#1                ;581
000274  bfd8              IT       LE                    ;581
000276  f04f0b01          MOVLE    r11,#1                ;581
00027a  f10b010f          ADD      r1,r11,#0xf           ;581
00027e  9a01              LDR      r2,[sp,#4]            ;581
000280  f021010f          BIC      r1,r1,#0xf            ;581
000284  fb010102          MLA      r1,r1,r2,r0           ;581
000288  9a00              LDR      r2,[sp,#0]            ;581
00028a  4291              CMP      r1,r2                 ;581
00028c  bfd8              IT       LE                    ;581
00028e  4430              ADDLE    r0,r6                 ;581
000290  dda9              BLE      |L464.486|
000292  f2403035          MOV      r0,#0x335             ;581
000296  4a8d              LDR      r2,|L464.1228|
000298  e9cd2000          STRD     r2,r0,[sp,#0]         ;581
00029c  9102              STR      r1,[sp,#8]            ;581
00029e  4b8c              LDR      r3,|L464.1232|
0002a0  4a95              LDR      r2,|L464.1272|
0002a2  498f              LDR      r1,|L464.1248|
0002a4  2005              MOVS     r0,#5                 ;581
0002a6  f7fffffe          BL       _Anki_Log
0002aa  f04f30ff          MOV      r0,#0xffffffff        ;581
0002ae  6020              STR      r0,[r4,#0]            ;581
0002b0  6060              STR      r0,[r4,#4]            ;581
0002b2  60a0              STR      r0,[r4,#8]            ;581
0002b4  2000              MOVS     r0,#0                 ;581
0002b6  6120              STR      r0,[r4,#0x10]         ;581
0002b8  e796              B        |L464.488|
                  |L464.698|
0002ba  2000              MOVS     r0,#0                 ;581
0002bc  9008              STR      r0,[sp,#0x20]         ;581
0002be  f1bb0f01          CMP      r11,#1                ;581
0002c2  bfd4              ITE      LE                    ;581
0002c4  2001              MOVLE    r0,#1                 ;581
0002c6  4658              MOVGT    r0,r11                ;581
0002c8  0080              LSLS     r0,r0,#2              ;581
0002ca  300f              ADDS     r0,r0,#0xf            ;581
0002cc  f020060f          BIC      r6,r0,#0xf            ;581
0002d0  9800              LDR      r0,[sp,#0]            ;581
0002d2  9012              STR      r0,[sp,#0x48]         ;581
0002d4  a808              ADD      r0,sp,#0x20           ;581
0002d6  9011              STR      r0,[sp,#0x44]         ;581
0002d8  9802              LDR      r0,[sp,#8]            ;581
0002da  900f              STR      r0,[sp,#0x3c]         ;581
0002dc  2e00              CMP      r6,#0                 ;581
0002de  dc0a              BGT      |L464.758|
0002e0  f240310b          MOV      r1,#0x30b             ;581
0002e4  4885              LDR      r0,|L464.1276|
0002e6  e9cd0100          STRD     r0,r1,[sp,#0]         ;581
0002ea  4b85              LDR      r3,|L464.1280|
0002ec  4a85              LDR      r2,|L464.1284|
0002ee  4986              LDR      r1,|L464.1288|
0002f0  2005              MOVS     r0,#5                 ;581
0002f2  f7fffffe          BL       _Anki_Log
                  |L464.758|
0002f6  a80f              ADD      r0,sp,#0x3c           ;581
0002f8  60a6              STR      r6,[r4,#8]            ;581
0002fa  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
0002fe  4602              MOV      r2,r0                 ;581
000300  e9dd3011          LDRD     r3,r0,[sp,#0x44]      ;581
000304  4631              MOV      r1,r6                 ;581
000306  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
00030a  0006              MOVS     r6,r0                 ;581
00030c  9808              LDR      r0,[sp,#0x20]         ;581
00030e  9000              STR      r0,[sp,#0]            ;581
000310  9910              LDR      r1,[sp,#0x40]         ;581
000312  9802              LDR      r0,[sp,#8]            ;581
000314  9101              STR      r1,[sp,#4]            ;581
000316  900f              STR      r0,[sp,#0x3c]         ;581
000318  d00e              BEQ      |L464.824|
00031a  9800              LDR      r0,[sp,#0]            ;581
00031c  2810              CMP      r0,#0x10              ;581
00031e  d243              BCS      |L464.936|
000320  f2403123          MOV      r1,#0x323             ;581
000324  4879              LDR      r0,|L464.1292|
000326  e9cd0100          STRD     r0,r1,[sp,#0]         ;581
00032a  4b79              LDR      r3,|L464.1296|
00032c  4a79              LDR      r2,|L464.1300|
00032e  497a              LDR      r1,|L464.1304|
000330  2005              MOVS     r0,#5                 ;581
000332  f7fffffe          BL       _Anki_Log
000336  e011              B        |L464.860|
                  |L464.824|
000338  f240311e          MOV      r1,#0x31e             ;581
00033c  4873              LDR      r0,|L464.1292|
00033e  e9cd0100          STRD     r0,r1,[sp,#0]         ;581
000342  4b73              LDR      r3,|L464.1296|
000344  4a75              LDR      r2,|L464.1308|
000346  4976              LDR      r1,|L464.1312|
000348  2005              MOVS     r0,#5                 ;581
00034a  f7fffffe          BL       _Anki_Log
00034e  f04f30ff          MOV      r0,#0xffffffff        ;581
000352  6020              STR      r0,[r4,#0]            ;581
000354  6060              STR      r0,[r4,#4]            ;581
000356  60a0              STR      r0,[r4,#8]            ;581
000358  2000              MOVS     r0,#0                 ;581
                  |L464.858|
00035a  6120              STR      r0,[r4,#0x10]         ;581
                  |L464.860|
00035c  9a0b              LDR      r2,[sp,#0x2c]         ;581
00035e  990d              LDR      r1,[sp,#0x34]         ;581
000360  2000              MOVS     r0,#0                 ;583
000362  fb001602          MLA      r6,r0,r2,r1           ;583
000366  9a05              LDR      r2,[sp,#0x14]         ;583
000368  9907              LDR      r1,[sp,#0x1c]         ;583
00036a  ea4f0999          LSR      r9,r9,#2              ;586
00036e  fb001402          MLA      r4,r0,r2,r1           ;586
000372  ea4f0048          LSL      r0,r8,#1              ;588
000376  9002              STR      r0,[sp,#8]            ;590
000378  2000              MOVS     r0,#0                 ;590
00037a  9008              STR      r0,[sp,#0x20]         ;590
00037c  980e              LDR      r0,[sp,#0x38]         ;590
00037e  2800              CMP      r0,#0                 ;590
000380  dd7e              BLE      |L464.1152|
                  |L464.898|
000382  9807              LDR      r0,[sp,#0x1c]         ;590
000384  b3f0              CBZ      r0,|L464.1028|
000386  9803              LDR      r0,[sp,#0xc]          ;590
000388  2800              CMP      r0,#0                 ;590
00038a  bfa4              ITT      GE                    ;590
00038c  9804              LDRGE    r0,[sp,#0x10]         ;590
00038e  2800              CMPGE    r0,#0                 ;590
000390  db4d              BLT      |L464.1070|
000392  9905              LDR      r1,[sp,#0x14]         ;590
000394  9803              LDR      r0,[sp,#0xc]          ;590
000396  9b05              LDR      r3,[sp,#0x14]         ;590
000398  4341              MULS     r1,r0,r1              ;590
00039a  9a07              LDR      r2,[sp,#0x1c]         ;590
00039c  2000              MOVS     r0,#0                 ;590
00039e  fb002003          MLA      r0,r0,r3,r2           ;590
0003a2  f7fffffe          BL       __aeabi_memclr4
0003a6  e04d              B        |L464.1092|
                  |L464.936|
0003a8  a80f              ADD      r0,sp,#0x3c           ;590
0003aa  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
0003ae  b158              CBZ      r0,|L464.968|
0003b0  f2403126          MOV      r1,#0x326             ;590
0003b4  4855              LDR      r0,|L464.1292|
0003b6  e9cd0100          STRD     r0,r1,[sp,#0]         ;590
0003ba  4b55              LDR      r3,|L464.1296|
0003bc  4a59              LDR      r2,|L464.1316|
0003be  4956              LDR      r1,|L464.1304|
0003c0  2005              MOVS     r0,#5                 ;590
0003c2  f7fffffe          BL       _Anki_Log
0003c6  e7c9              B        |L464.860|
                  |L464.968|
0003c8  980f              LDR      r0,[sp,#0x3c]         ;590
0003ca  60e0              STR      r0,[r4,#0xc]          ;590
0003cc  9801              LDR      r0,[sp,#4]            ;590
0003ce  6126              STR      r6,[r4,#0x10]         ;590
0003d0  e9c40b00          STRD     r0,r11,[r4,#0]        ;590
0003d4  f106000f          ADD      r0,r6,#0xf            ;590
0003d8  f020000f          BIC      r0,r0,#0xf            ;590
0003dc  1b80              SUBS     r0,r0,r6              ;590
0003de  f1bb0f01          CMP      r11,#1                ;590
0003e2  bfd8              IT       LE                    ;590
0003e4  f04f0b01          MOVLE    r11,#1                ;590
0003e8  ea4f018b          LSL      r1,r11,#2             ;590
0003ec  310f              ADDS     r1,r1,#0xf            ;590
0003ee  9a01              LDR      r2,[sp,#4]            ;590
0003f0  f021010f          BIC      r1,r1,#0xf            ;590
0003f4  fb010102          MLA      r1,r1,r2,r0           ;590
0003f8  9a00              LDR      r2,[sp,#0]            ;590
0003fa  4291              CMP      r1,r2                 ;590
0003fc  bfd8              IT       LE                    ;590
0003fe  4430              ADDLE    r0,r6                 ;590
000400  ddab              BLE      |L464.858|
000402  e000              B        |L464.1030|
                  |L464.1028|
000404  e013              B        |L464.1070|
                  |L464.1030|
000406  f2403035          MOV      r0,#0x335             ;590
00040a  4a40              LDR      r2,|L464.1292|
00040c  e9cd2000          STRD     r2,r0,[sp,#0]         ;590
000410  9102              STR      r1,[sp,#8]            ;590
000412  4b3f              LDR      r3,|L464.1296|
000414  4a44              LDR      r2,|L464.1320|
000416  4942              LDR      r1,|L464.1312|
000418  2005              MOVS     r0,#5                 ;590
00041a  f7fffffe          BL       _Anki_Log
00041e  f04f30ff          MOV      r0,#0xffffffff        ;590
000422  6020              STR      r0,[r4,#0]            ;590
000424  6060              STR      r0,[r4,#4]            ;590
000426  60a0              STR      r0,[r4,#8]            ;590
000428  2000              MOVS     r0,#0                 ;590
00042a  6120              STR      r0,[r4,#0x10]         ;590
00042c  e796              B        |L464.860|
                  |L464.1070|
00042e  f2402176          MOV      r1,#0x276             ;590
000432  483e              LDR      r0,|L464.1324|
000434  e9cd0100          STRD     r0,r1,[sp,#0]         ;590
000438  4b3d              LDR      r3,|L464.1328|
00043a  4a3e              LDR      r2,|L464.1332|
00043c  493e              LDR      r1,|L464.1336|
00043e  2005              MOVS     r0,#5                 ;590
000440  f7fffffe          BL       _Anki_Log
                  |L464.1092|
000444  f04f0b00          MOV      r11,#0                ;594
000448  2d00              CMP      r5,#0                 ;594
00044a  bfc4              ITT      GT                    ;595
00044c  9808              LDRGT    r0,[sp,#0x20]         ;595
00044e  fa00fe08          LSLGT    lr,r0,r8              ;595
000452  dd1e              BLE      |L464.1170|
                  |L464.1108|
000454  f8da2008          LDR      r2,[r10,#8]           ;594
000458  f8da1010          LDR      r1,[r10,#0x10]        ;594
00045c  eb0e000b          ADD      r0,lr,r11             ;595
000460  fb001102          MLA      r1,r0,r2,r1           ;595
000464  2000              MOVS     r0,#0                 ;601
000466  f1b90f00          CMP      r9,#0                 ;601
00046a  dd06              BLE      |L464.1146|
                  |L464.1132|
00046c  f8512020          LDR      r2,[r1,r0,LSL #2]     ;603
000470  f8462020          STR      r2,[r6,r0,LSL #2]     ;603
000474  1c40              ADDS     r0,r0,#1              ;603
000476  4581              CMP      r9,r0                 ;601
000478  dcf8              BGT      |L464.1132|
                  |L464.1146|
00047a  2100              MOVS     r1,#0                 ;607
00047c  2f00              CMP      r7,#0                 ;607
00047e  e000              B        |L464.1154|
                  |L464.1152|
000480  e088              B        |L464.1428|
                  |L464.1154|
000482  dd69              BLE      |L464.1368|
                  |L464.1156|
000484  2000              MOVS     r0,#0                 ;608
000486  2d00              CMP      r5,#0                 ;608
000488  bfc8              IT       GT                    ;609
00048a  fa01fc08          LSLGT    r12,r1,r8             ;609
00048e  dd60              BLE      |L464.1362|
                  |L464.1168|
000490  e054              B        |L464.1340|
                  |L464.1170|
000492  e066              B        |L464.1378|
                  |L464.1172|
                          DCD      _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::__PRETTY_FUNCTION__
                  |L464.1176|
                          DCD      _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_1 ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::string (instance 3)
                  |L464.1180|
                          DCD      _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_3 ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::string (instance 5)
                  |L464.1184|
                          DCD      _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::string
                  |L464.1188|
                          DCD      _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_0 ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::string (instance 2)
                  |L464.1192|
                          DCD      _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEEs_2 ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::string (instance 4)
                  |L464.1196|
                          DCD      _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L464.1200|
                          DCD      _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 3)
                  |L464.1204|
                          DCD      _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 2)
                  |L464.1208|
                          DCD      _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string
                  |L464.1212|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L464.1216|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1 ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 3)
                  |L464.1220|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0 ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 2)
                  |L464.1224|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string
                  |L464.1228|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L464.1232|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 3)
                  |L464.1236|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3 ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 5)
                  |L464.1240|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2 ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 4)
                  |L464.1244|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 2)
                  |L464.1248|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string
                  |L464.1252|
                          DCD      _ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L464.1256|
                          DCD      _ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<unsigned>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 3)
                  |L464.1260|
                          DCD      _ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<unsigned>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 2)
                  |L464.1264|
                          DCD      _ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs ; Anki::Embedded::Array<unsigned>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string
                  |L464.1268|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4 ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 6)
                  |L464.1272|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5 ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 7)
                  |L464.1276|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L464.1280|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1 ; Anki::Embedded::Array<unsigned>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 3)
                  |L464.1284|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0 ; Anki::Embedded::Array<unsigned>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 2)
                  |L464.1288|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs ; Anki::Embedded::Array<unsigned>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string
                  |L464.1292|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L464.1296|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 3)
                  |L464.1300|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3 ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 5)
                  |L464.1304|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2 ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 4)
                  |L464.1308|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 2)
                  |L464.1312|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string
                  |L464.1316|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4 ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 6)
                  |L464.1320|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5 ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 7)
                  |L464.1324|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::SetZero()::__PRETTY_FUNCTION__
                  |L464.1328|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE7SetZeroEvEs_1 ; Anki::Embedded::Array<unsigned>::SetZero()::string (instance 3)
                  |L464.1332|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE7SetZeroEvEs_0 ; Anki::Embedded::Array<unsigned>::SetZero()::string (instance 2)
                  |L464.1336|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE7SetZeroEvEs ; Anki::Embedded::Array<unsigned>::SetZero()::string
                  |L464.1340|
00053c  eb0c0200          ADD      r2,r12,r0             ;609
000540  f8543021          LDR      r3,[r4,r1,LSL #2]     ;611
000544  5cb2              LDRB     r2,[r6,r2]            ;611
000546  1c40              ADDS     r0,r0,#1              ;611
000548  441a              ADD      r2,r2,r3              ;611
00054a  f8442021          STR      r2,[r4,r1,LSL #2]     ;611
00054e  4285              CMP      r5,r0                 ;608
000550  dc9e              BGT      |L464.1168|
                  |L464.1362|
000552  1c49              ADDS     r1,r1,#1              ;608
000554  428f              CMP      r7,r1                 ;607
000556  dc95              BGT      |L464.1156|
                  |L464.1368|
000558  f10b0b01          ADD      r11,r11,#1            ;607
00055c  455d              CMP      r5,r11                ;594
00055e  f73faf79          BGT      |L464.1108|
                  |L464.1378|
000562  9917              LDR      r1,[sp,#0x5c]         ;594
000564  9808              LDR      r0,[sp,#0x20]         ;594
000566  690a              LDR      r2,[r1,#0x10]         ;594
000568  6889              LDR      r1,[r1,#8]            ;594
00056a  fb002101          MLA      r1,r0,r1,r2           ;594
00056e  2000              MOVS     r0,#0                 ;618
000570  2f00              CMP      r7,#0                 ;618
000572  dd08              BLE      |L464.1414|
                  |L464.1396|
000574  f8543020          LDR      r3,[r4,r0,LSL #2]     ;619
000578  9a02              LDR      r2,[sp,#8]            ;619
00057a  fa23f202          LSR      r2,r3,r2              ;619
00057e  540a              STRB     r2,[r1,r0]            ;619
000580  1c40              ADDS     r0,r0,#1              ;619
000582  4287              CMP      r7,r0                 ;618
000584  dcf6              BGT      |L464.1396|
                  |L464.1414|
000586  9808              LDR      r0,[sp,#0x20]         ;590
000588  990e              LDR      r1,[sp,#0x38]         ;590
00058a  1c40              ADDS     r0,r0,#1              ;590
00058c  9008              STR      r0,[sp,#0x20]         ;590
00058e  4288              CMP      r0,r1                 ;590
000590  f6ffaef7          BLT      |L464.898|
                  |L464.1428|
000594  b019              ADD      sp,sp,#0x64
000596  2000              MOVS     r0,#0                 ;623
000598  e8bd8ff0          POP      {r4-r11,pc}
;;;625    
                          ENDP


                          AREA ||area_number.465||, COMGROUP=_ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE, LINKORDER=||t._ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.465||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5PointIfEC1Ev||, COMGROUP=_ZN4Anki8Embedded5PointIfEC1Ev, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5PointIfEC2Ev                  ; Alternate entry point ; Anki::Embedded::Point<float>::Point__sub_object()
                  _ZN4Anki8Embedded5PointIfEC1Ev PROC ; Anki::Embedded::Point<float>::Point()
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
000000  ed9f0a03          VLDR     s0,|L471.16|
000004  ed800a00          VSTR     s0,[r0,#0]
000008  ed800a01          VSTR     s0,[r0,#4]
00000c  4770              BX       lr
                          ENDP

00000e  0000              DCW      0x0000
                  |L471.16|
000010  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.472||, COMGROUP=_ZN4Anki8Embedded5PointIfEC1Ev, LINKORDER=||t._ZN4Anki8Embedded5PointIfEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.472||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5PointIfEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Point3IfEC1Ev||, COMGROUP=_ZN4Anki8Embedded6Point3IfEC1Ev, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Point3IfEC2Ev                  ; Alternate entry point ; Anki::Embedded::Point3<float>::Point3__sub_object()
                  _ZN4Anki8Embedded6Point3IfEC1Ev PROC ; Anki::Embedded::Point3<float>::Point3()
;;;145    
;;;146        template<typename Type> Point3<Type>::Point3()
;;;147          : x(static_cast<Type>(0)), y(static_cast<Type>(0)), z(static_cast<Type>(0))
;;;148        {
;;;149        }
;;;150    
000000  ed9f0a04          VLDR     s0,|L478.20|
000004  ed800a00          VSTR     s0,[r0,#0]
000008  ed800a01          VSTR     s0,[r0,#4]
00000c  ed800a02          VSTR     s0,[r0,#8]
000010  4770              BX       lr
                          ENDP

000012  0000              DCW      0x0000
                  |L478.20|
000014  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.479||, COMGROUP=_ZN4Anki8Embedded6Point3IfEC1Ev, LINKORDER=||t._ZN4Anki8Embedded6Point3IfEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.479||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Point3IfEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Point3IfEC1Efff||, COMGROUP=_ZN4Anki8Embedded6Point3IfEC1Efff, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded6Point3IfEC2Efff                  ; Alternate entry point ; Anki::Embedded::Point3<float>::Point3__sub_object(float, float, float)
                  _ZN4Anki8Embedded6Point3IfEC1Efff PROC ; Anki::Embedded::Point3<float>::Point3(float, float, float)
;;;150    
;;;151        template<typename Type> Point3<Type>::Point3(const Type x, const Type y, const Type z)
;;;152          : x(x), y(y), z(z)
;;;153        {
;;;154        }
;;;155    
000000  ed800a00          VSTR     s0,[r0,#0]
000004  edc00a01          VSTR     s1,[r0,#4]
000008  ed801a02          VSTR     s2,[r0,#8]
00000c  4770              BX       lr
                          ENDP


                          AREA ||area_number.486||, COMGROUP=_ZN4Anki8Embedded6Point3IfEC1Efff, LINKORDER=||t._ZN4Anki8Embedded6Point3IfEC1Efff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.486||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Point3IfEC1Efff||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi PROC ; Anki::Embedded::Array<float>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0d              BGE      |L492.36|
000008  f24021e3          MOV      r1,#0x2e3
00000c  4809              LDR      r0,|L492.52|
00000e  e9cd0100          STRD     r0,r1,[sp,#0]
000012  4b09              LDR      r3,|L492.56|
000014  4a09              LDR      r2,|L492.60|
000016  490a              LDR      r1,|L492.64|
000018  2005              MOVS     r0,#5
00001a  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
00001e  b003              ADD      sp,sp,#0xc
000020  2000              MOVS     r0,#0                 ;739
000022  bd00              POP      {pc}
                  |L492.36|
000024  2902              CMP      r1,#2                 ;742
000026  bf2c              ITE      CS                    ;743
000028  2001              MOVCS    r0,#1                 ;743
00002a  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
00002e  b003              ADD      sp,sp,#0xc
000030  bd00              POP      {pc}
;;;747    
                          ENDP

000032  0000              DCW      0x0000
                  |L492.52|
                          DCD      _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::get_size(int) const::__PRETTY_FUNCTION__
                  |L492.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiEs_1 ; Anki::Embedded::Array<float>::get_size(int) const::string (instance 3)
                  |L492.60|
                          DCD      _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiEs_0 ; Anki::Embedded::Array<float>::get_size(int) const::string (instance 2)
                  |L492.64|
                          DCD      _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiEs ; Anki::Embedded::Array<float>::get_size(int) const::string

                          AREA ||area_number.493||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.493||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv PROC ; Anki::Embedded::Quadrilateral<float>::ComputeClockwiseCorners<float>() const
;;;268          // Warning: This may give weird results for non-convex quadrilaterals
;;;269          template<typename OutType> Quadrilateral<OutType> ComputeClockwiseCorners() const;
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
000004  460d              MOV      r5,r1
000006  ed2d8b04          VPUSH    {d8-d9}
00000a  b0c3              SUB      sp,sp,#0x10c
00000c  2201              MOVS     r2,#1
00000e  2300              MOVS     r3,#0
000010  4611              MOV      r1,r2
000012  a840              ADD      r0,sp,#0x100
000014  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000018  6803              LDR      r3,[r0,#0]
00001a  2280              MOVS     r2,#0x80
00001c  a904              ADD      r1,sp,#0x10
00001e  a824              ADD      r0,sp,#0x90
000020  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
000024  2300              MOVS     r3,#0
000026  461a              MOV      r2,r3
000028  2101              MOVS     r1,#1
00002a  a841              ADD      r0,sp,#0x104
00002c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000030  6800              LDR      r0,[r0,#0]
000032  9000              STR      r0,[sp,#0]
000034  ab24              ADD      r3,sp,#0x90
000036  2204              MOVS     r2,#4
000038  2101              MOVS     r1,#1
00003a  a82b              ADD      r0,sp,#0xac
00003c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000040  2701              MOVS     r7,#1
000042  2300              MOVS     r3,#0
000044  ac30              ADD      r4,sp,#0xc0
000046  f04f0a04          MOV      r10,#4
00004a  ae24              ADD      r6,sp,#0x90
00004c  461a              MOV      r2,r3
00004e  4639              MOV      r1,r7
000050  a842              ADD      r0,sp,#0x108
000052  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000056  f8d08000          LDR      r8,[r0,#0]
00005a  f104000c          ADD      r0,r4,#0xc
00005e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000062  f1a0040c          SUB      r4,r0,#0xc
000066  1eb8              SUBS     r0,r7,#2
000068  6020              STR      r0,[r4,#0]
00006a  f04f0900          MOV      r9,#0
00006e  f8c49010          STR      r9,[r4,#0x10]
000072  6060              STR      r0,[r4,#4]
000074  a903              ADD      r1,sp,#0xc
000076  e9cd1800          STRD     r1,r8,[sp,#0]
00007a  2010              MOVS     r0,#0x10
00007c  f8cd900c          STR      r9,[sp,#0xc]
000080  4683              MOV      r11,r0
000082  60a0              STR      r0,[r4,#8]
000084  a801              ADD      r0,sp,#4
000086  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00008a  4602              MOV      r2,r0
00008c  4659              MOV      r1,r11
00008e  4630              MOV      r0,r6
000090  9b00              LDR      r3,[sp,#0]
000092  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
000096  f8ddb00c          LDR      r11,[sp,#0xc]
00009a  f8cd80d4          STR      r8,[sp,#0xd4]
00009e  f8df824c          LDR      r8,|L499.748|
0000a2  0006              MOVS     r6,r0
0000a4  d00d              BEQ      |L499.194|
0000a6  f1bb0f10          CMP      r11,#0x10
0000aa  d21c              BCS      |L499.230|
0000ac  f2403023          MOV      r0,#0x323
0000b0  e9cd8000          STRD     r8,r0,[sp,#0]
0000b4  4b8e              LDR      r3,|L499.752|
0000b6  4a8f              LDR      r2,|L499.756|
0000b8  498f              LDR      r1,|L499.760|
0000ba  2005              MOVS     r0,#5
0000bc  f7fffffe          BL       _Anki_Log
0000c0  e045              B        |L499.334|
                  |L499.194|
0000c2  f240301e          MOV      r0,#0x31e
0000c6  e9cd8000          STRD     r8,r0,[sp,#0]
0000ca  4b89              LDR      r3,|L499.752|
0000cc  4a8b              LDR      r2,|L499.764|
0000ce  498c              LDR      r1,|L499.768|
0000d0  2005              MOVS     r0,#5
0000d2  f7fffffe          BL       _Anki_Log
0000d6  f04f30ff          MOV      r0,#0xffffffff
0000da  6020              STR      r0,[r4,#0]
0000dc  6060              STR      r0,[r4,#4]
0000de  f8c49010          STR      r9,[r4,#0x10]
0000e2  60a0              STR      r0,[r4,#8]
0000e4  e033              B        |L499.334|
                  |L499.230|
0000e6  a835              ADD      r0,sp,#0xd4
0000e8  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
0000ec  b150              CBZ      r0,|L499.260|
0000ee  f2403026          MOV      r0,#0x326
0000f2  e9cd8000          STRD     r8,r0,[sp,#0]
0000f6  4b7e              LDR      r3,|L499.752|
0000f8  4a82              LDR      r2,|L499.772|
0000fa  497f              LDR      r1,|L499.760|
0000fc  2005              MOVS     r0,#5
0000fe  f7fffffe          BL       _Anki_Log
000102  e024              B        |L499.334|
                  |L499.260|
000104  9835              LDR      r0,[sp,#0xd4]
000106  e9c40603          STRD     r0,r6,[r4,#0xc]
00010a  f106000f          ADD      r0,r6,#0xf
00010e  f020000f          BIC      r0,r0,#0xf
000112  e9c47a00          STRD     r7,r10,[r4,#0]
000116  1b80              SUBS     r0,r0,r6
000118  2110              MOVS     r1,#0x10
00011a  fb110107          SMLABB   r1,r1,r7,r0
00011e  4559              CMP      r1,r11
000120  bfdc              ITT      LE
000122  4430              ADDLE    r0,r6
000124  6120              STRLE    r0,[r4,#0x10]
000126  dd12              BLE      |L499.334|
000128  f2403035          MOV      r0,#0x335
00012c  f8cd8000          STR      r8,[sp,#0]
000130  e9cd0101          STRD     r0,r1,[sp,#4]
000134  4b6e              LDR      r3,|L499.752|
000136  4a74              LDR      r2,|L499.776|
000138  4971              LDR      r1,|L499.768|
00013a  2005              MOVS     r0,#5
00013c  f7fffffe          BL       _Anki_Log
000140  f04f30ff          MOV      r0,#0xffffffff
000144  6020              STR      r0,[r4,#0]
000146  6060              STR      r0,[r4,#4]
000148  f8c49010          STR      r9,[r4,#0x10]
00014c  60a0              STR      r0,[r4,#8]
                  |L499.334|
00014e  a836              ADD      r0,sp,#0xd8
000150  462b              MOV      r3,r5
000152  ed9f9a6e          VLDR     s18,|L499.780|
000156  2100              MOVS     r1,#0
000158  ed8d9a36          VSTR     s18,[sp,#0xd8]
00015c  ed8d9a37          VSTR     s18,[sp,#0xdc]
                  |L499.352|
000160  eb0302c1          ADD      r2,r3,r1,LSL #3
000164  ed900a00          VLDR     s0,[r0,#0]
000168  edd20a00          VLDR     s1,[r2,#0]
00016c  1c49              ADDS     r1,r1,#1
00016e  2904              CMP      r1,#4
000170  ee300a20          VADD.F32 s0,s0,s1
000174  ed800a00          VSTR     s0,[r0,#0]
000178  ed900a01          VLDR     s0,[r0,#4]
00017c  edd20a01          VLDR     s1,[r2,#4]
000180  ee300a20          VADD.F32 s0,s0,s1
000184  ed800a01          VSTR     s0,[r0,#4]
000188  dbea              BLT      |L499.352|
00018a  edd00a00          VLDR     s1,[r0,#0]
00018e  eeb50a00          VMOV.F32 s0,#0.25000000
000192  2400              MOVS     r4,#0
000194  ee600a80          VMUL.F32 s1,s1,s0
000198  edc00a00          VSTR     s1,[r0,#0]
00019c  edd00a01          VLDR     s1,[r0,#4]
0001a0  ee200a80          VMUL.F32 s0,s1,s0
0001a4  ed800a01          VSTR     s0,[r0,#4]
                  |L499.424|
0001a8  eb0500c4          ADD      r0,r5,r4,LSL #3
0001ac  eddd0a36          VLDR     s1,[sp,#0xd8]
0001b0  ed900a00          VLDR     s0,[r0,#0]
0001b4  9a2d              LDR      r2,[sp,#0xb4]
0001b6  992f              LDR      r1,[sp,#0xbc]
0001b8  ee708a60          VSUB.F32 s17,s0,s1
0001bc  ed900a01          VLDR     s0,[r0,#4]
0001c0  eddd0a37          VLDR     s1,[sp,#0xdc]
0001c4  2000              MOVS     r0,#0
0001c6  eef58ac0          VCMPE.F32 s17,#0.0
0001ca  ee308a60          VSUB.F32 s16,s0,s1
0001ce  fb001002          MLA      r0,r0,r2,r1
0001d2  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001d6  eb000684          ADD      r6,r0,r4,LSL #2
0001da  bf02              ITTT     EQ
0001dc  eeb58ac0          VCMPEEQ.F32 s16,#0.0
0001e0  eef1fa10          VMRSEQ   APSR_nzcv,FPSCR
0001e4  ed869a00          VSTREQ   s18,[r6,#0]
0001e8  d016              BEQ      |L499.536|
0001ea  eef00a68          VMOV.F32 s1,s17
0001ee  eeb00a48          VMOV.F32 s0,s16
0001f2  f7fffffe          BL       __hardfp_atan2f
0001f6  ee680aa8          VMUL.F32 s1,s17,s17
0001fa  ed860a00          VSTR     s0,[r6,#0]
0001fe  ee480a08          VMLA.F32 s1,s16,s16
000202  eeb10ae0          VSQRT.F32 s0,s1
000206  eeb40a40          VCMP.F32 s0,s0
00020a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00020e  bf1c              ITT      NE
000210  eeb00a60          VMOVNE.F32 s0,s1
000214  f7fffffe          BLNE     __hardfp_sqrtf
                  |L499.536|
000218  1c64              ADDS     r4,r4,#1
00021a  2c04              CMP      r4,#4
00021c  dbc4              BLT      |L499.424|
00021e  483c              LDR      r0,|L499.784|
000220  2301              MOVS     r3,#1
000222  e9cd9000          STRD     r9,r0,[sp,#0]
000226  461a              MOV      r2,r3
000228  a930              ADD      r1,sp,#0xc0
00022a  a82b              ADD      r0,sp,#0xac
00022c  f7fffffe          BL       _ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)
000230  9932              LDR      r1,[sp,#0xc8]
000232  9834              LDR      r0,[sp,#0xd0]
000234  f8ddc11c          LDR      r12,[sp,#0x11c]
000238  fb090001          MLA      r0,r9,r1,r0
00023c  2304              MOVS     r3,#4
00023e  6801              LDR      r1,[r0,#0]
000240  2208              MOVS     r2,#8
000242  eb0501c1          ADD      r1,r5,r1,LSL #3
000246  ed910a00          VLDR     s0,[r1,#0]
00024a  edd10a01          VLDR     s1,[r1,#4]
00024e  ed8d0a38          VSTR     s0,[sp,#0xe0]
000252  edcd0a39          VSTR     s1,[sp,#0xe4]
000256  6841              LDR      r1,[r0,#4]
000258  eb0501c1          ADD      r1,r5,r1,LSL #3
00025c  ed910a00          VLDR     s0,[r1,#0]
000260  edd10a01          VLDR     s1,[r1,#4]
000264  ed8d0a3a          VSTR     s0,[sp,#0xe8]
000268  edcd0a3b          VSTR     s1,[sp,#0xec]
00026c  6881              LDR      r1,[r0,#8]
00026e  eb0501c1          ADD      r1,r5,r1,LSL #3
000272  ed910a00          VLDR     s0,[r1,#0]
000276  edd10a01          VLDR     s1,[r1,#4]
00027a  ed8d0a3c          VSTR     s0,[sp,#0xf0]
00027e  edcd0a3d          VSTR     s1,[sp,#0xf4]
000282  68c0              LDR      r0,[r0,#0xc]
000284  4923              LDR      r1,|L499.788|
000286  eb0500c0          ADD      r0,r5,r0,LSL #3
00028a  ed900a00          VLDR     s0,[r0,#0]
00028e  edd00a01          VLDR     s1,[r0,#4]
000292  ed8d0a3e          VSTR     s0,[sp,#0xf8]
000296  edcd0a3f          VSTR     s1,[sp,#0xfc]
00029a  4660              MOV      r0,r12
00029c  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
0002a0  ed9d0a38          VLDR     s0,[sp,#0xe0]
0002a4  ed800a00          VSTR     s0,[r0,#0]
0002a8  ed9d0a39          VLDR     s0,[sp,#0xe4]
0002ac  ed800a01          VSTR     s0,[r0,#4]
0002b0  ed9d0a3a          VLDR     s0,[sp,#0xe8]
0002b4  ed800a02          VSTR     s0,[r0,#8]
0002b8  ed9d0a3b          VLDR     s0,[sp,#0xec]
0002bc  ed800a03          VSTR     s0,[r0,#0xc]
0002c0  ed9d0a3c          VLDR     s0,[sp,#0xf0]
0002c4  ed800a04          VSTR     s0,[r0,#0x10]
0002c8  ed9d0a3d          VLDR     s0,[sp,#0xf4]
0002cc  ed800a05          VSTR     s0,[r0,#0x14]
0002d0  ed9d0a3e          VLDR     s0,[sp,#0xf8]
0002d4  ed800a06          VSTR     s0,[r0,#0x18]
0002d8  ed9d0a3f          VLDR     s0,[sp,#0xfc]
0002dc  ed800a07          VSTR     s0,[r0,#0x1c]
0002e0  b043              ADD      sp,sp,#0x10c
0002e2  ecbd8b04          VPOP     {d8-d9}
0002e6  b002              ADD      sp,sp,#8
0002e8  e8bd8ff0          POP      {r4-r11,pc}
;;;270    
;;;271          template<typename OutType> Quadrilateral<OutType> ComputeRotatedCorners(const f32 radians) const;
;;;272    
;;;273          bool IsConvex() const;
;;;274    
;;;275          bool operator== (const Quadrilateral<Type> &quad2) const;
;;;276    
;;;277          Quadrilateral<Type> operator+ (const Quadrilateral<Type> &quad2) const;
;;;278    
;;;279          Quadrilateral<Type> operator- (const Quadrilateral<Type> &quad2) const;
;;;280    
;;;281          inline Quadrilateral<Type>& operator= (const Quadrilateral<Type> &quad2);
;;;282    
;;;283          // Keeping this explicit to avoid accidental setting of quads of
;;;284          // different types
;;;285          template<typename InType> void SetCast(const Quadrilateral<InType> &quad2);
;;;286    
;;;287          inline const Point<Type>& operator[] (const s32 index) const;
;;;288          inline Point<Type>& operator[] (const s32 index);
;;;289        }; // class Quadrilateral<Type>
;;;290      } // namespace Embedded
;;;291    } // namespace Anki
;;;292    
;;;293    #endif // _ANKICORETECHEMBEDDED_COMMON_POINT_DECLARATIONS_H_
;;;20     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;21     #include "anki/common/robot/sequences_declarations.h"
;;;1      /**
;;;2      File: sequences_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      A Sequence is a mathematically-defined, ordered list. The sequence classes allow for operations on sequences, without requiring them to be explicitly evaluated.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/flags_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> class Array;
;;;23         template<typename Type> class FixedLengthList;
;;;24         template<typename Type> class ArraySlice;
;;;25         class MemoryStack;
;;;26     
;;;27         // #pragma mark --- Class Declarations ---
;;;28         template<typename Type> class Sequence
;;;29         {
;;;30         }; // class Sequence
;;;31     
;;;32         // A LinearSequence is like the result of a call to Matlab's linspace() It has a start, end, and
;;;33         // increment. It does not explicitly compute the values in the sequence, so does not require
;;;34         // much memory.
;;;35         //
;;;36         // WARNING:
;;;37         // The "end" of a LinearSequence is computed automatically, and is less-than-or-equal-to the
;;;38         // requested end.
;;;39         template<typename Type> class LinearSequence : public Sequence<Type>
;;;40         {
;;;41         public:
;;;42     
;;;43           LinearSequence();
;;;44     
;;;45           // Matlab equivalent: start:end
;;;46           LinearSequence(const Type start, const Type end);
;;;47     
;;;48           // Matlab equivalent: start:increment:end
;;;49           LinearSequence(const Type start, const Type increment, const Type end);
;;;50     
;;;51           // No Matlab equivalent
;;;52           // NOTE: end is unused. It is just present to prevent confusion with the other polymorphic constructors
;;;53           LinearSequence(const Type start, const Type increment, const Type end, const s32 size);
;;;54     
;;;55           // Explicitly evaluate each element of the sequence, and put the results in an Array.
;;;56           Array<Type> Evaluate(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;57           Result Evaluate(ArraySlice<Type> out) const;
;;;58     
;;;59           Type get_start() const;
;;;60     
;;;61           // NOTE: The increment is meaningless for LinearSequences of size 0 or 1.
;;;62           Type get_increment() const;
;;;63     
;;;64           // Note: End it not computed, as it is tempting to use it as a loop condition, but it is not safe
;;;65           // Type get_end() const;
;;;66     
;;;67           // Matlab equivalent: length(start:increment:end)
;;;68           s32 get_size() const;
;;;69     
;;;70         protected:
;;;71           // For speed, FixedLengthList is allowed to access protected members, instead of having to
;;;72           // construct a new LinearSequence every time an element is popped or pushed
;;;73           template<typename FixedLengthListType> friend class FixedLengthList;
;;;74     
;;;75           s32 size;
;;;76     
;;;77           Type start;
;;;78           Type increment;
;;;79     
;;;80           static s32 computeSize(const Type start, const Type increment, const Type end);
;;;81         }; // class LinearSequence
;;;82     
;;;83         // IndexSequence creates the input for slicing an Array
;;;84         // If start or end is less than 0, it is equivalent to (end+value)
;;;85         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type end, s32 arraySize);
;;;86         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type increment, Type end, s32 arraySize);
;;;87         LinearSequence<s32> IndexSequence(s32 arraySize); // Internally, it sets start==0, end=arraySize-1, like the Matlab colon operator array(:,:)
;;;88     
;;;89         // Linspace only works correctly for f32 and f64. To prevent misusage, trying ints will give a linker error.
;;;90         template<typename Type> LinearSequence<Type> Linspace(const Type start, const Type end, const s32 size);
;;;91     
;;;92         // These do not link, as they are unsafe
;;;93         template<> LinearSequence<u8> Linspace(const u8 start, const u8 end, const s32 size);
;;;94         template<> LinearSequence<s8> Linspace(const s8 start, const s8 end, const s32 size);
;;;95         template<> LinearSequence<u16> Linspace(const u16 start, const u16 end, const s32 size);
;;;96         template<> LinearSequence<s16> Linspace(const s16 start, const s16 end, const s32 size);
;;;97         template<> LinearSequence<u32> Linspace(const u32 start, const u32 end, const s32 size);
;;;98         template<> LinearSequence<s32> Linspace(const s32 start, const s32 end, const s32 size);
;;;99         template<> LinearSequence<u64> Linspace(const u64 start, const u64 end, const s32 size);
;;;100        template<> LinearSequence<s64> Linspace(const s64 start, const s64 end, const s32 size);
;;;101    
;;;102        // TODO: Logspace
;;;103        //template<typename Type> class Logspace : public Sequence<Type>
;;;104        //{
;;;105        //public:
;;;106        //protected:
;;;107        //};
;;;108    
;;;109        // A Meshgrid is like the result of a call to Matlab's meshgrid(). It is made of two
;;;110        // LinearSequence objects, so does not require much memory.
;;;111        template<typename Type> class Meshgrid
;;;112        {
;;;113        public:
;;;114          Meshgrid();
;;;115    
;;;116          // Matlab equivalent: meshgrid(xGridVector, yGridVector)
;;;117          Meshgrid(const LinearSequence<Type> xGridVector, const LinearSequence<Type> yGridVector);
;;;118    
;;;119          // Allocate an Array, and evaluate this Meshgrid object
;;;120          //
;;;121          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;122          // The first suffix X or Y is for the xGrid vs yGrid
;;;123          // The second suffix 1 or 2 is for 1D vs 2D output
;;;124          Array<Type> EvaluateX1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;125          Array<Type> EvaluateX2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;126          Array<Type> EvaluateY1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;127          Array<Type> EvaluateY2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;128    
;;;129          // Evaluate this Meshgrid object into a pre-allocated Array
;;;130          //
;;;131          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;132          Result EvaluateX1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;133          Result EvaluateX2(ArraySlice<Type> out) const;
;;;134          Result EvaluateY1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;135          Result EvaluateY2(ArraySlice<Type> out) const;
;;;136    
;;;137          s32 get_numElements() const;
;;;138    
;;;139          inline const LinearSequence<Type>& get_xGridVector() const;
;;;140    
;;;141          inline const LinearSequence<Type>& get_yGridVector() const;
;;;142    
;;;143        protected:
;;;144          LinearSequence<Type> xGridVector;
;;;145          LinearSequence<Type> yGridVector;
;;;146        };
;;;147      } // namespace Embedded
;;;148    } //namespace Anki
;;;149    
;;;150    #endif // #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;22     
;;;23     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;24     namespace cv
;;;25     {
;;;26       class Mat;
;;;27       template<typename Type> class Mat_;
;;;28     }
;;;29     #endif
;;;30     
;;;31     namespace Anki
;;;32     {
;;;33       namespace Embedded
;;;34       {
;;;35         template<typename Type> class ArraySlice;
;;;36         template<typename Type> class ConstArraySlice;
;;;37         template<typename Type> class ConstArraySliceExpression;
;;;38     
;;;39         const s32 ARRAY_FILE_HEADER_LENGTH = 32;
;;;40         const s32 ARRAY_FILE_HEADER_VALID_LENGTH = 14; //< How many characters are not spaces
;;;41         const char ARRAY_FILE_HEADER[ARRAY_FILE_HEADER_LENGTH+1] = "\x89" "AnkiEArray1.2                  ";
;;;42     
;;;43         // #pragma mark --- Array Class Declaration ---
;;;44     
;;;45         template<typename Type> class Array
;;;46         {
;;;47         public:
;;;48     
;;;49           // The stride is the "numCols*sizeof(Type)" rounded up by 16, plus any boundary padding
;;;50           static s32 ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags);
;;;51     
;;;52           // The minimum required memory is the size of a stride, times the number of rows
;;;53           static s32 ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags);
;;;54     
;;;55           // Initializes Array as invalid
;;;56           Array();
;;;57     
;;;58           // Constructor for a Array, pointing to user-allocated MemoryStack. This is the preferred
;;;59           // method for creating a new Array.
;;;60           //
;;;61           // Flags::Buffer.isFullyAllocated doesn't do anything
;;;62           Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;63     
;;;64           // Constructor for a Array, pointing to user-allocated data. This type of array is more
;;;65           // restrictive than most matrix libraries. For example, it may make it hard to convert from
;;;66           // OpenCV::Mat to Array, though the reverse is trivial.
;;;67           //
;;;68           // If following are true, then the contents of data will not be modified, and it will work as
;;;69           // a normal buffer without extra zeros as stride padding:
;;;70           // 1. (numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0
;;;71           // 2. reinterpret_cast<size_t>(data) % MEMORY_ALIGNMENT == 0
;;;72           // 3. numRows*numCols*sizeof(Type) <= dataLength
;;;73           //
;;;74           // If Flags::Buffer.isFullyAllocated == true, then the input data buffer's stride must be a
;;;75           // simple multiple
;;;76           Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags=Flags::Buffer(false,false,true));
;;;77     
;;;78           // Load an image from file. Requires OpenCV;
;;;79           static Array<Type> LoadImage(const char * filename, MemoryStack &memory);
;;;80     
;;;81           // Load or save an array saved as a debugStream.
;;;82           // compressionLevel can be from 0 (uncompressed) to 9 (most compressed). If OpenCV is not used, it must be zero.
;;;83           static Array<Type> LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory);
;;;84           static Array<Type> LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength); //< allocatedBuffer must be allocated and freed manually
;;;85           Result SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const;
;;;86     
;;;87           // Pointer to the data, at a given (y,x) location
;;;88           //
;;;89           // NOTE:
;;;90           // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;91           // inner loop, like: "Type * restrict pArray = Array.Pointer(5);", then index
;;;92           // pArray in the inner loop.
;;;93           inline const Type* Pointer(const s32 index0, const s32 index1) const;
;;;94           inline Type* Pointer(const s32 index0, const s32 index1);
;;;95     
;;;96           // Use this operator for normal C-style 2d matrix indexing. For example, "array[5][0] = 6;"
;;;97           // will set the element in the fifth row and first column to 6. This is the same as
;;;98           // "array.Pointer(5)[0] = 6;"
;;;99           //
;;;100          // NOTE:
;;;101          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;102          // inner loop, like: "Type * restrict pArray = Array[5];", then index
;;;103          // pArray in the inner loop.
;;;104          inline const Type * operator[](const s32 index0) const;
;;;105          inline Type * operator[](const s32 index0);
;;;106    
;;;107          // Pointer to the data, at a given (y,x) location
;;;108          //
;;;109          // NOTE:
;;;110          // The default order of coordinates for the Point() constructor is (x,y). So for example,
;;;111          // access Array[5][3] via Array.Pointer(Point<s16>(3,5))
;;;112          //
;;;113          // NOTE:
;;;114          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;115          // inner loop, like: "Type * restrict pArray = Array.Pointer(Point<s16>(5,0));", then index
;;;116          // pArray in the inner loop.
;;;117          inline const Type* Pointer(const Point<s16> &point) const;
;;;118          inline Type* Pointer(const Point<s16> &point);
;;;119    
;;;120          // Get the ith element, like Matlab's 1D indexing of a 2D array.
;;;121          // For example, the 5th element of Arrays of size (1,6) and (6,1) is the same;
;;;122          const Type& Element(const s32 elementIndex) const;
;;;123          Type& Element(const s32 elementIndex);
;;;124    
;;;125          // Return a slice accessor for this array, like the Matlab expression "array(1:5, 2:3:5)"
;;;126          //
;;;127          // NOTE:
;;;128          // If min or max is less than 0, it is equivalent to (end+value). For example, "Array(0,-1,3,5)"
;;;129          // is the same as "Array(0,arrayHeight-1,3,5)"
;;;130          ArraySlice<Type> operator() ();
;;;131          ArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;132          ArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX);
;;;133          ArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX);
;;;134          ConstArraySlice<Type> operator() () const;
;;;135          ConstArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const;
;;;136          ConstArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const;
;;;137          ConstArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const;
;;;138    
;;;139          // ArraySlice Transpose doesn't modify the data, it just sets an "isTransposed" flag.
;;;140          // Anything that uses ArraySliceExpression respects this flag. This doesn't include things
;;;141          // like Matrix::Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out) for example.
;;;142          ConstArraySliceExpression<Type> Transpose() const;
;;;143    
;;;144    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;145          // Copies the OpenCV Mat. If needed, it converts from color to grayscale by averaging the color channels.
;;;146          s32 Set(const cv::Mat_<Type> &in);
;;;147    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;148    
;;;149          // Use the simple OpenCV gui to display this array as an image
;;;150          // Does nothing is OpenCV is not available
;;;151          void Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues=false, const bool fitImageToWindow=false) const;
;;;152    
;;;153          // Print out the contents of this Array
;;;154          //
;;;155          // NOTE:
;;;156          // * If the min X or Y is less than zero, it will be treated as zero
;;;157          // * If the max X or Y is greater than the size of the array minus one, it will be treated as
;;;158          //   the size of the array minus one
;;;159          Result Print(const char * const variableName = "Array", const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;160          Result PrintAlternate(const char * const variableName = "Array", const s32 version=2, const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;161    
;;;162          // Checks if this array is equal to another array, up to some allowable
;;;163          // per-element varation, epsilon. If the arrays are not the same size,
;;;164          // false is returned.
;;;165          bool IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const;
;;;166    
;;;167          // Checks the basic parameters of this Array, and if it is allocated.
;;;168          bool IsValid() const;
;;;169    
;;;170          // Resize will use MemoryStack::Reallocate() to change the Array's size. It only works if this
;;;171          // Array was the last thing allocated. The reallocated memory will not be cleared
;;;172          //
;;;173          // WARNING:
;;;174          // This will not update any references to the memory, you must update all references manually.
;;;175          Result Resize(const s32 numRows, const s32 numCols, MemoryStack &memory);
;;;176    
;;;177          // Set every element in the Array to zero, including the stride padding.
;;;178          // Returns the number of bytes set to zero
;;;179          s32 SetZero();
;;;180    
;;;181          // Set every element in the Array to this value
;;;182          // Returns the number of values set
;;;183          s32 Set(const Type value);
;;;184    
;;;185          // Elementwise copies the input Array into this array. No memory is allocated.
;;;186          s32 Set(const Array<Type> &in);
;;;187    
;;;188          // Copy values to this Array.
;;;189          // If the input array does not contain enough elements, the remainder of this Array will be filled with zeros.
;;;190          // Returns the number of values set (not counting extra zeros)
;;;191          s32 Set(const Type * const values, const s32 numValues);
;;;192    
;;;193          // Read in the input, then cast it to this object's type
;;;194          //
;;;195          // WARNING:
;;;196          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;197          template<typename InType> s32 SetCast(const Array<InType> &in);
;;;198          template<typename InType> s32 SetCast(const InType * const values, const s32 numValues);
;;;199    
;;;200          // This is a shallow copy. There's no reference counting. Updating the data of one array will
;;;201          // update that of others (because they point to the same location in memory).
;;;202          // However, Resizing or other operations on one array won't update the others.
;;;203          Array& operator= (const Array & rightHandSide);
;;;204    
;;;205          // Similar to Matlabs size(matrix, dimension), and dimension is in {0,1}
;;;206          s32 get_size(s32 dimension) const;
;;;207    
;;;208          // Get the stride, which is the number of bytes between an element at (n,m) and an element at (n+1,m)
;;;209          s32 get_stride() const;
;;;210    
;;;211          // just size[0] * size[1]
;;;212          s32 get_numElements() const;
;;;213    
;;;214          // Return the flags that were used when this object was constructed.
;;;215          Flags::Buffer get_flags() const;
;;;216    
;;;217          // Equivalent to Pointer(0,0)
;;;218          //
;;;219          // These are for very low-level access to the buffers. Probably you want to be using one of
;;;220          // the Pointer() accessor methods instead of these.
;;;221          void* get_buffer();
;;;222          const void* get_buffer() const;
;;;223    
;;;224        protected:
;;;225          static const s32 HEADER_LENGTH = 8;
;;;226          static const s32 FOOTER_LENGTH = 8;
;;;227    
;;;228          s32 size[2];
;;;229          s32 stride;
;;;230          Flags::Buffer flags;
;;;231    
;;;232          Type * data;
;;;233    
;;;234          // Basic allocation method
;;;235          void* AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate);
;;;236    
;;;237          // Performs checks and sets appropriate parameters for this object
;;;238          Result InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags);
;;;239    
;;;240          // Set all the buffers and sizes to zero, to signal an invalid array
;;;241          void InvalidateArray();
;;;242    
;;;243          // If this object's Type is a basic type, this method prints out this object.
;;;244          Result PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;245    
;;;246          // If this object's Type is a string, this method prints out this object.
;;;247          Result PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;248        }; // class Array
;;;249    
;;;250        // #pragma mark --- FixedPointArray Class Declaration ---
;;;251    
;;;252        template<typename Type> class FixedPointArray : public Array<Type>
;;;253        {
;;;254        public:
;;;255          FixedPointArray();
;;;256    
;;;257          // Same as Array() constructor
;;;258          // This is the preferred method for constructing an FixedPointArray
;;;259          FixedPointArray(const s32 numRows, const s32 numCols, const s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;260    
;;;261          // Same as Array() constructor
;;;262          // This is the advanced method for constructing an FixedPointArray
;;;263          FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;264    
;;;265          s32 get_numFractionalBits() const;
;;;266    
;;;267        protected:
;;;268          s32 numFractionalBits;
;;;269        };
;;;270    
;;;271        // If you don't know the type of the Array you're loading, use this function directly, then cast it based on the read parameters
;;;272        Array<u8> LoadBinaryArray_UnknownType(
;;;273          const char * filename,
;;;274          MemoryStack *scratch,
;;;275          MemoryStack *memory,
;;;276          void * allocatedBuffer,
;;;277          const s32 allocatedBufferLength,
;;;278          u16  &basicType_sizeOfType,
;;;279          bool &basicType_isBasicType,
;;;280          bool &basicType_isInteger,
;;;281          bool &basicType_isSigned,
;;;282          bool &basicType_isFloat,
;;;283          bool &basicType_isString
;;;284          );
;;;285    
;;;286    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;287        // Returns a cv::Mat that mirrors the data in the input Array.
;;;288        // WARNING: If you copy the cv::Mat or assign it incorrectly, it will no longer mirror the input Array
;;;289        // WARNING: This const_casts the input array, so you can unsafely modify it via the output cv::Mat
;;;290        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out);
;;;291    #endif
;;;292      } // namespace Embedded
;;;293    } //namespace Anki
;;;294    
;;;295    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_DECLARATIONS_H_
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;2      File: arraySlices_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      An array slice is a sub-array of an Array object.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Class Declarations ---
;;;23     
;;;24         template<typename Type> class ConstArraySlice;
;;;25         template<typename Type> class ArraySlice;
;;;26         template<typename Type> class ConstArraySliceExpression;
;;;27     
;;;28         // An ArraySlice is a simple indexing wrapper on top of an Array. The slice of an Array could be
;;;29         // a sub-rectangle of an array and/or skip every n-th element.
;;;30         //
;;;31         // For example, Array(0,3,-1,1,2,4) is the same as Matlab's array(1:3:end, 2:2:5).
;;;32         // (The Array indexing starts from zero vs Matlab's one, hence the different numbers).
;;;33         //
;;;34         // TODO: support non-int indexes
;;;35         // TODO: is there a better way of doing this than a completely different class, different only
;;;36         //       by const?
;;;37         template<typename Type> class ConstArraySlice
;;;38         {
;;;39         public:
;;;40           ConstArraySlice();
;;;41     
;;;42           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;43           ConstArraySlice(const Array<Type> &array);
;;;44     
;;;45           // It's probably easier to call array.operator() than this constructor directly
;;;46           ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;47     
;;;48           // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;49           ConstArraySliceExpression<Type> Transpose() const;
;;;50     
;;;51           bool IsValid() const;
;;;52     
;;;53           const LinearSequence<s32>& get_ySlice() const;
;;;54     
;;;55           const LinearSequence<s32>& get_xSlice() const;
;;;56     
;;;57           // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;58           // don't support the full ArraySlice type, and should be used with caution.
;;;59           const Array<Type>& get_array() const;
;;;60     
;;;61         protected:
;;;62           LinearSequence<s32> ySlice;
;;;63           LinearSequence<s32> xSlice;
;;;64     
;;;65           Array<Type> array;
;;;66     
;;;67           // For speed, this is a direct pointer to the Array's protected data
;;;68           const Type * constArrayData;
;;;69         }; // template<typename Type> class ArraySlice
;;;70     
;;;71         // A non-const version of ConstArraySlice, see ConstArraySlice for details
;;;72         //
;;;73         // WARNING: A "const ArraySlice" doesn't have a const Array. Only ConstArraySlice has a const
;;;74         //          Array. This allows for implicit conversion to non-const function parameters.
;;;75         template<typename Type> class ArraySlice : public ConstArraySlice<Type>
;;;76         {
;;;77         public:
;;;78           ArraySlice();
;;;79     
;;;80           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;81           // The Array parameter is not a reference, to allow for implicit conversion
;;;82           ArraySlice(Array<Type> array);
;;;83     
;;;84           // It's probably easier to call array.operator() than this constructor directly
;;;85           // The Array parameter is not a reference, to allow for implicit conversion
;;;86           ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;87     
;;;88           // If automaticTranspose==true, then you can set a MxN slice with a NxM input.
;;;89           // Matlab allows this for vectors, though this method will also work for
;;;90           // arbitrary-sized arrays.
;;;91           s32 Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
;;;92     
;;;93           // Explicitly evaluate the input LinearSequence into this ArraySlice
;;;94           s32 Set(const LinearSequence<Type> &input);
;;;95     
;;;96           // Set all values of this slice to the given value.
;;;97           //
;;;98           // For example, "array(0,-1,1,4).Set(5);" is the same as
;;;99           // Matlab's "array(1:end, 2:5) = 5;"
;;;100          s32 Set(const Type value);
;;;101    
;;;102          // Copy values to this ArraySlice.
;;;103          // numValues must be equal to the number of values in this slice
;;;104          // Returns the number of values set
;;;105          s32 Set(const Type * const values, const s32 numValues);
;;;106    
;;;107          // Read in the input, then cast it to this object's type
;;;108          //
;;;109          // WARNING:
;;;110          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;111          template<typename InType> s32 SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose);
;;;112          //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;113    
;;;114          // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;115          // don't support the full ArraySlice type, and should be used with caution.
;;;116          Array<Type>& get_array();
;;;117    
;;;118        protected:
;;;119    
;;;120          // For speed, this is a direct pointer to the Array's protected data
;;;121          Type * arrayData;
;;;122        }; // template<typename Type> class ArraySlice
;;;123    
;;;124        // An ConstArraySliceExpression is like a ConstArraySlice, but can also be transposed
;;;125        // It may have other abilities in the future, but will probably always be const
;;;126        template<typename Type> class ConstArraySliceExpression : public ConstArraySlice<Type>
;;;127        {
;;;128        public:
;;;129          ConstArraySliceExpression();
;;;130    
;;;131          ConstArraySliceExpression(const Array<Type> input, bool isTransposed=false);
;;;132    
;;;133          ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed=false);
;;;134    
;;;135          ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed=false);
;;;136    
;;;137          // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;138          // This object isn't modified, but the returned object is.
;;;139          ConstArraySliceExpression<Type> Transpose() const;
;;;140    
;;;141          bool get_isTransposed() const;
;;;142    
;;;143        protected:
;;;144          bool isTransposed;
;;;145        };
;;;146    
;;;147        // To simplify the creation of kernels using an ArraySlice, and to aid the compiler optimizer,
;;;148        // an ArraySliceLimits can be initialized at the beginning of the function, then used as the
;;;149        // limits for the inner loops.
;;;150    
;;;151        // The suffix of in# and out# refer to the number of input and output matrices.
;;;152        // If output == 0, then the output is a scalar.
;;;153    
;;;154        template<typename Type> class ArraySliceSimpleLimits
;;;155        {
;;;156        public:
;;;157          Type xStart;
;;;158          Type xIncrement;
;;;159          s32  xSize;
;;;160    
;;;161          Type yStart;
;;;162          Type yIncrement;
;;;163          s32  ySize;
;;;164    
;;;165          ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;166        };
;;;167    
;;;168        // In1 and out0 is a special, ultra-simple case, for one matrix input and a scalar output
;;;169        template<typename Type> class ArraySliceLimits_in1_out0
;;;170        {
;;;171        public:
;;;172          // Was this ArraySliceLimits initialized?
;;;173          bool isValid;
;;;174    
;;;175          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;176    
;;;177          ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;178        };
;;;179    
;;;180        // One input, one output
;;;181        template<typename Type> class ArraySliceLimits_in1_out1
;;;182        {
;;;183        public:
;;;184          // Was this ArraySliceLimits initialized?
;;;185          bool isValid;
;;;186    
;;;187          // Can a simple (non-transposed) iteration be performed?
;;;188          bool isSimpleIteration;
;;;189    
;;;190          // These are the current values for the coordinates in the input and output images
;;;191          s32 out1Y;
;;;192          s32 out1X;
;;;193          s32 in1Y;
;;;194          s32 in1X;
;;;195    
;;;196          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;197          s32 ySize;
;;;198          s32 xSize;
;;;199    
;;;200          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;201          // incremented every iteration of the inner loop
;;;202          s32 out1_xInnerIncrement;
;;;203          s32 in1_xInnerIncrement;
;;;204          s32 in1_yInnerIncrement;
;;;205    
;;;206          ArraySliceLimits_in1_out1(
;;;207            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;208            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;209    
;;;210          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;211          inline void OuterIncrementTop();
;;;212    
;;;213          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;214          inline void OuterIncrementBottom();
;;;215    
;;;216        protected:
;;;217          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;218    
;;;219          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;220          bool in1_isTransposed;
;;;221        };
;;;222    
;;;223        // Two inputs, one output
;;;224        template<typename Type> class ArraySliceLimits_in2_out1
;;;225        {
;;;226        public:
;;;227          // Was this ArraySliceLimits initialized?
;;;228          bool isValid;
;;;229    
;;;230          // Can a simple (non-transposed) iteration be performed?
;;;231          bool isSimpleIteration;
;;;232    
;;;233          // These are the current values for the coordinates in the input and output images
;;;234          s32 out1Y;
;;;235          s32 out1X;
;;;236          s32 in1Y;
;;;237          s32 in1X;
;;;238          s32 in2Y;
;;;239          s32 in2X;
;;;240    
;;;241          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;242          s32 ySize;
;;;243          s32 xSize;
;;;244    
;;;245          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;246          // incremented every iteration of the inner loop
;;;247          s32 out1_xInnerIncrement;
;;;248          s32 in1_xInnerIncrement;
;;;249          s32 in1_yInnerIncrement;
;;;250          s32 in2_xInnerIncrement;
;;;251          s32 in2_yInnerIncrement;
;;;252    
;;;253          ArraySliceLimits_in2_out1(
;;;254            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;255            const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed,
;;;256            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;257    
;;;258          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;259          inline void OuterIncrementTop();
;;;260    
;;;261          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;262          inline void OuterIncrementBottom();
;;;263    
;;;264        protected:
;;;265          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;266    
;;;267          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;268          bool in1_isTransposed;
;;;269    
;;;270          ArraySliceSimpleLimits<Type> rawIn2Limits;
;;;271          bool in2_isTransposed;
;;;272        };
;;;273      } // namespace Embedded
;;;274    } // namespace Anki
;;;275    
;;;276    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         class SerializedBuffer;
;;;24     
;;;25         // A FixedLengthList is a list with a fixed maximum size, which is allocated at construction.
;;;26         template<typename Type> class FixedLengthList : public ArraySlice<Type>
;;;27         {
;;;28         public:
;;;29           FixedLengthList();
;;;30     
;;;31           // Constructor for a FixedLengthList, pointing to user-allocated data.
;;;32           FixedLengthList(s32 maximumSize, void * data, s32 dataLength, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;33     
;;;34           // Constructor for a FixedLengthList, pointing to user-allocated MemoryStack
;;;35           FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;36     
;;;37           bool IsValid() const;
;;;38     
;;;39           // Resize will use MemoryStack::Reallocate() to change the FixedLengthList's size. It only works if this
;;;40           // FixedLengthList was the last thing allocated. The reallocated memory will not be cleared
;;;41           //
;;;42           // WARNING:
;;;43           // This will not update any references to the memory, you must update all references manually.
;;;44           Result Resize(s32 maximumSize, MemoryStack &memory);
;;;45     
;;;46           Result PushBack(const Type &value);
;;;47     
;;;48           // Will act as a normal pop, except when the list is empty. Then subsequent
;;;49           // calls will keep returning the first value in the list.
;;;50           Type PopBack();
;;;51     
;;;52           // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
;;;53           inline void Clear();
;;;54     
;;;55           // Does this ever need to be declared explicitly?
;;;56           //FixedLengthList& operator= (const FixedLengthList & rightHandSide);
;;;57     
;;;58           // Pointer to the data, at a given location
;;;59           inline Type* Pointer(const s32 index);
;;;60           inline const Type* Pointer(const s32 index) const;
;;;61     
;;;62           // Use this operator for normal C-style vector indexing. For example, "list[5] = 6;" will set
;;;63           // the element in the fifth row and first column to 6. This is the same as "*list.Pointer(5) =
;;;64           // 6;"
;;;65           //
;;;66           // NOTE:
;;;67           // Using this in a inner loop may be less efficient than using an explicit pointer with a
;;;68           // restrict keyword (Though the runtime cost isn't nearly as large as the [] operator for the
;;;69           // Array class). For speeding up performance-critical inner loops, use something like: "Type *
;;;70           // restrict pList = list.Pointer(0);" outside the inner loop, then index
;;;71           // pList in the inner loop.
;;;72           inline const Type& operator[](const s32 index) const;
;;;73           inline Type& operator[](const s32 index);
;;;74     
;;;75           // Print out the contents of this FixedLengthList
;;;76           Result Print(const char * const variableName = "FixedLengthList", const s32 minIndex = 0, const s32 maxIndex = 0x7FFFFFE) const;
;;;77     
;;;78           // Set every element in the Array to zero, including the stride padding, but not including the optional fill patterns (if they exist)
;;;79           // Returns the number of bytes set to zero
;;;80           inline s32 SetZero();
;;;81     
;;;82           // Read in the input, then cast it to this object's type
;;;83           //
;;;84           // WARNING:
;;;85           // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;86           template<typename InType> s32 SetCast(const FixedLengthList<InType> &input, bool automaticTranspose=true);
;;;87           //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;88     
;;;89           // The maximum size is set at object construction
;;;90           inline s32 get_maximumSize() const;
;;;91     
;;;92           // The current size changes as the FixedLengthList is used
;;;93           inline s32 get_size() const;
;;;94     
;;;95           // Attempt to set the size to newSize. Returns the value that was actually set.
;;;96           s32 set_size(s32 newSize);
;;;97     
;;;98         protected:
;;;99           // TODO: make less hacky
;;;100          friend class SerializedBuffer;
;;;101        }; // class FixedLengthList
;;;102      } // namespace Embedded
;;;103    } //namespace Anki
;;;104    
;;;105    #endif // _ANKICORETECHEMBEDDED_COMMON_FIXEDLENGTHLIST_DECLARATIONS_H_
;;;19     
;;;20     namespace Anki
;;;21     {
;;;22       namespace Embedded
;;;23       {
;;;24         // A 1d, run-length encoded piece of a 2d component
;;;25         // The type is for storing the ID. u16 is enough for QVGA, but VGA and above need s32
;;;26         template<typename Type> class ConnectedComponentSegment
;;;27         {
;;;28         public:
;;;29           // xStart, xEnd, y use array indexes, meaning the first pixel is at (0,0), not (0.5,0.5) like true coordinates
;;;30           s16 xStart, xEnd, y;
;;;31           Type id;
;;;32     
;;;33           ConnectedComponentSegment();
;;;34     
;;;35           ConnectedComponentSegment(const s16 xStart, const s16 xEnd, const s16 y = -1, const Type id = 0);
;;;36     
;;;37           // Returns a positive s64 if a > b, a negative s64 is a < b, or zero if they are identical
;;;38           // The ordering of components is first by id (the ids are sorted in increasing value, but with zero at the end {1...MAX_VALUE,0}), then y, then xStart
;;;39           // TODO: Doublecheck that this is correct for corner cases
;;;40           static inline s64 Compare(const ConnectedComponentSegment<Type> &a, const ConnectedComponentSegment<Type> &b);
;;;41     
;;;42           void Print() const;
;;;43     
;;;44           bool operator== (const ConnectedComponentSegment &component2) const;
;;;45         }; // class ConnectedComponentSegment
;;;46     
;;;47         // Template for ConnectedComponents. See ConnectedComponents for documentation.
;;;48         template<typename Type> class ConnectedComponentsTemplate
;;;49         {
;;;50         public:
;;;51     
;;;52           static Result Extract1dComponents(const u8 * restrict binaryImageRow, const s16 binaryImageWidth, const s16 minComponentWidth, const s16 maxSkipDistance, FixedLengthList<ConnectedComponentSegment<Type> > &extractedComponents);
;;;53     
;;;54           ConnectedComponentsTemplate();
;;;55     
;;;56           ConnectedComponentsTemplate(const Type maxComponentSegments, const s16 maxImageWidth, MemoryStack &memory);
;;;57     
;;;58           Result Extract2dComponents_FullImage(const Array<u8> &binaryImage, const s16 minComponentWidth, const s16 maxSkipDistance, MemoryStack scratch);
;;;59     
;;;60           Result Extract2dComponents_PerRow_Initialize(MemoryStack &fastMemory, MemoryStack &slowerMemory, MemoryStack &slowestMemory);
;;;61           Result Extract2dComponents_PerRow_NextRow(const u8 * restrict binaryImageRow, const s32 imageWidth, const s16 whichRow, const s16 minComponentWidth, const s16 maxSkipDistance);
;;;62           Result Extract2dComponents_PerRow_Finalize();
;;;63     
;;;64           Result SortConnectedComponentSegments();
;;;65     
;;;66           Result SortConnectedComponentSegmentsById(MemoryStack scratch);
;;;67     
;;;68           Result CompressConnectedComponentSegmentIds(MemoryStack scratch);
;;;69     
;;;70           Result ComputeComponentSizes(FixedLengthList<s32> &componentSizes);
;;;71     
;;;72           Result ComputeComponentCentroids(FixedLengthList<Point<s16> > &componentCentroids, MemoryStack scratch);
;;;73     
;;;74           Result ComputeComponentBoundingBoxes(FixedLengthList<Rectangle<s16> > &componentBoundingBoxes);
;;;75     
;;;76           Result ComputeNumComponentSegmentsForEachId(FixedLengthList<s32> &numComponentSegments);
;;;77     
;;;78           Result InvalidateSmallOrLargeComponents(const s32 minimumNumPixels, const s32 maximumNumPixels, MemoryStack scratch);
;;;79     
;;;80           Result InvalidateSolidOrSparseComponents(const s32 sparseMultiplyThreshold, const s32 solidMultiplyThreshold, MemoryStack scratch);
;;;81     
;;;82           Result InvalidateFilledCenterComponents_shrunkRectangle(const s32 percentHorizontal, const s32 percentVertical, MemoryStack scratch);
;;;83     
;;;84           Result InvalidateFilledCenterComponents_hollowRows(const f32 minHollowRatio, MemoryStack scratch);
;;;85     
;;;86           Result PushBack(const ConnectedComponentSegment<Type> &value);
;;;87     
;;;88           // Note that this is a const-only accessor function. The ConnectedComponets class keeps a lot
;;;89           // of tabs on sorting and maximumId and such, so no one else should be directly modifying the
;;;90           // buffers.
;;;91           inline const ConnectedComponentSegment<Type>* Pointer(const s32 index) const;
;;;92           inline const ConnectedComponentSegment<Type>& operator[](const s32 index) const;
;;;93     
;;;94           bool IsValid() const;
;;;95     
;;;96           Result Print() const;
;;;97     
;;;98           Type get_maximumId() const;
;;;99     
;;;100          s32 get_size() const;
;;;101    
;;;102          bool get_isSortedInId() const;
;;;103          bool get_isSortedInY() const;
;;;104          bool get_isSortedInX() const;
;;;105    
;;;106        protected:
;;;107          enum State
;;;108          {
;;;109            STATE_INVALID,
;;;110            STATE_CONSTRUCTED,
;;;111            STATE_INITIALIZED,
;;;112            STATE_FINALIZED
;;;113          };
;;;114    
;;;115          FixedLengthList<ConnectedComponentSegment<Type> > components;
;;;116          FixedLengthList<ConnectedComponentSegment<Type> > currentComponents1d;
;;;117          FixedLengthList<ConnectedComponentSegment<Type> > previousComponents1d;
;;;118          FixedLengthList<ConnectedComponentSegment<Type> > newPreviousComponents1d;
;;;119          FixedLengthList<Type> equivalentComponents;
;;;120    
;;;121          State curState;
;;;122    
;;;123          bool isSortedInId;
;;;124          bool isSortedInY;
;;;125          bool isSortedInX;
;;;126    
;;;127          Type maximumId;
;;;128          s32 maxImageWidth;
;;;129          s32 maxComponentSegments;
;;;130    
;;;131          // Iterate through components, and update the maximum id
;;;132          Result FindMaximumId();
;;;133        }; // class ConnectedComponentsTemplate
;;;134    
;;;135        // A ConnectedComponents class holds a list of ConnectedComponentSegment<Type> objects
;;;136        // It can incrementally parse an input binary image per-row, updating its global list as it goes
;;;137        // It also contains various utilities to remove poor-quality components
;;;138        class ConnectedComponents
;;;139        {
;;;140        public:
;;;141    
;;;142          ConnectedComponents();
;;;143    
;;;144          // Constructor for a ConnectedComponents, pointing to user-allocated MemoryStack
;;;145          // The memory should remain valid for the entire life of the object
;;;146          ConnectedComponents(const s32 maxComponentSegments, const s16 maxImageWidth, MemoryStack &memory); //< This default constructor creates a u16 object
;;;147          ConnectedComponents(const s32 maxComponentSegments, const s16 maxImageWidth, const bool useU16, MemoryStack &memory);
;;;148    
;;;149          // Extract 2d connected components from binaryImage All extracted components are stored in a
;;;150          // single list of ComponentSegments
;;;151          Result Extract2dComponents_FullImage(const Array<u8> &binaryImage, const s16 minComponentWidth, const s16 maxSkipDistance, MemoryStack scratch);
;;;152    
;;;153          // Methods to parse an input binary image per-row, updating this object's global list as it goes
;;;154          //
;;;155          // WARNING:
;;;156          // The memory allocated in Extract2dComponents_PerRow_Initialize() must be valid until
;;;157          // Extract2dComponents_PerRow_Finalize() is called. It does not have to be in the same
;;;158          // location as the memory used by the constructor
;;;159          // Note: fastMemory and slowMemory can be the same object pointing to the same memory
;;;160          Result Extract2dComponents_PerRow_Initialize(MemoryStack &fastMemory, MemoryStack &slowerMemory, MemoryStack &slowestMemory);
;;;161          Result Extract2dComponents_PerRow_NextRow(const u8 * restrict binaryImageRow, const s32 imageWidth, const s16 whichRow, const s16 minComponentWidth, const s16 maxSkipDistance);
;;;162          Result Extract2dComponents_PerRow_Finalize();
;;;163    
;;;164          // Sort the components by id (the ids are sorted in increasing value, but with zero at the end {1...MAX_VALUE,0}), then y, then xStart
;;;165          // WARNING: This method is really slow if called first. If you have the memory available, call SortConnectedComponentSegmentsById() first.
;;;166          Result SortConnectedComponentSegments();
;;;167    
;;;168          // Sort the components by id. This will retain the original ordering as well, so if the
;;;169          // components are already sorted in y, the output of this method will be sorted in id and y.
;;;170          // Requires numValidComponentSegments*sizeof(ConnectedComponentSegment<u16>) bytes of scratch
;;;171          Result SortConnectedComponentSegmentsById(MemoryStack scratch);
;;;172    
;;;173          // The list of components may have unused ids. This function compresses the set of ids, so that
;;;174          // max(ids) == numberOfUniqueValues(ids). For example, the list of ids {0,4,5,7} would be
;;;175          // changed to {0,1,2,3}.
;;;176          //
;;;177          // For a ConnectedComponent that has a maximum id of N, this function requires
;;;178          // 3n + 1 bytes of scratch.
;;;179          //
;;;180          // TODO: If scratch usage is a bigger issue than computation time, this could be done with a bitmask
;;;181          Result CompressConnectedComponentSegmentIds(MemoryStack scratch);
;;;182    
;;;183          // Iterate through components, and compute the number of pixels for each component
;;;184          // componentSizes must be at least sizeof(s32)*(maximumdId+1) bytes
;;;185          // NOTE: this is probably inefficient, compared with interlacing the loops in a kernel
;;;186          Result ComputeComponentSizes(FixedLengthList<s32> &componentSizes);
;;;187    
;;;188          // Iterate through components, and compute the centroid of each component componentCentroids
;;;189          // must be at least sizeof(Point<s16>)*(maximumdId+1) bytes
;;;190          // NOTE: this is probably inefficient, compared with interlacing the loops in a kernel
;;;191          //
;;;192          // For a ConnectedComponent that has a maximum id of N, this function requires
;;;193          // 4n + 4 bytes of scratch.
;;;194          Result ComputeComponentCentroids(FixedLengthList<Point<s16> > &componentCentroids, MemoryStack scratch);
;;;195    
;;;196          // Iterate through components, and compute bounding box for each component
;;;197          // componentBoundingBoxes must be at least sizeof(Rectangle<s16>)*(maximumdId+1) bytes
;;;198          // NOTE: this is probably inefficient, compared with interlacing the loops in a kernel
;;;199          Result ComputeComponentBoundingBoxes(FixedLengthList<Rectangle<s16> > &componentBoundingBoxes);
;;;200    
;;;201          // Iterate through components, and compute the number of componentSegments that have each id
;;;202          // componentSizes must be at least sizeof(s32)*(maximumdId+1) bytes
;;;203          // NOTE: this is probably inefficient, compared with interlacing the loops in a kernel
;;;204          Result ComputeNumComponentSegmentsForEachId(FixedLengthList<s32> &numComponentSegments);
;;;205    
;;;206          // Goes through the list components, and computes the number of pixels for each.
;;;207          // For any componentId with less than minimumNumPixels pixels, all ConnectedComponentSegment<u16> with that id will have their ids set to zero
;;;208          //
;;;209          // For a ConnectedComponent that has a maximum id of N, this function requires
;;;210          // 4n + 4 bytes of scratch.
;;;211          Result InvalidateSmallOrLargeComponents(const s32 minimumNumPixels, const s32 maximumNumPixels, MemoryStack scratch);
;;;212    
;;;213          // Goes through the list components, and computes the "solidness", which is the ratio of
;;;214          // "numPixels / (boundingWidth*boundingHeight)". For any componentId with that is too solid or
;;;215          // sparse (opposite of solid), all ConnectedComponentSegment<u16> with that id will have their ids
;;;216          // set to zero
;;;217          //
;;;218          // The SQ26.5 parameter sparseMultiplyThreshold is set so that a component is invalid if
;;;219          // "sparseMultiplyThreshold*numPixels < boundingWidth*boundingHeight". A resonable value is
;;;220          // between 5<<5 = 160 and 100<<5 = 3200.
;;;221          //
;;;222          // The SQ26.5 parameter solidMultiplyThreshold is set so that a component is invalid if
;;;223          // "solidMultiplyThreshold*numPixels > boundingWidth*boundingHeight". A resonable value is
;;;224          // between 1.5*pow(2,5) = 48 and 5<<5 = 160.
;;;225          //
;;;226          // NOTE: This can overflow if the number of pixels is greater than 2^26 (a bit more Ultra-HD
;;;227          //       resolution)
;;;228          //
;;;229          // For a ConnectedComponent that has a maximum id of N, this function requires 8N + 8 bytes
;;;230          // of scratch.
;;;231          Result InvalidateSolidOrSparseComponents(const s32 sparseMultiplyThreshold, const s32 solidMultiplyThreshold, MemoryStack scratch);
;;;232    
;;;233          // If a component doesn't have a hollow center, it's not a fiducial. Based on a component's
;;;234          // centroid, and its maximum extent, this method makes sure no componentSegment is inside of
;;;235          // an inner rectangle. For example, take a component centered at (50,50), that is 20 pixels
;;;236          // wide and high. If percentHorizontal=0.5 and percentVertical=0.25, then no componentSegment
;;;237          // should intersect the rectangle between (40,45) and (60,55).
;;;238          //
;;;239          // percentHorizontal and percentVertical are SQ23.8,
;;;240          // and should range from (0.0, 1.0), non-inclusive
;;;241          //
;;;242          // For a ConnectedComponent that has a maximum id of N, this function requires 10N + 10 bytes
;;;243          // of scratch.
;;;244          Result InvalidateFilledCenterComponents_shrunkRectangle(const s32 percentHorizontal, const s32 percentVertical, MemoryStack scratch);
;;;245    
;;;246          // Go along each row of components. Find the maximum difference between the end of one
;;;247          // component and the start of the next. The amount of space in the center of a component is
;;;248          // approximated as the sum of the per-row max distances, divided by the number of filled pixels.
;;;249          //
;;;250          // For example:
;;;251          // If minHollowRatio==0.5, this means that a component must have at least half as many interior as exterior pixels.
;;;252          // If minHollowRatio==1.0, this means that a component must have at least an equal number of interior and exterior pixels.
;;;253          // If minHollowRatio==2.0, this means that a component must have at least twice as many interior as exterior pixels.
;;;254          // TODO: what is a reasonable value? 1.0?
;;;255          Result InvalidateFilledCenterComponents_hollowRows(const f32 minHollowRatio, MemoryStack scratch);
;;;256    
;;;257          bool IsValid() const;
;;;258    
;;;259          Result Print() const;
;;;260    
;;;261          s32 get_maximumId() const;
;;;262    
;;;263          s32 get_size() const;
;;;264    
;;;265          bool get_useU16() const;
;;;266    
;;;267          bool get_isSortedInId() const;
;;;268          bool get_isSortedInY() const;
;;;269          bool get_isSortedInX() const;
;;;270    
;;;271          const ConnectedComponentsTemplate<u16>* get_componentsU16() const;
;;;272          const ConnectedComponentsTemplate<s32>* get_componentsS32() const;
;;;273    
;;;274          ConnectedComponentsTemplate<u16>* get_componentsU16();
;;;275          ConnectedComponentsTemplate<s32>* get_componentsS32();
;;;276    
;;;277        protected:
;;;278          // Only one of these classes will be initialized, based on the constructor
;;;279          bool useU16;
;;;280          ConnectedComponentsTemplate<u16> componentsU16;
;;;281          ConnectedComponentsTemplate<s32> componentsS32;
;;;282        }; // class ConnectedComponents
;;;283      } // namespace Embedded
;;;284    } // namespace Anki
;;;285    
;;;286    #endif // _ANKICORETECHEMBEDDED_VISION_VISIONKERNELS_CONNECTEDCOMPONENTS_DECLARATIONS_H_
;;;16     
;;;17     #include "anki/common/types.h"
;;;1      /**
;;;18     #include "anki/common/robot/memory.h"
;;;1      /**
;;;19     #include "anki/common/robot/fixedLengthList.h"
;;;1      /**
;;;2      File: fixedLengthList.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of fixedLenghtList_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_H_
;;;14     
;;;15     #include "anki/common/robot/fixedLengthList_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;1      /**
;;;2      File: utilities.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of utilities_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;14     
;;;15     #include "anki/common/robot/utilities_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;17     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;2      * File: trig_fast.h
;;;3      *
;;;4      * Author: Kevin Yoon
;;;5      * Created: 22-OCT-2012
;;;6      *
;;;7      * Some trig functions to supplement incomplete math libraries on embedded targets.
;;;8      * Error of all functions is less than +/- 0.01.
;;;9      * For bettery accuracy, lookup tables should be regenerated with u16.
;;;10     *
;;;11     **/
;;;12     #ifndef _TRIG_FAST_H
;;;13     #define _TRIG_FAST_H
;;;14     
;;;15     // When USE_SMALL_LUT defined, a smaller lookup table is used to conserve space.
;;;16     // USE_INTERPOLATION is also automatically defined, since without it answers are probably too wrong to be useful.
;;;17     // If USE_SMALL_LUT is not defined, a large LUT is used.
;;;18     //#define USE_SMALL_LUT
;;;19     
;;;20     // When defined, interpolates between lookup values for higher accuracy.
;;;21     #define USE_INTERPOLATION
;;;22     
;;;23     // Arctangent function based on lookup table
;;;24     // returns answer in radians
;;;25     float atan_fast(float x);
;;;26     
;;;27     // Arcsine function based on lookup table
;;;28     // returns answer in radians
;;;29     float asin_fast(float x);
;;;30     
;;;31     // Arctangent function which uses atan_fast
;;;32     // returns answer in radians
;;;33     float atan2_fast(float y, float x);
;;;34     
;;;35     // Arctangent function which uses asin from math.h
;;;36     // Useful on embedded systems that don't include atan2 in math.h
;;;37     // More accurate than atan2_fast.
;;;38     // Nothing particularly fast about this implementation.
;;;39     // returns answer in radians
;;;40     float atan2_acc(float y, float x);
;;;41     
;;;42     #endif
;;;19     
;;;20     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;21     #include "opencv2/core/core.hpp"
;;;22     #endif
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         //template<typename Type> inline Type RoundUp(const Type number, const Type multiple)
;;;29     
;;;30         // void* and size_t is a special case, good for aligning pointers
;;;31         inline const void* RoundUp(const void* number, const size_t multiple)
;;;32         {
;;;33           const size_t numberT = reinterpret_cast<size_t>(number);
;;;34           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;35         }
;;;36     
;;;37         inline void* RoundUp(void* number, const size_t multiple)
;;;38         {
;;;39           const size_t numberT = reinterpret_cast<size_t>(number);
;;;40           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;41         }
;;;42     
;;;43         template<> inline u32 RoundUp(const u32 number, const u32 multiple)
;;;44         {
;;;45           return (number + (multiple-1)) & ~(multiple-1);
;;;46         }
;;;47     
;;;48         template<> inline s32 RoundUp(const s32 number, const s32 multiple)
;;;49         {
;;;50           if(number <= 0) {
;;;51             return multiple*( number/multiple );
;;;52           } else {
;;;53             return multiple*( (number-1)/multiple + 1 );
;;;54           }
;;;55         }
;;;56     
;;;57     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;58         template<> inline unsigned long RoundUp(const unsigned long number, const unsigned long multiple)
;;;59         {
;;;60           return (number + (multiple-1)) & ~(multiple-1);
;;;61         }
;;;62     #endif
;;;63     
;;;64         template<> inline u32 RoundDown(const u32 number, const u32 multiple)
;;;65         {
;;;66           return multiple * (number/multiple);
;;;67         }
;;;68     
;;;69         template<> inline s32 RoundDown(const s32 number, const s32 multiple)
;;;70         {
;;;71           if(number < 0) {
;;;72             return multiple * ((number-multiple+1) / multiple);
;;;73           } else {
;;;74             return multiple * (number/multiple);
;;;75           }
;;;76         }
;;;77     
;;;78     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;79         template<> inline unsigned long RoundDown(const unsigned long number, const unsigned long multiple)
;;;80         {
;;;81           return multiple * (number/multiple);
;;;82         }
;;;83     #endif
;;;84     
;;;85         template<typename Type> Type ApproximateExp(const Type exponent, const s32 numTerms)
;;;86         {
;;;87           AnkiAssert(numTerms > 2);
;;;88     
;;;89           const Type exponentAbs = ABS(exponent);
;;;90     
;;;91           Type sum = static_cast<Type>(1) + exponentAbs;
;;;92     
;;;93           Type numerator = static_cast<Type>(exponentAbs);
;;;94           Type denominator = static_cast<Type>(1);
;;;95           for(s32 i=2; i<=numTerms; i++) {
;;;96             numerator *= exponentAbs;
;;;97             denominator *= i;
;;;98     
;;;99             sum += numerator / denominator;
;;;100          }
;;;101    
;;;102          if(exponent < 0) {
;;;103            sum = static_cast<Type>(1) / sum;
;;;104          }
;;;105    
;;;106          return sum;
;;;107        }
;;;108    
;;;109        template<typename Type> void Swap(Type &a, Type &b)
;;;110        {
;;;111          const Type tmp = a;
;;;112          a = b;
;;;113          b = tmp;
;;;114        } // template<typename Type> Swap(Type a, Type b)
;;;115    
;;;116        template<typename Type> u32 BinaryStringToUnsignedNumber(const FixedLengthList<Type> &bits, bool firstBitIsLow)
;;;117        {
;;;118          u32 number = 0;
;;;119    
;;;120          const s32 numBits = bits.get_size();
;;;121    
;;;122          for(s32 bit=0; bit<numBits; bit++) {
;;;123            if(firstBitIsLow) {
;;;124              if(bit == 0) {
;;;125                number += bits[bit];
;;;126              } else {
;;;127                number += bits[bit] << bit;
;;;128              }
;;;129            } else {
;;;130              if(bit == (numBits-1)) {
;;;131                number += bits[bit];
;;;132              } else {
;;;133                number += bits[bit] << (numBits - bit - 1);
;;;134              }
;;;135            }
;;;136          }
;;;137    
;;;138          return number;
;;;139        }
;;;140    
;;;141        template<typename Type> Type Determinant2x2(const Type a, const Type b, const Type c, const Type d)
;;;142        {
;;;143          return a*d - b*c;
;;;144        }
;;;145    
;;;146        template<typename Type> Type Determinant3x3(const Type a, const Type b, const Type c, const Type d, const Type e, const Type f, const Type g, const Type h, const Type i)
;;;147        {
;;;148          return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
;;;149        }
;;;150    
;;;151        template<typename Type> void Invert3x3(Type &a, Type &b, Type &c, Type &d, Type &e, Type &f, Type &g, Type &h, Type &i)
;;;152        {
;;;153          const Type determinant = Determinant3x3(a,b,c,d,e,f,g,h,i);
;;;154          const Type determinantInverse = static_cast<Type>(1) / determinant;
;;;155    
;;;156          const Type A =  (e*i - f*h);
;;;157          const Type B = -(d*i - f*g);
;;;158          const Type C =  (d*h - e*g);
;;;159          const Type D = -(b*i - c*h);
;;;160          const Type E =  (a*i - c*g);
;;;161          const Type F = -(a*h - b*g);
;;;162          const Type G =  (b*f - c*e);
;;;163          const Type H = -(a*f - c*d);
;;;164          const Type I =  (a*e - b*d);
;;;165    
;;;166          a = A * determinantInverse;
;;;167          b = D * determinantInverse;
;;;168          c = G * determinantInverse;
;;;169          d = B * determinantInverse;
;;;170          e = E * determinantInverse;
;;;171          f = H * determinantInverse;
;;;172          g = C * determinantInverse;
;;;173          h = F * determinantInverse;
;;;174          i = I * determinantInverse;
;;;175        }
;;;176    
;;;177        template<typename Type> void Cart2Pol(const Type x, const Type y, Type &rho, Type &theta)
;;;178        {
;;;179          if (x==0 && y==0) {
;;;180            theta = 0;
;;;181            rho = 0;
;;;182          } else {
;;;183            theta = atan2f(y, x);
;;;184            rho = sqrtf(x*x + y*y);
;;;185          }
;;;186        }
;;;187    
;;;188        template<typename Type> void Pol2Cart(const Type rho, const Type theta, Type &x, Type &y)
;;;189        {
;;;190          x = rho * cosf(theta);
;;;191          y = rho * sinf(theta);
;;;192        }
;;;193    
;;;194        inline s32 FloorS32(f32 x)
;;;195        {
;;;196          return static_cast<s32>(floorf(x));
;;;197        }
;;;198    
;;;199        inline s32 CeilS32(f32 x)
;;;200        {
;;;201          return static_cast<s32>(ceilf(x));
;;;202        }
;;;203    
;;;204    #if !defined(__EDG__)
;;;205        // Some platforms may not round to zero correctly, so do the function calls
;;;206        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(floorf(v + 0.5f)) : 0; }
;;;207        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(floorf(v + 0.5f)) : 0; }
;;;208        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(floorf(v + 0.5f)) : static_cast<s32>(ceilf(v - 0.5f)); }
;;;209        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(floorf(v + 0.5f)) : static_cast<s64>(ceilf(v - 0.5f)); }
;;;210        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;211        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;212    
;;;213        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(floor(v + 0.5)) : 0; }
;;;214        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(floor(v + 0.5)) : 0; }
;;;215        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(floor(v + 0.5)) : static_cast<s32>(ceil(v - 0.5)); }
;;;216        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(floor(v + 0.5)) : static_cast<s64>(ceil(v - 0.5)); }
;;;217        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;218        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;219    #else
;;;220        // The M4 rounds to zero correctly, without the function calls
;;;221        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(v + 0.5f) : 0; }
;;;222        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(v + 0.5f) : 0; }
;;;223        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(v + 0.5f) : static_cast<s32>(v - 0.5f); }
;;;224        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(v + 0.5f) : static_cast<s64>(v - 0.5f); }
;;;225        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;226        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;227    
;;;228        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(v + 0.5) : 0; }
;;;229        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(v + 0.5) : 0; }
;;;230        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(v + 0.5) : static_cast<s32>(v - 0.5); }
;;;231        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(v + 0.5) : static_cast<s64>(v - 0.5); }
;;;232        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;233        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;234    #endif
;;;235    
;;;236        // Most cases of RoundIfInteger are from int-to-int or float-to-float, so just do a normal cast
;;;237        template<typename Type> inline Type RoundIfInteger(const u8  v) { return static_cast<Type>(v); }
;;;238        template<typename Type> inline Type RoundIfInteger(const s8  v) { return static_cast<Type>(v); }
;;;239        template<typename Type> inline Type RoundIfInteger(const u16 v) { return static_cast<Type>(v); }
;;;240        template<typename Type> inline Type RoundIfInteger(const s16 v) { return static_cast<Type>(v); }
;;;241        template<typename Type> inline Type RoundIfInteger(const u32 v) { return static_cast<Type>(v); }
;;;242        template<typename Type> inline Type RoundIfInteger(const s32 v) { return static_cast<Type>(v); }
;;;243        template<typename Type> inline Type RoundIfInteger(const u64 v) { return static_cast<Type>(v); }
;;;244        template<typename Type> inline Type RoundIfInteger(const s64 v) { return static_cast<Type>(v); }
;;;245        template<typename Type> inline Type RoundIfInteger(const f32 v) { return static_cast<Type>(v); }
;;;246        template<typename Type> inline Type RoundIfInteger(const f64 v) { return static_cast<Type>(v); }
;;;247    
;;;248        // Specialize for cases with float-to-int
;;;249        template<> inline u8  RoundIfInteger(const f32 v) { return static_cast<u8> (Round<s32>(v)); }
;;;250        template<> inline s8  RoundIfInteger(const f32 v) { return static_cast<s8> (Round<s32>(v)); }
;;;251        template<> inline u16 RoundIfInteger(const f32 v) { return static_cast<u16>(Round<s32>(v)); }
;;;252        template<> inline s16 RoundIfInteger(const f32 v) { return static_cast<s16>(Round<s32>(v)); }
;;;253        template<> inline u32 RoundIfInteger(const f32 v) { return static_cast<u32>(Round<u32>(v)); }
;;;254        template<> inline s32 RoundIfInteger(const f32 v) { return static_cast<s32>(Round<s32>(v)); }
;;;255        template<> inline u64 RoundIfInteger(const f32 v) { return static_cast<u64>(Round<u64>(v)); }
;;;256        template<> inline s64 RoundIfInteger(const f32 v) { return static_cast<s64>(Round<s64>(v)); }
;;;257    
;;;258        template<> inline u8  RoundIfInteger(const f64 v) { return static_cast<u8> (Round<s32>(v)); }
;;;259        template<> inline s8  RoundIfInteger(const f64 v) { return static_cast<s8> (Round<s32>(v)); }
;;;260        template<> inline u16 RoundIfInteger(const f64 v) { return static_cast<u16>(Round<s32>(v)); }
;;;261        template<> inline s16 RoundIfInteger(const f64 v) { return static_cast<s16>(Round<s32>(v)); }
;;;262        template<> inline u32 RoundIfInteger(const f64 v) { return static_cast<u32>(Round<u32>(v)); }
;;;263        template<> inline s32 RoundIfInteger(const f64 v) { return static_cast<s32>(Round<s32>(v)); }
;;;264        template<> inline u64 RoundIfInteger(const f64 v) { return static_cast<u64>(Round<u64>(v)); }
;;;265        template<> inline s64 RoundIfInteger(const f64 v) { return static_cast<s64>(Round<s64>(v)); }
;;;266    
;;;267        // Floats and complex data types aren't specialized
;;;268        template<typename Type> inline Type saturate_cast(const u8  v) { return static_cast<Type>(v); }
;;;269        template<typename Type> inline Type saturate_cast(const s8  v) { return static_cast<Type>(v); }
;;;270        template<typename Type> inline Type saturate_cast(const u16 v) { return static_cast<Type>(v); }
;;;271        template<typename Type> inline Type saturate_cast(const s16 v) { return static_cast<Type>(v); }
;;;272        template<typename Type> inline Type saturate_cast(const u32 v) { return static_cast<Type>(v); }
;;;273        template<typename Type> inline Type saturate_cast(const s32 v) { return static_cast<Type>(v); }
;;;274        template<typename Type> inline Type saturate_cast(const u64 v) { return static_cast<Type>(v); }
;;;275        template<typename Type> inline Type saturate_cast(const s64 v) { return static_cast<Type>(v); }
;;;276        template<typename Type> inline Type saturate_cast(const f32 v) { return static_cast<Type>(v); }
;;;277        template<typename Type> inline Type saturate_cast(const f64 v) { return static_cast<Type>(v); }
;;;278    
;;;279        // Most saturate_cast calls are explicitly specialized
;;;280        template<> inline u8  saturate_cast<u8> (const u8  v) { return v; }
;;;281        template<> inline u8  saturate_cast<u8> (const u16 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;282        template<> inline u8  saturate_cast<u8> (const u32 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;283        template<> inline u8  saturate_cast<u8> (const u64 v) { return (u8)             MIN((u64)u8_MAX, (u64)v); }
;;;284        template<> inline u8  saturate_cast<u8> (const s8  v) { return (u8)                              MAX((s32)0, (s32)v);  }
;;;285        template<> inline u8  saturate_cast<u8> (const s16 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;286        template<> inline u8  saturate_cast<u8> (const s32 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;287        template<> inline u8  saturate_cast<u8> (const s64 v) { return (u8)             MIN((s64)u8_MAX, MAX((s64)0, (s64)v)); }
;;;288        template<> inline u8  saturate_cast<u8> (const f32 v) { return (u8) Round<s32>( MIN((f32)u8_MAX, MAX((f32)0, (f32)v)) ); }
;;;289        template<> inline u8  saturate_cast<u8> (const f64 v) { return (u8) Round<s32>( MIN((f64)u8_MAX, MAX((f64)0, (f64)v)) ); }
;;;290    
;;;291        template<> inline s8  saturate_cast<s8> (const u8  v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;292        template<> inline s8  saturate_cast<s8> (const u16 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;293        template<> inline s8  saturate_cast<s8> (const u32 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;294        template<> inline s8  saturate_cast<s8> (const u64 v) { return (s8)             MIN((u64)s8_MAX, (u64)v); }
;;;295        template<> inline s8  saturate_cast<s8> (const s8  v) { return v; }
;;;296        template<> inline s8  saturate_cast<s8> (const s16 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;297        template<> inline s8  saturate_cast<s8> (const s32 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;298        template<> inline s8  saturate_cast<s8> (const s64 v) { return (s8)             MIN((s64)s8_MAX, MAX((s64)s8_MIN, (s64)v)); }
;;;299        template<> inline s8  saturate_cast<s8> (const f32 v) { return (s8) Round<s32>( MIN((f32)s8_MAX, MAX((f32)s8_MIN, (f32)v)) ); }
;;;300        template<> inline s8  saturate_cast<s8> (const f64 v) { return (s8) Round<s32>( MIN((f64)s8_MAX, MAX((f64)s8_MIN, (f64)v)) ); }
;;;301    
;;;302        template<> inline u16 saturate_cast<u16>(const u8  v) { return v; }
;;;303        template<> inline u16 saturate_cast<u16>(const u16 v) { return v; }
;;;304        template<> inline u16 saturate_cast<u16>(const u32 v) { return (u16)             MIN((u32)u16_MAX, (u32)v); }
;;;305        template<> inline u16 saturate_cast<u16>(const u64 v) { return (u16)             MIN((u64)u16_MAX, (u64)v); }
;;;306        template<> inline u16 saturate_cast<u16>(const s8  v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;307        template<> inline u16 saturate_cast<u16>(const s16 v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;308        template<> inline u16 saturate_cast<u16>(const s32 v) { return (u16)             MIN((s32)u16_MAX, MAX((s32)0, (s32)v)); }
;;;309        template<> inline u16 saturate_cast<u16>(const s64 v) { return (u16)             MIN((s64)u16_MAX, MAX((s64)0, (s64)v)); }
;;;310        template<> inline u16 saturate_cast<u16>(const f32 v) { return (u16) Round<s32>( MIN((f32)u16_MAX, MAX((f32)0, (f32)v)) ); }
;;;311        template<> inline u16 saturate_cast<u16>(const f64 v) { return (u16) Round<s32>( MIN((f64)u16_MAX, MAX((f64)0, (f64)v)) ); }
;;;312    
;;;313        template<> inline s16 saturate_cast<s16>(const u8  v) { return v; }
;;;314        template<> inline s16 saturate_cast<s16>(const u16 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;315        template<> inline s16 saturate_cast<s16>(const u32 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;316        template<> inline s16 saturate_cast<s16>(const u64 v) { return (s16)             MIN((u64)s16_MAX, (u64)v); }
;;;317        template<> inline s16 saturate_cast<s16>(const s8  v) { return v; }
;;;318        template<> inline s16 saturate_cast<s16>(const s16 v) { return v; }
;;;319        template<> inline s16 saturate_cast<s16>(const s32 v) { return (s16)             MIN((s32)s16_MAX, MAX((s32)s16_MIN, (s32)v)); }
;;;320        template<> inline s16 saturate_cast<s16>(const s64 v) { return (s16)             MIN((s64)s16_MAX, MAX((s64)s16_MIN, (s64)v)); }
;;;321        template<> inline s16 saturate_cast<s16>(const f32 v) { return (s16) Round<s32>( MIN((f32)s16_MAX, MAX((f32)s16_MIN, (f32)v)) ); }
;;;322        template<> inline s16 saturate_cast<s16>(const f64 v) { return (s16) Round<s32>( MIN((f64)s16_MAX, MAX((f64)s16_MIN, (f64)v)) ); }
;;;323    
;;;324        template<> inline u32 saturate_cast<u32>(const u8  v) { return v; }
;;;325        template<> inline u32 saturate_cast<u32>(const u16 v) { return v; }
;;;326        template<> inline u32 saturate_cast<u32>(const u32 v) { return v; }
;;;327        template<> inline u32 saturate_cast<u32>(const u64 v) { return (u32)             MIN((u64)u32_MAX, (u64)v); }
;;;328        template<> inline u32 saturate_cast<u32>(const s8  v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;329        template<> inline u32 saturate_cast<u32>(const s16 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;330        template<> inline u32 saturate_cast<u32>(const s32 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;331        template<> inline u32 saturate_cast<u32>(const s64 v) { return (u32)             MIN((s64)u32_MAX, MAX((s64)0, (s64)v)); }
;;;332        template<> inline u32 saturate_cast<u32>(const f32 v) { return (u32) (v > (f32)0xFFFFFF7F) ? 0xFFFFFFFF : Round<u32>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;333        template<> inline u32 saturate_cast<u32>(const f64 v) { return (u32) Round<u32>( MIN((f64)u32_MAX, MAX((f64)0, (f64)v)) ); }
;;;334    
;;;335        template<> inline s32 saturate_cast<s32>(const u8  v) { return v; }
;;;336        template<> inline s32 saturate_cast<s32>(const u16 v) { return v; }
;;;337        template<> inline s32 saturate_cast<s32>(const u32 v) { return (s32)             MIN((u32)s32_MAX, (u32)v); }
;;;338        template<> inline s32 saturate_cast<s32>(const u64 v) { return (s32)             MIN((u64)s32_MAX, (u64)v); }
;;;339        template<> inline s32 saturate_cast<s32>(const s8  v) { return v; }
;;;340        template<> inline s32 saturate_cast<s32>(const s16 v) { return v; }
;;;341        template<> inline s32 saturate_cast<s32>(const s32 v) { return v; }
;;;342        template<> inline s32 saturate_cast<s32>(const s64 v) { return (s32)             MIN((s64)s32_MAX, MAX((s64)s32_MIN, (s64)v)); }
;;;343        template<> inline s32 saturate_cast<s32>(const f32 v) { return (s32) (v > (f32)0x7FFFFFBF) ? 0x7FFFFFFF : Round<s32>(MAX((f32)s32_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;344        template<> inline s32 saturate_cast<s32>(const f64 v) { return (s32) Round<s32>( MIN((f64)s32_MAX, MAX((f64)s32_MIN, (f64)v)) ); }
;;;345    
;;;346        template<> inline u64 saturate_cast<u64>(const u8  v) { return v; }
;;;347        template<> inline u64 saturate_cast<u64>(const u16 v) { return v; }
;;;348        template<> inline u64 saturate_cast<u64>(const u32 v) { return v; }
;;;349        template<> inline u64 saturate_cast<u64>(const u64 v) { return v; }
;;;350        template<> inline u64 saturate_cast<u64>(const s8  v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;351        template<> inline u64 saturate_cast<u64>(const s16 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;352        template<> inline u64 saturate_cast<u64>(const s32 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;353        template<> inline u64 saturate_cast<u64>(const s64 v) { return (u64)                               MAX((s64)0, (s64)v);  }
;;;354        template<> inline u64 saturate_cast<u64>(const f32 v) { return (u64) (v > (f32)0XFFFFFF7FFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;355        template<> inline u64 saturate_cast<u64>(const f64 v) { return (u64) (v > (f64)0xFFFFFFFFFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f64)0, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;356    
;;;357        template<> inline s64 saturate_cast<s64>(const u8  v) { return v; }
;;;358        template<> inline s64 saturate_cast<s64>(const u16 v) { return v; }
;;;359        template<> inline s64 saturate_cast<s64>(const u32 v) { return v; }
;;;360        template<> inline s64 saturate_cast<s64>(const u64 v) { return (s64)             MIN((u64)s64_MAX, (u64)v); }
;;;361        template<> inline s64 saturate_cast<s64>(const s8  v) { return v; }
;;;362        template<> inline s64 saturate_cast<s64>(const s16 v) { return v; }
;;;363        template<> inline s64 saturate_cast<s64>(const s32 v) { return v; }
;;;364        template<> inline s64 saturate_cast<s64>(const s64 v) { return v; }
;;;365        template<> inline s64 saturate_cast<s64>(const f32 v) { return (s64) (v > (f32)0x7FFFFFBFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f32)s64_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;366        template<> inline s64 saturate_cast<s64>(const f64 v) { return (s64) (v > (f64)0x7FFFFFFFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f64)s64_MIN, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;367    
;;;368        template<> inline f32 saturate_cast(const f64 v) { return (f32) MIN((f64)FLT_MAX, MAX(-(f64)FLT_MAX, (f64)v)); }
;;;369      } // namespace Embedded
;;;370    } // namespace Anki
;;;371    
;;;372    #endif // _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;18     #include "anki/common/robot/memory.h"
;;;1      /**
;;;19     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;20     #include "anki/common/robot/geometry.h"
;;;1      /**
;;;2      File: geometry.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of geometry_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/geometry_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/memory.h"
;;;1      /**
;;;18     #include "anki/common/robot/matrix.h"
;;;1      /**
;;;2      File: matrix.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of matrix_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;14     
;;;15     #include "anki/common/robot/matrix_declarations.h"
;;;1      /**
;;;2      File: matrix_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various Matrix operations, such as matrix multiply and addition.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         namespace Matrix
;;;24         {
;;;25           // #pragma mark --- Declarations ---
;;;26     
;;;27           //
;;;28           // Simple matrix statistics
;;;29           //
;;;30     
;;;31           // Return the minimum element in this Array
;;;32           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat);
;;;33     
;;;34           // Return the maximum element in this Array
;;;35           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat);
;;;36     
;;;37           // Return the sum of every element in the Array
;;;38           template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat);
;;;39     
;;;40           // Return the mean of every element in the Array
;;;41           template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat);
;;;42     
;;;43           // Simultaneously compute the mean and variance of every element in the Array
;;;44           template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(const ConstArraySliceExpression<Array_Type> &mat,
;;;45             Accumulator_Type& mean, Accumulator_Type& var);
;;;46     
;;;47           //
;;;48           // Elementwise matrix operations
;;;49           //
;;;50     
;;;51           // Elementwise add two arrays. in1, in2, and out can be the same array
;;;52           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;53           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;54           template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;55     
;;;56           // Elementwise subtract two arrays. in1, in2, and out can be the same array
;;;57           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;58           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;59           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;60     
;;;61           // Elementwise multiply two arrays. in1, in2, and out can be the same array
;;;62           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;63           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;64           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;65     
;;;66           // Elementwise divide two arrays. in1, in2, and out can be the same array
;;;67           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;68           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;69           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;70     
;;;71           // Sum of absolute difference (SAD)
;;;72           template<typename InType, typename IntermediateType, typename OutType> Result SumOfAbsDiff(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;73           template<typename InType, typename IntermediateType, typename OutType> Result SumOfAbsDiff(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;74           template<typename InType, typename IntermediateType, typename OutType> Result SumOfAbsDiff(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;75     
;;;76           // Elementwise exponential on an array
;;;77           template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;78     
;;;79           // Elementwise square root on an array
;;;80           template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;81     
;;;82           //
;;;83           // Standard matrix operations
;;;84           //
;;;85     
;;;86           // Perform the matrix multiplication "out = in1 * in2"
;;;87           // Note that this is the naive O(n^3) Definition
;;;88           template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out);
;;;89     
;;;90           // Perform the matrix multiplication "out = in1 * in2'"
;;;91           // Note that this is the naive O(n^3) Definition
;;;92           // MultiplyTranspose has better access patterns than Multiply for certain types of arrays, so could be a lot faster (and easier to accelerate)
;;;93           template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out);
;;;94     
;;;95           //
;;;96           // Rotation Matrices
;;;97           //
;;;98     
;;;99           // TODO: Add other rotation-related math, like Rodrigues' formula, or Pose chaining...
;;;100    
;;;101          // Compute the three Euler angles from a given 3x3 Rotation Matrix.
;;;102          Result GetEulerAngles(const Array<f32>& R, f32& angle_x, f32& angle_y, f32& angle_z);
;;;103    
;;;104          //
;;;105          // Linear Algebra and Linear Solvers
;;;106          //
;;;107    
;;;108          // Compute the Cholesky-Banachiewicz decomposition, to return a lower-triangular matrix L such that A=L*L'
;;;109          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;110            Array<Type> &A_L,      //!< Input A Matrix and Output lower-triangular L matrix
;;;111            Array<Type> &Bt_Xt,    //!< Input B-transpose matrix and Output X-transpose solution
;;;112            bool realCholesky,     //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;113            bool &numericalFailure //!< If true, the solver failed because of numerical instability
;;;114            );
;;;115    
;;;116          // Compute the homography such that "transformedPoints = homography * originalPoints"
;;;117          //
;;;118          // WARNING: This uses the inhomogeneous solution and the Cholesky decomposition, therefore it
;;;119          //          will be incorrect if H_33 is zero, which happens in certain cases of lines at
;;;120          //          inifinty. For more details, see Multiple View Geometry 2nd Edition, Example 4.1
;;;121          template<typename Type> Result EstimateHomography(
;;;122            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;123            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;124            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;125            bool &numericalFailure, //!< Did the homography solver fail?
;;;126            MemoryStack scratch //!< Scratch memory
;;;127            );
;;;128    
;;;129          //template<typename InType, typename IntermediateType, typename OutType> Result CholeskyDecomposition(
;;;130          //  const Array<InType> &A,                    //!< Input A Matrix
;;;131          //  Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;132          //  Array<OutType> &L                          //!< Output lower-triangular L matrix
;;;133          //  );
;;;134    
;;;135          //template<typename InType, typename IntermediateType, typename OutType> Result SolveWithLowerTriangular(
;;;136          //  const Array<InType> &L,                          //!< Input lower-triangular L matrix (such as computed by CholeskyDecomposition)
;;;137          //  const Array<InType> &b,                          //!< Input b matrix
;;;138          //  const Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;139          //  Array<OutType> &x                                //!< Output x solution
;;;140          //  );
;;;141    
;;;142          // Solves Ax = b
;;;143          // Specifically, it uses SVD to minimize ||Ax - b||
;;;144          // Note that the A, b, and x matrices are transposed (this is because for large numbers of samples, transposed inputs are liable to be faster)
;;;145          //Result SolveLeastSquaresWithSVD_f32(Array<f32> &At, const Array<f32> &bt, Array<f32> &xt, MemoryStack scratch);
;;;146          //Result SolveLeastSquaresWithSVD_f64(Array<f64> &At, const Array<f64> &bt, Array<f64> &xt, MemoryStack scratch);
;;;147    
;;;148          //
;;;149          // Matrix structure operations
;;;150          //
;;;151    
;;;152          // matlab equivalent: out = reshape(in, [M,N]);
;;;153          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;154          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory);
;;;155    
;;;156          // matlab equivalent: out = in(:);
;;;157          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;158          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory);
;;;159    
;;;160          // Perform an immediate matrix transpose (unlike the lazy transpose of ArraySlice)
;;;161          // in and out must be different Array objects
;;;162          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out);
;;;163    
;;;164          // Rotate an array clockwise by 90, 180, or 270 degrees.
;;;165          // NOTE: Only works for a square matrix.
;;;166          // NOTE: In and out must be different arrays (unlike the interview question)
;;;167          template<typename InType, typename OutType> Result Rotate90( const Array<InType> &in, Array<OutType> &out);
;;;168          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out);
;;;169          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out);
;;;170    
;;;171          //
;;;172          // Misc matrix operations
;;;173          //
;;;174    
;;;175          // Works the same as the Matlab sort() for matrices.
;;;176          // InsertionSort(X) sorts each column of X in ascending order.
;;;177          // The minIndex and maxIndex are for the sortWhichDimension. maxIndex is automatically clipped to the size of the input Array.
;;;178          // NOTE: this currently uses insertion sort, so may be slow for large, badly-unsorted arrays
;;;179          template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;180    
;;;181          // Subsections less-than-or-equal-to insertionSortSize are sorted with insertion sort
;;;182          template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;183    
;;;184          // indexes must be allocated, but will be overwritten by InsertionSort()
;;;185          template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;186    
;;;187          template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;188    
;;;189          // For a square array, either:
;;;190          // 1. When lowerToUpper==true,  copies the lower (left)  triangle to the upper (right) triangle
;;;191          // 2. When lowerToUpper==false, copies the upper (right) triangle to the lower (left)  triangle
;;;192          // Functionally the same as OpenCV completeSymm()
;;;193          template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper = false);
;;;194    
;;;195          // There's probably no need to use these directly. Instead, use the normal Matrix:: operations, like Matrix::Add
;;;196          namespace Elementwise
;;;197          {
;;;198            template<typename InType, typename IntermediateType, typename OutType> class Add {
;;;199            public:
;;;200              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) + static_cast<IntermediateType>(value2));}
;;;201            };
;;;202    
;;;203            template<typename InType, typename IntermediateType, typename OutType> class Subtract {
;;;204            public:
;;;205              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) - static_cast<IntermediateType>(value2));}
;;;206            };
;;;207    
;;;208            template<typename InType, typename IntermediateType, typename OutType> class DotMultiply {
;;;209            public:
;;;210              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) * static_cast<IntermediateType>(value2));}
;;;211            };
;;;212    
;;;213            template<typename InType, typename IntermediateType, typename OutType> class DotDivide {
;;;214            public:
;;;215              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) / static_cast<IntermediateType>(value2));}
;;;216            };
;;;217    
;;;218            // Technically a unary operator, but we ignore the second parameter
;;;219            // TODO: if this is slow, make a unary version of ApplyOperation
;;;220            template<typename InType, typename IntermediateType, typename OutType> class Exp {
;;;221            public:
;;;222              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(expf(static_cast<IntermediateType>(value1)));}
;;;223            };
;;;224    
;;;225            template<typename InType, typename IntermediateType, typename OutType> class Sqrt {
;;;226            public:
;;;227              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(sqrtf(static_cast<IntermediateType>(value1)));}
;;;228            };
;;;229    
;;;230            template<typename InType, typename IntermediateType, typename OutType> class SumOfAbsDiff {
;;;231            public:
;;;232              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(ABS(static_cast<IntermediateType>(value1) - static_cast<IntermediateType>(value2)));}
;;;233            };
;;;234    
;;;235            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;236            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;237            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;238          } // namespace Elementwise
;;;239        } // namespace Matrix
;;;240      } // namespace Embedded
;;;241    } // namespace Anki
;;;242    
;;;243    #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;18     #include "anki/common/robot/memory.h"
;;;19     #include "anki/common/robot/errorHandling.h"
;;;20     #include "anki/common/robot/geometry.h"
;;;21     #include "anki/common/robot/utilities_c.h"
;;;22     #include "anki/common/robot/sequences.h"
;;;23     #include "anki/common/robot/matrix.h"
;;;24     #include "anki/common/robot/comparisons.h"
;;;25     
;;;26     #include "anki/common/shared/utilities_shared.h"
;;;27     
;;;28     #include "anki/common/robot/serialize_declarations.h"
;;;29     
;;;30     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;31     #include "opencv2/core/core.hpp"
;;;32     #include "opencv2/highgui/highgui.hpp"
;;;33     #include "opencv2/imgproc/imgproc.hpp"
;;;34     #include "opencv2/objdetect/objdetect.hpp"
;;;35     #endif
;;;36     
;;;37     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;38     #define ANKICORETECH_EMBEDDED_USE_MALLOC 1
;;;39     #define ANKICORETECH_EMBEDDED_USE_ZLIB 1
;;;40     #endif
;;;41     
;;;42     #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;43     #include "zlib.h"
;;;44     #endif
;;;45     
;;;46     namespace Anki
;;;47     {
;;;48       namespace Embedded
;;;49       {
;;;50         template<typename Type> class ArraySlice;
;;;51         template<typename Type> class ConstArraySlice;
;;;52         template<typename Type> class ConstArraySliceExpression;
;;;53     
;;;54         // #pragma mark --- Array Definitions ---
;;;55     
;;;56         template<typename Type> s32 Array<Type>::ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags)
;;;57         {
;;;58           AnkiConditionalErrorAndReturnValue(numCols >= 0,
;;;59             0, "Array<Type>::ComputeRequiredStride", "Invalid size");
;;;60     
;;;61           const s32 numColsCapped = MAX(numCols, 1);
;;;62     
;;;63           const s32 bufferRequired = static_cast<s32>(RoundUp<size_t>(sizeof(Type)*numColsCapped, MEMORY_ALIGNMENT));
;;;64     
;;;65           return bufferRequired;
;;;66         }
;;;67     
;;;68         template<typename Type> s32 Array<Type>::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags)
;;;69         {
;;;70           AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0,
;;;71             0, "Array<Type>::ComputeMinimumRequiredMemory", "Invalid size");
;;;72     
;;;73           const s32 numRowsCapped = MAX(numRows, 1);
;;;74     
;;;75           return numRowsCapped * Array<Type>::ComputeRequiredStride(numCols, flags);
;;;76         }
;;;77     
;;;78         template<typename Type> Array<Type>::Array()
;;;79         {
;;;80           InvalidateArray();
;;;81         }
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
;;;139        template<typename Type> Array<Type> Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;140        {
;;;141          Array<Type> newArray = Array<Type>();
;;;142    
;;;143    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;144          const cv::Mat cvImage = cv::imread(filename, CV_LOAD_IMAGE_GRAYSCALE);
;;;145    
;;;146          AnkiConditionalErrorAndReturnValue(cvImage.cols > 0 && cvImage.rows > 0,
;;;147            newArray, "Array<Type>::LoadImage", "Could not load image");
;;;148    
;;;149          newArray = Array<Type>(cvImage.rows, cvImage.cols, memory);
;;;150    
;;;151          AnkiConditionalErrorAndReturnValue(newArray.IsValid(),
;;;152            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;153    
;;;154          const u8 * restrict pCvImage = cvImage.data;
;;;155    
;;;156          for(s32 y=0; y<cvImage.rows; y++) {
;;;157            Type * restrict pNewArray = newArray.Pointer(y, 0);
;;;158    
;;;159            for(s32 x=0; x<cvImage.cols; x++) {
;;;160              pNewArray[x] = static_cast<Type>(pCvImage[x]);
;;;161            }
;;;162    
;;;163            pCvImage += cvImage.step.buf[0];
;;;164          }
;;;165    #else
;;;166          AnkiError("Array<Type>::Array", "OpenCV is required to load an image from an image file");
;;;167    #endif
;;;168    
;;;169          return newArray;
;;;170        } // Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;171    
;;;172        template<typename Type> Array<Type> LoadBinaryArray_Generic(const char * filename, MemoryStack *scratch, MemoryStack *memory, void * allocatedBuffer, const s32 allocatedBufferLength)
;;;173        {
;;;174          u16  basicType_sizeOfType;
;;;175          bool basicType_isBasicType;
;;;176          bool basicType_isInteger;
;;;177          bool basicType_isSigned;
;;;178          bool basicType_isFloat;
;;;179          bool basicType_isString;
;;;180    
;;;181          Array<u8> rawArray = LoadBinaryArray_UnknownType(
;;;182            filename,
;;;183            scratch, memory,
;;;184            allocatedBuffer, allocatedBufferLength,
;;;185            basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString);
;;;186    
;;;187          // TODO: check that the types match
;;;188    
;;;189          Array<Type> newArray = *reinterpret_cast<Array<Type>*>( &rawArray );
;;;190    
;;;191          return newArray;
;;;192        } // / LoadBinaryArray_Generic()
;;;193    
;;;194        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;195        {
;;;196          return LoadBinaryArray_Generic<Type>(filename, &scratch, &memory, NULL, -1);
;;;197        } // Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;198    
;;;199        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength) //< allocatedBuffer must be freed manually
;;;200        {
;;;201          return LoadBinaryArray_Generic<Type>(filename, NULL, NULL, allocatedBuffer, allocatedBufferLength);
;;;202        } // LoadBinaryMalloc()
;;;203    
;;;204        template<typename Type> Result Array<Type>::SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const
;;;205        {
;;;206          AnkiConditionalErrorAndReturnValue(AreValid(*this, scratch) && filename,
;;;207            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::SaveBinary", "Invalid inputs");
;;;208    
;;;209          AnkiConditionalErrorAndReturnValue(compressionLevel >= 0 && compressionLevel <= 9,
;;;210            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::SaveBinary", "Invalid compression level");
;;;211    
;;;212          // If this is a string array, add the sizes of the null terminated strings (or zero otherwise)
;;;213          const s32 stringsLength = TotalArrayStringLengths<Type>(*this);
;;;214    
;;;215          const s32 serializedBufferLength = 4096 + ARRAY_FILE_HEADER_LENGTH + this->get_size(0) * this->get_stride() + stringsLength;
;;;216          void *buffer = scratch.Allocate(serializedBufferLength);
;;;217    
;;;218          AnkiConditionalErrorAndReturnValue(buffer,
;;;219            RESULT_FAIL_OUT_OF_MEMORY, "Array<Type>::SaveBinary", "Memory could not be allocated");
;;;220    
;;;221          SerializedBuffer toSave(buffer, serializedBufferLength);
;;;222    
;;;223          toSave.PushBack<Type>("Array", *this);
;;;224    
;;;225          s32 startIndex;
;;;226          u8 * bufferStart = reinterpret_cast<u8*>(toSave.get_memoryStack().get_validBufferStart(startIndex));
;;;227          const s32 validUsedBytes = toSave.get_memoryStack().get_usedBytes() - startIndex;
;;;228    
;;;229          // const s32 startDiff = static_cast<s32>( reinterpret_cast<size_t>(bufferStart) - reinterpret_cast<size_t>(toSave.get_memoryStack().get_buffer()) );
;;;230          // const s32 endDiff = toSave.get_memoryStack().get_totalBytes() - toSave.get_memoryStack().get_usedBytes();
;;;231    
;;;232          FILE *fp = fopen(filename, "wb");
;;;233    
;;;234          AnkiConditionalErrorAndReturnValue(fp,
;;;235            RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Could not open file %s", filename);
;;;236    
;;;237          if(compressionLevel > 0) {
;;;238    #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;239            char tmpTextHeader[ARRAY_FILE_HEADER_LENGTH+1];
;;;240            strncpy(tmpTextHeader, &ARRAY_FILE_HEADER[0], ARRAY_FILE_HEADER_LENGTH+1);
;;;241            snprintf(tmpTextHeader+ARRAY_FILE_HEADER_VALID_LENGTH+1, ARRAY_FILE_HEADER_LENGTH-ARRAY_FILE_HEADER_VALID_LENGTH, "z%s ", ZLIB_VERSION);
;;;242    
;;;243            const s32 originalLength = validUsedBytes + SERIALIZED_BUFFER_HEADER_LENGTH + SERIALIZED_BUFFER_FOOTER_LENGTH;
;;;244    
;;;245            uLongf compressedLength = 128 + saturate_cast<s32>(1.1 * originalLength);
;;;246    
;;;247            void * uncompressed = malloc(originalLength);
;;;248            void * compressed = malloc(compressedLength + 2*sizeof(s32));
;;;249    
;;;250            if(!uncompressed || !compressed) {
;;;251              if(uncompressed)
;;;252                free(uncompressed);
;;;253    
;;;254              if(compressed)
;;;255                free(compressed);
;;;256    
;;;257              AnkiError("Array<Type>::SaveBinary", "Out of memory");
;;;258    
;;;259              return RESULT_FAIL_OUT_OF_MEMORY;
;;;260            }
;;;261    
;;;262            // Copy the uncompressed data into one buffer
;;;263            {
;;;264              char * pUncompressed = reinterpret_cast<char*>(uncompressed);
;;;265    
;;;266              memcpy(pUncompressed, &SERIALIZED_BUFFER_HEADER[0], SERIALIZED_BUFFER_HEADER_LENGTH);
;;;267              pUncompressed += SERIALIZED_BUFFER_HEADER_LENGTH;
;;;268    
;;;269              memcpy(pUncompressed, bufferStart, validUsedBytes);
;;;270              pUncompressed += validUsedBytes;
;;;271    
;;;272              memcpy(pUncompressed, &SERIALIZED_BUFFER_FOOTER[0], SERIALIZED_BUFFER_FOOTER_LENGTH);
;;;273            }
;;;274    
;;;275            const s32 compressionResult = compress2(reinterpret_cast<Bytef*>(compressed) + 2*sizeof(s32), &compressedLength, reinterpret_cast<Bytef*>(uncompressed), originalLength, compressionLevel);
;;;276    
;;;277            if(compressionResult != Z_OK) {
;;;278              if(uncompressed)
;;;279                free(uncompressed);
;;;280    
;;;281              if(compressed)
;;;282                free(compressed);
;;;283    
;;;284              AnkiError("Array<Type>::SaveBinary", "Zlib error");
;;;285              return RESULT_FAIL_IO;
;;;286            }
;;;287    
;;;288            reinterpret_cast<s32*>(compressed)[0] = static_cast<s32>(originalLength);
;;;289            reinterpret_cast<s32*>(compressed)[1] = static_cast<s32>(compressedLength);
;;;290    
;;;291            const size_t bytesWrittenForTextHeader = fwrite(tmpTextHeader, 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;292    
;;;293            const size_t bytesWritten = fwrite(compressed, 1, compressedLength + 2*sizeof(s32), fp);
;;;294    
;;;295            if(uncompressed)
;;;296              free(uncompressed);
;;;297    
;;;298            if(compressed)
;;;299              free(compressed);
;;;300    
;;;301            AnkiConditionalErrorAndReturnValue(
;;;302              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;303              bytesWritten == (compressedLength + 2*sizeof(s32)),
;;;304              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;305    
;;;306    #else
;;;307            AnkiError("Array<Type>::SaveBinary", "Saving with compression requires zlib");
;;;308            return RESULT_FAIL;
;;;309    #endif
;;;310          } else {
;;;311            const size_t bytesWrittenForTextHeader = fwrite(&ARRAY_FILE_HEADER[0], 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;312    
;;;313            const size_t bytesWrittenForHeader = fwrite(&SERIALIZED_BUFFER_HEADER[0], 1, SERIALIZED_BUFFER_HEADER_LENGTH, fp);
;;;314    
;;;315            const size_t bytesWritten = fwrite(bufferStart, 1, validUsedBytes, fp);
;;;316    
;;;317            const size_t bytesWrittenForFooter = fwrite(&SERIALIZED_BUFFER_FOOTER[0], 1, SERIALIZED_BUFFER_FOOTER_LENGTH, fp);
;;;318    
;;;319            AnkiConditionalErrorAndReturnValue(
;;;320              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;321              bytesWrittenForHeader == SERIALIZED_BUFFER_HEADER_LENGTH &&
;;;322              bytesWritten == validUsedBytes &&
;;;323              bytesWrittenForFooter == SERIALIZED_BUFFER_FOOTER_LENGTH,
;;;324              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;325          }
;;;326    
;;;327          fclose(fp);
;;;328    
;;;329          return RESULT_OK;
;;;330        } // Array<Type>::SaveBinary(const char * filename, MemoryStack scratch)
;;;331    
;;;332        template<typename Type> const Type* Array<Type>::Pointer(const s32 index0, const s32 index1) const
;;;333        {
;;;334          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;335          AnkiAssert(this->IsValid());
;;;336    
;;;337          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride ) + index1;
;;;338        }
;;;339    
;;;340        template<typename Type> Type* Array<Type>::Pointer(const s32 index0, const s32 index1)
;;;341        {
;;;342          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;343          AnkiAssert(this->IsValid());
;;;344    
;;;345          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride ) + index1;
;;;346        }
;;;347    
;;;348        template<typename Type> inline const Type * Array<Type>::operator[](const s32 index0) const
;;;349        {
;;;350          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;351    
;;;352          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride );
;;;353        }
;;;354    
;;;355        template<typename Type> inline Type * Array<Type>::operator[](const s32 index0)
;;;356        {
;;;357          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;358    
;;;359          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride );
;;;360        }
;;;361    
;;;362        template<typename Type> const Type* Array<Type>::Pointer(const Point<s16> &point) const
;;;363        {
;;;364          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;365        }
;;;366    
;;;367        template<typename Type> Type* Array<Type>::Pointer(const Point<s16> &point)
;;;368        {
;;;369          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;370        }
;;;371    
;;;372        template<typename Type> const Type& Array<Type>::Element(const s32 elementIndex) const
;;;373        {
;;;374          const s32 index1 = elementIndex % size[1];
;;;375          const s32 index0 = (elementIndex - index1) / size[1];
;;;376    
;;;377          return *Pointer(index0, index1);
;;;378        }
;;;379    
;;;380        template<typename Type> Type& Array<Type>::Element(const s32 elementIndex)
;;;381        {
;;;382          const s32 index1 = elementIndex % size[1];
;;;383          const s32 index0 = (elementIndex - index1) / size[1];
;;;384    
;;;385          return *Pointer(index0, index1);
;;;386        }
;;;387    
;;;388        template<typename Type> ArraySlice<Type> Array<Type>::operator() ()
;;;389        {
;;;390          ArraySlice<Type> slice(*this);
;;;391    
;;;392          return slice;
;;;393        }
;;;394    
;;;395        template<typename Type> ArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;396        {
;;;397          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;398    
;;;399          return slice;
;;;400        }
;;;401    
;;;402        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX)
;;;403        {
;;;404          LinearSequence<s32> ySlice = IndexSequence<s32>(minY, 1, maxY, this->size[0]);
;;;405          LinearSequence<s32> xSlice = IndexSequence<s32>(minX, 1, maxX, this->size[1]);
;;;406    
;;;407          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;408    
;;;409          return slice;
;;;410        }
;;;411    
;;;412        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX)
;;;413        {
;;;414          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;415          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;416    
;;;417          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;418    
;;;419          return slice;
;;;420        }
;;;421    
;;;422        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() () const
;;;423        {
;;;424          ConstArraySlice<Type> slice(*this);
;;;425    
;;;426          return slice;
;;;427        }
;;;428    
;;;429        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const
;;;430        {
;;;431          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;432    
;;;433          return slice;
;;;434        }
;;;435    
;;;436        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const
;;;437        {
;;;438          LinearSequence<s32> ySlice = IndexSequence(minY, 1, maxY, this->size[0]);
;;;439          LinearSequence<s32> xSlice = IndexSequence(minX, 1, maxX, this->size[1]);
;;;440    
;;;441          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;442    
;;;443          return slice;
;;;444        }
;;;445    
;;;446        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const
;;;447        {
;;;448          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;449          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;450    
;;;451          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;452    
;;;453          return slice;
;;;454        }
;;;455    
;;;456        template<typename Type> ConstArraySliceExpression<Type> Array<Type>::Transpose() const
;;;457        {
;;;458          ConstArraySliceExpression<Type> expression(this->operator() ());
;;;459          expression.Transpose();
;;;460    
;;;461          return expression;
;;;462        }
;;;463    
;;;464    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;465        template<typename Type> s32 Array<Type>::Set(const cv::Mat_<Type> &in)
;;;466        {
;;;467          const s32 inHeight = in.rows;
;;;468          const s32 inWidth = in.cols;
;;;469    
;;;470          AnkiConditionalErrorAndReturnValue(inHeight != 0,
;;;471            0, "Array<Type>::Set", "input cv::Mat is invalid. If you use the release OpenCV libraries with the debug build, lots of things like file loading don't work.");
;;;472    
;;;473          const bool isColor = in.channels() == 3 || inWidth == this->size[1]*3;
;;;474    
;;;475          if(isColor) {
;;;476            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0],
;;;477              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;478          } else {
;;;479            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;480              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;481          }
;;;482    
;;;483          for(s32 y=0; y<this->size[0]; y++) {
;;;484            const Type * restrict pIn = reinterpret_cast<const Type*>(in.ptr(y,0));
;;;485            Type * restrict pThis = this->Pointer(y,0);
;;;486    
;;;487            // If grayscale, just copy. If color, convert to grayscale
;;;488            if(isColor) {
;;;489              for(s32 x=0; x<this->size[1]; x++) {
;;;490                pThis[x] = (pIn[3*x] + pIn[3*x + 1] + pIn[3*x + 2]) / 3;
;;;491              }
;;;492            } else {
;;;493              memcpy(pThis, pIn, inWidth*sizeof(Type));
;;;494            }
;;;495          }
;;;496    
;;;497          return this->size[0]*this->size[1];
;;;498        }
;;;499    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;500    
;;;501        template<typename Type> void Array<Type>::Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues, const bool fitImageToWindow) const
;;;502        {
;;;503    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;504          AnkiConditionalError(this->IsValid(), "Array<Type>::Show", "Array<Type> is not valid");
;;;505    
;;;506          if(fitImageToWindow) {
;;;507            cv::namedWindow(windowName, CV_WINDOW_NORMAL);
;;;508          } else {
;;;509            cv::namedWindow(windowName, CV_WINDOW_AUTOSIZE);
;;;510          }
;;;511    
;;;512          if(scaleValues) {
;;;513            cv::Mat_<f64> scaledArray;
;;;514    
;;;515            if(ArrayToCvMat(*this, &scaledArray) != RESULT_OK)
;;;516              return;
;;;517    
;;;518            const f64 minValue = Matrix::Min<Type>(*this);
;;;519            const f64 maxValue = Matrix::Max<Type>(*this);
;;;520            const f64 range = maxValue - minValue;
;;;521    
;;;522            scaledArray -= minValue;
;;;523            scaledArray /= range;
;;;524    
;;;525            cv::imshow(windowName, scaledArray);
;;;526          } else {
;;;527            cv::Mat_<Type> arrayCopy;
;;;528    
;;;529            if(ArrayToCvMat(*this, &arrayCopy) != RESULT_OK)
;;;530              return;
;;;531    
;;;532            cv::imshow(windowName, arrayCopy);
;;;533          }
;;;534    
;;;535          if(waitForKeypress) {
;;;536            cv::waitKey();
;;;537          }
;;;538    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;539        }
;;;540    
;;;541        template<typename Type> Result Array<Type>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;542        {
;;;543          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;544            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;545    
;;;546          CoreTechPrint(variableName);
;;;547          CoreTechPrint(":\n");
;;;548          for(s32 y=MAX(0,minY); y<MIN(maxY+1,size[0]); y++) {
;;;549            const Type * const pThisData = this->Pointer(y, 0);
;;;550            for(s32 x=MAX(0,minX); x<MIN(maxX+1,size[1]); x++) {
;;;551              pThisData[x].Print();
;;;552            }
;;;553            CoreTechPrint("\n");
;;;554          }
;;;555          CoreTechPrint("\n");
;;;556    
;;;557          return RESULT_OK;
;;;558        }
;;;559    
;;;560        template<typename Type> Result Array<Type>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;561        {
;;;562          return this->Print(variableName, minY, maxY, minX, maxX);
;;;563        }
;;;564    
;;;565        template<typename Type> bool Array<Type>::IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const
;;;566        {
;;;567          bool isSame = false;
;;;568          if(AreValid(*this, other)) {
;;;569            const s32 nrows = this->get_size(0);
;;;570            const s32 ncols = this->get_size(1);
;;;571    
;;;572            if(other.get_size(0)==nrows && other.get_size(1) == ncols) {
;;;573              isSame = true;
;;;574              for(s32 i=0; i<nrows && isSame; ++i) {
;;;575                const Type * restrict pThis  = this->Pointer(i,0);
;;;576                const Type * restrict pOther = other.Pointer(i,0);
;;;577    
;;;578                for(s32 j=0; j<ncols; ++j) {
;;;579                  if(!NEAR(pThis[j], pOther[j], epsilon)) {
;;;580                    isSame = false;
;;;581                    break;
;;;582                  }
;;;583                } // for j
;;;584              } // for i
;;;585            } // if sizes match
;;;586          } // if both valid
;;;587    
;;;588          return isSame;
;;;589        } // IsNearlyEqualTo()
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
;;;592        {
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
;;;602        }
;;;603    
;;;604        template<typename Type> Result Array<Type>::Resize(const s32 numRows, const s32 numCols, MemoryStack &memory)
;;;605        {
;;;606          AnkiConditionalErrorAndReturnValue(numCols > 0 && numRows > 0,
;;;607            RESULT_FAIL_INVALID_SIZE, "Array<Type>::Resize", "Invalid size");
;;;608    
;;;609          s32 numBytesAllocated = 0;
;;;610    
;;;611          this->data = reinterpret_cast<Type*>( AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, true) );
;;;612    
;;;613          // Don't clear the reallocated memory
;;;614          const bool clearMemory = this->flags.get_zeroAllocatedMemory();
;;;615          this->flags.set_zeroAllocatedMemory(false);
;;;616    
;;;617          const Result result = InitializeBuffer(numRows,
;;;618            numCols,
;;;619            this->data,
;;;620            numBytesAllocated,
;;;621            this->flags);
;;;622    
;;;623          this->flags.set_zeroAllocatedMemory(clearMemory);
;;;624    
;;;625          return result;
;;;626        }
;;;627    
;;;628        template<typename Type> s32 Array<Type>::SetZero()
;;;629        {
;;;630          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;631            0, "Array<Type>::SetZero", "Array<Type> is not valid");
;;;632    
;;;633          const s32 numBytes = this->get_size(0)*this->get_stride();
;;;634    
;;;635          memset(this->Pointer(0,0), 0, numBytes);
;;;636    
;;;637          return numBytes;
;;;638        }
;;;639    
;;;640        template<typename Type> s32 Array<Type>::Set(const Type value)
;;;641        {
;;;642          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;643            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;644    
;;;645          for(s32 y=0; y<size[0]; y++) {
;;;646            Type * restrict pThisData = Pointer(y, 0);
;;;647            for(s32 x=0; x<size[1]; x++) {
;;;648              pThisData[x] = value;
;;;649            }
;;;650          }
;;;651    
;;;652          return size[0]*size[1];
;;;653        }
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
;;;656        {
;;;657          return this->SetCast<Type>(in);
;;;658        }
;;;659    
;;;660        template<typename Type> template<typename InType> s32 Array<Type>::SetCast(const Array<InType> &in)
;;;661        {
;;;662          const s32 inHeight = in.get_size(0);
;;;663          const s32 inWidth = in.get_size(1);
;;;664    
;;;665          AnkiConditionalErrorAndReturnValue(AreValid(*this, in),
;;;666            0, "Array<Type>::Set", "Invalid objects");
;;;667    
;;;668          AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;669            0, "Array<Type>::Set", "Array sizes don't match");
;;;670    
;;;671          for(s32 y=0; y<size[0]; y++) {
;;;672            const InType * restrict pIn = in.Pointer(y, 0);
;;;673            Type * restrict pThisData = Pointer(y, 0);
;;;674    
;;;675            for(s32 x=0; x<size[1]; x++) {
;;;676              pThisData[x] = saturate_cast<Type>(pIn[x]);
;;;677            }
;;;678          }
;;;679    
;;;680          return size[0]*size[1];
;;;681        }
;;;682    
;;;683        template<typename InType> s32 SetCast(const InType * const values, const s32 numValues)
;;;684        {
;;;685          // This is a little tough to write a general case for, so this method should be specialized
;;;686          // for each relevant case
;;;687          AnkiAssert(false);
;;;688    
;;;689          return 0;
;;;690        }
;;;691    
;;;692        template<typename Type> s32 Array<Type>::Set(const Type * const values, const s32 numValues)
;;;693        {
;;;694          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;695            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;696    
;;;697          s32 numValuesSet = 0;
;;;698    
;;;699          for(s32 y=0; y<size[0]; y++) {
;;;700            u32 * restrict pThisData = reinterpret_cast<u32*>(Pointer(y, 0));
;;;701    
;;;702            const s32 numValuesThisRow = MAX(0, MIN(numValues - y*size[1], size[1]));
;;;703    
;;;704            if(numValuesThisRow > 0) {
;;;705              // For small data types, this may be too many bytes, but the stride padding should make
;;;706              // the writing okay (I think)
;;;707              const s32 numWordsToCopy = (sizeof(Type)*numValuesThisRow + 3) / 4;
;;;708    
;;;709              //memcpy(pThisData, values + y*size[1], numValuesThisRow*sizeof(Type));
;;;710              for(s32 x=0; x<numWordsToCopy; x++) {
;;;711                //AnkiAssert(reinterpret_cast<size_t>(values+y*size[1]) % 4 == 0);
;;;712                pThisData[x] = reinterpret_cast<const u32*>(values+y*size[1])[x];
;;;713              }
;;;714              numValuesSet += numValuesThisRow;
;;;715            }
;;;716    
;;;717            if(numValuesThisRow < size[1]) {
;;;718              memset(pThisData+numValuesThisRow*sizeof(Type), 0, (size[1]-numValuesThisRow)*sizeof(Type));
;;;719            }
;;;720          }
;;;721    
;;;722          return numValuesSet;
;;;723        }
;;;724    
;;;725        template<typename Type> Array<Type>& Array<Type>::operator= (const Array<Type> & rightHandSide)
;;;726        {
;;;727          this->size[0] = rightHandSide.size[0];
;;;728          this->size[1] = rightHandSide.size[1];
;;;729    
;;;730          this->stride = rightHandSide.stride;
;;;731          this->flags = rightHandSide.flags;
;;;732          this->data = rightHandSide.data;
;;;733    
;;;734          return *this;
;;;735        }
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
;;;738        {
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
;;;747    
;;;748        template<typename Type> s32 Array<Type>::get_stride() const
;;;749        {
;;;750          return stride;
;;;751        }
;;;752    
;;;753        template<typename Type> s32 Array<Type>::get_numElements() const
;;;754        {
;;;755          if(size[0] > 0 && size[1] > 0) {
;;;756            return size[0] * size[1];
;;;757          } else {
;;;758            return 0;
;;;759          }
;;;760        }
;;;761    
;;;762        template<typename Type> void* Array<Type>::get_buffer()
;;;763        {
;;;764          return data;
;;;765        }
;;;766    
;;;767        template<typename Type> const void* Array<Type>::get_buffer() const
;;;768        {
;;;769          return data;
;;;770        }
;;;771    
;;;772        template<typename Type> Flags::Buffer Array<Type>::get_flags() const
;;;773        {
;;;774          return flags;
;;;775        }
;;;776    
;;;777        template<typename Type> void* Array<Type>::AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate)
;;;778        {
;;;779          AnkiConditionalError(numRows >= 0 && stride > 0,
;;;780            "Array<Type>::AllocateBufferFromMemoryStack", "Invalid size");
;;;781    
;;;782          const s32 numRowsCapped = MAX(numRows, 1);
;;;783    
;;;784          this->stride = stride;
;;;785    
;;;786          const s32 numBytesRequested = numRowsCapped * this->stride;
;;;787    
;;;788          if(reAllocate) {
;;;789            return memory.Reallocate(this->data, numBytesRequested, numBytesAllocated);
;;;790          } else {
;;;791            return memory.Allocate(numBytesRequested, flags.get_zeroAllocatedMemory(), numBytesAllocated);
;;;792          }
;;;793        }
;;;794    
;;;795        template<typename Type> Result Array<Type>::InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags)
;;;796        {
;;;797          if(!rawData) {
;;;798            AnkiError("Anki.Array2d.initialize", "input data buffer is NULL");
;;;799            InvalidateArray();
;;;800            return RESULT_FAIL_UNINITIALIZED_MEMORY;
;;;801          }
;;;802    
;;;803          AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0 && dataLength >= MEMORY_ALIGNMENT,
;;;804            RESULT_FAIL_INVALID_SIZE, "Array<Type>::InitializeBuffer", "Negative dimension");
;;;805    
;;;806          AnkiConditionalErrorAndReturnValue(!flags.get_useBoundaryFillPatterns(),
;;;807            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::InitializeBuffer", "Fill patterns not supported for Array");
;;;808    
;;;809          this->flags = flags;
;;;810          this->size[0] = numRows;
;;;811          this->size[1] = numCols;
;;;812    
;;;813          // Initialize an empty array.
;;;814    
;;;815          this->data = reinterpret_cast<Type*>(rawData);
;;;816    
;;;817          const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData), MEMORY_ALIGNMENT) - reinterpret_cast<size_t>(rawData));
;;;818          const s32 requiredBytes = ComputeRequiredStride(numCols,flags)*numRows + extraAlignmentBytes;
;;;819    
;;;820          if(requiredBytes > dataLength) {
;;;821            AnkiError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
;;;822            InvalidateArray();
;;;823            return RESULT_FAIL_OUT_OF_MEMORY;
;;;824          }
;;;825    
;;;826          this->data = reinterpret_cast<Type*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
;;;827    
;;;828          //#if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;829          //      this->UpdateCvMatMirror(*this);
;;;830          //#endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;831    
;;;832          return RESULT_OK;
;;;833        } // Array<Type>::InitializeBuffer()
;;;834    
;;;835        // Set all the buffers and sizes to -1, to signal an invalid array
;;;836        template<typename Type> void Array<Type>::InvalidateArray()
;;;837        {
;;;838          this->size[0] = -1;
;;;839          this->size[1] = -1;
;;;840          this->stride = -1;
;;;841          this->data = NULL;
;;;842        } // void Array<Type>::InvalidateArray()
;;;843    
;;;844        template<typename Type> Result Array<Type>::PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX)  const
;;;845        {
;;;846          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;847            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;848    
;;;849          const s32 realMinX = MAX(0,minX);
;;;850          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;851          const s32 realMinY = MAX(0,minY);
;;;852          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;853    
;;;854          CoreTechPrint("%s type(int:%d,signed:%d,float:%d,sizeof:%d):\n", variableName, Flags::TypeCharacteristics<Type>::isInteger, Flags::TypeCharacteristics<Type>::isSigned, Flags::TypeCharacteristics<Type>::isFloat, sizeof(Type));
;;;855    
;;;856          for(s32 y=realMinY; y<realMaxY; y++) {
;;;857            const Type * const pThisData = this->Pointer(y, 0);
;;;858            for(s32 x=realMinX; x<realMaxX; x++) {
;;;859              if(Flags::TypeCharacteristics<Type>::isBasicType) {
;;;860                if(Flags::TypeCharacteristics<Type>::isInteger) {
;;;861                  CoreTechPrint("%d ", static_cast<s32>(pThisData[x]));
;;;862                } else {
;;;863                  if(version==1) {
;;;864                    CoreTechPrint("%f ", (float)pThisData[x]);
;;;865                  } else {
;;;866                    CoreTechPrint("%e ", (float)pThisData[x]);
;;;867                  }
;;;868                }
;;;869              } else {
;;;870                CoreTechPrint("! ");
;;;871              }
;;;872            }
;;;873            CoreTechPrint("\n");
;;;874          }
;;;875          CoreTechPrint("\n");
;;;876    
;;;877          return RESULT_OK;
;;;878        }
;;;879    
;;;880        template<typename Type> Result Array<Type>::PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;881        {
;;;882          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;883            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::PrintString", "Array<Type> is not valid");
;;;884    
;;;885          const s32 realMinX = MAX(0,minX);
;;;886          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;887          const s32 realMinY = MAX(0,minY);
;;;888          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;889    
;;;890          CoreTechPrint("%s:\n", variableName);
;;;891    
;;;892          for(s32 y=realMinY; y<realMaxY; y++) {
;;;893            const char * const * pThisData = this->Pointer(y, 0);
;;;894            for(s32 x=realMinX; x<realMaxX; x++) {
;;;895              const char * curString = pThisData[x];
;;;896              if(!curString) {
;;;897                CoreTechPrint("NULL, ");
;;;898              } else {
;;;899                CoreTechPrint("\"%s\", ", curString);
;;;900              }
;;;901            }
;;;902            CoreTechPrint("\n");
;;;903          }
;;;904          CoreTechPrint("\n");
;;;905    
;;;906          return RESULT_OK;
;;;907        }
;;;908    
;;;909        // #pragma mark --- FixedPointArray Definitions ---
;;;910    
;;;911        template<typename Type> FixedPointArray<Type>::FixedPointArray()
;;;912          : Array<Type>(), numFractionalBits(-1)
;;;913        {
;;;914        }
;;;915    
;;;916        template<typename Type> FixedPointArray<Type>::FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags)
;;;917          : Array<Type>(numRows, numCols, data, dataLength, flags), numFractionalBits(numFractionalBits)
;;;918        {
;;;919          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= (sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;920        }
;;;921    
;;;922        template<typename Type> FixedPointArray<Type>::FixedPointArray(s32 numRows, s32 numCols, s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags)
;;;923          : Array<Type>(numRows, numCols, memory, flags), numFractionalBits(numFractionalBits)
;;;924        {
;;;925          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= static_cast<s32>(sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;926        }
;;;927    
;;;928        template<typename Type> s32 FixedPointArray<Type>::get_numFractionalBits() const
;;;929        {
;;;930          return numFractionalBits;
;;;931        }
;;;932    
;;;933    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;934        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;935        {
;;;936          AnkiConditionalErrorAndReturnValue(in.IsValid() && out,
;;;937            RESULT_FAIL, "ArrayToCvMat", "This Array is invalid");
;;;938    
;;;939          out->refcount = NULL;
;;;940    
;;;941          // These two should be set, because if the Mat_ constructor was not called, these will not be initialized
;;;942          out->step.p = out->step.buf;
;;;943          out->size = &out->rows;
;;;944    
;;;945          *out = cv::Mat_<Type>(in.get_size(0), in.get_size(1), const_cast<Type*>(in.Pointer(0,0)), static_cast<size_t>(in.get_stride()));
;;;946    
;;;947          return RESULT_OK;
;;;948        } // template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;949    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;950    
;;;951        // #pragma mark --- Array Specializations ---
;;;952    
;;;953        template<> Result Array<bool>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;954        template<> Result Array<u8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;955        template<> Result Array<s8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;956        template<> Result Array<u16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;957        template<> Result Array<s16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;958        template<> Result Array<u32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;959        template<> Result Array<s32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;960        template<> Result Array<u64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;961        template<> Result Array<s64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;962        template<> Result Array<f32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;963        template<> Result Array<f64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;964        template<> Result Array<const char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;965        template<> Result Array<char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;966    
;;;967        template<> Result Array<f32>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;968        template<> Result Array<f64>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;969    
;;;970        template<> template<> s32 Array<u8>::SetCast(const s32 * const values, const s32 numValues);
;;;971        template<> template<> s32 Array<s16>::SetCast(const s32 * const values, const s32 numValues);
;;;972      } // namespace Embedded
;;;973    } //namespace Anki
;;;974    
;;;975    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;17     #include "anki/common/robot/arraySlices.h"
;;;1      /**
;;;2      File: arraySlices.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of arraySlices_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;14     
;;;15     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> ConstArraySlice<Type>::ConstArraySlice()
;;;23           : ySlice(LinearSequence<s32>()), xSlice(LinearSequence<s32>()), array(Array<Type>()), constArrayData(NULL)
;;;24         {
;;;25         }
;;;26     
;;;27         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array)
;;;28           : ySlice(LinearSequence<s32>(0,array.get_size(0)-1)), xSlice(LinearSequence<s32>(0,array.get_size(1)-1)), array(array)
;;;29         {
;;;30           if(array.get_numElements() == 0) {
;;;31             this->constArrayData = NULL;
;;;32           } else {
;;;33             this->constArrayData = array.Pointer(0,0);
;;;34           }
;;;35         }
;;;36     
;;;37         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;38           : ySlice(ySlice), xSlice(xSlice), array(array)
;;;39         {
;;;40           if(array.get_numElements() == 0) {
;;;41             this->constArrayData = NULL;
;;;42           } else {
;;;43             this->constArrayData = array.Pointer(0,0);
;;;44           }
;;;45         }
;;;46     
;;;47         template<typename Type> ConstArraySliceExpression<Type> ConstArraySlice<Type>::Transpose() const
;;;48         {
;;;49           ConstArraySliceExpression<Type> expression(*this, true);
;;;50     
;;;51           return expression;
;;;52         }
;;;53     
;;;54         template<typename Type> bool ConstArraySlice<Type>::IsValid() const
;;;55         {
;;;56           return this->array.IsValid();
;;;57         }
;;;58     
;;;59         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_ySlice() const
;;;60         {
;;;61           return ySlice;
;;;62         }
;;;63     
;;;64         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_xSlice() const
;;;65         {
;;;66           return xSlice;
;;;67         }
;;;68     
;;;69         template<typename Type> const Array<Type>& ConstArraySlice<Type>::get_array() const
;;;70         {
;;;71           return this->array;
;;;72         }
;;;73     
;;;74         template<typename Type> ArraySlice<Type>::ArraySlice()
;;;75           : ConstArraySlice<Type>(), arrayData(NULL)
;;;76         {
;;;77         }
;;;78     
;;;79         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array)
;;;80           : ConstArraySlice<Type>(array)
;;;81         {
;;;82           if(array.get_numElements() == 0) {
;;;83             this->arrayData = NULL;
;;;84           } else {
;;;85             this->arrayData = array.Pointer(0,0);
;;;86           }
;;;87         }
;;;88     
;;;89         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;90           : ConstArraySlice<Type>(array, ySlice, xSlice)
;;;91         {
;;;92           if(array.get_numElements() == 0) {
;;;93             this->arrayData = NULL;
;;;94           } else {
;;;95             this->arrayData = array.Pointer(0,0);
;;;96           }
;;;97         }
;;;98     
;;;99         template<typename Type> s32 ArraySlice<Type>::Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;100        {
;;;101          return this->SetCast<Type>(input, automaticTranspose);
;;;102        }
;;;103    
;;;104        template<typename Type> s32 ArraySlice<Type>::Set(const LinearSequence<Type> &input)
;;;105        {
;;;106          const Result result = input.Evaluate(*this);
;;;107          return (result==RESULT_OK) ? input.get_size() : 0;
;;;108        }
;;;109    
;;;110        template<typename Type> s32 ArraySlice<Type>::Set(const Type value)
;;;111        {
;;;112          Array<Type> &array = this->get_array();
;;;113    
;;;114          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;115            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;116    
;;;117          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;118    
;;;119          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;120            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;121    
;;;122          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;123            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;124            Type * restrict pMat = array.Pointer(y, 0);
;;;125    
;;;126            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;127              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;128              pMat[x] = value;
;;;129            }
;;;130          }
;;;131    
;;;132          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;133        }
;;;134    
;;;135        template<typename Type> s32 ArraySlice<Type>::Set(const Type * const values, const s32 numValues)
;;;136        {
;;;137          Array<Type> &array = this->get_array();
;;;138    
;;;139          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;140            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;141    
;;;142          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;143    
;;;144          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;145            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;146    
;;;147          AnkiConditionalErrorAndReturnValue(limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize == numValues,
;;;148            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;149    
;;;150          s32 ci = 0;
;;;151          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;152            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;153            Type * restrict pMat = array.Pointer(y, 0);
;;;154    
;;;155            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;156              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;157              pMat[x] = values[ci];
;;;158              ci++;
;;;159            }
;;;160          }
;;;161    
;;;162          AnkiAssert(ci == limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize);
;;;163    
;;;164          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;165        }
;;;166    
;;;167        template<typename Type> template<typename InType> s32 ArraySlice<Type>::SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;168        {
;;;169          AnkiConditionalErrorAndReturnValue(AreValid(*this, input),
;;;170            0, "ArraySlice<Type>::Set", "Invalid objects");
;;;171    
;;;172          AnkiConditionalErrorAndReturnValue(this->get_array().get_buffer() != input.get_array().get_buffer(),
;;;173            0, "ArraySlice<Type>::Set", "Arrays must be in different memory locations");
;;;174    
;;;175          ArraySliceLimits_in1_out1<s32> limits(
;;;176            input.get_ySlice(), input.get_xSlice(), input.get_isTransposed(),
;;;177            this->get_ySlice(), this->get_xSlice());
;;;178    
;;;179          if(!limits.isValid) {
;;;180            if(automaticTranspose) {
;;;181              // If we're allowed to transpose, give it another shot
;;;182              limits = ArraySliceLimits_in1_out1<s32> (input.get_ySlice(), input.get_xSlice(), !input.get_isTransposed(), this->get_ySlice(), this->get_xSlice());
;;;183    
;;;184              if(!limits.isValid) {
;;;185                AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;186                return 0;
;;;187              }
;;;188            } else {
;;;189              AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;190              return 0;
;;;191            }
;;;192          }
;;;193    
;;;194          Array<Type> &out1Array = this->get_array();
;;;195          const Array<InType> &in1Array = input.get_array();
;;;196    
;;;197          if(limits.isSimpleIteration) {
;;;198            // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;199    
;;;200            for(s32 y=0; y<limits.ySize; y++) {
;;;201              const InType * restrict pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;202              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;203    
;;;204              limits.OuterIncrementTop();
;;;205    
;;;206              for(s32 x=0; x<limits.xSize; x++) {
;;;207                pOut1[limits.out1X] = static_cast<Type>( pIn1[limits.in1X] );
;;;208    
;;;209                limits.out1X += limits.out1_xInnerIncrement;
;;;210                limits.in1X += limits.in1_xInnerIncrement;
;;;211              }
;;;212    
;;;213              limits.OuterIncrementBottom();
;;;214            }
;;;215          } else {
;;;216            for(s32 y=0; y<limits.ySize; y++) {
;;;217              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;218    
;;;219              limits.OuterIncrementTop();
;;;220    
;;;221              for(s32 x=0; x<limits.xSize; x++) {
;;;222                const InType pIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;223    
;;;224                pOut1[limits.out1X] = static_cast<Type>( pIn1 );
;;;225    
;;;226                limits.out1X += limits.out1_xInnerIncrement;
;;;227                limits.in1Y += limits.in1_yInnerIncrement;
;;;228              }
;;;229    
;;;230              limits.OuterIncrementBottom();
;;;231            }
;;;232          }
;;;233    
;;;234          return limits.ySize*limits.xSize;
;;;235        }
;;;236    
;;;237        template<typename Type> Array<Type>& ArraySlice<Type>::get_array()
;;;238        {
;;;239          return this->array;
;;;240        }
;;;241    
;;;242        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression()
;;;243          : ConstArraySlice<Type>(), isTransposed(false)
;;;244        {
;;;245        }
;;;246    
;;;247        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const Array<Type> input, bool isTransposed)
;;;248          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;249        {
;;;250        }
;;;251    
;;;252        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed)
;;;253          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;254        {
;;;255        }
;;;256    
;;;257        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed)
;;;258          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;259        {
;;;260        }
;;;261    
;;;262        template<typename Type> ConstArraySliceExpression<Type> ConstArraySliceExpression<Type>::Transpose() const
;;;263        {
;;;264          ConstArraySliceExpression<Type> expression(*this, !this->get_isTransposed());
;;;265    
;;;266          return expression;
;;;267        }
;;;268    
;;;269        template<typename Type> bool ConstArraySliceExpression<Type>::get_isTransposed() const
;;;270        {
;;;271          return isTransposed;
;;;272        }
;;;273    
;;;274        template<typename Type> ArraySliceSimpleLimits<Type>::ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;275          : xStart(in1_xSlice.get_start()), xIncrement(in1_xSlice.get_increment()), xSize(in1_xSlice.get_size()),
;;;276          yStart(in1_ySlice.get_start()), yIncrement(in1_ySlice.get_increment()), ySize(in1_ySlice.get_size())
;;;277        {
;;;278        }
;;;279    
;;;280        template<typename Type> ArraySliceLimits_in1_out0<Type>::ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;281          : isValid(true), rawIn1Limits(in1_ySlice, in1_xSlice)
;;;282        {
;;;283        } // ArraySliceLimits_in1_out0
;;;284    
;;;285        template<typename Type> ArraySliceLimits_in1_out1<Type>::ArraySliceLimits_in1_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;286          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;287          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;288          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed)
;;;289        {
;;;290          isValid = false;
;;;291    
;;;292          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;293    
;;;294          if(!in1_isTransposed) {
;;;295            if(rawOut1Limits.xSize == rawIn1Limits.xSize && rawOut1Limits.ySize == rawIn1Limits.ySize) {
;;;296              isValid = true;
;;;297              isSimpleIteration = true;
;;;298    
;;;299              this->in1Y = this->rawIn1Limits.yStart;
;;;300              this->out1Y = this->rawOut1Limits.yStart;
;;;301    
;;;302              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;303              this->in1_yInnerIncrement = 0;
;;;304            }
;;;305          } else { // if(!in1_isTransposed)
;;;306            if(rawOut1Limits.xSize == rawIn1Limits.ySize && rawOut1Limits.ySize == rawIn1Limits.xSize) {
;;;307              isValid = true;
;;;308              isSimpleIteration = false;
;;;309    
;;;310              this->in1X = this->rawIn1Limits.xStart;
;;;311              this->out1Y = this->rawOut1Limits.yStart;
;;;312    
;;;313              this->in1_xInnerIncrement = 0;
;;;314              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;315            }
;;;316          } // if(!in1_isTransposed) ... else
;;;317    
;;;318          if(!isValid) {
;;;319            AnkiError("ArraySliceLimits_in1_out1", "Subscripted assignment dimension mismatch");
;;;320            return;
;;;321          }
;;;322        } // ArraySliceLimits_in1_out1
;;;323    
;;;324        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;325        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;326        {
;;;327          if(isSimpleIteration) {
;;;328            this->in1X = this->rawIn1Limits.xStart;
;;;329            this->out1X = this->rawOut1Limits.xStart;
;;;330          } else { // if(isSimpleIteration)
;;;331            this->in1Y = this->rawIn1Limits.yStart;
;;;332            this->out1X = this->rawOut1Limits.xStart;
;;;333          } // if(isSimpleIteration) ... else
;;;334        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;335    
;;;336        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;337        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;338        {
;;;339          if(isSimpleIteration) {
;;;340            this->in1Y += this->rawIn1Limits.yIncrement;
;;;341            this->out1Y += this->rawOut1Limits.yIncrement;
;;;342          } else { // if(isSimpleIteration)
;;;343            this->in1X += this->rawIn1Limits.xIncrement;
;;;344            this->out1Y += this->rawOut1Limits.yIncrement;
;;;345          } // if(isSimpleIteration) ... else
;;;346        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;347    
;;;348        template<typename Type> ArraySliceLimits_in2_out1<Type>::ArraySliceLimits_in2_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;349          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;350          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;351          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed),
;;;352          rawIn2Limits(in2_ySlice, in2_xSlice), in2_isTransposed(in2_isTransposed)
;;;353        {
;;;354          isValid = false;
;;;355    
;;;356          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;357          this->in1_yInnerIncrement = 0;
;;;358          this->in1_xInnerIncrement = 0;
;;;359          this->in2_yInnerIncrement = 0;
;;;360          this->in2_xInnerIncrement = 0;
;;;361    
;;;362          if(!in1_isTransposed && !in2_isTransposed) {
;;;363            const bool sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;364    
;;;365            if(sizesMatch) {
;;;366              isValid = true;
;;;367              isSimpleIteration = true;
;;;368    
;;;369              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;370              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;371    
;;;372              this->in1Y = this->rawIn1Limits.yStart;
;;;373              this->in2Y = this->rawIn2Limits.yStart;
;;;374              this->out1Y = this->rawOut1Limits.yStart;
;;;375            }
;;;376          } else { // if(!in1_isTransposed)
;;;377            isSimpleIteration = false;
;;;378    
;;;379            bool sizesMatch = false;
;;;380    
;;;381            if(in1_isTransposed && in2_isTransposed) {
;;;382              sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;383              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;384              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;385            } else if(in1_isTransposed) {
;;;386              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;387              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;388              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;389            } else if(in2_isTransposed) {
;;;390              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;391              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;392              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;393            } else {
;;;394              AnkiAssert(false); // should not be possible
;;;395            }
;;;396    
;;;397            if(!sizesMatch) {
;;;398              AnkiError("ArraySliceLimits_in2_out1", "Subscripted assignment dimension mismatch");
;;;399              return;
;;;400            }
;;;401    
;;;402            isValid = true;
;;;403    
;;;404            this->in1X = this->rawIn1Limits.xStart;
;;;405            this->in1Y = this->rawIn1Limits.yStart;
;;;406            this->in2X = this->rawIn2Limits.xStart;
;;;407            this->in2Y = this->rawIn2Limits.yStart;
;;;408    
;;;409            this->out1Y = this->rawOut1Limits.yStart;
;;;410          } // if(!in1_isTransposed) ... else
;;;411        } // ArraySliceLimits_in1_out1
;;;412    
;;;413        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;414        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;415        {
;;;416          if(isSimpleIteration) {
;;;417            this->out1X = this->rawOut1Limits.xStart;
;;;418            this->in1X = this->rawIn1Limits.xStart;
;;;419            this->in2X = this->rawIn2Limits.xStart;
;;;420          } else { // if(isSimpleIteration)
;;;421            this->out1X = this->rawOut1Limits.xStart;
;;;422    
;;;423            if(in1_isTransposed) {
;;;424              this->in1Y = this->rawIn1Limits.yStart;
;;;425            } else {
;;;426              this->in1X = this->rawIn1Limits.xStart;
;;;427            }
;;;428    
;;;429            if(in2_isTransposed) {
;;;430              this->in2Y = this->rawIn2Limits.yStart;
;;;431            } else {
;;;432              this->in2X = this->rawIn2Limits.xStart;
;;;433            }
;;;434          } // if(isSimpleIteration) ... else
;;;435        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;436    
;;;437        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;438        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;439        {
;;;440          if(isSimpleIteration) {
;;;441            this->in1Y += this->rawIn1Limits.yIncrement;
;;;442            this->in2Y += this->rawIn2Limits.yIncrement;
;;;443            this->out1Y += this->rawOut1Limits.yIncrement;
;;;444          } else { // if(isSimpleIteration)
;;;445            this->out1Y += this->rawOut1Limits.yIncrement;
;;;446    
;;;447            if(in1_isTransposed) {
;;;448              this->in1X += this->rawIn1Limits.xIncrement;
;;;449            } else {
;;;450              this->in1Y += this->rawIn1Limits.yIncrement;
;;;451            }
;;;452    
;;;453            if(in2_isTransposed) {
;;;454              this->in2X += this->rawIn2Limits.xIncrement;
;;;455            } else {
;;;456              this->in2Y += this->rawIn2Limits.yIncrement;
;;;457            }
;;;458          } // if(isSimpleIteration) ... else
;;;459        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;460      } // namespace Embedded
;;;461    } // namespace Anki
;;;462    
;;;463    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;19     #include "anki/common/robot/benchmarking.h"
;;;1      /**
;;;2      File: benchmarkins.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Low-overhead benchmarking, based on a list of start and end events.
;;;7      
;;;8      The basic use of this benchmarking utility is as follows:
;;;9      1. InitBenchmarking()
;;;10     2. At the beginning of the section you want to benchmark, put BeginBenchmark("event type");
;;;11     3. At the end of the section you want to benchmark, put EndBenchmark("event type");
;;;12     4. When you're done running the program, call PrintBenchmarkResults() to print the results
;;;13     
;;;14     Copyright Anki, Inc. 2013
;;;15     For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;16     **/
;;;17     
;;;18     #ifndef _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;19     #define _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     
;;;21     #include "anki/common/robot/config.h"
;;;1      /**
;;;22     #include "anki/common/robot/fixedLengthList_declarations.h"
;;;1      /**
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         const s32 MAX_BENCHMARK_EVENTS = 16000;
;;;29     
;;;30         typedef struct BenchmarkElement
;;;31         {
;;;32           // All times in microseconds, on all platforms
;;;33     
;;;34           static const s32 NAME_LENGTH = 64;
;;;35     
;;;36           // Inclusive includes all the time for all sub-benchmarks
;;;37           u32 inclusive_mean;
;;;38           u32 inclusive_min;
;;;39           u32 inclusive_max;
;;;40           u32 inclusive_total;
;;;41     
;;;42           // Exclusive does not include sub-benchmarks
;;;43           u32 exclusive_mean;
;;;44           u32 exclusive_min;
;;;45           u32 exclusive_max;
;;;46           u32 exclusive_total;
;;;47     
;;;48           // How many times was this element's name benchmarked?
;;;49           u32 numEvents;
;;;50     
;;;51           char name[BenchmarkElement::NAME_LENGTH];
;;;52     
;;;53           BenchmarkElement(const char * name);
;;;54     
;;;55           // Print with CoreTechPrint()
;;;56           void Print(const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;57     
;;;58           // Like snprintf(). Returns the number of characters printed, not including the final null byte.
;;;59           s32 Snprint(char * buffer, const s32 bufferLength, const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;60         } BenchmarkElement;
;;;61     
;;;62         typedef struct ShowBenchmarkParameters
;;;63         {
;;;64           char name[BenchmarkElement::NAME_LENGTH];
;;;65           bool showExclusiveTime;
;;;66           u8 red, green, blue;
;;;67     
;;;68           ShowBenchmarkParameters(
;;;69             const char * name,
;;;70             const bool showExclusiveTime,
;;;71             const u8 *color); //< Color is {R,G,B}
;;;72         } ShowBenchmarkParameters;
;;;73     
;;;74         // Call this before doing any benchmarking, to clear the buffer of benchmarkEvents.
;;;75         // Can be called multiple times.
;;;76         void InitBenchmarking();
;;;77     
;;;78         // Use these functions to add a new event to the list. These functions are very fast.
;;;79         //
;;;80         // WARNING: name must be in globally available memory
;;;81         //
;;;82         // WARNING: the character string must be less than BenchmarkElement::NAME_LENGTH bytes
;;;83         //
;;;84         // WARNING: Using the same name for different benchmark events
;;;85         //
;;;86         // WARNING: nesting BeginBenchmark() and EndBenchmark() events that have the same name won't work.
;;;87         // This is okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("b"); EndBenchmark("a");
;;;88         // This is not okay: BeginBenchmark("a"); BeginBenchmark("a"); EndBenchmark("a"); EndBenchmark("a");
;;;89         // This is not okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("a"); EndBenchmark("b");
;;;90         void BeginBenchmark(const char *name);
;;;91         void EndBenchmark(const char *name);
;;;92     
;;;93         // Compile all the benchmark events that were recorded
;;;94         FixedLengthList<BenchmarkElement> ComputeBenchmarkResults(MemoryStack &memory);
;;;95     
;;;96         // CoreTechPrint() the benchmark results
;;;97         // WARNING: This doesn't work well with multi-threaded programs
;;;98         Result PrintBenchmarkResults(const FixedLengthList<BenchmarkElement> &results, const bool verbose=true, const bool microseconds=true);
;;;99     
;;;100        // Compile and print out all the benchmark events that were recorded
;;;101        Result ComputeAndPrintBenchmarkResults(const bool verbose, const bool microseconds, MemoryStack scratch);
;;;102    
;;;103        // "benchmarkElements" is a list of lists of benchmarkElements, where each list is a set from one session computed from ComputeBenchmarkResults()
;;;104        // This function sorts them and prints the elementPercentile" percentile
;;;105        Result PrintPercentileBenchmark(const FixedLengthList<FixedLengthList<BenchmarkElement> > &benchmarkElements, const s32 numRuns, const f32 elementPercentile, MemoryStack scratch);
;;;106    
;;;107        // Use OpenCV to display a running benchmark
;;;108        // Requires a "TotalTime" benchmark event
;;;109        // namesToDisplay can be 11 or less names
;;;110        Result ShowBenchmarkResults(
;;;111          const FixedLengthList<BenchmarkElement> &results,
;;;112          const FixedLengthList<ShowBenchmarkParameters> &namesToDisplay,
;;;113          const f32 pixelsPerMillisecond,
;;;114          const s32 imageHeight,
;;;115          const s32 imageWidth);
;;;116    
;;;117        s32 GetNameIndex(const char * name, const FixedLengthList<BenchmarkElement> &outputResults);
;;;118      } // namespace Embedded
;;;119    } // namespace Anki
;;;120    
;;;121    #endif // _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     #include "anki/common/robot/comparisons.h"
;;;1      /**
;;;2      File: comparisons.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of comparisons_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;14     
;;;15     #include "anki/common/robot/comparisons_declarations.h"
;;;1      /**
;;;2      File: comparisons_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various elementwise tests, to ensure that the data of two Arrays is equal.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Declarations ---
;;;23         // Check every element of this array against the input array. If the arrays are different
;;;24         // sizes, uninitialized, or if any element is more different than the threshold, then
;;;25         // return false.
;;;26         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold = static_cast<Type>(0.0001));
;;;27     
;;;28         // Check every element of this array against the input array. If the arrays are different
;;;29         // sizes or uninitialized, return false. The percentThreshold is between 0.0 and 1.0. To
;;;30         // return false, an element must fail both thresholds. The percent threshold fails if an
;;;31         // element is more than a percentage different than its matching element (calulated from the
;;;32         // maximum of the two).
;;;33         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold = 0.01, const double absoluteThreshold = 0.0001);
;;;34     
;;;35         // If any of the input objects are not valid, then return false
;;;36         // NOTE: the objects must have an IsValid() method
;;;37         template<typename Type1> bool AreValid(const Type1 &object1);
;;;38         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2);
;;;39         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;40         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;41         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;42         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;43         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;44         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;45         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;46     
;;;47         // If the objects have different sizes or are uninitialized, then return false.
;;;48         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;49         template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2);
;;;50         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;51         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;52         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;53         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;54         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;55         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;56         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;57     
;;;58         // Check sizes against an input height and width
;;;59         template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1);
;;;60         template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2);
;;;61         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;62         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;63         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;64         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;65         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;66         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;67         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;68     
;;;69         // If the Arrays are aliased (pointing to the same location in memory) or uninitialized, then return false
;;;70         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;71         template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2);
;;;72         template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;73         template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;74         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;75         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;76         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;77         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;78         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;79       } // namespace Embedded
;;;80     } // namespace Anki
;;;81     
;;;82     #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark
;;;23     
;;;24         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold)
;;;25         {
;;;26           if(!AreEqualSize(array1, array2))
;;;27             return false;
;;;28     
;;;29           const s32 height = array1.get_size(0);
;;;30           const s32 width = array1.get_size(1);
;;;31     
;;;32           for(s32 y=0; y<height; y++) {
;;;33             const Type * const pArray1 = array1.Pointer(y, 0);
;;;34             const Type * const pArray2 = array2.Pointer(y, 0);
;;;35             for(s32 x=0; x<width; x++) {
;;;36               if(pArray1[x] > pArray2[x]) {
;;;37                 if((pArray1[x] - pArray2[x]) > threshold)
;;;38                   return false;
;;;39               } else {
;;;40                 if((pArray2[x] - pArray1[x]) > threshold)
;;;41                   return false;
;;;42               }
;;;43             }
;;;44           }
;;;45     
;;;46           return true;
;;;47         }
;;;48     
;;;49         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold, const double absoluteThreshold)
;;;50         {
;;;51           if(!AreEqualSize(array1, array2))
;;;52             return false;
;;;53     
;;;54           const s32 height = array1.get_size(0);
;;;55           const s32 width = array1.get_size(1);
;;;56     
;;;57           for(s32 y=0; y<height; y++) {
;;;58             const Type * const pArray1 = array1.Pointer(y, 0);
;;;59             const Type * const pArray2 = array2.Pointer(y, 0);
;;;60             for(s32 x=0; x<width; x++) {
;;;61               const double value1 = static_cast<double>(pArray1[x]);
;;;62               const double value2 = static_cast<double>(pArray2[x]);
;;;63               const double percentThresholdValue = percentThreshold * MAX(value1,value2);
;;;64     
;;;65               if(fabs(value1 - value2) > percentThresholdValue && fabs(value1 - value2) > absoluteThreshold)
;;;66                 return false;
;;;67             }
;;;68           }
;;;69     
;;;70           return true;
;;;71         }
;;;72     
;;;73         template<typename Type1> bool AreValid(const Type1 &object1)
;;;74         {
;;;75           if(!object1.IsValid())
;;;76             return false;
;;;77     
;;;78           return true;
;;;79         }
;;;80     
;;;81         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2)
;;;82         {
;;;83           if(!object1.IsValid() || !object2.IsValid())
;;;84             return false;
;;;85     
;;;86           return true;
;;;87         }
;;;88     
;;;89         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;90         {
;;;91           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid())
;;;92             return false;
;;;93     
;;;94           return true;
;;;95         }
;;;96     
;;;97         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;98         {
;;;99           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid())
;;;100            return false;
;;;101    
;;;102          return true;
;;;103        }
;;;104    
;;;105        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;106        {
;;;107          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid())
;;;108            return false;
;;;109    
;;;110          return true;
;;;111        }
;;;112    
;;;113        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;114        {
;;;115          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid())
;;;116            return false;
;;;117    
;;;118          return true;
;;;119        }
;;;120    
;;;121        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;122        {
;;;123          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid())
;;;124            return false;
;;;125    
;;;126          return true;
;;;127        }
;;;128    
;;;129        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;130        {
;;;131          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid())
;;;132            return false;
;;;133    
;;;134          return true;
;;;135        }
;;;136    
;;;137        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;138        {
;;;139          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid() || !object9.IsValid())
;;;140            return false;
;;;141    
;;;142          return true;
;;;143        }
;;;144    
;;;145        template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2)
;;;146        {
;;;147          if(!AreValid(object1, object2))
;;;148            return false;
;;;149    
;;;150          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1))
;;;151            return false;
;;;152    
;;;153          return true;
;;;154        }
;;;155    
;;;156        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;157        {
;;;158          if(!AreValid(object1, object2, object3))
;;;159            return false;
;;;160    
;;;161          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;162            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1))
;;;163            return false;
;;;164    
;;;165          return true;
;;;166        }
;;;167    
;;;168        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;169        {
;;;170          if(!AreValid(object1, object2, object3, object4))
;;;171            return false;
;;;172    
;;;173          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;174            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;175            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1))
;;;176            return false;
;;;177    
;;;178          return true;
;;;179        }
;;;180    
;;;181        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;182        {
;;;183          if(!AreValid(object1, object2, object3, object4, object5))
;;;184            return false;
;;;185    
;;;186          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;187            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;188            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;189            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1))
;;;190            return false;
;;;191    
;;;192          return true;
;;;193        }
;;;194    
;;;195        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;196        {
;;;197          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;198            return false;
;;;199    
;;;200          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;201            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;202            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;203            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;204            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1))
;;;205            return false;
;;;206    
;;;207          return true;
;;;208        }
;;;209    
;;;210        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;211        {
;;;212          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;213            return false;
;;;214    
;;;215          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;216            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;217            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;218            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;219            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;220            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1))
;;;221            return false;
;;;222    
;;;223          return true;
;;;224        }
;;;225    
;;;226        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;227        {
;;;228          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;229            return false;
;;;230    
;;;231          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;232            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;233            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;234            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;235            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;236            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;237            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1))
;;;238            return false;
;;;239    
;;;240          return true;
;;;241        }
;;;242    
;;;243        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;244        {
;;;245          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;246            return false;
;;;247    
;;;248          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;249            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;250            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;251            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;252            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;253            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;254            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1) ||
;;;255            object1.get_size(0) != object9.get_size(0) || object1.get_size(1) != object9.get_size(1))
;;;256            return false;
;;;257    
;;;258          return true;
;;;259        }
;;;260    
;;;261        template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1)
;;;262        {
;;;263          if(!AreValid(object1))
;;;264            return false;
;;;265    
;;;266          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;267            return false;
;;;268    
;;;269          return true;
;;;270        }
;;;271    
;;;272        template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2)
;;;273        {
;;;274          if(!AreValid(object1, object2))
;;;275            return false;
;;;276    
;;;277          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;278            return false;
;;;279    
;;;280          return AreEqualSize(object1, object2);
;;;281        }
;;;282    
;;;283        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;284        {
;;;285          if(!AreValid(object1, object2, object3))
;;;286            return false;
;;;287    
;;;288          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;289            return false;
;;;290    
;;;291          return AreEqualSize(object1, object2, object3);
;;;292        }
;;;293    
;;;294        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;295        {
;;;296          if(!AreValid(object1, object2, object3, object4))
;;;297            return false;
;;;298    
;;;299          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;300            return false;
;;;301    
;;;302          return AreEqualSize(object1, object2, object3, object4);
;;;303        }
;;;304    
;;;305        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;306        {
;;;307          if(!AreValid(object1, object2, object3, object4, object5))
;;;308            return false;
;;;309    
;;;310          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;311            return false;
;;;312    
;;;313          return AreEqualSize(object1, object2, object3, object4, object5);
;;;314        }
;;;315    
;;;316        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;317        {
;;;318          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;319            return false;
;;;320    
;;;321          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;322            return false;
;;;323    
;;;324          return AreEqualSize(object1, object2, object3, object4, object5, object6);
;;;325        }
;;;326    
;;;327        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;328        {
;;;329          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;330            return false;
;;;331    
;;;332          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;333            return false;
;;;334    
;;;335          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7);
;;;336        }
;;;337    
;;;338        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;339        {
;;;340          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;341            return false;
;;;342    
;;;343          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;344            return false;
;;;345    
;;;346          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8);
;;;347        }
;;;348    
;;;349        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;350        {
;;;351          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;352            return false;
;;;353    
;;;354          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;355            return false;
;;;356    
;;;357          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8, object9);
;;;358        }
;;;359    
;;;360        template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2)
;;;361        {
;;;362          if(!AreValid(object1, object2))
;;;363            return false;
;;;364    
;;;365          const size_t bufferPointers[] = {
;;;366            reinterpret_cast<size_t>(object1.get_buffer()),
;;;367            reinterpret_cast<size_t>(object2.get_buffer())};
;;;368    
;;;369          for(s32 i=0; i<2; i++) {
;;;370            for(s32 j=i+1; j<2; j++) {
;;;371              if(bufferPointers[i] == bufferPointers[j])
;;;372                return false;
;;;373            }
;;;374          }
;;;375    
;;;376          return true;
;;;377        }
;;;378    
;;;379        template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;380        {
;;;381          if(!AreValid(object1, object2, object3))
;;;382            return false;
;;;383    
;;;384          const size_t bufferPointers[] = {
;;;385            reinterpret_cast<size_t>(object1.get_buffer()),
;;;386            reinterpret_cast<size_t>(object2.get_buffer()),
;;;387            reinterpret_cast<size_t>(object3.get_buffer())};
;;;388    
;;;389          for(s32 i=0; i<3; i++) {
;;;390            for(s32 j=i+1; j<3; j++) {
;;;391              if(bufferPointers[i] == bufferPointers[j])
;;;392                return false;
;;;393            }
;;;394          }
;;;395    
;;;396          return true;
;;;397        }
;;;398    
;;;399        template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;400        {
;;;401          if(!AreValid(object1, object2, object3, object4))
;;;402            return false;
;;;403    
;;;404          const size_t bufferPointers[] = {
;;;405            reinterpret_cast<size_t>(object1.get_buffer()),
;;;406            reinterpret_cast<size_t>(object2.get_buffer()),
;;;407            reinterpret_cast<size_t>(object3.get_buffer()),
;;;408            reinterpret_cast<size_t>(object4.get_buffer())};
;;;409    
;;;410          for(s32 i=0; i<4; i++) {
;;;411            for(s32 j=i+1; j<4; j++) {
;;;412              if(bufferPointers[i] == bufferPointers[j])
;;;413                return false;
;;;414            }
;;;415          }
;;;416    
;;;417          return true;
;;;418        }
;;;419    
;;;420        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;421        {
;;;422          if(!AreValid(object1, object2, object3, object4, object5))
;;;423            return false;
;;;424    
;;;425          const size_t bufferPointers[] = {
;;;426            reinterpret_cast<size_t>(object1.get_buffer()),
;;;427            reinterpret_cast<size_t>(object2.get_buffer()),
;;;428            reinterpret_cast<size_t>(object3.get_buffer()),
;;;429            reinterpret_cast<size_t>(object4.get_buffer()),
;;;430            reinterpret_cast<size_t>(object5.get_buffer())};
;;;431    
;;;432          for(s32 i=0; i<5; i++) {
;;;433            for(s32 j=i+1; j<5; j++) {
;;;434              if(bufferPointers[i] == bufferPointers[j])
;;;435                return false;
;;;436            }
;;;437          }
;;;438    
;;;439          return true;
;;;440        }
;;;441    
;;;442        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;443        {
;;;444          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;445            return false;
;;;446    
;;;447          const size_t bufferPointers[] = {
;;;448            reinterpret_cast<size_t>(object1.get_buffer()),
;;;449            reinterpret_cast<size_t>(object2.get_buffer()),
;;;450            reinterpret_cast<size_t>(object3.get_buffer()),
;;;451            reinterpret_cast<size_t>(object4.get_buffer()),
;;;452            reinterpret_cast<size_t>(object5.get_buffer()),
;;;453            reinterpret_cast<size_t>(object6.get_buffer())};
;;;454    
;;;455          for(s32 i=0; i<6; i++) {
;;;456            for(s32 j=i+1; j<6; j++) {
;;;457              if(bufferPointers[i] == bufferPointers[j])
;;;458                return false;
;;;459            }
;;;460          }
;;;461    
;;;462          return true;
;;;463        }
;;;464    
;;;465        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;466        {
;;;467          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;468            return false;
;;;469    
;;;470          const size_t bufferPointers[] = {
;;;471            reinterpret_cast<size_t>(object1.get_buffer()),
;;;472            reinterpret_cast<size_t>(object2.get_buffer()),
;;;473            reinterpret_cast<size_t>(object3.get_buffer()),
;;;474            reinterpret_cast<size_t>(object4.get_buffer()),
;;;475            reinterpret_cast<size_t>(object5.get_buffer()),
;;;476            reinterpret_cast<size_t>(object6.get_buffer()),
;;;477            reinterpret_cast<size_t>(object7.get_buffer())};
;;;478    
;;;479          for(s32 i=0; i<7; i++) {
;;;480            for(s32 j=i+1; j<7; j++) {
;;;481              if(bufferPointers[i] == bufferPointers[j])
;;;482                return false;
;;;483            }
;;;484          }
;;;485    
;;;486          return true;
;;;487        }
;;;488    
;;;489        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;490        {
;;;491          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;492            return false;
;;;493    
;;;494          const size_t bufferPointers[] = {
;;;495            reinterpret_cast<size_t>(object1.get_buffer()),
;;;496            reinterpret_cast<size_t>(object2.get_buffer()),
;;;497            reinterpret_cast<size_t>(object3.get_buffer()),
;;;498            reinterpret_cast<size_t>(object4.get_buffer()),
;;;499            reinterpret_cast<size_t>(object5.get_buffer()),
;;;500            reinterpret_cast<size_t>(object6.get_buffer()),
;;;501            reinterpret_cast<size_t>(object7.get_buffer()),
;;;502            reinterpret_cast<size_t>(object8.get_buffer())};
;;;503    
;;;504          for(s32 i=0; i<8; i++) {
;;;505            for(s32 j=i+1; j<8; j++) {
;;;506              if(bufferPointers[i] == bufferPointers[j])
;;;507                return false;
;;;508            }
;;;509          }
;;;510    
;;;511          return true;
;;;512        }
;;;513    
;;;514        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;515        {
;;;516          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;517            return false;
;;;518    
;;;519          const size_t bufferPointers[] = {
;;;520            reinterpret_cast<size_t>(object1.get_buffer()),
;;;521            reinterpret_cast<size_t>(object2.get_buffer()),
;;;522            reinterpret_cast<size_t>(object3.get_buffer()),
;;;523            reinterpret_cast<size_t>(object4.get_buffer()),
;;;524            reinterpret_cast<size_t>(object5.get_buffer()),
;;;525            reinterpret_cast<size_t>(object6.get_buffer()),
;;;526            reinterpret_cast<size_t>(object7.get_buffer()),
;;;527            reinterpret_cast<size_t>(object8.get_buffer()),
;;;528            reinterpret_cast<size_t>(object9.get_buffer()) };
;;;529    
;;;530          for(s32 i=0; i<9; i++) {
;;;531            for(s32 j=i+1; j<9; j++) {
;;;532              if(bufferPointers[i] == bufferPointers[j])
;;;533                return false;
;;;534            }
;;;535          }
;;;536    
;;;537          return true;
;;;538        }
;;;539      } // namespace Embedded
;;;540    } // namespace Anki
;;;541    
;;;542    #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26         namespace Matrix
;;;27         {
;;;28           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;29           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;30           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;31           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;32     
;;;33           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;34           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;35           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;36           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;37     
;;;38           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;39           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;40           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;41           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;42     
;;;43           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;44           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;45           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;46           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;47     
;;;48           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;49           {
;;;50             const Array<Type> &array = mat.get_array();
;;;51     
;;;52             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;53               0, "Matrix::Min", "Array<Type> is not valid");
;;;54     
;;;55             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;56     
;;;57             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;58               0, "Matrix::Min", "Limits is not valid");
;;;59     
;;;60             Type minValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;61             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;62               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;63               const Type * restrict pMat = array.Pointer(y, 0);
;;;64     
;;;65               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;66                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;67                 minValue = MIN(minValue, pMat[x]);
;;;68               }
;;;69             }
;;;70     
;;;71             return minValue;
;;;72           } // template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;73     
;;;74           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;75           {
;;;76             const Array<Type> &array = mat.get_array();
;;;77     
;;;78             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;79               0, "Matrix::Max", "Array<Type> is not valid");
;;;80     
;;;81             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;82     
;;;83             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;84               0, "Matrix::Max", "Limits is not valid");
;;;85     
;;;86             Type maxValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;87             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;88               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;89               const Type * restrict pMat = array.Pointer(y, 0);
;;;90     
;;;91               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;92                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;93                 maxValue = MAX(maxValue, pMat[x]);
;;;94               }
;;;95             }
;;;96     
;;;97             return maxValue;
;;;98           } // template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;99     
;;;100          template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat)
;;;101          {
;;;102            const Array<Array_Type> &array = mat.get_array();
;;;103    
;;;104            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;105              0, "Matrix::Sum", "Array<Type> is not valid");
;;;106    
;;;107            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;108    
;;;109            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;110              0, "Matrix::Sum", "Limits is not valid");
;;;111    
;;;112            Accumulator_Type sum = 0;
;;;113            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;114              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;115              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;116    
;;;117              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;118                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;119                sum += pMat[x];
;;;120              }
;;;121            }
;;;122    
;;;123            return sum;
;;;124          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;125    
;;;126          template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;127          {
;;;128            const Accumulator_Type sum = Sum<Array_Type,Accumulator_Type>(mat);
;;;129            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;130            const Array_Type mean = static_cast<Array_Type>(sum / numElements);
;;;131    
;;;132            return mean;
;;;133          } // template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;134    
;;;135          template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(
;;;136            const ConstArraySliceExpression<Array_Type> &mat,
;;;137            Accumulator_Type& mean,
;;;138            Accumulator_Type& var)
;;;139          {
;;;140            const Array<Array_Type> &array = mat.get_array();
;;;141    
;;;142            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;143              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Array<Type> is not valid");
;;;144    
;;;145            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;146    
;;;147            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;148              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Limits is not valid");
;;;149    
;;;150            Accumulator_Type sum = 0;
;;;151            Accumulator_Type sumSq = 0;
;;;152            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;153              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;154              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;155    
;;;156              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;157                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;158                const Accumulator_Type val = static_cast<Accumulator_Type>(pMat[x]);
;;;159                sum   += val;
;;;160                sumSq += val*val;
;;;161              }
;;;162            }
;;;163    
;;;164            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;165    
;;;166            mean = sum / numElements;                  // mean = E[x]
;;;167            var  = (sumSq / numElements) - (mean*mean);  // var  = E[x^2] - E[x]^2
;;;168    
;;;169            return RESULT_OK;
;;;170          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;171    
;;;172          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;173          {
;;;174            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;175          } // template<typename Type> Result Add(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;176    
;;;177          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;178          {
;;;179            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;180          }
;;;181    
;;;182          template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;183          {
;;;184            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;185          }
;;;186    
;;;187          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;188          {
;;;189            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;190          } // template<typename Type> Result Subtract(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;191    
;;;192          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;193          {
;;;194            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;195          }
;;;196    
;;;197          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;198          {
;;;199            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;200          }
;;;201    
;;;202          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;203          {
;;;204            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;205          } // template<typename Type> Result DotMultiply(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;206    
;;;207          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;208          {
;;;209            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;210          }
;;;211    
;;;212          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;213          {
;;;214            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;215          }
;;;216    
;;;217          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;218          {
;;;219            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;220          } // template<typename Type> Result DotDivide(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;221    
;;;222          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;223          {
;;;224            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;225          }
;;;226    
;;;227          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;228          {
;;;229            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;230          }
;;;231    
;;;232          template<typename InType, typename IntermediateType, typename OutType> Result SumOfAbsDiff(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;233          {
;;;234            return Elementwise::ApplyOperation<InType, Elementwise::SumOfAbsDiff<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;235          } // template<typename Type> Result DotDivide(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;236    
;;;237          template<typename InType, typename IntermediateType, typename OutType> Result SumOfAbsDiff(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;238          {
;;;239            return Elementwise::ApplyOperation<InType, Elementwise::SumOfAbsDiff<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;240          }
;;;241    
;;;242          template<typename InType, typename IntermediateType, typename OutType> Result SumOfAbsDiff(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;243          {
;;;244            return Elementwise::ApplyOperation<InType, Elementwise::SumOfAbsDiff<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;245          }
;;;246    
;;;247          template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;248          {
;;;249            return Elementwise::ApplyOperation<InType, Elementwise::Exp<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;250          } // template<typename Type> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;251    
;;;252          template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;253          {
;;;254            return Elementwise::ApplyOperation<InType, Elementwise::Sqrt<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;255          }
;;;256    
;;;257          template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;258          {
;;;259            const s32 in1Height = in1.get_size(0);
;;;260            const s32 in1Width = in1.get_size(1);
;;;261    
;;;262            const s32 in2Height = in2.get_size(0);
;;;263            const s32 in2Width = in2.get_size(1);
;;;264            const s32 in2Stride = in2.get_stride();
;;;265    
;;;266            AnkiConditionalErrorAndReturnValue(in1Width == in2Height,
;;;267              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;268    
;;;269            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2Width, out),
;;;270              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;271    
;;;272            for(s32 y1=0; y1<in1Height; y1++) {
;;;273              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;274              OutType * restrict pOut = out.Pointer(y1, 0);
;;;275    
;;;276              for(s32 x2=0; x2<in2Width; x2++) {
;;;277                const u8 * restrict pIn2 = reinterpret_cast<const u8*>(in2.Pointer(0, x2));
;;;278    
;;;279                OutType accumulator = 0;
;;;280    
;;;281                s32 y2;
;;;282                for(y2=0; y2<in2Height-3; y2+=4) {
;;;283                  const InType in1_0 = pIn1[y2];
;;;284                  const InType in1_1 = pIn1[y2+1];
;;;285                  const InType in1_2 = pIn1[y2+2];
;;;286                  const InType in1_3 = pIn1[y2+3];
;;;287    
;;;288                  const InType in2_0 = *reinterpret_cast<const InType*>(pIn2);
;;;289                  const InType in2_1 = *reinterpret_cast<const InType*>(pIn2 + in2Stride);
;;;290                  const InType in2_2 = *reinterpret_cast<const InType*>(pIn2 + 2*in2Stride);
;;;291                  const InType in2_3 = *reinterpret_cast<const InType*>(pIn2 + 3*in2Stride);
;;;292    
;;;293                  accumulator +=
;;;294                    in1_0 * in2_0 +
;;;295                    in1_1 * in2_1 +
;;;296                    in1_2 * in2_2 +
;;;297                    in1_3 * in2_3;
;;;298    
;;;299                  pIn2 += 4*in2Stride;
;;;300                }
;;;301    
;;;302                for(; y2<in2Height; y2++) {
;;;303                  accumulator += pIn1[y2] * (*reinterpret_cast<const InType*>(pIn2));
;;;304    
;;;305                  pIn2 += in2Stride;
;;;306                }
;;;307    
;;;308                pOut[x2] = accumulator;
;;;309              }
;;;310            }
;;;311    
;;;312            return RESULT_OK;
;;;313          } // template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;314    
;;;315          template<typename InType, typename OutType> NO_INLINE Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;316          {
;;;317            const s32 in1Height = in1.get_size(0);
;;;318            const s32 in1Width = in1.get_size(1);
;;;319    
;;;320            const s32 in2TransposedHeight = in2Transposed.get_size(0);
;;;321            const s32 in2TransposedWidth = in2Transposed.get_size(1);
;;;322    
;;;323            AnkiConditionalErrorAndReturnValue(in1Width == in2TransposedWidth,
;;;324              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;325    
;;;326            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2TransposedHeight, out),
;;;327              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;328    
;;;329            for(s32 y1=0; y1<in1Height; y1++)
;;;330            {
;;;331              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;332    
;;;333              for(s32 y2=0; y2<in2TransposedHeight; y2++) {
;;;334                const InType * restrict pIn2 = in2Transposed.Pointer(y2, 0);
;;;335    
;;;336                OutType accumulator = 0;
;;;337    
;;;338                s32 x;
;;;339                for(x=0; x<in2TransposedWidth-3; x+=4) {
;;;340                  const InType in1_0 = pIn1[x];
;;;341                  const InType in1_1 = pIn1[x+1];
;;;342                  const InType in1_2 = pIn1[x+2];
;;;343                  const InType in1_3 = pIn1[x+3];
;;;344    
;;;345                  const InType in2_0 = pIn2[x];
;;;346                  const InType in2_1 = pIn2[x+1];
;;;347                  const InType in2_2 = pIn2[x+2];
;;;348                  const InType in2_3 = pIn2[x+3];
;;;349    
;;;350                  accumulator +=
;;;351                    in1_0 * in2_0 +
;;;352                    in1_1 * in2_1 +
;;;353                    in1_2 * in2_2 +
;;;354                    in1_3 * in2_3;
;;;355                }
;;;356    
;;;357                for(; x<in2TransposedWidth; x++) {
;;;358                  accumulator += pIn1[x] * pIn2[x];
;;;359                }
;;;360    
;;;361                *out.Pointer(y1, y2) = accumulator;
;;;362              }
;;;363            }
;;;364    
;;;365            return RESULT_OK;
;;;366          } // template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;367    
;;;368          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;369            Array<Type> &A_L,       //!< Input A Matrix and Output lower-triangular L matrix
;;;370            Array<Type> &Bt_Xt,     //!< Input B-transpose matrix and Output X-transpose solution
;;;371            bool realCholesky,      //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;372            bool &numericalFailure  //!< If true, the solver failed because of numerical instability
;;;373            )
;;;374          {
;;;375            const s32 matrixHeight = A_L.get_size(0);
;;;376            const s32 numSamples = Bt_Xt.get_size(0);
;;;377    
;;;378            numericalFailure = false;
;;;379    
;;;380            AnkiConditionalErrorAndReturnValue(AreValid(A_L, Bt_Xt),
;;;381              RESULT_FAIL_INVALID_OBJECT, "CholeskyDecomposition", "Invalid objects");
;;;382    
;;;383            AnkiConditionalErrorAndReturnValue(matrixHeight == A_L.get_size(1),
;;;384              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "A_L is not square");
;;;385    
;;;386            AnkiConditionalErrorAndReturnValue(Bt_Xt.get_size(1) == matrixHeight,
;;;387              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "Xt and Bt are the wrong sizes");
;;;388    
;;;389            // TODO: check if symmetric and positive-definite
;;;390    
;;;391            const Type minStableValue = Anki::Embedded::Flags::numeric_limits<Type>::epsilon();
;;;392    
;;;393            for(s32 i = 0; i < matrixHeight; i++) {
;;;394              // First, compute the non-diagonal values
;;;395              // This uses the results from the diagonal inverse computation from previous iterations of i
;;;396              Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;397    
;;;398              for(s32 j = 0; j < i; j++) {
;;;399                Type * restrict pAL_yj = A_L.Pointer(j, 0);
;;;400    
;;;401                Type sum = pAL_yi[j];
;;;402                for(s32 k = 0; k < j; k++) {
;;;403                  const Type value1 = pAL_yi[k];
;;;404                  const Type value2 = pAL_yj[k];
;;;405                  sum -= value1*value2;
;;;406                }
;;;407    
;;;408                pAL_yi[j] = sum*pAL_yj[j];
;;;409              } // for(s32 j = 0; j < i; j++)
;;;410    
;;;411              // Second, compute the inverse of the diagonal
;;;412              {
;;;413                Type sum = pAL_yi[i];
;;;414                for(s32 k = 0; k < i; k++) {
;;;415                  const Type value = pAL_yi[k];
;;;416                  sum -= value*value;
;;;417                }
;;;418    
;;;419                if(sum < minStableValue) {
;;;420                  numericalFailure = true;
;;;421                  return RESULT_OK;
;;;422                }
;;;423    
;;;424                // TODO: change this f32 square root to f64 if Type==f64
;;;425                const Type sumRoot = static_cast<Type>(sqrtf(static_cast<f32>(sum)));
;;;426                pAL_yi[i] = static_cast<Type>(1) / sumRoot;
;;;427              }
;;;428            } // for(s32 i = 0; i < m; i++)
;;;429    
;;;430            // Solve L*y = b via forward substitution
;;;431            for(s32 i = 0; i < matrixHeight; i++) {
;;;432              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;433              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;434    
;;;435              for(s32 j = 0; j < numSamples; j++) {
;;;436                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;437    
;;;438                Type sum = pBX_yj[i];
;;;439                for(s32 k = 0; k < i; k++) {
;;;440                  const Type value1 = pAL_yi[k];
;;;441                  const Type value2 = pBX_yj[k];
;;;442                  sum -= value1*value2;
;;;443                }
;;;444    
;;;445                pBX_yj[i] = sum*pAL_yi[i];
;;;446              }
;;;447            }
;;;448    
;;;449            // Solve L'*X = Y via back substitution
;;;450            for(s32 i = matrixHeight-1; i >= 0; i--) {
;;;451              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;452              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;453    
;;;454              for(s32 j = 0; j < numSamples; j++) {
;;;455                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;456    
;;;457                Type sum = pBX_yj[i];
;;;458                for(s32 k = matrixHeight-1; k > i; k-- ) {
;;;459                  const Type value1 = A_L[k][i];
;;;460                  const Type value2 = pBX_yj[k];
;;;461                  sum -= value1*value2;
;;;462                }
;;;463    
;;;464                pBX_yj[i] = sum*pAL_yi[i];
;;;465              }
;;;466            }
;;;467    
;;;468            if(realCholesky) {
;;;469              // Invert the diagonal values of L, and set upper triangular to zero
;;;470              for(s32 i = 0; i < matrixHeight; i++) {
;;;471                Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;472    
;;;473                pAL_yi[i] = static_cast<Type>(1) / pAL_yi[i];
;;;474    
;;;475                for(s32 j = i+1; j < matrixHeight; j++) {
;;;476                  pAL_yi[j] = 0;
;;;477                }
;;;478              }
;;;479            }
;;;480    
;;;481            return RESULT_OK;
;;;482          } // SolveLeastSquaresWithCholesky()
;;;483    
;;;484          template<typename Type> NO_INLINE Result EstimateHomography(
;;;485            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;486            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;487            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;488            bool &numericalFailure, //!< Did the homography solver fail?
;;;489            MemoryStack scratch //!< Scratch memory
;;;490            )
;;;491          {
;;;492            const Type MAX_SOLVE_DISTANCE = static_cast<Type>(0.1);
;;;493    
;;;494            //BeginBenchmark("EstimateHomography_init");
;;;495    
;;;496            const s32 numPoints = originalPoints.get_size();
;;;497    
;;;498            AnkiConditionalErrorAndReturnValue(AreValid(originalPoints, transformedPoints, homography, scratch),
;;;499              RESULT_FAIL_INVALID_OBJECT, "EstimateHomography", "Invalid objects");
;;;500    
;;;501            AnkiConditionalErrorAndReturnValue(transformedPoints.get_size() == numPoints && numPoints >= 4,
;;;502              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "originalPoints and transformedPoints must be the same size, and have at least four points apiece.");
;;;503    
;;;504            AnkiConditionalErrorAndReturnValue(AreEqualSize(3, 3, homography),
;;;505              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "homography must be 3x3");
;;;506    
;;;507            homography.SetZero();
;;;508            homography[0][0] = 1;
;;;509            homography[1][1] = 1;
;;;510            homography[2][2] = 1;
;;;511    
;;;512            Array<Type> A(8, 2*numPoints, scratch);
;;;513            Array<Type> bt(1, 2*numPoints, scratch);
;;;514    
;;;515            const Point<Type> * const pOriginalPoints = originalPoints.Pointer(0);
;;;516            const Point<Type> * const pTransformedPoints = transformedPoints.Pointer(0);
;;;517    
;;;518            Type * restrict pBt = bt.Pointer(0,0);
;;;519    
;;;520            //EndBenchmark("EstimateHomography_init");
;;;521    
;;;522            //BeginBenchmark("EstimateHomography_a&b");
;;;523    
;;;524            for(s32 i=0; i<numPoints; i++) {
;;;525              Type * restrict A_y1 = A.Pointer(2*i, 0);
;;;526              Type * restrict A_y2 = A.Pointer(2*i + 1, 0);
;;;527    
;;;528              const Type xi = pOriginalPoints[i].x;
;;;529              const Type yi = pOriginalPoints[i].y;
;;;530    
;;;531              const Type xp = pTransformedPoints[i].x;
;;;532              const Type yp = pTransformedPoints[i].y;
;;;533    
;;;534              A_y1[0] = 0;  A_y1[1] = 0;  A_y1[2] = 0; A_y1[3] = -xi; A_y1[4] = -yi; A_y1[5] = -1; A_y1[6] = xi*yp;  A_y1[7] = yi*yp;
;;;535              A_y2[0] = xi; A_y2[1] = yi; A_y2[2] = 1; A_y2[3] = 0;   A_y2[4] = 0;   A_y2[5] = 0;  A_y2[6] = -xi*xp; A_y2[7] = -yi*xp;
;;;536    
;;;537              pBt[2*i] = -yp;
;;;538              pBt[2*i + 1] = xp;
;;;539            }
;;;540    
;;;541            //EndBenchmark("EstimateHomography_a&b");
;;;542    
;;;543            //BeginBenchmark("EstimateHomography_At");
;;;544    
;;;545            Array<Type> At(2*numPoints, 8, scratch);
;;;546    
;;;547            Matrix::Transpose(A, At);
;;;548    
;;;549            //EndBenchmark("EstimateHomography_At");
;;;550    
;;;551            //BeginBenchmark("EstimateHomography_AtA");
;;;552    
;;;553            Array<Type> AtA(8, 8, scratch, Flags::Buffer(false,false,false));
;;;554            Array<Type> Atb(8, 1, scratch, Flags::Buffer(false,false,false));
;;;555    
;;;556            Matrix::Multiply(At, A, AtA);
;;;557    
;;;558            //EndBenchmark("EstimateHomography_AtA");
;;;559    
;;;560            //BeginBenchmark("EstimateHomography_Atb");
;;;561    
;;;562            Matrix::MultiplyTranspose(At, bt, Atb);
;;;563    
;;;564            //EndBenchmark("EstimateHomography_Atb");
;;;565    
;;;566            //BeginBenchmark("EstimateHomography_transposeAtb");
;;;567    
;;;568            Array<Type> Atbt(1, 8, scratch);
;;;569    
;;;570            Matrix::Transpose(Atb, Atbt);
;;;571    
;;;572            //EndBenchmark("EstimateHomography_transposeAtb");
;;;573    
;;;574            //BeginBenchmark("EstimateHomography_cholesky");
;;;575    
;;;576            const Result choleskyResult = SolveLeastSquaresWithCholesky(AtA, Atbt, false, numericalFailure);
;;;577    
;;;578            AnkiConditionalErrorAndReturnValue(choleskyResult == RESULT_OK,
;;;579              choleskyResult, "EstimateHomography", "SolveLeastSquaresWithCholesky failed");
;;;580    
;;;581            if(numericalFailure){
;;;582              AnkiWarn("EstimateHomography", "numericalFailure");
;;;583              return RESULT_OK;
;;;584            }
;;;585    
;;;586            Type * restrict pAtbt = Atbt.Pointer(0,0);
;;;587    
;;;588            homography[0][0] = pAtbt[0]; homography[0][1] = pAtbt[1]; homography[0][2] = pAtbt[2];
;;;589            homography[1][0] = pAtbt[3]; homography[1][1] = pAtbt[4]; homography[1][2] = pAtbt[5];
;;;590            homography[2][0] = pAtbt[6]; homography[2][1] = pAtbt[7]; homography[2][2] = static_cast<Type>(1);
;;;591    
;;;592            // Check that the solution is fairly close
;;;593            // TODO: make work for numPoints != 4
;;;594            if(numPoints == 4) {
;;;595              Array<Type> point1(3,1,scratch);
;;;596              Array<Type> point1Warped(3,1,scratch);
;;;597              for(s32 iPoint=0; iPoint<numPoints; iPoint++) {
;;;598                point1[0][0] = originalPoints[iPoint].x;
;;;599                point1[1][0] = originalPoints[iPoint].y;
;;;600                point1[2][0] = 1;
;;;601    
;;;602                Matrix::Multiply(homography, point1, point1Warped);
;;;603                point1Warped[0][0] /= point1Warped[2][0];
;;;604                point1Warped[1][0] /= point1Warped[2][0];
;;;605    
;;;606                const Type distance = sqrtf(powf(static_cast<f32>(transformedPoints[iPoint].x) - static_cast<f32>(point1Warped[0][0]), 2.0f) + powf(static_cast<f32>(transformedPoints[iPoint].y) - static_cast<f32>(point1Warped[1][0]), 2.0f));
;;;607    
;;;608                if(distance > MAX_SOLVE_DISTANCE) {
;;;609                  AnkiWarn("EstimateHomography", "Poor solution precision");
;;;610    
;;;611                  numericalFailure = true;
;;;612    
;;;613                  homography.SetZero();
;;;614                  homography[0][0] = 1;
;;;615                  homography[1][1] = 1;
;;;616                  homography[2][2] = 1;
;;;617    
;;;618                  return RESULT_OK;
;;;619                }
;;;620              }
;;;621            }
;;;622            //EndBenchmark("EstimateHomography_cholesky");
;;;623    
;;;624            return RESULT_OK;
;;;625          } // EstimateHomography()
;;;626    
;;;627          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;628          {
;;;629            const s32 inHeight = in.get_size(0);
;;;630            const s32 inWidth = in.get_size(1);
;;;631    
;;;632            const s32 outHeight = out.get_size(0);
;;;633            const s32 outWidth = out.get_size(1);
;;;634    
;;;635            AnkiConditionalErrorAndReturnValue((inHeight*inWidth) == (outHeight*outWidth),
;;;636              RESULT_FAIL_INVALID_SIZE, "Reshape", "Input and Output matrices are incompatible sizes");
;;;637    
;;;638            s32 inIndexY = 0;
;;;639            s32 inIndexX = 0;
;;;640    
;;;641            if(isColumnMajor) {
;;;642              for(s32 y = 0; y < outHeight; y++)
;;;643              {
;;;644                OutType * const pOut = out.Pointer(y,0);
;;;645    
;;;646                for(s32 x = 0; x < outWidth; x++) {
;;;647                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;648    
;;;649                  pOut[x] = static_cast<OutType>(curIn);
;;;650    
;;;651                  inIndexY++;
;;;652                  if(inIndexY >= inHeight) {
;;;653                    inIndexY = 0;
;;;654                    inIndexX++;
;;;655                  }
;;;656                }
;;;657              }
;;;658            } else { // if(isColumnMajor)
;;;659              for(s32 y = 0; y < outHeight; y++)
;;;660              {
;;;661                OutType * const pOut = out.Pointer(y,0);
;;;662    
;;;663                for(s32 x = 0; x < outWidth; x++) {
;;;664                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;665    
;;;666                  pOut[x] = static_cast<OutType>(curIn);
;;;667    
;;;668                  inIndexX++;
;;;669                  if(inIndexX >= inWidth) {
;;;670                    inIndexX = 0;
;;;671                    inIndexY++;
;;;672                  }
;;;673                }
;;;674              }
;;;675            } // if(isColumnMajor) ... else
;;;676    
;;;677            return RESULT_OK;
;;;678          } // Reshape()
;;;679    
;;;680          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory)
;;;681          {
;;;682            Array<OutType> out(newHeight, newWidth, memory);
;;;683    
;;;684            Reshape<InType, OutType>(isColumnMajor, in, out);
;;;685    
;;;686            return out;
;;;687          }
;;;688    
;;;689          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;690          {
;;;691            AnkiConditionalErrorAndReturnValue(out.get_size(0) == 1,
;;;692              RESULT_FAIL_INVALID_SIZE, "Vectorize", "Output is not 1xN");
;;;693    
;;;694            return Reshape<InType, OutType>(isColumnMajor, in, out);
;;;695          }
;;;696    
;;;697          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory)
;;;698          {
;;;699            const s32 inHeight = in.get_size(0);
;;;700            const s32 inWidth = in.get_size(1);
;;;701    
;;;702            Array<OutType> out(1, inHeight*inWidth, memory);
;;;703    
;;;704            Vectorize<InType, OutType>(isColumnMajor, in, out);
;;;705    
;;;706            return out;
;;;707          }
;;;708    
;;;709          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out)
;;;710          {
;;;711            const s32 inHeight = in.get_size(0);
;;;712            const s32 inWidth = in.get_size(1);
;;;713    
;;;714            const s32 outStride = out.get_stride();
;;;715    
;;;716            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;717              RESULT_FAIL_INVALID_OBJECT, "Transpose", "Invalid objects");
;;;718    
;;;719            AnkiConditionalErrorAndReturnValue(AreEqualSize(in.get_size(1), in.get_size(0), out),
;;;720              RESULT_FAIL_INVALID_SIZE, "Transpose", "out is not the correct size");
;;;721    
;;;722            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;723              RESULT_FAIL_ALIASED_MEMORY, "Transpose", "in and out cannot be the same array");
;;;724    
;;;725            for(s32 yIn=0; yIn<inHeight; yIn++) {
;;;726              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;727              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0,yIn));
;;;728    
;;;729              s32 xIn;
;;;730              s32 outOffset0 = 0;
;;;731    
;;;732              for(xIn=0; xIn<inWidth-1; xIn+=2) {
;;;733                const InType in0 = pIn[xIn];
;;;734                const InType in1 = pIn[xIn+1];
;;;735    
;;;736                const s32 outOffset1 = outOffset0 + outStride;
;;;737    
;;;738                *reinterpret_cast<OutType*>(pOut + outOffset0) = static_cast<OutType>(in0);
;;;739                *reinterpret_cast<OutType*>(pOut + outOffset1) = static_cast<OutType>(in1);
;;;740    
;;;741                outOffset0 += 2*outStride;
;;;742              }
;;;743    
;;;744              for(; xIn<inWidth; xIn++) {
;;;745                *out.Pointer(xIn,yIn) = static_cast<OutType>(pIn[xIn]);
;;;746              }
;;;747            }
;;;748    
;;;749            return RESULT_OK;
;;;750          } // Transpose()
;;;751    
;;;752          template<typename InType, typename OutType> Result Rotate90(const Array<InType> &in, Array<OutType> &out)
;;;753          {
;;;754            const s32 arrWidth = in.get_size(1);
;;;755    
;;;756            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;757              RESULT_FAIL_INVALID_OBJECT, "Rotate90", "Invalid objects");
;;;758    
;;;759            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;760              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;761    
;;;762            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;763              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;764    
;;;765            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;766              RESULT_FAIL_ALIASED_MEMORY, "Rotate90", "in and out cannot be the same array");
;;;767    
;;;768            const s32 outStride = out.get_stride();
;;;769    
;;;770            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;771              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;772              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0, arrWidth-yIn-1));
;;;773    
;;;774              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;775                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;776    
;;;777                pOut += outStride;
;;;778              }
;;;779            }
;;;780    
;;;781            return RESULT_OK;
;;;782          } // Rotate90()
;;;783    
;;;784          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out)
;;;785          {
;;;786            const s32 arrWidth = in.get_size(1);
;;;787    
;;;788            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;789              RESULT_FAIL_INVALID_OBJECT, "Rotate180", "Invalid objects");
;;;790    
;;;791            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;792              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;793    
;;;794            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;795              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;796    
;;;797            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;798              RESULT_FAIL_ALIASED_MEMORY, "Rotate180", "in and out cannot be the same array");
;;;799    
;;;800            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;801              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;802              OutType * restrict pOut = out.Pointer(arrWidth-yIn-1, 0);
;;;803    
;;;804              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;805                pOut[arrWidth-xIn-1] = static_cast<OutType>(pIn[xIn]);
;;;806              }
;;;807            }
;;;808    
;;;809            return RESULT_OK;
;;;810          } // Rotate180()
;;;811    
;;;812          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out)
;;;813          {
;;;814            const s32 arrWidth = in.get_size(1);
;;;815    
;;;816            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;817              RESULT_FAIL_INVALID_OBJECT, "Rotate270", "Invalid objects");
;;;818    
;;;819            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;820              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;821    
;;;822            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;823              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;824    
;;;825            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;826              RESULT_FAIL_ALIASED_MEMORY, "Rotate270", "in and out cannot be the same array");
;;;827    
;;;828            const s32 outStride = out.get_stride();
;;;829    
;;;830            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;831              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;832              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(arrWidth-1, yIn));
;;;833    
;;;834              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;835                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;836    
;;;837                pOut -= outStride;
;;;838              }
;;;839            }
;;;840    
;;;841            return RESULT_OK;
;;;842          } // Rotate270()
;;;843    
;;;844          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;845          {
;;;846            const s32 arrWidth = arr.get_size(1);
;;;847    
;;;848            for(s32 x=0; x<arrWidth; x++) {
;;;849              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;850                const Type valueToInsert = arr[y][x];
;;;851    
;;;852                s32 holePosition = y;
;;;853    
;;;854                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;855                  arr[holePosition][x] = arr[holePosition-1][x];
;;;856                  holePosition--;
;;;857                }
;;;858    
;;;859                arr[holePosition][x] = valueToInsert;
;;;860              }
;;;861            } // for(s32 x=0; x<arrWidth; x++)
;;;862          } // InsertionSort_sortAscendingDimension0()
;;;863    
;;;864          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;865          {
;;;866            const s32 arrWidth = arr.get_size(1);
;;;867    
;;;868            for(s32 x=0; x<arrWidth; x++) {
;;;869              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;870                const Type valueToInsert = arr[y][x];
;;;871    
;;;872                s32 holePosition = y;
;;;873    
;;;874                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;875                  arr[holePosition][x] = arr[holePosition-1][x];
;;;876                  holePosition--;
;;;877                }
;;;878    
;;;879                arr[holePosition][x] = valueToInsert;
;;;880              }
;;;881            } // for(s32 x=0; x<arrWidth; x++)
;;;882          } // InsertionSort_sortDescendingDimension0
;;;883    
;;;884          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;885          {
;;;886            const s32 arrHeight = arr.get_size(0);
;;;887    
;;;888            for(s32 y=0; y<arrHeight; y++) {
;;;889              Type * const pArr = arr[y];
;;;890    
;;;891              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;892                const Type valueToInsert = pArr[x];
;;;893    
;;;894                s32 holePosition = x;
;;;895    
;;;896                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;897                  pArr[holePosition] = pArr[holePosition-1];
;;;898                  holePosition--;
;;;899                }
;;;900    
;;;901                pArr[holePosition] = valueToInsert;
;;;902              }
;;;903            } // for(s32 x=0; x<arrWidth; x++)
;;;904          } // InsertionSort_sortAscendingDimension1()
;;;905    
;;;906          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;907          {
;;;908            const s32 arrHeight = arr.get_size(0);
;;;909    
;;;910            for(s32 y=0; y<arrHeight; y++) {
;;;911              Type * const pArr = arr[y];
;;;912    
;;;913              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;914                const Type valueToInsert = pArr[x];
;;;915    
;;;916                s32 holePosition = x;
;;;917    
;;;918                while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;919                  pArr[holePosition] = pArr[holePosition-1];
;;;920                  holePosition--;
;;;921                }
;;;922    
;;;923                pArr[holePosition] = valueToInsert;
;;;924              }
;;;925            } // for(s32 x=0; x<arrWidth; x++)
;;;926          } // InsertionSort_sortAscendingDimension1()
;;;927    
;;;928          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;929          {
;;;930            const s32 arrWidth = arr.get_size(1);
;;;931    
;;;932            for(s32 x=0; x<arrWidth; x++) {
;;;933              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;934                const Type valueToInsert = arr[y][x];
;;;935                const s32 indexToInsert = indexes[y][x];
;;;936    
;;;937                s32 holePosition = y;
;;;938    
;;;939                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;940                  arr[holePosition][x] = arr[holePosition-1][x];
;;;941                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;942                  holePosition--;
;;;943                }
;;;944    
;;;945                arr[holePosition][x] = valueToInsert;
;;;946                indexes[holePosition][x] = indexToInsert;
;;;947              }
;;;948            } // for(s32 x=0; x<arrWidth; x++)
;;;949          } // InsertionSort_sortAscendingDimension0()
;;;950    
;;;951          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;952          {
;;;953            const s32 arrWidth = arr.get_size(1);
;;;954    
;;;955            for(s32 x=0; x<arrWidth; x++) {
;;;956              indexes[0][x] = 0;
;;;957    
;;;958              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;959                const Type valueToInsert = arr[y][x];
;;;960                const s32 indexToInsert = indexes[y][x];
;;;961    
;;;962                s32 holePosition = y;
;;;963    
;;;964                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;965                  arr[holePosition][x] = arr[holePosition-1][x];
;;;966                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;967                  holePosition--;
;;;968                }
;;;969    
;;;970                arr[holePosition][x] = valueToInsert;
;;;971                indexes[holePosition][x] = indexToInsert;
;;;972              }
;;;973            } // for(s32 x=0; x<arrWidth; x++)
;;;974          } // InsertionSort_sortDescendingDimension0()
;;;975    
;;;976          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;977          {
;;;978            const s32 arrHeight = arr.get_size(0);
;;;979    
;;;980            for(s32 y=0; y<arrHeight; y++) {
;;;981              Type * const pArr = arr[y];
;;;982              s32 * const pIndexes = indexes[y];
;;;983    
;;;984              pIndexes[0] = 0;
;;;985    
;;;986              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;987                const Type valueToInsert = pArr[x];
;;;988                const s32 indexToInsert = pIndexes[x];
;;;989    
;;;990                s32 holePosition = x;
;;;991    
;;;992                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;993                  pArr[holePosition] = pArr[holePosition-1];
;;;994                  pIndexes[holePosition] = pIndexes[holePosition-1];
;;;995                  holePosition--;
;;;996                }
;;;997    
;;;998                pArr[holePosition] = valueToInsert;
;;;999                pIndexes[holePosition] = indexToInsert;
;;;1000             }
;;;1001           } // for(s32 x=0; x<arrWidth; x++)
;;;1002         } // InsertionSort_sortAscendingDimension1()
;;;1003   
;;;1004         template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;1005         {
;;;1006           const s32 arrHeight = arr.get_size(0);
;;;1007   
;;;1008           for(s32 y=0; y<arrHeight; y++) {
;;;1009             Type * const pArr = arr[y];
;;;1010             s32 * const pIndexes = indexes[y];
;;;1011   
;;;1012             pIndexes[0] = 0;
;;;1013   
;;;1014             for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;1015               const Type valueToInsert = pArr[x];
;;;1016               const s32 indexToInsert = pIndexes[x];
;;;1017   
;;;1018               s32 holePosition = x;
;;;1019   
;;;1020               while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;1021                 pArr[holePosition] = pArr[holePosition-1];
;;;1022                 pIndexes[holePosition] = pIndexes[holePosition-1];
;;;1023                 holePosition--;
;;;1024               }
;;;1025   
;;;1026               pArr[holePosition] = valueToInsert;
;;;1027               pIndexes[holePosition] = indexToInsert;
;;;1028             }
;;;1029           } // for(s32 x=0; x<arrWidth; x++)
;;;1030         } // InsertionSort_sortDescendingDimension1()
;;;1031   
;;;1032         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1033         {
;;;1034           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1035             return;
;;;1036           }
;;;1037   
;;;1038           // Select the median value of the first, middle, and last elements as the pivot
;;;1039           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1040   
;;;1041           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1042   
;;;1043           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1044             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1045   
;;;1046           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1047             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1048   
;;;1049           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x))
;;;1050             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1051   
;;;1052           // Search from the beginning to before the moved pivot
;;;1053           s32 i = trueMinIndex;
;;;1054           s32 j = trueMaxIndex - 2;
;;;1055   
;;;1056           if(i >= j) {
;;;1057             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1058             // NOTE: This really means your insertionSortSize value is too low
;;;1059             return;
;;;1060           }
;;;1061   
;;;1062           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1063   
;;;1064           const Type pivot = *arr.Pointer(midIndex, x);
;;;1065   
;;;1066           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1067   
;;;1068           // Main partitioning loop
;;;1069           while(true) {
;;;1070             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1071             while(*arr.Pointer(i,x) < pivot) {
;;;1072               i++;
;;;1073             }
;;;1074   
;;;1075             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1076             while(*arr.Pointer(j,x) > pivot) {
;;;1077               j--;
;;;1078             }
;;;1079   
;;;1080             if(i < j) {
;;;1081               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1082               i++;
;;;1083               j--;
;;;1084             } else {
;;;1085               break;
;;;1086             }
;;;1087           }
;;;1088   
;;;1089           // Replace the pivot
;;;1090           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1091   
;;;1092           // Recurse
;;;1093           QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1094   
;;;1095           QuickSort_sortAscendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1096         } // QuickSort_sortAscendingDimension0
;;;1097   
;;;1098         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1099         {
;;;1100           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1101             return;
;;;1102           }
;;;1103   
;;;1104           // Select the median value of the first, middle, and last elements as the pivot
;;;1105           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1106   
;;;1107           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1108   
;;;1109           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1110             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1111   
;;;1112           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1113             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1114   
;;;1115           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x))
;;;1116             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1117   
;;;1118           // Search from the beginning to before the moved pivot
;;;1119           s32 i = trueMinIndex;
;;;1120           s32 j = trueMaxIndex - 2;
;;;1121   
;;;1122           if(i >= j) {
;;;1123             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1124             // NOTE: This really means your insertionSortSize value is too low
;;;1125             return;
;;;1126           }
;;;1127   
;;;1128           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1129   
;;;1130           const Type pivot = *arr.Pointer(midIndex, x);
;;;1131   
;;;1132           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1133   
;;;1134           // Main partitioning loop
;;;1135           while(true) {
;;;1136             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1137             while(*arr.Pointer(i,x) > pivot) {
;;;1138               i++;
;;;1139             }
;;;1140   
;;;1141             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1142             while(*arr.Pointer(j,x) < pivot) {
;;;1143               j--;
;;;1144             }
;;;1145   
;;;1146             if(i < j) {
;;;1147               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1148               i++;
;;;1149               j--;
;;;1150             } else {
;;;1151               break;
;;;1152             }
;;;1153           }
;;;1154   
;;;1155           // Replace the pivot
;;;1156           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1157   
;;;1158           // Recurse
;;;1159           QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1160   
;;;1161           QuickSort_sortDescendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1162         } // QuickSort_sortDescendingDimension0
;;;1163   
;;;1164         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1165         {
;;;1166           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1167             return;
;;;1168           }
;;;1169   
;;;1170           Type * restrict pArr = arr.Pointer(y,0);
;;;1171   
;;;1172           // Select the median value of the first, middle, and last elements as the pivot
;;;1173           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1174   
;;;1175           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1176   
;;;1177           if(pArr[midIndex] < pArr[trueMinIndex])
;;;1178             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1179   
;;;1180           if(pArr[trueMaxIndex] < pArr[trueMinIndex])
;;;1181             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1182   
;;;1183           if(pArr[trueMaxIndex] < pArr[midIndex])
;;;1184             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1185   
;;;1186           // Search from the beginning to before the moved pivot
;;;1187           s32 i = trueMinIndex;
;;;1188           s32 j = trueMaxIndex - 2;
;;;1189   
;;;1190           if(i >= j) {
;;;1191             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1192             // NOTE: This really means your insertionSortSize value is too low
;;;1193             return;
;;;1194           }
;;;1195   
;;;1196           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1197   
;;;1198           const Type pivot = pArr[midIndex];
;;;1199   
;;;1200           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1201   
;;;1202           // Main partitioning loop
;;;1203           while(true) {
;;;1204             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1205             while(pArr[i] < pivot) {
;;;1206               i++;
;;;1207             }
;;;1208   
;;;1209             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1210             while(pArr[j] > pivot) {
;;;1211               j--;
;;;1212             }
;;;1213   
;;;1214             if(i < j) {
;;;1215               Swap<Type>(pArr[i], pArr[j]);
;;;1216               i++;
;;;1217               j--;
;;;1218             } else {
;;;1219               break;
;;;1220             }
;;;1221           }
;;;1222   
;;;1223           // Replace the pivot
;;;1224           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1225   
;;;1226           // Recurse
;;;1227           QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1228   
;;;1229           QuickSort_sortAscendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1230         } // QuickSort_sortAscendingDimension1
;;;1231   
;;;1232         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1233         {
;;;1234           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1235             return;
;;;1236           }
;;;1237   
;;;1238           Type * restrict pArr = arr.Pointer(y,0);
;;;1239   
;;;1240           // Select the median value of the first, middle, and last elements as the pivot
;;;1241           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1242   
;;;1243           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1244   
;;;1245           if(pArr[midIndex] < pArr[trueMaxIndex])
;;;1246             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1247   
;;;1248           if(pArr[trueMinIndex] < pArr[trueMaxIndex])
;;;1249             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1250   
;;;1251           if(pArr[trueMinIndex] < pArr[midIndex])
;;;1252             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1253   
;;;1254           // Search from the beginning to before the moved pivot
;;;1255           s32 i = trueMinIndex;
;;;1256           s32 j = trueMaxIndex - 2;
;;;1257   
;;;1258           if(i >= j) {
;;;1259             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1260             // NOTE: This really means your insertionSortSize value is too low
;;;1261             return;
;;;1262           }
;;;1263   
;;;1264           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1265   
;;;1266           const Type pivot = pArr[midIndex];
;;;1267   
;;;1268           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1269   
;;;1270           // Main partitioning loop
;;;1271           while(true) {
;;;1272             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1273             while(pArr[i] > pivot) {
;;;1274               i++;
;;;1275             }
;;;1276   
;;;1277             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1278             while(pArr[j] < pivot) {
;;;1279               j--;
;;;1280             }
;;;1281   
;;;1282             if(i < j) {
;;;1283               Swap<Type>(pArr[i], pArr[j]);
;;;1284               i++;
;;;1285               j--;
;;;1286             } else {
;;;1287               break;
;;;1288             }
;;;1289           }
;;;1290   
;;;1291           // Replace the pivot
;;;1292           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1293   
;;;1294           // Recurse
;;;1295           QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1296   
;;;1297           QuickSort_sortDescendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1298         } // QuickSort_sortDescendingDimension1
;;;1299   
;;;1300         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1301         {
;;;1302           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1303             return;
;;;1304           }
;;;1305   
;;;1306           // Select the median value of the first, middle, and last elements as the pivot
;;;1307           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1308   
;;;1309           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1310   
;;;1311           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1312             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1313             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1314           }
;;;1315   
;;;1316           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1317             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1318             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1319           }
;;;1320   
;;;1321           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1322             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1323             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(midIndex, x));
;;;1324           }
;;;1325   
;;;1326           // Search from the beginning to before the moved pivot
;;;1327           s32 i = trueMinIndex;
;;;1328           s32 j = trueMaxIndex - 2;
;;;1329   
;;;1330           if(i >= j) {
;;;1331             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1332             // NOTE: This really means your insertionSortSize value is too low
;;;1333             return;
;;;1334           }
;;;1335   
;;;1336           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1337   
;;;1338           const Type pivot = *arr.Pointer(midIndex, x);
;;;1339   
;;;1340           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1341           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1342   
;;;1343           // Main partitioning loop
;;;1344           while(true) {
;;;1345             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1346             while(*arr.Pointer(i,x) < pivot) {
;;;1347               i++;
;;;1348             }
;;;1349   
;;;1350             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1351             while(*arr.Pointer(j,x) > pivot) {
;;;1352               j--;
;;;1353             }
;;;1354   
;;;1355             if(i < j) {
;;;1356               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1357               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1358               i++;
;;;1359               j--;
;;;1360             } else {
;;;1361               break;
;;;1362             }
;;;1363           }
;;;1364   
;;;1365           // Replace the pivot
;;;1366           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1367           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1368   
;;;1369           // Recurse
;;;1370           QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1371   
;;;1372           QuickSort_sortAscendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1373         } // QuickSort_sortAscendingDimension0
;;;1374   
;;;1375         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1376         {
;;;1377           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1378             return;
;;;1379           }
;;;1380   
;;;1381           // Select the median value of the first, middle, and last elements as the pivot
;;;1382           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1383   
;;;1384           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1385   
;;;1386           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1387             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1388             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1389           }
;;;1390   
;;;1391           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1392             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1393             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1394           }
;;;1395   
;;;1396           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1397             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1398             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(midIndex, x));
;;;1399           }
;;;1400   
;;;1401           // Search from the beginning to before the moved pivot
;;;1402           s32 i = trueMinIndex;
;;;1403           s32 j = trueMaxIndex - 2;
;;;1404   
;;;1405           if(i >= j) {
;;;1406             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1407             // NOTE: This really means your insertionSortSize value is too low
;;;1408             return;
;;;1409           }
;;;1410   
;;;1411           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1412   
;;;1413           const Type pivot = *arr.Pointer(midIndex, x);
;;;1414   
;;;1415           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1416           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1417   
;;;1418           // Main partitioning loop
;;;1419           while(true) {
;;;1420             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1421             while(*arr.Pointer(i,x) > pivot) {
;;;1422               i++;
;;;1423             }
;;;1424   
;;;1425             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1426             while(*arr.Pointer(j,x) < pivot) {
;;;1427               j--;
;;;1428             }
;;;1429   
;;;1430             if(i < j) {
;;;1431               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1432               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1433               i++;
;;;1434               j--;
;;;1435             } else {
;;;1436               break;
;;;1437             }
;;;1438           }
;;;1439   
;;;1440           // Replace the pivot
;;;1441           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1442           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1443   
;;;1444           // Recurse
;;;1445           QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1446   
;;;1447           QuickSort_sortDescendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1448         } // QuickSort_sortDescendingDimension0
;;;1449   
;;;1450         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1451         {
;;;1452           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1453             return;
;;;1454           }
;;;1455   
;;;1456           Type * restrict pArr = arr.Pointer(y,0);
;;;1457           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1458   
;;;1459           // Select the median value of the first, middle, and last elements as the pivot
;;;1460           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1461   
;;;1462           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1463   
;;;1464           if(pArr[midIndex] < pArr[trueMinIndex]) {
;;;1465             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1466             Swap<s32>(pIndexes[midIndex], pIndexes[trueMinIndex]);
;;;1467           }
;;;1468   
;;;1469           if(pArr[trueMaxIndex] < pArr[trueMinIndex]) {
;;;1470             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1471             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[trueMinIndex]);
;;;1472           }
;;;1473   
;;;1474           if(pArr[trueMaxIndex] < pArr[midIndex]) {
;;;1475             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1476             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[midIndex]);
;;;1477           }
;;;1478   
;;;1479           // Search from the beginning to before the moved pivot
;;;1480           s32 i = trueMinIndex;
;;;1481           s32 j = trueMaxIndex - 2;
;;;1482   
;;;1483           if(i >= j) {
;;;1484             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1485             // NOTE: This really means your insertionSortSize value is too low
;;;1486             return;
;;;1487           }
;;;1488   
;;;1489           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1490   
;;;1491           const Type pivot = pArr[midIndex];
;;;1492   
;;;1493           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1494           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1495   
;;;1496           // Main partitioning loop
;;;1497           while(true) {
;;;1498             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1499             while(pArr[i] < pivot) {
;;;1500               i++;
;;;1501             }
;;;1502   
;;;1503             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1504             while(pArr[j] > pivot) {
;;;1505               j--;
;;;1506             }
;;;1507   
;;;1508             if(i < j) {
;;;1509               Swap<Type>(pArr[i], pArr[j]);
;;;1510               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1511               i++;
;;;1512               j--;
;;;1513             } else {
;;;1514               break;
;;;1515             }
;;;1516           }
;;;1517   
;;;1518           // Replace the pivot
;;;1519           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1520           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1521   
;;;1522           // Recurse
;;;1523           QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1524   
;;;1525           QuickSort_sortAscendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1526         } // QuickSort_sortAscendingDimension1
;;;1527   
;;;1528         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1529         {
;;;1530           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1531             return;
;;;1532           }
;;;1533   
;;;1534           Type * restrict pArr = arr.Pointer(y,0);
;;;1535           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1536   
;;;1537           // Select the median value of the first, middle, and last elements as the pivot
;;;1538           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1539   
;;;1540           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1541   
;;;1542           if(pArr[midIndex] < pArr[trueMaxIndex]) {
;;;1543             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1544             Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex]);
;;;1545           }
;;;1546   
;;;1547           if(pArr[trueMinIndex] < pArr[trueMaxIndex]) {
;;;1548             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1549             Swap<s32>(pIndexes[trueMinIndex], pIndexes[trueMaxIndex]);
;;;1550           }
;;;1551   
;;;1552           if(pArr[trueMinIndex] < pArr[midIndex]) {
;;;1553             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1554             Swap<s32>(pIndexes[trueMinIndex], pIndexes[midIndex]);
;;;1555           }
;;;1556   
;;;1557           // Search from the beginning to before the moved pivot
;;;1558           s32 i = trueMinIndex;
;;;1559           s32 j = trueMaxIndex - 2;
;;;1560   
;;;1561           if(i >= j) {
;;;1562             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1563             // NOTE: This really means your insertionSortSize value is too low
;;;1564             return;
;;;1565           }
;;;1566   
;;;1567           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1568   
;;;1569           const Type pivot = pArr[midIndex];
;;;1570   
;;;1571           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1572           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1573   
;;;1574           // Main partitioning loop
;;;1575           while(true) {
;;;1576             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1577             while(pArr[i] > pivot) {
;;;1578               i++;
;;;1579             }
;;;1580   
;;;1581             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1582             while(pArr[j] < pivot) {
;;;1583               j--;
;;;1584             }
;;;1585   
;;;1586             if(i < j) {
;;;1587               Swap<Type>(pArr[i], pArr[j]);
;;;1588               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1589               i++;
;;;1590               j--;
;;;1591             } else {
;;;1592               break;
;;;1593             }
;;;1594           }
;;;1595   
;;;1596           // Replace the pivot
;;;1597           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1598           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1599   
;;;1600           // Recurse
;;;1601           QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1602   
;;;1603           QuickSort_sortDescendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1604         } // QuickSort_sortDescendingDimension1
;;;1605   
;;;1606         template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1607         {
;;;1608           // const s32 arrHeight = arr.get_size(0);
;;;1609           // const s32 arrWidth = arr.get_size(1);
;;;1610   
;;;1611           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1612             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1613   
;;;1614           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1615             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1616   
;;;1617           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1618           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1619   
;;;1620           if(sortWhichDimension == 0) {
;;;1621             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1622             if(sortAscending) {
;;;1623               InsertionSort_sortAscendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1624             } else { // if(sortAscending)
;;;1625               InsertionSort_sortDescendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1626             } // if(sortAscending) ... else
;;;1627           } else { // sortWhichDimension == 1
;;;1628             if(sortAscending) {
;;;1629               InsertionSort_sortAscendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1630             } else { // if(sortAscending)
;;;1631               InsertionSort_sortDescendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1632             } // if(sortAscending) ... else
;;;1633           } // if(sortWhichDimension == 0) ... else
;;;1634   
;;;1635           return RESULT_OK;
;;;1636         } // InsertionSort()
;;;1637   
;;;1638         template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1639         {
;;;1640           const s32 arrHeight = arr.get_size(0);
;;;1641           const s32 arrWidth = arr.get_size(1);
;;;1642   
;;;1643           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1644             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1645   
;;;1646           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1647             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1648   
;;;1649           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1650             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1651   
;;;1652           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1653           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1654   
;;;1655           if(sortWhichDimension == 0) {
;;;1656             for(s32 y=0; y<arrHeight; y++) {
;;;1657               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1658               for(s32 x=0; x<arrWidth; x++) {
;;;1659                 pIndexes[x] = y;
;;;1660               }
;;;1661             }
;;;1662   
;;;1663             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1664             if(sortAscending) {
;;;1665               InsertionSort_sortAscendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1666             } else { // if(sortAscending)
;;;1667               InsertionSort_sortDescendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1668             } // if(sortAscending) ... else
;;;1669           } else { // sortWhichDimension == 1
;;;1670             for(s32 y=0; y<arrHeight; y++) {
;;;1671               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1672               for(s32 x=0; x<arrWidth; x++) {
;;;1673                 pIndexes[x] = x;
;;;1674               }
;;;1675             }
;;;1676   
;;;1677             if(sortAscending) {
;;;1678               InsertionSort_sortAscendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1679             } else { // if(sortAscending)
;;;1680               InsertionSort_sortDescendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1681             } // if(sortAscending) ... else
;;;1682           } // if(sortWhichDimension == 0) ... else
;;;1683   
;;;1684           return RESULT_OK;
;;;1685         } // InsertionSort()
;;;1686   
;;;1687         template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1688         {
;;;1689           const s32 arrHeight = arr.get_size(0);
;;;1690           const s32 arrWidth = arr.get_size(1);
;;;1691   
;;;1692           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1693             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1694   
;;;1695           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1696             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1697   
;;;1698           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1699             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1700   
;;;1701           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1702           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1703   
;;;1704           if(sortWhichDimension == 0) {
;;;1705             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1706             if(sortAscending) {
;;;1707               for(s32 x=0; x<arrWidth; x++) {
;;;1708                 QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1709               }
;;;1710   
;;;1711               if(insertionSortSize > 1)
;;;1712                 InsertionSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1713             } else { // if(sortAscending)
;;;1714               for(s32 x=0; x<arrWidth; x++) {
;;;1715                 QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1716               }
;;;1717   
;;;1718               if(insertionSortSize > 1)
;;;1719                 InsertionSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1720             } // if(sortAscending) ... else
;;;1721           } else { // sortWhichDimension == 1
;;;1722             if(sortAscending) {
;;;1723               for(s32 y=0; y<arrHeight; y++) {
;;;1724                 QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1725               }
;;;1726   
;;;1727               if(insertionSortSize > 1)
;;;1728                 InsertionSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1729             } else { // if(sortAscending)
;;;1730               for(s32 y=0; y<arrHeight; y++) {
;;;1731                 QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1732               }
;;;1733   
;;;1734               if(insertionSortSize > 1)
;;;1735                 InsertionSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1736             } // if(sortAscending) ... else
;;;1737           } // if(sortWhichDimension == 0) ... else
;;;1738   
;;;1739           return RESULT_OK;
;;;1740         } // QuickSort()
;;;1741   
;;;1742         template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1743         {
;;;1744           const s32 arrHeight = arr.get_size(0);
;;;1745           const s32 arrWidth = arr.get_size(1);
;;;1746   
;;;1747           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1748             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1749   
;;;1750           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1751             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1752   
;;;1753           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1754             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1755   
;;;1756           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1757             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1758   
;;;1759           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1760           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1761   
;;;1762           if(sortWhichDimension == 0) {
;;;1763             for(s32 y=0; y<arrHeight; y++) {
;;;1764               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1765               for(s32 x=0; x<arrWidth; x++) {
;;;1766                 pIndexes[x] = y;
;;;1767               }
;;;1768             }
;;;1769   
;;;1770             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1771             if(sortAscending) {
;;;1772               for(s32 x=0; x<arrWidth; x++) {
;;;1773                 QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1774               }
;;;1775   
;;;1776               if(insertionSortSize > 1)
;;;1777                 InsertionSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1778             } else { // if(sortAscending)
;;;1779               for(s32 x=0; x<arrWidth; x++) {
;;;1780                 QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1781               }
;;;1782   
;;;1783               if(insertionSortSize > 1)
;;;1784                 InsertionSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1785             } // if(sortAscending) ... else
;;;1786           } else { // sortWhichDimension == 1
;;;1787             for(s32 y=0; y<arrHeight; y++) {
;;;1788               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1789               for(s32 x=0; x<arrWidth; x++) {
;;;1790                 pIndexes[x] = x;
;;;1791               }
;;;1792             }
;;;1793   
;;;1794             if(sortAscending) {
;;;1795               for(s32 y=0; y<arrHeight; y++) {
;;;1796                 QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1797               }
;;;1798   
;;;1799               if(insertionSortSize > 1)
;;;1800                 InsertionSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1801             } else { // if(sortAscending)
;;;1802               for(s32 y=0; y<arrHeight; y++) {
;;;1803                 QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1804               }
;;;1805   
;;;1806               if(insertionSortSize > 1)
;;;1807                 InsertionSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1808             } // if(sortAscending) ... else
;;;1809           } // if(sortWhichDimension == 0) ... else
;;;1810   
;;;1811           return RESULT_OK;
;;;1812         } // QuickSort()
;;;1813   
;;;1814         template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1815         {
;;;1816           AnkiConditionalErrorAndReturnValue(arr.get_size(0) == arr.get_size(1),
;;;1817             RESULT_FAIL_INVALID_SIZE, "MakeSymmetric", "Input array must be square");
;;;1818   
;;;1819           const s32 arrHeight = arr.get_size(0);
;;;1820           for(s32 y = 0; y < arrHeight; y++)
;;;1821           {
;;;1822             const s32 x0 = lowerToUpper ? (y+1)     : 0;
;;;1823             const s32 x1 = lowerToUpper ? arrHeight : y;
;;;1824   
;;;1825             for(s32 x = x0; x < x1; x++) {
;;;1826               *arr.Pointer(y,x) = *arr.Pointer(x,y);
;;;1827             }
;;;1828           }
;;;1829   
;;;1830           return RESULT_OK;
;;;1831         } // template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1832   
;;;1833         namespace Elementwise
;;;1834         {
;;;1835           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1836           {
;;;1837             const Array<InType> &in1Array = in1.get_array();
;;;1838             const Array<InType> &in2Array = in2.get_array();
;;;1839             Array<OutType> &out1Array = out.get_array();
;;;1840   
;;;1841             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, in2Array, out1Array),
;;;1842               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1843   
;;;1844             ArraySliceLimits_in2_out1<s32> limits(
;;;1845               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1846               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1847               out.get_ySlice(), out.get_xSlice());
;;;1848   
;;;1849             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1850               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1851   
;;;1852             if(limits.isSimpleIteration) {
;;;1853               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1854   
;;;1855               for(s32 y=0; y<limits.ySize; y++) {
;;;1856                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1857                 const InType * const pIn2 = in2Array.Pointer(limits.in2Y, 0);
;;;1858                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1859   
;;;1860                 limits.OuterIncrementTop();
;;;1861   
;;;1862                 for(s32 x=0; x<limits.xSize; x++) {
;;;1863                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], pIn2[limits.in2X]);
;;;1864   
;;;1865                   limits.in1X += limits.in1_xInnerIncrement;
;;;1866                   limits.in2X += limits.in2_xInnerIncrement;
;;;1867                   limits.out1X += limits.out1_xInnerIncrement;
;;;1868                 }
;;;1869   
;;;1870                 limits.OuterIncrementBottom();
;;;1871               }
;;;1872             } else { // if(limits.isSimpleIteration)
;;;1873               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1874   
;;;1875               for(s32 y=0; y<limits.ySize; y++) {
;;;1876                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1877   
;;;1878                 limits.OuterIncrementTop();
;;;1879   
;;;1880                 for(s32 x=0; x<limits.xSize; x++) {
;;;1881                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1882                   const InType valIn2 = *in2Array.Pointer(limits.in2Y, limits.in2X);
;;;1883   
;;;1884                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, valIn2);
;;;1885   
;;;1886                   limits.in1X += limits.in1_xInnerIncrement;
;;;1887                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1888                   limits.in2X += limits.in2_xInnerIncrement;
;;;1889                   limits.in2Y += limits.in2_yInnerIncrement;
;;;1890                   limits.out1X += limits.out1_xInnerIncrement;
;;;1891                 }
;;;1892   
;;;1893                 limits.OuterIncrementBottom();
;;;1894               }
;;;1895             } //   if(limits.isSimpleIteration)  ... else
;;;1896   
;;;1897             return RESULT_OK;
;;;1898           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1899   
;;;1900           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1901           {
;;;1902             const Array<InType> &in1Array = in1.get_array();
;;;1903             Array<OutType> &out1Array = out.get_array();
;;;1904   
;;;1905             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, out1Array),
;;;1906               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1907   
;;;1908             ArraySliceLimits_in1_out1<s32> limits(
;;;1909               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1910               out.get_ySlice(), out.get_xSlice());
;;;1911   
;;;1912             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1913               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1914   
;;;1915             if(limits.isSimpleIteration) {
;;;1916               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1917   
;;;1918               for(s32 y=0; y<limits.ySize; y++) {
;;;1919                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1920                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1921   
;;;1922                 limits.OuterIncrementTop();
;;;1923   
;;;1924                 for(s32 x=0; x<limits.xSize; x++) {
;;;1925                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], value2);
;;;1926   
;;;1927                   limits.in1X += limits.in1_xInnerIncrement;
;;;1928                   limits.out1X += limits.out1_xInnerIncrement;
;;;1929                 }
;;;1930   
;;;1931                 limits.OuterIncrementBottom();
;;;1932               }
;;;1933             } else { // if(limits.isSimpleIteration)
;;;1934               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1935   
;;;1936               for(s32 y=0; y<limits.ySize; y++) {
;;;1937                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1938   
;;;1939                 limits.OuterIncrementTop();
;;;1940   
;;;1941                 for(s32 x=0; x<limits.xSize; x++) {
;;;1942                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1943   
;;;1944                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, value2);
;;;1945   
;;;1946                   limits.in1X += limits.in1_xInnerIncrement;
;;;1947                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1948                   limits.out1X += limits.out1_xInnerIncrement;
;;;1949                 }
;;;1950   
;;;1951                 limits.OuterIncrementBottom();
;;;1952               }
;;;1953             } //   if(limits.isSimpleIteration)  ... else
;;;1954   
;;;1955             return RESULT_OK;
;;;1956           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1957   
;;;1958           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1959           {
;;;1960             const Array<InType> &in2Array = in2.get_array();
;;;1961             Array<OutType> &out1Array = out.get_array();
;;;1962   
;;;1963             AnkiConditionalErrorAndReturnValue(AreValid(in2Array, out1Array),
;;;1964               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1965   
;;;1966             ArraySliceLimits_in1_out1<s32> limits(
;;;1967               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1968               out.get_ySlice(), out.get_xSlice());
;;;1969   
;;;1970             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1971               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1972   
;;;1973             if(limits.isSimpleIteration) {
;;;1974               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1975   
;;;1976               for(s32 y=0; y<limits.ySize; y++) {
;;;1977                 const InType * const pIn2 = in2Array.Pointer(limits.in1Y, 0);
;;;1978                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1979   
;;;1980                 limits.OuterIncrementTop();
;;;1981   
;;;1982                 for(s32 x=0; x<limits.xSize; x++) {
;;;1983                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, pIn2[limits.in1X]);
;;;1984   
;;;1985                   limits.in1X += limits.in1_xInnerIncrement;
;;;1986                   limits.out1X += limits.out1_xInnerIncrement;
;;;1987                 }
;;;1988   
;;;1989                 limits.OuterIncrementBottom();
;;;1990               }
;;;1991             } else { // if(limits.isSimpleIteration)
;;;1992               // If either input is transposed, then we will do an inefficent loop iteration
;;;1993   
;;;1994               for(s32 y=0; y<limits.ySize; y++) {
;;;1995                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1996   
;;;1997                 limits.OuterIncrementTop();
;;;1998   
;;;1999                 for(s32 x=0; x<limits.xSize; x++) {
;;;2000                   const InType valIn2 = *in2Array.Pointer(limits.in1Y, limits.in1X);
;;;2001   
;;;2002                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, valIn2);
;;;2003   
;;;2004                   limits.in1X += limits.in1_xInnerIncrement;
;;;2005                   limits.in1Y += limits.in1_yInnerIncrement;
;;;2006                   limits.out1X += limits.out1_xInnerIncrement;
;;;2007                 }
;;;2008   
;;;2009                 limits.OuterIncrementBottom();
;;;2010               }
;;;2011             } //   if(limits.isSimpleIteration)  ... else
;;;2012   
;;;2013             return RESULT_OK;
;;;2014           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;2015         } // namespace Elementwise
;;;2016       } // namespace Matrix
;;;2017     } // namespace Embedded
;;;2018   } // namespace Anki
;;;2019   
;;;2020   #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;19     
;;;20     #include "anki/common/shared/utilities_shared.h"
;;;1      /**
;;;2      File: utilities_shared.h
;;;3      Author: Kevin Yoon
;;;4      Created: 2014
;;;5      
;;;6      Copyright Anki, Inc. 2014
;;;7      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;8      **/
;;;9      
;;;10     #ifndef _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;11     #define _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;12     
;;;13     #include <stdarg.h>
;;;1      /* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
;;;14     
;;;15     namespace Anki
;;;16     {
;;;17       // For printing throughout Coretech libraries.
;;;18       // Calls printf() by default, but can be made to use an externally
;;;19       // defined function via SetCoreTechPrintFunctionPtr().
;;;20       int CoreTechPrint(const char * format, ...);
;;;21       int CoreTechPrint(const char * format, va_list argList);
;;;22     
;;;23       // Sets the function pointer that CoreTechPrint() uses.
;;;24       // Convenient for on-robot print which could be more complex
;;;25       // than just printf().
;;;26       void SetCoreTechPrintFunctionPtr( int (*fp)(const char * format, va_list) );
;;;27     } // namespace Anki
;;;28     
;;;29     #endif // _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26     #if 0
;;;27     #pragma mark --- 2D Point Implementations ---
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
;;;34         template<typename Type> Point<Type>::Point(const Type x, const Type y)
;;;35           : x(x), y(y)
;;;36         {
;;;37         }
;;;38     
;;;39         template<typename Type> Point<Type>::Point(const Point<Type>& pt)
;;;40           : x(pt.x), y(pt.y)
;;;41         {
;;;42         }
;;;43     
;;;44     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;45         template<typename Type> Point<Type>::Point(const cv::Point_<Type>& pt)
;;;46           : x(pt.x), y(pt.y)
;;;47         {
;;;48         }
;;;49     #endif
;;;50     
;;;51     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;52         template<typename Type> cv::Point_<Type> Point<Type>::get_CvPoint_() const
;;;53         {
;;;54           return cv::Point_<Type>(x,y);
;;;55         }
;;;56     #endif
;;;57     
;;;58         template<typename Type> template<typename InType> void Point<Type>::SetCast(const Point<InType> &in)
;;;59         {
;;;60           this->x = saturate_cast<Type>(in.x);
;;;61           this->y = saturate_cast<Type>(in.y);
;;;62         }
;;;63     
;;;64         template<typename Type> void Point<Type>::Print() const
;;;65         {
;;;66           CoreTechPrint("(%d,%d) ", this->x, this->y);
;;;67         }
;;;68     
;;;69         template<typename Type> bool Point<Type>::operator== (const Point<Type> &point2) const
;;;70         {
;;;71           if(this->x == point2.x && this->y == point2.y)
;;;72             return true;
;;;73     
;;;74           return false;
;;;75         }
;;;76     
;;;77         template<typename Type> Point<Type> Point<Type>::operator+ (const Point<Type> &point2) const
;;;78         {
;;;79           return Point<Type>(this->x+point2.x, this->y+point2.y);
;;;80         }
;;;81     
;;;82         template<typename Type> Point<Type> Point<Type>::operator- (const Point<Type> &point2) const
;;;83         {
;;;84           return Point<Type>(this->x-point2.x, this->y-point2.y);
;;;85         }
;;;86     
;;;87         template<typename Type> Point<Type> Point<Type>::operator- () const
;;;88         {
;;;89           return Point<Type>(-this->x, -this->y);
;;;90         }
;;;91     
;;;92         template<typename Type> Point<Type>& Point<Type>::operator*= (const Type value)
;;;93         {
;;;94           this->x *= value;
;;;95           this->y *= value;
;;;96           return *this;
;;;97         }
;;;98     
;;;99         template<typename Type> Point<Type>& Point<Type>::operator-= (const Type value)
;;;100        {
;;;101          this->x -= value;
;;;102          this->y -= value;
;;;103          return *this;
;;;104        }
;;;105    
;;;106        template<typename Type> Point<Type>& Point<Type>::operator+= (const Point<Type> &point2)
;;;107        {
;;;108          this->x += point2.x;
;;;109          this->y += point2.y;
;;;110          return *this;
;;;111        }
;;;112    
;;;113        template<typename Type> Point<Type>& Point<Type>::operator-= (const Point<Type> &point2)
;;;114        {
;;;115          this->x -= point2.x;
;;;116          this->y -= point2.y;
;;;117          return *this;
;;;118        }
;;;119    
;;;120        template<typename Type> inline Point<Type>& Point<Type>::operator= (const Point<Type> &point2)
;;;121        {
;;;122          this->x = point2.x;
;;;123          this->y = point2.y;
;;;124    
;;;125          return *this;
;;;126        }
;;;127    
;;;128        template<typename Type> f32 Point<Type>::Dist(const Point<Type> &point2) const
;;;129        {
;;;130          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) + (this->y - point2.y)*(this->y - point2.y));
;;;131        }
;;;132    
;;;133        template<typename Type> f32 Point<Type>::Length() const
;;;134        {
;;;135          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y)));
;;;136        }
;;;137    
;;;138        // #pragma mark --- Point Specializations ---
;;;139        template<> void Point<f32>::Print() const;
;;;140        template<> void Point<f64>::Print() const;
;;;141    
;;;142    #if 0
;;;143    #pragma mark --- 3D Point Implementations ---
;;;144    #endif
;;;145    
;;;146        template<typename Type> Point3<Type>::Point3()
;;;147          : x(static_cast<Type>(0)), y(static_cast<Type>(0)), z(static_cast<Type>(0))
;;;148        {
;;;149        }
;;;150    
;;;151        template<typename Type> Point3<Type>::Point3(const Type x, const Type y, const Type z)
;;;152          : x(x), y(y), z(z)
;;;153        {
;;;154        }
;;;155    
;;;156        template<typename Type> Point3<Type>::Point3(const Point3<Type>& pt)
;;;157          : x(pt.x), y(pt.y), z(pt.z)
;;;158        {
;;;159        }
;;;160    
;;;161    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;162        template<typename Type> Point3<Type>::Point3(const cv::Point3_<Type>& pt)
;;;163          : x(pt.x), y(pt.y), z(pt.z)
;;;164        {
;;;165        }
;;;166    #endif
;;;167    
;;;168    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;169        template<typename Type> cv::Point3_<Type> Point3<Type>::get_CvPoint_() const
;;;170        {
;;;171          return cv::Point3_<Type>(x,y,z);
;;;172        }
;;;173    #endif
;;;174    
;;;175        template<typename Type> void Point3<Type>::Print() const
;;;176        {
;;;177          CoreTechPrint("(%d,%d,%d) ", this->x, this->y, this->z);
;;;178        }
;;;179    
;;;180        template<typename Type> bool Point3<Type>::operator== (const Point3<Type> &point2) const
;;;181        {
;;;182          if(this->x == point2.x && this->y == point2.y && this->z == point2.z)
;;;183            return true;
;;;184    
;;;185          return false;
;;;186        }
;;;187    
;;;188        template<typename Type> Point3<Type> Point3<Type>::operator+ (const Point3<Type> &point2) const
;;;189        {
;;;190          return Point3<Type>(this->x+point2.x, this->y+point2.y, this->z+point2.z);
;;;191        }
;;;192    
;;;193        template<typename Type> Point3<Type> Point3<Type>::operator- (const Point3<Type> &point2) const
;;;194        {
;;;195          return Point3<Type>(this->x-point2.x, this->y-point2.y, this->z-point2.z);
;;;196        }
;;;197    
;;;198        template<typename Type> Point3<Type> Point3<Type>::operator- () const
;;;199        {
;;;200          return Point3<Type>(-this->x, -this->y, -this->z);
;;;201        }
;;;202    
;;;203        template<typename Type> Point3<Type>& Point3<Type>::operator*= (const Type value)
;;;204        {
;;;205          this->x *= value;
;;;206          this->y *= value;
;;;207          this->z *= value;
;;;208          return *this;
;;;209        }
;;;210    
;;;211        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Type value)
;;;212        {
;;;213          this->x -= value;
;;;214          this->y -= value;
;;;215          this->z -= value;
;;;216          return *this;
;;;217        }
;;;218    
;;;219        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Point3<Type> &point2)
;;;220        {
;;;221          this->x -= point2.x;
;;;222          this->y -= point2.y;
;;;223          this->z -= point2.z;
;;;224          return *this;
;;;225        }
;;;226    
;;;227        template<typename Type> inline Point3<Type>& Point3<Type>::operator= (const Point3<Type> &point2)
;;;228        {
;;;229          this->x = point2.x;
;;;230          this->y = point2.y;
;;;231          this->z = point2.z;
;;;232          return *this;
;;;233        }
;;;234    
;;;235        template<typename Type> f32 Point3<Type>::Dist(const Point3<Type> &point2) const
;;;236        {
;;;237          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) +
;;;238            (this->y - point2.y)*(this->y - point2.y) +
;;;239            (this->z - point2.z)*(this->z - point2.z));
;;;240        }
;;;241    
;;;242        template<typename Type> f32 Point3<Type>::Length() const
;;;243        {
;;;244          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y) + (this->z*this->z)));
;;;245        }
;;;246    
;;;247        template<typename Type> f32 Point3<Type>::MakeUnitLength()
;;;248        {
;;;249          const f32 L = this->Length();
;;;250          if(L != 0) {
;;;251            this->operator*=(1.f / L);
;;;252          }
;;;253          return L;
;;;254        }
;;;255    
;;;256        template<typename Type>
;;;257        Type DotProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;258        {
;;;259          return (point1.x*point2.x) + (point1.y*point2.y) + (point1.z*point2.z);
;;;260        }
;;;261    
;;;262        template<typename Type>
;;;263        Point3<Type> CrossProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;264        {
;;;265          return Point3<Type>(-point2.y*point1.z + point1.y*point2.z,
;;;266            point2.x*point1.z - point1.x*point2.z,
;;;267            -point2.x*point1.y + point1.x*point2.y);
;;;268        }
;;;269    
;;;270        template<typename Type>
;;;271        Point3<Type> operator* (const Array<Type>& M, const Point3<Type>& p)
;;;272        {
;;;273          // Matrix M must be 3x3
;;;274          AnkiAssert(AreEqualSize(3, 3, M));
;;;275    
;;;276          return Point3<Type>(M[0][0]*p.x + M[0][1]*p.y + M[0][2]*p.z,
;;;277            M[1][0]*p.x + M[1][1]*p.y + M[1][2]*p.z,
;;;278            M[2][0]*p.x + M[2][1]*p.y + M[2][2]*p.z);
;;;279        }
;;;280    
;;;281        // #pragma mark --- Point Specializations ---
;;;282        template<> void Point3<f32>::Print() const;
;;;283        template<> void Point3<f64>::Print() const;
;;;284    
;;;285    #if 0
;;;286    #pragma mark --- Pose Implementations ---
;;;287    #endif
;;;288    
;;;289        template<typename Type>
;;;290        Result ComputePoseDiff(const Array<Type>& R1, const Point3<Type>& T1,
;;;291          const Array<Type>& R2, const Point3<Type>& T2,
;;;292          Array<Type>& Rdiff, Point3<Type>& Tdiff,
;;;293          MemoryStack scratch)
;;;294        {
;;;295          // All the rotation matrices should be 3x3
;;;296          AnkiAssert(AreEqualSize(3, 3, R1));
;;;297          AnkiAssert(AreEqualSize(3, 3, R2));
;;;298          AnkiAssert(AreEqualSize(3, 3, Rdiff));
;;;299    
;;;300          Array<Type> invR1 = Array<Type>(3,3,scratch);
;;;301          Matrix::Transpose(R1, invR1);
;;;302    
;;;303          Matrix::Multiply(invR1, R2, Rdiff);
;;;304          Tdiff = invR1 * (T2 - T1);
;;;305    
;;;306          return RESULT_OK;
;;;307        }
;;;308    
;;;309    #if 0
;;;310    #pragma mark --- Rectangle Implementations ---
;;;311    #endif
;;;312    
;;;313        template<typename Type> Rectangle<Type>::Rectangle()
;;;314          : left(static_cast<Type>(0)), right(static_cast<Type>(0)), top(static_cast<Type>(0)), bottom(static_cast<Type>(0))
;;;315        {
;;;316        }
;;;317    
;;;318        template<typename Type> Rectangle<Type>::Rectangle(const Type left, const Type right, const Type top, const Type bottom)
;;;319          : left(left), right(right), top(top), bottom(bottom)
;;;320        {
;;;321        }
;;;322    
;;;323        template<typename Type> Rectangle<Type>::Rectangle(const Rectangle<Type>& rect)
;;;324          : left(rect.left), right(rect.right), top(rect.top), bottom(rect.bottom)
;;;325        {
;;;326        }
;;;327    
;;;328        template<typename Type> void Rectangle<Type>::Print() const
;;;329        {
;;;330          CoreTechPrint("(%d,%d)->(%d,%d) ", this->left, this->top, this->right, this->bottom);
;;;331        }
;;;332    
;;;333        template<typename Type> template<typename OutType> Point<OutType> Rectangle<Type>::ComputeCenter() const
;;;334        {
;;;335          Point<OutType> center(
;;;336            (static_cast<OutType>(this->left) + static_cast<OutType>(this->right)) / 2,
;;;337            (static_cast<OutType>(this->top) + static_cast<OutType>(this->bottom)) / 2);
;;;338    
;;;339          return center;
;;;340        }
;;;341    
;;;342        template<typename Type> template<typename OutType> Rectangle<OutType> Rectangle<Type>::ComputeScaledRectangle(const f32 scalePercent) const
;;;343        {
;;;344          const f32 width = static_cast<f32>(this->get_width());
;;;345          const f32 height = static_cast<f32>(this->get_height());
;;;346    
;;;347          const f32 scaledWidth = width * scalePercent;
;;;348          const f32 scaledHeight = height * scalePercent;
;;;349    
;;;350          const f32 dx2 = (scaledWidth - width) / 2.0f;
;;;351          const f32 dy2 = (scaledHeight - height) / 2.0f;
;;;352    
;;;353          Rectangle<OutType> scaledRect(
;;;354            static_cast<OutType>( static_cast<f32>(this->left)   - dx2 ),
;;;355            static_cast<OutType>( static_cast<f32>(this->right)  + dx2 ),
;;;356            static_cast<OutType>( static_cast<f32>(this->top)    - dy2 ),
;;;357            static_cast<OutType>( static_cast<f32>(this->bottom) + dy2 ));
;;;358    
;;;359          return scaledRect;
;;;360        }
;;;361    
;;;362        template<typename Type> bool Rectangle<Type>::operator== (const Rectangle<Type> &rectangle2) const
;;;363        {
;;;364          if(this->left == rectangle2.left && this->top == rectangle2.top && this->right == rectangle2.right && this->bottom == rectangle2.bottom)
;;;365            return true;
;;;366    
;;;367          return false;
;;;368        }
;;;369    
;;;370        template<typename Type> Rectangle<Type> Rectangle<Type>::operator+ (const Rectangle<Type> &rectangle2) const
;;;371        {
;;;372          return Rectangle<Type>(this->top+rectangle2.top, this->bottom+rectangle2.bottom, this->left+rectangle2.left, this->right+rectangle2.right);
;;;373        }
;;;374    
;;;375        template<typename Type> Rectangle<Type> Rectangle<Type>::operator- (const Rectangle<Type> &rectangle2) const
;;;376        {
;;;377          return Rectangle<Type>(this->top-rectangle2.top, this->bottom-rectangle2.bottom, this->left-rectangle2.left, this->right-rectangle2.right);
;;;378        }
;;;379    
;;;380        template<typename Type> inline Rectangle<Type>& Rectangle<Type>::operator= (const Rectangle<Type> &rect2)
;;;381        {
;;;382          this->left = rect2.left;
;;;383          this->right = rect2.right;
;;;384          this->top = rect2.top;
;;;385          this->bottom = rect2.bottom;
;;;386    
;;;387          return *this;
;;;388        }
;;;389    
;;;390        template<typename Type> Type Rectangle<Type>::get_width() const
;;;391        {
;;;392          return right - left;
;;;393        }
;;;394    
;;;395        template<typename Type> Type Rectangle<Type>::get_height() const
;;;396        {
;;;397          return bottom - top;
;;;398        }
;;;399    
;;;400        // #pragma mark --- Rectangle Specializations ---
;;;401        template<> void Rectangle<f32>::Print() const;
;;;402        template<> void Rectangle<f64>::Print() const;
;;;403    
;;;404        // #pragma mark --- Quadrilateral Definitions ---
;;;405    
;;;406        template<typename Type> Quadrilateral<Type>::Quadrilateral()
;;;407        {
;;;408          for(s32 i=0; i<4; i++) {
;;;409            corners[i] = Point<Type>();
;;;410          }
;;;411        }
;;;412    
;;;413        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Point<Type> &corner1, const Point<Type> &corner2, const Point<Type> &corner3, const Point<Type> &corner4)
;;;414        {
;;;415          corners[0] = corner1;
;;;416          corners[1] = corner2;
;;;417          corners[2] = corner3;
;;;418          corners[3] = corner4;
;;;419        }
;;;420    
;;;421        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Quadrilateral<Type>& quad2)
;;;422        {
;;;423          for(s32 i=0; i<4; i++) {
;;;424            this->corners[i] = quad2.corners[i];
;;;425          }
;;;426        }
;;;427    
;;;428        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Rectangle<Type>& rect)
;;;429        {
;;;430          this->corners[0].x = rect.left;   this->corners[0].y = rect.top;
;;;431          this->corners[1].x = rect.right;  this->corners[1].y = rect.top;
;;;432          this->corners[2].x = rect.left;   this->corners[2].y = rect.bottom;
;;;433          this->corners[3].x = rect.right;  this->corners[3].y = rect.bottom;
;;;434        }
;;;435    
;;;436        template<typename Type> void Quadrilateral<Type>::Print() const
;;;437        {
;;;438          CoreTechPrint("{(%d,%d), (%d,%d), (%d,%d), (%d,%d)} ",
;;;439            this->corners[0].x, this->corners[0].y,
;;;440            this->corners[1].x, this->corners[1].y,
;;;441            this->corners[2].x, this->corners[2].y,
;;;442            this->corners[3].x, this->corners[3].y);
;;;443        }
;;;444    
;;;445        template<typename Type> template<typename OutType> Point<OutType> Quadrilateral<Type>::ComputeCenter() const
;;;446        {
;;;447          Point<OutType> center(0, 0);
;;;448    
;;;449          for(s32 i=0; i<4; i++) {
;;;450            center.x += static_cast<OutType>(this->corners[i].x);
;;;451            center.y += static_cast<OutType>(this->corners[i].y);
;;;452          }
;;;453    
;;;454          center.x /= 4;
;;;455          center.y /= 4;
;;;456    
;;;457          return center;
;;;458        }
;;;459    
;;;460        template<typename Type> template<typename OutType> Rectangle<OutType> Quadrilateral<Type>::ComputeBoundingRectangle() const
;;;461        {
;;;462          Rectangle<OutType> boundingRect(
;;;463            static_cast<OutType>(this->corners[0].x),
;;;464            static_cast<OutType>(this->corners[0].x),
;;;465            static_cast<OutType>(this->corners[0].y),
;;;466            static_cast<OutType>(this->corners[0].y));
;;;467    
;;;468          // Initialize the template rectangle to the bounding box of the given
;;;469          // quadrilateral
;;;470          for(s32 i=1; i<4; ++i) {
;;;471            boundingRect.left   = MIN(boundingRect.left,   static_cast<OutType>(this->corners[i].x));
;;;472            boundingRect.right  = MAX(boundingRect.right,  static_cast<OutType>(this->corners[i].x));
;;;473            boundingRect.top    = MIN(boundingRect.top,    static_cast<OutType>(this->corners[i].y));
;;;474            boundingRect.bottom = MAX(boundingRect.bottom, static_cast<OutType>(this->corners[i].y));
;;;475          }
;;;476    
;;;477          return boundingRect;
;;;478        }
;;;479    
;;;480        template<typename Type> template<typename OutType> Quadrilateral<OutType> Quadrilateral<Type>::ComputeClockwiseCorners() const
;;;481        {
;;;482          char tmpBuffer[128];
;;;483          MemoryStack scratch(tmpBuffer, 128);
;;;484    
;;;485          Array<f32> thetas(1,4,scratch);
;;;486          Array<s32> indexes(1,4,scratch);
;;;487          Point<f32> center = this->ComputeCenter<f32>();
;;;488    
;;;489          for(s32 i=0; i<4; i++) {
;;;490            f32 rho = 0.0f;
;;;491    
;;;492            Cart2Pol<f32>(
;;;493              static_cast<f32>(this->corners[i].x) - center.x,
;;;494              static_cast<f32>(this->corners[i].y) - center.y,
;;;495              rho, thetas[0][i]);
;;;496          }
;;;497    
;;;498          Matrix::InsertionSort(thetas, indexes, 1);
;;;499    
;;;500          const Quadrilateral<OutType> sortedQuad(
;;;501            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][0]].x), static_cast<OutType>(this->corners[indexes[0][0]].y)),
;;;502            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][1]].x), static_cast<OutType>(this->corners[indexes[0][1]].y)),
;;;503            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][2]].x), static_cast<OutType>(this->corners[indexes[0][2]].y)),
;;;504            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][3]].x), static_cast<OutType>(this->corners[indexes[0][3]].y)));
;;;505    
;;;506          return sortedQuad;
;;;507        }
;;;508    
                          ENDP

                  |L499.748|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L499.752|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 3)
                  |L499.756|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3 ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 5)
                  |L499.760|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2 ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 4)
                  |L499.764|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 2)
                  |L499.768|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string
                  |L499.772|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4 ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 6)
                  |L499.776|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5 ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 7)
                  |L499.780|
00030c  00000000          DCFS     0x00000000 ; 0
                  |L499.784|
                          DCD      0x07fffffe
                  |L499.788|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()

                          AREA ||area_number.500||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv, LINKORDER=||t._ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.500||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi PROC ; Anki::Embedded::Array<unsigned char>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0d              BGE      |L506.36|
000008  f24021e3          MOV      r1,#0x2e3
00000c  4809              LDR      r0,|L506.52|
00000e  e9cd0100          STRD     r0,r1,[sp,#0]
000012  4b09              LDR      r3,|L506.56|
000014  4a09              LDR      r2,|L506.60|
000016  490a              LDR      r1,|L506.64|
000018  2005              MOVS     r0,#5
00001a  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
00001e  b003              ADD      sp,sp,#0xc
000020  2000              MOVS     r0,#0                 ;739
000022  bd00              POP      {pc}
                  |L506.36|
000024  2902              CMP      r1,#2                 ;742
000026  bf2c              ITE      CS                    ;743
000028  2001              MOVCS    r0,#1                 ;743
00002a  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
00002e  b003              ADD      sp,sp,#0xc
000030  bd00              POP      {pc}
;;;747    
                          ENDP

000032  0000              DCW      0x0000
                  |L506.52|
                          DCD      _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::get_size(int) const::__PRETTY_FUNCTION__
                  |L506.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiEs_1 ; Anki::Embedded::Array<unsigned char>::get_size(int) const::string (instance 3)
                  |L506.60|
                          DCD      _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiEs_0 ; Anki::Embedded::Array<unsigned char>::get_size(int) const::string (instance 2)
                  |L506.64|
                          DCD      _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiEs ; Anki::Embedded::Array<unsigned char>::get_size(int) const::string

                          AREA ||area_number.507||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.507||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L513.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L513.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.514||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.514||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEEC2EiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>::FixedLengthList__sub_object(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;75     
;;;76         template<typename Type> FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;77           : ArraySlice<Type>(Array<Type>(1, maximumSize, memory, flags), LinearSequence<s32>(0,0), LinearSequence<s32>(0,0))
;;;78         {
;;;79           if(this->array.get_numElements() == 0) {
;;;80             this->arrayData = NULL;
;;;81           } else {
;;;82             this->arrayData = this->array.Pointer(0,0);
;;;83           }
;;;84     
;;;85           if(flags.get_isFullyAllocated()) {
;;;86             this->set_size(maximumSize);
;;;87           } else {
;;;88             this->set_size(0);
;;;89           }
;;;90         } // FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;91     
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  b091              SUB      sp,sp,#0x44
000006  4605              MOV      r5,r0
000008  4691              MOV      r9,r2
00000a  a808              ADD      r0,sp,#0x20
00000c  f04f0801          MOV      r8,#1
000010  f8dda050          LDR      r10,[sp,#0x50]
000014  9f12              LDR      r7,[sp,#0x48]
000016  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00001a  f1a0040c          SUB      r4,r0,#0xc
00001e  f04f30ff          MOV      r0,#0xffffffff
000022  6020              STR      r0,[r4,#0]
000024  6060              STR      r0,[r4,#4]
000026  f04f0b00          MOV      r11,#0
00002a  f8c4b010          STR      r11,[r4,#0x10]
00002e  60a0              STR      r0,[r4,#8]
000030  2f00              CMP      r7,#0
000032  da0a              BGE      |L520.74|
000034  217d              MOVS     r1,#0x7d
000036  4879              LDR      r0,|L520.540|
000038  e9cd0100          STRD     r0,r1,[sp,#0]
00003c  4b78              LDR      r3,|L520.544|
00003e  4a79              LDR      r2,|L520.548|
000040  4979              LDR      r1,|L520.552|
000042  2005              MOVS     r0,#5
000044  f7fffffe          BL       _Anki_Log
000048  e087              B        |L520.346|
                  |L520.74|
00004a  f8cdb010          STR      r11,[sp,#0x10]
00004e  2f01              CMP      r7,#1
000050  bfd4              ITE      LE
000052  2001              MOVLE    r0,#1
000054  4638              MOVGT    r0,r7
000056  212c              MOVS     r1,#0x2c
000058  4348              MULS     r0,r1,r0
00005a  300f              ADDS     r0,r0,#0xf
00005c  f020060f          BIC      r6,r0,#0xf
000060  a804              ADD      r0,sp,#0x10
000062  e9cd0a02          STRD     r0,r10,[sp,#8]
000066  2e00              CMP      r6,#0
000068  dc0a              BGT      |L520.128|
00006a  f240310b          MOV      r1,#0x30b
00006e  486f              LDR      r0,|L520.556|
000070  e9cd0100          STRD     r0,r1,[sp,#0]
000074  4b6e              LDR      r3,|L520.560|
000076  4a6f              LDR      r2,|L520.564|
000078  496f              LDR      r1,|L520.568|
00007a  2005              MOVS     r0,#5
00007c  f7fffffe          BL       _Anki_Log
                  |L520.128|
000080  a803              ADD      r0,sp,#0xc
000082  60a6              STR      r6,[r4,#8]
000084  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
000088  4602              MOV      r2,r0
00008a  4631              MOV      r1,r6
00008c  4648              MOV      r0,r9
00008e  9b02              LDR      r3,[sp,#8]
000090  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
000094  f8cda00c          STR      r10,[sp,#0xc]
000098  f8dd9010          LDR      r9,[sp,#0x10]
00009c  f8dfa19c          LDR      r10,|L520.572|
0000a0  0006              MOVS     r6,r0
0000a2  d00d              BEQ      |L520.192|
0000a4  f1b90f10          CMP      r9,#0x10
0000a8  d21c              BCS      |L520.228|
0000aa  f2403023          MOV      r0,#0x323
0000ae  e9cda000          STRD     r10,r0,[sp,#0]
0000b2  4b63              LDR      r3,|L520.576|
0000b4  4a63              LDR      r2,|L520.580|
0000b6  4964              LDR      r1,|L520.584|
0000b8  2005              MOVS     r0,#5
0000ba  f7fffffe          BL       _Anki_Log
0000be  e04c              B        |L520.346|
                  |L520.192|
0000c0  f240301e          MOV      r0,#0x31e
0000c4  e9cda000          STRD     r10,r0,[sp,#0]
0000c8  4b5d              LDR      r3,|L520.576|
0000ca  4a60              LDR      r2,|L520.588|
0000cc  4960              LDR      r1,|L520.592|
0000ce  2005              MOVS     r0,#5
0000d0  f7fffffe          BL       _Anki_Log
0000d4  f04f30ff          MOV      r0,#0xffffffff
0000d8  6020              STR      r0,[r4,#0]
0000da  6060              STR      r0,[r4,#4]
0000dc  f8c4b010          STR      r11,[r4,#0x10]
0000e0  60a0              STR      r0,[r4,#8]
0000e2  e03a              B        |L520.346|
                  |L520.228|
0000e4  a803              ADD      r0,sp,#0xc
0000e6  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
0000ea  b150              CBZ      r0,|L520.258|
0000ec  f2403026          MOV      r0,#0x326
0000f0  e9cda000          STRD     r10,r0,[sp,#0]
0000f4  4b52              LDR      r3,|L520.576|
0000f6  4a57              LDR      r2,|L520.596|
0000f8  4953              LDR      r1,|L520.584|
0000fa  2005              MOVS     r0,#5
0000fc  f7fffffe          BL       _Anki_Log
000100  e02b              B        |L520.346|
                  |L520.258|
000102  9903              LDR      r1,[sp,#0xc]
000104  e9c41603          STRD     r1,r6,[r4,#0xc]
000108  f106000f          ADD      r0,r6,#0xf
00010c  f020000f          BIC      r0,r0,#0xf
000110  e9c48700          STRD     r8,r7,[r4,#0]
000114  1b80              SUBS     r0,r0,r6
000116  2f01              CMP      r7,#1
000118  bfd8              IT       LE
00011a  2701              MOVLE    r7,#1
00011c  212c              MOVS     r1,#0x2c
00011e  4379              MULS     r1,r7,r1
000120  310f              ADDS     r1,r1,#0xf
000122  f021010f          BIC      r1,r1,#0xf
000126  fb010108          MLA      r1,r1,r8,r0
00012a  4549              CMP      r1,r9
00012c  bfdc              ITT      LE
00012e  1831              ADDLE    r1,r6,r0
000130  6121              STRLE    r1,[r4,#0x10]
000132  dd12              BLE      |L520.346|
000134  f2403035          MOV      r0,#0x335
000138  f8cda000          STR      r10,[sp,#0]
00013c  e9cd0101          STRD     r0,r1,[sp,#4]
000140  4b3f              LDR      r3,|L520.576|
000142  4a45              LDR      r2,|L520.600|
000144  4942              LDR      r1,|L520.592|
000146  2005              MOVS     r0,#5
000148  f7fffffe          BL       _Anki_Log
00014c  f04f30ff          MOV      r0,#0xffffffff
000150  6020              STR      r0,[r4,#0]
000152  6060              STR      r0,[r4,#4]
000154  f8c4b010          STR      r11,[r4,#0x10]
000158  60a0              STR      r0,[r4,#8]
                  |L520.346|
00015a  e89403c0          LDM      r4,{r6-r9}
00015e  2200              MOVS     r2,#0
000160  6924              LDR      r4,[r4,#0x10]
000162  4611              MOV      r1,r2
000164  a80a              ADD      r0,sp,#0x28
000166  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00016a  4682              MOV      r10,r0
00016c  2200              MOVS     r2,#0
00016e  4611              MOV      r1,r2
000170  a80d              ADD      r0,sp,#0x34
000172  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000176  e9da2300          LDRD     r2,r3,[r10,#0]
00017a  4601              MOV      r1,r0
00017c  f8dac008          LDR      r12,[r10,#8]
000180  4628              MOV      r0,r5
000182  f8c5c008          STR      r12,[r5,#8]
000186  e9c02300          STRD     r2,r3,[r0,#0]
00018a  e9d12300          LDRD     r2,r3,[r1,#0]
00018e  6889              LDR      r1,[r1,#8]
000190  f1050a14          ADD      r10,r5,#0x14
000194  62ac              STR      r4,[r5,#0x28]
000196  e88a03c2          STM      r10,{r1,r6-r9}
00019a  2e00              CMP      r6,#0
00019c  e9c52303          STRD     r2,r3,[r5,#0xc]
0001a0  bfc8              IT       GT
0001a2  2f00              CMPGT    r7,#0
0001a4  dd28              BLE      |L520.504|
0001a6  fb06f107          MUL      r1,r6,r7
0001aa  b329              CBZ      r1,|L520.504|
0001ac  2100              MOVS     r1,#0
0001ae  fb014108          MLA      r1,r1,r8,r4
0001b2  62e9              STR      r1,[r5,#0x2c]
                  |L520.436|
0001b4  2e00              CMP      r6,#0
0001b6  bfc8              IT       GT
0001b8  2f00              CMPGT    r7,#0
0001ba  dd20              BLE      |L520.510|
0001bc  fb06f007          MUL      r0,r6,r7
0001c0  b1e8              CBZ      r0,|L520.510|
0001c2  2000              MOVS     r0,#0
0001c4  fb004008          MLA      r0,r0,r8,r4
0001c8  6328              STR      r0,[r5,#0x30]
                  |L520.458|
0001ca  69a8              LDR      r0,[r5,#0x18]
0001cc  2800              CMP      r0,#0
0001ce  bfc4              ITT      GT
0001d0  69e9              LDRGT    r1,[r5,#0x1c]
0001d2  2900              CMPGT    r1,#0
0001d4  dd16              BLE      |L520.516|
0001d6  4348              MULS     r0,r1,r0
0001d8  d014              BEQ      |L520.516|
0001da  6a2a              LDR      r2,[r5,#0x20]
0001dc  6aa9              LDR      r1,[r5,#0x28]
0001de  2000              MOVS     r0,#0
0001e0  fb001002          MLA      r0,r0,r2,r1
0001e4  6328              STR      r0,[r5,#0x30]
                  |L520.486|
0001e6  a814              ADD      r0,sp,#0x50
0001e8  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0001ec  b168              CBZ      r0,|L520.522|
0001ee  4628              MOV      r0,r5
0001f0  9912              LDR      r1,[sp,#0x48]
0001f2  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>::set_size(int)
0001f6  e00c              B        |L520.530|
                  |L520.504|
0001f8  f8c5b02c          STR      r11,[r5,#0x2c]
0001fc  e7da              B        |L520.436|
                  |L520.510|
0001fe  f8c5b030          STR      r11,[r5,#0x30]
000202  e7e2              B        |L520.458|
                  |L520.516|
000204  f8c5b030          STR      r11,[r5,#0x30]
000208  e7ed              B        |L520.486|
                  |L520.522|
00020a  2100              MOVS     r1,#0
00020c  4628              MOV      r0,r5
00020e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>::set_size(int)
                  |L520.530|
000212  b015              ADD      sp,sp,#0x54
000214  4628              MOV      r0,r5
000216  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

00021a  0000              DCW      0x0000
                  |L520.540|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L520.544|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 3)
                  |L520.548|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 2)
                  |L520.552|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string
                  |L520.556|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L520.560|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 3)
                  |L520.564|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 2)
                  |L520.568|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string
                  |L520.572|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L520.576|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 3)
                  |L520.580|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 5)
                  |L520.584|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 4)
                  |L520.588|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 2)
                  |L520.592|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string
                  |L520.596|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 6)
                  |L520.600|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 7)

                          AREA ||area_number.521||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.521||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker*>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L527.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L527.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.528||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.528||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEEC2EiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker*>::FixedLengthList__sub_object(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker*>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;75     
;;;76         template<typename Type> FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;77           : ArraySlice<Type>(Array<Type>(1, maximumSize, memory, flags), LinearSequence<s32>(0,0), LinearSequence<s32>(0,0))
;;;78         {
;;;79           if(this->array.get_numElements() == 0) {
;;;80             this->arrayData = NULL;
;;;81           } else {
;;;82             this->arrayData = this->array.Pointer(0,0);
;;;83           }
;;;84     
;;;85           if(flags.get_isFullyAllocated()) {
;;;86             this->set_size(maximumSize);
;;;87           } else {
;;;88             this->set_size(0);
;;;89           }
;;;90         } // FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;91     
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  b091              SUB      sp,sp,#0x44
000006  4605              MOV      r5,r0
000008  4691              MOV      r9,r2
00000a  a808              ADD      r0,sp,#0x20
00000c  f04f0801          MOV      r8,#1
000010  f8dda050          LDR      r10,[sp,#0x50]
000014  9f12              LDR      r7,[sp,#0x48]
000016  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00001a  f1a0040c          SUB      r4,r0,#0xc
00001e  f04f30ff          MOV      r0,#0xffffffff
000022  6020              STR      r0,[r4,#0]
000024  6060              STR      r0,[r4,#4]
000026  f04f0b00          MOV      r11,#0
00002a  f8c4b010          STR      r11,[r4,#0x10]
00002e  60a0              STR      r0,[r4,#8]
000030  2f00              CMP      r7,#0
000032  da0a              BGE      |L534.74|
000034  217d              MOVS     r1,#0x7d
000036  4878              LDR      r0,|L534.536|
000038  e9cd0100          STRD     r0,r1,[sp,#0]
00003c  4b77              LDR      r3,|L534.540|
00003e  4a78              LDR      r2,|L534.544|
000040  4978              LDR      r1,|L534.548|
000042  2005              MOVS     r0,#5
000044  f7fffffe          BL       _Anki_Log
000048  e085              B        |L534.342|
                  |L534.74|
00004a  f8cdb010          STR      r11,[sp,#0x10]
00004e  2f01              CMP      r7,#1
000050  bfd4              ITE      LE
000052  2001              MOVLE    r0,#1
000054  4638              MOVGT    r0,r7
000056  0080              LSLS     r0,r0,#2
000058  300f              ADDS     r0,r0,#0xf
00005a  f020060f          BIC      r6,r0,#0xf
00005e  a804              ADD      r0,sp,#0x10
000060  e9cd0a02          STRD     r0,r10,[sp,#8]
000064  2e00              CMP      r6,#0
000066  dc0a              BGT      |L534.126|
000068  f240310b          MOV      r1,#0x30b
00006c  486e              LDR      r0,|L534.552|
00006e  e9cd0100          STRD     r0,r1,[sp,#0]
000072  4b6e              LDR      r3,|L534.556|
000074  4a6e              LDR      r2,|L534.560|
000076  496f              LDR      r1,|L534.564|
000078  2005              MOVS     r0,#5
00007a  f7fffffe          BL       _Anki_Log
                  |L534.126|
00007e  a803              ADD      r0,sp,#0xc
000080  60a6              STR      r6,[r4,#8]
000082  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
000086  4602              MOV      r2,r0
000088  4631              MOV      r1,r6
00008a  4648              MOV      r0,r9
00008c  9b02              LDR      r3,[sp,#8]
00008e  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
000092  f8cda00c          STR      r10,[sp,#0xc]
000096  f8dd9010          LDR      r9,[sp,#0x10]
00009a  f8dfa19c          LDR      r10,|L534.568|
00009e  0006              MOVS     r6,r0
0000a0  d00d              BEQ      |L534.190|
0000a2  f1b90f10          CMP      r9,#0x10
0000a6  d21c              BCS      |L534.226|
0000a8  f2403023          MOV      r0,#0x323
0000ac  e9cda000          STRD     r10,r0,[sp,#0]
0000b0  4b62              LDR      r3,|L534.572|
0000b2  4a63              LDR      r2,|L534.576|
0000b4  4963              LDR      r1,|L534.580|
0000b6  2005              MOVS     r0,#5
0000b8  f7fffffe          BL       _Anki_Log
0000bc  e04b              B        |L534.342|
                  |L534.190|
0000be  f240301e          MOV      r0,#0x31e
0000c2  e9cda000          STRD     r10,r0,[sp,#0]
0000c6  4b5d              LDR      r3,|L534.572|
0000c8  4a5f              LDR      r2,|L534.584|
0000ca  4960              LDR      r1,|L534.588|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f04f30ff          MOV      r0,#0xffffffff
0000d6  6020              STR      r0,[r4,#0]
0000d8  6060              STR      r0,[r4,#4]
0000da  f8c4b010          STR      r11,[r4,#0x10]
0000de  60a0              STR      r0,[r4,#8]
0000e0  e039              B        |L534.342|
                  |L534.226|
0000e2  a803              ADD      r0,sp,#0xc
0000e4  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
0000e8  b150              CBZ      r0,|L534.256|
0000ea  f2403026          MOV      r0,#0x326
0000ee  e9cda000          STRD     r10,r0,[sp,#0]
0000f2  4b52              LDR      r3,|L534.572|
0000f4  4a56              LDR      r2,|L534.592|
0000f6  4953              LDR      r1,|L534.580|
0000f8  2005              MOVS     r0,#5
0000fa  f7fffffe          BL       _Anki_Log
0000fe  e02a              B        |L534.342|
                  |L534.256|
000100  9903              LDR      r1,[sp,#0xc]
000102  e9c41603          STRD     r1,r6,[r4,#0xc]
000106  f106000f          ADD      r0,r6,#0xf
00010a  f020000f          BIC      r0,r0,#0xf
00010e  e9c48700          STRD     r8,r7,[r4,#0]
000112  1b80              SUBS     r0,r0,r6
000114  2f01              CMP      r7,#1
000116  bfd8              IT       LE
000118  2701              MOVLE    r7,#1
00011a  00b9              LSLS     r1,r7,#2
00011c  310f              ADDS     r1,r1,#0xf
00011e  f021010f          BIC      r1,r1,#0xf
000122  fb010108          MLA      r1,r1,r8,r0
000126  4549              CMP      r1,r9
000128  bfdc              ITT      LE
00012a  1831              ADDLE    r1,r6,r0
00012c  6121              STRLE    r1,[r4,#0x10]
00012e  dd12              BLE      |L534.342|
000130  f2403035          MOV      r0,#0x335
000134  f8cda000          STR      r10,[sp,#0]
000138  e9cd0101          STRD     r0,r1,[sp,#4]
00013c  4b3f              LDR      r3,|L534.572|
00013e  4a45              LDR      r2,|L534.596|
000140  4942              LDR      r1,|L534.588|
000142  2005              MOVS     r0,#5
000144  f7fffffe          BL       _Anki_Log
000148  f04f30ff          MOV      r0,#0xffffffff
00014c  6020              STR      r0,[r4,#0]
00014e  6060              STR      r0,[r4,#4]
000150  f8c4b010          STR      r11,[r4,#0x10]
000154  60a0              STR      r0,[r4,#8]
                  |L534.342|
000156  e89403c0          LDM      r4,{r6-r9}
00015a  2200              MOVS     r2,#0
00015c  6924              LDR      r4,[r4,#0x10]
00015e  4611              MOV      r1,r2
000160  a80a              ADD      r0,sp,#0x28
000162  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000166  4682              MOV      r10,r0
000168  2200              MOVS     r2,#0
00016a  4611              MOV      r1,r2
00016c  a80d              ADD      r0,sp,#0x34
00016e  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000172  e9da2300          LDRD     r2,r3,[r10,#0]
000176  4601              MOV      r1,r0
000178  f8dac008          LDR      r12,[r10,#8]
00017c  4628              MOV      r0,r5
00017e  f8c5c008          STR      r12,[r5,#8]
000182  e9c02300          STRD     r2,r3,[r0,#0]
000186  e9d12300          LDRD     r2,r3,[r1,#0]
00018a  6889              LDR      r1,[r1,#8]
00018c  f1050a14          ADD      r10,r5,#0x14
000190  62ac              STR      r4,[r5,#0x28]
000192  e88a03c2          STM      r10,{r1,r6-r9}
000196  2e00              CMP      r6,#0
000198  e9c52303          STRD     r2,r3,[r5,#0xc]
00019c  bfc8              IT       GT
00019e  2f00              CMPGT    r7,#0
0001a0  dd28              BLE      |L534.500|
0001a2  fb06f107          MUL      r1,r6,r7
0001a6  b329              CBZ      r1,|L534.500|
0001a8  2100              MOVS     r1,#0
0001aa  fb014108          MLA      r1,r1,r8,r4
0001ae  62e9              STR      r1,[r5,#0x2c]
                  |L534.432|
0001b0  2e00              CMP      r6,#0
0001b2  bfc8              IT       GT
0001b4  2f00              CMPGT    r7,#0
0001b6  dd20              BLE      |L534.506|
0001b8  fb06f007          MUL      r0,r6,r7
0001bc  b1e8              CBZ      r0,|L534.506|
0001be  2000              MOVS     r0,#0
0001c0  fb004008          MLA      r0,r0,r8,r4
0001c4  6328              STR      r0,[r5,#0x30]
                  |L534.454|
0001c6  69a9              LDR      r1,[r5,#0x18]
0001c8  2900              CMP      r1,#0
0001ca  bfc4              ITT      GT
0001cc  69e8              LDRGT    r0,[r5,#0x1c]
0001ce  2800              CMPGT    r0,#0
0001d0  dd16              BLE      |L534.512|
0001d2  4348              MULS     r0,r1,r0
0001d4  d014              BEQ      |L534.512|
0001d6  6a2a              LDR      r2,[r5,#0x20]
0001d8  6aa9              LDR      r1,[r5,#0x28]
0001da  2000              MOVS     r0,#0
0001dc  fb001002          MLA      r0,r0,r2,r1
0001e0  6328              STR      r0,[r5,#0x30]
                  |L534.482|
0001e2  a814              ADD      r0,sp,#0x50
0001e4  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0001e8  b168              CBZ      r0,|L534.518|
0001ea  4628              MOV      r0,r5
0001ec  9912              LDR      r1,[sp,#0x48]
0001ee  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker*>::set_size(int)
0001f2  e00c              B        |L534.526|
                  |L534.500|
0001f4  f8c5b02c          STR      r11,[r5,#0x2c]
0001f8  e7da              B        |L534.432|
                  |L534.506|
0001fa  f8c5b030          STR      r11,[r5,#0x30]
0001fe  e7e2              B        |L534.454|
                  |L534.512|
000200  f8c5b030          STR      r11,[r5,#0x30]
000204  e7ed              B        |L534.482|
                  |L534.518|
000206  2100              MOVS     r1,#0
000208  4628              MOV      r0,r5
00020a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker*>::set_size(int)
                  |L534.526|
00020e  b015              ADD      sp,sp,#0x54
000210  4628              MOV      r0,r5
000212  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

000216  0000              DCW      0x0000
                  |L534.536|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L534.540|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 3)
                  |L534.544|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string (instance 2)
                  |L534.548|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::string
                  |L534.552|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L534.556|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 3)
                  |L534.560|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string (instance 2)
                  |L534.564|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::string
                  |L534.568|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L534.572|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_1 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 3)
                  |L534.576|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_3 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 5)
                  |L534.580|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_2 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 4)
                  |L534.584|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_0 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 2)
                  |L534.588|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string
                  |L534.592|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_4 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 6)
                  |L534.596|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEEs_5 ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::string (instance 7)

                          AREA ||area_number.535||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.535||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_||, COMGROUP=_ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_ PROC ; Anki::Embedded::operator *<float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Point3<T1>&)
;;;270        template<typename Type>
;;;271        Point3<Type> operator* (const Array<Type>& M, const Point3<Type>& p)
000000  b430              PUSH     {r4,r5}
000002  f8d1c008          LDR      r12,[r1,#8]
000006  690b              LDR      r3,[r1,#0x10]
;;;272        {
;;;273          // Matrix M must be 3x3
;;;274          AnkiAssert(AreEqualSize(3, 3, M));
;;;275    
;;;276          return Point3<Type>(M[0][0]*p.x + M[0][1]*p.y + M[0][2]*p.z,
000008  2402              MOVS     r4,#2
00000a  fb04310c          MLA      r1,r4,r12,r3
00000e  ed920a00          VLDR     s0,[r2,#0]
000012  edd10a00          VLDR     s1,[r1,#0]
000016  ed922a01          VLDR     s4,[r2,#4]
00001a  edd21a02          VLDR     s3,[r2,#8]
00001e  ee201a80          VMUL.F32 s2,s1,s0
000022  edd10a01          VLDR     s1,[r1,#4]
000026  ee001a82          VMLA.F32 s2,s1,s4
00002a  edd10a02          VLDR     s1,[r1,#8]
00002e  2101              MOVS     r1,#1
000030  fb01310c          MLA      r1,r1,r12,r3
000034  ee001aa1          VMLA.F32 s2,s1,s3
000038  edd10a00          VLDR     s1,[r1,#0]
00003c  edd12a01          VLDR     s5,[r1,#4]
000040  ee600a80          VMUL.F32 s1,s1,s0
000044  ee420a82          VMLA.F32 s1,s5,s4
000048  edd12a02          VLDR     s5,[r1,#8]
00004c  2100              MOVS     r1,#0
00004e  fb01310c          MLA      r1,r1,r12,r3
000052  ee420aa1          VMLA.F32 s1,s5,s3
000056  edd12a00          VLDR     s5,[r1,#0]
00005a  ee220a80          VMUL.F32 s0,s5,s0
00005e  edd12a01          VLDR     s5,[r1,#4]
000062  ee020a82          VMLA.F32 s0,s5,s4
000066  ed912a02          VLDR     s4,[r1,#8]
00006a  bc30              POP      {r4,r5}
00006c  ee020a21          VMLA.F32 s0,s4,s3
000070  f7ffbffe          B.W      _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
;;;277            M[1][0]*p.x + M[1][1]*p.y + M[1][2]*p.z,
;;;278            M[2][0]*p.x + M[2][1]*p.y + M[2][2]*p.z);
;;;279        }
;;;280    
                          ENDP


                          AREA ||area_number.542||, COMGROUP=_ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_, LINKORDER=||t._ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.542||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||, COMGROUP=_ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii PROC ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)
;;;1637   
;;;1638         template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1639         {
000004  b083              SUB      sp,sp,#0xc
000006  460c              MOV      r4,r1
000008  e9dd670c          LDRD     r6,r7,[sp,#0x30]
00000c  469a              MOV      r10,r3
00000e  4693              MOV      r11,r2
000010  4680              MOV      r8,r0
;;;1640           const s32 arrHeight = arr.get_size(0);
000012  2100              MOVS     r1,#0
000014  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000018  4681              MOV      r9,r0
;;;1641           const s32 arrWidth = arr.get_size(1);
00001a  2101              MOVS     r1,#1
00001c  4640              MOV      r0,r8
00001e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000022  4605              MOV      r5,r0
000024  f8d80010          LDR      r0,[r8,#0x10]
000028  b328              CBZ      r0,|L548.118|
00002a  f8d80000          LDR      r0,[r8,#0]
00002e  2800              CMP      r0,#0
000030  bfa4              ITT      GE
000032  f8d80004          LDRGE    r0,[r8,#4]
000036  2800              CMPGE    r0,#0
000038  db1d              BLT      |L548.118|
00003a  6920              LDR      r0,[r4,#0x10]
00003c  b1d8              CBZ      r0,|L548.118|
00003e  6820              LDR      r0,[r4,#0]
000040  2800              CMP      r0,#0
000042  bfa4              ITT      GE
000044  6860              LDRGE    r0,[r4,#4]
000046  2800              CMPGE    r0,#0
000048  db15              BLT      |L548.118|
;;;1642   
;;;1643           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1644             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1645   
;;;1646           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
00004a  f1bb0f00          CMP      r11,#0
00004e  bf18              IT       NE
000050  f1bb0f01          CMPNE    r11,#1
000054  d01f              BEQ      |L548.150|
000056  f240616e          MOV      r1,#0x66e
00005a  48ee              LDR      r0,|L548.1044|
00005c  e9cd0100          STRD     r0,r1,[sp,#0]
000060  4bed              LDR      r3,|L548.1048|
000062  4aee              LDR      r2,|L548.1052|
000064  49ee              LDR      r1,|L548.1056|
000066  2005              MOVS     r0,#5
000068  f7fffffe          BL       _Anki_Log
;;;1647             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1648   
;;;1649           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1650             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1651   
;;;1652           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1653           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1654   
;;;1655           if(sortWhichDimension == 0) {
;;;1656             for(s32 y=0; y<arrHeight; y++) {
;;;1657               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1658               for(s32 x=0; x<arrWidth; x++) {
;;;1659                 pIndexes[x] = y;
;;;1660               }
;;;1661             }
;;;1662   
;;;1663             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1664             if(sortAscending) {
;;;1665               InsertionSort_sortAscendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1666             } else { // if(sortAscending)
;;;1667               InsertionSort_sortDescendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1668             } // if(sortAscending) ... else
;;;1669           } else { // sortWhichDimension == 1
;;;1670             for(s32 y=0; y<arrHeight; y++) {
;;;1671               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1672               for(s32 x=0; x<arrWidth; x++) {
;;;1673                 pIndexes[x] = x;
;;;1674               }
;;;1675             }
;;;1676   
;;;1677             if(sortAscending) {
;;;1678               InsertionSort_sortAscendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1679             } else { // if(sortAscending)
;;;1680               InsertionSort_sortDescendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1681             } // if(sortAscending) ... else
;;;1682           } // if(sortWhichDimension == 0) ... else
;;;1683   
;;;1684           return RESULT_OK;
;;;1685         } // InsertionSort()
00006c  b003              ADD      sp,sp,#0xc
00006e  f04f7040          MOV      r0,#0x3000000         ;1646
000072  e8bd8ff0          POP      {r4-r11,pc}
                  |L548.118|
000076  f240616b          MOV      r1,#0x66b             ;1643
00007a  48e6              LDR      r0,|L548.1044|
00007c  e9cd0100          STRD     r0,r1,[sp,#0]         ;1643
000080  4be5              LDR      r3,|L548.1048|
000082  4ae8              LDR      r2,|L548.1060|
000084  49e6              LDR      r1,|L548.1056|
000086  2005              MOVS     r0,#5                 ;1643
000088  f7fffffe          BL       _Anki_Log
00008c  b003              ADD      sp,sp,#0xc
00008e  f04f6080          MOV      r0,#0x4000000         ;1643
000092  e8bd8ff0          POP      {r4-r11,pc}
                  |L548.150|
000096  2100              MOVS     r1,#0
000098  4640              MOV      r0,r8
00009a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00009e  4601              MOV      r1,r0
0000a0  6820              LDR      r0,[r4,#0]
0000a2  4281              CMP      r1,r0
0000a4  d107              BNE      |L548.182|
0000a6  2101              MOVS     r1,#1
0000a8  4640              MOV      r0,r8
0000aa  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000ae  4601              MOV      r1,r0
0000b0  6860              LDR      r0,[r4,#4]
0000b2  4281              CMP      r1,r0
0000b4  d00f              BEQ      |L548.214|
                  |L548.182|
0000b6  f2406171          MOV      r1,#0x671             ;1649
0000ba  48d6              LDR      r0,|L548.1044|
0000bc  e9cd0100          STRD     r0,r1,[sp,#0]         ;1649
0000c0  4bd5              LDR      r3,|L548.1048|
0000c2  4ad9              LDR      r2,|L548.1064|
0000c4  49d6              LDR      r1,|L548.1056|
0000c6  2005              MOVS     r0,#5                 ;1649
0000c8  f7fffffe          BL       _Anki_Log
0000cc  b003              ADD      sp,sp,#0xc
0000ce  f04f60a0          MOV      r0,#0x5000000         ;1649
0000d2  e8bd8ff0          POP      {r4-r11,pc}
                  |L548.214|
0000d6  4659              MOV      r1,r11                ;1652
0000d8  4640              MOV      r0,r8                 ;1652
0000da  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000de  1e41              SUBS     r1,r0,#1              ;1652
0000e0  2e00              CMP      r6,#0                 ;1652
0000e2  bfcc              ITE      GT                    ;1652
0000e4  4630              MOVGT    r0,r6                 ;1652
0000e6  2000              MOVLE    r0,#0                 ;1652
0000e8  4281              CMP      r1,r0                 ;1652
0000ea  dd03              BLE      |L548.244|
0000ec  2e00              CMP      r6,#0                 ;1652
0000ee  bfd8              IT       LE                    ;1652
0000f0  2600              MOVLE    r6,#0                 ;1652
0000f2  e004              B        |L548.254|
                  |L548.244|
0000f4  4659              MOV      r1,r11                ;1652
0000f6  4640              MOV      r0,r8                 ;1652
0000f8  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000fc  1e46              SUBS     r6,r0,#1              ;1652
                  |L548.254|
0000fe  4659              MOV      r1,r11                ;1653
000100  4640              MOV      r0,r8                 ;1653
000102  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000106  1e41              SUBS     r1,r0,#1              ;1653
000108  2f00              CMP      r7,#0                 ;1653
00010a  bfcc              ITE      GT                    ;1653
00010c  4638              MOVGT    r0,r7                 ;1653
00010e  2000              MOVLE    r0,#0                 ;1653
000110  4281              CMP      r1,r0                 ;1653
000112  dd03              BLE      |L548.284|
000114  2f00              CMP      r7,#0                 ;1653
000116  bfd8              IT       LE                    ;1653
000118  2700              MOVLE    r7,#0                 ;1653
00011a  e004              B        |L548.294|
                  |L548.284|
00011c  4659              MOV      r1,r11                ;1653
00011e  4640              MOV      r0,r8                 ;1653
000120  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000124  1e47              SUBS     r7,r0,#1              ;1653
                  |L548.294|
000126  ea5f000b          MOVS     r0,r11                ;1655
00012a  f04f0b00          MOV      r11,#0                ;1655
00012e  4659              MOV      r1,r11                ;1670
000130  d037              BEQ      |L548.418|
000132  f1b90f00          CMP      r9,#0                 ;1670
000136  dd0e              BLE      |L548.342|
                  |L548.312|
000138  68a2              LDR      r2,[r4,#8]            ;1670
00013a  6920              LDR      r0,[r4,#0x10]         ;1670
00013c  fb010202          MLA      r2,r1,r2,r0           ;1670
000140  2000              MOVS     r0,#0                 ;1672
000142  2d00              CMP      r5,#0                 ;1672
000144  dd04              BLE      |L548.336|
                  |L548.326|
000146  f8420020          STR      r0,[r2,r0,LSL #2]     ;1673
00014a  1c40              ADDS     r0,r0,#1              ;1673
00014c  4285              CMP      r5,r0                 ;1672
00014e  dcfa              BGT      |L548.326|
                  |L548.336|
000150  1c49              ADDS     r1,r1,#1              ;1672
000152  4549              CMP      r1,r9                 ;1670
000154  dbf0              BLT      |L548.312|
                  |L548.342|
000156  f1ba0f00          CMP      r10,#0                ;1677
00015a  f04f0100          MOV      r1,#0                 ;1677
00015e  4640              MOV      r0,r8                 ;1677
000160  f0008116          BEQ.W    |L548.912|
000164  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000168  f1b00a00          SUBS     r10,r0,#0             ;1677
00016c  f04f0500          MOV      r5,#0                 ;1677
000170  f340814c          BLE.W    |L548.1036|
                  |L548.372|
000174  f8d81008          LDR      r1,[r8,#8]            ;1677
000178  f8d80010          LDR      r0,[r8,#0x10]         ;1677
00017c  1c72              ADDS     r2,r6,#1              ;1677
00017e  fb050c01          MLA      r12,r5,r1,r0          ;1677
000182  68a1              LDR      r1,[r4,#8]            ;1677
000184  6920              LDR      r0,[r4,#0x10]         ;1677
000186  42ba              CMP      r2,r7                 ;1677
000188  fb050301          MLA      r3,r5,r1,r0           ;1677
00018c  f8c3b000          STR      r11,[r3,#0]           ;1677
000190  dc79              BGT      |L548.646|
                  |L548.402|
000192  eb0c0082          ADD      r0,r12,r2,LSL #2      ;1677
000196  f8539022          LDR      r9,[r3,r2,LSL #2]     ;1677
00019a  edd00a00          VLDR     s1,[r0,#0]            ;1677
00019e  4611              MOV      r1,r2                 ;1677
0001a0  e0dc              B        |L548.860|
                  |L548.418|
0001a2  f1b90f00          CMP      r9,#0                 ;1656
0001a6  dd0e              BLE      |L548.454|
                  |L548.424|
0001a8  68a2              LDR      r2,[r4,#8]            ;1656
0001aa  6920              LDR      r0,[r4,#0x10]         ;1656
0001ac  fb010202          MLA      r2,r1,r2,r0           ;1656
0001b0  2000              MOVS     r0,#0                 ;1658
0001b2  2d00              CMP      r5,#0                 ;1658
0001b4  dd04              BLE      |L548.448|
                  |L548.438|
0001b6  f8421020          STR      r1,[r2,r0,LSL #2]     ;1659
0001ba  1c40              ADDS     r0,r0,#1              ;1659
0001bc  4285              CMP      r5,r0                 ;1658
0001be  dcfa              BGT      |L548.438|
                  |L548.448|
0001c0  1c49              ADDS     r1,r1,#1              ;1658
0001c2  4549              CMP      r1,r9                 ;1656
0001c4  dbf0              BLT      |L548.424|
                  |L548.454|
0001c6  f1ba0f00          CMP      r10,#0                ;1664
0001ca  d05d              BEQ      |L548.648|
0001cc  2101              MOVS     r1,#1                 ;1664
0001ce  4640              MOV      r0,r8                 ;1664
0001d0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0001d4  f1b00900          SUBS     r9,r0,#0              ;1664
0001d8  f04f0200          MOV      r2,#0                 ;1664
0001dc  dd52              BLE      |L548.644|
                  |L548.478|
0001de  1c70              ADDS     r0,r6,#1              ;1664
0001e0  42b8              CMP      r0,r7                 ;1664
0001e2  dc4c              BGT      |L548.638|
                  |L548.484|
0001e4  f8d83008          LDR      r3,[r8,#8]            ;1664
0001e8  f8d81010          LDR      r1,[r8,#0x10]         ;1664
0001ec  fb001103          MLA      r1,r0,r3,r1           ;1664
0001f0  eb010182          ADD      r1,r1,r2,LSL #2       ;1664
0001f4  68a3              LDR      r3,[r4,#8]            ;1664
0001f6  edd10a00          VLDR     s1,[r1,#0]            ;1664
0001fa  6921              LDR      r1,[r4,#0x10]         ;1664
0001fc  fb001103          MLA      r1,r0,r3,r1           ;1664
000200  f8515022          LDR      r5,[r1,r2,LSL #2]     ;1664
000204  4601              MOV      r1,r0                 ;1664
000206  e013              B        |L548.560|
                  |L548.520|
000208  fb01330c          MLA      r3,r1,r12,r3          ;1664
00020c  eb030382          ADD      r3,r3,r2,LSL #2       ;1664
000210  f1a10a01          SUB      r10,r1,#1             ;1664
000214  ed830a00          VSTR     s0,[r3,#0]            ;1664
000218  f8d4c008          LDR      r12,[r4,#8]           ;1664
00021c  6923              LDR      r3,[r4,#0x10]         ;1664
00021e  fb0a3a0c          MLA      r10,r10,r12,r3        ;1664
000222  fb01330c          MLA      r3,r1,r12,r3          ;1664
000226  f85aa022          LDR      r10,[r10,r2,LSL #2]   ;1664
00022a  f843a022          STR      r10,[r3,r2,LSL #2]    ;1664
00022e  1e49              SUBS     r1,r1,#1              ;1664
                  |L548.560|
000230  42b1              CMP      r1,r6                 ;1664
000232  dd10              BLE      |L548.598|
000234  f8d8c008          LDR      r12,[r8,#8]           ;1664
000238  f8d83010          LDR      r3,[r8,#0x10]         ;1664
00023c  f1a10a01          SUB      r10,r1,#1             ;1664
000240  fb0a3a0c          MLA      r10,r10,r12,r3        ;1664
000244  eb0a0a82          ADD      r10,r10,r2,LSL #2     ;1664
000248  ed9a0a00          VLDR     s0,[r10,#0]           ;1664
00024c  eeb40ae0          VCMPE.F32 s0,s1                 ;1664
000250  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1664
000254  dcd8              BGT      |L548.520|
                  |L548.598|
000256  f8d8c008          LDR      r12,[r8,#8]           ;1664
00025a  f8d83010          LDR      r3,[r8,#0x10]         ;1664
00025e  1c40              ADDS     r0,r0,#1              ;1664
000260  fb01330c          MLA      r3,r1,r12,r3          ;1664
000264  eb030382          ADD      r3,r3,r2,LSL #2       ;1664
000268  42b8              CMP      r0,r7                 ;1664
00026a  edc30a00          VSTR     s1,[r3,#0]            ;1664
00026e  f8d4c008          LDR      r12,[r4,#8]           ;1664
000272  6923              LDR      r3,[r4,#0x10]         ;1664
000274  fb01310c          MLA      r1,r1,r12,r3          ;1664
000278  f8415022          STR      r5,[r1,r2,LSL #2]     ;1664
00027c  ddb2              BLE      |L548.484|
                  |L548.638|
00027e  1c52              ADDS     r2,r2,#1              ;1664
000280  454a              CMP      r2,r9                 ;1664
000282  dbac              BLT      |L548.478|
                  |L548.644|
000284  e0c2              B        |L548.1036|
                  |L548.646|
000286  e07e              B        |L548.902|
                  |L548.648|
000288  4645              MOV      r5,r8                 ;1667
00028a  2101              MOVS     r1,#1                 ;1667
00028c  4640              MOV      r0,r8                 ;1667
00028e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000292  f1b00a00          SUBS     r10,r0,#0             ;1667
000296  f04f0200          MOV      r2,#0                 ;1667
00029a  dd55              BLE      |L548.840|
                  |L548.668|
00029c  68a3              LDR      r3,[r4,#8]            ;1667
00029e  6921              LDR      r1,[r4,#0x10]         ;1667
0002a0  2000              MOVS     r0,#0                 ;1667
0002a2  fb001003          MLA      r0,r0,r3,r1           ;1667
0002a6  f840b022          STR      r11,[r0,r2,LSL #2]    ;1667
0002aa  1c70              ADDS     r0,r6,#1              ;1667
0002ac  42b8              CMP      r0,r7                 ;1667
0002ae  dc48              BGT      |L548.834|
                  |L548.688|
0002b0  68ab              LDR      r3,[r5,#8]            ;1667
0002b2  6929              LDR      r1,[r5,#0x10]         ;1667
0002b4  fb001103          MLA      r1,r0,r3,r1           ;1667
0002b8  eb010182          ADD      r1,r1,r2,LSL #2       ;1667
0002bc  68a3              LDR      r3,[r4,#8]            ;1667
0002be  edd10a00          VLDR     s1,[r1,#0]            ;1667
0002c2  6921              LDR      r1,[r4,#0x10]         ;1667
0002c4  fb001103          MLA      r1,r0,r3,r1           ;1667
0002c8  f8519022          LDR      r9,[r1,r2,LSL #2]     ;1667
0002cc  4601              MOV      r1,r0                 ;1667
0002ce  e013              B        |L548.760|
                  |L548.720|
0002d0  fb01330c          MLA      r3,r1,r12,r3          ;1667
0002d4  eb030382          ADD      r3,r3,r2,LSL #2       ;1667
0002d8  f1a10801          SUB      r8,r1,#1              ;1667
0002dc  ed830a00          VSTR     s0,[r3,#0]            ;1667
0002e0  f8d4c008          LDR      r12,[r4,#8]           ;1667
0002e4  6923              LDR      r3,[r4,#0x10]         ;1667
0002e6  fb08380c          MLA      r8,r8,r12,r3          ;1667
0002ea  fb01330c          MLA      r3,r1,r12,r3          ;1667
0002ee  f8588022          LDR      r8,[r8,r2,LSL #2]     ;1667
0002f2  f8438022          STR      r8,[r3,r2,LSL #2]     ;1667
0002f6  1e49              SUBS     r1,r1,#1              ;1667
                  |L548.760|
0002f8  42b1              CMP      r1,r6                 ;1667
0002fa  dd0f              BLE      |L548.796|
0002fc  f8d5c008          LDR      r12,[r5,#8]           ;1667
000300  692b              LDR      r3,[r5,#0x10]         ;1667
000302  f1a10801          SUB      r8,r1,#1              ;1667
000306  fb08380c          MLA      r8,r8,r12,r3          ;1667
00030a  eb080882          ADD      r8,r8,r2,LSL #2       ;1667
00030e  ed980a00          VLDR     s0,[r8,#0]            ;1667
000312  eeb40ae0          VCMPE.F32 s0,s1                 ;1667
000316  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1667
00031a  d3d9              BCC      |L548.720|
                  |L548.796|
00031c  f8d5c008          LDR      r12,[r5,#8]           ;1667
000320  692b              LDR      r3,[r5,#0x10]         ;1667
000322  1c40              ADDS     r0,r0,#1              ;1667
000324  fb01330c          MLA      r3,r1,r12,r3          ;1667
000328  eb030382          ADD      r3,r3,r2,LSL #2       ;1667
00032c  42b8              CMP      r0,r7                 ;1667
00032e  edc30a00          VSTR     s1,[r3,#0]            ;1667
000332  f8d4c008          LDR      r12,[r4,#8]           ;1667
000336  6923              LDR      r3,[r4,#0x10]         ;1667
000338  fb01310c          MLA      r1,r1,r12,r3          ;1667
00033c  f8419022          STR      r9,[r1,r2,LSL #2]     ;1667
000340  ddb6              BLE      |L548.688|
                  |L548.834|
000342  1c52              ADDS     r2,r2,#1              ;1667
000344  4552              CMP      r2,r10                ;1667
000346  dba9              BLT      |L548.668|
                  |L548.840|
000348  e060              B        |L548.1036|
                  |L548.842|
00034a  ed800a00          VSTR     s0,[r0,#0]            ;1667
00034e  eb030081          ADD      r0,r3,r1,LSL #2       ;1667
000352  f8500c04          LDR      r0,[r0,#-4]           ;1667
000356  f8430021          STR      r0,[r3,r1,LSL #2]     ;1667
00035a  1e49              SUBS     r1,r1,#1              ;1667
                  |L548.860|
00035c  42b1              CMP      r1,r6                 ;1667
00035e  dd08              BLE      |L548.882|
000360  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1667
000364  ed100a01          VLDR     s0,[r0,#-4]           ;1667
000368  eeb40ae0          VCMPE.F32 s0,s1                 ;1667
00036c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1667
000370  dceb              BGT      |L548.842|
                  |L548.882|
000372  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1667
000376  1c52              ADDS     r2,r2,#1              ;1667
000378  edc00a00          VSTR     s1,[r0,#0]            ;1667
00037c  f8439021          STR      r9,[r3,r1,LSL #2]     ;1667
000380  42ba              CMP      r2,r7                 ;1667
000382  f77faf06          BLE      |L548.402|
                  |L548.902|
000386  1c6d              ADDS     r5,r5,#1              ;1667
000388  4555              CMP      r5,r10                ;1667
00038a  f6ffaef3          BLT      |L548.372|
00038e  e03d              B        |L548.1036|
                  |L548.912|
000390  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000394  f1b00a00          SUBS     r10,r0,#0             ;1667
000398  f04f0500          MOV      r5,#0                 ;1667
00039c  dd36              BLE      |L548.1036|
                  |L548.926|
00039e  f8d81008          LDR      r1,[r8,#8]            ;1667
0003a2  f8d80010          LDR      r0,[r8,#0x10]         ;1667
0003a6  1c72              ADDS     r2,r6,#1              ;1667
0003a8  fb050c01          MLA      r12,r5,r1,r0          ;1667
0003ac  68a1              LDR      r1,[r4,#8]            ;1667
0003ae  6920              LDR      r0,[r4,#0x10]         ;1667
0003b0  42ba              CMP      r2,r7                 ;1667
0003b2  fb050301          MLA      r3,r5,r1,r0           ;1667
0003b6  f8c3b000          STR      r11,[r3,#0]           ;1667
0003ba  dc24              BGT      |L548.1030|
                  |L548.956|
0003bc  eb0c0082          ADD      r0,r12,r2,LSL #2      ;1667
0003c0  f8539022          LDR      r9,[r3,r2,LSL #2]     ;1667
0003c4  edd00a00          VLDR     s1,[r0,#0]            ;1667
0003c8  4611              MOV      r1,r2                 ;1667
0003ca  e008              B        |L548.990|
                  |L548.972|
0003cc  ed800a00          VSTR     s0,[r0,#0]            ;1667
0003d0  eb030081          ADD      r0,r3,r1,LSL #2       ;1667
0003d4  f8500c04          LDR      r0,[r0,#-4]           ;1667
0003d8  f8430021          STR      r0,[r3,r1,LSL #2]     ;1667
0003dc  1e49              SUBS     r1,r1,#1              ;1667
                  |L548.990|
0003de  42b1              CMP      r1,r6                 ;1667
0003e0  dd08              BLE      |L548.1012|
0003e2  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1667
0003e6  ed100a01          VLDR     s0,[r0,#-4]           ;1667
0003ea  eeb40ae0          VCMPE.F32 s0,s1                 ;1667
0003ee  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1667
0003f2  d3eb              BCC      |L548.972|
                  |L548.1012|
0003f4  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1667
0003f8  1c52              ADDS     r2,r2,#1              ;1667
0003fa  edc00a00          VSTR     s1,[r0,#0]            ;1667
0003fe  f8439021          STR      r9,[r3,r1,LSL #2]     ;1667
000402  42ba              CMP      r2,r7                 ;1667
000404  ddda              BLE      |L548.956|
                  |L548.1030|
000406  1c6d              ADDS     r5,r5,#1              ;1667
000408  4555              CMP      r5,r10                ;1667
00040a  dbc8              BLT      |L548.926|
                  |L548.1036|
00040c  b003              ADD      sp,sp,#0xc
00040e  2000              MOVS     r0,#0                 ;1684
000410  e8bd8ff0          POP      {r4-r11,pc}
;;;1686   
                          ENDP

                  |L548.1044|
                          DCD      _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::__PRETTY_FUNCTION__
                  |L548.1048|
                          DCD      _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_1 ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::string (instance 3)
                  |L548.1052|
                          DCD      _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_2 ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::string (instance 4)
                  |L548.1056|
                          DCD      _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::string
                  |L548.1060|
                          DCD      _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_0 ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::string (instance 2)
                  |L548.1064|
                          DCD      _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiEs_3 ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::string (instance 5)

                          AREA ||area_number.549||, COMGROUP=_ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii, LINKORDER=||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.549||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||
                          DCD      0x00000001

                          AREA ||.constdata__ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
00001c  696e6561          DCB      0x69,0x6e,0x65,0x61
000020  72536571          DCB      0x72,0x53,0x65,0x71
000024  75656e63          DCB      0x75,0x65,0x6e,0x63
000028  653c5479          DCB      0x65,0x3c,0x54,0x79
00002c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000030  3a636f6d          DCB      0x3a,0x63,0x6f,0x6d
000034  70757465          DCB      0x70,0x75,0x74,0x65
000038  53697a65          DCB      0x53,0x69,0x7a,0x65
00003c  28547970          DCB      0x28,0x54,0x79,0x70
000040  652c2054          DCB      0x65,0x2c,0x20,0x54
000044  7970652c          DCB      0x79,0x70,0x65,0x2c
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  6529205b          DCB      0x65,0x29,0x20,0x5b
000050  77697468          DCB      0x77,0x69,0x74,0x68
000054  20547970          DCB      0x20,0x54,0x79,0x70
000058  65203d20          DCB      0x65,0x20,0x3d,0x20
00005c  7369676e          DCB      0x73,0x69,0x67,0x6e
000060  65642069          DCB      0x65,0x64,0x20,0x69
000064  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2073          DCB      0x20,0x3d,0x20,0x73
000094  69676e65          DCB      0x69,0x67,0x6e,0x65
000098  6420696e          DCB      0x64,0x20,0x69,0x6e
00009c  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000088  6f61745d          DCB      0x6f,0x61,0x74,0x5d
00008c  00                DCB      0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000054  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000bc  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2066          DCB      0x20,0x3d,0x20,0x66
000094  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000098  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20756e          DCB      0x3d,0x20,0x75,0x6e
000088  7369676e          DCB      0x73,0x69,0x67,0x6e
00008c  65642063          DCB      0x65,0x64,0x20,0x63
000090  6861725d          DCB      0x68,0x61,0x72,0x5d
000094  00                DCB      0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  756e7369          DCB      0x75,0x6e,0x73,0x69
000054  676e6564          DCB      0x67,0x6e,0x65,0x64
000058  20636861          DCB      0x20,0x63,0x68,0x61
00005c  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  756e7369          DCB      0x75,0x6e,0x73,0x69
0000bc  676e6564          DCB      0x67,0x6e,0x65,0x64
0000c0  20636861          DCB      0x20,0x63,0x68,0x61
0000c4  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2075          DCB      0x20,0x3d,0x20,0x75
000094  6e736967          DCB      0x6e,0x73,0x69,0x67
000098  6e656420          DCB      0x6e,0x65,0x64,0x20
00009c  63686172          DCB      0x63,0x68,0x61,0x72
0000a0  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  53657443          DCB      0x53,0x65,0x74,0x43
00002c  61737428          DCB      0x61,0x73,0x74,0x28
000030  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000034  7420416e          DCB      0x74,0x20,0x41,0x6e
000038  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00003c  456d6265          DCB      0x45,0x6d,0x62,0x65
000040  64646564          DCB      0x64,0x64,0x65,0x64
000044  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000048  7261793c          DCB      0x72,0x61,0x79,0x3c
00004c  496e5479          DCB      0x49,0x6e,0x54,0x79
000050  70653e20          DCB      0x70,0x65,0x3e,0x20
000054  2629205b          DCB      0x26,0x29,0x20,0x5b
000058  77697468          DCB      0x77,0x69,0x74,0x68
00005c  20496e54          DCB      0x20,0x49,0x6e,0x54
000060  79706520          DCB      0x79,0x70,0x65,0x20
000064  3d20756e          DCB      0x3d,0x20,0x75,0x6e
000068  7369676e          DCB      0x73,0x69,0x67,0x6e
00006c  65642063          DCB      0x65,0x64,0x20,0x63
000070  6861722c          DCB      0x68,0x61,0x72,0x2c
000074  20547970          DCB      0x20,0x54,0x79,0x70
000078  65203d20          DCB      0x65,0x20,0x3d,0x20
00007c  756e7369          DCB      0x75,0x6e,0x73,0x69
000080  676e6564          DCB      0x67,0x6e,0x65,0x64
000084  20636861          DCB      0x20,0x63,0x68,0x61
000088  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20756e          DCB      0x3d,0x20,0x75,0x6e
000088  7369676e          DCB      0x73,0x69,0x67,0x6e
00008c  65642069          DCB      0x65,0x64,0x20,0x69
000090  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIjE7SetZeroEvE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE7SetZeroEvE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::SetZero()::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  5365745a          DCB      0x53,0x65,0x74,0x5a
00002c  65726f28          DCB      0x65,0x72,0x6f,0x28
000030  29205b77          DCB      0x29,0x20,0x5b,0x77
000034  69746820          DCB      0x69,0x74,0x68,0x20
000038  54797065          DCB      0x54,0x79,0x70,0x65
00003c  203d2075          DCB      0x20,0x3d,0x20,0x75
000040  6e736967          DCB      0x6e,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e745d          DCB      0x69,0x6e,0x74,0x5d
00004c  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  756e7369          DCB      0x75,0x6e,0x73,0x69
0000bc  676e6564          DCB      0x67,0x6e,0x65,0x64
0000c0  20696e74          DCB      0x20,0x69,0x6e,0x74
0000c4  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2075          DCB      0x20,0x3d,0x20,0x75
000094  6e736967          DCB      0x6e,0x73,0x69,0x67
000098  6e656420          DCB      0x6e,0x65,0x64,0x20
00009c  696e745d          DCB      0x69,0x6e,0x74,0x5d
0000a0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a5669          DCB      0x3a,0x3a,0x56,0x69
000098  73696f6e          DCB      0x73,0x69,0x6f,0x6e
00009c  4d61726b          DCB      0x4d,0x61,0x72,0x6b
0000a0  65725d00          DCB      0x65,0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  56697369          DCB      0x56,0x69,0x73,0x69
0000cc  6f6e4d61          DCB      0x6f,0x6e,0x4d,0x61
0000d0  726b6572          DCB      0x72,0x6b,0x65,0x72
0000d4  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a56          DCB      0x64,0x3a,0x3a,0x56
0000a4  6973696f          DCB      0x69,0x73,0x69,0x6f
0000a8  6e4d6172          DCB      0x6e,0x4d,0x61,0x72
0000ac  6b65725d          DCB      0x6b,0x65,0x72,0x5d
0000b0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a5669          DCB      0x3a,0x3a,0x56,0x69
000098  73696f6e          DCB      0x73,0x69,0x6f,0x6e
00009c  4d61726b          DCB      0x4d,0x61,0x72,0x6b
0000a0  6572202a          DCB      0x65,0x72,0x20,0x2a
0000a4  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  56697369          DCB      0x56,0x69,0x73,0x69
0000cc  6f6e4d61          DCB      0x6f,0x6e,0x4d,0x61
0000d0  726b6572          DCB      0x72,0x6b,0x65,0x72
0000d4  202a5d00          DCB      0x20,0x2a,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a56          DCB      0x64,0x3a,0x3a,0x56
0000a4  6973696f          DCB      0x69,0x73,0x69,0x6f
0000a8  6e4d6172          DCB      0x6e,0x4d,0x61,0x72
0000ac  6b657220          DCB      0x6b,0x65,0x72,0x20
0000b0  2a5d00            DCB      0x2a,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a496e73          DCB      0x3a,0x49,0x6e,0x73
000028  65727469          DCB      0x65,0x72,0x74,0x69
00002c  6f6e536f          DCB      0x6f,0x6e,0x53,0x6f
000030  72742841          DCB      0x72,0x74,0x28,0x41
000034  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000038  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00003c  65646465          DCB      0x65,0x64,0x64,0x65
000040  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000044  72726179          DCB      0x72,0x72,0x61,0x79
000048  3c547970          DCB      0x3c,0x54,0x79,0x70
00004c  653e2026          DCB      0x65,0x3e,0x20,0x26
000050  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000054  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000058  456d6265          DCB      0x45,0x6d,0x62,0x65
00005c  64646564          DCB      0x64,0x64,0x65,0x64
000060  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000064  7261793c          DCB      0x72,0x61,0x79,0x3c
000068  7369676e          DCB      0x73,0x69,0x67,0x6e
00006c  65642069          DCB      0x65,0x64,0x20,0x69
000070  6e743e20          DCB      0x6e,0x74,0x3e,0x20
000074  262c2073          DCB      0x26,0x2c,0x20,0x73
000078  69676e65          DCB      0x69,0x67,0x6e,0x65
00007c  6420696e          DCB      0x64,0x20,0x69,0x6e
000080  742c2062          DCB      0x74,0x2c,0x20,0x62
000084  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
000088  20736967          DCB      0x20,0x73,0x69,0x67
00008c  6e656420          DCB      0x6e,0x65,0x64,0x20
000090  696e742c          DCB      0x69,0x6e,0x74,0x2c
000094  20736967          DCB      0x20,0x73,0x69,0x67
000098  6e656420          DCB      0x6e,0x65,0x64,0x20
00009c  696e7429          DCB      0x69,0x6e,0x74,0x29
0000a0  205b7769          DCB      0x20,0x5b,0x77,0x69
0000a4  74682054          DCB      0x74,0x68,0x20,0x54
0000a8  79706520          DCB      0x79,0x70,0x65,0x20
0000ac  3d20666c          DCB      0x3d,0x20,0x66,0x6c
0000b0  6f61745d          DCB      0x6f,0x61,0x74,0x5d
0000b4  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a4d756c          DCB      0x3a,0x4d,0x75,0x6c
000028  7469706c          DCB      0x74,0x69,0x70,0x6c
00002c  7928636f          DCB      0x79,0x28,0x63,0x6f
000030  6e737420          DCB      0x6e,0x73,0x74,0x20
000034  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000038  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00003c  62656464          DCB      0x62,0x65,0x64,0x64
000040  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000044  41727261          DCB      0x41,0x72,0x72,0x61
000048  793c5479          DCB      0x79,0x3c,0x54,0x79
00004c  70653e20          DCB      0x70,0x65,0x3e,0x20
000050  262c2063          DCB      0x26,0x2c,0x20,0x63
000054  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a417272          DCB      0x3a,0x41,0x72,0x72
00006c  61793c54          DCB      0x61,0x79,0x3c,0x54
000070  7970653e          DCB      0x79,0x70,0x65,0x3e
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00007c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000080  62656464          DCB      0x62,0x65,0x64,0x64
000084  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000088  41727261          DCB      0x41,0x72,0x72,0x61
00008c  793c4f75          DCB      0x79,0x3c,0x4f,0x75
000090  74547970          DCB      0x74,0x54,0x79,0x70
000094  653e2026          DCB      0x65,0x3e,0x20,0x26
000098  29205b77          DCB      0x29,0x20,0x5b,0x77
00009c  69746820          DCB      0x69,0x74,0x68,0x20
0000a0  496e5479          DCB      0x49,0x6e,0x54,0x79
0000a4  7065203d          DCB      0x70,0x65,0x20,0x3d
0000a8  20666c6f          DCB      0x20,0x66,0x6c,0x6f
0000ac  61742c20          DCB      0x61,0x74,0x2c,0x20
0000b0  4f757454          DCB      0x4f,0x75,0x74,0x54
0000b4  79706520          DCB      0x79,0x70,0x65,0x20
0000b8  3d20666c          DCB      0x3d,0x20,0x66,0x6c
0000bc  6f61745d          DCB      0x6f,0x61,0x74,0x5d
0000c0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a496d61          DCB      0x3a,0x49,0x6d,0x61
000020  67655072          DCB      0x67,0x65,0x50,0x72
000024  6f636573          DCB      0x6f,0x63,0x65,0x73
000028  73696e67          DCB      0x73,0x69,0x6e,0x67
00002c  3a3a446f          DCB      0x3a,0x3a,0x44,0x6f
000030  776e7361          DCB      0x77,0x6e,0x73,0x61
000034  6d706c65          DCB      0x6d,0x70,0x6c,0x65
000038  4279506f          DCB      0x42,0x79,0x50,0x6f
00003c  7765724f          DCB      0x77,0x65,0x72,0x4f
000040  6654776f          DCB      0x66,0x54,0x77,0x6f
000044  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000048  73742041          DCB      0x73,0x74,0x20,0x41
00004c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000050  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000054  65646465          DCB      0x65,0x64,0x64,0x65
000058  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00005c  72726179          DCB      0x72,0x72,0x61,0x79
000060  3c547970          DCB      0x3c,0x54,0x79,0x70
000064  653e2026          DCB      0x65,0x3e,0x20,0x26
000068  2c207369          DCB      0x2c,0x20,0x73,0x69
00006c  676e6564          DCB      0x67,0x6e,0x65,0x64
000070  20696e74          DCB      0x20,0x69,0x6e,0x74
000074  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000078  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00007c  456d6265          DCB      0x45,0x6d,0x62,0x65
000080  64646564          DCB      0x64,0x64,0x65,0x64
000084  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000088  7261793c          DCB      0x72,0x61,0x79,0x3c
00008c  4f757454          DCB      0x4f,0x75,0x74,0x54
000090  7970653e          DCB      0x79,0x70,0x65,0x3e
000094  20262c20          DCB      0x20,0x26,0x2c,0x20
000098  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00009c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000a0  62656464          DCB      0x62,0x65,0x64,0x64
0000a4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000a8  4d656d6f          DCB      0x4d,0x65,0x6d,0x6f
0000ac  72795374          DCB      0x72,0x79,0x53,0x74
0000b0  61636b29          DCB      0x61,0x63,0x6b,0x29
0000b4  205b7769          DCB      0x20,0x5b,0x77,0x69
0000b8  74682049          DCB      0x74,0x68,0x20,0x49
0000bc  6e547970          DCB      0x6e,0x54,0x79,0x70
0000c0  65203d20          DCB      0x65,0x20,0x3d,0x20
0000c4  756e7369          DCB      0x75,0x6e,0x73,0x69
0000c8  676e6564          DCB      0x67,0x6e,0x65,0x64
0000cc  20636861          DCB      0x20,0x63,0x68,0x61
0000d0  722c2049          DCB      0x72,0x2c,0x20,0x49
0000d4  6e746572          DCB      0x6e,0x74,0x65,0x72
0000d8  6d656469          DCB      0x6d,0x65,0x64,0x69
0000dc  61746554          DCB      0x61,0x74,0x65,0x54
0000e0  79706520          DCB      0x79,0x70,0x65,0x20
0000e4  3d20756e          DCB      0x3d,0x20,0x75,0x6e
0000e8  7369676e          DCB      0x73,0x69,0x67,0x6e
0000ec  65642069          DCB      0x65,0x64,0x20,0x69
0000f0  6e742c20          DCB      0x6e,0x74,0x2c,0x20
0000f4  4f757454          DCB      0x4f,0x75,0x74,0x54
0000f8  79706520          DCB      0x79,0x70,0x65,0x20
0000fc  3d20756e          DCB      0x3d,0x20,0x75,0x6e
000100  7369676e          DCB      0x73,0x69,0x67,0x6e
000104  65642063          DCB      0x65,0x64,0x20,0x63
000108  6861725d          DCB      0x68,0x61,0x72,0x5d
00010c  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "supervisor\\src\\offboardVisionSystem.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_offboardVisionSystem_cpp_b6ff7547___Z7__REV16j|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___24_offboardVisionSystem_cpp_b6ff7547___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_offboardVisionSystem_cpp_b6ff7547___Z7__REVSHi|
#line 144
|__asm___24_offboardVisionSystem_cpp_b6ff7547___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
