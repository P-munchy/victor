; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\path.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\path.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\path.crf ..\coretech\planning\shared\src\path.cpp]
                          THUMB

                          AREA ||i._ZN4Anki8Planning11GetArcAngleEffffffb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Planning11GetArcAngleEffffffb PROC ; Anki::Planning::GetArcAngle(float, float, float, float, float, float, bool)
;;;599        // Returns angle between two points on a circle
;;;600        f32 GetArcAngle(f32 start_x, f32 start_y, f32 end_x, f32 end_y, f32 center_x, f32 center_y, bool CCW)
000000  b510              PUSH     {r4,lr}
;;;601        {
000002  4604              MOV      r4,r0
000004  ed2d8b04          VPUSH    {d8-d9}
;;;602          f32 a_start_x, a_start_y;  // Vector from circle center to starting point on circle when computing arc length
;;;603          f32 a_end_x, a_end_y;      // Vector from circle center to end point on circle when computing arc length
;;;604          
;;;605          
;;;606          a_start_x = start_x - center_x;
000008  ee308a42          VSUB.F32 s16,s0,s4
;;;607          a_start_y = start_y - center_y;
00000c  ee708ae2          VSUB.F32 s17,s1,s5
;;;608          
;;;609          a_end_x = end_x - center_x;
000010  ee710a42          VSUB.F32 s1,s2,s4
;;;610          a_end_y = end_y - center_y;
000014  ee310ae2          VSUB.F32 s0,s3,s5
;;;611          
;;;612          f32 theta = ATAN2_ACC(a_end_y, a_end_x) - ATAN2_ACC(a_start_y, a_start_x);
000018  f7fffffe          BL       _Z9atan2_accff ; atan2_acc(float, float)
00001c  eeb09a40          VMOV.F32 s18,s0
000020  eef00a48          VMOV.F32 s1,s16
000024  eeb00a68          VMOV.F32 s0,s17
000028  f7fffffe          BL       _Z9atan2_accff ; atan2_acc(float, float)
00002c  ee390a40          VSUB.F32 s0,s18,s0
;;;613          if (theta < 0 && CCW)
;;;614            return theta + 2*PI_F;
000030  eddf0a0e          VLDR     s1,|L1.108|
000034  eeb50ac0          VCMPE.F32 s0,#0.0               ;613
000038  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;613
00003c  d206              BCS      |L1.76|
00003e  2c00              CMP      r4,#0                 ;613
000040  bf1e              ITTT     NE
000042  ee300a20          VADDNE.F32 s0,s0,s1
;;;615          else if (theta > 0 && !CCW)
;;;616            return theta - 2*PI_F;
;;;617          
;;;618          return theta;
;;;619        }
000046  ecbd8b04          VPOPNE   {d8-d9}
00004a  bd10              POPNE    {r4,pc}
                  |L1.76|
00004c  eeb50ac0          VCMPE.F32 s0,#0.0               ;615
000050  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;615
000054  bfdc              ITT      LE
000056  ecbd8b04          VPOPLE   {d8-d9}
00005a  bd10              POPLE    {r4,pc}
00005c  2c00              CMP      r4,#0                 ;615
00005e  bf08              IT       EQ                    ;616
000060  ee300a60          VSUBEQ.F32 s0,s0,s1              ;616
000064  ecbd8b04          VPOP     {d8-d9}
000068  bd10              POP      {r4,pc}
;;;620        
                          ENDP

00006a  0000              DCW      0x0000
                  |L1.108|
00006c  40c90fdb          DCFS     0x40c90fdb ; 6.2831854820251465

                          AREA ||i._ZN4Anki8Planning11PathSegment10DefineLineEfffffff||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Planning11PathSegment10DefineLineEfffffff PROC ; Anki::Planning::PathSegment::DefineLine(float, float, float, float, float, float, float)
;;;31         ////////////// PathSegment implementations ////////////
;;;32         void PathSegment::DefineLine(f32 x_start, f32 y_start, f32 x_end, f32 y_end,
000000  2101              MOVS     r1,#1
;;;33                                      f32 targetSpeed, f32 accel, f32 decel)
;;;34         {
;;;35           type_ = PST_LINE;
000002  7001              STRB     r1,[r0,#0]
000004  ed802a06          VSTR     s4,[r0,#0x18]
000008  edc02a07          VSTR     s5,[r0,#0x1c]
00000c  ed803a08          VSTR     s6,[r0,#0x20]
000010  1d01              ADDS     r1,r0,#4
000012  ec810a04          VSTM     r1,{s0-s3}
;;;36           def_.line.startPt_x = x_start;
;;;37           def_.line.startPt_y = y_start;
;;;38           def_.line.endPt_x = x_end;
;;;39           def_.line.endPt_y = y_end;
;;;40           
;;;41           SetSpeedProfile(targetSpeed, accel, decel);
;;;42         }
000016  4770              BX       lr
;;;43         
                          ENDP


                          AREA ||i._ZN4Anki8Planning11PathSegment11OffsetStartEff||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Planning11PathSegment11OffsetStartEff PROC ; Anki::Planning::PathSegment::OffsetStart(float, float)
;;;91         
;;;92         void PathSegment::OffsetStart(f32 xOffset, f32 yOffset)
000000  b510              PUSH     {r4,lr}
;;;93         {
;;;94           switch(type_) {
000002  7801              LDRB     r1,[r0,#0]
000004  2901              CMP      r1,#1
000006  d008              BEQ      |L3.26|
000008  2902              CMP      r1,#2
00000a  bf18              IT       NE
00000c  2903              CMPNE    r1,#3
00000e  d01d              BEQ      |L3.76|
;;;95           case PST_LINE:
;;;96             def_.line.startPt_x += xOffset;
;;;97             def_.line.startPt_y += yOffset;
;;;98             def_.line.endPt_x += xOffset;
;;;99             def_.line.endPt_y += yOffset;
;;;100            break;
;;;101          case PST_ARC:
;;;102            def_.arc.centerPt_x += xOffset;
;;;103            def_.arc.centerPt_y += yOffset;
;;;104            break;
;;;105          case PST_POINT_TURN:
;;;106            def_.turn.x += xOffset;
;;;107            def_.turn.y += yOffset;
;;;108            break;
;;;109          default:
;;;110            CoreTechPrint("ERROR (OffsetStart): Undefined segment %d\n", type_);
000010  a015              ADR      r0,|L3.104|
000012  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;111            assert(false);
000016  f7fffffe          BL       abort
                  |L3.26|
00001a  ed901a01          VLDR     s2,[r0,#4]            ;96
00001e  ee311a00          VADD.F32 s2,s2,s0              ;96
000022  ed801a01          VSTR     s2,[r0,#4]            ;96
000026  ed901a02          VLDR     s2,[r0,#8]            ;97
00002a  ee311a20          VADD.F32 s2,s2,s1              ;97
00002e  ed801a02          VSTR     s2,[r0,#8]            ;97
000032  ed901a03          VLDR     s2,[r0,#0xc]          ;98
000036  ee310a00          VADD.F32 s0,s2,s0              ;98
00003a  ed800a03          VSTR     s0,[r0,#0xc]          ;98
00003e  ed900a04          VLDR     s0,[r0,#0x10]         ;99
000042  ee300a20          VADD.F32 s0,s0,s1              ;99
000046  ed800a04          VSTR     s0,[r0,#0x10]         ;99
;;;112          }
;;;113        }
00004a  bd10              POP      {r4,pc}
                  |L3.76|
00004c  ed901a01          VLDR     s2,[r0,#4]            ;106
000050  ee310a00          VADD.F32 s0,s2,s0              ;106
000054  ed800a01          VSTR     s0,[r0,#4]            ;106
000058  ed900a02          VLDR     s0,[r0,#8]            ;107
00005c  ee300a20          VADD.F32 s0,s0,s1              ;107
000060  ed800a02          VSTR     s0,[r0,#8]            ;107
000064  bd10              POP      {r4,pc}
;;;114    
                          ENDP

000066  0000              DCW      0x0000
                  |L3.104|
000068  4552524f          DCB      "ERROR (OffsetStart): Undefined segment %d\n",0
00006c  5220284f
000070  66667365
000074  74537461
000078  7274293a
00007c  20556e64
000080  6566696e
000084  65642073
000088  65676d65
00008c  6e742025
000090  640a00  
000093  00                DCB      0

                          AREA ||i._ZN4Anki8Planning11PathSegment15DefinePointTurnEffffff||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Planning11PathSegment15DefinePointTurnEffffff PROC ; Anki::Planning::PathSegment::DefinePointTurn(float, float, float, float, float, float)
;;;56         
;;;57         void PathSegment::DefinePointTurn(f32 x, f32 y, f32 targetAngle,
000000  2103              MOVS     r1,#3
;;;58                                           f32 targetRotSpeed, f32 rotAccel, f32 rotDecel)
;;;59         {
;;;60           type_ = PST_POINT_TURN;
000002  7001              STRB     r1,[r0,#0]
;;;61           def_.turn.x = x;
000004  ed800a01          VSTR     s0,[r0,#4]
;;;62           def_.turn.y = y;
000008  edc00a02          VSTR     s1,[r0,#8]
;;;63           def_.turn.targetAngle = targetAngle;
00000c  ed801a03          VSTR     s2,[r0,#0xc]
000010  edc01a06          VSTR     s3,[r0,#0x18]
000014  ed802a07          VSTR     s4,[r0,#0x1c]
000018  edc02a08          VSTR     s5,[r0,#0x20]
;;;64           
;;;65           SetSpeedProfile(targetRotSpeed, rotAccel, rotDecel);
;;;66         }
00001c  4770              BX       lr
;;;67     
                          ENDP


                          AREA ||i._ZN4Anki8Planning11PathSegment15SetSpeedProfileEfff||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Planning11PathSegment15SetSpeedProfileEfff PROC ; Anki::Planning::PathSegment::SetSpeedProfile(float, float, float)
;;;67     
;;;68         void PathSegment::SetSpeedProfile(f32 targetSpeed, f32 accel, f32 decel)
000000  ed800a06          VSTR     s0,[r0,#0x18]
;;;69         {
;;;70           targetSpeed_ = targetSpeed;
;;;71           accel_ = accel;
000004  edc00a07          VSTR     s1,[r0,#0x1c]
;;;72           decel_ = decel;
000008  ed801a08          VSTR     s2,[r0,#0x20]
;;;73         }
00000c  4770              BX       lr
;;;74         
                          ENDP


                          AREA ||i._ZN4Anki8Planning11PathSegment9DefineArcEffffffff||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Planning11PathSegment9DefineArcEffffffff PROC ; Anki::Planning::PathSegment::DefineArc(float, float, float, float, float, float, float, float)
;;;43         
;;;44         void PathSegment::DefineArc(f32 x_center, f32 y_center, f32 radius, f32 startRad, f32 sweepRad,
000000  2102              MOVS     r1,#2
;;;45                                     f32 targetSpeed, f32 accel, f32 decel)
;;;46         {
;;;47           type_ = PST_ARC;
000002  f8001b04          STRB     r1,[r0],#4
000006  ec800a08          VSTM     r0,{s0-s7}
;;;48           def_.arc.centerPt_x = x_center;
;;;49           def_.arc.centerPt_y = y_center;
;;;50           def_.arc.radius = radius;
;;;51           def_.arc.startRad = startRad;
;;;52           def_.arc.sweepRad = sweepRad;
;;;53           
;;;54           SetSpeedProfile(targetSpeed, accel, decel);
;;;55         }
00000a  4770              BX       lr
;;;56         
                          ENDP


                          AREA ||i._ZN4Anki8Planning16GenerateCSCCurveEfffffffffffNS0_14DubinsPathTypeEPNS0_11PathSegmentERf||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Planning16GenerateCSCCurveEfffffffffffNS0_14DubinsPathTypeEPNS0_11PathSegmentERf PROC ; Anki::Planning::GenerateCSCCurve(float, float, float, float, float, float, float, float, float, float, float, Anki::Planning::DubinsPathType, Anki::Planning::PathSegment*, float&)
;;;623        // Returns the number of segments in the path.
;;;624        u8 GenerateCSCCurve(f32 startPt_x, f32 startPt_y, f32 startPt_theta,
000000  b577              PUSH     {r0-r2,r4-r6,lr}
;;;625                            f32 endPt_x, f32 endPt_y, f32 endPt_theta,
;;;626                            f32 start_radius, f32 end_radius,
;;;627                            f32 targetSpeed, f32 accel, f32 decel,
;;;628                            DubinsPathType pathType, PathSegment path[], f32 &path_length)
;;;629        {
000002  4614              MOV      r4,r2
000004  ed2d0b0c          VPUSH    {d0-d5}
000008  460e              MOV      r6,r1
;;;630         
;;;631          assert(pathType != NUM_DUBINS_PATHS);
00000a  2804              CMP      r0,#4
00000c  ed2d8b10          VPUSH    {d8-d15}              ;629
000010  b081              SUB      sp,sp,#4              ;629
000012  eeb0da63          VMOV.F32 s26,s7                ;629
000016  eef0da43          VMOV.F32 s27,s6                ;629
00001a  eef0ca62          VMOV.F32 s25,s5                ;629
00001e  eeb0ba41          VMOV.F32 s22,s2                ;629
000022  eef0ea60          VMOV.F32 s29,s1                ;629
000026  eeb0fa40          VMOV.F32 s30,s0                ;629
00002a  d02a              BEQ      |L7.130|
;;;632          
;;;633          // Compute LSL, LSR, RSR, RSL paths
;;;634          // http://gieseanw.wordpress.com/2012/10/21/a-comprehensive-step-by-step-tutorial-to-computing-dubins-paths/
;;;635          
;;;636          // p_c1: Center of circle 1 (for start pose) which has radius r1.
;;;637          // p_c2: Center of circle 2 (for end pose) which has radius r2
;;;638          // V1: Vector from p_c1 to p_c2
;;;639          // V2: Tangent vector from p_t1 on circle 1 to p_t2 on circle 2
;;;640          // n: Unit normal vector (perpendicular to V2)
;;;641          //
;;;642          // V1 can be made to be parallel to V2 by subtracting (r1-r2) • n
;;;643          // So n • (V1 - ((r1-r2) • n)) = 0, since n and (V1 - ((r1-r2) • n)) are orthogonal
;;;644          //    n • V1 + r2 - r1 = 0
;;;645          //    n • V1 = r1 - r2
;;;646          //
;;;647          // Let D be the magnitude of V1.
;;;648          // Let v1 be V1 normalized so that
;;;649          //
;;;650          //    n • v1 = (r1 - r2)/D
;;;651          //
;;;652          // Let c = (r1-r2)/D
;;;653          // c is the cosine of the angle between v1 and n, since A • B == |A| |B| cos(theta).
;;;654          //
;;;655          // This means the sine of the angle is sqrt(1-c^2), since sin^2 + cos^2 = 1.
;;;656          //
;;;657          // If v1 is rotated by acos(c) then we have n.
;;;658          //
;;;659          // n_x = v1_x * c - v1_y * sqrt(1-c^2)
;;;660          // n_y = v1_x * sqrt(1-c^2) + v1_y * c
;;;661          //
;;;662          // Follow n by r1 from p_c1 to get p_t1.
;;;663          // Follow n by r2 from p_c2 to get p_t2.
;;;664          
;;;665          
;;;666          f32 r1 = ABS(start_radius);
00002c  eef5dac0          VCMPE.F32 s27,#0.0
000030  eef1fa10          VMRS     APSR_nzcv,FPSCR
000034  bfac              ITE      GE
000036  eef08a6d          VMOVGE.F32 s17,s27
00003a  eef18a6d          VNEGLT.F32 s17,s27
;;;667          f32 r2 = ABS(end_radius);
00003e  eeb5dac0          VCMPE.F32 s26,#0.0
000042  eef1fa10          VMRS     APSR_nzcv,FPSCR
000046  bfac              ITE      GE
000048  eeb08a4d          VMOVGE.F32 s16,s26
00004c  eeb18a4d          VNEGLT.F32 s16,s26
;;;668          f32 p_c1_x, p_c1_y;    // Center point of circle 1
;;;669          f32 p_c2_x, p_c2_y;    // Center point of circle 2
;;;670          f32 p_t1_x, p_t1_y;    // Tangent point on circle 1
;;;671          f32 p_t2_x, p_t2_y;    // Tangent point on circle 2
;;;672          f32 V1_x, V1_y;        // Vector from p_c1 to p_t1
;;;673          f32 n_x, n_y;          // Orthogonal vector to tangent line
;;;674          f32 v1_x, v1_y;        // Unit vector of V1
;;;675          f32 V1_mag;            // Magnitude of V1
;;;676          f32 cosTanPtAngle, sinTanPtAngle;
;;;677          f32 segment_length;
;;;678          u8 num_segments = 0;
000050  2500              MOVS     r5,#0
;;;679          PathSegment* ps;
;;;680          
;;;681          path_length = FLT_MAX;
000052  ed9f0aae          VLDR     s0,|L7.780|
;;;682    
;;;683          
;;;684          f32 sign1;
;;;685          f32 sign2;
;;;686          f32 minCircleDist;
;;;687          switch(pathType) {
;;;688            case RSR:
;;;689              sign1 = 1.0;
;;;690              sign2 = 1.0;
;;;691              minCircleDist = ABS(r1 - r2);
;;;692              break;
;;;693            case LSL:
;;;694              sign1 = -1.0;
000056  eebf9a00          VMOV.F32 s18,#-1.00000000
00005a  ed840a00          VSTR     s0,[r4,#0]            ;681
00005e  eef7fa00          VMOV.F32 s31,#1.00000000       ;689
000062  b1e0              CBZ      r0,|L7.158|
000064  2801              CMP      r0,#1                 ;687
;;;695              sign2 = -1.0;
;;;696              minCircleDist = ABS(r1 - r2);
;;;697              break;
;;;698            case RSL:
;;;699              sign1 = 1.0;
;;;700              sign2 = -1.0;
;;;701              minCircleDist = r1 + r2;
;;;702              break;
;;;703            case LSR:
;;;704              sign1 = -1.0;
000066  bf04              ITT      EQ
000068  eef09a49          VMOVEQ.F32 s19,s18
;;;705              sign2 = 1.0;
00006c  eeb09a6f          VMOVEQ.F32 s18,s31
000070  d021              BEQ      |L7.182|
000072  2802              CMP      r0,#2                 ;687
000074  bf08              IT       EQ                    ;699
000076  eef09a6f          VMOVEQ.F32 s19,s31               ;699
00007a  d01c              BEQ      |L7.182|
00007c  2803              CMP      r0,#3                 ;687
00007e  d002              BEQ      |L7.134|
000080  e059              B        |L7.310|
                  |L7.130|
000082  f7fffffe          BL       abort
                  |L7.134|
000086  ee38aac8          VSUB.F32 s20,s17,s16           ;691
00008a  eef09a6f          VMOV.F32 s19,s31               ;689
00008e  eeb09a69          VMOV.F32 s18,s19               ;690
000092  eeb5aac0          VCMPE.F32 s20,#0.0              ;691
000096  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;691
00009a  da0e              BGE      |L7.186|
00009c  e008              B        |L7.176|
                  |L7.158|
00009e  ee38aac8          VSUB.F32 s20,s17,s16           ;696
0000a2  eef09a49          VMOV.F32 s19,s18               ;694
0000a6  eeb5aac0          VCMPE.F32 s20,#0.0              ;696
0000aa  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;696
0000ae  da04              BGE      |L7.186|
                  |L7.176|
0000b0  ee38aa68          VSUB.F32 s20,s16,s17           ;696
0000b4  e001              B        |L7.186|
                  |L7.182|
0000b6  ee38aa88          VADD.F32 s20,s17,s16           ;701
                  |L7.186|
;;;706              minCircleDist = r1 + r2;
;;;707              break;
;;;708            default:
;;;709              return 0;
;;;710          }
;;;711          
;;;712          
;;;713          // Compute center of circle 1
;;;714          p_c1_x = startPt_x + sign1 * r1 * sinf(startPt_theta);
0000ba  eeb00a4b          VMOV.F32 s0,s22
0000be  f7fffffe          BL       __hardfp_sinf
0000c2  ee69aaa8          VMUL.F32 s21,s19,s17
0000c6  eeb0ca4f          VMOV.F32 s24,s30
0000ca  edcdaa00          VSTR     s21,[sp,#0]
0000ce  ee0aca80          VMLA.F32 s24,s21,s0
;;;715          p_c1_y = startPt_y - sign1 * r1 * cosf(startPt_theta);
0000d2  eeb00a4b          VMOV.F32 s0,s22
0000d6  f7fffffe          BL       __hardfp_cosf
0000da  eef0ba6e          VMOV.F32 s23,s29
0000de  ee4abac0          VMLS.F32 s23,s21,s0
;;;716          
;;;717          // Compute center of circle 2
;;;718          p_c2_x = endPt_x + sign2 * r2 * sinf(endPt_theta);
0000e2  eeb00a6c          VMOV.F32 s0,s25
0000e6  f7fffffe          BL       __hardfp_sinf
0000ea  ee29ea08          VMUL.F32 s28,s18,s16
0000ee  ed9dba14          VLDR     s22,[sp,#0x50]
0000f2  ee0eba00          VMLA.F32 s22,s28,s0
;;;719          p_c2_y = endPt_y - sign2 * r2 * cosf(endPt_theta);
0000f6  eeb00a6c          VMOV.F32 s0,s25
0000fa  f7fffffe          BL       __hardfp_cosf
0000fe  edddaa15          VLDR     s21,[sp,#0x54]
000102  ee4eaa40          VMLS.F32 s21,s28,s0
;;;720          
;;;721          // Compute V1
;;;722          V1_x = p_c2_x - p_c1_x;
000106  ee3bea4c          VSUB.F32 s28,s22,s24
;;;723          V1_y = p_c2_y - p_c1_y;
;;;724          V1_mag = sqrtf(V1_x * V1_x + V1_y * V1_y);
00010a  ee6e0a0e          VMUL.F32 s1,s28,s28
00010e  ee7acaeb          VSUB.F32 s25,s21,s23           ;723
000112  ee4c0aac          VMLA.F32 s1,s25,s25
000116  eeb10ae0          VSQRT.F32 s0,s1
00011a  eeb40a40          VCMP.F32 s0,s0
00011e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000122  bf1c              ITT      NE
000124  eeb00a60          VMOVNE.F32 s0,s1
000128  f7fffffe          BLNE     __hardfp_sqrtf
;;;725    
;;;726          // Check if circle centers are too close together
;;;727          if (V1_mag <= minCircleDist) {
00012c  eeb40aca          VCMPE.F32 s0,s20
000130  eef1fa10          VMRS     APSR_nzcv,FPSCR
000134  d805              BHI      |L7.322|
                  |L7.310|
;;;728            return 0;
000136  2000              MOVS     r0,#0
                  |L7.312|
;;;729          }
;;;730          
;;;731          v1_x = V1_x / V1_mag;
;;;732          v1_y = V1_y / V1_mag;
;;;733          
;;;734          // Compute cosTanPtAngle (aka c) and sinTanPtAngle
;;;735          cosTanPtAngle = (sign1 * r1 - sign2 * r2) / V1_mag;
;;;736          sinTanPtAngle = sqrtf(1-cosTanPtAngle*cosTanPtAngle);
;;;737          
;;;738          // Compute n
;;;739          n_x = v1_x * cosTanPtAngle - v1_y * sinTanPtAngle;
;;;740          n_y = v1_x * sinTanPtAngle + v1_y * cosTanPtAngle;
;;;741          
;;;742          // Compute tangent points
;;;743          p_t1_x = p_c1_x + n_x * r1 * sign1;
;;;744          p_t1_y = p_c1_y + n_y * r1 * sign1;
;;;745          
;;;746          p_t2_x = p_c2_x + n_x * r2 * sign2;
;;;747          p_t2_y = p_c2_y + n_y * r2 * sign2;
;;;748          
;;;749          
;;;750    #if(DEBUG_PATH)
;;;751           f32 tanPtAngle = ATAN2_ACC(n_y, n_x);
;;;752           CoreTechPrint("Dubins %d: \n"
;;;753           " p_c1 (%f, %f)\n"
;;;754           " p_c2 (%f, %f)\n"
;;;755           " V1 (%f %f)\n"
;;;756           " n (%f %f)\n"
;;;757           " p_t1 (%f, %f)\n"
;;;758           " p_t2 (%f, %f)\n",
;;;759           pathType,
;;;760           p_c1_x, p_c1_y,
;;;761           p_c2_x, p_c2_y,
;;;762           V1_x, V1_y,
;;;763           n_x, n_y,
;;;764           p_t1_x, p_t1_y,
;;;765           p_t2_x, p_t2_y
;;;766           );
;;;767    #endif
;;;768          
;;;769    
;;;770          // Generate path segment definitions
;;;771          path_length = 0;
;;;772          ps = &path[num_segments];
;;;773          ps->DefineArc(p_c1_x, p_c1_y,
;;;774                        start_radius,
;;;775                        ATAN2_ACC(startPt_y - p_c1_y, startPt_x - p_c1_x),
;;;776                        GetArcAngle(startPt_x, startPt_y, p_t1_x, p_t1_y, p_c1_x, p_c1_y, sign1 < 0),
;;;777                        targetSpeed, accel, decel);
;;;778          segment_length = ps->GetLength();
;;;779          
;;;780          if(segment_length > 0) {
;;;781            path_length += segment_length;
;;;782            ++num_segments;
;;;783          }
;;;784          
;;;785          ps = &path[num_segments];
;;;786          ps->DefineLine(p_t1_x, p_t1_y, p_t2_x, p_t2_y,
;;;787                          targetSpeed, accel, decel);
;;;788          segment_length = ps->GetLength();
;;;789    
;;;790          if(segment_length > 0) {
;;;791            path_length += segment_length;
;;;792            ++num_segments;
;;;793          }
;;;794          
;;;795          ps = &path[num_segments];
;;;796          ps->DefineArc(p_c2_x, p_c2_y,
;;;797                        end_radius,
;;;798                        ATAN2_ACC(p_t2_y - p_c2_y, p_t2_x - p_c2_x),
;;;799                        GetArcAngle(p_t2_x, p_t2_y, endPt_x, endPt_y, p_c2_x, p_c2_y, sign2 < 0),
;;;800                        targetSpeed, accel, decel);
;;;801          segment_length = ps->GetLength();
;;;802    
;;;803          if(segment_length > 0) {
;;;804            path_length += segment_length;
;;;805            ++num_segments;
;;;806          }
;;;807          
;;;808          return num_segments;
;;;809        }
000138  b001              ADD      sp,sp,#4
00013a  ecbd8b10          VPOP     {d8-d15}
00013e  b00f              ADD      sp,sp,#0x3c
000140  bd70              POP      {r4-r6,pc}
                  |L7.322|
000142  ee8eaa00          VDIV.F32 s20,s28,s0            ;731
000146  eddd0a00          VLDR     s1,[sp,#0]            ;732
00014a  ee490a48          VMLS.F32 s1,s18,s16            ;735
00014e  ee8cea80          VDIV.F32 s28,s25,s0            ;732
000152  eec0ca80          VDIV.F32 s25,s1,s0             ;735
000156  eeb00a6f          VMOV.F32 s0,s31                ;736
00015a  ee0c0aec          VMLS.F32 s0,s25,s25            ;736
00015e  eef10ac0          VSQRT.F32 s1,s0                 ;736
000162  eef40a60          VCMP.F32 s1,s1                 ;736
000166  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;736
00016a  d003              BEQ      |L7.372|
00016c  f7fffffe          BL       __hardfp_sqrtf
000170  eef00a40          VMOV.F32 s1,s0                 ;736
                  |L7.372|
000174  ee2a0a2c          VMUL.F32 s0,s20,s25            ;739
000178  ee0e0a60          VMLS.F32 s0,s28,s1             ;739
00017c  ee6a0a20          VMUL.F32 s1,s20,s1             ;740
000180  eeb0aa4c          VMOV.F32 s20,s24               ;743
000184  ee4e0a2c          VMLA.F32 s1,s28,s25            ;740
000188  ee201a28          VMUL.F32 s2,s0,s17             ;743
00018c  ee200a08          VMUL.F32 s0,s0,s16             ;746
000190  eef0ca4b          VMOV.F32 s25,s22               ;746
000194  ee01aa29          VMLA.F32 s20,s2,s19            ;743
000198  ee40ca09          VMLA.F32 s25,s0,s18            ;746
00019c  ee201aa8          VMUL.F32 s2,s1,s17             ;744
0001a0  ee200a88          VMUL.F32 s0,s1,s16             ;747
0001a4  eef08a6b          VMOV.F32 s17,s23               ;744
0001a8  eeb08a6a          VMOV.F32 s16,s21               ;747
0001ac  ee418a29          VMLA.F32 s17,s2,s19            ;744
0001b0  ee008a09          VMLA.F32 s16,s0,s18            ;747
0001b4  ed9f0a56          VLDR     s0,|L7.784|
0001b8  eef59ac0          VCMPE.F32 s19,#0.0              ;773
0001bc  ed840a00          VSTR     s0,[r4,#0]            ;771
0001c0  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;773
0001c4  bf34              ITE      CC                    ;773
0001c6  2001              MOVCC    r0,#1                 ;773
0001c8  2000              MOVCS    r0,#0                 ;773
0001ca  eef02a6b          VMOV.F32 s5,s23                ;773
0001ce  eeb02a4c          VMOV.F32 s4,s24                ;773
0001d2  eef01a68          VMOV.F32 s3,s17                ;773
0001d6  eeb01a4a          VMOV.F32 s2,s20                ;773
0001da  eef00a6e          VMOV.F32 s1,s29                ;773
0001de  eeb00a4f          VMOV.F32 s0,s30                ;773
0001e2  f7fffffe          BL       _ZN4Anki8Planning11GetArcAngleEffffffb ; Anki::Planning::GetArcAngle(float, float, float, float, float, float, bool)
0001e6  eef09a40          VMOV.F32 s19,s0                ;773
0001ea  ee7f0a4c          VSUB.F32 s1,s30,s24            ;773
0001ee  ee3e0aeb          VSUB.F32 s0,s29,s23            ;773
0001f2  f7fffffe          BL       _Z9atan2_accff ; atan2_acc(float, float)
0001f6  eef01a40          VMOV.F32 s3,s0                 ;773
0001fa  eddd3a1b          VLDR     s7,[sp,#0x6c]         ;773
0001fe  ed9d3a1a          VLDR     s6,[sp,#0x68]         ;773
000202  eddd2a19          VLDR     s5,[sp,#0x64]         ;773
000206  eeb02a69          VMOV.F32 s4,s19                ;773
00020a  eeb01a6d          VMOV.F32 s2,s27                ;773
00020e  eef00a6b          VMOV.F32 s1,s23                ;773
000212  eeb00a4c          VMOV.F32 s0,s24                ;773
000216  4630              MOV      r0,r6                 ;773
000218  f7fffffe          BL       _ZN4Anki8Planning11PathSegment9DefineArcEffffffff ; Anki::Planning::PathSegment::DefineArc(float, float, float, float, float, float, float, float)
00021c  4630              MOV      r0,r6                 ;778
00021e  f7fffffe          BL       _ZNK4Anki8Planning11PathSegment9GetLengthEv ; Anki::Planning::PathSegment::GetLength() const
000222  eeb50ac0          VCMPE.F32 s0,#0.0               ;780
000226  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;780
00022a  dd06              BLE      |L7.570|
00022c  edd40a00          VLDR     s1,[r4,#0]            ;781
000230  2501              MOVS     r5,#1                 ;782
000232  ee300a80          VADD.F32 s0,s1,s0              ;781
000236  ed840a00          VSTR     s0,[r4,#0]            ;781
                  |L7.570|
00023a  eb0500c5          ADD      r0,r5,r5,LSL #3       ;785
00023e  eb060280          ADD      r2,r6,r0,LSL #2       ;785
000242  ed9d3a1b          VLDR     s6,[sp,#0x6c]         ;786
000246  eddd2a1a          VLDR     s5,[sp,#0x68]         ;786
00024a  ed9d2a19          VLDR     s4,[sp,#0x64]         ;786
00024e  eef01a48          VMOV.F32 s3,s16                ;786
000252  eeb01a6c          VMOV.F32 s2,s25                ;786
000256  eef00a68          VMOV.F32 s1,s17                ;786
00025a  eeb00a4a          VMOV.F32 s0,s20                ;786
00025e  4610              MOV      r0,r2                 ;786
000260  f7fffffe          BL       _ZN4Anki8Planning11PathSegment10DefineLineEfffffff ; Anki::Planning::PathSegment::DefineLine(float, float, float, float, float, float, float)
000264  4610              MOV      r0,r2                 ;788
000266  f7fffffe          BL       _ZNK4Anki8Planning11PathSegment9GetLengthEv ; Anki::Planning::PathSegment::GetLength() const
00026a  eeb50ac0          VCMPE.F32 s0,#0.0               ;790
00026e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;790
000272  dd06              BLE      |L7.642|
000274  edd40a00          VLDR     s1,[r4,#0]            ;791
000278  1c6d              ADDS     r5,r5,#1              ;791
00027a  ee300a80          VADD.F32 s0,s1,s0              ;791
00027e  ed840a00          VSTR     s0,[r4,#0]            ;791
                  |L7.642|
000282  eeb59ac0          VCMPE.F32 s18,#0.0              ;796
000286  eb0500c5          ADD      r0,r5,r5,LSL #3       ;795
00028a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;796
00028e  eb060680          ADD      r6,r6,r0,LSL #2       ;795
000292  bf34              ITE      CC                    ;796
000294  2001              MOVCC    r0,#1                 ;796
000296  2000              MOVCS    r0,#0                 ;796
000298  eef02a6a          VMOV.F32 s5,s21                ;796
00029c  eeb02a4b          VMOV.F32 s4,s22                ;796
0002a0  eddd1a15          VLDR     s3,[sp,#0x54]         ;796
0002a4  ed9d1a14          VLDR     s2,[sp,#0x50]         ;796
0002a8  eef00a48          VMOV.F32 s1,s16                ;796
0002ac  eeb00a6c          VMOV.F32 s0,s25                ;796
0002b0  f7fffffe          BL       _ZN4Anki8Planning11GetArcAngleEffffffb ; Anki::Planning::GetArcAngle(float, float, float, float, float, float, bool)
0002b4  eef08a40          VMOV.F32 s17,s0                ;796
0002b8  ee7c0acb          VSUB.F32 s1,s25,s22            ;796
0002bc  ee380a6a          VSUB.F32 s0,s16,s21            ;796
0002c0  f7fffffe          BL       _Z9atan2_accff ; atan2_acc(float, float)
0002c4  eef01a40          VMOV.F32 s3,s0                 ;796
0002c8  eddd3a1b          VLDR     s7,[sp,#0x6c]         ;796
0002cc  ed9d3a1a          VLDR     s6,[sp,#0x68]         ;796
0002d0  eddd2a19          VLDR     s5,[sp,#0x64]         ;796
0002d4  eeb02a68          VMOV.F32 s4,s17                ;796
0002d8  eeb01a4d          VMOV.F32 s2,s26                ;796
0002dc  eef00a6a          VMOV.F32 s1,s21                ;796
0002e0  eeb00a4b          VMOV.F32 s0,s22                ;796
0002e4  4630              MOV      r0,r6                 ;796
0002e6  f7fffffe          BL       _ZN4Anki8Planning11PathSegment9DefineArcEffffffff ; Anki::Planning::PathSegment::DefineArc(float, float, float, float, float, float, float, float)
0002ea  4630              MOV      r0,r6                 ;801
0002ec  f7fffffe          BL       _ZNK4Anki8Planning11PathSegment9GetLengthEv ; Anki::Planning::PathSegment::GetLength() const
0002f0  eeb50ac0          VCMPE.F32 s0,#0.0               ;803
0002f4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;803
0002f8  dd06              BLE      |L7.776|
0002fa  edd40a00          VLDR     s1,[r4,#0]            ;804
0002fe  1c6d              ADDS     r5,r5,#1              ;804
000300  ee300a80          VADD.F32 s0,s1,s0              ;804
000304  ed840a00          VSTR     s0,[r4,#0]            ;804
                  |L7.776|
000308  4628              MOV      r0,r5                 ;808
00030a  e715              B        |L7.312|
;;;810        
                          ENDP

                  |L7.780|
00030c  7f7fffff          DCFS     0x7f7fffff ; 3.4028234663852886e+38
                  |L7.784|
000310  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Planning18GenerateDubinsPathERNS0_4PathEffffffffffffPf||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Planning18GenerateDubinsPathERNS0_4PathEffffffffffffPf PROC ; Anki::Planning::GenerateDubinsPath(Anki::Planning::Path&, float, float, float, float, float, float, float, float, float, float, float, float, float*)
;;;820        // Fails automatically
;;;821        u8 GenerateDubinsPath(Path &path,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;822                              f32 start_x, f32 start_y, f32 start_theta,
;;;823                              f32 end_x, f32 end_y, f32 end_theta,
;;;824                              f32 start_radius, f32 end_radius,
;;;825                              f32 targetSpeed, f32 accel, f32 decel,
;;;826                              f32 final_straight_approach_length,
;;;827                              f32 *path_length)
;;;828        {
000004  460f              MOV      r7,r1
000006  ed2d8b10          VPUSH    {d8-d15}
00000a  b0ed              SUB      sp,sp,#0x1b4
00000c  4604              MOV      r4,r0
00000e  eef08a65          VMOV.F32 s17,s11
000012  eeb09a45          VMOV.F32 s18,s10
000016  eef09a64          VMOV.F32 s19,s9
00001a  eeb0aa44          VMOV.F32 s20,s8
00001e  eeb0da63          VMOV.F32 s26,s7
000022  eef0da43          VMOV.F32 s27,s6
000026  eef0ca62          VMOV.F32 s25,s5
00002a  eef0aa42          VMOV.F32 s21,s4
00002e  eeb0ba61          VMOV.F32 s22,s3
000032  eeb0ea41          VMOV.F32 s28,s2
000036  eef0ea60          VMOV.F32 s29,s1
00003a  eeb0fa40          VMOV.F32 s30,s0
;;;829          PathSegment csc_path[NUM_DUBINS_PATHS][3];
00003e  230c              MOVS     r3,#0xc
000040  2224              MOVS     r2,#0x24
000042  495b              LDR      r1,|L8.432|
000044  4668              MOV      r0,sp
000046  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
;;;830          
;;;831          u32 shortestNumSegments = 0;
00004a  2600              MOVS     r6,#0
;;;832          f32 shortestPathLength = FLT_MAX;
00004c  ed9f8a59          VLDR     s16,|L8.436|
;;;833          DubinsPathType shortestPathType = NUM_DUBINS_PATHS;
000050  f04f0804          MOV      r8,#4
;;;834          u32 numSegments;
;;;835          f32 pathLength;
;;;836          
;;;837          
;;;838          // Compute end point before the final straight segment
;;;839          // and then append the straight segment after the Dubins path is generated
;;;840          f32 preStraightApproach_x = end_x - final_straight_approach_length * cosf(end_theta);
000054  eeb00a6c          VMOV.F32 s0,s25
000058  f7fffffe          BL       __hardfp_cosf
00005c  eeb0ca4b          VMOV.F32 s24,s22
000060  ee08cac0          VMLS.F32 s24,s17,s0
;;;841          f32 preStraightApproach_y = end_y - final_straight_approach_length * sinf(end_theta);
000064  eeb00a6c          VMOV.F32 s0,s25
000068  f7fffffe          BL       __hardfp_sinf
00006c  eef0ba6a          VMOV.F32 s23,s21
;;;842          
;;;843          
;;;844    #if(DEBUG_PATH)
;;;845          CoreTechPrint("DUBINS: startPt %f %f %f, preEnd %f %f, endPt %f %f %f, start_radius %f, end_radius %f\n",
;;;846                start_x, start_y, start_theta, preStraightApproach_x, preStraightApproach_y, end_x, end_y, end_theta, start_radius, end_radius);
;;;847    #endif
;;;848    
;;;849          for (DubinsPathType i = LSL; i != NUM_DUBINS_PATHS; i = (DubinsPathType)(i+1)) {
000070  2500              MOVS     r5,#0
000072  ee48bac0          VMLS.F32 s23,s17,s0            ;841
000076  46e9              MOV      r9,sp                 ;829
                  |L8.120|
;;;850    
;;;851            numSegments = GenerateCSCCurve(start_x, start_y, start_theta, preStraightApproach_x, preStraightApproach_y, end_theta, start_radius, end_radius,  targetSpeed, accel, decel, i, csc_path[i], pathLength);
000078  eb0500c5          ADD      r0,r5,r5,LSL #3
00007c  eb000040          ADD      r0,r0,r0,LSL #1
000080  eb090180          ADD      r1,r9,r0,LSL #2
000084  aa6c              ADD      r2,sp,#0x1b0
000086  4628              MOV      r0,r5
000088  eeb05a49          VMOV.F32 s10,s18
00008c  eef04a69          VMOV.F32 s9,s19
000090  eeb04a4a          VMOV.F32 s8,s20
000094  eef03a4d          VMOV.F32 s7,s26
000098  eeb03a6d          VMOV.F32 s6,s27
00009c  eef02a6c          VMOV.F32 s5,s25
0000a0  eeb02a6b          VMOV.F32 s4,s23
0000a4  eef01a4c          VMOV.F32 s3,s24
0000a8  eeb01a4e          VMOV.F32 s2,s28
0000ac  eef00a6e          VMOV.F32 s1,s29
0000b0  eeb00a4f          VMOV.F32 s0,s30
0000b4  f7fffffe          BL       _ZN4Anki8Planning16GenerateCSCCurveEfffffffffffNS0_14DubinsPathTypeEPNS0_11PathSegmentERf ; Anki::Planning::GenerateCSCCurve(float, float, float, float, float, float, float, float, float, float, float, Anki::Planning::DubinsPathType, Anki::Planning::PathSegment*, float&)
;;;852    #if(DEBUG_PATH)
;;;853            CoreTechPrint("Dubins path %d: numSegments %d, length %f m\n", i, numSegments, pathLength);
;;;854    #endif
;;;855            if (pathLength < shortestPathLength) {
0000b8  ed9d0a6c          VLDR     s0,[sp,#0x1b0]
0000bc  eeb40ac8          VCMPE.F32 s0,s16
0000c0  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000c4  d203              BCS      |L8.206|
;;;856              shortestNumSegments = numSegments;
0000c6  4606              MOV      r6,r0
;;;857              shortestPathLength = pathLength;
0000c8  eeb08a40          VMOV.F32 s16,s0
;;;858              shortestPathType = i;
0000cc  46a8              MOV      r8,r5
                  |L8.206|
0000ce  1c68              ADDS     r0,r5,#1              ;849
0000d0  b2c5              UXTB     r5,r0                 ;849
0000d2  2d04              CMP      r5,#4                 ;849
0000d4  d1d0              BNE      |L8.120|
;;;859            }
;;;860          }
;;;861    
;;;862          // If a path was found, copy it to the path_ and tack on the final straight segment.
;;;863          if (shortestPathType != NUM_DUBINS_PATHS) {
0000d6  f1b80f04          CMP      r8,#4
0000da  d063              BEQ      |L8.420|
;;;864            
;;;865            //path.numPathSegments_ = shortestNumSegments;
;;;866            for (u32 j = 0; j < shortestNumSegments; ++j) {
0000dc  2500              MOVS     r5,#0
0000de  2e00              CMP      r6,#0
0000e0  d943              BLS      |L8.362|
;;;867              //path_[j] = csc_path[shortestPathType][j];
;;;868              
;;;869              switch(csc_path[shortestPathType][j].GetType()) {
0000e2  eb0800c8          ADD      r0,r8,r8,LSL #3
0000e6  eb000040          ADD      r0,r0,r0,LSL #1
0000ea  eb090880          ADD      r8,r9,r0,LSL #2
                  |L8.238|
0000ee  eb0500c5          ADD      r0,r5,r5,LSL #3
0000f2  eb080080          ADD      r0,r8,r0,LSL #2
0000f6  7801              LDRB     r1,[r0,#0]
0000f8  2901              CMP      r1,#1
0000fa  d006              BEQ      |L8.266|
0000fc  2902              CMP      r1,#2
0000fe  d024              BEQ      |L8.330|
;;;870                case PST_LINE:
;;;871                {
;;;872                  const PathSegmentDef::s_line *l = &(csc_path[shortestPathType][j].GetDef().line);
;;;873                  path.AppendLine(0, l->startPt_x, l->startPt_y, l->endPt_x, l->endPt_y, targetSpeed, accel, decel);
;;;874                  break;
;;;875                }
;;;876                case PST_ARC:
;;;877                {
;;;878                  const PathSegmentDef::s_arc *a = &(csc_path[shortestPathType][j].GetDef().arc);
;;;879                  path.AppendArc(0, a->centerPt_x, a->centerPt_y, a->radius, a->startRad, a->sweepRad, targetSpeed, accel, decel);
;;;880                  break;
;;;881                }
;;;882                default:
;;;883                  CoreTechPrint("ERROR: Invalid path segment type in Dubins path. Should not be possible!\n");
000100  482d              LDR      r0,|L8.440|
000102  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;884                  assert(0);
000106  f7fffffe          BL       abort
                  |L8.266|
00010a  1d00              ADDS     r0,r0,#4
00010c  ec900a04          VLDM     r0,{s0-s3}
000110  7960              LDRB     r0,[r4,#5]
000112  280a              CMP      r0,#0xa
000114  d001              BEQ      |L8.282|
000116  f7fffffe          BL       abort
                  |L8.282|
00011a  7920              LDRB     r0,[r4,#4]            ;873
00011c  280a              CMP      r0,#0xa               ;873
00011e  d303              BCC      |L8.296|
000120  4826              LDR      r0,|L8.444|
000122  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
000126  e01d              B        |L8.356|
                  |L8.296|
000128  6821              LDR      r1,[r4,#0]            ;873
00012a  eb0000c0          ADD      r0,r0,r0,LSL #3       ;873
00012e  eb010080          ADD      r0,r1,r0,LSL #2       ;873
000132  eeb03a49          VMOV.F32 s6,s18                ;873
000136  eef02a69          VMOV.F32 s5,s19                ;873
00013a  eeb02a4a          VMOV.F32 s4,s20                ;873
00013e  f7fffffe          BL       _ZN4Anki8Planning11PathSegment10DefineLineEfffffff ; Anki::Planning::PathSegment::DefineLine(float, float, float, float, float, float, float)
000142  7920              LDRB     r0,[r4,#4]            ;873
000144  1c40              ADDS     r0,r0,#1              ;873
000146  7120              STRB     r0,[r4,#4]            ;873
000148  e00c              B        |L8.356|
                  |L8.330|
00014a  1d00              ADDS     r0,r0,#4              ;873
00014c  eef03a49          VMOV.F32 s7,s18                ;879
000150  ec900a05          VLDM     r0,{s0-s4}            ;879
000154  eeb03a69          VMOV.F32 s6,s19                ;879
000158  eef02a4a          VMOV.F32 s5,s20                ;879
00015c  2100              MOVS     r1,#0                 ;879
00015e  4620              MOV      r0,r4                 ;879
000160  f7fffffe          BL       _ZN4Anki8Planning4Path9AppendArcEjffffffff ; Anki::Planning::Path::AppendArc(unsigned, float, float, float, float, float, float, float, float)
                  |L8.356|
000164  1c6d              ADDS     r5,r5,#1              ;879
000166  42b5              CMP      r5,r6                 ;866
000168  d3c1              BCC      |L8.238|
                  |L8.362|
;;;885                  break;
;;;886              }
;;;887              
;;;888            }
;;;889            
;;;890            // Optionally, append a 4th straight line segment
;;;891            if (final_straight_approach_length != 0) {
00016a  eef58ac0          VCMPE.F32 s17,#0.0
00016e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000172  d013              BEQ      |L8.412|
;;;892              path.AppendLine(0, preStraightApproach_x, preStraightApproach_y, end_x, end_y, targetSpeed, accel, decel);
000174  eeb03a49          VMOV.F32 s6,s18
000178  eef02a69          VMOV.F32 s5,s19
00017c  eeb02a4a          VMOV.F32 s4,s20
000180  eef01a6a          VMOV.F32 s3,s21
000184  eeb01a4b          VMOV.F32 s2,s22
000188  eef00a6b          VMOV.F32 s1,s23
00018c  eeb00a4c          VMOV.F32 s0,s24
000190  2100              MOVS     r1,#0
000192  4620              MOV      r0,r4
000194  f7fffffe          BL       _ZN4Anki8Planning4Path10AppendLineEjfffffff ; Anki::Planning::Path::AppendLine(unsigned, float, float, float, float, float, float, float)
;;;893              shortestPathLength += final_straight_approach_length;
000198  ee388a28          VADD.F32 s16,s16,s17
                  |L8.412|
;;;894            }
;;;895            
;;;896            if (path_length) {
00019c  2f00              CMP      r7,#0
;;;897              *path_length = shortestPathLength;
00019e  bf18              IT       NE
0001a0  ed878a00          VSTRNE   s16,[r7,#0]
                  |L8.420|
0001a4  7920              LDRB     r0,[r4,#4]
;;;898            }
;;;899          }
;;;900          
;;;901    #if(DEBUG_PATH)
;;;902          CoreTechPrint("Dubins: Shortest path %d, length %f\n", shortestPathType, shortestPathLength);
;;;903    #endif
;;;904          
;;;905          return path.GetNumSegments();
;;;906        }
0001a6  b06d              ADD      sp,sp,#0x1b4
0001a8  ecbd8b10          VPOP     {d8-d15}
0001ac  e8bd83f0          POP      {r4-r9,pc}
;;;907      
                          ENDP

                  |L8.432|
                          DCD      _ZN4Anki8Planning11PathSegmentC1Ev ; Anki::Planning::PathSegment::PathSegment()
                  |L8.436|
0001b4  7f7fffff          DCFS     0x7f7fffff ; 3.4028234663852886e+38
                  |L8.440|
                          DCD      ||.conststring||+0xf8
                  |L8.444|
                          DCD      ||i._ZN4Anki8Planning4Path10AppendLineEjfffffff||+0x38

                          AREA ||i._ZN4Anki8Planning4Path10AppendLineEjfffffff||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Planning4Path10AppendLineEjfffffff PROC ; Anki::Planning::Path::AppendLine(unsigned, float, float, float, float, float, float, float)
;;;994        // tODO: Change units to meters
;;;995        bool Path::AppendLine(u32 matID, f32 x_start, f32 y_start, f32 x_end, f32 y_end,
000000  b510              PUSH     {r4,lr}
;;;996                              f32 targetSpeed, f32 accel, f32 decel)
;;;997        {
000002  4602              MOV      r2,r0
;;;998          assert(capacity_ == MAX_NUM_PATH_SEGMENTS);
000004  7940              LDRB     r0,[r0,#5]
000006  280a              CMP      r0,#0xa
000008  d001              BEQ      |L9.14|
00000a  f7fffffe          BL       abort
                  |L9.14|
;;;999    
;;;1000         if (numPathSegments_ >= MAX_NUM_PATH_SEGMENTS) {
00000e  7910              LDRB     r0,[r2,#4]
000010  280a              CMP      r0,#0xa
000012  d304              BCC      |L9.30|
;;;1001           CoreTechPrint("ERROR (AppendLine): Exceeded path size\n");
000014  a008              ADR      r0,|L9.56|
000016  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;1002           return false;
00001a  2000              MOVS     r0,#0
;;;1003         }
;;;1004         
;;;1005         path_[numPathSegments_].DefineLine(x_start, y_start, x_end, y_end,
;;;1006                                            targetSpeed, accel, decel);
;;;1007   
;;;1008   #if DEBUG_PATH_APPEND
;;;1009         CoreTechPrint("INFO (AppendLine): numPathSegments_ = %u :", numPathSegments_);
;;;1010         path_[numPathSegments_].Print();
;;;1011   #endif
;;;1012   
;;;1013         numPathSegments_++;
;;;1014         
;;;1015         return true;
;;;1016       }
00001c  bd10              POP      {r4,pc}
                  |L9.30|
00001e  6811              LDR      r1,[r2,#0]            ;1005
000020  eb0000c0          ADD      r0,r0,r0,LSL #3       ;1005
000024  eb010080          ADD      r0,r1,r0,LSL #2       ;1005
000028  f7fffffe          BL       _ZN4Anki8Planning11PathSegment10DefineLineEfffffff ; Anki::Planning::PathSegment::DefineLine(float, float, float, float, float, float, float)
00002c  7910              LDRB     r0,[r2,#4]            ;1013
00002e  1c40              ADDS     r0,r0,#1              ;1013
000030  7110              STRB     r0,[r2,#4]            ;1013
000032  2001              MOVS     r0,#1                 ;1015
000034  bd10              POP      {r4,pc}
;;;1017     
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
000038  4552524f          DCB      "ERROR (AppendLine): Exceeded path size\n",0
00003c  52202841
000040  7070656e
000044  644c696e
000048  65293a20
00004c  45786365
000050  65646564
000054  20706174
000058  68207369
00005c  7a650a00

                          AREA ||i._ZN4Anki8Planning4Path13AppendSegmentERKNS0_11PathSegmentE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Planning4Path13AppendSegmentERKNS0_11PathSegmentE PROC ; Anki::Planning::Path::AppendSegment(const Anki::Planning::PathSegment&)
;;;1130   
;;;1131       bool Path::AppendSegment(const PathSegment& segment)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1132       {
;;;1133         assert(capacity_ == MAX_NUM_PATH_SEGMENTS);
000004  7942              LDRB     r2,[r0,#5]
000006  2a0a              CMP      r2,#0xa
000008  d001              BEQ      |L10.14|
00000a  f7fffffe          BL       abort
                  |L10.14|
;;;1134   
;;;1135         if (numPathSegments_ >= MAX_NUM_PATH_SEGMENTS) {
00000e  7902              LDRB     r2,[r0,#4]
000010  2a0a              CMP      r2,#0xa
000012  d305              BCC      |L10.32|
;;;1136           CoreTechPrint("ERROR (AppendSegment): Exceeded path size\n");
000014  a00b              ADR      r0,|L10.68|
000016  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;1137           return false;
00001a  2000              MOVS     r0,#0
;;;1138         }
;;;1139   
;;;1140         path_[numPathSegments_] = segment;
;;;1141   
;;;1142   #if DEBUG_PATH_APPEND
;;;1143         CoreTechPrint("INFO (AppendSegment): numPathSegments_ = %u :", numPathSegments_);
;;;1144         path_[numPathSegments_].Print();
;;;1145   #endif
;;;1146   
;;;1147         numPathSegments_++;
;;;1148   
;;;1149         return true;
;;;1150       }  
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L10.32|
000020  6803              LDR      r3,[r0,#0]            ;1140
000022  eb0202c2          ADD      r2,r2,r2,LSL #3       ;1140
000026  eb030282          ADD      r2,r3,r2,LSL #2       ;1140
00002a  e89113f8          LDM      r1,{r3-r9,r12}        ;1140
00002e  e88213f8          STM      r2,{r3-r9,r12}        ;1140
000032  6a09              LDR      r1,[r1,#0x20]         ;1140
000034  6211              STR      r1,[r2,#0x20]         ;1147
000036  7901              LDRB     r1,[r0,#4]            ;1147
000038  1c49              ADDS     r1,r1,#1              ;1147
00003a  7101              STRB     r1,[r0,#4]            ;1147
00003c  2001              MOVS     r0,#1                 ;1149
00003e  e8bd87f0          POP      {r4-r10,pc}
;;;1151       
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
000044  4552524f          DCB      "ERROR (AppendSegment): Exceeded path size\n",0
000048  52202841
00004c  7070656e
000050  64536567
000054  6d656e74
000058  293a2045
00005c  78636565
000060  64656420
000064  70617468
000068  2073697a
00006c  650a00  
00006f  00                DCB      0

                          AREA ||i._ZN4Anki8Planning4Path15AppendPointTurnEjffffff||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Planning4Path15AppendPointTurnEjffffff PROC ; Anki::Planning::Path::AppendPointTurn(unsigned, float, float, float, float, float, float)
;;;1112       
;;;1113       bool Path::AppendPointTurn(u32 matID, f32 x, f32 y, f32 targetAngle,
000000  b510              PUSH     {r4,lr}
;;;1114                                  f32 targetRotSpeed, f32 rotAccel, f32 rotDecel)
;;;1115       {
;;;1116         assert(capacity_ == MAX_NUM_PATH_SEGMENTS);
000002  7941              LDRB     r1,[r0,#5]
000004  290a              CMP      r1,#0xa
000006  d001              BEQ      |L11.12|
000008  f7fffffe          BL       abort
                  |L11.12|
;;;1117   
;;;1118         if (numPathSegments_ >= MAX_NUM_PATH_SEGMENTS) {
00000c  7901              LDRB     r1,[r0,#4]
00000e  290a              CMP      r1,#0xa
000010  d304              BCC      |L11.28|
;;;1119           CoreTechPrint("ERROR (AppendPointTurn): Exceeded path size\n");
000012  a00e              ADR      r0,|L11.76|
000014  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;1120           return false;
000018  2000              MOVS     r0,#0
;;;1121         }
;;;1122         
;;;1123         path_[numPathSegments_].DefinePointTurn(x,y,targetAngle,
;;;1124                                                 targetRotSpeed, rotAccel, rotDecel);
;;;1125   
;;;1126         numPathSegments_++;
;;;1127         
;;;1128         return true;
;;;1129       }
00001a  bd10              POP      {r4,pc}
                  |L11.28|
00001c  6802              LDR      r2,[r0,#0]            ;1123
00001e  eb0101c1          ADD      r1,r1,r1,LSL #3       ;1123
000022  eb020181          ADD      r1,r2,r1,LSL #2       ;1123
000026  2203              MOVS     r2,#3                 ;1123
000028  700a              STRB     r2,[r1,#0]            ;1123
00002a  ed810a01          VSTR     s0,[r1,#4]            ;1123
00002e  edc10a02          VSTR     s1,[r1,#8]            ;1123
000032  ed811a03          VSTR     s2,[r1,#0xc]          ;1123
000036  edc11a06          VSTR     s3,[r1,#0x18]         ;1123
00003a  ed812a07          VSTR     s4,[r1,#0x1c]         ;1123
00003e  edc12a08          VSTR     s5,[r1,#0x20]         ;1123
000042  7901              LDRB     r1,[r0,#4]            ;1126
000044  1c49              ADDS     r1,r1,#1              ;1126
000046  7101              STRB     r1,[r0,#4]            ;1126
000048  2001              MOVS     r0,#1                 ;1128
00004a  bd10              POP      {r4,pc}
;;;1130   
                          ENDP

                  |L11.76|
00004c  4552524f          DCB      "ERROR (AppendPointTurn): Exceeded path size\n",0
000050  52202841
000054  7070656e
000058  64506f69
00005c  6e745475
000060  726e293a
000064  20457863
000068  65656465
00006c  64207061
000070  74682073
000074  697a650a
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i._ZN4Anki8Planning4Path5ClearEv||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Planning4Path5ClearEv PROC ; Anki::Planning::Path::Clear()
;;;571    
;;;572        void Path::Clear()
000000  b510              PUSH     {r4,lr}
;;;573        {
;;;574          assert(capacity_ == MAX_NUM_PATH_SEGMENTS);
000002  7941              LDRB     r1,[r0,#5]
000004  290a              CMP      r1,#0xa
;;;575    
;;;576          numPathSegments_ = 0;
000006  bf02              ITTT     EQ
000008  2100              MOVEQ    r1,#0
00000a  7101              STRBEQ   r1,[r0,#4]
;;;577        }
00000c  bd10              POPEQ    {r4,pc}
00000e  f7fffffe          BL       abort
;;;578    
                          ENDP


                          AREA ||i._ZN4Anki8Planning4Path6AddArcEffffffff||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Planning4Path6AddArcEffffffff PROC ; Anki::Planning::Path::AddArc(float, float, float, float, float, float, float, float)
;;;1018     
;;;1019       void Path::AddArc(f32 x_center, f32 y_center, f32 radius, f32 startRad, f32 sweepRad,
000000  b510              PUSH     {r4,lr}
;;;1020                         f32 targetSpeed, f32 accel, f32 decel) {
000002  4604              MOV      r4,r0
000004  ed2d8b08          VPUSH    {d8-d11}
000008  eef08a63          VMOV.F32 s17,s7
00000c  eeb09a43          VMOV.F32 s18,s6
000010  eef09a62          VMOV.F32 s19,s5
000014  eeb08a42          VMOV.F32 s16,s4
;;;1021         assert(capacity_ == MAX_NUM_PATH_SEGMENTS);
000018  7940              LDRB     r0,[r0,#5]
00001a  eeb0aa61          VMOV.F32 s20,s3                ;1020
00001e  eef0aa41          VMOV.F32 s21,s2                ;1020
000022  eeb0ba60          VMOV.F32 s22,s1                ;1020
000026  eef0ba40          VMOV.F32 s23,s0                ;1020
00002a  280a              CMP      r0,#0xa
00002c  d001              BEQ      |L13.50|
00002e  f7fffffe          BL       abort
                  |L13.50|
;;;1022   
;;;1023         if (FLT_NEAR(sweepRad,0)) {
000032  ee180a10          VMOV     r0,s16
000036  4914              LDR      r1,|L13.136|
000038  4288              CMP      r0,r1
00003a  d207              BCS      |L13.76|
00003c  ee180a10          VMOV     r0,s16
000040  4912              LDR      r1,|L13.140|
000042  4288              CMP      r0,r1
;;;1024           CoreTechPrint("ERROR: sweepRad is zero\n");
000044  bfbc              ITT      LT
000046  a012              ADRLT    r0,|L13.144|
000048  f7fffffe          BLLT     _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
                  |L13.76|
;;;1025         }
;;;1026   
;;;1027         path_[numPathSegments_].DefineArc(x_center, y_center, radius, startRad, sweepRad,
00004c  7920              LDRB     r0,[r4,#4]
00004e  6821              LDR      r1,[r4,#0]
000050  eb0000c0          ADD      r0,r0,r0,LSL #3
000054  eb010080          ADD      r0,r1,r0,LSL #2
000058  eef03a68          VMOV.F32 s7,s17
00005c  eeb03a49          VMOV.F32 s6,s18
000060  eef02a69          VMOV.F32 s5,s19
000064  eeb02a48          VMOV.F32 s4,s16
000068  eef01a4a          VMOV.F32 s3,s20
00006c  eeb01a6a          VMOV.F32 s2,s21
000070  eef00a4b          VMOV.F32 s1,s22
000074  eeb00a6b          VMOV.F32 s0,s23
000078  f7fffffe          BL       _ZN4Anki8Planning11PathSegment9DefineArcEffffffff ; Anki::Planning::PathSegment::DefineArc(float, float, float, float, float, float, float, float)
;;;1028                                           targetSpeed, accel, decel);
;;;1029   
;;;1030   #if DEBUG_PATH_APPEND
;;;1031         CoreTechPrint("INFO (AddArc): numPathSegments_ = %u :", numPathSegments_);
;;;1032         path_[numPathSegments_].Print();
;;;1033   #endif
;;;1034   
;;;1035         numPathSegments_++;
00007c  7920              LDRB     r0,[r4,#4]
00007e  1c40              ADDS     r0,r0,#1
000080  7120              STRB     r0,[r4,#4]
;;;1036       }
000082  ecbd8b08          VPOP     {d8-d11}
000086  bd10              POP      {r4,pc}
;;;1037     
                          ENDP

                  |L13.136|
                          DCD      0xb727c5ac
                  |L13.140|
                          DCD      0x3727c5ac
                  |L13.144|
000090  4552524f          DCB      "ERROR: sweepRad is zero\n",0
000094  523a2073
000098  77656570
00009c  52616420
0000a0  6973207a
0000a4  65726f0a
0000a8  00      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i._ZN4Anki8Planning4Path7PopBackEh||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Planning4Path7PopBackEh PROC ; Anki::Planning::Path::PopBack(unsigned char)
;;;927        
;;;928        bool Path::PopBack(const u8 numSegments)
000000  b510              PUSH     {r4,lr}
;;;929        {
;;;930          assert(capacity_ == MAX_NUM_PATH_SEGMENTS);
000002  7942              LDRB     r2,[r0,#5]
000004  2a0a              CMP      r2,#0xa
000006  d001              BEQ      |L14.12|
000008  f7fffffe          BL       abort
                  |L14.12|
;;;931    
;;;932          if (numSegments <= numPathSegments_) {
00000c  7902              LDRB     r2,[r0,#4]
00000e  428a              CMP      r2,r1
;;;933            numPathSegments_ -= numSegments;
;;;934            return true;
;;;935          } else {
;;;936    #if(DEBUG_PATH)
;;;937            CoreTechPrint("WARNING(Path::PopBack): Can't pop %d segments from %d segment path\n", numSegments, numPathSegments_);
;;;938    #endif
;;;939          }
;;;940          
;;;941          return false;
000010  bf3c              ITT      CC
000012  2000              MOVCC    r0,#0
;;;942        }
000014  bd10              POPCC    {r4,pc}
000016  1a51              SUBS     r1,r2,r1              ;933
000018  7101              STRB     r1,[r0,#4]            ;933
00001a  2001              MOVS     r0,#1                 ;934
00001c  bd10              POP      {r4,pc}
;;;943        
                          ENDP


                          AREA ||i._ZN4Anki8Planning4Path8PopFrontEh||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Planning4Path8PopFrontEh PROC ; Anki::Planning::Path::PopFront(unsigned char)
;;;907      
;;;908        bool Path::PopFront(const u8 numSegments)
000000  b510              PUSH     {r4,lr}
;;;909        {
;;;910          assert(capacity_ == MAX_NUM_PATH_SEGMENTS);
000002  7942              LDRB     r2,[r0,#5]
000004  2a0a              CMP      r2,#0xa
000006  d001              BEQ      |L15.12|
000008  f7fffffe          BL       abort
                  |L15.12|
;;;911    
;;;912          if (numSegments <= numPathSegments_) {
00000c  7902              LDRB     r2,[r0,#4]
00000e  428a              CMP      r2,r1
;;;913            numPathSegments_ -= numSegments;
;;;914            
;;;915            // Shift path segments to front down
;;;916            memcpy(path_, &(path_[numSegments]), numPathSegments_*sizeof(PathSegment));
;;;917            
;;;918            return true;
;;;919          } else {
;;;920            #if(DEBUG_PATH)
;;;921            CoreTechPrint("WARNING(Path::PopFront): Can't pop %d segments from %d segment path\n", numSegments, numPathSegments_);
;;;922            #endif
;;;923          }
;;;924          
;;;925          return false;
000010  bf3c              ITT      CC
000012  2000              MOVCC    r0,#0
;;;926        }
000014  bd10              POPCC    {r4,pc}
000016  1a52              SUBS     r2,r2,r1              ;913
000018  b2d2              UXTB     r2,r2                 ;913
00001a  7102              STRB     r2,[r0,#4]            ;913
00001c  6800              LDR      r0,[r0,#0]            ;916
00001e  eb0101c1          ADD      r1,r1,r1,LSL #3       ;916
000022  eb0202c2          ADD      r2,r2,r2,LSL #3       ;916
000026  eb000181          ADD      r1,r0,r1,LSL #2       ;916
00002a  0092              LSLS     r2,r2,#2              ;916
00002c  f7fffffe          BL       __aeabi_memcpy4
000030  2001              MOVS     r0,#1                 ;918
000032  bd10              POP      {r4,pc}
;;;927        
                          ENDP


                          AREA ||i._ZN4Anki8Planning4Path9AppendArcEjffffffff||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Planning4Path9AppendArcEjffffffff PROC ; Anki::Planning::Path::AppendArc(unsigned, float, float, float, float, float, float, float, float)
;;;1038     
;;;1039       bool Path::AppendArc(u32 matID, f32 x_center, f32 y_center, f32 radius, f32 startRad, f32 sweepRad,
000000  b570              PUSH     {r4-r6,lr}
;;;1040                            f32 targetSpeed, f32 accel, f32 decel)
;;;1041       {
000002  4604              MOV      r4,r0
000004  ed2d8b0c          VPUSH    {d8-d13}
000008  b096              SUB      sp,sp,#0x58
00000a  eef09a63          VMOV.F32 s19,s7
00000e  eeb0aa43          VMOV.F32 s20,s6
000012  eef0aa62          VMOV.F32 s21,s5
000016  eeb09a42          VMOV.F32 s18,s4
00001a  eeb0ba41          VMOV.F32 s22,s2
;;;1042         assert(capacity_ == MAX_NUM_PATH_SEGMENTS);
00001e  7940              LDRB     r0,[r0,#5]
000020  eeb0ca60          VMOV.F32 s24,s1                ;1041
000024  eef0ba40          VMOV.F32 s23,s0                ;1041
000028  280a              CMP      r0,#0xa
00002a  f04080f9          BNE.W    |L16.544|
;;;1043   
;;;1044         if (numPathSegments_ >= MAX_NUM_PATH_SEGMENTS) {
00002e  7920              LDRB     r0,[r4,#4]
000030  280a              CMP      r0,#0xa
000032  d307              BCC      |L16.68|
;;;1045           CoreTechPrint("ERROR (AppendArc): Exceeded path size\n");
000034  a0aa              ADR      r0,|L16.736|
000036  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;1046           return false;
;;;1047         }
;;;1048         
;;;1049         if (FLT_NEAR(sweepRad,0)) {
;;;1050           CoreTechPrint("ERROR: sweepRad is zero\n");
;;;1051           return false;
;;;1052         }
;;;1053         
;;;1054   
;;;1055         // Make sure startRad is between -PI and PI
;;;1056         startRad = Radians(startRad).ToFloat();
;;;1057   
;;;1058         
;;;1059         // Arcs need to be true functions.
;;;1060         // i.e. for any value of x there can only be one y value.
;;;1061         // This also means that an arc cannot sweep past the angles 0 or PI.
;;;1062         //
;;;1063         // Split up into several arcs if necessary.
;;;1064         
;;;1065         f32 sweepRadLeft = ABS(sweepRad);
;;;1066         f32 sweep;
;;;1067         Radians currAngle(startRad);
;;;1068         Radians zeroAngle(0);
;;;1069         Radians piAngle(PI);
;;;1070         
;;;1071         // limitAngle toggles between zeroAngle and piAngle for as
;;;1072         // long as traversing sweepRad causes it to cross 0 or PI.
;;;1073         Radians limitAngle = zeroAngle;
;;;1074   
;;;1075         if ((currAngle >= zeroAngle && currAngle != piAngle && sweepRad > 0) ||
;;;1076             (currAngle < zeroAngle && sweepRad < 0)) {
;;;1077           limitAngle = piAngle;
;;;1078         }
;;;1079   
;;;1080         
;;;1081         while(sweepRadLeft > 0) {
;;;1082           
;;;1083           if (sweepRad > 0) {
;;;1084             // sweeping CCW
;;;1085             sweep = MIN( ABS((limitAngle - currAngle).ToFloat()), sweepRadLeft);
;;;1086           } else {
;;;1087             // sweeping CW
;;;1088             sweep = MAX( -ABS((limitAngle - currAngle).ToFloat()), -sweepRadLeft);
;;;1089           }
;;;1090           
;;;1091           if(!NEAR_ZERO(sweep)) {
;;;1092             AddArc(x_center, y_center, radius, currAngle.ToFloat(), sweep,
;;;1093                    targetSpeed, accel, decel);
;;;1094           }
;;;1095             
;;;1096           if (ABS(sweep) == sweepRadLeft) {
;;;1097             sweepRadLeft = 0;
;;;1098           } else {
;;;1099             currAngle = limitAngle;
;;;1100             sweepRadLeft -= ABS(sweep);
;;;1101           }
;;;1102           
;;;1103           // toggle limit angle
;;;1104           limitAngle = (limitAngle == piAngle ? zeroAngle : piAngle);
;;;1105   
;;;1106         }
;;;1107         
;;;1108         
;;;1109         return true;
;;;1110       }
00003a  b016              ADD      sp,sp,#0x58
00003c  2000              MOVS     r0,#0                 ;1046
00003e  ecbd8b0c          VPOP     {d8-d13}
000042  bd70              POP      {r4-r6,pc}
                  |L16.68|
000044  ee190a10          VMOV     r0,s18                ;1049
000048  4daf              LDR      r5,|L16.776|
00004a  4eb0              LDR      r6,|L16.780|
00004c  42a8              CMP      r0,r5                 ;1049
00004e  d20b              BCS      |L16.104|
000050  ee190a10          VMOV     r0,s18                ;1049
000054  42b0              CMP      r0,r6                 ;1049
000056  da07              BGE      |L16.104|
000058  a0ad              ADR      r0,|L16.784|
00005a  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
00005e  b016              ADD      sp,sp,#0x58
000060  2000              MOVS     r0,#0                 ;1051
000062  ecbd8b0c          VPOP     {d8-d13}
000066  bd70              POP      {r4-r6,pc}
                  |L16.104|
000068  eeb00a61          VMOV.F32 s0,s3                 ;1056
00006c  a814              ADD      r0,sp,#0x50           ;1056
00006e  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
000072  ed900a00          VLDR     s0,[r0,#0]            ;1056
000076  eeb59ac0          VCMPE.F32 s18,#0.0              ;1065
00007a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1065
00007e  bfac              ITE      GE                    ;1065
000080  eef08a49          VMOVGE.F32 s17,s18               ;1065
000084  eef18a49          VNEGLT.F32 s17,s18               ;1065
000088  4668              MOV      r0,sp                 ;1067
00008a  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
00008e  ed9fdaa7          VLDR     s26,|L16.812|
000092  a804              ADD      r0,sp,#0x10           ;1068
000094  eeb00a4d          VMOV.F32 s0,s26                ;1068
000098  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
00009c  ed9f0aa4          VLDR     s0,|L16.816|
0000a0  a806              ADD      r0,sp,#0x18           ;1069
0000a2  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
0000a6  a904              ADD      r1,sp,#0x10           ;1073
0000a8  a802              ADD      r0,sp,#8              ;1073
0000aa  f7fffffe          BL       _ZN4Anki7RadiansC1ERKS0_ ; Anki::Radians::Radians(const Anki::Radians&)
0000ae  a904              ADD      r1,sp,#0x10           ;1075
0000b0  4668              MOV      r0,sp                 ;1075
0000b2  f7fffffe          BL       _ZN4AnkigeERKNS_7RadiansES2_ ; Anki::operator >=(const Anki::Radians&, const Anki::Radians&)
0000b6  b150              CBZ      r0,|L16.206|
0000b8  a906              ADD      r1,sp,#0x18           ;1075
0000ba  4668              MOV      r0,sp                 ;1075
0000bc  f7fffffe          BL       _ZN4AnkineERKNS_7RadiansES2_ ; Anki::operator !=(const Anki::Radians&, const Anki::Radians&)
0000c0  2800              CMP      r0,#0                 ;1075
0000c2  bf1c              ITT      NE                    ;1075
0000c4  eeb59ac0          VCMPENE.F32 s18,#0.0              ;1075
0000c8  eef1fa10          VMRSNE   APSR_nzcv,FPSCR       ;1075
0000cc  dc0a              BGT      |L16.228|
                  |L16.206|
0000ce  a904              ADD      r1,sp,#0x10           ;1076
0000d0  4668              MOV      r0,sp                 ;1076
0000d2  f7fffffe          BL       _ZN4AnkiltERKNS_7RadiansES2_ ; Anki::operator <(const Anki::Radians&, const Anki::Radians&)
0000d6  2800              CMP      r0,#0                 ;1076
0000d8  bf1c              ITT      NE                    ;1076
0000da  eeb59ac0          VCMPENE.F32 s18,#0.0              ;1076
0000de  eef1fa10          VMRSNE   APSR_nzcv,FPSCR       ;1076
0000e2  d203              BCS      |L16.236|
                  |L16.228|
0000e4  a906              ADD      r1,sp,#0x18           ;1077
0000e6  a802              ADD      r0,sp,#8              ;1077
0000e8  f7fffffe          BL       _ZN4Anki7RadiansaSERKS0_ ; Anki::Radians::operator =(const Anki::Radians&)
                  |L16.236|
0000ec  eef58ac0          VCMPE.F32 s17,#0.0              ;1081
0000f0  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1081
0000f4  dd78              BLE      |L16.488|
                  |L16.246|
0000f6  eeb59ac0          VCMPE.F32 s18,#0.0              ;1083
0000fa  466a              MOV      r2,sp                 ;1088
0000fc  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1083
000100  a902              ADD      r1,sp,#8              ;1088
000102  a808              ADD      r0,sp,#0x20           ;1088
000104  dd3b              BLE      |L16.382|
000106  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
00010a  ed9d0a08          VLDR     s0,[sp,#0x20]         ;1085
00010e  466a              MOV      r2,sp                 ;1085
000110  a902              ADD      r1,sp,#8              ;1085
000112  eeb50ac0          VCMPE.F32 s0,#0.0               ;1085
000116  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1085
00011a  db05              BLT      |L16.296|
00011c  a80c              ADD      r0,sp,#0x30           ;1085
00011e  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
000122  ed9d0a0c          VLDR     s0,[sp,#0x30]         ;1085
000126  e006              B        |L16.310|
                  |L16.296|
000128  a80e              ADD      r0,sp,#0x38           ;1085
00012a  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
00012e  ed9d0a0e          VLDR     s0,[sp,#0x38]         ;1085
000132  eeb10a40          VNEG.F32 s0,s0                 ;1085
                  |L16.310|
000136  eeb40ae8          VCMPE.F32 s0,s17                ;1085
00013a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1085
00013e  bf28              IT       CS                    ;1085
000140  eeb08a68          VMOVCS.F32 s16,s17               ;1085
000144  d25a              BCS      |L16.508|
000146  466a              MOV      r2,sp                 ;1085
000148  a902              ADD      r1,sp,#8              ;1085
00014a  a80a              ADD      r0,sp,#0x28           ;1085
00014c  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
000150  ed9d0a0a          VLDR     s0,[sp,#0x28]         ;1085
000154  466a              MOV      r2,sp                 ;1085
000156  a902              ADD      r1,sp,#8              ;1085
000158  eeb50ac0          VCMPE.F32 s0,#0.0               ;1085
00015c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1085
000160  db05              BLT      |L16.366|
000162  a810              ADD      r0,sp,#0x40           ;1085
000164  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
000168  ed9d8a10          VLDR     s16,[sp,#0x40]        ;1085
00016c  e046              B        |L16.508|
                  |L16.366|
00016e  a812              ADD      r0,sp,#0x48           ;1085
000170  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
000174  ed9d0a12          VLDR     s0,[sp,#0x48]         ;1085
000178  eeb18a40          VNEG.F32 s16,s0                ;1085
00017c  e03e              B        |L16.508|
                  |L16.382|
00017e  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
000182  ed9d0a08          VLDR     s0,[sp,#0x20]         ;1088
000186  466a              MOV      r2,sp                 ;1088
000188  a902              ADD      r1,sp,#8              ;1088
00018a  eeb50ac0          VCMPE.F32 s0,#0.0               ;1088
00018e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1088
000192  db05              BLT      |L16.416|
000194  a80c              ADD      r0,sp,#0x30           ;1088
000196  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
00019a  ed9d0a0c          VLDR     s0,[sp,#0x30]         ;1088
00019e  e006              B        |L16.430|
                  |L16.416|
0001a0  a80e              ADD      r0,sp,#0x38           ;1088
0001a2  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
0001a6  ed9d0a0e          VLDR     s0,[sp,#0x38]         ;1088
0001aa  eeb10a40          VNEG.F32 s0,s0                 ;1088
                  |L16.430|
0001ae  eeb18a68          VNEG.F32 s16,s17               ;1088
0001b2  eeb10a40          VNEG.F32 s0,s0                 ;1088
0001b6  eeb48ac0          VCMPE.F32 s16,s0                ;1088
0001ba  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1088
0001be  d21d              BCS      |L16.508|
0001c0  466a              MOV      r2,sp                 ;1088
0001c2  a902              ADD      r1,sp,#8              ;1088
0001c4  a80a              ADD      r0,sp,#0x28           ;1088
0001c6  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
0001ca  ed9d0a0a          VLDR     s0,[sp,#0x28]         ;1088
0001ce  466a              MOV      r2,sp                 ;1088
0001d0  a902              ADD      r1,sp,#8              ;1088
0001d2  eeb50ac0          VCMPE.F32 s0,#0.0               ;1088
0001d6  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1088
0001da  db06              BLT      |L16.490|
0001dc  a810              ADD      r0,sp,#0x40           ;1088
0001de  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
0001e2  ed9d0a10          VLDR     s0,[sp,#0x40]         ;1088
0001e6  e007              B        |L16.504|
                  |L16.488|
0001e8  e075              B        |L16.726|
                  |L16.490|
0001ea  a812              ADD      r0,sp,#0x48           ;1088
0001ec  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
0001f0  ed9d0a12          VLDR     s0,[sp,#0x48]         ;1088
0001f4  eeb10a40          VNEG.F32 s0,s0                 ;1088
                  |L16.504|
0001f8  eeb18a40          VNEG.F32 s16,s0                ;1088
                  |L16.508|
0001fc  eeb58ac0          VCMPE.F32 s16,#0.0              ;1091
000200  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1091
000204  d038              BEQ      |L16.632|
000206  ee180a10          VMOV     r0,s16                ;1091
00020a  4285              CMP      r5,r0                 ;1091
00020c  d903              BLS      |L16.534|
00020e  ee180a10          VMOV     r0,s16                ;1091
000212  42b0              CMP      r0,r6                 ;1091
000214  db30              BLT      |L16.632|
                  |L16.534|
000216  7960              LDRB     r0,[r4,#5]            ;1091
000218  edddca00          VLDR     s25,[sp,#0]           ;1091
00021c  280a              CMP      r0,#0xa               ;1091
00021e  d001              BEQ      |L16.548|
                  |L16.544|
000220  f7fffffe          BL       abort
                  |L16.548|
000224  eeb00a48          VMOV.F32 s0,s16                ;1092
000228  ee100a10          VMOV     r0,s0                 ;1092
00022c  42a8              CMP      r0,r5                 ;1092
00022e  d208              BCS      |L16.578|
000230  eeb00a48          VMOV.F32 s0,s16                ;1092
000234  ee100a10          VMOV     r0,s0                 ;1092
000238  42b0              CMP      r0,r6                 ;1092
00023a  bfbc              ITT      LT                    ;1092
00023c  483d              LDRLT    r0,|L16.820|
00023e  f7fffffe          BLLT     _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
                  |L16.578|
000242  7921              LDRB     r1,[r4,#4]            ;1092
000244  6822              LDR      r2,[r4,#0]            ;1092
000246  eb0100c1          ADD      r0,r1,r1,LSL #3       ;1092
00024a  eb020080          ADD      r0,r2,r0,LSL #2       ;1092
00024e  eef03a69          VMOV.F32 s7,s19                ;1092
000252  eeb03a4a          VMOV.F32 s6,s20                ;1092
000256  eef02a6a          VMOV.F32 s5,s21                ;1092
00025a  eeb02a48          VMOV.F32 s4,s16                ;1092
00025e  eef01a6c          VMOV.F32 s3,s25                ;1092
000262  eeb01a4b          VMOV.F32 s2,s22                ;1092
000266  eef00a4c          VMOV.F32 s1,s24                ;1092
00026a  eeb00a6b          VMOV.F32 s0,s23                ;1092
00026e  f7fffffe          BL       _ZN4Anki8Planning11PathSegment9DefineArcEffffffff ; Anki::Planning::PathSegment::DefineArc(float, float, float, float, float, float, float, float)
000272  7920              LDRB     r0,[r4,#4]            ;1092
000274  1c40              ADDS     r0,r0,#1              ;1092
000276  7120              STRB     r0,[r4,#4]            ;1092
                  |L16.632|
000278  eeb58ac0          VCMPE.F32 s16,#0.0              ;1096
00027c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1096
000280  bfac              ITE      GE                    ;1096
000282  eeb00a48          VMOVGE.F32 s0,s16                ;1096
000286  eeb10a48          VNEGLT.F32 s0,s16                ;1096
00028a  eeb40a68          VCMP.F32 s0,s17                ;1096
00028e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1096
000292  bf08              IT       EQ                    ;1097
000294  eef08a4d          VMOVEQ.F32 s17,s26               ;1097
000298  d00c              BEQ      |L16.692|
00029a  a902              ADD      r1,sp,#8              ;1099
00029c  4668              MOV      r0,sp                 ;1099
00029e  f7fffffe          BL       _ZN4Anki7RadiansaSERKS0_ ; Anki::Radians::operator =(const Anki::Radians&)
0002a2  eeb58ac0          VCMPE.F32 s16,#0.0              ;1100
0002a6  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1100
0002aa  bfb8              IT       LT                    ;1100
0002ac  eeb18a48          VNEGLT.F32 s16,s16               ;1100
0002b0  ee788ac8          VSUB.F32 s17,s17,s16           ;1100
                  |L16.692|
0002b4  a906              ADD      r1,sp,#0x18           ;1104
0002b6  a802              ADD      r0,sp,#8              ;1104
0002b8  f7fffffe          BL       _ZN4AnkieqERKNS_7RadiansES2_ ; Anki::operator ==(const Anki::Radians&, const Anki::Radians&)
0002bc  2800              CMP      r0,#0                 ;1104
0002be  bf14              ITE      NE                    ;1104
0002c0  a904              ADDNE    r1,sp,#0x10           ;1104
0002c2  a906              ADDEQ    r1,sp,#0x18           ;1104
0002c4  a802              ADD      r0,sp,#8              ;1104
0002c6  f7fffffe          BL       _ZN4Anki7RadiansaSERKS0_ ; Anki::Radians::operator =(const Anki::Radians&)
0002ca  eef58ac0          VCMPE.F32 s17,#0.0              ;1081
0002ce  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1081
0002d2  f73faf10          BGT      |L16.246|
                  |L16.726|
0002d6  b016              ADD      sp,sp,#0x58
0002d8  2001              MOVS     r0,#1                 ;1109
0002da  ecbd8b0c          VPOP     {d8-d13}
0002de  bd70              POP      {r4-r6,pc}
;;;1111       
                          ENDP

                  |L16.736|
0002e0  4552524f          DCB      "ERROR (AppendArc): Exceeded path size\n",0
0002e4  52202841
0002e8  7070656e
0002ec  64417263
0002f0  293a2045
0002f4  78636565
0002f8  64656420
0002fc  70617468
000300  2073697a
000304  650a00  
000307  00                DCB      0
                  |L16.776|
                          DCD      0xb727c5ac
                  |L16.780|
                          DCD      0x3727c5ac
                  |L16.784|
000310  4552524f          DCB      "ERROR: sweepRad is zero\n",0
000314  523a2073
000318  77656570
00031c  52616420
000320  6973207a
000324  65726f0a
000328  00      
000329  00                DCB      0
00032a  00                DCB      0
00032b  00                DCB      0
                  |L16.812|
00032c  00000000          DCFS     0x00000000 ; 0
                  |L16.816|
000330  40490fdb          DCFS     0x40490fdb ; 3.1415927410125732
                  |L16.820|
                          DCD      ||i._ZN4Anki8Planning4Path6AddArcEffffffff||+0x90

                          AREA ||i._ZN4Anki8Planning4PathC1ERKS1_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Planning4PathC2ERKS1_                  ; Alternate entry point ; Anki::Planning::Path::Path__sub_object(const Anki::Planning::Path&)
                  _ZN4Anki8Planning4PathC1ERKS1_ PROC ; Anki::Planning::Path::Path(const Anki::Planning::Path&)
;;;533    
;;;534        Path::Path(const Path& other)
;;;535        {
;;;536          capacity_ = MAX_NUM_PATH_SEGMENTS;
;;;537    
;;;538    #if CORETECH_ROBOT
;;;539      #if defined CORETECH_BASESTATION
;;;540      #error "only one of CORETECH_BASESTATION or CORETECH_ROBOT can be defined"
;;;541      #endif
;;;542          path_ = __pathSegmentStackForRobot;
;;;543    #elif defined CORETECH_BASESTATION
;;;544          path_ = new PathSegment[MAX_NUM_PATH_SEGMENTS];
;;;545    #else
;;;546    #error "one of CORETECH_BASESTATION or CORETECH_ROBOT must be defined"
;;;547    #endif
;;;548    
;;;549          Clear();
;;;550    
;;;551          *this = other;
;;;552        }
;;;553    
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
000004  230a              MOVS     r3,#0xa
000006  2224              MOVS     r2,#0x24
000008  490e              LDR      r1,|L17.68|
00000a  3008              ADDS     r0,r0,#8
00000c  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
000010  f1a00408          SUB      r4,r0,#8
000014  200a              MOVS     r0,#0xa
000016  7160              STRB     r0,[r4,#5]
000018  f1040008          ADD      r0,r4,#8
00001c  6020              STR      r0,[r4,#0]
00001e  2000              MOVS     r0,#0
000020  7120              STRB     r0,[r4,#4]
000022  7968              LDRB     r0,[r5,#5]
000024  280a              CMP      r0,#0xa
000026  d001              BEQ      |L17.44|
000028  f7fffffe          BL       abort
                  |L17.44|
00002c  7928              LDRB     r0,[r5,#4]
00002e  7120              STRB     r0,[r4,#4]
000030  eb0000c0          ADD      r0,r0,r0,LSL #3
000034  0082              LSLS     r2,r0,#2
000036  6829              LDR      r1,[r5,#0]
000038  6820              LDR      r0,[r4,#0]
00003a  f7fffffe          BL       __aeabi_memcpy4
00003e  4620              MOV      r0,r4
000040  bd70              POP      {r4-r6,pc}
                          ENDP

000042  0000              DCW      0x0000
                  |L17.68|
                          DCD      _ZN4Anki8Planning11PathSegmentC1Ev ; Anki::Planning::PathSegment::PathSegment()

                          AREA ||i._ZN4Anki8Planning4PathC1Ev||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Planning4PathC2Ev                  ; Alternate entry point ; Anki::Planning::Path::Path__sub_object()
                  _ZN4Anki8Planning4PathC1Ev PROC ; Anki::Planning::Path::Path()
;;;515    
;;;516        Path::Path()
;;;517        {
;;;518          capacity_ = MAX_NUM_PATH_SEGMENTS;
;;;519    
;;;520    #if CORETECH_ROBOT
;;;521      #if defined CORETECH_BASESTATION
;;;522      #error "only one of CORETECH_BASESTATION or CORETECH_ROBOT can be defined"
;;;523      #endif
;;;524          path_ = __pathSegmentStackForRobot;
;;;525    #elif defined CORETECH_BASESTATION
;;;526          path_ = new PathSegment[MAX_NUM_PATH_SEGMENTS];
;;;527    #else
;;;528    #error "one of CORETECH_BASESTATION or CORETECH_ROBOT must be defined"
;;;529    #endif
;;;530    
;;;531          Clear();
;;;532        }
;;;533    
000000  b510              PUSH     {r4,lr}
000002  230a              MOVS     r3,#0xa
000004  2224              MOVS     r2,#0x24
000006  4906              LDR      r1,|L18.32|
000008  3008              ADDS     r0,r0,#8
00000a  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
00000e  210a              MOVS     r1,#0xa
000010  f8001c03          STRB     r1,[r0,#-3]
000014  4601              MOV      r1,r0
000016  f8401d08          STR      r1,[r0,#-8]!
00001a  2100              MOVS     r1,#0
00001c  7101              STRB     r1,[r0,#4]
00001e  bd10              POP      {r4,pc}
                          ENDP

                  |L18.32|
                          DCD      _ZN4Anki8Planning11PathSegmentC1Ev ; Anki::Planning::PathSegment::PathSegment()

                          AREA ||i._ZN4Anki8Planning4PathD1Ev||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Planning4PathD2Ev                  ; Alternate entry point ; Anki::Planning::Path::~Path__sub_object()
                  _ZN4Anki8Planning4PathD1Ev PROC ; Anki::Planning::Path::~Path()
;;;553    
;;;554        Path::~Path()
;;;555        {
;;;556    #if CORETECH_BASESTATION
;;;557          delete [] path_;
;;;558          path_ = nullptr;
;;;559    #endif
;;;560        }
;;;561        
000000  4770              BX       lr
                          ENDP


                          AREA ||i._ZN4Anki8Planning4PathaSERKS1_||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Planning4PathaSERKS1_ PROC ; Anki::Planning::Path::operator =(const Anki::Planning::Path&)
;;;561        
;;;562        Path& Path::operator=(const Path& rhs)
000000  b510              PUSH     {r4,lr}
;;;563        {
000002  4604              MOV      r4,r0
;;;564          capacity_ = MAX_NUM_PATH_SEGMENTS;
000004  200a              MOVS     r0,#0xa
000006  7160              STRB     r0,[r4,#5]
;;;565          assert(capacity_ == rhs.capacity_);
000008  7948              LDRB     r0,[r1,#5]
00000a  280a              CMP      r0,#0xa
00000c  d001              BEQ      |L20.18|
00000e  f7fffffe          BL       abort
                  |L20.18|
;;;566    
;;;567          numPathSegments_ = rhs.numPathSegments_;
000012  7908              LDRB     r0,[r1,#4]
000014  7120              STRB     r0,[r4,#4]
;;;568          memcpy(path_, rhs.path_, numPathSegments_*sizeof(PathSegment));
000016  eb0000c0          ADD      r0,r0,r0,LSL #3
00001a  0082              LSLS     r2,r0,#2
00001c  6809              LDR      r1,[r1,#0]
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       __aeabi_memcpy4
;;;569          return *this;
000024  4620              MOV      r0,r4
;;;570        }
000026  bd10              POP      {r4,pc}
;;;571    
                          ENDP


                          AREA ||i._ZNK4Anki8Planning11PathSegment11GetEndPointERfS2_||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Planning11PathSegment11GetEndPointERfS2_ PROC ; Anki::Planning::PathSegment::GetEndPoint(float&, float&) const
;;;135        
;;;136        void PathSegment::GetEndPoint(f32 &x, f32 &y) const
000000  b570              PUSH     {r4-r6,lr}
;;;137        {
000002  460e              MOV      r6,r1
;;;138          switch(type_){
000004  7801              LDRB     r1,[r0,#0]
000006  4615              MOV      r5,r2                 ;137
000008  4604              MOV      r4,r0                 ;137
00000a  2901              CMP      r1,#1
00000c  d008              BEQ      |L21.32|
00000e  2902              CMP      r1,#2
000010  d00d              BEQ      |L21.46|
000012  2903              CMP      r1,#3
000014  d02c              BEQ      |L21.112|
;;;139            case PST_LINE:
;;;140              x = def_.line.endPt_x;
;;;141              y = def_.line.endPt_y;
;;;142              break;
;;;143            case PST_ARC:
;;;144              x = def_.arc.centerPt_x + def_.arc.radius * cosf(def_.arc.startRad + def_.arc.sweepRad);
;;;145              y = def_.arc.centerPt_y + def_.arc.radius * sinf(def_.arc.startRad + def_.arc.sweepRad);
;;;146              break;
;;;147            case PST_POINT_TURN:
;;;148              x = def_.turn.x;
;;;149              y = def_.turn.y;
;;;150              break;
;;;151            default:
;;;152              CoreTechPrint("ERROR (GetEndPoint): Undefined segment %d\n", type_);
000016  a01b              ADR      r0,|L21.132|
000018  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;153              assert(false);
00001c  f7fffffe          BL       abort
                  |L21.32|
000020  ed940a03          VLDR     s0,[r4,#0xc]          ;140
000024  ed860a00          VSTR     s0,[r6,#0]            ;140
000028  ed900a04          VLDR     s0,[r0,#0x10]         ;141
00002c  e026              B        |L21.124|
                  |L21.46|
00002e  ed940a04          VLDR     s0,[r4,#0x10]         ;144
000032  edd40a05          VLDR     s1,[r4,#0x14]         ;144
000036  ee300a20          VADD.F32 s0,s0,s1              ;144
00003a  f7fffffe          BL       __hardfp_cosf
00003e  edd40a01          VLDR     s1,[r4,#4]            ;144
000042  ed941a03          VLDR     s2,[r4,#0xc]          ;144
000046  ee410a00          VMLA.F32 s1,s2,s0              ;144
00004a  edc60a00          VSTR     s1,[r6,#0]            ;144
00004e  ed940a04          VLDR     s0,[r4,#0x10]         ;145
000052  edd40a05          VLDR     s1,[r4,#0x14]         ;145
000056  ee300a20          VADD.F32 s0,s0,s1              ;145
00005a  f7fffffe          BL       __hardfp_sinf
00005e  edd40a02          VLDR     s1,[r4,#8]            ;145
000062  ed941a03          VLDR     s2,[r4,#0xc]          ;145
000066  ee410a00          VMLA.F32 s1,s2,s0              ;145
00006a  edc50a00          VSTR     s1,[r5,#0]            ;145
;;;154          }
;;;155        }
00006e  bd70              POP      {r4-r6,pc}
                  |L21.112|
000070  ed940a01          VLDR     s0,[r4,#4]            ;148
000074  ed860a00          VSTR     s0,[r6,#0]            ;148
000078  ed900a02          VLDR     s0,[r0,#8]            ;149
                  |L21.124|
00007c  ed820a00          VSTR     s0,[r2,#0]            ;141
000080  bd70              POP      {r4-r6,pc}
;;;156    
                          ENDP

000082  0000              DCW      0x0000
                  |L21.132|
000084  4552524f          DCB      "ERROR (GetEndPoint): Undefined segment %d\n",0
000088  52202847
00008c  6574456e
000090  64506f69
000094  6e74293a
000098  20556e64
00009c  6566696e
0000a0  65642073
0000a4  65676d65
0000a8  6e742025
0000ac  640a00  
0000af  00                DCB      0

                          AREA ||i._ZNK4Anki8Planning11PathSegment13GetStartPointERfS2_||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Planning11PathSegment13GetStartPointERfS2_ PROC ; Anki::Planning::PathSegment::GetStartPoint(float&, float&) const
;;;114    
;;;115        void PathSegment::GetStartPoint(f32 &x, f32 &y) const
000000  b570              PUSH     {r4-r6,lr}
;;;116        {
000002  460e              MOV      r6,r1
;;;117          switch(type_){
000004  7801              LDRB     r1,[r0,#0]
000006  4615              MOV      r5,r2                 ;116
000008  4604              MOV      r4,r0                 ;116
00000a  2901              CMP      r1,#1
00000c  d008              BEQ      |L22.32|
00000e  2902              CMP      r1,#2
000010  d00f              BEQ      |L22.50|
000012  2903              CMP      r1,#3
000014  d004              BEQ      |L22.32|
;;;118            case PST_LINE:
;;;119              x = def_.line.startPt_x;
;;;120              y = def_.line.startPt_y;
;;;121              break;
;;;122            case PST_ARC:
;;;123              x = def_.arc.centerPt_x + def_.arc.radius * cosf(def_.arc.startRad);
;;;124              y = def_.arc.centerPt_y + def_.arc.radius * sinf(def_.arc.startRad);
;;;125              break;
;;;126            case PST_POINT_TURN:
;;;127              x = def_.turn.x;
;;;128              y = def_.turn.y;
;;;129              break;
;;;130            default:
;;;131              CoreTechPrint("ERROR (GetStartPoint): Undefined segment %d\n", type_);
000016  a013              ADR      r0,|L22.100|
000018  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;132              assert(false);
00001c  f7fffffe          BL       abort
                  |L22.32|
000020  ed940a01          VLDR     s0,[r4,#4]            ;119
000024  ed860a00          VSTR     s0,[r6,#0]            ;119
000028  ed900a02          VLDR     s0,[r0,#8]            ;120
00002c  ed820a00          VSTR     s0,[r2,#0]            ;120
;;;133          }
;;;134        }
000030  bd70              POP      {r4-r6,pc}
                  |L22.50|
000032  ed940a04          VLDR     s0,[r4,#0x10]         ;123
000036  f7fffffe          BL       __hardfp_cosf
00003a  edd40a01          VLDR     s1,[r4,#4]            ;123
00003e  ed941a03          VLDR     s2,[r4,#0xc]          ;123
000042  ee410a00          VMLA.F32 s1,s2,s0              ;123
000046  edc60a00          VSTR     s1,[r6,#0]            ;123
00004a  ed940a04          VLDR     s0,[r4,#0x10]         ;124
00004e  f7fffffe          BL       __hardfp_sinf
000052  edd40a02          VLDR     s1,[r4,#8]            ;124
000056  ed941a03          VLDR     s2,[r4,#0xc]          ;124
00005a  ee410a00          VMLA.F32 s1,s2,s0              ;124
00005e  edc50a00          VSTR     s1,[r5,#0]            ;124
000062  bd70              POP      {r4-r6,pc}
;;;135        
                          ENDP

                  |L22.100|
000064  4552524f          DCB      "ERROR (GetStartPoint): Undefined segment %d\n",0
000068  52202847
00006c  65745374
000070  61727450
000074  6f696e74
000078  293a2055
00007c  6e646566
000080  696e6564
000084  20736567
000088  6d656e74
00008c  2025640a
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i._ZNK4Anki8Planning11PathSegment16GetDistToSegmentEfffRfS2_||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Planning11PathSegment16GetDistToSegmentEfffRfS2_ PROC ; Anki::Planning::PathSegment::GetDistToSegment(float, float, float, float&, float&) const
;;;207        
;;;208        SegmentRangeStatus PathSegment::GetDistToSegment(const f32 x, const f32 y, const f32 angle,
000000  b510              PUSH     {r4,lr}
;;;209                                                        f32 &shortestDistanceToPath, f32 &radDiff) const
;;;210        {
;;;211          SegmentRangeStatus res = OOR_NEAR_END;
;;;212          
;;;213          switch(type_) {
000002  7803              LDRB     r3,[r0,#0]
000004  2b01              CMP      r3,#1
000006  d005              BEQ      |L23.20|
000008  2b02              CMP      r3,#2
00000a  d007              BEQ      |L23.28|
00000c  2b03              CMP      r3,#3
00000e  d009              BEQ      |L23.36|
;;;214            case PST_LINE:
;;;215              res = GetDistToLineSegment(x,y,angle,shortestDistanceToPath,radDiff);
;;;216              break;
;;;217            case PST_ARC:
;;;218              res = GetDistToArcSegment(x,y,angle,shortestDistanceToPath,radDiff);
;;;219              break;
;;;220            case PST_POINT_TURN:
;;;221              // NOTE: This always returns IN_SEGMENT_RANGE since we can't know purely
;;;222              // from the given pose whether it's approaching or past the target angle.
;;;223              res = GetDistToPointTurnSegment(x,y,angle,shortestDistanceToPath,radDiff);
;;;224              break;
;;;225            default:
;;;226              assert(false);
000010  f7fffffe          BL       abort
                  |L23.20|
000014  e8bd4010          POP      {r4,lr}               ;215
000018  f7ffbffe          B.W      _ZNK4Anki8Planning11PathSegment20GetDistToLineSegmentEfffRfS2_ ; Anki::Planning::PathSegment::GetDistToLineSegment(float, float, float, float&, float&) const
                  |L23.28|
00001c  e8bd4010          POP      {r4,lr}               ;218
000020  f7ffbffe          B.W      _ZNK4Anki8Planning11PathSegment19GetDistToArcSegmentEfffRfS2_ ; Anki::Planning::PathSegment::GetDistToArcSegment(float, float, float, float&, float&) const
                  |L23.36|
000024  e8bd4010          POP      {r4,lr}               ;223
000028  f7ffbffe          B.W      _ZNK4Anki8Planning11PathSegment25GetDistToPointTurnSegmentEfffRfS2_ ; Anki::Planning::PathSegment::GetDistToPointTurnSegment(float, float, float, float&, float&) const
;;;227          }
;;;228          
;;;229          return res;
;;;230        }
;;;231        
                          ENDP


                          AREA ||i._ZNK4Anki8Planning11PathSegment19GetDistToArcSegmentEfffRfS2_||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Planning11PathSegment19GetDistToArcSegmentEfffRfS2_ PROC ; Anki::Planning::PathSegment::GetDistToArcSegment(float, float, float, float&, float&) const
;;;355    
;;;356        SegmentRangeStatus PathSegment::GetDistToArcSegment(const f32 x, const f32 y, const f32 angle,
000000  b5f0              PUSH     {r4-r7,lr}
;;;357                                                           f32 &shortestDistanceToPath, f32 &radDiff) const
;;;358        {
;;;359          const PathSegmentDef::s_arc* seg = &(def_.arc);
000002  1d04              ADDS     r4,r0,#4
000004  ed2d8b0c          VPUSH    {d8-d13}              ;358
000008  eef0ba40          VMOV.F32 s23,s0                ;358
00000c  b08b              SUB      sp,sp,#0x2c           ;358
00000e  4617              MOV      r7,r2                 ;358
000010  460d              MOV      r5,r1                 ;358
000012  eeb0ca41          VMOV.F32 s24,s2                ;358
000016  eeb0ba60          VMOV.F32 s22,s1                ;358
;;;360          
;;;361    #if(DEBUG_PATH)
;;;362          CoreTechPrint("ARC (%f, %f), startRad: %f, sweepRad: %f, radius: %f\n",
;;;363                seg->centerPt_x, seg->centerPt_y, seg->startRad, seg->sweepRad, seg->radius);
;;;364    #endif
;;;365          
;;;366          
;;;367          // Assuming arc is broken up so that it is a true function
;;;368          
;;;369          // Arc paramters
;;;370          f32 x_center = seg->centerPt_x;
00001a  ed908a01          VLDR     s16,[r0,#4]
;;;371          f32 y_center = seg->centerPt_y;
00001e  edd0aa02          VLDR     s21,[r0,#8]
;;;372          f32 r = seg->radius;
000022  ed90aa03          VLDR     s20,[r0,#0xc]
;;;373          Anki::Radians startRad = seg->startRad;
000026  ed900a04          VLDR     s0,[r0,#0x10]
00002a  a804              ADD      r0,sp,#0x10
00002c  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
;;;374          
;;;375          // Line formed by circle center and robot pose
;;;376          f32 dy = y - y_center;
000030  ee7b9a6a          VSUB.F32 s19,s22,s21
;;;377          f32 dx = x - x_center;
000034  ee3b9ac8          VSUB.F32 s18,s23,s16
;;;378          f32 m = dy / dx;
000038  eeb0da4b          VMOV.F32 s26,s22
;;;379          f32 b = y - m*x;
;;;380          
;;;381          
;;;382          // Find heading error
;;;383          bool movingCCW = seg->sweepRad >= 0;
00003c  ed940a04          VLDR     s0,[r4,#0x10]
000040  eec98a89          VDIV.F32 s17,s19,s18           ;378
000044  eeb50ac0          VCMPE.F32 s0,#0.0
000048  ee08daeb          VMLS.F32 s26,s17,s23           ;379
00004c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000050  bfac              ITE      GE
000052  2601              MOVGE    r6,#1
000054  2600              MOVLT    r6,#0
;;;384          Anki::Radians theta_line = ATAN2_FAST(dy,dx); // angle of line from circle center to robot
000056  eef00a49          VMOV.F32 s1,s18
00005a  eeb00a69          VMOV.F32 s0,s19
00005e  f7fffffe          BL       _Z10atan2_fastff ; atan2_fast(float, float)
000062  4668              MOV      r0,sp
000064  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
;;;385          Anki::Radians theta_tangent = theta_line + Anki::Radians((movingCCW ? 1 : -1 ) * PIDIV2);
000068  2e00              CMP      r6,#0
00006a  bf14              ITE      NE
00006c  2001              MOVNE    r0,#1
00006e  f04f30ff          MOVEQ    r0,#0xffffffff
000072  ee000a10          VMOV     s0,r0
000076  eeb80ac0          VCVT.F32.S32 s0,s0
00007a  eddf0ab5          VLDR     s1,|L24.848|
00007e  a808              ADD      r0,sp,#0x20
000080  ee200a20          VMUL.F32 s0,s0,s1
000084  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
000088  4602              MOV      r2,r0
00008a  4669              MOV      r1,sp
00008c  a806              ADD      r0,sp,#0x18
00008e  f7fffffe          BL       _ZN4AnkiplERKNS_7RadiansES2_ ; Anki::operator +(const Anki::Radians&, const Anki::Radians&)
;;;386          
;;;387          radDiff = (theta_tangent - angle).ToFloat();
000092  eeb00a4c          VMOV.F32 s0,s24
000096  a906              ADD      r1,sp,#0x18
000098  a802              ADD      r0,sp,#8
00009a  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansEf ; Anki::operator -(const Anki::Radians&, float)
00009e  ed9d0a02          VLDR     s0,[sp,#8]
0000a2  ed870a00          VSTR     s0,[r7,#0]
0000a6  ed9d0a00          VLDR     s0,[sp,#0]
;;;388          
;;;389          // If the line is nearly vertical (within 0.5deg), approximate it
;;;390          // with true vertical so we don't take sqrts of -ve numbers.
;;;391          f32 x_intersect, y_intersect;
;;;392          if (NEAR(ABS(theta_line.ToFloat()), PIDIV2, 0.01f)) {
0000aa  eeb50ac0          VCMPE.F32 s0,#0.0
0000ae  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000b2  bfac              ITE      GE
0000b4  eef00a40          VMOVGE.F32 s1,s0
0000b8  eef10a40          VNEGLT.F32 s1,s0
0000bc  ee100a90          VMOV     r0,s1
0000c0  49a4              LDR      r1,|L24.852|
0000c2  4288              CMP      r0,r1
0000c4  d019              BEQ      |L24.250|
0000c6  eeb50ac0          VCMPE.F32 s0,#0.0
0000ca  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000ce  bfac              ITE      GE
0000d0  eef00a40          VMOVGE.F32 s1,s0
0000d4  eef10a40          VNEGLT.F32 s1,s0
0000d8  ee100a90          VMOV     r0,s1
0000dc  499e              LDR      r1,|L24.856|
0000de  4281              CMP      r1,r0
0000e0  da19              BGE      |L24.278|
0000e2  eeb50ac0          VCMPE.F32 s0,#0.0
0000e6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000ea  bfb8              IT       LT
0000ec  eeb10a40          VNEGLT.F32 s0,s0
0000f0  ee100a10          VMOV     r0,s0
0000f4  4999              LDR      r1,|L24.860|
0000f6  4288              CMP      r0,r1
0000f8  da0d              BGE      |L24.278|
                  |L24.250|
;;;393            shortestDistanceToPath = ABS(dy) - r;
0000fa  eef59ac0          VCMPE.F32 s19,#0.0
0000fe  eef1fa10          VMRS     APSR_nzcv,FPSCR
000102  bfb8              IT       LT
000104  eef19a69          VNEGLT.F32 s19,s19
000108  ee390aca          VSUB.F32 s0,s19,s20
;;;394            x_intersect = x_center;
00010c  eef08a48          VMOV.F32 s17,s16
000110  ed850a00          VSTR     s0,[r5,#0]            ;393
000114  e088              B        |L24.552|
                  |L24.278|
;;;395            y_intersect = y_center + r * (dx > 0 ? 1 : -1);
;;;396            
;;;397          } else {
;;;398            
;;;399            // Where does circle (x - x_center)^2 + (y - y_center)^2 = r^2 and y=mx+b intersect where y=mx+b represents
;;;400            // the line between the circle center and the robot?
;;;401            // (y - y_center)^2 == r^2 - (x - x_center)^2
;;;402            // y = sqrt(r^2 - (x - x_center)^2) + y_center
;;;403            //   = mx + b
;;;404            // (mx + b - y_center)^2 == r^2 - (x - x_center)^2
;;;405            // m^2*x^2 + 2*m*(b - y_center)*x + (b - y_center)^2 == r^2 - x^2 + 2*x_center*x - x_center^2
;;;406            // (m^2+1) * x^2 + (2*m*(b - y_center) - 2*x_center) * x + (b - y_center)^2 - r^2 + x_center^2 == 0
;;;407            //
;;;408            // Use quadratic formula to solve
;;;409            
;;;410            // Quadratic formula coefficients
;;;411            f32 A = m*m + 1;
;;;412            f32 B = 2*m*(b-y_center) - 2*x_center;
000116  eef0ca00          VMOV.F32 s25,#2.00000000
00011a  ee3d0a6a          VSUB.F32 s0,s26,s21
00011e  ee680aac          VMUL.F32 s1,s17,s25
000122  eeb7ca00          VMOV.F32 s24,#1.00000000       ;411
;;;413            f32 C = (b - y_center)*(b - y_center) - r*r + x_center*x_center;
;;;414            f32 sqrtPart = sqrtf(B*B - 4*A*C);
000126  eeb11a00          VMOV.F32 s2,#4.00000000
00012a  ee08caa8          VMLA.F32 s24,s17,s17           ;411
00012e  ee608a80          VMUL.F32 s17,s1,s0             ;412
000132  ee200a00          VMUL.F32 s0,s0,s0              ;413
000136  ee488a6c          VMLS.F32 s17,s16,s25           ;412
00013a  ee0a0a4a          VMLS.F32 s0,s20,s20            ;413
00013e  ee2c1a01          VMUL.F32 s2,s24,s2
000142  ee680aa8          VMUL.F32 s1,s17,s17
000146  ee080a08          VMLA.F32 s0,s16,s16            ;413
00014a  ee410a40          VMLS.F32 s1,s2,s0
00014e  eeb10ae0          VSQRT.F32 s0,s1
000152  eeb40a40          VCMP.F32 s0,s0
000156  eef1fa10          VMRS     APSR_nzcv,FPSCR
00015a  bf1c              ITT      NE
00015c  eeb00a60          VMOVNE.F32 s0,s1
000160  f7fffffe          BLNE     __hardfp_sqrtf
;;;415            
;;;416            f32 x_intersect_1 = (-B + sqrtPart) / (2*A);
000164  ee701a68          VSUB.F32 s3,s0,s17
000168  ee2c1a2c          VMUL.F32 s2,s24,s25
;;;417            f32 x_intersect_2 = (-B - sqrtPart) / (2*A);
;;;418            
;;;419            
;;;420            // Now we have 2 roots.
;;;421            // Select the one that's on the same side of the circle center as the robot is.
;;;422            x_intersect = x_intersect_2;
;;;423            if (SIGN(dx) == SIGN(x_intersect_1 - x_center)) {
00016c  eeb59ac0          VCMPE.F32 s18,#0.0
000170  eec10a81          VDIV.F32 s1,s3,s2              ;416
000174  eef11a68          VNEG.F32 s3,s17                ;417
000178  ee310ac0          VSUB.F32 s0,s3,s0              ;417
00017c  eec08a01          VDIV.F32 s17,s0,s2             ;417
000180  eef1fa10          VMRS     APSR_nzcv,FPSCR
000184  bfac              ITE      GE
000186  2001              MOVGE    r0,#1
000188  2000              MOVLT    r0,#0
00018a  ee300ac8          VSUB.F32 s0,s1,s16
00018e  eeb50ac0          VCMPE.F32 s0,#0.0
000192  eef1fa10          VMRS     APSR_nzcv,FPSCR
000196  bfac              ITE      GE
000198  2101              MOVGE    r1,#1
00019a  2100              MOVLT    r1,#0
00019c  4288              CMP      r0,r1
;;;424              x_intersect = x_intersect_1;
00019e  bf08              IT       EQ
0001a0  eef08a60          VMOVEQ.F32 s17,s1
;;;425            }
;;;426            
;;;427            // Find y value of intersection
;;;428            f32 dx_intersect = x_intersect - x_center;
0001a4  ee380ac8          VSUB.F32 s0,s17,s16
;;;429            if (ABS(dx_intersect) > r) {
0001a8  eeb50ac0          VCMPE.F32 s0,#0.0
0001ac  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001b0  bfac              ITE      GE
0001b2  eef00a40          VMOVGE.F32 s1,s0
0001b6  eef10a40          VNEGLT.F32 s1,s0
0001ba  eef40aca          VCMPE.F32 s1,s20
0001be  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001c2  dc1c              BGT      |L24.510|
;;;430              // This can sometimes happen if we're at the right-most or left-most side of the circle
;;;431              y_intersect = y_center;
;;;432            } else {
;;;433              y_intersect = y_center + (dy > 0 ? 1 : -1) * sqrtf((r*r) - (dx_intersect * dx_intersect));
0001c4  ee6a0a0a          VMUL.F32 s1,s20,s20
0001c8  ee400a40          VMLS.F32 s1,s0,s0
0001cc  eeb10ae0          VSQRT.F32 s0,s1
0001d0  eeb40a40          VCMP.F32 s0,s0
0001d4  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001d8  bf1c              ITT      NE
0001da  eeb00a60          VMOVNE.F32 s0,s1
0001de  f7fffffe          BLNE     __hardfp_sqrtf
0001e2  eef59ac0          VCMPE.F32 s19,#0.0
0001e6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001ea  bfcc              ITE      GT
0001ec  2001              MOVGT    r0,#1
0001ee  f04f30ff          MOVLE    r0,#0xffffffff
0001f2  ee000a90          VMOV     s1,r0
0001f6  eef80ae0          VCVT.F32.S32 s1,s1
0001fa  ee40aa80          VMLA.F32 s21,s1,s0
                  |L24.510|
;;;434            }
;;;435            
;;;436            // Compute distance to intersection point (i.e. shortest distance to arc)
;;;437            shortestDistanceToPath = sqrtf((x - x_intersect) * (x - x_intersect) + (y - y_intersect) * (y - y_intersect));
0001fe  ee3b0ae8          VSUB.F32 s0,s23,s17
000202  ee200a00          VMUL.F32 s0,s0,s0
000206  ee7b0a6a          VSUB.F32 s1,s22,s21
00020a  ee000aa0          VMLA.F32 s0,s1,s1
00020e  eef10ac0          VSQRT.F32 s1,s0
000212  eef40a60          VCMP.F32 s1,s1
000216  eef1fa10          VMRS     APSR_nzcv,FPSCR
00021a  d003              BEQ      |L24.548|
00021c  f7fffffe          BL       __hardfp_sqrtf
000220  eef00a40          VMOV.F32 s1,s0
                  |L24.548|
000224  edc50a00          VSTR     s1,[r5,#0]
                  |L24.552|
;;;438            
;;;439    #if(DEBUG_PATH)
;;;440            CoreTechPrint("A: %f, B: %f, C: %f, sqrt: %f\n", A, B, C, sqrtPart);
;;;441            CoreTechPrint("x_intersects: (%f %f)\n", x_intersect_1, x_intersect_2);
;;;442    #endif
;;;443            
;;;444            
;;;445          }
;;;446          
;;;447          // Figure out sign of distance according to robot orientation and whether it's inside or outside the circle.
;;;448          bool robotInsideCircle = ABS(dx) < ABS(x_intersect - x_center);
000228  eeb59ac0          VCMPE.F32 s18,#0.0
00022c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000230  bfb8              IT       LT
000232  eeb19a49          VNEGLT.F32 s18,s18
000236  ee380ac8          VSUB.F32 s0,s17,s16
00023a  eeb50ac0          VCMPE.F32 s0,#0.0
00023e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000242  bfb8              IT       LT
000244  ee380a68          VSUBLT.F32 s0,s16,s17
000248  eeb49ac0          VCMPE.F32 s18,s0
00024c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000250  bf34              ITE      CC
000252  2001              MOVCC    r0,#1
000254  2000              MOVCS    r0,#0
;;;449          if ((robotInsideCircle && !movingCCW) || (!robotInsideCircle && movingCCW)) {
000256  ea300106          BICS     r1,r0,r6
00025a  bf08              IT       EQ
00025c  ea360000          BICSEQ   r0,r6,r0
000260  d005              BEQ      |L24.622|
;;;450            shortestDistanceToPath *= -1;
000262  ed950a00          VLDR     s0,[r5,#0]
000266  eeb10a40          VNEG.F32 s0,s0
00026a  ed850a00          VSTR     s0,[r5,#0]
                  |L24.622|
;;;451          }
;;;452    
;;;453          // Did we pass the current segment?
;;;454          // Check if the angDiff exceeds the sweep angle.
;;;455          // Also check for transitions between -PI and +PI by checking if angDiff
;;;456          // ever exceeds a conservative half the distance if PI was approached from the opposite direction.
;;;457          SegmentRangeStatus segStatus = IN_SEGMENT_RANGE;
00026e  2500              MOVS     r5,#0
;;;458          f32 angDiff = (theta_line - startRad).ToFloat();
000270  aa04              ADD      r2,sp,#0x10
000272  4669              MOV      r1,sp
000274  a802              ADD      r0,sp,#8
000276  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
00027a  ed9d0a02          VLDR     s0,[sp,#8]
;;;459          if ( (movingCCW && (angDiff > seg->sweepRad || angDiff < -0.5f*(2.f*PI-seg->sweepRad))) ||
00027e  ed9f1a38          VLDR     s2,|L24.864|
;;;460              (!movingCCW && (angDiff < seg->sweepRad || angDiff >  0.5f*(2.f*PI+seg->sweepRad))) ){
000282  edd40a04          VLDR     s1,[r4,#0x10]
000286  eebe2a00          VMOV.F32 s4,#-0.50000000       ;459
00028a  eef61a00          VMOV.F32 s3,#0.50000000
00028e  b176              CBZ      r6,|L24.686|
000290  eef40ac0          VCMPE.F32 s1,s0                 ;459
000294  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;459
000298  d317              BCC      |L24.714|
00029a  ee710a60          VSUB.F32 s1,s2,s1              ;459
00029e  ee600a82          VMUL.F32 s1,s1,s4              ;459
0002a2  eef40ac0          VCMPE.F32 s1,s0                 ;459
0002a6  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;459
0002aa  dd10              BLE      |L24.718|
0002ac  e00d              B        |L24.714|
                  |L24.686|
0002ae  eef40ac0          VCMPE.F32 s1,s0
0002b2  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002b6  dc08              BGT      |L24.714|
0002b8  ee700a81          VADD.F32 s1,s1,s2
0002bc  ee600aa1          VMUL.F32 s1,s1,s3
0002c0  eef40ac0          VCMPE.F32 s1,s0
0002c4  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002c8  d21c              BCS      |L24.772|
                  |L24.714|
;;;461            segStatus = OOR_NEAR_END;
0002ca  2502              MOVS     r5,#2
0002cc  b1d6              CBZ      r6,|L24.772|
                  |L24.718|
;;;462          }
;;;463    
;;;464          
;;;465          if (movingCCW) {
;;;466            if (angDiff > seg->sweepRad || angDiff < -0.5f*(2.f*PI-seg->sweepRad)) {
0002ce  edd40a04          VLDR     s1,[r4,#0x10]
0002d2  eef40ac0          VCMPE.F32 s1,s0
0002d6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002da  d323              BCC      |L24.804|
0002dc  ee710a60          VSUB.F32 s1,s2,s1
0002e0  ee600a82          VMUL.F32 s1,s1,s4
0002e4  eef40ac0          VCMPE.F32 s1,s0
0002e8  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002ec  dc1a              BGT      |L24.804|
;;;467              segStatus = OOR_NEAR_END;
;;;468            } else if (angDiff < 0 && angDiff > -0.5f*(2.f*PI-seg->sweepRad)) {
0002ee  eeb50ac0          VCMPE.F32 s0,#0.0
0002f2  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002f6  bf3c              ITT      CC
0002f8  eef40ac0          VCMPECC.F32 s1,s0
0002fc  eef1fa10          VMRSCC   APSR_nzcv,FPSCR
000300  d221              BCS      |L24.838|
000302  e01f              B        |L24.836|
                  |L24.772|
;;;469              segStatus = OOR_NEAR_START;
;;;470            }
;;;471              
;;;472          } else {
;;;473            if (angDiff < seg->sweepRad || angDiff >  0.5f*(2.f*PI+seg->sweepRad)) {
000304  edd40a04          VLDR     s1,[r4,#0x10]
000308  eef40ac0          VCMPE.F32 s1,s0
00030c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000310  dc08              BGT      |L24.804|
000312  ee302a81          VADD.F32 s4,s1,s2
000316  ee222a21          VMUL.F32 s4,s4,s3
00031a  eeb42ac0          VCMPE.F32 s4,s0
00031e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000322  d201              BCS      |L24.808|
                  |L24.804|
;;;474              segStatus = OOR_NEAR_END;
000324  2502              MOVS     r5,#2
000326  e00e              B        |L24.838|
                  |L24.808|
;;;475            } else if (angDiff > 0 && angDiff < 0.5f*(2.f*PI-seg->sweepRad)) {
000328  eeb50ac0          VCMPE.F32 s0,#0.0
00032c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000330  dd09              BLE      |L24.838|
000332  ee710a60          VSUB.F32 s1,s2,s1
000336  ee600aa1          VMUL.F32 s1,s1,s3
00033a  eef40ac0          VCMPE.F32 s1,s0
00033e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000342  dd00              BLE      |L24.838|
                  |L24.836|
;;;476              segStatus = OOR_NEAR_START;
000344  2501              MOVS     r5,#1
                  |L24.838|
;;;477            }
;;;478          }
;;;479    
;;;480          
;;;481    #if(DEBUG_PATH)
;;;482          CoreTechPrint("x: %f, y: %f, m: %f, b: %f\n", x,y,m,b);
;;;483          CoreTechPrint("x_center: %f, y_center: %f\n", x_center, y_center);
;;;484          CoreTechPrint("x_int: %f, y_int: %f\n", x_intersect, y_intersect);
;;;485          CoreTechPrint("dy: %f, dx: %f, dist: %f, radDiff: %f\n", dy, dx, shortestDistanceToPath, radDiff);
;;;486          CoreTechPrint("insideCircle: %d, segmentRangeStatus: %d\n", robotInsideCircle, segStatus);
;;;487          CoreTechPrint("theta_line: %f, theta_tangent: %f\n", theta_line.ToFloat(), theta_tangent.ToFloat());
;;;488    #endif
;;;489          
;;;490          return segStatus;
;;;491        }
000346  b00b              ADD      sp,sp,#0x2c
000348  4628              MOV      r0,r5                 ;490
00034a  ecbd8b0c          VPOP     {d8-d13}
00034e  bdf0              POP      {r4-r7,pc}
;;;492        
                          ENDP

                  |L24.848|
000350  3fc90fdb          DCFS     0x3fc90fdb ; 1.5707963705062866
                  |L24.852|
                          DCD      0x3fc90fdb
                  |L24.856|
                          DCD      0x3fc7c82d
                  |L24.860|
                          DCD      0x3fca5789
                  |L24.864|
000360  40c90fdb          DCFS     0x40c90fdb ; 6.2831854820251465

                          AREA ||i._ZNK4Anki8Planning11PathSegment20GetDistToLineSegmentEfffRfS2_||, CODE, READONLY, ALIGN=3

                  _ZNK4Anki8Planning11PathSegment20GetDistToLineSegmentEfffRfS2_ PROC ; Anki::Planning::PathSegment::GetDistToLineSegment(float, float, float, float&, float&) const
;;;233        
;;;234        SegmentRangeStatus PathSegment::GetDistToLineSegment(const f32 x, const f32 y, const f32 angle,
000000  b570              PUSH     {r4-r6,lr}
;;;235                                                            f32 &shortestDistanceToPath, f32 &radDiff) const
;;;236        {
;;;237          const PathSegmentDef::s_line* seg = &(def_.line);
000002  1d04              ADDS     r4,r0,#4
000004  ed2d8b0a          VPUSH    {d8-d12}              ;236
000008  eef08a40          VMOV.F32 s17,s0                ;236
00000c  eeb09a60          VMOV.F32 s18,s1                ;236
000010  eef0ba41          VMOV.F32 s23,s2                ;236
000014  b084              SUB      sp,sp,#0x10           ;236
000016  4616              MOV      r6,r2                 ;236
;;;238          
;;;239          f32 line_m_ = (seg->endPt_y - seg->startPt_y) / (seg->endPt_x - seg->startPt_x);
000018  ed900a04          VLDR     s0,[r0,#0x10]
00001c  ed90ba02          VLDR     s22,[r0,#8]
000020  edd00a03          VLDR     s1,[r0,#0xc]
000024  460d              MOV      r5,r1                 ;236
000026  ee709a4b          VSUB.F32 s19,s0,s22
00002a  ed900a01          VLDR     s0,[r0,#4]
00002e  ee30aac0          VSUB.F32 s20,s1,s0
;;;240          f32 line_b_ = seg->startPt_y - line_m_ * seg->startPt_x;
;;;241          f32 line_dy_sign_ = ((seg->endPt_y - seg->startPt_y) >= 0) ? 1.0 : -1.0;
000032  eef59ac0          VCMPE.F32 s19,#0.0
000036  ee898a8a          VDIV.F32 s16,s19,s20           ;239
00003a  ee08ba40          VMLS.F32 s22,s16,s0            ;240
00003e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000042  bfac              ITE      GE
000044  ed9f0b9e          VLDRGE   d0,|L25.704|
000048  ed9f0b9f          VLDRLT   d0,|L25.712|
00004c  ec510b10          VMOV     r0,r1,d0
000050  f7fffffe          BL       __aeabi_d2f
000054  ee0c0a10          VMOV     s24,r0
;;;242          Radians line_theta_ = ATAN2_FAST(seg->endPt_y - seg->startPt_y, seg->endPt_x - seg->startPt_x);
000058  eef00a4a          VMOV.F32 s1,s20
00005c  eeb00a69          VMOV.F32 s0,s19
000060  f7fffffe          BL       _Z10atan2_fastff ; atan2_fast(float, float)
000064  4668              MOV      r0,sp
000066  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
;;;243          
;;;244          
;;;245          // Find shortest path to current segment.
;;;246          // Shortest path is along a line with inverse negative slope (i.e. -1/m).
;;;247          // Point of intersection is solution to mx + b == (-1/m)*x + b_inv where b_inv = y-(-1/m)*x
;;;248          
;;;249    #if(DEBUG_PATH)
;;;250          CoreTechPrint("LINE (%f, %f, %f, %f)\n", seg->startPt_x, seg->startPt_y, seg->endPt_x, seg->endPt_y);
;;;251          CoreTechPrint("Robot Pose: x: %f, y: %f ang: %f\n", x,y,angle);
;;;252    #endif
;;;253          
;;;254          
;;;255          // Distance to start point
;;;256          f32 sqDistToStartPt = (seg->startPt_x - x) * (seg->startPt_x - x) +
;;;257          (seg->startPt_y - y) * (seg->startPt_y - y);
;;;258          
;;;259          // Distance to end point
;;;260          f32 sqDistToEndPt = (seg->endPt_x - x) * (seg->endPt_x - x) +
00006a  ed941a02          VLDR     s2,[r4,#8]
00006e  ed942a00          VLDR     s4,[r4,#0]            ;256
000072  edd40a01          VLDR     s1,[r4,#4]            ;256
000076  ee711a68          VSUB.F32 s3,s2,s17
00007a  ee320a68          VSUB.F32 s0,s4,s17             ;256
;;;261          (seg->endPt_y - y) * (seg->endPt_y - y);
;;;262          
;;;263          
;;;264          if (ABS(line_m_) > 10000) {
00007e  eeb58ac0          VCMPE.F32 s16,#0.0
000082  ee21aaa1          VMUL.F32 s20,s3,s3             ;260
000086  edd41a03          VLDR     s3,[r4,#0xc]          ;260
00008a  ee60aa00          VMUL.F32 s21,s0,s0             ;256
00008e  ee300ac9          VSUB.F32 s0,s1,s18             ;256
000092  ee712ac9          VSUB.F32 s5,s3,s18             ;260
000096  ee40aa00          VMLA.F32 s21,s0,s0             ;256
00009a  ee02aaa2          VMLA.F32 s20,s5,s5             ;260
00009e  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000a2  bfac              ITE      GE
0000a4  eef02a48          VMOVGE.F32 s5,s16
0000a8  eef12a48          VNEGLT.F32 s5,s16
0000ac  ee120a90          VMOV     r0,s5
0000b0  4987              LDR      r1,|L25.720|
0000b2  4288              CMP      r0,r1
0000b4  dd32              BLE      |L25.284|
;;;265            // Special case: Vertical line
;;;266            if (seg->endPt_y > seg->startPt_y) {
0000b6  eef41ae0          VCMPE.F32 s3,s1
0000ba  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;267              shortestDistanceToPath = seg->startPt_x - x;
;;;268            } else {
;;;269              shortestDistanceToPath = x - seg->startPt_x;
0000be  bfd4              ITE      LE
0000c0  ee380ac2          VSUBLE.F32 s0,s17,s4
0000c4  ee320a68          VSUBGT.F32 s0,s4,s17             ;267
0000c8  ed850a00          VSTR     s0,[r5,#0]
;;;270            }
;;;271            
;;;272            // Compute angle difference
;;;273            radDiff = (line_theta_ - angle).ToFloat();
0000cc  eeb00a6b          VMOV.F32 s0,s23
0000d0  4669              MOV      r1,sp
0000d2  a802              ADD      r0,sp,#8
0000d4  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansEf ; Anki::operator -(const Anki::Radians&, float)
0000d8  ed9d0a02          VLDR     s0,[sp,#8]
0000dc  ed860a00          VSTR     s0,[r6,#0]
;;;274            
;;;275            // If the point (x_intersect,y_intersect) is not between startPt and endPt,
;;;276            // and the robot is closer to the end point than it is to the start point,
;;;277            // then we've passed this segment and should go to next one
;;;278            if ( SIGN(seg->startPt_y - y) == SIGN(seg->endPt_y - y)) {
0000e0  ed940a01          VLDR     s0,[r4,#4]
0000e4  ee300a49          VSUB.F32 s0,s0,s18
0000e8  eeb50ac0          VCMPE.F32 s0,#0.0
0000ec  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000f0  bfac              ITE      GE
0000f2  2001              MOVGE    r0,#1
0000f4  2000              MOVLT    r0,#0
0000f6  ed940a03          VLDR     s0,[r4,#0xc]
0000fa  ee300a49          VSUB.F32 s0,s0,s18
0000fe  eeb50ac0          VCMPE.F32 s0,#0.0
000102  eef1fa10          VMRS     APSR_nzcv,FPSCR
000106  bfac              ITE      GE
000108  2101              MOVGE    r1,#1
00010a  2100              MOVLT    r1,#0
00010c  4288              CMP      r0,r1
00010e  d17a              BNE      |L25.518|
;;;279                if (sqDistToStartPt > sqDistToEndPt) {
000110  eef4aaca          VCMPE.F32 s21,s20
000114  eef1fa10          VMRS     APSR_nzcv,FPSCR
000118  dc76              BGT      |L25.520|
00011a  e0c4              B        |L25.678|
                  |L25.284|
;;;280                  return OOR_NEAR_END;
;;;281                } else {
;;;282                  return OOR_NEAR_START;
;;;283                }
;;;284            }
;;;285            
;;;286          } else if (FLT_NEAR(line_m_, 0.f)) {
00011c  ee180a10          VMOV     r0,s16
000120  496c              LDR      r1,|L25.724|
000122  4288              CMP      r0,r1
000124  d235              BCS      |L25.402|
000126  ee180a10          VMOV     r0,s16
00012a  496b              LDR      r1,|L25.728|
00012c  4288              CMP      r0,r1
00012e  da30              BGE      |L25.402|
;;;287            // Special case: Horizontal line
;;;288            if (seg->endPt_x > seg->startPt_x) {
000130  eeb42ac1          VCMPE.F32 s4,s2
000134  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;289              shortestDistanceToPath = y - seg->startPt_y;
000138  bf38              IT       CC
00013a  ee390a60          VSUBCC.F32 s0,s18,s1
00013e  ed850a00          VSTR     s0,[r5,#0]
;;;290            } else {
;;;291              shortestDistanceToPath = seg->startPt_y - y;
;;;292            }
;;;293            
;;;294            // Compute angle difference
;;;295            radDiff = (line_theta_ - angle).ToFloat();
000142  eeb00a6b          VMOV.F32 s0,s23
000146  4669              MOV      r1,sp
000148  a802              ADD      r0,sp,#8
00014a  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansEf ; Anki::operator -(const Anki::Radians&, float)
00014e  ed9d0a02          VLDR     s0,[sp,#8]
000152  ed860a00          VSTR     s0,[r6,#0]
;;;296            
;;;297            // If the point (x_intersect,y_intersect) is not between startPt and endPt,
;;;298            // and the robot is closer to the end point than it is to the start point,
;;;299            // then we've passed this segment and should go to next one
;;;300            if ( SIGN(seg->startPt_x - x) == SIGN(seg->endPt_x - x)) {
000156  ed940a00          VLDR     s0,[r4,#0]
00015a  ee300a68          VSUB.F32 s0,s0,s17
00015e  eeb50ac0          VCMPE.F32 s0,#0.0
000162  eef1fa10          VMRS     APSR_nzcv,FPSCR
000166  bfac              ITE      GE
000168  2001              MOVGE    r0,#1
00016a  2000              MOVLT    r0,#0
00016c  ed940a02          VLDR     s0,[r4,#8]
000170  ee300a68          VSUB.F32 s0,s0,s17
000174  eeb50ac0          VCMPE.F32 s0,#0.0
000178  eef1fa10          VMRS     APSR_nzcv,FPSCR
00017c  bfac              ITE      GE
00017e  2101              MOVGE    r1,#1
000180  2100              MOVLT    r1,#0
000182  4288              CMP      r0,r1
000184  d13f              BNE      |L25.518|
;;;301              if (sqDistToStartPt > sqDistToEndPt) {
000186  eef4aaca          VCMPE.F32 s21,s20
00018a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00018e  dc3b              BGT      |L25.520|
000190  e089              B        |L25.678|
                  |L25.402|
;;;302                return OOR_NEAR_END;
;;;303              } else {
;;;304                return OOR_NEAR_START;
;;;305              }
;;;306            }
;;;307            
;;;308          } else {
;;;309            
;;;310            f32 b_inv = y + x/line_m_;
000192  ee880a88          VDIV.F32 s0,s17,s16
000196  ee300a09          VADD.F32 s0,s0,s18
;;;311            
;;;312            f32 x_intersect = line_m_ * (b_inv - line_b_) / (line_m_*line_m_ + 1);
00019a  ee700a4b          VSUB.F32 s1,s0,s22
00019e  ee201a88          VMUL.F32 s2,s1,s16
0001a2  eef70a00          VMOV.F32 s1,#1.00000000
0001a6  ee480a08          VMLA.F32 s1,s16,s16
0001aa  eec19a20          VDIV.F32 s19,s2,s1
;;;313            f32 y_intersect = - (x_intersect / line_m_) + b_inv;
0001ae  eec90a88          VDIV.F32 s1,s19,s16
0001b2  ee30ba60          VSUB.F32 s22,s0,s1
;;;314            
;;;315            f32 dy = y - y_intersect;
;;;316            f32 dx = x - x_intersect;
0001b6  ee380ae9          VSUB.F32 s0,s17,s19
0001ba  ee399a4b          VSUB.F32 s18,s18,s22           ;315
;;;317            
;;;318            shortestDistanceToPath = sqrtf(dy*dy + dx*dx);
0001be  ee690a09          VMUL.F32 s1,s18,s18
0001c2  ee400a00          VMLA.F32 s1,s0,s0
0001c6  eeb10ae0          VSQRT.F32 s0,s1
0001ca  eeb40a40          VCMP.F32 s0,s0
0001ce  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001d2  bf1c              ITT      NE
0001d4  eeb00a60          VMOVNE.F32 s0,s1
0001d8  f7fffffe          BLNE     __hardfp_sqrtf
0001dc  ed850a00          VSTR     s0,[r5,#0]
;;;319            
;;;320    #if(DEBUG_PATH)
;;;321            CoreTechPrint("m: %f, b: %f\n",line_m_,line_b_);
;;;322            CoreTechPrint("x_int: %f, y_int: %f, b_inv: %f\n", x_intersect, y_intersect, b_inv);
;;;323            CoreTechPrint("dy: %f, dx: %f, dist: %f\n", dy, dx, shortestDistanceToPath);
;;;324            CoreTechPrint("SIGN(dx): %d, dy_sign: %f\n", (SIGN(dx) ? 1 : -1), line_dy_sign_);
;;;325            CoreTechPrint("lineTheta: %f\n", line_theta_.ToFloat());
;;;326            //PRINT("lineTheta: %f, robotTheta: %f\n", seg->theta.ToFloat(), currPose.GetAngle().ToFloat());
;;;327    #endif
;;;328            
;;;329            // Compute the sign of the error distance
;;;330            shortestDistanceToPath *= (SIGN(line_m_) ? 1 : -1) * (SIGN(dy) ? 1 : -1) * line_dy_sign_;
0001e0  eeb58ac0          VCMPE.F32 s16,#0.0
0001e4  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001e8  bfac              ITE      GE
0001ea  2001              MOVGE    r0,#1
0001ec  f04f30ff          MOVLT    r0,#0xffffffff
0001f0  eeb59ac0          VCMPE.F32 s18,#0.0
0001f4  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001f8  bfac              ITE      GE
0001fa  2101              MOVGE    r1,#1
0001fc  f04f31ff          MOVLT    r1,#0xffffffff
000200  fb10f001          SMULBB   r0,r0,r1
000204  e001              B        |L25.522|
                  |L25.518|
000206  e053              B        |L25.688|
                  |L25.520|
000208  e048              B        |L25.668|
                  |L25.522|
00020a  ee000a90          VMOV     s1,r0
;;;331            
;;;332            
;;;333            // Compute angle difference
;;;334            radDiff = (line_theta_ - angle).ToFloat();
00020e  4669              MOV      r1,sp
000210  a802              ADD      r0,sp,#8
000212  eef80ae0          VCVT.F32.S32 s1,s1                 ;330
000216  ee600a8c          VMUL.F32 s1,s1,s24             ;330
00021a  ee200a80          VMUL.F32 s0,s1,s0              ;330
00021e  ed850a00          VSTR     s0,[r5,#0]            ;330
000222  eeb00a6b          VMOV.F32 s0,s23
000226  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansEf ; Anki::operator -(const Anki::Radians&, float)
00022a  ed9d0a02          VLDR     s0,[sp,#8]
00022e  ed860a00          VSTR     s0,[r6,#0]
;;;335            
;;;336            
;;;337            // Did we pass the current segment?
;;;338            // If the point (x_intersect,y_intersect) is not between startPt and endPt,
;;;339            // and the robot is closer to the end point than it is to the start point,
;;;340            // then we've passed this segment and should go to next one
;;;341            if ( (SIGN(seg->startPt_x - x_intersect) == SIGN(seg->endPt_x - x_intersect))
000232  ed940a00          VLDR     s0,[r4,#0]
000236  ee300a69          VSUB.F32 s0,s0,s19
00023a  eeb50ac0          VCMPE.F32 s0,#0.0
00023e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000242  bfac              ITE      GE
000244  2001              MOVGE    r0,#1
000246  2000              MOVLT    r0,#0
000248  ed940a02          VLDR     s0,[r4,#8]
00024c  ee300a69          VSUB.F32 s0,s0,s19
000250  eeb50ac0          VCMPE.F32 s0,#0.0
000254  eef1fa10          VMRS     APSR_nzcv,FPSCR
000258  bfac              ITE      GE
00025a  2101              MOVGE    r1,#1
00025c  2100              MOVLT    r1,#0
00025e  4288              CMP      r0,r1
000260  d126              BNE      |L25.688|
;;;342                && (SIGN(seg->startPt_y - y_intersect) == SIGN(seg->endPt_y - y_intersect)) ) {
000262  ed940a01          VLDR     s0,[r4,#4]
000266  ee300a4b          VSUB.F32 s0,s0,s22
00026a  eeb50ac0          VCMPE.F32 s0,#0.0
00026e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000272  bfac              ITE      GE
000274  2001              MOVGE    r0,#1
000276  2000              MOVLT    r0,#0
000278  ed940a03          VLDR     s0,[r4,#0xc]
00027c  ee300a4b          VSUB.F32 s0,s0,s22
000280  eeb50ac0          VCMPE.F32 s0,#0.0
000284  eef1fa10          VMRS     APSR_nzcv,FPSCR
000288  bfac              ITE      GE
00028a  2101              MOVGE    r1,#1
00028c  2100              MOVLT    r1,#0
00028e  4288              CMP      r0,r1
000290  d10e              BNE      |L25.688|
;;;343              if (sqDistToStartPt > sqDistToEndPt){
000292  eef4aaca          VCMPE.F32 s21,s20
000296  eef1fa10          VMRS     APSR_nzcv,FPSCR
00029a  dd04              BLE      |L25.678|
                  |L25.668|
;;;344                return OOR_NEAR_END;
;;;345              } else {
;;;346                return OOR_NEAR_START;
;;;347              }
;;;348            }
;;;349          }
;;;350          
;;;351          return IN_SEGMENT_RANGE;
;;;352        }
00029c  b004              ADD      sp,sp,#0x10
00029e  2002              MOVS     r0,#2                 ;344
0002a0  ecbd8b0a          VPOP     {d8-d12}
0002a4  bd70              POP      {r4-r6,pc}
                  |L25.678|
0002a6  b004              ADD      sp,sp,#0x10
0002a8  2001              MOVS     r0,#1                 ;346
0002aa  ecbd8b0a          VPOP     {d8-d12}
0002ae  bd70              POP      {r4-r6,pc}
                  |L25.688|
0002b0  b004              ADD      sp,sp,#0x10
0002b2  2000              MOVS     r0,#0                 ;351
0002b4  ecbd8b0a          VPOP     {d8-d12}
0002b8  bd70              POP      {r4-r6,pc}
;;;353        
                          ENDP

0002ba  0000              DCW      0x0000
                          DCD      0x00000000
                  |L25.704|
0002c0  00000000          DCFD     0x3ff0000000000000 ; 1
0002c4  3ff00000
                  |L25.712|
0002c8  00000000          DCFD     0xbff0000000000000 ; -1
0002cc  bff00000
                  |L25.720|
                          DCD      0x461c4000
                  |L25.724|
                          DCD      0xb727c5ac
                  |L25.728|
                          DCD      0x3727c5ac

                          AREA ||i._ZNK4Anki8Planning11PathSegment25GetDistToPointTurnSegmentEfffRfS2_||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Planning11PathSegment25GetDistToPointTurnSegmentEfffRfS2_ PROC ; Anki::Planning::PathSegment::GetDistToPointTurnSegment(float, float, float, float&, float&) const
;;;494    
;;;495        SegmentRangeStatus PathSegment::GetDistToPointTurnSegment(const f32 x, const f32 y, const f32 angle,
000000  b5f0              PUSH     {r4-r7,lr}
;;;496                                                            f32 &shortestDistanceToPath, f32 &radDiff) const
;;;497        {
;;;498          const PathSegmentDef::s_turn* seg = &(def_.turn);
000002  1d04              ADDS     r4,r0,#4
000004  ed2d8b02          VPUSH    {d8}                  ;497
000008  eeb08a41          VMOV.F32 s16,s2                ;497
;;;499          
;;;500    #if(DEBUG_PATH)
;;;501          CoreTechPrint("TURN (%f, %f), targetAngle: %f, targetRotSpeed: %f\n",
;;;502                seg->x, seg->y, seg->targetAngle, GetTargetSpeed());
;;;503    #endif
;;;504          
;;;505          shortestDistanceToPath = sqrtf( (x - seg->x)*(x - seg->x) + (y - seg->y)*(y - seg->y) );
00000c  ed901a01          VLDR     s2,[r0,#4]
000010  b085              SUB      sp,sp,#0x14           ;497
000012  4617              MOV      r7,r2                 ;497
000014  ee300a41          VSUB.F32 s0,s0,s2
000018  460e              MOV      r6,r1                 ;497
00001a  4605              MOV      r5,r0                 ;497
00001c  ee601a00          VMUL.F32 s3,s0,s0
000020  ed900a02          VLDR     s0,[r0,#8]
000024  ee300ac0          VSUB.F32 s0,s1,s0
000028  ee401a00          VMLA.F32 s3,s0,s0
00002c  eeb10ae1          VSQRT.F32 s0,s3
000030  eeb40a40          VCMP.F32 s0,s0
000034  eef1fa10          VMRS     APSR_nzcv,FPSCR
000038  bf1c              ITT      NE
00003a  eeb00a61          VMOVNE.F32 s0,s3
00003e  f7fffffe          BLNE     __hardfp_sqrtf
000042  ed860a00          VSTR     s0,[r6,#0]
;;;506          Radians currAngle(angle);
000046  eeb00a48          VMOV.F32 s0,s16
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
;;;507          Radians targetAngle(seg->targetAngle);
000050  ed940a02          VLDR     s0,[r4,#8]
000054  a802              ADD      r0,sp,#8
000056  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
00005a  ed950a06          VLDR     s0,[r5,#0x18]
;;;508          radDiff = currAngle.angularDistance(targetAngle,GetTargetSpeed() < 0);
00005e  eeb50ac0          VCMPE.F32 s0,#0.0
000062  eef1fa10          VMRS     APSR_nzcv,FPSCR
000066  bf34              ITE      CC
000068  2201              MOVCC    r2,#1
00006a  2200              MOVCS    r2,#0
00006c  a902              ADD      r1,sp,#8
00006e  4668              MOV      r0,sp
000070  f7fffffe          BL       _ZN4Anki7Radians15angularDistanceERKS0_b ; Anki::Radians::angularDistance(const Anki::Radians&, bool)
000074  ed870a00          VSTR     s0,[r7,#0]
;;;509          
;;;510          return IN_SEGMENT_RANGE;
;;;511        }
000078  b005              ADD      sp,sp,#0x14
00007a  2000              MOVS     r0,#0                 ;510
00007c  ecbd8b02          VPOP     {d8}
000080  bdf0              POP      {r4-r7,pc}
;;;512        
                          ENDP


                          AREA ||i._ZNK4Anki8Planning11PathSegment5PrintEv||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Planning11PathSegment5PrintEv PROC ; Anki::Planning::PathSegment::Print() const
;;;158        
;;;159        void PathSegment::Print() const
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;160        {
000004  4605              MOV      r5,r0
;;;161          switch(type_) {
000006  7800              LDRB     r0,[r0,#0]
000008  b08e              SUB      sp,sp,#0x38           ;160
00000a  2801              CMP      r0,#1
00000c  d036              BEQ      |L27.124|
00000e  2802              CMP      r0,#2
000010  d076              BEQ      |L27.256|
000012  2803              CMP      r0,#3
;;;162            case PST_LINE:
;;;163            {
;;;164              const PathSegmentDef::s_line& seg = def_.line;
;;;165              CoreTechPrint("line: (%f, %f) to (%f, %f), speed/accel/decel = (%f, %f, %f)\n",
;;;166                     seg.startPt_x,
;;;167                     seg.startPt_y,
;;;168                     seg.endPt_x,
;;;169                     seg.endPt_y,
;;;170                     GetTargetSpeed(),
;;;171                     GetAccel(),
;;;172                     GetDecel());
;;;173              break;
;;;174            }
;;;175            case PST_ARC:
;;;176            {
;;;177              const PathSegmentDef::s_arc& seg = def_.arc;
;;;178              CoreTechPrint("arc: centerPt (%f, %f), radius %f, startAng %f, sweep %f, speed/accel/decel = (%f, %f, %f)\n",
;;;179                     seg.centerPt_x,
;;;180                     seg.centerPt_y,
;;;181                     seg.radius,
;;;182                     seg.startRad,
;;;183                     seg.sweepRad,
;;;184                     GetTargetSpeed(),
;;;185                     GetAccel(),
;;;186                     GetDecel());
;;;187              break;
;;;188            }
;;;189            case PST_POINT_TURN:
;;;190            {
;;;191              const PathSegmentDef::s_turn& seg = def_.turn;
;;;192              CoreTechPrint("ptTurn: x %f, y %f, targetAngle %f, speed/accel/decel = (%f, %f, %f)\n",
;;;193                     seg.x,
;;;194                     seg.y,
;;;195                     seg.targetAngle,
;;;196                     GetTargetSpeed(),
;;;197                     GetAccel(),
;;;198                     GetDecel());
;;;199              break;
;;;200            }
;;;201            default:
;;;202              break;
;;;203          }
;;;204    
;;;205        }
000014  bf1c              ITT      NE
000016  b00e              ADDNE    sp,sp,#0x38
000018  e8bd87f0          POPNE    {r4-r10,pc}
00001c  1d2c              ADDS     r4,r5,#4              ;191
00001e  6a28              LDR      r0,[r5,#0x20]         ;192
000020  f7fffffe          BL       __aeabi_f2d
000024  4681              MOV      r9,r0                 ;192
000026  468a              MOV      r10,r1                ;192
000028  69e8              LDR      r0,[r5,#0x1c]         ;192
00002a  f7fffffe          BL       __aeabi_f2d
00002e  4607              MOV      r7,r0                 ;192
000030  4688              MOV      r8,r1                 ;192
000032  69a8              LDR      r0,[r5,#0x18]         ;192
000034  f7fffffe          BL       __aeabi_f2d
000038  e9cd0102          STRD     r0,r1,[sp,#8]         ;192
00003c  68a0              LDR      r0,[r4,#8]            ;192
00003e  f7fffffe          BL       __aeabi_f2d
000042  4605              MOV      r5,r0                 ;192
000044  460e              MOV      r6,r1                 ;192
000046  6860              LDR      r0,[r4,#4]            ;192
000048  f7fffffe          BL       __aeabi_f2d
00004c  e9cd0100          STRD     r0,r1,[sp,#0]         ;192
000050  6820              LDR      r0,[r4,#0]            ;192
000052  f7fffffe          BL       __aeabi_f2d
000056  ec410b10          VMOV     d0,r0,r1              ;192
00005a  a806              ADD      r0,sp,#0x18           ;192
00005c  ec532b10          VMOV     r2,r3,d0              ;192
000060  e8800780          STM      r0,{r7-r10}           ;192
000064  e9dd0102          LDRD     r0,r1,[sp,#8]         ;192
000068  e9cd5602          STRD     r5,r6,[sp,#8]         ;192
00006c  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;192
000070  4845              LDR      r0,|L27.392|
000072  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
000076  b00e              ADD      sp,sp,#0x38
000078  e8bd87f0          POP      {r4-r10,pc}
                  |L27.124|
00007c  f1050a04          ADD      r10,r5,#4             ;164
000080  6a28              LDR      r0,[r5,#0x20]         ;165
000082  f7fffffe          BL       __aeabi_f2d
000086  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;165
00008a  69e8              LDR      r0,[r5,#0x1c]         ;165
00008c  f7fffffe          BL       __aeabi_f2d
000090  4680              MOV      r8,r0                 ;165
000092  4689              MOV      r9,r1                 ;165
000094  69a8              LDR      r0,[r5,#0x18]         ;165
000096  f7fffffe          BL       __aeabi_f2d
00009a  e9cd0102          STRD     r0,r1,[sp,#8]         ;165
00009e  f8da000c          LDR      r0,[r10,#0xc]         ;165
0000a2  f7fffffe          BL       __aeabi_f2d
0000a6  e9cd0100          STRD     r0,r1,[sp,#0]         ;165
0000aa  f8da0008          LDR      r0,[r10,#8]           ;165
0000ae  f7fffffe          BL       __aeabi_f2d
0000b2  4606              MOV      r6,r0                 ;165
0000b4  460f              MOV      r7,r1                 ;165
0000b6  f8da0004          LDR      r0,[r10,#4]           ;165
0000ba  f7fffffe          BL       __aeabi_f2d
0000be  4604              MOV      r4,r0                 ;165
0000c0  460d              MOV      r5,r1                 ;165
0000c2  f8da0000          LDR      r0,[r10,#0]           ;165
0000c6  f7fffffe          BL       __aeabi_f2d
0000ca  ec410b10          VMOV     d0,r0,r1              ;165
0000ce  e9dd0104          LDRD     r0,r1,[sp,#0x10]      ;165
0000d2  e9cd010a          STRD     r0,r1,[sp,#0x28]      ;165
0000d6  e9cd8908          STRD     r8,r9,[sp,#0x20]      ;165
0000da  e9dd0102          LDRD     r0,r1,[sp,#8]         ;165
0000de  e9cd0106          STRD     r0,r1,[sp,#0x18]      ;165
0000e2  e9dd0100          LDRD     r0,r1,[sp,#0]         ;165
0000e6  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;165
0000ea  e88d00f0          STM      sp,{r4-r7}            ;165
0000ee  ec532b10          VMOV     r2,r3,d0              ;165
0000f2  a026              ADR      r0,|L27.396|
0000f4  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
0000f8  b00e              ADD      sp,sp,#0x38
0000fa  e8bd87f0          POP      {r4-r10,pc}
0000fe  e7ff              B        |L27.256|
                  |L27.256|
000100  1d2c              ADDS     r4,r5,#4              ;177
000102  6a28              LDR      r0,[r5,#0x20]         ;178
000104  f7fffffe          BL       __aeabi_f2d
000108  4681              MOV      r9,r0                 ;178
00010a  468a              MOV      r10,r1                ;178
00010c  69e8              LDR      r0,[r5,#0x1c]         ;178
00010e  f7fffffe          BL       __aeabi_f2d
000112  e9cd0106          STRD     r0,r1,[sp,#0x18]      ;178
000116  69a8              LDR      r0,[r5,#0x18]         ;178
000118  f7fffffe          BL       __aeabi_f2d
00011c  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;178
000120  6920              LDR      r0,[r4,#0x10]         ;178
000122  f7fffffe          BL       __aeabi_f2d
000126  4607              MOV      r7,r0                 ;178
000128  4688              MOV      r8,r1                 ;178
00012a  68e0              LDR      r0,[r4,#0xc]          ;178
00012c  f7fffffe          BL       __aeabi_f2d
000130  e9cd0102          STRD     r0,r1,[sp,#8]         ;178
000134  68a0              LDR      r0,[r4,#8]            ;178
000136  f7fffffe          BL       __aeabi_f2d
00013a  4605              MOV      r5,r0                 ;178
00013c  460e              MOV      r6,r1                 ;178
00013e  6860              LDR      r0,[r4,#4]            ;178
000140  f7fffffe          BL       __aeabi_f2d
000144  e9cd0100          STRD     r0,r1,[sp,#0]         ;178
000148  6820              LDR      r0,[r4,#0]            ;178
00014a  f7fffffe          BL       __aeabi_f2d
00014e  e9cd9a0c          STRD     r9,r10,[sp,#0x30]     ;178
000152  ec410b10          VMOV     d0,r0,r1              ;178
000156  e9dd0106          LDRD     r0,r1,[sp,#0x18]      ;178
00015a  e9cd010a          STRD     r0,r1,[sp,#0x28]      ;178
00015e  e9dd0104          LDRD     r0,r1,[sp,#0x10]      ;178
000162  e9cd7806          STRD     r7,r8,[sp,#0x18]      ;178
000166  e9cd0108          STRD     r0,r1,[sp,#0x20]      ;178
00016a  e9dd0102          LDRD     r0,r1,[sp,#8]         ;178
00016e  e9cd5602          STRD     r5,r6,[sp,#8]         ;178
000172  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;178
000176  ec532b10          VMOV     r2,r3,d0              ;178
00017a  4814              LDR      r0,|L27.460|
00017c  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
000180  b00e              ADD      sp,sp,#0x38
000182  e8bd87f0          POP      {r4-r10,pc}
;;;206    
                          ENDP

000186  0000              DCW      0x0000
                  |L27.392|
                          DCD      ||.conststring||+0x5c
                  |L27.396|
00018c  6c696e65          DCB      "line: (%f, %f) to (%f, %f), speed/accel/decel = (%f, %f"
000190  3a202825
000194  662c2025
000198  66292074
00019c  6f202825
0001a0  662c2025
0001a4  66292c20
0001a8  73706565
0001ac  642f6163
0001b0  63656c2f
0001b4  64656365
0001b8  6c203d20
0001bc  2825662c
0001c0  202566  
0001c3  2c202566          DCB      ", %f)\n",0
0001c7  290a00  
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L27.460|
                          DCD      ||.conststring||

                          AREA ||i._ZNK4Anki8Planning11PathSegment9GetLengthEv||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Planning11PathSegment9GetLengthEv PROC ; Anki::Planning::PathSegment::GetLength() const
;;;74         
;;;75         f32 PathSegment::GetLength() const
000000  b510              PUSH     {r4,lr}
;;;76         {
;;;77           switch(type_)
000002  7801              LDRB     r1,[r0,#0]
000004  2901              CMP      r1,#1
000006  d00b              BEQ      |L28.32|
000008  2902              CMP      r1,#2
00000a  d027              BEQ      |L28.92|
00000c  2903              CMP      r1,#3
;;;78           {
;;;79             case PST_LINE:
;;;80               return sqrtf((def_.line.startPt_x - def_.line.endPt_x)*(def_.line.startPt_x - def_.line.endPt_x) + (def_.line.startPt_y - def_.line.endPt_y)*(def_.line.startPt_y - def_.line.endPt_y));
;;;81             case PST_ARC:
;;;82               return ABS(def_.arc.sweepRad) * def_.arc.radius;
;;;83             case PST_POINT_TURN:
;;;84               return 0;
00000e  bf04              ITT      EQ
000010  ed9f0a19          VLDREQ   s0,|L28.120|
;;;85             default:
;;;86               CoreTechPrint("ERROR (Path::GetLength): Undefined segment %d\n", type_);
;;;87               assert(false);
;;;88           }
;;;89           return 0;
;;;90         }
000014  bd10              POPEQ    {r4,pc}
000016  a019              ADR      r0,|L28.124|
000018  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
00001c  f7fffffe          BL       abort
                  |L28.32|
000020  ed900a01          VLDR     s0,[r0,#4]            ;80
000024  edd00a03          VLDR     s1,[r0,#0xc]          ;80
000028  ed901a04          VLDR     s2,[r0,#0x10]         ;80
00002c  ee300a60          VSUB.F32 s0,s0,s1              ;80
000030  edd00a02          VLDR     s1,[r0,#8]            ;80
000034  ee200a00          VMUL.F32 s0,s0,s0              ;80
000038  ee700ac1          VSUB.F32 s1,s1,s2              ;80
00003c  ee000aa0          VMLA.F32 s0,s1,s1              ;80
000040  eef10ac0          VSQRT.F32 s1,s0                 ;80
000044  eef40a60          VCMP.F32 s1,s1                 ;80
000048  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;80
00004c  bf04              ITT      EQ                    ;80
00004e  eeb00a60          VMOVEQ.F32 s0,s1                 ;80
000052  bd10              POPEQ    {r4,pc}
000054  e8bd4010          POP      {r4,lr}               ;80
000058  f7ffbffe          B.W      __hardfp_sqrtf
                  |L28.92|
00005c  ed900a05          VLDR     s0,[r0,#0x14]         ;82
000060  eeb50ac0          VCMPE.F32 s0,#0.0               ;82
000064  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;82
000068  bfb8              IT       LT                    ;82
00006a  eeb10a40          VNEGLT.F32 s0,s0                 ;82
00006e  edd00a03          VLDR     s1,[r0,#0xc]          ;82
000072  ee200a20          VMUL.F32 s0,s0,s1              ;82
000076  bd10              POP      {r4,pc}
;;;91         
                          ENDP

                  |L28.120|
000078  00000000          DCFS     0x00000000 ; 0
                  |L28.124|
00007c  4552524f          DCB      "ERROR (Path::GetLength): Undefined segment %d\n",0
000080  52202850
000084  6174683a
000088  3a476574
00008c  4c656e67
000090  7468293a
000094  20556e64
000098  6566696e
00009c  65642073
0000a0  65676d65
0000a4  6e742025
0000a8  640a00  
0000ab  00                DCB      0

                          AREA ||i._ZNK4Anki8Planning4Path12PrintSegmentEh||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Planning4Path12PrintSegmentEh PROC ; Anki::Planning::Path::PrintSegment(unsigned char) const
;;;588        
;;;589        void Path::PrintSegment(u8 segment) const
000000  b570              PUSH     {r4-r6,lr}
;;;590        {
000002  4604              MOV      r4,r0
;;;591          assert(capacity_ == MAX_NUM_PATH_SEGMENTS);
000004  7940              LDRB     r0,[r0,#5]
000006  460d              MOV      r5,r1                 ;590
000008  280a              CMP      r0,#0xa
00000a  d001              BEQ      |L29.16|
00000c  f7fffffe          BL       abort
                  |L29.16|
;;;592    
;;;593          if (segment < numPathSegments_) {
000010  7920              LDRB     r0,[r4,#4]
000012  42a8              CMP      r0,r5
;;;594            CoreTechPrint("Path segment %d - ", segment);
;;;595            path_[segment].Print();
;;;596          }
;;;597        }
000014  bf98              IT       LS
000016  bd70              POPLS    {r4-r6,pc}
000018  a005              ADR      r0,|L29.48|
00001a  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
00001e  eb0501c5          ADD      r1,r5,r5,LSL #3       ;595
000022  6820              LDR      r0,[r4,#0]            ;595
000024  e8bd4070          POP      {r4-r6,lr}            ;595
000028  eb000081          ADD      r0,r0,r1,LSL #2       ;595
00002c  f7ffbffe          B.W      _ZNK4Anki8Planning11PathSegment5PrintEv ; Anki::Planning::PathSegment::Print() const
;;;598          
                          ENDP

                  |L29.48|
000030  50617468          DCB      "Path segment %d - ",0
000034  20736567
000038  6d656e74
00003c  20256420
000040  2d2000  
000043  00                DCB      0

                          AREA ||i._ZNK4Anki8Planning4Path15CheckContinuityEfa||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Planning4Path15CheckContinuityEfa PROC ; Anki::Planning::Path::CheckContinuity(float, signed char) const
;;;973      
;;;974        bool Path::CheckContinuity(f32 tolerance_distance_squared, s8 pathSegmentIdx) const
000000  b570              PUSH     {r4-r6,lr}
;;;975        {
000002  4605              MOV      r5,r0
000004  ed2d8b02          VPUSH    {d8}
000008  eeb08a40          VMOV.F32 s16,s0
;;;976          assert(capacity_ == MAX_NUM_PATH_SEGMENTS);
00000c  7940              LDRB     r0,[r0,#5]
00000e  280a              CMP      r0,#0xa
000010  d001              BEQ      |L30.22|
000012  f7fffffe          BL       abort
                  |L30.22|
;;;977    
;;;978          // Check entire path?
;;;979          if (pathSegmentIdx < 0) {
000016  2900              CMP      r1,#0
000018  da1b              BGE      |L30.82|
;;;980            for (u8 i=0; i< numPathSegments_; ++i) {
00001a  7928              LDRB     r0,[r5,#4]
00001c  2400              MOVS     r4,#0
00001e  2800              CMP      r0,#0
000020  d90b              BLS      |L30.58|
                  |L30.34|
;;;981              if (!CheckSegmentContinuity(tolerance_distance_squared, i)) {
000022  b261              SXTB     r1,r4
000024  eeb00a48          VMOV.F32 s0,s16
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       _ZNK4Anki8Planning4Path22CheckSegmentContinuityEfa ; Anki::Planning::Path::CheckSegmentContinuity(float, signed char) const
00002e  b140              CBZ      r0,|L30.66|
000030  1c60              ADDS     r0,r4,#1              ;980
000032  b2c4              UXTB     r4,r0                 ;980
000034  7928              LDRB     r0,[r5,#4]            ;980
000036  42a0              CMP      r0,r4                 ;980
000038  d8f3              BHI      |L30.34|
                  |L30.58|
;;;982                CoreTechPrint("ERROR: Continuity check failed on segment %d\n", i);
;;;983                return false;
;;;984              }
;;;985            }
;;;986            return true;
;;;987          }
;;;988          
;;;989          // Just check specified segment
;;;990          return CheckSegmentContinuity(tolerance_distance_squared, pathSegmentIdx);
;;;991        }
00003a  ecbd8b02          VPOP     {d8}
00003e  2001              MOVS     r0,#1                 ;986
000040  bd70              POP      {r4-r6,pc}
                  |L30.66|
000042  4621              MOV      r1,r4                 ;982
000044  a007              ADR      r0,|L30.100|
000046  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
00004a  ecbd8b02          VPOP     {d8}
00004e  2000              MOVS     r0,#0                 ;983
000050  bd70              POP      {r4-r6,pc}
                  |L30.82|
000052  eeb00a48          VMOV.F32 s0,s16                ;990
000056  ecbd8b02          VPOP     {d8}                  ;990
00005a  4628              MOV      r0,r5                 ;990
00005c  e8bd4070          POP      {r4-r6,lr}            ;990
000060  f7ffbffe          B.W      _ZNK4Anki8Planning4Path22CheckSegmentContinuityEfa ; Anki::Planning::Path::CheckSegmentContinuity(float, signed char) const
;;;992    
                          ENDP

                  |L30.100|
000064  4552524f          DCB      "ERROR: Continuity check failed on segment %d\n",0
000068  523a2043
00006c  6f6e7469
000070  6e756974
000074  79206368
000078  65636b20
00007c  6661696c
000080  6564206f
000084  6e207365
000088  676d656e
00008c  74202564
000090  0a00    
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i._ZNK4Anki8Planning4Path22CheckSegmentContinuityEfa||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Planning4Path22CheckSegmentContinuityEfa PROC ; Anki::Planning::Path::CheckSegmentContinuity(float, signed char) const
;;;948        // at transition points.
;;;949        bool Path::CheckSegmentContinuity(f32 tolerance_distance_squared, s8 pathSegmentIdx) const
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;950        {
000004  4604              MOV      r4,r0
000006  ed2d8b04          VPUSH    {d8-d9}
00000a  b08c              SUB      sp,sp,#0x30
00000c  468a              MOV      r10,r1
;;;951          assert(capacity_ == MAX_NUM_PATH_SEGMENTS);
00000e  7940              LDRB     r0,[r0,#5]
000010  eef09a40          VMOV.F32 s19,s0                ;950
000014  280a              CMP      r0,#0xa
000016  d001              BEQ      |L31.28|
000018  f7fffffe          BL       abort
                  |L31.28|
;;;952    
;;;953          // If checking continuity on non-existent piece
;;;954          if (pathSegmentIdx >= numPathSegments_)
00001c  7920              LDRB     r0,[r4,#4]
00001e  4550              CMP      r0,r10
;;;955            return false;
000020  bfdf              ITTTT    LE
000022  2000              MOVLE    r0,#0
;;;956          
;;;957          // If checking continuity on first piece
;;;958          if (pathSegmentIdx == 0)
;;;959            return true;
;;;960        
;;;961          // Compute distance between start point of specified segment to end point of previous segment
;;;962          f32 start_x, start_y, end_x, end_y;
;;;963          path_[pathSegmentIdx].GetStartPoint(start_x, start_y);
;;;964          path_[pathSegmentIdx-1].GetEndPoint(end_x, end_y);
;;;965          if ((start_x - end_x)*(start_x - end_x) + (start_y - end_y)*(start_y - end_y) < tolerance_distance_squared) {
;;;966            return true;
;;;967          }
;;;968      
;;;969          CoreTechPrint("Continuity fail: Segment %d start point (%f, %f), Segment %d end point (%f, %f)\n",
;;;970                pathSegmentIdx, start_x, start_y, pathSegmentIdx - 1, end_x, end_y);
;;;971          return false;
;;;972        }
000024  b00c              ADDLE    sp,sp,#0x30
000026  ecbd8b04          VPOPLE   {d8-d9}
00002a  e8bd87f0          POPLE    {r4-r10,pc}
00002e  f1ba0f00          CMP      r10,#0                ;958
000032  d027              BEQ      |L31.132|
000034  6820              LDR      r0,[r4,#0]            ;963
000036  eb0a05ca          ADD      r5,r10,r10,LSL #3     ;963
00003a  eb000085          ADD      r0,r0,r5,LSL #2       ;963
00003e  aa08              ADD      r2,sp,#0x20           ;963
000040  a903              ADD      r1,sp,#0xc            ;963
000042  f7fffffe          BL       _ZNK4Anki8Planning11PathSegment13GetStartPointERfS2_ ; Anki::Planning::PathSegment::GetStartPoint(float&, float&) const
000046  f06f0123          MVN      r1,#0x23              ;964
00004a  6820              LDR      r0,[r4,#0]            ;964
00004c  eb010185          ADD      r1,r1,r5,LSL #2       ;964
000050  4408              ADD      r0,r0,r1              ;964
000052  aa0a              ADD      r2,sp,#0x28           ;964
000054  a909              ADD      r1,sp,#0x24           ;964
000056  f7fffffe          BL       _ZNK4Anki8Planning11PathSegment11GetEndPointERfS2_ ; Anki::Planning::PathSegment::GetEndPoint(float&, float&) const
00005a  ed9d8a03          VLDR     s16,[sp,#0xc]         ;965
00005e  eddd8a09          VLDR     s17,[sp,#0x24]        ;965
000062  ed9d9a08          VLDR     s18,[sp,#0x20]        ;965
000066  ee780a68          VSUB.F32 s1,s16,s17            ;965
00006a  ee601aa0          VMUL.F32 s3,s1,s1              ;965
00006e  eddd0a0a          VLDR     s1,[sp,#0x28]         ;965
000072  ee391a60          VSUB.F32 s2,s18,s1             ;965
000076  ee411a01          VMLA.F32 s3,s2,s2              ;965
00007a  eef41ae9          VCMPE.F32 s3,s19                ;965
00007e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;965
000082  d205              BCS      |L31.144|
                  |L31.132|
000084  2001              MOVS     r0,#1                 ;966
                  |L31.134|
000086  b00c              ADD      sp,sp,#0x30
000088  ecbd8b04          VPOP     {d8-d9}
00008c  e8bd87f0          POP      {r4-r10,pc}
                  |L31.144|
000090  ee100a90          VMOV     r0,s1                 ;969
000094  f7fffffe          BL       __aeabi_f2d
000098  4680              MOV      r8,r0                 ;969
00009a  4689              MOV      r9,r1                 ;969
00009c  ee180a90          VMOV     r0,s17                ;969
0000a0  f7fffffe          BL       __aeabi_f2d
0000a4  4606              MOV      r6,r0                 ;969
0000a6  460f              MOV      r7,r1                 ;969
0000a8  ee190a10          VMOV     r0,s18                ;969
0000ac  f7fffffe          BL       __aeabi_f2d
0000b0  4604              MOV      r4,r0                 ;969
0000b2  460d              MOV      r5,r1                 ;969
0000b4  ee180a10          VMOV     r0,s16                ;969
0000b8  f7fffffe          BL       __aeabi_f2d
0000bc  ec410b10          VMOV     d0,r0,r1              ;969
0000c0  9400              STR      r4,[sp,#0]            ;969
0000c2  f1aa0001          SUB      r0,r10,#1             ;969
0000c6  e9cd5001          STRD     r5,r0,[sp,#4]         ;969
0000ca  ac04              ADD      r4,sp,#0x10           ;969
0000cc  ec532b10          VMOV     r2,r3,d0              ;969
0000d0  e88403c0          STM      r4,{r6-r9}            ;969
0000d4  4651              MOV      r1,r10                ;969
0000d6  4802              LDR      r0,|L31.224|
0000d8  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
0000dc  2000              MOVS     r0,#0                 ;971
0000de  e7d2              B        |L31.134|
;;;973      
                          ENDP

                  |L31.224|
                          DCD      ||.conststring||+0xa4

                          AREA ||i._ZNK4Anki8Planning4Path9PrintPathEv||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Planning4Path9PrintPathEv PROC ; Anki::Planning::Path::PrintPath() const
;;;579        
;;;580        void Path::PrintPath() const
000000  b570              PUSH     {r4-r6,lr}
;;;581        {
000002  4604              MOV      r4,r0
;;;582          assert(capacity_ == MAX_NUM_PATH_SEGMENTS);
000004  7940              LDRB     r0,[r0,#5]
000006  280a              CMP      r0,#0xa
000008  d107              BNE      |L32.26|
;;;583    
;;;584          for(u8 i = 0; i<numPathSegments_; ++i) {
00000a  7920              LDRB     r0,[r4,#4]
00000c  2500              MOVS     r5,#0
00000e  2800              CMP      r0,#0
;;;585            PrintSegment(i);
;;;586          }
;;;587        }
000010  bf98              IT       LS
000012  bd70              POPLS    {r4-r6,pc}
                  |L32.20|
000014  7960              LDRB     r0,[r4,#5]
000016  280a              CMP      r0,#0xa
000018  d001              BEQ      |L32.30|
                  |L32.26|
00001a  f7fffffe          BL       abort
                  |L32.30|
00001e  7921              LDRB     r1,[r4,#4]            ;585
000020  4628              MOV      r0,r5                 ;585
000022  42a9              CMP      r1,r5                 ;585
000024  d90a              BLS      |L32.60|
000026  4601              MOV      r1,r0                 ;585
000028  4807              LDR      r0,|L32.72|
00002a  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
00002e  6821              LDR      r1,[r4,#0]            ;585
000030  eb0500c5          ADD      r0,r5,r5,LSL #3       ;585
000034  eb010080          ADD      r0,r1,r0,LSL #2       ;585
000038  f7fffffe          BL       _ZNK4Anki8Planning11PathSegment5PrintEv ; Anki::Planning::PathSegment::Print() const
                  |L32.60|
00003c  1c68              ADDS     r0,r5,#1              ;584
00003e  b2c5              UXTB     r5,r0                 ;584
000040  7920              LDRB     r0,[r4,#4]            ;584
000042  42a8              CMP      r0,r5                 ;584
000044  d8e6              BHI      |L32.20|
000046  bd70              POP      {r4-r6,pc}
;;;588        
                          ENDP

                  |L32.72|
                          DCD      ||i._ZNK4Anki8Planning4Path12PrintSegmentEh||+0x30

                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki8Planning11PathSegment15SetSpeedProfileEfff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning11PathSegment15SetSpeedProfileEfff||
                          DCD      0x00000001

                          AREA ||area_number.34||, LINKORDER=||i._ZN4Anki8Planning11PathSegment10DefineLineEfffffff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning11PathSegment10DefineLineEfffffff||
                          DCD      0x00000001

                          AREA ||area_number.35||, LINKORDER=||i._ZN4Anki8Planning11PathSegment9DefineArcEffffffff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.35||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning11PathSegment9DefineArcEffffffff||
                          DCD      0x00000001

                          AREA ||area_number.36||, LINKORDER=||i._ZN4Anki8Planning11PathSegment15DefinePointTurnEffffff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.36||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning11PathSegment15DefinePointTurnEffffff||
                          DCD      0x00000001

                          AREA ||area_number.37||, LINKORDER=||i._ZN4Anki8Planning11PathSegment11OffsetStartEff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.37||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning11PathSegment11OffsetStartEff||
                          DCD      0x00000001

                          AREA ||area_number.38||, LINKORDER=||i._ZNK4Anki8Planning11PathSegment9GetLengthEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.38||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Planning11PathSegment9GetLengthEv||
                          DCD      0x00000001

                          AREA ||area_number.39||, LINKORDER=||i._ZNK4Anki8Planning11PathSegment13GetStartPointERfS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Planning11PathSegment13GetStartPointERfS2_||
                          DCD      0x00000001

                          AREA ||area_number.40||, LINKORDER=||i._ZNK4Anki8Planning11PathSegment11GetEndPointERfS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.40||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Planning11PathSegment11GetEndPointERfS2_||
                          DCD      0x00000001

                          AREA ||area_number.41||, LINKORDER=||i._ZNK4Anki8Planning11PathSegment5PrintEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Planning11PathSegment5PrintEv||
                          DCD      0x00000001

                          AREA ||area_number.42||, LINKORDER=||i._ZNK4Anki8Planning11PathSegment25GetDistToPointTurnSegmentEfffRfS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Planning11PathSegment25GetDistToPointTurnSegmentEfffRfS2_||
                          DCD      0x00000001

                          AREA ||area_number.43||, LINKORDER=||i._ZNK4Anki8Planning11PathSegment19GetDistToArcSegmentEfffRfS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Planning11PathSegment19GetDistToArcSegmentEfffRfS2_||
                          DCD      0x00000001

                          AREA ||area_number.44||, LINKORDER=||i._ZNK4Anki8Planning11PathSegment20GetDistToLineSegmentEfffRfS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Planning11PathSegment20GetDistToLineSegmentEfffRfS2_||
                          DCD      0x00000001

                          AREA ||area_number.45||, LINKORDER=||i._ZNK4Anki8Planning11PathSegment16GetDistToSegmentEfffRfS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Planning11PathSegment16GetDistToSegmentEfffRfS2_||
                          DCD      0x00000001

                          AREA ||area_number.46||, LINKORDER=||i._ZN4Anki8Planning4Path5ClearEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning4Path5ClearEv||
                          DCD      0x00000001

                          AREA ||area_number.47||, LINKORDER=||i._ZN4Anki8Planning4PathC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning4PathC1Ev||
                          DCD      0x00000001

                          AREA ||area_number.48||, LINKORDER=||i._ZN4Anki8Planning4PathaSERKS1_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.48||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning4PathaSERKS1_||
                          DCD      0x00000001

                          AREA ||area_number.49||, LINKORDER=||i._ZN4Anki8Planning4PathC1ERKS1_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.49||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning4PathC1ERKS1_||
                          DCD      0x00000001

                          AREA ||area_number.50||, LINKORDER=||i._ZN4Anki8Planning4PathD1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.50||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning4PathD1Ev||
                          DCD      0x00000001

                          AREA ||area_number.51||, LINKORDER=||i._ZNK4Anki8Planning4Path12PrintSegmentEh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Planning4Path12PrintSegmentEh||
                          DCD      0x00000001

                          AREA ||area_number.52||, LINKORDER=||i._ZNK4Anki8Planning4Path9PrintPathEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.52||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Planning4Path9PrintPathEv||
                          DCD      0x00000001

                          AREA ||area_number.53||, LINKORDER=||i._ZN4Anki8Planning4Path10AppendLineEjfffffff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning4Path10AppendLineEjfffffff||
                          DCD      0x00000001

                          AREA ||area_number.54||, LINKORDER=||i._ZN4Anki8Planning4Path6AddArcEffffffff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.54||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning4Path6AddArcEffffffff||
                          DCD      0x00000001

                          AREA ||area_number.55||, LINKORDER=||i._ZN4Anki8Planning4Path9AppendArcEjffffffff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.55||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning4Path9AppendArcEjffffffff||
                          DCD      0x00000001

                          AREA ||area_number.56||, LINKORDER=||i._ZN4Anki8Planning4Path15AppendPointTurnEjffffff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.56||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning4Path15AppendPointTurnEjffffff||
                          DCD      0x00000001

                          AREA ||area_number.57||, LINKORDER=||i._ZN4Anki8Planning4Path13AppendSegmentERKNS0_11PathSegmentE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning4Path13AppendSegmentERKNS0_11PathSegmentE||
                          DCD      0x00000001

                          AREA ||area_number.58||, LINKORDER=||i._ZN4Anki8Planning4Path8PopFrontEh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning4Path8PopFrontEh||
                          DCD      0x00000001

                          AREA ||area_number.59||, LINKORDER=||i._ZN4Anki8Planning4Path7PopBackEh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.59||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning4Path7PopBackEh||
                          DCD      0x00000001

                          AREA ||area_number.60||, LINKORDER=||i._ZNK4Anki8Planning4Path22CheckSegmentContinuityEfa||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Planning4Path22CheckSegmentContinuityEfa||
                          DCD      0x00000001

                          AREA ||area_number.61||, LINKORDER=||i._ZNK4Anki8Planning4Path15CheckContinuityEfa||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.61||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Planning4Path15CheckContinuityEfa||
                          DCD      0x00000001

                          AREA ||area_number.62||, LINKORDER=||i._ZN4Anki8Planning11GetArcAngleEffffffb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.62||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning11GetArcAngleEffffffb||
                          DCD      0x00000001

                          AREA ||area_number.63||, LINKORDER=||i._ZN4Anki8Planning16GenerateCSCCurveEfffffffffffNS0_14DubinsPathTypeEPNS0_11PathSegmentERf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.63||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning16GenerateCSCCurveEfffffffffffNS0_14DubinsPathTypeEPNS0_11PathSegmentERf||
                          DCD      0x00000001

                          AREA ||area_number.64||, LINKORDER=||i._ZN4Anki8Planning18GenerateDubinsPathERNS0_4PathEffffffffffffPf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.64||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning18GenerateDubinsPathERNS0_4PathEffffffffffffPf||
                          DCD      0x00000001

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  6172633a          DCB      "arc: centerPt (%f, %f), radius %f, startAng %f, sweep %"
000004  2063656e
000008  74657250
00000c  74202825
000010  662c2025
000014  66292c20
000018  72616469
00001c  75732025
000020  662c2073
000024  74617274
000028  416e6720
00002c  25662c20
000030  73776565
000034  702025  
000037  662c2073          DCB      "f, speed/accel/decel = (%f, %f, %f)\n",0
00003b  70656564
00003f  2f616363
000043  656c2f64
000047  6563656c
00004b  203d2028
00004f  25662c20
000053  25662c20
000057  2566290a
00005b  00      
00005c  70745475          DCB      "ptTurn: x %f, y %f, targetAngle %f, speed/accel/decel ="
000060  726e3a20
000064  78202566
000068  2c207920
00006c  25662c20
000070  74617267
000074  6574416e
000078  676c6520
00007c  25662c20
000080  73706565
000084  642f6163
000088  63656c2f
00008c  64656365
000090  6c203d  
000093  20282566          DCB      " (%f, %f, %f)\n",0
000097  2c202566
00009b  2c202566
00009f  290a00  
0000a2  00                DCB      0
0000a3  00                DCB      0
0000a4  436f6e74          DCB      "Continuity fail: Segment %d start point (%f, %f), Segme"
0000a8  696e7569
0000ac  74792066
0000b0  61696c3a
0000b4  20536567
0000b8  6d656e74
0000bc  20256420
0000c0  73746172
0000c4  7420706f
0000c8  696e7420
0000cc  2825662c
0000d0  20256629
0000d4  2c205365
0000d8  676d65  
0000db  6e742025          DCB      "nt %d end point (%f, %f)\n",0
0000df  6420656e
0000e3  6420706f
0000e7  696e7420
0000eb  2825662c
0000ef  20256629
0000f3  0a00    
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
0000f8  4552524f          DCB      "ERROR: Invalid path segment type in Dubins path. Should"
0000fc  523a2049
000100  6e76616c
000104  69642070
000108  61746820
00010c  7365676d
000110  656e7420
000114  74797065
000118  20696e20
00011c  44756269
000120  6e732070
000124  6174682e
000128  2053686f
00012c  756c64  
00012f  206e6f74          DCB      " not be possible!\n",0
000133  20626520
000137  706f7373
00013b  69626c65
00013f  210a00  

                          AREA ||i._ZN4Anki8Planning11PathSegmentC1Ev||, COMGROUP=_ZN4Anki8Planning11PathSegmentC1Ev, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Planning11PathSegmentC2Ev                  ; Alternate entry point ; Anki::Planning::PathSegment::PathSegment__sub_object()
                  _ZN4Anki8Planning11PathSegmentC1Ev PROC ; Anki::Planning::PathSegment::PathSegment()
;;;86         public:
;;;87           PathSegment() : type_(PST_UNKNOWN) {};
;;;88           
000000  2100              MOVS     r1,#0
000002  7001              STRB     r1,[r0,#0]
000004  4770              BX       lr
                          ENDP


                          AREA ||area_number.201||, COMGROUP=_ZN4Anki8Planning11PathSegmentC1Ev, LINKORDER=||i._ZN4Anki8Planning11PathSegmentC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.201||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Planning11PathSegmentC1Ev||
                          DCD      0x00000001
