; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\serialize.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\serialize.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\serialize.crf ..\coretech\common\robot\src\serialize.cpp]
                          THUMB

                          AREA ||i._ZN4Anki8Embedded16SerializedBuffer11AllocateRawEi||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer11AllocateRawEi PROC ; Anki::Embedded::SerializedBuffer::AllocateRaw(int)
;;;255    
;;;256        void* SerializedBuffer::AllocateRaw(const s32 dataLength)
000000  b500              PUSH     {lr}
;;;257        {
;;;258          const s32 bytesRequired = RoundUp<s32>(dataLength, MEMORY_ALIGNMENT);
000002  2210              MOVS     r2,#0x10
000004  b083              SUB      sp,sp,#0xc            ;257
000006  2900              CMP      r1,#0                 ;257
000008  bfc8              IT       GT                    ;257
00000a  1e49              SUBGT    r1,r1,#1              ;257
00000c  fb91f1f2          SDIV     r1,r1,r2              ;257
000010  bfc8              IT       GT                    ;257
000012  1c49              ADDGT    r1,r1,#1              ;257
000014  0109              LSLS     r1,r1,#4              ;257
;;;259    
;;;260          s32 numBytesAllocated;
;;;261    
;;;262          u8 * segment = reinterpret_cast<u8*>( memoryStack.Allocate(bytesRequired, numBytesAllocated) );
000016  aa02              ADD      r2,sp,#8
000018  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEiRi ; Anki::Embedded::MemoryStack::Allocate(int, int&)
;;;263    
;;;264          AnkiConditionalErrorAndReturnValue(segment != NULL,
00001c  2800              CMP      r0,#0
;;;265            NULL, "SerializedBuffer::AllocateRaw", "Could not add data");
;;;266    
;;;267          return segment;
;;;268        } // static void* PushBack(const SerializedBuffer::DataType type, const void * header, s32 headerLength, const void * data, s32 dataLength, MemoryStack *scratch)
00001e  bf1c              ITT      NE
000020  b003              ADDNE    sp,sp,#0xc
000022  bd00              POPNE    {pc}
000024  f44f7184          MOV      r1,#0x108             ;264
000028  4805              LDR      r0,|L1.64|
00002a  e9cd0100          STRD     r0,r1,[sp,#0]         ;264
00002e  a305              ADR      r3,|L1.68|
000030  a20f              ADR      r2,|L1.112|
000032  a114              ADR      r1,|L1.132|
000034  2005              MOVS     r0,#5                 ;264
000036  f7fffffe          BL       _Anki_Log
00003a  b003              ADD      sp,sp,#0xc
00003c  2000              MOVS     r0,#0                 ;264
00003e  bd00              POP      {pc}
;;;269    
                          ENDP

                  |L1.64|
                          DCD      ||.constdata||+0x193
                  |L1.68|
000044  2e2e5c63          DCB      "..\\coretech\\common\\robot\\src\\serialize.cpp",0
000048  6f726574
00004c  6563685c
000050  636f6d6d
000054  6f6e5c72
000058  6f626f74
00005c  5c737263
000060  5c736572
000064  69616c69
000068  7a652e63
00006c  707000  
00006f  00                DCB      0
                  |L1.112|
000070  436f756c          DCB      "Could not add data",0
000074  64206e6f
000078  74206164
00007c  64206461
000080  746100  
000083  00                DCB      0
                  |L1.132|
000084  53657269          DCB      "SerializedBuffer::AllocateRaw",0
000088  616c697a
00008c  65644275
000090  66666572
000094  3a3a416c
000098  6c6f6361
00009c  74655261
0000a0  7700    
0000a2  00                DCB      0
0000a3  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded16SerializedBuffer12EncodedArray11DeserializeEbRiS3_S3_RNS0_5Flags6BufferERtRbS8_S8_S8_S8_S3_PPvS3_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer12EncodedArray11DeserializeEbRiS3_S3_RNS0_5Flags6BufferERtRbS8_S8_S8_S8_S3_PPvS3_ PROC ; Anki::Embedded::SerializedBuffer::EncodedArray::Deserialize(bool, int&, int&, int&, Anki::Embedded::Flags::Buffer&, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
;;;77     
;;;78         Result SerializedBuffer::EncodedArray::Deserialize(const bool updateBufferPointer, s32 &height, s32 &width, s32 &stride, Flags::Buffer &flags, u16 &basicType_sizeOfType, bool &basicType_isBasicType, bool &basicType_isInteger, bool &basicType_isSigned, bool &basicType_isFloat, bool &basicType_isString, s32 &basicType_numElements, void** buffer, s32 &bufferLength)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;79         {
000004  b087              SUB      sp,sp,#0x1c
000006  461f              MOV      r7,r3
000008  4690              MOV      r8,r2
00000a  e9dd2312          LDRD     r2,r3,[sp,#0x48]
00000e  4689              MOV      r9,r1
000010  4682              MOV      r10,r0
000012  e9dd1014          LDRD     r1,r0,[sp,#0x50]
000016  e9dd4518          LDRD     r4,r5,[sp,#0x60]
00001a  e9dd6c16          LDRD     r6,r12,[sp,#0x58]
;;;80           if(bufferLength < SerializedBuffer::EncodedArray::CODE_LENGTH) {
00001e  f8d5e000          LDR      lr,[r5,#0]
000022  f8ddb044          LDR      r11,[sp,#0x44]
000026  f1be0f18          CMP      lr,#0x18
;;;81             return RESULT_FAIL_OUT_OF_MEMORY;
00002a  bfbe              ITTT     LT
00002c  4818              LDRLT    r0,|L2.144|
;;;82           }
;;;83     
;;;84           if(SerializedBuffer::EncodedBasicTypeBuffer::Deserialize(false, basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString, basicType_numElements, buffer, bufferLength) != RESULT_OK)
;;;85             return RESULT_FAIL;
;;;86     
;;;87           height = reinterpret_cast<u32*>(*buffer)[2];
;;;88           width = reinterpret_cast<u32*>(*buffer)[3];
;;;89           stride = reinterpret_cast<u32*>(*buffer)[4];
;;;90           flags.set_rawFlags(reinterpret_cast<u32*>(*buffer)[5]);
;;;91     
;;;92           if(updateBufferPointer) {
;;;93             *buffer = reinterpret_cast<u8*>(*buffer) + SerializedBuffer::EncodedArray::CODE_LENGTH;
;;;94             bufferLength -= SerializedBuffer::EncodedArray::CODE_LENGTH;
;;;95           }
;;;96     
;;;97           return RESULT_OK;
;;;98         }
00002e  b007              ADDLT    sp,sp,#0x1c
000030  e8bd8ff0          POPLT    {r4-r11,pc}
000034  9602              STR      r6,[sp,#8]            ;84
000036  9505              STR      r5,[sp,#0x14]         ;84
000038  e9cd1000          STRD     r1,r0,[sp,#0]         ;84
00003c  e9cdc403          STRD     r12,r4,[sp,#0xc]      ;84
000040  4659              MOV      r1,r11                ;84
000042  2000              MOVS     r0,#0                 ;84
000044  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer22EncodedBasicTypeBuffer11DeserializeEbRtRbS4_S4_S4_S4_RiPPvS5_ ; Anki::Embedded::SerializedBuffer::EncodedBasicTypeBuffer::Deserialize(bool, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
000048  2800              CMP      r0,#0                 ;84
00004a  bf1e              ITTT     NE                    ;85
00004c  2001              MOVNE    r0,#1                 ;85
00004e  b007              ADDNE    sp,sp,#0x1c
000050  e8bd8ff0          POPNE    {r4-r11,pc}
000054  6820              LDR      r0,[r4,#0]            ;87
000056  6880              LDR      r0,[r0,#8]            ;87
000058  f8c90000          STR      r0,[r9,#0]            ;88
00005c  6820              LDR      r0,[r4,#0]            ;88
00005e  68c0              LDR      r0,[r0,#0xc]          ;88
000060  f8c80000          STR      r0,[r8,#0]            ;89
000064  6820              LDR      r0,[r4,#0]            ;89
000066  6900              LDR      r0,[r0,#0x10]         ;89
000068  6038              STR      r0,[r7,#0]            ;90
00006a  6820              LDR      r0,[r4,#0]            ;90
00006c  6941              LDR      r1,[r0,#0x14]         ;90
00006e  9810              LDR      r0,[sp,#0x40]         ;90
000070  f7fffffe          BL       _ZN4Anki8Embedded5Flags6Buffer12set_rawFlagsEj ; Anki::Embedded::Flags::Buffer::set_rawFlags(unsigned)
000074  f1ba0f00          CMP      r10,#0                ;92
000078  d005              BEQ      |L2.134|
00007a  6820              LDR      r0,[r4,#0]            ;93
00007c  3018              ADDS     r0,r0,#0x18           ;93
00007e  6020              STR      r0,[r4,#0]            ;94
000080  6828              LDR      r0,[r5,#0]            ;94
000082  3818              SUBS     r0,r0,#0x18           ;94
000084  6028              STR      r0,[r5,#0]            ;94
                  |L2.134|
000086  b007              ADD      sp,sp,#0x1c
000088  2000              MOVS     r0,#0                 ;97
00008a  e8bd8ff0          POP      {r4-r11,pc}
;;;99     
                          ENDP

00008e  0000              DCW      0x0000
                  |L2.144|
                          DCD      0x01000001

                          AREA ||i._ZN4Anki8Embedded16SerializedBuffer14PushBackStringEPKcz||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer14PushBackStringEPKcz PROC ; Anki::Embedded::SerializedBuffer::PushBackString(const char*, ...)
;;;283    
;;;284        void* SerializedBuffer::PushBackString(const char * format, ...)
000000  b570              PUSH     {r4-r6,lr}
;;;285        {
000002  b082              SUB      sp,sp,#8
000004  460c              MOV      r4,r1
;;;286          // After switching to a better board, this will work
;;;287    #if 0
;;;288          const s32 outputStringLength = 1024;
;;;289          static char outputString[outputStringLength];
;;;290    
;;;291          va_list arguments;
;;;292          va_start(arguments, format);
;;;293          snprintf(outputString, outputStringLength, format, arguments);
;;;294          va_end(arguments);
;;;295    
;;;296          s32 usedLength = outputStringLength;
;;;297          for(s32 i=0; i<outputStringLength; i++) {
;;;298            if(outputString[i] == '\0') {
;;;299              usedLength = i;
;;;300              break;
;;;301            }
;;;302          }
;;;303    
;;;304          if(usedLength == outputStringLength) {
;;;305            outputString[outputStringLength-1] = '\0';
;;;306          }
;;;307    
;;;308          return PushBack("String", DATA_TYPE_STRING, &outputString[0], usedLength);
;;;309    #else
;;;310          // Temporary hack
;;;311    
;;;312          s32 usedLength = -1;
000006  f04f36ff          MOV      r6,#0xffffffff
;;;313          for(s32 i=0; i<1024; i++) {
00000a  f04f0c00          MOV      r12,#0
                  |L3.14|
;;;314            if(format[i] == '\0') {
00000e  f814500c          LDRB     r5,[r4,r12]
000012  b1c5              CBZ      r5,|L3.70|
000014  f10c0c01          ADD      r12,r12,#1
000018  f5bc6f80          CMP      r12,#0x400            ;313
00001c  dbf7              BLT      |L3.14|
                  |L3.30|
;;;315              usedLength = i;
;;;316              break;
;;;317            }
;;;318          }
;;;319    
;;;320          if(usedLength == -1)
00001e  f1b63fff          CMP      r6,#0xffffffff
;;;321            return NULL;
000022  bf02              ITTT     EQ
000024  2000              MOVEQ    r0,#0
;;;322    
;;;323          void* segment = Allocate("String", "String", usedLength);
;;;324    
;;;325          AnkiConditionalErrorAndReturnValue(segment != NULL,
;;;326            NULL, "SerializedBuffer::PushBackString", "Could not add data");
;;;327    
;;;328          memcpy(segment, format, usedLength);
;;;329    
;;;330          return segment;
;;;331    #endif
;;;332        }
000026  b002              ADDEQ    sp,sp,#8
000028  bd70              POPEQ    {r4-r6,pc}
00002a  4633              MOV      r3,r6                 ;323
00002c  a20e              ADR      r2,|L3.104|
00002e  a10e              ADR      r1,|L3.104|
000030  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer8AllocateEPKcS3_i ; Anki::Embedded::SerializedBuffer::Allocate(const char*, const char*, int)
000034  0005              MOVS     r5,r0                 ;323
000036  d008              BEQ      |L3.74|
000038  4632              MOV      r2,r6                 ;328
00003a  4621              MOV      r1,r4                 ;328
00003c  f7fffffe          BL       __aeabi_memcpy
000040  b002              ADD      sp,sp,#8
000042  4628              MOV      r0,r5                 ;330
000044  bd70              POP      {r4-r6,pc}
                  |L3.70|
000046  4666              MOV      r6,r12                ;315
000048  e7e9              B        |L3.30|
                  |L3.74|
00004a  f2401145          MOV      r1,#0x145             ;325
00004e  4808              LDR      r0,|L3.112|
000050  e9cd0100          STRD     r0,r1,[sp,#0]         ;325
000054  a307              ADR      r3,|L3.116|
000056  a212              ADR      r2,|L3.160|
000058  a116              ADR      r1,|L3.180|
00005a  2005              MOVS     r0,#5                 ;325
00005c  f7fffffe          BL       _Anki_Log
000060  b002              ADD      sp,sp,#8
000062  2000              MOVS     r0,#0                 ;325
000064  bd70              POP      {r4-r6,pc}
;;;333    
                          ENDP

000066  0000              DCW      0x0000
                  |L3.104|
000068  53747269          DCB      "String",0
00006c  6e6700  
00006f  00                DCB      0
                  |L3.112|
                          DCD      ||.constdata||+0x149
                  |L3.116|
000074  2e2e5c63          DCB      "..\\coretech\\common\\robot\\src\\serialize.cpp",0
000078  6f726574
00007c  6563685c
000080  636f6d6d
000084  6f6e5c72
000088  6f626f74
00008c  5c737263
000090  5c736572
000094  69616c69
000098  7a652e63
00009c  707000  
00009f  00                DCB      0
                  |L3.160|
0000a0  436f756c          DCB      "Could not add data",0
0000a4  64206e6f
0000a8  74206164
0000ac  64206461
0000b0  746100  
0000b3  00                DCB      0
                  |L3.180|
0000b4  53657269          DCB      "SerializedBuffer::PushBackString",0
0000b8  616c697a
0000bc  65644275
0000c0  66666572
0000c4  3a3a5075
0000c8  73684261
0000cc  636b5374
0000d0  72696e67
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded16SerializedBuffer15get_memoryStackEv||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded16SerializedBuffer15get_memoryStackEv PROC ; Anki::Embedded::SerializedBuffer::get_memoryStack()
;;;343    
;;;344        MemoryStack& SerializedBuffer::get_memoryStack()
000000  4770              BX       lr
;;;345        {
;;;346          return memoryStack;
;;;347        }
;;;348    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded16SerializedBuffer17EncodedArraySlice11DeserializeEbRiS3_S3_RNS0_5Flags6BufferES3_S3_S3_S3_S3_S3_RtRbS8_S8_S8_S8_S3_PPvS3_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer17EncodedArraySlice11DeserializeEbRiS3_S3_RNS0_5Flags6BufferES3_S3_S3_S3_S3_S3_RtRbS8_S8_S8_S8_S3_PPvS3_ PROC ; Anki::Embedded::SerializedBuffer::EncodedArraySlice::Deserialize(bool, int&, int&, int&, Anki::Embedded::Flags::Buffer&, int&, int&, int&, int&, int&, int&, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
;;;99     
;;;100        Result SerializedBuffer::EncodedArraySlice::Deserialize(const bool updateBufferPointer, s32 &height, s32 &width, s32 &stride, Flags::Buffer &flags, s32 &ySlice_start, s32 &ySlice_increment, s32 &ySlice_size, s32 &xSlice_start, s32 &xSlice_increment, s32 &xSlice_size, u16 &basicType_sizeOfType, bool &basicType_isBasicType, bool &basicType_isInteger, bool &basicType_isSigned, bool &basicType_isFloat, bool &basicType_isString, s32 &basicType_numElements, void** buffer, s32 &bufferLength)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;101        {
000004  b08b              SUB      sp,sp,#0x2c
000006  e9ddc222          LDRD     r12,r2,[sp,#0x88]
00000a  e9dd4526          LDRD     r4,r5,[sp,#0x98]
00000e  e9dd1024          LDRD     r1,r0,[sp,#0x90]
000012  e9dd761d          LDRD     r7,r6,[sp,#0x74]
000016  e9dd9820          LDRD     r9,r8,[sp,#0x80]
;;;102          if(bufferLength < SerializedBuffer::EncodedArraySlice::CODE_LENGTH) {
00001a  f8d5e000          LDR      lr,[r5,#0]
00001e  f8ddb060          LDR      r11,[sp,#0x60]
000022  f8dda07c          LDR      r10,[sp,#0x7c]
000026  f1be0f30          CMP      lr,#0x30
;;;103            return RESULT_FAIL_OUT_OF_MEMORY;
00002a  bfbe              ITTT     LT
00002c  481d              LDRLT    r0,|L5.164|
;;;104          }
;;;105    
;;;106          if(SerializedBuffer::EncodedArray::Deserialize(false, height, width, stride, flags, basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString, basicType_numElements, buffer, bufferLength) != RESULT_OK)
;;;107            return RESULT_FAIL;
;;;108    
;;;109          ySlice_start = reinterpret_cast<u32*>(*buffer)[6];
;;;110          ySlice_increment = reinterpret_cast<u32*>(*buffer)[7];
;;;111          ySlice_size = reinterpret_cast<u32*>(*buffer)[8];
;;;112          xSlice_start = reinterpret_cast<u32*>(*buffer)[9];
;;;113          xSlice_increment = reinterpret_cast<u32*>(*buffer)[10];
;;;114          xSlice_size = reinterpret_cast<u32*>(*buffer)[11];
;;;115    
;;;116          if(updateBufferPointer) {
;;;117            *buffer = reinterpret_cast<u8*>(*buffer) + SerializedBuffer::EncodedArraySlice::CODE_LENGTH;
;;;118            bufferLength -= SerializedBuffer::EncodedArraySlice::CODE_LENGTH;
;;;119          }
;;;120    
;;;121          return RESULT_OK;
;;;122        }
00002e  b00f              ADDLT    sp,sp,#0x3c
000030  e8bd8ff0          POPLT    {r4-r11,pc}
000034  e9cd1006          STRD     r1,r0,[sp,#0x18]
000038  e9cdc204          STRD     r12,r2,[sp,#0x10]
00003c  e9cd4508          STRD     r4,r5,[sp,#0x20]
000040  e9cd9802          STRD     r9,r8,[sp,#8]
000044  e9cdba00          STRD     r11,r10,[sp,#0]
000048  e9dd120c          LDRD     r1,r2,[sp,#0x30]      ;106
00004c  2000              MOVS     r0,#0                 ;106
00004e  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer12EncodedArray11DeserializeEbRiS3_S3_RNS0_5Flags6BufferERtRbS8_S8_S8_S8_S3_PPvS3_ ; Anki::Embedded::SerializedBuffer::EncodedArray::Deserialize(bool, int&, int&, int&, Anki::Embedded::Flags::Buffer&, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
000052  2800              CMP      r0,#0                 ;106
000054  bf1e              ITTT     NE                    ;107
000056  2001              MOVNE    r0,#1                 ;107
000058  b00f              ADDNE    sp,sp,#0x3c
00005a  e8bd8ff0          POPNE    {r4-r11,pc}
00005e  6820              LDR      r0,[r4,#0]            ;109
000060  6981              LDR      r1,[r0,#0x18]         ;109
000062  9819              LDR      r0,[sp,#0x64]         ;109
000064  6001              STR      r1,[r0,#0]            ;110
000066  6820              LDR      r0,[r4,#0]            ;110
000068  69c1              LDR      r1,[r0,#0x1c]         ;110
00006a  981a              LDR      r0,[sp,#0x68]         ;110
00006c  6001              STR      r1,[r0,#0]            ;111
00006e  6820              LDR      r0,[r4,#0]            ;111
000070  6a01              LDR      r1,[r0,#0x20]         ;111
000072  981b              LDR      r0,[sp,#0x6c]         ;111
000074  6001              STR      r1,[r0,#0]            ;112
000076  6820              LDR      r0,[r4,#0]            ;112
000078  6a41              LDR      r1,[r0,#0x24]         ;112
00007a  981c              LDR      r0,[sp,#0x70]         ;112
00007c  6001              STR      r1,[r0,#0]            ;113
00007e  6820              LDR      r0,[r4,#0]            ;113
000080  6a80              LDR      r0,[r0,#0x28]         ;113
000082  6038              STR      r0,[r7,#0]            ;114
000084  6820              LDR      r0,[r4,#0]            ;114
000086  6ac0              LDR      r0,[r0,#0x2c]         ;114
000088  6030              STR      r0,[r6,#0]            ;116
00008a  980b              LDR      r0,[sp,#0x2c]         ;116
00008c  b128              CBZ      r0,|L5.154|
00008e  6820              LDR      r0,[r4,#0]            ;117
000090  3030              ADDS     r0,r0,#0x30           ;117
000092  6020              STR      r0,[r4,#0]            ;118
000094  6828              LDR      r0,[r5,#0]            ;118
000096  3830              SUBS     r0,r0,#0x30           ;118
000098  6028              STR      r0,[r5,#0]            ;118
                  |L5.154|
00009a  b00f              ADD      sp,sp,#0x3c
00009c  2000              MOVS     r0,#0                 ;121
00009e  e8bd8ff0          POP      {r4-r11,pc}
;;;123    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L5.164|
                          DCD      0x01000001

                          AREA ||i._ZN4Anki8Embedded16SerializedBuffer20FindSerializedBufferEPKviRiS4_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer20FindSerializedBufferEPKviRiS4_ PROC ; Anki::Embedded::SerializedBuffer::FindSerializedBuffer(const void*, int, int&, int&)
;;;123    
;;;124        Result SerializedBuffer::FindSerializedBuffer(const void * rawBuffer, const s32 rawBufferLength, s32 &startIndex, s32 &endIndex)
000000  b5f0              PUSH     {r4-r7,lr}
;;;125        {
000002  b083              SUB      sp,sp,#0xc
;;;126          startIndex = -1;
000004  f04f3cff          MOV      r12,#0xffffffff
;;;127          endIndex = -1;
000008  f8c2c000          STR      r12,[r2,#0]
;;;128    
;;;129          AnkiConditionalErrorAndReturnValue(rawBuffer != NULL,
00000c  f8c3c000          STR      r12,[r3,#0]
000010  f8dfc0b8          LDR      r12,|L6.204|
000014  2800              CMP      r0,#0
000016  d010              BEQ      |L6.58|
;;;130            RESULT_FAIL_UNINITIALIZED_MEMORY, "SerializedBuffer::FindSerializedBuffer", "rawBuffer is NULL");
;;;131    
;;;132          AnkiConditionalErrorAndReturnValue(rawBufferLength >= 0,
000018  2900              CMP      r1,#0
00001a  da1a              BGE      |L6.82|
00001c  f04f0084          MOV      r0,#0x84
000020  e9cdc000          STRD     r12,r0,[sp,#0]
000024  a32a              ADR      r3,|L6.208|
000026  a235              ADR      r2,|L6.252|
000028  a13a              ADR      r1,|L6.276|
00002a  f04f0005          MOV      r0,#5
00002e  f7fffffe          BL       _Anki_Log
;;;133            RESULT_FAIL_INVALID_PARAMETER, "SerializedBuffer::FindSerializedBuffer", "rawBufferLength is >= 0");
;;;134    
;;;135          if(rawBufferLength == 0)
;;;136            return RESULT_OK;
;;;137    
;;;138          s32 state = 0;
;;;139          s32 index = 0;
;;;140    
;;;141          // Look for the header
;;;142          while(index < rawBufferLength) {
;;;143            if(state == SERIALIZED_BUFFER_HEADER_LENGTH) {
;;;144              startIndex = index;
;;;145              break;
;;;146            }
;;;147    
;;;148            if(reinterpret_cast<const u8*>(rawBuffer)[index] == SERIALIZED_BUFFER_HEADER[state]) {
;;;149              state++;
;;;150            } else if(reinterpret_cast<const u8*>(rawBuffer)[index] == SERIALIZED_BUFFER_HEADER[0]) {
;;;151              state = 1;
;;;152            } else {
;;;153              state = 0;
;;;154            }
;;;155    
;;;156            index++;
;;;157          } // while(index < rawBufferLength)
;;;158    
;;;159          // Look for the footer
;;;160          state = 0;
;;;161          while(index < rawBufferLength) {
;;;162            if(state == SERIALIZED_BUFFER_FOOTER_LENGTH) {
;;;163              endIndex = index-SERIALIZED_BUFFER_FOOTER_LENGTH-1;
;;;164              break;
;;;165            }
;;;166    
;;;167            //CoreTechPrint("%d) %d %x %x\n", index, state, rawBufferU8[index], SERIALIZED_BUFFER_FOOTER[state]);
;;;168    
;;;169            if(reinterpret_cast<const u8*>(rawBuffer)[index] == SERIALIZED_BUFFER_FOOTER[state]) {
;;;170              state++;
;;;171            } else if(reinterpret_cast<const u8*>(rawBuffer)[index] == SERIALIZED_BUFFER_FOOTER[0]) {
;;;172              state = 1;
;;;173            } else {
;;;174              state = 0;
;;;175            }
;;;176    
;;;177            index++;
;;;178          } // while(index < rawBufferLength)
;;;179    
;;;180          if(state == SERIALIZED_BUFFER_FOOTER_LENGTH) {
;;;181            endIndex = index-SERIALIZED_BUFFER_FOOTER_LENGTH-1;
;;;182          }
;;;183    
;;;184          return RESULT_OK;
;;;185        } // void FindSerializedBuffer(const void * rawBuffer, s32 &startIndex, s32 &endIndex)
000032  b003              ADD      sp,sp,#0xc
000034  f04f7040          MOV      r0,#0x3000000         ;132
000038  bdf0              POP      {r4-r7,pc}
                  |L6.58|
00003a  2081              MOVS     r0,#0x81              ;129
00003c  e9cdc000          STRD     r12,r0,[sp,#0]        ;129
000040  a323              ADR      r3,|L6.208|
000042  a23e              ADR      r2,|L6.316|
000044  a133              ADR      r1,|L6.276|
000046  2005              MOVS     r0,#5                 ;129
000048  f7fffffe          BL       _Anki_Log
00004c  b003              ADD      sp,sp,#0xc
00004e  4840              LDR      r0,|L6.336|
000050  bdf0              POP      {r4-r7,pc}
                  |L6.82|
000052  d037              BEQ      |L6.196|
000054  f04f0400          MOV      r4,#0                 ;138
000058  46a4              MOV      r12,r4                ;139
00005a  4e3e              LDR      r6,|L6.340|
00005c  e001              B        |L6.98|
                  |L6.94|
00005e  2c08              CMP      r4,#8                 ;143
000060  d028              BEQ      |L6.180|
                  |L6.98|
000062  f810500c          LDRB     r5,[r0,r12]           ;148
000066  5d37              LDRB     r7,[r6,r4]            ;148
000068  42bd              CMP      r5,r7                 ;148
00006a  bf08              IT       EQ                    ;148
00006c  1c64              ADDEQ    r4,r4,#1              ;148
00006e  d003              BEQ      |L6.120|
000070  2dff              CMP      r5,#0xff              ;150
000072  bf0c              ITE      EQ                    ;151
000074  2401              MOVEQ    r4,#1                 ;151
000076  2400              MOVNE    r4,#0                 ;153
                  |L6.120|
000078  f10c0c01          ADD      r12,r12,#1            ;153
00007c  458c              CMP      r12,r1                ;142
00007e  dbee              BLT      |L6.94|
                  |L6.128|
000080  2200              MOVS     r2,#0                 ;160
000082  458c              CMP      r12,r1                ;161
000084  bfb8              IT       LT                    ;169
000086  4d34              LDRLT    r5,|L6.344|
000088  da1c              BGE      |L6.196|
                  |L6.138|
00008a  f810400c          LDRB     r4,[r0,r12]           ;169
00008e  5cae              LDRB     r6,[r5,r2]            ;169
000090  42b4              CMP      r4,r6                 ;169
000092  bf08              IT       EQ                    ;169
000094  1c52              ADDEQ    r2,r2,#1              ;169
000096  d003              BEQ      |L6.160|
000098  2cfe              CMP      r4,#0xfe              ;171
00009a  bf0c              ITE      EQ                    ;172
00009c  2201              MOVEQ    r2,#1                 ;172
00009e  2200              MOVNE    r2,#0                 ;174
                  |L6.160|
0000a0  f10c0c01          ADD      r12,r12,#1            ;174
0000a4  458c              CMP      r12,r1                ;161
0000a6  da08              BGE      |L6.186|
0000a8  2a08              CMP      r2,#8                 ;162
0000aa  d1ee              BNE      |L6.138|
0000ac  f1ac0009          SUB      r0,r12,#9             ;163
0000b0  6018              STR      r0,[r3,#0]            ;164
0000b2  e004              B        |L6.190|
                  |L6.180|
0000b4  f8c2c000          STR      r12,[r2,#0]           ;145
0000b8  e7e2              B        |L6.128|
                  |L6.186|
0000ba  2a08              CMP      r2,#8                 ;180
0000bc  d102              BNE      |L6.196|
                  |L6.190|
0000be  f1ac0009          SUB      r0,r12,#9             ;181
0000c2  6018              STR      r0,[r3,#0]            ;181
                  |L6.196|
0000c4  b003              ADD      sp,sp,#0xc
0000c6  2000              MOVS     r0,#0                 ;184
0000c8  bdf0              POP      {r4-r7,pc}
;;;186    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L6.204|
                          DCD      ||.constdata||+0x10
                  |L6.208|
0000d0  2e2e5c63          DCB      "..\\coretech\\common\\robot\\src\\serialize.cpp",0
0000d4  6f726574
0000d8  6563685c
0000dc  636f6d6d
0000e0  6f6e5c72
0000e4  6f626f74
0000e8  5c737263
0000ec  5c736572
0000f0  69616c69
0000f4  7a652e63
0000f8  707000  
0000fb  00                DCB      0
                  |L6.252|
0000fc  72617742          DCB      "rawBufferLength is >= 0",0
000100  75666665
000104  724c656e
000108  67746820
00010c  6973203e
000110  3d203000
                  |L6.276|
000114  53657269          DCB      "SerializedBuffer::FindSerializedBuffer",0
000118  616c697a
00011c  65644275
000120  66666572
000124  3a3a4669
000128  6e645365
00012c  7269616c
000130  697a6564
000134  42756666
000138  657200  
00013b  00                DCB      0
                  |L6.316|
00013c  72617742          DCB      "rawBuffer is NULL",0
000140  75666665
000144  72206973
000148  204e554c
00014c  4c00    
00014e  00                DCB      0
00014f  00                DCB      0
                  |L6.336|
                          DCD      0x01000002
                  |L6.340|
                          DCD      ||.constdata||
                  |L6.344|
                          DCD      ||.constdata||+0x8

                          AREA ||i._ZN4Anki8Embedded16SerializedBuffer22EncodedBasicTypeBuffer11DeserializeEbRtRbS4_S4_S4_S4_RiPPvS5_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer22EncodedBasicTypeBuffer11DeserializeEbRtRbS4_S4_S4_S4_RiPPvS5_ PROC ; Anki::Embedded::SerializedBuffer::EncodedBasicTypeBuffer::Deserialize(bool, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
;;;34     
;;;35         Result SerializedBuffer::EncodedBasicTypeBuffer::Deserialize(const bool updateBufferPointer, u16 &sizeOfType, bool &isBasicType, bool &isInteger, bool &isSigned, bool &isFloat, bool &isString, s32 &numElements, void** buffer, s32 &bufferLength)
000000  e92d0ff0          PUSH     {r4-r11}
;;;36         {
000004  e9ddc40c          LDRD     r12,r4,[sp,#0x30]
000008  e9dd6509          LDRD     r6,r5,[sp,#0x24]
;;;37           if(bufferLength < SerializedBuffer::EncodedBasicTypeBuffer::CODE_LENGTH) {
00000c  f8d48000          LDR      r8,[r4,#0]
000010  f8dda02c          LDR      r10,[sp,#0x2c]
000014  9f08              LDR      r7,[sp,#0x20]
000016  f1b80f08          CMP      r8,#8
;;;38             return RESULT_FAIL_OUT_OF_MEMORY;
00001a  bfbe              ITTT     LT
00001c  4828              LDRLT    r0,|L7.192|
;;;39           }
;;;40     
;;;41           if(reinterpret_cast<u32*>(*buffer)[0] & 1)
;;;42             isBasicType = true;
;;;43           else
;;;44             isBasicType = false;
;;;45     
;;;46           if(reinterpret_cast<u32*>(*buffer)[0] & (1<<1))
;;;47             isInteger = true;
;;;48           else
;;;49             isInteger = false;
;;;50     
;;;51           if(reinterpret_cast<u32*>(*buffer)[0] & (1<<2))
;;;52             isSigned = true;
;;;53           else
;;;54             isSigned = false;
;;;55     
;;;56           if(reinterpret_cast<u32*>(*buffer)[0] & (1<<3))
;;;57             isFloat = true;
;;;58           else
;;;59             isFloat = false;
;;;60     
;;;61           if(reinterpret_cast<u32*>(*buffer)[0] & (1<<4))
;;;62             isString = true;
;;;63           else
;;;64             isString = false;
;;;65     
;;;66           sizeOfType = (reinterpret_cast<u32*>(*buffer)[0] & 0xFFFF0000) >> 16;
;;;67     
;;;68           numElements = static_cast<s32>(reinterpret_cast<u32*>(*buffer)[1]);
;;;69     
;;;70           if(updateBufferPointer) {
;;;71             *buffer = reinterpret_cast<u8*>(*buffer) + SerializedBuffer::EncodedBasicTypeBuffer::CODE_LENGTH;
;;;72             bufferLength -= SerializedBuffer::EncodedBasicTypeBuffer::CODE_LENGTH;
;;;73           }
;;;74     
;;;75           return RESULT_OK;
;;;76         }
00001e  e8bd0ff0          POPLT    {r4-r11}
000022  4770              BXLT     lr
000024  f8dc8000          LDR      r8,[r12,#0]           ;41
000028  f04f0900          MOV      r9,#0                 ;42
00002c  f8988000          LDRB     r8,[r8,#0]            ;41
000030  f0180f01          TST      r8,#1                 ;41
000034  f04f0801          MOV      r8,#1                 ;42
000038  bf14              ITE      NE                    ;42
00003a  f8828000          STRBNE   r8,[r2,#0]            ;42
00003e  f8829000          STRBEQ   r9,[r2,#0]            ;44
000042  f8dc2000          LDR      r2,[r12,#0]           ;46
000046  7812              LDRB     r2,[r2,#0]            ;46
000048  f0120f02          TST      r2,#2                 ;46
00004c  bf14              ITE      NE                    ;47
00004e  f8838000          STRBNE   r8,[r3,#0]            ;47
000052  f8839000          STRBEQ   r9,[r3,#0]            ;49
000056  f8dc2000          LDR      r2,[r12,#0]           ;51
00005a  7812              LDRB     r2,[r2,#0]            ;51
00005c  f0120f04          TST      r2,#4                 ;51
000060  bf14              ITE      NE                    ;52
000062  f8878000          STRBNE   r8,[r7,#0]            ;52
000066  f8879000          STRBEQ   r9,[r7,#0]            ;54
00006a  f8dc2000          LDR      r2,[r12,#0]           ;56
00006e  7812              LDRB     r2,[r2,#0]            ;56
000070  f0120f08          TST      r2,#8                 ;56
000074  bf14              ITE      NE                    ;57
000076  f8868000          STRBNE   r8,[r6,#0]            ;57
00007a  f8869000          STRBEQ   r9,[r6,#0]            ;59
00007e  f8dc2000          LDR      r2,[r12,#0]           ;61
000082  7812              LDRB     r2,[r2,#0]            ;61
000084  f0120f10          TST      r2,#0x10              ;61
000088  bf14              ITE      NE                    ;62
00008a  f8858000          STRBNE   r8,[r5,#0]            ;62
00008e  f8859000          STRBEQ   r9,[r5,#0]            ;64
000092  f8dc2000          LDR      r2,[r12,#0]           ;66
000096  6812              LDR      r2,[r2,#0]            ;66
000098  0c12              LSRS     r2,r2,#16             ;66
00009a  800a              STRH     r2,[r1,#0]            ;66
00009c  f8dc1000          LDR      r1,[r12,#0]           ;68
0000a0  6849              LDR      r1,[r1,#4]            ;68
0000a2  f8ca1000          STR      r1,[r10,#0]           ;41
0000a6  b138              CBZ      r0,|L7.184|
0000a8  f8dc0000          LDR      r0,[r12,#0]           ;71
0000ac  3008              ADDS     r0,r0,#8              ;71
0000ae  f8cc0000          STR      r0,[r12,#0]           ;72
0000b2  6820              LDR      r0,[r4,#0]            ;72
0000b4  3808              SUBS     r0,r0,#8              ;72
0000b6  6020              STR      r0,[r4,#0]            ;72
                  |L7.184|
0000b8  e8bd0ff0          POP      {r4-r11}
0000bc  2000              MOVS     r0,#0                 ;75
0000be  4770              BX       lr
;;;77     
                          ENDP

                  |L7.192|
                          DCD      0x01000001

                          AREA ||i._ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi PROC ; Anki::Embedded::SerializedBuffer::SerializeDescriptionStrings(const char*, const char*, void**, int&)
;;;239    
;;;240        Result SerializedBuffer::SerializeDescriptionStrings(const char *typeName, const char *objectName, void ** buffer, s32 &bufferLength)
000000  b470              PUSH     {r4-r6}
000002  f8d3c000          LDR      r12,[r3,#0]
000006  2500              MOVS     r5,#0
000008  f1bc0f20          CMP      r12,#0x20
00000c  bfb8              IT       LT
00000e  4660              MOVLT    r0,r12
;;;241        {
000010  db16              BLT      |L8.64|
000012  f04f0c00          MOV      r12,#0
000016  b150              CBZ      r0,|L8.46|
                  |L8.24|
000018  f810400c          LDRB     r4,[r0,r12]
00001c  b13c              CBZ      r4,|L8.46|
00001e  6816              LDR      r6,[r2,#0]
000020  f806400c          STRB     r4,[r6,r12]
000024  f10c0c01          ADD      r12,r12,#1
000028  f1bc0f1f          CMP      r12,#0x1f
00002c  dbf4              BLT      |L8.24|
                  |L8.46|
00002e  6810              LDR      r0,[r2,#0]
000030  f800500c          STRB     r5,[r0,r12]
000034  6810              LDR      r0,[r2,#0]
000036  3020              ADDS     r0,r0,#0x20
000038  6010              STR      r0,[r2,#0]
00003a  6818              LDR      r0,[r3,#0]
00003c  3820              SUBS     r0,r0,#0x20
00003e  6018              STR      r0,[r3,#0]
                  |L8.64|
000040  2820              CMP      r0,#0x20
000042  db14              BLT      |L8.110|
000044  2000              MOVS     r0,#0
000046  b151              CBZ      r1,|L8.94|
                  |L8.72|
000048  f811c000          LDRB     r12,[r1,r0]
00004c  f1bc0f00          CMP      r12,#0
000050  d005              BEQ      |L8.94|
000052  6814              LDR      r4,[r2,#0]
000054  f804c000          STRB     r12,[r4,r0]
000058  1c40              ADDS     r0,r0,#1
00005a  281f              CMP      r0,#0x1f
00005c  dbf4              BLT      |L8.72|
                  |L8.94|
00005e  6811              LDR      r1,[r2,#0]
000060  540d              STRB     r5,[r1,r0]
000062  6810              LDR      r0,[r2,#0]
000064  3020              ADDS     r0,r0,#0x20
000066  6010              STR      r0,[r2,#0]
000068  6818              LDR      r0,[r3,#0]
00006a  3820              SUBS     r0,r0,#0x20
00006c  6018              STR      r0,[r3,#0]
                  |L8.110|
;;;242          SerializeOneDescriptionString(typeName, buffer, bufferLength);
;;;243          SerializeOneDescriptionString(objectName, buffer, bufferLength);
;;;244    
;;;245          return RESULT_OK;
;;;246        }
00006e  bc70              POP      {r4-r6}
000070  2000              MOVS     r0,#0                 ;245
000072  4770              BX       lr
;;;247    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi PROC ; Anki::Embedded::SerializedBuffer::DeserializeDescriptionStrings(char*, char*, void**, int&)
;;;247    
;;;248        Result SerializedBuffer::DeserializeDescriptionStrings(char *typeName, char *objectName, void ** buffer, s32 &bufferLength)
000000  b430              PUSH     {r4,r5}
000002  f8d3c000          LDR      r12,[r3,#0]
000006  2500              MOVS     r5,#0
000008  f1bc0f20          CMP      r12,#0x20
00000c  bfb8              IT       LT
00000e  4660              MOVLT    r0,r12
;;;249        {
000010  db17              BLT      |L9.66|
000012  2800              CMP      r0,#0
000014  bf18              IT       NE
000016  f04f0c00          MOVNE    r12,#0
00001a  d00c              BEQ      |L9.54|
                  |L9.28|
00001c  6814              LDR      r4,[r2,#0]
00001e  f814400c          LDRB     r4,[r4,r12]
000022  b134              CBZ      r4,|L9.50|
000024  f800400c          STRB     r4,[r0,r12]
000028  f10c0c01          ADD      r12,r12,#1
00002c  f1bc0f1f          CMP      r12,#0x1f
000030  dbf4              BLT      |L9.28|
                  |L9.50|
000032  f800500c          STRB     r5,[r0,r12]
                  |L9.54|
000036  6810              LDR      r0,[r2,#0]
000038  3020              ADDS     r0,r0,#0x20
00003a  6010              STR      r0,[r2,#0]
00003c  6818              LDR      r0,[r3,#0]
00003e  3820              SUBS     r0,r0,#0x20
000040  6018              STR      r0,[r3,#0]
                  |L9.66|
000042  2820              CMP      r0,#0x20
000044  db16              BLT      |L9.116|
000046  2900              CMP      r1,#0
000048  bf18              IT       NE
00004a  2000              MOVNE    r0,#0
00004c  d00c              BEQ      |L9.104|
                  |L9.78|
00004e  f8d2c000          LDR      r12,[r2,#0]
000052  f81cc000          LDRB     r12,[r12,r0]
000056  f1bc0f00          CMP      r12,#0
00005a  d004              BEQ      |L9.102|
00005c  f801c000          STRB     r12,[r1,r0]
000060  1c40              ADDS     r0,r0,#1
000062  281f              CMP      r0,#0x1f
000064  dbf3              BLT      |L9.78|
                  |L9.102|
000066  540d              STRB     r5,[r1,r0]
                  |L9.104|
000068  6810              LDR      r0,[r2,#0]
00006a  3020              ADDS     r0,r0,#0x20
00006c  6010              STR      r0,[r2,#0]
00006e  6818              LDR      r0,[r3,#0]
000070  3820              SUBS     r0,r0,#0x20
000072  6018              STR      r0,[r3,#0]
                  |L9.116|
;;;250          DeserializeOneDescriptionString(typeName, buffer, bufferLength);
;;;251          DeserializeOneDescriptionString(objectName, buffer, bufferLength);
;;;252    
;;;253          return RESULT_OK;
;;;254        }
000074  bc30              POP      {r4,r5}
000076  2000              MOVS     r0,#0                 ;253
000078  4770              BX       lr
;;;255    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded16SerializedBuffer29SerializeOneDescriptionStringEPKcPPvRi||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer29SerializeOneDescriptionStringEPKcPPvRi PROC ; Anki::Embedded::SerializedBuffer::SerializeOneDescriptionString(const char*, void**, int&)
;;;186    
;;;187        Result SerializedBuffer::SerializeOneDescriptionString(const char *description, void ** buffer, s32 &bufferLength)
000000  b410              PUSH     {r4}
;;;188        {
;;;189          if(bufferLength < DESCRIPTION_STRING_LENGTH) {
000002  6813              LDR      r3,[r2,#0]
000004  2b20              CMP      r3,#0x20
;;;190            return RESULT_FAIL_OUT_OF_MEMORY;
000006  bfbe              ITTT     LT
000008  480e              LDRLT    r0,|L10.68|
;;;191          }
;;;192    
;;;193          s32 iChar = 0;
;;;194    
;;;195          // If objectName is not NULL, copy it
;;;196          if(description) {
;;;197            for(iChar=0; iChar<(DESCRIPTION_STRING_LENGTH-1); iChar++) {
;;;198              if(description[iChar] == '\0') {
;;;199                break;
;;;200              }
;;;201    
;;;202              reinterpret_cast<u8*>(*buffer)[iChar] = description[iChar];
;;;203            }
;;;204          } // if(objectName)
;;;205    
;;;206          reinterpret_cast<u8*>(*buffer)[iChar] = '\0';
;;;207    
;;;208          *buffer = reinterpret_cast<u8*>(*buffer) + DESCRIPTION_STRING_LENGTH;
;;;209          bufferLength -= DESCRIPTION_STRING_LENGTH;
;;;210    
;;;211          return RESULT_OK;
;;;212        }
00000a  bc10              POPLT    {r4}
00000c  4770              BXLT     lr
00000e  2300              MOVS     r3,#0                 ;193
000010  b150              CBZ      r0,|L10.40|
                  |L10.18|
000012  f810c003          LDRB     r12,[r0,r3]           ;198
000016  f1bc0f00          CMP      r12,#0                ;198
00001a  d005              BEQ      |L10.40|
00001c  680c              LDR      r4,[r1,#0]            ;202
00001e  f804c003          STRB     r12,[r4,r3]           ;202
000022  1c5b              ADDS     r3,r3,#1              ;202
000024  2b1f              CMP      r3,#0x1f              ;197
000026  dbf4              BLT      |L10.18|
                  |L10.40|
000028  f8d1c000          LDR      r12,[r1,#0]           ;206
00002c  2000              MOVS     r0,#0                 ;206
00002e  f80c0003          STRB     r0,[r12,r3]           ;206
000032  6808              LDR      r0,[r1,#0]            ;208
000034  3020              ADDS     r0,r0,#0x20           ;208
000036  6008              STR      r0,[r1,#0]            ;209
000038  6810              LDR      r0,[r2,#0]            ;209
00003a  3820              SUBS     r0,r0,#0x20           ;209
00003c  6010              STR      r0,[r2,#0]            ;211
00003e  bc10              POP      {r4}
000040  2000              MOVS     r0,#0                 ;211
000042  4770              BX       lr
;;;213    
                          ENDP

                  |L10.68|
                          DCD      0x01000001

                          AREA ||i._ZN4Anki8Embedded16SerializedBuffer31DeserializeOneDescriptionStringEPcPPvRi||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer31DeserializeOneDescriptionStringEPcPPvRi PROC ; Anki::Embedded::SerializedBuffer::DeserializeOneDescriptionString(char*, void**, int&)
;;;213    
;;;214        Result SerializedBuffer::DeserializeOneDescriptionString(char *description, void ** buffer, s32 &bufferLength)
000000  6813              LDR      r3,[r2,#0]
;;;215        {
;;;216          if(bufferLength < DESCRIPTION_STRING_LENGTH) {
000002  2b20              CMP      r3,#0x20
;;;217            return RESULT_FAIL_OUT_OF_MEMORY;
000004  bfbc              ITT      LT
000006  480f              LDRLT    r0,|L11.68|
;;;218          }
;;;219    
;;;220          if(description) {
;;;221            s32 iChar = 0;
;;;222    
;;;223            for(iChar=0; iChar<(DESCRIPTION_STRING_LENGTH-1); iChar++) {
;;;224              if(reinterpret_cast<u8*>(*buffer)[iChar] == '\0') {
;;;225                break;
;;;226              }
;;;227    
;;;228              description[iChar] = reinterpret_cast<u8*>(*buffer)[iChar];
;;;229            }
;;;230    
;;;231            description[iChar] = '\0';
;;;232          }
;;;233    
;;;234          *buffer = reinterpret_cast<u8*>(*buffer) + DESCRIPTION_STRING_LENGTH;
;;;235          bufferLength -= DESCRIPTION_STRING_LENGTH;
;;;236    
;;;237          return RESULT_OK;
;;;238        }
000008  4770              BXLT     lr
00000a  2800              CMP      r0,#0                 ;220
00000c  bf18              IT       NE                    ;221
00000e  2300              MOVNE    r3,#0                 ;221
000010  d00f              BEQ      |L11.50|
                  |L11.18|
000012  f8d1c000          LDR      r12,[r1,#0]           ;224
000016  f81cc003          LDRB     r12,[r12,r3]          ;224
00001a  f1bc0f00          CMP      r12,#0                ;224
00001e  d004              BEQ      |L11.42|
000020  f800c003          STRB     r12,[r0,r3]           ;228
000024  1c5b              ADDS     r3,r3,#1              ;228
000026  2b1f              CMP      r3,#0x1f              ;223
000028  dbf3              BLT      |L11.18|
                  |L11.42|
00002a  f04f0c00          MOV      r12,#0                ;231
00002e  f800c003          STRB     r12,[r0,r3]           ;231
                  |L11.50|
000032  6808              LDR      r0,[r1,#0]            ;234
000034  3020              ADDS     r0,r0,#0x20           ;234
000036  6008              STR      r0,[r1,#0]            ;235
000038  6810              LDR      r0,[r2,#0]            ;235
00003a  3820              SUBS     r0,r0,#0x20           ;235
00003c  6010              STR      r0,[r2,#0]            ;237
00003e  2000              MOVS     r0,#0                 ;237
000040  4770              BX       lr
;;;239    
                          ENDP

000042  0000              DCW      0x0000
                  |L11.68|
                          DCD      0x01000001

                          AREA ||i._ZN4Anki8Embedded16SerializedBuffer8AllocateEPKcS3_i||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer8AllocateEPKcS3_i PROC ; Anki::Embedded::SerializedBuffer::Allocate(const char*, const char*, int)
;;;269    
;;;270        void* SerializedBuffer::Allocate(const char *typeName, const char *objectName, const s32 dataLength)
000000  b530              PUSH     {r4,r5,lr}
;;;271        {
000002  4684              MOV      r12,r0
000004  b085              SUB      sp,sp,#0x14
000006  460d              MOV      r5,r1
;;;272          s32 totalLength = dataLength + 2*DESCRIPTION_STRING_LENGTH;
000008  f1030040          ADD      r0,r3,#0x40
00000c  2110              MOVS     r1,#0x10
00000e  4614              MOV      r4,r2                 ;271
000010  9003              STR      r0,[sp,#0xc]          ;271
000012  2800              CMP      r0,#0                 ;271
000014  bfc8              IT       GT                    ;271
000016  1e40              SUBGT    r0,r0,#1              ;271
000018  fb90f0f1          SDIV     r0,r0,r1              ;271
00001c  bfc8              IT       GT                    ;271
00001e  1c40              ADDGT    r0,r0,#1              ;271
000020  0101              LSLS     r1,r0,#4              ;271
000022  aa04              ADD      r2,sp,#0x10           ;271
000024  4660              MOV      r0,r12                ;271
000026  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEiRi ; Anki::Embedded::MemoryStack::Allocate(int, int&)
00002a  2800              CMP      r0,#0                 ;271
00002c  d10d              BNE      |L12.74|
00002e  f44f7184          MOV      r1,#0x108             ;271
000032  4814              LDR      r0,|L12.132|
000034  4b14              LDR      r3,|L12.136|
000036  e9cd0100          STRD     r0,r1,[sp,#0]         ;271
00003a  f103022c          ADD      r2,r3,#0x2c           ;271
00003e  f1020114          ADD      r1,r2,#0x14           ;271
000042  2005              MOVS     r0,#5                 ;271
000044  f7fffffe          BL       _Anki_Log
000048  2000              MOVS     r0,#0                 ;271
                  |L12.74|
;;;273          void *segment = AllocateRaw(totalLength);
;;;274    
;;;275          AnkiConditionalErrorAndReturnValue(segment != NULL,
00004a  9002              STR      r0,[sp,#8]
00004c  b158              CBZ      r0,|L12.102|
;;;276            NULL, "SerializedBuffer::Allocate", "Could not add data");
;;;277    
;;;278          if(SerializeDescriptionStrings(typeName, objectName, &segment, totalLength) != RESULT_OK)
00004e  ab03              ADD      r3,sp,#0xc
000050  aa02              ADD      r2,sp,#8
000052  4621              MOV      r1,r4
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeDescriptionStrings(const char*, const char*, void**, int&)
00005a  2800              CMP      r0,#0
;;;279            return NULL;
;;;280    
;;;281          return segment;
00005c  bf0c              ITE      EQ
00005e  9802              LDREQ    r0,[sp,#8]
000060  2000              MOVNE    r0,#0                 ;279
;;;282        }
000062  b005              ADD      sp,sp,#0x14
000064  bd30              POP      {r4,r5,pc}
                  |L12.102|
000066  f2401113          MOV      r1,#0x113             ;275
00006a  4808              LDR      r0,|L12.140|
00006c  4b06              LDR      r3,|L12.136|
00006e  e9cd0100          STRD     r0,r1,[sp,#0]         ;275
000072  f103022c          ADD      r2,r3,#0x2c           ;275
000076  a106              ADR      r1,|L12.144|
000078  2005              MOVS     r0,#5                 ;275
00007a  f7fffffe          BL       _Anki_Log
00007e  b005              ADD      sp,sp,#0x14
000080  2000              MOVS     r0,#0                 ;275
000082  bd30              POP      {r4,r5,pc}
;;;283    
                          ENDP

                  |L12.132|
                          DCD      ||.constdata||+0x193
                  |L12.136|
                          DCD      ||i._ZN4Anki8Embedded16SerializedBuffer11AllocateRawEi||+0x44
                  |L12.140|
                          DCD      ||.constdata||+0xf0
                  |L12.144|
000090  53657269          DCB      "SerializedBuffer::Allocate",0
000094  616c697a
000098  65644275
00009c  66666572
0000a0  3a3a416c
0000a4  6c6f6361
0000a8  746500  
0000ab  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded16SerializedBufferC1EPviNS0_5Flags6BufferE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBufferC2EPviNS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::SerializedBuffer::SerializedBuffer__sub_object(void*, int, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded16SerializedBufferC1EPviNS0_5Flags6BufferE PROC ; Anki::Embedded::SerializedBuffer::SerializedBuffer(void*, int, Anki::Embedded::Flags::Buffer)
;;;23     
;;;24         SerializedBuffer::SerializedBuffer(void *buffer, s32 bufferLength, Flags::Buffer flags)
;;;25     
;;;26         {
;;;27           if(flags.get_isFullyAllocated()) {
;;;28             AnkiConditionalErrorAndReturn((reinterpret_cast<size_t>(buffer)+MemoryStack::HEADER_LENGTH)%MEMORY_ALIGNMENT == 0,
;;;29               "SerializedBuffer::SerializedBuffer", "If fully allocated, the %dth byte of the buffer must be %d byte aligned", MemoryStack::HEADER_LENGTH, MEMORY_ALIGNMENT);
;;;30           }
;;;31     
;;;32           this->memoryStack = MemoryStack(buffer, bufferLength, flags);
;;;33         }
;;;34     
000000  b57f              PUSH     {r0-r6,lr}
000002  b08c              SUB      sp,sp,#0x30
000004  4616              MOV      r6,r2
000006  460d              MOV      r5,r1
000008  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1Ev ; Anki::Embedded::MemoryStack::MemoryStack()
00000c  4604              MOV      r4,r0
00000e  a80f              ADD      r0,sp,#0x3c
000010  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
000014  2800              CMP      r0,#0
000016  bf1c              ITT      NE
000018  f1050008          ADDNE    r0,r5,#8
00001c  f0100f0f          TSTNE    r0,#0xf
000020  d00e              BEQ      |L13.64|
000022  480d              LDR      r0,|L13.88|
000024  2310              MOVS     r3,#0x10
000026  2208              MOVS     r2,#8
000028  211c              MOVS     r1,#0x1c
00002a  e88d000f          STM      sp,{r0-r3}
00002e  a30b              ADR      r3,|L13.92|
000030  4a15              LDR      r2,|L13.136|
000032  a116              ADR      r1,|L13.140|
000034  2005              MOVS     r0,#5
000036  f7fffffe          BL       _Anki_Log
                  |L13.58|
00003a  b010              ADD      sp,sp,#0x40
00003c  4620              MOV      r0,r4
00003e  bd70              POP      {r4-r6,pc}
                  |L13.64|
000040  4632              MOV      r2,r6
000042  4629              MOV      r1,r5
000044  a804              ADD      r0,sp,#0x10
000046  9b0f              LDR      r3,[sp,#0x3c]
000048  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
00004c  e890106f          LDM      r0,{r0-r3,r5,r6,r12}
000050  e884106f          STM      r4,{r0-r3,r5,r6,r12}
000054  e7f1              B        |L13.58|
                          ENDP

000056  0000              DCW      0x0000
                  |L13.88|
                          DCD      ||.constdata||+0x8a
                  |L13.92|
00005c  2e2e5c63          DCB      "..\\coretech\\common\\robot\\src\\serialize.cpp",0
000060  6f726574
000064  6563685c
000068  636f6d6d
00006c  6f6e5c72
000070  6f626f74
000074  5c737263
000078  5c736572
00007c  69616c69
000080  7a652e63
000084  707000  
000087  00                DCB      0
                  |L13.136|
                          DCD      ||.conststring||
                  |L13.140|
00008c  53657269          DCB      "SerializedBuffer::SerializedBuffer",0
000090  616c697a
000094  65644275
000098  66666572
00009c  3a3a5365
0000a0  7269616c
0000a4  697a6564
0000a8  42756666
0000ac  657200  
0000af  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded16SerializedBufferC1Ev||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded16SerializedBufferC2Ev                  ; Alternate entry point ; Anki::Embedded::SerializedBuffer::SerializedBuffer__sub_object()
                  _ZN4Anki8Embedded16SerializedBufferC1Ev PROC ; Anki::Embedded::SerializedBuffer::SerializedBuffer()
;;;18       {
;;;19         SerializedBuffer::SerializedBuffer()
;;;20         {
;;;21           this->memoryStack = MemoryStack();
;;;22         }
;;;23     
000000  b5f0              PUSH     {r4-r7,lr}
000002  b087              SUB      sp,sp,#0x1c
000004  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1Ev ; Anki::Embedded::MemoryStack::MemoryStack()
000008  4607              MOV      r7,r0
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1Ev ; Anki::Embedded::MemoryStack::MemoryStack()
000010  4601              MOV      r1,r0
000012  4638              MOV      r0,r7
000014  e891107e          LDM      r1,{r1-r6,r12}
000018  e887007e          STM      r7,{r1-r6}
00001c  f8c7c018          STR      r12,[r7,#0x18]
000020  b007              ADD      sp,sp,#0x1c
000022  bdf0              POP      {r4-r7,pc}
                          ENDP


                          AREA ||i._ZN4Anki8Embedded23TotalArrayStringLengthsIPKcEEiRKNS0_5ArrayIT_EE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded23TotalArrayStringLengthsIPKcEEiRKNS0_5ArrayIT_EE PROC ; Anki::Embedded::TotalArrayStringLengths<const char*>(const Anki::Embedded::Array<T1>&)
;;;430    
;;;431        template<> s32 TotalArrayStringLengths<const char*>(const Array<const char*> &in)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;432        {
000004  4681              MOV      r9,r0
;;;433          const s32 inHeight = in.get_size(0);
;;;434          const s32 inWidth = in.get_size(1);
;;;435    
;;;436          s32 stringsLength = sizeof(s32);
000006  2604              MOVS     r6,#4
;;;437          for(s32 y=0; y<inHeight; y++) {
000008  e9d9a800          LDRD     r10,r8,[r9,#0]
00000c  2500              MOVS     r5,#0
00000e  f1ba0f00          CMP      r10,#0
000012  dd15              BLE      |L15.64|
                  |L15.20|
000014  f8d91008          LDR      r1,[r9,#8]            ;432
000018  f8d90010          LDR      r0,[r9,#0x10]         ;432
;;;438            char const * const * restrict pIn = in.Pointer(y,0);
;;;439            for(s32 x=0; x<inWidth; x++) {
00001c  2400              MOVS     r4,#0
00001e  fb050701          MLA      r7,r5,r1,r0
000022  f1b80f00          CMP      r8,#0
000026  dd08              BLE      |L15.58|
                  |L15.40|
;;;440              stringsLength += strlen(pIn[x]) + 1;
000028  f8570024          LDR      r0,[r7,r4,LSL #2]
00002c  f7fffffe          BL       strlen
000030  4430              ADD      r0,r0,r6
000032  1c46              ADDS     r6,r0,#1
000034  1c64              ADDS     r4,r4,#1
000036  45a0              CMP      r8,r4                 ;439
000038  dcf6              BGT      |L15.40|
                  |L15.58|
00003a  1c6d              ADDS     r5,r5,#1              ;439
00003c  4555              CMP      r5,r10                ;437
00003e  dbe9              BLT      |L15.20|
                  |L15.64|
;;;441            }
;;;442          }
;;;443    
;;;444          return stringsLength;
000040  4630              MOV      r0,r6
;;;445        }
000042  e8bd87f0          POP      {r4-r10,pc}
;;;446    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded23TotalArrayStringLengthsIPcEEiRKNS0_5ArrayIT_EE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded23TotalArrayStringLengthsIPcEEiRKNS0_5ArrayIT_EE PROC ; Anki::Embedded::TotalArrayStringLengths<char*>(const Anki::Embedded::Array<T1>&)
;;;446    
;;;447        template<> s32 TotalArrayStringLengths<char*>(const Array<char*> &in)
000000  b500              PUSH     {lr}
;;;448        {
000002  e890100f          LDM      r0,{r0-r3,r12}
000006  b085              SUB      sp,sp,#0x14
000008  e88d100f          STM      sp,{r0-r3,r12}
;;;449          // Add const qualifier and call the const version
;;;450          const Array<const char*> constIn = *reinterpret_cast<const Array<const char*>*>(&in);
;;;451          return TotalArrayStringLengths(constIn);
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       _ZN4Anki8Embedded23TotalArrayStringLengthsIPKcEEiRKNS0_5ArrayIT_EE ; Anki::Embedded::TotalArrayStringLengths<const char*>(const Anki::Embedded::Array<T1>&)
;;;452        }
000012  b005              ADD      sp,sp,#0x14
000014  bd00              POP      {pc}
;;;453    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded24CopyArrayStringsToBufferIPKcEEvRKNS0_5ArrayIT_EEPPvRi||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded24CopyArrayStringsToBufferIPKcEEvRKNS0_5ArrayIT_EEPPvRi PROC ; Anki::Embedded::CopyArrayStringsToBuffer<const char*>(const Anki::Embedded::Array<T1>&, void**, int&)
;;;453    
;;;454        template<> void CopyArrayStringsToBuffer<const char*>(const Array<const char*> &in, void ** buffer, s32 &bufferLength)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;455        {
000004  4683              MOV      r11,r0
000006  6800              LDR      r0,[r0,#0]
000008  9000              STR      r0,[sp,#0]
00000a  4617              MOV      r7,r2
00000c  460d              MOV      r5,r1
;;;456          const s32 inHeight = in.get_size(0);
;;;457          const s32 inWidth = in.get_size(1);
;;;458    
;;;459          const s32 stringsLength = TotalArrayStringLengths(in);
00000e  4658              MOV      r0,r11
000010  f8dba004          LDR      r10,[r11,#4]
000014  f7fffffe          BL       _ZN4Anki8Embedded23TotalArrayStringLengthsIPKcEEiRKNS0_5ArrayIT_EE ; Anki::Embedded::TotalArrayStringLengths<const char*>(const Anki::Embedded::Array<T1>&)
;;;460    
;;;461          // Copy the null terminated strings to the end
;;;462    
;;;463          // First copy the total size of the strings
;;;464          reinterpret_cast<u32*>(*buffer)[0] = stringsLength;
000018  6829              LDR      r1,[r5,#0]
;;;465          *buffer = reinterpret_cast<u8*>(*buffer) + sizeof(u32);
;;;466          bufferLength -= sizeof(u32);
;;;467    
;;;468          // Then copy the strings
;;;469          for(s32 y=0; y<inHeight; y++) {
00001a  f04f0900          MOV      r9,#0
00001e  6008              STR      r0,[r1,#0]            ;465
000020  6828              LDR      r0,[r5,#0]            ;465
000022  1d00              ADDS     r0,r0,#4              ;465
000024  6028              STR      r0,[r5,#0]            ;466
000026  6838              LDR      r0,[r7,#0]            ;466
000028  1f00              SUBS     r0,r0,#4              ;466
00002a  6038              STR      r0,[r7,#0]
00002c  9800              LDR      r0,[sp,#0]
00002e  2800              CMP      r0,#0
;;;470            char const * const * restrict pIn = in.Pointer(y,0);
;;;471            for(s32 x=0; x<inWidth; x++) {
;;;472              const s32 curStringLength = static_cast<s32>( strlen(pIn[x]) + 1 );
;;;473    
;;;474              memcpy(*buffer, pIn[x], curStringLength);
;;;475    
;;;476              *buffer = reinterpret_cast<u8*>(*buffer) + curStringLength;
;;;477              bufferLength -= curStringLength;
;;;478            }
;;;479          }
;;;480        }
000030  bfd8              IT       LE
000032  e8bd8ff8          POPLE    {r3-r11,pc}
                  |L17.54|
000036  f8db1008          LDR      r1,[r11,#8]
00003a  f8db0010          LDR      r0,[r11,#0x10]
00003e  2400              MOVS     r4,#0                 ;471
000040  fb090801          MLA      r8,r9,r1,r0           ;471
000044  f1ba0f00          CMP      r10,#0                ;471
000048  dd13              BLE      |L17.114|
                  |L17.74|
00004a  f8580024          LDR      r0,[r8,r4,LSL #2]     ;472
00004e  f7fffffe          BL       strlen
000052  1c46              ADDS     r6,r0,#1              ;472
000054  f8581024          LDR      r1,[r8,r4,LSL #2]     ;474
000058  4632              MOV      r2,r6                 ;474
00005a  6828              LDR      r0,[r5,#0]            ;474
00005c  f7fffffe          BL       __aeabi_memcpy
000060  6828              LDR      r0,[r5,#0]            ;476
000062  1c64              ADDS     r4,r4,#1              ;477
000064  4430              ADD      r0,r0,r6              ;476
000066  6028              STR      r0,[r5,#0]            ;477
000068  6838              LDR      r0,[r7,#0]            ;477
00006a  1b80              SUBS     r0,r0,r6              ;477
00006c  6038              STR      r0,[r7,#0]            ;471
00006e  45a2              CMP      r10,r4                ;471
000070  dceb              BGT      |L17.74|
                  |L17.114|
000072  9800              LDR      r0,[sp,#0]            ;469
000074  f1090901          ADD      r9,r9,#1              ;469
000078  4581              CMP      r9,r0                 ;469
00007a  dbdc              BLT      |L17.54|
00007c  e8bd8ff8          POP      {r3-r11,pc}
;;;481    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded24CopyArrayStringsToBufferIPcEEvRKNS0_5ArrayIT_EEPPvRi||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded24CopyArrayStringsToBufferIPcEEvRKNS0_5ArrayIT_EEPPvRi PROC ; Anki::Embedded::CopyArrayStringsToBuffer<char*>(const Anki::Embedded::Array<T1>&, void**, int&)
;;;481    
;;;482        template<> void CopyArrayStringsToBuffer<char*>(const Array<char*> &in, void ** buffer, s32 &bufferLength)
000000  b530              PUSH     {r4,r5,lr}
;;;483        {
000002  e8901039          LDM      r0,{r0,r3-r5,r12}
000006  b085              SUB      sp,sp,#0x14
000008  e88d1039          STM      sp,{r0,r3-r5,r12}
;;;484          // Just cast the "char *" as "const char *", and serialize
;;;485          const Array<const char*> constIn = *reinterpret_cast<const Array<const char*> *>(&in);
;;;486          return CopyArrayStringsToBuffer<const char*>(constIn, buffer, bufferLength);
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       _ZN4Anki8Embedded24CopyArrayStringsToBufferIPKcEEvRKNS0_5ArrayIT_EEPPvRi ; Anki::Embedded::CopyArrayStringsToBuffer<const char*>(const Anki::Embedded::Array<T1>&, void**, int&)
;;;487        }
000012  b005              ADD      sp,sp,#0x14
000014  bd30              POP      {r4,r5,pc}
;;;488    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded24SerializedBufferIterator7GetNextEPPKcS4_Rib||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded24SerializedBufferIterator7GetNextEPPKcS4_Rib PROC ; Anki::Embedded::SerializedBufferIterator::GetNext(const char**, const char**, int&, bool)
;;;377    
;;;378        void * SerializedBufferIterator::GetNext(const char **typeName, const char **objectName, s32 &dataLength, const bool requireFillPatternMatch)
000000  b570              PUSH     {r4-r6,lr}
;;;379        {
000002  b082              SUB      sp,sp,#8
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  f04f31ff          MOV      r1,#0xffffffff
00000c  9a06              LDR      r2,[sp,#0x18]
00000e  6019              STR      r1,[r3,#0]
000010  461c              MOV      r4,r3
000012  4619              MOV      r1,r3
000014  f7fffffe          BL       _ZN4Anki8Embedded24MemoryStackConstIterator7GetNextERib ; Anki::Embedded::MemoryStackConstIterator::GetNext(int&, bool)
000018  b158              CBZ      r0,|L19.50|
00001a  6030              STR      r0,[r6,#0]
00001c  6821              LDR      r1,[r4,#0]
00001e  3020              ADDS     r0,r0,#0x20
000020  3920              SUBS     r1,r1,#0x20
000022  6021              STR      r1,[r4,#0]
000024  6028              STR      r0,[r5,#0]
000026  6821              LDR      r1,[r4,#0]
000028  3920              SUBS     r1,r1,#0x20
00002a  6021              STR      r1,[r4,#0]
;;;380          // To avoid code duplication, we'll use the const version of GetNext(), though our MemoryStack is not const
;;;381          void * segment = const_cast<void*>(SerializedBufferConstIterator::GetNext(typeName, objectName, dataLength, requireFillPatternMatch));
;;;382    
;;;383          return segment;
;;;384        }
00002c  b002              ADD      sp,sp,#8
00002e  3020              ADDS     r0,r0,#0x20
000030  bd70              POP      {r4-r6,pc}
                  |L19.50|
000032  f2401167          MOV      r1,#0x167
000036  4806              LDR      r0,|L19.80|
000038  4a07              LDR      r2,|L19.88|
00003a  e9cd0100          STRD     r0,r1,[sp,#0]
00003e  4b05              LDR      r3,|L19.84|
000040  f1020118          ADD      r1,r2,#0x18
000044  2005              MOVS     r0,#5
000046  f7fffffe          BL       _Anki_Log
00004a  b002              ADD      sp,sp,#8
00004c  2000              MOVS     r0,#0
00004e  bd70              POP      {r4-r6,pc}
;;;385    
                          ENDP

                  |L19.80|
                          DCD      ||.constdata||+0x1d3
                  |L19.84|
                          DCD      ||i._ZN4Anki8Embedded16SerializedBuffer11AllocateRawEi||+0x44
                  |L19.88|
                          DCD      ||i._ZN4Anki8Embedded29SerializedBufferConstIterator7GetNextEPPKcS4_Rib||+0x58

                          AREA ||i._ZN4Anki8Embedded24SerializedBufferIteratorC1ERNS0_16SerializedBufferE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded24SerializedBufferIteratorC2ERNS0_16SerializedBufferE                  ; Alternate entry point ; Anki::Embedded::SerializedBufferIterator::SerializedBufferIterator__sub_object(Anki::Embedded::SerializedBuffer&)
                  _ZN4Anki8Embedded24SerializedBufferIteratorC1ERNS0_16SerializedBufferE PROC ; Anki::Embedded::SerializedBufferIterator::SerializedBufferIterator(Anki::Embedded::SerializedBuffer&)
;;;372    
;;;373        SerializedBufferIterator::SerializedBufferIterator(SerializedBuffer &serializedBuffer)
;;;374          : SerializedBufferConstIterator(serializedBuffer)
;;;375        {
;;;376        }
;;;377    
000000  f7ffbffe          B.W      _ZN4Anki8Embedded24MemoryStackConstIteratorC1ERKNS0_11MemoryStackE ; Anki::Embedded::MemoryStackConstIterator::MemoryStackConstIterator(const Anki::Embedded::MemoryStack&)
                          ENDP


                          AREA ||i._ZN4Anki8Embedded26CopyArrayStringsFromBufferIPKcEENS_6ResultERNS0_5ArrayIT_EEPPvRiRNS0_11MemoryStackE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded26CopyArrayStringsFromBufferIPKcEENS_6ResultERNS0_5ArrayIT_EEPPvRiRNS0_11MemoryStackE PROC ; Anki::Embedded::CopyArrayStringsFromBuffer<const char*>(Anki::Embedded::Array<T1>&, void**, int&, Anki::Embedded::MemoryStack&)
;;;529    
;;;530        template<> Result CopyArrayStringsFromBuffer<const char*>(Array<const char*> &out, void ** buffer, s32 &bufferLength, MemoryStack &memory)
000000  b570              PUSH     {r4-r6,lr}
;;;531        {
000002  e8901071          LDM      r0,{r0,r4-r6,r12}
000006  b086              SUB      sp,sp,#0x18
000008  e88d1071          STM      sp,{r0,r4-r6,r12}
;;;532          // Just cast the "const char *" as "char *", and deserialize
;;;533          Array<char*> nonConstIn = *reinterpret_cast<Array<char*> *>(&out);
;;;534          return CopyArrayStringsFromBuffer<char*>(nonConstIn, buffer, bufferLength, memory);
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       _ZN4Anki8Embedded26CopyArrayStringsFromBufferIPcEENS_6ResultERNS0_5ArrayIT_EEPPvRiRNS0_11MemoryStackE ; Anki::Embedded::CopyArrayStringsFromBuffer<char*>(Anki::Embedded::Array<T1>&, void**, int&, Anki::Embedded::MemoryStack&)
;;;535        }
000012  b006              ADD      sp,sp,#0x18
000014  bd70              POP      {r4-r6,pc}
;;;536      } // namespace Embedded
                          ENDP


                          AREA ||i._ZN4Anki8Embedded26CopyArrayStringsFromBufferIPcEENS_6ResultERNS0_5ArrayIT_EEPPvRiRNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded26CopyArrayStringsFromBufferIPcEENS_6ResultERNS0_5ArrayIT_EEPPvRiRNS0_11MemoryStackE PROC ; Anki::Embedded::CopyArrayStringsFromBuffer<char*>(Anki::Embedded::Array<T1>&, void**, int&, Anki::Embedded::MemoryStack&)
;;;488    
;;;489        template<> Result CopyArrayStringsFromBuffer<char*>(Array<char*> &out, void ** buffer, s32 &bufferLength, MemoryStack &memory)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;490        {
000004  460d              MOV      r5,r1
;;;491          // Copy the null terminated strings from the end
;;;492    
;;;493          // First, get the total size of the strings
;;;494          const u32 stringsLength = reinterpret_cast<u32*>(*buffer)[0];
000006  6809              LDR      r1,[r1,#0]
000008  b083              SUB      sp,sp,#0xc            ;490
00000a  4691              MOV      r9,r2                 ;490
00000c  f8517b04          LDR      r7,[r1],#4
;;;495          *buffer = reinterpret_cast<u8*>(*buffer) + sizeof(u32);
;;;496          bufferLength -= sizeof(u32);
000010  6029              STR      r1,[r5,#0]
000012  6810              LDR      r0,[r2,#0]
;;;497    
;;;498          // Allocate the space for all strings
;;;499          char * stringBuffer = reinterpret_cast<char*>( memory.Allocate(stringsLength) );
000014  4639              MOV      r1,r7
000016  1f00              SUBS     r0,r0,#4              ;496
000018  6010              STR      r0,[r2,#0]
00001a  4618              MOV      r0,r3
00001c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEi ; Anki::Embedded::MemoryStack::Allocate(int)
000020  ea5f0800          MOVS     r8,r0
;;;500    
;;;501          AnkiConditionalErrorAndReturnValue(stringBuffer,
000024  d029              BEQ      |L22.122|
000026  9803              LDR      r0,[sp,#0xc]
;;;502            RESULT_FAIL_OUT_OF_MEMORY, "SerializedBuffer::DeserializeRawArray", "Out of memory");
;;;503    
;;;504          s32 stringsLengthLeft = stringsLength;
;;;505    
;;;506          // Copy each string and set the pointer for Array out
;;;507          const s32 outHeight = out.get_size(0);
;;;508          const s32 outWidth = out.get_size(1);
;;;509          for(s32 y=0; y<outHeight; y++) {
000028  f04f0a00          MOV      r10,#0
00002c  6800              LDR      r0,[r0,#0]
00002e  9000              STR      r0,[sp,#0]            ;508
000030  9803              LDR      r0,[sp,#0xc]          ;508
000032  f8d0b004          LDR      r11,[r0,#4]
000036  9800              LDR      r0,[sp,#0]
000038  2800              CMP      r0,#0
00003a  dd47              BLE      |L22.204|
                  |L22.60|
00003c  9803              LDR      r0,[sp,#0xc]
;;;510            char ** restrict pOut = out.Pointer(y,0);
;;;511            for(s32 x=0; x<outWidth; x++) {
00003e  2600              MOVS     r6,#0
000040  f1bb0f00          CMP      r11,#0
000044  6901              LDR      r1,[r0,#0x10]
000046  6880              LDR      r0,[r0,#8]
000048  fb0a1000          MLA      r0,r10,r0,r1
00004c  9001              STR      r0,[sp,#4]
00004e  dd38              BLE      |L22.194|
                  |L22.80|
;;;512              const s32 curStringLength = static_cast<s32>( strlen(reinterpret_cast<const char*>(*buffer)) + 1 );
000050  6828              LDR      r0,[r5,#0]
000052  f7fffffe          BL       strlen
000056  1c44              ADDS     r4,r0,#1
;;;513    
;;;514              AnkiConditionalErrorAndReturnValue(curStringLength <= stringsLengthLeft,
000058  42bc              CMP      r4,r7
00005a  dd1d              BLE      |L22.152|
00005c  f2402102          MOV      r1,#0x202
000060  481c              LDR      r0,|L22.212|
000062  e9cd0100          STRD     r0,r1,[sp,#0]
000066  a31c              ADR      r3,|L22.216|
000068  a226              ADR      r2,|L22.260|
00006a  a130              ADR      r1,|L22.300|
00006c  2005              MOVS     r0,#5
00006e  f7fffffe          BL       _Anki_Log
;;;515                RESULT_FAIL, "SerializedBuffer::DeserializeRawArray", "Not enought bytes left to set the array");
;;;516    
;;;517              pOut[x] = stringBuffer;
;;;518              memcpy(stringBuffer, *buffer, curStringLength);
;;;519              stringBuffer += curStringLength;
;;;520    
;;;521              *buffer = reinterpret_cast<u8*>(*buffer) + curStringLength;
;;;522              bufferLength -= curStringLength;
;;;523              stringsLengthLeft -= curStringLength;
;;;524            }
;;;525          }
;;;526    
;;;527          return RESULT_OK;
;;;528        }
000072  b007              ADD      sp,sp,#0x1c
000074  2001              MOVS     r0,#1                 ;514
000076  e8bd8ff0          POP      {r4-r11,pc}
                  |L22.122|
00007a  f24011f5          MOV      r1,#0x1f5             ;501
00007e  4815              LDR      r0,|L22.212|
000080  e9cd0100          STRD     r0,r1,[sp,#0]         ;501
000084  a314              ADR      r3,|L22.216|
000086  a233              ADR      r2,|L22.340|
000088  a128              ADR      r1,|L22.300|
00008a  2005              MOVS     r0,#5                 ;501
00008c  f7fffffe          BL       _Anki_Log
000090  b007              ADD      sp,sp,#0x1c
000092  4834              LDR      r0,|L22.356|
000094  e8bd8ff0          POP      {r4-r11,pc}
                  |L22.152|
000098  9801              LDR      r0,[sp,#4]            ;517
00009a  4622              MOV      r2,r4                 ;518
00009c  f8408026          STR      r8,[r0,r6,LSL #2]     ;517
0000a0  4640              MOV      r0,r8                 ;518
0000a2  6829              LDR      r1,[r5,#0]            ;518
0000a4  f7fffffe          BL       __aeabi_memcpy
0000a8  6828              LDR      r0,[r5,#0]            ;521
0000aa  1b3f              SUBS     r7,r7,r4              ;523
0000ac  4420              ADD      r0,r0,r4              ;521
0000ae  6028              STR      r0,[r5,#0]            ;522
0000b0  f8d90000          LDR      r0,[r9,#0]            ;522
0000b4  1c76              ADDS     r6,r6,#1              ;523
0000b6  1b00              SUBS     r0,r0,r4              ;522
0000b8  44a0              ADD      r8,r8,r4              ;519
0000ba  f8c90000          STR      r0,[r9,#0]            ;511
0000be  45b3              CMP      r11,r6                ;511
0000c0  dcc6              BGT      |L22.80|
                  |L22.194|
0000c2  9800              LDR      r0,[sp,#0]            ;509
0000c4  f10a0a01          ADD      r10,r10,#1            ;509
0000c8  4550              CMP      r0,r10                ;509
0000ca  dcb7              BGT      |L22.60|
                  |L22.204|
0000cc  b007              ADD      sp,sp,#0x1c
0000ce  2000              MOVS     r0,#0                 ;527
0000d0  e8bd8ff0          POP      {r4-r11,pc}
;;;529    
                          ENDP

                  |L22.212|
                          DCD      ||.constdata||+0x2cd
                  |L22.216|
0000d8  2e2e5c63          DCB      "..\\coretech\\common\\robot\\src\\serialize.cpp",0
0000dc  6f726574
0000e0  6563685c
0000e4  636f6d6d
0000e8  6f6e5c72
0000ec  6f626f74
0000f0  5c737263
0000f4  5c736572
0000f8  69616c69
0000fc  7a652e63
000100  707000  
000103  00                DCB      0
                  |L22.260|
000104  4e6f7420          DCB      "Not enought bytes left to set the array",0
000108  656e6f75
00010c  67687420
000110  62797465
000114  73206c65
000118  66742074
00011c  6f207365
000120  74207468
000124  65206172
000128  72617900
                  |L22.300|
00012c  53657269          DCB      "SerializedBuffer::DeserializeRawArray",0
000130  616c697a
000134  65644275
000138  66666572
00013c  3a3a4465
000140  73657269
000144  616c697a
000148  65526177
00014c  41727261
000150  7900    
000152  00                DCB      0
000153  00                DCB      0
                  |L22.340|
000154  4f757420          DCB      "Out of memory",0
000158  6f66206d
00015c  656d6f72
000160  7900    
000162  00                DCB      0
000163  00                DCB      0
                  |L22.356|
                          DCD      0x01000001

                          AREA ||i._ZN4Anki8Embedded29SerializedBufferConstIterator7GetNextEPPKcS4_Rib||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded29SerializedBufferConstIterator7GetNextEPPKcS4_Rib PROC ; Anki::Embedded::SerializedBufferConstIterator::GetNext(const char**, const char**, int&, bool)
;;;353    
;;;354        const void * SerializedBufferConstIterator::GetNext(const char ** typeName, const char ** objectName, s32 &dataLength, const bool requireFillPatternMatch)
000000  b570              PUSH     {r4-r6,lr}
;;;355        {
000002  b082              SUB      sp,sp,#8
000004  4616              MOV      r6,r2
000006  460d              MOV      r5,r1
;;;356          dataLength = -1;
000008  f04f31ff          MOV      r1,#0xffffffff
00000c  9a06              LDR      r2,[sp,#0x18]
;;;357          const char * segment = reinterpret_cast<const char*>( MemoryStackConstIterator::GetNext(dataLength, requireFillPatternMatch) );
00000e  6019              STR      r1,[r3,#0]
000010  461c              MOV      r4,r3                 ;355
000012  4619              MOV      r1,r3
000014  f7fffffe          BL       _ZN4Anki8Embedded24MemoryStackConstIterator7GetNextERib ; Anki::Embedded::MemoryStackConstIterator::GetNext(int&, bool)
;;;358    
;;;359          AnkiConditionalErrorAndReturnValue(segment != NULL,
000018  b158              CBZ      r0,|L23.50|
;;;360            NULL, "SerializedBufferConstIterator::GetNext", "segmentToReturn is NULL");
;;;361    
;;;362          *typeName = segment;
;;;363          segment += SerializedBuffer::DESCRIPTION_STRING_LENGTH;
;;;364          dataLength -= SerializedBuffer::DESCRIPTION_STRING_LENGTH;
00001a  6028              STR      r0,[r5,#0]
00001c  6821              LDR      r1,[r4,#0]
00001e  3020              ADDS     r0,r0,#0x20
000020  3920              SUBS     r1,r1,#0x20
;;;365    
;;;366          *objectName = segment;
000022  6021              STR      r1,[r4,#0]
;;;367          segment += SerializedBuffer::DESCRIPTION_STRING_LENGTH;
;;;368          dataLength -= SerializedBuffer::DESCRIPTION_STRING_LENGTH;
000024  6030              STR      r0,[r6,#0]
000026  6821              LDR      r1,[r4,#0]
000028  3920              SUBS     r1,r1,#0x20
;;;369    
;;;370          return segment;
00002a  6021              STR      r1,[r4,#0]
;;;371        }
00002c  b002              ADD      sp,sp,#8
00002e  3020              ADDS     r0,r0,#0x20           ;368
000030  bd70              POP      {r4-r6,pc}
                  |L23.50|
000032  f2401167          MOV      r1,#0x167             ;359
000036  4806              LDR      r0,|L23.80|
000038  e9cd0100          STRD     r0,r1,[sp,#0]         ;359
00003c  4b05              LDR      r3,|L23.84|
00003e  a206              ADR      r2,|L23.88|
000040  a10b              ADR      r1,|L23.112|
000042  2005              MOVS     r0,#5                 ;359
000044  f7fffffe          BL       _Anki_Log
000048  b002              ADD      sp,sp,#8
00004a  2000              MOVS     r0,#0                 ;359
00004c  bd70              POP      {r4-r6,pc}
;;;372    
                          ENDP

00004e  0000              DCW      0x0000
                  |L23.80|
                          DCD      ||.constdata||+0x1d3
                  |L23.84|
                          DCD      ||i._ZN4Anki8Embedded16SerializedBuffer11AllocateRawEi||+0x44
                  |L23.88|
000058  7365676d          DCB      "segmentToReturn is NULL",0
00005c  656e7454
000060  6f526574
000064  75726e20
000068  6973204e
00006c  554c4c00
                  |L23.112|
000070  53657269          DCB      "SerializedBufferConstIterator::GetNext",0
000074  616c697a
000078  65644275
00007c  66666572
000080  436f6e73
000084  74497465
000088  7261746f
00008c  723a3a47
000090  65744e65
000094  787400  
000097  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded29SerializedBufferConstIteratorC1ERKNS0_16SerializedBufferE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded29SerializedBufferConstIteratorC2ERKNS0_16SerializedBufferE                  ; Alternate entry point ; Anki::Embedded::SerializedBufferConstIterator::SerializedBufferConstIterator__sub_object(const Anki::Embedded::SerializedBuffer&)
                  _ZN4Anki8Embedded29SerializedBufferConstIteratorC1ERKNS0_16SerializedBufferE PROC ; Anki::Embedded::SerializedBufferConstIterator::SerializedBufferConstIterator(const Anki::Embedded::SerializedBuffer&)
;;;348    
;;;349        SerializedBufferConstIterator::SerializedBufferConstIterator(const SerializedBuffer &serializedBuffer)
;;;350          : MemoryStackConstIterator(serializedBuffer.get_memoryStack())
;;;351        {
;;;352        }
;;;353    
000000  f7ffbffe          B.W      _ZN4Anki8Embedded24MemoryStackConstIteratorC1ERKNS0_11MemoryStackE ; Anki::Embedded::MemoryStackConstIterator::MemoryStackConstIterator(const Anki::Embedded::MemoryStack&)
                          ENDP


                          AREA ||i._ZN4Anki8Embedded38SerializedBufferReconstructingIterator7GetNextEPPKcS4_RiRb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded38SerializedBufferReconstructingIterator7GetNextEPPKcS4_RiRb PROC ; Anki::Embedded::SerializedBufferReconstructingIterator::GetNext(const char**, const char**, int&, bool&)
;;;422    
;;;423        void * SerializedBufferReconstructingIterator::GetNext(const char ** typeName, const char ** objectName, s32 &dataLength, bool &isReportedSegmentLengthCorrect)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;424        {
000004  b084              SUB      sp,sp,#0x10
000006  4616              MOV      r6,r2
000008  460f              MOV      r7,r1
00000a  461d              MOV      r5,r3
00000c  aa03              ADD      r2,sp,#0xc
00000e  a902              ADD      r1,sp,#8
000010  9c0a              LDR      r4,[sp,#0x28]
000012  f7fffffe          BL       _ZN4Anki8Embedded38MemoryStackReconstructingConstIterator7GetNextERiS2_ ; Anki::Embedded::MemoryStackReconstructingConstIterator::GetNext(int&, int&)
000016  e9dd1c02          LDRD     r1,r12,[sp,#8]
00001a  f04f0800          MOV      r8,#0
00001e  4561              CMP      r1,r12
000020  bf06              ITTE     EQ
000022  2101              MOVEQ    r1,#1
000024  7021              STRBEQ   r1,[r4,#0]
000026  f8848000          STRBNE   r8,[r4,#0]
00002a  b140              CBZ      r0,|L25.62|
00002c  6038              STR      r0,[r7,#0]
00002e  3020              ADDS     r0,r0,#0x20
000030  6030              STR      r0,[r6,#0]
000032  f8c5c000          STR      r12,[r5,#0]
;;;425          // To avoid code duplication, we'll use the const version of GetNext(), though our MemoryStack is not const
;;;426          void * segment = const_cast<void*>(SerializedBufferReconstructingConstIterator::GetNext(typeName, objectName, dataLength, isReportedSegmentLengthCorrect));
;;;427    
;;;428          return segment;
;;;429        }
000036  b004              ADD      sp,sp,#0x10
000038  3020              ADDS     r0,r0,#0x20
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L25.62|
00003e  f2401193          MOV      r1,#0x193
000042  4807              LDR      r0,|L25.96|
000044  4a08              LDR      r2,|L25.104|
000046  e9cd0100          STRD     r0,r1,[sp,#0]
00004a  4b06              LDR      r3,|L25.100|
00004c  f1020118          ADD      r1,r2,#0x18
000050  2005              MOVS     r0,#5
000052  f7fffffe          BL       _Anki_Log
000056  b004              ADD      sp,sp,#0x10
000058  4640              MOV      r0,r8
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;430    
                          ENDP

00005e  0000              DCW      0x0000
                  |L25.96|
                          DCD      ||.constdata||+0x248
                  |L25.100|
                          DCD      ||i._ZN4Anki8Embedded16SerializedBuffer11AllocateRawEi||+0x44
                  |L25.104|
                          DCD      ||i._ZN4Anki8Embedded29SerializedBufferConstIterator7GetNextEPPKcS4_Rib||+0x58

                          AREA ||i._ZN4Anki8Embedded38SerializedBufferReconstructingIteratorC1ERNS0_16SerializedBufferE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded38SerializedBufferReconstructingIteratorC2ERNS0_16SerializedBufferE                  ; Alternate entry point ; Anki::Embedded::SerializedBufferReconstructingIterator::SerializedBufferReconstructingIterator__sub_object(Anki::Embedded::SerializedBuffer&)
                  _ZN4Anki8Embedded38SerializedBufferReconstructingIteratorC1ERNS0_16SerializedBufferE PROC ; Anki::Embedded::SerializedBufferReconstructingIterator::SerializedBufferReconstructingIterator(Anki::Embedded::SerializedBuffer&)
;;;417    
;;;418        SerializedBufferReconstructingIterator::SerializedBufferReconstructingIterator(SerializedBuffer &serializedBuffer)
;;;419          : SerializedBufferReconstructingConstIterator(serializedBuffer)
;;;420        {
;;;421        }
;;;422    
000000  f7ffbffe          B.W      _ZN4Anki8Embedded38MemoryStackReconstructingConstIteratorC1ERKNS0_11MemoryStackE ; Anki::Embedded::MemoryStackReconstructingConstIterator::MemoryStackReconstructingConstIterator(const Anki::Embedded::MemoryStack&)
                          ENDP


                          AREA ||i._ZN4Anki8Embedded43SerializedBufferReconstructingConstIterator7GetNextEPPKcS4_RiRb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded43SerializedBufferReconstructingConstIterator7GetNextEPPKcS4_RiRb PROC ; Anki::Embedded::SerializedBufferReconstructingConstIterator::GetNext(const char**, const char**, int&, bool&)
;;;390    
;;;391        const void * SerializedBufferReconstructingConstIterator::GetNext(const char ** typeName, const char ** objectName, s32 &dataLength, bool &isReportedSegmentLengthCorrect)
000000  b5f0              PUSH     {r4-r7,lr}
;;;392        {
000002  b085              SUB      sp,sp,#0x14
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  461d              MOV      r5,r3
;;;393          s32 trueSegmentLength;
;;;394          s32 reportedSegmentLength;
;;;395          const char * segment = reinterpret_cast<const char*>( MemoryStackReconstructingConstIterator::GetNext(trueSegmentLength, reportedSegmentLength) );
00000a  aa03              ADD      r2,sp,#0xc
00000c  a902              ADD      r1,sp,#8
00000e  9c0a              LDR      r4,[sp,#0x28]
000010  f7fffffe          BL       _ZN4Anki8Embedded38MemoryStackReconstructingConstIterator7GetNextERiS2_ ; Anki::Embedded::MemoryStackReconstructingConstIterator::GetNext(int&, int&)
000014  e9dd1c02          LDRD     r1,r12,[sp,#8]
;;;396    
;;;397          if(trueSegmentLength == reportedSegmentLength) {
000018  4561              CMP      r1,r12
;;;398            isReportedSegmentLengthCorrect = true;
00001a  bf0c              ITE      EQ
00001c  2101              MOVEQ    r1,#1
;;;399          } else {
;;;400            isReportedSegmentLengthCorrect = false;
00001e  2100              MOVNE    r1,#0
000020  7021              STRB     r1,[r4,#0]
000022  b138              CBZ      r0,|L27.52|
;;;401          }
;;;402    
;;;403          AnkiConditionalErrorAndReturnValue(segment != NULL,
;;;404            NULL, "SerializedBufferConstIterator::GetNext", "segmentToReturn is NULL");
;;;405    
;;;406          *typeName = segment;
000024  6038              STR      r0,[r7,#0]
000026  3020              ADDS     r0,r0,#0x20
;;;407          segment += SerializedBuffer::DESCRIPTION_STRING_LENGTH;
;;;408    
;;;409          *objectName = segment;
;;;410          segment += SerializedBuffer::DESCRIPTION_STRING_LENGTH;
;;;411    
;;;412          // TODO: return true, or reported?
;;;413          dataLength = reportedSegmentLength;
000028  6030              STR      r0,[r6,#0]
;;;414    
;;;415          return segment;
00002a  f8c5c000          STR      r12,[r5,#0]
;;;416        }
00002e  b005              ADD      sp,sp,#0x14
000030  3020              ADDS     r0,r0,#0x20           ;413
000032  bdf0              POP      {r4-r7,pc}
                  |L27.52|
000034  f2401193          MOV      r1,#0x193             ;403
000038  4806              LDR      r0,|L27.84|
00003a  4a08              LDR      r2,|L27.92|
00003c  e9cd0100          STRD     r0,r1,[sp,#0]         ;403
000040  4b05              LDR      r3,|L27.88|
000042  f1020118          ADD      r1,r2,#0x18           ;403
000046  2005              MOVS     r0,#5                 ;403
000048  f7fffffe          BL       _Anki_Log
00004c  b005              ADD      sp,sp,#0x14
00004e  2000              MOVS     r0,#0                 ;403
000050  bdf0              POP      {r4-r7,pc}
;;;417    
                          ENDP

000052  0000              DCW      0x0000
                  |L27.84|
                          DCD      ||.constdata||+0x248
                  |L27.88|
                          DCD      ||i._ZN4Anki8Embedded16SerializedBuffer11AllocateRawEi||+0x44
                  |L27.92|
                          DCD      ||i._ZN4Anki8Embedded29SerializedBufferConstIterator7GetNextEPPKcS4_Rib||+0x58

                          AREA ||i._ZN4Anki8Embedded43SerializedBufferReconstructingConstIteratorC1ERKNS0_16SerializedBufferE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded43SerializedBufferReconstructingConstIteratorC2ERKNS0_16SerializedBufferE                  ; Alternate entry point ; Anki::Embedded::SerializedBufferReconstructingConstIterator::SerializedBufferReconstructingConstIterator__sub_object(const Anki::Embedded::SerializedBuffer&)
                  _ZN4Anki8Embedded43SerializedBufferReconstructingConstIteratorC1ERKNS0_16SerializedBufferE PROC ; Anki::Embedded::SerializedBufferReconstructingConstIterator::SerializedBufferReconstructingConstIterator(const Anki::Embedded::SerializedBuffer&)
;;;385    
;;;386        SerializedBufferReconstructingConstIterator::SerializedBufferReconstructingConstIterator(const SerializedBuffer &serializedBuffer)
;;;387          : MemoryStackReconstructingConstIterator(serializedBuffer.get_memoryStack())
;;;388        {
;;;389        }
;;;390    
000000  f7ffbffe          B.W      _ZN4Anki8Embedded38MemoryStackReconstructingConstIteratorC1ERKNS0_11MemoryStackE ; Anki::Embedded::MemoryStackReconstructingConstIterator::MemoryStackReconstructingConstIterator(const Anki::Embedded::MemoryStack&)
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded16SerializedBuffer15get_memoryStackEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded16SerializedBuffer15get_memoryStackEv PROC ; Anki::Embedded::SerializedBuffer::get_memoryStack() const
;;;338    
;;;339        const MemoryStack& SerializedBuffer::get_memoryStack() const
000000  4770              BX       lr
;;;340        {
;;;341          return memoryStack;
;;;342        }
;;;343    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded16SerializedBuffer7IsValidEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded16SerializedBuffer7IsValidEv PROC ; Anki::Embedded::SerializedBuffer::IsValid() const
;;;333    
;;;334        bool SerializedBuffer::IsValid() const
000000  f7ffbffe          B.W      _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
;;;335        {
;;;336          return memoryStack.IsValid();
;;;337        }
;;;338    
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBuffer20FindSerializedBufferEPKviRiS4_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBuffer20FindSerializedBufferEPKviRiS4_||
                          DCD      0x00000001

                          AREA ||area_number.32||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBuffer29SerializeOneDescriptionStringEPKcPPvRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.32||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBuffer29SerializeOneDescriptionStringEPKcPPvRi||
                          DCD      0x00000001

                          AREA ||area_number.33||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.33||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi||
                          DCD      0x00000001

                          AREA ||area_number.34||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBuffer31DeserializeOneDescriptionStringEPcPPvRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBuffer31DeserializeOneDescriptionStringEPcPPvRi||
                          DCD      0x00000001

                          AREA ||area_number.35||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.35||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi||
                          DCD      0x00000001

                          AREA ||area_number.36||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBufferC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.36||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBufferC1Ev||
                          DCD      0x00000001

                          AREA ||area_number.37||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBufferC1EPviNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.37||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBufferC1EPviNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||area_number.38||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBuffer11AllocateRawEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.38||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBuffer11AllocateRawEi||
                          DCD      0x00000001

                          AREA ||area_number.39||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBuffer8AllocateEPKcS3_i||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBuffer8AllocateEPKcS3_i||
                          DCD      0x00000001

                          AREA ||area_number.40||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBuffer14PushBackStringEPKcz||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.40||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBuffer14PushBackStringEPKcz||
                          DCD      0x00000001

                          AREA ||area_number.41||, LINKORDER=||i._ZNK4Anki8Embedded16SerializedBuffer7IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded16SerializedBuffer7IsValidEv||
                          DCD      0x00000001

                          AREA ||area_number.42||, LINKORDER=||i._ZNK4Anki8Embedded16SerializedBuffer15get_memoryStackEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded16SerializedBuffer15get_memoryStackEv||
                          DCD      0x00000001

                          AREA ||area_number.43||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBuffer15get_memoryStackEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBuffer15get_memoryStackEv||
                          DCD      0x00000001

                          AREA ||area_number.44||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBuffer22EncodedBasicTypeBuffer11DeserializeEbRtRbS4_S4_S4_S4_RiPPvS5_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBuffer22EncodedBasicTypeBuffer11DeserializeEbRtRbS4_S4_S4_S4_RiPPvS5_||
                          DCD      0x00000001

                          AREA ||area_number.45||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBuffer12EncodedArray11DeserializeEbRiS3_S3_RNS0_5Flags6BufferERtRbS8_S8_S8_S8_S3_PPvS3_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBuffer12EncodedArray11DeserializeEbRiS3_S3_RNS0_5Flags6BufferERtRbS8_S8_S8_S8_S3_PPvS3_||
                          DCD      0x00000001

                          AREA ||area_number.46||, LINKORDER=||i._ZN4Anki8Embedded16SerializedBuffer17EncodedArraySlice11DeserializeEbRiS3_S3_RNS0_5Flags6BufferES3_S3_S3_S3_S3_S3_RtRbS8_S8_S8_S8_S3_PPvS3_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded16SerializedBuffer17EncodedArraySlice11DeserializeEbRiS3_S3_RNS0_5Flags6BufferES3_S3_S3_S3_S3_S3_RtRbS8_S8_S8_S8_S3_PPvS3_||
                          DCD      0x00000001

                          AREA ||area_number.47||, LINKORDER=||i._ZN4Anki8Embedded29SerializedBufferConstIteratorC1ERKNS0_16SerializedBufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded29SerializedBufferConstIteratorC1ERKNS0_16SerializedBufferE||
                          DCD      0x00000001

                          AREA ||area_number.48||, LINKORDER=||i._ZN4Anki8Embedded29SerializedBufferConstIterator7GetNextEPPKcS4_Rib||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.48||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded29SerializedBufferConstIterator7GetNextEPPKcS4_Rib||
                          DCD      0x00000001

                          AREA ||area_number.49||, LINKORDER=||i._ZN4Anki8Embedded24SerializedBufferIteratorC1ERNS0_16SerializedBufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.49||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded24SerializedBufferIteratorC1ERNS0_16SerializedBufferE||
                          DCD      0x00000001

                          AREA ||area_number.50||, LINKORDER=||i._ZN4Anki8Embedded24SerializedBufferIterator7GetNextEPPKcS4_Rib||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.50||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded24SerializedBufferIterator7GetNextEPPKcS4_Rib||
                          DCD      0x00000001

                          AREA ||area_number.51||, LINKORDER=||i._ZN4Anki8Embedded43SerializedBufferReconstructingConstIteratorC1ERKNS0_16SerializedBufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded43SerializedBufferReconstructingConstIteratorC1ERKNS0_16SerializedBufferE||
                          DCD      0x00000001

                          AREA ||area_number.52||, LINKORDER=||i._ZN4Anki8Embedded43SerializedBufferReconstructingConstIterator7GetNextEPPKcS4_RiRb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.52||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded43SerializedBufferReconstructingConstIterator7GetNextEPPKcS4_RiRb||
                          DCD      0x00000001

                          AREA ||area_number.53||, LINKORDER=||i._ZN4Anki8Embedded38SerializedBufferReconstructingIteratorC1ERNS0_16SerializedBufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded38SerializedBufferReconstructingIteratorC1ERNS0_16SerializedBufferE||
                          DCD      0x00000001

                          AREA ||area_number.54||, LINKORDER=||i._ZN4Anki8Embedded38SerializedBufferReconstructingIterator7GetNextEPPKcS4_RiRb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.54||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded38SerializedBufferReconstructingIterator7GetNextEPPKcS4_RiRb||
                          DCD      0x00000001

                          AREA ||area_number.55||, LINKORDER=||i._ZN4Anki8Embedded23TotalArrayStringLengthsIPKcEEiRKNS0_5ArrayIT_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.55||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded23TotalArrayStringLengthsIPKcEEiRKNS0_5ArrayIT_EE||
                          DCD      0x00000001

                          AREA ||area_number.56||, LINKORDER=||i._ZN4Anki8Embedded23TotalArrayStringLengthsIPcEEiRKNS0_5ArrayIT_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.56||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded23TotalArrayStringLengthsIPcEEiRKNS0_5ArrayIT_EE||
                          DCD      0x00000001

                          AREA ||area_number.57||, LINKORDER=||i._ZN4Anki8Embedded24CopyArrayStringsToBufferIPKcEEvRKNS0_5ArrayIT_EEPPvRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded24CopyArrayStringsToBufferIPKcEEvRKNS0_5ArrayIT_EEPPvRi||
                          DCD      0x00000001

                          AREA ||area_number.58||, LINKORDER=||i._ZN4Anki8Embedded24CopyArrayStringsToBufferIPcEEvRKNS0_5ArrayIT_EEPPvRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded24CopyArrayStringsToBufferIPcEEvRKNS0_5ArrayIT_EEPPvRi||
                          DCD      0x00000001

                          AREA ||area_number.59||, LINKORDER=||i._ZN4Anki8Embedded26CopyArrayStringsFromBufferIPcEENS_6ResultERNS0_5ArrayIT_EEPPvRiRNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.59||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded26CopyArrayStringsFromBufferIPcEENS_6ResultERNS0_5ArrayIT_EEPPvRiRNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.60||, LINKORDER=||i._ZN4Anki8Embedded26CopyArrayStringsFromBufferIPKcEENS_6ResultERNS0_5ArrayIT_EEPPvRiRNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded26CopyArrayStringsFromBufferIPKcEENS_6ResultERNS0_5ArrayIT_EEPPvRiRNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  _ZN4Anki8Embedded24SERIALIZED_BUFFER_HEADERE ; Anki::Embedded::SERIALIZED_BUFFER_HEADER
000000  ff00fe02          DCB      0xff,0x00,0xfe,0x02
000004  fd0304fc          DCB      0xfd,0x03,0x04,0xfc
                  _ZN4Anki8Embedded24SERIALIZED_BUFFER_FOOTERE ; Anki::Embedded::SERIALIZED_BUFFER_FOOTER
000008  fe00fd02          DCB      0xfe,0x00,0xfd,0x02
00000c  fc0304fb          DCB      0xfc,0x03,0x04,0xfb
                  __PRETTY_FUNCTION__
000010  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000014  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000018  73756c74          DCB      0x73,0x75,0x6c,0x74
00001c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000020  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000024  6d626564          DCB      0x6d,0x62,0x65,0x64
000028  6465643a          DCB      0x64,0x65,0x64,0x3a
00002c  3a536572          DCB      0x3a,0x53,0x65,0x72
000030  69616c69          DCB      0x69,0x61,0x6c,0x69
000034  7a656442          DCB      0x7a,0x65,0x64,0x42
000038  75666665          DCB      0x75,0x66,0x66,0x65
00003c  723a3a46          DCB      0x72,0x3a,0x3a,0x46
000040  696e6453          DCB      0x69,0x6e,0x64,0x53
000044  65726961          DCB      0x65,0x72,0x69,0x61
000048  6c697a65          DCB      0x6c,0x69,0x7a,0x65
00004c  64427566          DCB      0x64,0x42,0x75,0x66
000050  66657228          DCB      0x66,0x65,0x72,0x28
000054  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000058  7420766f          DCB      0x74,0x20,0x76,0x6f
00005c  6964202a          DCB      0x69,0x64,0x20,0x2a
000060  2c207369          DCB      0x2c,0x20,0x73,0x69
000064  676e6564          DCB      0x67,0x6e,0x65,0x64
000068  20696e74          DCB      0x20,0x69,0x6e,0x74
00006c  2c207369          DCB      0x2c,0x20,0x73,0x69
000070  676e6564          DCB      0x67,0x6e,0x65,0x64
000074  20696e74          DCB      0x20,0x69,0x6e,0x74
000078  20262c20          DCB      0x20,0x26,0x2c,0x20
00007c  7369676e          DCB      0x73,0x69,0x67,0x6e
000080  65642069          DCB      0x65,0x64,0x20,0x69
000084  6e742026          DCB      0x6e,0x74,0x20,0x26
000088  2900              DCB      0x29,0x00
                  |symbol_number.89|
00008a  416e              DCB      0x41,0x6e
00008c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000090  456d6265          DCB      0x45,0x6d,0x62,0x65
000094  64646564          DCB      0x64,0x64,0x65,0x64
000098  3a3a5365          DCB      0x3a,0x3a,0x53,0x65
00009c  7269616c          DCB      0x72,0x69,0x61,0x6c
0000a0  697a6564          DCB      0x69,0x7a,0x65,0x64
0000a4  42756666          DCB      0x42,0x75,0x66,0x66
0000a8  65723a3a          DCB      0x65,0x72,0x3a,0x3a
0000ac  53657269          DCB      0x53,0x65,0x72,0x69
0000b0  616c697a          DCB      0x61,0x6c,0x69,0x7a
0000b4  65644275          DCB      0x65,0x64,0x42,0x75
0000b8  66666572          DCB      0x66,0x66,0x65,0x72
0000bc  28766f69          DCB      0x28,0x76,0x6f,0x69
0000c0  64202a2c          DCB      0x64,0x20,0x2a,0x2c
0000c4  20736967          DCB      0x20,0x73,0x69,0x67
0000c8  6e656420          DCB      0x6e,0x65,0x64,0x20
0000cc  696e742c          DCB      0x69,0x6e,0x74,0x2c
0000d0  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000d4  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000d8  6d626564          DCB      0x6d,0x62,0x65,0x64
0000dc  6465643a          DCB      0x64,0x65,0x64,0x3a
0000e0  3a466c61          DCB      0x3a,0x46,0x6c,0x61
0000e4  67733a3a          DCB      0x67,0x73,0x3a,0x3a
0000e8  42756666          DCB      0x42,0x75,0x66,0x66
0000ec  65722900          DCB      0x65,0x72,0x29,0x00
                  |symbol_number.90|
0000f0  766f6964          DCB      0x76,0x6f,0x69,0x64
0000f4  202a416e          DCB      0x20,0x2a,0x41,0x6e
0000f8  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0000fc  456d6265          DCB      0x45,0x6d,0x62,0x65
000100  64646564          DCB      0x64,0x64,0x65,0x64
000104  3a3a5365          DCB      0x3a,0x3a,0x53,0x65
000108  7269616c          DCB      0x72,0x69,0x61,0x6c
00010c  697a6564          DCB      0x69,0x7a,0x65,0x64
000110  42756666          DCB      0x42,0x75,0x66,0x66
000114  65723a3a          DCB      0x65,0x72,0x3a,0x3a
000118  416c6c6f          DCB      0x41,0x6c,0x6c,0x6f
00011c  63617465          DCB      0x63,0x61,0x74,0x65
000120  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000124  73742063          DCB      0x73,0x74,0x20,0x63
000128  68617220          DCB      0x68,0x61,0x72,0x20
00012c  2a2c2063          DCB      0x2a,0x2c,0x20,0x63
000130  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000134  20636861          DCB      0x20,0x63,0x68,0x61
000138  72202a2c          DCB      0x72,0x20,0x2a,0x2c
00013c  20736967          DCB      0x20,0x73,0x69,0x67
000140  6e656420          DCB      0x6e,0x65,0x64,0x20
000144  696e7429          DCB      0x69,0x6e,0x74,0x29
000148  00                DCB      0x00
                  |symbol_number.91|
000149  766f69            DCB      0x76,0x6f,0x69
00014c  64202a41          DCB      0x64,0x20,0x2a,0x41
000150  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000154  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000158  65646465          DCB      0x65,0x64,0x64,0x65
00015c  643a3a53          DCB      0x64,0x3a,0x3a,0x53
000160  65726961          DCB      0x65,0x72,0x69,0x61
000164  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000168  64427566          DCB      0x64,0x42,0x75,0x66
00016c  6665723a          DCB      0x66,0x65,0x72,0x3a
000170  3a507573          DCB      0x3a,0x50,0x75,0x73
000174  68426163          DCB      0x68,0x42,0x61,0x63
000178  6b537472          DCB      0x6b,0x53,0x74,0x72
00017c  696e6728          DCB      0x69,0x6e,0x67,0x28
000180  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000184  74206368          DCB      0x74,0x20,0x63,0x68
000188  6172202a          DCB      0x61,0x72,0x20,0x2a
00018c  2c202e2e          DCB      0x2c,0x20,0x2e,0x2e
000190  2e2900            DCB      0x2e,0x29,0x00
                  |symbol_number.92|
000193  76                DCB      0x76
000194  6f696420          DCB      0x6f,0x69,0x64,0x20
000198  2a416e6b          DCB      0x2a,0x41,0x6e,0x6b
00019c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0001a0  6d626564          DCB      0x6d,0x62,0x65,0x64
0001a4  6465643a          DCB      0x64,0x65,0x64,0x3a
0001a8  3a536572          DCB      0x3a,0x53,0x65,0x72
0001ac  69616c69          DCB      0x69,0x61,0x6c,0x69
0001b0  7a656442          DCB      0x7a,0x65,0x64,0x42
0001b4  75666665          DCB      0x75,0x66,0x66,0x65
0001b8  723a3a41          DCB      0x72,0x3a,0x3a,0x41
0001bc  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
0001c0  61746552          DCB      0x61,0x74,0x65,0x52
0001c4  61772873          DCB      0x61,0x77,0x28,0x73
0001c8  69676e65          DCB      0x69,0x67,0x6e,0x65
0001cc  6420696e          DCB      0x64,0x20,0x69,0x6e
0001d0  742900            DCB      0x74,0x29,0x00
                  |symbol_number.93|
0001d3  63                DCB      0x63
0001d4  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0001d8  20766f69          DCB      0x20,0x76,0x6f,0x69
0001dc  64202a41          DCB      0x64,0x20,0x2a,0x41
0001e0  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0001e4  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0001e8  65646465          DCB      0x65,0x64,0x64,0x65
0001ec  643a3a53          DCB      0x64,0x3a,0x3a,0x53
0001f0  65726961          DCB      0x65,0x72,0x69,0x61
0001f4  6c697a65          DCB      0x6c,0x69,0x7a,0x65
0001f8  64427566          DCB      0x64,0x42,0x75,0x66
0001fc  66657243          DCB      0x66,0x65,0x72,0x43
000200  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000204  49746572          DCB      0x49,0x74,0x65,0x72
000208  61746f72          DCB      0x61,0x74,0x6f,0x72
00020c  3a3a4765          DCB      0x3a,0x3a,0x47,0x65
000210  744e6578          DCB      0x74,0x4e,0x65,0x78
000214  7428636f          DCB      0x74,0x28,0x63,0x6f
000218  6e737420          DCB      0x6e,0x73,0x74,0x20
00021c  63686172          DCB      0x63,0x68,0x61,0x72
000220  202a2a2c          DCB      0x20,0x2a,0x2a,0x2c
000224  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000228  73742063          DCB      0x73,0x74,0x20,0x63
00022c  68617220          DCB      0x68,0x61,0x72,0x20
000230  2a2a2c20          DCB      0x2a,0x2a,0x2c,0x20
000234  7369676e          DCB      0x73,0x69,0x67,0x6e
000238  65642069          DCB      0x65,0x64,0x20,0x69
00023c  6e742026          DCB      0x6e,0x74,0x20,0x26
000240  2c20626f          DCB      0x2c,0x20,0x62,0x6f
000244  6f6c2900          DCB      0x6f,0x6c,0x29,0x00
                  |symbol_number.94|
000248  636f6e73          DCB      0x63,0x6f,0x6e,0x73
00024c  7420766f          DCB      0x74,0x20,0x76,0x6f
000250  6964202a          DCB      0x69,0x64,0x20,0x2a
000254  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000258  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00025c  62656464          DCB      0x62,0x65,0x64,0x64
000260  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000264  53657269          DCB      0x53,0x65,0x72,0x69
000268  616c697a          DCB      0x61,0x6c,0x69,0x7a
00026c  65644275          DCB      0x65,0x64,0x42,0x75
000270  66666572          DCB      0x66,0x66,0x65,0x72
000274  5265636f          DCB      0x52,0x65,0x63,0x6f
000278  6e737472          DCB      0x6e,0x73,0x74,0x72
00027c  75637469          DCB      0x75,0x63,0x74,0x69
000280  6e67436f          DCB      0x6e,0x67,0x43,0x6f
000284  6e737449          DCB      0x6e,0x73,0x74,0x49
000288  74657261          DCB      0x74,0x65,0x72,0x61
00028c  746f723a          DCB      0x74,0x6f,0x72,0x3a
000290  3a476574          DCB      0x3a,0x47,0x65,0x74
000294  4e657874          DCB      0x4e,0x65,0x78,0x74
000298  28636f6e          DCB      0x28,0x63,0x6f,0x6e
00029c  73742063          DCB      0x73,0x74,0x20,0x63
0002a0  68617220          DCB      0x68,0x61,0x72,0x20
0002a4  2a2a2c20          DCB      0x2a,0x2a,0x2c,0x20
0002a8  636f6e73          DCB      0x63,0x6f,0x6e,0x73
0002ac  74206368          DCB      0x74,0x20,0x63,0x68
0002b0  6172202a          DCB      0x61,0x72,0x20,0x2a
0002b4  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
0002b8  69676e65          DCB      0x69,0x67,0x6e,0x65
0002bc  6420696e          DCB      0x64,0x20,0x69,0x6e
0002c0  7420262c          DCB      0x74,0x20,0x26,0x2c
0002c4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0002c8  6c202629          DCB      0x6c,0x20,0x26,0x29
0002cc  00                DCB      0x00
                  |symbol_number.95|
0002cd  416e6b            DCB      0x41,0x6e,0x6b
0002d0  693a3a52          DCB      0x69,0x3a,0x3a,0x52
0002d4  6573756c          DCB      0x65,0x73,0x75,0x6c
0002d8  7420416e          DCB      0x74,0x20,0x41,0x6e
0002dc  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0002e0  456d6265          DCB      0x45,0x6d,0x62,0x65
0002e4  64646564          DCB      0x64,0x64,0x65,0x64
0002e8  3a3a436f          DCB      0x3a,0x3a,0x43,0x6f
0002ec  70794172          DCB      0x70,0x79,0x41,0x72
0002f0  72617953          DCB      0x72,0x61,0x79,0x53
0002f4  7472696e          DCB      0x74,0x72,0x69,0x6e
0002f8  67734672          DCB      0x67,0x73,0x46,0x72
0002fc  6f6d4275          DCB      0x6f,0x6d,0x42,0x75
000300  66666572          DCB      0x66,0x66,0x65,0x72
000304  28416e6b          DCB      0x28,0x41,0x6e,0x6b
000308  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00030c  6d626564          DCB      0x6d,0x62,0x65,0x64
000310  6465643a          DCB      0x64,0x65,0x64,0x3a
000314  3a417272          DCB      0x3a,0x41,0x72,0x72
000318  61793c54          DCB      0x61,0x79,0x3c,0x54
00031c  7970653e          DCB      0x79,0x70,0x65,0x3e
000320  20262c20          DCB      0x20,0x26,0x2c,0x20
000324  766f6964          DCB      0x76,0x6f,0x69,0x64
000328  202a2a2c          DCB      0x20,0x2a,0x2a,0x2c
00032c  20736967          DCB      0x20,0x73,0x69,0x67
000330  6e656420          DCB      0x6e,0x65,0x64,0x20
000334  696e7420          DCB      0x69,0x6e,0x74,0x20
000338  262c2041          DCB      0x26,0x2c,0x20,0x41
00033c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000340  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000344  65646465          DCB      0x65,0x64,0x64,0x65
000348  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00034c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000350  79537461          DCB      0x79,0x53,0x74,0x61
000354  636b2026          DCB      0x63,0x6b,0x20,0x26
000358  29205b77          DCB      0x29,0x20,0x5b,0x77
00035c  69746820          DCB      0x69,0x74,0x68,0x20
000360  54797065          DCB      0x54,0x79,0x70,0x65
000364  203d2063          DCB      0x20,0x3d,0x20,0x63
000368  68617220          DCB      0x68,0x61,0x72,0x20
00036c  2a5d00            DCB      0x2a,0x5d,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  49662066          DCB      "If fully allocated, the %dth byte of the buffer must be"
000004  756c6c79
000008  20616c6c
00000c  6f636174
000010  65642c20
000014  74686520
000018  25647468
00001c  20627974
000020  65206f66
000024  20746865
000028  20627566
00002c  66657220
000030  6d757374
000034  206265  
000037  20256420          DCB      " %d byte aligned",0
00003b  62797465
00003f  20616c69
000043  676e6564
000047  00      

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIPKcE8get_sizeEiEs||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIPKcE8get_sizeEiEs, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIPKcE8get_sizeEiEs ; Anki::Embedded::Array<const char*>::get_size(int) const::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a676574          DCB      0x3a,0x67,0x65,0x74
000010  5f73697a          DCB      0x5f,0x73,0x69,0x7a
000014  6500              DCB      0x65,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIPKcE8get_sizeEiEs_0||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIPKcE8get_sizeEiEs_0, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIPKcE8get_sizeEiEs_0 ; Anki::Embedded::Array<const char*>::get_size(int) const::string (instance 2)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIPKcE8get_sizeEiEs_1||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIPKcE8get_sizeEiEs_1, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIPKcE8get_sizeEiEs_1 ; Anki::Embedded::Array<const char*>::get_size(int) const::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIPcE8get_sizeEiEs||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIPcE8get_sizeEiEs, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIPcE8get_sizeEiEs ; Anki::Embedded::Array<char*>::get_size(int) const::string
000000  41727261          DCB      0x41,0x72,0x72,0x61
000004  793c5479          DCB      0x79,0x3c,0x54,0x79
000008  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00000c  3a676574          DCB      0x3a,0x67,0x65,0x74
000010  5f73697a          DCB      0x5f,0x73,0x69,0x7a
000014  6500              DCB      0x65,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIPcE8get_sizeEiEs_0||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIPcE8get_sizeEiEs_0, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIPcE8get_sizeEiEs_0 ; Anki::Embedded::Array<char*>::get_size(int) const::string (instance 2)
000000  4e656761          DCB      0x4e,0x65,0x67,0x61
000004  74697665          DCB      0x74,0x69,0x76,0x65
000008  2064696d          DCB      0x20,0x64,0x69,0x6d
00000c  656e7369          DCB      0x65,0x6e,0x73,0x69
000010  6f6e00            DCB      0x6f,0x6e,0x00

                          AREA ||.data__ZZNK4Anki8Embedded5ArrayIPcE8get_sizeEiEs_1||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIPcE8get_sizeEiEs_1, DATA, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIPcE8get_sizeEiEs_1 ; Anki::Embedded::Array<char*>::get_size(int) const::string (instance 3)
000000  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000004  6f726574          DCB      0x6f,0x72,0x65,0x74
000008  6563685c          DCB      0x65,0x63,0x68,0x5c
00000c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000010  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000014  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000018  64655c61          DCB      0x64,0x65,0x5c,0x61
00001c  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000020  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000024  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000028  6f626f74          DCB      0x6f,0x62,0x6f,0x74
00002c  2f617272          DCB      0x2f,0x61,0x72,0x72
000030  61793264          DCB      0x61,0x79,0x32,0x64
000034  2e6800            DCB      0x2e,0x68,0x00
