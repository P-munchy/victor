; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\sharp.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\sharp.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\sharp.crf arm_hal\hal\sharp.cpp]
                          THUMB

                          AREA ||i.TIM7_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM7_IRQHandler PROC
;;;589    */
;;;590    extern "C" void TIM7_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;591    {
;;;592      static TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
;;;593      static char bits, m;
;;;594      static int long_count;
;;;595    //  TIM7->CR1 &= ~0x01;           // Disable Counter
;;;596      TIM7->SR = 0;        // Reset interrupt flag
000002  48f1              LDR      r0,|L1.968|
000004  2500              MOVS     r5,#0
000006  8005              STRH     r5,[r0,#0]
;;;597      
;;;598      // check for new messages
;;;599      // set m, I2Cstate, bits here
;;;600      if(I2Cstate == 0)
000008  4cf0              LDR      r4,|L1.972|
00000a  78e2              LDRB     r2,[r4,#3]  ; I2Cstate
;;;601      {
;;;602        m = 0x80; // reset m
00000c  2180              MOVS     r1,#0x80
;;;603        bits = 0;
;;;604        I2Cstate = 0x00;
;;;605        read_msg.DATA[0] = 0x00;
00000e  f1040018          ADD      r0,r4,#0x18
000012  b92a              CBNZ     r2,|L1.32|
000014  7061              STRB     r1,[r4,#1]            ;602
000016  7025              STRB     r5,[r4,#0]            ;603
000018  70e5              STRB     r5,[r4,#3]            ;604
00001a  7145              STRB     r5,[r0,#5]
;;;606        read_msg.DATA[1] = 0x00;
00001c  7185              STRB     r5,[r0,#6]
;;;607        long_count = 0;
00001e  6065              STR      r5,[r4,#4]  ; long_count
                  |L1.32|
;;;608      }
;;;609      
;;;610      switch(I2Cstate)
000020  78e2              LDRB     r2,[r4,#3]  ; I2Cstate
000022  2a38              CMP      r2,#0x38
000024  f08081cc          BCS.W    |L1.960|
000028  e8dff002          TBB      [pc,r2]
00002c  1c283245          DCB      0x1c,0x28,0x32,0x45
000030  525d6a72          DCB      0x52,0x5d,0x6a,0x72
000034  7e525d89          DCB      0x7e,0x52,0x5d,0x89
000038  919b525d          DCB      0x91,0x9b,0x52,0x5d
00003c  a4acb6c0          DCB      0xa4,0xac,0xb6,0xc0
000040  ad29d3dc          DCB      0xad,0x29,0xd3,0xdc
000044  535ef4f2          DCB      0x53,0x5e,0xf4,0xf2
000048  f1535ef0          DCB      0xf1,0x53,0x5e,0xf0
00004c  b7efad29          DCB      0xb7,0xef,0xad,0x29
000050  eeed535e          DCB      0xee,0xed,0x53,0x5e
000054  ecebeaad          DCB      0xec,0xeb,0xea,0xad
000058  b7e9e8e7          DCB      0xb7,0xe9,0xe8,0xe7
00005c  efb7e6b7          DCB      0xef,0xb7,0xe6,0xb7
000060  e5e6b7e5          DCB      0xe5,0xe6,0xb7,0xe5
;;;611      {
;;;612        //// send a start bit ////
;;;613        case 0x00:  // start bit (part 1)
;;;614          #ifdef I2C_TRIGGER
;;;615          GPIO_SET(GPIO_TRIGGER, PIN_TRIGGER);
000064  49da              LDR      r1,|L1.976|
000066  f44f6000          MOV      r0,#0x800
00006a  8008              STRH     r0,[r1,#0]
;;;616          #endif
;;;617          GPIO_RESET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA);
00006c  48d9              LDR      r0,|L1.980|
00006e  6800              LDR      r0,[r0,#0]  ; write_msg
000070  6901              LDR      r1,[r0,#0x10]
000072  6880              LDR      r0,[r0,#8]
000074  8341              STRH     r1,[r0,#0x1a]
;;;618          I2Cstate++;
000076  78e0              LDRB     r0,[r4,#3]  ; I2Cstate
000078  1c40              ADDS     r0,r0,#1
;;;619          // wait
;;;620          break;
00007a  e026              B        |L1.202|
;;;621        
;;;622        case 0x01: // start bit (part 2)
;;;623          GPIO_RESET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
00007c  48d5              LDR      r0,|L1.980|
;;;624          I2Cstate++;
;;;625          // wait
;;;626          break;
;;;627          
;;;628        //// send slave_write address ////
;;;629        case 0x02: // reset clock, set data (part 1 x 8)
;;;630          GPIO_RESET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;631          (m & write_msg.IFACE->ADDR_SLAVE_W) ? GPIO_SET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA) : GPIO_RESET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA);
;;;632          m >>= 1;
;;;633          I2Cstate++;
;;;634          // wait
;;;635          break;
;;;636        
;;;637        case 0x03: // set clock (part 2 x 8)
;;;638          GPIO_SET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;639          m == 0 ? I2Cstate++ : I2Cstate--;
;;;640          // wait
;;;641          break;
;;;642        
;;;643        case 0x04: // end with a clock reset, and reset m (part 3)
;;;644          GPIO_RESET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL); 
;;;645          m = 0x80; // reset m
;;;646          I2Cstate++;
;;;647          // wait
;;;648          break;
;;;649    
;;;650        //// receive ack ////
;;;651        case 0x05: // set clock and data (part 1)
;;;652          GPIO_SET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;653          GPIO_SET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA);
;;;654          I2Cstate++;
;;;655          // wait
;;;656          break;
;;;657                    
;;;658        case 0x06: // read ack and reset clock (part 2)
;;;659          if ((!!(GPIO_READ(write_msg.IFACE->GPIO_SDA) & write_msg.IFACE->PIN_SDA)) != I2C_ACK)
;;;660          {
;;;661            assert(0);
;;;662            I2Cstate = 0x35;
;;;663          }
;;;664          else // success
;;;665          {
;;;666            I2Cstate++;
;;;667          }
;;;668          GPIO_RESET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;669          GPIO_RESET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA);
;;;670          // wait
;;;671          break;
;;;672          
;;;673        //// send word address ////
;;;674        case 0x07: // reset clock, set data (part 1 x 8)
;;;675          GPIO_RESET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;676          (m & write_msg.ADDR_WORD) ? GPIO_SET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA) : GPIO_RESET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA);
;;;677          m >>= 1;
;;;678          I2Cstate++;
;;;679          // wait
;;;680          break;
;;;681        
;;;682        case 0x08: // set clock (part 2 x 8)
;;;683          GPIO_SET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;684          m == 0 ? I2Cstate++ : I2Cstate--;
;;;685          // wait
;;;686          break;
;;;687        
;;;688        case 0x09: // end with a clock reset and reset m (part 3)
;;;689          GPIO_RESET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;690          m = 0x80; // reset m
;;;691          I2Cstate++;
;;;692          // wait
;;;693          break;
;;;694          
;;;695        //// receive ack ////
;;;696        case 0x0A: // set clock and data (part 1)
;;;697          GPIO_SET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;698          GPIO_SET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA);
;;;699          I2Cstate++;
;;;700          // wait
;;;701          break;
;;;702                    
;;;703        case 0x0B: // read data and reset clock (part 2)
;;;704          if ((!!(GPIO_READ(write_msg.IFACE->GPIO_SDA) & write_msg.IFACE->PIN_SDA)) != I2C_ACK)
;;;705          {
;;;706            assert(0);
;;;707            I2Cstate = 0x35;
;;;708          }
;;;709          else // success
;;;710          {
;;;711            I2Cstate++;
;;;712          }
;;;713          GPIO_RESET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;714          GPIO_RESET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA);
;;;715          // wait
;;;716          break;
;;;717    
;;;718        //// send data ////
;;;719        case 0x0C: // reset clock, set data (part 1 x 8)
;;;720          GPIO_RESET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;721          (m & write_msg.DATA) ? GPIO_SET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA) : GPIO_RESET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA);
;;;722          m >>= 1;
;;;723          I2Cstate++;
;;;724          // wait
;;;725          break;
;;;726        
;;;727        case 0x0D: // set clock (part 2 x 8)
;;;728          GPIO_SET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;729          m == 0 ? I2Cstate++ : I2Cstate--;
;;;730          // wait
;;;731          break;
;;;732        
;;;733        case 0x0E: // end with a clock reset and reset m (part 3)
;;;734          GPIO_RESET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;735          m = 0x80; // reset m
;;;736          I2Cstate++;
;;;737          // wait
;;;738          break;
;;;739           
;;;740        //// receive ack ////
;;;741        case 0x0F: // set clock and data (part 1)
;;;742          GPIO_SET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;743          GPIO_SET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA);
;;;744          I2Cstate++;
;;;745          // wait
;;;746          break;
;;;747                    
;;;748        case 0x10: // read data and reset clock (part 2)
;;;749          if ((!!(GPIO_READ(write_msg.IFACE->GPIO_SDA) & write_msg.IFACE->PIN_SDA)) != I2C_ACK)
;;;750          {
;;;751            assert(0);
;;;752            I2Cstate = 0x35;
;;;753          }
;;;754          else // success
;;;755          {
;;;756            I2Cstate++;
;;;757          }
;;;758          GPIO_RESET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;759          GPIO_RESET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA);
;;;760          // wait
;;;761          break;
;;;762          
;;;763        //// stop condition ////
;;;764        case 0x11: // reset data (part 1)
;;;765          GPIO_RESET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA);
;;;766          I2Cstate++;
;;;767          // wait
;;;768          break;
;;;769          
;;;770        case 0x12: // set clock (part 2)
;;;771          GPIO_SET(write_msg.IFACE->GPIO_SCL, write_msg.IFACE->PIN_SCL);
;;;772          I2Cstate++;
;;;773          // wait
;;;774          break;
;;;775          
;;;776        case 0x13: // set data (part 3)
;;;777          GPIO_SET(write_msg.IFACE->GPIO_SDA, write_msg.IFACE->PIN_SDA);
;;;778          if(long_count == 750)
;;;779          {
;;;780            I2Cstate++;
;;;781            long_count = 0;
;;;782          }
;;;783          else
;;;784          {
;;;785            long_count++;
;;;786          }
;;;787          // wait
;;;788          //TIM7->ARR = 2000; // approx 3.75 or 4 ms wait
;;;789          break;
;;;790    
;;;791    //////////////////////////////
;;;792    
;;;793    
;;;794        //// send a start bit ////
;;;795        case 0x14:  // start bit (part 1)
;;;796          GPIO_RESET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
;;;797          I2Cstate++;
;;;798          //TIM7->ARR = 1; // put this back
;;;799          // wait
;;;800          break;
;;;801        
;;;802        case 0x15: // start bit (part 2)
;;;803          GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
00007e  6800              LDR      r0,[r0,#0]  ; read_msg
000080  68c1              LDR      r1,[r0,#0xc]
000082  6840              LDR      r0,[r0,#4]
000084  8341              STRH     r1,[r0,#0x1a]
;;;804          I2Cstate++;
000086  78e0              LDRB     r0,[r4,#3]  ; I2Cstate
000088  1c40              ADDS     r0,r0,#1
00008a  70e0              STRB     r0,[r4,#3]
;;;805          // wait
;;;806          break;
00008c  f000b998          B.W      |L1.960|
000090  48d0              LDR      r0,|L1.980|
000092  6800              LDR      r0,[r0,#0]            ;630  ; write_msg
000094  68c1              LDR      r1,[r0,#0xc]          ;630
000096  6842              LDR      r2,[r0,#4]            ;630
000098  8351              STRH     r1,[r2,#0x1a]         ;630
00009a  7802              LDRB     r2,[r0,#0]            ;631
00009c  7861              LDRB     r1,[r4,#1]            ;631  ; m
00009e  420a              TST      r2,r1                 ;631
0000a0  f0408106          BNE.W    |L1.688|
0000a4  f000b908          B.W      |L1.696|
                  |L1.168|
0000a8  0848              LSRS     r0,r1,#1              ;632
0000aa  7060              STRB     r0,[r4,#1]            ;632
0000ac  78e0              LDRB     r0,[r4,#3]            ;633  ; I2Cstate
0000ae  1c40              ADDS     r0,r0,#1              ;633
0000b0  70e0              STRB     r0,[r4,#3]            ;633
0000b2  f000b985          B.W      |L1.960|
0000b6  48c7              LDR      r0,|L1.980|
0000b8  6800              LDR      r0,[r0,#0]            ;638  ; write_msg
0000ba  68c1              LDR      r1,[r0,#0xc]          ;638
0000bc  6840              LDR      r0,[r0,#4]            ;638
0000be  8301              STRH     r1,[r0,#0x18]         ;638
0000c0  7860              LDRB     r0,[r4,#1]            ;639  ; m
0000c2  2800              CMP      r0,#0                 ;639
0000c4  d138              BNE      |L1.312|
                  |L1.198|
0000c6  78e0              LDRB     r0,[r4,#3]            ;639  ; I2Cstate
0000c8  1c40              ADDS     r0,r0,#1              ;639
                  |L1.202|
0000ca  70e0              STRB     r0,[r4,#3]            ;639
0000cc  f000b978          B.W      |L1.960|
0000d0  48c0              LDR      r0,|L1.980|
;;;807          
;;;808        //// send slave_write address ////
;;;809        case 0x16: // reset clock, set data (part 1 x 8)
;;;810          GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;811          (m & read_msg.IFACE->ADDR_SLAVE_W) ? GPIO_SET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA) : GPIO_RESET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
;;;812          m >>= 1;
;;;813          I2Cstate++;
;;;814          // wait
;;;815          break;
;;;816        
;;;817        case 0x17: // set clock (part 2 x 8)
;;;818          GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;819          m == 0 ? I2Cstate++ : I2Cstate--;
;;;820          // wait
;;;821          break;
;;;822        
;;;823        case 0x18: // end with a clock reset, and reset m (part 3)
;;;824          GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL); 
0000d2  6800              LDR      r0,[r0,#0]  ; read_msg
0000d4  68c2              LDR      r2,[r0,#0xc]
0000d6  6840              LDR      r0,[r0,#4]
0000d8  8342              STRH     r2,[r0,#0x1a]
;;;825          m = 0x80; // reset m
0000da  7061              STRB     r1,[r4,#1]
;;;826          I2Cstate++;
0000dc  78e0              LDRB     r0,[r4,#3]  ; I2Cstate
0000de  1c40              ADDS     r0,r0,#1
0000e0  70e0              STRB     r0,[r4,#3]
;;;827          // wait
;;;828          break;
0000e2  f000b96d          B.W      |L1.960|
0000e6  48bb              LDR      r0,|L1.980|
;;;829    
;;;830        //// receive ack ////
;;;831        case 0x19: // set clock and data (part 1)
;;;832          GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
0000e8  6800              LDR      r0,[r0,#0]  ; read_msg
0000ea  68c1              LDR      r1,[r0,#0xc]
0000ec  6842              LDR      r2,[r0,#4]
0000ee  8311              STRH     r1,[r2,#0x18]
;;;833          GPIO_SET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
0000f0  6901              LDR      r1,[r0,#0x10]
0000f2  6880              LDR      r0,[r0,#8]
0000f4  8301              STRH     r1,[r0,#0x18]
;;;834          I2Cstate++;
0000f6  78e0              LDRB     r0,[r4,#3]  ; I2Cstate
0000f8  1c40              ADDS     r0,r0,#1
0000fa  70e0              STRB     r0,[r4,#3]
;;;835          // wait
;;;836          break;
0000fc  f000b960          B.W      |L1.960|
000100  48b4              LDR      r0,|L1.980|
000102  6800              LDR      r0,[r0,#0]            ;659  ; write_msg
000104  6881              LDR      r1,[r0,#8]            ;659
000106  6909              LDR      r1,[r1,#0x10]         ;659
000108  6902              LDR      r2,[r0,#0x10]         ;659
00010a  4211              TST      r1,r2                 ;659
00010c  d072              BEQ      |L1.500|
                  |L1.270|
00010e  e7fe              B        |L1.270|
000110  49b0              LDR      r1,|L1.980|
000112  6808              LDR      r0,[r1,#0]            ;675  ; write_msg
000114  68c2              LDR      r2,[r0,#0xc]          ;675
000116  6843              LDR      r3,[r0,#4]            ;675
000118  835a              STRH     r2,[r3,#0x1a]         ;675
00011a  790a              LDRB     r2,[r1,#4]            ;676  ; write_msg
00011c  7861              LDRB     r1,[r4,#1]            ;676  ; m
00011e  420a              TST      r2,r1                 ;676
000120  f04080c6          BNE.W    |L1.688|
000124  f000b8c8          B.W      |L1.696|
000128  48aa              LDR      r0,|L1.980|
00012a  6800              LDR      r0,[r0,#0]            ;683  ; write_msg
00012c  68c1              LDR      r1,[r0,#0xc]          ;683
00012e  6840              LDR      r0,[r0,#4]            ;683
000130  8301              STRH     r1,[r0,#0x18]         ;683
000132  7860              LDRB     r0,[r4,#1]            ;684  ; m
000134  2800              CMP      r0,#0                 ;684
000136  d0c6              BEQ      |L1.198|
                  |L1.312|
000138  78e0              LDRB     r0,[r4,#3]            ;684  ; I2Cstate
00013a  1e40              SUBS     r0,r0,#1              ;684
00013c  e7c5              B        |L1.202|
00013e  48a5              LDR      r0,|L1.980|
000140  6800              LDR      r0,[r0,#0]            ;704  ; write_msg
000142  6881              LDR      r1,[r0,#8]            ;704
000144  6909              LDR      r1,[r1,#0x10]         ;704
000146  6902              LDR      r2,[r0,#0x10]         ;704
000148  4211              TST      r1,r2                 ;704
00014a  d06a              BEQ      |L1.546|
                  |L1.332|
00014c  e7fe              B        |L1.332|
00014e  49a1              LDR      r1,|L1.980|
000150  6808              LDR      r0,[r1,#0]            ;720  ; write_msg
000152  68c2              LDR      r2,[r0,#0xc]          ;720
000154  6843              LDR      r3,[r0,#4]            ;720
000156  835a              STRH     r2,[r3,#0x1a]         ;720
000158  794a              LDRB     r2,[r1,#5]            ;721  ; write_msg
00015a  7861              LDRB     r1,[r4,#1]            ;721  ; m
00015c  420a              TST      r2,r1                 ;721
00015e  d17d              BNE      |L1.604|
000160  e0aa              B        |L1.696|
000162  489c              LDR      r0,|L1.980|
000164  6800              LDR      r0,[r0,#0]            ;728  ; write_msg
000166  68c1              LDR      r1,[r0,#0xc]          ;728
000168  6840              LDR      r0,[r0,#4]            ;728
00016a  8301              STRH     r1,[r0,#0x18]         ;728
00016c  7860              LDRB     r0,[r4,#1]            ;729  ; m
00016e  2800              CMP      r0,#0                 ;729
000170  d1e2              BNE      |L1.312|
000172  e7a8              B        |L1.198|
000174  4897              LDR      r0,|L1.980|
000176  6800              LDR      r0,[r0,#0]            ;749  ; write_msg
000178  6881              LDR      r1,[r0,#8]            ;749
00017a  690a              LDR      r2,[r1,#0x10]         ;749
00017c  6901              LDR      r1,[r0,#0x10]         ;749
00017e  420a              TST      r2,r1                 ;749
000180  d04f              BEQ      |L1.546|
                  |L1.386|
000182  e7fe              B        |L1.386|
000184  4893              LDR      r0,|L1.980|
000186  6800              LDR      r0,[r0,#0]            ;796  ; read_msg
000188  6901              LDR      r1,[r0,#0x10]         ;796
00018a  6880              LDR      r0,[r0,#8]            ;796
00018c  8341              STRH     r1,[r0,#0x1a]         ;796
00018e  78e0              LDRB     r0,[r4,#3]            ;797  ; I2Cstate
000190  1c40              ADDS     r0,r0,#1              ;797
000192  70e0              STRB     r0,[r4,#3]            ;797
000194  f000b914          B.W      |L1.960|
000198  488e              LDR      r0,|L1.980|
;;;837                    
;;;838        case 0x1A: // read ack and reset clock (part 2)
;;;839          if ((!!(GPIO_READ(read_msg.IFACE->GPIO_SDA) & read_msg.IFACE->PIN_SDA)) != I2C_ACK)
;;;840          {
;;;841            assert(0);
;;;842            I2Cstate = 0x35;
;;;843          }
;;;844          else // success
;;;845          {
;;;846            I2Cstate++;
;;;847          }
;;;848          GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;849          GPIO_RESET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
;;;850          // wait
;;;851          break;
;;;852          
;;;853        //// send word address ////
;;;854        case 0x1B: // reset clock, set data (part 1 x 8)
;;;855          GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;856          (m & read_msg.ADDR_WORD) ? GPIO_SET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA) : GPIO_RESET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
;;;857          m >>= 1;
;;;858          I2Cstate++;
;;;859          // wait
;;;860          break;
;;;861        
;;;862        case 0x1C: // set clock (part 2 x 8)
;;;863          GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;864          m == 0 ? I2Cstate++ : I2Cstate--;
;;;865          // wait
;;;866          break;
;;;867        
;;;868        case 0x1D: // end with a clock reset and reset m (part 3)
;;;869          GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;870          m = 0x80; // reset m
;;;871          I2Cstate++;
;;;872          // wait
;;;873          break;
;;;874          
;;;875        //// receive ack ////
;;;876        case 0x1E: // set clock and data (part 1)
;;;877          GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;878          GPIO_SET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
;;;879          I2Cstate++;
;;;880          // wait
;;;881          break;
;;;882                    
;;;883        case 0x1F: // read data and reset clock (part 2)
;;;884          if ((!!(GPIO_READ(read_msg.IFACE->GPIO_SDA) & read_msg.IFACE->PIN_SDA)) != I2C_ACK)
;;;885          {
;;;886            assert(0);
;;;887            I2Cstate = 0x35;
;;;888          }
;;;889          else // success
;;;890          {
;;;891            I2Cstate++;
;;;892          }
;;;893          GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;894          GPIO_RESET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
;;;895          // wait
;;;896          break;
;;;897         
;;;898        //// stop condition ////
;;;899        case 0x20: // set clock (part 1)
;;;900          GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
00019a  6800              LDR      r0,[r0,#0]  ; read_msg
00019c  68c1              LDR      r1,[r0,#0xc]
00019e  6840              LDR      r0,[r0,#4]
0001a0  8301              STRH     r1,[r0,#0x18]
;;;901          I2Cstate++;
0001a2  78e0              LDRB     r0,[r4,#3]  ; I2Cstate
0001a4  1c40              ADDS     r0,r0,#1
0001a6  70e0              STRB     r0,[r4,#3]
;;;902          // wait
;;;903          break;
0001a8  f000b90a          B.W      |L1.960|
0001ac  4889              LDR      r0,|L1.980|
0001ae  6800              LDR      r0,[r0,#0]            ;777  ; write_msg
0001b0  6901              LDR      r1,[r0,#0x10]         ;777
0001b2  6880              LDR      r0,[r0,#8]            ;777
0001b4  8301              STRH     r1,[r0,#0x18]         ;777
0001b6  6860              LDR      r0,[r4,#4]            ;778  ; long_count
0001b8  f5a07100          SUB      r1,r0,#0x200          ;778
0001bc  39ee              SUBS     r1,r1,#0xee           ;778
0001be  bf08              IT       EQ                    ;780
0001c0  78e0              LDRBEQ   r0,[r4,#3]            ;780  ; I2Cstate
0001c2  f1000001          ADD      r0,r0,#1              ;785
0001c6  bf06              ITTE     EQ                    ;780
0001c8  70e0              STRBEQ   r0,[r4,#3]            ;780
0001ca  6065              STREQ    r5,[r4,#4]            ;781  ; long_count
0001cc  6060              STRNE    r0,[r4,#4]            ;785  ; long_count
0001ce  f000b8f7          B.W      |L1.960|
0001d2  6800              LDR      r0,[r0,#0]            ;810  ; read_msg
0001d4  68c1              LDR      r1,[r0,#0xc]          ;810
0001d6  6842              LDR      r2,[r0,#4]            ;810
0001d8  8351              STRH     r1,[r2,#0x1a]         ;810
0001da  7802              LDRB     r2,[r0,#0]            ;811
0001dc  7861              LDRB     r1,[r4,#1]            ;811  ; m
0001de  420a              TST      r2,r1                 ;811
0001e0  d166              BNE      |L1.688|
0001e2  e069              B        |L1.696|
0001e4  6800              LDR      r0,[r0,#0]            ;818  ; read_msg
0001e6  68c1              LDR      r1,[r0,#0xc]          ;818
0001e8  6840              LDR      r0,[r0,#4]            ;818
0001ea  8301              STRH     r1,[r0,#0x18]         ;818
0001ec  7860              LDRB     r0,[r4,#1]            ;819  ; m
0001ee  2800              CMP      r0,#0                 ;819
0001f0  d1a2              BNE      |L1.312|
0001f2  e768              B        |L1.198|
                  |L1.500|
0001f4  e015              B        |L1.546|
0001f6  e0d5              B        |L1.932|
0001f8  e0c9              B        |L1.910|
0001fa  e0b6              B        |L1.874|
0001fc  e0a1              B        |L1.834|
0001fe  e095              B        |L1.812|
000200  e089              B        |L1.790|
000202  e074              B        |L1.750|
000204  e065              B        |L1.722|
000206  e05b              B        |L1.704|
000208  e04a              B        |L1.672|
00020a  e041              B        |L1.656|
00020c  e030              B        |L1.624|
00020e  e026              B        |L1.606|
000210  e012              B        |L1.568|
000212  e7ff              B        |L1.532|
                  |L1.532|
000214  6800              LDR      r0,[r0,#0]            ;839  ; read_msg
000216  6881              LDR      r1,[r0,#8]            ;839
000218  6909              LDR      r1,[r1,#0x10]         ;839
00021a  6902              LDR      r2,[r0,#0x10]         ;839
00021c  4211              TST      r1,r2                 ;839
00021e  d000              BEQ      |L1.546|
                  |L1.544|
000220  e7fe              B        |L1.544|
                  |L1.546|
000222  78e1              LDRB     r1,[r4,#3]            ;846  ; I2Cstate
000224  1c49              ADDS     r1,r1,#1              ;846
000226  70e1              STRB     r1,[r4,#3]            ;846
000228  68c1              LDR      r1,[r0,#0xc]          ;848
00022a  6842              LDR      r2,[r0,#4]            ;848
00022c  8351              STRH     r1,[r2,#0x1a]         ;848
00022e  6901              LDR      r1,[r0,#0x10]         ;849
000230  6880              LDR      r0,[r0,#8]            ;849
000232  8341              STRH     r1,[r0,#0x1a]         ;849
000234  f000b8c4          B.W      |L1.960|
                  |L1.568|
000238  6801              LDR      r1,[r0,#0]            ;855  ; read_msg
00023a  68ca              LDR      r2,[r1,#0xc]          ;855
00023c  684b              LDR      r3,[r1,#4]            ;855
00023e  835a              STRH     r2,[r3,#0x1a]         ;855
000240  7902              LDRB     r2,[r0,#4]            ;856  ; read_msg
000242  7860              LDRB     r0,[r4,#1]            ;856  ; m
000244  4202              TST      r2,r0                 ;856
000246  690a              LDR      r2,[r1,#0x10]         ;856
000248  6889              LDR      r1,[r1,#8]            ;856
00024a  bf14              ITE      NE                    ;856
00024c  830a              STRHNE   r2,[r1,#0x18]         ;856
00024e  834a              STRHEQ   r2,[r1,#0x1a]         ;856
000250  0840              LSRS     r0,r0,#1              ;857
000252  7060              STRB     r0,[r4,#1]            ;857
000254  78e0              LDRB     r0,[r4,#3]            ;858  ; I2Cstate
000256  1c40              ADDS     r0,r0,#1              ;858
000258  70e0              STRB     r0,[r4,#3]            ;858
00025a  e0b1              B        |L1.960|
                  |L1.604|
00025c  e028              B        |L1.688|
                  |L1.606|
00025e  6800              LDR      r0,[r0,#0]            ;863  ; read_msg
000260  68c1              LDR      r1,[r0,#0xc]          ;863
000262  6840              LDR      r0,[r0,#4]            ;863
000264  8301              STRH     r1,[r0,#0x18]         ;863
000266  7860              LDRB     r0,[r4,#1]            ;864  ; m
000268  2800              CMP      r0,#0                 ;864
00026a  f47faf65          BNE      |L1.312|
00026e  e72a              B        |L1.198|
                  |L1.624|
000270  6800              LDR      r0,[r0,#0]            ;884  ; read_msg
000272  6881              LDR      r1,[r0,#8]            ;884
000274  6909              LDR      r1,[r1,#0x10]         ;884
000276  6902              LDR      r2,[r0,#0x10]         ;884
000278  4211              TST      r1,r2                 ;884
00027a  d000              BEQ      |L1.638|
                  |L1.636|
00027c  e7fe              B        |L1.636|
                  |L1.638|
00027e  78e1              LDRB     r1,[r4,#3]            ;891  ; I2Cstate
000280  1c49              ADDS     r1,r1,#1              ;891
000282  70e1              STRB     r1,[r4,#3]            ;891
000284  68c1              LDR      r1,[r0,#0xc]          ;893
000286  6842              LDR      r2,[r0,#4]            ;893
000288  8351              STRH     r1,[r2,#0x1a]         ;893
00028a  6901              LDR      r1,[r0,#0x10]         ;894
00028c  6880              LDR      r0,[r0,#8]            ;894
00028e  e02c              B        |L1.746|
                  |L1.656|
;;;904    
;;;905        case 0x21: // set data (part 2)
;;;906          GPIO_SET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
000290  6800              LDR      r0,[r0,#0]  ; read_msg
000292  6901              LDR      r1,[r0,#0x10]
000294  6880              LDR      r0,[r0,#8]
000296  8301              STRH     r1,[r0,#0x18]
;;;907          I2Cstate++;
000298  78e0              LDRB     r0,[r4,#3]  ; I2Cstate
00029a  1c40              ADDS     r0,r0,#1
00029c  70e0              STRB     r0,[r4,#3]
;;;908          // wait
;;;909          break;
00029e  e08f              B        |L1.960|
                  |L1.672|
;;;910         
;;;911        //// send a start bit ////
;;;912        case 0x22:  // start bit (part 1)
;;;913          GPIO_RESET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
;;;914          I2Cstate++;
;;;915          // wait
;;;916          break;
;;;917        
;;;918        case 0x23: // start bit (part 2)
;;;919          GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;920          I2Cstate++;
;;;921          // wait
;;;922          break;
;;;923        
;;;924        //// send slave_read address ////
;;;925        case 0x24: // reset clock, set data (part 1 x 8)
;;;926          GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
0002a0  6800              LDR      r0,[r0,#0]  ; read_msg
0002a2  68c1              LDR      r1,[r0,#0xc]
0002a4  6842              LDR      r2,[r0,#4]
0002a6  8351              STRH     r1,[r2,#0x1a]
;;;927          (m & read_msg.IFACE->ADDR_SLAVE_R) ? GPIO_SET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA) : GPIO_RESET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
0002a8  7842              LDRB     r2,[r0,#1]
0002aa  7861              LDRB     r1,[r4,#1]  ; m
0002ac  420a              TST      r2,r1
0002ae  d003              BEQ      |L1.696|
                  |L1.688|
0002b0  6902              LDR      r2,[r0,#0x10]
0002b2  6880              LDR      r0,[r0,#8]
0002b4  8302              STRH     r2,[r0,#0x18]
0002b6  e6f7              B        |L1.168|
                  |L1.696|
0002b8  6902              LDR      r2,[r0,#0x10]
0002ba  6880              LDR      r0,[r0,#8]
0002bc  8342              STRH     r2,[r0,#0x1a]
0002be  e6f3              B        |L1.168|
                  |L1.704|
;;;928          m >>= 1;
;;;929          I2Cstate++;
;;;930          // wait
;;;931          break;
;;;932        
;;;933        case 0x25: // set clock (part 2 x 8)
;;;934          GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
0002c0  6800              LDR      r0,[r0,#0]  ; read_msg
0002c2  68c1              LDR      r1,[r0,#0xc]
0002c4  6840              LDR      r0,[r0,#4]
0002c6  8301              STRH     r1,[r0,#0x18]
;;;935          m == 0 ? I2Cstate++ : I2Cstate--;
0002c8  7860              LDRB     r0,[r4,#1]  ; m
0002ca  2800              CMP      r0,#0
0002cc  f47faf34          BNE      |L1.312|
0002d0  e6f9              B        |L1.198|
                  |L1.722|
;;;936          // wait
;;;937          break;
;;;938        
;;;939        case 0x26: // end with a clock reset, and reset m (part 3)
;;;940          GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL); 
;;;941          m = 0x80; // reset m
;;;942          I2Cstate++;
;;;943          // wait
;;;944          break;
;;;945          
;;;946        //// receive ack ////
;;;947        case 0x27: // set clock and data (part 1)
;;;948          GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;949          GPIO_SET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
;;;950          I2Cstate++;
;;;951          // wait
;;;952          break;
;;;953                    
;;;954        case 0x28: // read data and reset clock (part 2)
;;;955          if ((!!(GPIO_READ(read_msg.IFACE->GPIO_SDA) & read_msg.IFACE->PIN_SDA)) != I2C_ACK)
0002d2  6800              LDR      r0,[r0,#0]  ; read_msg
0002d4  6881              LDR      r1,[r0,#8]
0002d6  6909              LDR      r1,[r1,#0x10]
0002d8  6902              LDR      r2,[r0,#0x10]
0002da  4211              TST      r1,r2
0002dc  d000              BEQ      |L1.736|
                  |L1.734|
;;;956          {
;;;957            assert(0);
0002de  e7fe              B        |L1.734|
                  |L1.736|
;;;958            I2Cstate = 0x35;
;;;959          }
;;;960          else // success
;;;961          {
;;;962            I2Cstate++;
0002e0  78e1              LDRB     r1,[r4,#3]  ; I2Cstate
0002e2  1c49              ADDS     r1,r1,#1
0002e4  70e1              STRB     r1,[r4,#3]
;;;963          }
;;;964          GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
0002e6  68c1              LDR      r1,[r0,#0xc]
0002e8  6840              LDR      r0,[r0,#4]
                  |L1.746|
0002ea  8341              STRH     r1,[r0,#0x1a]
0002ec  e068              B        |L1.960|
                  |L1.750|
;;;965          //GPIO_RESET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA); // (let data continue to float?!) TODO, fix the others in ACK. maybe they don't need it?
;;;966          // wait
;;;967          break;
;;;968    
;;;969        //// read data 1 ////
;;;970        case 0x29: // set clock high, read data (part 1)
;;;971          GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
0002ee  6801              LDR      r1,[r0,#0]  ; read_msg
0002f0  68ca              LDR      r2,[r1,#0xc]
0002f2  684b              LDR      r3,[r1,#4]
0002f4  831a              STRH     r2,[r3,#0x18]
;;;972          read_msg.DATA[0] |= ((!!(GPIO_READ(read_msg.IFACE->GPIO_SDA) & read_msg.IFACE->PIN_SDA)));
0002f6  688a              LDR      r2,[r1,#8]
0002f8  6912              LDR      r2,[r2,#0x10]
0002fa  6909              LDR      r1,[r1,#0x10]
0002fc  4011              ANDS     r1,r1,r2
0002fe  bf18              IT       NE
000300  2101              MOVNE    r1,#1
000302  7942              LDRB     r2,[r0,#5]  ; read_msg
000304  4311              ORRS     r1,r1,r2
000306  7141              STRB     r1,[r0,#5]
;;;973          bits++;
000308  7820              LDRB     r0,[r4,#0]  ; bits
00030a  1c40              ADDS     r0,r0,#1
00030c  7020              STRB     r0,[r4,#0]
;;;974          I2Cstate++;
00030e  78e0              LDRB     r0,[r4,#3]  ; I2Cstate
000310  1c40              ADDS     r0,r0,#1
000312  70e0              STRB     r0,[r4,#3]
000314  e054              B        |L1.960|
                  |L1.790|
;;;975          // wait
;;;976          break;
;;;977          
;;;978        case 0x2A: // set clock low
;;;979          GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
000316  6801              LDR      r1,[r0,#0]  ; read_msg
000318  68ca              LDR      r2,[r1,#0xc]
00031a  6849              LDR      r1,[r1,#4]
00031c  834a              STRH     r2,[r1,#0x1a]
;;;980          if(bits == 8)
00031e  7821              LDRB     r1,[r4,#0]  ; bits
000320  2908              CMP      r1,#8
000322  d02f              BEQ      |L1.900|
;;;981          {
;;;982            I2Cstate++;
;;;983            bits = 0;
;;;984          }
;;;985          else
;;;986          {
;;;987            read_msg.DATA[0] <<= 1;
000324  7941              LDRB     r1,[r0,#5]  ; read_msg
000326  0049              LSLS     r1,r1,#1
000328  7141              STRB     r1,[r0,#5]
;;;988            I2Cstate--;
00032a  e705              B        |L1.312|
                  |L1.812|
;;;989          }
;;;990          // wait
;;;991          break;
;;;992        
;;;993        //// send ack ////
;;;994        case 0x2B: // set the ack
;;;995          I2C_ACK == 0 ? GPIO_RESET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA) : GPIO_SET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
;;;996          I2Cstate++;
;;;997          // wait
;;;998          break;
;;;999          
;;;1000       case 0x2C: // clock high
;;;1001         GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;1002         I2Cstate++;
;;;1003         // wait
;;;1004         break;
;;;1005         
;;;1006       case 0x2D: // clock low, let data float
;;;1007         GPIO_SET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
00032c  6800              LDR      r0,[r0,#0]  ; read_msg
00032e  6901              LDR      r1,[r0,#0x10]
000330  6882              LDR      r2,[r0,#8]
000332  8311              STRH     r1,[r2,#0x18]
;;;1008         GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
000334  68c1              LDR      r1,[r0,#0xc]
000336  6840              LDR      r0,[r0,#4]
000338  8341              STRH     r1,[r0,#0x1a]
;;;1009         I2Cstate++;
00033a  78e0              LDRB     r0,[r4,#3]  ; I2Cstate
00033c  1c40              ADDS     r0,r0,#1
00033e  70e0              STRB     r0,[r4,#3]
;;;1010         // wait
;;;1011         break;
000340  e03e              B        |L1.960|
                  |L1.834|
;;;1012         
;;;1013       //// read data 2 ////
;;;1014       case 0x2E: // set clock high, read data (part 1)
;;;1015         GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
000342  6801              LDR      r1,[r0,#0]  ; read_msg
000344  68ca              LDR      r2,[r1,#0xc]
000346  684b              LDR      r3,[r1,#4]
000348  831a              STRH     r2,[r3,#0x18]
;;;1016         read_msg.DATA[1] |= ((!!(GPIO_READ(read_msg.IFACE->GPIO_SDA) & read_msg.IFACE->PIN_SDA)));
00034a  688a              LDR      r2,[r1,#8]
00034c  6912              LDR      r2,[r2,#0x10]
00034e  6909              LDR      r1,[r1,#0x10]
000350  4011              ANDS     r1,r1,r2
000352  bf18              IT       NE
000354  2101              MOVNE    r1,#1
000356  7982              LDRB     r2,[r0,#6]  ; read_msg
000358  4311              ORRS     r1,r1,r2
00035a  7181              STRB     r1,[r0,#6]
;;;1017         bits++;
00035c  7820              LDRB     r0,[r4,#0]  ; bits
00035e  1c40              ADDS     r0,r0,#1
000360  7020              STRB     r0,[r4,#0]
;;;1018         I2Cstate++;
000362  78e0              LDRB     r0,[r4,#3]  ; I2Cstate
000364  1c40              ADDS     r0,r0,#1
000366  70e0              STRB     r0,[r4,#3]
000368  e02a              B        |L1.960|
                  |L1.874|
;;;1019         // wait
;;;1020         break;
;;;1021         
;;;1022       case 0x2F: // set clock low
;;;1023         GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
00036a  6801              LDR      r1,[r0,#0]  ; read_msg
00036c  68ca              LDR      r2,[r1,#0xc]
00036e  6849              LDR      r1,[r1,#4]
000370  834a              STRH     r2,[r1,#0x1a]
;;;1024         if(bits == 8)
000372  7821              LDRB     r1,[r4,#0]  ; bits
000374  2908              CMP      r1,#8
000376  d005              BEQ      |L1.900|
;;;1025         {
;;;1026           I2Cstate++;
;;;1027           bits = 0;
;;;1028         }
;;;1029         else
;;;1030         {
;;;1031           read_msg.DATA[1] <<= 1;
000378  7981              LDRB     r1,[r0,#6]  ; read_msg
00037a  0049              LSLS     r1,r1,#1
00037c  7181              STRB     r1,[r0,#6]
;;;1032           I2Cstate--;
00037e  78e0              LDRB     r0,[r4,#3]  ; I2Cstate
000380  1e40              SUBS     r0,r0,#1
000382  e6a2              B        |L1.202|
                  |L1.900|
000384  78e0              LDRB     r0,[r4,#3]            ;1026  ; I2Cstate
000386  1c40              ADDS     r0,r0,#1              ;1026
000388  70e0              STRB     r0,[r4,#3]            ;1026
00038a  7025              STRB     r5,[r4,#0]            ;1027
00038c  e018              B        |L1.960|
                  |L1.910|
;;;1033         }
;;;1034         // wait
;;;1035         break;
;;;1036         
;;;1037       //// send nack ////
;;;1038       case 0x30: // set the nack
;;;1039         I2C_ACK == 0 ? GPIO_SET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA) : GPIO_RESET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
;;;1040         I2Cstate++;
;;;1041         // wait
;;;1042         break;
;;;1043         
;;;1044       case 0x31: // clock high
;;;1045         GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;1046         I2Cstate++;
;;;1047         // wait
;;;1048         break;    
;;;1049       
;;;1050       //// stop condition (SUCCESS)////
;;;1051       case 0x32: // reset data (part 1)
;;;1052         GPIO_RESET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
00038e  6800              LDR      r0,[r0,#0]  ; read_msg
000390  6901              LDR      r1,[r0,#0x10]
000392  6882              LDR      r2,[r0,#8]
000394  8351              STRH     r1,[r2,#0x1a]
;;;1053         GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
000396  68c1              LDR      r1,[r0,#0xc]
000398  6840              LDR      r0,[r0,#4]
00039a  8341              STRH     r1,[r0,#0x1a]
;;;1054         I2Cstate++;
00039c  78e0              LDRB     r0,[r4,#3]  ; I2Cstate
00039e  1c40              ADDS     r0,r0,#1
0003a0  70e0              STRB     r0,[r4,#3]
;;;1055         // wait
;;;1056         break;
0003a2  e00d              B        |L1.960|
                  |L1.932|
;;;1057         
;;;1058       case 0x33: // set clock (part 2)
;;;1059         GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;1060         I2Cstate++;
;;;1061         // wait
;;;1062         break;
;;;1063   
;;;1064       case 0x34: // set data (part 3)
;;;1065         GPIO_SET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
0003a4  6800              LDR      r0,[r0,#0]  ; read_msg
0003a6  6901              LDR      r1,[r0,#0x10]
0003a8  6880              LDR      r0,[r0,#8]
0003aa  8301              STRH     r1,[r0,#0x18]
;;;1066         #ifdef I2C_TRIGGER
;;;1067         GPIO_RESET(GPIO_TRIGGER, PIN_TRIGGER);
0003ac  490a              LDR      r1,|L1.984|
0003ae  f44f6000          MOV      r0,#0x800
0003b2  8008              STRH     r0,[r1,#0]
;;;1068         #endif
;;;1069         TIM_ITConfig(TIM7, TIM_IT_Update, DISABLE); // Disable interrupt
0003b4  2200              MOVS     r2,#0
0003b6  2101              MOVS     r1,#1
0003b8  4808              LDR      r0,|L1.988|
0003ba  f7fffffe          BL       TIM_ITConfig
;;;1070         I2Cstate = 0;
0003be  70e5              STRB     r5,[r4,#3]
                  |L1.960|
;;;1071         // wait
;;;1072         break;
;;;1073         
;;;1074       //// stop condition (FAILURE) ////
;;;1075       case 0x35: // reset data (part 1)
;;;1076         GPIO_RESET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
;;;1077         GPIO_RESET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;1078         I2Cstate++;
;;;1079         // wait
;;;1080         break;
;;;1081         
;;;1082       case 0x36: // set clock (part 2)
;;;1083         GPIO_SET(read_msg.IFACE->GPIO_SCL, read_msg.IFACE->PIN_SCL);
;;;1084         I2Cstate++;
;;;1085         // wait
;;;1086         break;
;;;1087   
;;;1088       case 0x37: // set data (part 3)
;;;1089         GPIO_SET(read_msg.IFACE->GPIO_SDA, read_msg.IFACE->PIN_SDA);
;;;1090         #ifdef I2C_TRIGGER
;;;1091         GPIO_RESET(GPIO_TRIGGER, PIN_TRIGGER);
;;;1092         #endif
;;;1093         TIM_ITConfig(TIM7, TIM_IT_Update, DISABLE); // Disable interrupt
;;;1094         I2Cstate = 0;
;;;1095         // wait
;;;1096         break;
;;;1097     }
;;;1098     TIM7->CR1 = TIM_CR1_CEN | TIM_CR1_URS | TIM_CR1_OPM; // Fire off one pulse
0003c0  4906              LDR      r1,|L1.988|
0003c2  200d              MOVS     r0,#0xd
0003c4  8008              STRH     r0,[r1,#0]
;;;1099   //   TIM7->CR1 |= 0x01;           // Ensable Counter
;;;1100   }
0003c6  bd70              POP      {r4-r6,pc}
;;;1101   
                          ENDP

                  |L1.968|
                          DCD      0x40001410
                  |L1.972|
                          DCD      ||.data||
                  |L1.976|
                          DCD      0x40020418
                  |L1.980|
                          DCD      ||.data||+0x10
                  |L1.984|
                          DCD      0x4002041a
                  |L1.988|
                          DCD      0x40001400

                          AREA ||i._ZN4Anki5Cozmo3HAL10SensorInitEP12I2CInterface||, CODE, READONLY, ALIGN=1

                  _ZN4Anki5Cozmo3HAL10SensorInitEP12I2CInterface PROC ; Anki::Cozmo::HAL::SensorInit(I2CInterface*)
;;;362    
;;;363          static void SensorInit(I2CInterface *iface)
000000  b510              PUSH     {r4,lr}
;;;364          {
000002  4604              MOV      r4,r0
;;;365            data_write(iface, 0x01, PRST_1 | RES_A_14BIT | RANGE_A_X8);
000004  2223              MOVS     r2,#0x23
000006  2101              MOVS     r1,#1
000008  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10data_writeEP12I2CInterfaceii ; Anki::Cozmo::HAL::data_write(I2CInterface*, int, int)
;;;366            data_write(iface, 0x02, INTTYPE_PULSE | RES_P_10BIT | RANGE_P_X8);
00000c  225b              MOVS     r2,#0x5b
00000e  2102              MOVS     r1,#2
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10data_writeEP12I2CInterfaceii ; Anki::Cozmo::HAL::data_write(I2CInterface*, int, int)
;;;367            data_write(iface, 0x03, INTVAL_0 | IS_130MA | PIN_FLAG_P );
000016  2230              MOVS     r2,#0x30
000018  2103              MOVS     r1,#3
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10data_writeEP12I2CInterfaceii ; Anki::Cozmo::HAL::data_write(I2CInterface*, int, int)
;;;368            data_write(iface, PL_LOW, 0x0F); // Set proximity sensor low threshold
000020  220f              MOVS     r2,#0xf
000022  2108              MOVS     r1,#8
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10data_writeEP12I2CInterfaceii ; Anki::Cozmo::HAL::data_write(I2CInterface*, int, int)
;;;369            data_write(iface, PL_HIGH, 0x00);
00002a  2200              MOVS     r2,#0
00002c  2109              MOVS     r1,#9
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10data_writeEP12I2CInterfaceii ; Anki::Cozmo::HAL::data_write(I2CInterface*, int, int)
;;;370            data_write(iface, PH_LOW, 0x0F); // Set proximity sensor high threshold
000034  220f              MOVS     r2,#0xf
000036  210a              MOVS     r1,#0xa
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10data_writeEP12I2CInterfaceii ; Anki::Cozmo::HAL::data_write(I2CInterface*, int, int)
;;;371            data_write(iface, PH_HIGH, 0x00); 
00003e  2200              MOVS     r2,#0
000040  210b              MOVS     r1,#0xb
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10data_writeEP12I2CInterfaceii ; Anki::Cozmo::HAL::data_write(I2CInterface*, int, int)
;;;372            data_write(iface, 0x00,  OP1_PS); // Enable sensor in PS mode, auto-shutdown, currently in shutdown
000048  4620              MOV      r0,r4
00004a  2220              MOVS     r2,#0x20
00004c  e8bd4010          POP      {r4,lr}
000050  2100              MOVS     r1,#0
000052  f7ffbffe          B.W      _ZN4Anki5Cozmo3HAL10data_writeEP12I2CInterfaceii ; Anki::Cozmo::HAL::data_write(I2CInterface*, int, int)
;;;373          }
;;;374    
                          ENDP


                          AREA ||i._ZN4Anki5Cozmo3HAL10data_writeEP12I2CInterfaceii||, CODE, READONLY, ALIGN=1

                  _ZN4Anki5Cozmo3HAL10data_writeEP12I2CInterfaceii PROC ; Anki::Cozmo::HAL::data_write(I2CInterface*, int, int)
;;;327          
;;;328          static void data_write(I2CInterface *iface, int word_addr, int write_data)
000000  b570              PUSH     {r4-r6,lr}
;;;329          {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  68a1              LDR      r1,[r4,#8]
000008  8a00              LDRH     r0,[r0,#0x10]
00000a  4615              MOV      r5,r2
00000c  8348              STRH     r0,[r1,#0x1a]
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
000014  6861              LDR      r1,[r4,#4]
000016  89a0              LDRH     r0,[r4,#0xc]
000018  8348              STRH     r0,[r1,#0x1a]
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
;;;330            unsigned char ack;
;;;331            
;;;332            Start(iface); //start condition     
;;;333            ack = Write((u8)(iface->ADDR_SLAVE_W), iface); //slave address send      
000020  7820              LDRB     r0,[r4,#0]
000022  4621              MOV      r1,r4
000024  f7fffffe          BL       _ZN4Anki5Cozmo3HAL5WriteEhP12I2CInterface ; Anki::Cozmo::HAL::Write(unsigned char, I2CInterface*)
000028  b940              CBNZ     r0,|L3.60|
;;;334            if (ack != I2C_ACK) {
;;;335              Stop(iface);
;;;336              //m_ErrorMsg();
;;;337              return;
;;;338            }
;;;339            ack = Write(word_addr, iface ); //word address send
00002a  b2f0              UXTB     r0,r6
00002c  4621              MOV      r1,r4
00002e  f7fffffe          BL       _ZN4Anki5Cozmo3HAL5WriteEhP12I2CInterface ; Anki::Cozmo::HAL::Write(unsigned char, I2CInterface*)
;;;340            if (ack != I2C_ACK) {
000032  b918              CBNZ     r0,|L3.60|
;;;341              Stop(iface);
;;;342              //m_ErrorMsg();
;;;343              return;
;;;344            }   
;;;345            ack = Write(write_data, iface); //write data send
000034  b2e8              UXTB     r0,r5
000036  4621              MOV      r1,r4
000038  f7fffffe          BL       _ZN4Anki5Cozmo3HAL5WriteEhP12I2CInterface ; Anki::Cozmo::HAL::Write(unsigned char, I2CInterface*)
                  |L3.60|
;;;346            if (ack != I2C_ACK) {
;;;347              Stop(iface);
;;;348              //m_ErrorMsg();
;;;349              return;
;;;350            }
;;;351            Stop(iface);
00003c  4620              MOV      r0,r4
00003e  e8bd4070          POP      {r4-r6,lr}
000042  f7ffbffe          B.W      _ZN4Anki5Cozmo3HAL4StopEP12I2CInterface ; Anki::Cozmo::HAL::Stop(I2CInterface*)
;;;352            
;;;353            return;
;;;354          }
;;;355    
                          ENDP


                          AREA ||i._ZN4Anki5Cozmo3HAL12GetProximityEPNS1_15ProximityValuesE||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_i
                          REQUIRE _printf_int_dec
                  _ZN4Anki5Cozmo3HAL12GetProximityEPNS1_15ProximityValuesE PROC ; Anki::Cozmo::HAL::GetProximity(Anki::Cozmo::HAL::ProximityValues*)
;;;503          // current order is left -> right -> forward
;;;504          void GetProximity(ProximityValues *prox)
000000  b570              PUSH     {r4-r6,lr}
;;;505          {
;;;506            static sharpID ID = IRleft;      
;;;507            static int count = 0;
;;;508            count++;
000002  4d32              LDR      r5,|L4.204|
000004  4604              MOV      r4,r0                 ;505
000006  2600              MOVS     r6,#0
000008  68a8              LDR      r0,[r5,#8]  ; count
00000a  1c40              ADDS     r0,r0,#1
;;;509            if(count == 100)
00000c  60a8              STR      r0,[r5,#8]  ; count
00000e  2864              CMP      r0,#0x64
000010  d103              BNE      |L4.26|
;;;510            {
;;;511              UARTPutString(".\r\n");
000012  a02f              ADR      r0,|L4.208|
000014  f7fffffe          BL       _ZN4Anki5Cozmo3HAL13UARTPutStringEPKc ; Anki::Cozmo::HAL::UARTPutString(const char*)
;;;512              count = 0;
000018  60ae              STR      r6,[r5,#8]  ; count
                  |L4.26|
;;;513            }
;;;514            
;;;515            // Only continue if we are robot #2;
;;;516            if (*(int*)(0x1FFF7A10) != 0x001d001d )
00001a  482e              LDR      r0,|L4.212|
00001c  6800              LDR      r0,[r0,#0]
00001e  f1b01f1d          CMP      r0,#0x1d001d
000022  d004              BEQ      |L4.46|
;;;517            {
;;;518              prox->forward = 0;
000024  80a6              STRH     r6,[r4,#4]
;;;519              prox->left = 0;
000026  8026              STRH     r6,[r4,#0]
;;;520              prox->right = 0;
000028  8066              STRH     r6,[r4,#2]
;;;521    	  prox->latest = IRleft;
00002a  71a6              STRB     r6,[r4,#6]
;;;522              return;
;;;523            }
;;;524            
;;;525    
;;;526            while (I2Cstate != 0) // both messages must be sent to proceed
;;;527            {
;;;528              MicroWait(1000);
;;;529              printf("State = %i (not hex!!)\r\n", I2Cstate);
;;;530            }
;;;531            
;;;532            switch(ID)
;;;533            {
;;;534              case IRforward:
;;;535                prox->latest = ID;
;;;536                ID = IRleft; // get left next
;;;537                prox->forward = (read_msg.DATA[1] & 0xFF) << 8 | (read_msg.DATA[0] & 0xFF);
;;;538                SetWriteMsg(&iface_left, 0x00, OP1_PS | OP3);   // schedule a write: wakeup, proximity mode
;;;539                SetReadMsg(&iface_left, D2_LOW); // schedule a read
;;;540                break;
;;;541                
;;;542              case IRleft:
;;;543                prox->latest = ID;
;;;544                ID = IRright; // get right next
;;;545                prox->left = (read_msg.DATA[1] & 0xFF) << 8 | (read_msg.DATA[0] & 0xFF);   
;;;546                SetWriteMsg(&iface_right, 0x00, OP1_PS | OP3); // schedule a write: wakeup, proximity mode
;;;547                SetReadMsg(&iface_right, D2_LOW); // schedule a read
;;;548                break;
;;;549                
;;;550              case IRright:
;;;551                prox->latest = ID;
;;;552                ID = IRforward; // get forward next
;;;553                prox->right = (read_msg.DATA[1] & 0xFF) << 8 | (read_msg.DATA[0] & 0xFF);   
;;;554                SetWriteMsg(&iface_forward, 0x00, OP1_PS | OP3);  // schedule a write: wakeup, proximity mode
;;;555                SetReadMsg(&iface_forward, D2_LOW); // schedule a read 
;;;556                break;  
;;;557            }
;;;558    /*
;;;559            if (read_msg.STATUS == I2C_FAILURE || write_msg.STATUS == I2C_FAILURE)
;;;560              prox->status = IR_I2C_ERROR;
;;;561            else if ( read_msg.DATA[1] > 3) // should only be 10 bits, rules out double read errors
;;;562              prox->status = IR_I2C_ERROR;
;;;563            else
;;;564              prox->status = IR_GOOD;
;;;565              
;;;566            write_msg.SENT_FLAG = I2C_UNSENT;
;;;567            read_msg.SENT_FLAG = I2C_UNSENT;
;;;568    */
;;;569            TIM_ITConfig(TIM7, TIM_IT_Update, ENABLE); // Enable interrupt
;;;570          }
00002c  bd70              POP      {r4-r6,pc}
                  |L4.46|
00002e  78e8              LDRB     r0,[r5,#3]            ;526  ; I2Cstate
000030  b150              CBZ      r0,|L4.72|
                  |L4.50|
000032  f44f707a          MOV      r0,#0x3e8             ;528
000036  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
00003a  78e9              LDRB     r1,[r5,#3]            ;529  ; I2Cstate
00003c  a026              ADR      r0,|L4.216|
00003e  f7fffffe          BL       __2printf
000042  78e8              LDRB     r0,[r5,#3]            ;526  ; I2Cstate
000044  2800              CMP      r0,#0                 ;526
000046  d1f4              BNE      |L4.50|
                  |L4.72|
000048  492a              LDR      r1,|L4.244|
00004a  78a8              LDRB     r0,[r5,#2]            ;532  ; ID
00004c  f04f0ca0          MOV      r12,#0xa0             ;538
000050  f1a10308          SUB      r3,r1,#8              ;538
000054  2210              MOVS     r2,#0x10              ;539
000056  b198              CBZ      r0,|L4.128|
000058  2801              CMP      r0,#1                 ;532
00005a  d002              BEQ      |L4.98|
00005c  2802              CMP      r0,#2                 ;532
00005e  d01f              BEQ      |L4.160|
000060  e02d              B        |L4.190|
                  |L4.98|
000062  71a0              STRB     r0,[r4,#6]            ;535
000064  70ae              STRB     r6,[r5,#2]            ;536
000066  7948              LDRB     r0,[r1,#5]            ;537  ; read_msg
000068  798d              LDRB     r5,[r1,#6]            ;537  ; read_msg
00006a  ea402005          ORR      r0,r0,r5,LSL #8       ;537
00006e  80a0              STRH     r0,[r4,#4]            ;537
000070  4821              LDR      r0,|L4.248|
000072  6018              STR      r0,[r3,#0]            ;538  ; write_msg
000074  711e              STRB     r6,[r3,#4]            ;538
000076  f883c005          STRB     r12,[r3,#5]           ;538
00007a  6008              STR      r0,[r1,#0]            ;538  ; read_msg
00007c  710a              STRB     r2,[r1,#4]            ;538
00007e  e01e              B        |L4.190|
                  |L4.128|
000080  71a0              STRB     r0,[r4,#6]            ;543
000082  2002              MOVS     r0,#2                 ;544
000084  70a8              STRB     r0,[r5,#2]            ;544
000086  7948              LDRB     r0,[r1,#5]            ;545  ; read_msg
000088  798d              LDRB     r5,[r1,#6]            ;545  ; read_msg
00008a  ea402005          ORR      r0,r0,r5,LSL #8       ;545
00008e  8020              STRH     r0,[r4,#0]            ;545
000090  481a              LDR      r0,|L4.252|
000092  6018              STR      r0,[r3,#0]            ;546  ; write_msg
000094  711e              STRB     r6,[r3,#4]            ;546
000096  f883c005          STRB     r12,[r3,#5]           ;546
00009a  6008              STR      r0,[r1,#0]            ;546  ; read_msg
00009c  710a              STRB     r2,[r1,#4]            ;546
00009e  e00e              B        |L4.190|
                  |L4.160|
0000a0  71a0              STRB     r0,[r4,#6]            ;551
0000a2  2001              MOVS     r0,#1                 ;552
0000a4  70a8              STRB     r0,[r5,#2]            ;552
0000a6  7948              LDRB     r0,[r1,#5]            ;553  ; read_msg
0000a8  798d              LDRB     r5,[r1,#6]            ;553  ; read_msg
0000aa  ea402005          ORR      r0,r0,r5,LSL #8       ;553
0000ae  8060              STRH     r0,[r4,#2]            ;553
0000b0  4813              LDR      r0,|L4.256|
0000b2  6018              STR      r0,[r3,#0]            ;554  ; write_msg
0000b4  711e              STRB     r6,[r3,#4]            ;554
0000b6  f883c005          STRB     r12,[r3,#5]           ;554
0000ba  6008              STR      r0,[r1,#0]            ;554  ; read_msg
0000bc  710a              STRB     r2,[r1,#4]            ;554
                  |L4.190|
0000be  e8bd4070          POP      {r4-r6,lr}            ;569
0000c2  2201              MOVS     r2,#1                 ;569
0000c4  4611              MOV      r1,r2                 ;569
0000c6  480f              LDR      r0,|L4.260|
0000c8  f7ffbffe          B.W      TIM_ITConfig
;;;571          
                          ENDP

                  |L4.204|
                          DCD      ||.data||
                  |L4.208|
0000d0  2e0d0a00          DCB      ".\r\n",0
                  |L4.212|
                          DCD      0x1fff7a10
                  |L4.216|
0000d8  53746174          DCB      "State = %i (not hex!!)\r\n",0
0000dc  65203d20
0000e0  25692028
0000e4  6e6f7420
0000e8  68657821
0000ec  21290d0a
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L4.244|
                          DCD      ||.data||+0x18
                  |L4.248|
                          DCD      ||.bss||
                  |L4.252|
                          DCD      ||.bss||+0x28
                  |L4.256|
                          DCD      ||.bss||+0x14
                  |L4.260|
                          DCD      0x40001400

                          AREA ||i._ZN4Anki5Cozmo3HAL4StopEP12I2CInterface||, CODE, READONLY, ALIGN=1

                  _ZN4Anki5Cozmo3HAL4StopEP12I2CInterface PROC ; Anki::Cozmo::HAL::Stop(I2CInterface*)
;;;267          // Issue a Stop condition
;;;268          static void Stop(I2CInterface *iface)
000000  b510              PUSH     {r4,lr}
;;;269          {
000002  4604              MOV      r4,r0
000004  8a00              LDRH     r0,[r0,#0x10]
000006  68a1              LDR      r1,[r4,#8]
000008  8348              STRH     r0,[r1,#0x1a]
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
000010  6861              LDR      r1,[r4,#4]
000012  89a0              LDRH     r0,[r4,#0xc]
000014  8308              STRH     r0,[r1,#0x18]
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
00001c  68a1              LDR      r1,[r4,#8]
00001e  8a20              LDRH     r0,[r4,#0x10]
000020  8308              STRH     r0,[r1,#0x18]
000022  e8bd4010          POP      {r4,lr}
000026  2001              MOVS     r0,#1
000028  f7ffbffe          B.W      _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
;;;270            DriveSDA(0, iface);
;;;271            DriveSCL(1, iface);
;;;272            DriveSDA(1, iface);
;;;273          }
;;;274    
                          ENDP


                          AREA ||i._ZN4Anki5Cozmo3HAL5WriteEhP12I2CInterface||, CODE, READONLY, ALIGN=1

                  _ZN4Anki5Cozmo3HAL5WriteEhP12I2CInterface PROC ; Anki::Cozmo::HAL::Write(unsigned char, I2CInterface*)
;;;275          // Write byte and return true for Ack or false for Nak
;;;276          static u8 Write(u8 b,  I2CInterface *iface)
000000  b570              PUSH     {r4-r6,lr}
;;;277          {
000002  460c              MOV      r4,r1
000004  4606              MOV      r6,r0
;;;278            u8 m;
;;;279            // Write byte
;;;280            for (m = 0x80; m != 0; m >>= 1)
000006  2580              MOVS     r5,#0x80
                  |L6.8|
000008  8a21              LDRH     r1,[r4,#0x10]
00000a  68a0              LDR      r0,[r4,#8]
;;;281            {
;;;282              DriveSDA(m & b, iface);
00000c  4235              TST      r5,r6
00000e  bf14              ITE      NE
000010  8301              STRHNE   r1,[r0,#0x18]
000012  8341              STRHEQ   r1,[r0,#0x1a]
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
00001a  6861              LDR      r1,[r4,#4]
00001c  89a0              LDRH     r0,[r4,#0xc]
00001e  8308              STRH     r0,[r1,#0x18]
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
000026  6861              LDR      r1,[r4,#4]
000028  89a0              LDRH     r0,[r4,#0xc]
00002a  8348              STRH     r0,[r1,#0x1a]
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
000032  086d              LSRS     r5,r5,#1              ;280
000034  d1e8              BNE      |L6.8|
000036  6861              LDR      r1,[r4,#4]            ;280
000038  89a0              LDRH     r0,[r4,#0xc]          ;280
00003a  8308              STRH     r0,[r1,#0x18]         ;280
00003c  2001              MOVS     r0,#1                 ;280
00003e  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
000042  68a1              LDR      r1,[r4,#8]            ;280
000044  8a20              LDRH     r0,[r4,#0x10]         ;280
000046  8308              STRH     r0,[r1,#0x18]         ;280
000048  2001              MOVS     r0,#1                 ;280
00004a  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
00004e  68a0              LDR      r0,[r4,#8]            ;280
000050  6900              LDR      r0,[r0,#0x10]         ;280
000052  6921              LDR      r1,[r4,#0x10]         ;280
000054  4208              TST      r0,r1                 ;280
000056  bf14              ITE      NE                    ;280
000058  2501              MOVNE    r5,#1                 ;280
00005a  2500              MOVEQ    r5,#0                 ;280
00005c  89a1              LDRH     r1,[r4,#0xc]          ;280
00005e  6862              LDR      r2,[r4,#4]            ;280
000060  8351              STRH     r1,[r2,#0x1a]         ;280
000062  2001              MOVS     r0,#1                 ;280
000064  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
;;;283              DriveSCL(1, iface);
;;;284              DriveSCL(0, iface);
;;;285            }
;;;286    
;;;287            DriveSCL(1, iface);
;;;288            b = ReadSDA(iface);
;;;289            DriveSCL(0, iface);
;;;290    
;;;291            return b;
000068  4628              MOV      r0,r5
;;;292          }
00006a  bd70              POP      {r4-r6,pc}
;;;293    
                          ENDP


                          AREA ||i._ZN4Anki5Cozmo3HAL9SharpInitEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo3HAL9SharpInitEv PROC ; Anki::Cozmo::HAL::SharpInit()
;;;375    
;;;376          void SharpInit()
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;377          {
;;;378            // Set message sent flags (for interrupt operation)
;;;379            I2Cstate = 0;
000004  4854              LDR      r0,|L7.344|
000006  b087              SUB      sp,sp,#0x1c           ;377
000008  2500              MOVS     r5,#0
00000a  70c5              STRB     r5,[r0,#3]
;;;380           
;;;381            // Configure sharp sensors
;;;382            // forward
;;;383            iface_forward.ADDR_SLAVE_W       =   ADDR_SLAVE_W_L;
00000c  4853              LDR      r0,|L7.348|
00000e  2272              MOVS     r2,#0x72
;;;384            iface_forward.ADDR_SLAVE_R       =   ADDR_SLAVE_R_L;
000010  2373              MOVS     r3,#0x73
000012  7002              STRB     r2,[r0,#0]            ;383
;;;385            iface_forward.GPIO_SCL           =   GPIO_SCL;
;;;386            iface_forward.GPIO_SDA           =   GPIO_SDA1;
;;;387            iface_forward.PIN_SCL            =   PIN_SCL;
000014  2440              MOVS     r4,#0x40
000016  7043              STRB     r3,[r0,#1]            ;384
;;;388            iface_forward.PIN_SDA            =   PIN_SDA1;
000018  0127              LSLS     r7,r4,#4
00001a  e9c04703          STRD     r4,r7,[r0,#0xc]
00001e  f8df9144          LDR      r9,|L7.356|
000022  4e4f              LDR      r6,|L7.352|
000024  e9c06901          STRD     r6,r9,[r0,#4]
;;;389            
;;;390            // right
;;;391            iface_right.ADDR_SLAVE_W    =   ADDR_SLAVE_W_L;
000028  f1000114          ADD      r1,r0,#0x14
;;;392            iface_right.ADDR_SLAVE_R    =   ADDR_SLAVE_R_L;
;;;393            iface_right.GPIO_SCL        =   GPIO_SCL;
;;;394            iface_right.GPIO_SDA        =   GPIO_SDA2;
;;;395            iface_right.PIN_SCL         =   PIN_SCL;
;;;396            iface_right.PIN_SDA         =   PIN_SDA2;
00002c  f04f0880          MOV      r8,#0x80
000030  700a              STRB     r2,[r1,#0]            ;391
000032  704b              STRB     r3,[r1,#1]            ;392
000034  f8c18010          STR      r8,[r1,#0x10]  ; _ZN4Anki5Cozmo3HAL11iface_rightE
000038  604e              STR      r6,[r1,#4]  ; _ZN4Anki5Cozmo3HAL11iface_rightE
00003a  e9c16402          STRD     r6,r4,[r1,#8]
;;;397            
;;;398            // left
;;;399            iface_left.ADDR_SLAVE_W      =   ADDR_SLAVE_W_H;
00003e  3928              SUBS     r1,r1,#0x28
000040  2088              MOVS     r0,#0x88
000042  7008              STRB     r0,[r1,#0]
;;;400            iface_left.ADDR_SLAVE_R      =   ADDR_SLAVE_R_H;
000044  2089              MOVS     r0,#0x89
000046  7048              STRB     r0,[r1,#1]
000048  e9c14703          STRD     r4,r7,[r1,#0xc]
00004c  e9c16901          STRD     r6,r9,[r1,#4]
;;;401            iface_left.GPIO_SCL          =   GPIO_SCL;
;;;402            iface_left.GPIO_SDA          =   GPIO_SDA1;
;;;403            iface_left.PIN_SCL           =   PIN_SCL;
;;;404            iface_left.PIN_SDA           =   PIN_SDA1;
;;;405            
;;;406            
;;;407            // Enable GPIO clocks
;;;408            RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
000050  2101              MOVS     r1,#1
000052  2002              MOVS     r0,#2
000054  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;409            RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
000058  2101              MOVS     r1,#1
00005a  2008              MOVS     r0,#8
00005c  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;410            RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);
000060  2101              MOVS     r1,#1
000062  2020              MOVS     r0,#0x20
000064  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;411            
;;;412            // Init Gpio
;;;413            GPIO_SET(GPIO_SCL, PIN_SCL);
000068  483f              LDR      r0,|L7.360|
00006a  8004              STRH     r4,[r0,#0]
;;;414            GPIO_SET(GPIO_SDA1, PIN_SDA1);
00006c  493f              LDR      r1,|L7.364|
00006e  800f              STRH     r7,[r1,#0]
;;;415            GPIO_SET(GPIO_SDA2, PIN_SDA2);
000070  f8a08000          STRH     r8,[r0,#0]
;;;416            
;;;417            GPIO_InitTypeDef GPIO_InitStructure;
;;;418            GPIO_InitStructure.GPIO_Pin = PIN_SCL | PIN_SDA2;
;;;419            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000074  2401              MOVS     r4,#1
000076  f88d4004          STRB     r4,[sp,#4]
00007a  20c0              MOVS     r0,#0xc0              ;418
;;;420            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;   // This MUST be set fast otherwise reads are unreliable 
00007c  f88d4005          STRB     r4,[sp,#5]
000080  9000              STR      r0,[sp,#0]            ;419
;;;421            GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
000082  f88d4006          STRB     r4,[sp,#6]
;;;422            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;        // Changed to UP for reliability (some hardware might not have pullups???)
000086  f88d4007          STRB     r4,[sp,#7]
;;;423            GPIO_Init(GPIOD, &GPIO_InitStructure); 
00008a  4669              MOV      r1,sp
00008c  4630              MOV      r0,r6
00008e  f7fffffe          BL       GPIO_Init
;;;424            
;;;425            GPIO_InitStructure.GPIO_Pin = PIN_SDA1;
;;;426            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000092  f88d4004          STRB     r4,[sp,#4]
;;;427            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;   // This MUST be set fast otherwise reads are unreliable 
000096  f88d4005          STRB     r4,[sp,#5]
;;;428            GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
00009a  f88d4006          STRB     r4,[sp,#6]
00009e  9700              STR      r7,[sp,#0]            ;426
;;;429            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;        // Changed to UP for reliability (some hardware might not have pullups???)
0000a0  f88d4007          STRB     r4,[sp,#7]
;;;430            GPIO_Init(GPIOB, &GPIO_InitStructure); 
0000a4  4669              MOV      r1,sp
0000a6  4648              MOV      r0,r9
0000a8  f7fffffe          BL       GPIO_Init
;;;431            
;;;432            GPIO_InitStructure.GPIO_Pin = PIN_INT;
;;;433            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
0000ac  f88d5004          STRB     r5,[sp,#4]
;;;434            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;   // This MUST be set fast otherwise reads are unreliable 
0000b0  f88d4005          STRB     r4,[sp,#5]
;;;435            GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
0000b4  f88d4006          STRB     r4,[sp,#6]
0000b8  f8cd8000          STR      r8,[sp,#0]            ;433
;;;436            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
0000bc  f88d4007          STRB     r4,[sp,#7]
;;;437            GPIO_Init(GPIOF, &GPIO_InitStructure);     
0000c0  4669              MOV      r1,sp
0000c2  482b              LDR      r0,|L7.368|
0000c4  f7fffffe          BL       GPIO_Init
;;;438            
;;;439            #ifdef I2C_TRIGGER
;;;440            GPIO_InitStructure.GPIO_Pin = PIN_TRIGGER;   // test port pin
;;;441            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
0000c8  f88d4004          STRB     r4,[sp,#4]
0000cc  02e0              LSLS     r0,r4,#11             ;440
;;;442            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
0000ce  f88d5005          STRB     r5,[sp,#5]
0000d2  9000              STR      r0,[sp,#0]            ;441
;;;443            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
0000d4  f88d5006          STRB     r5,[sp,#6]
;;;444            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
0000d8  f88d5007          STRB     r5,[sp,#7]
;;;445            GPIO_Init(GPIOB, &GPIO_InitStructure); 
0000dc  4669              MOV      r1,sp
0000de  4648              MOV      r0,r9
0000e0  f7fffffe          BL       GPIO_Init
;;;446            #endif
;;;447    
;;;448    
;;;449            // Set for 250 kHz clk signal. 89/1 prescaleer/period
;;;450            TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
;;;451            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE);
0000e4  2101              MOVS     r1,#1
0000e6  2020              MOVS     r0,#0x20
0000e8  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;452            TIM_TimeBaseStructure.TIM_Prescaler = 179; // 89
0000ec  20b3              MOVS     r0,#0xb3
0000ee  f8ad0008          STRH     r0,[sp,#8]
;;;453            TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;454            TIM_TimeBaseStructure.TIM_Period = 0x0001;
;;;455            TIM_TimeBaseStructure.TIM_ClockDivision = 0;
0000f2  f8ad5010          STRH     r5,[sp,#0x10]
0000f6  f8ad500a          STRH     r5,[sp,#0xa]          ;453
;;;456            TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
0000fa  f88d5012          STRB     r5,[sp,#0x12]
;;;457            TIM_TimeBaseInit(TIM7, &TIM_TimeBaseStructure);
0000fe  4d1d              LDR      r5,|L7.372|
000100  9403              STR      r4,[sp,#0xc]          ;455
000102  a902              ADD      r1,sp,#8
000104  4628              MOV      r0,r5
000106  f7fffffe          BL       TIM_TimeBaseInit
;;;458            
;;;459            TIM_SelectOnePulseMode(TIM7, TIM_OPMode_Single);
00010a  2108              MOVS     r1,#8
00010c  4628              MOV      r0,r5
00010e  f7fffffe          BL       TIM_SelectOnePulseMode
;;;460            TIM7->EGR = TIM_PSCReloadMode_Immediate;
000112  4919              LDR      r1,|L7.376|
000114  800c              STRH     r4,[r1,#0]
;;;461            
;;;462            // Route interrupt
;;;463            NVIC_InitTypeDef NVIC_InitStructure;
;;;464            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000116  f88d4017          STRB     r4,[sp,#0x17]
;;;465            NVIC_InitStructure.NVIC_IRQChannel = TIM7_IRQn ;
00011a  2137              MOVS     r1,#0x37
00011c  f88d1014          STRB     r1,[sp,#0x14]
;;;466            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;  
000120  2102              MOVS     r1,#2
000122  f88d1015          STRB     r1,[sp,#0x15]
;;;467            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; 
000126  f88d1016          STRB     r1,[sp,#0x16]
;;;468            NVIC_Init(&NVIC_InitStructure);      
00012a  a805              ADD      r0,sp,#0x14
00012c  f7fffffe          BL       NVIC_Init
;;;469            // TIM_ITConfig(TIM7, TIM_IT_Update, ENABLE); // Enable interrupt
;;;470            TIM_Cmd(TIM7, ENABLE);
000130  2101              MOVS     r1,#1
000132  4628              MOV      r0,r5
000134  f7fffffe          BL       TIM_Cmd
;;;471            
;;;472            MicroWait(1000);
000138  f44f707a          MOV      r0,#0x3e8
00013c  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
;;;473             
;;;474            SensorInit(&iface_left);
000140  480e              LDR      r0,|L7.380|
000142  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10SensorInitEP12I2CInterface ; Anki::Cozmo::HAL::SensorInit(I2CInterface*)
;;;475            SensorInit(&iface_forward);
000146  4805              LDR      r0,|L7.348|
000148  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10SensorInitEP12I2CInterface ; Anki::Cozmo::HAL::SensorInit(I2CInterface*)
;;;476            SensorInit(&iface_right); 
00014c  480c              LDR      r0,|L7.384|
00014e  f7fffffe          BL       _ZN4Anki5Cozmo3HAL10SensorInitEP12I2CInterface ; Anki::Cozmo::HAL::SensorInit(I2CInterface*)
;;;477          }
000152  b007              ADD      sp,sp,#0x1c
000154  e8bd83f0          POP      {r4-r9,pc}
;;;478          
                          ENDP

                  |L7.344|
                          DCD      ||.data||
                  |L7.348|
                          DCD      ||.bss||+0x14
                  |L7.352|
                          DCD      0x40020c00
                  |L7.356|
                          DCD      0x40020400
                  |L7.360|
                          DCD      0x40020c18
                  |L7.364|
                          DCD      0x40020418
                  |L7.368|
                          DCD      0x40021400
                  |L7.372|
                          DCD      0x40001400
                  |L7.376|
                          DCD      0x40001414
                  |L7.380|
                          DCD      ||.bss||
                  |L7.384|
                          DCD      ||.bss||+0x28

                          AREA ||i.__sti___9_sharp_cpp||, CODE, READONLY, ALIGN=2

                  __sti___9_sharp_cpp PROC
000000  4803              LDR      r0,|L8.16|
000002  ed9f0a02          VLDR     s0,|L8.12|
000006  ed800a03          VSTR     s0,[r0,#0xc]
00000a  4770              BX       lr
                          ENDP

                  |L8.12|
00000c  423df6f2          DCFS     0x423df6f2 ; 47.491157531738281
                  |L8.16|
                          DCD      ||.data||

                          AREA ||.ARM.exidx||, LINKORDER=||i.TIM7_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.TIM7_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.10||, LINKORDER=||i._ZN4Anki5Cozmo3HAL4StopEP12I2CInterface||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo3HAL4StopEP12I2CInterface||
                          DCD      0x00000001

                          AREA ||area_number.11||, LINKORDER=||i._ZN4Anki5Cozmo3HAL5WriteEhP12I2CInterface||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo3HAL5WriteEhP12I2CInterface||
                          DCD      0x00000001

                          AREA ||area_number.12||, LINKORDER=||i._ZN4Anki5Cozmo3HAL10data_writeEP12I2CInterfaceii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo3HAL10data_writeEP12I2CInterfaceii||
                          DCD      0x00000001

                          AREA ||area_number.13||, LINKORDER=||i._ZN4Anki5Cozmo3HAL9SharpInitEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo3HAL9SharpInitEv||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i._ZN4Anki5Cozmo3HAL12GetProximityEPNS1_15ProximityValuesE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo3HAL12GetProximityEPNS1_15ProximityValuesE||
                          DCD      0x00000001

                          AREA ||area_number.15||, LINKORDER=||i.__sti___9_sharp_cpp||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___9_sharp_cpp||
                          DCD      0x00000001

                          AREA ||area_number.16||, LINKORDER=||i._ZN4Anki5Cozmo3HAL10SensorInitEP12I2CInterface||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo3HAL10SensorInitEP12I2CInterface||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _ZN4Anki5Cozmo3HAL10iface_leftE ; Anki::Cozmo::HAL::iface_left
                          %        20
                  _ZN4Anki5Cozmo3HAL13iface_forwardE ; Anki::Cozmo::HAL::iface_forward
                          %        20
                  _ZN4Anki5Cozmo3HAL11iface_rightE ; Anki::Cozmo::HAL::iface_right
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  bits
000000  00                DCB      0x00
                  m
000001  00                DCB      0x00
                  ||ID||
000002  00                DCB      0x00
                  I2Cstate
000003  00                DCB      0x00
                  long_count
                          DCD      0x00000000
                  count
                          DCD      0x00000000
                  _ZN4Anki5Cozmo21ROBOT_BOUNDING_RADIUSE ; Anki::Cozmo::ROBOT_BOUNDING_RADIUS
                          DCD      0x00000000
                  write_msg
                          %        8
                  read_msg
                          %        8

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___9_sharp_cpp

;*** Start embedded assembler ***

#line 1 "arm_hal\\hal\\sharp.cpp"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_sharp_cpp_c2f71283___Z7__REV16j|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___9_sharp_cpp_c2f71283___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_sharp_cpp_c2f71283___Z7__REVSHi|
#line 144
|__asm___9_sharp_cpp_c2f71283___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
