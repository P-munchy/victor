; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\spi.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\spi.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\spi.crf arm_hal\hal\spi.cpp]
                          THUMB

                          AREA ||i.DMA2_Stream1_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA2_Stream1_IRQHandler PROC
;;;200    extern "C"
;;;201    void DMA_HANDLER_RX(void)
000000  b510              PUSH     {r4,lr}
;;;202    {
;;;203      using namespace Anki::Cozmo::HAL;
;;;204        
;;;205      // Clear DMA Transfer Complete flag
;;;206      DMA_ClearFlag(DMA_STREAM_RX, DMA_FLAG_RX);
000002  491b              LDR      r1,|L1.112|
000004  481b              LDR      r0,|L1.116|
000006  f7fffffe          BL       DMA_ClearFlag
;;;207      USART_HalfDuplexCmd(UART, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  481a              LDR      r0,|L1.120|
00000e  f7fffffe          BL       USART_HalfDuplexCmd
;;;208      //PrintCrap();
;;;209      //UARTPutChar('R');
;;;210      
;;;211      // Atomically copy "live" buffers to/from the DMA copies
;;;212      // XXX: There is a timing error causing an off-by-one, but I have to get into Kevin's hands
;;;213      memcpy((void*)&g_dataToHead, ((u8*)&m_DMAtoHead) + 1, sizeof(g_dataToHead) - 1);
000012  491a              LDR      r1,|L1.124|
000014  223f              MOVS     r2,#0x3f
000016  f101007f          ADD      r0,r1,#0x7f
00001a  f7fffffe          BL       __aeabi_memcpy
;;;214      memcpy((void*)&m_DMAtoBody, (void*)&g_dataToBody, sizeof(m_DMAtoBody));
00001e  4918              LDR      r1,|L1.128|
000020  2240              MOVS     r2,#0x40
000022  f1a10080          SUB      r0,r1,#0x80
000026  f7fffffe          BL       __aeabi_memcpy
;;;215      
;;;216      // Wait 80uS before replying
;;;217      MicroWait(80);
00002a  2050              MOVS     r0,#0x50
00002c  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
;;;218      
;;;219      // Turn around the connection and transmit reply
;;;220      DMA_STREAM_TX->NDTR = sizeof(m_DMAtoBody);// Buffer size
000030  4914              LDR      r1,|L1.132|
000032  2040              MOVS     r0,#0x40
000034  6008              STR      r0,[r1,#0]
;;;221      DMA_STREAM_TX->M0AR = (u32)&m_DMAtoBody;  // Buffer address
000036  4915              LDR      r1,|L1.140|
000038  4813              LDR      r0,|L1.136|
00003a  6008              STR      r0,[r1,#0]
;;;222      DMA_STREAM_TX->CR |= DMA_SxCR_EN; // Enable DMA
00003c  4814              LDR      r0,|L1.144|
00003e  6801              LDR      r1,[r0,#0]
000040  f0410101          ORR      r1,r1,#1
000044  6001              STR      r1,[r0,#0]
;;;223      
;;;224    #if 0
;;;225      volatile u8* d = (volatile u8*)&g_dataToHead;
;;;226      for (int i = 0; i < 0x10; i++)
;;;227      {
;;;228        UARTPutHex(d[i]);
;;;229        UARTPutChar(' ');
;;;230      }
;;;231      UARTPutChar('\n');
;;;232    #endif
;;;233      
;;;234      const u8 MAX_FAILED_TRANSFER_COUNT = 10;
;;;235      static u8 s_failedTransferCount = 0;
;;;236      // Verify the source is the body
;;;237      if (g_dataToHead.common.source != SPI_SOURCE_BODY)
000046  4813              LDR      r0,|L1.148|
000048  7800              LDRB     r0,[r0,#0]  ; _ZN4Anki5Cozmo3HAL12g_dataToHeadE
;;;238      {
;;;239        if (++s_failedTransferCount > MAX_FAILED_TRANSFER_COUNT)
00004a  4c13              LDR      r4,|L1.152|
00004c  2842              CMP      r0,#0x42              ;237
00004e  d002              BEQ      |L1.86|
000050  7860              LDRB     r0,[r4,#1]  ; s_failedTransferCount
000052  1c40              ADDS     r0,r0,#1
000054  7060              STRB     r0,[r4,#1]
                  |L1.86|
;;;240        {
;;;241          //NVIC_SystemReset();
;;;242        }
;;;243      }
;;;244      
;;;245      s_failedTransferCount = 0;  // XXX: We need to do something about sync loss here
000056  2000              MOVS     r0,#0
000058  7060              STRB     r0,[r4,#1]
;;;246      
;;;247    	// Hack to allow timing events longer than about 50ms
;;;248    	GetMicroCounter();
00005a  f7fffffe          BL       _ZN4Anki5Cozmo3HAL15GetMicroCounterEv ; Anki::Cozmo::HAL::GetMicroCounter()
;;;249    	
;;;250      // Run MainExecution if init is done
;;;251      if (g_halInitComplete)
00005e  7820              LDRB     r0,[r4,#0]  ; _ZN4Anki5Cozmo3HAL17g_halInitCompleteE
000060  2800              CMP      r0,#0
;;;252      {
;;;253        Anki::Cozmo::Robot::step_MainExecution();
;;;254      }
;;;255    }
000062  bf08              IT       EQ
000064  bd10              POPEQ    {r4,pc}
000066  e8bd4010          POP      {r4,lr}               ;253
00006a  f7ffbffe          B.W      _ZN4Anki5Cozmo5Robot18step_MainExecutionEv ; Anki::Cozmo::Robot::step_MainExecution()
                          ENDP

00006e  0000              DCW      0x0000
                  |L1.112|
                          DCD      0x10000800
                  |L1.116|
                          DCD      0x40026428
                  |L1.120|
                          DCD      0x40011400
                  |L1.124|
                          DCD      ||.bss||+0x1
                  |L1.128|
                          DCD      ||.bss||+0xc0
                  |L1.132|
                          DCD      0x400264a4
                  |L1.136|
                          DCD      ||.bss||+0x40
                  |L1.140|
                          DCD      0x400264ac
                  |L1.144|
                          DCD      0x400264a0
                  |L1.148|
                          DCD      ||.bss||+0x80
                  |L1.152|
                          DCD      ||.data||

                          AREA ||i.DMA2_Stream6_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA2_Stream6_IRQHandler PROC
;;;175    extern "C"
;;;176    void DMA_HANDLER_TX(void)
000000  b538              PUSH     {r3-r5,lr}
;;;177    {
;;;178      using namespace Anki::Cozmo::HAL;
;;;179        
;;;180      // Clear DMA Transfer Complete flag
;;;181      DMA_ClearFlag(DMA_STREAM_TX, DMA_FLAG_TX);
000002  4912              LDR      r1,|L2.76|
000004  4812              LDR      r0,|L2.80|
000006  f7fffffe          BL       DMA_ClearFlag
;;;182      USART_HalfDuplexCmd(UART, ENABLE);
00000a  4c12              LDR      r4,|L2.84|
00000c  2101              MOVS     r1,#1
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       USART_HalfDuplexCmd
;;;183      //UARTPutChar('T');
;;;184      
;;;185      // Wait 40uS before listening again
;;;186      MicroWait(200);
000014  20c8              MOVS     r0,#0xc8
000016  f7fffffe          BL       _ZN4Anki5Cozmo3HAL9MicroWaitEj ; Anki::Cozmo::HAL::MicroWait(unsigned)
;;;187      
;;;188      // Clear anything in the USART
;;;189      while (UART->SR & USART_FLAG_RXNE)
00001a  8821              LDRH     r1,[r4,#0]
00001c  f0110f20          TST      r1,#0x20
;;;190        volatile int x = UART->DR;
000020  bf18              IT       NE
000022  490d              LDRNE    r1,|L2.88|
000024  d005              BEQ      |L2.50|
                  |L2.38|
000026  880a              LDRH     r2,[r1,#0]
000028  9200              STR      r2,[sp,#0]            ;189
00002a  8822              LDRH     r2,[r4,#0]            ;189
00002c  f0120f20          TST      r2,#0x20              ;189
000030  d1f9              BNE      |L2.38|
                  |L2.50|
;;;191      
;;;192      // Turn around the connection and receive reply
;;;193      DMA_STREAM_RX->NDTR = sizeof(m_DMAtoHead);// Buffer size
000032  480a              LDR      r0,|L2.92|
000034  2140              MOVS     r1,#0x40
000036  6001              STR      r1,[r0,#0]
;;;194      DMA_STREAM_RX->M0AR = (u32)&m_DMAtoHead;  // Buffer address
000038  490a              LDR      r1,|L2.100|
00003a  4809              LDR      r0,|L2.96|
00003c  6008              STR      r0,[r1,#0]
;;;195      DMA_STREAM_RX->CR |= DMA_SxCR_EN; // Enable DMA
00003e  480a              LDR      r0,|L2.104|
000040  6801              LDR      r1,[r0,#0]
000042  f0410101          ORR      r1,r1,#1
000046  6001              STR      r1,[r0,#0]
;;;196    }
000048  bd38              POP      {r3-r5,pc}
;;;197    
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      0x20200000
                  |L2.80|
                          DCD      0x400264a0
                  |L2.84|
                          DCD      0x40011400
                  |L2.88|
                          DCD      0x40011404
                  |L2.92|
                          DCD      0x4002642c
                  |L2.96|
                          DCD      ||.bss||
                  |L2.100|
                          DCD      0x40026434
                  |L2.104|
                          DCD      0x40026428

                          AREA ||i._ZN4Anki5Cozmo3HAL7SPIInitEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo3HAL7SPIInitEv PROC ; Anki::Cozmo::HAL::SPIInit()
;;;62     
;;;63           void SPIInit()
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;64           {
;;;65             // Clock configuration
;;;66             RCC_AHB1PeriphClockCmd(RCC_GPIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  b097              SUB      sp,sp,#0x5c           ;64
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;67             RCC_AHB1PeriphClockCmd(RCC_DMA, ENABLE);
00000e  2101              MOVS     r1,#1
000010  0588              LSLS     r0,r1,#22
000012  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;68             RCC_APB2PeriphClockCmd(RCC_UART, ENABLE);
000016  2101              MOVS     r1,#1
000018  2020              MOVS     r0,#0x20
00001a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;69             
;;;70             // Configure the pins for UART in AF mode
;;;71             GPIO_InitTypeDef GPIO_InitStructure;
;;;72             GPIO_InitStructure.GPIO_Pin = PIN_TRX;  
00001e  f44f6000          MOV      r0,#0x800
;;;73             GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000022  9014              STR      r0,[sp,#0x50]
000024  2002              MOVS     r0,#2
000026  f88d0054          STRB     r0,[sp,#0x54]
;;;74             GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
00002a  2400              MOVS     r4,#0
00002c  f88d4055          STRB     r4,[sp,#0x55]
;;;75             GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;    // Open collector transmit/receive
000030  2501              MOVS     r5,#1
;;;76             GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;77             GPIO_Init(GPIO_TRX, &GPIO_InitStructure);
000032  4e51              LDR      r6,|L3.376|
000034  f88d5056          STRB     r5,[sp,#0x56]         ;75
000038  f88d4057          STRB     r4,[sp,#0x57]         ;76
00003c  a914              ADD      r1,sp,#0x50
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       GPIO_Init
;;;78             
;;;79             GPIO_PinAFConfig(GPIO_TRX, SOURCE_TRX, GPIO_AF);
000044  2208              MOVS     r2,#8
000046  210b              MOVS     r1,#0xb
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       GPIO_PinAFConfig
;;;80             
;;;81             // Configure the UART for the appropriate baudrate
;;;82             USART_InitTypeDef USART_InitStructure;
;;;83             USART_Cmd(UART, DISABLE);
00004e  2100              MOVS     r1,#0
000050  484a              LDR      r0,|L3.380|
000052  f7fffffe          BL       USART_Cmd
;;;84             USART_InitStructure.USART_BaudRate = BAUDRATE;
000056  484a              LDR      r0,|L3.384|
;;;85             USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000058  9010              STR      r0,[sp,#0x40]
;;;86             USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;87             USART_InitStructure.USART_Parity = USART_Parity_No;
00005a  f8ad4048          STRH     r4,[sp,#0x48]
;;;88             USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;89             USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005e  200c              MOVS     r0,#0xc
000060  f8ad4044          STRH     r4,[sp,#0x44]         ;85
000064  f8ad004a          STRH     r0,[sp,#0x4a]
000068  f8ad4046          STRH     r4,[sp,#0x46]         ;86
00006c  f8ad404c          STRH     r4,[sp,#0x4c]         ;88
;;;90             USART_Init(UART, &USART_InitStructure);
000070  a910              ADD      r1,sp,#0x40
000072  4842              LDR      r0,|L3.380|
000074  f7fffffe          BL       USART_Init
;;;91             //USART_HalfDuplexCmd(UART, ENABLE);
;;;92             USART_Cmd(UART, ENABLE);
000078  2101              MOVS     r1,#1
00007a  4840              LDR      r0,|L3.380|
00007c  f7fffffe          BL       USART_Cmd
;;;93             
;;;94             // Configure DMA for receiving
;;;95             DMA_DeInit(DMA_STREAM_RX);
000080  4840              LDR      r0,|L3.388|
000082  f7fffffe          BL       DMA_DeInit
;;;96             
;;;97             DMA_InitTypeDef DMA_InitStructure;
;;;98             DMA_InitStructure.DMA_Channel = DMA_CHANNEL_RX;
;;;99             DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&UART->DR;
;;;100            DMA_InitStructure.DMA_Memory0BaseAddr = (u32)&m_DMAtoHead;
000086  4841              LDR      r0,|L3.396|
;;;101            DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
;;;102            DMA_InitStructure.DMA_BufferSize = sizeof(m_DMAtoHead);
000088  e9cd0402          STRD     r0,r4,[sp,#8]
00008c  2640              MOVS     r6,#0x40
;;;103            DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
;;;104            DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
00008e  f44f6980          MOV      r9,#0x400
000092  e9cd6404          STRD     r6,r4,[sp,#0x10]
000096  e9cd9406          STRD     r9,r4,[sp,#0x18]
;;;105            DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
;;;106            DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
;;;107            DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
;;;108            DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
00009a  f44f3a80          MOV      r10,#0x10000
00009e  9408              STR      r4,[sp,#0x20]
0000a0  e9cd4a09          STRD     r4,r10,[sp,#0x24]
;;;109            DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
;;;110            DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;
0000a4  f04f0b03          MOV      r11,#3
0000a8  e9cd4b0b          STRD     r4,r11,[sp,#0x2c]
0000ac  f8df80d8          LDR      r8,|L3.392|
0000b0  f04f6720          MOV      r7,#0xa000000         ;98
;;;111            DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
;;;112            DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
;;;113            DMA_Init(DMA_STREAM_RX, &DMA_InitStructure);
0000b4  e9cd7800          STRD     r7,r8,[sp,#0]
0000b8  940d              STR      r4,[sp,#0x34]         ;112
0000ba  4669              MOV      r1,sp
0000bc  4831              LDR      r0,|L3.388|
0000be  940e              STR      r4,[sp,#0x38]
0000c0  f7fffffe          BL       DMA_Init
;;;114            
;;;115            // Enable DMA
;;;116            USART_DMACmd(UART, USART_DMAReq_Rx, ENABLE);
0000c4  2201              MOVS     r2,#1
0000c6  2140              MOVS     r1,#0x40
0000c8  f1a80004          SUB      r0,r8,#4
0000cc  f7fffffe          BL       USART_DMACmd
;;;117            //DMA_Cmd(DMA_STREAM_RX, ENABLE);
;;;118                            
;;;119            // Enable interrupt on DMA transfer complete for RX.
;;;120            DMA_ITConfig(DMA_STREAM_RX, DMA_IT_TC, ENABLE);
0000d0  2201              MOVS     r2,#1
0000d2  2110              MOVS     r1,#0x10
0000d4  482b              LDR      r0,|L3.388|
0000d6  f7fffffe          BL       DMA_ITConfig
;;;121            
;;;122            NVIC_InitTypeDef NVIC_InitStructure;
;;;123            NVIC_InitStructure.NVIC_IRQChannel = DMA_IRQ_RX;
0000da  2039              MOVS     r0,#0x39
0000dc  f88d003c          STRB     r0,[sp,#0x3c]
;;;124            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;  // Don't want this to be a very high priority
0000e0  f88d503d          STRB     r5,[sp,#0x3d]
;;;125            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;126            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
0000e4  f88d403e          STRB     r4,[sp,#0x3e]
;;;127            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000e8  f88d503f          STRB     r5,[sp,#0x3f]
;;;128            NVIC_Init(&NVIC_InitStructure);   
0000ec  a80f              ADD      r0,sp,#0x3c
0000ee  f7fffffe          BL       NVIC_Init
;;;129    
;;;130            // Set up first "hello" message to body
;;;131            g_dataToBody.common.source = SPI_SOURCE_HEAD;
0000f2  4827              LDR      r0,|L3.400|
0000f4  2148              MOVS     r1,#0x48
0000f6  7001              STRB     r1,[r0,#0]
;;;132            g_dataToBody.common.SYNC[0] = 0xfa;
0000f8  21fa              MOVS     r1,#0xfa
0000fa  7041              STRB     r1,[r0,#1]
;;;133            g_dataToBody.common.SYNC[1] = 0xf3;
0000fc  21f3              MOVS     r1,#0xf3
0000fe  7081              STRB     r1,[r0,#2]
;;;134            g_dataToBody.common.SYNC[2] = 0x20;
000100  2120              MOVS     r1,#0x20
000102  70c1              STRB     r1,[r0,#3]
;;;135            memcpy((void*)&m_DMAtoBody, (void*)&g_dataToBody, sizeof(m_DMAtoBody));
000104  4601              MOV      r1,r0
000106  2240              MOVS     r2,#0x40
000108  3880              SUBS     r0,r0,#0x80
00010a  f7fffffe          BL       __aeabi_memcpy
;;;136            
;;;137            // Configure DMA For transmitting
;;;138            DMA_DeInit(DMA_STREAM_TX);        
00010e  4821              LDR      r0,|L3.404|
000110  f7fffffe          BL       DMA_DeInit
;;;139            DMA_InitStructure.DMA_Channel = DMA_CHANNEL_TX;
;;;140            DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&UART->DR;
;;;141            DMA_InitStructure.DMA_Memory0BaseAddr = (u32)&m_DMAtoBody;
000114  4820              LDR      r0,|L3.408|
;;;142            DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
;;;143            DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
000116  e9cd0602          STRD     r0,r6,[sp,#8]
00011a  e9cd9406          STRD     r9,r4,[sp,#0x18]
00011e  9409              STR      r4,[sp,#0x24]
000120  e9cd6404          STRD     r6,r4,[sp,#0x10]
;;;144            DMA_InitStructure.DMA_BufferSize = sizeof(m_DMAtoBody);
;;;145            DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
;;;146            DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
;;;147            DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
;;;148            DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;  // Use in combination with FIFO to increase throughput? Needs to be divisible by 1, 1/4, 1/2 of FIFO size
000124  e9cda40a          STRD     r10,r4,[sp,#0x28]
000128  9408              STR      r4,[sp,#0x20]
00012a  e9cdb40c          STRD     r11,r4,[sp,#0x30]
;;;149            DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
;;;150            DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;  // See comment above
;;;151            DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;
;;;152            DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
;;;153            DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
;;;154            DMA_Init(DMA_STREAM_TX, &DMA_InitStructure);
00012e  e9cd7800          STRD     r7,r8,[sp,#0]
000132  4669              MOV      r1,sp
000134  4817              LDR      r0,|L3.404|
000136  940e              STR      r4,[sp,#0x38]
000138  f7fffffe          BL       DMA_Init
;;;155            
;;;156            // Enable interrupt on DMA transfer complete for RX.
;;;157            DMA_ITConfig(DMA_STREAM_TX, DMA_IT_TC, ENABLE);
00013c  2201              MOVS     r2,#1
00013e  2110              MOVS     r1,#0x10
000140  4814              LDR      r0,|L3.404|
000142  f7fffffe          BL       DMA_ITConfig
;;;158            
;;;159            NVIC_InitStructure.NVIC_IRQChannel = DMA_IRQ_TX;
000146  2045              MOVS     r0,#0x45
000148  f88d003c          STRB     r0,[sp,#0x3c]
;;;160            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;  // Don't want this to be a very high priority
00014c  f88d503d          STRB     r5,[sp,#0x3d]
;;;161            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000150  f88d403e          STRB     r4,[sp,#0x3e]
;;;162            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000154  f88d503f          STRB     r5,[sp,#0x3f]
;;;163            NVIC_Init(&NVIC_InitStructure); 
000158  a80f              ADD      r0,sp,#0x3c
00015a  f7fffffe          BL       NVIC_Init
;;;164            
;;;165            // Enable first UART transmission - this will tell the body we are awake and ready                
;;;166            USART_DMACmd(UART, USART_DMAReq_Tx, ENABLE);
00015e  2201              MOVS     r2,#1
000160  2180              MOVS     r1,#0x80
000162  f1a80004          SUB      r0,r8,#4
000166  f7fffffe          BL       USART_DMACmd
;;;167            DMA_Cmd(DMA_STREAM_TX, ENABLE);
00016a  2101              MOVS     r1,#1
00016c  4809              LDR      r0,|L3.404|
00016e  f7fffffe          BL       DMA_Cmd
;;;168          }                      
000172  b017              ADD      sp,sp,#0x5c
000174  e8bd8ff0          POP      {r4-r11,pc}
;;;169        }
                          ENDP

                  |L3.376|
                          DCD      0x40020000
                  |L3.380|
                          DCD      0x40011400
                  |L3.384|
                          DCD      0x00055730
                  |L3.388|
                          DCD      0x40026428
                  |L3.392|
                          DCD      0x40011404
                  |L3.396|
                          DCD      ||.bss||
                  |L3.400|
                          DCD      ||.bss||+0xc0
                  |L3.404|
                          DCD      0x400264a0
                  |L3.408|
                          DCD      ||.bss||+0x40

                          AREA ||i._ZN4Anki5Cozmo3HAL9PrintCrapEv||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  _ZN4Anki5Cozmo3HAL9PrintCrapEv PROC ; Anki::Cozmo::HAL::PrintCrap()
;;;51     
;;;52           void PrintCrap()
000000  b570              PUSH     {r4-r6,lr}
;;;53           {
;;;54             printf("\nTX: %d  RX: %d\n", DMA_STREAM_TX->NDTR, DMA_STREAM_RX->NDTR);
000002  480c              LDR      r0,|L4.52|
000004  6802              LDR      r2,[r0,#0]
000006  480c              LDR      r0,|L4.56|
000008  6801              LDR      r1,[r0,#0]
00000a  a00c              ADR      r0,|L4.60|
00000c  f7fffffe          BL       __2printf
;;;55             for (int i = 0; i < sizeof(g_dataToHead); i++)
000010  2400              MOVS     r4,#0
;;;56             {
;;;57               printf("%02x", ((u8*)(&g_dataToHead))[i]);
000012  4d0f              LDR      r5,|L4.80|
;;;58               if ((i & 63) == 63)
000014  263f              MOVS     r6,#0x3f
                  |L4.22|
000016  a00f              ADR      r0,|L4.84|
000018  5d29              LDRB     r1,[r5,r4]            ;57
00001a  f7fffffe          BL       __2printf
00001e  ea360004          BICS     r0,r6,r4
;;;59                 printf("\n");
000022  bf04              ITT      EQ
000024  a00d              ADREQ    r0,|L4.92|
000026  f7fffffe          BLEQ     __2printf
00002a  1c64              ADDS     r4,r4,#1
00002c  2c40              CMP      r4,#0x40              ;55
00002e  d3f2              BCC      |L4.22|
;;;60             }
;;;61           }
000030  bd70              POP      {r4-r6,pc}
;;;62     
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      0x4002642c
                  |L4.56|
                          DCD      0x400264a4
                  |L4.60|
00003c  0a54583a          DCB      "\nTX: %d  RX: %d\n",0
000040  20256420
000044  2052583a
000048  2025640a
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0
                  |L4.80|
                          DCD      ||.bss||+0x80
                  |L4.84|
000054  25303278          DCB      "%02x",0
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L4.92|
00005c  0a00              DCB      "\n",0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.__sti___7_spi_cpp_2ddf8692||, CODE, READONLY, ALIGN=2

                  __sti___7_spi_cpp_2ddf8692 PROC
000000  4803              LDR      r0,|L5.16|
000002  ed9f0a02          VLDR     s0,|L5.12|
000006  ed800a01          VSTR     s0,[r0,#4]
00000a  4770              BX       lr
                          ENDP

                  |L5.12|
00000c  423df6f2          DCFS     0x423df6f2 ; 47.491157531738281
                  |L5.16|
                          DCD      ||.data||

                          AREA ||.ARM.exidx||, LINKORDER=||i.DMA2_Stream6_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.DMA2_Stream6_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.7||, LINKORDER=||i.DMA2_Stream1_IRQHandler||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.DMA2_Stream1_IRQHandler||
                          DCD      0x00000001

                          AREA ||area_number.8||, LINKORDER=||i._ZN4Anki5Cozmo3HAL9PrintCrapEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo3HAL9PrintCrapEv||
                          DCD      0x00000001

                          AREA ||area_number.9||, LINKORDER=||i._ZN4Anki5Cozmo3HAL7SPIInitEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo3HAL7SPIInitEv||
                          DCD      0x00000001

                          AREA ||area_number.10||, LINKORDER=||i.__sti___7_spi_cpp_2ddf8692||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___7_spi_cpp_2ddf8692||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _ZN4Anki5Cozmo3HAL11m_DMAtoHeadE ; Anki::Cozmo::HAL::m_DMAtoHead
                          %        64
                  _ZN4Anki5Cozmo3HAL11m_DMAtoBodyE ; Anki::Cozmo::HAL::m_DMAtoBody
                          %        64
                  _ZN4Anki5Cozmo3HAL12g_dataToHeadE ; Anki::Cozmo::HAL::g_dataToHead
                          %        64
                  _ZN4Anki5Cozmo3HAL12g_dataToBodyE ; Anki::Cozmo::HAL::g_dataToBody
                          %        64

                          AREA ||.data||, DATA, ALIGN=2

                  _ZN4Anki5Cozmo3HAL17g_halInitCompleteE ; Anki::Cozmo::HAL::g_halInitComplete
000000  00                DCB      0x00
                  s_failedTransferCount
000001  000000            DCB      0x00,0x00,0x00
                  _ZN4Anki5Cozmo21ROBOT_BOUNDING_RADIUSE ; Anki::Cozmo::ROBOT_BOUNDING_RADIUS
                          DCD      0x00000000

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___7_spi_cpp_2ddf8692

;*** Start embedded assembler ***

#line 1 "arm_hal\\hal\\spi.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_spi_cpp_2ddf8692___Z7__REV16j|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___7_spi_cpp_2ddf8692___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_spi_cpp_2ddf8692___Z7__REVSHi|
#line 144
|__asm___7_spi_cpp_2ddf8692___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
