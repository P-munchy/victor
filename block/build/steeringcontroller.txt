; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\steeringcontroller.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\steeringcontroller.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\steeringcontroller.crf supervisor\src\steeringController.cpp]
                          THUMB

                          AREA ||i._ZN4Anki5Cozmo18SteeringController15ManagePointTurnEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController15ManagePointTurnEv PROC ; Anki::Cozmo::SteeringController::ManagePointTurn()
;;;437        //       Is it good enough or should we use position or velocity control?
;;;438        void ManagePointTurn()
000000  b510              PUSH     {r4,lr}
;;;439        {
000002  ed2d8b02          VPUSH    {d8}
000006  b084              SUB      sp,sp,#0x10
;;;440          if (!SpeedController::IsVehicleStopped() && !startedPointTurn_) {
000008  f7fffffe          BL       _ZN4Anki5Cozmo15SpeedController16IsVehicleStoppedEv ; Anki::Cozmo::SpeedController::IsVehicleStopped()
00000c  4c29              LDR      r4,|L1.180|
;;;441            RunLineFollowControllerNL(0,0);
00000e  eddf8a2a          VLDR     s17,|L1.184|
000012  78e1              LDRB     r1,[r4,#3]            ;440  ; _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e617startedPointTurn_E
000014  4308              ORRS     r0,r0,r1              ;440
000016  d043              BEQ      |L1.160|
;;;442            return;
;;;443          }
;;;444    
;;;445          startedPointTurn_ = true;
000018  2001              MOVS     r0,#1
00001a  70e0              STRB     r0,[r4,#3]
;;;446          
;;;447          
;;;448          // Compute distance to target
;;;449          Radians currAngle = Cozmo::Localization::GetCurrentMatOrientation();
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       _ZN4Anki5Cozmo12Localization24GetCurrentMatOrientationEv ; Anki::Cozmo::Localization::GetCurrentMatOrientation()
;;;450          float angularDistToTarget = currAngle.angularDistance(targetRad_, maxAngularVel_ < 0);
000022  ed940a09          VLDR     s0,[r4,#0x24]
000026  eeb50ac0          VCMPE.F32 s0,#0.0
00002a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00002e  bf34              ITE      CC
000030  2201              MOVCC    r2,#1
000032  2200              MOVCS    r2,#0
000034  4921              LDR      r1,|L1.188|
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       _ZN4Anki7Radians15angularDistanceERKS0_b ; Anki::Radians::angularDistance(const Anki::Radians&, bool)
00003c  eeb08a40          VMOV.F32 s16,s0
;;;451          
;;;452          // Update current angular velocity
;;;453          f32 currDesiredAngle;
;;;454          vpg_.Step(currAngularVel_, currDesiredAngle);
000040  aa02              ADD      r2,sp,#8
000042  491f              LDR      r1,|L1.192|
000044  481f              LDR      r0,|L1.196|
000046  f7fffffe          BL       _ZN4Anki24VelocityProfileGenerator4StepERfS1_ ; Anki::VelocityProfileGenerator::Step(float&, float&)
;;;455          
;;;456          //PRINT("currAngle: %f, targetRad: %f, AngularDist: %f, currAngularVel: %f, currDesiredAngle: %f\n",
;;;457          //          currAngle.ToFloat(), targetRad_.ToFloat(), angularDistToTarget, currAngularVel_, currDesiredAngle);
;;;458          
;;;459          
;;;460          // Check for stop condition
;;;461          if (ABS(angularDistToTarget) < POINT_TURN_TARGET_DIST_STOP_RAD) {
00004a  eeb58ac0          VCMPE.F32 s16,#0.0
00004e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000052  bfb8              IT       LT
000054  eeb18a48          VNEGLT.F32 s16,s16
000058  ee180a10          VMOV     r0,s16
00005c  491a              LDR      r1,|L1.200|
00005e  4288              CMP      r0,r1
000060  da03              BGE      |L1.106|
;;;462            currSteerMode_ = SM_PATH_FOLLOW;
000062  2000              MOVS     r0,#0
000064  7060              STRB     r0,[r4,#1]
;;;463            currAngularVel_ = 0;
000066  edc48a0c          VSTR     s17,[r4,#0x30]
                  |L1.106|
;;;464    #if(DEBUG_STEERING_CONTROLLER)
;;;465            PRINT("POINT TURN: Stopping\n");
;;;466    #endif
;;;467          }
;;;468          
;;;469          // Compute the velocity along the arc length equivalent of currAngularVel.
;;;470          // currAngularVel_ / PI = arcVel / (PI * R)
;;;471          s16 arcVel = (s16)(currAngularVel_ * WHEEL_DIST_HALF_MM); // mm/s
00006a  ed940a0c          VLDR     s0,[r4,#0x30]
00006e  eddf0a17          VLDR     s1,|L1.204|
000072  ee200a20          VMUL.F32 s0,s0,s1
000076  eebd0ac0          VCVT.S32.F32 s0,s0
00007a  ee100a10          VMOV     r0,s0
00007e  b200              SXTH     r0,r0
;;;472          
;;;473          // Compute the wheel velocities
;;;474          s16 wleft = -arcVel;
;;;475          s16 wright = arcVel;
;;;476    
;;;477          
;;;478    #if(DEBUG_STEERING_CONTROLLER)
;;;479          PRINT("POINT TURN: angularDistToTarget: %f radians, arcVel: %d mm/s\n", angularDistToTarget, arcVel);
;;;480    #endif
;;;481          
;;;482          WheelController::SetDesiredWheelSpeeds(wleft, wright);
000080  ee000a10          VMOV     s0,r0
000084  4241              RSBS     r1,r0,#0              ;474
000086  b209              SXTH     r1,r1                 ;474
000088  eef80ac0          VCVT.F32.S32 s1,s0
00008c  ee001a10          VMOV     s0,r1
000090  eeb80ac0          VCVT.F32.S32 s0,s0
000094  f7fffffe          BL       _ZN4Anki5Cozmo15WheelController21SetDesiredWheelSpeedsEff ; Anki::Cozmo::WheelController::SetDesiredWheelSpeeds(float, float)
;;;483        }
000098  b004              ADD      sp,sp,#0x10
00009a  ecbd8b02          VPOP     {d8}
00009e  bd10              POP      {r4,pc}
                  |L1.160|
0000a0  eeb00a68          VMOV.F32 s0,s17                ;441
0000a4  eef00a40          VMOV.F32 s1,s0                 ;441
0000a8  f7fffffe          BL       _ZN4Anki5Cozmo18SteeringController25RunLineFollowControllerNLEff ; Anki::Cozmo::SteeringController::RunLineFollowControllerNL(float, float)
0000ac  b004              ADD      sp,sp,#0x10
0000ae  ecbd8b02          VPOP     {d8}
0000b2  bd10              POP      {r4,pc}
;;;484        
                          ENDP

                  |L1.180|
                          DCD      ||.data||
                  |L1.184|
0000b8  00000000          DCFS     0x00000000 ; 0
                  |L1.188|
                          DCD      ||.data||+0x38
                  |L1.192|
                          DCD      ||.data||+0x30
                  |L1.196|
                          DCD      ||.bss||
                  |L1.200|
                          DCD      0x3d4ccccd
                  |L1.204|
0000cc  41becccd          DCFS     0x41becccd ; 23.850000381469727

                          AREA ||i._ZN4Anki5Cozmo18SteeringController16ExecutePointTurnEffff||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController16ExecutePointTurnEffff PROC ; Anki::Cozmo::SteeringController::ExecutePointTurn(float, float, float, float)
;;;390        
;;;391        void ExecutePointTurn(f32 targetAngle, f32 maxAngularVel, f32 angularAccel, f32 angularDecel)
000000  b570              PUSH     {r4-r6,lr}
;;;392        {
;;;393          currSteerMode_ = SM_POINT_TURN;
000002  4e4c              LDR      r6,|L2.308|
000004  2002              MOVS     r0,#2
000006  ed2d8b04          VPUSH    {d8-d9}               ;392
00000a  b084              SUB      sp,sp,#0x10           ;392
00000c  eef08a61          VMOV.F32 s17,s3                ;392
000010  eeb08a41          VMOV.F32 s16,s2                ;392
000014  eeb09a60          VMOV.F32 s18,s1                ;392
000018  eef09a40          VMOV.F32 s19,s0                ;392
00001c  7070              STRB     r0,[r6,#1]
;;;394          
;;;395          // Stop the robot if not already
;;;396          if (SpeedController::GetUserCommandedDesiredVehicleSpeed() != 0) {
00001e  f7fffffe          BL       _ZN4Anki5Cozmo15SpeedController35GetUserCommandedDesiredVehicleSpeedEv ; Anki::Cozmo::SpeedController::GetUserCommandedDesiredVehicleSpeed()
000022  2800              CMP      r0,#0
;;;397            SpeedController::SetUserCommandedDesiredVehicleSpeed(0);
000024  bf1c              ITT      NE
000026  2000              MOVNE    r0,#0
000028  f7fffffe          BLNE     _ZN4Anki5Cozmo15SpeedController35SetUserCommandedDesiredVehicleSpeedEs ; Anki::Cozmo::SpeedController::SetUserCommandedDesiredVehicleSpeed(short)
;;;398          }
;;;399          
;;;400          targetRad_ = targetAngle;
00002c  eeb00a69          VMOV.F32 s0,s19
000030  4841              LDR      r0,|L2.312|
000032  f7fffffe          BL       _ZN4Anki7RadiansaSEf ; Anki::Radians::operator =(float)
;;;401          maxAngularVel_ = maxAngularVel;
000036  ed869a09          VSTR     s18,[r6,#0x24]
;;;402          angularAccel_ = angularAccel;
00003a  ed868a0a          VSTR     s16,[r6,#0x28]
;;;403          angularDecel_ = angularDecel;
00003e  edc68a0b          VSTR     s17,[r6,#0x2c]
;;;404          startedPointTurn_ = false;
000042  2000              MOVS     r0,#0
000044  70f0              STRB     r0,[r6,#3]
;;;405          
;;;406          
;;;407          f32 currAngle = Localization::GetCurrentMatOrientation().ToFloat();
000046  a802              ADD      r0,sp,#8
000048  f7fffffe          BL       _ZN4Anki5Cozmo12Localization24GetCurrentMatOrientationEv ; Anki::Cozmo::Localization::GetCurrentMatOrientation()
00004c  483a              LDR      r0,|L2.312|
00004e  eddd8a02          VLDR     s17,[sp,#8]
;;;408          
;;;409          // Compute target angle that is on the appropriate side of currAngle given the maxAngularVel
;;;410          // which determines the turning direction.
;;;411          f32 destAngle = targetRad_.ToFloat();
;;;412          if (currAngle > destAngle && maxAngularVel_ > 0) {
;;;413            destAngle += 2*PI_F;
000052  ed9f0a3a          VLDR     s0,|L2.316|
000056  ed908a00          VLDR     s16,[r0,#0]
00005a  eef48ac8          VCMPE.F32 s17,s16               ;412
00005e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;412
000062  bfc1              ITTTT    GT                    ;412
000064  edd60a09          VLDRGT   s1,[r6,#0x24]         ;412
000068  eef50ac0          VCMPEGT.F32 s1,#0.0               ;412
00006c  eef1fa10          VMRSGT   APSR_nzcv,FPSCR       ;412
000070  ee388a00          VADDGT.F32 s16,s16,s0
000074  dc0c              BGT      |L2.144|
;;;414          } else if (currAngle < destAngle && maxAngularVel_ < 0) {
000076  eef48ac8          VCMPE.F32 s17,s16
00007a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00007e  bf3f              ITTTT    CC
000080  edd60a09          VLDRCC   s1,[r6,#0x24]
000084  eef50ac0          VCMPECC.F32 s1,#0.0
000088  eef1fa10          VMRSCC   APSR_nzcv,FPSCR
;;;415            destAngle -= 2*PI_F;
00008c  ee388a40          VSUBCC.F32 s16,s16,s0
                  |L2.144|
;;;416          }
;;;417          
;;;418          // Check that the maxAngularVel is greater than the terminal speed
;;;419          // If not, make it at least that big.
;;;420          if (ABS(maxAngularVel_) < POINT_TURN_TERMINAL_VEL_RAD_PER_S) {
000090  ed960a09          VLDR     s0,[r6,#0x24]
000094  eeb50ac0          VCMPE.F32 s0,#0.0
000098  eef1fa10          VMRS     APSR_nzcv,FPSCR
00009c  bfac              ITE      GE
00009e  eef00a40          VMOVGE.F32 s1,s0
0000a2  eef10a40          VNEGLT.F32 s1,s0
0000a6  ee100a90          VMOV     r0,s1
0000aa  4925              LDR      r1,|L2.320|
;;;421            maxAngularVel_ = POINT_TURN_TERMINAL_VEL_RAD_PER_S * (maxAngularVel_ > 0 ? 1 : -1);
0000ac  eddf9a25          VLDR     s19,|L2.324|
0000b0  4281              CMP      r1,r0                 ;420
0000b2  dd22              BLE      |L2.250|
0000b4  eeb50ac0          VCMPE.F32 s0,#0.0
0000b8  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000bc  bfd4              ITE      LE
0000be  f04f30ff          MOVLE    r0,#0xffffffff
0000c2  2001              MOVGT    r0,#1
0000c4  ee000a10          VMOV     s0,r0
0000c8  eeb80ac0          VCVT.F32.S32 s0,s0
0000cc  ee200a29          VMUL.F32 s0,s0,s19
0000d0  ed860a09          VSTR     s0,[r6,#0x24]
;;;422            PRINT("WARNING (PointTurn.TooSlow): Speeding up commanded point turn of %f rad/s to %f rad/s\n", maxAngularVel, maxAngularVel_);
0000d4  ee100a10          VMOV     r0,s0
0000d8  f7fffffe          BL       __aeabi_f2d
0000dc  4604              MOV      r4,r0
0000de  460d              MOV      r5,r1
0000e0  ee190a10          VMOV     r0,s18
0000e4  f7fffffe          BL       __aeabi_f2d
0000e8  ec410b11          VMOV     d1,r0,r1
0000ec  4816              LDR      r0,|L2.328|
0000ee  ec532b11          VMOV     r2,r3,d1
0000f2  e9cd4500          STRD     r4,r5,[sp,#0]
0000f6  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
                  |L2.250|
;;;423          }
;;;424          
;;;425          // Generate velocity profile
;;;426          // TODO: Use IMUFilter::GetRotationSpeed() for start speed?
;;;427          vpg_.StartProfile(0,
0000fa  ed961a09          VLDR     s2,[r6,#0x24]
0000fe  eeb51ac0          VCMPE.F32 s2,#0.0
000102  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;428                            currAngle,
;;;429                            maxAngularVel_,
;;;430                            angularAccel_,
;;;431                            maxAngularVel_ > 0 ? POINT_TURN_TERMINAL_VEL_RAD_PER_S : -POINT_TURN_TERMINAL_VEL_RAD_PER_S,
000106  bfcc              ITE      GT
000108  eeb02a69          VMOVGT.F32 s4,s19
00010c  ed9f2a0f          VLDRLE   s4,|L2.332|
000110  ed9f3a0f          VLDR     s6,|L2.336|
000114  eef02a48          VMOV.F32 s5,s16
000118  edd61a0a          VLDR     s3,[r6,#0x28]
00011c  eef00a68          VMOV.F32 s1,s17
000120  ed9f0a0c          VLDR     s0,|L2.340|
000124  480c              LDR      r0,|L2.344|
000126  f7fffffe          BL       _ZN4Anki24VelocityProfileGenerator12StartProfileEfffffff ; Anki::VelocityProfileGenerator::StartProfile(float, float, float, float, float, float, float)
;;;432                            destAngle,
;;;433                            CONTROL_DT);
;;;434        }
00012a  b004              ADD      sp,sp,#0x10
00012c  ecbd8b04          VPOP     {d8-d9}
000130  bd70              POP      {r4-r6,pc}
;;;435        
                          ENDP

000132  0000              DCW      0x0000
                  |L2.308|
                          DCD      ||.data||
                  |L2.312|
                          DCD      ||.data||+0x38
                  |L2.316|
00013c  40c90fdb          DCFS     0x40c90fdb ; 6.2831854820251465
                  |L2.320|
                          DCD      0x3ecccccd
                  |L2.324|
000144  3ecccccd          DCFS     0x3ecccccd ; 0.40000000596046448
                  |L2.328|
                          DCD      ||.conststring||
                  |L2.332|
00014c  becccccd          DCFS     0xbecccccd ; -0.40000000596046448
                  |L2.336|
000150  3ba3d70b          DCFS     0x3ba3d70b ; 0.0050000003539025784
                  |L2.340|
000154  00000000          DCFS     0x00000000 ; 0
                  |L2.344|
                          DCD      ||.bss||

                          AREA ||i._ZN4Anki5Cozmo18SteeringController16ManagePathFollowEv||, CODE, READONLY, ALIGN=3

                  _ZN4Anki5Cozmo18SteeringController16ManagePathFollowEv PROC ; Anki::Cozmo::SteeringController::ManagePathFollow()
;;;293        
;;;294        void ManagePathFollow()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;295        {
000004  ed2d8b02          VPUSH    {d8}
000008  b086              SUB      sp,sp,#0x18
;;;296          f32 pathDistErr = 0, pathRadErr = 0;
00000a  eddf8a47          VLDR     s17,|L3.296|
00000e  edcd8a05          VSTR     s17,[sp,#0x14]
000012  edcd8a04          VSTR     s17,[sp,#0x10]
;;;297          f32 fidx = INVALID_IDEAL_FOLLOW_LINE_IDX;
000016  ed9f8a45          VLDR     s16,|L3.300|
;;;298          if (PathFollower::IsTraversingPath()) {
00001a  f7fffffe          BL       _ZN4Anki5Cozmo12PathFollower16IsTraversingPathEv ; Anki::Cozmo::PathFollower::IsTraversingPath()
00001e  2800              CMP      r0,#0
000020  d062              BEQ      |L3.232|
;;;299            bool gotError = PathFollower::GetPathError(pathDistErr, pathRadErr);
000022  a904              ADD      r1,sp,#0x10
000024  a805              ADD      r0,sp,#0x14
000026  f7fffffe          BL       _ZN4Anki5Cozmo12PathFollower12GetPathErrorERfS2_ ; Anki::Cozmo::PathFollower::GetPathError(float&, float&)
;;;300            
;;;301            if (gotError) {
00002a  2800              CMP      r0,#0
00002c  d059              BEQ      |L3.226|
;;;302              fidx = pathDistErr;
00002e  ed9d8a05          VLDR     s16,[sp,#0x14]
;;;303              
;;;304              // HACK!
;;;305              //SetGains(DEFAULT_STEERING_K1, DEFAULT_STEERING_K2);
;;;306              if (DockingController::IsBusy()) {
000032  f7fffffe          BL       _ZN4Anki5Cozmo17DockingController6IsBusyEv ; Anki::Cozmo::DockingController::IsBusy()
000036  2800              CMP      r0,#0
000038  d02e              BEQ      |L3.152|
;;;307                //SetGains(DEFAULT_STEERING_K1, 5.f);
;;;308                fidx = CLIP(fidx, -5, 5);  // TODO: Loosen this up the closer we get to the block?????
00003a  ee180a10          VMOV     r0,s16
00003e  493c              LDR      r1,|L3.304|
000040  4288              CMP      r0,r1
000042  bf2c              ITE      CS
000044  eeb90a04          VMOVCS.F32 s0,#-5.00000000
000048  eeb00a48          VMOVCC.F32 s0,s16
00004c  ee100a10          VMOV     r0,s0
000050  4a38              LDR      r2,|L3.308|
000052  4290              CMP      r0,r2
000054  bfa8              IT       GE
000056  eeb18a04          VMOVGE.F32 s16,#5.00000000
00005a  da05              BGE      |L3.104|
00005c  ee180a10          VMOV     r0,s16
000060  4288              CMP      r0,r1
000062  bf28              IT       CS
000064  eeb98a04          VMOVCS.F32 s16,#-5.00000000
                  |L3.104|
;;;309                pathRadErr = CLIP(pathRadErr, -0.2, 0.2);
000068  4933              LDR      r1,|L3.312|
00006a  9804              LDR      r0,[sp,#0x10]
00006c  4288              CMP      r0,r1
00006e  d805              BHI      |L3.124|
000070  4a32              LDR      r2,|L3.316|
000072  4290              CMP      r0,r2
000074  bfa8              IT       GE
000076  ed9f0b32          VLDRGE   d0,|L3.320|
00007a  da08              BGE      |L3.142|
                  |L3.124|
00007c  4288              CMP      r0,r1
00007e  bf88              IT       HI
000080  ed9f0b31          VLDRHI   d0,|L3.328|
000084  d803              BHI      |L3.142|
000086  f7fffffe          BL       __aeabi_f2d
00008a  ec410b10          VMOV     d0,r0,r1
                  |L3.142|
00008e  ec510b10          VMOV     r0,r1,d0
000092  f7fffffe          BL       __aeabi_d2f
000096  9004              STR      r0,[sp,#0x10]
                  |L3.152|
;;;310              }
;;;311              
;;;312              PERIODIC_PRINT(1000,"fidx: %f, distErr %f, radErr %f\n", fidx, pathDistErr, pathRadErr);
000098  f8df80b4          LDR      r8,|L3.336|
00009c  f8b80004          LDRH     r0,[r8,#4]  ; cnt
0000a0  1c41              ADDS     r1,r0,#1
0000a2  f8a81004          STRH     r1,[r8,#4]
0000a6  f5b07f7a          CMP      r0,#0x3e8
0000aa  d31d              BCC      |L3.232|
0000ac  9804              LDR      r0,[sp,#0x10]
0000ae  f7fffffe          BL       __aeabi_f2d
0000b2  4606              MOV      r6,r0
0000b4  460f              MOV      r7,r1
0000b6  9805              LDR      r0,[sp,#0x14]
0000b8  f7fffffe          BL       __aeabi_f2d
0000bc  4604              MOV      r4,r0
0000be  460d              MOV      r5,r1
0000c0  ee180a10          VMOV     r0,s16
0000c4  f7fffffe          BL       __aeabi_f2d
0000c8  e88d00f0          STM      sp,{r4-r7}
0000cc  ec410b10          VMOV     d0,r0,r1
0000d0  a020              ADR      r0,|L3.340|
0000d2  ec532b10          VMOV     r2,r3,d0
0000d6  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
0000da  2000              MOVS     r0,#0
0000dc  f8a80004          STRH     r0,[r8,#4]
0000e0  e002              B        |L3.232|
                  |L3.226|
;;;313              //PRINT("fidx: %f, distErr %f, radErr %f\n", fidx, pathDistErr, pathRadErr);
;;;314    
;;;315            } else {
;;;316              SpeedController::SetUserCommandedDesiredVehicleSpeed(0);
0000e2  2000              MOVS     r0,#0
0000e4  f7fffffe          BL       _ZN4Anki5Cozmo15SpeedController35SetUserCommandedDesiredVehicleSpeedEs ; Anki::Cozmo::SpeedController::SetUserCommandedDesiredVehicleSpeed(short)
                  |L3.232|
;;;317            }
;;;318          }
;;;319          
;;;320          
;;;321          //If we found a valid followline, let's run the controller
;;;322          if (fidx != INVALID_IDEAL_FOLLOW_LINE_IDX) {
0000e8  ee180a10          VMOV     r0,s16
0000ec  4922              LDR      r1,|L3.376|
0000ee  4288              CMP      r0,r1
;;;323            // Run controller and pass in current speed
;;;324            RunLineFollowControllerNL( fidx, pathRadErr );
0000f0  bf1c              ITT      NE
0000f2  eddd0a04          VLDRNE   s1,[sp,#0x10]
0000f6  eeb00a48          VMOVNE.F32 s0,s16
0000fa  d10d              BNE      |L3.280|
;;;325            
;;;326          } else {
;;;327            // No steering intention -- unless desired speed is 0
;;;328            // we'll continue to use the previously commanded fidx
;;;329            if (SpeedController::GetUserCommandedDesiredVehicleSpeed() == 0) {
0000fc  f7fffffe          BL       _ZN4Anki5Cozmo15SpeedController35GetUserCommandedDesiredVehicleSpeedEv ; Anki::Cozmo::SpeedController::GetUserCommandedDesiredVehicleSpeed()
000100  2800              CMP      r0,#0
;;;330              RunLineFollowControllerNL( 0, 0);
000102  bf07              ITTEE    EQ
000104  eeb00a68          VMOVEQ.F32 s0,s17
000108  eef00a40          VMOVEQ.F32 s1,s0
;;;331            }
;;;332          }
;;;333        }
00010c  b006              ADDNE    sp,sp,#0x18
00010e  ecbd8b02          VPOPNE   {d8}
000112  bf18              IT       NE
000114  e8bd81f0          POPNE    {r4-r8,pc}
                  |L3.280|
000118  f7fffffe          BL       _ZN4Anki5Cozmo18SteeringController25RunLineFollowControllerNLEff ; Anki::Cozmo::SteeringController::RunLineFollowControllerNL(float, float)
00011c  b006              ADD      sp,sp,#0x18
00011e  ecbd8b02          VPOP     {d8}
000122  e8bd81f0          POP      {r4-r8,pc}
;;;334    
                          ENDP

000126  0000              DCW      0x0000
                  |L3.296|
000128  00000000          DCFS     0x00000000 ; 0
                  |L3.300|
00012c  46fffe00          DCFS     0x46fffe00 ; 32767
                  |L3.304|
                          DCD      0xc0a00000
                  |L3.308|
                          DCD      0x40a00000
                  |L3.312|
                          DCD      0xbe4ccccd
                  |L3.316|
                          DCD      0x3e4ccccd
                  |L3.320|
000140  9999999a          DCFD     0x3fc999999999999a ; 0.20000000000000001
000144  3fc99999
                  |L3.328|
000148  9999999a          DCFD     0xbfc999999999999a ; -0.20000000000000001
00014c  bfc99999
                  |L3.336|
                          DCD      ||.data||
                  |L3.340|
000154  66696478          DCB      "fidx: %f, distErr %f, radErr %f\n",0
000158  3a202566
00015c  2c206469
000160  73744572
000164  72202566
000168  2c207261
00016c  64457272
000170  2025660a
000174  00      
000175  00                DCB      0
000176  00                DCB      0
000177  00                DCB      0
                  |L3.376|
                          DCD      0x46fffe00

                          AREA ||i._ZN4Anki5Cozmo18SteeringController17ManageDirectDriveEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController17ManageDirectDriveEv PROC ; Anki::Cozmo::SteeringController::ManageDirectDrive()
;;;356        
;;;357        void ManageDirectDrive()
000000  b500              PUSH     {lr}
;;;358        {
000002  b083              SUB      sp,sp,#0xc
;;;359          // Get current desired wheel speeds
;;;360          f32 currLeftVel, currRightVel;
;;;361          WheelController::GetDesiredWheelSpeeds(currLeftVel, currRightVel);
000004  4669              MOV      r1,sp
000006  a801              ADD      r0,sp,#4
000008  f7fffffe          BL       _ZN4Anki5Cozmo15WheelController21GetDesiredWheelSpeedsERfS2_ ; Anki::Cozmo::WheelController::GetDesiredWheelSpeeds(float&, float&)
;;;362          
;;;363    //      PRINT("CURR: %f %f\n", targetLeftVel_, targetRightVel_);
;;;364         
;;;365          if (leftAccelPerCycle_ == 0) {
00000c  4830              LDR      r0,|L4.208|
00000e  ed900a07          VLDR     s0,[r0,#0x1c]
000012  eeb50ac0          VCMPE.F32 s0,#0.0
000016  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;366            // max acceleration (i.e. command target velocity)
;;;367            currLeftVel = targetLeftVel_;
00001a  bf08              IT       EQ
00001c  ed900a05          VLDREQ   s0,[r0,#0x14]
000020  d01f              BEQ      |L4.98|
;;;368          } else {
;;;369            if (ABS(currLeftVel - targetLeftVel_) < ABS(leftAccelPerCycle_)) {
000022  ed9d1a01          VLDR     s2,[sp,#4]
000026  edd00a05          VLDR     s1,[r0,#0x14]
00002a  ee711a60          VSUB.F32 s3,s2,s1
00002e  eef51ac0          VCMPE.F32 s3,#0.0
000032  eef1fa10          VMRS     APSR_nzcv,FPSCR
000036  bfb8              IT       LT
000038  ee701ac1          VSUBLT.F32 s3,s1,s2
00003c  eeb50ac0          VCMPE.F32 s0,#0.0
000040  eef1fa10          VMRS     APSR_nzcv,FPSCR
000044  bfac              ITE      GE
000046  eeb02a40          VMOVGE.F32 s4,s0
00004a  eeb12a40          VNEGLT.F32 s4,s0
00004e  eef41ac2          VCMPE.F32 s3,s4
000052  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;370              currLeftVel = targetLeftVel_;
000056  bf34              ITE      CC
000058  edcd0a01          VSTRCC   s1,[sp,#4]
;;;371            } else {
;;;372              currLeftVel += leftAccelPerCycle_;
00005c  ee310a00          VADDCS.F32 s0,s2,s0
000060  d301              BCC      |L4.102|
                  |L4.98|
000062  ed8d0a01          VSTR     s0,[sp,#4]
                  |L4.102|
;;;373            }
;;;374          }
;;;375          
;;;376          if (rightAccelPerCycle_ == 0) {
000066  ed900a08          VLDR     s0,[r0,#0x20]
00006a  eeb50ac0          VCMPE.F32 s0,#0.0
00006e  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;377            // max acceleration (i.e. command target velocity)
;;;378            currRightVel = targetRightVel_;
000072  bf08              IT       EQ
000074  ed900a06          VLDREQ   s0,[r0,#0x18]
000078  d01f              BEQ      |L4.186|
;;;379          } else {
;;;380            if (ABS(currRightVel - targetRightVel_) < ABS(rightAccelPerCycle_)) {
00007a  eddd0a00          VLDR     s1,[sp,#0]
00007e  ed901a06          VLDR     s2,[r0,#0x18]
000082  ee701ac1          VSUB.F32 s3,s1,s2
000086  eef51ac0          VCMPE.F32 s3,#0.0
00008a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00008e  bfb8              IT       LT
000090  ee711a60          VSUBLT.F32 s3,s2,s1
000094  eeb50ac0          VCMPE.F32 s0,#0.0
000098  eef1fa10          VMRS     APSR_nzcv,FPSCR
00009c  bfac              ITE      GE
00009e  eeb02a40          VMOVGE.F32 s4,s0
0000a2  eeb12a40          VNEGLT.F32 s4,s0
0000a6  eef41ac2          VCMPE.F32 s3,s4
0000aa  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;381              currRightVel = targetRightVel_;
0000ae  bf34              ITE      CC
0000b0  ed8d1a00          VSTRCC   s2,[sp,#0]
;;;382            } else {
;;;383              currRightVel += rightAccelPerCycle_;
0000b4  ee300a80          VADDCS.F32 s0,s1,s0
0000b8  d301              BCC      |L4.190|
                  |L4.186|
0000ba  ed8d0a00          VSTR     s0,[sp,#0]
                  |L4.190|
;;;384            }
;;;385          }
;;;386          
;;;387          WheelController::SetDesiredWheelSpeeds(currLeftVel, currRightVel);
0000be  eddd0a00          VLDR     s1,[sp,#0]
0000c2  ed9d0a01          VLDR     s0,[sp,#4]
0000c6  f7fffffe          BL       _ZN4Anki5Cozmo15WheelController21SetDesiredWheelSpeedsEff ; Anki::Cozmo::WheelController::SetDesiredWheelSpeeds(float, float)
;;;388          
;;;389        }
0000ca  b003              ADD      sp,sp,#0xc
0000cc  bd00              POP      {pc}
;;;390        
                          ENDP

0000ce  0000              DCW      0x0000
                  |L4.208|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo18SteeringController17SetPathFollowModeEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController17SetPathFollowModeEv PROC ; Anki::Cozmo::SteeringController::SetPathFollowMode()
;;;287        
;;;288        void SetPathFollowMode()
000000  4901              LDR      r1,|L5.8|
;;;289        {
;;;290          currSteerMode_ = SM_PATH_FOLLOW;
000002  2000              MOVS     r0,#0
000004  7048              STRB     r0,[r1,#1]
;;;291        }
000006  4770              BX       lr
;;;292        
                          ENDP

                  |L5.8|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo18SteeringController18ExecuteDirectDriveEffff||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController18ExecuteDirectDriveEffff PROC ; Anki::Cozmo::SteeringController::ExecuteDirectDrive(float, float, float, float)
;;;335        
;;;336        void ExecuteDirectDrive(f32 left_vel, f32 right_vel, f32 left_accel, f32 right_accel)
000000  b510              PUSH     {r4,lr}
;;;337        {
;;;338          //PRINT("DIRECT DRIVE %f %f\n", left_vel, right_vel);
;;;339          currSteerMode_ = SM_DIRECT_DRIVE;
000002  4c24              LDR      r4,|L6.148|
000004  2001              MOVS     r0,#1
000006  ed2d8b04          VPUSH    {d8-d9}               ;337
00000a  b082              SUB      sp,sp,#8              ;337
00000c  eeb08a61          VMOV.F32 s16,s3                ;337
000010  7060              STRB     r0,[r4,#1]
000012  eef08a41          VMOV.F32 s17,s2                ;337
000016  eef09a60          VMOV.F32 s19,s1                ;337
00001a  eeb09a40          VMOV.F32 s18,s0                ;337
;;;340          
;;;341          // Get current desired wheel speeds
;;;342          f32 currLeftVel, currRightVel;
;;;343          WheelController::GetDesiredWheelSpeeds(currLeftVel, currRightVel);
00001e  a901              ADD      r1,sp,#4
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       _ZN4Anki5Cozmo15WheelController21GetDesiredWheelSpeedsERfS2_ ; Anki::Cozmo::WheelController::GetDesiredWheelSpeeds(float&, float&)
;;;344          
;;;345          targetLeftVel_ = left_vel;
;;;346          targetRightVel_ = right_vel;
;;;347          leftAccelPerCycle_ = ABS(left_accel) * CONTROL_DT;
000026  eef58ac0          VCMPE.F32 s17,#0.0
00002a  ed849a05          VSTR     s18,[r4,#0x14]        ;345
00002e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000032  edc49a06          VSTR     s19,[r4,#0x18]        ;346
000036  bfb8              IT       LT
000038  eef18a68          VNEGLT.F32 s17,s17
00003c  ed9f0a16          VLDR     s0,|L6.152|
;;;348          rightAccelPerCycle_ = ABS(right_accel) * CONTROL_DT;
000040  eeb58ac0          VCMPE.F32 s16,#0.0
000044  ee681a80          VMUL.F32 s3,s17,s0             ;347
000048  eef1fa10          VMRS     APSR_nzcv,FPSCR
00004c  edc41a07          VSTR     s3,[r4,#0x1c]         ;347
000050  bfb8              IT       LT
000052  eeb18a48          VNEGLT.F32 s16,s16
000056  ee281a00          VMUL.F32 s2,s16,s0
00005a  ed841a08          VSTR     s2,[r4,#0x20]
;;;349          
;;;350          if (currLeftVel > targetLeftVel_)
00005e  ed9d0a00          VLDR     s0,[sp,#0]
000062  eeb40ac9          VCMPE.F32 s0,s18
000066  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;351            leftAccelPerCycle_ *= -1;
00006a  bfc4              ITT      GT
00006c  eeb10a61          VNEGGT.F32 s0,s3
000070  ed840a07          VSTRGT   s0,[r4,#0x1c]
;;;352          if (currRightVel > targetRightVel_)
000074  ed9d0a01          VLDR     s0,[sp,#4]
000078  eeb40ae9          VCMPE.F32 s0,s19
00007c  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;353            rightAccelPerCycle_ *= -1;
000080  bfc4              ITT      GT
000082  eeb10a41          VNEGGT.F32 s0,s2
000086  ed840a08          VSTRGT   s0,[r4,#0x20]
;;;354          
;;;355        }
00008a  b002              ADD      sp,sp,#8
00008c  ecbd8b04          VPOP     {d8-d9}
000090  bd10              POP      {r4,pc}
;;;356        
                          ENDP

000092  0000              DCW      0x0000
                  |L6.148|
                          DCD      ||.data||
                  |L6.152|
000098  3ba3d70b          DCFS     0x3ba3d70b ; 0.0050000003539025784

                          AREA ||i._ZN4Anki5Cozmo18SteeringController21CheckWheelSpeedLimitsERfS2_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController21CheckWheelSpeedLimitsERfS2_ PROC ; Anki::Cozmo::SteeringController::CheckWheelSpeedLimits(float&, float&)
;;;132        // 2) If wheel speeds will cause robot to turn faster than permitted, shift both wheel speed towards each other.
;;;133        void CheckWheelSpeedLimits(f32& lSpeed, f32& rSpeed)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;134        {
;;;135          
;;;136          // Do any of the speeds exceed max?
;;;137          // If so, then shift both speeds to be within range by the same amount
;;;138          // so that desired curvature is still achieved.
;;;139          // If we're in path following mode, maintaining proper curvature
;;;140          // is probably more important than maintaining speed.
;;;141          f32 *lowerWheelSpeed = &lSpeed;
000004  4602              MOV      r2,r0
000006  ed2d8b02          VPUSH    {d8}                  ;134
00000a  b084              SUB      sp,sp,#0x10           ;134
;;;142          f32 *higherWheelSpeed = &rSpeed;
;;;143          if (lSpeed > rSpeed) {
00000c  ed900a00          VLDR     s0,[r0,#0]
000010  edd10a00          VLDR     s1,[r1,#0]
000014  460c              MOV      r4,r1                 ;142
000016  eeb40ae0          VCMPE.F32 s0,s1
00001a  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;144            lowerWheelSpeed = &rSpeed;
00001e  bfc4              ITT      GT
000020  4622              MOVGT    r2,r4
;;;145            higherWheelSpeed = &lSpeed;
000022  4604              MOVGT    r4,r0
;;;146          }
;;;147          
;;;148          f32 wheelSpeedDiff = *higherWheelSpeed - *lowerWheelSpeed;
000024  ed940a00          VLDR     s0,[r4,#0]
000028  edd20a00          VLDR     s1,[r2,#0]
;;;149          f32 avgSpeed = (*higherWheelSpeed + *lowerWheelSpeed) * 0.5f;
00002c  eef61a00          VMOV.F32 s3,#0.50000000
;;;150          
;;;151          // Center speeds on 0 if wheelSpeedDiff exceeds maximum achievable wheel speed
;;;152          if (wheelSpeedDiff > 2*MAX_WHEEL_SPEED_MMPS) {
000030  4943              LDR      r1,|L7.320|
000032  ee301a60          VSUB.F32 s2,s0,s1              ;148
000036  ee700a20          VADD.F32 s1,s0,s1              ;149
00003a  ee110a10          VMOV     r0,s2
00003e  ee600aa1          VMUL.F32 s1,s1,s3              ;149
000042  4288              CMP      r0,r1
000044  dd09              BLE      |L7.90|
;;;153            *higherWheelSpeed -= avgSpeed;
000046  ee300a60          VSUB.F32 s0,s0,s1
00004a  ed840a00          VSTR     s0,[r4,#0]
;;;154            *lowerWheelSpeed -= avgSpeed;
00004e  ed920a00          VLDR     s0,[r2,#0]
000052  ee300a60          VSUB.F32 s0,s0,s1
000056  ed820a00          VSTR     s0,[r2,#0]
                  |L7.90|
;;;155          }
;;;156          
;;;157          // If higherWheelSpeed exceeds max, decrease both wheel speeds
;;;158          if (*higherWheelSpeed > MAX_WHEEL_SPEED_MMPS) {
00005a  ed940a00          VLDR     s0,[r4,#0]
00005e  4939              LDR      r1,|L7.324|
000060  ee100a10          VMOV     r0,s0
;;;159            *lowerWheelSpeed -= *higherWheelSpeed - MAX_WHEEL_SPEED_MMPS;
000064  eddf0a38          VLDR     s1,|L7.328|
000068  4288              CMP      r0,r1                 ;158
00006a  dd0f              BLE      |L7.140|
00006c  ee300a60          VSUB.F32 s0,s0,s1
000070  ed921a00          VLDR     s2,[r2,#0]
000074  ee310a40          VSUB.F32 s0,s2,s0
000078  ed820a00          VSTR     s0,[r2,#0]
;;;160            *higherWheelSpeed -= *higherWheelSpeed - MAX_WHEEL_SPEED_MMPS;
00007c  ed940a00          VLDR     s0,[r4,#0]
000080  ee301a60          VSUB.F32 s2,s0,s1
000084  ee300a41          VSUB.F32 s0,s0,s2
000088  ed840a00          VSTR     s0,[r4,#0]
                  |L7.140|
;;;161          }
;;;162          
;;;163          // If lowerWheelSpeed is faster than negative max, increase both wheel speeds
;;;164          if (*lowerWheelSpeed < -MAX_WHEEL_SPEED_MMPS) {
00008c  ed920a00          VLDR     s0,[r2,#0]
000090  492e              LDR      r1,|L7.332|
000092  ee100a10          VMOV     r0,s0
000096  4288              CMP      r0,r1
000098  d90f              BLS      |L7.186|
;;;165            *higherWheelSpeed -= *lowerWheelSpeed + MAX_WHEEL_SPEED_MMPS;
00009a  ee300a20          VADD.F32 s0,s0,s1
00009e  ed941a00          VLDR     s2,[r4,#0]
0000a2  ee310a40          VSUB.F32 s0,s2,s0
0000a6  ed840a00          VSTR     s0,[r4,#0]
;;;166            *lowerWheelSpeed -= *lowerWheelSpeed + MAX_WHEEL_SPEED_MMPS;
0000aa  ed920a00          VLDR     s0,[r2,#0]
0000ae  ee700a20          VADD.F32 s1,s0,s1
0000b2  ee300a60          VSUB.F32 s0,s0,s1
0000b6  ed820a00          VSTR     s0,[r2,#0]
                  |L7.186|
;;;167          }
;;;168          
;;;169          // TODO: Should we also make sure that neither the left or right wheel is
;;;170          // driving at a speed that is less than the minimum wheel speed?
;;;171          // What's the point of commanding unreachable desired speeds?
;;;172          // ...
;;;173          
;;;174          
;;;175          // Check turning speed limit
;;;176          if (maxRotationWheelSpeedDiff > 0) {
0000ba  4825              LDR      r0,|L7.336|
0000bc  ed900a04          VLDR     s0,[r0,#0x10]
0000c0  eeb50ac0          VCMPE.F32 s0,#0.0
0000c4  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;177            wheelSpeedDiff = *higherWheelSpeed - *lowerWheelSpeed;
;;;178            if (wheelSpeedDiff > maxRotationWheelSpeedDiff) {
;;;179              f32 speedAdjust = 0.5*(wheelSpeedDiff - maxRotationWheelSpeedDiff);
;;;180              *higherWheelSpeed -= speedAdjust;
;;;181              *lowerWheelSpeed += speedAdjust;
;;;182              PRINT("  Wheel speed adjust: (%f, %f), adjustment %f\n", *higherWheelSpeed, *lowerWheelSpeed, speedAdjust);
;;;183            }
;;;184          }
;;;185          
;;;186        }
0000c8  bfde              ITTT     LE
0000ca  b004              ADDLE    sp,sp,#0x10
0000cc  ecbd8b02          VPOPLE   {d8}
0000d0  e8bd81f0          POPLE    {r4-r8,pc}
0000d4  ed941a00          VLDR     s2,[r4,#0]            ;177
0000d8  edd20a00          VLDR     s1,[r2,#0]            ;177
0000dc  ee710a60          VSUB.F32 s1,s2,s1              ;177
0000e0  eef40ac0          VCMPE.F32 s1,s0                 ;178
0000e4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;178
0000e8  dd25              BLE      |L7.310|
0000ea  ee300ac0          VSUB.F32 s0,s1,s0              ;179
0000ee  ee200a21          VMUL.F32 s0,s0,s3              ;179
0000f2  ee100a10          VMOV     r0,s0                 ;182
0000f6  ee710a40          VSUB.F32 s1,s2,s0              ;180
0000fa  edc40a00          VSTR     s1,[r4,#0]            ;180
0000fe  edd20a00          VLDR     s1,[r2,#0]            ;181
000102  ee308a80          VADD.F32 s16,s1,s0             ;181
000106  ed828a00          VSTR     s16,[r2,#0]           ;181
00010a  f7fffffe          BL       __aeabi_f2d
00010e  4607              MOV      r7,r0                 ;182
000110  4688              MOV      r8,r1                 ;182
000112  ee180a10          VMOV     r0,s16                ;182
000116  f7fffffe          BL       __aeabi_f2d
00011a  4605              MOV      r5,r0                 ;182
00011c  460e              MOV      r6,r1                 ;182
00011e  6820              LDR      r0,[r4,#0]            ;182
000120  f7fffffe          BL       __aeabi_f2d
000124  e88d01e0          STM      sp,{r5-r8}            ;182
000128  ec410b10          VMOV     d0,r0,r1              ;182
00012c  a009              ADR      r0,|L7.340|
00012e  ec532b10          VMOV     r2,r3,d0              ;182
000132  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
                  |L7.310|
000136  b004              ADD      sp,sp,#0x10
000138  ecbd8b02          VPOP     {d8}
00013c  e8bd81f0          POP      {r4-r8,pc}
;;;187        
                          ENDP

                  |L7.320|
                          DCD      0x43aa0000
                  |L7.324|
                          DCD      0x432a0000
                  |L7.328|
000148  432a0000          DCFS     0x432a0000 ; 170
                  |L7.332|
                          DCD      0xc32a0000
                  |L7.336|
                          DCD      ||.data||
                  |L7.340|
000154  20205768          DCB      "  Wheel speed adjust: (%f, %f), adjustment %f\n",0
000158  65656c20
00015c  73706565
000160  64206164
000164  6a757374
000168  3a202825
00016c  662c2025
000170  66292c20
000174  61646a75
000178  73746d65
00017c  6e742025
000180  660a00  
000183  00                DCB      0

                          AREA ||i._ZN4Anki5Cozmo18SteeringController21SetRotationSpeedLimitEf||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController21SetRotationSpeedLimitEf PROC ; Anki::Cozmo::SteeringController::SetRotationSpeedLimit(float)
;;;119        
;;;120        void SetRotationSpeedLimit(f32 rad_per_s)
000000  eddf0a03          VLDR     s1,|L8.16|
;;;121        {
;;;122          maxRotationWheelSpeedDiff = rad_per_s * WHEEL_DIST_MM;
000004  4803              LDR      r0,|L8.20|
000006  ee200a20          VMUL.F32 s0,s0,s1
00000a  ed800a04          VSTR     s0,[r0,#0x10]
;;;123        }
00000e  4770              BX       lr
;;;124        
                          ENDP

                  |L8.16|
000010  423ecccd          DCFS     0x423ecccd ; 47.700000762939453
                  |L8.20|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo18SteeringController25DisableRotationSpeedLimitEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController25DisableRotationSpeedLimitEv PROC ; Anki::Cozmo::SteeringController::DisableRotationSpeedLimit()
;;;124        
;;;125        void DisableRotationSpeedLimit()
000000  4803              LDR      r0,|L9.16|
;;;126        {
;;;127          maxRotationWheelSpeedDiff = 0.f;
000002  ed9f0a02          VLDR     s0,|L9.12|
000006  ed800a04          VSTR     s0,[r0,#0x10]
;;;128        }
00000a  4770              BX       lr
;;;129        
                          ENDP

                  |L9.12|
00000c  00000000          DCFS     0x00000000 ; 0
                  |L9.16|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo18SteeringController25RunLineFollowControllerNLEff||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController25RunLineFollowControllerNLEff PROC ; Anki::Cozmo::SteeringController::RunLineFollowControllerNL(float, float)
;;;201         */
;;;202        void RunLineFollowControllerNL(f32 offsetError_mm, float headingError_rad)
000000  b570              PUSH     {r4-r6,lr}
;;;203        {
000002  ed2d8b04          VPUSH    {d8-d9}
000006  b084              SUB      sp,sp,#0x10
000008  eeb08a60          VMOV.F32 s16,s1
00000c  eef08a40          VMOV.F32 s17,s0
;;;204          
;;;205          //We only steer in certain cases, for example if the car is supposed to move
;;;206          static bool steering_active = FALSE;
;;;207    
;;;208          // Control law
;;;209          float curvature = 0;
000010  ed9f9a5c          VLDR     s18,|L10.388|
;;;210          
;;;211          //Get the current vehicle speed (based on encoder values etc.) in mm/sec
;;;212          s16 currspeed = SpeedController::GetCurrentMeasuredVehicleSpeed();
000014  f7fffffe          BL       _ZN4Anki5Cozmo15SpeedController30GetCurrentMeasuredVehicleSpeedEv ; Anki::Cozmo::SpeedController::GetCurrentMeasuredVehicleSpeed()
000018  4605              MOV      r5,r0
;;;213          //Get the desired vehicle speed (the one the user commanded to the car)
;;;214          s16 desspeed = SpeedController::GetControllerCommandedVehicleSpeed();
00001a  f7fffffe          BL       _ZN4Anki5Cozmo15SpeedController34GetControllerCommandedVehicleSpeedEv ; Anki::Cozmo::SpeedController::GetControllerCommandedVehicleSpeed()
00001e  4604              MOV      r4,r0
;;;215          
;;;216          // If moving backwards, modify distance and angular error such that proper curvature
;;;217          // is computed below.
;;;218          if (currspeed < 0) {
000020  2d00              CMP      r5,#0
000022  da0c              BGE      |L10.62|
;;;219            offsetError_mm *= -1;
000024  eef18a68          VNEG.F32 s17,s17
;;;220            headingError_rad = -Radians(headingError_rad + PI_F).ToFloat();
000028  ed9f0a57          VLDR     s0,|L10.392|
00002c  a802              ADD      r0,sp,#8
00002e  ee380a00          VADD.F32 s0,s16,s0
000032  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
000036  ed900a00          VLDR     s0,[r0,#0]
00003a  eeb18a40          VNEG.F32 s16,s0
                  |L10.62|
;;;221          }
;;;222          
;;;223          ///////////////////////////////////////////////////////////////////////////////
;;;224          
;;;225          // Activate steering if: We are moving and the commanded speed is bigger than
;;;226          // zero (or bigger than 0+eps)
;;;227          if(SpeedController::IsVehicleStopped() == FALSE && ABS(desspeed) > SpeedController::SPEED_CONSIDER_VEHICLE_STOPPED_MM_S) {
00003e  f7fffffe          BL       _ZN4Anki5Cozmo15SpeedController16IsVehicleStoppedEv ; Anki::Cozmo::SpeedController::IsVehicleStopped()
;;;228            steering_active = TRUE;
000042  4e52              LDR      r6,|L10.396|
000044  b920              CBNZ     r0,|L10.80|
000046  1ca0              ADDS     r0,r4,#2              ;227
000048  2804              CMP      r0,#4                 ;227
00004a  bf84              ITT      HI
00004c  2001              MOVHI    r0,#1
00004e  70b0              STRBHI   r0,[r6,#2]
                  |L10.80|
;;;229            
;;;230          }
;;;231          
;;;232          
;;;233          // Desired behavior?  We probably only want the robot to actively steering when it's attempting to follow a path.
;;;234          // When it's not following a path, you should be able to push it around freely.
;;;235          
;;;236          //Deactivate steering if: We are not really moving and the commanded speed is zero (or smaller than 0+eps)
;;;237          if (SpeedController::IsVehicleStopped() == TRUE && ABS(desspeed) <= SpeedController::SPEED_CONSIDER_VEHICLE_STOPPED_MM_S) {
000050  f7fffffe          BL       _ZN4Anki5Cozmo15SpeedController16IsVehicleStoppedEv ; Anki::Cozmo::SpeedController::IsVehicleStopped()
000054  2800              CMP      r0,#0
;;;238            steering_active = false;
;;;239            
;;;240            // Set wheel controller coast mode as we finish decelerating to 0
;;;241            WheelController::SetCoastMode(true);
;;;242          }
;;;243          
;;;244          // If we're commanding any non-zero speed, don't coast
;;;245          if(ABS(desspeed) > SpeedController::SPEED_CONSIDER_VEHICLE_STOPPED_MM_S) {
000056  f1040002          ADD      r0,r4,#2
00005a  d005              BEQ      |L10.104|
00005c  2804              CMP      r0,#4                 ;237
00005e  d805              BHI      |L10.108|
000060  2000              MOVS     r0,#0                 ;238
000062  70b0              STRB     r0,[r6,#2]            ;238
000064  2001              MOVS     r0,#1                 ;241
000066  e002              B        |L10.110|
                  |L10.104|
000068  2804              CMP      r0,#4
00006a  d902              BLS      |L10.114|
                  |L10.108|
;;;246            WheelController::SetCoastMode(false);
00006c  2000              MOVS     r0,#0
                  |L10.110|
00006e  f7fffffe          BL       _ZN4Anki5Cozmo15WheelController12SetCoastModeEb ; Anki::Cozmo::WheelController::SetCoastMode(bool)
                  |L10.114|
;;;247          }
;;;248          
;;;249          ///////////////////////////////////////////////////////////////////////////////
;;;250          if (steering_active == TRUE)
000072  78b0              LDRB     r0,[r6,#2]  ; steering_active
000074  b1b0              CBZ      r0,|L10.164|
;;;251          {
;;;252            curvature = -K1_ * (atan_fast(K2_ * offsetError_mm / (ABS(currspeed) + 200)) - headingError_rad);
000076  ed960a03          VLDR     s0,[r6,#0xc]
00007a  2d00              CMP      r5,#0
00007c  ee600a28          VMUL.F32 s1,s0,s17
000080  bfb8              IT       LT
000082  426d              RSBLT    r5,r5,#0
000084  f10500c8          ADD      r0,r5,#0xc8
000088  ee000a10          VMOV     s0,r0
00008c  eeb81ac0          VCVT.F32.S32 s2,s0
000090  ee800a81          VDIV.F32 s0,s1,s2
000094  f7fffffe          BL       _Z9atan_fastf ; atan_fast(float)
000098  ee300a48          VSUB.F32 s0,s0,s16
00009c  edd60a02          VLDR     s1,[r6,#8]
;;;253          } else {
;;;254            curvature = 0;
;;;255          }
;;;256          
;;;257    #if(DEBUG_STEERING_CONTROLLER)
;;;258          PRINT(" STEERING: offsetError_mm: %f, headingError_rad: %f, curvature: %f, currSpeed: %d\n", offsetError_mm, headingError_rad, curvature, currspeed);
;;;259    #endif
;;;260          
;;;261          
;;;262          //We are moving along a circle, so let's compute the speed for the single wheels
;;;263          //Let's interpret the delta_speed as a curvature:
;;;264          //Curvature is 1/radius
;;;265          // Commanded speeds to wheels are desired speed + offsets for curvature
;;;266          
;;;267          //if delta speed is positive, the left wheel is supposed to turn slower, it becomes the INNER wheel
;;;268          float leftspeed =  (float)desspeed - WHEEL_DIST_HALF_MM * curvature * desspeed;
;;;269          
;;;270          //if delta speed is positive, the right wheel is supposed to turn faster, it becomes the OUTER wheel
;;;271          float rightspeed = (float)desspeed + WHEEL_DIST_HALF_MM * curvature * desspeed;
;;;272          
;;;273          
;;;274          CheckWheelSpeedLimits(leftspeed, rightspeed);
;;;275              
;;;276          s16 wleft = (s16)CLIP(leftspeed,s16_MIN,s16_MAX);
;;;277          s16 wright = (s16)CLIP(rightspeed,s16_MIN,s16_MAX);
;;;278          
;;;279    #if(DEBUG_STEERING_CONTROLLER)
;;;280          PRINT(" STEERING: %d (L), %d (R)\n", wleft, wright);
;;;281    #endif
;;;282          
;;;283          //Command the desired wheel speeds to the wheels
;;;284          WheelController::SetDesiredWheelSpeeds(wleft, wright);
;;;285        }
0000a0  ee209ac0          VNMUL.F32 s18,s1,s0
                  |L10.164|
0000a4  ee004a90          VMOV     s1,r4                 ;268
0000a8  ed9f0a39          VLDR     s0,|L10.400|
0000ac  a901              ADD      r1,sp,#4              ;274
0000ae  eeb81ae0          VCVT.F32.S32 s2,s1                 ;268
0000b2  ee004a90          VMOV     s1,r4                 ;268
0000b6  ee290a00          VMUL.F32 s0,s18,s0             ;268
0000ba  4668              MOV      r0,sp                 ;274
0000bc  eef80ae0          VCVT.F32.S32 s1,s1                 ;268
0000c0  ee400a41          VMLS.F32 s1,s0,s2              ;268
0000c4  edcd0a00          VSTR     s1,[sp,#0]            ;268
0000c8  ee004a90          VMOV     s1,r4                 ;271
0000cc  eeb81ae0          VCVT.F32.S32 s2,s1                 ;271
0000d0  ee004a90          VMOV     s1,r4                 ;271
0000d4  eef80ae0          VCVT.F32.S32 s1,s1                 ;271
0000d8  ee400a01          VMLA.F32 s1,s0,s2              ;271
0000dc  edcd0a01          VSTR     s1,[sp,#4]            ;271
0000e0  f7fffffe          BL       _ZN4Anki5Cozmo18SteeringController21CheckWheelSpeedLimitsERfS2_ ; Anki::Cozmo::SteeringController::CheckWheelSpeedLimits(float&, float&)
0000e4  ed9d0a00          VLDR     s0,[sp,#0]            ;276
0000e8  ed9f1a2a          VLDR     s2,|L10.404|
0000ec  ee100a10          VMOV     r0,s0                 ;276
0000f0  f1b04f47          CMP      r0,#0xc7000000        ;276
0000f4  bf34              ITE      CC                    ;276
0000f6  eef00a40          VMOVCC.F32 s1,s0                 ;276
0000fa  eef00a41          VMOVCS.F32 s1,s2                 ;276
0000fe  ee100a90          VMOV     r0,s1                 ;276
000102  4a25              LDR      r2,|L10.408|
000104  eddf1a25          VLDR     s3,|L10.412|
000108  4290              CMP      r0,r2                 ;276
00010a  bfa8              IT       GE                    ;276
00010c  eeb00a61          VMOVGE.F32 s0,s3                 ;276
000110  da06              BGE      |L10.288|
000112  ee100a10          VMOV     r0,s0                 ;276
000116  f1b04f47          CMP      r0,#0xc7000000        ;276
00011a  bf28              IT       CS                    ;276
00011c  eeb00a41          VMOVCS.F32 s0,s2                 ;276
                  |L10.288|
000120  eebd0ac0          VCVT.S32.F32 s0,s0                 ;276
000124  ee100a10          VMOV     r0,s0                 ;276
000128  ed9d0a01          VLDR     s0,[sp,#4]            ;277
00012c  b201              SXTH     r1,r0                 ;276
00012e  ee100a10          VMOV     r0,s0                 ;277
000132  f1b04f47          CMP      r0,#0xc7000000        ;277
000136  bf34              ITE      CC                    ;277
000138  eef00a40          VMOVCC.F32 s1,s0                 ;277
00013c  eef00a41          VMOVCS.F32 s1,s2                 ;277
000140  ee100a90          VMOV     r0,s1                 ;277
000144  4290              CMP      r0,r2                 ;277
000146  bfa8              IT       GE                    ;277
000148  eeb00a61          VMOVGE.F32 s0,s3                 ;277
00014c  da06              BGE      |L10.348|
00014e  ee100a10          VMOV     r0,s0                 ;277
000152  f1b04f47          CMP      r0,#0xc7000000        ;277
000156  bf28              IT       CS                    ;277
000158  eeb00a41          VMOVCS.F32 s0,s2                 ;277
                  |L10.348|
00015c  eebd0ac0          VCVT.S32.F32 s0,s0                 ;277
000160  ee100a10          VMOV     r0,s0                 ;277
000164  b200              SXTH     r0,r0                 ;277
000166  ee000a10          VMOV     s0,r0                 ;284
00016a  eef80ac0          VCVT.F32.S32 s1,s0                 ;284
00016e  ee001a10          VMOV     s0,r1                 ;284
000172  eeb80ac0          VCVT.F32.S32 s0,s0                 ;284
000176  f7fffffe          BL       _ZN4Anki5Cozmo15WheelController21SetDesiredWheelSpeedsEff ; Anki::Cozmo::WheelController::SetDesiredWheelSpeeds(float, float)
00017a  b004              ADD      sp,sp,#0x10
00017c  ecbd8b04          VPOP     {d8-d9}
000180  bd70              POP      {r4-r6,pc}
;;;286        
                          ENDP

000182  0000              DCW      0x0000
                  |L10.388|
000184  00000000          DCFS     0x00000000 ; 0
                  |L10.392|
000188  40490fdb          DCFS     0x40490fdb ; 3.1415927410125732
                  |L10.396|
                          DCD      ||.data||
                  |L10.400|
000190  41becccd          DCFS     0x41becccd ; 23.850000381469727
                  |L10.404|
000194  c7000000          DCFS     0xc7000000 ; -32768
                  |L10.408|
                          DCD      0x46fffe00
                  |L10.412|
00019c  46fffe00          DCFS     0x46fffe00 ; 32767

                          AREA ||i._ZN4Anki5Cozmo18SteeringController6ManageEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController6ManageEv PROC ; Anki::Cozmo::SteeringController::Manage()
;;;95         //This manages at a high level what the steering controller needs to do (steer, use open loop, etc.)
;;;96         void Manage()
000000  4806              LDR      r0,|L11.28|
;;;97         {
;;;98     #if(DEBUG_STEERING_CONTROLLER)
;;;99           PRINT("STEER MODE: %d\n", currSteerMode_);
;;;100    #endif
;;;101          switch(currSteerMode_) {
000002  7840              LDRB     r0,[r0,#1]  ; _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e614currSteerMode_E
000004  b130              CBZ      r0,|L11.20|
000006  2801              CMP      r0,#1
000008  d006              BEQ      |L11.24|
00000a  2802              CMP      r0,#2
;;;102          
;;;103            case SM_PATH_FOLLOW:
;;;104              ManagePathFollow();
;;;105              break;
;;;106            case SM_DIRECT_DRIVE:
;;;107              ManageDirectDrive();
;;;108              break;
;;;109            case SM_POINT_TURN:
;;;110              ManagePointTurn();
;;;111              break;
;;;112            default:
;;;113              break;
;;;114              
;;;115          }
;;;116          
;;;117        }
00000c  bf18              IT       NE
00000e  4770              BXNE     lr
000010  f7ffbffe          B.W      _ZN4Anki5Cozmo18SteeringController15ManagePointTurnEv ; Anki::Cozmo::SteeringController::ManagePointTurn()
                  |L11.20|
000014  f7ffbffe          B.W      _ZN4Anki5Cozmo18SteeringController16ManagePathFollowEv ; Anki::Cozmo::SteeringController::ManagePathFollow()
                  |L11.24|
000018  f7ffbffe          B.W      _ZN4Anki5Cozmo18SteeringController17ManageDirectDriveEv ; Anki::Cozmo::SteeringController::ManageDirectDrive()
;;;118        
                          ENDP

                  |L11.28|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo18SteeringController6ReInitEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController6ReInitEv PROC ; Anki::Cozmo::SteeringController::ReInit()
;;;76         
;;;77         void ReInit()
000000  4901              LDR      r1,|L12.8|
;;;78         {
;;;79           isInit_ = false;
000002  2000              MOVS     r0,#0
000004  7008              STRB     r0,[r1,#0]
;;;80         }
000006  4770              BX       lr
;;;81         
                          ENDP

                  |L12.8|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo18SteeringController7GetModeEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController7GetModeEv PROC ; Anki::Cozmo::SteeringController::GetMode()
;;;89         
;;;90         SteerMode GetMode()
000000  4801              LDR      r0,|L13.8|
;;;91         {
;;;92           return currSteerMode_;
000002  7840              LDRB     r0,[r0,#1]  ; _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e614currSteerMode_E
;;;93         }
000004  4770              BX       lr
;;;94         
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo18SteeringController8SetGainsEff||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController8SetGainsEff PROC ; Anki::Cozmo::SteeringController::SetGains(float, float)
;;;82         //sets the steering controller constants
;;;83         void SetGains(float k1, float k2)
000000  4802              LDR      r0,|L14.12|
;;;84         {
;;;85           K1_ = k1;
000002  ed800a02          VSTR     s0,[r0,#8]
;;;86           K2_ = k2;
000006  edc00a03          VSTR     s1,[r0,#0xc]
;;;87         }
00000a  4770              BX       lr
;;;88         
                          ENDP

                  |L14.12|
                          DCD      ||.data||

                          AREA ||i.__sti___22_steeringController_cpp_8d9ca2e6||, CODE, READONLY, ALIGN=2

                  __sti___22_steeringController_cpp_8d9ca2e6 PROC
000000  4807              LDR      r0,|L15.32|
000002  b510              PUSH     {r4,lr}
000004  ed9f0a05          VLDR     s0,|L15.28|
000008  ed800a0d          VSTR     s0,[r0,#0x34]
00000c  3038              ADDS     r0,r0,#0x38
00000e  f7fffffe          BL       _ZN4Anki7RadiansC1Ev ; Anki::Radians::Radians()
000012  e8bd4010          POP      {r4,lr}
000016  4803              LDR      r0,|L15.36|
000018  f7ffbffe          B.W      _ZN4Anki24VelocityProfileGeneratorC1Ev ; Anki::VelocityProfileGenerator::VelocityProfileGenerator()
                          ENDP

                  |L15.28|
00001c  423df6f2          DCFS     0x423df6f2 ; 47.491157531738281
                  |L15.32|
                          DCD      ||.data||
                  |L15.36|
                          DCD      ||.bss||

                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController6ReInitEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController6ReInitEv||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController8SetGainsEff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController8SetGainsEff||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController7GetModeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController7GetModeEv||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController21CheckWheelSpeedLimitsERfS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController21CheckWheelSpeedLimitsERfS2_||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController25RunLineFollowControllerNLEff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController25RunLineFollowControllerNLEff||
                          DCD      0x00000001

                          AREA ||area_number.21||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController15ManagePointTurnEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController15ManagePointTurnEv||
                          DCD      0x00000001

                          AREA ||area_number.22||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController17ManageDirectDriveEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController17ManageDirectDriveEv||
                          DCD      0x00000001

                          AREA ||area_number.23||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController16ManagePathFollowEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController16ManagePathFollowEv||
                          DCD      0x00000001

                          AREA ||area_number.24||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController6ManageEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController6ManageEv||
                          DCD      0x00000001

                          AREA ||area_number.25||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController21SetRotationSpeedLimitEf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController21SetRotationSpeedLimitEf||
                          DCD      0x00000001

                          AREA ||area_number.26||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController25DisableRotationSpeedLimitEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.26||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController25DisableRotationSpeedLimitEv||
                          DCD      0x00000001

                          AREA ||area_number.27||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController17SetPathFollowModeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.27||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController17SetPathFollowModeEv||
                          DCD      0x00000001

                          AREA ||area_number.28||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController18ExecuteDirectDriveEffff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController18ExecuteDirectDriveEffff||
                          DCD      0x00000001

                          AREA ||area_number.29||, LINKORDER=||i._ZN4Anki5Cozmo18SteeringController16ExecutePointTurnEffff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.29||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo18SteeringController16ExecutePointTurnEffff||
                          DCD      0x00000001

                          AREA ||area_number.30||, LINKORDER=||i.__sti___22_steeringController_cpp_8d9ca2e6||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.30||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___22_steeringController_cpp_8d9ca2e6||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e64vpg_E ; Anki::Cozmo::SteeringController::<unnamed>::vpg_
                          %        80

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  5741524e          DCB      "WARNING (PointTurn.TooSlow): Speeding up commanded poin"
000004  494e4720
000008  28506f69
00000c  6e745475
000010  726e2e54
000014  6f6f536c
000018  6f77293a
00001c  20537065
000020  6564696e
000024  67207570
000028  20636f6d
00002c  6d616e64
000030  65642070
000034  6f696e  
000037  74207475          DCB      "t turn of %f rad/s to %f rad/s\n",0
00003b  726e206f
00003f  66202566
000043  20726164
000047  2f732074
00004b  6f202566
00004f  20726164
000053  2f730a00

                          AREA ||.data||, DATA, ALIGN=2

                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e67isInit_E ; Anki::Cozmo::SteeringController::<unnamed>::isInit_
000000  00                DCB      0x00
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e614currSteerMode_E ; Anki::Cozmo::SteeringController::<unnamed>::currSteerMode_
000001  00                DCB      0x00
                  steering_active
000002  00                DCB      0x00
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e617startedPointTurn_E ; Anki::Cozmo::SteeringController::<unnamed>::startedPointTurn_
000003  00                DCB      0x00
                  ||cnt||
000004  03e8              DCW      0x03e8
000006  0000              DCB      0x00,0x00
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e63K1_E ; Anki::Cozmo::SteeringController::<unnamed>::K1_
000008  3dcccccd          DCFS     0x3dcccccd ; 0.10000000149011612
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e63K2_E ; Anki::Cozmo::SteeringController::<unnamed>::K2_
00000c  41200000          DCFS     0x41200000 ; 10
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e625maxRotationWheelSpeedDiffE ; Anki::Cozmo::SteeringController::<unnamed>::maxRotationWheelSpeedDiff
000010  00000000          DCFS     0x00000000 ; 0
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e614targetLeftVel_E ; Anki::Cozmo::SteeringController::<unnamed>::targetLeftVel_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e615targetRightVel_E ; Anki::Cozmo::SteeringController::<unnamed>::targetRightVel_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e618leftAccelPerCycle_E ; Anki::Cozmo::SteeringController::<unnamed>::leftAccelPerCycle_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e619rightAccelPerCycle_E ; Anki::Cozmo::SteeringController::<unnamed>::rightAccelPerCycle_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e614maxAngularVel_E ; Anki::Cozmo::SteeringController::<unnamed>::maxAngularVel_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e613angularAccel_E ; Anki::Cozmo::SteeringController::<unnamed>::angularAccel_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e613angularDecel_E ; Anki::Cozmo::SteeringController::<unnamed>::angularDecel_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e615currAngularVel_E ; Anki::Cozmo::SteeringController::<unnamed>::currAngularVel_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo21ROBOT_BOUNDING_RADIUSE ; Anki::Cozmo::ROBOT_BOUNDING_RADIUS
                          DCD      0x00000000
                  _ZN4Anki5Cozmo18SteeringController46_GLOBAL__N__22_steeringController_cpp_8d9ca2e610targetRad_E ; Anki::Cozmo::SteeringController::<unnamed>::targetRad_
                          %        8

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___22_steeringController_cpp_8d9ca2e6
