; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\stm32f4xx_can.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f4xx_can.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\stm32f4xx_can.crf arm_hal\lib\stm32f4xx_can.c]
                          THUMB

                          AREA ||i.CAN_CancelTransmit||, CODE, READONLY, ALIGN=1

                  CAN_CancelTransmit PROC
;;;702      */
;;;703    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
000000  b169              CBZ      r1,|L1.30|
;;;704    {
;;;705      /* Check the parameters */
;;;706      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;707      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
;;;708      /* abort transmission */
;;;709      switch (Mailbox)
000002  2901              CMP      r1,#1
;;;710      {
;;;711        case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
;;;712          break;
;;;713        case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
000004  bf04              ITT      EQ
000006  6881              LDREQ    r1,[r0,#8]
000008  f4414100          ORREQ    r1,r1,#0x8000
00000c  d005              BEQ      |L1.26|
00000e  2902              CMP      r1,#2                 ;709
;;;714          break;
;;;715        case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
000010  bf06              ITTE     EQ
000012  6881              LDREQ    r1,[r0,#8]
000014  f4410100          ORREQ    r1,r1,#0x800000
;;;716          break;
;;;717        default:
;;;718          break;
;;;719      }
;;;720    }
000018  4770              BXNE     lr
                  |L1.26|
00001a  6081              STR      r1,[r0,#8]            ;715
00001c  4770              BX       lr
                  |L1.30|
00001e  6881              LDR      r1,[r0,#8]            ;711
000020  f0410180          ORR      r1,r1,#0x80           ;711
000024  6081              STR      r1,[r0,#8]            ;711
000026  4770              BX       lr
;;;721    /**
                          ENDP


                          AREA ||i.CAN_ClearFlag||, CODE, READONLY, ALIGN=2

                  CAN_ClearFlag PROC
;;;1429     */
;;;1430   void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  4a0b              LDR      r2,|L2.48|
;;;1431   {
;;;1432     uint32_t flagtmp=0;
;;;1433     /* Check the parameters */
;;;1434     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1435     assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
;;;1436     
;;;1437     if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
000002  4291              CMP      r1,r2
;;;1438     {
;;;1439       /* Clear the selected CAN flags */
;;;1440       CANx->ESR = (uint32_t)RESET;
000004  bf02              ITTT     EQ
000006  2100              MOVEQ    r1,#0
000008  6181              STREQ    r1,[r0,#0x18]
;;;1441     }
;;;1442     else /* MSR or TSR or RF0R or RF1R */
;;;1443     {
;;;1444       flagtmp = CAN_FLAG & 0x000FFFFF;
;;;1445   
;;;1446       if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
;;;1447       {
;;;1448         /* Receive Flags */
;;;1449         CANx->RF0R = (uint32_t)(flagtmp);
;;;1450       }
;;;1451       else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
;;;1452       {
;;;1453         /* Receive Flags */
;;;1454         CANx->RF1R = (uint32_t)(flagtmp);
;;;1455       }
;;;1456       else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
;;;1457       {
;;;1458         /* Transmit Flags */
;;;1459         CANx->TSR = (uint32_t)(flagtmp);
;;;1460       }
;;;1461       else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
;;;1462       {
;;;1463         /* Operating mode Flags */
;;;1464         CANx->MSR = (uint32_t)(flagtmp);
;;;1465       }
;;;1466     }
;;;1467   }
00000a  4770              BXEQ     lr
00000c  f3c10213          UBFX     r2,r1,#0,#20          ;1444
000010  f0117f00          TST      r1,#0x2000000         ;1446
000014  bf1c              ITT      NE                    ;1449
000016  60c2              STRNE    r2,[r0,#0xc]          ;1449
000018  4770              BXNE     lr
00001a  f0116f80          TST      r1,#0x4000000         ;1451
00001e  bf1c              ITT      NE                    ;1454
000020  6102              STRNE    r2,[r0,#0x10]         ;1454
000022  4770              BXNE     lr
000024  f0116f00          TST      r1,#0x8000000         ;1456
000028  bf14              ITE      NE                    ;1459
00002a  6082              STRNE    r2,[r0,#8]            ;1459
00002c  6042              STREQ    r2,[r0,#4]            ;1464
00002e  4770              BX       lr
;;;1468   
                          ENDP

                  |L2.48|
                          DCD      0x30f00070

                          AREA ||i.CAN_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  CAN_ClearITPendingBit PROC
;;;1593     */
;;;1594   void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  b410              PUSH     {r4}
;;;1595   {
;;;1596     /* Check the parameters */
;;;1597     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1598     assert_param(IS_CAN_CLEAR_IT(CAN_IT));
;;;1599   
;;;1600     switch (CAN_IT)
;;;1601     {
;;;1602       case CAN_IT_TME:
;;;1603         /* Clear CAN_TSR_RQCPx (rc_w1)*/
;;;1604         CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
;;;1605         break;
;;;1606       case CAN_IT_FF0:
;;;1607         /* Clear CAN_RF0R_FULL0 (rc_w1)*/
;;;1608         CANx->RF0R = CAN_RF0R_FULL0; 
000002  2308              MOVS     r3,#8
;;;1609         break;
;;;1610       case CAN_IT_FOV0:
;;;1611         /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
;;;1612         CANx->RF0R = CAN_RF0R_FOVR0; 
;;;1613         break;
;;;1614       case CAN_IT_FF1:
;;;1615         /* Clear CAN_RF1R_FULL1 (rc_w1)*/
;;;1616         CANx->RF1R = CAN_RF1R_FULL1;  
;;;1617         break;
;;;1618       case CAN_IT_FOV1:
;;;1619         /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
;;;1620         CANx->RF1R = CAN_RF1R_FOVR1; 
;;;1621         break;
;;;1622       case CAN_IT_WKU:
;;;1623         /* Clear CAN_MSR_WKUI (rc_w1)*/
;;;1624         CANx->MSR = CAN_MSR_WKUI;  
;;;1625         break;
;;;1626       case CAN_IT_SLK:
;;;1627         /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
;;;1628         CANx->MSR = CAN_MSR_SLAKI;   
;;;1629         break;
;;;1630       case CAN_IT_EWG:
;;;1631         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1632         CANx->MSR = CAN_MSR_ERRI;
000004  2204              MOVS     r2,#4
000006  f04f0c10          MOV      r12,#0x10             ;1612
00000a  f5b17f00          CMP      r1,#0x200             ;1600
00000e  d040              BEQ      |L3.146|
000010  dc21              BGT      |L3.86|
000012  2920              CMP      r1,#0x20              ;1600
000014  bf02              ITTT     EQ                    ;1616
000016  6103              STREQ    r3,[r0,#0x10]         ;1616
;;;1633          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
;;;1634         break;
;;;1635       case CAN_IT_EPV:
;;;1636         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1637         CANx->MSR = CAN_MSR_ERRI; 
;;;1638          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1639         break;
;;;1640       case CAN_IT_BOF:
;;;1641         /* Clear CAN_MSR_ERRI (rc_w1) */ 
;;;1642         CANx->MSR = CAN_MSR_ERRI; 
;;;1643          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1644          break;
;;;1645       case CAN_IT_LEC:
;;;1646         /*  Clear LEC bits */
;;;1647         CANx->ESR = RESET; 
;;;1648         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1649         CANx->MSR = CAN_MSR_ERRI; 
;;;1650         break;
;;;1651       case CAN_IT_ERR:
;;;1652         /*Clear LEC bits */
;;;1653         CANx->ESR = RESET; 
;;;1654         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1655         CANx->MSR = CAN_MSR_ERRI; 
;;;1656          /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
;;;1657          break;
;;;1658       default:
;;;1659          break;
;;;1660      }
;;;1661   }
000018  bc10              POPEQ    {r4}
00001a  4770              BXEQ     lr
00001c  dc10              BGT      |L3.64|
00001e  2901              CMP      r1,#1                 ;1600
000020  bf01              ITTTT    EQ                    ;1604
000022  491d              LDREQ    r1,|L3.152|
000024  6081              STREQ    r1,[r0,#8]            ;1604
000026  bc10              POPEQ    {r4}
000028  4770              BXEQ     lr
00002a  2904              CMP      r1,#4                 ;1600
00002c  bf02              ITTT     EQ                    ;1608
00002e  60c3              STREQ    r3,[r0,#0xc]          ;1608
000030  bc10              POPEQ    {r4}
000032  4770              BXEQ     lr
000034  2908              CMP      r1,#8                 ;1600
000036  bf08              IT       EQ                    ;1612
000038  f8c0c00c          STREQ    r12,[r0,#0xc]         ;1612
00003c  bc10              POP      {r4}
00003e  4770              BX       lr
                  |L3.64|
000040  2940              CMP      r1,#0x40              ;1600
000042  bf02              ITTT     EQ                    ;1620
000044  f8c0c010          STREQ    r12,[r0,#0x10]        ;1620
000048  bc10              POPEQ    {r4}
00004a  4770              BXEQ     lr
00004c  f5b17f80          CMP      r1,#0x100             ;1600
000050  d01f              BEQ      |L3.146|
000052  bc10              POP      {r4}
000054  4770              BX       lr
                  |L3.86|
000056  2400              MOVS     r4,#0
000058  f5b14f00          CMP      r1,#0x8000            ;1600
00005c  d008              BEQ      |L3.112|
00005e  dc0b              BGT      |L3.120|
000060  f5b16f80          CMP      r1,#0x400             ;1600
000064  d015              BEQ      |L3.146|
000066  f5b16f00          CMP      r1,#0x800             ;1600
00006a  bf1c              ITT      NE
00006c  bc10              POPNE    {r4}
00006e  4770              BXNE     lr
                  |L3.112|
000070  6184              STR      r4,[r0,#0x18]         ;1653
000072  6042              STR      r2,[r0,#4]            ;1655
000074  bc10              POP      {r4}
000076  4770              BX       lr
                  |L3.120|
000078  f5b13f80          CMP      r1,#0x10000           ;1600
00007c  bf02              ITTT     EQ                    ;1624
00007e  6043              STREQ    r3,[r0,#4]            ;1624
000080  bc10              POPEQ    {r4}
000082  4770              BXEQ     lr
000084  f5b13f00          CMP      r1,#0x20000           ;1600
000088  bf08              IT       EQ                    ;1628
00008a  f8c0c004          STREQ    r12,[r0,#4]           ;1628
00008e  bc10              POP      {r4}
000090  4770              BX       lr
                  |L3.146|
000092  6042              STR      r2,[r0,#4]            ;1642
000094  bc10              POP      {r4}
000096  4770              BX       lr
;;;1662    /**
                          ENDP

                  |L3.152|
                          DCD      0x00010101

                          AREA ||i.CAN_DBGFreeze||, CODE, READONLY, ALIGN=1

                  CAN_DBGFreeze PROC
;;;492      */
;;;493    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;494    {
;;;495      /* Check the parameters */
;;;496      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;497      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;498      
;;;499      if (NewState != DISABLE)
;;;500      {
;;;501        /* Enable Debug Freeze  */
;;;502        CANx->MCR |= MCR_DBF;
;;;503      }
;;;504      else
;;;505      {
;;;506        /* Disable Debug Freeze */
;;;507        CANx->MCR &= ~MCR_DBF;
000002  6801              LDR      r1,[r0,#0]
000004  bf14              ITE      NE                    ;502
000006  f4413180          ORRNE    r1,r1,#0x10000        ;502
00000a  f4213180          BICEQ    r1,r1,#0x10000
00000e  6001              STR      r1,[r0,#0]            ;502
;;;508      }
;;;509    }
000010  4770              BX       lr
;;;510    
                          ENDP


                          AREA ||i.CAN_DeInit||, CODE, READONLY, ALIGN=1

                  CAN_DeInit PROC
;;;166      */
;;;167    void CAN_DeInit(CAN_TypeDef* CANx)
000000  f1a04180          SUB      r1,r0,#0x40000000
;;;168    {
000004  b510              PUSH     {r4,lr}
;;;169      /* Check the parameters */
;;;170      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;171     
;;;172      if (CANx == CAN1)
000006  f5b141c8          SUBS     r1,r1,#0x6400
;;;173      {
;;;174        /* Enable CAN1 reset state */
;;;175        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
;;;176        /* Release CAN1 from reset state */
;;;177        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
;;;178      }
;;;179      else
;;;180      {  
;;;181        /* Enable CAN2 reset state */
;;;182        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
00000a  f04f0101          MOV      r1,#1
00000e  d009              BEQ      |L5.36|
000010  0688              LSLS     r0,r1,#26
000012  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;183        /* Release CAN2 from reset state */
;;;184        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
000016  e8bd4010          POP      {r4,lr}
00001a  2100              MOVS     r1,#0
00001c  f04f6080          MOV      r0,#0x4000000
000020  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L5.36|
000024  f04f7000          MOV      r0,#0x2000000         ;175
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
00002c  e8bd4010          POP      {r4,lr}               ;177
000030  2100              MOVS     r1,#0                 ;177
000032  f04f7000          MOV      r0,#0x2000000         ;177
000036  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;185      }
;;;186    }
;;;187    
                          ENDP


                          AREA ||i.CAN_FIFORelease||, CODE, READONLY, ALIGN=1

                  CAN_FIFORelease PROC
;;;798      */
;;;799    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  b121              CBZ      r1,|L6.12|
;;;800    {
;;;801      /* Check the parameters */
;;;802      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;803      assert_param(IS_CAN_FIFO(FIFONumber));
;;;804      /* Release FIFO0 */
;;;805      if (FIFONumber == CAN_FIFO0)
;;;806      {
;;;807        CANx->RF0R |= CAN_RF0R_RFOM0;
;;;808      }
;;;809      /* Release FIFO1 */
;;;810      else /* FIFONumber == CAN_FIFO1 */
;;;811      {
;;;812        CANx->RF1R |= CAN_RF1R_RFOM1;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410120          ORR      r1,r1,#0x20
000008  6101              STR      r1,[r0,#0x10]
;;;813      }
;;;814    }
00000a  4770              BX       lr
                  |L6.12|
00000c  68c1              LDR      r1,[r0,#0xc]          ;807
00000e  f0410120          ORR      r1,r1,#0x20           ;807
000012  60c1              STR      r1,[r0,#0xc]          ;807
000014  4770              BX       lr
;;;815    
                          ENDP


                          AREA ||i.CAN_FilterInit||, CODE, READONLY, ALIGN=2

                  CAN_FilterInit PROC
;;;333      */
;;;334    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000000  b430              PUSH     {r4,r5}
;;;335    {
;;;336      uint32_t filter_number_bit_pos = 0;
;;;337      /* Check the parameters */
;;;338      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
;;;339      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
;;;340      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
;;;341      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
;;;342      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
;;;343    
;;;344      filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
000002  7a82              LDRB     r2,[r0,#0xa]
;;;345    
;;;346      /* Initialisation mode for the filter */
;;;347      CAN1->FMR |= FMR_FINIT;
000004  4b34              LDR      r3,|L7.216|
000006  2101              MOVS     r1,#1                 ;344
000008  4091              LSLS     r1,r1,r2              ;344
00000a  681a              LDR      r2,[r3,#0]
00000c  f0420201          ORR      r2,r2,#1
000010  601a              STR      r2,[r3,#0]
;;;348    
;;;349      /* Filter Deactivation */
;;;350      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
000012  f8dfc0c8          LDR      r12,|L7.220|
000016  f8dc2000          LDR      r2,[r12,#0]
00001a  438a              BICS     r2,r2,r1
00001c  f8cc2000          STR      r2,[r12,#0]
;;;351    
;;;352      /* Filter Scale */
;;;353      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
000020  7b04              LDRB     r4,[r0,#0xc]
;;;354      {
;;;355        /* 16-bit scale for the filter */
;;;356        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
000022  4a2f              LDR      r2,|L7.224|
000024  b9d4              CBNZ     r4,|L7.92|
000026  6814              LDR      r4,[r2,#0]
000028  438c              BICS     r4,r4,r1
00002a  6014              STR      r4,[r2,#0]
;;;357    
;;;358        /* First 16-bit identifier and First 16-bit mask */
;;;359        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;360        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
00002c  8844              LDRH     r4,[r0,#2]
00002e  88c5              LDRH     r5,[r0,#6]
000030  ea444405          ORR      r4,r4,r5,LSL #16
000034  7a85              LDRB     r5,[r0,#0xa]
000036  00ed              LSLS     r5,r5,#3
000038  f1054580          ADD      r5,r5,#0x40000000
00003c  f50545c0          ADD      r5,r5,#0x6000
000040  f8c54640          STR      r4,[r5,#0x640]
;;;361           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;362            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;363    
;;;364        /* Second 16-bit identifier and Second 16-bit mask */
;;;365        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;366        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
000044  8805              LDRH     r5,[r0,#0]
000046  8884              LDRH     r4,[r0,#4]
000048  ea454504          ORR      r5,r5,r4,LSL #16
00004c  7a84              LDRB     r4,[r0,#0xa]
00004e  00e4              LSLS     r4,r4,#3
000050  f1044480          ADD      r4,r4,#0x40000000
000054  f50444c0          ADD      r4,r4,#0x6000
000058  f8c45644          STR      r5,[r4,#0x644]
                  |L7.92|
;;;367           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;368            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;369      }
;;;370    
;;;371      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
00005c  7b04              LDRB     r4,[r0,#0xc]
00005e  2c01              CMP      r4,#1
000060  d118              BNE      |L7.148|
;;;372      {
;;;373        /* 32-bit scale for the filter */
;;;374        CAN1->FS1R |= filter_number_bit_pos;
000062  6814              LDR      r4,[r2,#0]
000064  430c              ORRS     r4,r4,r1
000066  6014              STR      r4,[r2,#0]
;;;375        /* 32-bit identifier or First 32-bit identifier */
;;;376        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
000068  7a84              LDRB     r4,[r0,#0xa]
00006a  6802              LDR      r2,[r0,#0]
00006c  00e4              LSLS     r4,r4,#3
00006e  f1044480          ADD      r4,r4,#0x40000000
000072  f50444c0          ADD      r4,r4,#0x6000
000076  ea4f4232          ROR      r2,r2,#16
00007a  f8c42640          STR      r2,[r4,#0x640]
;;;377           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;378            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;379        /* 32-bit mask or Second 32-bit identifier */
;;;380        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
00007e  7a84              LDRB     r4,[r0,#0xa]
000080  6842              LDR      r2,[r0,#4]
000082  00e4              LSLS     r4,r4,#3
000084  f1044480          ADD      r4,r4,#0x40000000
000088  f50444c0          ADD      r4,r4,#0x6000
00008c  ea4f4232          ROR      r2,r2,#16
000090  f8c42644          STR      r2,[r4,#0x644]
                  |L7.148|
;;;381           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;382            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;383      }
;;;384    
;;;385      /* Filter Mode */
;;;386      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
000094  7ac4              LDRB     r4,[r0,#0xb]
;;;387      {
;;;388        /*Id/Mask mode for the filter*/
;;;389        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
000096  4a13              LDR      r2,|L7.228|
000098  2c00              CMP      r4,#0                 ;386
;;;390      }
;;;391      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;392      {
;;;393        /*Identifier list mode for the filter*/
;;;394        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
00009a  6814              LDR      r4,[r2,#0]
00009c  bf0c              ITE      EQ                    ;389
00009e  438c              BICEQ    r4,r4,r1              ;389
0000a0  430c              ORRNE    r4,r4,r1
0000a2  6014              STR      r4,[r2,#0]
;;;395      }
;;;396    
;;;397      /* Filter FIFO assignment */
;;;398      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
0000a4  8904              LDRH     r4,[r0,#8]
;;;399      {
;;;400        /* FIFO 0 assignation for the filter */
;;;401        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
0000a6  4a10              LDR      r2,|L7.232|
0000a8  b914              CBNZ     r4,|L7.176|
0000aa  6814              LDR      r4,[r2,#0]
0000ac  438c              BICS     r4,r4,r1
0000ae  6014              STR      r4,[r2,#0]
                  |L7.176|
;;;402      }
;;;403    
;;;404      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
0000b0  8904              LDRH     r4,[r0,#8]
0000b2  2c01              CMP      r4,#1
0000b4  d102              BNE      |L7.188|
;;;405      {
;;;406        /* FIFO 1 assignation for the filter */
;;;407        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
0000b6  6814              LDR      r4,[r2,#0]
0000b8  430c              ORRS     r4,r4,r1
0000ba  6014              STR      r4,[r2,#0]
                  |L7.188|
;;;408      }
;;;409      
;;;410      /* Filter activation */
;;;411      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
0000bc  7b40              LDRB     r0,[r0,#0xd]
0000be  2801              CMP      r0,#1
0000c0  d104              BNE      |L7.204|
;;;412      {
;;;413        CAN1->FA1R |= filter_number_bit_pos;
0000c2  f8dc0000          LDR      r0,[r12,#0]
0000c6  4308              ORRS     r0,r0,r1
0000c8  f8cc0000          STR      r0,[r12,#0]
                  |L7.204|
;;;414      }
;;;415    
;;;416      /* Leave the initialisation mode for the filter */
;;;417      CAN1->FMR &= ~FMR_FINIT;
0000cc  6818              LDR      r0,[r3,#0]
0000ce  f0200001          BIC      r0,r0,#1
0000d2  6018              STR      r0,[r3,#0]
;;;418    }
0000d4  bc30              POP      {r4,r5}
0000d6  4770              BX       lr
;;;419    
                          ENDP

                  |L7.216|
                          DCD      0x40006600
                  |L7.220|
                          DCD      0x4000661c
                  |L7.224|
                          DCD      0x4000660c
                  |L7.228|
                          DCD      0x40006604
                  |L7.232|
                          DCD      0x40006614

                          AREA ||i.CAN_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetFlagStatus PROC
;;;1329     */
;;;1330   FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  4603              MOV      r3,r0
;;;1331   {
;;;1332     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1333     
;;;1334     /* Check the parameters */
;;;1335     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1336     assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
;;;1337     
;;;1338   
;;;1339     if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
000004  f4110f70          TST      r1,#0xf00000
;;;1340     { 
;;;1341       /* Check the status of the specified CAN flag */
;;;1342       if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000008  f3c10213          UBFX     r2,r1,#0,#20
00000c  d005              BEQ      |L8.26|
00000e  6999              LDR      r1,[r3,#0x18]
000010  4211              TST      r1,r2
;;;1343       { 
;;;1344         /* CAN_FLAG is set */
;;;1345         bitstatus = SET;
;;;1346       }
;;;1347       else
;;;1348       { 
;;;1349         /* CAN_FLAG is reset */
;;;1350         bitstatus = RESET;
;;;1351       }
;;;1352     }
;;;1353     else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
;;;1354     { 
;;;1355       /* Check the status of the specified CAN flag */
;;;1356       if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1357       { 
;;;1358         /* CAN_FLAG is set */
;;;1359         bitstatus = SET;
;;;1360       }
;;;1361       else
;;;1362       { 
;;;1363         /* CAN_FLAG is reset */
;;;1364         bitstatus = RESET;
;;;1365       }
;;;1366     }
;;;1367     else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
;;;1368     { 
;;;1369       /* Check the status of the specified CAN flag */
;;;1370       if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1371       { 
;;;1372         /* CAN_FLAG is set */
;;;1373         bitstatus = SET;
;;;1374       }
;;;1375       else
;;;1376       { 
;;;1377         /* CAN_FLAG is reset */
;;;1378         bitstatus = RESET;
;;;1379       }
;;;1380     }
;;;1381     else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
;;;1382     { 
;;;1383       /* Check the status of the specified CAN flag */
;;;1384       if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1385       { 
;;;1386         /* CAN_FLAG is set */
;;;1387         bitstatus = SET;
;;;1388       }
;;;1389       else
;;;1390       { 
;;;1391         /* CAN_FLAG is reset */
;;;1392         bitstatus = RESET;
;;;1393       }
;;;1394     }
;;;1395     else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
;;;1396     { 
;;;1397       /* Check the status of the specified CAN flag */
;;;1398       if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1399       { 
;;;1400         /* CAN_FLAG is set */
;;;1401         bitstatus = SET;
;;;1402       }
;;;1403       else
;;;1404       { 
;;;1405         /* CAN_FLAG is reset */
;;;1406         bitstatus = RESET;
;;;1407       }
;;;1408     }
;;;1409     /* Return the CAN_FLAG status */
;;;1410     return  bitstatus;
;;;1411   }
000012  bf08              IT       EQ
000014  4770              BXEQ     lr
                  |L8.22|
000016  2001              MOVS     r0,#1                 ;1345
000018  4770              BX       lr
                  |L8.26|
00001a  f0117f80          TST      r1,#0x1000000         ;1353
00001e  d004              BEQ      |L8.42|
000020  6859              LDR      r1,[r3,#4]            ;1356
000022  4211              TST      r1,r2                 ;1356
000024  bf08              IT       EQ
000026  4770              BXEQ     lr
000028  e7f5              B        |L8.22|
                  |L8.42|
00002a  f0116f00          TST      r1,#0x8000000         ;1367
00002e  d004              BEQ      |L8.58|
000030  6899              LDR      r1,[r3,#8]            ;1370
000032  4211              TST      r1,r2                 ;1370
000034  bf08              IT       EQ
000036  4770              BXEQ     lr
000038  e7ed              B        |L8.22|
                  |L8.58|
00003a  f0117f00          TST      r1,#0x2000000         ;1381
00003e  d004              BEQ      |L8.74|
000040  68d9              LDR      r1,[r3,#0xc]          ;1384
000042  4211              TST      r1,r2                 ;1384
000044  bf08              IT       EQ
000046  4770              BXEQ     lr
000048  e7e5              B        |L8.22|
                  |L8.74|
00004a  6919              LDR      r1,[r3,#0x10]         ;1398
00004c  4211              TST      r1,r2                 ;1398
00004e  d1e2              BNE      |L8.22|
000050  4770              BX       lr
;;;1412   
                          ENDP


                          AREA ||i.CAN_GetITStatus||, CODE, READONLY, ALIGN=2

                  CAN_GetITStatus PROC
;;;1489     */
;;;1490   ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  6943              LDR      r3,[r0,#0x14]
;;;1491   {
;;;1492     ITStatus itstatus = RESET;
000002  2200              MOVS     r2,#0
;;;1493     /* Check the parameters */
;;;1494     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1495     assert_param(IS_CAN_IT(CAN_IT));
;;;1496     
;;;1497     /* check the interrupt enable bit */
;;;1498    if((CANx->IER & CAN_IT) != RESET)
000004  420b              TST      r3,r1
000006  d07d              BEQ      |L9.260|
;;;1499    {
;;;1500      /* in case the Interrupt is enabled, .... */
;;;1501       switch (CAN_IT)
000008  f5b17f80          CMP      r1,#0x100
00000c  d05c              BEQ      |L9.200|
00000e  dc10              BGT      |L9.50|
000010  2908              CMP      r1,#8
000012  d035              BEQ      |L9.128|
000014  dc06              BGT      |L9.36|
000016  2901              CMP      r1,#1
000018  d020              BEQ      |L9.92|
00001a  2902              CMP      r1,#2
00001c  d024              BEQ      |L9.104|
00001e  2904              CMP      r1,#4
000020  d028              BEQ      |L9.116|
000022  e06f              B        |L9.260|
                  |L9.36|
000024  2910              CMP      r1,#0x10
000026  d031              BEQ      |L9.140|
000028  2920              CMP      r1,#0x20
00002a  d035              BEQ      |L9.152|
00002c  2940              CMP      r1,#0x40
00002e  d039              BEQ      |L9.164|
000030  e068              B        |L9.260|
                  |L9.50|
000032  f5b14f00          CMP      r1,#0x8000
000036  d05f              BEQ      |L9.248|
000038  dc09              BGT      |L9.78|
00003a  f5b17f00          CMP      r1,#0x200
00003e  d049              BEQ      |L9.212|
000040  f5b16f80          CMP      r1,#0x400
000044  d04c              BEQ      |L9.224|
000046  f5b16f00          CMP      r1,#0x800
00004a  d04f              BEQ      |L9.236|
00004c  e05a              B        |L9.260|
                  |L9.78|
00004e  f5b13f80          CMP      r1,#0x10000
000052  d02d              BEQ      |L9.176|
000054  f5b13f00          CMP      r1,#0x20000
000058  d030              BEQ      |L9.188|
00005a  e053              B        |L9.260|
                  |L9.92|
;;;1502       {
;;;1503         case CAN_IT_TME:
;;;1504           /* Check CAN_TSR_RQCPx bits */
;;;1505           itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
00005c  6880              LDR      r0,[r0,#8]
00005e  492a              LDR      r1,|L9.264|
000060  2200              MOVS     r2,#0
000062  4208              TST      r0,r1
000064  d14d              BNE      |L9.258|
000066  e04d              B        |L9.260|
                  |L9.104|
;;;1506           break;
;;;1507         case CAN_IT_FMP0:
;;;1508           /* Check CAN_RF0R_FMP0 bit */
;;;1509           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
000068  68c0              LDR      r0,[r0,#0xc]
00006a  2200              MOVS     r2,#0
00006c  f0100f03          TST      r0,#3
000070  d147              BNE      |L9.258|
000072  e047              B        |L9.260|
                  |L9.116|
;;;1510           break;
;;;1511         case CAN_IT_FF0:
;;;1512           /* Check CAN_RF0R_FULL0 bit */
;;;1513           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
000074  68c0              LDR      r0,[r0,#0xc]
000076  2200              MOVS     r2,#0
000078  f0100f08          TST      r0,#8
00007c  d141              BNE      |L9.258|
00007e  e041              B        |L9.260|
                  |L9.128|
;;;1514           break;
;;;1515         case CAN_IT_FOV0:
;;;1516           /* Check CAN_RF0R_FOVR0 bit */
;;;1517           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
000080  68c0              LDR      r0,[r0,#0xc]
000082  2200              MOVS     r2,#0
000084  f0100f10          TST      r0,#0x10
000088  d13b              BNE      |L9.258|
00008a  e03b              B        |L9.260|
                  |L9.140|
;;;1518           break;
;;;1519         case CAN_IT_FMP1:
;;;1520           /* Check CAN_RF1R_FMP1 bit */
;;;1521           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
00008c  6900              LDR      r0,[r0,#0x10]
00008e  2200              MOVS     r2,#0
000090  f0100f03          TST      r0,#3
000094  d135              BNE      |L9.258|
000096  e035              B        |L9.260|
                  |L9.152|
;;;1522           break;
;;;1523         case CAN_IT_FF1:
;;;1524           /* Check CAN_RF1R_FULL1 bit */
;;;1525           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
000098  6900              LDR      r0,[r0,#0x10]
00009a  2200              MOVS     r2,#0
00009c  f0100f08          TST      r0,#8
0000a0  d12f              BNE      |L9.258|
0000a2  e02f              B        |L9.260|
                  |L9.164|
;;;1526           break;
;;;1527         case CAN_IT_FOV1:
;;;1528           /* Check CAN_RF1R_FOVR1 bit */
;;;1529           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
0000a4  6900              LDR      r0,[r0,#0x10]
0000a6  2200              MOVS     r2,#0
0000a8  f0100f10          TST      r0,#0x10
0000ac  d129              BNE      |L9.258|
0000ae  e029              B        |L9.260|
                  |L9.176|
;;;1530           break;
;;;1531         case CAN_IT_WKU:
;;;1532           /* Check CAN_MSR_WKUI bit */
;;;1533           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
0000b0  6840              LDR      r0,[r0,#4]
0000b2  2200              MOVS     r2,#0
0000b4  f0100f08          TST      r0,#8
0000b8  d123              BNE      |L9.258|
0000ba  e023              B        |L9.260|
                  |L9.188|
;;;1534           break;
;;;1535         case CAN_IT_SLK:
;;;1536           /* Check CAN_MSR_SLAKI bit */
;;;1537           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
0000bc  6840              LDR      r0,[r0,#4]
0000be  2200              MOVS     r2,#0
0000c0  f0100f10          TST      r0,#0x10
0000c4  d11d              BNE      |L9.258|
0000c6  e01d              B        |L9.260|
                  |L9.200|
;;;1538           break;
;;;1539         case CAN_IT_EWG:
;;;1540           /* Check CAN_ESR_EWGF bit */
;;;1541           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
0000c8  6980              LDR      r0,[r0,#0x18]
0000ca  2200              MOVS     r2,#0
0000cc  f0100f01          TST      r0,#1
0000d0  d117              BNE      |L9.258|
0000d2  e017              B        |L9.260|
                  |L9.212|
;;;1542           break;
;;;1543         case CAN_IT_EPV:
;;;1544           /* Check CAN_ESR_EPVF bit */
;;;1545           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
0000d4  6980              LDR      r0,[r0,#0x18]
0000d6  2200              MOVS     r2,#0
0000d8  f0100f02          TST      r0,#2
0000dc  d111              BNE      |L9.258|
0000de  e011              B        |L9.260|
                  |L9.224|
;;;1546           break;
;;;1547         case CAN_IT_BOF:
;;;1548           /* Check CAN_ESR_BOFF bit */
;;;1549           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
0000e0  6980              LDR      r0,[r0,#0x18]
0000e2  2200              MOVS     r2,#0
0000e4  f0100f04          TST      r0,#4
0000e8  d10b              BNE      |L9.258|
0000ea  e00b              B        |L9.260|
                  |L9.236|
;;;1550           break;
;;;1551         case CAN_IT_LEC:
;;;1552           /* Check CAN_ESR_LEC bit */
;;;1553           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
0000ec  6980              LDR      r0,[r0,#0x18]
0000ee  2200              MOVS     r2,#0
0000f0  f0100f70          TST      r0,#0x70
0000f4  d105              BNE      |L9.258|
0000f6  e005              B        |L9.260|
                  |L9.248|
;;;1554           break;
;;;1555         case CAN_IT_ERR:
;;;1556           /* Check CAN_MSR_ERRI bit */ 
;;;1557           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
0000f8  6840              LDR      r0,[r0,#4]
0000fa  2200              MOVS     r2,#0
0000fc  f0100f04          TST      r0,#4
000100  d000              BEQ      |L9.260|
                  |L9.258|
000102  2201              MOVS     r2,#1
                  |L9.260|
;;;1558           break;
;;;1559         default:
;;;1560           /* in case of error, return RESET */
;;;1561           itstatus = RESET;
;;;1562           break;
;;;1563       }
;;;1564     }
;;;1565     else
;;;1566     {
;;;1567      /* in case the Interrupt is not enabled, return RESET */
;;;1568       itstatus  = RESET;
;;;1569     }
;;;1570     
;;;1571     /* Return the CAN_IT status */
;;;1572     return  itstatus;
000104  4610              MOV      r0,r2
;;;1573   }
000106  4770              BX       lr
;;;1574   
                          ENDP

                  |L9.264|
                          DCD      0x00010101

                          AREA ||i.CAN_GetLSBTransmitErrorCounter||, CODE, READONLY, ALIGN=1

                  CAN_GetLSBTransmitErrorCounter PROC
;;;1084     */
;;;1085   uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
000000  6980              LDR      r0,[r0,#0x18]
;;;1086   {
;;;1087     uint8_t counter=0;
;;;1088     
;;;1089     /* Check the parameters */
;;;1090     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1091     
;;;1092     /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1093     counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
000002  f3c04007          UBFX     r0,r0,#16,#8
;;;1094     
;;;1095     /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1096     return counter;
;;;1097   }
000006  4770              BX       lr
;;;1098   /**
                          ENDP


                          AREA ||i.CAN_GetLastErrorCode||, CODE, READONLY, ALIGN=1

                  CAN_GetLastErrorCode PROC
;;;1039     */
;;;1040   uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
000000  6980              LDR      r0,[r0,#0x18]
;;;1041   {
;;;1042     uint8_t errorcode=0;
;;;1043     
;;;1044     /* Check the parameters */
;;;1045     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1046     
;;;1047     /* Get the error code*/
;;;1048     errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
000002  f3c01002          UBFX     r0,r0,#4,#3
000006  0100              LSLS     r0,r0,#4
;;;1049     
;;;1050     /* Return the error code*/
;;;1051     return errorcode;
;;;1052   }
000008  4770              BX       lr
;;;1053   
                          ENDP


                          AREA ||i.CAN_GetReceiveErrorCounter||, CODE, READONLY, ALIGN=1

                  CAN_GetReceiveErrorCounter PROC
;;;1064     */
;;;1065   uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
000000  6980              LDR      r0,[r0,#0x18]
;;;1066   {
;;;1067     uint8_t counter=0;
;;;1068     
;;;1069     /* Check the parameters */
;;;1070     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1071     
;;;1072     /* Get the Receive Error Counter*/
;;;1073     counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
000002  0e00              LSRS     r0,r0,#24
;;;1074     
;;;1075     /* Return the Receive Error Counter*/
;;;1076     return counter;
;;;1077   }
000004  4770              BX       lr
;;;1078   
                          ENDP


                          AREA ||i.CAN_ITConfig||, CODE, READONLY, ALIGN=1

                  CAN_ITConfig PROC
;;;1289     */
;;;1290   void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1291   {
;;;1292     /* Check the parameters */
;;;1293     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1294     assert_param(IS_CAN_IT(CAN_IT));
;;;1295     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1296   
;;;1297     if (NewState != DISABLE)
;;;1298     {
;;;1299       /* Enable the selected CANx interrupt */
;;;1300       CANx->IER |= CAN_IT;
;;;1301     }
;;;1302     else
;;;1303     {
;;;1304       /* Disable the selected CANx interrupt */
;;;1305       CANx->IER &= ~CAN_IT;
000002  6942              LDR      r2,[r0,#0x14]
000004  bf14              ITE      NE                    ;1300
000006  4311              ORRNE    r1,r1,r2              ;1300
000008  ea220101          BICEQ    r1,r2,r1
00000c  6141              STR      r1,[r0,#0x14]         ;1300
;;;1306     }
;;;1307   }
00000e  4770              BX       lr
;;;1308   /**
                          ENDP


                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=1

                  CAN_Init PROC
;;;196      */
;;;197    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
000000  6803              LDR      r3,[r0,#0]
;;;198    {
;;;199      uint8_t InitStatus = CAN_InitStatus_Failed;
;;;200      uint32_t wait_ack = 0x00000000;
000002  2200              MOVS     r2,#0
;;;201      /* Check the parameters */
;;;202      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;203      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
;;;204      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
;;;205      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
;;;206      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
;;;207      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
;;;208      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
;;;209      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
;;;210      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
;;;211      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
;;;212      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
;;;213      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
;;;214    
;;;215      /* Exit from sleep mode */
;;;216      CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
000004  f0230302          BIC      r3,r3,#2
000008  6003              STR      r3,[r0,#0]
;;;217    
;;;218      /* Request initialisation */
;;;219      CANx->MCR |= CAN_MCR_INRQ ;
00000a  6803              LDR      r3,[r0,#0]
00000c  f0430301          ORR      r3,r3,#1
000010  6003              STR      r3,[r0,#0]
;;;220    
;;;221      /* Wait the acknowledge */
;;;222      while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
000012  f64f73ff          MOV      r3,#0xffff
                  |L14.22|
000016  f8d0c004          LDR      r12,[r0,#4]
00001a  f01c0f01          TST      r12,#1
00001e  d103              BNE      |L14.40|
000020  429a              CMP      r2,r3
000022  bf18              IT       NE
000024  1c52              ADDNE    r2,r2,#1
000026  d1f6              BNE      |L14.22|
                  |L14.40|
;;;223      {
;;;224        wait_ack++;
;;;225      }
;;;226    
;;;227      /* Check acknowledge */
;;;228      if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
000028  6842              LDR      r2,[r0,#4]
00002a  f0120f01          TST      r2,#1
00002e  d059              BEQ      |L14.228|
;;;229      {
;;;230        InitStatus = CAN_InitStatus_Failed;
;;;231      }
;;;232      else 
;;;233      {
;;;234        /* Set the time triggered communication mode */
;;;235        if (CAN_InitStruct->CAN_TTCM == ENABLE)
000030  798a              LDRB     r2,[r1,#6]
000032  2a01              CMP      r2,#1
;;;236        {
;;;237          CANx->MCR |= CAN_MCR_TTCM;
;;;238        }
;;;239        else
;;;240        {
;;;241          CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
000034  6802              LDR      r2,[r0,#0]
000036  bf0c              ITE      EQ                    ;237
000038  f0420280          ORREQ    r2,r2,#0x80           ;237
00003c  f0220280          BICNE    r2,r2,#0x80
000040  6002              STR      r2,[r0,#0]
;;;242        }
;;;243    
;;;244        /* Set the automatic bus-off management */
;;;245        if (CAN_InitStruct->CAN_ABOM == ENABLE)
000042  79ca              LDRB     r2,[r1,#7]
000044  2a01              CMP      r2,#1
;;;246        {
;;;247          CANx->MCR |= CAN_MCR_ABOM;
;;;248        }
;;;249        else
;;;250        {
;;;251          CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
000046  6802              LDR      r2,[r0,#0]
000048  bf0c              ITE      EQ                    ;247
00004a  f0420240          ORREQ    r2,r2,#0x40           ;247
00004e  f0220240          BICNE    r2,r2,#0x40
000052  6002              STR      r2,[r0,#0]
;;;252        }
;;;253    
;;;254        /* Set the automatic wake-up mode */
;;;255        if (CAN_InitStruct->CAN_AWUM == ENABLE)
000054  7a0a              LDRB     r2,[r1,#8]
000056  2a01              CMP      r2,#1
;;;256        {
;;;257          CANx->MCR |= CAN_MCR_AWUM;
;;;258        }
;;;259        else
;;;260        {
;;;261          CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
000058  6802              LDR      r2,[r0,#0]
00005a  bf0c              ITE      EQ                    ;257
00005c  f0420220          ORREQ    r2,r2,#0x20           ;257
000060  f0220220          BICNE    r2,r2,#0x20
000064  6002              STR      r2,[r0,#0]
;;;262        }
;;;263    
;;;264        /* Set the no automatic retransmission */
;;;265        if (CAN_InitStruct->CAN_NART == ENABLE)
000066  7a4a              LDRB     r2,[r1,#9]
000068  2a01              CMP      r2,#1
;;;266        {
;;;267          CANx->MCR |= CAN_MCR_NART;
;;;268        }
;;;269        else
;;;270        {
;;;271          CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
00006a  6802              LDR      r2,[r0,#0]
00006c  bf0c              ITE      EQ                    ;267
00006e  f0420210          ORREQ    r2,r2,#0x10           ;267
000072  f0220210          BICNE    r2,r2,#0x10
000076  6002              STR      r2,[r0,#0]
;;;272        }
;;;273    
;;;274        /* Set the receive FIFO locked mode */
;;;275        if (CAN_InitStruct->CAN_RFLM == ENABLE)
000078  7a8a              LDRB     r2,[r1,#0xa]
00007a  2a01              CMP      r2,#1
;;;276        {
;;;277          CANx->MCR |= CAN_MCR_RFLM;
;;;278        }
;;;279        else
;;;280        {
;;;281          CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
00007c  6802              LDR      r2,[r0,#0]
00007e  bf0c              ITE      EQ                    ;277
000080  f0420208          ORREQ    r2,r2,#8              ;277
000084  f0220208          BICNE    r2,r2,#8
000088  6002              STR      r2,[r0,#0]
;;;282        }
;;;283    
;;;284        /* Set the transmit FIFO priority */
;;;285        if (CAN_InitStruct->CAN_TXFP == ENABLE)
00008a  7aca              LDRB     r2,[r1,#0xb]
00008c  2a01              CMP      r2,#1
;;;286        {
;;;287          CANx->MCR |= CAN_MCR_TXFP;
;;;288        }
;;;289        else
;;;290        {
;;;291          CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
00008e  6802              LDR      r2,[r0,#0]
000090  bf0c              ITE      EQ                    ;287
000092  f0420204          ORREQ    r2,r2,#4              ;287
000096  f0220204          BICNE    r2,r2,#4
00009a  6002              STR      r2,[r0,#0]
;;;292        }
;;;293    
;;;294        /* Set the bit timing register */
;;;295        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
00009c  788a              LDRB     r2,[r1,#2]
00009e  f891c003          LDRB     r12,[r1,#3]
0000a2  0792              LSLS     r2,r2,#30
0000a4  ea42620c          ORR      r2,r2,r12,LSL #24
0000a8  f891c004          LDRB     r12,[r1,#4]
0000ac  ea42420c          ORR      r2,r2,r12,LSL #16
0000b0  f891c005          LDRB     r12,[r1,#5]
0000b4  8809              LDRH     r1,[r1,#0]
0000b6  ea42520c          ORR      r2,r2,r12,LSL #20
0000ba  1e49              SUBS     r1,r1,#1
0000bc  4311              ORRS     r1,r1,r2
0000be  61c1              STR      r1,[r0,#0x1c]
;;;296                    ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
;;;297                    ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
;;;298                    ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
;;;299                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;300    
;;;301        /* Request leave initialisation */
;;;302        CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
0000c0  6801              LDR      r1,[r0,#0]
0000c2  f0210101          BIC      r1,r1,#1
0000c6  6001              STR      r1,[r0,#0]
;;;303    
;;;304       /* Wait the acknowledge */
;;;305       wait_ack = 0;
0000c8  2100              MOVS     r1,#0
                  |L14.202|
;;;306    
;;;307       while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
0000ca  6842              LDR      r2,[r0,#4]
0000cc  f0120f01          TST      r2,#1
0000d0  bf1c              ITT      NE
0000d2  4299              CMPNE    r1,r3
0000d4  1c49              ADDNE    r1,r1,#1
0000d6  d1f8              BNE      |L14.202|
;;;308       {
;;;309         wait_ack++;
;;;310       }
;;;311    
;;;312        /* ...and check acknowledged */
;;;313        if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
0000d8  6840              LDR      r0,[r0,#4]
0000da  f0100f01          TST      r0,#1
;;;314        {
;;;315          InitStatus = CAN_InitStatus_Failed;
;;;316        }
;;;317        else
;;;318        {
;;;319          InitStatus = CAN_InitStatus_Success ;
0000de  bf04              ITT      EQ
0000e0  2001              MOVEQ    r0,#1
;;;320        }
;;;321      }
;;;322    
;;;323      /* At this step, return the status of initialization */
;;;324      return InitStatus;
;;;325    }
0000e2  4770              BXEQ     lr
                  |L14.228|
0000e4  2000              MOVS     r0,#0                 ;230
0000e6  4770              BX       lr
;;;326    
                          ENDP


                          AREA ||i.CAN_MessagePending||, CODE, READONLY, ALIGN=1

                  CAN_MessagePending PROC
;;;821      */
;;;822    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  4602              MOV      r2,r0
;;;823    {
;;;824      uint8_t message_pending=0;
000002  2000              MOVS     r0,#0
;;;825      /* Check the parameters */
;;;826      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;827      assert_param(IS_CAN_FIFO(FIFONumber));
;;;828      if (FIFONumber == CAN_FIFO0)
000004  2900              CMP      r1,#0
;;;829      {
;;;830        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
000006  bf08              IT       EQ
000008  68d0              LDREQ    r0,[r2,#0xc]
00000a  d003              BEQ      |L15.20|
;;;831      }
;;;832      else if (FIFONumber == CAN_FIFO1)
00000c  2901              CMP      r1,#1
;;;833      {
;;;834        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
00000e  bf0c              ITE      EQ
000010  6910              LDREQ    r0,[r2,#0x10]
;;;835      }
;;;836      else
;;;837      {
;;;838        message_pending = 0;
;;;839      }
;;;840      return message_pending;
;;;841    }
000012  4770              BXNE     lr
                  |L15.20|
000014  f0000003          AND      r0,r0,#3              ;830
000018  4770              BX       lr
;;;842    /**
                          ENDP


                          AREA ||i.CAN_OperatingModeRequest||, CODE, READONLY, ALIGN=1

                  CAN_OperatingModeRequest PROC
;;;871      */
;;;872    uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
000000  2300              MOVS     r3,#0
;;;873    {
;;;874      uint8_t status = CAN_ModeStatus_Failed;
;;;875      
;;;876      /* Timeout for INAK or also for SLAK bits*/
;;;877      uint32_t timeout = INAK_TIMEOUT; 
000002  f64f72ff          MOV      r2,#0xffff
000006  b121              CBZ      r1,|L16.18|
;;;878    
;;;879      /* Check the parameters */
;;;880      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;881      assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
;;;882    
;;;883      if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
;;;884      {
;;;885        /* Request initialisation */
;;;886        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
;;;887    
;;;888        /* Wait the acknowledge */
;;;889        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
;;;890        {
;;;891          timeout--;
;;;892        }
;;;893        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
;;;894        {
;;;895          status = CAN_ModeStatus_Failed;
;;;896        }
;;;897        else
;;;898        {
;;;899          status = CAN_ModeStatus_Success;
;;;900        }
;;;901      }
;;;902      else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
000008  2901              CMP      r1,#1
00000a  d016              BEQ      |L16.58|
;;;903      {
;;;904        /* Request leave initialisation and sleep mode  and enter Normal mode */
;;;905        CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
;;;906    
;;;907        /* Wait the acknowledge */
;;;908        while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
;;;909        {
;;;910          timeout--;
;;;911        }
;;;912        if ((CANx->MSR & CAN_MODE_MASK) != 0)
;;;913        {
;;;914          status = CAN_ModeStatus_Failed;
;;;915        }
;;;916        else
;;;917        {
;;;918          status = CAN_ModeStatus_Success;
;;;919        }
;;;920      }
;;;921      else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
00000c  2902              CMP      r1,#2
00000e  d024              BEQ      |L16.90|
000010  e039              B        |L16.134|
                  |L16.18|
000012  6801              LDR      r1,[r0,#0]            ;886
000014  f0210102          BIC      r1,r1,#2              ;886
000018  f0410101          ORR      r1,r1,#1              ;886
00001c  6001              STR      r1,[r0,#0]            ;886
                  |L16.30|
00001e  6841              LDR      r1,[r0,#4]            ;889
000020  f0010103          AND      r1,r1,#3              ;889
000024  2901              CMP      r1,#1                 ;889
000026  bf1c              ITT      NE                    ;889
000028  2a00              CMPNE    r2,#0                 ;889
00002a  1e52              SUBNE    r2,r2,#1              ;889
00002c  d1f7              BNE      |L16.30|
00002e  6840              LDR      r0,[r0,#4]            ;893
000030  f0000003          AND      r0,r0,#3              ;893
000034  2801              CMP      r0,#1                 ;893
000036  d123              BNE      |L16.128|
000038  e024              B        |L16.132|
                  |L16.58|
00003a  6801              LDR      r1,[r0,#0]            ;905
00003c  f0210103          BIC      r1,r1,#3              ;905
000040  6001              STR      r1,[r0,#0]            ;905
                  |L16.66|
000042  6841              LDR      r1,[r0,#4]            ;908
000044  f0110f03          TST      r1,#3                 ;908
000048  bf1c              ITT      NE                    ;908
00004a  2a00              CMPNE    r2,#0                 ;908
00004c  1e52              SUBNE    r2,r2,#1              ;908
00004e  d1f8              BNE      |L16.66|
000050  6840              LDR      r0,[r0,#4]            ;912
000052  f0100f03          TST      r0,#3                 ;912
000056  d113              BNE      |L16.128|
000058  e014              B        |L16.132|
                  |L16.90|
;;;922      {
;;;923        /* Request Sleep mode */
;;;924        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  f0410102          ORR      r1,r1,#2
000064  6001              STR      r1,[r0,#0]
                  |L16.102|
;;;925    
;;;926        /* Wait the acknowledge */
;;;927        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
000066  6841              LDR      r1,[r0,#4]
000068  f0010103          AND      r1,r1,#3
00006c  2902              CMP      r1,#2
00006e  bf1c              ITT      NE
000070  2a00              CMPNE    r2,#0
000072  1e52              SUBNE    r2,r2,#1
000074  d1f7              BNE      |L16.102|
;;;928        {
;;;929          timeout--;
;;;930        }
;;;931        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
000076  6840              LDR      r0,[r0,#4]
000078  f0000003          AND      r0,r0,#3
00007c  2802              CMP      r0,#2
00007e  d001              BEQ      |L16.132|
                  |L16.128|
;;;932        {
;;;933          status = CAN_ModeStatus_Failed;
000080  2300              MOVS     r3,#0
000082  e000              B        |L16.134|
                  |L16.132|
;;;934        }
;;;935        else
;;;936        {
;;;937          status = CAN_ModeStatus_Success;
000084  2301              MOVS     r3,#1
                  |L16.134|
;;;938        }
;;;939      }
;;;940      else
;;;941      {
;;;942        status = CAN_ModeStatus_Failed;
;;;943      }
;;;944    
;;;945      return  (uint8_t) status;
000086  4618              MOV      r0,r3
;;;946    }
000088  4770              BX       lr
;;;947    
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;749      */
;;;750    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
000000  eb001301          ADD      r3,r0,r1,LSL #4
;;;751    {
;;;752      /* Check the parameters */
;;;753      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;754      assert_param(IS_CAN_FIFO(FIFONumber));
;;;755      /* Get the Id */
;;;756      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
000004  f8d3c1b0          LDR      r12,[r3,#0x1b0]
000008  f01c0c04          ANDS     r12,r12,#4
00000c  f882c008          STRB     r12,[r2,#8]
;;;757      if (RxMessage->IDE == CAN_Id_Standard)
;;;758      {
;;;759        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
;;;760      }
;;;761      else
;;;762      {
;;;763        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
000010  f8d3c1b0          LDR      r12,[r3,#0x1b0]
000014  bf07              ITTEE    EQ                    ;759
000016  ea4f5c5c          LSREQ    r12,r12,#21           ;759
00001a  f8c2c000          STREQ    r12,[r2,#0]           ;759
00001e  ea4f0cdc          LSRNE    r12,r12,#3
000022  f8c2c004          STRNE    r12,[r2,#4]
;;;764      }
;;;765      
;;;766      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
000026  f8d3c1b0          LDR      r12,[r3,#0x1b0]
00002a  f00c0c02          AND      r12,r12,#2
00002e  f882c009          STRB     r12,[r2,#9]
;;;767      /* Get the DLC */
;;;768      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
000032  f8d3c1b4          LDR      r12,[r3,#0x1b4]
000036  f00c0c0f          AND      r12,r12,#0xf
00003a  f882c00a          STRB     r12,[r2,#0xa]
;;;769      /* Get the FMI */
;;;770      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
00003e  f8d3c1b4          LDR      r12,[r3,#0x1b4]
000042  ea4f2c1c          LSR      r12,r12,#8
000046  f882c013          STRB     r12,[r2,#0x13]
;;;771      /* Get the data field */
;;;772      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
00004a  f8d3c1b8          LDR      r12,[r3,#0x1b8]
00004e  f882c00b          STRB     r12,[r2,#0xb]
;;;773      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
000052  f8d3c1b8          LDR      r12,[r3,#0x1b8]
000056  ea4f2c1c          LSR      r12,r12,#8
00005a  f882c00c          STRB     r12,[r2,#0xc]
;;;774      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
00005e  f8d3c1b8          LDR      r12,[r3,#0x1b8]
000062  ea4f4c1c          LSR      r12,r12,#16
000066  f882c00d          STRB     r12,[r2,#0xd]
;;;775      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
00006a  f8d3c1b8          LDR      r12,[r3,#0x1b8]
00006e  ea4f6c1c          LSR      r12,r12,#24
000072  f882c00e          STRB     r12,[r2,#0xe]
;;;776      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
000076  f8d3c1bc          LDR      r12,[r3,#0x1bc]
00007a  f882c00f          STRB     r12,[r2,#0xf]
;;;777      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
00007e  f8d3c1bc          LDR      r12,[r3,#0x1bc]
000082  ea4f2c1c          LSR      r12,r12,#8
000086  f882c010          STRB     r12,[r2,#0x10]
;;;778      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
00008a  f8d3c1bc          LDR      r12,[r3,#0x1bc]
00008e  ea4f4c1c          LSR      r12,r12,#16
000092  f882c011          STRB     r12,[r2,#0x11]
;;;779      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
000096  f8d331bc          LDR      r3,[r3,#0x1bc]
00009a  0e1b              LSRS     r3,r3,#24
00009c  7493              STRB     r3,[r2,#0x12]
00009e  b121              CBZ      r1,|L17.170|
;;;780      /* Release the FIFO */
;;;781      /* Release FIFO0 */
;;;782      if (FIFONumber == CAN_FIFO0)
;;;783      {
;;;784        CANx->RF0R |= CAN_RF0R_RFOM0;
;;;785      }
;;;786      /* Release FIFO1 */
;;;787      else /* FIFONumber == CAN_FIFO1 */
;;;788      {
;;;789        CANx->RF1R |= CAN_RF1R_RFOM1;
0000a0  6901              LDR      r1,[r0,#0x10]
0000a2  f0410120          ORR      r1,r1,#0x20
0000a6  6101              STR      r1,[r0,#0x10]
;;;790      }
;;;791    }
0000a8  4770              BX       lr
                  |L17.170|
0000aa  68c1              LDR      r1,[r0,#0xc]          ;784
0000ac  f0410120          ORR      r1,r1,#0x20           ;784
0000b0  60c1              STR      r1,[r0,#0xc]          ;784
0000b2  4770              BX       lr
;;;792    
                          ENDP


                          AREA ||i.CAN_SlaveStartBank||, CODE, READONLY, ALIGN=2

                  CAN_SlaveStartBank PROC
;;;467      */
;;;468    void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
000000  4909              LDR      r1,|L18.40|
;;;469    {
;;;470      /* Check the parameters */
;;;471      assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
;;;472      
;;;473      /* Enter Initialisation mode for the filter */
;;;474      CAN1->FMR |= FMR_FINIT;
000002  680a              LDR      r2,[r1,#0]
000004  f0420201          ORR      r2,r2,#1
000008  600a              STR      r2,[r1,#0]
;;;475      
;;;476      /* Select the start slave bank */
;;;477      CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
00000a  680a              LDR      r2,[r1,#0]
00000c  f4227287          BIC      r2,r2,#0x10e
000010  f4225278          BIC      r2,r2,#0x3e00
000014  600a              STR      r2,[r1,#0]
;;;478      CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
000016  680a              LDR      r2,[r1,#0]
000018  ea422000          ORR      r0,r2,r0,LSL #8
00001c  6008              STR      r0,[r1,#0]
;;;479      
;;;480      /* Leave Initialisation mode for the filter */
;;;481      CAN1->FMR &= ~FMR_FINIT;
00001e  6808              LDR      r0,[r1,#0]
000020  f0200001          BIC      r0,r0,#1
000024  6008              STR      r0,[r1,#0]
;;;482    }
000026  4770              BX       lr
;;;483    
                          ENDP

                  |L18.40|
                          DCD      0x40006600

                          AREA ||i.CAN_Sleep||, CODE, READONLY, ALIGN=1

                  CAN_Sleep PROC
;;;952      */
;;;953    uint8_t CAN_Sleep(CAN_TypeDef* CANx)
000000  6802              LDR      r2,[r0,#0]
;;;954    {
;;;955      uint8_t sleepstatus = CAN_Sleep_Failed;
000002  2100              MOVS     r1,#0
;;;956      
;;;957      /* Check the parameters */
;;;958      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;959        
;;;960      /* Request Sleep mode */
;;;961       CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
000004  f0220201          BIC      r2,r2,#1
000008  f0420202          ORR      r2,r2,#2
00000c  6002              STR      r2,[r0,#0]
;;;962       
;;;963      /* Sleep mode status */
;;;964      if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
00000e  6840              LDR      r0,[r0,#4]
000010  f0000003          AND      r0,r0,#3
000014  2802              CMP      r0,#2
;;;965      {
;;;966        /* Sleep mode not entered */
;;;967        sleepstatus =  CAN_Sleep_Ok;
000016  bf08              IT       EQ
000018  2101              MOVEQ    r1,#1
;;;968      }
;;;969      /* return sleep mode status */
;;;970       return (uint8_t)sleepstatus;
00001a  4608              MOV      r0,r1
;;;971    }
00001c  4770              BX       lr
;;;972    
                          ENDP


                          AREA ||i.CAN_StructInit||, CODE, READONLY, ALIGN=1

                  CAN_StructInit PROC
;;;424      */
;;;425    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000000  2100              MOVS     r1,#0
;;;426    {
;;;427      /* Reset CAN init structure parameters values */
;;;428      
;;;429      /* Initialize the time triggered communication mode */
;;;430      CAN_InitStruct->CAN_TTCM = DISABLE;
000002  7181              STRB     r1,[r0,#6]
;;;431      
;;;432      /* Initialize the automatic bus-off management */
;;;433      CAN_InitStruct->CAN_ABOM = DISABLE;
000004  71c1              STRB     r1,[r0,#7]
;;;434      
;;;435      /* Initialize the automatic wake-up mode */
;;;436      CAN_InitStruct->CAN_AWUM = DISABLE;
000006  7201              STRB     r1,[r0,#8]
;;;437      
;;;438      /* Initialize the no automatic retransmission */
;;;439      CAN_InitStruct->CAN_NART = DISABLE;
000008  7241              STRB     r1,[r0,#9]
;;;440      
;;;441      /* Initialize the receive FIFO locked mode */
;;;442      CAN_InitStruct->CAN_RFLM = DISABLE;
00000a  7281              STRB     r1,[r0,#0xa]
;;;443      
;;;444      /* Initialize the transmit FIFO priority */
;;;445      CAN_InitStruct->CAN_TXFP = DISABLE;
00000c  72c1              STRB     r1,[r0,#0xb]
;;;446      
;;;447      /* Initialize the CAN_Mode member */
;;;448      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
00000e  7081              STRB     r1,[r0,#2]
;;;449      
;;;450      /* Initialize the CAN_SJW member */
;;;451      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
000010  70c1              STRB     r1,[r0,#3]
;;;452      
;;;453      /* Initialize the CAN_BS1 member */
;;;454      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
000012  2103              MOVS     r1,#3
000014  7101              STRB     r1,[r0,#4]
;;;455      
;;;456      /* Initialize the CAN_BS2 member */
;;;457      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
000016  2102              MOVS     r1,#2
000018  7141              STRB     r1,[r0,#5]
;;;458      
;;;459      /* Initialize the CAN_Prescaler member */
;;;460      CAN_InitStruct->CAN_Prescaler = 1;
00001a  2101              MOVS     r1,#1
00001c  8001              STRH     r1,[r0,#0]
;;;461    }
00001e  4770              BX       lr
;;;462    
                          ENDP


                          AREA ||i.CAN_TTComModeCmd||, CODE, READONLY, ALIGN=1

                  CAN_TTComModeCmd PROC
;;;522      */
;;;523    void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;524    {
;;;525      /* Check the parameters */
;;;526      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;527      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;528      if (NewState != DISABLE)
;;;529      {
;;;530        /* Enable the TTCM mode */
;;;531        CANx->MCR |= CAN_MCR_TTCM;
;;;532    
;;;533        /* Set TGT bits */
;;;534        CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
;;;535        CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
;;;536        CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
;;;537      }
;;;538      else
;;;539      {
;;;540        /* Disable the TTCM mode */
;;;541        CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
000002  6801              LDR      r1,[r0,#0]
000004  d013              BEQ      |L21.46|
000006  f0410180          ORR      r1,r1,#0x80           ;531
00000a  6001              STR      r1,[r0,#0]            ;531
00000c  f8d01184          LDR      r1,[r0,#0x184]        ;534
000010  f4417180          ORR      r1,r1,#0x100          ;534
000014  f8c01184          STR      r1,[r0,#0x184]        ;534
000018  f8d01194          LDR      r1,[r0,#0x194]        ;535
00001c  f4417180          ORR      r1,r1,#0x100          ;535
000020  f8c01194          STR      r1,[r0,#0x194]        ;535
000024  f8d011a4          LDR      r1,[r0,#0x1a4]        ;536
000028  f4417180          ORR      r1,r1,#0x100          ;536
00002c  e012              B        |L21.84|
                  |L21.46|
00002e  f0210180          BIC      r1,r1,#0x80
000032  6001              STR      r1,[r0,#0]
;;;542    
;;;543        /* Reset TGT bits */
;;;544        CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
000034  f8d01184          LDR      r1,[r0,#0x184]
000038  f4217180          BIC      r1,r1,#0x100
00003c  f8c01184          STR      r1,[r0,#0x184]
;;;545        CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
000040  f8d01194          LDR      r1,[r0,#0x194]
000044  f4217180          BIC      r1,r1,#0x100
000048  f8c01194          STR      r1,[r0,#0x194]
;;;546        CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
00004c  f8d011a4          LDR      r1,[r0,#0x1a4]
000050  f4217180          BIC      r1,r1,#0x100
                  |L21.84|
000054  f8c011a4          STR      r1,[r0,#0x1a4]        ;536
;;;547      }
;;;548    }
000058  4770              BX       lr
;;;549    /**
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;576      */
;;;577    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
000000  b410              PUSH     {r4}
;;;578    {
000002  4602              MOV      r2,r0
;;;579      uint8_t transmit_mailbox = 0;
000004  2000              MOVS     r0,#0
;;;580      /* Check the parameters */
;;;581      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;582      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;583      assert_param(IS_CAN_RTR(TxMessage->RTR));
;;;584      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;585    
;;;586      /* Select one empty transmit mailbox */
;;;587      if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
000006  6893              LDR      r3,[r2,#8]
000008  f0136f80          TST      r3,#0x4000000
00000c  d03e              BEQ      |L22.140|
                  |L22.14|
;;;588      {
;;;589        transmit_mailbox = 0;
;;;590      }
;;;591      else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
;;;592      {
;;;593        transmit_mailbox = 1;
;;;594      }
;;;595      else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
;;;596      {
;;;597        transmit_mailbox = 2;
;;;598      }
;;;599      else
;;;600      {
;;;601        transmit_mailbox = CAN_TxStatus_NoMailBox;
;;;602      }
;;;603    
;;;604      if (transmit_mailbox != CAN_TxStatus_NoMailBox)
;;;605      {
;;;606        /* Set up the Id */
;;;607        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
00000e  eb021200          ADD      r2,r2,r0,LSL #4
000012  f8d23180          LDR      r3,[r2,#0x180]
000016  f0030301          AND      r3,r3,#1
00001a  f8c23180          STR      r3,[r2,#0x180]
;;;608        if (TxMessage->IDE == CAN_Id_Standard)
00001e  7a0b              LDRB     r3,[r1,#8]
000020  2b00              CMP      r3,#0
000022  d042              BEQ      |L22.170|
;;;609        {
;;;610          assert_param(IS_CAN_STDID(TxMessage->StdId));  
;;;611          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
;;;612                                                      TxMessage->RTR);
;;;613        }
;;;614        else
;;;615        {
;;;616          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
;;;617          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
000024  f8d2c180          LDR      r12,[r2,#0x180]
000028  684c              LDR      r4,[r1,#4]
00002a  ea4c0303          ORR      r3,r12,r3
00002e  f891c009          LDRB     r12,[r1,#9]
000032  ea4c0cc4          ORR      r12,r12,r4,LSL #3
000036  ea43030c          ORR      r3,r3,r12
                  |L22.58|
00003a  f8c23180          STR      r3,[r2,#0x180]
;;;618                                                      TxMessage->IDE | \
;;;619                                                      TxMessage->RTR);
;;;620        }
;;;621        
;;;622        /* Set up the DLC */
;;;623        TxMessage->DLC &= (uint8_t)0x0000000F;
00003e  7a8b              LDRB     r3,[r1,#0xa]
000040  f003030f          AND      r3,r3,#0xf
000044  728b              STRB     r3,[r1,#0xa]
;;;624        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
000046  f8d23184          LDR      r3,[r2,#0x184]
00004a  f023030f          BIC      r3,r3,#0xf
00004e  f8c23184          STR      r3,[r2,#0x184]
;;;625        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
000052  f8d23184          LDR      r3,[r2,#0x184]
000056  f891c00a          LDRB     r12,[r1,#0xa]
00005a  ea43030c          ORR      r3,r3,r12
00005e  f8c23184          STR      r3,[r2,#0x184]
;;;626    
;;;627        /* Set up the data field */
;;;628        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
000062  7acb              LDRB     r3,[r1,#0xb]
000064  f8d1c00c          LDR      r12,[r1,#0xc]
000068  ea43230c          ORR      r3,r3,r12,LSL #8
00006c  f8c23188          STR      r3,[r2,#0x188]
;;;629                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;630                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;631                                                 ((uint32_t)TxMessage->Data[0]));
;;;632        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
000070  7bcb              LDRB     r3,[r1,#0xf]
000072  6909              LDR      r1,[r1,#0x10]
000074  ea432101          ORR      r1,r3,r1,LSL #8
000078  f8c2118c          STR      r1,[r2,#0x18c]
;;;633                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;634                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;635                                                 ((uint32_t)TxMessage->Data[4]));
;;;636        /* Request transmission */
;;;637        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
00007c  f8d21180          LDR      r1,[r2,#0x180]
000080  f0410101          ORR      r1,r1,#1
000084  f8c21180          STR      r1,[r2,#0x180]
;;;638      }
;;;639      return transmit_mailbox;
;;;640    }
000088  bc10              POP      {r4}
00008a  4770              BX       lr
                  |L22.140|
00008c  6890              LDR      r0,[r2,#8]            ;591
00008e  f0106f00          TST      r0,#0x8000000         ;591
000092  bf18              IT       NE                    ;593
000094  2001              MOVNE    r0,#1                 ;593
000096  d1ba              BNE      |L22.14|
000098  6890              LDR      r0,[r2,#8]            ;595
00009a  f0105f80          TST      r0,#0x10000000        ;595
00009e  bf14              ITE      NE                    ;597
0000a0  2002              MOVNE    r0,#2                 ;597
0000a2  2004              MOVEQ    r0,#4                 ;601
0000a4  d1b3              BNE      |L22.14|
0000a6  bc10              POP      {r4}
0000a8  4770              BX       lr
                  |L22.170|
0000aa  f8d23180          LDR      r3,[r2,#0x180]        ;611
0000ae  f891c009          LDRB     r12,[r1,#9]           ;611
0000b2  ea43030c          ORR      r3,r3,r12             ;611
0000b6  f8b1c000          LDRH     r12,[r1,#0]           ;611
0000ba  ea43534c          ORR      r3,r3,r12,LSL #21     ;611
0000be  e7bc              B        |L22.58|
;;;641    
                          ENDP


                          AREA ||i.CAN_TransmitStatus||, CODE, READONLY, ALIGN=2

                  CAN_TransmitStatus PROC
;;;648      */
;;;649    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
000000  2200              MOVS     r2,#0
;;;650    {
;;;651      uint32_t state = 0;
;;;652    
;;;653      /* Check the parameters */
;;;654      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;655      assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
;;;656     
;;;657      switch (TransmitMailbox)
000002  2900              CMP      r1,#0
;;;658      {
;;;659        case (CAN_TXMAILBOX_0): 
;;;660          state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
000004  bf04              ITT      EQ
000006  6880              LDREQ    r0,[r0,#8]
000008  4918              LDREQ    r1,|L23.108|
00000a  d007              BEQ      |L23.28|
00000c  2901              CMP      r1,#1                 ;657
;;;661          break;
;;;662        case (CAN_TXMAILBOX_1): 
;;;663          state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
00000e  bf04              ITT      EQ
000010  6880              LDREQ    r0,[r0,#8]
000012  4917              LDREQ    r1,|L23.112|
000014  d002              BEQ      |L23.28|
000016  2902              CMP      r1,#2                 ;657
000018  d003              BEQ      |L23.34|
00001a  e006              B        |L23.42|
                  |L23.28|
00001c  ea000201          AND      r2,r0,r1              ;660
000020  e003              B        |L23.42|
                  |L23.34|
;;;664          break;
;;;665        case (CAN_TXMAILBOX_2): 
;;;666          state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
000022  6880              LDR      r0,[r0,#8]
000024  4913              LDR      r1,|L23.116|
000026  ea000201          AND      r2,r0,r1
                  |L23.42|
;;;667          break;
;;;668        default:
;;;669          state = CAN_TxStatus_Failed;
;;;670          break;
;;;671      }
;;;672      switch (state)
00002a  4913              LDR      r1,|L23.120|
00002c  1a50              SUBS     r0,r2,r1
00002e  428a              CMP      r2,r1
000030  d017              BEQ      |L23.98|
000032  dc0a              BGT      |L23.74|
000034  2a00              CMP      r2,#0
000036  bf15              ITETE    NE
000038  f06f6080          MVNNE    r0,#0x4000000
;;;673      {
;;;674          /* transmit pending  */
;;;675        case (0x0): state = CAN_TxStatus_Pending;
00003c  2002              MOVEQ    r0,#2
00003e  eb120000          ADDSNE   r0,r2,r0              ;672
;;;676          break;
;;;677          /* transmit failed  */
;;;678         case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
;;;679          break;
;;;680         case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
;;;681          break;
;;;682         case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
;;;683          break;
;;;684          /* transmit succeeded  */
;;;685        case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
;;;686          break;
;;;687        case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
;;;688          break;
;;;689        case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
;;;690          break;
;;;691        default: state = CAN_TxStatus_Failed;
;;;692          break;
;;;693      }
;;;694      return (uint8_t) state;
;;;695    }
000042  4770              BXEQ     lr
000044  2802              CMP      r0,#2                 ;672
000046  d00e              BEQ      |L23.102|
000048  e00b              B        |L23.98|
                  |L23.74|
00004a  f5b07f00          CMP      r0,#0x200             ;672
00004e  d00a              BEQ      |L23.102|
000050  f1a06000          SUB      r0,r0,#0x8000000      ;672
000054  f5b0407f          SUBS     r0,r0,#0xff00         ;672
000058  bf08              IT       EQ
00005a  4770              BXEQ     lr
00005c  f5b03f00          CMP      r0,#0x20000           ;672
000060  d001              BEQ      |L23.102|
                  |L23.98|
000062  2000              MOVS     r0,#0                 ;691
000064  4770              BX       lr
                  |L23.102|
000066  2001              MOVS     r0,#1                 ;689
000068  4770              BX       lr
;;;696    
                          ENDP

00006a  0000              DCW      0x0000
                  |L23.108|
                          DCD      0x04000003
                  |L23.112|
                          DCD      0x08000300
                  |L23.116|
                          DCD      0x10030000
                  |L23.120|
                          DCD      0x08000100

                          AREA ||i.CAN_WakeUp||, CODE, READONLY, ALIGN=1

                  CAN_WakeUp PROC
;;;977      */
;;;978    uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
000000  6802              LDR      r2,[r0,#0]
;;;979    {
;;;980      uint32_t wait_slak = SLAK_TIMEOUT;
000002  f64f71ff          MOV      r1,#0xffff
;;;981      uint8_t wakeupstatus = CAN_WakeUp_Failed;
000006  2300              MOVS     r3,#0
;;;982      
;;;983      /* Check the parameters */
;;;984      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;985        
;;;986      /* Wake up request */
;;;987      CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
000008  f0220202          BIC      r2,r2,#2
00000c  6002              STR      r2,[r0,#0]
                  |L24.14|
;;;988        
;;;989      /* Sleep mode status */
;;;990      while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
00000e  6842              LDR      r2,[r0,#4]
000010  f0120f02          TST      r2,#2
000014  bf1c              ITT      NE
000016  2900              CMPNE    r1,#0
000018  1e49              SUBNE    r1,r1,#1
00001a  d1f8              BNE      |L24.14|
;;;991      {
;;;992       wait_slak--;
;;;993      }
;;;994      if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
00001c  6840              LDR      r0,[r0,#4]
00001e  f0100f02          TST      r0,#2
;;;995      {
;;;996       /* wake up done : Sleep mode exited */
;;;997        wakeupstatus = CAN_WakeUp_Ok;
000022  bf08              IT       EQ
000024  2301              MOVEQ    r3,#1
;;;998      }
;;;999      /* return wakeup status */
;;;1000     return (uint8_t)wakeupstatus;
000026  4618              MOV      r0,r3
;;;1001   }
000028  4770              BX       lr
;;;1002   /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\stm32f4xx_can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_can_c_347dae01____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___15_stm32f4xx_can_c_347dae01____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_can_c_347dae01____REVSH|
#line 144
|__asm___15_stm32f4xx_can_c_347dae01____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
