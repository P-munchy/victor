; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\stm32f4xx_dac.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f4xx_dac.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\stm32f4xx_dac.crf arm_hal\lib\stm32f4xx_dac.c]
                          THUMB

                          AREA ||i.DAC_ClearFlag||, CODE, READONLY, ALIGN=2

                  DAC_ClearFlag PROC
;;;624      */
;;;625    void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
000000  fa01f000          LSL      r0,r1,r0
;;;626    {
;;;627      /* Check the parameters */
;;;628      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;629      assert_param(IS_DAC_FLAG(DAC_FLAG));
;;;630    
;;;631      /* Clear the selected DAC flags */
;;;632      DAC->SR = (DAC_FLAG << DAC_Channel);
000004  4901              LDR      r1,|L1.12|
000006  6008              STR      r0,[r1,#0]
;;;633    }
000008  4770              BX       lr
;;;634    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      0x40007434

                          AREA ||i.DAC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  DAC_ClearITPendingBit PROC
;;;687      */
;;;688    void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
000000  fa01f000          LSL      r0,r1,r0
;;;689    {
;;;690      /* Check the parameters */
;;;691      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;692      assert_param(IS_DAC_IT(DAC_IT)); 
;;;693    
;;;694      /* Clear the selected DAC interrupt pending bits */
;;;695      DAC->SR = (DAC_IT << DAC_Channel);
000004  4901              LDR      r1,|L2.12|
000006  6008              STR      r0,[r1,#0]
;;;696    }
000008  4770              BX       lr
;;;697    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x40007434

                          AREA ||i.DAC_Cmd||, CODE, READONLY, ALIGN=2

                  DAC_Cmd PROC
;;;265      */
;;;266    void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  4a05              LDR      r2,|L3.24|
;;;267    {
;;;268      /* Check the parameters */
;;;269      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;270      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;271    
;;;272      if (NewState != DISABLE)
;;;273      {
;;;274        /* Enable the selected DAC channel */
;;;275        DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
000002  2301              MOVS     r3,#1
000004  fa03f000          LSL      r0,r3,r0
000008  2900              CMP      r1,#0                 ;272
;;;276      }
;;;277      else
;;;278      {
;;;279        /* Disable the selected DAC channel */
;;;280        DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
00000a  6811              LDR      r1,[r2,#0]
00000c  bf14              ITE      NE                    ;275
00000e  4308              ORRNE    r0,r0,r1              ;275
000010  ea210000          BICEQ    r0,r1,r0
000014  6010              STR      r0,[r2,#0]            ;275
;;;281      }
;;;282    }
000016  4770              BX       lr
;;;283    
                          ENDP

                  |L3.24|
                          DCD      0x40007400

                          AREA ||i.DAC_DMACmd||, CODE, READONLY, ALIGN=2

                  DAC_DMACmd PROC
;;;509      */
;;;510    void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  4a05              LDR      r2,|L4.24|
;;;511    {
;;;512      /* Check the parameters */
;;;513      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;514      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;515    
;;;516      if (NewState != DISABLE)
;;;517      {
;;;518        /* Enable the selected DAC channel DMA request */
;;;519        DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
000002  1493              ASRS     r3,r2,#18
000004  fa03f000          LSL      r0,r3,r0
000008  2900              CMP      r1,#0                 ;516
;;;520      }
;;;521      else
;;;522      {
;;;523        /* Disable the selected DAC channel DMA request */
;;;524        DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
00000a  6811              LDR      r1,[r2,#0]
00000c  bf14              ITE      NE                    ;519
00000e  4308              ORRNE    r0,r0,r1              ;519
000010  ea210000          BICEQ    r0,r1,r0
000014  6010              STR      r0,[r2,#0]            ;519
;;;525      }
;;;526    }
000016  4770              BX       lr
;;;527    /**
                          ENDP

                  |L4.24|
                          DCD      0x40007400

                          AREA ||i.DAC_DeInit||, CODE, READONLY, ALIGN=1

                  DAC_DeInit PROC
;;;186      */
;;;187    void DAC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;188    {
;;;189      /* Enable DAC reset state */
;;;190      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0748              LSLS     r0,r1,#29
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;191      /* Release DAC from reset state */
;;;192      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
00000a  e8bd4010          POP      {r4,lr}
00000e  2100              MOVS     r1,#0
000010  f04f5000          MOV      r0,#0x20000000
000014  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;193    }
;;;194    
                          ENDP


                          AREA ||i.DAC_DualSoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_DualSoftwareTriggerCmd PROC
;;;317      */
;;;318    void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L6.20|
;;;319    {
;;;320      /* Check the parameters */
;;;321      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;322    
;;;323      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;324      {
;;;325        /* Enable software trigger for both DAC channels */
;;;326        DAC->SWTRIGR |= DUAL_SWTRIG_SET;
;;;327      }
;;;328      else
;;;329      {
;;;330        /* Disable software trigger for both DAC channels */
;;;331        DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;326
000008  f0400003          ORRNE    r0,r0,#3              ;326
00000c  f0200003          BICEQ    r0,r0,#3
000010  6008              STR      r0,[r1,#0]            ;326
;;;332      }
;;;333    }
000012  4770              BX       lr
;;;334    
                          ENDP

                  |L6.20|
                          DCD      0x40007404

                          AREA ||i.DAC_GetDataOutputValue||, CODE, READONLY, ALIGN=2

                  DAC_GetDataOutputValue PROC
;;;464      */
;;;465    uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
000000  4904              LDR      r1,|L7.20|
;;;466    {
000002  b081              SUB      sp,sp,#4
;;;467      __IO uint32_t tmp = 0;
;;;468      
;;;469      /* Check the parameters */
;;;470      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;471      
;;;472      tmp = (uint32_t) DAC_BASE ;
;;;473      tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
000004  eb010090          ADD      r0,r1,r0,LSR #2
000008  302c              ADDS     r0,r0,#0x2c
;;;474      
;;;475      /* Returns the DAC channel data output register value */
;;;476      return (uint16_t) (*(__IO uint32_t*) tmp);
00000a  9000              STR      r0,[sp,#0]
00000c  6800              LDR      r0,[r0,#0]
;;;477    }
00000e  b001              ADD      sp,sp,#4
000010  b280              UXTH     r0,r0                 ;476
000012  4770              BX       lr
;;;478    /**
                          ENDP

                  |L7.20|
                          DCD      0x40007400

                          AREA ||i.DAC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  DAC_GetFlagStatus PROC
;;;589      */
;;;590    FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
000000  4b04              LDR      r3,|L8.20|
;;;591    {
000002  4602              MOV      r2,r0
;;;592      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;593      /* Check the parameters */
;;;594      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;595      assert_param(IS_DAC_FLAG(DAC_FLAG));
;;;596    
;;;597      /* Check the status of the specified DAC flag */
;;;598      if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
000006  681b              LDR      r3,[r3,#0]
000008  4091              LSLS     r1,r1,r2
00000a  420b              TST      r3,r1
;;;599      {
;;;600        /* DAC_FLAG is set */
;;;601        bitstatus = SET;
00000c  bf18              IT       NE
00000e  2001              MOVNE    r0,#1
;;;602      }
;;;603      else
;;;604      {
;;;605        /* DAC_FLAG is reset */
;;;606        bitstatus = RESET;
;;;607      }
;;;608      /* Return the DAC_FLAG status */
;;;609      return  bitstatus;
;;;610    }
000010  4770              BX       lr
;;;611    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40007434

                          AREA ||i.DAC_GetITStatus||, CODE, READONLY, ALIGN=2

                  DAC_GetITStatus PROC
;;;647      */
;;;648    ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
000000  4b06              LDR      r3,|L9.28|
;;;649    {
000002  4602              MOV      r2,r0
;;;650      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;651      uint32_t enablestatus = 0;
;;;652      
;;;653      /* Check the parameters */
;;;654      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;655      assert_param(IS_DAC_IT(DAC_IT));
;;;656    
;;;657      /* Get the DAC_IT enable bit status */
;;;658      enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
000006  681b              LDR      r3,[r3,#0]
000008  4091              LSLS     r1,r1,r2
00000a  ea030201          AND      r2,r3,r1
;;;659      
;;;660      /* Check the status of the specified DAC interrupt */
;;;661      if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
00000e  4b04              LDR      r3,|L9.32|
000010  681b              LDR      r3,[r3,#0]
000012  420b              TST      r3,r1
000014  bf1c              ITT      NE
000016  2a00              CMPNE    r2,#0
;;;662      {
;;;663        /* DAC_IT is set */
;;;664        bitstatus = SET;
000018  2001              MOVNE    r0,#1
;;;665      }
;;;666      else
;;;667      {
;;;668        /* DAC_IT is reset */
;;;669        bitstatus = RESET;
;;;670      }
;;;671      /* Return the DAC_IT status */
;;;672      return  bitstatus;
;;;673    }
00001a  4770              BX       lr
;;;674    
                          ENDP

                  |L9.28|
                          DCD      0x40007400
                  |L9.32|
                          DCD      0x40007434

                          AREA ||i.DAC_ITConfig||, CODE, READONLY, ALIGN=2

                  DAC_ITConfig PROC
;;;557      */ 
;;;558    void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
000000  4b05              LDR      r3,|L10.24|
;;;559    {
;;;560      /* Check the parameters */
;;;561      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;562      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;563      assert_param(IS_DAC_IT(DAC_IT)); 
;;;564    
;;;565      if (NewState != DISABLE)
;;;566      {
;;;567        /* Enable the selected DAC interrupts */
;;;568        DAC->CR |=  (DAC_IT << DAC_Channel);
000002  fa01f000          LSL      r0,r1,r0
000006  2a00              CMP      r2,#0                 ;565
;;;569      }
;;;570      else
;;;571      {
;;;572        /* Disable the selected DAC interrupts */
;;;573        DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
000008  6819              LDR      r1,[r3,#0]
00000a  bf14              ITE      NE                    ;568
00000c  4308              ORRNE    r0,r0,r1              ;568
00000e  ea210000          BICEQ    r0,r1,r0
000012  6018              STR      r0,[r3,#0]            ;568
;;;574      }
;;;575    }
000014  4770              BX       lr
;;;576    
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      0x40007400

                          AREA ||i.DAC_Init||, CODE, READONLY, ALIGN=2

                  DAC_Init PROC
;;;205      */
;;;206    void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
000000  4b0b              LDR      r3,|L11.48|
;;;207    {
000002  b410              PUSH     {r4}
;;;208      uint32_t tmpreg1 = 0, tmpreg2 = 0;
;;;209    
;;;210      /* Check the DAC parameters */
;;;211      assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
;;;212      assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
;;;213      assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
;;;214      assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
;;;215    
;;;216    /*---------------------------- DAC CR Configuration --------------------------*/
;;;217      /* Get the DAC CR value */
;;;218      tmpreg1 = DAC->CR;
000004  681a              LDR      r2,[r3,#0]
;;;219      /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
;;;220      tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
000006  f6407cfe          MOV      r12,#0xffe
00000a  fa0cfc00          LSL      r12,r12,r0
00000e  ea22020c          BIC      r2,r2,r12
000012  e9d1c400          LDRD     r12,r4,[r1,#0]
;;;221      /* Configure for the selected DAC channel: buffer output, trigger, 
;;;222         wave generation, mask/amplitude for wave generation */
;;;223      /* Set TSELx and TENx bits according to DAC_Trigger value */
;;;224      /* Set WAVEx bits according to DAC_WaveGeneration value */
;;;225      /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
;;;226      /* Set BOFFx bit according to DAC_OutputBuffer value */   
;;;227      tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
000016  ea4c0c04          ORR      r12,r12,r4
00001a  e9d14102          LDRD     r4,r1,[r1,#8]
00001e  4321              ORRS     r1,r1,r4
000020  ea4c0101          ORR      r1,r12,r1
;;;228                 DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
;;;229                 DAC_InitStruct->DAC_OutputBuffer);
;;;230      /* Calculate CR register value depending on DAC_Channel */
;;;231      tmpreg1 |= tmpreg2 << DAC_Channel;
000024  fa01f000          LSL      r0,r1,r0
000028  4310              ORRS     r0,r0,r2
;;;232      /* Write to DAC CR */
;;;233      DAC->CR = tmpreg1;
00002a  6018              STR      r0,[r3,#0]
;;;234    }
00002c  bc10              POP      {r4}
00002e  4770              BX       lr
;;;235    
                          ENDP

                  |L11.48|
                          DCD      0x40007400

                          AREA ||i.DAC_SetChannel1Data||, CODE, READONLY, ALIGN=1

                  DAC_SetChannel1Data PROC
;;;377      */
;;;378    void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
000000  f6a030f8          SUB      r0,r0,#0xbf8
;;;379    {  
000004  b081              SUB      sp,sp,#4
000006  f1004080          ADD      r0,r0,#0x40000000
00000a  f5004000          ADD      r0,r0,#0x8000
;;;380      __IO uint32_t tmp = 0;
;;;381      
;;;382      /* Check the parameters */
;;;383      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;384      assert_param(IS_DAC_DATA(Data));
;;;385      
;;;386      tmp = (uint32_t)DAC_BASE; 
;;;387      tmp += DHR12R1_OFFSET + DAC_Align;
;;;388    
;;;389      /* Set the DAC channel1 selected data holding register */
;;;390      *(__IO uint32_t *) tmp = Data;
00000e  9000              STR      r0,[sp,#0]
000010  6001              STR      r1,[r0,#0]
;;;391    }
000012  b001              ADD      sp,sp,#4
000014  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.DAC_SetChannel2Data||, CODE, READONLY, ALIGN=1

                  DAC_SetChannel2Data PROC
;;;402      */
;;;403    void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
000000  f6a030ec          SUB      r0,r0,#0xbec
;;;404    {
000004  b081              SUB      sp,sp,#4
000006  f1004080          ADD      r0,r0,#0x40000000
00000a  f5004000          ADD      r0,r0,#0x8000
;;;405      __IO uint32_t tmp = 0;
;;;406    
;;;407      /* Check the parameters */
;;;408      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;409      assert_param(IS_DAC_DATA(Data));
;;;410      
;;;411      tmp = (uint32_t)DAC_BASE;
;;;412      tmp += DHR12R2_OFFSET + DAC_Align;
;;;413    
;;;414      /* Set the DAC channel2 selected data holding register */
;;;415      *(__IO uint32_t *)tmp = Data;
00000e  9000              STR      r0,[sp,#0]
000010  6001              STR      r1,[r0,#0]
;;;416    }
000012  b001              ADD      sp,sp,#4
000014  4770              BX       lr
;;;417    
                          ENDP


                          AREA ||i.DAC_SetDualChannelData||, CODE, READONLY, ALIGN=1

                  DAC_SetDualChannelData PROC
;;;430      */
;;;431    void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
000000  2808              CMP      r0,#8
;;;432    {
;;;433      uint32_t data = 0, tmp = 0;
;;;434      
;;;435      /* Check the parameters */
;;;436      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;437      assert_param(IS_DAC_DATA(Data1));
;;;438      assert_param(IS_DAC_DATA(Data2));
;;;439      
;;;440      /* Calculate and set dual DAC data holding register value */
;;;441      if (DAC_Align == DAC_Align_8b_R)
;;;442      {
;;;443        data = ((uint32_t)Data2 << 8) | Data1; 
000002  bf0c              ITE      EQ
000004  ea422101          ORREQ    r1,r2,r1,LSL #8
;;;444      }
;;;445      else
;;;446      {
;;;447        data = ((uint32_t)Data2 << 16) | Data1;
000008  ea424101          ORRNE    r1,r2,r1,LSL #16
00000c  f1004080          ADD      r0,r0,#0x40000000
000010  f50040e8          ADD      r0,r0,#0x7400
;;;448      }
;;;449      
;;;450      tmp = (uint32_t)DAC_BASE;
;;;451      tmp += DHR12RD_OFFSET + DAC_Align;
;;;452    
;;;453      /* Set the dual DAC selected data holding register */
;;;454      *(__IO uint32_t *)tmp = data;
000014  6201              STR      r1,[r0,#0x20]
;;;455    }
000016  4770              BX       lr
;;;456    
                          ENDP


                          AREA ||i.DAC_SoftwareTriggerCmd||, CODE, READONLY, ALIGN=2

                  DAC_SoftwareTriggerCmd PROC
;;;293      */
;;;294    void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
000000  4a06              LDR      r2,|L15.28|
;;;295    {
;;;296      /* Check the parameters */
;;;297      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;298      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;299    
;;;300      if (NewState != DISABLE)
;;;301      {
;;;302        /* Enable software trigger for the selected DAC channel */
;;;303        DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
000002  0900              LSRS     r0,r0,#4
000004  2301              MOVS     r3,#1
000006  fa03f000          LSL      r0,r3,r0
00000a  2900              CMP      r1,#0                 ;300
;;;304      }
;;;305      else
;;;306      {
;;;307        /* Disable software trigger for the selected DAC channel */
;;;308        DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
00000c  6811              LDR      r1,[r2,#0]
00000e  bf14              ITE      NE                    ;303
000010  4308              ORRNE    r0,r0,r1              ;303
000012  ea210000          BICEQ    r0,r1,r0
000016  6010              STR      r0,[r2,#0]            ;303
;;;309      }
;;;310    }
000018  4770              BX       lr
;;;311    
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x40007404

                          AREA ||i.DAC_StructInit||, CODE, READONLY, ALIGN=1

                  DAC_StructInit PROC
;;;241      */
;;;242    void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
000000  2100              MOVS     r1,#0
;;;243    {
;;;244    /*--------------- Reset DAC init structure parameters values -----------------*/
;;;245      /* Initialize the DAC_Trigger member */
;;;246      DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
;;;247      /* Initialize the DAC_WaveGeneration member */
;;;248      DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
000002  6001              STR      r1,[r0,#0]
;;;249      /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
;;;250      DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
000004  6041              STR      r1,[r0,#4]
;;;251      /* Initialize the DAC_OutputBuffer member */
;;;252      DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;253    }
00000a  4770              BX       lr
;;;254    
                          ENDP


                          AREA ||i.DAC_WaveGenerationCmd||, CODE, READONLY, ALIGN=2

                  DAC_WaveGenerationCmd PROC
;;;348      */
;;;349    void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
000000  4b05              LDR      r3,|L17.24|
;;;350    {
;;;351      /* Check the parameters */
;;;352      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;353      assert_param(IS_DAC_WAVE(DAC_Wave)); 
;;;354      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;355    
;;;356      if (NewState != DISABLE)
;;;357      {
;;;358        /* Enable the selected wave generation for the selected DAC channel */
;;;359        DAC->CR |= DAC_Wave << DAC_Channel;
000002  fa01f000          LSL      r0,r1,r0
000006  2a00              CMP      r2,#0                 ;356
;;;360      }
;;;361      else
;;;362      {
;;;363        /* Disable the selected wave generation for the selected DAC channel */
;;;364        DAC->CR &= ~(DAC_Wave << DAC_Channel);
000008  6819              LDR      r1,[r3,#0]
00000a  bf14              ITE      NE                    ;359
00000c  4308              ORRNE    r0,r0,r1              ;359
00000e  ea210000          BICEQ    r0,r1,r0
000012  6018              STR      r0,[r3,#0]            ;359
;;;365      }
;;;366    }
000014  4770              BX       lr
;;;367    
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      0x40007400

;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\stm32f4xx_dac.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_dac_c_4da4a0a9____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___15_stm32f4xx_dac_c_4da4a0a9____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_dac_c_4da4a0a9____REVSH|
#line 144
|__asm___15_stm32f4xx_dac_c_4da4a0a9____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
