; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\stm32f4xx_dcmi.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f4xx_dcmi.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\stm32f4xx_dcmi.crf arm_hal\lib\stm32f4xx_dcmi.c]
                          THUMB

                          AREA ||i.DCMI_CROPCmd||, CODE, READONLY, ALIGN=2

                  DCMI_CROPCmd PROC
;;;222      */
;;;223    void DCMI_CROPCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L1.20|
;;;224    {
;;;225      /* Check the parameters */
;;;226      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;227        
;;;228      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;229      {
;;;230        /* Enable the DCMI Crop feature */
;;;231        DCMI->CR |= (uint32_t)DCMI_CR_CROP;
;;;232      }
;;;233      else
;;;234      {
;;;235        /* Disable the DCMI Crop feature */
;;;236        DCMI->CR &= ~(uint32_t)DCMI_CR_CROP;
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;231
000008  f0400004          ORRNE    r0,r0,#4              ;231
00000c  f0200004          BICEQ    r0,r0,#4
000010  6008              STR      r0,[r1,#0]            ;231
;;;237      }
;;;238    }
000012  4770              BX       lr
;;;239    
                          ENDP

                  |L1.20|
                          DCD      0x50050000

                          AREA ||i.DCMI_CROPConfig||, CODE, READONLY, ALIGN=2

                  DCMI_CROPConfig PROC
;;;204      */
;;;205    void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct)
000000  6801              LDR      r1,[r0,#0]
;;;206    {  
;;;207      /* Sets the CROP window coordinates */
;;;208      DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
000002  ea4f4231          ROR      r2,r1,#16
000006  4903              LDR      r1,|L2.20|
000008  620a              STR      r2,[r1,#0x20]
;;;209                      ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalStartLine << 16));
;;;210    
;;;211      /* Sets the CROP window size */
;;;212      DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
00000a  6840              LDR      r0,[r0,#4]
00000c  ea4f4030          ROR      r0,r0,#16
000010  6248              STR      r0,[r1,#0x24]
;;;213                      ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalLineCount << 16));
;;;214    }
000012  4770              BX       lr
;;;215    
                          ENDP

                  |L2.20|
                          DCD      0x50050000

                          AREA ||i.DCMI_CaptureCmd||, CODE, READONLY, ALIGN=2

                  DCMI_CaptureCmd PROC
;;;321      */
;;;322    void DCMI_CaptureCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L3.20|
;;;323    {
;;;324      /* Check the parameters */
;;;325      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;326        
;;;327      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;328      {
;;;329        /* Enable the DCMI Capture */
;;;330        DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
;;;331      }
;;;332      else
;;;333      {
;;;334        /* Disable the DCMI Capture */
;;;335        DCMI->CR &= ~(uint32_t)DCMI_CR_CAPTURE;
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;330
000008  f0400001          ORRNE    r0,r0,#1              ;330
00000c  f0200001          BICEQ    r0,r0,#1
000010  6008              STR      r0,[r1,#0]            ;330
;;;336      }
;;;337    }
000012  4770              BX       lr
;;;338    
                          ENDP

                  |L3.20|
                          DCD      0x50050000

                          AREA ||i.DCMI_ClearFlag||, CODE, READONLY, ALIGN=2

                  DCMI_ClearFlag PROC
;;;460      */
;;;461    void DCMI_ClearFlag(uint16_t DCMI_FLAG)
000000  4901              LDR      r1,|L4.8|
;;;462    {
;;;463      /* Check the parameters */
;;;464      assert_param(IS_DCMI_CLEAR_FLAG(DCMI_FLAG));
;;;465      
;;;466      /* Clear the flag by writing in the ICR register 1 in the corresponding 
;;;467      Flag position*/
;;;468      
;;;469      DCMI->ICR = DCMI_FLAG;
000002  6148              STR      r0,[r1,#0x14]
;;;470    }
000004  4770              BX       lr
;;;471    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  DCMI_ClearITPendingBit PROC
;;;514      */
;;;515    void DCMI_ClearITPendingBit(uint16_t DCMI_IT)
000000  4901              LDR      r1,|L5.8|
;;;516    {
;;;517      /* Clear the interrupt pending Bit by writing in the ICR register 1 in the 
;;;518      corresponding pending Bit position*/
;;;519      
;;;520      DCMI->ICR = DCMI_IT;
000002  6148              STR      r0,[r1,#0x14]
;;;521    }
000004  4770              BX       lr
;;;522    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_Cmd||, CODE, READONLY, ALIGN=2

                  DCMI_Cmd PROC
;;;298      */
;;;299    void DCMI_Cmd(FunctionalState NewState)
000000  4904              LDR      r1,|L6.20|
;;;300    {
;;;301      /* Check the parameters */
;;;302      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;303      
;;;304      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;305      {
;;;306        /* Enable the DCMI by setting ENABLE bit */
;;;307        DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
;;;308      }
;;;309      else
;;;310      {
;;;311        /* Disable the DCMI by clearing ENABLE bit */
;;;312        DCMI->CR &= ~(uint32_t)DCMI_CR_ENABLE;
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;307
000008  f4404080          ORRNE    r0,r0,#0x4000         ;307
00000c  f4204080          BICEQ    r0,r0,#0x4000
000010  6008              STR      r0,[r1,#0]            ;307
;;;313      }
;;;314    }
000012  4770              BX       lr
;;;315    
                          ENDP

                  |L6.20|
                          DCD      0x50050000

                          AREA ||i.DCMI_DeInit||, CODE, READONLY, ALIGN=2

                  DCMI_DeInit PROC
;;;125      */
;;;126    void DCMI_DeInit(void)
000000  4805              LDR      r0,|L7.24|
;;;127    {
;;;128      DCMI->CR = 0x0;
000002  2100              MOVS     r1,#0
000004  6001              STR      r1,[r0,#0]
;;;129      DCMI->IER = 0x0;
000006  60c1              STR      r1,[r0,#0xc]
;;;130      DCMI->ICR = 0x1F;
000008  221f              MOVS     r2,#0x1f
00000a  6142              STR      r2,[r0,#0x14]
;;;131      DCMI->ESCR = 0x0;
00000c  6181              STR      r1,[r0,#0x18]
;;;132      DCMI->ESUR = 0x0;
00000e  61c1              STR      r1,[r0,#0x1c]
;;;133      DCMI->CWSTRTR = 0x0;
000010  6201              STR      r1,[r0,#0x20]
;;;134      DCMI->CWSIZER = 0x0;
000012  6241              STR      r1,[r0,#0x24]
;;;135    }
000014  4770              BX       lr
;;;136    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x50050000

                          AREA ||i.DCMI_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  DCMI_GetFlagStatus PROC
;;;413      */
;;;414    FlagStatus DCMI_GetFlagStatus(uint16_t DCMI_FLAG)
000000  2200              MOVS     r2,#0
;;;415    {
;;;416      FlagStatus bitstatus = RESET;
;;;417      uint32_t dcmireg, tempreg = 0;
;;;418    
;;;419      /* Check the parameters */
;;;420      assert_param(IS_DCMI_GET_FLAG(DCMI_FLAG));
;;;421      
;;;422      /* Get the DCMI register index */
;;;423      dcmireg = (((uint16_t)DCMI_FLAG) >> 12);
;;;424      
;;;425      if (dcmireg == 0x00) /* The FLAG is in RISR register */
;;;426      {
;;;427        tempreg= DCMI->RISR;
000002  4b07              LDR      r3,|L8.32|
000004  0b01              LSRS     r1,r0,#12             ;423
000006  bf08              IT       EQ
000008  6899              LDREQ    r1,[r3,#8]
00000a  d003              BEQ      |L8.20|
;;;428      }
;;;429      else if (dcmireg == 0x02) /* The FLAG is in SR register */
00000c  2902              CMP      r1,#2
;;;430      {
;;;431        tempreg = DCMI->SR;
00000e  bf0c              ITE      EQ
000010  6859              LDREQ    r1,[r3,#4]
;;;432      }
;;;433      else /* The FLAG is in MISR register */
;;;434      {
;;;435        tempreg = DCMI->MISR;
000012  6919              LDRNE    r1,[r3,#0x10]
                  |L8.20|
;;;436      }
;;;437      
;;;438      if ((tempreg & DCMI_FLAG) != (uint16_t)RESET )
000014  4201              TST      r1,r0
;;;439      {
;;;440        bitstatus = SET;
000016  bf18              IT       NE
000018  2201              MOVNE    r2,#1
;;;441      }
;;;442      else
;;;443      {
;;;444        bitstatus = RESET;
;;;445      }
;;;446      /* Return the DCMI_FLAG status */
;;;447      return  bitstatus;
00001a  4610              MOV      r0,r2
;;;448    }
00001c  4770              BX       lr
;;;449    
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      0x50050000

                          AREA ||i.DCMI_GetITStatus||, CODE, READONLY, ALIGN=2

                  DCMI_GetITStatus PROC
;;;482      */
;;;483    ITStatus DCMI_GetITStatus(uint16_t DCMI_IT)
000000  4a03              LDR      r2,|L9.16|
;;;484    {
000002  4601              MOV      r1,r0
;;;485      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;486      uint32_t itstatus = 0;
;;;487      
;;;488      /* Check the parameters */
;;;489      assert_param(IS_DCMI_GET_IT(DCMI_IT));
;;;490      
;;;491      itstatus = DCMI->MISR & DCMI_IT; /* Only masked interrupts are checked */
000006  6912              LDR      r2,[r2,#0x10]
000008  420a              TST      r2,r1
;;;492      
;;;493      if ((itstatus != (uint16_t)RESET))
;;;494      {
;;;495        bitstatus = SET;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;496      }
;;;497      else
;;;498      {
;;;499        bitstatus = RESET;
;;;500      }
;;;501      return bitstatus;
;;;502    }
00000e  4770              BX       lr
;;;503    
                          ENDP

                  |L9.16|
                          DCD      0x50050000

                          AREA ||i.DCMI_ITConfig||, CODE, READONLY, ALIGN=2

                  DCMI_ITConfig PROC
;;;376      */
;;;377    void DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;378    {
;;;379      /* Check the parameters */
;;;380      assert_param(IS_DCMI_CONFIG_IT(DCMI_IT));
;;;381      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;382      
;;;383      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;384      {
;;;385        /* Enable the Interrupt sources */
;;;386        DCMI->IER |= DCMI_IT;
;;;387      }
;;;388      else
;;;389      {
;;;390        /* Disable the Interrupt sources */
;;;391        DCMI->IER &= (uint16_t)(~DCMI_IT);
000004  68d1              LDR      r1,[r2,#0xc]
000006  bf11              ITEEE    NE                    ;386
000008  4308              ORRNE    r0,r0,r1              ;386
00000a  43c0              MVNEQ    r0,r0
00000c  b280              UXTHEQ   r0,r0
00000e  4008              ANDEQ    r0,r0,r1
000010  60d0              STR      r0,[r2,#0xc]          ;386
;;;392      }  
;;;393    }
000012  4770              BX       lr
;;;394    
                          ENDP

                  |L10.20|
                          DCD      0x50050000

                          AREA ||i.DCMI_Init||, CODE, READONLY, ALIGN=2

                  DCMI_Init PROC
;;;142      */
;;;143    void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct)
000000  4913              LDR      r1,|L11.80|
;;;144    {
000002  b410              PUSH     {r4}
;;;145      uint32_t temp = 0x0;
;;;146      
;;;147      /* Check the parameters */
;;;148      assert_param(IS_DCMI_CAPTURE_MODE(DCMI_InitStruct->DCMI_CaptureMode));
;;;149      assert_param(IS_DCMI_SYNCHRO(DCMI_InitStruct->DCMI_SynchroMode));
;;;150      assert_param(IS_DCMI_PCKPOLARITY(DCMI_InitStruct->DCMI_PCKPolarity));
;;;151      assert_param(IS_DCMI_VSPOLARITY(DCMI_InitStruct->DCMI_VSPolarity));
;;;152      assert_param(IS_DCMI_HSPOLARITY(DCMI_InitStruct->DCMI_HSPolarity));
;;;153      assert_param(IS_DCMI_CAPTURE_RATE(DCMI_InitStruct->DCMI_CaptureRate));
;;;154      assert_param(IS_DCMI_EXTENDED_DATA(DCMI_InitStruct->DCMI_ExtendedDataMode));
;;;155    
;;;156      /* The DCMI configuration registers should be programmed correctly before 
;;;157      enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
;;;158      DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
000004  680a              LDR      r2,[r1,#0]
000006  f0220201          BIC      r2,r2,#1
00000a  f4224280          BIC      r2,r2,#0x4000
00000e  600a              STR      r2,[r1,#0]
;;;159       
;;;160      /* Reset the old DCMI configuration */
;;;161      temp = DCMI->CR;
000010  680a              LDR      r2,[r1,#0]
;;;162      
;;;163      temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
;;;164                          DCMI_CR_HSPOL  | DCMI_CR_VSPOL | DCMI_CR_FCRC_0 | 
;;;165                          DCMI_CR_FCRC_1 | DCMI_CR_EDM_0 | DCMI_CR_EDM_1); 
;;;166                      
;;;167      /* Sets the new configuration of the DCMI peripheral */
;;;168      temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
000012  8803              LDRH     r3,[r0,#0]
000014  f8b0c002          LDRH     r12,[r0,#2]
000018  88c4              LDRH     r4,[r0,#6]
00001a  ea43030c          ORR      r3,r3,r12
00001e  f8b0c004          LDRH     r12,[r0,#4]
000022  f42272f9          BIC      r2,r2,#0x1f2          ;163
000026  ea4c0c04          ORR      r12,r12,r4
00002a  ea43030c          ORR      r3,r3,r12
00002e  f8b0c008          LDRH     r12,[r0,#8]
000032  f4226260          BIC      r2,r2,#0xe00          ;163
000036  ea43030c          ORR      r3,r3,r12
00003a  f8b0c00a          LDRH     r12,[r0,#0xa]
00003e  8980              LDRH     r0,[r0,#0xc]
000040  ea43030c          ORR      r3,r3,r12
000044  4318              ORRS     r0,r0,r3
000046  4310              ORRS     r0,r0,r2
;;;169                         DCMI_InitStruct->DCMI_SynchroMode |
;;;170                         DCMI_InitStruct->DCMI_PCKPolarity |
;;;171                         DCMI_InitStruct->DCMI_VSPolarity |
;;;172                         DCMI_InitStruct->DCMI_HSPolarity |
;;;173                         DCMI_InitStruct->DCMI_CaptureRate |
;;;174                         DCMI_InitStruct->DCMI_ExtendedDataMode);
;;;175    
;;;176      DCMI->CR = temp;                              
000048  6008              STR      r0,[r1,#0]
;;;177    }
00004a  bc10              POP      {r4}
00004c  4770              BX       lr
;;;178    
                          ENDP

00004e  0000              DCW      0x0000
                  |L11.80|
                          DCD      0x50050000

                          AREA ||i.DCMI_JPEGCmd||, CODE, READONLY, ALIGN=2

                  DCMI_JPEGCmd PROC
;;;260      */
;;;261    void DCMI_JPEGCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L12.20|
;;;262    {
;;;263      /* Check the parameters */
;;;264      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;265     
;;;266      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;267      {
;;;268        /* Enable the DCMI JPEG format */
;;;269        DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
;;;270      }
;;;271      else
;;;272      {
;;;273        /* Disable the DCMI JPEG format */
;;;274        DCMI->CR &= ~(uint32_t)DCMI_CR_JPEG;
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;269
000008  f0400008          ORRNE    r0,r0,#8              ;269
00000c  f0200008          BICEQ    r0,r0,#8
000010  6008              STR      r0,[r1,#0]            ;269
;;;275      }
;;;276    }
000012  4770              BX       lr
;;;277    /**
                          ENDP

                  |L12.20|
                          DCD      0x50050000

                          AREA ||i.DCMI_ReadData||, CODE, READONLY, ALIGN=2

                  DCMI_ReadData PROC
;;;343      */
;;;344    uint32_t DCMI_ReadData(void)
000000  4801              LDR      r0,|L13.8|
;;;345    {
;;;346      return DCMI->DR;
000002  6a80              LDR      r0,[r0,#0x28]
;;;347    }
000004  4770              BX       lr
;;;348    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x50050000

                          AREA ||i.DCMI_SetEmbeddedSynchroCodes||, CODE, READONLY, ALIGN=2

                  DCMI_SetEmbeddedSynchroCodes PROC
;;;245      */
;;;246    void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
000000  78c1              LDRB     r1,[r0,#3]
;;;247    {
;;;248      DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
000002  6800              LDR      r0,[r0,#0]
000004  f361601f          BFI      r0,r1,#24,#8
000008  4901              LDR      r1,|L14.16|
00000a  6188              STR      r0,[r1,#0x18]
;;;249                              ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
;;;250                              ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
;;;251                              ((uint32_t)DCMI_CodesInitStruct->DCMI_FrameEndCode << 24));
;;;252    }
00000c  4770              BX       lr
;;;253    
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x50050000

                          AREA ||i.DCMI_StructInit||, CODE, READONLY, ALIGN=1

                  DCMI_StructInit PROC
;;;184      */
;;;185    void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct)
000000  2100              MOVS     r1,#0
;;;186    {
;;;187      /* Set the default configuration */
;;;188      DCMI_InitStruct->DCMI_CaptureMode = DCMI_CaptureMode_Continuous;
000002  8001              STRH     r1,[r0,#0]
;;;189      DCMI_InitStruct->DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
000004  8041              STRH     r1,[r0,#2]
;;;190      DCMI_InitStruct->DCMI_PCKPolarity = DCMI_PCKPolarity_Falling;
000006  8081              STRH     r1,[r0,#4]
;;;191      DCMI_InitStruct->DCMI_VSPolarity = DCMI_VSPolarity_Low;
000008  80c1              STRH     r1,[r0,#6]
;;;192      DCMI_InitStruct->DCMI_HSPolarity = DCMI_HSPolarity_Low;
00000a  8101              STRH     r1,[r0,#8]
;;;193      DCMI_InitStruct->DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;
00000c  8141              STRH     r1,[r0,#0xa]
;;;194      DCMI_InitStruct->DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;
00000e  8181              STRH     r1,[r0,#0xc]
;;;195    }
000010  4770              BX       lr
;;;196    
                          ENDP


;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\stm32f4xx_dcmi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_dcmi_c_3610e7fb____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___16_stm32f4xx_dcmi_c_3610e7fb____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_dcmi_c_3610e7fb____REVSH|
#line 144
|__asm___16_stm32f4xx_dcmi_c_3610e7fb____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
