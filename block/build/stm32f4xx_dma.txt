; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\stm32f4xx_dma.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f4xx_dma.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\stm32f4xx_dma.crf arm_hal\lib\stm32f4xx_dma.c]
                          THUMB

                          AREA ||i.DMA_ClearFlag||, CODE, READONLY, ALIGN=2

                  DMA_ClearFlag PROC
;;;1070     */
;;;1071   void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
000000  4a06              LDR      r2,|L1.28|
;;;1072   {
;;;1073     DMA_TypeDef* DMAy;
;;;1074   
;;;1075     /* Check the parameters */
;;;1076     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1077     assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
;;;1078   
;;;1079     /* Determine the DMA to which belongs the stream */
;;;1080     if (DMAy_Streamx < DMA2_Stream0)
000002  4290              CMP      r0,r2
;;;1081     {
;;;1082       /* DMAy_Streamx belongs to DMA1 */
;;;1083       DMAy = DMA1; 
000004  bf34              ITE      CC
000006  4806              LDRCC    r0,|L1.32|
;;;1084     } 
;;;1085     else 
;;;1086     {
;;;1087       /* DMAy_Streamx belongs to DMA2 */
;;;1088       DMAy = DMA2; 
000008  4806              LDRCS    r0,|L1.36|
;;;1089     }
;;;1090   
;;;1091     /* Check if LIFCR or HIFCR register is targeted */
;;;1092     if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
00000a  f0115f00          TST      r1,#0x20000000
;;;1093     {
;;;1094       /* Set DMAy HIFCR register clear flag bits */
;;;1095       DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
00000e  4a06              LDR      r2,|L1.40|
000010  ea010102          AND      r1,r1,r2
000014  bf14              ITE      NE
000016  60c1              STRNE    r1,[r0,#0xc]
;;;1096     }
;;;1097     else 
;;;1098     {
;;;1099       /* Set DMAy LIFCR register clear flag bits */
;;;1100       DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
000018  6081              STREQ    r1,[r0,#8]
;;;1101     }    
;;;1102   }
00001a  4770              BX       lr
;;;1103   
                          ENDP

                  |L1.28|
                          DCD      0x40026410
                  |L1.32|
                          DCD      0x40026000
                  |L1.36|
                          DCD      0x40026400
                  |L1.40|
                          DCD      0x0f7d0f7d

                          AREA ||i.DMA_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  DMA_ClearITPendingBit PROC
;;;1251     */
;;;1252   void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
000000  4a06              LDR      r2,|L2.28|
;;;1253   {
;;;1254     DMA_TypeDef* DMAy;
;;;1255   
;;;1256     /* Check the parameters */
;;;1257     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1258     assert_param(IS_DMA_CLEAR_IT(DMA_IT));
;;;1259   
;;;1260     /* Determine the DMA to which belongs the stream */
;;;1261     if (DMAy_Streamx < DMA2_Stream0)
000002  4290              CMP      r0,r2
;;;1262     {
;;;1263       /* DMAy_Streamx belongs to DMA1 */
;;;1264       DMAy = DMA1; 
000004  bf34              ITE      CC
000006  4806              LDRCC    r0,|L2.32|
;;;1265     } 
;;;1266     else 
;;;1267     {
;;;1268       /* DMAy_Streamx belongs to DMA2 */
;;;1269       DMAy = DMA2; 
000008  4806              LDRCS    r0,|L2.36|
;;;1270     }
;;;1271   
;;;1272     /* Check if LIFCR or HIFCR register is targeted */
;;;1273     if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
00000a  f0115f00          TST      r1,#0x20000000
;;;1274     {
;;;1275       /* Set DMAy HIFCR register clear interrupt bits */
;;;1276       DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
00000e  4a06              LDR      r2,|L2.40|
000010  ea010102          AND      r1,r1,r2
000014  bf14              ITE      NE
000016  60c1              STRNE    r1,[r0,#0xc]
;;;1277     }
;;;1278     else 
;;;1279     {
;;;1280       /* Set DMAy LIFCR register clear interrupt bits */
;;;1281       DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
000018  6081              STREQ    r1,[r0,#8]
;;;1282     }   
;;;1283   }
00001a  4770              BX       lr
;;;1284   
                          ENDP

                  |L2.28|
                          DCD      0x40026410
                  |L2.32|
                          DCD      0x40026000
                  |L2.36|
                          DCD      0x40026400
                  |L2.40|
                          DCD      0x0f7d0f7d

                          AREA ||i.DMA_Cmd||, CODE, READONLY, ALIGN=1

                  DMA_Cmd PROC
;;;477      */
;;;478    void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;479    {
;;;480      /* Check the parameters */
;;;481      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;482      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;483    
;;;484      if (NewState != DISABLE)
;;;485      {
;;;486        /* Enable the selected DMAy Streamx by setting EN bit */
;;;487        DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
;;;488      }
;;;489      else
;;;490      {
;;;491        /* Disable the selected DMAy Streamx by clearing EN bit */
;;;492        DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
000002  6801              LDR      r1,[r0,#0]
000004  bf14              ITE      NE                    ;487
000006  f0410101          ORRNE    r1,r1,#1              ;487
00000a  f0210101          BICEQ    r1,r1,#1
00000e  6001              STR      r1,[r0,#0]            ;487
;;;493      }
;;;494    }
000010  4770              BX       lr
;;;495    
                          ENDP


                          AREA ||i.DMA_DeInit||, CODE, READONLY, ALIGN=2

                  DMA_DeInit PROC
;;;195      */
;;;196    void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
000000  e92d03f0          PUSH     {r4-r9}
;;;197    {
;;;198      /* Check the parameters */
;;;199      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;200    
;;;201      /* Disable the selected DMAy Streamx */
;;;202      DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
000004  6801              LDR      r1,[r0,#0]
000006  f0210101          BIC      r1,r1,#1
00000a  6001              STR      r1,[r0,#0]
;;;203    
;;;204      /* Reset DMAy Streamx control register */
;;;205      DMAy_Streamx->CR  = 0;
00000c  2100              MOVS     r1,#0
00000e  6001              STR      r1,[r0,#0]
;;;206      
;;;207      /* Reset DMAy Streamx Number of Data to Transfer register */
;;;208      DMAy_Streamx->NDTR = 0;
000010  6041              STR      r1,[r0,#4]
;;;209      
;;;210      /* Reset DMAy Streamx peripheral address register */
;;;211      DMAy_Streamx->PAR  = 0;
000012  6081              STR      r1,[r0,#8]
;;;212      
;;;213      /* Reset DMAy Streamx memory 0 address register */
;;;214      DMAy_Streamx->M0AR = 0;
000014  60c1              STR      r1,[r0,#0xc]
;;;215    
;;;216      /* Reset DMAy Streamx memory 1 address register */
;;;217      DMAy_Streamx->M1AR = 0;
000016  6101              STR      r1,[r0,#0x10]
;;;218    
;;;219      /* Reset DMAy Streamx FIFO control register */
;;;220      DMAy_Streamx->FCR = (uint32_t)0x00000021; 
000018  2121              MOVS     r1,#0x21
00001a  6141              STR      r1,[r0,#0x14]
;;;221    
;;;222      /* Reset interrupt pending bits for the selected stream */
;;;223      if (DMAy_Streamx == DMA1_Stream0)
00001c  4a44              LDR      r2,|L4.304|
;;;224      {
;;;225        /* Reset interrupt pending bits for DMA1 Stream0 */
;;;226        DMA1->LIFCR = DMA_Stream0_IT_MASK;
00001e  4945              LDR      r1,|L4.308|
000020  f04f083d          MOV      r8,#0x3d
000024  4290              CMP      r0,r2                 ;223
000026  bf02              ITTT     EQ
000028  f8c18008          STREQ    r8,[r1,#8]
;;;227      }
;;;228      else if (DMAy_Streamx == DMA1_Stream1)
;;;229      {
;;;230        /* Reset interrupt pending bits for DMA1 Stream1 */
;;;231        DMA1->LIFCR = DMA_Stream1_IT_MASK;
;;;232      }
;;;233      else if (DMAy_Streamx == DMA1_Stream2)
;;;234      {
;;;235        /* Reset interrupt pending bits for DMA1 Stream2 */
;;;236        DMA1->LIFCR = DMA_Stream2_IT_MASK;
;;;237      }
;;;238      else if (DMAy_Streamx == DMA1_Stream3)
;;;239      {
;;;240        /* Reset interrupt pending bits for DMA1 Stream3 */
;;;241        DMA1->LIFCR = DMA_Stream3_IT_MASK;
;;;242      }
;;;243      else if (DMAy_Streamx == DMA1_Stream4)
;;;244      {
;;;245        /* Reset interrupt pending bits for DMA1 Stream4 */
;;;246        DMA1->HIFCR = DMA_Stream4_IT_MASK;
;;;247      }
;;;248      else if (DMAy_Streamx == DMA1_Stream5)
;;;249      {
;;;250        /* Reset interrupt pending bits for DMA1 Stream5 */
;;;251        DMA1->HIFCR = DMA_Stream5_IT_MASK;
;;;252      }
;;;253      else if (DMAy_Streamx == DMA1_Stream6)
;;;254      {
;;;255        /* Reset interrupt pending bits for DMA1 Stream6 */
;;;256        DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
;;;257      }
;;;258      else if (DMAy_Streamx == DMA1_Stream7)
;;;259      {
;;;260        /* Reset interrupt pending bits for DMA1 Stream7 */
;;;261        DMA1->HIFCR = DMA_Stream7_IT_MASK;
;;;262      }
;;;263      else if (DMAy_Streamx == DMA2_Stream0)
;;;264      {
;;;265        /* Reset interrupt pending bits for DMA2 Stream0 */
;;;266        DMA2->LIFCR = DMA_Stream0_IT_MASK;
;;;267      }
;;;268      else if (DMAy_Streamx == DMA2_Stream1)
;;;269      {
;;;270        /* Reset interrupt pending bits for DMA2 Stream1 */
;;;271        DMA2->LIFCR = DMA_Stream1_IT_MASK;
;;;272      }
;;;273      else if (DMAy_Streamx == DMA2_Stream2)
;;;274      {
;;;275        /* Reset interrupt pending bits for DMA2 Stream2 */
;;;276        DMA2->LIFCR = DMA_Stream2_IT_MASK;
;;;277      }
;;;278      else if (DMAy_Streamx == DMA2_Stream3)
;;;279      {
;;;280        /* Reset interrupt pending bits for DMA2 Stream3 */
;;;281        DMA2->LIFCR = DMA_Stream3_IT_MASK;
;;;282      }
;;;283      else if (DMAy_Streamx == DMA2_Stream4)
;;;284      {
;;;285        /* Reset interrupt pending bits for DMA2 Stream4 */
;;;286        DMA2->HIFCR = DMA_Stream4_IT_MASK;
;;;287      }
;;;288      else if (DMAy_Streamx == DMA2_Stream5)
;;;289      {
;;;290        /* Reset interrupt pending bits for DMA2 Stream5 */
;;;291        DMA2->HIFCR = DMA_Stream5_IT_MASK;
;;;292      }
;;;293      else if (DMAy_Streamx == DMA2_Stream6)
;;;294      {
;;;295        /* Reset interrupt pending bits for DMA2 Stream6 */
;;;296        DMA2->HIFCR = DMA_Stream6_IT_MASK;
;;;297      }
;;;298      else 
;;;299      {
;;;300        if (DMAy_Streamx == DMA2_Stream7)
;;;301        {
;;;302          /* Reset interrupt pending bits for DMA2 Stream7 */
;;;303          DMA2->HIFCR = DMA_Stream7_IT_MASK;
;;;304        }
;;;305      }
;;;306    }
00002c  e8bd03f0          POPEQ    {r4-r9}
000030  4770              BXEQ     lr
000032  4a41              LDR      r2,|L4.312|
000034  f44f6474          MOV      r4,#0xf40             ;231
000038  4290              CMP      r0,r2                 ;228
00003a  bf02              ITTT     EQ                    ;231
00003c  608c              STREQ    r4,[r1,#8]            ;231
00003e  e8bd03f0          POPEQ    {r4-r9}
000042  4770              BXEQ     lr
000044  4a3d              LDR      r2,|L4.316|
000046  f44f1574          MOV      r5,#0x3d0000          ;236
00004a  4290              CMP      r0,r2                 ;233
00004c  bf02              ITTT     EQ                    ;236
00004e  608d              STREQ    r5,[r1,#8]            ;236
000050  e8bd03f0          POPEQ    {r4-r9}
000054  4770              BXEQ     lr
000056  4a3a              LDR      r2,|L4.320|
000058  f04f6674          MOV      r6,#0xf400000         ;241
00005c  4290              CMP      r0,r2                 ;238
00005e  bf02              ITTT     EQ                    ;241
000060  608e              STREQ    r6,[r1,#8]            ;241
000062  e8bd03f0          POPEQ    {r4-r9}
000066  4770              BXEQ     lr
000068  4b36              LDR      r3,|L4.324|
00006a  4a37              LDR      r2,|L4.328|
00006c  4298              CMP      r0,r3                 ;243
00006e  bf02              ITTT     EQ                    ;246
000070  60ca              STREQ    r2,[r1,#0xc]          ;246
000072  e8bd03f0          POPEQ    {r4-r9}
000076  4770              BXEQ     lr
000078  f8dfc0d0          LDR      r12,|L4.332|
00007c  4b34              LDR      r3,|L4.336|
00007e  4560              CMP      r0,r12                ;248
000080  bf02              ITTT     EQ                    ;251
000082  60cb              STREQ    r3,[r1,#0xc]          ;251
000084  e8bd03f0          POPEQ    {r4-r9}
000088  4770              BXEQ     lr
00008a  4f32              LDR      r7,|L4.340|
00008c  f8dfc0c8          LDR      r12,|L4.344|
000090  42b8              CMP      r0,r7                 ;253
000092  bf02              ITTT     EQ                    ;256
000094  f8c1c00c          STREQ    r12,[r1,#0xc]         ;256
000098  e8bd03f0          POPEQ    {r4-r9}
00009c  4770              BXEQ     lr
00009e  f8df90bc          LDR      r9,|L4.348|
0000a2  f04f573d          MOV      r7,#0x2f400000        ;261
0000a6  4548              CMP      r0,r9                 ;258
0000a8  bf02              ITTT     EQ                    ;261
0000aa  60cf              STREQ    r7,[r1,#0xc]          ;261
0000ac  e8bd03f0          POPEQ    {r4-r9}
0000b0  4770              BXEQ     lr
0000b2  f8df90ac          LDR      r9,|L4.352|
0000b6  492b              LDR      r1,|L4.356|
0000b8  4548              CMP      r0,r9                 ;263
0000ba  bf02              ITTT     EQ                    ;266
0000bc  f8c18000          STREQ    r8,[r1,#0]            ;266
0000c0  e8bd03f0          POPEQ    {r4-r9}
0000c4  4770              BXEQ     lr
0000c6  f8df80a0          LDR      r8,|L4.360|
0000ca  4540              CMP      r0,r8                 ;268
0000cc  bf02              ITTT     EQ                    ;271
0000ce  600c              STREQ    r4,[r1,#0]            ;271
0000d0  e8bd03f0          POPEQ    {r4-r9}
0000d4  4770              BXEQ     lr
0000d6  4c25              LDR      r4,|L4.364|
0000d8  42a0              CMP      r0,r4                 ;273
0000da  bf02              ITTT     EQ                    ;276
0000dc  600d              STREQ    r5,[r1,#0]            ;276
0000de  e8bd03f0          POPEQ    {r4-r9}
0000e2  4770              BXEQ     lr
0000e4  4c22              LDR      r4,|L4.368|
0000e6  42a0              CMP      r0,r4                 ;278
0000e8  bf02              ITTT     EQ                    ;281
0000ea  600e              STREQ    r6,[r1,#0]            ;281
0000ec  e8bd03f0          POPEQ    {r4-r9}
0000f0  4770              BXEQ     lr
0000f2  4c20              LDR      r4,|L4.372|
0000f4  4920              LDR      r1,|L4.376|
0000f6  42a0              CMP      r0,r4                 ;283
0000f8  bf02              ITTT     EQ                    ;286
0000fa  600a              STREQ    r2,[r1,#0]            ;286
0000fc  e8bd03f0          POPEQ    {r4-r9}
000100  4770              BXEQ     lr
000102  4a1e              LDR      r2,|L4.380|
000104  4290              CMP      r0,r2                 ;288
000106  bf02              ITTT     EQ                    ;291
000108  600b              STREQ    r3,[r1,#0]            ;291
00010a  e8bd03f0          POPEQ    {r4-r9}
00010e  4770              BXEQ     lr
000110  4a1b              LDR      r2,|L4.384|
000112  4290              CMP      r0,r2                 ;293
000114  bf02              ITTT     EQ                    ;296
000116  f8c1c000          STREQ    r12,[r1,#0]           ;296
00011a  e8bd03f0          POPEQ    {r4-r9}
00011e  4770              BXEQ     lr
000120  4a18              LDR      r2,|L4.388|
000122  4290              CMP      r0,r2                 ;300
000124  bf08              IT       EQ                    ;303
000126  600f              STREQ    r7,[r1,#0]            ;303
000128  e8bd03f0          POP      {r4-r9}
00012c  4770              BX       lr
;;;307    
                          ENDP

00012e  0000              DCW      0x0000
                  |L4.304|
                          DCD      0x40026010
                  |L4.308|
                          DCD      0x40026000
                  |L4.312|
                          DCD      0x40026028
                  |L4.316|
                          DCD      0x40026040
                  |L4.320|
                          DCD      0x40026058
                  |L4.324|
                          DCD      0x40026070
                  |L4.328|
                          DCD      0x2000003d
                  |L4.332|
                          DCD      0x40026088
                  |L4.336|
                          DCD      0x20000f40
                  |L4.340|
                          DCD      0x400260a0
                  |L4.344|
                          DCD      0x203d0000
                  |L4.348|
                          DCD      0x400260b8
                  |L4.352|
                          DCD      0x40026410
                  |L4.356|
                          DCD      0x40026408
                  |L4.360|
                          DCD      0x40026428
                  |L4.364|
                          DCD      0x40026440
                  |L4.368|
                          DCD      0x40026458
                  |L4.372|
                          DCD      0x40026470
                  |L4.376|
                          DCD      0x4002640c
                  |L4.380|
                          DCD      0x40026488
                  |L4.384|
                          DCD      0x400264a0
                  |L4.388|
                          DCD      0x400264b8

                          AREA ||i.DMA_DoubleBufferModeCmd||, CODE, READONLY, ALIGN=1

                  DMA_DoubleBufferModeCmd PROC
;;;760      */
;;;761    void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;762    {  
;;;763      /* Check the parameters */
;;;764      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;765      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;766    
;;;767      /* Configure the Double Buffer mode */
;;;768      if (NewState != DISABLE)
;;;769      {
;;;770        /* Enable the Double buffer mode */
;;;771        DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
;;;772      }
;;;773      else
;;;774      {
;;;775        /* Disable the Double buffer mode */
;;;776        DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
000002  6801              LDR      r1,[r0,#0]
000004  bf14              ITE      NE                    ;771
000006  f4412180          ORRNE    r1,r1,#0x40000        ;771
00000a  f4212180          BICEQ    r1,r1,#0x40000
00000e  6001              STR      r1,[r0,#0]            ;771
;;;777      }
;;;778    }
000010  4770              BX       lr
;;;779    
                          ENDP


                          AREA ||i.DMA_DoubleBufferModeConfig||, CODE, READONLY, ALIGN=1

                  DMA_DoubleBufferModeConfig PROC
;;;729      */
;;;730    void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
000000  2a00              CMP      r2,#0
;;;731                                    uint32_t DMA_CurrentMemory)
;;;732    {  
;;;733      /* Check the parameters */
;;;734      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;735      assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));
;;;736    
;;;737      if (DMA_CurrentMemory != DMA_Memory_0)
;;;738      {
;;;739        /* Set Memory 1 as current memory address */
;;;740        DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
;;;741      }
;;;742      else
;;;743      {
;;;744        /* Set Memory 0 as current memory address */
;;;745        DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
000002  6802              LDR      r2,[r0,#0]
000004  bf14              ITE      NE                    ;740
000006  f4422200          ORRNE    r2,r2,#0x80000        ;740
00000a  f4222200          BICEQ    r2,r2,#0x80000
00000e  6002              STR      r2,[r0,#0]
;;;746      }
;;;747    
;;;748      /* Write to DMAy Streamx M1AR */
;;;749      DMAy_Streamx->M1AR = Memory1BaseAddr;
000010  6101              STR      r1,[r0,#0x10]
;;;750    }
000012  4770              BX       lr
;;;751    
                          ENDP


                          AREA ||i.DMA_FlowControllerConfig||, CODE, READONLY, ALIGN=1

                  DMA_FlowControllerConfig PROC
;;;549      */
;;;550    void DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl)
000000  2900              CMP      r1,#0
;;;551    {
;;;552      /* Check the parameters */
;;;553      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;554      assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));
;;;555    
;;;556      /* Check the needed flow controller  */
;;;557      if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
;;;558      {
;;;559        /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
;;;560        DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
;;;561      }
;;;562      else
;;;563      {
;;;564        /* Clear the PFCTRL bit: Memory is the flow controller */
;;;565        DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
000002  6801              LDR      r1,[r0,#0]
000004  bf14              ITE      NE                    ;560
000006  f0410120          ORRNE    r1,r1,#0x20           ;560
00000a  f0210120          BICEQ    r1,r1,#0x20
00000e  6001              STR      r1,[r0,#0]            ;560
;;;566      }
;;;567    }
000010  4770              BX       lr
;;;568    /**
                          ENDP


                          AREA ||i.DMA_GetCmdStatus||, CODE, READONLY, ALIGN=1

                  DMA_GetCmdStatus PROC
;;;942      */
;;;943    FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx)
000000  4601              MOV      r1,r0
;;;944    {
;;;945      FunctionalState state = DISABLE;
000002  2000              MOVS     r0,#0
;;;946    
;;;947      /* Check the parameters */
;;;948      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;949    
;;;950      if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
000004  6809              LDR      r1,[r1,#0]
000006  f0110f01          TST      r1,#1
;;;951      {
;;;952        /* The selected DMAy Streamx EN bit is set (DMA is still transferring) */
;;;953        state = ENABLE;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;954      }
;;;955      else
;;;956      {
;;;957        /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
;;;958            all transfers are complete) */
;;;959        state = DISABLE;
;;;960      }
;;;961      return state;
;;;962    }
00000e  4770              BX       lr
;;;963    
                          ENDP


                          AREA ||i.DMA_GetCurrDataCounter||, CODE, READONLY, ALIGN=1

                  DMA_GetCurrDataCounter PROC
;;;646      */
;;;647    uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx)
000000  6840              LDR      r0,[r0,#4]
;;;648    {
;;;649      /* Check the parameters */
;;;650      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;651    
;;;652      /* Return the number of remaining data units for DMAy Streamx */
;;;653      return ((uint16_t)(DMAy_Streamx->NDTR));
000002  b280              UXTH     r0,r0
;;;654    }
000004  4770              BX       lr
;;;655    /**
                          ENDP


                          AREA ||i.DMA_GetCurrentMemoryTarget||, CODE, READONLY, ALIGN=1

                  DMA_GetCurrentMemoryTarget PROC
;;;827      */
;;;828    uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx)
000000  4601              MOV      r1,r0
;;;829    {
;;;830      uint32_t tmp = 0;
000002  2000              MOVS     r0,#0
;;;831      
;;;832      /* Check the parameters */
;;;833      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;834    
;;;835      /* Get the current memory target */
;;;836      if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
000004  6809              LDR      r1,[r1,#0]
000006  f4112f00          TST      r1,#0x80000
;;;837      {
;;;838        /* Current memory buffer used is Memory 1 */
;;;839        tmp = 1;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;840      }  
;;;841      else
;;;842      {
;;;843        /* Current memory buffer used is Memory 0 */
;;;844        tmp = 0;    
;;;845      }
;;;846      return tmp;
;;;847    }
00000e  4770              BX       lr
;;;848    /**
                          ENDP


                          AREA ||i.DMA_GetFIFOStatus||, CODE, READONLY, ALIGN=1

                  DMA_GetFIFOStatus PROC
;;;976      */
;;;977    uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx)
000000  6940              LDR      r0,[r0,#0x14]
;;;978    {
;;;979      uint32_t tmpreg = 0;
;;;980     
;;;981      /* Check the parameters */
;;;982      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;983      
;;;984      /* Get the FIFO level bits */
;;;985      tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
000002  f0000038          AND      r0,r0,#0x38
;;;986      
;;;987      return tmpreg;
;;;988    }
000006  4770              BX       lr
;;;989    
                          ENDP


                          AREA ||i.DMA_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  DMA_GetFlagStatus PROC
;;;1003     */
;;;1004   FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
000000  4602              MOV      r2,r0
;;;1005   {
;;;1006     FlagStatus bitstatus = RESET;
;;;1007     DMA_TypeDef* DMAy;
;;;1008     uint32_t tmpreg = 0;
;;;1009   
;;;1010     /* Check the parameters */
;;;1011     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1012     assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
;;;1013   
;;;1014     /* Determine the DMA to which belongs the stream */
;;;1015     if (DMAy_Streamx < DMA2_Stream0)
000002  4b08              LDR      r3,|L12.36|
000004  2000              MOVS     r0,#0                 ;1006
000006  429a              CMP      r2,r3
;;;1016     {
;;;1017       /* DMAy_Streamx belongs to DMA1 */
;;;1018       DMAy = DMA1; 
000008  bf34              ITE      CC
00000a  4a07              LDRCC    r2,|L12.40|
;;;1019     } 
;;;1020     else 
;;;1021     {
;;;1022       /* DMAy_Streamx belongs to DMA2 */
;;;1023       DMAy = DMA2; 
00000c  4a07              LDRCS    r2,|L12.44|
;;;1024     }
;;;1025   
;;;1026     /* Check if the flag is in HISR or LISR */
;;;1027     if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
00000e  f0115f00          TST      r1,#0x20000000
;;;1028     {
;;;1029       /* Get DMAy HISR register value */
;;;1030       tmpreg = DMAy->HISR;
000012  bf14              ITE      NE
000014  6852              LDRNE    r2,[r2,#4]
;;;1031     }
;;;1032     else
;;;1033     {
;;;1034       /* Get DMAy LISR register value */
;;;1035       tmpreg = DMAy->LISR;
000016  6812              LDREQ    r2,[r2,#0]
;;;1036     }   
;;;1037    
;;;1038     /* Mask the reserved bits */
;;;1039     tmpreg &= (uint32_t)RESERVED_MASK;
000018  4b05              LDR      r3,|L12.48|
00001a  401a              ANDS     r2,r2,r3
;;;1040   
;;;1041     /* Check the status of the specified DMA flag */
;;;1042     if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
00001c  420a              TST      r2,r1
;;;1043     {
;;;1044       /* DMA_FLAG is set */
;;;1045       bitstatus = SET;
00001e  bf18              IT       NE
000020  2001              MOVNE    r0,#1
;;;1046     }
;;;1047     else
;;;1048     {
;;;1049       /* DMA_FLAG is reset */
;;;1050       bitstatus = RESET;
;;;1051     }
;;;1052   
;;;1053     /* Return the DMA_FLAG status */
;;;1054     return  bitstatus;
;;;1055   }
000022  4770              BX       lr
;;;1056   
                          ENDP

                  |L12.36|
                          DCD      0x40026410
                  |L12.40|
                          DCD      0x40026000
                  |L12.44|
                          DCD      0x40026400
                  |L12.48|
                          DCD      0x0f7d0f7d

                          AREA ||i.DMA_GetITStatus||, CODE, READONLY, ALIGN=2

                  DMA_GetITStatus PROC
;;;1169     */
;;;1170   ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
000000  4a12              LDR      r2,|L13.76|
;;;1171   {
;;;1172     ITStatus bitstatus = RESET;
000002  2300              MOVS     r3,#0
;;;1173     DMA_TypeDef* DMAy;
;;;1174     uint32_t tmpreg = 0, enablestatus = 0;
;;;1175   
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1178     assert_param(IS_DMA_GET_IT(DMA_IT));
;;;1179    
;;;1180     /* Determine the DMA to which belongs the stream */
;;;1181     if (DMAy_Streamx < DMA2_Stream0)
000004  4290              CMP      r0,r2
;;;1182     {
;;;1183       /* DMAy_Streamx belongs to DMA1 */
;;;1184       DMAy = DMA1; 
000006  bf34              ITE      CC
000008  4a11              LDRCC    r2,|L13.80|
;;;1185     } 
;;;1186     else 
;;;1187     {
;;;1188       /* DMAy_Streamx belongs to DMA2 */
;;;1189       DMAy = DMA2; 
00000a  4a12              LDRCS    r2,|L13.84|
;;;1190     }
;;;1191   
;;;1192     /* Check if the interrupt enable bit is in the CR or FCR register */
;;;1193     if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
00000c  f8dfc048          LDR      r12,|L13.88|
000010  ea110f0c          TST      r1,r12
;;;1194     {
;;;1195       /* Get the interrupt enable position mask in CR register */
;;;1196       tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
;;;1197       
;;;1198       /* Check the enable bit in CR register */
;;;1199       enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
;;;1200     }
;;;1201     else 
;;;1202     {
;;;1203       /* Check the enable bit in FCR register */
;;;1204       enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
000014  bf04              ITT      EQ
000016  6940              LDREQ    r0,[r0,#0x14]
000018  f0000080          ANDEQ    r0,r0,#0x80
00001c  d006              BEQ      |L13.44|
00001e  f04f0c1e          MOV      r12,#0x1e             ;1196
000022  6800              LDR      r0,[r0,#0]            ;1199
000024  ea0c2cd1          AND      r12,r12,r1,LSR #11    ;1196
000028  ea00000c          AND      r0,r0,r12             ;1199
                  |L13.44|
;;;1205     }
;;;1206    
;;;1207     /* Check if the interrupt pending flag is in LISR or HISR */
;;;1208     if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
00002c  f0115f00          TST      r1,#0x20000000
;;;1209     {
;;;1210       /* Get DMAy HISR register value */
;;;1211       tmpreg = DMAy->HISR ;
000030  bf14              ITE      NE
000032  6852              LDRNE    r2,[r2,#4]
;;;1212     }
;;;1213     else
;;;1214     {
;;;1215       /* Get DMAy LISR register value */
;;;1216       tmpreg = DMAy->LISR ;
000034  6812              LDREQ    r2,[r2,#0]
;;;1217     } 
;;;1218   
;;;1219     /* mask all reserved bits */
;;;1220     tmpreg &= (uint32_t)RESERVED_MASK;
000036  f8dfc024          LDR      r12,|L13.92|
00003a  ea02020c          AND      r2,r2,r12
;;;1221   
;;;1222     /* Check the status of the specified DMA interrupt */
;;;1223     if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
00003e  420a              TST      r2,r1
000040  bf1c              ITT      NE
000042  2800              CMPNE    r0,#0
;;;1224     {
;;;1225       /* DMA_IT is set */
;;;1226       bitstatus = SET;
000044  2301              MOVNE    r3,#1
;;;1227     }
;;;1228     else
;;;1229     {
;;;1230       /* DMA_IT is reset */
;;;1231       bitstatus = RESET;
;;;1232     }
;;;1233   
;;;1234     /* Return the DMA_IT status */
;;;1235     return  bitstatus;
000046  4618              MOV      r0,r3
;;;1236   }
000048  4770              BX       lr
;;;1237   
                          ENDP

00004a  0000              DCW      0x0000
                  |L13.76|
                          DCD      0x40026410
                  |L13.80|
                          DCD      0x40026000
                  |L13.84|
                          DCD      0x40026400
                  |L13.88|
                          DCD      0x0f3c0f3c
                  |L13.92|
                          DCD      0x0f7d0f7d

                          AREA ||i.DMA_ITConfig||, CODE, READONLY, ALIGN=1

                  DMA_ITConfig PROC
;;;1117     */
;;;1118   void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
000000  f0110f80          TST      r1,#0x80
;;;1119   {
000004  d007              BEQ      |L14.22|
;;;1120     /* Check the parameters */
;;;1121     assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;1122     assert_param(IS_DMA_CONFIG_IT(DMA_IT));
;;;1123     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1124   
;;;1125     /* Check if the DMA_IT parameter contains a FIFO interrupt */
;;;1126     if ((DMA_IT & DMA_IT_FE) != 0)
;;;1127     {
;;;1128       if (NewState != DISABLE)
;;;1129       {
;;;1130         /* Enable the selected DMA FIFO interrupts */
;;;1131         DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
;;;1132       }    
;;;1133       else 
;;;1134       {
;;;1135         /* Disable the selected DMA FIFO interrupts */
;;;1136         DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
000006  6943              LDR      r3,[r0,#0x14]
000008  2a00              CMP      r2,#0                 ;1128
00000a  bf0c              ITE      EQ
00000c  f0230380          BICEQ    r3,r3,#0x80
000010  f0430380          ORRNE    r3,r3,#0x80           ;1131
000014  6143              STR      r3,[r0,#0x14]         ;1131
                  |L14.22|
;;;1137       }
;;;1138     }
;;;1139   
;;;1140     /* Check if the DMA_IT parameter contains a Transfer interrupt */
;;;1141     if (DMA_IT != DMA_IT_FE)
000016  2980              CMP      r1,#0x80
;;;1142     {
;;;1143       if (NewState != DISABLE)
;;;1144       {
;;;1145         /* Enable the selected DMA transfer interrupts */
;;;1146         DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
;;;1147       }
;;;1148       else
;;;1149       {
;;;1150         /* Disable the selected DMA transfer interrupts */
;;;1151         DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
;;;1152       }    
;;;1153     }
;;;1154   }
000018  bf08              IT       EQ
00001a  4770              BXEQ     lr
00001c  f001011e          AND      r1,r1,#0x1e           ;1146
000020  2a00              CMP      r2,#0                 ;1143
000022  6802              LDR      r2,[r0,#0]            ;1151
000024  bf0c              ITE      EQ                    ;1151
000026  ea220101          BICEQ    r1,r2,r1              ;1151
00002a  4311              ORRNE    r1,r1,r2              ;1146
00002c  6001              STR      r1,[r0,#0]            ;1151
00002e  4770              BX       lr
;;;1155   
                          ENDP


                          AREA ||i.DMA_Init||, CODE, READONLY, ALIGN=2

                  DMA_Init PROC
;;;318      */
;;;319    void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
000000  b410              PUSH     {r4}
;;;320    {
;;;321      uint32_t tmpreg = 0;
;;;322    
;;;323      /* Check the parameters */
;;;324      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;325      assert_param(IS_DMA_CHANNEL(DMA_InitStruct->DMA_Channel));
;;;326      assert_param(IS_DMA_DIRECTION(DMA_InitStruct->DMA_DIR));
;;;327      assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
;;;328      assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
;;;329      assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));
;;;330      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
;;;331      assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
;;;332      assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
;;;333      assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
;;;334      assert_param(IS_DMA_FIFO_MODE_STATE(DMA_InitStruct->DMA_FIFOMode));
;;;335      assert_param(IS_DMA_FIFO_THRESHOLD(DMA_InitStruct->DMA_FIFOThreshold));
;;;336      assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
;;;337      assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));
;;;338    
;;;339      /*------------------------- DMAy Streamx CR Configuration ------------------*/
;;;340      /* Get the DMAy_Streamx CR value */
;;;341      tmpreg = DMAy_Streamx->CR;
000002  6802              LDR      r2,[r0,#0]
;;;342    
;;;343      /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
;;;344      tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
000004  4b1b              LDR      r3,|L15.116|
;;;345                             DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE | \
;;;346                             DMA_SxCR_MINC | DMA_SxCR_PINC | DMA_SxCR_CIRC | \
;;;347                             DMA_SxCR_DIR));
;;;348    
;;;349      /* Configure DMAy Streamx: */
;;;350      /* Set CHSEL bits according to DMA_CHSEL value */
;;;351      /* Set DIR bits according to DMA_DIR value */
;;;352      /* Set PINC bit according to DMA_PeripheralInc value */
;;;353      /* Set MINC bit according to DMA_MemoryInc value */
;;;354      /* Set PSIZE bits according to DMA_PeripheralDataSize value */
;;;355      /* Set MSIZE bits according to DMA_MemoryDataSize value */
;;;356      /* Set CIRC bit according to DMA_Mode value */
;;;357      /* Set PL bits according to DMA_Priority value */
;;;358      /* Set MBURST bits according to DMA_MemoryBurst value */
;;;359      /* Set PBURST bits according to DMA_PeripheralBurst value */
;;;360      tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
000006  f8d1c00c          LDR      r12,[r1,#0xc]
00000a  401a              ANDS     r2,r2,r3              ;344
00000c  680b              LDR      r3,[r1,#0]
00000e  ea43030c          ORR      r3,r3,r12
000012  e9d1c405          LDRD     r12,r4,[r1,#0x14]
000016  ea4c0c04          ORR      r12,r12,r4
00001a  ea43030c          ORR      r3,r3,r12
00001e  f8d1c01c          LDR      r12,[r1,#0x1c]
000022  ea43030c          ORR      r3,r3,r12
000026  f8d1c020          LDR      r12,[r1,#0x20]
00002a  ea43030c          ORR      r3,r3,r12
00002e  f8d1c024          LDR      r12,[r1,#0x24]
000032  ea43030c          ORR      r3,r3,r12
000036  f8d1c028          LDR      r12,[r1,#0x28]
00003a  ea43030c          ORR      r3,r3,r12
00003e  f8d1c034          LDR      r12,[r1,#0x34]
000042  ea43030c          ORR      r3,r3,r12
000046  f8d1c038          LDR      r12,[r1,#0x38]
00004a  ea43030c          ORR      r3,r3,r12
00004e  431a              ORRS     r2,r2,r3
;;;361                DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
;;;362                DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
;;;363                DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
;;;364                DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
;;;365    
;;;366      /* Write to DMAy Streamx CR register */
;;;367      DMAy_Streamx->CR = tmpreg;
000050  6002              STR      r2,[r0,#0]
;;;368    
;;;369      /*------------------------- DMAy Streamx FCR Configuration -----------------*/
;;;370      /* Get the DMAy_Streamx FCR value */
;;;371      tmpreg = DMAy_Streamx->FCR;
000052  6942              LDR      r2,[r0,#0x14]
;;;372    
;;;373      /* Clear DMDIS and FTH bits */
;;;374      tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
000054  e9d13c0b          LDRD     r3,r12,[r1,#0x2c]
000058  f0220207          BIC      r2,r2,#7
;;;375    
;;;376      /* Configure DMAy Streamx FIFO: 
;;;377        Set DMDIS bits according to DMA_FIFOMode value 
;;;378        Set FTH bits according to DMA_FIFOThreshold value */
;;;379      tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
00005c  ea43030c          ORR      r3,r3,r12
000060  431a              ORRS     r2,r2,r3
;;;380    
;;;381      /* Write to DMAy Streamx CR */
;;;382      DMAy_Streamx->FCR = tmpreg;
000062  6142              STR      r2,[r0,#0x14]
;;;383    
;;;384      /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
;;;385      /* Write to DMAy Streamx NDTR register */
;;;386      DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
000064  690a              LDR      r2,[r1,#0x10]
000066  6042              STR      r2,[r0,#4]
;;;387    
;;;388      /*------------------------- DMAy Streamx PAR Configuration -----------------*/
;;;389      /* Write to DMAy Streamx PAR */
;;;390      DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
000068  684a              LDR      r2,[r1,#4]
00006a  6082              STR      r2,[r0,#8]
;;;391    
;;;392      /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
;;;393      /* Write to DMAy Streamx M0AR */
;;;394      DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
00006c  6889              LDR      r1,[r1,#8]
00006e  60c1              STR      r1,[r0,#0xc]
;;;395    }
000070  bc10              POP      {r4}
000072  4770              BX       lr
;;;396    
                          ENDP

                  |L15.116|
                          DCD      0xf01c803f

                          AREA ||i.DMA_MemoryTargetConfig||, CODE, READONLY, ALIGN=1

                  DMA_MemoryTargetConfig PROC
;;;801      */
;;;802    void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
000000  2a00              CMP      r2,#0
;;;803                               uint32_t DMA_MemoryTarget)
;;;804    {
;;;805      /* Check the parameters */
;;;806      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;807      assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
;;;808        
;;;809      /* Check the Memory target to be configured */
;;;810      if (DMA_MemoryTarget != DMA_Memory_0)
;;;811      {
;;;812        /* Write to DMAy Streamx M1AR */
;;;813        DMAy_Streamx->M1AR = MemoryBaseAddr;    
000002  bf14              ITE      NE
000004  6101              STRNE    r1,[r0,#0x10]
;;;814      }  
;;;815      else
;;;816      {
;;;817        /* Write to DMAy Streamx M0AR */
;;;818        DMAy_Streamx->M0AR = MemoryBaseAddr;  
000006  60c1              STREQ    r1,[r0,#0xc]
;;;819      }
;;;820    }
000008  4770              BX       lr
;;;821    
                          ENDP


                          AREA ||i.DMA_PeriphIncOffsetSizeConfig||, CODE, READONLY, ALIGN=1

                  DMA_PeriphIncOffsetSizeConfig PROC
;;;513      */
;;;514    void DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos)
000000  2900              CMP      r1,#0
;;;515    {
;;;516      /* Check the parameters */
;;;517      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;518      assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));
;;;519    
;;;520      /* Check the needed Peripheral increment offset */
;;;521      if(DMA_Pincos != DMA_PINCOS_Psize)
;;;522      {
;;;523        /* Configure DMA_SxCR_PINCOS bit with the input parameter */
;;;524        DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
;;;525      }
;;;526      else
;;;527      {
;;;528        /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
;;;529        DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
000002  6801              LDR      r1,[r0,#0]
000004  bf14              ITE      NE                    ;524
000006  f4414100          ORRNE    r1,r1,#0x8000         ;524
00000a  f4214100          BICEQ    r1,r1,#0x8000
00000e  6001              STR      r1,[r0,#0]            ;524
;;;530      }
;;;531    }
000010  4770              BX       lr
;;;532    
                          ENDP


                          AREA ||i.DMA_SetCurrDataCounter||, CODE, READONLY, ALIGN=1

                  DMA_SetCurrDataCounter PROC
;;;631      */
;;;632    void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter)
000000  6041              STR      r1,[r0,#4]
;;;633    {
;;;634      /* Check the parameters */
;;;635      assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
;;;636    
;;;637      /* Write the number of data units to be transferred */
;;;638      DMAy_Streamx->NDTR = (uint16_t)Counter;
;;;639    }
000002  4770              BX       lr
;;;640    
                          ENDP


                          AREA ||i.DMA_StructInit||, CODE, READONLY, ALIGN=1

                  DMA_StructInit PROC
;;;402      */
;;;403    void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
000000  2100              MOVS     r1,#0
;;;404    {
;;;405      /*-------------- Reset DMA init structure parameters values ----------------*/
;;;406      /* Initialize the DMA_Channel member */
;;;407      DMA_InitStruct->DMA_Channel = 0;
;;;408    
;;;409      /* Initialize the DMA_PeripheralBaseAddr member */
;;;410      DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
000002  6001              STR      r1,[r0,#0]
;;;411    
;;;412      /* Initialize the DMA_Memory0BaseAddr member */
;;;413      DMA_InitStruct->DMA_Memory0BaseAddr = 0;
000004  6041              STR      r1,[r0,#4]
;;;414    
;;;415      /* Initialize the DMA_DIR member */
;;;416      DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
000006  6081              STR      r1,[r0,#8]
;;;417    
;;;418      /* Initialize the DMA_BufferSize member */
;;;419      DMA_InitStruct->DMA_BufferSize = 0;
000008  60c1              STR      r1,[r0,#0xc]
;;;420    
;;;421      /* Initialize the DMA_PeripheralInc member */
;;;422      DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
00000a  6101              STR      r1,[r0,#0x10]
;;;423    
;;;424      /* Initialize the DMA_MemoryInc member */
;;;425      DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
00000c  6141              STR      r1,[r0,#0x14]
;;;426    
;;;427      /* Initialize the DMA_PeripheralDataSize member */
;;;428      DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
00000e  6181              STR      r1,[r0,#0x18]
;;;429    
;;;430      /* Initialize the DMA_MemoryDataSize member */
;;;431      DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
000010  61c1              STR      r1,[r0,#0x1c]
;;;432    
;;;433      /* Initialize the DMA_Mode member */
;;;434      DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
000012  6201              STR      r1,[r0,#0x20]
;;;435    
;;;436      /* Initialize the DMA_Priority member */
;;;437      DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
000014  6241              STR      r1,[r0,#0x24]
;;;438    
;;;439      /* Initialize the DMA_FIFOMode member */
;;;440      DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
000016  6281              STR      r1,[r0,#0x28]
;;;441    
;;;442      /* Initialize the DMA_FIFOThreshold member */
;;;443      DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
000018  62c1              STR      r1,[r0,#0x2c]
;;;444    
;;;445      /* Initialize the DMA_MemoryBurst member */
;;;446      DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
00001a  6301              STR      r1,[r0,#0x30]
;;;447    
;;;448      /* Initialize the DMA_PeripheralBurst member */
;;;449      DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
00001c  6341              STR      r1,[r0,#0x34]
00001e  6381              STR      r1,[r0,#0x38]
;;;450    }
000020  4770              BX       lr
;;;451    
                          ENDP


;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\stm32f4xx_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_dma_c_e9b554c0____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___15_stm32f4xx_dma_c_e9b554c0____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_dma_c_e9b554c0____REVSH|
#line 144
|__asm___15_stm32f4xx_dma_c_e9b554c0____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
