; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\stm32f4xx_flash.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f4xx_flash.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\stm32f4xx_flash.crf arm_hal\lib\stm32f4xx_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;1480     */
;;;1481   void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;1482   {
;;;1483     /* Check the parameters */
;;;1484     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
;;;1485     
;;;1486     /* Clear the flags */
;;;1487     FLASH->SR = FLASH_FLAG;
000002  6008              STR      r0,[r1,#0]
;;;1488   }
000004  4770              BX       lr
;;;1489   
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_DataCacheCmd||, CODE, READONLY, ALIGN=2

                  FLASH_DataCacheCmd PROC
;;;305      */
;;;306    void FLASH_DataCacheCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L2.20|
;;;307    {
;;;308      /* Check the parameters */
;;;309      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;310      
;;;311      if(NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;312      {
;;;313        FLASH->ACR |= FLASH_ACR_DCEN;
;;;314      }
;;;315      else
;;;316      {
;;;317        FLASH->ACR &= (~FLASH_ACR_DCEN);
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;313
000008  f4406080          ORRNE    r0,r0,#0x400          ;313
00000c  f4206080          BICEQ    r0,r0,#0x400
000010  6008              STR      r0,[r1,#0]            ;313
;;;318      }
;;;319    }
000012  4770              BX       lr
;;;320    
                          ENDP

                  |L2.20|
                          DCD      0x40023c00

                          AREA ||i.FLASH_DataCacheReset||, CODE, READONLY, ALIGN=2

                  FLASH_DataCacheReset PROC
;;;337      */
;;;338    void FLASH_DataCacheReset(void)
000000  4802              LDR      r0,|L3.12|
;;;339    {
;;;340      FLASH->ACR |= FLASH_ACR_DCRST;
000002  6801              LDR      r1,[r0,#0]
000004  f4415180          ORR      r1,r1,#0x1000
000008  6001              STR      r1,[r0,#0]
;;;341    }
00000a  4770              BX       lr
;;;342    
                          ENDP

                  |L3.12|
                          DCD      0x40023c00

                          AREA ||i.FLASH_EraseAllBank1Sectors||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank1Sectors PROC
;;;585      */
;;;586    FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange)
000000  b530              PUSH     {r4,r5,lr}
;;;587    {
000002  4605              MOV      r5,r0
;;;588      uint32_t tmp_psize = 0x0;
000004  2400              MOVS     r4,#0
;;;589      FLASH_Status status = FLASH_COMPLETE;
;;;590      
;;;591      /* Wait for last operation to be completed */
;;;592      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;593      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;594      
;;;595      if(VoltageRange == VoltageRange_1)
00000a  b155              CBZ      r5,|L4.34|
;;;596      {
;;;597         tmp_psize = FLASH_PSIZE_BYTE;
;;;598      }
;;;599      else if(VoltageRange == VoltageRange_2)
00000c  2d01              CMP      r5,#1
;;;600      {
;;;601        tmp_psize = FLASH_PSIZE_HALF_WORD;
00000e  bf08              IT       EQ
000010  f44f7480          MOVEQ    r4,#0x100
000014  d005              BEQ      |L4.34|
;;;602      }
;;;603      else if(VoltageRange == VoltageRange_3)
000016  2d02              CMP      r5,#2
;;;604      {
;;;605        tmp_psize = FLASH_PSIZE_WORD;
000018  bf0c              ITE      EQ
00001a  f44f7400          MOVEQ    r4,#0x200
;;;606      }
;;;607      else
;;;608      {
;;;609        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
00001e  f44f7440          MOVNE    r4,#0x300
                  |L4.34|
;;;610      }  
;;;611      if(status == FLASH_COMPLETE)
000022  2809              CMP      r0,#9
;;;612      {
;;;613        /* if the previous operation is completed, proceed to erase all sectors */
;;;614         FLASH->CR &= CR_PSIZE_MASK;
;;;615         FLASH->CR |= tmp_psize;
;;;616         FLASH->CR |= FLASH_CR_MER1;
;;;617         FLASH->CR |= FLASH_CR_STRT;
;;;618        
;;;619        /* Wait for last operation to be completed */
;;;620        status = FLASH_WaitForLastOperation();
;;;621    
;;;622        /* if the erase operation is completed, disable the MER Bit */
;;;623        FLASH->CR &= (~FLASH_CR_MER1);
;;;624    
;;;625      }   
;;;626      /* Return the Erase Status */
;;;627      return status;
;;;628    }
000024  bf18              IT       NE
000026  bd30              POPNE    {r4,r5,pc}
000028  4d0b              LDR      r5,|L4.88|
00002a  6828              LDR      r0,[r5,#0]            ;614
00002c  f4207040          BIC      r0,r0,#0x300          ;614
000030  6028              STR      r0,[r5,#0]            ;614
000032  6828              LDR      r0,[r5,#0]            ;615
000034  4320              ORRS     r0,r0,r4              ;615
000036  6028              STR      r0,[r5,#0]            ;615
000038  6828              LDR      r0,[r5,#0]            ;616
00003a  f0400004          ORR      r0,r0,#4              ;616
00003e  6028              STR      r0,[r5,#0]            ;616
000040  6828              LDR      r0,[r5,#0]            ;617
000042  f4403080          ORR      r0,r0,#0x10000        ;617
000046  6028              STR      r0,[r5,#0]            ;617
000048  f7fffffe          BL       FLASH_WaitForLastOperation
00004c  6829              LDR      r1,[r5,#0]            ;623
00004e  f0210104          BIC      r1,r1,#4              ;623
000052  6029              STR      r1,[r5,#0]            ;623
000054  bd30              POP      {r4,r5,pc}
;;;629    
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      0x40023c10

                          AREA ||i.FLASH_EraseAllBank2Sectors||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank2Sectors PROC
;;;652      */
;;;653    FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange)
000000  b530              PUSH     {r4,r5,lr}
;;;654    {
000002  4605              MOV      r5,r0
;;;655      uint32_t tmp_psize = 0x0;
000004  2400              MOVS     r4,#0
;;;656      FLASH_Status status = FLASH_COMPLETE;
;;;657      
;;;658      /* Wait for last operation to be completed */
;;;659      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;660      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;661      
;;;662      if(VoltageRange == VoltageRange_1)
00000a  b155              CBZ      r5,|L5.34|
;;;663      {
;;;664         tmp_psize = FLASH_PSIZE_BYTE;
;;;665      }
;;;666      else if(VoltageRange == VoltageRange_2)
00000c  2d01              CMP      r5,#1
;;;667      {
;;;668        tmp_psize = FLASH_PSIZE_HALF_WORD;
00000e  bf08              IT       EQ
000010  f44f7480          MOVEQ    r4,#0x100
000014  d005              BEQ      |L5.34|
;;;669      }
;;;670      else if(VoltageRange == VoltageRange_3)
000016  2d02              CMP      r5,#2
;;;671      {
;;;672        tmp_psize = FLASH_PSIZE_WORD;
000018  bf0c              ITE      EQ
00001a  f44f7400          MOVEQ    r4,#0x200
;;;673      }
;;;674      else
;;;675      {
;;;676        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
00001e  f44f7440          MOVNE    r4,#0x300
                  |L5.34|
;;;677      }  
;;;678      if(status == FLASH_COMPLETE)
000022  2809              CMP      r0,#9
;;;679      {
;;;680        /* if the previous operation is completed, proceed to erase all sectors */
;;;681         FLASH->CR &= CR_PSIZE_MASK;
;;;682         FLASH->CR |= tmp_psize;
;;;683         FLASH->CR |= FLASH_CR_MER2;
;;;684         FLASH->CR |= FLASH_CR_STRT;
;;;685        
;;;686        /* Wait for last operation to be completed */
;;;687        status = FLASH_WaitForLastOperation();
;;;688    
;;;689        /* if the erase operation is completed, disable the MER Bit */
;;;690        FLASH->CR &= (~FLASH_CR_MER2);
;;;691    
;;;692      }   
;;;693      /* Return the Erase Status */
;;;694      return status;
;;;695    }
000024  bf18              IT       NE
000026  bd30              POPNE    {r4,r5,pc}
000028  4d0b              LDR      r5,|L5.88|
00002a  6828              LDR      r0,[r5,#0]            ;681
00002c  f4207040          BIC      r0,r0,#0x300          ;681
000030  6028              STR      r0,[r5,#0]            ;681
000032  6828              LDR      r0,[r5,#0]            ;682
000034  4320              ORRS     r0,r0,r4              ;682
000036  6028              STR      r0,[r5,#0]            ;682
000038  6828              LDR      r0,[r5,#0]            ;683
00003a  f4404000          ORR      r0,r0,#0x8000         ;683
00003e  6028              STR      r0,[r5,#0]            ;683
000040  6828              LDR      r0,[r5,#0]            ;684
000042  f4403080          ORR      r0,r0,#0x10000        ;684
000046  6028              STR      r0,[r5,#0]            ;684
000048  f7fffffe          BL       FLASH_WaitForLastOperation
00004c  6829              LDR      r1,[r5,#0]            ;690
00004e  f4214100          BIC      r1,r1,#0x8000         ;690
000052  6029              STR      r1,[r5,#0]            ;690
000054  bd30              POP      {r4,r5,pc}
;;;696    
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      0x40023c10

                          AREA ||i.FLASH_EraseAllSectors||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllSectors PROC
;;;504      */
;;;505    FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
000000  b530              PUSH     {r4,r5,lr}
;;;506    {
000002  4605              MOV      r5,r0
;;;507      uint32_t tmp_psize = 0x0;
000004  2400              MOVS     r4,#0
;;;508      FLASH_Status status = FLASH_COMPLETE;
;;;509      
;;;510      /* Wait for last operation to be completed */
;;;511      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;512      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;513      
;;;514      if(VoltageRange == VoltageRange_1)
00000a  b155              CBZ      r5,|L6.34|
;;;515      {
;;;516         tmp_psize = FLASH_PSIZE_BYTE;
;;;517      }
;;;518      else if(VoltageRange == VoltageRange_2)
00000c  2d01              CMP      r5,#1
;;;519      {
;;;520        tmp_psize = FLASH_PSIZE_HALF_WORD;
00000e  bf08              IT       EQ
000010  f44f7480          MOVEQ    r4,#0x100
000014  d005              BEQ      |L6.34|
;;;521      }
;;;522      else if(VoltageRange == VoltageRange_3)
000016  2d02              CMP      r5,#2
;;;523      {
;;;524        tmp_psize = FLASH_PSIZE_WORD;
000018  bf0c              ITE      EQ
00001a  f44f7400          MOVEQ    r4,#0x200
;;;525      }
;;;526      else
;;;527      {
;;;528        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
00001e  f44f7440          MOVNE    r4,#0x300
                  |L6.34|
;;;529      }  
;;;530      if(status == FLASH_COMPLETE)
000022  2809              CMP      r0,#9
;;;531      {
;;;532        /* if the previous operation is completed, proceed to erase all sectors */
;;;533    #if defined (STM32F427_437xx) || defined (STM32F429_439xx)    
;;;534        FLASH->CR &= CR_PSIZE_MASK;
;;;535        FLASH->CR |= tmp_psize;
;;;536        FLASH->CR |= (FLASH_CR_MER1 | FLASH_CR_MER2);
;;;537        FLASH->CR |= FLASH_CR_STRT;
;;;538        
;;;539        /* Wait for last operation to be completed */
;;;540        status = FLASH_WaitForLastOperation();
;;;541    
;;;542        /* if the erase operation is completed, disable the MER Bit */
;;;543        FLASH->CR &= ~(FLASH_CR_MER1 | FLASH_CR_MER2);
;;;544    #endif /* STM32F427_437xx ||  STM32F429_439xx */
;;;545    
;;;546    #if defined (STM32F40_41xxx) || defined (STM32F401xx) 
;;;547        FLASH->CR &= CR_PSIZE_MASK;
;;;548        FLASH->CR |= tmp_psize;
;;;549        FLASH->CR |= FLASH_CR_MER;
;;;550        FLASH->CR |= FLASH_CR_STRT;
;;;551        
;;;552        /* Wait for last operation to be completed */
;;;553        status = FLASH_WaitForLastOperation();
;;;554    
;;;555        /* if the erase operation is completed, disable the MER Bit */
;;;556        FLASH->CR &= (~FLASH_CR_MER);
;;;557    #endif /* STM32F40_41xxx || STM32F401xx */
;;;558    
;;;559      }   
;;;560      /* Return the Erase Status */
;;;561      return status;
;;;562    }
000024  bf18              IT       NE
000026  bd30              POPNE    {r4,r5,pc}
000028  4d0b              LDR      r5,|L6.88|
00002a  6828              LDR      r0,[r5,#0]            ;547
00002c  f4207040          BIC      r0,r0,#0x300          ;547
000030  6028              STR      r0,[r5,#0]            ;547
000032  6828              LDR      r0,[r5,#0]            ;548
000034  4320              ORRS     r0,r0,r4              ;548
000036  6028              STR      r0,[r5,#0]            ;548
000038  6828              LDR      r0,[r5,#0]            ;549
00003a  f0400004          ORR      r0,r0,#4              ;549
00003e  6028              STR      r0,[r5,#0]            ;549
000040  6828              LDR      r0,[r5,#0]            ;550
000042  f4403080          ORR      r0,r0,#0x10000        ;550
000046  6028              STR      r0,[r5,#0]            ;550
000048  f7fffffe          BL       FLASH_WaitForLastOperation
00004c  6829              LDR      r1,[r5,#0]            ;556
00004e  f0210104          BIC      r1,r1,#4              ;556
000052  6029              STR      r1,[r5,#0]            ;556
000054  bd30              POP      {r4,r5,pc}
;;;563    
                          ENDP

000056  0000              DCW      0x0000
                  |L6.88|
                          DCD      0x40023c10

                          AREA ||i.FLASH_EraseSector||, CODE, READONLY, ALIGN=2

                  FLASH_EraseSector PROC
;;;436      */
;;;437    FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
000000  b570              PUSH     {r4-r6,lr}
;;;438    {
000002  4606              MOV      r6,r0
;;;439      uint32_t tmp_psize = 0x0;
000004  2500              MOVS     r5,#0
000006  b151              CBZ      r1,|L7.30|
;;;440      FLASH_Status status = FLASH_COMPLETE;
;;;441    
;;;442      /* Check the parameters */
;;;443      assert_param(IS_FLASH_SECTOR(FLASH_Sector));
;;;444      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;445      
;;;446      if(VoltageRange == VoltageRange_1)
;;;447      {
;;;448         tmp_psize = FLASH_PSIZE_BYTE;
;;;449      }
;;;450      else if(VoltageRange == VoltageRange_2)
000008  2901              CMP      r1,#1
;;;451      {
;;;452        tmp_psize = FLASH_PSIZE_HALF_WORD;
00000a  bf08              IT       EQ
00000c  f44f7580          MOVEQ    r5,#0x100
000010  d005              BEQ      |L7.30|
;;;453      }
;;;454      else if(VoltageRange == VoltageRange_3)
000012  2902              CMP      r1,#2
;;;455      {
;;;456        tmp_psize = FLASH_PSIZE_WORD;
000014  bf0c              ITE      EQ
000016  f44f7500          MOVEQ    r5,#0x200
;;;457      }
;;;458      else
;;;459      {
;;;460        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
00001a  f44f7540          MOVNE    r5,#0x300
                  |L7.30|
;;;461      }
;;;462      /* Wait for last operation to be completed */
;;;463      status = FLASH_WaitForLastOperation();
00001e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;464      
;;;465      if(status == FLASH_COMPLETE)
000022  2809              CMP      r0,#9
;;;466      { 
;;;467        /* if the previous operation is completed, proceed to erase the sector */
;;;468        FLASH->CR &= CR_PSIZE_MASK;
;;;469        FLASH->CR |= tmp_psize;
;;;470        FLASH->CR &= SECTOR_MASK;
;;;471        FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
;;;472        FLASH->CR |= FLASH_CR_STRT;
;;;473        
;;;474        /* Wait for last operation to be completed */
;;;475        status = FLASH_WaitForLastOperation();
;;;476        
;;;477        /* if the erase operation is completed, disable the SER Bit */
;;;478        FLASH->CR &= (~FLASH_CR_SER);
;;;479        FLASH->CR &= SECTOR_MASK; 
;;;480      }
;;;481      /* Return the Erase Status */
;;;482      return status;
;;;483    }
000024  bf18              IT       NE
000026  bd70              POPNE    {r4-r6,pc}
000028  4c0f              LDR      r4,|L7.104|
00002a  6820              LDR      r0,[r4,#0]            ;468
00002c  f4207040          BIC      r0,r0,#0x300          ;468
000030  6020              STR      r0,[r4,#0]            ;468
000032  6820              LDR      r0,[r4,#0]            ;469
000034  4328              ORRS     r0,r0,r5              ;469
000036  6020              STR      r0,[r4,#0]            ;469
000038  6820              LDR      r0,[r4,#0]            ;470
00003a  f02000f8          BIC      r0,r0,#0xf8           ;470
00003e  6020              STR      r0,[r4,#0]            ;470
000040  6820              LDR      r0,[r4,#0]            ;471
000042  f0460102          ORR      r1,r6,#2              ;471
000046  4308              ORRS     r0,r0,r1              ;471
000048  6020              STR      r0,[r4,#0]            ;471
00004a  6820              LDR      r0,[r4,#0]            ;472
00004c  f4403080          ORR      r0,r0,#0x10000        ;472
000050  6020              STR      r0,[r4,#0]            ;472
000052  f7fffffe          BL       FLASH_WaitForLastOperation
000056  6821              LDR      r1,[r4,#0]            ;478
000058  f0210102          BIC      r1,r1,#2              ;478
00005c  6021              STR      r1,[r4,#0]            ;478
00005e  6821              LDR      r1,[r4,#0]            ;479
000060  f02101f8          BIC      r1,r1,#0xf8           ;479
000064  6021              STR      r1,[r4,#0]            ;479
000066  bd70              POP      {r4-r6,pc}
;;;484    
                          ENDP

                  |L7.104|
                          DCD      0x40023c10

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;1449     */
;;;1450   FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  4a03              LDR      r2,|L8.16|
;;;1451   {
000002  4601              MOV      r1,r0
;;;1452     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1453     /* Check the parameters */
;;;1454     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
;;;1455   
;;;1456     if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
;;;1457     {
;;;1458       bitstatus = SET;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;1459     }
;;;1460     else
;;;1461     {
;;;1462       bitstatus = RESET;
;;;1463     }
;;;1464     /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;1465     return bitstatus; 
;;;1466   }
00000e  4770              BX       lr
;;;1467   
                          ENDP

                  |L8.16|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;1495     */
;;;1496   FLASH_Status FLASH_GetStatus(void)
000000  490f              LDR      r1,|L9.64|
;;;1497   {
;;;1498     FLASH_Status flashstatus = FLASH_COMPLETE;
000002  2009              MOVS     r0,#9
;;;1499     
;;;1500     if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000004  680a              LDR      r2,[r1,#0]
000006  f4123f80          TST      r2,#0x10000
;;;1501     {
;;;1502       flashstatus = FLASH_BUSY;
00000a  bf1c              ITT      NE
00000c  2001              MOVNE    r0,#1
;;;1503     }
;;;1504     else 
;;;1505     {  
;;;1506       if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
;;;1507       { 
;;;1508         flashstatus = FLASH_ERROR_WRP;
;;;1509       }
;;;1510       else
;;;1511       {
;;;1512         if((FLASH->SR & FLASH_FLAG_RDERR) != (uint32_t)0x00)
;;;1513         { 
;;;1514           flashstatus = FLASH_ERROR_RD;
;;;1515         } 
;;;1516         else 
;;;1517         {
;;;1518           if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
;;;1519           {
;;;1520             flashstatus = FLASH_ERROR_PROGRAM; 
;;;1521           }
;;;1522           else
;;;1523           {
;;;1524             if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
;;;1525             {
;;;1526               flashstatus = FLASH_ERROR_OPERATION;
;;;1527             }
;;;1528             else
;;;1529             {
;;;1530               flashstatus = FLASH_COMPLETE;
;;;1531             }
;;;1532           }
;;;1533         }
;;;1534       }
;;;1535     }
;;;1536     /* Return the FLASH Status */
;;;1537     return flashstatus;
;;;1538   }
00000e  4770              BXNE     lr
000010  680a              LDR      r2,[r1,#0]            ;1506
000012  f0120f10          TST      r2,#0x10              ;1506
000016  bf1c              ITT      NE                    ;1508
000018  2006              MOVNE    r0,#6                 ;1508
00001a  4770              BXNE     lr
00001c  680a              LDR      r2,[r1,#0]            ;1512
00001e  f4127f80          TST      r2,#0x100             ;1512
000022  bf1c              ITT      NE                    ;1514
000024  2002              MOVNE    r0,#2                 ;1514
000026  4770              BXNE     lr
000028  680a              LDR      r2,[r1,#0]            ;1518
00002a  f0120fef          TST      r2,#0xef              ;1518
00002e  bf1c              ITT      NE                    ;1520
000030  2007              MOVNE    r0,#7                 ;1520
000032  4770              BXNE     lr
000034  6809              LDR      r1,[r1,#0]            ;1524
000036  f0110f02          TST      r1,#2                 ;1524
00003a  bf18              IT       NE                    ;1526
00003c  2008              MOVNE    r0,#8                 ;1526
00003e  4770              BX       lr
;;;1539   
                          ENDP

                  |L9.64|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;1417     */
;;;1418   void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;1419   {
;;;1420     /* Check the parameters */
;;;1421     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1422     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1423   
;;;1424     if(NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1425     {
;;;1426       /* Enable the interrupt sources */
;;;1427       FLASH->CR |= FLASH_IT;
;;;1428     }
;;;1429     else
;;;1430     {
;;;1431       /* Disable the interrupt sources */
;;;1432       FLASH->CR &= ~(uint32_t)FLASH_IT;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1427
000008  4308              ORRNE    r0,r0,r1              ;1427
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1427
;;;1433     }
;;;1434   }
000010  4770              BX       lr
;;;1435   
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40023c10

                          AREA ||i.FLASH_InstructionCacheCmd||, CODE, READONLY, ALIGN=2

                  FLASH_InstructionCacheCmd PROC
;;;284      */
;;;285    void FLASH_InstructionCacheCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L11.20|
;;;286    {
;;;287      /* Check the parameters */
;;;288      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;289      
;;;290      if(NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;291      {
;;;292        FLASH->ACR |= FLASH_ACR_ICEN;
;;;293      }
;;;294      else
;;;295      {
;;;296        FLASH->ACR &= (~FLASH_ACR_ICEN);
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;292
000008  f4407000          ORRNE    r0,r0,#0x200          ;292
00000c  f4207000          BICEQ    r0,r0,#0x200
000010  6008              STR      r0,[r1,#0]            ;292
;;;297      }
;;;298    }
000012  4770              BX       lr
;;;299    
                          ENDP

                  |L11.20|
                          DCD      0x40023c00

                          AREA ||i.FLASH_InstructionCacheReset||, CODE, READONLY, ALIGN=2

                  FLASH_InstructionCacheReset PROC
;;;326      */
;;;327    void FLASH_InstructionCacheReset(void)
000000  4802              LDR      r0,|L12.12|
;;;328    {
;;;329      FLASH->ACR |= FLASH_ACR_ICRST;
000002  6801              LDR      r1,[r0,#0]
000004  f4416100          ORR      r1,r1,#0x800
000008  6001              STR      r1,[r0,#0]
;;;330    }
00000a  4770              BX       lr
;;;331    
                          ENDP

                  |L12.12|
                          DCD      0x40023c00

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;399      */
;;;400    void FLASH_Lock(void)
000000  4802              LDR      r0,|L13.12|
;;;401    {
;;;402      /* Set the LOCK Bit to lock the FLASH Registers access */
;;;403      FLASH->CR |= FLASH_CR_LOCK;
000002  6801              LDR      r1,[r0,#0]
000004  f0414100          ORR      r1,r1,#0x80000000
000008  6001              STR      r1,[r0,#0]
;;;404    }
00000a  4770              BX       lr
;;;405    
                          ENDP

                  |L13.12|
                          DCD      0x40023c10

                          AREA ||i.FLASH_OB_BORConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BORConfig PROC
;;;1262     */
;;;1263   void FLASH_OB_BORConfig(uint8_t OB_BOR)
000000  4904              LDR      r1,|L14.20|
;;;1264   {
;;;1265     /* Check the parameters */
;;;1266     assert_param(IS_OB_BOR(OB_BOR));
;;;1267   
;;;1268     /* Set the BOR Level */
;;;1269     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
000002  780a              LDRB     r2,[r1,#0]
000004  f022020c          BIC      r2,r2,#0xc
000008  700a              STRB     r2,[r1,#0]
;;;1270     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
00000a  780a              LDRB     r2,[r1,#0]
00000c  4310              ORRS     r0,r0,r2
00000e  7008              STRB     r0,[r1,#0]
;;;1271   
;;;1272   }
000010  4770              BX       lr
;;;1273   
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_BootConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BootConfig PROC
;;;1241     */
;;;1242   void FLASH_OB_BootConfig(uint8_t OB_BOOT)
000000  4904              LDR      r1,|L15.20|
;;;1243   {
;;;1244     /* Check the parameters */
;;;1245     assert_param(IS_OB_BOOT(OB_BOOT));
;;;1246   
;;;1247     /* Set Dual Bank Boot */
;;;1248     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BFB2);
000002  780a              LDRB     r2,[r1,#0]
000004  f0220210          BIC      r2,r2,#0x10
000008  700a              STRB     r2,[r1,#0]
;;;1249     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOOT;
00000a  780a              LDRB     r2,[r1,#0]
00000c  4310              ORRS     r0,r0,r2
00000e  7008              STRB     r0,[r1,#0]
;;;1250   
;;;1251   }
000010  4770              BX       lr
;;;1252   
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetBOR||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetBOR PROC
;;;1388     */
;;;1389   uint8_t FLASH_OB_GetBOR(void)
000000  4802              LDR      r0,|L16.12|
;;;1390   {
;;;1391     /* Return the FLASH BOR level */
;;;1392     return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
000002  7800              LDRB     r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;1393   }
000008  4770              BX       lr
;;;1394   
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetPCROP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetPCROP PROC
;;;1337     */
;;;1338   uint16_t FLASH_OB_GetPCROP(void)
000000  4801              LDR      r0,|L17.8|
;;;1339   {
;;;1340     /* Return the FLASH PC Read/write protection Register value */
;;;1341     return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1342   }
000004  4770              BX       lr
;;;1343   
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_GetPCROP1||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetPCROP1 PROC
;;;1351     */
;;;1352   uint16_t FLASH_OB_GetPCROP1(void)
000000  4801              LDR      r0,|L18.8|
;;;1353   {
;;;1354     /* Return the FLASH write protection Register value */
;;;1355     return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1356   }
000004  4770              BX       lr
;;;1357   
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      0x40023c1a

                          AREA ||i.FLASH_OB_GetRDP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetRDP PROC
;;;1364     */
;;;1365   FlagStatus FLASH_OB_GetRDP(void)
000000  4903              LDR      r1,|L19.16|
;;;1366   {
;;;1367     FlagStatus readstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1368   
;;;1369     if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
000004  7809              LDRB     r1,[r1,#0]
000006  29aa              CMP      r1,#0xaa
;;;1370     {
;;;1371       readstatus = SET;
000008  bf18              IT       NE
00000a  2001              MOVNE    r0,#1
;;;1372     }
;;;1373     else
;;;1374     {
;;;1375       readstatus = RESET;
;;;1376     }
;;;1377     return readstatus;
;;;1378   }
00000c  4770              BX       lr
;;;1379   
                          ENDP

00000e  0000              DCW      0x0000
                  |L19.16|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_GetUser||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetUser PROC
;;;1298     */
;;;1299   uint8_t FLASH_OB_GetUser(void)
000000  4802              LDR      r0,|L20.12|
;;;1300   {
;;;1301     /* Return the User Option Byte */
;;;1302     return (uint8_t)(FLASH->OPTCR >> 5);
000002  6800              LDR      r0,[r0,#0]
000004  f3c01047          UBFX     r0,r0,#5,#8
;;;1303   }
000008  4770              BX       lr
;;;1304   
                          ENDP

00000a  0000              DCW      0x0000
                  |L20.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP PROC
;;;1309     */
;;;1310   uint16_t FLASH_OB_GetWRP(void)
000000  4801              LDR      r0,|L21.8|
;;;1311   {
;;;1312     /* Return the FLASH write protection Register value */
;;;1313     return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1314   }
000004  4770              BX       lr
;;;1315   
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_GetWRP1||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP1 PROC
;;;1323     */
;;;1324   uint16_t FLASH_OB_GetWRP1(void)
000000  4801              LDR      r0,|L22.8|
;;;1325   {
;;;1326     /* Return the FLASH write protection Register value */
;;;1327     return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1328   }
000004  4770              BX       lr
;;;1329   
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x40023c1a

                          AREA ||i.FLASH_OB_Launch||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Launch PROC
;;;1279     */
;;;1280   FLASH_Status FLASH_OB_Launch(void)
000000  4803              LDR      r0,|L23.16|
;;;1281   {
;;;1282     FLASH_Status status = FLASH_COMPLETE;
;;;1283   
;;;1284     /* Set the OPTSTRT bit in OPTCR register */
;;;1285     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
000002  7801              LDRB     r1,[r0,#0]
000004  f0410102          ORR      r1,r1,#2
000008  7001              STRB     r1,[r0,#0]
;;;1286   
;;;1287     /* Wait for last operation to be completed */
;;;1288     status = FLASH_WaitForLastOperation();
00000a  f7ffbffe          B.W      FLASH_WaitForLastOperation
;;;1289   
;;;1290     return status;
;;;1291   }
;;;1292   
                          ENDP

00000e  0000              DCW      0x0000
                  |L23.16|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Lock PROC
;;;950      */
;;;951    void FLASH_OB_Lock(void)
000000  4802              LDR      r0,|L24.12|
;;;952    {
;;;953      /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
;;;954      FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;955    }
00000a  4770              BX       lr
;;;956    
                          ENDP

                  |L24.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_PCROP1Config||, CODE, READONLY, ALIGN=2

                  FLASH_OB_PCROP1Config PROC
;;;1132     */
;;;1133   void FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1134   { 
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1135     FLASH_Status status = FLASH_COMPLETE;
;;;1136     
;;;1137     /* Check the parameters */
;;;1138     assert_param(IS_OB_PCROP(OB_PCROP));
;;;1139     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1140       
;;;1141     status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1142   
;;;1143     if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
;;;1144     { 
;;;1145       if(NewState != DISABLE)
;;;1146       {
;;;1147         *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;
;;;1148       }
;;;1149       else
;;;1150       {
;;;1151         *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_PCROP);
;;;1152       }
;;;1153     }
;;;1154   }
00000c  bf18              IT       NE
00000e  bd30              POPNE    {r4,r5,pc}
000010  4803              LDR      r0,|L25.32|
000012  2d00              CMP      r5,#0                 ;1145
000014  8801              LDRH     r1,[r0,#0]            ;1151
000016  bf14              ITE      NE                    ;1147
000018  4321              ORRNE    r1,r1,r4              ;1147
00001a  43a1              BICEQ    r1,r1,r4              ;1151
00001c  8001              STRH     r1,[r0,#0]            ;1151
00001e  bd30              POP      {r4,r5,pc}
;;;1155   
                          ENDP

                  |L25.32|
                          DCD      0x40023c1a

                          AREA ||i.FLASH_OB_PCROPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_PCROPConfig PROC
;;;1095     */
;;;1096   void FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1097   { 
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1098     FLASH_Status status = FLASH_COMPLETE;
;;;1099     
;;;1100     /* Check the parameters */
;;;1101     assert_param(IS_OB_PCROP(OB_PCROP));
;;;1102     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1103       
;;;1104     status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1105   
;;;1106     if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
;;;1107     { 
;;;1108       if(NewState != DISABLE)
;;;1109       {
;;;1110         *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;    
;;;1111       }
;;;1112       else
;;;1113       {
;;;1114         *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_PCROP);
;;;1115       }
;;;1116     }
;;;1117   }
00000c  bf18              IT       NE
00000e  bd30              POPNE    {r4,r5,pc}
000010  4803              LDR      r0,|L26.32|
000012  2d00              CMP      r5,#0                 ;1108
000014  8801              LDRH     r1,[r0,#0]            ;1114
000016  bf14              ITE      NE                    ;1110
000018  4321              ORRNE    r1,r1,r4              ;1110
00001a  43a1              BICEQ    r1,r1,r4              ;1114
00001c  8001              STRH     r1,[r0,#0]            ;1114
00001e  bd30              POP      {r4,r5,pc}
;;;1118   
                          ENDP

                  |L26.32|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_PCROPSelectionConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_PCROPSelectionConfig PROC
;;;1065     */
;;;1066   void FLASH_OB_PCROPSelectionConfig(uint8_t OB_PcROP)
000000  4a03              LDR      r2,|L27.16|
;;;1067   {  
;;;1068     uint8_t optiontmp = 0xFF;
;;;1069         
;;;1070     /* Check the parameters */
;;;1071     assert_param(IS_OB_PCROP_SELECT(OB_PcROP));
;;;1072     
;;;1073     /* Mask SPRMOD bit */
;;;1074     optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
000002  7811              LDRB     r1,[r2,#0]
000004  f001017f          AND      r1,r1,#0x7f
;;;1075     /* Update Option Byte */
;;;1076     *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PcROP | optiontmp); 
000008  4308              ORRS     r0,r0,r1
00000a  7010              STRB     r0,[r2,#0]
;;;1077       
;;;1078   }
00000c  4770              BX       lr
;;;1079   
                          ENDP

00000e  0000              DCW      0x0000
                  |L27.16|
                          DCD      0x40023c17

                          AREA ||i.FLASH_OB_RDPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_RDPConfig PROC
;;;1168     */
;;;1169   void FLASH_OB_RDPConfig(uint8_t OB_RDP)
000000  b510              PUSH     {r4,lr}
;;;1170   {
000002  4604              MOV      r4,r0
;;;1171     FLASH_Status status = FLASH_COMPLETE;
;;;1172   
;;;1173     /* Check the parameters */
;;;1174     assert_param(IS_OB_RDP(OB_RDP));
;;;1175   
;;;1176     status = FLASH_WaitForLastOperation();
000004  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1177   
;;;1178     if(status == FLASH_COMPLETE)
000008  2809              CMP      r0,#9
;;;1179     {
;;;1180       *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
00000a  bf04              ITT      EQ
00000c  4801              LDREQ    r0,|L28.20|
00000e  7004              STRBEQ   r4,[r0,#0]
;;;1181   
;;;1182     }
;;;1183   }
000010  bd10              POP      {r4,pc}
;;;1184   
                          ENDP

000012  0000              DCW      0x0000
                  |L28.20|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Unlock PROC
;;;935      */
;;;936    void FLASH_OB_Unlock(void)
000000  4805              LDR      r0,|L29.24|
;;;937    {
;;;938      if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
000002  6800              LDR      r0,[r0,#0]
000004  f0100f01          TST      r0,#1
;;;939      {
;;;940        /* Authorizes the Option Byte register programming */
;;;941        FLASH->OPTKEYR = FLASH_OPT_KEY1;
;;;942        FLASH->OPTKEYR = FLASH_OPT_KEY2;
;;;943      }  
;;;944    }
000008  bf08              IT       EQ
00000a  4770              BXEQ     lr
00000c  4903              LDR      r1,|L29.28|
00000e  4804              LDR      r0,|L29.32|
000010  6001              STR      r1,[r0,#0]            ;941
000012  4904              LDR      r1,|L29.36|
000014  6001              STR      r1,[r0,#0]            ;942
000016  4770              BX       lr
;;;945    
                          ENDP

                  |L29.24|
                          DCD      0x40023c14
                  |L29.28|
                          DCD      0x08192a3b
                  |L29.32|
                          DCD      0x40023c08
                  |L29.36|
                          DCD      0x4c5d6e7f

                          AREA ||i.FLASH_OB_UserConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_UserConfig PROC
;;;1200     */
;;;1201   void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
000000  b570              PUSH     {r4-r6,lr}
;;;1202   {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;1203     uint8_t optiontmp = 0xFF;
;;;1204     FLASH_Status status = FLASH_COMPLETE; 
;;;1205   
;;;1206     /* Check the parameters */
;;;1207     assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;1208     assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;1209     assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;1210   
;;;1211     /* Wait for last operation to be completed */
;;;1212     status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1213     
;;;1214     if(status == FLASH_COMPLETE)
00000c  2809              CMP      r0,#9
;;;1215     { 
;;;1216   #if defined (STM32F427_437xx) || defined (STM32F429_439xx)     
;;;1217       /* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */
;;;1218       optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);
;;;1219   #endif /* STM32F427_437xx ||  STM32F429_439xx */
;;;1220   
;;;1221   #if defined (STM32F40_41xxx) || defined (STM32F401xx) 
;;;1222       /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
;;;1223       optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
;;;1224   #endif /* STM32F40_41xxx || STM32F401xx */ 
;;;1225   
;;;1226       /* Update User Option Byte */
;;;1227       *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
;;;1228     }  
;;;1229   }
00000e  bf18              IT       NE
000010  bd70              POPNE    {r4-r6,pc}
000012  4b04              LDR      r3,|L30.36|
000014  7818              LDRB     r0,[r3,#0]            ;1223
000016  f000000f          AND      r0,r0,#0xf            ;1223
00001a  4328              ORRS     r0,r0,r5              ;1227
00001c  4320              ORRS     r0,r0,r4              ;1227
00001e  4330              ORRS     r0,r0,r6              ;1227
000020  7018              STRB     r0,[r3,#0]            ;1227
000022  bd70              POP      {r4-r6,pc}
;;;1230   
                          ENDP

                  |L30.36|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_WRP1Config||, CODE, READONLY, ALIGN=2

                  FLASH_OB_WRP1Config PROC
;;;1015     */
;;;1016   void FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1017   { 
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1018     FLASH_Status status = FLASH_COMPLETE;
;;;1019     
;;;1020     /* Check the parameters */
;;;1021     assert_param(IS_OB_WRP(OB_WRP));
;;;1022     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1023       
;;;1024     status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1025   
;;;1026     if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
;;;1027     { 
;;;1028       if(NewState != DISABLE)
;;;1029       {
;;;1030         *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_WRP);
;;;1031       }
;;;1032       else
;;;1033       {
;;;1034         *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
;;;1035       }
;;;1036     }
;;;1037   }
00000c  bf18              IT       NE
00000e  bd30              POPNE    {r4,r5,pc}
000010  4803              LDR      r0,|L31.32|
000012  2d00              CMP      r5,#0                 ;1028
000014  8801              LDRH     r1,[r0,#0]            ;1034
000016  bf14              ITE      NE                    ;1030
000018  43a1              BICNE    r1,r1,r4              ;1030
00001a  4321              ORREQ    r1,r1,r4              ;1034
00001c  8001              STRH     r1,[r0,#0]            ;1034
00001e  bd30              POP      {r4,r5,pc}
;;;1038   
                          ENDP

                  |L31.32|
                          DCD      0x40023c1a

                          AREA ||i.FLASH_OB_WRPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_WRPConfig PROC
;;;973      */
;;;974    void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;975    { 
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;976      FLASH_Status status = FLASH_COMPLETE;
;;;977      
;;;978      /* Check the parameters */
;;;979      assert_param(IS_OB_WRP(OB_WRP));
;;;980      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;981        
;;;982      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;983    
;;;984      if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
;;;985      { 
;;;986        if(NewState != DISABLE)
;;;987        {
;;;988          *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
;;;989        }
;;;990        else
;;;991        {
;;;992          *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
;;;993        }
;;;994      }
;;;995    }
00000c  bf18              IT       NE
00000e  bd30              POPNE    {r4,r5,pc}
000010  4803              LDR      r0,|L32.32|
000012  2d00              CMP      r5,#0                 ;986
000014  8801              LDRH     r1,[r0,#0]            ;992
000016  bf14              ITE      NE                    ;988
000018  43a1              BICNE    r1,r1,r4              ;988
00001a  4321              ORREQ    r1,r1,r4              ;992
00001c  8001              STRH     r1,[r0,#0]            ;992
00001e  bd30              POP      {r4,r5,pc}
;;;996    
                          ENDP

                  |L32.32|
                          DCD      0x40023c16

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;262      */
;;;263    void FLASH_PrefetchBufferCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L33.20|
;;;264    {
;;;265      /* Check the parameters */
;;;266      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;267      
;;;268      /* Enable or disable the Prefetch Buffer */
;;;269      if(NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;270      {
;;;271        FLASH->ACR |= FLASH_ACR_PRFTEN;
;;;272      }
;;;273      else
;;;274      {
;;;275        FLASH->ACR &= (~FLASH_ACR_PRFTEN);
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;271
000008  f4407080          ORRNE    r0,r0,#0x100          ;271
00000c  f4207080          BICEQ    r0,r0,#0x100
000010  6008              STR      r0,[r1,#0]            ;271
;;;276      }
;;;277    }
000012  4770              BX       lr
;;;278    
                          ENDP

                  |L33.20|
                          DCD      0x40023c00

                          AREA ||i.FLASH_ProgramByte||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramByte PROC
;;;836      */
;;;837    FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;838    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;839      FLASH_Status status = FLASH_COMPLETE;
;;;840    
;;;841      /* Check the parameters */
;;;842      assert_param(IS_FLASH_ADDRESS(Address));
;;;843    
;;;844      /* Wait for last operation to be completed */
;;;845      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;846      
;;;847      if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
;;;848      {
;;;849        /* if the previous operation is completed, proceed to program the new data */
;;;850        FLASH->CR &= CR_PSIZE_MASK;
;;;851        FLASH->CR |= FLASH_PSIZE_BYTE;
;;;852        FLASH->CR |= FLASH_CR_PG;
;;;853      
;;;854        *(__IO uint8_t*)Address = Data;
;;;855            
;;;856        /* Wait for last operation to be completed */
;;;857        status = FLASH_WaitForLastOperation();
;;;858    
;;;859        /* if the program operation is completed, disable the PG Bit */
;;;860        FLASH->CR &= (~FLASH_CR_PG);
;;;861      } 
;;;862    
;;;863      /* Return the Program Status */
;;;864      return status;
;;;865    }
00000c  bf18              IT       NE
00000e  bd70              POPNE    {r4-r6,pc}
000010  4c09              LDR      r4,|L34.56|
000012  6820              LDR      r0,[r4,#0]            ;850
000014  f4207040          BIC      r0,r0,#0x300          ;850
000018  6020              STR      r0,[r4,#0]            ;850
00001a  6820              LDR      r0,[r4,#0]            ;851
00001c  6020              STR      r0,[r4,#0]            ;851
00001e  6820              LDR      r0,[r4,#0]            ;852
000020  f0400001          ORR      r0,r0,#1              ;852
000024  6020              STR      r0,[r4,#0]            ;852
000026  7035              STRB     r5,[r6,#0]            ;854
000028  f7fffffe          BL       FLASH_WaitForLastOperation
00002c  6821              LDR      r1,[r4,#0]            ;860
00002e  f0210101          BIC      r1,r1,#1              ;860
000032  6021              STR      r1,[r4,#0]            ;860
000034  bd70              POP      {r4-r6,pc}
;;;866    
                          ENDP

000036  0000              DCW      0x0000
                  |L34.56|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramDoubleWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramDoubleWord PROC
;;;709      */
;;;710    FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;711    {
000002  4617              MOV      r7,r2
000004  461e              MOV      r6,r3
000006  4605              MOV      r5,r0
;;;712      FLASH_Status status = FLASH_COMPLETE;
;;;713    
;;;714      /* Check the parameters */
;;;715      assert_param(IS_FLASH_ADDRESS(Address));
;;;716    
;;;717      /* Wait for last operation to be completed */
;;;718      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;719      
;;;720      if(status == FLASH_COMPLETE)
00000c  2809              CMP      r0,#9
;;;721      {
;;;722        /* if the previous operation is completed, proceed to program the new data */
;;;723        FLASH->CR &= CR_PSIZE_MASK;
;;;724        FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
;;;725        FLASH->CR |= FLASH_CR_PG;
;;;726      
;;;727        *(__IO uint64_t*)Address = Data;
;;;728            
;;;729        /* Wait for last operation to be completed */
;;;730        status = FLASH_WaitForLastOperation();
;;;731    
;;;732        /* if the program operation is completed, disable the PG Bit */
;;;733        FLASH->CR &= (~FLASH_CR_PG);
;;;734      } 
;;;735      /* Return the Program Status */
;;;736      return status;
;;;737    }
00000e  bf18              IT       NE
000010  bdf0              POPNE    {r4-r7,pc}
000012  4c0b              LDR      r4,|L35.64|
000014  6820              LDR      r0,[r4,#0]            ;723
000016  f4207040          BIC      r0,r0,#0x300          ;723
00001a  6020              STR      r0,[r4,#0]            ;723
00001c  6820              LDR      r0,[r4,#0]            ;724
00001e  f4407040          ORR      r0,r0,#0x300          ;724
000022  6020              STR      r0,[r4,#0]            ;724
000024  6820              LDR      r0,[r4,#0]            ;725
000026  f0400001          ORR      r0,r0,#1              ;725
00002a  6020              STR      r0,[r4,#0]            ;725
00002c  602f              STR      r7,[r5,#0]            ;727
00002e  606e              STR      r6,[r5,#4]            ;727
000030  f7fffffe          BL       FLASH_WaitForLastOperation
000034  6821              LDR      r1,[r4,#0]            ;733
000036  f0210101          BIC      r1,r1,#1              ;733
00003a  6021              STR      r1,[r4,#0]            ;733
00003c  bdf0              POP      {r4-r7,pc}
;;;738    
                          ENDP

00003e  0000              DCW      0x0000
                  |L35.64|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;794      */
;;;795    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;796    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;797      FLASH_Status status = FLASH_COMPLETE;
;;;798    
;;;799      /* Check the parameters */
;;;800      assert_param(IS_FLASH_ADDRESS(Address));
;;;801    
;;;802      /* Wait for last operation to be completed */
;;;803      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;804      
;;;805      if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
;;;806      {
;;;807        /* if the previous operation is completed, proceed to program the new data */
;;;808        FLASH->CR &= CR_PSIZE_MASK;
;;;809        FLASH->CR |= FLASH_PSIZE_HALF_WORD;
;;;810        FLASH->CR |= FLASH_CR_PG;
;;;811      
;;;812        *(__IO uint16_t*)Address = Data;
;;;813            
;;;814        /* Wait for last operation to be completed */
;;;815        status = FLASH_WaitForLastOperation();
;;;816    
;;;817        /* if the program operation is completed, disable the PG Bit */
;;;818        FLASH->CR &= (~FLASH_CR_PG);
;;;819      } 
;;;820      /* Return the Program Status */
;;;821      return status;
;;;822    }
00000c  bf18              IT       NE
00000e  bd70              POPNE    {r4-r6,pc}
000010  4c0a              LDR      r4,|L36.60|
000012  6820              LDR      r0,[r4,#0]            ;808
000014  f4207040          BIC      r0,r0,#0x300          ;808
000018  6020              STR      r0,[r4,#0]            ;808
00001a  6820              LDR      r0,[r4,#0]            ;809
00001c  f4407080          ORR      r0,r0,#0x100          ;809
000020  6020              STR      r0,[r4,#0]            ;809
000022  6820              LDR      r0,[r4,#0]            ;810
000024  f0400001          ORR      r0,r0,#1              ;810
000028  6020              STR      r0,[r4,#0]            ;810
00002a  8035              STRH     r5,[r6,#0]            ;812
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  6821              LDR      r1,[r4,#0]            ;818
000032  f0210101          BIC      r1,r1,#1              ;818
000036  6021              STR      r1,[r4,#0]            ;818
000038  bd70              POP      {r4-r6,pc}
;;;823    
                          ENDP

00003a  0000              DCW      0x0000
                  |L36.60|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;752      */
;;;753    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;754    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;755      FLASH_Status status = FLASH_COMPLETE;
;;;756    
;;;757      /* Check the parameters */
;;;758      assert_param(IS_FLASH_ADDRESS(Address));
;;;759    
;;;760      /* Wait for last operation to be completed */
;;;761      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;762      
;;;763      if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
;;;764      {
;;;765        /* if the previous operation is completed, proceed to program the new data */
;;;766        FLASH->CR &= CR_PSIZE_MASK;
;;;767        FLASH->CR |= FLASH_PSIZE_WORD;
;;;768        FLASH->CR |= FLASH_CR_PG;
;;;769      
;;;770        *(__IO uint32_t*)Address = Data;
;;;771            
;;;772        /* Wait for last operation to be completed */
;;;773        status = FLASH_WaitForLastOperation();
;;;774    
;;;775        /* if the program operation is completed, disable the PG Bit */
;;;776        FLASH->CR &= (~FLASH_CR_PG);
;;;777      } 
;;;778      /* Return the Program Status */
;;;779      return status;
;;;780    }
00000c  bf18              IT       NE
00000e  bd70              POPNE    {r4-r6,pc}
000010  4c0a              LDR      r4,|L37.60|
000012  6820              LDR      r0,[r4,#0]            ;766
000014  f4207040          BIC      r0,r0,#0x300          ;766
000018  6020              STR      r0,[r4,#0]            ;766
00001a  6820              LDR      r0,[r4,#0]            ;767
00001c  f4407000          ORR      r0,r0,#0x200          ;767
000020  6020              STR      r0,[r4,#0]            ;767
000022  6820              LDR      r0,[r4,#0]            ;768
000024  f0400001          ORR      r0,r0,#1              ;768
000028  6020              STR      r0,[r4,#0]            ;768
00002a  6035              STR      r5,[r6,#0]            ;770
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  6821              LDR      r1,[r4,#0]            ;776
000032  f0210101          BIC      r1,r1,#1              ;776
000036  6021              STR      r1,[r4,#0]            ;776
000038  bd70              POP      {r4-r6,pc}
;;;781    
                          ENDP

00003a  0000              DCW      0x0000
                  |L37.60|
                          DCD      0x40023c10

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;247      */
;;;248    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4901              LDR      r1,|L38.8|
;;;249    {
;;;250      /* Check the parameters */
;;;251      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;252      
;;;253      /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
;;;254      *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
000002  7008              STRB     r0,[r1,#0]
;;;255    }
000004  4770              BX       lr
;;;256    
                          ENDP

000006  0000              DCW      0x0000
                  |L38.8|
                          DCD      0x40023c00

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;384      */
;;;385    void FLASH_Unlock(void)
000000  4805              LDR      r0,|L39.24|
;;;386    {
;;;387      if((FLASH->CR & FLASH_CR_LOCK) != RESET)
000002  6800              LDR      r0,[r0,#0]
000004  f0104f00          TST      r0,#0x80000000
;;;388      {
;;;389        /* Authorize the FLASH Registers access */
;;;390        FLASH->KEYR = FLASH_KEY1;
;;;391        FLASH->KEYR = FLASH_KEY2;
;;;392      }  
;;;393    }
000008  bf08              IT       EQ
00000a  4770              BXEQ     lr
00000c  4903              LDR      r1,|L39.28|
00000e  4804              LDR      r0,|L39.32|
000010  6001              STR      r1,[r0,#0]            ;390
000012  4904              LDR      r1,|L39.36|
000014  6001              STR      r1,[r0,#0]            ;391
000016  4770              BX       lr
;;;394    
                          ENDP

                  |L39.24|
                          DCD      0x40023c10
                  |L39.28|
                          DCD      0x45670123
                  |L39.32|
                          DCD      0x40023c04
                  |L39.36|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=2

                  FLASH_WaitForLastOperation PROC
;;;1545     */
;;;1546   FLASH_Status FLASH_WaitForLastOperation(void)
000000  b508              PUSH     {r3,lr}
;;;1547   { 
;;;1548     __IO FLASH_Status status = FLASH_COMPLETE;
000002  2009              MOVS     r0,#9
000004  f88d0000          STRB     r0,[sp,#0]
;;;1549      
;;;1550     /* Check for the FLASH Status */
;;;1551     status = FLASH_GetStatus();
000008  f7fffffe          BL       FLASH_GetStatus
00000c  f88d0000          STRB     r0,[sp,#0]
;;;1552   
;;;1553     /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
;;;1554        Even if the FLASH operation fails, the BUSY flag will be reset and an error
;;;1555        flag will be set */
;;;1556     while(status == FLASH_BUSY)
000010  f89d0000          LDRB     r0,[sp,#0]
000014  2801              CMP      r0,#1
000016  bf08              IT       EQ
000018  4914              LDREQ    r1,|L40.108|
00001a  d123              BNE      |L40.100|
                  |L40.28|
00001c  680a              LDR      r2,[r1,#0]
00001e  2009              MOVS     r0,#9
000020  f4123f80          TST      r2,#0x10000
000024  bf18              IT       NE
000026  2001              MOVNE    r0,#1
000028  d116              BNE      |L40.88|
00002a  680a              LDR      r2,[r1,#0]
00002c  f0120f10          TST      r2,#0x10
000030  bf18              IT       NE
000032  2006              MOVNE    r0,#6
000034  d110              BNE      |L40.88|
000036  680a              LDR      r2,[r1,#0]
000038  f4127f80          TST      r2,#0x100
00003c  bf18              IT       NE
00003e  2002              MOVNE    r0,#2
000040  d10a              BNE      |L40.88|
000042  680a              LDR      r2,[r1,#0]
000044  f0120fef          TST      r2,#0xef
000048  bf18              IT       NE
00004a  2007              MOVNE    r0,#7
00004c  d104              BNE      |L40.88|
00004e  680a              LDR      r2,[r1,#0]
000050  f0120f02          TST      r2,#2
000054  bf18              IT       NE
000056  2008              MOVNE    r0,#8
                  |L40.88|
;;;1557     {
;;;1558       status = FLASH_GetStatus();
000058  f88d0000          STRB     r0,[sp,#0]
00005c  f89d0000          LDRB     r0,[sp,#0]            ;1556
000060  2801              CMP      r0,#1                 ;1556
000062  d0db              BEQ      |L40.28|
                  |L40.100|
;;;1559     }
;;;1560     /* Return the operation status */
;;;1561     return status;
000064  f89d0000          LDRB     r0,[sp,#0]
;;;1562   }
000068  bd08              POP      {r3,pc}
;;;1563   
                          ENDP

00006a  0000              DCW      0x0000
                  |L40.108|
                          DCD      0x40023c0c

;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\stm32f4xx_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_flash_c_a2a150d6____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___17_stm32f4xx_flash_c_a2a150d6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_flash_c_a2a150d6____REVSH|
#line 144
|__asm___17_stm32f4xx_flash_c_a2a150d6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
