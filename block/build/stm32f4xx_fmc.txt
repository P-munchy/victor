; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\stm32f4xx_fmc.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f4xx_fmc.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\stm32f4xx_fmc.crf arm_hal\lib\stm32f4xx_fmc.c]
                          THUMB

                          AREA ||i.FMC_ClearFlag||, CODE, READONLY, ALIGN=1

                  FMC_ClearFlag PROC
;;;1216     */
;;;1217   void FMC_ClearFlag(uint32_t FMC_Bank, uint32_t FMC_FLAG)
000000  f04f4220          MOV      r2,#0xa0000000
;;;1218   {
;;;1219    /* Check the parameters */
;;;1220     assert_param(IS_FMC_GETFLAG_BANK(FMC_Bank));
;;;1221     assert_param(IS_FMC_CLEAR_FLAG(FMC_FLAG)) ;
;;;1222       
;;;1223     if(FMC_Bank == FMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d00b              BEQ      |L1.32|
;;;1224     {
;;;1225       FMC_Bank2->SR2 &= (~FMC_FLAG); 
;;;1226     }  
;;;1227     else if(FMC_Bank == FMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d00c              BEQ      |L1.40|
;;;1228     {
;;;1229       FMC_Bank3->SR3 &= (~FMC_FLAG);
;;;1230     }
;;;1231     else if(FMC_Bank == FMC_Bank4_PCCARD)
00000e  f5b05f80          CMP      r0,#0x1000
000012  d00f              BEQ      |L1.52|
;;;1232     {
;;;1233       FMC_Bank4->SR4 &= (~FMC_FLAG);
;;;1234     }
;;;1235     /* FMC_Bank5_6 SDRAM*/
;;;1236     else
;;;1237     {
;;;1238       FMC_Bank5_6->SDRTR &= (~FMC_FLAG);
000014  f8d20154          LDR      r0,[r2,#0x154]
000018  4388              BICS     r0,r0,r1
00001a  f8c20154          STR      r0,[r2,#0x154]
;;;1239     }
;;;1240     
;;;1241   }
00001e  4770              BX       lr
                  |L1.32|
000020  6e50              LDR      r0,[r2,#0x64]         ;1225
000022  4388              BICS     r0,r0,r1              ;1225
000024  6650              STR      r0,[r2,#0x64]         ;1225
000026  4770              BX       lr
                  |L1.40|
000028  f8d20084          LDR      r0,[r2,#0x84]         ;1229
00002c  4388              BICS     r0,r0,r1              ;1229
00002e  f8c20084          STR      r0,[r2,#0x84]         ;1229
000032  4770              BX       lr
                  |L1.52|
000034  f8d200a4          LDR      r0,[r2,#0xa4]         ;1233
000038  4388              BICS     r0,r0,r1              ;1233
00003a  f8c200a4          STR      r0,[r2,#0xa4]         ;1233
00003e  4770              BX       lr
;;;1242   
                          ENDP


                          AREA ||i.FMC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  FMC_ClearITPendingBit PROC
;;;1331     */
;;;1332   void FMC_ClearITPendingBit(uint32_t FMC_Bank, uint32_t FMC_IT)
000000  f04f4220          MOV      r2,#0xa0000000
;;;1333   {
;;;1334     /* Check the parameters */
;;;1335     assert_param(IS_FMC_IT_BANK(FMC_Bank));
;;;1336     assert_param(IS_FMC_IT(FMC_IT));
;;;1337       
;;;1338     if(FMC_Bank == FMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d00c              BEQ      |L2.34|
;;;1339     {
;;;1340       FMC_Bank2->SR2 &= ~(FMC_IT >> 3); 
;;;1341     }  
;;;1342     else if(FMC_Bank == FMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d00e              BEQ      |L2.44|
;;;1343     {
;;;1344       FMC_Bank3->SR3 &= ~(FMC_IT >> 3);
;;;1345     }
;;;1346     else if(FMC_Bank == FMC_Bank4_PCCARD)
00000e  f5b05f80          CMP      r0,#0x1000
000012  d012              BEQ      |L2.58|
;;;1347     {
;;;1348       FMC_Bank4->SR4 &= ~(FMC_IT >> 3);
;;;1349     }
;;;1350     /* FMC_Bank5_6 SDRAM*/
;;;1351     else
;;;1352     {
;;;1353       FMC_Bank5_6->SDRTR |= FMC_SDRTR_CRE;
000014  f8d20154          LDR      r0,[r2,#0x154]
000018  f0400001          ORR      r0,r0,#1
00001c  f8c20154          STR      r0,[r2,#0x154]
;;;1354     }
;;;1355   }
000020  4770              BX       lr
                  |L2.34|
000022  6e50              LDR      r0,[r2,#0x64]         ;1340
000024  ea2000d1          BIC      r0,r0,r1,LSR #3       ;1340
000028  6650              STR      r0,[r2,#0x64]         ;1340
00002a  4770              BX       lr
                  |L2.44|
00002c  f8d20084          LDR      r0,[r2,#0x84]         ;1344
000030  ea2000d1          BIC      r0,r0,r1,LSR #3       ;1344
000034  f8c20084          STR      r0,[r2,#0x84]         ;1344
000038  4770              BX       lr
                  |L2.58|
00003a  f8d200a4          LDR      r0,[r2,#0xa4]         ;1348
00003e  ea2000d1          BIC      r0,r0,r1,LSR #3       ;1348
000042  f8c200a4          STR      r0,[r2,#0xa4]         ;1348
000046  4770              BX       lr
;;;1356   
                          ENDP


                          AREA ||i.FMC_GetECC||, CODE, READONLY, ALIGN=1

                  FMC_GetECC PROC
;;;578      */
;;;579    uint32_t FMC_GetECC(uint32_t FMC_Bank)
000000  f04f4120          MOV      r1,#0xa0000000
;;;580    {
;;;581      uint32_t eccval = 0x00000000;
;;;582      
;;;583      if(FMC_Bank == FMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
;;;584      {
;;;585        /* Get the ECCR2 register value */
;;;586        eccval = FMC_Bank2->ECCR2;
000006  bf0c              ITE      EQ
000008  6f48              LDREQ    r0,[r1,#0x74]
;;;587      }
;;;588      else
;;;589      {
;;;590        /* Get the ECCR3 register value */
;;;591        eccval = FMC_Bank3->ECCR3;
00000a  f8d10094          LDRNE    r0,[r1,#0x94]
;;;592      }
;;;593      /* Return the error correction code value */
;;;594      return(eccval);
;;;595    }
00000e  4770              BX       lr
;;;596    /**
                          ENDP


                          AREA ||i.FMC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  FMC_GetFlagStatus PROC
;;;1160     */
;;;1161   FlagStatus FMC_GetFlagStatus(uint32_t FMC_Bank, uint32_t FMC_FLAG)
000000  2300              MOVS     r3,#0
;;;1162   {
;;;1163     FlagStatus bitstatus = RESET;
;;;1164     uint32_t tmpsr = 0x00000000;
;;;1165     
;;;1166     /* Check the parameters */
;;;1167     assert_param(IS_FMC_GETFLAG_BANK(FMC_Bank));
;;;1168     assert_param(IS_FMC_GET_FLAG(FMC_FLAG));
;;;1169     
;;;1170     if(FMC_Bank == FMC_Bank2_NAND)
;;;1171     {
;;;1172       tmpsr = FMC_Bank2->SR2;
000002  f04f4220          MOV      r2,#0xa0000000
000006  2810              CMP      r0,#0x10              ;1170
000008  bf08              IT       EQ
00000a  6e50              LDREQ    r0,[r2,#0x64]
00000c  d00c              BEQ      |L4.40|
;;;1173     }  
;;;1174     else if(FMC_Bank == FMC_Bank3_NAND)
00000e  f5b07f80          CMP      r0,#0x100
;;;1175     {
;;;1176       tmpsr = FMC_Bank3->SR3;
000012  bf08              IT       EQ
000014  f8d20084          LDREQ    r0,[r2,#0x84]
000018  d006              BEQ      |L4.40|
;;;1177     }
;;;1178     else if(FMC_Bank == FMC_Bank4_PCCARD)
00001a  f5b05f80          CMP      r0,#0x1000
;;;1179     {
;;;1180       tmpsr = FMC_Bank4->SR4;
00001e  bf0c              ITE      EQ
000020  f8d200a4          LDREQ    r0,[r2,#0xa4]
;;;1181     }
;;;1182     else 
;;;1183     {
;;;1184       tmpsr = FMC_Bank5_6->SDSR;
000024  f8d20158          LDRNE    r0,[r2,#0x158]
                  |L4.40|
;;;1185     }
;;;1186     
;;;1187     /* Get the flag status */
;;;1188     if ((tmpsr & FMC_FLAG) != FMC_FLAG )
000028  ea310000          BICS     r0,r1,r0
;;;1189     {
;;;1190       bitstatus = RESET;
;;;1191     }
;;;1192     else
;;;1193     {
;;;1194       bitstatus = SET;
00002c  bf08              IT       EQ
00002e  2301              MOVEQ    r3,#1
;;;1195     }
;;;1196     /* Return the flag status */
;;;1197     return bitstatus;
000030  4618              MOV      r0,r3
;;;1198   }
000032  4770              BX       lr
;;;1199   
                          ENDP


                          AREA ||i.FMC_GetITStatus||, CODE, READONLY, ALIGN=1

                  FMC_GetITStatus PROC
;;;1259     */
;;;1260   ITStatus FMC_GetITStatus(uint32_t FMC_Bank, uint32_t FMC_IT)
000000  b410              PUSH     {r4}
;;;1261   {
;;;1262     ITStatus bitstatus = RESET;
000002  2400              MOVS     r4,#0
;;;1263     uint32_t tmpsr = 0x0;
;;;1264     uint32_t tmpsr2 = 0x0;
000004  4623              MOV      r3,r4
;;;1265     uint32_t itstatus = 0x0;
;;;1266     uint32_t itenable = 0x0; 
;;;1267     
;;;1268     /* Check the parameters */
;;;1269     assert_param(IS_FMC_IT_BANK(FMC_Bank));
;;;1270     assert_param(IS_FMC_GET_IT(FMC_IT));
;;;1271     
;;;1272     if(FMC_Bank == FMC_Bank2_NAND)
;;;1273     {
;;;1274       tmpsr = FMC_Bank2->SR2;
000006  f04f4c20          MOV      r12,#0xa0000000
00000a  2810              CMP      r0,#0x10              ;1272
00000c  bf08              IT       EQ
00000e  f8dc2064          LDREQ    r2,[r12,#0x64]
000012  d00e              BEQ      |L5.50|
;;;1275     }  
;;;1276     else if(FMC_Bank == FMC_Bank3_NAND)
000014  f5b07f80          CMP      r0,#0x100
;;;1277     {
;;;1278       tmpsr = FMC_Bank3->SR3;
000018  bf08              IT       EQ
00001a  f8dc2084          LDREQ    r2,[r12,#0x84]
00001e  d008              BEQ      |L5.50|
;;;1279     }
;;;1280     else if(FMC_Bank == FMC_Bank4_PCCARD)
000020  f5b05f80          CMP      r0,#0x1000
;;;1281     {
;;;1282       tmpsr = FMC_Bank4->SR4;
000024  bf0e              ITEE     EQ
000026  f8dc20a4          LDREQ    r2,[r12,#0xa4]
;;;1283     }
;;;1284     /* FMC_Bank5_6 SDRAM*/
;;;1285     else
;;;1286     {
;;;1287       tmpsr = FMC_Bank5_6->SDRTR;
00002a  f8dc2154          LDRNE    r2,[r12,#0x154]
;;;1288       tmpsr2 = FMC_Bank5_6->SDSR;
00002e  f8dc3158          LDRNE    r3,[r12,#0x158]
                  |L5.50|
;;;1289     } 
;;;1290     
;;;1291     /* get the IT enable bit status*/
;;;1292     itenable = tmpsr & FMC_IT;
000032  ea020c01          AND      r12,r2,r1
;;;1293     
;;;1294     /* get the corresponding IT Flag status*/
;;;1295     if((FMC_Bank == FMC_Bank1_SDRAM) || (FMC_Bank == FMC_Bank2_SDRAM))
000036  2800              CMP      r0,#0
000038  bf16              ITET     NE
00003a  2801              CMPNE    r0,#1
;;;1296     {
;;;1297       itstatus = tmpsr2 & FMC_SDSR_RE;  
00003c  f0030001          ANDEQ    r0,r3,#1
;;;1298     }           
;;;1299     else
;;;1300     {
;;;1301       itstatus = tmpsr & (FMC_IT >> 3);  
000040  ea0200d1          ANDNE    r0,r2,r1,LSR #3
;;;1302     }  
;;;1303     
;;;1304     if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
000044  2800              CMP      r0,#0
000046  bf1c              ITT      NE
000048  f1bc0f00          CMPNE    r12,#0
;;;1305     {
;;;1306       bitstatus = SET;
00004c  2401              MOVNE    r4,#1
;;;1307     }
;;;1308     else
;;;1309     {
;;;1310       bitstatus = RESET;
;;;1311     }
;;;1312     return bitstatus; 
00004e  4620              MOV      r0,r4
;;;1313   }
000050  bc10              POP      {r4}
000052  4770              BX       lr
;;;1314   
                          ENDP


                          AREA ||i.FMC_GetModeStatus||, CODE, READONLY, ALIGN=1

                  FMC_GetModeStatus PROC
;;;975      */
;;;976    uint32_t FMC_GetModeStatus(uint32_t SDRAM_Bank)
000000  f04f4120          MOV      r1,#0xa0000000
;;;977    {
;;;978      uint32_t tmpreg = 0;
;;;979      
;;;980      /* Check the parameter */
;;;981      assert_param(IS_FMC_SDRAM_BANK(SDRAM_Bank));
;;;982    
;;;983      /* Get the busy flag status */
;;;984      if(SDRAM_Bank == FMC_Bank1_SDRAM)
000004  2800              CMP      r0,#0
;;;985      {
;;;986        tmpreg = (uint32_t)(FMC_Bank5_6->SDSR & FMC_SDSR_MODES1); 
;;;987      }
;;;988      else
;;;989      {
;;;990        tmpreg = ((uint32_t)(FMC_Bank5_6->SDSR & FMC_SDSR_MODES2) >> 2);
000006  f8d10158          LDR      r0,[r1,#0x158]
00000a  bf0e              ITEE     EQ                    ;986
00000c  f0000006          ANDEQ    r0,r0,#6              ;986
000010  f0000018          ANDNE    r0,r0,#0x18
000014  0880              LSRNE    r0,r0,#2
;;;991      }
;;;992      
;;;993      /* Return the mode status */
;;;994      return tmpreg;
;;;995    }
000016  4770              BX       lr
;;;996    
                          ENDP


                          AREA ||i.FMC_ITConfig||, CODE, READONLY, ALIGN=1

                  FMC_ITConfig PROC
;;;1083     */
;;;1084   void FMC_ITConfig(uint32_t FMC_Bank, uint32_t FMC_IT, FunctionalState NewState)
000000  f04f4320          MOV      r3,#0xa0000000
;;;1085   {
000004  b1c2              CBZ      r2,|L7.56|
;;;1086     assert_param(IS_FMC_IT_BANK(FMC_Bank));
;;;1087     assert_param(IS_FMC_IT(FMC_IT));	
;;;1088     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1089     
;;;1090     if (NewState != DISABLE)
;;;1091     {
;;;1092       /* Enable the selected FMC_Bank2 interrupts */
;;;1093       if(FMC_Bank == FMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
;;;1094       {
;;;1095         FMC_Bank2->SR2 |= FMC_IT;
000008  bf04              ITT      EQ
00000a  6e58              LDREQ    r0,[r3,#0x64]
00000c  4308              ORREQ    r0,r0,r1
00000e  d02c              BEQ      |L7.106|
;;;1096       }
;;;1097       /* Enable the selected FMC_Bank3 interrupts */
;;;1098       else if (FMC_Bank == FMC_Bank3_NAND)
000010  f5b07f80          CMP      r0,#0x100
;;;1099       {
;;;1100         FMC_Bank3->SR3 |= FMC_IT;
000014  bf04              ITT      EQ
000016  f8d30084          LDREQ    r0,[r3,#0x84]
00001a  4308              ORREQ    r0,r0,r1
00001c  d027              BEQ      |L7.110|
;;;1101       }
;;;1102       /* Enable the selected FMC_Bank4 interrupts */
;;;1103       else if (FMC_Bank == FMC_Bank4_PCCARD)
00001e  f5b05f80          CMP      r0,#0x1000
;;;1104       {
;;;1105         FMC_Bank4->SR4 |= FMC_IT;    
000022  bf0c              ITE      EQ
000024  f8d300a4          LDREQ    r0,[r3,#0xa4]
;;;1106       }
;;;1107       /* Enable the selected FMC_Bank5_6 interrupt */
;;;1108       else
;;;1109       {
;;;1110         /* Enables the interrupt if the refresh error flag is set */
;;;1111         FMC_Bank5_6->SDRTR |= FMC_IT; 
000028  f8d30154          LDRNE    r0,[r3,#0x154]
00002c  ea400001          ORR      r0,r0,r1
000030  d018              BEQ      |L7.100|
                  |L7.50|
000032  f8c30154          STR      r0,[r3,#0x154]
;;;1112       }
;;;1113     }
;;;1114     else
;;;1115     {
;;;1116       /* Disable the selected FMC_Bank2 interrupts */
;;;1117       if(FMC_Bank == FMC_Bank2_NAND)
;;;1118       {
;;;1119         
;;;1120         FMC_Bank2->SR2 &= (uint32_t)~FMC_IT;
;;;1121       }
;;;1122       /* Disable the selected FMC_Bank3 interrupts */
;;;1123       else if (FMC_Bank == FMC_Bank3_NAND)
;;;1124       {
;;;1125         FMC_Bank3->SR3 &= (uint32_t)~FMC_IT;
;;;1126       }
;;;1127       /* Disable the selected FMC_Bank4 interrupts */
;;;1128       else if(FMC_Bank == FMC_Bank4_PCCARD)
;;;1129       {
;;;1130         FMC_Bank4->SR4 &= (uint32_t)~FMC_IT;    
;;;1131       }
;;;1132       /* Disable the selected FMC_Bank5_6 interrupt */
;;;1133       else
;;;1134       {
;;;1135         /* Disables the interrupt if the refresh error flag is not set */
;;;1136         FMC_Bank5_6->SDRTR &= (uint32_t)~FMC_IT; 
;;;1137       }
;;;1138     }
;;;1139   }
000036  4770              BX       lr
                  |L7.56|
000038  2810              CMP      r0,#0x10              ;1117
00003a  bf04              ITT      EQ                    ;1120
00003c  6e58              LDREQ    r0,[r3,#0x64]         ;1120
00003e  4388              BICEQ    r0,r0,r1              ;1120
000040  d013              BEQ      |L7.106|
000042  f5b07f80          CMP      r0,#0x100             ;1123
000046  bf04              ITT      EQ                    ;1125
000048  f8d30084          LDREQ    r0,[r3,#0x84]         ;1125
00004c  4388              BICEQ    r0,r0,r1              ;1125
00004e  d00e              BEQ      |L7.110|
000050  f5b05f80          CMP      r0,#0x1000            ;1128
000054  bf0c              ITE      EQ                    ;1130
000056  f8d300a4          LDREQ    r0,[r3,#0xa4]         ;1130
00005a  f8d30154          LDRNE    r0,[r3,#0x154]        ;1136
00005e  ea200001          BIC      r0,r0,r1              ;1136
000062  d1e6              BNE      |L7.50|
                  |L7.100|
000064  f8c300a4          STR      r0,[r3,#0xa4]         ;1105
000068  4770              BX       lr
                  |L7.106|
00006a  6658              STR      r0,[r3,#0x64]         ;1095
00006c  4770              BX       lr
                  |L7.110|
00006e  f8c30084          STR      r0,[r3,#0x84]         ;1100
000072  4770              BX       lr
;;;1140   
                          ENDP


                          AREA ||i.FMC_NANDCmd||, CODE, READONLY, ALIGN=2

                  FMC_NANDCmd PROC
;;;499      */
;;;500    void FMC_NANDCmd(uint32_t FMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;501    {
000004  b151              CBZ      r1,|L8.28|
;;;502      assert_param(IS_FMC_NAND_BANK(FMC_Bank));
;;;503      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;504      
;;;505      if (NewState != DISABLE)
;;;506      {
;;;507        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;508        if(FMC_Bank == FMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
;;;509        {
;;;510          FMC_Bank2->PCR2 |= PCR_PBKEN_SET;
000008  bf0c              ITE      EQ
00000a  6e10              LDREQ    r0,[r2,#0x60]
;;;511        }
;;;512        else
;;;513        {
;;;514          FMC_Bank3->PCR3 |= PCR_PBKEN_SET;
00000c  f8d20080          LDRNE    r0,[r2,#0x80]
000010  f0400004          ORR      r0,r0,#4
000014  d00b              BEQ      |L8.46|
                  |L8.22|
000016  f8c20080          STR      r0,[r2,#0x80]
;;;515        }
;;;516      }
;;;517      else
;;;518      {
;;;519        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;520        if(FMC_Bank == FMC_Bank2_NAND)
;;;521        {
;;;522          FMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
;;;523        }
;;;524        else
;;;525        {
;;;526          FMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
;;;527        }
;;;528      }
;;;529    }
00001a  4770              BX       lr
                  |L8.28|
00001c  4905              LDR      r1,|L8.52|
00001e  2810              CMP      r0,#0x10              ;520
000020  bf14              ITE      NE                    ;526
000022  f8d20080          LDRNE    r0,[r2,#0x80]         ;526
000026  6e10              LDREQ    r0,[r2,#0x60]         ;522
000028  ea000001          AND      r0,r0,r1              ;522
00002c  d1f3              BNE      |L8.22|
                  |L8.46|
00002e  6610              STR      r0,[r2,#0x60]         ;510
000030  4770              BX       lr
;;;530    /**
                          ENDP

000032  0000              DCW      0x0000
                  |L8.52|
                          DCD      0x000ffffb

                          AREA ||i.FMC_NANDDeInit||, CODE, READONLY, ALIGN=1

                  FMC_NANDDeInit PROC
;;;374      */
;;;375    void FMC_NANDDeInit(uint32_t FMC_Bank)
000000  2340              MOVS     r3,#0x40
;;;376    {
;;;377      /* Check the parameter */
;;;378      assert_param(IS_FMC_NAND_BANK(FMC_Bank));
;;;379      
;;;380      if(FMC_Bank == FMC_Bank2_NAND)
;;;381      {
;;;382        /* Set the FMC_Bank2 registers to their reset values */
;;;383        FMC_Bank2->PCR2 = 0x00000018;
000002  f04f0c18          MOV      r12,#0x18
000006  f04f4120          MOV      r1,#0xa0000000
;;;384        FMC_Bank2->SR2 = 0x00000040;
;;;385        FMC_Bank2->PMEM2 = 0xFCFCFCFC;
00000a  f04f32fc          MOV      r2,#0xfcfcfcfc
00000e  2810              CMP      r0,#0x10              ;380
000010  d008              BEQ      |L9.36|
;;;386        FMC_Bank2->PATT2 = 0xFCFCFCFC;  
;;;387      }
;;;388      /* FMC_Bank3_NAND */  
;;;389      else
;;;390      {
;;;391        /* Set the FMC_Bank3 registers to their reset values */
;;;392        FMC_Bank3->PCR3 = 0x00000018;
000012  f8c1c080          STR      r12,[r1,#0x80]
;;;393        FMC_Bank3->SR3 = 0x00000040;
000016  f8c13084          STR      r3,[r1,#0x84]
;;;394        FMC_Bank3->PMEM3 = 0xFCFCFCFC;
00001a  f8c12088          STR      r2,[r1,#0x88]
;;;395        FMC_Bank3->PATT3 = 0xFCFCFCFC; 
00001e  f8c1208c          STR      r2,[r1,#0x8c]
;;;396      }  
;;;397    }
000022  4770              BX       lr
                  |L9.36|
000024  f8c1c060          STR      r12,[r1,#0x60]        ;383
000028  664b              STR      r3,[r1,#0x64]         ;384
00002a  668a              STR      r2,[r1,#0x68]         ;385
00002c  66ca              STR      r2,[r1,#0x6c]         ;386
00002e  4770              BX       lr
;;;398    
                          ENDP


                          AREA ||i.FMC_NANDECCCmd||, CODE, READONLY, ALIGN=2

                  FMC_NANDECCCmd PROC
;;;539      */
;;;540    void FMC_NANDECCCmd(uint32_t FMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;541    {
000004  b151              CBZ      r1,|L10.28|
;;;542      assert_param(IS_FMC_NAND_BANK(FMC_Bank));
;;;543      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;544      
;;;545      if (NewState != DISABLE)
;;;546      {
;;;547        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;548        if(FMC_Bank == FMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
;;;549        {
;;;550          FMC_Bank2->PCR2 |= PCR_ECCEN_SET;
000008  bf0c              ITE      EQ
00000a  6e10              LDREQ    r0,[r2,#0x60]
;;;551        }
;;;552        else
;;;553        {
;;;554          FMC_Bank3->PCR3 |= PCR_ECCEN_SET;
00000c  f8d20080          LDRNE    r0,[r2,#0x80]
000010  f0400040          ORR      r0,r0,#0x40
000014  d00b              BEQ      |L10.46|
                  |L10.22|
000016  f8c20080          STR      r0,[r2,#0x80]
;;;555        }
;;;556      }
;;;557      else
;;;558      {
;;;559        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;560        if(FMC_Bank == FMC_Bank2_NAND)
;;;561        {
;;;562          FMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
;;;563        }
;;;564        else
;;;565        {
;;;566          FMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
;;;567        }
;;;568      }
;;;569    }
00001a  4770              BX       lr
                  |L10.28|
00001c  4905              LDR      r1,|L10.52|
00001e  2810              CMP      r0,#0x10              ;560
000020  bf14              ITE      NE                    ;566
000022  f8d20080          LDRNE    r0,[r2,#0x80]         ;566
000026  6e10              LDREQ    r0,[r2,#0x60]         ;562
000028  ea000001          AND      r0,r0,r1              ;562
00002c  d1f3              BNE      |L10.22|
                  |L10.46|
00002e  6610              STR      r0,[r2,#0x60]         ;550
000030  4770              BX       lr
;;;570    
                          ENDP

000032  0000              DCW      0x0000
                  |L10.52|
                          DCD      0x000fffbf

                          AREA ||i.FMC_NANDInit||, CODE, READONLY, ALIGN=1

                  FMC_NANDInit PROC
;;;405      */
;;;406    void FMC_NANDInit(FMC_NANDInitTypeDef* FMC_NANDInitStruct)
000000  b410              PUSH     {r4}
;;;407    {
000002  e9d01201          LDRD     r1,r2,[r0,#4]
;;;408      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
;;;409        
;;;410      /* Check the parameters */
;;;411      assert_param(IS_FMC_NAND_BANK(FMC_NANDInitStruct->FMC_Bank));
;;;412      assert_param(IS_FMC_WAIT_FEATURE(FMC_NANDInitStruct->FMC_Waitfeature));
;;;413      assert_param(IS_FMC_NAND_MEMORY_WIDTH(FMC_NANDInitStruct->FMC_MemoryDataWidth));
;;;414      assert_param(IS_FMC_ECC_STATE(FMC_NANDInitStruct->FMC_ECC));
;;;415      assert_param(IS_FMC_ECCPAGE_SIZE(FMC_NANDInitStruct->FMC_ECCPageSize));
;;;416      assert_param(IS_FMC_TCLR_TIME(FMC_NANDInitStruct->FMC_TCLRSetupTime));
;;;417      assert_param(IS_FMC_TAR_TIME(FMC_NANDInitStruct->FMC_TARSetupTime));
;;;418      assert_param(IS_FMC_SETUP_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime));
;;;419      assert_param(IS_FMC_WAIT_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime));
;;;420      assert_param(IS_FMC_HOLD_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime));
;;;421      assert_param(IS_FMC_HIZ_TIME(FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime));
;;;422      assert_param(IS_FMC_SETUP_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime));
;;;423      assert_param(IS_FMC_WAIT_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime));
;;;424      assert_param(IS_FMC_HOLD_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime));
;;;425      assert_param(IS_FMC_HIZ_TIME(FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime));
;;;426      
;;;427      /* Set the tmppcr value according to FMC_NANDInitStruct parameters */
;;;428      tmppcr = (uint32_t)FMC_NANDInitStruct->FMC_Waitfeature |
000006  4311              ORRS     r1,r1,r2
000008  e9d02303          LDRD     r2,r3,[r0,#0xc]
00000c  431a              ORRS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6942              LDR      r2,[r0,#0x14]
000012  ea412142          ORR      r1,r1,r2,LSL #9
000016  6982              LDR      r2,[r0,#0x18]
000018  ea413142          ORR      r1,r1,r2,LSL #13
00001c  f0410208          ORR      r2,r1,#8
;;;429                PCR_MEMORYTYPE_NAND |
;;;430                FMC_NANDInitStruct->FMC_MemoryDataWidth |
;;;431                FMC_NANDInitStruct->FMC_ECC |
;;;432                FMC_NANDInitStruct->FMC_ECCPageSize |
;;;433                (FMC_NANDInitStruct->FMC_TCLRSetupTime << 9 )|
;;;434                (FMC_NANDInitStruct->FMC_TARSetupTime << 13);
;;;435                
;;;436      /* Set tmppmem value according to FMC_CommonSpaceTimingStructure parameters */
;;;437      tmppmem = (uint32_t)FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime |
000020  69c1              LDR      r1,[r0,#0x1c]
000022  e9d1c300          LDRD     r12,r3,[r1,#0]
000026  ea4c2303          ORR      r3,r12,r3,LSL #8
00002a  f8b1c008          LDRH     r12,[r1,#8]
00002e  7b09              LDRB     r1,[r1,#0xc]
000030  ea4f4c0c          LSL      r12,r12,#16
000034  ea4c6101          ORR      r1,r12,r1,LSL #24
000038  430b              ORRS     r3,r3,r1
;;;438                (FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime << 8) |
;;;439                (FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime << 16)|
;;;440                (FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime << 24); 
;;;441                
;;;442      /* Set tmppatt value according to FMC_AttributeSpaceTimingStructure parameters */
;;;443      tmppatt = (uint32_t)FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime |
00003a  6a01              LDR      r1,[r0,#0x20]
00003c  e9d1c400          LDRD     r12,r4,[r1,#0]
000040  ea4c2c04          ORR      r12,r12,r4,LSL #8
000044  890c              LDRH     r4,[r1,#8]
000046  7b09              LDRB     r1,[r1,#0xc]
000048  0424              LSLS     r4,r4,#16
00004a  ea446101          ORR      r1,r4,r1,LSL #24
00004e  ea4c0101          ORR      r1,r12,r1
;;;444                (FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime << 8) |
;;;445                (FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime << 16)|
;;;446                (FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime << 24);
;;;447      
;;;448      if(FMC_NANDInitStruct->FMC_Bank == FMC_Bank2_NAND)
;;;449      {
;;;450        /* FMC_Bank2_NAND registers configuration */
;;;451        FMC_Bank2->PCR2 = tmppcr;
000052  f8d0c000          LDR      r12,[r0,#0]
000056  f04f4020          MOV      r0,#0xa0000000
00005a  f1bc0f10          CMP      r12,#0x10             ;448
00005e  d007              BEQ      |L11.112|
;;;452        FMC_Bank2->PMEM2 = tmppmem;
;;;453        FMC_Bank2->PATT2 = tmppatt;
;;;454      }
;;;455      else
;;;456      {
;;;457        /* FMC_Bank3_NAND registers configuration */
;;;458        FMC_Bank3->PCR3 = tmppcr;
000060  f8c02080          STR      r2,[r0,#0x80]
;;;459        FMC_Bank3->PMEM3 = tmppmem;
000064  f8c03088          STR      r3,[r0,#0x88]
;;;460        FMC_Bank3->PATT3 = tmppatt;
000068  f8c0108c          STR      r1,[r0,#0x8c]
;;;461      }
;;;462    }
00006c  bc10              POP      {r4}
00006e  4770              BX       lr
                  |L11.112|
000070  6602              STR      r2,[r0,#0x60]         ;451
000072  6683              STR      r3,[r0,#0x68]         ;452
000074  66c1              STR      r1,[r0,#0x6c]         ;453
000076  bc10              POP      {r4}
000078  4770              BX       lr
;;;463    
                          ENDP


                          AREA ||i.FMC_NANDStructInit||, CODE, READONLY, ALIGN=1

                  FMC_NANDStructInit PROC
;;;470      */
;;;471    void FMC_NANDStructInit(FMC_NANDInitTypeDef* FMC_NANDInitStruct)
000000  2210              MOVS     r2,#0x10
;;;472    { 
;;;473      /* Reset NAND Init structure parameters values */
;;;474      FMC_NANDInitStruct->FMC_Bank = FMC_Bank2_NAND;
;;;475      FMC_NANDInitStruct->FMC_Waitfeature = FMC_Waitfeature_Disable;
000002  2100              MOVS     r1,#0
000004  e9c02100          STRD     r2,r1,[r0,#0]
000008  e9c02102          STRD     r2,r1,[r0,#8]
;;;476      FMC_NANDInitStruct->FMC_MemoryDataWidth = FMC_NAND_MemoryDataWidth_16b;
;;;477      FMC_NANDInitStruct->FMC_ECC = FMC_ECC_Disable;
;;;478      FMC_NANDInitStruct->FMC_ECCPageSize = FMC_ECCPageSize_256Bytes;
;;;479      FMC_NANDInitStruct->FMC_TCLRSetupTime = 0x0;
00000c  6101              STR      r1,[r0,#0x10]
;;;480      FMC_NANDInitStruct->FMC_TARSetupTime = 0x0;
00000e  6141              STR      r1,[r0,#0x14]
;;;481      FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime = 252;
000010  6181              STR      r1,[r0,#0x18]
000012  69c2              LDR      r2,[r0,#0x1c]
000014  21fc              MOVS     r1,#0xfc
;;;482      FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime = 252;
000016  6011              STR      r1,[r2,#0]
000018  69c2              LDR      r2,[r0,#0x1c]
;;;483      FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime = 252;
00001a  6051              STR      r1,[r2,#4]
00001c  69c2              LDR      r2,[r0,#0x1c]
;;;484      FMC_NANDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime = 252;
00001e  6091              STR      r1,[r2,#8]
000020  69c2              LDR      r2,[r0,#0x1c]
;;;485      FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime = 252;
000022  60d1              STR      r1,[r2,#0xc]
000024  6a02              LDR      r2,[r0,#0x20]
;;;486      FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime = 252;
000026  6011              STR      r1,[r2,#0]
000028  6a02              LDR      r2,[r0,#0x20]
;;;487      FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime = 252;
00002a  6051              STR      r1,[r2,#4]
00002c  6a02              LDR      r2,[r0,#0x20]
;;;488      FMC_NANDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime = 252;	  
00002e  6091              STR      r1,[r2,#8]
000030  6a00              LDR      r0,[r0,#0x20]
000032  60c1              STR      r1,[r0,#0xc]
;;;489    }
000034  4770              BX       lr
;;;490    
                          ENDP


                          AREA ||i.FMC_NORSRAMCmd||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAMCmd PROC
;;;301      */
;;;302    void FMC_NORSRAMCmd(uint32_t FMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;303    {
;;;304      assert_param(IS_FMC_NORSRAM_BANK(FMC_Bank));
;;;305      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;306      
;;;307      if (NewState != DISABLE)
;;;308      {
;;;309        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;310        FMC_Bank1->BTCR[FMC_Bank] |= BCR_MBKEN_SET;
000004  eb020080          ADD      r0,r2,r0,LSL #2
000008  2900              CMP      r1,#0                 ;307
;;;311      }
;;;312      else
;;;313      {
;;;314        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;315        FMC_Bank1->BTCR[FMC_Bank] &= BCR_MBKEN_RESET;
00000a  6801              LDR      r1,[r0,#0]
00000c  bf12              ITEE     NE                    ;310
00000e  f0410101          ORRNE    r1,r1,#1              ;310
000012  4a02              LDREQ    r2,|L13.28|
000014  4011              ANDEQ    r1,r1,r2
000016  6001              STR      r1,[r0,#0]            ;310
;;;316      }
;;;317    }
000018  4770              BX       lr
;;;318    /**
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x000ffffe

                          AREA ||i.FMC_NORSRAMDeInit||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAMDeInit PROC
;;;129      */
;;;130    void FMC_NORSRAMDeInit(uint32_t FMC_Bank)
000000  f04f4220          MOV      r2,#0xa0000000
;;;131    {
;;;132      /* Check the parameter */
;;;133      assert_param(IS_FMC_NORSRAM_BANK(FMC_Bank));
;;;134      
;;;135      /* FMC_Bank1_NORSRAM1 */
;;;136      if(FMC_Bank == FMC_Bank1_NORSRAM1)
;;;137      {
;;;138        FMC_Bank1->BTCR[FMC_Bank] = 0x000030DB;    
;;;139      }
;;;140      /* FMC_Bank1_NORSRAM2,  FMC_Bank1_NORSRAM3 or FMC_Bank1_NORSRAM4 */
;;;141      else
;;;142      {   
;;;143        FMC_Bank1->BTCR[FMC_Bank] = 0x000030D2; 
000004  eb020180          ADD      r1,r2,r0,LSL #2
000008  2800              CMP      r0,#0                 ;136
00000a  bf07              ITTEE    EQ                    ;138
00000c  f24300db          MOVEQ    r0,#0x30db            ;138
000010  6010              STREQ    r0,[r2,#0]            ;138
000012  f24300d2          MOVNE    r0,#0x30d2
000016  6008              STRNE    r0,[r1,#0]
;;;144      }
;;;145      FMC_Bank1->BTCR[FMC_Bank + 1] = 0x0FFFFFFF;
000018  f06f4070          MVN      r0,#0xf0000000
00001c  6048              STR      r0,[r1,#4]
;;;146      FMC_Bank1E->BWTR[FMC_Bank] = 0x0FFFFFFF;  
00001e  f8c10104          STR      r0,[r1,#0x104]
;;;147    }
000022  4770              BX       lr
;;;148    
                          ENDP


                          AREA ||i.FMC_NORSRAMInit||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAMInit PROC
;;;156      */
;;;157    void FMC_NORSRAMInit(FMC_NORSRAMInitTypeDef* FMC_NORSRAMInitStruct)
000000  b410              PUSH     {r4}
;;;158    {
000002  e9d01201          LDRD     r1,r2,[r0,#4]
;;;159      uint32_t tmpr = 0;
;;;160      
;;;161      /* Check the parameters */
;;;162      assert_param(IS_FMC_NORSRAM_BANK(FMC_NORSRAMInitStruct->FMC_Bank));
;;;163      assert_param(IS_FMC_MUX(FMC_NORSRAMInitStruct->FMC_DataAddressMux));
;;;164      assert_param(IS_FMC_MEMORY(FMC_NORSRAMInitStruct->FMC_MemoryType));
;;;165      assert_param(IS_FMC_NORSRAM_MEMORY_WIDTH(FMC_NORSRAMInitStruct->FMC_MemoryDataWidth));
;;;166      assert_param(IS_FMC_BURSTMODE(FMC_NORSRAMInitStruct->FMC_BurstAccessMode));
;;;167      assert_param(IS_FMC_WAIT_POLARITY(FMC_NORSRAMInitStruct->FMC_WaitSignalPolarity));
;;;168      assert_param(IS_FMC_WRAP_MODE(FMC_NORSRAMInitStruct->FMC_WrapMode));
;;;169      assert_param(IS_FMC_WAIT_SIGNAL_ACTIVE(FMC_NORSRAMInitStruct->FMC_WaitSignalActive));
;;;170      assert_param(IS_FMC_WRITE_OPERATION(FMC_NORSRAMInitStruct->FMC_WriteOperation));
;;;171      assert_param(IS_FMC_WAITE_SIGNAL(FMC_NORSRAMInitStruct->FMC_WaitSignal));
;;;172      assert_param(IS_FMC_EXTENDED_MODE(FMC_NORSRAMInitStruct->FMC_ExtendedMode));
;;;173      assert_param(IS_FMC_ASYNWAIT(FMC_NORSRAMInitStruct->FMC_AsynchronousWait));
;;;174      assert_param(IS_FMC_WRITE_BURST(FMC_NORSRAMInitStruct->FMC_WriteBurst));
;;;175      assert_param(IS_FMC_CONTINOUS_CLOCK(FMC_NORSRAMInitStruct->FMC_ContinousClock));  
;;;176      assert_param(IS_FMC_ADDRESS_SETUP_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressSetupTime));
;;;177      assert_param(IS_FMC_ADDRESS_HOLD_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressHoldTime));
;;;178      assert_param(IS_FMC_DATASETUP_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataSetupTime));
;;;179      assert_param(IS_FMC_TURNAROUND_TIME(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_BusTurnAroundDuration));
;;;180      assert_param(IS_FMC_CLK_DIV(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision));
;;;181      assert_param(IS_FMC_DATA_LATENCY(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataLatency));
;;;182      assert_param(IS_FMC_ACCESS_MODE(FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AccessMode)); 
;;;183      
;;;184      /* NOR/SRAM Bank control register configuration */ 
;;;185      FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank] =   
000006  4311              ORRS     r1,r1,r2
000008  e9d02303          LDRD     r2,r3,[r0,#0xc]
00000c  431a              ORRS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6942              LDR      r2,[r0,#0x14]
000012  6803              LDR      r3,[r0,#0]
000014  4311              ORRS     r1,r1,r2
000016  6982              LDR      r2,[r0,#0x18]
000018  4311              ORRS     r1,r1,r2
00001a  69c2              LDR      r2,[r0,#0x1c]
00001c  4311              ORRS     r1,r1,r2
00001e  6a02              LDR      r2,[r0,#0x20]
000020  4311              ORRS     r1,r1,r2
000022  6a42              LDR      r2,[r0,#0x24]
000024  4311              ORRS     r1,r1,r2
000026  6a82              LDR      r2,[r0,#0x28]
000028  4311              ORRS     r1,r1,r2
00002a  6ac2              LDR      r2,[r0,#0x2c]
00002c  4311              ORRS     r1,r1,r2
00002e  6b02              LDR      r2,[r0,#0x30]
000030  4311              ORRS     r1,r1,r2
000032  6b42              LDR      r2,[r0,#0x34]
000034  4311              ORRS     r1,r1,r2
000036  f04f4220          MOV      r2,#0xa0000000
00003a  f8421023          STR      r1,[r2,r3,LSL #2]
;;;186                (uint32_t)FMC_NORSRAMInitStruct->FMC_DataAddressMux |
;;;187                FMC_NORSRAMInitStruct->FMC_MemoryType |
;;;188                FMC_NORSRAMInitStruct->FMC_MemoryDataWidth |
;;;189                FMC_NORSRAMInitStruct->FMC_BurstAccessMode |
;;;190                FMC_NORSRAMInitStruct->FMC_WaitSignalPolarity |
;;;191                FMC_NORSRAMInitStruct->FMC_WrapMode |
;;;192                FMC_NORSRAMInitStruct->FMC_WaitSignalActive |
;;;193                FMC_NORSRAMInitStruct->FMC_WriteOperation |
;;;194                FMC_NORSRAMInitStruct->FMC_WaitSignal |
;;;195                FMC_NORSRAMInitStruct->FMC_ExtendedMode |
;;;196                FMC_NORSRAMInitStruct->FMC_AsynchronousWait |
;;;197                FMC_NORSRAMInitStruct->FMC_WriteBurst |
;;;198                FMC_NORSRAMInitStruct->FMC_ContinousClock;
;;;199    
;;;200                
;;;201      if(FMC_NORSRAMInitStruct->FMC_MemoryType == FMC_MemoryType_NOR)
00003e  6881              LDR      r1,[r0,#8]
000040  2908              CMP      r1,#8
000042  d106              BNE      |L15.82|
;;;202      {
;;;203        FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
000044  6801              LDR      r1,[r0,#0]
000046  eb020181          ADD      r1,r2,r1,LSL #2
00004a  680b              LDR      r3,[r1,#0]
00004c  f0430340          ORR      r3,r3,#0x40
000050  600b              STR      r3,[r1,#0]
                  |L15.82|
;;;204      }
;;;205    
;;;206      /* Configure Continuous clock feature when bank2..4 is used */
;;;207      if((FMC_NORSRAMInitStruct->FMC_ContinousClock == FMC_CClock_SyncAsync) && (FMC_NORSRAMInitStruct->FMC_Bank != FMC_Bank1_NORSRAM1))
000052  6b41              LDR      r1,[r0,#0x34]
000054  f5b11f80          CMP      r1,#0x100000
000058  d114              BNE      |L15.132|
00005a  6801              LDR      r1,[r0,#0]
00005c  b191              CBZ      r1,|L15.132|
;;;208      {
;;;209        tmpr = (uint32_t)((FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1+1]) & ~(((uint32_t)0x0F) << 20));    
00005e  6851              LDR      r1,[r2,#4]
;;;210        
;;;211        FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1]  |= FMC_NORSRAMInitStruct->FMC_ContinousClock;
000060  6813              LDR      r3,[r2,#0]
000062  f4210170          BIC      r1,r1,#0xf00000       ;209
000066  f4431380          ORR      r3,r3,#0x100000
00006a  6013              STR      r3,[r2,#0]
;;;212        FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1]  |= FMC_BurstAccessMode_Enable;
00006c  6813              LDR      r3,[r2,#0]
00006e  f4437380          ORR      r3,r3,#0x100
000072  6013              STR      r3,[r2,#0]
;;;213        FMC_Bank1->BTCR[FMC_Bank1_NORSRAM1+1] = (uint32_t)(tmpr | (((FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision)-1) << 20));
000074  6b83              LDR      r3,[r0,#0x38]
000076  f8dfc094          LDR      r12,|L15.268|
00007a  8a1b              LDRH     r3,[r3,#0x10]
00007c  eb0c5303          ADD      r3,r12,r3,LSL #20
000080  4319              ORRS     r1,r1,r3
000082  6051              STR      r1,[r2,#4]
                  |L15.132|
;;;214      }
;;;215      
;;;216      /* NOR/SRAM Bank timing register configuration */
;;;217      FMC_Bank1->BTCR[FMC_NORSRAMInitStruct->FMC_Bank+1] =   
000084  6b81              LDR      r1,[r0,#0x38]
000086  e9d13c00          LDRD     r3,r12,[r1,#0]
00008a  ea43130c          ORR      r3,r3,r12,LSL #4
00008e  f8d1c008          LDR      r12,[r1,#8]
000092  898c              LDRH     r4,[r1,#0xc]
000094  ea4f2c0c          LSL      r12,r12,#8
000098  ea4c4c04          ORR      r12,r12,r4,LSL #16
00009c  ea43030c          ORR      r3,r3,r12
0000a0  f8b1c010          LDRH     r12,[r1,#0x10]
0000a4  ea43530c          ORR      r3,r3,r12,LSL #20
0000a8  f891c014          LDRB     r12,[r1,#0x14]
0000ac  6989              LDR      r1,[r1,#0x18]
0000ae  ea43630c          ORR      r3,r3,r12,LSL #24
0000b2  4319              ORRS     r1,r1,r3
0000b4  6803              LDR      r3,[r0,#0]
0000b6  eb020383          ADD      r3,r2,r3,LSL #2
0000ba  6059              STR      r1,[r3,#4]
;;;218                (uint32_t)FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressSetupTime |
;;;219                (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressHoldTime << 4) |
;;;220                (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataSetupTime << 8) |
;;;221                (FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_BusTurnAroundDuration << 16) |
;;;222                ((FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision) << 20) |
;;;223                ((FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataLatency) << 24) |
;;;224                 FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AccessMode;
;;;225         
;;;226      /* NOR/SRAM Bank timing register for write configuration, if extended mode is used */
;;;227      if(FMC_NORSRAMInitStruct->FMC_ExtendedMode == FMC_ExtendedMode_Enable)
0000bc  6a81              LDR      r1,[r0,#0x28]
0000be  f5b14f80          CMP      r1,#0x4000
0000c2  d008              BEQ      |L15.214|
;;;228      {
;;;229        assert_param(IS_FMC_ADDRESS_SETUP_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressSetupTime));
;;;230        assert_param(IS_FMC_ADDRESS_HOLD_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressHoldTime));
;;;231        assert_param(IS_FMC_DATASETUP_TIME(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataSetupTime));
;;;232        assert_param(IS_FMC_CLK_DIV(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_CLKDivision));
;;;233        assert_param(IS_FMC_DATA_LATENCY(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataLatency));
;;;234        assert_param(IS_FMC_ACCESS_MODE(FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AccessMode));
;;;235        
;;;236        FMC_Bank1E->BWTR[FMC_NORSRAMInitStruct->FMC_Bank] =   
;;;237                   (uint32_t)FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressSetupTime |
;;;238                   (FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressHoldTime << 4 )|
;;;239                   (FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataSetupTime << 8) |
;;;240                   ((FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_CLKDivision) << 20) |
;;;241                   ((FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataLatency) << 24) |
;;;242                   FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AccessMode;
;;;243      }
;;;244      else
;;;245      {
;;;246        FMC_Bank1E->BWTR[FMC_NORSRAMInitStruct->FMC_Bank] = 0x0FFFFFFF;
0000c4  6800              LDR      r0,[r0,#0]
0000c6  f06f4170          MVN      r1,#0xf0000000
0000ca  eb020080          ADD      r0,r2,r0,LSL #2
0000ce  f8c01104          STR      r1,[r0,#0x104]
;;;247      }
;;;248      
;;;249    }
0000d2  bc10              POP      {r4}
0000d4  4770              BX       lr
                  |L15.214|
0000d6  6bc1              LDR      r1,[r0,#0x3c]         ;236
0000d8  6800              LDR      r0,[r0,#0]            ;236
0000da  e9d13c00          LDRD     r3,r12,[r1,#0]        ;236
0000de  ea43130c          ORR      r3,r3,r12,LSL #4      ;236
0000e2  f8d1c008          LDR      r12,[r1,#8]           ;236
0000e6  8a0c              LDRH     r4,[r1,#0x10]         ;236
0000e8  ea4f2c0c          LSL      r12,r12,#8            ;236
0000ec  ea4c5c04          ORR      r12,r12,r4,LSL #20    ;236
0000f0  ea43030c          ORR      r3,r3,r12             ;236
0000f4  f891c014          LDRB     r12,[r1,#0x14]        ;236
0000f8  6989              LDR      r1,[r1,#0x18]         ;236
0000fa  ea43630c          ORR      r3,r3,r12,LSL #24     ;236
0000fe  eb020080          ADD      r0,r2,r0,LSL #2       ;236
000102  4319              ORRS     r1,r1,r3              ;236
000104  f8c01104          STR      r1,[r0,#0x104]        ;236
000108  bc10              POP      {r4}
00010a  4770              BX       lr
;;;250    
                          ENDP

                  |L15.268|
                          DCD      0xfff00000

                          AREA ||i.FMC_NORSRAMStructInit||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAMStructInit PROC
;;;256      */
;;;257    void FMC_NORSRAMStructInit(FMC_NORSRAMInitTypeDef* FMC_NORSRAMInitStruct)
000000  2100              MOVS     r1,#0
;;;258    {  
;;;259      /* Reset NOR/SRAM Init structure parameters values */
;;;260      FMC_NORSRAMInitStruct->FMC_Bank = FMC_Bank1_NORSRAM1;
;;;261      FMC_NORSRAMInitStruct->FMC_DataAddressMux = FMC_DataAddressMux_Enable;
000002  2202              MOVS     r2,#2
000004  e9c01200          STRD     r1,r2,[r0,#0]
;;;262      FMC_NORSRAMInitStruct->FMC_MemoryType = FMC_MemoryType_SRAM;
;;;263      FMC_NORSRAMInitStruct->FMC_MemoryDataWidth = FMC_NORSRAM_MemoryDataWidth_16b;
000008  2210              MOVS     r2,#0x10
00000a  e9c01202          STRD     r1,r2,[r0,#8]
;;;264      FMC_NORSRAMInitStruct->FMC_BurstAccessMode = FMC_BurstAccessMode_Disable;
;;;265      FMC_NORSRAMInitStruct->FMC_AsynchronousWait = FMC_AsynchronousWait_Disable;
00000e  6101              STR      r1,[r0,#0x10]
;;;266      FMC_NORSRAMInitStruct->FMC_WaitSignalPolarity = FMC_WaitSignalPolarity_Low;
000010  62c1              STR      r1,[r0,#0x2c]
;;;267      FMC_NORSRAMInitStruct->FMC_WrapMode = FMC_WrapMode_Disable;
000012  6141              STR      r1,[r0,#0x14]
;;;268      FMC_NORSRAMInitStruct->FMC_WaitSignalActive = FMC_WaitSignalActive_BeforeWaitState;
;;;269      FMC_NORSRAMInitStruct->FMC_WriteOperation = FMC_WriteOperation_Enable;
000014  0212              LSLS     r2,r2,#8
000016  6181              STR      r1,[r0,#0x18]
000018  e9c01207          STRD     r1,r2,[r0,#0x1c]
;;;270      FMC_NORSRAMInitStruct->FMC_WaitSignal = FMC_WaitSignal_Enable;
00001c  0052              LSLS     r2,r2,#1
00001e  e9c02109          STRD     r2,r1,[r0,#0x24]
;;;271      FMC_NORSRAMInitStruct->FMC_ExtendedMode = FMC_ExtendedMode_Disable;
;;;272      FMC_NORSRAMInitStruct->FMC_WriteBurst = FMC_WriteBurst_Disable;
;;;273      FMC_NORSRAMInitStruct->FMC_ContinousClock = FMC_CClock_SyncOnly;
000022  6301              STR      r1,[r0,#0x30]
;;;274      
;;;275      FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressSetupTime = 15;
000024  6341              STR      r1,[r0,#0x34]
000026  6b83              LDR      r3,[r0,#0x38]
000028  220f              MOVS     r2,#0xf
;;;276      FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AddressHoldTime = 15;
00002a  601a              STR      r2,[r3,#0]
00002c  6b83              LDR      r3,[r0,#0x38]
;;;277      FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataSetupTime = 255;
00002e  605a              STR      r2,[r3,#4]
000030  f8d0c038          LDR      r12,[r0,#0x38]
000034  23ff              MOVS     r3,#0xff
;;;278      FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_BusTurnAroundDuration = 15;
000036  f8cc3008          STR      r3,[r12,#8]
00003a  f8d0c038          LDR      r12,[r0,#0x38]
;;;279      FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_CLKDivision = 15;
00003e  f8cc200c          STR      r2,[r12,#0xc]
000042  f8d0c038          LDR      r12,[r0,#0x38]
;;;280      FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_DataLatency = 15;
000046  f8cc2010          STR      r2,[r12,#0x10]
00004a  f8d0c038          LDR      r12,[r0,#0x38]
;;;281      FMC_NORSRAMInitStruct->FMC_ReadWriteTimingStruct->FMC_AccessMode = FMC_AccessMode_A; 
00004e  f8cc2014          STR      r2,[r12,#0x14]
000052  f8d0c038          LDR      r12,[r0,#0x38]
;;;282      FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressSetupTime = 15;
000056  f8cc1018          STR      r1,[r12,#0x18]
00005a  f8d0c03c          LDR      r12,[r0,#0x3c]
;;;283      FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AddressHoldTime = 15;
00005e  f8cc2000          STR      r2,[r12,#0]
000062  f8d0c03c          LDR      r12,[r0,#0x3c]
;;;284      FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataSetupTime = 255;
000066  f8cc2004          STR      r2,[r12,#4]
00006a  f8d0c03c          LDR      r12,[r0,#0x3c]
;;;285      FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_BusTurnAroundDuration = 15;
00006e  f8cc3008          STR      r3,[r12,#8]
000072  6bc3              LDR      r3,[r0,#0x3c]
;;;286      FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_CLKDivision = 15;
000074  60da              STR      r2,[r3,#0xc]
000076  6bc3              LDR      r3,[r0,#0x3c]
;;;287      FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_DataLatency = 15;
000078  611a              STR      r2,[r3,#0x10]
00007a  6bc3              LDR      r3,[r0,#0x3c]
;;;288      FMC_NORSRAMInitStruct->FMC_WriteTimingStruct->FMC_AccessMode = FMC_AccessMode_A;
00007c  615a              STR      r2,[r3,#0x14]
00007e  6bc0              LDR      r0,[r0,#0x3c]
000080  6181              STR      r1,[r0,#0x18]
;;;289    }
000082  4770              BX       lr
;;;290    
                          ENDP


                          AREA ||i.FMC_PCCARDCmd||, CODE, READONLY, ALIGN=2

                  FMC_PCCARDCmd PROC
;;;737      */
;;;738    void FMC_PCCARDCmd(FunctionalState NewState)
000000  f04f4120          MOV      r1,#0xa0000000
;;;739    {
;;;740      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;741      
;;;742      if (NewState != DISABLE)
000004  2800              CMP      r0,#0
;;;743      {
;;;744        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;745        FMC_Bank4->PCR4 |= PCR_PBKEN_SET;
000006  bf19              ITTEE    NE
000008  f8d100a0          LDRNE    r0,[r1,#0xa0]
00000c  f0400004          ORRNE    r0,r0,#4
;;;746      }
;;;747      else
;;;748      {
;;;749        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;750        FMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
000010  f8d120a0          LDREQ    r2,[r1,#0xa0]
000014  4802              LDREQ    r0,|L17.32|
000016  bf08              IT       EQ
000018  4010              ANDEQ    r0,r0,r2
00001a  f8c100a0          STR      r0,[r1,#0xa0]         ;745
;;;751      }
;;;752    }
00001e  4770              BX       lr
;;;753    
                          ENDP

                  |L17.32|
                          DCD      0x000ffffb

                          AREA ||i.FMC_PCCARDDeInit||, CODE, READONLY, ALIGN=2

                  FMC_PCCARDDeInit PROC
;;;642      */
;;;643    void FMC_PCCARDDeInit(void)
000000  4805              LDR      r0,|L18.24|
;;;644    {
;;;645      /* Set the FMC_Bank4 registers to their reset values */
;;;646      FMC_Bank4->PCR4 = 0x00000018; 
000002  2118              MOVS     r1,#0x18
000004  6001              STR      r1,[r0,#0]
;;;647      FMC_Bank4->SR4 = 0x00000000;	
000006  2100              MOVS     r1,#0
000008  6041              STR      r1,[r0,#4]
;;;648      FMC_Bank4->PMEM4 = 0xFCFCFCFC;
00000a  f04f31fc          MOV      r1,#0xfcfcfcfc
00000e  6081              STR      r1,[r0,#8]
;;;649      FMC_Bank4->PATT4 = 0xFCFCFCFC;
000010  60c1              STR      r1,[r0,#0xc]
;;;650      FMC_Bank4->PIO4 = 0xFCFCFCFC;
000012  6101              STR      r1,[r0,#0x10]
;;;651    }
000014  4770              BX       lr
;;;652    
                          ENDP

000016  0000              DCW      0x0000
                  |L18.24|
                          DCD      0xa00000a0

                          AREA ||i.FMC_PCCARDInit||, CODE, READONLY, ALIGN=2

                  FMC_PCCARDInit PROC
;;;659      */
;;;660    void FMC_PCCARDInit(FMC_PCCARDInitTypeDef* FMC_PCCARDInitStruct)
000000  e9d01200          LDRD     r1,r2,[r0,#0]
;;;661    {
;;;662      /* Check the parameters */
;;;663      assert_param(IS_FMC_WAIT_FEATURE(FMC_PCCARDInitStruct->FMC_Waitfeature));
;;;664      assert_param(IS_FMC_TCLR_TIME(FMC_PCCARDInitStruct->FMC_TCLRSetupTime));
;;;665      assert_param(IS_FMC_TAR_TIME(FMC_PCCARDInitStruct->FMC_TARSetupTime));
;;;666     
;;;667      assert_param(IS_FMC_SETUP_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime));
;;;668      assert_param(IS_FMC_WAIT_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime));
;;;669      assert_param(IS_FMC_HOLD_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime));
;;;670      assert_param(IS_FMC_HIZ_TIME(FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime));
;;;671      
;;;672      assert_param(IS_FMC_SETUP_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime));
;;;673      assert_param(IS_FMC_WAIT_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime));
;;;674      assert_param(IS_FMC_HOLD_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime));
;;;675      assert_param(IS_FMC_HIZ_TIME(FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime));
;;;676      assert_param(IS_FMC_SETUP_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_SetupTime));
;;;677      assert_param(IS_FMC_WAIT_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_WaitSetupTime));
;;;678      assert_param(IS_FMC_HOLD_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HoldSetupTime));
;;;679      assert_param(IS_FMC_HIZ_TIME(FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HiZSetupTime));
;;;680      
;;;681      /* Set the PCR4 register value according to FMC_PCCARDInitStruct parameters */
;;;682      FMC_Bank4->PCR4 = (uint32_t)FMC_PCCARDInitStruct->FMC_Waitfeature |
000004  ea412142          ORR      r1,r1,r2,LSL #9
000008  6882              LDR      r2,[r0,#8]
00000a  2310              MOVS     r3,#0x10
00000c  ea433242          ORR      r2,r3,r2,LSL #13
000010  4311              ORRS     r1,r1,r2
000012  4a15              LDR      r2,|L19.104|
000014  6011              STR      r1,[r2,#0]
;;;683                         FMC_NAND_MemoryDataWidth_16b |  
;;;684                         (FMC_PCCARDInitStruct->FMC_TCLRSetupTime << 9) |
;;;685                         (FMC_PCCARDInitStruct->FMC_TARSetupTime << 13);
;;;686                
;;;687      /* Set PMEM4 register value according to FMC_CommonSpaceTimingStructure parameters */
;;;688      FMC_Bank4->PMEM4 = (uint32_t)FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime |
000016  68c1              LDR      r1,[r0,#0xc]
000018  e9d13c00          LDRD     r3,r12,[r1,#0]
00001c  ea43230c          ORR      r3,r3,r12,LSL #8
000020  f8b1c008          LDRH     r12,[r1,#8]
000024  7b09              LDRB     r1,[r1,#0xc]
000026  ea4f4c0c          LSL      r12,r12,#16
00002a  ea4c6101          ORR      r1,r12,r1,LSL #24
00002e  4319              ORRS     r1,r1,r3
000030  6091              STR      r1,[r2,#8]
;;;689                          (FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime << 8) |
;;;690                          (FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime << 16)|
;;;691                          (FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime << 24); 
;;;692                
;;;693      /* Set PATT4 register value according to FMC_AttributeSpaceTimingStructure parameters */
;;;694      FMC_Bank4->PATT4 = (uint32_t)FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime |
000032  6901              LDR      r1,[r0,#0x10]
000034  e9d13c00          LDRD     r3,r12,[r1,#0]
000038  ea43230c          ORR      r3,r3,r12,LSL #8
00003c  f8b1c008          LDRH     r12,[r1,#8]
000040  7b09              LDRB     r1,[r1,#0xc]
000042  ea4f4c0c          LSL      r12,r12,#16
000046  ea4c6101          ORR      r1,r12,r1,LSL #24
00004a  4319              ORRS     r1,r1,r3
00004c  60d1              STR      r1,[r2,#0xc]
;;;695                          (FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime << 8) |
;;;696                          (FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime << 16)|
;;;697                          (FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime << 24);	
;;;698                
;;;699      /* Set PIO4 register value according to FMC_IOSpaceTimingStructure parameters */
;;;700      FMC_Bank4->PIO4 = (uint32_t)FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_SetupTime |
00004e  6940              LDR      r0,[r0,#0x14]
000050  e9d01300          LDRD     r1,r3,[r0,#0]
000054  ea412103          ORR      r1,r1,r3,LSL #8
000058  8903              LDRH     r3,[r0,#8]
00005a  7b00              LDRB     r0,[r0,#0xc]
00005c  041b              LSLS     r3,r3,#16
00005e  ea436000          ORR      r0,r3,r0,LSL #24
000062  4308              ORRS     r0,r0,r1
000064  6110              STR      r0,[r2,#0x10]
;;;701                         (FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_WaitSetupTime << 8) |
;;;702                         (FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HoldSetupTime << 16)|
;;;703                         (FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HiZSetupTime << 24);             
;;;704    }
000066  4770              BX       lr
;;;705    
                          ENDP

                  |L19.104|
                          DCD      0xa00000a0

                          AREA ||i.FMC_PCCARDStructInit||, CODE, READONLY, ALIGN=1

                  FMC_PCCARDStructInit PROC
;;;711      */
;;;712    void FMC_PCCARDStructInit(FMC_PCCARDInitTypeDef* FMC_PCCARDInitStruct)
000000  2100              MOVS     r1,#0
;;;713    {
;;;714      /* Reset PCCARD Init structure parameters values */
;;;715      FMC_PCCARDInitStruct->FMC_Waitfeature = FMC_Waitfeature_Disable;
;;;716      FMC_PCCARDInitStruct->FMC_TCLRSetupTime = 0;
000002  6001              STR      r1,[r0,#0]
;;;717      FMC_PCCARDInitStruct->FMC_TARSetupTime = 0;
000004  6041              STR      r1,[r0,#4]
;;;718      FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_SetupTime = 252;
000006  6081              STR      r1,[r0,#8]
000008  68c2              LDR      r2,[r0,#0xc]
00000a  21fc              MOVS     r1,#0xfc
;;;719      FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_WaitSetupTime = 252;
00000c  6011              STR      r1,[r2,#0]
00000e  68c2              LDR      r2,[r0,#0xc]
;;;720      FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HoldSetupTime = 252;
000010  6051              STR      r1,[r2,#4]
000012  68c2              LDR      r2,[r0,#0xc]
;;;721      FMC_PCCARDInitStruct->FMC_CommonSpaceTimingStruct->FMC_HiZSetupTime = 252;
000014  6091              STR      r1,[r2,#8]
000016  68c2              LDR      r2,[r0,#0xc]
;;;722      FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_SetupTime = 252;
000018  60d1              STR      r1,[r2,#0xc]
00001a  6902              LDR      r2,[r0,#0x10]
;;;723      FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_WaitSetupTime = 252;
00001c  6011              STR      r1,[r2,#0]
00001e  6902              LDR      r2,[r0,#0x10]
;;;724      FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HoldSetupTime = 252;
000020  6051              STR      r1,[r2,#4]
000022  6902              LDR      r2,[r0,#0x10]
;;;725      FMC_PCCARDInitStruct->FMC_AttributeSpaceTimingStruct->FMC_HiZSetupTime = 252;	
000024  6091              STR      r1,[r2,#8]
000026  6902              LDR      r2,[r0,#0x10]
;;;726      FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_SetupTime = 252;
000028  60d1              STR      r1,[r2,#0xc]
00002a  6942              LDR      r2,[r0,#0x14]
;;;727      FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_WaitSetupTime = 252;
00002c  6011              STR      r1,[r2,#0]
00002e  6942              LDR      r2,[r0,#0x14]
;;;728      FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HoldSetupTime = 252;
000030  6051              STR      r1,[r2,#4]
000032  6942              LDR      r2,[r0,#0x14]
;;;729      FMC_PCCARDInitStruct->FMC_IOSpaceTimingStruct->FMC_HiZSetupTime = 252;
000034  6091              STR      r1,[r2,#8]
000036  6940              LDR      r0,[r0,#0x14]
000038  60c1              STR      r1,[r0,#0xc]
;;;730    }
00003a  4770              BX       lr
;;;731    
                          ENDP


                          AREA ||i.FMC_SDRAMCmdConfig||, CODE, READONLY, ALIGN=2

                  FMC_SDRAMCmdConfig PROC
;;;949      */
;;;950    void FMC_SDRAMCmdConfig(FMC_SDRAMCommandTypeDef* FMC_SDRAMCommandStruct)
000000  e9d01200          LDRD     r1,r2,[r0,#0]
;;;951    {
;;;952      uint32_t tmpr = 0x0;
;;;953        
;;;954      /* check parameters */
;;;955      assert_param(IS_FMC_COMMAND_MODE(FMC_SDRAMCommandStruct->FMC_CommandMode));
;;;956      assert_param(IS_FMC_COMMAND_TARGET(FMC_SDRAMCommandStruct->FMC_CommandTarget));
;;;957      assert_param(IS_FMC_AUTOREFRESH_NUMBER(FMC_SDRAMCommandStruct->FMC_AutoRefreshNumber));
;;;958      assert_param(IS_FMC_MODE_REGISTER(FMC_SDRAMCommandStruct->FMC_ModeRegisterDefinition));
;;;959      
;;;960      tmpr =   (uint32_t)(FMC_SDRAMCommandStruct->FMC_CommandMode |
000004  4311              ORRS     r1,r1,r2
000006  6882              LDR      r2,[r0,#8]
000008  f06f031f          MVN      r3,#0x1f
00000c  68c0              LDR      r0,[r0,#0xc]
00000e  eb031242          ADD      r2,r3,r2,LSL #5
000012  ea422040          ORR      r0,r2,r0,LSL #9
000016  4308              ORRS     r0,r0,r1
000018  4901              LDR      r1,|L21.32|
;;;961                          FMC_SDRAMCommandStruct->FMC_CommandTarget |
;;;962                         (((FMC_SDRAMCommandStruct->FMC_AutoRefreshNumber)-1)<<5) |
;;;963                         ((FMC_SDRAMCommandStruct->FMC_ModeRegisterDefinition)<<9));
;;;964      
;;;965      FMC_Bank5_6->SDCMR = tmpr;
00001a  6008              STR      r0,[r1,#0]
;;;966    
;;;967    }
00001c  4770              BX       lr
;;;968    
                          ENDP

00001e  0000              DCW      0x0000
                  |L21.32|
                          DCD      0xa0000150

                          AREA ||i.FMC_SDRAMDeInit||, CODE, READONLY, ALIGN=1

                  FMC_SDRAMDeInit PROC
;;;809      */
;;;810    void FMC_SDRAMDeInit(uint32_t FMC_Bank)
000000  f44f7234          MOV      r2,#0x2d0
;;;811    {
;;;812      /* Check the parameter */
;;;813      assert_param(IS_FMC_SDRAM_BANK(FMC_Bank));
;;;814      
;;;815      FMC_Bank5_6->SDCR[FMC_Bank] = 0x000002D0;
000004  0651              LSLS     r1,r2,#25
000006  eb010080          ADD      r0,r1,r0,LSL #2
00000a  f8c02140          STR      r2,[r0,#0x140]
;;;816      FMC_Bank5_6->SDTR[FMC_Bank] = 0x0FFFFFFF;    
00000e  f06f4270          MVN      r2,#0xf0000000
000012  f8c02148          STR      r2,[r0,#0x148]
;;;817      FMC_Bank5_6->SDCMR = 0x00000000;
000016  2000              MOVS     r0,#0
000018  f8c10150          STR      r0,[r1,#0x150]
;;;818      FMC_Bank5_6->SDRTR = 0x00000000;
00001c  f8c10154          STR      r0,[r1,#0x154]
;;;819      FMC_Bank5_6->SDSR = 0x00000000; 
000020  f8c10158          STR      r0,[r1,#0x158]
;;;820    }  
000024  4770              BX       lr
;;;821    
                          ENDP


                          AREA ||i.FMC_SDRAMInit||, CODE, READONLY, ALIGN=2

                  FMC_SDRAMInit PROC
;;;829      */
;;;830    void FMC_SDRAMInit(FMC_SDRAMInitTypeDef* FMC_SDRAMInitStruct)
000000  b4f0              PUSH     {r4-r7}
;;;831    { 
000002  e9d01201          LDRD     r1,r2,[r0,#4]
;;;832      /* temporary registers */
;;;833      uint32_t tmpr1 = 0;
;;;834      uint32_t tmpr2 = 0;
;;;835      uint32_t tmpr3 = 0;
;;;836      uint32_t tmpr4 = 0;
;;;837      
;;;838      /* Check the parameters */
;;;839      
;;;840      /* Control parameters */
;;;841      assert_param(IS_FMC_SDRAM_BANK(FMC_SDRAMInitStruct->FMC_Bank));
;;;842      assert_param(IS_FMC_COLUMNBITS_NUMBER(FMC_SDRAMInitStruct->FMC_ColumnBitsNumber)); 
;;;843      assert_param(IS_FMC_ROWBITS_NUMBER(FMC_SDRAMInitStruct->FMC_RowBitsNumber));
;;;844      assert_param(IS_FMC_SDMEMORY_WIDTH(FMC_SDRAMInitStruct->FMC_SDMemoryDataWidth));
;;;845      assert_param(IS_FMC_INTERNALBANK_NUMBER(FMC_SDRAMInitStruct->FMC_InternalBankNumber)); 
;;;846      assert_param(IS_FMC_CAS_LATENCY(FMC_SDRAMInitStruct->FMC_CASLatency));
;;;847      assert_param(IS_FMC_WRITE_PROTECTION(FMC_SDRAMInitStruct->FMC_WriteProtection));
;;;848      assert_param(IS_FMC_SDCLOCK_PERIOD(FMC_SDRAMInitStruct->FMC_SDClockPeriod));
;;;849      assert_param(IS_FMC_READ_BURST(FMC_SDRAMInitStruct->FMC_ReadBurst));
;;;850      assert_param(IS_FMC_READPIPE_DELAY(FMC_SDRAMInitStruct->FMC_ReadPipeDelay));   
;;;851      
;;;852      /* Timing parameters */
;;;853      assert_param(IS_FMC_LOADTOACTIVE_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay)); 
;;;854      assert_param(IS_FMC_EXITSELFREFRESH_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay));
;;;855      assert_param(IS_FMC_SELFREFRESH_TIME(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime));
;;;856      assert_param(IS_FMC_ROWCYCLE_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay));
;;;857      assert_param(IS_FMC_WRITE_RECOVERY_TIME(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime)); 
;;;858      assert_param(IS_FMC_RP_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay)); 
;;;859      assert_param(IS_FMC_RCD_DELAY(FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RCDDelay));    
;;;860      
;;;861      /* SDRAM bank control register configuration */ 
;;;862      tmpr1 =   (uint32_t)FMC_SDRAMInitStruct->FMC_ColumnBitsNumber |
000006  4311              ORRS     r1,r1,r2
000008  e9d02303          LDRD     r2,r3,[r0,#0xc]
00000c  431a              ORRS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6942              LDR      r2,[r0,#0x14]
000012  69c3              LDR      r3,[r0,#0x1c]
000014  4311              ORRS     r1,r1,r2
000016  6982              LDR      r2,[r0,#0x18]
000018  f8d0c024          LDR      r12,[r0,#0x24]
00001c  4311              ORRS     r1,r1,r2
00001e  6a02              LDR      r2,[r0,#0x20]
000020  4319              ORRS     r1,r1,r3
000022  4311              ORRS     r1,r1,r2
;;;863                 FMC_SDRAMInitStruct->FMC_RowBitsNumber |
;;;864                 FMC_SDRAMInitStruct->FMC_SDMemoryDataWidth |
;;;865                 FMC_SDRAMInitStruct->FMC_InternalBankNumber |           
;;;866                 FMC_SDRAMInitStruct->FMC_CASLatency |
;;;867                 FMC_SDRAMInitStruct->FMC_WriteProtection |
;;;868                 FMC_SDRAMInitStruct->FMC_SDClockPeriod |
;;;869                 FMC_SDRAMInitStruct->FMC_ReadBurst | 
;;;870                 FMC_SDRAMInitStruct->FMC_ReadPipeDelay;
;;;871                
;;;872      if(FMC_SDRAMInitStruct->FMC_Bank == FMC_Bank1_SDRAM )
000024  6805              LDR      r5,[r0,#0]
000026  ea41010c          ORR      r1,r1,r12             ;862
;;;873      {
;;;874        FMC_Bank5_6->SDCR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr1;
00002a  f04f4420          MOV      r4,#0xa0000000
00002e  2d00              CMP      r5,#0                 ;872
000030  bf08              IT       EQ
000032  f8c41140          STREQ    r1,[r4,#0x140]
000036  d009              BEQ      |L23.76|
;;;875      }
;;;876      else   /* SDCR2 "don't care" bits configuration */
;;;877      {
;;;878        tmpr3 = (uint32_t)FMC_SDRAMInitStruct->FMC_SDClockPeriod |
000038  431a              ORRS     r2,r2,r3
00003a  ea42020c          ORR      r2,r2,r12
;;;879                 FMC_SDRAMInitStruct->FMC_ReadBurst | 
;;;880                 FMC_SDRAMInitStruct->FMC_ReadPipeDelay;
;;;881        
;;;882        FMC_Bank5_6->SDCR[FMC_Bank1_SDRAM] = tmpr3;
00003e  f8c42140          STR      r2,[r4,#0x140]
;;;883        FMC_Bank5_6->SDCR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr1;
000042  6802              LDR      r2,[r0,#0]
000044  eb040282          ADD      r2,r4,r2,LSL #2
000048  f8c21140          STR      r1,[r2,#0x140]
                  |L23.76|
;;;884      }
;;;885      /* SDRAM bank timing register configuration */
;;;886      if(FMC_SDRAMInitStruct->FMC_Bank == FMC_Bank1_SDRAM )
;;;887      {
;;;888        tmpr2 =   (uint32_t)((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay)-1) |
00004c  f06f020f          MVN      r2,#0xf
000050  0115              LSLS     r5,r2,#4
000052  6801              LDR      r1,[r0,#0]            ;886
000054  ea4f3c02          LSL      r12,r2,#12
000058  0413              LSLS     r3,r2,#16
00005a  b319              CBZ      r1,|L23.164|
;;;889                (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay)-1) << 4) |
;;;890                (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime)-1) << 8) |
;;;891                (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay)-1) << 12) |
;;;892                (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime)-1) << 16) |
;;;893                (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay)-1) << 20) |
;;;894                (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RCDDelay)-1) << 24);
;;;895                
;;;896                FMC_Bank5_6->SDTR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr2;
;;;897      }
;;;898      else   /* SDTR "don't care bits configuration */
;;;899      {
;;;900        tmpr2 =   (uint32_t)((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay)-1) |
00005c  6a81              LDR      r1,[r0,#0x28]
00005e  680e              LDR      r6,[r1,#0]
000060  684f              LDR      r7,[r1,#4]
000062  1e76              SUBS     r6,r6,#1
000064  eb021207          ADD      r2,r2,r7,LSL #4
000068  4332              ORRS     r2,r2,r6
00006a  688e              LDR      r6,[r1,#8]
00006c  eb052506          ADD      r5,r5,r6,LSL #8
000070  432a              ORRS     r2,r2,r5
000072  8a0d              LDRH     r5,[r1,#0x10]
000074  eb0c4c05          ADD      r12,r12,r5,LSL #16
000078  ea42020c          ORR      r2,r2,r12
;;;901                (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay)-1) << 4) |
;;;902                (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime)-1) << 8) |
;;;903                (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime)-1) << 16);
;;;904                
;;;905        tmpr4 =   (uint32_t)(((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay)-1) << 12) |
00007c  f8d1c00c          LDR      r12,[r1,#0xc]
000080  8a89              LDRH     r1,[r1,#0x14]
000082  ea4f3c0c          LSL      r12,r12,#12
000086  f5ac5c80          SUB      r12,r12,#0x1000
00008a  eb035101          ADD      r1,r3,r1,LSL #20
00008e  ea4c0101          ORR      r1,r12,r1
;;;906                (((FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay)-1) << 20);
;;;907                
;;;908                FMC_Bank5_6->SDTR[FMC_Bank1_SDRAM] = tmpr4;
000092  f8c41148          STR      r1,[r4,#0x148]
;;;909                FMC_Bank5_6->SDTR[FMC_SDRAMInitStruct->FMC_Bank] = tmpr2;
000096  6800              LDR      r0,[r0,#0]
000098  eb040080          ADD      r0,r4,r0,LSL #2
00009c  f8c02148          STR      r2,[r0,#0x148]
;;;910      }
;;;911      
;;;912    }
0000a0  bcf0              POP      {r4-r7}
0000a2  4770              BX       lr
                  |L23.164|
0000a4  6a80              LDR      r0,[r0,#0x28]         ;888
0000a6  6801              LDR      r1,[r0,#0]            ;888
0000a8  6846              LDR      r6,[r0,#4]            ;888
0000aa  1e49              SUBS     r1,r1,#1              ;888
0000ac  eb021206          ADD      r2,r2,r6,LSL #4       ;888
0000b0  4311              ORRS     r1,r1,r2              ;888
0000b2  6882              LDR      r2,[r0,#8]            ;888
0000b4  eb052202          ADD      r2,r5,r2,LSL #8       ;888
0000b8  4311              ORRS     r1,r1,r2              ;888
0000ba  4d0b              LDR      r5,|L23.232|
0000bc  68c2              LDR      r2,[r0,#0xc]          ;888
0000be  eb053202          ADD      r2,r5,r2,LSL #12      ;888
0000c2  4311              ORRS     r1,r1,r2              ;888
0000c4  8a02              LDRH     r2,[r0,#0x10]         ;888
0000c6  eb0c4202          ADD      r2,r12,r2,LSL #16     ;888
0000ca  4311              ORRS     r1,r1,r2              ;888
0000cc  8a82              LDRH     r2,[r0,#0x14]         ;888
0000ce  7e00              LDRB     r0,[r0,#0x18]         ;888
0000d0  eb035202          ADD      r2,r3,r2,LSL #20      ;888
0000d4  4311              ORRS     r1,r1,r2              ;888
0000d6  032a              LSLS     r2,r5,#12             ;888
0000d8  eb026000          ADD      r0,r2,r0,LSL #24      ;888
0000dc  4308              ORRS     r0,r0,r1              ;888
0000de  f8c40148          STR      r0,[r4,#0x148]        ;896
0000e2  bcf0              POP      {r4-r7}
0000e4  4770              BX       lr
;;;913    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L23.232|
                          DCD      0xfffff000

                          AREA ||i.FMC_SDRAMStructInit||, CODE, READONLY, ALIGN=1

                  FMC_SDRAMStructInit PROC
;;;919      */
;;;920    void FMC_SDRAMStructInit(FMC_SDRAMInitTypeDef* FMC_SDRAMInitStruct)  
000000  2200              MOVS     r2,#0
;;;921    {  
;;;922      /* Reset SDRAM Init structure parameters values */
;;;923      FMC_SDRAMInitStruct->FMC_Bank = FMC_Bank1_SDRAM;
;;;924      FMC_SDRAMInitStruct->FMC_ColumnBitsNumber = FMC_ColumnBits_Number_8b;
000002  6002              STR      r2,[r0,#0]
;;;925      FMC_SDRAMInitStruct->FMC_RowBitsNumber = FMC_RowBits_Number_11b; 
000004  6042              STR      r2,[r0,#4]
;;;926      FMC_SDRAMInitStruct->FMC_SDMemoryDataWidth = FMC_SDMemory_Width_16b;
000006  2110              MOVS     r1,#0x10
;;;927      FMC_SDRAMInitStruct->FMC_InternalBankNumber = FMC_InternalBank_Number_4; 
000008  2340              MOVS     r3,#0x40
00000a  6082              STR      r2,[r0,#8]
00000c  e9c01303          STRD     r1,r3,[r0,#0xc]
;;;928      FMC_SDRAMInitStruct->FMC_CASLatency = FMC_CAS_Latency_1;  
000010  2380              MOVS     r3,#0x80
;;;929      FMC_SDRAMInitStruct->FMC_WriteProtection = FMC_Write_Protection_Enable;
000012  6143              STR      r3,[r0,#0x14]
000014  014b              LSLS     r3,r1,#5
000016  e9c03206          STRD     r3,r2,[r0,#0x18]
;;;930      FMC_SDRAMInitStruct->FMC_SDClockPeriod = FMC_SDClock_Disable;
;;;931      FMC_SDRAMInitStruct->FMC_ReadBurst = FMC_Read_Burst_Disable;
;;;932      FMC_SDRAMInitStruct->FMC_ReadPipeDelay = FMC_ReadPipe_Delay_0; 
00001a  6202              STR      r2,[r0,#0x20]
;;;933       
;;;934      FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_LoadToActiveDelay = 16;
00001c  6242              STR      r2,[r0,#0x24]
00001e  6a82              LDR      r2,[r0,#0x28]
;;;935      FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_ExitSelfRefreshDelay = 16;
000020  6011              STR      r1,[r2,#0]
000022  6a82              LDR      r2,[r0,#0x28]
;;;936      FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_SelfRefreshTime = 16;
000024  6051              STR      r1,[r2,#4]
000026  6a82              LDR      r2,[r0,#0x28]
;;;937      FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RowCycleDelay = 16;
000028  6091              STR      r1,[r2,#8]
00002a  6a82              LDR      r2,[r0,#0x28]
;;;938      FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_WriteRecoveryTime = 16;
00002c  60d1              STR      r1,[r2,#0xc]
00002e  6a82              LDR      r2,[r0,#0x28]
;;;939      FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RPDelay = 16;
000030  6111              STR      r1,[r2,#0x10]
000032  6a82              LDR      r2,[r0,#0x28]
;;;940      FMC_SDRAMInitStruct->FMC_SDRAMTimingStruct->FMC_RCDDelay = 16;
000034  6151              STR      r1,[r2,#0x14]
000036  6a80              LDR      r0,[r0,#0x28]
000038  6181              STR      r1,[r0,#0x18]
;;;941      
;;;942    }
00003a  4770              BX       lr
;;;943    
                          ENDP


                          AREA ||i.FMC_SDRAMWriteProtectionConfig||, CODE, READONLY, ALIGN=1

                  FMC_SDRAMWriteProtectionConfig PROC
;;;1031     */
;;;1032   void FMC_SDRAMWriteProtectionConfig(uint32_t SDRAM_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;1033   {
;;;1034     /* Check the parameter */
;;;1035     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1036     assert_param(IS_FMC_SDRAM_BANK(SDRAM_Bank));
;;;1037     
;;;1038     if (NewState != DISABLE)
;;;1039     {
;;;1040       FMC_Bank5_6->SDCR[SDRAM_Bank] |= FMC_Write_Protection_Enable;    
000004  eb020080          ADD      r0,r2,r0,LSL #2
000008  2900              CMP      r1,#0                 ;1038
;;;1041     }
;;;1042     else
;;;1043     {
;;;1044       FMC_Bank5_6->SDCR[SDRAM_Bank] &= SDCR_WriteProtection_RESET;
00000a  f8d01140          LDR      r1,[r0,#0x140]
00000e  bf12              ITEE     NE                    ;1040
000010  f4417100          ORRNE    r1,r1,#0x200          ;1040
000014  f64752ff          MOVEQ    r2,#0x7dff
000018  4011              ANDEQ    r1,r1,r2
00001a  f8c01140          STR      r1,[r0,#0x140]        ;1040
;;;1045     } 
;;;1046     
;;;1047   }
00001e  4770              BX       lr
;;;1048   
                          ENDP


                          AREA ||i.FMC_SetAutoRefresh_Number||, CODE, READONLY, ALIGN=2

                  FMC_SetAutoRefresh_Number PROC
;;;1015     */
;;;1016   void FMC_SetAutoRefresh_Number(uint32_t FMC_Number)
000000  4902              LDR      r1,|L26.12|
;;;1017   {
;;;1018     /* check the parameters */
;;;1019     assert_param(IS_FMC_AUTOREFRESH_NUMBER(FMC_Number));
;;;1020     
;;;1021     FMC_Bank5_6->SDCMR |= (FMC_Number << 5);   
000002  680a              LDR      r2,[r1,#0]
000004  ea421040          ORR      r0,r2,r0,LSL #5
000008  6008              STR      r0,[r1,#0]
;;;1022   }
00000a  4770              BX       lr
;;;1023   
                          ENDP

                  |L26.12|
                          DCD      0xa0000150

                          AREA ||i.FMC_SetRefreshCount||, CODE, READONLY, ALIGN=2

                  FMC_SetRefreshCount PROC
;;;1001     */
;;;1002   void FMC_SetRefreshCount(uint32_t FMC_Count)
000000  4902              LDR      r1,|L27.12|
;;;1003   {
;;;1004     /* check the parameters */
;;;1005     assert_param(IS_FMC_REFRESH_COUNT(FMC_Count));
;;;1006     
;;;1007     FMC_Bank5_6->SDRTR |= (FMC_Count<<1);
000002  680a              LDR      r2,[r1,#0]
000004  ea420040          ORR      r0,r2,r0,LSL #1
000008  6008              STR      r0,[r1,#0]
;;;1008      
;;;1009   }
00000a  4770              BX       lr
;;;1010   
                          ENDP

                  |L27.12|
                          DCD      0xa0000154

;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\stm32f4xx_fmc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_fmc_c_d78b8e92____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___15_stm32f4xx_fmc_c_d78b8e92____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_fmc_c_d78b8e92____REVSH|
#line 144
|__asm___15_stm32f4xx_fmc_c_d78b8e92____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
