; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\stm32f4xx_hash_sha1.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f4xx_hash_sha1.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\stm32f4xx_hash_sha1.crf arm_hal\lib\stm32f4xx_hash_sha1.c]
                          THUMB

                          AREA ||i.HASH_SHA1||, CODE, READONLY, ALIGN=1

                  HASH_SHA1 PROC
;;;92       */
;;;93     ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20])
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;94     {
000004  b08f              SUB      sp,sp,#0x3c
;;;95       HASH_InitTypeDef SHA1_HASH_InitStructure;
;;;96       HASH_MsgDigest SHA1_MessageDigest;
;;;97       __IO uint16_t nbvalidbitsdata = 0;
000006  f04f0900          MOV      r9,#0
00000a  4617              MOV      r7,r2                 ;94
00000c  460e              MOV      r6,r1                 ;94
00000e  4604              MOV      r4,r0                 ;94
000010  f8ad9034          STRH     r9,[sp,#0x34]
;;;98       uint32_t i = 0;
;;;99       __IO uint32_t counter = 0;
;;;100      uint32_t busystatus = 0;
;;;101      ErrorStatus status = SUCCESS;
;;;102      uint32_t inputaddr  = (uint32_t)Input;
;;;103      uint32_t outputaddr = (uint32_t)Output;
;;;104    
;;;105      /* Number of valid bits in last word of the Input data */
;;;106      nbvalidbitsdata = 8 * (Ilen % 4);
000014  0788              LSLS     r0,r1,#30
000016  0ec0              LSRS     r0,r0,#27
000018  464d              MOV      r5,r9                 ;98
00001a  f04f0801          MOV      r8,#1                 ;101
00001e  f8cd9030          STR      r9,[sp,#0x30]
000022  f8ad0034          STRH     r0,[sp,#0x34]
;;;107    
;;;108      /* HASH peripheral initialization */
;;;109      HASH_DeInit();
000026  f7fffffe          BL       HASH_DeInit
;;;110    
;;;111      /* HASH Configuration */
;;;112      SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
;;;113      SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
;;;114      SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
00002a  2020              MOVS     r0,#0x20
00002c  f8cd9020          STR      r9,[sp,#0x20]
000030  e9cd9009          STRD     r9,r0,[sp,#0x24]
;;;115      HASH_Init(&SHA1_HASH_InitStructure);
000034  a808              ADD      r0,sp,#0x20
000036  f7fffffe          BL       HASH_Init
;;;116    
;;;117      /* Configure the number of valid bits in last word of the data */
;;;118      HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
00003a  f8bd0034          LDRH     r0,[sp,#0x34]
00003e  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;119    
;;;120      /* Write the Input block in the IN FIFO */
;;;121      for(i=0; i<Ilen; i+=4)
000042  2e00              CMP      r6,#0
000044  d906              BLS      |L1.84|
                  |L1.70|
;;;122      {
;;;123        HASH_DataIn(*(uint32_t*)inputaddr);
000046  6820              LDR      r0,[r4,#0]
000048  f7fffffe          BL       HASH_DataIn
00004c  1d24              ADDS     r4,r4,#4
00004e  1d2d              ADDS     r5,r5,#4
000050  42ae              CMP      r6,r5                 ;121
000052  d8f8              BHI      |L1.70|
                  |L1.84|
;;;124        inputaddr+=4;
;;;125      }
;;;126    
;;;127      /* Start the HASH processor */
;;;128      HASH_StartDigest();
000054  f7fffffe          BL       HASH_StartDigest
                  |L1.88|
;;;129    
;;;130      /* wait until the Busy flag is RESET */
;;;131      do
;;;132      {
;;;133        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
000058  2008              MOVS     r0,#8
00005a  f7fffffe          BL       HASH_GetFlagStatus
;;;134        counter++;
00005e  990c              LDR      r1,[sp,#0x30]
000060  1c49              ADDS     r1,r1,#1
;;;135      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
000062  910c              STR      r1,[sp,#0x30]
000064  f5b13f80          CMP      r1,#0x10000
000068  d002              BEQ      |L1.112|
00006a  2800              CMP      r0,#0
00006c  d1f4              BNE      |L1.88|
00006e  e004              B        |L1.122|
                  |L1.112|
;;;136    
;;;137      if (busystatus != RESET)
000070  2800              CMP      r0,#0
;;;138      {
;;;139         status = ERROR;
000072  bf18              IT       NE
000074  f04f0800          MOVNE    r8,#0
000078  d111              BNE      |L1.158|
                  |L1.122|
;;;140      }
;;;141      else
;;;142      {
;;;143        /* Read the message digest */
;;;144        HASH_GetDigest(&SHA1_MessageDigest);
00007a  4668              MOV      r0,sp
00007c  f7fffffe          BL       HASH_GetDigest
;;;145        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
000080  9800              LDR      r0,[sp,#0]
000082  ba00              REV      r0,r0
;;;146        outputaddr+=4;
;;;147        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
000084  6038              STR      r0,[r7,#0]
000086  9801              LDR      r0,[sp,#4]
000088  ba00              REV      r0,r0
;;;148        outputaddr+=4;
;;;149        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
00008a  6078              STR      r0,[r7,#4]
00008c  9802              LDR      r0,[sp,#8]
00008e  ba00              REV      r0,r0
;;;150        outputaddr+=4;
;;;151        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
000090  60b8              STR      r0,[r7,#8]
000092  9803              LDR      r0,[sp,#0xc]
000094  ba00              REV      r0,r0
;;;152        outputaddr+=4;
;;;153        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
000096  60f8              STR      r0,[r7,#0xc]
000098  9804              LDR      r0,[sp,#0x10]
00009a  ba00              REV      r0,r0
00009c  6138              STR      r0,[r7,#0x10]
                  |L1.158|
;;;154      }
;;;155      return status;
;;;156    }
00009e  b00f              ADD      sp,sp,#0x3c
0000a0  4640              MOV      r0,r8                 ;155
0000a2  e8bd83f0          POP      {r4-r9,pc}
;;;157    
                          ENDP


                          AREA ||i.HMAC_SHA1||, CODE, READONLY, ALIGN=1

                  HMAC_SHA1 PROC
;;;168      */
;;;169    ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;170                          uint32_t Ilen, uint8_t Output[20])
;;;171    {
000004  b08f              SUB      sp,sp,#0x3c
000006  4606              MOV      r6,r0
;;;172      HASH_InitTypeDef SHA1_HASH_InitStructure;
;;;173      HASH_MsgDigest SHA1_MessageDigest;
;;;174      __IO uint16_t nbvalidbitsdata = 0;
000008  2000              MOVS     r0,#0
00000a  f8ddb060          LDR      r11,[sp,#0x60]
00000e  4699              MOV      r9,r3                 ;171
000010  4617              MOV      r7,r2                 ;171
000012  460c              MOV      r4,r1                 ;171
000014  f8ad0038          STRH     r0,[sp,#0x38]
;;;175      __IO uint16_t nbvalidbitskey = 0;
000018  f8ad0004          STRH     r0,[sp,#4]
;;;176      uint32_t i = 0;
00001c  4680              MOV      r8,r0
;;;177      __IO uint32_t counter = 0;
;;;178      uint32_t busystatus = 0;
;;;179      ErrorStatus status = SUCCESS;
;;;180      uint32_t keyaddr    = (uint32_t)Key;
;;;181      uint32_t inputaddr  = (uint32_t)Input;
;;;182      uint32_t outputaddr = (uint32_t)Output;
;;;183    
;;;184      /* Number of valid bits in last word of the Input data */
;;;185      nbvalidbitsdata = 8 * (Ilen % 4);
00001e  9000              STR      r0,[sp,#0]
000020  0798              LSLS     r0,r3,#30
000022  0ec0              LSRS     r0,r0,#27
000024  f04f0a01          MOV      r10,#1                ;179
000028  4635              MOV      r5,r6                 ;180
00002a  f8ad0038          STRH     r0,[sp,#0x38]
;;;186    
;;;187      /* Number of valid bits in last word of the Key */
;;;188      nbvalidbitskey = 8 * (Keylen % 4);
00002e  0788              LSLS     r0,r1,#30
000030  0ec0              LSRS     r0,r0,#27
000032  f8ad0004          STRH     r0,[sp,#4]
;;;189    
;;;190      /* HASH peripheral initialization */
;;;191      HASH_DeInit();
000036  f7fffffe          BL       HASH_DeInit
;;;192    
;;;193      /* HASH Configuration */
;;;194      SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
00003a  2000              MOVS     r0,#0
;;;195      SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
00003c  900a              STR      r0,[sp,#0x28]
00003e  2040              MOVS     r0,#0x40
;;;196      SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
000040  900b              STR      r0,[sp,#0x2c]
000042  2020              MOVS     r0,#0x20
;;;197      if(Keylen > 64)
000044  900c              STR      r0,[sp,#0x30]
000046  2c40              CMP      r4,#0x40
;;;198      {
;;;199        /* HMAC long Key */
;;;200        SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
000048  bf8c              ITE      HI
00004a  f44f3080          MOVHI    r0,#0x10000
;;;201      }
;;;202      else
;;;203      {
;;;204        /* HMAC short Key */
;;;205        SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
00004e  2000              MOVLS    r0,#0
;;;206      }
;;;207      HASH_Init(&SHA1_HASH_InitStructure);
000050  900d              STR      r0,[sp,#0x34]
000052  a80a              ADD      r0,sp,#0x28
000054  f7fffffe          BL       HASH_Init
;;;208    
;;;209      /* Configure the number of valid bits in last word of the Key */
;;;210      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
000058  f8bd0004          LDRH     r0,[sp,#4]
00005c  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;211    
;;;212      /* Write the Key */
;;;213      for(i=0; i<Keylen; i+=4)
000060  2c00              CMP      r4,#0
000062  d907              BLS      |L2.116|
                  |L2.100|
;;;214      {
;;;215        HASH_DataIn(*(uint32_t*)keyaddr);
000064  6828              LDR      r0,[r5,#0]
000066  f7fffffe          BL       HASH_DataIn
00006a  1d2d              ADDS     r5,r5,#4
00006c  f1080804          ADD      r8,r8,#4
000070  4544              CMP      r4,r8                 ;213
000072  d8f7              BHI      |L2.100|
                  |L2.116|
;;;216        keyaddr+=4;
;;;217      }
;;;218    
;;;219      /* Start the HASH processor */
;;;220      HASH_StartDigest();
000074  f7fffffe          BL       HASH_StartDigest
                  |L2.120|
;;;221    
;;;222      /* wait until the Busy flag is RESET */
;;;223      do
;;;224      {
;;;225        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
000078  2008              MOVS     r0,#8
00007a  f7fffffe          BL       HASH_GetFlagStatus
;;;226        counter++;
00007e  9900              LDR      r1,[sp,#0]
000080  1c49              ADDS     r1,r1,#1
;;;227      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
000082  9100              STR      r1,[sp,#0]
000084  f5b13f80          CMP      r1,#0x10000
000088  d002              BEQ      |L2.144|
00008a  2800              CMP      r0,#0
00008c  d1f4              BNE      |L2.120|
00008e  e001              B        |L2.148|
                  |L2.144|
;;;228    
;;;229      if (busystatus != RESET)
000090  2800              CMP      r0,#0
000092  d13d              BNE      |L2.272|
                  |L2.148|
;;;230      {
;;;231         status = ERROR;
;;;232      }
;;;233      else
;;;234      {
;;;235        /* Configure the number of valid bits in last word of the Input data */
;;;236        HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
000094  f8bd0038          LDRH     r0,[sp,#0x38]
000098  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;237    
;;;238        /* Write the Input block in the IN FIFO */
;;;239        for(i=0; i<Ilen; i+=4)
00009c  2500              MOVS     r5,#0
00009e  f1b90f00          CMP      r9,#0
0000a2  d906              BLS      |L2.178|
                  |L2.164|
;;;240        {
;;;241          HASH_DataIn(*(uint32_t*)inputaddr);
0000a4  6838              LDR      r0,[r7,#0]
0000a6  f7fffffe          BL       HASH_DataIn
0000aa  1d2d              ADDS     r5,r5,#4
0000ac  1d3f              ADDS     r7,r7,#4
0000ae  45a9              CMP      r9,r5                 ;239
0000b0  d8f8              BHI      |L2.164|
                  |L2.178|
;;;242          inputaddr+=4;
;;;243        }
;;;244    
;;;245        /* Start the HASH processor */
;;;246        HASH_StartDigest();
0000b2  f7fffffe          BL       HASH_StartDigest
;;;247    
;;;248    
;;;249        /* wait until the Busy flag is RESET */
;;;250        counter =0;
0000b6  2700              MOVS     r7,#0
0000b8  9700              STR      r7,[sp,#0]
                  |L2.186|
;;;251        do
;;;252        {
;;;253          busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
0000ba  2008              MOVS     r0,#8
0000bc  f7fffffe          BL       HASH_GetFlagStatus
;;;254          counter++;
0000c0  9900              LDR      r1,[sp,#0]
0000c2  1c49              ADDS     r1,r1,#1
;;;255        }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
0000c4  9100              STR      r1,[sp,#0]
0000c6  f5b13f80          CMP      r1,#0x10000
0000ca  d002              BEQ      |L2.210|
0000cc  2800              CMP      r0,#0
0000ce  d1f4              BNE      |L2.186|
0000d0  e000              B        |L2.212|
                  |L2.210|
;;;256    
;;;257        if (busystatus != RESET)
0000d2  b9e8              CBNZ     r0,|L2.272|
                  |L2.212|
;;;258        {
;;;259          status = ERROR;
;;;260        }
;;;261        else
;;;262        {  
;;;263          /* Configure the number of valid bits in last word of the Key */
;;;264          HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
0000d4  f8bd0004          LDRH     r0,[sp,#4]
0000d8  f7fffffe          BL       HASH_SetLastWordValidBitsNbr
;;;265    
;;;266          /* Write the Key */
;;;267          keyaddr = (uint32_t)Key;
;;;268          for(i=0; i<Keylen; i+=4)
0000dc  2500              MOVS     r5,#0
0000de  2c00              CMP      r4,#0
0000e0  d906              BLS      |L2.240|
                  |L2.226|
;;;269          {
;;;270            HASH_DataIn(*(uint32_t*)keyaddr);
0000e2  6830              LDR      r0,[r6,#0]
0000e4  f7fffffe          BL       HASH_DataIn
0000e8  1d2d              ADDS     r5,r5,#4
0000ea  1d36              ADDS     r6,r6,#4
0000ec  42ac              CMP      r4,r5                 ;268
0000ee  d8f8              BHI      |L2.226|
                  |L2.240|
;;;271            keyaddr+=4;
;;;272          }
;;;273    
;;;274          /* Start the HASH processor */
;;;275          HASH_StartDigest();
0000f0  f7fffffe          BL       HASH_StartDigest
;;;276    
;;;277          /* wait until the Busy flag is RESET */
;;;278          counter =0;
0000f4  9700              STR      r7,[sp,#0]
                  |L2.246|
;;;279          do
;;;280          {
;;;281            busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
0000f6  2008              MOVS     r0,#8
0000f8  f7fffffe          BL       HASH_GetFlagStatus
;;;282            counter++;
0000fc  9900              LDR      r1,[sp,#0]
0000fe  1c49              ADDS     r1,r1,#1
;;;283          }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
000100  9100              STR      r1,[sp,#0]
000102  f5b13f80          CMP      r1,#0x10000
000106  d002              BEQ      |L2.270|
000108  2800              CMP      r0,#0
00010a  d1f4              BNE      |L2.246|
00010c  e003              B        |L2.278|
                  |L2.270|
;;;284    
;;;285          if (busystatus != RESET)
00010e  b110              CBZ      r0,|L2.278|
                  |L2.272|
;;;286          {
;;;287            status = ERROR;
000110  f04f0a00          MOV      r10,#0
000114  e016              B        |L2.324|
                  |L2.278|
;;;288          }
;;;289          else
;;;290          {
;;;291            /* Read the message digest */
;;;292            HASH_GetDigest(&SHA1_MessageDigest);
000116  a802              ADD      r0,sp,#8
000118  f7fffffe          BL       HASH_GetDigest
;;;293            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
00011c  9802              LDR      r0,[sp,#8]
00011e  ba00              REV      r0,r0
;;;294            outputaddr+=4;
;;;295            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
000120  f8cb0000          STR      r0,[r11,#0]
000124  9803              LDR      r0,[sp,#0xc]
000126  ba00              REV      r0,r0
;;;296            outputaddr+=4;
;;;297            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
000128  f8cb0004          STR      r0,[r11,#4]
00012c  9804              LDR      r0,[sp,#0x10]
00012e  ba00              REV      r0,r0
;;;298            outputaddr+=4;
;;;299            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
000130  f8cb0008          STR      r0,[r11,#8]
000134  9805              LDR      r0,[sp,#0x14]
000136  ba00              REV      r0,r0
;;;300            outputaddr+=4;
;;;301            *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
000138  f8cb000c          STR      r0,[r11,#0xc]
00013c  9806              LDR      r0,[sp,#0x18]
00013e  ba00              REV      r0,r0
000140  f8cb0010          STR      r0,[r11,#0x10]
                  |L2.324|
;;;302          }
;;;303        }  
;;;304      }
;;;305      return status;  
;;;306    }
000144  b00f              ADD      sp,sp,#0x3c
000146  4650              MOV      r0,r10                ;305
000148  e8bd8ff0          POP      {r4-r11,pc}
;;;307    /**
                          ENDP


;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\stm32f4xx_hash_sha1.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REVSH|
#line 144
|__asm___21_stm32f4xx_hash_sha1_c_328c56b9____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
