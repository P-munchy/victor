; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\stm32f4xx_i2c.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f4xx_i2c.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\stm32f4xx_i2c.crf arm_hal\lib\stm32f4xx_i2c.c]
                          THUMB

                          AREA ||i.I2C_ARPCmd||, CODE, READONLY, ALIGN=1

                  I2C_ARPCmd PROC
;;;717      */
;;;718    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;719    {
;;;720      /* Check the parameters */
;;;721      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;722      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;723      if (NewState != DISABLE)
;;;724      {
;;;725        /* Enable the selected I2C ARP */
;;;726        I2Cx->CR1 |= I2C_CR1_ENARP;
;;;727      }
;;;728      else
;;;729      {
;;;730        /* Disable the selected I2C ARP */
;;;731        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;726
000006  f0410110          ORRNE    r1,r1,#0x10           ;726
00000a  f0210110          BICEQ    r1,r1,#0x10
00000e  8001              STRH     r1,[r0,#0]            ;726
;;;732      }
;;;733    }
000010  4770              BX       lr
;;;734    /**
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;477      */
;;;478    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;479    {
;;;480      /* Check the parameters */
;;;481      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;482      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;483      if (NewState != DISABLE)
;;;484      {
;;;485        /* Enable the acknowledgement */
;;;486        I2Cx->CR1 |= I2C_CR1_ACK;
;;;487      }
;;;488      else
;;;489      {
;;;490        /* Disable the acknowledgement */
;;;491        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;486
000006  f4416180          ORRNE    r1,r1,#0x400          ;486
00000a  f4216180          BICEQ    r1,r1,#0x400
00000e  8001              STRH     r1,[r0,#0]            ;486
;;;492      }
;;;493    }
000010  4770              BX       lr
;;;494    
                          ENDP


                          AREA ||i.I2C_AnalogFilterCmd||, CODE, READONLY, ALIGN=1

                  I2C_AnalogFilterCmd PROC
;;;341      */
;;;342    void I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;343    {
;;;344      /* Check the parameters */
;;;345      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;346      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;347      if (NewState != DISABLE)
;;;348      {
;;;349        /* Enable the analog filter */
;;;350        I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
;;;351      }
;;;352      else
;;;353      {
;;;354        /* Disable the analog filter */
;;;355        I2Cx->FLTR |= I2C_FLTR_ANOFF;
000002  8c81              LDRH     r1,[r0,#0x24]
000004  bf14              ITE      NE                    ;350
000006  f0210110          BICNE    r1,r1,#0x10           ;350
00000a  f0410110          ORREQ    r1,r1,#0x10
00000e  8481              STRH     r1,[r0,#0x24]         ;350
;;;356      }
;;;357    }
000010  4770              BX       lr
;;;358    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;854      */
;;;855    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;856    {
;;;857      /* Check the parameters */
;;;858      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;859      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;860      if (NewState != DISABLE)
;;;861      {
;;;862        /* Enable the selected I2C PEC calculation */
;;;863        I2Cx->CR1 |= I2C_CR1_ENPEC;
;;;864      }
;;;865      else
;;;866      {
;;;867        /* Disable the selected I2C PEC calculation */
;;;868        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;863
000006  f0410120          ORRNE    r1,r1,#0x20           ;863
00000a  f0210120          BICEQ    r1,r1,#0x20
00000e  8001              STRH     r1,[r0,#0]            ;863
;;;869      }
;;;870    }
000010  4770              BX       lr
;;;871    
                          ENDP


                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;1157     */
;;;1158   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000000  8a83              LDRH     r3,[r0,#0x14]
;;;1159   {
;;;1160     uint32_t lastevent = 0;
;;;1161     uint32_t flag1 = 0, flag2 = 0;
;;;1162     ErrorStatus status = ERROR;
000002  2200              MOVS     r2,#0
;;;1163   
;;;1164     /* Check the parameters */
;;;1165     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1166     assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1167   
;;;1168     /* Read the I2Cx status register */
;;;1169     flag1 = I2Cx->SR1;
;;;1170     flag2 = I2Cx->SR2;
000004  8b00              LDRH     r0,[r0,#0x18]
;;;1171     flag2 = flag2 << 16;
;;;1172   
;;;1173     /* Get the last event value from I2C status register */
;;;1174     lastevent = (flag1 | flag2) & FLAG_MASK;
000006  ea434000          ORR      r0,r3,r0,LSL #16
00000a  f020407f          BIC      r0,r0,#0xff000000
;;;1175   
;;;1176     /* Check whether the last event contains the I2C_EVENT */
;;;1177     if ((lastevent & I2C_EVENT) == I2C_EVENT)
00000e  ea310000          BICS     r0,r1,r0
;;;1178     {
;;;1179       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1180       status = SUCCESS;
000012  bf08              IT       EQ
000014  2201              MOVEQ    r2,#1
;;;1181     }
;;;1182     else
;;;1183     {
;;;1184       /* ERROR: last event is different from I2C_EVENT */
;;;1185       status = ERROR;
;;;1186     }
;;;1187     /* Return status */
;;;1188     return status;
000016  4610              MOV      r0,r2
;;;1189   }
000018  4770              BX       lr
;;;1190   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1337     */
;;;1338   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  43c9              MVNS     r1,r1
;;;1339   {
;;;1340     uint32_t flagpos = 0;
;;;1341     /* Check the parameters */
;;;1342     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1343     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1344     /* Get the I2C flag position */
;;;1345     flagpos = I2C_FLAG & FLAG_MASK;
;;;1346     /* Clear the selected I2C flag */
;;;1347     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1348   }
000004  4770              BX       lr
;;;1349   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1431     */
;;;1432   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  43c9              MVNS     r1,r1
;;;1433   {
;;;1434     uint32_t flagpos = 0;
;;;1435     /* Check the parameters */
;;;1436     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1437     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1438   
;;;1439     /* Get the I2C flag position */
;;;1440     flagpos = I2C_IT & FLAG_MASK;
;;;1441   
;;;1442     /* Clear the selected I2C flag */
;;;1443     I2Cx->SR1 = (uint16_t)~flagpos;
000002  8281              STRH     r1,[r0,#0x14]
;;;1444   }
000004  4770              BX       lr
;;;1445   
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;312      */
;;;313    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;314    {
;;;315      /* Check the parameters */
;;;316      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;317      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;318      if (NewState != DISABLE)
;;;319      {
;;;320        /* Enable the selected I2C peripheral */
;;;321        I2Cx->CR1 |= I2C_CR1_PE;
;;;322      }
;;;323      else
;;;324      {
;;;325        /* Disable the selected I2C peripheral */
;;;326        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;321
000006  f0410101          ORRNE    r1,r1,#1              ;321
00000a  f0210101          BICEQ    r1,r1,#1
00000e  8001              STRH     r1,[r0,#0]            ;321
;;;327      }
;;;328    }
000010  4770              BX       lr
;;;329    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;909      */
;;;910    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;911    {
;;;912      /* Check the parameters */
;;;913      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;914      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;915      if (NewState != DISABLE)
;;;916      {
;;;917        /* Enable the selected I2C DMA requests */
;;;918        I2Cx->CR2 |= I2C_CR2_DMAEN;
;;;919      }
;;;920      else
;;;921      {
;;;922        /* Disable the selected I2C DMA requests */
;;;923        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;918
000006  f4416100          ORRNE    r1,r1,#0x800          ;918
00000a  f4216100          BICEQ    r1,r1,#0x800
00000e  8081              STRH     r1,[r0,#4]            ;918
;;;924      }
;;;925    }
000010  4770              BX       lr
;;;926    
                          ENDP


                          AREA ||i.I2C_DMALastTransferCmd||, CODE, READONLY, ALIGN=1

                  I2C_DMALastTransferCmd PROC
;;;933      */
;;;934    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;935    {
;;;936      /* Check the parameters */
;;;937      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;938      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;939      if (NewState != DISABLE)
;;;940      {
;;;941        /* Next DMA transfer is the last transfer */
;;;942        I2Cx->CR2 |= I2C_CR2_LAST;
;;;943      }
;;;944      else
;;;945      {
;;;946        /* Next DMA transfer is not the last transfer */
;;;947        I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
000002  8881              LDRH     r1,[r0,#4]
000004  bf14              ITE      NE                    ;942
000006  f4415180          ORRNE    r1,r1,#0x1000         ;942
00000a  f4215180          BICEQ    r1,r1,#0x1000
00000e  8081              STRH     r1,[r0,#4]            ;942
;;;948      }
;;;949    }
000010  4770              BX       lr
;;;950    
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=1

                  I2C_DeInit PROC
;;;136      */
;;;137    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;138    {
;;;139      /* Check the parameters */
;;;140      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;141    
;;;142      if (I2Cx == I2C1)
000002  f1a04180          SUB      r1,r0,#0x40000000
000006  f5b141a8          SUBS     r1,r1,#0x5400
00000a  d011              BEQ      |L11.48|
;;;143      {
;;;144        /* Enable I2C1 reset state */
;;;145        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
;;;146        /* Release I2C1 from reset state */
;;;147        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
;;;148      }
;;;149      else if (I2Cx == I2C2)
00000c  f5b16180          SUBS     r1,r1,#0x400
000010  d019              BEQ      |L11.70|
;;;150      {
;;;151        /* Enable I2C2 reset state */
;;;152        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
;;;153        /* Release I2C2 from reset state */
;;;154        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
;;;155      }
;;;156      else 
;;;157      {
;;;158        if (I2Cx == I2C3)
000012  f5b16180          SUBS     r1,r1,#0x400
;;;159        {
;;;160          /* Enable I2C3 reset state */
;;;161          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
;;;162          /* Release I2C3 from reset state */
;;;163          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
;;;164        }
;;;165      }
;;;166    }
000016  bf18              IT       NE
000018  bd10              POPNE    {r4,pc}
00001a  2101              MOVS     r1,#1                 ;161
00001c  05c8              LSLS     r0,r1,#23             ;161
00001e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000022  e8bd4010          POP      {r4,lr}               ;163
000026  2100              MOVS     r1,#0                 ;163
000028  f44f0000          MOV      r0,#0x800000          ;163
00002c  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L11.48|
000030  2101              MOVS     r1,#1                 ;145
000032  0548              LSLS     r0,r1,#21             ;145
000034  f7fffffe          BL       RCC_APB1PeriphResetCmd
000038  e8bd4010          POP      {r4,lr}               ;147
00003c  2100              MOVS     r1,#0                 ;147
00003e  f44f1000          MOV      r0,#0x200000          ;147
000042  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L11.70|
000046  2101              MOVS     r1,#1                 ;152
000048  0588              LSLS     r0,r1,#22             ;152
00004a  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004e  e8bd4010          POP      {r4,lr}               ;154
000052  2100              MOVS     r1,#0                 ;154
000054  f44f0080          MOV      r0,#0x400000          ;154
000058  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;167    
                          ENDP


                          AREA ||i.I2C_DigitalFilterConfig||, CODE, READONLY, ALIGN=1

                  I2C_DigitalFilterConfig PROC
;;;370      */
;;;371    void I2C_DigitalFilterConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DigitalFilter)
000000  8c82              LDRH     r2,[r0,#0x24]
;;;372    {
;;;373      uint16_t tmpreg = 0;
;;;374      
;;;375      /* Check the parameters */
;;;376      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;377      assert_param(IS_I2C_DIGITAL_FILTER(I2C_DigitalFilter));
;;;378      
;;;379      /* Get the old register value */
;;;380      tmpreg = I2Cx->FLTR;
;;;381      
;;;382      /* Reset I2Cx DNF bit [3:0] */
;;;383      tmpreg &= (uint16_t)~((uint16_t)I2C_FLTR_DNF);
;;;384      
;;;385      /* Set I2Cx DNF coefficient */
;;;386      tmpreg |= (uint16_t)((uint16_t)I2C_DigitalFilter & I2C_FLTR_DNF);
000002  f001010f          AND      r1,r1,#0xf
000006  f022020f          BIC      r2,r2,#0xf            ;383
00000a  4311              ORRS     r1,r1,r2
;;;387      
;;;388      /* Store the new register value */
;;;389      I2Cx->FLTR = tmpreg;
00000c  8481              STRH     r1,[r0,#0x24]
;;;390    }
00000e  4770              BX       lr
;;;391    
                          ENDP


                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;527      */
;;;528    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;529    {
;;;530      /* Check the parameters */
;;;531      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;532      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;533      if (NewState != DISABLE)
;;;534      {
;;;535        /* Enable dual addressing mode */
;;;536        I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
;;;537      }
;;;538      else
;;;539      {
;;;540        /* Disable dual addressing mode */
;;;541        I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
000002  8981              LDRH     r1,[r0,#0xc]
000004  bf14              ITE      NE                    ;536
000006  f0410101          ORRNE    r1,r1,#1              ;536
00000a  f0210101          BICEQ    r1,r1,#1
00000e  8181              STRH     r1,[r0,#0xc]          ;536
;;;542      }
;;;543    }
000010  4770              BX       lr
;;;544    
                          ENDP


                          AREA ||i.I2C_FastModeDutyCycleConfig||, CODE, READONLY, ALIGN=1

                  I2C_FastModeDutyCycleConfig PROC
;;;627      */
;;;628    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000000  f5b14f80          CMP      r1,#0x4000
;;;629    {
;;;630      /* Check the parameters */
;;;631      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;632      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;633      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
;;;634      {
;;;635        /* I2C fast mode Tlow/Thigh=2 */
;;;636        I2Cx->CCR &= I2C_DutyCycle_2;
;;;637      }
;;;638      else
;;;639      {
;;;640        /* I2C fast mode Tlow/Thigh=16/9 */
;;;641        I2Cx->CCR |= I2C_DutyCycle_16_9;
000004  8b81              LDRH     r1,[r0,#0x1c]
000006  bf14              ITE      NE                    ;636
000008  f4214180          BICNE    r1,r1,#0x4000         ;636
00000c  f4414180          ORREQ    r1,r1,#0x4000
000010  8381              STRH     r1,[r0,#0x1c]         ;636
;;;642      }
;;;643    }
000012  4770              BX       lr
;;;644    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;551      */
;;;552    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;553    {
;;;554      /* Check the parameters */
;;;555      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;556      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;557      if (NewState != DISABLE)
;;;558      {
;;;559        /* Enable generall call */
;;;560        I2Cx->CR1 |= I2C_CR1_ENGC;
;;;561      }
;;;562      else
;;;563      {
;;;564        /* Disable generall call */
;;;565        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;560
000006  f0410140          ORRNE    r1,r1,#0x40           ;560
00000a  f0210140          BICEQ    r1,r1,#0x40
00000e  8001              STRH     r1,[r0,#0]            ;560
;;;566      }
;;;567    }
000010  4770              BX       lr
;;;568    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;398      */
;;;399    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;400    {
;;;401      /* Check the parameters */
;;;402      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;403      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;404      if (NewState != DISABLE)
;;;405      {
;;;406        /* Generate a START condition */
;;;407        I2Cx->CR1 |= I2C_CR1_START;
;;;408      }
;;;409      else
;;;410      {
;;;411        /* Disable the START condition generation */
;;;412        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;407
000006  f4417180          ORRNE    r1,r1,#0x100          ;407
00000a  f4217180          BICEQ    r1,r1,#0x100
00000e  8001              STRH     r1,[r0,#0]            ;407
;;;413      }
;;;414    }
000010  4770              BX       lr
;;;415    
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;422      */
;;;423    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;424    {
;;;425      /* Check the parameters */
;;;426      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;427      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;428      if (NewState != DISABLE)
;;;429      {
;;;430        /* Generate a STOP condition */
;;;431        I2Cx->CR1 |= I2C_CR1_STOP;
;;;432      }
;;;433      else
;;;434      {
;;;435        /* Disable the STOP condition generation */
;;;436        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;431
000006  f4417100          ORRNE    r1,r1,#0x200          ;431
00000a  f4217100          BICEQ    r1,r1,#0x200
00000e  8001              STRH     r1,[r0,#0]            ;431
;;;437      }
;;;438    }
000010  4770              BX       lr
;;;439    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1260     */
;;;1261   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b082              SUB      sp,sp,#8
;;;1262   {
000002  4602              MOV      r2,r0
;;;1263     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1264     __IO uint32_t i2creg = 0, i2cxbase = 0;
;;;1265   
;;;1266     /* Check the parameters */
;;;1267     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1268     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1269   
;;;1270     /* Get the I2Cx peripheral base address */
;;;1271     i2cxbase = (uint32_t)I2Cx;
;;;1272     
;;;1273     /* Read flag register index */
;;;1274     i2creg = I2C_FLAG >> 28;
000006  9200              STR      r2,[sp,#0]
000008  0f0a              LSRS     r2,r1,#28
;;;1275     
;;;1276     /* Get bit[23:0] of the flag */
;;;1277     I2C_FLAG &= FLAG_MASK;
00000a  f021417f          BIC      r1,r1,#0xff000000
00000e  9201              STR      r2,[sp,#4]
;;;1278     
;;;1279     if(i2creg != 0)
;;;1280     {
;;;1281       /* Get the I2Cx SR1 register address */
;;;1282       i2cxbase += 0x14;
;;;1283     }
;;;1284     else
;;;1285     {
;;;1286       /* Flag in I2Cx SR2 Register */
;;;1287       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
000010  bf08              IT       EQ
000012  0c09              LSREQ    r1,r1,#16
;;;1288       /* Get the I2Cx SR2 register address */
;;;1289       i2cxbase += 0x18;
000014  9a00              LDR      r2,[sp,#0]
000016  bf14              ITE      NE
000018  3214              ADDNE    r2,r2,#0x14
00001a  3218              ADDEQ    r2,r2,#0x18
;;;1290     }
;;;1291     
;;;1292     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
00001c  9200              STR      r2,[sp,#0]
00001e  6812              LDR      r2,[r2,#0]
000020  420a              TST      r2,r1
;;;1293     {
;;;1294       /* I2C_FLAG is set */
;;;1295       bitstatus = SET;
000022  bf18              IT       NE
000024  2001              MOVNE    r0,#1
;;;1296     }
;;;1297     else
;;;1298     {
;;;1299       /* I2C_FLAG is reset */
;;;1300       bitstatus = RESET;
;;;1301     }
;;;1302     
;;;1303     /* Return the I2C_FLAG status */
;;;1304     return  bitstatus;
;;;1305   }
000026  b002              ADD      sp,sp,#8
000028  4770              BX       lr
;;;1306   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1371     */
;;;1372   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  8883              LDRH     r3,[r0,#4]
;;;1373   {
;;;1374     ITStatus bitstatus = RESET;
000002  2200              MOVS     r2,#0
;;;1375     uint32_t enablestatus = 0;
;;;1376   
;;;1377     /* Check the parameters */
;;;1378     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1379     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1380   
;;;1381     /* Check if the interrupt source is enabled or not */
;;;1382     enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
000004  f44f6ce0          MOV      r12,#0x700
000008  ea0c4c11          AND      r12,r12,r1,LSR #16
;;;1383     
;;;1384     /* Get bit[23:0] of the flag */
;;;1385     I2C_IT &= FLAG_MASK;
;;;1386   
;;;1387     /* Check the status of the specified I2C flag */
;;;1388     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
00000c  8a80              LDRH     r0,[r0,#0x14]
00000e  ea03030c          AND      r3,r3,r12             ;1382
000012  f021417f          BIC      r1,r1,#0xff000000     ;1385
000016  4208              TST      r0,r1
000018  bf1c              ITT      NE
00001a  2b00              CMPNE    r3,#0
;;;1389     {
;;;1390       /* I2C_IT is set */
;;;1391       bitstatus = SET;
00001c  2201              MOVNE    r2,#1
;;;1392     }
;;;1393     else
;;;1394     {
;;;1395       /* I2C_IT is reset */
;;;1396       bitstatus = RESET;
;;;1397     }
;;;1398     /* Return the I2C_IT status */
;;;1399     return  bitstatus;
00001e  4610              MOV      r0,r2
;;;1400   }
000020  4770              BX       lr
;;;1401   
                          ENDP


                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=1

                  I2C_GetLastEvent PROC
;;;1205     */
;;;1206   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000000  8a81              LDRH     r1,[r0,#0x14]
;;;1207   {
;;;1208     uint32_t lastevent = 0;
;;;1209     uint32_t flag1 = 0, flag2 = 0;
;;;1210   
;;;1211     /* Check the parameters */
;;;1212     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1213   
;;;1214     /* Read the I2Cx status register */
;;;1215     flag1 = I2Cx->SR1;
;;;1216     flag2 = I2Cx->SR2;
000002  8b00              LDRH     r0,[r0,#0x18]
;;;1217     flag2 = flag2 << 16;
;;;1218   
;;;1219     /* Get the last event value from I2C status register */
;;;1220     lastevent = (flag1 | flag2) & FLAG_MASK;
000004  ea414000          ORR      r0,r1,r0,LSL #16
000008  f020407f          BIC      r0,r0,#0xff000000
;;;1221   
;;;1222     /* Return status */
;;;1223     return lastevent;
;;;1224   }
00000c  4770              BX       lr
;;;1225   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;876      */
;;;877    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  8b00              LDRH     r0,[r0,#0x18]
;;;878    {
;;;879      /* Check the parameters */
;;;880      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;881      /* Return the selected I2C PEC value */
;;;882      return ((I2Cx->SR2) >> 8);
000002  0a00              LSRS     r0,r0,#8
;;;883    }
000004  4770              BX       lr
;;;884    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;1098     */
;;;1099   void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1100   {
;;;1101     /* Check the parameters */
;;;1102     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1103     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1104     assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;1105     
;;;1106     if (NewState != DISABLE)
;;;1107     {
;;;1108       /* Enable the selected I2C interrupts */
;;;1109       I2Cx->CR2 |= I2C_IT;
;;;1110     }
;;;1111     else
;;;1112     {
;;;1113       /* Disable the selected I2C interrupts */
;;;1114       I2Cx->CR2 &= (uint16_t)~I2C_IT;
000002  8882              LDRH     r2,[r0,#4]
000004  bf14              ITE      NE                    ;1109
000006  4311              ORRNE    r1,r1,r2              ;1109
000008  ea220101          BICEQ    r1,r2,r1
00000c  8081              STRH     r1,[r0,#4]            ;1109
;;;1115     }
;;;1116   }
00000e  4770              BX       lr
;;;1117   
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;179      */
;;;180    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;181    {
000002  4604              MOV      r4,r0
;;;182      uint16_t tmpreg = 0, freqrange = 0;
;;;183      uint16_t result = 0x04;
;;;184      uint32_t pclk1 = 8000000;
;;;185      RCC_ClocksTypeDef  rcc_clocks;
;;;186      /* Check the parameters */
;;;187      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;188      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;189      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;190      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;191      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;192      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;193      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;194    
;;;195    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;196      /* Get the I2Cx CR2 value */
;;;197      tmpreg = I2Cx->CR2;
000004  8880              LDRH     r0,[r0,#4]
000006  b084              SUB      sp,sp,#0x10           ;181
000008  460d              MOV      r5,r1                 ;181
;;;198      /* Clear frequency FREQ[5:0] bits */
;;;199      tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
00000a  f020063f          BIC      r6,r0,#0x3f
;;;200      /* Get pclk1 frequency value */
;;;201      RCC_GetClocksFreq(&rcc_clocks);
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       RCC_GetClocksFreq
;;;202      pclk1 = rcc_clocks.PCLK1_Frequency;
;;;203      /* Set frequency bits depending on pclk1 value */
;;;204      freqrange = (uint16_t)(pclk1 / 1000000);
000014  4929              LDR      r1,|L23.188|
000016  9802              LDR      r0,[sp,#8]
000018  fbb0f1f1          UDIV     r1,r0,r1
00001c  b289              UXTH     r1,r1
;;;205      tmpreg |= freqrange;
00001e  ea460201          ORR      r2,r6,r1
;;;206      /* Write to I2Cx CR2 */
;;;207      I2Cx->CR2 = tmpreg;
000022  80a2              STRH     r2,[r4,#4]
;;;208    
;;;209    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;210      /* Disable the selected I2C peripheral to configure TRISE */
;;;211      I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
000024  8822              LDRH     r2,[r4,#0]
000026  f0220201          BIC      r2,r2,#1
00002a  8022              STRH     r2,[r4,#0]
;;;212      /* Reset tmpreg value */
;;;213      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;214      tmpreg = 0;
;;;215    
;;;216      /* Configure speed in standard mode */
;;;217      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
00002c  4b24              LDR      r3,|L23.192|
00002e  682a              LDR      r2,[r5,#0]
000030  429a              CMP      r2,r3
000032  d81d              BHI      |L23.112|
;;;218      {
;;;219        /* Standard mode speed calculate */
;;;220        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000034  0052              LSLS     r2,r2,#1
000036  fbb0f0f2          UDIV     r0,r0,r2
00003a  b280              UXTH     r0,r0
;;;221        /* Test if CCR value is under 0x4*/
;;;222        if (result < 0x04)
00003c  2804              CMP      r0,#4
;;;223        {
;;;224          /* Set minimum allowed value */
;;;225          result = 0x04;  
00003e  bf38              IT       CC
000040  2004              MOVCC    r0,#4
000042  1c49              ADDS     r1,r1,#1
;;;226        }
;;;227        /* Set speed value for standard mode */
;;;228        tmpreg |= result;	  
;;;229        /* Set Maximum Rise Time for standard mode */
;;;230        I2Cx->TRISE = freqrange + 1; 
000044  8421              STRH     r1,[r4,#0x20]
                  |L23.70|
;;;231      }
;;;232      /* Configure speed in fast mode */
;;;233      /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
;;;234         input clock) must be a multiple of 10 MHz */
;;;235      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;236      {
;;;237        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
;;;238        {
;;;239          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;240          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
;;;241        }
;;;242        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;243        {
;;;244          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;245          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
;;;246          /* Set DUTY bit */
;;;247          result |= I2C_DutyCycle_16_9;
;;;248        }
;;;249    
;;;250        /* Test if CCR value is under 0x1*/
;;;251        if ((result & I2C_CCR_CCR) == 0)
;;;252        {
;;;253          /* Set minimum allowed value */
;;;254          result |= (uint16_t)0x0001;  
;;;255        }
;;;256        /* Set speed value and set F/S bit for fast mode */
;;;257        tmpreg |= (uint16_t)(result | I2C_CCR_FS);
;;;258        /* Set Maximum Rise Time for fast mode */
;;;259        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
;;;260      }
;;;261    
;;;262      /* Write to I2Cx CCR */
;;;263      I2Cx->CCR = tmpreg;
000046  83a0              STRH     r0,[r4,#0x1c]
;;;264      /* Enable the selected I2C peripheral */
;;;265      I2Cx->CR1 |= I2C_CR1_PE;
000048  8820              LDRH     r0,[r4,#0]
00004a  f0400001          ORR      r0,r0,#1
00004e  8020              STRH     r0,[r4,#0]
;;;266    
;;;267    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;268      /* Get the I2Cx CR1 value */
;;;269      tmpreg = I2Cx->CR1;
000050  8820              LDRH     r0,[r4,#0]
;;;270      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;271      tmpreg &= CR1_CLEAR_MASK;
;;;272      /* Configure I2Cx: mode and acknowledgement */
;;;273      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;274      /* Set ACK bit according to I2C_Ack value */
;;;275      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
000052  88a9              LDRH     r1,[r5,#4]
000054  896a              LDRH     r2,[r5,#0xa]
000056  f020000a          BIC      r0,r0,#0xa            ;271
00005a  f4206080          BIC      r0,r0,#0x400          ;271
00005e  4311              ORRS     r1,r1,r2
000060  4308              ORRS     r0,r0,r1
;;;276      /* Write to I2Cx CR1 */
;;;277      I2Cx->CR1 = tmpreg;
000062  8020              STRH     r0,[r4,#0]
;;;278    
;;;279    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;280      /* Set I2Cx Own Address1 and acknowledged address */
;;;281      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
000064  89a8              LDRH     r0,[r5,#0xc]
000066  8929              LDRH     r1,[r5,#8]
000068  4308              ORRS     r0,r0,r1
00006a  8120              STRH     r0,[r4,#8]
;;;282    }
00006c  b004              ADD      sp,sp,#0x10
00006e  bd70              POP      {r4-r6,pc}
                  |L23.112|
000070  88eb              LDRH     r3,[r5,#6]            ;237
000072  f5a34c3f          SUB      r12,r3,#0xbf00        ;237
000076  f1bc0cff          SUBS     r12,r12,#0xff         ;237
00007a  d019              BEQ      |L23.176|
00007c  eb0203c2          ADD      r3,r2,r2,LSL #3       ;245
000080  eb031202          ADD      r2,r3,r2,LSL #4       ;245
000084  fbb0f0f2          UDIV     r0,r0,r2              ;245
000088  b280              UXTH     r0,r0                 ;245
00008a  f4404080          ORR      r0,r0,#0x4000         ;247
                  |L23.142|
00008e  0502              LSLS     r2,r0,#20             ;251
000090  0d12              LSRS     r2,r2,#20             ;251
000092  bf08              IT       EQ                    ;254
000094  f0400001          ORREQ    r0,r0,#1              ;254
000098  f4404000          ORR      r0,r0,#0x8000         ;257
00009c  f44f7296          MOV      r2,#0x12c             ;259
0000a0  4351              MULS     r1,r2,r1              ;259
0000a2  f44f727a          MOV      r2,#0x3e8             ;259
0000a6  fbb1f1f2          UDIV     r1,r1,r2              ;259
0000aa  1c49              ADDS     r1,r1,#1              ;259
0000ac  8421              STRH     r1,[r4,#0x20]         ;259
0000ae  e7ca              B        |L23.70|
                  |L23.176|
0000b0  eb020242          ADD      r2,r2,r2,LSL #1       ;240
0000b4  fbb0f0f2          UDIV     r0,r0,r2              ;240
0000b8  b280              UXTH     r0,r0                 ;240
0000ba  e7e8              B        |L23.142|
;;;283    
                          ENDP

                  |L23.188|
                          DCD      0x000f4240
                  |L23.192|
                          DCD      0x000186a0

                          AREA ||i.I2C_NACKPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_NACKPositionConfig PROC
;;;665      */
;;;666    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;667    {
;;;668      /* Check the parameters */
;;;669      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;670      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;671      
;;;672      /* Check the input parameter */
;;;673      if (I2C_NACKPosition == I2C_NACKPosition_Next)
;;;674      {
;;;675        /* Next byte in shift register is the last received byte */
;;;676        I2Cx->CR1 |= I2C_NACKPosition_Next;
;;;677      }
;;;678      else
;;;679      {
;;;680        /* Current byte in shift register is the last received byte */
;;;681        I2Cx->CR1 &= I2C_NACKPosition_Current;
000004  8801              LDRH     r1,[r0,#0]
000006  bf0c              ITE      EQ                    ;676
000008  f4416100          ORREQ    r1,r1,#0x800          ;676
00000c  f4216100          BICNE    r1,r1,#0x800
000010  8001              STRH     r1,[r0,#0]            ;676
;;;682      }
;;;683    }
000012  4770              BX       lr
;;;684    
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;500      */
;;;501    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
000000  8982              LDRH     r2,[r0,#0xc]
;;;502    {
;;;503      uint16_t tmpreg = 0;
;;;504    
;;;505      /* Check the parameters */
;;;506      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;507    
;;;508      /* Get the old register value */
;;;509      tmpreg = I2Cx->OAR2;
;;;510    
;;;511      /* Reset I2Cx Own address2 bit [7:1] */
;;;512      tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
;;;513    
;;;514      /* Set I2Cx Own address2 */
;;;515      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
000002  f00101fe          AND      r1,r1,#0xfe
000006  f02202fe          BIC      r2,r2,#0xfe           ;512
00000a  4311              ORRS     r1,r1,r2
;;;516    
;;;517      /* Store the new register value */
;;;518      I2Cx->OAR2 = tmpreg;
00000c  8181              STRH     r1,[r0,#0xc]
;;;519    }
00000e  4770              BX       lr
;;;520    
                          ENDP


                          AREA ||i.I2C_PECPositionConfig||, CODE, READONLY, ALIGN=1

                  I2C_PECPositionConfig PROC
;;;830      */
;;;831    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000000  f5b16f00          CMP      r1,#0x800
;;;832    {
;;;833      /* Check the parameters */
;;;834      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;835      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;836      if (I2C_PECPosition == I2C_PECPosition_Next)
;;;837      {
;;;838        /* Next byte in shift register is PEC */
;;;839        I2Cx->CR1 |= I2C_PECPosition_Next;
;;;840      }
;;;841      else
;;;842      {
;;;843        /* Current byte in shift register is PEC */
;;;844        I2Cx->CR1 &= I2C_PECPosition_Current;
000004  8801              LDRH     r1,[r0,#0]
000006  bf0c              ITE      EQ                    ;839
000008  f4416100          ORREQ    r1,r1,#0x800          ;839
00000c  f4216100          BICNE    r1,r1,#0x800
000010  8001              STRH     r1,[r0,#0]            ;839
;;;845      }
;;;846    }
000012  4770              BX       lr
;;;847    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;1071     */
;;;1072   uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b081              SUB      sp,sp,#4
;;;1073   {
;;;1074     __IO uint32_t tmp = 0;
;;;1075   
;;;1076     /* Check the parameters */
;;;1077     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1078     assert_param(IS_I2C_REGISTER(I2C_Register));
;;;1079   
;;;1080     tmp = (uint32_t) I2Cx;
;;;1081     tmp += I2C_Register;
000002  4408              ADD      r0,r0,r1
;;;1082   
;;;1083     /* Return the selected register value */
;;;1084     return (*(__IO uint16_t *) tmp);
000004  9000              STR      r0,[sp,#0]
000006  8800              LDRH     r0,[r0,#0]
;;;1085   }
000008  b001              ADD      sp,sp,#4
00000a  4770              BX       lr
;;;1086   
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;768      */
;;;769    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;770    {
;;;771      /* Check the parameters */
;;;772      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;773      /* Return the data in the DR register */
;;;774      return (uint8_t)I2Cx->DR;
000002  b2c0              UXTB     r0,r0
;;;775    }
000004  4770              BX       lr
;;;776    
                          ENDP


                          AREA ||i.I2C_SMBusAlertConfig||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertConfig PROC
;;;693      */
;;;694    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000000  f5b15f00          CMP      r1,#0x2000
;;;695    {
;;;696      /* Check the parameters */
;;;697      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;698      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;699      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
;;;700      {
;;;701        /* Drive the SMBusAlert pin Low */
;;;702        I2Cx->CR1 |= I2C_SMBusAlert_Low;
;;;703      }
;;;704      else
;;;705      {
;;;706        /* Drive the SMBusAlert pin High  */
;;;707        I2Cx->CR1 &= I2C_SMBusAlert_High;
000004  8801              LDRH     r1,[r0,#0]
000006  bf0c              ITE      EQ                    ;702
000008  f4415100          ORREQ    r1,r1,#0x2000         ;702
00000c  f4215100          BICNE    r1,r1,#0x2000
000010  8001              STRH     r1,[r0,#0]            ;702
;;;708      }
;;;709    }
000012  4770              BX       lr
;;;710    
                          ENDP


                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  I2C_Send7bitAddress PROC
;;;450      */
;;;451    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000000  2a00              CMP      r2,#0
;;;452    {
;;;453      /* Check the parameters */
;;;454      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;455      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;456      /* Test on the direction to set/reset the read/write bit */
;;;457      if (I2C_Direction != I2C_Direction_Transmitter)
;;;458      {
;;;459        /* Set the address bit0 for read */
;;;460        Address |= I2C_OAR1_ADD0;
000002  bf14              ITE      NE
000004  f0410101          ORRNE    r1,r1,#1
;;;461      }
;;;462      else
;;;463      {
;;;464        /* Reset the address bit0 for write */
;;;465        Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
000008  f00101fe          ANDEQ    r1,r1,#0xfe
;;;466      }
;;;467      /* Send the address */
;;;468      I2Cx->DR = Address;
00000c  8201              STRH     r1,[r0,#0x10]
;;;469    }
00000e  4770              BX       lr
;;;470    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;755      */
;;;756    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  8201              STRH     r1,[r0,#0x10]
;;;757    {
;;;758      /* Check the parameters */
;;;759      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;760      /* Write in the DR register the data to be sent */
;;;761      I2Cx->DR = Data;
;;;762    }
000002  4770              BX       lr
;;;763    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;577      */
;;;578    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;579    {
;;;580      /* Check the parameters */
;;;581      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;582      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;583      if (NewState != DISABLE)
;;;584      {
;;;585        /* Peripheral under reset */
;;;586        I2Cx->CR1 |= I2C_CR1_SWRST;
;;;587      }
;;;588      else
;;;589      {
;;;590        /* Peripheral not under reset */
;;;591        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;586
000006  f4414100          ORRNE    r1,r1,#0x8000         ;586
00000a  f3c1010e          UBFXEQ   r1,r1,#0,#15
00000e  8001              STRH     r1,[r0,#0]            ;586
;;;592      }
;;;593    }
000010  4770              BX       lr
;;;594    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;601      */
;;;602    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;603    {
;;;604      /* Check the parameters */
;;;605      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;606      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;607      if (NewState == DISABLE)
;;;608      {
;;;609        /* Enable the selected I2C Clock stretching */
;;;610        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
;;;611      }
;;;612      else
;;;613      {
;;;614        /* Disable the selected I2C Clock stretching */
;;;615        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
000002  8801              LDRH     r1,[r0,#0]
000004  bf0c              ITE      EQ                    ;610
000006  f0410180          ORREQ    r1,r1,#0x80           ;610
00000a  f0210180          BICNE    r1,r1,#0x80
00000e  8001              STRH     r1,[r0,#0]            ;610
;;;616      }
;;;617    }
000010  4770              BX       lr
;;;618    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;288      */
;;;289    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  f2413188          MOV      r1,#0x1388
;;;290    {
;;;291    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;292      /* initialize the I2C_ClockSpeed member */
;;;293      I2C_InitStruct->I2C_ClockSpeed = 5000;
;;;294      /* Initialize the I2C_Mode member */
;;;295      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;296      /* Initialize the I2C_DutyCycle member */
;;;297      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
00000a  f64b72ff          MOV      r2,#0xbfff
00000e  80c2              STRH     r2,[r0,#6]
;;;298      /* Initialize the I2C_OwnAddress1 member */
;;;299      I2C_InitStruct->I2C_OwnAddress1 = 0;
000010  8101              STRH     r1,[r0,#8]
;;;300      /* Initialize the I2C_Ack member */
;;;301      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000012  8141              STRH     r1,[r0,#0xa]
;;;302      /* Initialize the I2C_AcknowledgedAddress member */
;;;303      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000014  f44f4180          MOV      r1,#0x4000
000018  8181              STRH     r1,[r0,#0xc]
;;;304    }
00001a  4770              BX       lr
;;;305    
                          ENDP


                          AREA ||i.I2C_TransmitPEC||, CODE, READONLY, ALIGN=1

                  I2C_TransmitPEC PROC
;;;799      */
;;;800    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;801    {
;;;802      /* Check the parameters */
;;;803      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;804      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;805      if (NewState != DISABLE)
;;;806      {
;;;807        /* Enable the selected I2C PEC transmission */
;;;808        I2Cx->CR1 |= I2C_CR1_PEC;
;;;809      }
;;;810      else
;;;811      {
;;;812        /* Disable the selected I2C PEC transmission */
;;;813        I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
000002  8801              LDRH     r1,[r0,#0]
000004  bf14              ITE      NE                    ;808
000006  f4415180          ORRNE    r1,r1,#0x1000         ;808
00000a  f4215180          BICEQ    r1,r1,#0x1000
00000e  8001              STRH     r1,[r0,#0]            ;808
;;;814      }
;;;815    }
000010  4770              BX       lr
;;;816    
                          ENDP


;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\stm32f4xx_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___15_stm32f4xx_i2c_c_7174d409____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_i2c_c_7174d409____REVSH|
#line 144
|__asm___15_stm32f4xx_i2c_c_7174d409____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
