; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\stm32f4xx_rtc.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f4xx_rtc.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\stm32f4xx_rtc.crf arm_hal\lib\stm32f4xx_rtc.c]
                          THUMB

                          AREA ||i.RTC_AlarmCmd||, CODE, READONLY, ALIGN=2

                  RTC_AlarmCmd PROC
;;;1309     */
;;;1310   ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
000000  b081              SUB      sp,sp,#4
;;;1311   {
;;;1312     __IO uint32_t alarmcounter = 0x00;
000002  2200              MOVS     r2,#0
;;;1313     uint32_t alarmstatus = 0x00;
;;;1314     ErrorStatus status = ERROR;
;;;1315       
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
;;;1318     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1319   
;;;1320     /* Disable the write protection for RTC registers */
;;;1321     RTC->WPR = 0xCA;
000004  f8dfc050          LDR      r12,|L1.88|
000008  9200              STR      r2,[sp,#0]
00000a  22ca              MOVS     r2,#0xca
00000c  f8cc2000          STR      r2,[r12,#0]
;;;1322     RTC->WPR = 0x53;
000010  2253              MOVS     r2,#0x53
000012  f8cc2000          STR      r2,[r12,#0]
;;;1323   
;;;1324     /* Configure the Alarm state */
;;;1325     if (NewState != DISABLE)
;;;1326     {
;;;1327       RTC->CR |= (uint32_t)RTC_Alarm;
000016  4a11              LDR      r2,|L1.92|
000018  2900              CMP      r1,#0                 ;1325
;;;1328   
;;;1329       status = SUCCESS;    
;;;1330     }
;;;1331     else
;;;1332     { 
;;;1333       /* Disable the Alarm in RTC_CR register */
;;;1334       RTC->CR &= (uint32_t)~RTC_Alarm;
00001a  6811              LDR      r1,[r2,#0]
00001c  d003              BEQ      |L1.38|
00001e  4308              ORRS     r0,r0,r1              ;1327
000020  6010              STR      r0,[r2,#0]            ;1327
000022  2001              MOVS     r0,#1                 ;1329
000024  e012              B        |L1.76|
                  |L1.38|
000026  4381              BICS     r1,r1,r0
000028  6011              STR      r1,[r2,#0]
;;;1335      
;;;1336       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1337       do
;;;1338       {
;;;1339         alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
00002a  4a0d              LDR      r2,|L1.96|
                  |L1.44|
00002c  6811              LDR      r1,[r2,#0]
;;;1340         alarmcounter++;  
00002e  9b00              LDR      r3,[sp,#0]
000030  ea012110          AND      r1,r1,r0,LSR #8       ;1339
000034  1c5b              ADDS     r3,r3,#1
;;;1341       } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
000036  9300              STR      r3,[sp,#0]
000038  f5b33f80          CMP      r3,#0x10000
00003c  d001              BEQ      |L1.66|
00003e  2900              CMP      r1,#0
000040  d0f4              BEQ      |L1.44|
                  |L1.66|
;;;1342       
;;;1343       if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
000042  6811              LDR      r1,[r2,#0]
000044  ea112010          ANDS     r0,r1,r0,LSR #8
;;;1344       {
;;;1345         status = ERROR;
;;;1346       } 
;;;1347       else
;;;1348       {
;;;1349         status = SUCCESS;
000048  bf18              IT       NE
00004a  2001              MOVNE    r0,#1
                  |L1.76|
;;;1350       }        
;;;1351     } 
;;;1352   
;;;1353     /* Enable the write protection for RTC registers */
;;;1354     RTC->WPR = 0xFF; 
00004c  21ff              MOVS     r1,#0xff
00004e  f8cc1000          STR      r1,[r12,#0]
;;;1355     
;;;1356     return status;
;;;1357   }
000052  b001              ADD      sp,sp,#4
000054  4770              BX       lr
;;;1358   
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0x40002824
                  |L1.92|
                          DCD      0x40002808
                  |L1.96|
                          DCD      0x4000280c

                          AREA ||i.RTC_AlarmStructInit||, CODE, READONLY, ALIGN=1

                  RTC_AlarmStructInit PROC
;;;1225     */
;;;1226   void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  2100              MOVS     r1,#0
;;;1227   {
;;;1228     /* Alarm Time Settings : Time = 00h:00mn:00sec */
;;;1229     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;1230     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;1231     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;1232     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
000008  7081              STRB     r1,[r0,#2]
;;;1233   
;;;1234     /* Alarm Date Settings : Date = 1st day of the month */
;;;1235     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
;;;1236     RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
00000a  2201              MOVS     r2,#1
00000c  6081              STR      r1,[r0,#8]
00000e  7302              STRB     r2,[r0,#0xc]
;;;1237   
;;;1238     /* Alarm Masks Settings : Mask =  all fields are not masked */
;;;1239     RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
000010  6041              STR      r1,[r0,#4]
;;;1240   }
000012  4770              BX       lr
;;;1241   
                          ENDP


                          AREA ||i.RTC_AlarmSubSecondConfig||, CODE, READONLY, ALIGN=2

                  RTC_AlarmSubSecondConfig PROC
;;;1403     */
;;;1404   void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
000000  4b09              LDR      r3,|L3.40|
;;;1405   {
;;;1406     uint32_t tmpreg = 0;
;;;1407   
;;;1408     /* Check the parameters */
;;;1409     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1410     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
;;;1411     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
;;;1412     
;;;1413     /* Disable the write protection for RTC registers */
;;;1414     RTC->WPR = 0xCA;
000002  f04f0cca          MOV      r12,#0xca
000006  f8c3c000          STR      r12,[r3,#0]
;;;1415     RTC->WPR = 0x53;
00000a  f04f0c53          MOV      r12,#0x53
00000e  f8c3c000          STR      r12,[r3,#0]
;;;1416     
;;;1417     /* Configure the Alarm A or Alarm B Sub Second registers */
;;;1418     tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
000012  4311              ORRS     r1,r1,r2
;;;1419     
;;;1420     if (RTC_Alarm == RTC_Alarm_A)
000014  f5b07f80          CMP      r0,#0x100
;;;1421     {
;;;1422       /* Configure the Alarm A Sub Second register */
;;;1423       RTC->ALRMASSR = tmpreg;
000018  bf0c              ITE      EQ
00001a  4804              LDREQ    r0,|L3.44|
;;;1424     }
;;;1425     else
;;;1426     {
;;;1427       /* Configure the Alarm B Sub Second register */
;;;1428       RTC->ALRMBSSR = tmpreg;
00001c  4804              LDRNE    r0,|L3.48|
00001e  6001              STR      r1,[r0,#0]
;;;1429     }
;;;1430   
;;;1431     /* Enable the write protection for RTC registers */
;;;1432     RTC->WPR = 0xFF;
000020  20ff              MOVS     r0,#0xff
000022  6018              STR      r0,[r3,#0]
;;;1433   
;;;1434   }
000024  4770              BX       lr
;;;1435   
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40002824
                  |L3.44|
                          DCD      0x40002844
                  |L3.48|
                          DCD      0x40002848

                          AREA ||i.RTC_BypassShadowCmd||, CODE, READONLY, ALIGN=2

                  RTC_BypassShadowCmd PROC
;;;709    */
;;;710    void RTC_BypassShadowCmd(FunctionalState NewState)
000000  4a08              LDR      r2,|L4.36|
;;;711    {
;;;712      /* Check the parameters */
;;;713      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;714    
;;;715      /* Disable the write protection for RTC registers */
;;;716      RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;717      RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;718      
;;;719      if (NewState != DISABLE)
;;;720      {
;;;721        /* Set the BYPSHAD bit */
;;;722        RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
00000a  4907              LDR      r1,|L4.40|
00000c  2800              CMP      r0,#0                 ;719
;;;723      }
;;;724      else
;;;725      {
;;;726        /* Reset the BYPSHAD bit */
;;;727        RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
00000e  6808              LDR      r0,[r1,#0]
000010  bf14              ITE      NE                    ;722
000012  f0400020          ORRNE    r0,r0,#0x20           ;722
000016  f00000df          ANDEQ    r0,r0,#0xdf
00001a  6008              STR      r0,[r1,#0]
;;;728      }
;;;729    
;;;730      /* Enable the write protection for RTC registers */
;;;731      RTC->WPR = 0xFF;
00001c  20ff              MOVS     r0,#0xff
00001e  6010              STR      r0,[r2,#0]
;;;732    }
000020  4770              BX       lr
;;;733    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x40002824
                  |L4.40|
                          DCD      0x40002808

                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;2723     */
;;;2724   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  2100              MOVS     r1,#0
;;;2725   {
;;;2726     uint8_t bcdhigh = 0;
;;;2727     
;;;2728     while (Value >= 10)
000002  280a              CMP      r0,#0xa
000004  d305              BCC      |L5.18|
                  |L5.6|
000006  1c49              ADDS     r1,r1,#1              ;2725
;;;2729     {
;;;2730       bcdhigh++;
000008  380a              SUBS     r0,r0,#0xa
;;;2731       Value -= 10;
00000a  b2c0              UXTB     r0,r0
00000c  b2c9              UXTB     r1,r1                 ;2730
00000e  280a              CMP      r0,#0xa               ;2728
000010  d2f9              BCS      |L5.6|
                  |L5.18|
;;;2732     }
;;;2733     
;;;2734     return  ((uint8_t)(bcdhigh << 4) | Value);
000012  0709              LSLS     r1,r1,#28
000014  ea406011          ORR      r0,r0,r1,LSR #24
;;;2735   }
000018  4770              BX       lr
;;;2736   
                          ENDP


                          AREA ||i.RTC_CalibOutputCmd||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputCmd PROC
;;;1837     */
;;;1838   void RTC_CalibOutputCmd(FunctionalState NewState)
000000  4a08              LDR      r2,|L6.36|
;;;1839   {
;;;1840     /* Check the parameters */
;;;1841     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1842     
;;;1843     /* Disable the write protection for RTC registers */
;;;1844     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1845     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1846     
;;;1847     if (NewState != DISABLE)
;;;1848     {
;;;1849       /* Enable the RTC clock output */
;;;1850       RTC->CR |= (uint32_t)RTC_CR_COE;
00000a  4907              LDR      r1,|L6.40|
00000c  2800              CMP      r0,#0                 ;1847
;;;1851     }
;;;1852     else
;;;1853     { 
;;;1854       /* Disable the RTC clock output */
;;;1855       RTC->CR &= (uint32_t)~RTC_CR_COE;
00000e  6808              LDR      r0,[r1,#0]
000010  bf14              ITE      NE                    ;1850
000012  f4400000          ORRNE    r0,r0,#0x800000       ;1850
000016  f4200000          BICEQ    r0,r0,#0x800000
00001a  6008              STR      r0,[r1,#0]
;;;1856     }
;;;1857     
;;;1858     /* Enable the write protection for RTC registers */
;;;1859     RTC->WPR = 0xFF; 
00001c  20ff              MOVS     r0,#0xff
00001e  6010              STR      r0,[r2,#0]
;;;1860   }
000020  4770              BX       lr
;;;1861   
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      0x40002824
                  |L6.40|
                          DCD      0x40002808

                          AREA ||i.RTC_CalibOutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputConfig PROC
;;;1869   */
;;;1870   void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
000000  4a07              LDR      r2,|L7.32|
;;;1871   {
;;;1872     /* Check the parameters */
;;;1873     assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
;;;1874   
;;;1875     /* Disable the write protection for RTC registers */
;;;1876     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1877     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1878     
;;;1879     /*clear flags before configuration */
;;;1880     RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
00000a  4906              LDR      r1,|L7.36|
00000c  680b              LDR      r3,[r1,#0]
00000e  f4232300          BIC      r3,r3,#0x80000
000012  600b              STR      r3,[r1,#0]
;;;1881   
;;;1882     /* Configure the RTC_CR register */
;;;1883     RTC->CR |= (uint32_t)RTC_CalibOutput;
000014  680b              LDR      r3,[r1,#0]
000016  4318              ORRS     r0,r0,r3
000018  6008              STR      r0,[r1,#0]
;;;1884   
;;;1885     /* Enable the write protection for RTC registers */
;;;1886     RTC->WPR = 0xFF;
00001a  20ff              MOVS     r0,#0xff
00001c  6010              STR      r0,[r2,#0]
;;;1887   }
00001e  4770              BX       lr
;;;1888   
                          ENDP

                  |L7.32|
                          DCD      0x40002824
                  |L7.36|
                          DCD      0x40002808

                          AREA ||i.RTC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RTC_ClearFlag PROC
;;;2640     */
;;;2641   void RTC_ClearFlag(uint32_t RTC_FLAG)
000000  b280              UXTH     r0,r0
;;;2642   {
;;;2643     /* Check the parameters */
;;;2644     assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
;;;2645   
;;;2646     /* Clear the Flags in the RTC_ISR register */
;;;2647     RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
000002  f0400080          ORR      r0,r0,#0x80
000006  43c1              MVNS     r1,r0
000008  4803              LDR      r0,|L8.24|
00000a  6802              LDR      r2,[r0,#0]
00000c  f0020280          AND      r2,r2,#0x80
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;2648   }
000014  4770              BX       lr
;;;2649   
                          ENDP

000016  0000              DCW      0x0000
                  |L8.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RTC_ClearITPendingBit PROC
;;;2700     */
;;;2701   void RTC_ClearITPendingBit(uint32_t RTC_IT)
000000  f3c0100f          UBFX     r0,r0,#4,#16
;;;2702   {
;;;2703     uint32_t tmpreg = 0;
;;;2704   
;;;2705     /* Check the parameters */
;;;2706     assert_param(IS_RTC_CLEAR_IT(RTC_IT));
;;;2707   
;;;2708     /* Get the RTC_ISR Interrupt pending bits mask */
;;;2709     tmpreg = (uint32_t)(RTC_IT >> 4);
;;;2710   
;;;2711     /* Clear the interrupt pending bits in the RTC_ISR register */
;;;2712     RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
000004  f0400080          ORR      r0,r0,#0x80
000008  43c1              MVNS     r1,r0
00000a  4803              LDR      r0,|L9.24|
00000c  6802              LDR      r2,[r0,#0]
00000e  f0020280          AND      r2,r2,#0x80
000012  4311              ORRS     r1,r1,r2
000014  6001              STR      r1,[r0,#0]
;;;2713   }
000016  4770              BX       lr
;;;2714   
                          ENDP

                  |L9.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_CoarseCalibCmd||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibCmd PROC
;;;1791     */
;;;1792   ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1793   {
;;;1794     ErrorStatus status = ERROR;
;;;1795     
;;;1796     /* Check the parameters */
;;;1797     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1798   
;;;1799     /* Disable the write protection for RTC registers */
;;;1800     RTC->WPR = 0xCA;
000002  4c0e              LDR      r4,|L10.60|
000004  4605              MOV      r5,r0                 ;1793
000006  2300              MOVS     r3,#0                 ;1794
000008  20ca              MOVS     r0,#0xca
00000a  6020              STR      r0,[r4,#0]
;;;1801     RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6020              STR      r0,[r4,#0]
;;;1802     
;;;1803     /* Set Initialization mode */
;;;1804     if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b170              CBZ      r0,|L10.52|
;;;1805     {
;;;1806       status =  ERROR;
;;;1807     }
;;;1808     else
;;;1809     {
;;;1810       if (NewState != DISABLE)
;;;1811       {
;;;1812         /* Enable the Coarse Calibration */
;;;1813         RTC->CR |= (uint32_t)RTC_CR_DCE;
000016  480a              LDR      r0,|L10.64|
000018  2d00              CMP      r5,#0                 ;1810
;;;1814       }
;;;1815       else
;;;1816       { 
;;;1817         /* Disable the Coarse Calibration */
;;;1818         RTC->CR &= (uint32_t)~RTC_CR_DCE;
00001a  6801              LDR      r1,[r0,#0]
00001c  bf0c              ITE      EQ
00001e  f0210180          BICEQ    r1,r1,#0x80
000022  f0410180          ORRNE    r1,r1,#0x80           ;1813
000026  6001              STR      r1,[r0,#0]
000028  4806              LDR      r0,|L10.68|
00002a  6801              LDR      r1,[r0,#0]
00002c  f0210180          BIC      r1,r1,#0x80
000030  6001              STR      r1,[r0,#0]
;;;1819       }
;;;1820       /* Exit Initialization mode */
;;;1821       RTC_ExitInitMode();
;;;1822       
;;;1823       status = SUCCESS;
000032  2301              MOVS     r3,#1
                  |L10.52|
;;;1824     } 
;;;1825     
;;;1826     /* Enable the write protection for RTC registers */
;;;1827     RTC->WPR = 0xFF; 
000034  20ff              MOVS     r0,#0xff
000036  6020              STR      r0,[r4,#0]
;;;1828     
;;;1829     return status;
000038  4618              MOV      r0,r3
;;;1830   }
00003a  bd30              POP      {r4,r5,pc}
;;;1831   
                          ENDP

                  |L10.60|
                          DCD      0x40002824
                  |L10.64|
                          DCD      0x40002808
                  |L10.68|
                          DCD      0x4000280c

                          AREA ||i.RTC_CoarseCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibConfig PROC
;;;1750     */
;;;1751   ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
000000  b570              PUSH     {r4-r6,lr}
;;;1752   {
;;;1753     ErrorStatus status = ERROR;
;;;1754      
;;;1755     /* Check the parameters */
;;;1756     assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
;;;1757     assert_param(IS_RTC_CALIB_VALUE(Value)); 
;;;1758   
;;;1759     /* Disable the write protection for RTC registers */
;;;1760     RTC->WPR = 0xCA;
000002  4c0c              LDR      r4,|L11.52|
000004  4605              MOV      r5,r0                 ;1752
000006  2300              MOVS     r3,#0                 ;1753
000008  20ca              MOVS     r0,#0xca
00000a  460e              MOV      r6,r1                 ;1752
00000c  6020              STR      r0,[r4,#0]
;;;1761     RTC->WPR = 0x53;
00000e  2053              MOVS     r0,#0x53
000010  6020              STR      r0,[r4,#0]
;;;1762   
;;;1763     /* Set Initialization mode */
;;;1764     if (RTC_EnterInitMode() == ERROR)
000012  f7fffffe          BL       RTC_EnterInitMode
000016  b148              CBZ      r0,|L11.44|
;;;1765     {
;;;1766       status = ERROR;
;;;1767     } 
;;;1768     else
;;;1769     {
;;;1770       /* Set the coarse calibration value */
;;;1771       RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
000018  4907              LDR      r1,|L11.56|
00001a  ea450006          ORR      r0,r5,r6
00001e  6008              STR      r0,[r1,#0]
000020  4806              LDR      r0,|L11.60|
000022  6801              LDR      r1,[r0,#0]
000024  f0210180          BIC      r1,r1,#0x80
000028  6001              STR      r1,[r0,#0]
;;;1772       /* Exit Initialization mode */
;;;1773       RTC_ExitInitMode();
;;;1774       
;;;1775       status = SUCCESS;
00002a  2301              MOVS     r3,#1
                  |L11.44|
;;;1776     } 
;;;1777   
;;;1778     /* Enable the write protection for RTC registers */
;;;1779     RTC->WPR = 0xFF; 
00002c  20ff              MOVS     r0,#0xff
00002e  6020              STR      r0,[r4,#0]
;;;1780     
;;;1781     return status;
000030  4618              MOV      r0,r3
;;;1782   }
000032  bd70              POP      {r4-r6,pc}
;;;1783   
                          ENDP

                  |L11.52|
                          DCD      0x40002824
                  |L11.56|
                          DCD      0x40002818
                  |L11.60|
                          DCD      0x4000280c

                          AREA ||i.RTC_DateStructInit||, CODE, READONLY, ALIGN=1

                  RTC_DateStructInit PROC
;;;1035     */
;;;1036   void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
000000  2101              MOVS     r1,#1
;;;1037   {
;;;1038     /* Monday, January 01 xx00 */
;;;1039     RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
000002  7001              STRB     r1,[r0,#0]
;;;1040     RTC_DateStruct->RTC_Date = 1;
000004  7081              STRB     r1,[r0,#2]
;;;1041     RTC_DateStruct->RTC_Month = RTC_Month_January;
000006  7041              STRB     r1,[r0,#1]
;;;1042     RTC_DateStruct->RTC_Year = 0;
000008  2100              MOVS     r1,#0
00000a  70c1              STRB     r1,[r0,#3]
;;;1043   }
00000c  4770              BX       lr
;;;1044   
                          ENDP


                          AREA ||i.RTC_DayLightSavingConfig||, CODE, READONLY, ALIGN=2

                  RTC_DayLightSavingConfig PROC
;;;1630     */
;;;1631   void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
000000  4b0a              LDR      r3,|L13.44|
;;;1632   {
;;;1633     /* Check the parameters */
;;;1634     assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
;;;1635     assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
;;;1636   
;;;1637     /* Disable the write protection for RTC registers */
;;;1638     RTC->WPR = 0xCA;
000002  22ca              MOVS     r2,#0xca
000004  601a              STR      r2,[r3,#0]
;;;1639     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  601a              STR      r2,[r3,#0]
;;;1640   
;;;1641     /* Clear the bits to be configured */
;;;1642     RTC->CR &= (uint32_t)~(RTC_CR_BCK);
00000a  4a09              LDR      r2,|L13.48|
00000c  f8d2c000          LDR      r12,[r2,#0]
000010  f42c2c80          BIC      r12,r12,#0x40000
000014  f8c2c000          STR      r12,[r2,#0]
;;;1643   
;;;1644     /* Configure the RTC_CR register */
;;;1645     RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
000018  f8d2c000          LDR      r12,[r2,#0]
00001c  4308              ORRS     r0,r0,r1
00001e  ea4c0000          ORR      r0,r12,r0
000022  6010              STR      r0,[r2,#0]
;;;1646   
;;;1647     /* Enable the write protection for RTC registers */
;;;1648     RTC->WPR = 0xFF; 
000024  20ff              MOVS     r0,#0xff
000026  6018              STR      r0,[r3,#0]
;;;1649   }
000028  4770              BX       lr
;;;1650   
                          ENDP

00002a  0000              DCW      0x0000
                  |L13.44|
                          DCD      0x40002824
                  |L13.48|
                          DCD      0x40002808

                          AREA ||i.RTC_DeInit||, CODE, READONLY, ALIGN=2

                  RTC_DeInit PROC
;;;374      */
;;;375    ErrorStatus RTC_DeInit(void)
000000  b538              PUSH     {r3-r5,lr}
;;;376    {
;;;377      __IO uint32_t wutcounter = 0x00;
000002  2300              MOVS     r3,#0
;;;378      uint32_t wutwfstatus = 0x00;
;;;379      ErrorStatus status = ERROR;
;;;380      
;;;381      /* Disable the write protection for RTC registers */
;;;382      RTC->WPR = 0xCA;
000004  4d28              LDR      r5,|L14.168|
000006  20ca              MOVS     r0,#0xca
000008  9300              STR      r3,[sp,#0]
00000a  461c              MOV      r4,r3                 ;379
00000c  6028              STR      r0,[r5,#0]
;;;383      RTC->WPR = 0x53;
00000e  2053              MOVS     r0,#0x53
000010  6028              STR      r0,[r5,#0]
;;;384    
;;;385      /* Set Initialization mode */
;;;386      if (RTC_EnterInitMode() == ERROR)
000012  f7fffffe          BL       RTC_EnterInitMode
000016  2800              CMP      r0,#0
000018  d040              BEQ      |L14.156|
;;;387      {
;;;388        status = ERROR;
;;;389      }  
;;;390      else
;;;391      {
;;;392        /* Reset TR, DR and CR registers */
;;;393        RTC->TR = (uint32_t)0x00000000;
00001a  4824              LDR      r0,|L14.172|
00001c  6003              STR      r3,[r0,#0]
;;;394        RTC->DR = (uint32_t)0x00002101;
00001e  4924              LDR      r1,|L14.176|
000020  f2421001          MOV      r0,#0x2101
000024  6008              STR      r0,[r1,#0]
;;;395        /* Reset All CR bits except CR[2:0] */
;;;396        RTC->CR &= (uint32_t)0x00000007;
000026  f1010c04          ADD      r12,r1,#4
00002a  f8dc0000          LDR      r0,[r12,#0]
00002e  f0000007          AND      r0,r0,#7
000032  f8cc0000          STR      r0,[r12,#0]
;;;397      
;;;398        /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;399        do
;;;400        {
;;;401          wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
000036  f10c0104          ADD      r1,r12,#4
                  |L14.58|
00003a  6808              LDR      r0,[r1,#0]
;;;402          wutcounter++;  
00003c  9a00              LDR      r2,[sp,#0]
00003e  f0000004          AND      r0,r0,#4              ;401
000042  1c52              ADDS     r2,r2,#1
;;;403        } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
000044  9200              STR      r2,[sp,#0]
000046  f5b23f80          CMP      r2,#0x10000
00004a  d001              BEQ      |L14.80|
00004c  2800              CMP      r0,#0
00004e  d0f4              BEQ      |L14.58|
                  |L14.80|
;;;404        
;;;405        if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
000050  6808              LDR      r0,[r1,#0]
000052  f0100f04          TST      r0,#4
000056  d025              BEQ      |L14.164|
;;;406        {
;;;407          status = ERROR;
;;;408        }
;;;409        else
;;;410        {
;;;411          /* Reset all RTC CR register bits */
;;;412          RTC->CR &= (uint32_t)0x00000000;
000058  f8dc0000          LDR      r0,[r12,#0]
00005c  f8cc3000          STR      r3,[r12,#0]
;;;413          RTC->WUTR = (uint32_t)0x0000FFFF;
000060  4a14              LDR      r2,|L14.180|
000062  f64f70ff          MOV      r0,#0xffff
000066  6010              STR      r0,[r2,#0]
;;;414          RTC->PRER = (uint32_t)0x007F00FF;
000068  1f12              SUBS     r2,r2,#4
00006a  4813              LDR      r0,|L14.184|
00006c  6010              STR      r0,[r2,#0]
;;;415          RTC->CALIBR = (uint32_t)0x00000000;
00006e  4813              LDR      r0,|L14.188|
000070  6003              STR      r3,[r0,#0]
;;;416          RTC->ALRMAR = (uint32_t)0x00000000;        
000072  1d00              ADDS     r0,r0,#4
000074  6003              STR      r3,[r0,#0]
;;;417          RTC->ALRMBR = (uint32_t)0x00000000;
000076  1d00              ADDS     r0,r0,#4
000078  6003              STR      r3,[r0,#0]
;;;418          RTC->SHIFTR = (uint32_t)0x00000000;
00007a  4811              LDR      r0,|L14.192|
00007c  6003              STR      r3,[r0,#0]
;;;419          RTC->CALR = (uint32_t)0x00000000;
00007e  4811              LDR      r0,|L14.196|
000080  6003              STR      r3,[r0,#0]
;;;420          RTC->ALRMASSR = (uint32_t)0x00000000;
000082  4811              LDR      r0,|L14.200|
000084  6003              STR      r3,[r0,#0]
;;;421          RTC->ALRMBSSR = (uint32_t)0x00000000;
000086  1d00              ADDS     r0,r0,#4
000088  6003              STR      r3,[r0,#0]
;;;422          
;;;423          /* Reset ISR register and exit initialization mode */
;;;424          RTC->ISR = (uint32_t)0x00000000;
00008a  600b              STR      r3,[r1,#0]
;;;425          
;;;426          /* Reset Tamper and alternate functions configuration register */
;;;427          RTC->TAFCR = 0x00000000;
00008c  480f              LDR      r0,|L14.204|
00008e  6003              STR      r3,[r0,#0]
;;;428      
;;;429          if(RTC_WaitForSynchro() == ERROR)
000090  f7fffffe          BL       RTC_WaitForSynchro
000094  2800              CMP      r0,#0
;;;430          {
;;;431            status = ERROR;
;;;432          }
;;;433          else
;;;434          {
;;;435            status = SUCCESS;      
000096  bf18              IT       NE
000098  2401              MOVNE    r4,#1
00009a  d003              BEQ      |L14.164|
                  |L14.156|
;;;436          }
;;;437        }
;;;438      }
;;;439      
;;;440      /* Enable the write protection for RTC registers */
;;;441      RTC->WPR = 0xFF;  
00009c  20ff              MOVS     r0,#0xff
00009e  6028              STR      r0,[r5,#0]
;;;442      
;;;443      return status;
0000a0  4620              MOV      r0,r4
;;;444    }
0000a2  bd38              POP      {r3-r5,pc}
                  |L14.164|
0000a4  2400              MOVS     r4,#0                 ;431
0000a6  e7f9              B        |L14.156|
;;;445    
                          ENDP

                  |L14.168|
                          DCD      0x40002824
                  |L14.172|
                          DCD      0x40002800
                  |L14.176|
                          DCD      0x40002804
                  |L14.180|
                          DCD      0x40002814
                  |L14.184|
                          DCD      0x007f00ff
                  |L14.188|
                          DCD      0x40002818
                  |L14.192|
                          DCD      0x4000282c
                  |L14.196|
                          DCD      0x4000283c
                  |L14.200|
                          DCD      0x40002844
                  |L14.204|
                          DCD      0x40002840

                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=2

                  RTC_EnterInitMode PROC
;;;551      */
;;;552    ErrorStatus RTC_EnterInitMode(void)
000000  b081              SUB      sp,sp,#4
;;;553    {
;;;554      __IO uint32_t initcounter = 0x00;
;;;555      ErrorStatus status = ERROR;
;;;556      uint32_t initstatus = 0x00;
;;;557         
;;;558      /* Check if the Initialization mode is set */
;;;559      if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
000002  490f              LDR      r1,|L15.64|
000004  2000              MOVS     r0,#0                 ;554
000006  9000              STR      r0,[sp,#0]
000008  6808              LDR      r0,[r1,#0]
00000a  f0100f40          TST      r0,#0x40
;;;560      {
;;;561        /* Set the Initialization mode */
;;;562        RTC->ISR = (uint32_t)RTC_INIT_MASK;
00000e  bf04              ITT      EQ
000010  f04f30ff          MOVEQ    r0,#0xffffffff
000014  6008              STREQ    r0,[r1,#0]
000016  d110              BNE      |L15.58|
                  |L15.24|
;;;563        
;;;564        /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;565        do
;;;566        {
;;;567          initstatus = RTC->ISR & RTC_ISR_INITF;
000018  6808              LDR      r0,[r1,#0]
;;;568          initcounter++;  
00001a  9a00              LDR      r2,[sp,#0]
00001c  f0000040          AND      r0,r0,#0x40           ;567
000020  1c52              ADDS     r2,r2,#1
;;;569        } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
000022  9200              STR      r2,[sp,#0]
000024  f5b23f80          CMP      r2,#0x10000
000028  d001              BEQ      |L15.46|
00002a  2800              CMP      r0,#0
00002c  d0f4              BEQ      |L15.24|
                  |L15.46|
;;;570        
;;;571        if ((RTC->ISR & RTC_ISR_INITF) != RESET)
00002e  6808              LDR      r0,[r1,#0]
000030  f0100040          ANDS     r0,r0,#0x40
;;;572        {
;;;573          status = SUCCESS;
;;;574        }
;;;575        else
;;;576        {
;;;577          status = ERROR;
;;;578        }        
;;;579      }
;;;580      else
;;;581      {
;;;582        status = SUCCESS;  
;;;583      } 
;;;584        
;;;585      return (status);  
;;;586    }
000034  bf04              ITT      EQ
000036  b001              ADDEQ    sp,sp,#4
000038  4770              BXEQ     lr
                  |L15.58|
00003a  2001              MOVS     r0,#1                 ;582
00003c  b001              ADD      sp,sp,#4
00003e  4770              BX       lr
;;;587    
                          ENDP

                  |L15.64|
                          DCD      0x4000280c

                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=2

                  RTC_ExitInitMode PROC
;;;596      */
;;;597    void RTC_ExitInitMode(void)
000000  4802              LDR      r0,|L16.12|
;;;598    { 
;;;599      /* Exit Initialization mode */
;;;600      RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
000002  6801              LDR      r1,[r0,#0]
000004  f0210180          BIC      r1,r1,#0x80
000008  6001              STR      r1,[r0,#0]
;;;601    }
00000a  4770              BX       lr
;;;602    
                          ENDP

                  |L16.12|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarm PROC
;;;1255     */
;;;1256   void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b470              PUSH     {r4-r6}
;;;1257   {
;;;1258     uint32_t tmpreg = 0;
;;;1259   
;;;1260     /* Check the parameters */
;;;1261     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1262     assert_param(IS_RTC_ALARM(RTC_Alarm)); 
;;;1263   
;;;1264     /* Get the RTC_ALRMxR register */
;;;1265     if (RTC_Alarm == RTC_Alarm_A)
000002  f5b17f80          CMP      r1,#0x100
;;;1266     {
;;;1267       tmpreg = (uint32_t)(RTC->ALRMAR);
000006  bf0c              ITE      EQ
000008  4920              LDREQ    r1,|L17.140|
;;;1268     }
;;;1269     else
;;;1270     {
;;;1271       tmpreg = (uint32_t)(RTC->ALRMBR);
00000a  4921              LDRNE    r1,|L17.144|
00000c  6809              LDR      r1,[r1,#0]
;;;1272     }
;;;1273   
;;;1274     /* Fill the structure with the read parameters */
;;;1275     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
;;;1276                                                        RTC_ALRMAR_HU)) >> 16);
;;;1277     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
;;;1278                                                        RTC_ALRMAR_MNU)) >> 8);
;;;1279     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
;;;1280                                                        RTC_ALRMAR_SU));
;;;1281     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
00000e  2340              MOVS     r3,#0x40
000010  f3c14405          UBFX     r4,r1,#16,#6          ;1275
000014  7014              STRB     r4,[r2,#0]            ;1275
000016  f3c12506          UBFX     r5,r1,#8,#7           ;1277
00001a  7055              STRB     r5,[r2,#1]            ;1277
00001c  f0010c7f          AND      r12,r1,#0x7f          ;1279
000020  f882c002          STRB     r12,[r2,#2]           ;1279
000024  ea034311          AND      r3,r3,r1,LSR #16
000028  70d3              STRB     r3,[r2,#3]
;;;1282     RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
00002a  f3c16305          UBFX     r3,r1,#24,#6
;;;1283     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
00002e  f0014680          AND      r6,r1,#0x40000000
000032  7313              STRB     r3,[r2,#0xc]          ;1282
;;;1284     RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
000034  f0013180          AND      r1,r1,#0x80808080
000038  e9c21601          STRD     r1,r6,[r2,#4]
00003c  2800              CMP      r0,#0                 ;1257
;;;1285   
;;;1286     if (RTC_Format == RTC_Format_BIN)
;;;1287     {
;;;1288       RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
;;;1289                                                           RTC_AlarmTime.RTC_Hours);
;;;1290       RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
;;;1291                                                           RTC_AlarmTime.RTC_Minutes);
;;;1292       RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
;;;1293                                                           RTC_AlarmTime.RTC_Seconds);
;;;1294       RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1295     }  
;;;1296   }
00003e  bf1c              ITT      NE
000040  bc70              POPNE    {r4-r6}
000042  4770              BXNE     lr
000044  0920              LSRS     r0,r4,#4
000046  eb000080          ADD      r0,r0,r0,LSL #2
00004a  f004010f          AND      r1,r4,#0xf
00004e  eb010040          ADD      r0,r1,r0,LSL #1
000052  7010              STRB     r0,[r2,#0]            ;1288
000054  0928              LSRS     r0,r5,#4              ;1288
000056  eb000080          ADD      r0,r0,r0,LSL #2       ;1288
00005a  f005010f          AND      r1,r5,#0xf            ;1288
00005e  eb010040          ADD      r0,r1,r0,LSL #1       ;1288
000062  7050              STRB     r0,[r2,#1]            ;1290
000064  ea4f101c          LSR      r0,r12,#4             ;1290
000068  eb000080          ADD      r0,r0,r0,LSL #2       ;1290
00006c  f00c010f          AND      r1,r12,#0xf           ;1290
000070  eb010040          ADD      r0,r1,r0,LSL #1       ;1290
000074  7090              STRB     r0,[r2,#2]            ;1292
000076  0918              LSRS     r0,r3,#4              ;1292
000078  eb000080          ADD      r0,r0,r0,LSL #2       ;1292
00007c  f003010f          AND      r1,r3,#0xf            ;1292
000080  eb010040          ADD      r0,r1,r0,LSL #1       ;1292
000084  7310              STRB     r0,[r2,#0xc]          ;1294
000086  bc70              POP      {r4-r6}
000088  4770              BX       lr
;;;1297   
                          ENDP

00008a  0000              DCW      0x0000
                  |L17.140|
                          DCD      0x4000281c
                  |L17.144|
                          DCD      0x40002820

                          AREA ||i.RTC_GetAlarmSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarmSubSecond PROC
;;;1444     */
;;;1445   uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
000000  f5b07f80          CMP      r0,#0x100
;;;1446   {
000004  d004              BEQ      |L18.16|
;;;1447     uint32_t tmpreg = 0;
;;;1448     
;;;1449     /* Get the RTC_ALRMxR register */
;;;1450     if (RTC_Alarm == RTC_Alarm_A)
;;;1451     {
;;;1452       tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
;;;1453     }
;;;1454     else
;;;1455     {
;;;1456       tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
000006  4805              LDR      r0,|L18.28|
000008  6800              LDR      r0,[r0,#0]
00000a  f3c0000e          UBFX     r0,r0,#0,#15
;;;1457     } 
;;;1458     
;;;1459     return (tmpreg);
;;;1460   }
00000e  4770              BX       lr
                  |L18.16|
000010  4803              LDR      r0,|L18.32|
000012  6800              LDR      r0,[r0,#0]            ;1452
000014  f3c0000e          UBFX     r0,r0,#0,#15          ;1452
000018  4770              BX       lr
;;;1461   
                          ENDP

00001a  0000              DCW      0x0000
                  |L18.28|
                          DCD      0x40002848
                  |L18.32|
                          DCD      0x40002844

                          AREA ||i.RTC_GetDate||, CODE, READONLY, ALIGN=2

                  RTC_GetDate PROC
;;;1054     */
;;;1055   void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  4a19              LDR      r2,|L19.104|
;;;1056   {
000002  b410              PUSH     {r4}
;;;1057     uint32_t tmpreg = 0;
;;;1058   
;;;1059     /* Check the parameters */
;;;1060     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1061     
;;;1062     /* Get the RTC_TR register */
;;;1063     tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
000004  6812              LDR      r2,[r2,#0]
000006  2800              CMP      r0,#0                 ;1056
000008  f02202c0          BIC      r2,r2,#0xc0
00000c  f022427f          BIC      r2,r2,#0xff000000
;;;1064   
;;;1065     /* Fill the structure fields with the read parameters */
;;;1066     RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
000010  ea4f4c12          LSR      r12,r2,#16
;;;1067     RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000014  f3c22404          UBFX     r4,r2,#8,#5
000018  f881c003          STRB     r12,[r1,#3]           ;1066
;;;1068     RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
00001c  f002033f          AND      r3,r2,#0x3f
000020  704c              STRB     r4,[r1,#1]            ;1067
000022  708b              STRB     r3,[r1,#2]
;;;1069     RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
000024  f3c23242          UBFX     r2,r2,#13,#3
000028  700a              STRB     r2,[r1,#0]
;;;1070   
;;;1071     /* Check the input parameters format */
;;;1072     if (RTC_Format == RTC_Format_BIN)
;;;1073     {
;;;1074       /* Convert the structure parameters to Binary format */
;;;1075       RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
;;;1076       RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
;;;1077       RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
;;;1078     }
;;;1079   }
00002a  bf1c              ITT      NE
00002c  bc10              POPNE    {r4}
00002e  4770              BXNE     lr
000030  ea4f101c          LSR      r0,r12,#4
000034  eb000080          ADD      r0,r0,r0,LSL #2
000038  f00c020f          AND      r2,r12,#0xf
00003c  eb020040          ADD      r0,r2,r0,LSL #1
000040  70c8              STRB     r0,[r1,#3]            ;1075
000042  0920              LSRS     r0,r4,#4              ;1075
000044  eb000080          ADD      r0,r0,r0,LSL #2       ;1075
000048  f004020f          AND      r2,r4,#0xf            ;1075
00004c  eb020040          ADD      r0,r2,r0,LSL #1       ;1075
000050  7048              STRB     r0,[r1,#1]            ;1076
000052  0918              LSRS     r0,r3,#4              ;1076
000054  eb000080          ADD      r0,r0,r0,LSL #2       ;1076
000058  f003020f          AND      r2,r3,#0xf            ;1076
00005c  eb020040          ADD      r0,r2,r0,LSL #1       ;1076
000060  7088              STRB     r0,[r1,#2]            ;1077
000062  bc10              POP      {r4}
000064  4770              BX       lr
;;;1080   
                          ENDP

000066  0000              DCW      0x0000
                  |L19.104|
                          DCD      0x40002804

                          AREA ||i.RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetFlagStatus PROC
;;;2604     */
;;;2605   FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
000000  4904              LDR      r1,|L20.20|
;;;2606   {
000002  4602              MOV      r2,r0
;;;2607     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2608     uint32_t tmpreg = 0;
;;;2609     
;;;2610     /* Check the parameters */
;;;2611     assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
;;;2612     
;;;2613     /* Get all the flags */
;;;2614     tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
000006  6809              LDR      r1,[r1,#0]
000008  4b03              LDR      r3,|L20.24|
00000a  4019              ANDS     r1,r1,r3
;;;2615     
;;;2616     /* Return the status of the flag */
;;;2617     if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
00000c  4211              TST      r1,r2
;;;2618     {
;;;2619       bitstatus = SET;
00000e  bf18              IT       NE
000010  2001              MOVNE    r0,#1
;;;2620     }
;;;2621     else
;;;2622     {
;;;2623       bitstatus = RESET;
;;;2624     }
;;;2625     return bitstatus;
;;;2626   }
000012  4770              BX       lr
;;;2627   
                          ENDP

                  |L20.20|
                          DCD      0x4000280c
                  |L20.24|
                          DCD      0x00013f7f

                          AREA ||i.RTC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetITStatus PROC
;;;2660     */
;;;2661   ITStatus RTC_GetITStatus(uint32_t RTC_IT)
000000  4a0a              LDR      r2,|L21.44|
;;;2662   {
;;;2663     ITStatus bitstatus = RESET;
000002  2100              MOVS     r1,#0
;;;2664     uint32_t tmpreg = 0, enablestatus = 0;
;;;2665    
;;;2666     /* Check the parameters */
;;;2667     assert_param(IS_RTC_GET_IT(RTC_IT));
;;;2668     
;;;2669     /* Get the TAMPER Interrupt enable bit and pending bit */
;;;2670     tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
000004  6812              LDR      r2,[r2,#0]
;;;2671    
;;;2672     /* Get the Interrupt enable Status */
;;;2673     enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
000006  4b0a              LDR      r3,|L21.48|
000008  f0020204          AND      r2,r2,#4              ;2670
00000c  681b              LDR      r3,[r3,#0]
00000e  ea0232d0          AND      r2,r2,r0,LSR #15
000012  4003              ANDS     r3,r3,r0
000014  431a              ORRS     r2,r2,r3
;;;2674     
;;;2675     /* Get the Interrupt pending bit */
;;;2676     tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
000016  4b07              LDR      r3,|L21.52|
000018  681b              LDR      r3,[r3,#0]
00001a  ea031010          AND      r0,r3,r0,LSR #4
;;;2677     
;;;2678     /* Get the status of the Interrupt */
;;;2679     if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
00001e  bf1e              ITTT     NE
000020  b280              UXTHNE   r0,r0
000022  2800              CMPNE    r0,#0
;;;2680     {
;;;2681       bitstatus = SET;
000024  2101              MOVNE    r1,#1
;;;2682     }
;;;2683     else
;;;2684     {
;;;2685       bitstatus = RESET;
;;;2686     }
;;;2687     return bitstatus;
000026  4608              MOV      r0,r1
;;;2688   }
000028  4770              BX       lr
;;;2689   
                          ENDP

00002a  0000              DCW      0x0000
                  |L21.44|
                          DCD      0x40002840
                  |L21.48|
                          DCD      0x40002808
                  |L21.52|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetStoreOperation||, CODE, READONLY, ALIGN=2

                  RTC_GetStoreOperation PROC
;;;1657     */
;;;1658   uint32_t RTC_GetStoreOperation(void)
000000  4802              LDR      r0,|L22.12|
;;;1659   {
;;;1660     return (RTC->CR & RTC_CR_BCK);
000002  6800              LDR      r0,[r0,#0]
000004  f4002080          AND      r0,r0,#0x40000
;;;1661   }
000008  4770              BX       lr
;;;1662   
                          ENDP

00000a  0000              DCW      0x0000
                  |L22.12|
                          DCD      0x40002808

                          AREA ||i.RTC_GetSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetSubSecond PROC
;;;919      */
;;;920    uint32_t RTC_GetSubSecond(void)
000000  4802              LDR      r0,|L23.12|
;;;921    {
;;;922      uint32_t tmpreg = 0;
;;;923      
;;;924      /* Get sub seconds values from the correspondent registers*/
;;;925      tmpreg = (uint32_t)(RTC->SSR);
000002  6800              LDR      r0,[r0,#0]
;;;926      
;;;927      /* Read DR register to unfroze calendar registers */
;;;928      (void) (RTC->DR);
000004  4902              LDR      r1,|L23.16|
000006  6809              LDR      r1,[r1,#0]
;;;929      
;;;930      return (tmpreg);
;;;931    }
000008  4770              BX       lr
;;;932    
                          ENDP

00000a  0000              DCW      0x0000
                  |L23.12|
                          DCD      0x40002828
                  |L23.16|
                          DCD      0x40002804

                          AREA ||i.RTC_GetTime||, CODE, READONLY, ALIGN=2

                  RTC_GetTime PROC
;;;886      */
;;;887    void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  4a18              LDR      r2,|L24.100|
;;;888    {
000002  b430              PUSH     {r4,r5}
;;;889      uint32_t tmpreg = 0;
;;;890    
;;;891      /* Check the parameters */
;;;892      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;893    
;;;894      /* Get the RTC_TR register */
;;;895      tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
000004  6812              LDR      r2,[r2,#0]
000006  4b18              LDR      r3,|L24.104|
;;;896      
;;;897      /* Fill the structure fields with the read parameters */
;;;898      RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
;;;899      RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
;;;900      RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
;;;901      RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
000008  2540              MOVS     r5,#0x40
00000a  401a              ANDS     r2,r2,r3              ;895
00000c  f3c24405          UBFX     r4,r2,#16,#6          ;898
000010  f3c22c06          UBFX     r12,r2,#8,#7          ;899
000014  700c              STRB     r4,[r1,#0]            ;898
000016  f002037f          AND      r3,r2,#0x7f           ;900
00001a  f881c001          STRB     r12,[r1,#1]           ;899
00001e  708b              STRB     r3,[r1,#2]            ;900
000020  ea054212          AND      r2,r5,r2,LSR #16
000024  70ca              STRB     r2,[r1,#3]
000026  2800              CMP      r0,#0                 ;888
;;;902    
;;;903      /* Check the input parameters format */
;;;904      if (RTC_Format == RTC_Format_BIN)
;;;905      {
;;;906        /* Convert the structure parameters to Binary format */
;;;907        RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
;;;908        RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
;;;909        RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
;;;910      }
;;;911    }
000028  bf1c              ITT      NE
00002a  bc30              POPNE    {r4,r5}
00002c  4770              BXNE     lr
00002e  0920              LSRS     r0,r4,#4
000030  eb000080          ADD      r0,r0,r0,LSL #2
000034  f004020f          AND      r2,r4,#0xf
000038  eb020040          ADD      r0,r2,r0,LSL #1
00003c  7008              STRB     r0,[r1,#0]            ;907
00003e  ea4f101c          LSR      r0,r12,#4             ;907
000042  eb000080          ADD      r0,r0,r0,LSL #2       ;907
000046  f00c020f          AND      r2,r12,#0xf           ;907
00004a  eb020040          ADD      r0,r2,r0,LSL #1       ;907
00004e  7048              STRB     r0,[r1,#1]            ;908
000050  0918              LSRS     r0,r3,#4              ;908
000052  eb000080          ADD      r0,r0,r0,LSL #2       ;908
000056  f003020f          AND      r2,r3,#0xf            ;908
00005a  eb020040          ADD      r0,r2,r0,LSL #1       ;908
00005e  7088              STRB     r0,[r1,#2]            ;909
000060  bc30              POP      {r4,r5}
000062  4770              BX       lr
;;;912    
                          ENDP

                  |L24.100|
                          DCD      0x40002800
                  |L24.104|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStamp||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStamp PROC
;;;2025     */
;;;2026   void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
000000  4b30              LDR      r3,|L25.196|
;;;2027                                         RTC_DateTypeDef* RTC_StampDateStruct)
;;;2028   {
000002  b410              PUSH     {r4}
;;;2029     uint32_t tmptime = 0, tmpdate = 0;
;;;2030   
;;;2031     /* Check the parameters */
;;;2032     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;2033   
;;;2034     /* Get the TimeStamp time and date registers values */
;;;2035     tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
000004  681b              LDR      r3,[r3,#0]
000006  f8dfc0c0          LDR      r12,|L25.200|
00000a  ea03030c          AND      r3,r3,r12
;;;2036     tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
00000e  f8dfc0bc          LDR      r12,|L25.204|
000012  f8dcc000          LDR      r12,[r12,#0]
;;;2037   
;;;2038     /* Fill the Time structure fields with the read parameters */
;;;2039     RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
000016  f3c34405          UBFX     r4,r3,#16,#6
00001a  700c              STRB     r4,[r1,#0]
;;;2040     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
00001c  f3c32406          UBFX     r4,r3,#8,#7
000020  704c              STRB     r4,[r1,#1]
;;;2041     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
000022  f003047f          AND      r4,r3,#0x7f
000026  708c              STRB     r4,[r1,#2]
;;;2042     RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
000028  2440              MOVS     r4,#0x40
00002a  ea044313          AND      r3,r4,r3,LSR #16
00002e  70cb              STRB     r3,[r1,#3]
;;;2043   
;;;2044     /* Fill the Date structure fields with the read parameters */
;;;2045     RTC_StampDateStruct->RTC_Year = 0;
000030  2300              MOVS     r3,#0
000032  f02c0cc0          BIC      r12,r12,#0xc0         ;2036
000036  70d3              STRB     r3,[r2,#3]
;;;2046     RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000038  f3cc2304          UBFX     r3,r12,#8,#5
00003c  7053              STRB     r3,[r2,#1]
;;;2047     RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
00003e  f00c033f          AND      r3,r12,#0x3f
000042  7093              STRB     r3,[r2,#2]
;;;2048     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
000044  f3cc3342          UBFX     r3,r12,#13,#3
000048  7013              STRB     r3,[r2,#0]
00004a  2800              CMP      r0,#0                 ;2028
;;;2049   
;;;2050     /* Check the input parameters format */
;;;2051     if (RTC_Format == RTC_Format_BIN)
;;;2052     {
;;;2053       /* Convert the Time structure parameters to Binary format */
;;;2054       RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
;;;2055       RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
;;;2056       RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
;;;2057   
;;;2058       /* Convert the Date structure parameters to Binary format */
;;;2059       RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
;;;2060       RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
;;;2061       RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
;;;2062     }
;;;2063   }
00004c  bf1c              ITT      NE
00004e  bc10              POPNE    {r4}
000050  4770              BXNE     lr
000052  7808              LDRB     r0,[r1,#0]            ;2054
000054  0903              LSRS     r3,r0,#4              ;2054
000056  eb030383          ADD      r3,r3,r3,LSL #2       ;2054
00005a  f000000f          AND      r0,r0,#0xf            ;2054
00005e  eb000043          ADD      r0,r0,r3,LSL #1       ;2054
000062  7008              STRB     r0,[r1,#0]            ;2054
000064  7848              LDRB     r0,[r1,#1]            ;2055
000066  0903              LSRS     r3,r0,#4              ;2055
000068  eb030383          ADD      r3,r3,r3,LSL #2       ;2055
00006c  f000000f          AND      r0,r0,#0xf            ;2055
000070  eb000043          ADD      r0,r0,r3,LSL #1       ;2055
000074  7048              STRB     r0,[r1,#1]            ;2055
000076  7888              LDRB     r0,[r1,#2]            ;2056
000078  0903              LSRS     r3,r0,#4              ;2056
00007a  eb030383          ADD      r3,r3,r3,LSL #2       ;2056
00007e  f000000f          AND      r0,r0,#0xf            ;2056
000082  eb000043          ADD      r0,r0,r3,LSL #1       ;2056
000086  7088              STRB     r0,[r1,#2]            ;2056
000088  7850              LDRB     r0,[r2,#1]            ;2059
00008a  0901              LSRS     r1,r0,#4              ;2059
00008c  eb010181          ADD      r1,r1,r1,LSL #2       ;2059
000090  f000000f          AND      r0,r0,#0xf            ;2059
000094  eb000041          ADD      r0,r0,r1,LSL #1       ;2059
000098  7050              STRB     r0,[r2,#1]            ;2059
00009a  7890              LDRB     r0,[r2,#2]            ;2060
00009c  0901              LSRS     r1,r0,#4              ;2060
00009e  eb010181          ADD      r1,r1,r1,LSL #2       ;2060
0000a2  f000000f          AND      r0,r0,#0xf            ;2060
0000a6  eb000041          ADD      r0,r0,r1,LSL #1       ;2060
0000aa  7090              STRB     r0,[r2,#2]            ;2060
0000ac  7810              LDRB     r0,[r2,#0]            ;2061
0000ae  0901              LSRS     r1,r0,#4              ;2061
0000b0  eb010181          ADD      r1,r1,r1,LSL #2       ;2061
0000b4  f000000f          AND      r0,r0,#0xf            ;2061
0000b8  eb000041          ADD      r0,r0,r1,LSL #1       ;2061
0000bc  7010              STRB     r0,[r2,#0]            ;2061
0000be  bc10              POP      {r4}
0000c0  4770              BX       lr
;;;2064   
                          ENDP

0000c2  0000              DCW      0x0000
                  |L25.196|
                          DCD      0x40002830
                  |L25.200|
                          DCD      0x007f7f7f
                  |L25.204|
                          DCD      0x40002834

                          AREA ||i.RTC_GetTimeStampSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStampSubSecond PROC
;;;2069     */
;;;2070   uint32_t RTC_GetTimeStampSubSecond(void)
000000  4801              LDR      r0,|L26.8|
;;;2071   {
;;;2072     /* Get timestamp sub seconds values from the correspondent registers */
;;;2073     return (uint32_t)(RTC->TSSSR);
000002  6800              LDR      r0,[r0,#0]
;;;2074   }
000004  4770              BX       lr
;;;2075   
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x40002838

                          AREA ||i.RTC_GetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_GetWakeUpCounter PROC
;;;1541     */
;;;1542   uint32_t RTC_GetWakeUpCounter(void)
000000  4801              LDR      r0,|L27.8|
;;;1543   {
;;;1544     /* Get the counter value */
;;;1545     return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
000002  6800              LDR      r0,[r0,#0]
000004  b280              UXTH     r0,r0
;;;1546   }
000006  4770              BX       lr
;;;1547   
                          ENDP

                  |L27.8|
                          DCD      0x40002814

                          AREA ||i.RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;2556     */
;;;2557   void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
000000  b410              PUSH     {r4}
;;;2558   {
;;;2559     /* Check the parameters */
;;;2560     assert_param(IS_RTC_CONFIG_IT(RTC_IT));
;;;2561     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2562   
;;;2563     /* Disable the write protection for RTC registers */
;;;2564     RTC->WPR = 0xCA;
000002  4c0f              LDR      r4,|L28.64|
000004  22ca              MOVS     r2,#0xca
000006  6022              STR      r2,[r4,#0]
;;;2565     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  6022              STR      r2,[r4,#0]
;;;2566   
;;;2567     if (NewState != DISABLE)
;;;2568     {
;;;2569       /* Configure the Interrupts in the RTC_CR register */
;;;2570       RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
00000c  4b0d              LDR      r3,|L28.68|
00000e  2900              CMP      r1,#0                 ;2567
000010  f0200204          BIC      r2,r0,#4
;;;2571       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2572       RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
000014  f8dfc030          LDR      r12,|L28.72|
;;;2573     }
;;;2574     else
;;;2575     {
;;;2576       /* Configure the Interrupts in the RTC_CR register */
;;;2577       RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
000018  6819              LDR      r1,[r3,#0]
00001a  f0000004          AND      r0,r0,#4              ;2572
00001e  bf14              ITE      NE                    ;2570
000020  4311              ORRNE    r1,r1,r2              ;2570
000022  4391              BICEQ    r1,r1,r2
000024  6019              STR      r1,[r3,#0]
;;;2578       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2579       RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
000026  f8dc1000          LDR      r1,[r12,#0]
00002a  bf14              ITE      NE                    ;2572
00002c  4308              ORRNE    r0,r0,r1              ;2572
00002e  ea210000          BICEQ    r0,r1,r0
000032  f8cc0000          STR      r0,[r12,#0]
;;;2580     }
;;;2581     /* Enable the write protection for RTC registers */
;;;2582     RTC->WPR = 0xFF; 
000036  20ff              MOVS     r0,#0xff
000038  6020              STR      r0,[r4,#0]
;;;2583   }
00003a  bc10              POP      {r4}
00003c  4770              BX       lr
;;;2584   
                          ENDP

00003e  0000              DCW      0x0000
                  |L28.64|
                          DCD      0x40002824
                  |L28.68|
                          DCD      0x40002808
                  |L28.72|
                          DCD      0x40002840

                          AREA ||i.RTC_Init||, CODE, READONLY, ALIGN=2

                  RTC_Init PROC
;;;456      */
;;;457    ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;458    {
;;;459      ErrorStatus status = ERROR;
;;;460      
;;;461      /* Check the parameters */
;;;462      assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
;;;463      assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
;;;464      assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
;;;465    
;;;466      /* Disable the write protection for RTC registers */
;;;467      RTC->WPR = 0xCA;
000002  4d12              LDR      r5,|L29.76|
000004  4603              MOV      r3,r0                 ;458
000006  2400              MOVS     r4,#0                 ;459
000008  20ca              MOVS     r0,#0xca
00000a  6028              STR      r0,[r5,#0]
;;;468      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6028              STR      r0,[r5,#0]
;;;469    
;;;470      /* Set Initialization mode */
;;;471      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b1b0              CBZ      r0,|L29.68|
;;;472      {
;;;473        status = ERROR;
;;;474      } 
;;;475      else
;;;476      {
;;;477        /* Clear RTC CR FMT Bit */
;;;478        RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
000016  480e              LDR      r0,|L29.80|
000018  6801              LDR      r1,[r0,#0]
00001a  f0210140          BIC      r1,r1,#0x40
00001e  6001              STR      r1,[r0,#0]
;;;479        /* Set RTC_CR register */
;;;480        RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
000020  6801              LDR      r1,[r0,#0]
000022  681a              LDR      r2,[r3,#0]
000024  4311              ORRS     r1,r1,r2
000026  6001              STR      r1,[r0,#0]
;;;481      
;;;482        /* Configure the RTC PRER */
;;;483        RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
000028  480a              LDR      r0,|L29.84|
00002a  6899              LDR      r1,[r3,#8]
00002c  6001              STR      r1,[r0,#0]
;;;484        RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
00002e  6801              LDR      r1,[r0,#0]
000030  889a              LDRH     r2,[r3,#4]
000032  ea414102          ORR      r1,r1,r2,LSL #16
000036  6001              STR      r1,[r0,#0]
000038  1f00              SUBS     r0,r0,#4
00003a  6801              LDR      r1,[r0,#0]
00003c  f0210180          BIC      r1,r1,#0x80
000040  6001              STR      r1,[r0,#0]
;;;485    
;;;486        /* Exit Initialization mode */
;;;487        RTC_ExitInitMode();
;;;488    
;;;489        status = SUCCESS;    
000042  2401              MOVS     r4,#1
                  |L29.68|
;;;490      }
;;;491      /* Enable the write protection for RTC registers */
;;;492      RTC->WPR = 0xFF; 
000044  20ff              MOVS     r0,#0xff
000046  6028              STR      r0,[r5,#0]
;;;493      
;;;494      return status;
000048  4620              MOV      r0,r4
;;;495    }
00004a  bd30              POP      {r4,r5,pc}
;;;496    
                          ENDP

                  |L29.76|
                          DCD      0x40002824
                  |L29.80|
                          DCD      0x40002808
                  |L29.84|
                          DCD      0x40002810

                          AREA ||i.RTC_OutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputConfig PROC
;;;1696     */
;;;1697   void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
000000  4b0a              LDR      r3,|L30.44|
;;;1698   {
;;;1699     /* Check the parameters */
;;;1700     assert_param(IS_RTC_OUTPUT(RTC_Output));
;;;1701     assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
;;;1702   
;;;1703     /* Disable the write protection for RTC registers */
;;;1704     RTC->WPR = 0xCA;
000002  22ca              MOVS     r2,#0xca
000004  601a              STR      r2,[r3,#0]
;;;1705     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  601a              STR      r2,[r3,#0]
;;;1706   
;;;1707     /* Clear the bits to be configured */
;;;1708     RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
00000a  4a09              LDR      r2,|L30.48|
00000c  f8d2c000          LDR      r12,[r2,#0]
000010  f42c0ce0          BIC      r12,r12,#0x700000
000014  f8c2c000          STR      r12,[r2,#0]
;;;1709   
;;;1710     /* Configure the output selection and polarity */
;;;1711     RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
000018  f8d2c000          LDR      r12,[r2,#0]
00001c  4308              ORRS     r0,r0,r1
00001e  ea4c0000          ORR      r0,r12,r0
000022  6010              STR      r0,[r2,#0]
;;;1712   
;;;1713     /* Enable the write protection for RTC registers */
;;;1714     RTC->WPR = 0xFF; 
000024  20ff              MOVS     r0,#0xff
000026  6018              STR      r0,[r3,#0]
;;;1715   }
000028  4770              BX       lr
;;;1716   
                          ENDP

00002a  0000              DCW      0x0000
                  |L30.44|
                          DCD      0x40002824
                  |L30.48|
                          DCD      0x40002808

                          AREA ||i.RTC_OutputTypeConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputTypeConfig PROC
;;;2398     */
;;;2399   void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
000000  4904              LDR      r1,|L31.20|
;;;2400   {
;;;2401     /* Check the parameters */
;;;2402     assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
;;;2403     
;;;2404     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
000002  680a              LDR      r2,[r1,#0]
000004  f4222280          BIC      r2,r2,#0x40000
000008  600a              STR      r2,[r1,#0]
;;;2405     RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
00000a  680a              LDR      r2,[r1,#0]
00000c  4310              ORRS     r0,r0,r2
00000e  6008              STR      r0,[r1,#0]
;;;2406   }
000010  4770              BX       lr
;;;2407   
                          ENDP

000012  0000              DCW      0x0000
                  |L31.20|
                          DCD      0x40002840

                          AREA ||i.RTC_ReadBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_ReadBackupRegister PROC
;;;2323     */
;;;2324   uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
000000  4903              LDR      r1,|L32.16|
;;;2325   {
000002  b081              SUB      sp,sp,#4
;;;2326     __IO uint32_t tmp = 0;
;;;2327     
;;;2328     /* Check the parameters */
;;;2329     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2330   
;;;2331     tmp = RTC_BASE + 0x50;
;;;2332     tmp += (RTC_BKP_DR * 4);
000004  eb010080          ADD      r0,r1,r0,LSL #2
;;;2333     
;;;2334     /* Read the specified register */
;;;2335     return (*(__IO uint32_t *)tmp);
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
;;;2336   }
00000c  b001              ADD      sp,sp,#4
00000e  4770              BX       lr
;;;2337   
                          ENDP

                  |L32.16|
                          DCD      0x40002850

                          AREA ||i.RTC_RefClockCmd||, CODE, READONLY, ALIGN=2

                  RTC_RefClockCmd PROC
;;;661      */
;;;662    ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;663    { 
;;;664      ErrorStatus status = ERROR;
;;;665      
;;;666      /* Check the parameters */
;;;667      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;668      
;;;669      /* Disable the write protection for RTC registers */
;;;670      RTC->WPR = 0xCA;
000002  4c0e              LDR      r4,|L33.60|
000004  4605              MOV      r5,r0                 ;663
000006  2300              MOVS     r3,#0                 ;664
000008  20ca              MOVS     r0,#0xca
00000a  6020              STR      r0,[r4,#0]
;;;671      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6020              STR      r0,[r4,#0]
;;;672        
;;;673      /* Set Initialization mode */
;;;674      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b170              CBZ      r0,|L33.52|
;;;675      {
;;;676        status = ERROR;
;;;677      } 
;;;678      else
;;;679      {  
;;;680        if (NewState != DISABLE)
;;;681        {
;;;682          /* Enable the RTC reference clock detection */
;;;683          RTC->CR |= RTC_CR_REFCKON;   
000016  480a              LDR      r0,|L33.64|
000018  2d00              CMP      r5,#0                 ;680
;;;684        }
;;;685        else
;;;686        {
;;;687          /* Disable the RTC reference clock detection */
;;;688          RTC->CR &= ~RTC_CR_REFCKON;    
00001a  6801              LDR      r1,[r0,#0]
00001c  bf0c              ITE      EQ
00001e  f0210110          BICEQ    r1,r1,#0x10
000022  f0410110          ORRNE    r1,r1,#0x10           ;683
000026  6001              STR      r1,[r0,#0]
000028  4806              LDR      r0,|L33.68|
00002a  6801              LDR      r1,[r0,#0]
00002c  f0210180          BIC      r1,r1,#0x80
000030  6001              STR      r1,[r0,#0]
;;;689        }
;;;690        /* Exit Initialization mode */
;;;691        RTC_ExitInitMode();
;;;692        
;;;693        status = SUCCESS;
000032  2301              MOVS     r3,#1
                  |L33.52|
;;;694      }
;;;695      
;;;696      /* Enable the write protection for RTC registers */
;;;697      RTC->WPR = 0xFF;  
000034  20ff              MOVS     r0,#0xff
000036  6020              STR      r0,[r4,#0]
;;;698      
;;;699      return status; 
000038  4618              MOV      r0,r3
;;;700    }
00003a  bd30              POP      {r4,r5,pc}
;;;701    
                          ENDP

                  |L33.60|
                          DCD      0x40002824
                  |L33.64|
                          DCD      0x40002808
                  |L33.68|
                          DCD      0x4000280c

                          AREA ||i.RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarm PROC
;;;1114     */
;;;1115   void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1116   {
000002  460d              MOV      r5,r1
;;;1117     uint32_t tmpreg = 0;
;;;1118     
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1121     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1122     assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
;;;1123     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
;;;1124   
;;;1125     if (RTC_Format == RTC_Format_BIN)
;;;1126     {
;;;1127       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000004  f8dfc090          LDR      r12,|L34.152|
000008  4614              MOV      r4,r2                 ;1116
00000a  0001              MOVS     r1,r0                 ;1125
;;;1128       {
;;;1129         assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1130         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
;;;1131       } 
;;;1132       else
;;;1133       {
;;;1134         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1135         assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1136       }
;;;1137       assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
;;;1138       assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
;;;1139       
;;;1140       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
00000c  6892              LDR      r2,[r2,#8]
;;;1141       {
;;;1142         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1143       }
;;;1144       else
;;;1145       {
;;;1146         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1147       }
;;;1148     }
;;;1149     else
;;;1150     {
;;;1151       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;1152       {
;;;1153         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
00000e  7820              LDRB     r0,[r4,#0]
000010  f8dc1000          LDR      r1,[r12,#0]           ;1151
000014  f04f0300          MOV      r3,#0                 ;1125
000018  f0010140          AND      r1,r1,#0x40           ;1151
00001c  d012              BEQ      |L34.68|
00001e  2900              CMP      r1,#0                 ;1151
;;;1154         assert_param(IS_RTC_HOUR12(tmpreg));
;;;1155         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
;;;1156       } 
;;;1157       else
;;;1158       {
;;;1159         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
000020  bf08              IT       EQ
000022  70e3              STRBEQ   r3,[r4,#3]
;;;1160         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
;;;1161       }
;;;1162       
;;;1163       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
;;;1164       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
;;;1165       
;;;1166       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1167       {
;;;1168         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1169         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
;;;1170       }
;;;1171       else
;;;1172       {
;;;1173         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1174         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
;;;1175       }    
;;;1176     }
;;;1177   
;;;1178     /* Check the input parameters format */
;;;1179     if (RTC_Format != RTC_Format_BIN)
;;;1180     {
;;;1181       tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
000024  78a1              LDRB     r1,[r4,#2]
000026  78e3              LDRB     r3,[r4,#3]
000028  ea414000          ORR      r0,r1,r0,LSL #16
00002c  7861              LDRB     r1,[r4,#1]
00002e  0209              LSLS     r1,r1,#8
000030  ea414103          ORR      r1,r1,r3,LSL #16
000034  4308              ORRS     r0,r0,r1
000036  7b21              LDRB     r1,[r4,#0xc]
000038  ea406001          ORR      r0,r0,r1,LSL #24
00003c  6861              LDR      r1,[r4,#4]
00003e  4310              ORRS     r0,r0,r2
000040  4308              ORRS     r0,r0,r1
000042  e01a              B        |L34.122|
                  |L34.68|
000044  2900              CMP      r1,#0                 ;1127
000046  bf08              IT       EQ                    ;1134
000048  70e3              STRBEQ   r3,[r4,#3]            ;1134
;;;1182                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1183                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
;;;1184                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1185                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1186                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1187                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1188     }  
;;;1189     else
;;;1190     {
;;;1191       tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
00004a  f7fffffe          BL       RTC_ByteToBcd2
00004e  0406              LSLS     r6,r0,#16
000050  7860              LDRB     r0,[r4,#1]
000052  f7fffffe          BL       RTC_ByteToBcd2
000056  ea462600          ORR      r6,r6,r0,LSL #8
00005a  78a0              LDRB     r0,[r4,#2]
00005c  f7fffffe          BL       RTC_ByteToBcd2
000060  78e1              LDRB     r1,[r4,#3]
000062  4330              ORRS     r0,r0,r6
000064  ea404601          ORR      r6,r0,r1,LSL #16
000068  7b20              LDRB     r0,[r4,#0xc]
00006a  f7fffffe          BL       RTC_ByteToBcd2
00006e  68a1              LDR      r1,[r4,#8]
000070  ea466000          ORR      r0,r6,r0,LSL #24
000074  4308              ORRS     r0,r0,r1
000076  6861              LDR      r1,[r4,#4]
000078  4308              ORRS     r0,r0,r1
                  |L34.122|
;;;1192                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1193                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
;;;1194                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1195                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1196                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1197                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1198     } 
;;;1199   
;;;1200     /* Disable the write protection for RTC registers */
;;;1201     RTC->WPR = 0xCA;
00007a  4a08              LDR      r2,|L34.156|
00007c  21ca              MOVS     r1,#0xca
00007e  6011              STR      r1,[r2,#0]
;;;1202     RTC->WPR = 0x53;
000080  2153              MOVS     r1,#0x53
000082  6011              STR      r1,[r2,#0]
;;;1203   
;;;1204     /* Configure the Alarm register */
;;;1205     if (RTC_Alarm == RTC_Alarm_A)
000084  f5b57f80          CMP      r5,#0x100
;;;1206     {
;;;1207       RTC->ALRMAR = (uint32_t)tmpreg;
000088  bf0c              ITE      EQ
00008a  4905              LDREQ    r1,|L34.160|
;;;1208     }
;;;1209     else
;;;1210     {
;;;1211       RTC->ALRMBR = (uint32_t)tmpreg;
00008c  4905              LDRNE    r1,|L34.164|
00008e  6008              STR      r0,[r1,#0]
;;;1212     }
;;;1213   
;;;1214     /* Enable the write protection for RTC registers */
;;;1215     RTC->WPR = 0xFF;   
000090  20ff              MOVS     r0,#0xff
000092  6010              STR      r0,[r2,#0]
;;;1216   }
000094  bd70              POP      {r4-r6,pc}
;;;1217   
                          ENDP

000096  0000              DCW      0x0000
                  |L34.152|
                          DCD      0x40002808
                  |L34.156|
                          DCD      0x40002824
                  |L34.160|
                          DCD      0x4000281c
                  |L34.164|
                          DCD      0x40002820

                          AREA ||i.RTC_SetDate||, CODE, READONLY, ALIGN=2

                  RTC_SetDate PROC
;;;944      */
;;;945    ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;946    {
000002  460c              MOV      r4,r1
;;;947      uint32_t tmpreg = 0;
;;;948      ErrorStatus status = ERROR;
000004  2500              MOVS     r5,#0
;;;949      
;;;950      /* Check the parameters */
;;;951      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;952    
;;;953      if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
000006  0002              MOVS     r2,r0
000008  7849              LDRB     r1,[r1,#1]
;;;954      {
;;;955        RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
;;;956      }  
;;;957      if (RTC_Format == RTC_Format_BIN)
;;;958      {
;;;959        assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;960        assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;961        assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
;;;962      }
;;;963      else
;;;964      {
;;;965        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
;;;966        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
;;;967        assert_param(IS_RTC_MONTH(tmpreg));
;;;968        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
;;;969        assert_param(IS_RTC_DATE(tmpreg));
;;;970      }
;;;971      assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
;;;972    
;;;973      /* Check the input parameters format */
;;;974      if (RTC_Format != RTC_Format_BIN)
;;;975      {
;;;976        tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
00000a  78e0              LDRB     r0,[r4,#3]
00000c  d009              BEQ      |L35.34|
00000e  78a2              LDRB     r2,[r4,#2]            ;968
000010  0209              LSLS     r1,r1,#8
000012  ea424000          ORR      r0,r2,r0,LSL #16
000016  7822              LDRB     r2,[r4,#0]
000018  ea413142          ORR      r1,r1,r2,LSL #13
00001c  ea400301          ORR      r3,r0,r1
000020  e015              B        |L35.78|
                  |L35.34|
000022  f0110f10          TST      r1,#0x10              ;953
000026  d003              BEQ      |L35.48|
000028  f0210110          BIC      r1,r1,#0x10           ;955
00002c  310a              ADDS     r1,r1,#0xa            ;955
00002e  7061              STRB     r1,[r4,#1]            ;955
                  |L35.48|
;;;977                  (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;978                  ((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;979                  (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;980      }  
;;;981      else
;;;982      {
;;;983        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
000030  f7fffffe          BL       RTC_ByteToBcd2
000034  0406              LSLS     r6,r0,#16
000036  7860              LDRB     r0,[r4,#1]
000038  f7fffffe          BL       RTC_ByteToBcd2
00003c  ea462600          ORR      r6,r6,r0,LSL #8
000040  78a0              LDRB     r0,[r4,#2]
000042  f7fffffe          BL       RTC_ByteToBcd2
000046  7821              LDRB     r1,[r4,#0]
000048  4330              ORRS     r0,r0,r6
00004a  ea403341          ORR      r3,r0,r1,LSL #13
                  |L35.78|
;;;984                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;985                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;986                  ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;987      }
;;;988    
;;;989      /* Disable the write protection for RTC registers */
;;;990      RTC->WPR = 0xCA;
00004e  4c0f              LDR      r4,|L35.140|
000050  20ca              MOVS     r0,#0xca
000052  6020              STR      r0,[r4,#0]
;;;991      RTC->WPR = 0x53;
000054  2053              MOVS     r0,#0x53
000056  6020              STR      r0,[r4,#0]
;;;992    
;;;993      /* Set Initialization mode */
;;;994      if (RTC_EnterInitMode() == ERROR)
000058  f7fffffe          BL       RTC_EnterInitMode
00005c  b188              CBZ      r0,|L35.130|
;;;995      {
;;;996        status = ERROR;
;;;997      } 
;;;998      else
;;;999      {
;;;1000       /* Set the RTC_DR register */
;;;1001       RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
00005e  490c              LDR      r1,|L35.144|
000060  f02300c0          BIC      r0,r3,#0xc0
000064  6008              STR      r0,[r1,#0]
000066  480b              LDR      r0,|L35.148|
000068  6801              LDR      r1,[r0,#0]
00006a  f0210180          BIC      r1,r1,#0x80
00006e  6001              STR      r1,[r0,#0]
;;;1002   
;;;1003       /* Exit Initialization mode */
;;;1004       RTC_ExitInitMode(); 
;;;1005   
;;;1006       /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;1007       if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
000070  1f00              SUBS     r0,r0,#4
000072  6800              LDR      r0,[r0,#0]
000074  f0100f20          TST      r0,#0x20
000078  d102              BNE      |L35.128|
;;;1008       {
;;;1009       if(RTC_WaitForSynchro() == ERROR)
00007a  f7fffffe          BL       RTC_WaitForSynchro
00007e  b100              CBZ      r0,|L35.130|
                  |L35.128|
;;;1010       {
;;;1011         status = ERROR;
;;;1012       }
;;;1013       else
;;;1014       {
;;;1015         status = SUCCESS;
;;;1016       }
;;;1017     }
;;;1018       else
;;;1019       {
;;;1020         status = SUCCESS;
000080  2501              MOVS     r5,#1
                  |L35.130|
;;;1021       }
;;;1022     }
;;;1023     /* Enable the write protection for RTC registers */
;;;1024     RTC->WPR = 0xFF;   
000082  20ff              MOVS     r0,#0xff
000084  6020              STR      r0,[r4,#0]
;;;1025     
;;;1026     return status;
000086  4628              MOV      r0,r5
;;;1027   }
000088  bd70              POP      {r4-r6,pc}
;;;1028   
                          ENDP

00008a  0000              DCW      0x0000
                  |L35.140|
                          DCD      0x40002824
                  |L35.144|
                          DCD      0x40002804
                  |L35.148|
                          DCD      0x4000280c

                          AREA ||i.RTC_SetTime||, CODE, READONLY, ALIGN=2

                  RTC_SetTime PROC
;;;764      */
;;;765    ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;766    {
;;;767      uint32_t tmpreg = 0;
;;;768      ErrorStatus status = ERROR;
000004  2500              MOVS     r5,#0
;;;769        
;;;770      /* Check the parameters */
;;;771      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;772      
;;;773      if (RTC_Format == RTC_Format_BIN)
;;;774      {
;;;775        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000006  4e23              LDR      r6,|L36.148|
000008  460c              MOV      r4,r1                 ;766
00000a  0002              MOVS     r2,r0                 ;773
;;;776        {
;;;777          assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;778          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
;;;779        } 
;;;780        else
;;;781        {
;;;782          RTC_TimeStruct->RTC_H12 = 0x00;
;;;783          assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
;;;784        }
;;;785        assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;786        assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
;;;787      }
;;;788      else
;;;789      {
;;;790        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;791        {
;;;792          tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00000c  7820              LDRB     r0,[r4,#0]
00000e  6832              LDR      r2,[r6,#0]            ;790
000010  4629              MOV      r1,r5                 ;773
000012  f0020240          AND      r2,r2,#0x40           ;790
000016  d00d              BEQ      |L36.52|
000018  2a00              CMP      r2,#0                 ;790
;;;793          assert_param(IS_RTC_HOUR12(tmpreg));
;;;794          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
;;;795        } 
;;;796        else
;;;797        {
;;;798          RTC_TimeStruct->RTC_H12 = 0x00;
00001a  bf08              IT       EQ
00001c  70e1              STRBEQ   r1,[r4,#3]
;;;799          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
;;;800        }
;;;801        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;802        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
;;;803      }
;;;804      
;;;805      /* Check the input parameters format */
;;;806      if (RTC_Format != RTC_Format_BIN)
;;;807      {
;;;808        tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
00001e  78a1              LDRB     r1,[r4,#2]
000020  78e2              LDRB     r2,[r4,#3]
000022  ea414000          ORR      r0,r1,r0,LSL #16
000026  7861              LDRB     r1,[r4,#1]
000028  0209              LSLS     r1,r1,#8
00002a  ea414102          ORR      r1,r1,r2,LSL #16
00002e  ea400301          ORR      r3,r0,r1
000032  e011              B        |L36.88|
                  |L36.52|
000034  2a00              CMP      r2,#0                 ;775
000036  bf08              IT       EQ                    ;782
000038  70e1              STRBEQ   r1,[r4,#3]            ;782
;;;809                 ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;810                 ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;811                 ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;812      }  
;;;813      else
;;;814      {
;;;815        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
00003a  f7fffffe          BL       RTC_ByteToBcd2
00003e  0407              LSLS     r7,r0,#16
000040  7860              LDRB     r0,[r4,#1]
000042  f7fffffe          BL       RTC_ByteToBcd2
000046  ea472700          ORR      r7,r7,r0,LSL #8
00004a  78a0              LDRB     r0,[r4,#2]
00004c  f7fffffe          BL       RTC_ByteToBcd2
000050  78e1              LDRB     r1,[r4,#3]
000052  4338              ORRS     r0,r0,r7
000054  ea404301          ORR      r3,r0,r1,LSL #16
                  |L36.88|
;;;816                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;817                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;818                       (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;819      }  
;;;820    
;;;821      /* Disable the write protection for RTC registers */
;;;822      RTC->WPR = 0xCA;
000058  4c0f              LDR      r4,|L36.152|
00005a  20ca              MOVS     r0,#0xca
00005c  6020              STR      r0,[r4,#0]
;;;823      RTC->WPR = 0x53;
00005e  2053              MOVS     r0,#0x53
000060  6020              STR      r0,[r4,#0]
;;;824    
;;;825      /* Set Initialization mode */
;;;826      if (RTC_EnterInitMode() == ERROR)
000062  f7fffffe          BL       RTC_EnterInitMode
000066  b180              CBZ      r0,|L36.138|
;;;827      {
;;;828        status = ERROR;
;;;829      } 
;;;830      else
;;;831      {
;;;832        /* Set the RTC_TR register */
;;;833        RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
000068  480c              LDR      r0,|L36.156|
00006a  490d              LDR      r1,|L36.160|
00006c  4018              ANDS     r0,r0,r3
00006e  6008              STR      r0,[r1,#0]
000070  480c              LDR      r0,|L36.164|
000072  6801              LDR      r1,[r0,#0]
000074  f0210180          BIC      r1,r1,#0x80
000078  6001              STR      r1,[r0,#0]
;;;834    
;;;835        /* Exit Initialization mode */
;;;836        RTC_ExitInitMode(); 
;;;837    
;;;838        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;839        if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
00007a  6830              LDR      r0,[r6,#0]
00007c  f0100f20          TST      r0,#0x20
000080  d102              BNE      |L36.136|
;;;840        {
;;;841        if(RTC_WaitForSynchro() == ERROR)
000082  f7fffffe          BL       RTC_WaitForSynchro
000086  b100              CBZ      r0,|L36.138|
                  |L36.136|
;;;842        {
;;;843          status = ERROR;
;;;844        }
;;;845        else
;;;846        {
;;;847          status = SUCCESS;
;;;848        }
;;;849      }
;;;850        else
;;;851        {
;;;852          status = SUCCESS;
000088  2501              MOVS     r5,#1
                  |L36.138|
;;;853        }
;;;854      }
;;;855      /* Enable the write protection for RTC registers */
;;;856      RTC->WPR = 0xFF; 
00008a  20ff              MOVS     r0,#0xff
00008c  6020              STR      r0,[r4,#0]
;;;857        
;;;858      return status;
00008e  4628              MOV      r0,r5
;;;859    }
000090  e8bd81f0          POP      {r4-r8,pc}
;;;860    
                          ENDP

                  |L36.148|
                          DCD      0x40002808
                  |L36.152|
                          DCD      0x40002824
                  |L36.156|
                          DCD      0x007f7f7f
                  |L36.160|
                          DCD      0x40002800
                  |L36.164|
                          DCD      0x4000280c

                          AREA ||i.RTC_SetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_SetWakeUpCounter PROC
;;;1520     */
;;;1521   void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
000000  4904              LDR      r1,|L37.20|
;;;1522   {
;;;1523     /* Check the parameters */
;;;1524     assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
;;;1525     
;;;1526     /* Disable the write protection for RTC registers */
;;;1527     RTC->WPR = 0xCA;
000002  22ca              MOVS     r2,#0xca
000004  600a              STR      r2,[r1,#0]
;;;1528     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  600a              STR      r2,[r1,#0]
;;;1529     
;;;1530     /* Configure the Wakeup Timer counter */
;;;1531     RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
00000a  4a03              LDR      r2,|L37.24|
00000c  6010              STR      r0,[r2,#0]
;;;1532     
;;;1533     /* Enable the write protection for RTC registers */
;;;1534     RTC->WPR = 0xFF; 
00000e  20ff              MOVS     r0,#0xff
000010  6008              STR      r0,[r1,#0]
;;;1535   }
000012  4770              BX       lr
;;;1536   
                          ENDP

                  |L37.20|
                          DCD      0x40002824
                  |L37.24|
                          DCD      0x40002814

                          AREA ||i.RTC_SmoothCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_SmoothCalibConfig PROC
;;;1905   */
;;;1906   ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
000000  b430              PUSH     {r4,r5}
;;;1907                                     uint32_t RTC_SmoothCalibPlusPulses,
;;;1908                                     uint32_t RTC_SmouthCalibMinusPulsesValue)
;;;1909   {
;;;1910     ErrorStatus status = ERROR;
;;;1911     uint32_t recalpfcount = 0;
;;;1912   
;;;1913     /* Check the parameters */
;;;1914     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
;;;1915     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
;;;1916     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
;;;1917   
;;;1918     /* Disable the write protection for RTC registers */
;;;1919     RTC->WPR = 0xCA;
000002  4d15              LDR      r5,|L38.88|
000004  f04f0cca          MOV      r12,#0xca
000008  2300              MOVS     r3,#0                 ;1911
00000a  f8c5c000          STR      r12,[r5,#0]
;;;1920     RTC->WPR = 0x53;
00000e  f04f0c53          MOV      r12,#0x53
000012  f8c5c000          STR      r12,[r5,#0]
;;;1921     
;;;1922     /* check if a calibration is pending*/
;;;1923     if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
000016  f8dfc044          LDR      r12,|L38.92|
00001a  f8dc4000          LDR      r4,[r12,#0]
00001e  f4143f80          TST      r4,#0x10000
000022  d008              BEQ      |L38.54|
                  |L38.36|
;;;1924     {
;;;1925       /* wait until the Calibration is completed*/
;;;1926       while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
000024  f8dc4000          LDR      r4,[r12,#0]
000028  f4143f80          TST      r4,#0x10000
00002c  bf1c              ITT      NE
00002e  f5b33f00          CMPNE    r3,#0x20000
000032  1c5b              ADDNE    r3,r3,#1
000034  d1f6              BNE      |L38.36|
                  |L38.54|
;;;1927       {
;;;1928         recalpfcount++;
;;;1929       }
;;;1930     }
;;;1931   
;;;1932     /* check if the calibration pending is completed or if there is no calibration operation at all*/
;;;1933     if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
000036  f8dc3000          LDR      r3,[r12,#0]
00003a  f4133f80          TST      r3,#0x10000
;;;1934     {
;;;1935       /* Configure the Smooth calibration settings */
;;;1936       RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
;;;1937   
;;;1938       status = SUCCESS;
;;;1939     }
;;;1940     else
;;;1941     {
;;;1942       status = ERROR;
00003e  bf18              IT       NE
000040  2000              MOVNE    r0,#0
000042  d003              BEQ      |L38.76|
                  |L38.68|
;;;1943     }
;;;1944   
;;;1945     /* Enable the write protection for RTC registers */
;;;1946     RTC->WPR = 0xFF;
000044  21ff              MOVS     r1,#0xff
000046  6029              STR      r1,[r5,#0]
;;;1947     
;;;1948     return (ErrorStatus)(status);
;;;1949   }
000048  bc30              POP      {r4,r5}
00004a  4770              BX       lr
                  |L38.76|
00004c  4308              ORRS     r0,r0,r1              ;1936
00004e  4904              LDR      r1,|L38.96|
000050  4310              ORRS     r0,r0,r2              ;1936
000052  6008              STR      r0,[r1,#0]            ;1936
000054  2001              MOVS     r0,#1                 ;1938
000056  e7f5              B        |L38.68|
;;;1950   
                          ENDP

                  |L38.88|
                          DCD      0x40002824
                  |L38.92|
                          DCD      0x4000280c
                  |L38.96|
                          DCD      0x4000283c

                          AREA ||i.RTC_StructInit||, CODE, READONLY, ALIGN=1

                  RTC_StructInit PROC
;;;502      */
;;;503    void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
000000  2100              MOVS     r1,#0
;;;504    {
;;;505      /* Initialize the RTC_HourFormat member */
;;;506      RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
;;;507        
;;;508      /* Initialize the RTC_AsynchPrediv member */
;;;509      RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
000002  6001              STR      r1,[r0,#0]
000004  217f              MOVS     r1,#0x7f
;;;510    
;;;511      /* Initialize the RTC_SynchPrediv member */
;;;512      RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
000006  6041              STR      r1,[r0,#4]
000008  21ff              MOVS     r1,#0xff
00000a  6081              STR      r1,[r0,#8]
;;;513    }
00000c  4770              BX       lr
;;;514    
                          ENDP


                          AREA ||i.RTC_SynchroShiftConfig||, CODE, READONLY, ALIGN=2

                  RTC_SynchroShiftConfig PROC
;;;2436   */
;;;2437   ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
000000  b510              PUSH     {r4,lr}
;;;2438   {
;;;2439     ErrorStatus status = ERROR;
;;;2440     uint32_t shpfcount = 0;
;;;2441   
;;;2442     /* Check the parameters */
;;;2443     assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
;;;2444     assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
;;;2445   
;;;2446     /* Disable the write protection for RTC registers */
;;;2447     RTC->WPR = 0xCA;
000002  4c15              LDR      r4,|L40.88|
000004  2200              MOVS     r2,#0                 ;2440
000006  23ca              MOVS     r3,#0xca
000008  6023              STR      r3,[r4,#0]
;;;2448     RTC->WPR = 0x53;
00000a  2353              MOVS     r3,#0x53
00000c  6023              STR      r3,[r4,#0]
;;;2449     
;;;2450     /* Check if a Shift is pending*/
;;;2451     if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
00000e  4b13              LDR      r3,|L40.92|
000010  f8d3c000          LDR      r12,[r3,#0]
000014  f01c0f08          TST      r12,#8
000018  d008              BEQ      |L40.44|
                  |L40.26|
;;;2452     {
;;;2453       /* Wait until the shift is completed*/
;;;2454       while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
00001a  f8d3c000          LDR      r12,[r3,#0]
00001e  f01c0f08          TST      r12,#8
000022  bf1c              ITT      NE
000024  f5b25f80          CMPNE    r2,#0x1000
000028  1c52              ADDNE    r2,r2,#1
00002a  d1f6              BNE      |L40.26|
                  |L40.44|
;;;2455       {
;;;2456         shpfcount++;
;;;2457       }
;;;2458     }
;;;2459   
;;;2460     /* Check if the Shift pending is completed or if there is no Shift operation at all*/
;;;2461     if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
00002c  681a              LDR      r2,[r3,#0]
00002e  f0120f08          TST      r2,#8
000032  d104              BNE      |L40.62|
;;;2462     {
;;;2463       /* check if the reference clock detection is disabled */
;;;2464       if((RTC->CR & RTC_CR_REFCKON) == RESET)
000034  4a0a              LDR      r2,|L40.96|
000036  6812              LDR      r2,[r2,#0]
000038  f0120f10          TST      r2,#0x10
00003c  d003              BEQ      |L40.70|
                  |L40.62|
;;;2465       {
;;;2466         /* Configure the Shift settings */
;;;2467         RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
;;;2468       
;;;2469         if(RTC_WaitForSynchro() == ERROR)
;;;2470         {
;;;2471           status = ERROR;
;;;2472         }
;;;2473         else
;;;2474         {
;;;2475           status = SUCCESS;
;;;2476         }
;;;2477       }
;;;2478       else
;;;2479       {
;;;2480         status = ERROR;
00003e  2000              MOVS     r0,#0
                  |L40.64|
;;;2481       }
;;;2482     }
;;;2483     else
;;;2484     {
;;;2485       status = ERROR;
;;;2486     }
;;;2487   
;;;2488     /* Enable the write protection for RTC registers */
;;;2489     RTC->WPR = 0xFF;
000040  21ff              MOVS     r1,#0xff
000042  6021              STR      r1,[r4,#0]
;;;2490     
;;;2491     return (ErrorStatus)(status);
;;;2492   }
000044  bd10              POP      {r4,pc}
                  |L40.70|
000046  4308              ORRS     r0,r0,r1              ;2467
000048  4906              LDR      r1,|L40.100|
00004a  6008              STR      r0,[r1,#0]            ;2467
00004c  f7fffffe          BL       RTC_WaitForSynchro
000050  2800              CMP      r0,#0                 ;2469
000052  bf18              IT       NE                    ;2475
000054  2001              MOVNE    r0,#1                 ;2475
000056  e7f3              B        |L40.64|
;;;2493   
                          ENDP

                  |L40.88|
                          DCD      0x40002824
                  |L40.92|
                          DCD      0x4000280c
                  |L40.96|
                          DCD      0x40002808
                  |L40.100|
                          DCD      0x4000282c

                          AREA ||i.RTC_TamperCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperCmd PROC
;;;2130     */
;;;2131   void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
000000  4a04              LDR      r2,|L41.20|
;;;2132   {
;;;2133     /* Check the parameters */
;;;2134     assert_param(IS_RTC_TAMPER(RTC_Tamper));  
;;;2135     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2136     
;;;2137     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;2138     {
;;;2139       /* Enable the selected Tamper pin */
;;;2140       RTC->TAFCR |= (uint32_t)RTC_Tamper;
;;;2141     }
;;;2142     else
;;;2143     {
;;;2144       /* Disable the selected Tamper pin */
;;;2145       RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;2140
000008  4308              ORRNE    r0,r0,r1              ;2140
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;2140
;;;2146     }  
;;;2147   }
000010  4770              BX       lr
;;;2148   
                          ENDP

000012  0000              DCW      0x0000
                  |L41.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperFilterConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperFilterConfig PROC
;;;2161     */
;;;2162   void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
000000  4904              LDR      r1,|L42.20|
;;;2163   {
;;;2164     /* Check the parameters */
;;;2165     assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
;;;2166      
;;;2167     /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
;;;2168     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
000002  680a              LDR      r2,[r1,#0]
000004  f42252c0          BIC      r2,r2,#0x1800
000008  600a              STR      r2,[r1,#0]
;;;2169   
;;;2170     /* Configure the RTC_TAFCR register */
;;;2171     RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
00000a  680a              LDR      r2,[r1,#0]
00000c  4310              ORRS     r0,r0,r2
00000e  6008              STR      r0,[r1,#0]
;;;2172   }
000010  4770              BX       lr
;;;2173   
                          ENDP

000012  0000              DCW      0x0000
                  |L42.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinSelection||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinSelection PROC
;;;2362     */
;;;2363   void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
000000  4904              LDR      r1,|L43.20|
;;;2364   {
;;;2365     /* Check the parameters */
;;;2366     assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
;;;2367     
;;;2368     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
000002  680a              LDR      r2,[r1,#0]
000004  f4223280          BIC      r2,r2,#0x10000
000008  600a              STR      r2,[r1,#0]
;;;2369     RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
00000a  680a              LDR      r2,[r1,#0]
00000c  4310              ORRS     r0,r0,r2
00000e  6008              STR      r0,[r1,#0]
;;;2370   }
000010  4770              BX       lr
;;;2371   
                          ENDP

000012  0000              DCW      0x0000
                  |L43.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinsPrechargeDuration||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinsPrechargeDuration PROC
;;;2218     */
;;;2219   void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
000000  4904              LDR      r1,|L44.20|
;;;2220   {
;;;2221     /* Check the parameters */
;;;2222     assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
;;;2223      
;;;2224     /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
;;;2225     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
000002  680a              LDR      r2,[r1,#0]
000004  f42242c0          BIC      r2,r2,#0x6000
000008  600a              STR      r2,[r1,#0]
;;;2226   
;;;2227     /* Configure the RTC_TAFCR register */
;;;2228     RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
00000a  680a              LDR      r2,[r1,#0]
00000c  4310              ORRS     r0,r0,r2
00000e  6008              STR      r0,[r1,#0]
;;;2229   }
000010  4770              BX       lr
;;;2230   
                          ENDP

000012  0000              DCW      0x0000
                  |L44.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPullUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperPullUpCmd PROC
;;;2261     */
;;;2262   void RTC_TamperPullUpCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L45.20|
;;;2263   {
;;;2264     /* Check the parameters */
;;;2265     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2266     
;;;2267    if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2268     {
;;;2269       /* Enable precharge of the selected Tamper pin */
;;;2270       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
;;;2271     }
;;;2272     else
;;;2273     {
;;;2274       /* Disable precharge of the selected Tamper pin */
;;;2275       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;2270
000008  f4204000          BICNE    r0,r0,#0x8000         ;2270
00000c  f4404000          ORREQ    r0,r0,#0x8000
000010  6008              STR      r0,[r1,#0]            ;2270
;;;2276     } 
;;;2277   }
000012  4770              BX       lr
;;;2278   
                          ENDP

                  |L45.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperSamplingFreqConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperSamplingFreqConfig PROC
;;;2195     */
;;;2196   void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
000000  4904              LDR      r1,|L46.20|
;;;2197   {
;;;2198     /* Check the parameters */
;;;2199     assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
;;;2200    
;;;2201     /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
;;;2202     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
000002  680a              LDR      r2,[r1,#0]
000004  f42262e0          BIC      r2,r2,#0x700
000008  600a              STR      r2,[r1,#0]
;;;2203   
;;;2204     /* Configure the RTC_TAFCR register */
;;;2205     RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
00000a  680a              LDR      r2,[r1,#0]
00000c  4310              ORRS     r0,r0,r2
00000e  6008              STR      r0,[r1,#0]
;;;2206   }
000010  4770              BX       lr
;;;2207   
                          ENDP

000012  0000              DCW      0x0000
                  |L46.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperTriggerConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperTriggerConfig PROC
;;;2104     */
;;;2105   void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
000000  4a04              LDR      r2,|L47.20|
;;;2106   {
;;;2107     /* Check the parameters */
;;;2108     assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
;;;2109     assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
;;;2110    
;;;2111     if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
000002  2900              CMP      r1,#0
;;;2112     {  
;;;2113       /* Configure the RTC_TAFCR register */
;;;2114       RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
;;;2115     }
;;;2116     else
;;;2117     { 
;;;2118       /* Configure the RTC_TAFCR register */
;;;2119       RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
000004  6811              LDR      r1,[r2,#0]
000006  bf0c              ITE      EQ                    ;2114
000008  ea210040          BICEQ    r0,r1,r0,LSL #1       ;2114
00000c  ea410040          ORRNE    r0,r1,r0,LSL #1
000010  6010              STR      r0,[r2,#0]            ;2114
;;;2120     }  
;;;2121   }
000012  4770              BX       lr
;;;2122   
                          ENDP

                  |L47.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampCmd PROC
;;;1981     */
;;;1982   void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
000000  4b0a              LDR      r3,|L48.44|
;;;1983   {
;;;1984     uint32_t tmpreg = 0;
;;;1985   
;;;1986     /* Check the parameters */
;;;1987     assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
;;;1988     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1989   
;;;1990     /* Get the RTC_CR register and clear the bits to be configured */
;;;1991     tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000002  681a              LDR      r2,[r3,#0]
;;;1992   
;;;1993     /* Get the new configuration */
;;;1994     if (NewState != DISABLE)
000004  2900              CMP      r1,#0
000006  f0220208          BIC      r2,r2,#8              ;1991
00000a  f4226200          BIC      r2,r2,#0x800          ;1991
;;;1995     {
;;;1996       tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
;;;1997     }
;;;1998     else
;;;1999     {
;;;2000       tmpreg |= (uint32_t)(RTC_TimeStampEdge);
00000e  ea420000          ORR      r0,r2,r0
000012  bf18              IT       NE                    ;1996
000014  f4406000          ORRNE    r0,r0,#0x800          ;1996
;;;2001     }
;;;2002   
;;;2003     /* Disable the write protection for RTC registers */
;;;2004     RTC->WPR = 0xCA;
000018  22ca              MOVS     r2,#0xca
00001a  4905              LDR      r1,|L48.48|
00001c  600a              STR      r2,[r1,#0]
;;;2005     RTC->WPR = 0x53;
00001e  2253              MOVS     r2,#0x53
000020  600a              STR      r2,[r1,#0]
;;;2006   
;;;2007     /* Configure the Time Stamp TSEDGE and Enable bits */
;;;2008     RTC->CR = (uint32_t)tmpreg;
000022  6018              STR      r0,[r3,#0]
;;;2009   
;;;2010     /* Enable the write protection for RTC registers */
;;;2011     RTC->WPR = 0xFF; 
000024  20ff              MOVS     r0,#0xff
000026  6008              STR      r0,[r1,#0]
;;;2012   }
000028  4770              BX       lr
;;;2013   
                          ENDP

00002a  0000              DCW      0x0000
                  |L48.44|
                          DCD      0x40002808
                  |L48.48|
                          DCD      0x40002824

                          AREA ||i.RTC_TimeStampOnTamperDetectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampOnTamperDetectionCmd PROC
;;;2238     */
;;;2239   void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L49.20|
;;;2240   {
;;;2241     /* Check the parameters */
;;;2242     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2243      
;;;2244     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2245     {
;;;2246       /* Save timestamp on tamper detection event */
;;;2247       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
;;;2248     }
;;;2249     else
;;;2250     {
;;;2251       /* Tamper detection does not cause a timestamp to be saved */
;;;2252       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;2247
000008  f0400080          ORRNE    r0,r0,#0x80           ;2247
00000c  f0200080          BICEQ    r0,r0,#0x80
000010  6008              STR      r0,[r1,#0]            ;2247
;;;2253     }
;;;2254   }
000012  4770              BX       lr
;;;2255   
                          ENDP

                  |L49.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampPinSelection||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampPinSelection PROC
;;;2379     */
;;;2380   void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
000000  4904              LDR      r1,|L50.20|
;;;2381   {
;;;2382     /* Check the parameters */
;;;2383     assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;2384     
;;;2385     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
000002  680a              LDR      r2,[r1,#0]
000004  f4223200          BIC      r2,r2,#0x20000
000008  600a              STR      r2,[r1,#0]
;;;2386     RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
00000a  680a              LDR      r2,[r1,#0]
00000c  4310              ORRS     r0,r0,r2
00000e  6008              STR      r0,[r1,#0]
;;;2387   }
000010  4770              BX       lr
;;;2388   
                          ENDP

000012  0000              DCW      0x0000
                  |L50.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStructInit||, CODE, READONLY, ALIGN=1

                  RTC_TimeStructInit PROC
;;;867      */
;;;868    void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
000000  2100              MOVS     r1,#0
;;;869    {
;;;870      /* Time = 00h:00min:00sec */
;;;871      RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;872      RTC_TimeStruct->RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;873      RTC_TimeStruct->RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;874      RTC_TimeStruct->RTC_Seconds = 0; 
000008  7081              STRB     r1,[r0,#2]
;;;875    }
00000a  4770              BX       lr
;;;876    
                          ENDP


                          AREA ||i.RTC_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;618      */
;;;619    ErrorStatus RTC_WaitForSynchro(void)
000000  b081              SUB      sp,sp,#4
;;;620    {
;;;621      __IO uint32_t synchrocounter = 0;
000002  2000              MOVS     r0,#0
;;;622      ErrorStatus status = ERROR;
;;;623      uint32_t synchrostatus = 0x00;
;;;624    
;;;625      /* Disable the write protection for RTC registers */
;;;626      RTC->WPR = 0xCA;
000004  4b0f              LDR      r3,|L52.68|
000006  9000              STR      r0,[sp,#0]
000008  20ca              MOVS     r0,#0xca
00000a  6018              STR      r0,[r3,#0]
;;;627      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6018              STR      r0,[r3,#0]
;;;628        
;;;629      /* Clear RSF flag */
;;;630      RTC->ISR &= (uint32_t)RTC_RSF_MASK;
000010  490d              LDR      r1,|L52.72|
000012  6808              LDR      r0,[r1,#0]
000014  f02000a0          BIC      r0,r0,#0xa0
000018  6008              STR      r0,[r1,#0]
                  |L52.26|
;;;631        
;;;632      /* Wait the registers to be synchronised */
;;;633      do
;;;634      {
;;;635        synchrostatus = RTC->ISR & RTC_ISR_RSF;
00001a  6808              LDR      r0,[r1,#0]
;;;636        synchrocounter++;  
00001c  9a00              LDR      r2,[sp,#0]
00001e  f0000020          AND      r0,r0,#0x20           ;635
000022  1c52              ADDS     r2,r2,#1
;;;637      } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
000024  9200              STR      r2,[sp,#0]
000026  f5b23f00          CMP      r2,#0x20000
00002a  d001              BEQ      |L52.48|
00002c  2800              CMP      r0,#0
00002e  d0f4              BEQ      |L52.26|
                  |L52.48|
;;;638        
;;;639      if ((RTC->ISR & RTC_ISR_RSF) != RESET)
000030  6808              LDR      r0,[r1,#0]
000032  f0100020          ANDS     r0,r0,#0x20
;;;640      {
;;;641        status = SUCCESS;
000036  bf18              IT       NE
000038  2001              MOVNE    r0,#1
;;;642      }
;;;643      else
;;;644      {
;;;645        status = ERROR;
;;;646      }        
;;;647    
;;;648      /* Enable the write protection for RTC registers */
;;;649      RTC->WPR = 0xFF; 
00003a  21ff              MOVS     r1,#0xff
00003c  6019              STR      r1,[r3,#0]
;;;650        
;;;651      return (status); 
;;;652    }
00003e  b001              ADD      sp,sp,#4
000040  4770              BX       lr
;;;653    
                          ENDP

000042  0000              DCW      0x0000
                  |L52.68|
                          DCD      0x40002824
                  |L52.72|
                          DCD      0x4000280c

                          AREA ||i.RTC_WakeUpClockConfig||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpClockConfig PROC
;;;1493     */
;;;1494   void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
000000  4a07              LDR      r2,|L53.32|
;;;1495   {
;;;1496     /* Check the parameters */
;;;1497     assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
;;;1498   
;;;1499     /* Disable the write protection for RTC registers */
;;;1500     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1501     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1502   
;;;1503     /* Clear the Wakeup Timer clock source bits in CR register */
;;;1504     RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
00000a  4906              LDR      r1,|L53.36|
00000c  680b              LDR      r3,[r1,#0]
00000e  f0230307          BIC      r3,r3,#7
000012  600b              STR      r3,[r1,#0]
;;;1505   
;;;1506     /* Configure the clock source */
;;;1507     RTC->CR |= (uint32_t)RTC_WakeUpClock;
000014  680b              LDR      r3,[r1,#0]
000016  4318              ORRS     r0,r0,r3
000018  6008              STR      r0,[r1,#0]
;;;1508     
;;;1509     /* Enable the write protection for RTC registers */
;;;1510     RTC->WPR = 0xFF; 
00001a  20ff              MOVS     r0,#0xff
00001c  6010              STR      r0,[r2,#0]
;;;1511   }
00001e  4770              BX       lr
;;;1512   
                          ENDP

                  |L53.32|
                          DCD      0x40002824
                  |L53.36|
                          DCD      0x40002808

                          AREA ||i.RTC_WakeUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpCmd PROC
;;;1553     */
;;;1554   ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
000000  b081              SUB      sp,sp,#4
;;;1555   {
;;;1556     __IO uint32_t wutcounter = 0x00;
000002  2100              MOVS     r1,#0
;;;1557     uint32_t wutwfstatus = 0x00;
;;;1558     ErrorStatus status = ERROR;
;;;1559     
;;;1560     /* Check the parameters */
;;;1561     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1562   
;;;1563     /* Disable the write protection for RTC registers */
;;;1564     RTC->WPR = 0xCA;
000004  4b13              LDR      r3,|L54.84|
000006  9100              STR      r1,[sp,#0]
000008  21ca              MOVS     r1,#0xca
00000a  6019              STR      r1,[r3,#0]
;;;1565     RTC->WPR = 0x53;
00000c  2153              MOVS     r1,#0x53
00000e  6019              STR      r1,[r3,#0]
;;;1566   
;;;1567     if (NewState != DISABLE)
;;;1568     {
;;;1569       /* Enable the Wakeup Timer */
;;;1570       RTC->CR |= (uint32_t)RTC_CR_WUTE;
000010  4911              LDR      r1,|L54.88|
000012  2800              CMP      r0,#0                 ;1567
;;;1571       status = SUCCESS;    
;;;1572     }
;;;1573     else
;;;1574     {
;;;1575       /* Disable the Wakeup Timer */
;;;1576       RTC->CR &= (uint32_t)~RTC_CR_WUTE;
000014  6808              LDR      r0,[r1,#0]
000016  bf14              ITE      NE                    ;1570
000018  f4406080          ORRNE    r0,r0,#0x400          ;1570
00001c  f4206080          BICEQ    r0,r0,#0x400
000020  6008              STR      r0,[r1,#0]
000022  bf14              ITE      NE                    ;1571
000024  2001              MOVNE    r0,#1                 ;1571
;;;1577       /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;1578       do
;;;1579       {
;;;1580         wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
000026  490d              LDREQ    r1,|L54.92|
000028  d10f              BNE      |L54.74|
                  |L54.42|
00002a  6808              LDR      r0,[r1,#0]
;;;1581         wutcounter++;  
00002c  9a00              LDR      r2,[sp,#0]
00002e  f0000004          AND      r0,r0,#4              ;1580
000032  1c52              ADDS     r2,r2,#1
;;;1582       } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
000034  9200              STR      r2,[sp,#0]
000036  f5b23f80          CMP      r2,#0x10000
00003a  d001              BEQ      |L54.64|
00003c  2800              CMP      r0,#0
00003e  d0f4              BEQ      |L54.42|
                  |L54.64|
;;;1583       
;;;1584       if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
000040  6808              LDR      r0,[r1,#0]
000042  f0100004          ANDS     r0,r0,#4
;;;1585       {
;;;1586         status = ERROR;
;;;1587       }
;;;1588       else
;;;1589       {
;;;1590         status = SUCCESS;
000046  bf18              IT       NE
000048  2001              MOVNE    r0,#1
                  |L54.74|
;;;1591       }    
;;;1592     }
;;;1593   
;;;1594     /* Enable the write protection for RTC registers */
;;;1595     RTC->WPR = 0xFF; 
00004a  21ff              MOVS     r1,#0xff
00004c  6019              STR      r1,[r3,#0]
;;;1596     
;;;1597     return status;
;;;1598   }
00004e  b001              ADD      sp,sp,#4
000050  4770              BX       lr
;;;1599   
                          ENDP

000052  0000              DCW      0x0000
                  |L54.84|
                          DCD      0x40002824
                  |L54.88|
                          DCD      0x40002808
                  |L54.92|
                          DCD      0x4000280c

                          AREA ||i.RTC_WriteBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_WriteBackupRegister PROC
;;;2302     */
;;;2303   void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
000000  4a03              LDR      r2,|L55.16|
;;;2304   {
000002  b081              SUB      sp,sp,#4
;;;2305     __IO uint32_t tmp = 0;
;;;2306     
;;;2307     /* Check the parameters */
;;;2308     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2309   
;;;2310     tmp = RTC_BASE + 0x50;
;;;2311     tmp += (RTC_BKP_DR * 4);
000004  eb020080          ADD      r0,r2,r0,LSL #2
;;;2312   
;;;2313     /* Write the specified register */
;;;2314     *(__IO uint32_t *)tmp = (uint32_t)Data;
000008  9000              STR      r0,[sp,#0]
00000a  6001              STR      r1,[r0,#0]
;;;2315   }
00000c  b001              ADD      sp,sp,#4
00000e  4770              BX       lr
;;;2316   
                          ENDP

                  |L55.16|
                          DCD      0x40002850

                          AREA ||i.RTC_WriteProtectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_WriteProtectionCmd PROC
;;;524      */
;;;525    void RTC_WriteProtectionCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L56.20|
;;;526    {
;;;527      /* Check the parameters */
;;;528      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;529        
;;;530      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;531      {
;;;532        /* Enable the write protection for RTC registers */
;;;533        RTC->WPR = 0xFF;   
000004  bf11              ITEEE    NE
000006  20ff              MOVNE    r0,#0xff
;;;534      }
;;;535      else
;;;536      {
;;;537        /* Disable the write protection for RTC registers */
;;;538        RTC->WPR = 0xCA;
000008  20ca              MOVEQ    r0,#0xca
00000a  6008              STREQ    r0,[r1,#0]
;;;539        RTC->WPR = 0x53;    
00000c  2053              MOVEQ    r0,#0x53
00000e  6008              STR      r0,[r1,#0]            ;533
;;;540      }
;;;541    }
000010  4770              BX       lr
;;;542    
                          ENDP

000012  0000              DCW      0x0000
                  |L56.20|
                          DCD      0x40002824

;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\stm32f4xx_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___15_stm32f4xx_rtc_c_81435638____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____REVSH|
#line 144
|__asm___15_stm32f4xx_rtc_c_81435638____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
