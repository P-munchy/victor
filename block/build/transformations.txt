; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\transformations.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\transformations.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\transformations.crf ..\coretech\vision\robot\src\transformations.cpp]
                          THUMB

                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3211DeserializeEPcPPvRiRNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3211DeserializeEPcPPvRiRNS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::Deserialize(char*, void**, int&, Anki::Embedded::MemoryStack&)
;;;420    
;;;421          Result PlanarTransformation_f32::Deserialize(char *objectName, void** buffer, s32 &bufferLength, MemoryStack &memory)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;422          {
000004  b09f              SUB      sp,sp,#0x7c
000006  4604              MOV      r4,r0
000008  461e              MOV      r6,r3
00000a  4615              MOV      r5,r2
;;;423            // TODO: check if the name is correct
;;;424            if(SerializedBuffer::DeserializeDescriptionStrings(NULL, objectName, buffer, bufferLength) != RESULT_OK)
00000c  2000              MOVS     r0,#0
00000e  f8dd80a0          LDR      r8,[sp,#0xa0]
000012  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi ; Anki::Embedded::SerializedBuffer::DeserializeDescriptionStrings(char*, char*, void**, int&)
000016  2800              CMP      r0,#0
;;;425              return RESULT_FAIL;
000018  bf1e              ITTT     NE
00001a  2001              MOVNE    r0,#1
;;;426    
;;;427            this->isValid = SerializedBuffer::DeserializeRawBasicType<bool>(NULL, buffer, bufferLength);
;;;428            this->transformType = static_cast<Transformations::TransformType>(SerializedBuffer::DeserializeRawBasicType<s32>(NULL, buffer, bufferLength));
;;;429            this->homography = SerializedBuffer::DeserializeRawArray<f32>(NULL, buffer, bufferLength, memory);
;;;430            this->initialCorners = SerializedBuffer::DeserializeRawBasicType<Quadrilateral<f32> >(NULL, buffer, bufferLength);
;;;431            this->centerOffset = SerializedBuffer::DeserializeRawBasicType<Point<f32> >(NULL, buffer, bufferLength);
;;;432            this->initialPointsAreZeroCentered = SerializedBuffer::DeserializeRawBasicType<bool>(NULL, buffer, bufferLength);
;;;433    
;;;434            AnkiConditionalErrorAndReturnValue(this->homography.IsValid(),
;;;435              RESULT_FAIL, "PlanarTransformation_f32::Deserialize", "Parsing error");
;;;436    
;;;437            return RESULT_OK;
;;;438          }
00001c  b01f              ADDNE    sp,sp,#0x7c
00001e  e8bd8ff0          POPNE    {r4-r11,pc}
000022  4632              MOV      r2,r6                 ;427
000024  4629              MOV      r1,r5                 ;427
000026  2000              MOVS     r0,#0                 ;427
000028  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRi ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<bool>(char*, void**, int&)
00002c  7020              STRB     r0,[r4,#0]            ;427
00002e  2100              MOVS     r1,#0                 ;428
000030  4633              MOV      r3,r6                 ;428
000032  462a              MOV      r2,r5                 ;428
000034  4608              MOV      r0,r1                 ;428
000036  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi ; Anki::Embedded::SerializedBuffer::DeserializeDescriptionStrings(char*, char*, void**, int&)
00003a  a80f              ADD      r0,sp,#0x3c           ;428
00003c  a914              ADD      r1,sp,#0x50           ;428
00003e  e9cd1002          STRD     r1,r0,[sp,#8]         ;428
000042  a813              ADD      r0,sp,#0x4c           ;428
000044  a912              ADD      r1,sp,#0x48           ;428
000046  e9cd1000          STRD     r1,r0,[sp,#0]         ;428
00004a  e9cd5604          STRD     r5,r6,[sp,#0x10]      ;428
00004e  ab11              ADD      r3,sp,#0x44           ;428
000050  aa10              ADD      r2,sp,#0x40           ;428
000052  a90e              ADD      r1,sp,#0x38           ;428
000054  2001              MOVS     r0,#1                 ;428
000056  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer22EncodedBasicTypeBuffer11DeserializeEbRtRbS4_S4_S4_S4_RiPPvS5_ ; Anki::Embedded::SerializedBuffer::EncodedBasicTypeBuffer::Deserialize(bool, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
00005a  682b              LDR      r3,[r5,#0]            ;428
00005c  f8bd1038          LDRH     r1,[sp,#0x38]         ;428
000060  f2427010          MOV      r0,#0x2710            ;428
000064  f8dfa230          LDR      r10,|L1.664|
000068  681a              LDR      r2,[r3,#0]            ;428
00006a  f2401b07          MOV      r11,#0x107            ;428
00006e  4281              CMP      r1,r0                 ;428
000070  d204              BCS      |L1.124|
000072  980f              LDR      r0,[sp,#0x3c]         ;428
000074  2800              CMP      r0,#0                 ;428
000076  bfc8              IT       GT                    ;428
000078  4582              CMPGT    r10,r0                ;428
00007a  dc0a              BGT      |L1.146|
                  |L1.124|
00007c  4887              LDR      r0,|L1.668|
00007e  e9cd0b00          STRD     r0,r11,[sp,#0]        ;428
000082  a387              ADR      r3,|L1.672|
000084  a295              ADR      r2,|L1.732|
000086  a19e              ADR      r1,|L1.768|
000088  2005              MOVS     r0,#5                 ;428
00008a  f7fffffe          BL       _Anki_Log
00008e  2200              MOVS     r2,#0                 ;428
000090  e007              B        |L1.162|
                  |L1.146|
000092  fb013c00          MLA      r12,r1,r0,r3          ;428
000096  f8c5c000          STR      r12,[r5,#0]           ;428
00009a  6833              LDR      r3,[r6,#0]            ;428
00009c  fb013110          MLS      r1,r1,r0,r3           ;428
0000a0  6031              STR      r1,[r6,#0]            ;428
                  |L1.162|
0000a2  8062              STRH     r2,[r4,#2]            ;428
0000a4  1d27              ADDS     r7,r4,#4              ;429
0000a6  4633              MOV      r3,r6                 ;429
0000a8  462a              MOV      r2,r5                 ;429
0000aa  2100              MOVS     r1,#0                 ;429
0000ac  a801              ADD      r0,sp,#4              ;429
0000ae  f8cd8000          STR      r8,[sp,#0]            ;429
0000b2  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer19DeserializeRawArrayIfEENS0_5ArrayIT_EEPcPPvRiRNS0_11MemoryStackE ; Anki::Embedded::SerializedBuffer::DeserializeRawArray<float>(char*, void**, int&, Anki::Embedded::MemoryStack&)
0000b6  f10d0904          ADD      r9,sp,#4              ;429
0000ba  f1040818          ADD      r8,r4,#0x18           ;430
0000be  e8b9100f          LDM      r9!,{r0-r3,r12}       ;429
0000c2  e8a7100f          STM      r7!,{r0-r3,r12}       ;429
0000c6  2100              MOVS     r1,#0                 ;430
0000c8  f10d0918          ADD      r9,sp,#0x18           ;430
0000cc  4633              MOV      r3,r6                 ;430
0000ce  462a              MOV      r2,r5                 ;430
0000d0  4608              MOV      r0,r1                 ;430
0000d2  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi ; Anki::Embedded::SerializedBuffer::DeserializeDescriptionStrings(char*, char*, void**, int&)
0000d6  a819              ADD      r0,sp,#0x64           ;430
0000d8  a91e              ADD      r1,sp,#0x78           ;430
0000da  e9cd1002          STRD     r1,r0,[sp,#8]         ;430
0000de  a81d              ADD      r0,sp,#0x74           ;430
0000e0  a91c              ADD      r1,sp,#0x70           ;430
0000e2  e9cd1000          STRD     r1,r0,[sp,#0]         ;430
0000e6  e9cd5604          STRD     r5,r6,[sp,#0x10]      ;430
0000ea  ab1b              ADD      r3,sp,#0x6c           ;430
0000ec  aa1a              ADD      r2,sp,#0x68           ;430
0000ee  a918              ADD      r1,sp,#0x60           ;430
0000f0  2001              MOVS     r0,#1                 ;430
0000f2  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer22EncodedBasicTypeBuffer11DeserializeEbRtRbS4_S4_S4_S4_RiPPvS5_ ; Anki::Embedded::SerializedBuffer::EncodedBasicTypeBuffer::Deserialize(bool, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
0000f6  a80e              ADD      r0,sp,#0x38           ;430
0000f8  2304              MOVS     r3,#4                 ;430
0000fa  2208              MOVS     r2,#8                 ;430
0000fc  498b              LDR      r1,|L1.812|
0000fe  682f              LDR      r7,[r5,#0]            ;430
000100  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
000104  4603              MOV      r3,r0                 ;430
000106  2000              MOVS     r0,#0                 ;430
                  |L1.264|
000108  eb0701c0          ADD      r1,r7,r0,LSL #3       ;430
00010c  eb0302c0          ADD      r2,r3,r0,LSL #3       ;430
000110  ed910a00          VLDR     s0,[r1,#0]            ;430
000114  1c40              ADDS     r0,r0,#1              ;430
000116  ed820a00          VSTR     s0,[r2,#0]            ;430
00011a  ed910a01          VLDR     s0,[r1,#4]            ;430
00011e  2804              CMP      r0,#4                 ;430
000120  ed820a01          VSTR     s0,[r2,#4]            ;430
000124  dbf0              BLT      |L1.264|
000126  f8bd1060          LDRH     r1,[sp,#0x60]         ;430
00012a  f2427710          MOV      r7,#0x2710            ;430
00012e  42b9              CMP      r1,r7                 ;430
000130  d204              BCS      |L1.316|
000132  9819              LDR      r0,[sp,#0x64]         ;430
000134  2800              CMP      r0,#0                 ;430
000136  bfc8              IT       GT                    ;430
000138  4582              CMPGT    r10,r0                ;430
00013a  dc0c              BGT      |L1.342|
                  |L1.316|
00013c  487c              LDR      r0,|L1.816|
00013e  e9cd0b00          STRD     r0,r11,[sp,#0]        ;430
000142  a357              ADR      r3,|L1.672|
000144  a265              ADR      r2,|L1.732|
000146  a16e              ADR      r1,|L1.768|
000148  2005              MOVS     r0,#5                 ;430
00014a  f7fffffe          BL       _Anki_Log
00014e  4648              MOV      r0,r9                 ;430
000150  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1Ev ; Anki::Embedded::Quadrilateral<float>::Quadrilateral()
000154  e020              B        |L1.408|
                  |L1.342|
000156  682a              LDR      r2,[r5,#0]            ;430
000158  fb012300          MLA      r3,r1,r0,r2           ;430
00015c  602b              STR      r3,[r5,#0]            ;430
00015e  6832              LDR      r2,[r6,#0]            ;430
000160  2304              MOVS     r3,#4                 ;430
000162  fb012110          MLS      r1,r1,r0,r2           ;430
000166  4648              MOV      r0,r9                 ;430
000168  6031              STR      r1,[r6,#0]            ;430
00016a  f10d0938          ADD      r9,sp,#0x38           ;430
00016e  2208              MOVS     r2,#8                 ;430
000170  496e              LDR      r1,|L1.812|
000172  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
000176  4603              MOV      r3,r0                 ;430
000178  2000              MOVS     r0,#0                 ;430
                  |L1.378|
00017a  eb0901c0          ADD      r1,r9,r0,LSL #3       ;430
00017e  eb0302c0          ADD      r2,r3,r0,LSL #3       ;430
000182  ed910a00          VLDR     s0,[r1,#0]            ;430
000186  1c40              ADDS     r0,r0,#1              ;430
000188  ed820a00          VSTR     s0,[r2,#0]            ;430
00018c  ed910a01          VLDR     s0,[r1,#4]            ;430
000190  2804              CMP      r0,#4                 ;430
000192  ed820a01          VSTR     s0,[r2,#4]            ;430
000196  dbf0              BLT      |L1.378|
                  |L1.408|
000198  ab06              ADD      r3,sp,#0x18           ;430
00019a  2000              MOVS     r0,#0                 ;430
                  |L1.412|
00019c  eb0301c0          ADD      r1,r3,r0,LSL #3       ;430
0001a0  eb0802c0          ADD      r2,r8,r0,LSL #3       ;430
0001a4  ed910a00          VLDR     s0,[r1,#0]            ;430
0001a8  1c40              ADDS     r0,r0,#1              ;430
0001aa  ed820a00          VSTR     s0,[r2,#0]            ;430
0001ae  ed910a01          VLDR     s0,[r1,#4]            ;430
0001b2  2804              CMP      r0,#4                 ;430
0001b4  ed820a01          VSTR     s0,[r2,#4]            ;430
0001b8  dbf0              BLT      |L1.412|
0001ba  2100              MOVS     r1,#0                 ;431
0001bc  f104083c          ADD      r8,r4,#0x3c           ;431
0001c0  4633              MOV      r3,r6                 ;431
0001c2  462a              MOV      r2,r5                 ;431
0001c4  4608              MOV      r0,r1                 ;431
0001c6  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi ; Anki::Embedded::SerializedBuffer::DeserializeDescriptionStrings(char*, char*, void**, int&)
0001ca  a811              ADD      r0,sp,#0x44           ;431
0001cc  a918              ADD      r1,sp,#0x60           ;431
0001ce  e9cd1002          STRD     r1,r0,[sp,#8]         ;431
0001d2  a815              ADD      r0,sp,#0x54           ;431
0001d4  a914              ADD      r1,sp,#0x50           ;431
0001d6  e9cd1000          STRD     r1,r0,[sp,#0]         ;431
0001da  e9cd5604          STRD     r5,r6,[sp,#0x10]      ;431
0001de  ab13              ADD      r3,sp,#0x4c           ;431
0001e0  aa12              ADD      r2,sp,#0x48           ;431
0001e2  a910              ADD      r1,sp,#0x40           ;431
0001e4  2001              MOVS     r0,#1                 ;431
0001e6  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer22EncodedBasicTypeBuffer11DeserializeEbRtRbS4_S4_S4_S4_RiPPvS5_ ; Anki::Embedded::SerializedBuffer::EncodedBasicTypeBuffer::Deserialize(bool, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
0001ea  6828              LDR      r0,[r5,#0]            ;431
0001ec  ed900a00          VLDR     s0,[r0,#0]            ;431
0001f0  ed8d0a0e          VSTR     s0,[sp,#0x38]         ;431
0001f4  ed900a01          VLDR     s0,[r0,#4]            ;431
0001f8  ed8d0a0f          VSTR     s0,[sp,#0x3c]         ;431
0001fc  f8bd1040          LDRH     r1,[sp,#0x40]         ;431
000200  42b9              CMP      r1,r7                 ;431
000202  d204              BCS      |L1.526|
000204  9811              LDR      r0,[sp,#0x44]         ;431
000206  2800              CMP      r0,#0                 ;431
000208  bfc8              IT       GT                    ;431
00020a  4582              CMPGT    r10,r0                ;431
00020c  dc0d              BGT      |L1.554|
                  |L1.526|
00020e  4849              LDR      r0,|L1.820|
000210  e9cd0b00          STRD     r0,r11,[sp,#0]        ;431
000214  a322              ADR      r3,|L1.672|
000216  a231              ADR      r2,|L1.732|
000218  a139              ADR      r1,|L1.768|
00021a  2005              MOVS     r0,#5                 ;431
00021c  f7fffffe          BL       _Anki_Log
000220  ed9f0a45          VLDR     s0,|L1.824|
000224  ed8d0a16          VSTR     s0,[sp,#0x58]         ;431
000228  e00d              B        |L1.582|
                  |L1.554|
00022a  682a              LDR      r2,[r5,#0]            ;431
00022c  fb012300          MLA      r3,r1,r0,r2           ;431
000230  602b              STR      r3,[r5,#0]            ;431
000232  6832              LDR      r2,[r6,#0]            ;431
000234  fb012110          MLS      r1,r1,r0,r2           ;431
000238  6031              STR      r1,[r6,#0]            ;431
00023a  ed9d0a0e          VLDR     s0,[sp,#0x38]         ;431
00023e  ed8d0a16          VSTR     s0,[sp,#0x58]         ;431
000242  ed9d0a0f          VLDR     s0,[sp,#0x3c]         ;431
                  |L1.582|
000246  4632              MOV      r2,r6                 ;432
000248  ed8d0a17          VSTR     s0,[sp,#0x5c]         ;432
00024c  ed9d0a16          VLDR     s0,[sp,#0x58]         ;432
000250  4629              MOV      r1,r5                 ;432
000252  ed880a00          VSTR     s0,[r8,#0]            ;432
000256  ed9d0a17          VLDR     s0,[sp,#0x5c]         ;432
00025a  2000              MOVS     r0,#0                 ;432
00025c  ed880a01          VSTR     s0,[r8,#4]            ;432
000260  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRi ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<bool>(char*, void**, int&)
000264  f8840038          STRB     r0,[r4,#0x38]         ;432
000268  1d20              ADDS     r0,r4,#4              ;434
00026a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00026e  2800              CMP      r0,#0                 ;434
000270  bf1e              ITTT     NE                    ;437
000272  2000              MOVNE    r0,#0                 ;437
000274  b01f              ADDNE    sp,sp,#0x7c
000276  e8bd8ff0          POPNE    {r4-r11,pc}
00027a  f44f71d9          MOV      r1,#0x1b2             ;434
00027e  482f              LDR      r0,|L1.828|
000280  e9cd0100          STRD     r0,r1,[sp,#0]         ;434
000284  a32e              ADR      r3,|L1.832|
000286  a23b              ADR      r2,|L1.884|
000288  a13e              ADR      r1,|L1.900|
00028a  2005              MOVS     r0,#5                 ;434
00028c  f7fffffe          BL       _Anki_Log
000290  b01f              ADD      sp,sp,#0x7c
000292  2001              MOVS     r0,#1                 ;434
000294  e8bd8ff0          POP      {r4-r11,pc}
;;;439    
                          ENDP

                  |L1.664|
                          DCD      0x000f4240
                  |L1.668|
                          DCD      _ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<int>(char*, void**, int&)::__PRETTY_FUNCTION__
                  |L1.672|
0002a0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/serial"
0002a4  6f726574
0002a8  6563685c
0002ac  636f6d6d
0002b0  6f6e5c69
0002b4  6e636c75
0002b8  64655c61
0002bc  6e6b692f
0002c0  636f6d6d
0002c4  6f6e2f72
0002c8  6f626f74
0002cc  2f736572
0002d0  69616c  
0002d3  697a652e          DCB      "ize.h",0
0002d7  6800    
0002d9  00                DCB      0
0002da  00                DCB      0
0002db  00                DCB      0
                  |L1.732|
0002dc  556e7265          DCB      "Unreasonable deserialized values",0
0002e0  61736f6e
0002e4  61626c65
0002e8  20646573
0002ec  65726961
0002f0  6c697a65
0002f4  64207661
0002f8  6c756573
0002fc  00      
0002fd  00                DCB      0
0002fe  00                DCB      0
0002ff  00                DCB      0
                  |L1.768|
000300  53657269          DCB      "SerializedBuffer::DeserializeRawBasicType",0
000304  616c697a
000308  65644275
00030c  66666572
000310  3a3a4465
000314  73657269
000318  616c697a
00031c  65526177
000320  42617369
000324  63547970
000328  6500    
00032a  00                DCB      0
00032b  00                DCB      0
                  |L1.812|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()
                  |L1.816|
                          DCD      _ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeINS0_13QuadrilateralIfEEEET_PcPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<Anki::Embedded::Quadrilateral<float>>(char*, void**, int&)::__PRETTY_FUNCTION__
                  |L1.820|
                          DCD      _ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeINS0_5PointIfEEEET_PcPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<Anki::Embedded::Point<float>>(char*, void**, int&)::__PRETTY_FUNCTION__
                  |L1.824|
000338  00000000          DCFS     0x00000000 ; 0
                  |L1.828|
                          DCD      ||.constdata||+0x5e5
                  |L1.832|
000340  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\transformations.cpp",0
000344  6f726574
000348  6563685c
00034c  76697369
000350  6f6e5c72
000354  6f626f74
000358  5c737263
00035c  5c747261
000360  6e73666f
000364  726d6174
000368  696f6e73
00036c  2e637070
000370  00      
000371  00                DCB      0
000372  00                DCB      0
000373  00                DCB      0
                  |L1.884|
000374  50617273          DCB      "Parsing error",0
000378  696e6720
00037c  6572726f
000380  7200    
000382  00                DCB      0
000383  00                DCB      0
                  |L1.900|
000384  506c616e          DCB      "PlanarTransformation_f32::Deserialize",0
000388  61725472
00038c  616e7366
000390  6f726d61
000394  74696f6e
000398  5f663332
00039c  3a3a4465
0003a0  73657269
0003a4  616c697a
0003a8  6500    
0003aa  00                DCB      0
0003ab  00                DCB      0

                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3214set_homographyERKNS0_5ArrayIfEE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3214set_homographyERKNS0_5ArrayIfEE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_homography(const Anki::Embedded::Array<float>&)
;;;456    
;;;457          Result PlanarTransformation_f32::set_homography(const Array<f32>& in)
000000  b510              PUSH     {r4,lr}
;;;458          {
;;;459            if(this->homography.Set(in) != 9)
000002  1d00              ADDS     r0,r0,#4
000004  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE3SetERKS2_ ; Anki::Embedded::Array<float>::Set(const Anki::Embedded::Array<float>&)
000008  2809              CMP      r0,#9
;;;460              return RESULT_FAIL_INVALID_SIZE;
00000a  bf14              ITE      NE
00000c  f04f60a0          MOVNE    r0,#0x5000000
;;;461    
;;;462            //AnkiAssert(FLT_NEAR(in[2][2], 1.0f));
;;;463    
;;;464            return RESULT_OK;
000010  2000              MOVEQ    r0,#0
;;;465          }
000012  bd10              POP      {r4,pc}
;;;466    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3216set_centerOffsetERKNS0_5PointIfEE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3216set_centerOffsetERKNS0_5PointIfEE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_centerOffset(const Anki::Embedded::Point<float>&)
;;;494    
;;;495          Result PlanarTransformation_f32::set_centerOffset(const Point<f32> &centerOffset)
000000  ed910a00          VLDR     s0,[r1,#0]
000004  ed800a0f          VSTR     s0,[r0,#0x3c]
000008  ed910a01          VLDR     s0,[r1,#4]
00000c  ed800a10          VSTR     s0,[r0,#0x40]
;;;496          {
;;;497            this->centerOffset = centerOffset;
;;;498    
;;;499            return RESULT_OK;
000010  2000              MOVS     r0,#0
;;;500          }
000012  4770              BX       lr
;;;501    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3217set_transformTypeENS1_13TransformTypeE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3217set_transformTypeENS1_13TransformTypeE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_transformType(Anki::Embedded::Transformations::TransformType)
;;;439    
;;;440          Result PlanarTransformation_f32::set_transformType(const TransformType transformType)
000000  f5b17f00          CMP      r1,#0x200
;;;441          {
;;;442            if(transformType == TRANSFORM_TRANSLATION || transformType == TRANSFORM_AFFINE || transformType == TRANSFORM_PROJECTIVE) {
000004  bf19              ITTEE    NE
000006  f5b16fc0          CMPNE    r1,#0x600
00000a  f5b16f00          CMPNE    r1,#0x800
;;;443              this->transformType = transformType;
00000e  8041              STRHEQ   r1,[r0,#2]
;;;444            } else {
;;;445              AnkiError("PlanarTransformation_f32::set_transformType", "Unknown transformation type %d", transformType);
;;;446              return RESULT_FAIL_INVALID_PARAMETER;
;;;447            }
;;;448    
;;;449            return RESULT_OK;
000010  2000              MOVEQ    r0,#0
;;;450          }
000012  bf08              IT       EQ
000014  4770              BXEQ     lr
000016  b500              PUSH     {lr}                  ;441
000018  b083              SUB      sp,sp,#0xc            ;441
00001a  4a09              LDR      r2,|L4.64|
00001c  f24010bd          MOV      r0,#0x1bd             ;445
000020  e9cd2000          STRD     r2,r0,[sp,#0]         ;445
000024  f2026355          ADD      r3,r2,#0x655          ;445
000028  9102              STR      r1,[sp,#8]            ;445
00002a  f2026235          ADD      r2,r2,#0x635          ;445
00002e  f1a2012c          SUB      r1,r2,#0x2c           ;445
000032  2005              MOVS     r0,#5                 ;445
000034  f7fffffe          BL       _Anki_Log
000038  b003              ADD      sp,sp,#0xc
00003a  f04f7040          MOV      r0,#0x3000000         ;446
00003e  bd00              POP      {pc}
;;;451    
                          ENDP

                  |L4.64|
                          DCD      ||.constdata||+0x677

                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3218set_initialCornersERKNS0_13QuadrilateralIfEE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3218set_initialCornersERKNS0_13QuadrilateralIfEE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_initialCorners(const Anki::Embedded::Quadrilateral<float>&)
;;;471    
;;;472          Result PlanarTransformation_f32::set_initialCorners(const Quadrilateral<f32> &initialCorners)
000000  f1000c18          ADD      r12,r0,#0x18
;;;473          {
;;;474            this->initialCorners = initialCorners;
000004  2000              MOVS     r0,#0
                  |L5.6|
000006  eb0103c0          ADD      r3,r1,r0,LSL #3
00000a  eb0c02c0          ADD      r2,r12,r0,LSL #3
00000e  ed930a00          VLDR     s0,[r3,#0]
000012  1c40              ADDS     r0,r0,#1
000014  ed820a00          VSTR     s0,[r2,#0]
000018  ed930a01          VLDR     s0,[r3,#4]
00001c  2804              CMP      r0,#4
00001e  ed820a01          VSTR     s0,[r2,#4]
000022  dbf0              BLT      |L5.6|
;;;475    
;;;476            return RESULT_OK;
000024  2000              MOVS     r0,#0
;;;477          }
000026  4770              BX       lr
;;;478    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221TransformPointsStaticERKNS0_5ArrayIfEES6_fRKNS0_5PointIfEENS1_13TransformTypeES6_bbRS4_SC_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221TransformPointsStaticERKNS0_5ArrayIfEES6_fRKNS0_5PointIfEENS1_13TransformTypeES6_bbRS4_SC_ PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::TransformPointsStatic(const Anki::Embedded::Array<float>&, const Anki::Embedded::Array<float>&, float, const Anki::Embedded::Point<float>&, Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Array<float>&, bool, bool, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
;;;534    
;;;535          Result PlanarTransformation_f32::TransformPointsStatic(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;536            const Array<f32> &xIn, const Array<f32> &yIn,
;;;537            const f32 scale,
;;;538            const Point<f32>& centerOffset,
;;;539            const TransformType transformType,
;;;540            const Array<f32> &homography,
;;;541            const bool inputPointsAreZeroCentered,
;;;542            const bool outputPointsAreZeroCentered,
;;;543            Array<f32> &xOut, Array<f32> &yOut)
;;;544          {
000004  4607              MOV      r7,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  b08b              SUB      sp,sp,#0x2c
00000c  469a              MOV      r10,r3
00000e  e9dd5419          LDRD     r5,r4,[sp,#0x64]
;;;545            AnkiConditionalErrorAndReturnValue(AreValid(homography, xIn, yIn, xOut, yOut),
000012  f8dd8058          LDR      r8,[sp,#0x58]
000016  4691              MOV      r9,r2                 ;544
000018  eeb08a40          VMOV.F32 s16,s0                ;544
00001c  460e              MOV      r6,r1                 ;544
00001e  4640              MOV      r0,r8
000020  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000024  2800              CMP      r0,#0
000026  d07d              BEQ      |L6.292|
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00002e  2800              CMP      r0,#0
000030  d078              BEQ      |L6.292|
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000038  2800              CMP      r0,#0
00003a  d073              BEQ      |L6.292|
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000042  2800              CMP      r0,#0
000044  d06e              BEQ      |L6.292|
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00004c  2800              CMP      r0,#0
00004e  d069              BEQ      |L6.292|
000050  4638              MOV      r0,r7
000052  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000056  2800              CMP      r0,#0
;;;546              RESULT_FAIL_INVALID_OBJECT, "PlanarTransformation_f32::TransformPoints", "Invalid objects");
;;;547    
;;;548            AnkiConditionalErrorAndReturnValue(NotAliased(xIn, xOut, yIn, yOut),
000058  f00080ae          BEQ.W    |L6.440|
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000062  2800              CMP      r0,#0
000064  f00080a8          BEQ.W    |L6.440|
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00006e  2800              CMP      r0,#0
000070  d07d              BEQ      |L6.366|
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000078  2800              CMP      r0,#0
00007a  d078              BEQ      |L6.366|
00007c  6938              LDR      r0,[r7,#0x10]
00007e  9006              STR      r0,[sp,#0x18]
000080  6928              LDR      r0,[r5,#0x10]
000082  9007              STR      r0,[sp,#0x1c]
000084  6930              LDR      r0,[r6,#0x10]
000086  9008              STR      r0,[sp,#0x20]
000088  6920              LDR      r0,[r4,#0x10]
00008a  2100              MOVS     r1,#0
00008c  aa06              ADD      r2,sp,#0x18
00008e  9009              STR      r0,[sp,#0x24]
                  |L6.144|
000090  1c48              ADDS     r0,r1,#1
000092  2804              CMP      r0,#4
000094  bfb8              IT       LT
000096  f8523021          LDRLT    r3,[r2,r1,LSL #2]
00009a  da06              BGE      |L6.170|
                  |L6.156|
00009c  f852c020          LDR      r12,[r2,r0,LSL #2]
0000a0  4563              CMP      r3,r12
0000a2  d064              BEQ      |L6.366|
0000a4  1c40              ADDS     r0,r0,#1
0000a6  2804              CMP      r0,#4
0000a8  dbf8              BLT      |L6.156|
                  |L6.170|
0000aa  1c49              ADDS     r1,r1,#1
0000ac  2904              CMP      r1,#4
0000ae  dbef              BLT      |L6.144|
0000b0  4638              MOV      r0,r7
0000b2  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
0000b6  2800              CMP      r0,#0
;;;549              RESULT_FAIL_ALIASED_MEMORY, "PlanarTransformation_f32::TransformPoints", "In and Out arrays must be in different memory locations");
;;;550    
;;;551            AnkiConditionalErrorAndReturnValue(AreEqualSize(xIn, yIn, xOut, yOut),
0000b8  f000808b          BEQ.W    |L6.466|
0000bc  4630              MOV      r0,r6
0000be  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
0000c2  2800              CMP      r0,#0
0000c4  f0008085          BEQ.W    |L6.466|
0000c8  4628              MOV      r0,r5
0000ca  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
0000ce  2800              CMP      r0,#0
0000d0  f000807f          BEQ.W    |L6.466|
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
0000da  2800              CMP      r0,#0
0000dc  f0008079          BEQ.W    |L6.466|
0000e0  2100              MOVS     r1,#0
0000e2  4638              MOV      r0,r7
0000e4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000e8  4683              MOV      r11,r0
0000ea  2100              MOVS     r1,#0
0000ec  4630              MOV      r0,r6
0000ee  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000f2  4583              CMP      r11,r0
0000f4  d16d              BNE      |L6.466|
0000f6  2101              MOVS     r1,#1
0000f8  4638              MOV      r0,r7
0000fa  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000fe  4683              MOV      r11,r0
000100  2101              MOVS     r1,#1
000102  4630              MOV      r0,r6
000104  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000108  4583              CMP      r11,r0
00010a  d162              BNE      |L6.466|
00010c  2100              MOVS     r1,#0
00010e  4638              MOV      r0,r7
000110  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000114  4683              MOV      r11,r0
000116  2100              MOVS     r1,#0
000118  4628              MOV      r0,r5
00011a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00011e  4583              CMP      r11,r0
000120  d157              BNE      |L6.466|
000122  e000              B        |L6.294|
                  |L6.292|
000124  e036              B        |L6.404|
                  |L6.294|
000126  2101              MOVS     r1,#1
000128  4638              MOV      r0,r7
00012a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00012e  4683              MOV      r11,r0
000130  2101              MOVS     r1,#1
000132  4628              MOV      r0,r5
000134  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000138  4583              CMP      r11,r0
00013a  d14a              BNE      |L6.466|
00013c  2100              MOVS     r1,#0
00013e  4638              MOV      r0,r7
000140  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000144  4683              MOV      r11,r0
000146  2100              MOVS     r1,#0
000148  4620              MOV      r0,r4
00014a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00014e  4583              CMP      r11,r0
000150  d13f              BNE      |L6.466|
000152  2101              MOVS     r1,#1
000154  4638              MOV      r0,r7
000156  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00015a  4683              MOV      r11,r0
00015c  2101              MOVS     r1,#1
00015e  4620              MOV      r0,r4
000160  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000164  4583              CMP      r11,r0
000166  d134              BNE      |L6.466|
;;;552              RESULT_FAIL_INVALID_SIZE, "PlanarTransformation_f32::TransformPoints", "All inputs and outputs must be the same size");
;;;553    
;;;554            const s32 numPointsY = xIn.get_size(0);
000168  2100              MOVS     r1,#0
00016a  4638              MOV      r0,r7
00016c  e000              B        |L6.368|
                  |L6.366|
00016e  e023              B        |L6.440|
                  |L6.368|
000170  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000174  4683              MOV      r11,r0
;;;555            const s32 numPointsX = xIn.get_size(1);
000176  2101              MOVS     r1,#1
000178  4638              MOV      r0,r7
00017a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00017e  ed9f0ae6          VLDR     s0,|L6.1304|
000182  9917              LDR      r1,[sp,#0x5c]
000184  2900              CMP      r1,#0
000186  bf1c              ITT      NE
000188  ed8d0a02          VSTRNE   s0,[sp,#8]
00018c  ed8d0a03          VSTRNE   s0,[sp,#0xc]
000190  d135              BNE      |L6.510|
000192  e02c              B        |L6.494|
                  |L6.404|
000194  f2402121          MOV      r1,#0x221             ;545
000198  48e0              LDR      r0,|L6.1308|
00019a  e9cd0100          STRD     r0,r1,[sp,#0]         ;545
00019e  a3e0              ADR      r3,|L6.1312|
0001a0  a2ec              ADR      r2,|L6.1364|
0001a2  a1f0              ADR      r1,|L6.1380|
0001a4  2005              MOVS     r0,#5                 ;545
0001a6  f7fffffe          BL       _Anki_Log
0001aa  f04f6080          MOV      r0,#0x4000000         ;545
                  |L6.430|
;;;556    
;;;557            // If the inputs or outputs should be shifted, set the offset appropriately
;;;558            const Point<f32> inputCenterOffset = inputPointsAreZeroCentered ? Point<f32>(0.0f, 0.0f) : Point<f32>(centerOffset.x, centerOffset.y);
;;;559            const Point<f32> outputCenterOffset = outputPointsAreZeroCentered ? Point<f32>(0.0f, 0.0f) : Point<f32>(centerOffset.x, centerOffset.y);
;;;560    
;;;561            if(transformType == TRANSFORM_TRANSLATION) {
;;;562              const f32 dx = (homography[0][2] - inputCenterOffset.x + outputCenterOffset.x) / scale;
;;;563              const f32 dy = (homography[1][2] - inputCenterOffset.y + outputCenterOffset.y) / scale;
;;;564    
;;;565              for(s32 y=0; y<numPointsY; y++) {
;;;566                const f32 * restrict pXIn = xIn.Pointer(y,0);
;;;567                const f32 * restrict pYIn = yIn.Pointer(y,0);
;;;568                f32 * restrict pXOut = xOut.Pointer(y,0);
;;;569                f32 * restrict pYOut = yOut.Pointer(y,0);
;;;570    
;;;571                for(s32 x=0; x<numPointsX; x++) {
;;;572                  pXOut[x] = pXIn[x] + dx;
;;;573                  pYOut[x] = pYIn[x] + dy;
;;;574                }
;;;575              }
;;;576            } else if(transformType == TRANSFORM_AFFINE) {
;;;577              const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2];
;;;578              const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2];
;;;579    
;;;580              AnkiAssert(FLT_NEAR(homography[2][0], 0.0f));
;;;581              AnkiAssert(FLT_NEAR(homography[2][1], 0.0f));
;;;582              AnkiAssert(FLT_NEAR(homography[2][2], 1.0f));
;;;583    
;;;584              for(s32 y=0; y<numPointsY; y++) {
;;;585                const f32 * restrict pXIn = xIn.Pointer(y,0);
;;;586                const f32 * restrict pYIn = yIn.Pointer(y,0);
;;;587                f32 * restrict pXOut = xOut.Pointer(y,0);
;;;588                f32 * restrict pYOut = yOut.Pointer(y,0);
;;;589    
;;;590                if(FLT_NEAR(scale, 1.0f)) {
;;;591                  for(s32 x=0; x<numPointsX; x++) {
;;;592                    const f32 xIn = pXIn[x];
;;;593                    const f32 yIn = pYIn[x];
;;;594    
;;;595                    // Remove center offset (offset may be zero)
;;;596                    const f32 xc = xIn - inputCenterOffset.x;
;;;597                    const f32 yc = yIn - inputCenterOffset.y;
;;;598    
;;;599                    const f32 xp = (h00*xc + h01*yc + h02);
;;;600                    const f32 yp = (h10*xc + h11*yc + h12);
;;;601    
;;;602                    // Restore center offset (offset may be zero)
;;;603                    pXOut[x] = xp + outputCenterOffset.x;
;;;604                    pYOut[x] = yp + outputCenterOffset.y;
;;;605                  }
;;;606                } else {
;;;607                  for(s32 x=0; x<numPointsX; x++) {
;;;608                    const f32 xIn = pXIn[x] * scale;
;;;609                    const f32 yIn = pYIn[x] * scale;
;;;610    
;;;611                    // Remove center offset (offset may be zero)
;;;612                    const f32 xc = xIn - inputCenterOffset.x;
;;;613                    const f32 yc = yIn - inputCenterOffset.y;
;;;614    
;;;615                    const f32 xp = (h00*xc + h01*yc + h02);
;;;616                    const f32 yp = (h10*xc + h11*yc + h12);
;;;617    
;;;618                    // Restore center offset (offset may be zero)
;;;619                    pXOut[x] = (xp + outputCenterOffset.x) / scale;
;;;620                    pYOut[x] = (yp + outputCenterOffset.y) / scale;
;;;621                  }
;;;622                } // if(FLT_NEAR(scale, 1.0f))
;;;623              }
;;;624            } else if(transformType == TRANSFORM_PROJECTIVE) {
;;;625              const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2];
;;;626              const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2];
;;;627              const f32 h20 = homography[2][0]; const f32 h21 = homography[2][1]; const f32 h22 = homography[2][2];
;;;628    
;;;629              //AnkiAssert(FLT_NEAR(homography[2][2], 1.0f));
;;;630    
;;;631              for(s32 y=0; y<numPointsY; y++) {
;;;632                const f32 * restrict pXIn = xIn.Pointer(y,0);
;;;633                const f32 * restrict pYIn = yIn.Pointer(y,0);
;;;634                f32 * restrict pXOut = xOut.Pointer(y,0);
;;;635                f32 * restrict pYOut = yOut.Pointer(y,0);
;;;636    
;;;637                if(FLT_NEAR(scale, 1.0f)) {
;;;638                  for(s32 x=0; x<numPointsX; x++) {
;;;639                    const f32 xIn = pXIn[x];
;;;640                    const f32 yIn = pYIn[x];
;;;641    
;;;642                    // Remove center offset (offset may be zero)
;;;643                    const f32 xc = xIn - inputCenterOffset.x;
;;;644                    const f32 yc = yIn - inputCenterOffset.y;
;;;645    
;;;646                    const f32 wpi = 1.0f / (h20*xc + h21*yc + h22);
;;;647    
;;;648                    const f32 xp = (h00*xc + h01*yc + h02) * wpi;
;;;649                    const f32 yp = (h10*xc + h11*yc + h12) * wpi;
;;;650    
;;;651                    // Restore center offset (offset may be zero)
;;;652                    pXOut[x] = xp + outputCenterOffset.x;
;;;653                    pYOut[x] = yp + outputCenterOffset.y;
;;;654                  }
;;;655                } else {
;;;656                  for(s32 x=0; x<numPointsX; x++) {
;;;657                    const f32 xIn = pXIn[x] * scale;
;;;658                    const f32 yIn = pYIn[x] * scale;
;;;659    
;;;660                    // Remove center offset (offset may be zero)
;;;661                    const f32 xc = xIn - inputCenterOffset.x;
;;;662                    const f32 yc = yIn - inputCenterOffset.y;
;;;663    
;;;664                    const f32 wpi = 1.0f / (h20*xc + h21*yc + h22);
;;;665    
;;;666                    const f32 xp = (h00*xc + h01*yc + h02) * wpi;
;;;667                    const f32 yp = (h10*xc + h11*yc + h12) * wpi;
;;;668    
;;;669                    // Restore center offset (offset may be zero)
;;;670                    pXOut[x] = (xp + outputCenterOffset.x) / scale;
;;;671                    pYOut[x] = (yp + outputCenterOffset.y) / scale;
;;;672                  }
;;;673                } // if(FLT_NEAR(scale, 1.0f))
;;;674              }
;;;675            } else {
;;;676              // Should be checked earlier
;;;677              AnkiAssert(false);
;;;678              return RESULT_FAIL;
;;;679            }
;;;680    
;;;681            return RESULT_OK;
;;;682          }
0001ae  b00b              ADD      sp,sp,#0x2c
0001b0  ecbd8b02          VPOP     {d8}
0001b4  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.440|
0001b8  f44f7109          MOV      r1,#0x224             ;548
0001bc  48d7              LDR      r0,|L6.1308|
0001be  e9cd0100          STRD     r0,r1,[sp,#0]         ;548
0001c2  a3d7              ADR      r3,|L6.1312|
0001c4  a2f2              ADR      r2,|L6.1424|
0001c6  a1e7              ADR      r1,|L6.1380|
0001c8  2005              MOVS     r0,#5                 ;548
0001ca  f7fffffe          BL       _Anki_Log
0001ce  48fe              LDR      r0,|L6.1480|
0001d0  e7ed              B        |L6.430|
                  |L6.466|
0001d2  f2402127          MOV      r1,#0x227             ;551
0001d6  48d1              LDR      r0,|L6.1308|
0001d8  e9cd0100          STRD     r0,r1,[sp,#0]         ;551
0001dc  a3d0              ADR      r3,|L6.1312|
0001de  a2fb              ADR      r2,|L6.1484|
0001e0  a1e0              ADR      r1,|L6.1380|
0001e2  2005              MOVS     r0,#5                 ;551
0001e4  f7fffffe          BL       _Anki_Log
0001e8  f04f60a0          MOV      r0,#0x5000000         ;551
0001ec  e7df              B        |L6.430|
                  |L6.494|
0001ee  edd90a00          VLDR     s1,[r9,#0]            ;555
0001f2  ed991a01          VLDR     s2,[r9,#4]            ;555
0001f6  edcd0a02          VSTR     s1,[sp,#8]            ;555
0001fa  ed8d1a03          VSTR     s2,[sp,#0xc]          ;555
                  |L6.510|
0001fe  9918              LDR      r1,[sp,#0x60]         ;555
000200  2900              CMP      r1,#0                 ;555
000202  bf1c              ITT      NE                    ;555
000204  ed8d0a04          VSTRNE   s0,[sp,#0x10]         ;555
000208  ed8d0a05          VSTRNE   s0,[sp,#0x14]         ;555
00020c  d107              BNE      |L6.542|
00020e  ed990a00          VLDR     s0,[r9,#0]            ;555
000212  edd90a01          VLDR     s1,[r9,#4]            ;555
000216  ed8d0a04          VSTR     s0,[sp,#0x10]         ;555
00021a  edcd0a05          VSTR     s1,[sp,#0x14]         ;555
                  |L6.542|
00021e  f5ba7f00          CMP      r10,#0x200            ;561
000222  d07d              BEQ      |L6.800|
000224  4bf5              LDR      r3,|L6.1532|
000226  f5ba6fc0          CMP      r10,#0x600            ;576
00022a  d07a              BEQ      |L6.802|
00022c  f5ba6f00          CMP      r10,#0x800            ;624
000230  bf18              IT       NE                    ;678
000232  2001              MOVNE    r0,#1                 ;678
000234  d1bb              BNE      |L6.430|
000236  f8d8c010          LDR      r12,[r8,#0x10]        ;624
00023a  f8d82008          LDR      r2,[r8,#8]            ;624
00023e  2100              MOVS     r1,#0                 ;625
000240  fb01c102          MLA      r1,r1,r2,r12          ;625
000244  edd15a00          VLDR     s11,[r1,#0]           ;625
000248  ed915a01          VLDR     s10,[r1,#4]           ;625
00024c  edd14a02          VLDR     s9,[r1,#8]            ;625
000250  2101              MOVS     r1,#1                 ;626
000252  fb01c102          MLA      r1,r1,r2,r12          ;626
000256  ed914a00          VLDR     s8,[r1,#0]            ;626
00025a  edd13a01          VLDR     s7,[r1,#4]            ;626
00025e  ed913a02          VLDR     s6,[r1,#8]            ;626
000262  2102              MOVS     r1,#2                 ;627
000264  fb01c102          MLA      r1,r1,r2,r12          ;627
000268  2200              MOVS     r2,#0                 ;631
00026a  edd12a00          VLDR     s5,[r1,#0]            ;627
00026e  ed912a01          VLDR     s4,[r1,#4]            ;627
000272  edd11a02          VLDR     s3,[r1,#8]            ;627
000276  f1bb0f00          CMP      r11,#0                ;631
00027a  bfc8              IT       GT                    ;646
00027c  eddf6ae0          VLDRGT   s13,|L6.1536|
000280  f3408220          BLE.W    |L6.1732|
                  |L6.644|
000284  f8d7c008          LDR      r12,[r7,#8]           ;631
000288  6939              LDR      r1,[r7,#0x10]         ;631
00028a  fb021a0c          MLA      r10,r2,r12,r1         ;631
00028e  f8d6c008          LDR      r12,[r6,#8]           ;631
000292  6931              LDR      r1,[r6,#0x10]         ;631
000294  fb02190c          MLA      r9,r2,r12,r1          ;631
000298  f8d5c008          LDR      r12,[r5,#8]           ;631
00029c  6929              LDR      r1,[r5,#0x10]         ;631
00029e  fb02180c          MLA      r8,r2,r12,r1          ;631
0002a2  f8d4c008          LDR      r12,[r4,#8]           ;631
0002a6  6921              LDR      r1,[r4,#0x10]         ;631
0002a8  fb021c0c          MLA      r12,r2,r12,r1         ;631
0002ac  ee181a10          VMOV     r1,s16                ;637
0002b0  4419              ADD      r1,r1,r3              ;637
0002b2  29fb              CMP      r1,#0xfb              ;637
0002b4  f04f0100          MOV      r1,#0                 ;656
0002b8  f08081bb          BCS.W    |L6.1586|
0002bc  2800              CMP      r0,#0                 ;638
0002be  f34081fd          BLE.W    |L6.1724|
                  |L6.706|
0002c2  eb0a0e81          ADD      lr,r10,r1,LSL #2      ;639
0002c6  ed9d1a02          VLDR     s2,[sp,#8]            ;643
0002ca  edde0a00          VLDR     s1,[lr,#0]            ;639
0002ce  eb090e81          ADD      lr,r9,r1,LSL #2       ;640
0002d2  ee700ac1          VSUB.F32 s1,s1,s2              ;643
0002d6  ed9e0a00          VLDR     s0,[lr,#0]            ;640
0002da  ed9d1a03          VLDR     s2,[sp,#0xc]          ;644
0002de  eb080e81          ADD      lr,r8,r1,LSL #2       ;652
0002e2  ee300a41          VSUB.F32 s0,s0,s2              ;644
0002e6  ee221aa0          VMUL.F32 s2,s5,s1              ;646
0002ea  ee021a00          VMLA.F32 s2,s4,s0              ;646
0002ee  ee316a21          VADD.F32 s12,s2,s3             ;646
0002f2  ee861a86          VDIV.F32 s2,s13,s12            ;646
0002f6  ee256aa0          VMUL.F32 s12,s11,s1            ;648
0002fa  ee640a20          VMUL.F32 s1,s8,s1              ;649
0002fe  ee056a00          VMLA.F32 s12,s10,s0            ;648
000302  ee430a80          VMLA.F32 s1,s7,s0              ;649
000306  ee366a24          VADD.F32 s12,s12,s9            ;648
00030a  ee300a83          VADD.F32 s0,s1,s6              ;649
00030e  eddd0a04          VLDR     s1,[sp,#0x10]         ;652
000312  ee266a01          VMUL.F32 s12,s12,s2            ;648
000316  ee200a01          VMUL.F32 s0,s0,s2              ;649
00031a  ee700a86          VADD.F32 s1,s1,s12             ;652
00031e  e001              B        |L6.804|
                  |L6.800|
000320  e00f              B        |L6.834|
                  |L6.802|
000322  e065              B        |L6.1008|
                  |L6.804|
000324  edce0a00          VSTR     s1,[lr,#0]            ;652
000328  eddd0a05          VLDR     s1,[sp,#0x14]         ;653
00032c  eb0c0e81          ADD      lr,r12,r1,LSL #2      ;653
000330  1c49              ADDS     r1,r1,#1              ;638
000332  ee300a80          VADD.F32 s0,s1,s0              ;653
000336  4288              CMP      r0,r1                 ;638
000338  ed8e0a00          VSTR     s0,[lr,#0]            ;653
00033c  dcc1              BGT      |L6.706|
00033e  f000b9bd          B.W      |L6.1724|
                  |L6.834|
000342  f8d82008          LDR      r2,[r8,#8]            ;638
000346  f8d81010          LDR      r1,[r8,#0x10]         ;638
00034a  2300              MOVS     r3,#0                 ;562
00034c  fb031302          MLA      r3,r3,r2,r1           ;562
000350  eddd0a02          VLDR     s1,[sp,#8]            ;562
000354  ed930a02          VLDR     s0,[r3,#8]            ;562
000358  2301              MOVS     r3,#1                 ;563
00035a  fb031102          MLA      r1,r3,r2,r1           ;563
00035e  ee300a60          VSUB.F32 s0,s0,s1              ;562
000362  eddd0a04          VLDR     s1,[sp,#0x10]         ;562
000366  ed9d1a03          VLDR     s2,[sp,#0xc]          ;563
00036a  2200              MOVS     r2,#0                 ;565
00036c  ee300a20          VADD.F32 s0,s0,s1              ;562
000370  f1bb0f00          CMP      r11,#0                ;565
000374  eec00a08          VDIV.F32 s1,s0,s16             ;562
000378  ed910a02          VLDR     s0,[r1,#8]            ;563
00037c  ee300a41          VSUB.F32 s0,s0,s2              ;563
000380  ed9d1a05          VLDR     s2,[sp,#0x14]         ;563
000384  ee301a01          VADD.F32 s2,s0,s2              ;563
000388  ee810a08          VDIV.F32 s0,s2,s16             ;563
00038c  dd7e              BLE      |L6.1164|
                  |L6.910|
00038e  68bb              LDR      r3,[r7,#8]            ;565
000390  6939              LDR      r1,[r7,#0x10]         ;565
000392  f8d6c008          LDR      r12,[r6,#8]           ;565
000396  fb021303          MLA      r3,r2,r3,r1           ;565
00039a  6931              LDR      r1,[r6,#0x10]         ;565
00039c  f8d48008          LDR      r8,[r4,#8]            ;565
0003a0  fb02190c          MLA      r9,r2,r12,r1          ;565
0003a4  f8d5c008          LDR      r12,[r5,#8]           ;565
0003a8  6929              LDR      r1,[r5,#0x10]         ;565
0003aa  fb021c0c          MLA      r12,r2,r12,r1         ;565
0003ae  6921              LDR      r1,[r4,#0x10]         ;565
0003b0  fb021808          MLA      r8,r2,r8,r1           ;565
0003b4  2100              MOVS     r1,#0                 ;571
0003b6  2800              CMP      r0,#0                 ;571
0003b8  dd16              BLE      |L6.1000|
                  |L6.954|
0003ba  eb030a81          ADD      r10,r3,r1,LSL #2      ;572
0003be  ed9a1a00          VLDR     s2,[r10,#0]           ;572
0003c2  eb0c0a81          ADD      r10,r12,r1,LSL #2     ;572
0003c6  ee311a20          VADD.F32 s2,s2,s1              ;572
0003ca  ed8a1a00          VSTR     s2,[r10,#0]           ;572
0003ce  eb090a81          ADD      r10,r9,r1,LSL #2      ;573
0003d2  ed9a1a00          VLDR     s2,[r10,#0]           ;573
0003d6  eb080a81          ADD      r10,r8,r1,LSL #2      ;573
0003da  1c49              ADDS     r1,r1,#1              ;571
0003dc  ee311a00          VADD.F32 s2,s2,s0              ;573
0003e0  4288              CMP      r0,r1                 ;571
0003e2  ed8a1a00          VSTR     s2,[r10,#0]           ;573
0003e6  dce8              BGT      |L6.954|
                  |L6.1000|
0003e8  1c52              ADDS     r2,r2,#1              ;565
0003ea  455a              CMP      r2,r11                ;565
0003ec  dbcf              BLT      |L6.910|
0003ee  e169              B        |L6.1732|
                  |L6.1008|
0003f0  f8d8c008          LDR      r12,[r8,#8]           ;565
0003f4  f8d82010          LDR      r2,[r8,#0x10]         ;565
0003f8  2100              MOVS     r1,#0                 ;577
0003fa  fb01210c          MLA      r1,r1,r12,r2          ;577
0003fe  edd13a00          VLDR     s7,[r1,#0]            ;577
000402  ed913a01          VLDR     s6,[r1,#4]            ;577
000406  edd12a02          VLDR     s5,[r1,#8]            ;577
00040a  2101              MOVS     r1,#1                 ;578
00040c  fb01210c          MLA      r1,r1,r12,r2          ;578
000410  2200              MOVS     r2,#0                 ;584
000412  ed912a00          VLDR     s4,[r1,#0]            ;578
000416  edd11a01          VLDR     s3,[r1,#4]            ;578
00041a  ed911a02          VLDR     s2,[r1,#8]            ;578
00041e  f1bb0f00          CMP      r11,#0                ;584
000422  dd33              BLE      |L6.1164|
                  |L6.1060|
000424  f8d7c008          LDR      r12,[r7,#8]           ;584
000428  6939              LDR      r1,[r7,#0x10]         ;584
00042a  fb021a0c          MLA      r10,r2,r12,r1         ;584
00042e  f8d6c008          LDR      r12,[r6,#8]           ;584
000432  6931              LDR      r1,[r6,#0x10]         ;584
000434  fb02190c          MLA      r9,r2,r12,r1          ;584
000438  f8d5c008          LDR      r12,[r5,#8]           ;584
00043c  6929              LDR      r1,[r5,#0x10]         ;584
00043e  fb02180c          MLA      r8,r2,r12,r1          ;584
000442  f8d4c008          LDR      r12,[r4,#8]           ;584
000446  6921              LDR      r1,[r4,#0x10]         ;584
000448  fb021c0c          MLA      r12,r2,r12,r1         ;584
00044c  ee181a10          VMOV     r1,s16                ;590
000450  4419              ADD      r1,r1,r3              ;590
000452  29fb              CMP      r1,#0xfb              ;590
000454  f04f0100          MOV      r1,#0                 ;607
000458  d233              BCS      |L6.1218|
00045a  2800              CMP      r0,#0                 ;591
00045c  dd5a              BLE      |L6.1300|
                  |L6.1118|
00045e  eb0a0e81          ADD      lr,r10,r1,LSL #2      ;592
000462  ed9d4a02          VLDR     s8,[sp,#8]            ;596
000466  edde0a00          VLDR     s1,[lr,#0]            ;592
00046a  eb090e81          ADD      lr,r9,r1,LSL #2       ;593
00046e  ee700ac4          VSUB.F32 s1,s1,s8              ;596
000472  ed9e0a00          VLDR     s0,[lr,#0]            ;593
000476  ed9d4a03          VLDR     s8,[sp,#0xc]          ;597
00047a  ee300a44          VSUB.F32 s0,s0,s8              ;597
00047e  ee234aa0          VMUL.F32 s8,s7,s1              ;599
000482  ee034a00          VMLA.F32 s8,s6,s0              ;599
000486  ee344a22          VADD.F32 s8,s8,s5              ;599
00048a  e000              B        |L6.1166|
                  |L6.1164|
00048c  e11a              B        |L6.1732|
                  |L6.1166|
00048e  ee620a20          VMUL.F32 s1,s4,s1              ;600
000492  eb080e81          ADD      lr,r8,r1,LSL #2       ;603
000496  ee410a80          VMLA.F32 s1,s3,s0              ;600
00049a  ee300a81          VADD.F32 s0,s1,s2              ;600
00049e  eddd0a04          VLDR     s1,[sp,#0x10]         ;603
0004a2  ee700a84          VADD.F32 s1,s1,s8              ;603
0004a6  edce0a00          VSTR     s1,[lr,#0]            ;603
0004aa  eddd0a05          VLDR     s1,[sp,#0x14]         ;604
0004ae  eb0c0e81          ADD      lr,r12,r1,LSL #2      ;604
0004b2  1c49              ADDS     r1,r1,#1              ;591
0004b4  ee300a80          VADD.F32 s0,s1,s0              ;604
0004b8  4288              CMP      r0,r1                 ;591
0004ba  ed8e0a00          VSTR     s0,[lr,#0]            ;604
0004be  dcce              BGT      |L6.1118|
0004c0  e0b2              B        |L6.1576|
                  |L6.1218|
0004c2  2800              CMP      r0,#0                 ;607
0004c4  dd26              BLE      |L6.1300|
                  |L6.1222|
0004c6  eb0a0e81          ADD      lr,r10,r1,LSL #2      ;608
0004ca  ed9d4a02          VLDR     s8,[sp,#8]            ;612
0004ce  ed9e0a00          VLDR     s0,[lr,#0]            ;608
0004d2  eb090e81          ADD      lr,r9,r1,LSL #2       ;609
0004d6  ee600a08          VMUL.F32 s1,s0,s16             ;608
0004da  ed9e0a00          VLDR     s0,[lr,#0]            ;609
0004de  ee200a08          VMUL.F32 s0,s0,s16             ;609
0004e2  ee700ac4          VSUB.F32 s1,s1,s8              ;612
0004e6  ed9d4a03          VLDR     s8,[sp,#0xc]          ;613
0004ea  ee300a44          VSUB.F32 s0,s0,s8              ;613
0004ee  ee234aa0          VMUL.F32 s8,s7,s1              ;615
0004f2  ee620a20          VMUL.F32 s1,s4,s1              ;616
0004f6  ee034a00          VMLA.F32 s8,s6,s0              ;615
0004fa  ee410a80          VMLA.F32 s1,s3,s0              ;616
0004fe  ee344a22          VADD.F32 s8,s8,s5              ;615
000502  ee300a81          VADD.F32 s0,s1,s2              ;616
000506  eddd0a04          VLDR     s1,[sp,#0x10]         ;619
00050a  ee700a84          VADD.F32 s1,s1,s8              ;619
00050e  ee804a88          VDIV.F32 s8,s1,s16             ;619
000512  e077              B        |L6.1540|
                  |L6.1300|
000514  e088              B        |L6.1576|
000516  0000              DCW      0x0000
                  |L6.1304|
000518  00000000          DCFS     0x00000000 ; 0
                  |L6.1308|
                          DCD      ||.constdata||+0x701
                  |L6.1312|
000520  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\transformations.cpp",0
000524  6f726574
000528  6563685c
00052c  76697369
000530  6f6e5c72
000534  6f626f74
000538  5c737263
00053c  5c747261
000540  6e73666f
000544  726d6174
000548  696f6e73
00054c  2e637070
000550  00      
000551  00                DCB      0
000552  00                DCB      0
000553  00                DCB      0
                  |L6.1364|
000554  496e7661          DCB      "Invalid objects",0
000558  6c696420
00055c  6f626a65
000560  63747300
                  |L6.1380|
000564  506c616e          DCB      "PlanarTransformation_f32::TransformPoints",0
000568  61725472
00056c  616e7366
000570  6f726d61
000574  74696f6e
000578  5f663332
00057c  3a3a5472
000580  616e7366
000584  6f726d50
000588  6f696e74
00058c  7300    
00058e  00                DCB      0
00058f  00                DCB      0
                  |L6.1424|
000590  496e2061          DCB      "In and Out arrays must be in different memory locations"
000594  6e64204f
000598  75742061
00059c  72726179
0005a0  73206d75
0005a4  73742062
0005a8  6520696e
0005ac  20646966
0005b0  66657265
0005b4  6e74206d
0005b8  656d6f72
0005bc  79206c6f
0005c0  63617469
0005c4  6f6e73  
0005c7  00                DCB      0
                  |L6.1480|
                          DCD      0x01000003
                  |L6.1484|
0005cc  416c6c20          DCB      "All inputs and outputs must be the same size",0
0005d0  696e7075
0005d4  74732061
0005d8  6e64206f
0005dc  75747075
0005e0  7473206d
0005e4  75737420
0005e8  62652074
0005ec  68652073
0005f0  616d6520
0005f4  73697a65
0005f8  00      
0005f9  00                DCB      0
0005fa  00                DCB      0
0005fb  00                DCB      0
                  |L6.1532|
                          DCD      0xc08000a7
                  |L6.1536|
000600  3f800000          DCFS     0x3f800000 ; 1
                  |L6.1540|
000604  eb080e81          ADD      lr,r8,r1,LSL #2       ;619
000608  ed8e4a00          VSTR     s8,[lr,#0]            ;619
00060c  eddd0a05          VLDR     s1,[sp,#0x14]         ;620
000610  eb0c0e81          ADD      lr,r12,r1,LSL #2      ;620
000614  1c49              ADDS     r1,r1,#1              ;607
000616  ee300a80          VADD.F32 s0,s1,s0              ;620
00061a  4288              CMP      r0,r1                 ;607
00061c  eec00a08          VDIV.F32 s1,s0,s16             ;620
000620  edce0a00          VSTR     s1,[lr,#0]            ;620
000624  f73faf4f          BGT      |L6.1222|
                  |L6.1576|
000628  1c52              ADDS     r2,r2,#1              ;584
00062a  455a              CMP      r2,r11                ;584
00062c  f6ffaefa          BLT      |L6.1060|
000630  e048              B        |L6.1732|
                  |L6.1586|
000632  2800              CMP      r0,#0                 ;656
000634  dd42              BLE      |L6.1724|
                  |L6.1590|
000636  eb0a0e81          ADD      lr,r10,r1,LSL #2      ;657
00063a  ed9d1a02          VLDR     s2,[sp,#8]            ;661
00063e  ed9e0a00          VLDR     s0,[lr,#0]            ;657
000642  eb090e81          ADD      lr,r9,r1,LSL #2       ;658
000646  ee600a08          VMUL.F32 s1,s0,s16             ;657
00064a  ed9e0a00          VLDR     s0,[lr,#0]            ;658
00064e  eb080e81          ADD      lr,r8,r1,LSL #2       ;670
000652  ee200a08          VMUL.F32 s0,s0,s16             ;658
000656  ee700ac1          VSUB.F32 s1,s1,s2              ;661
00065a  ed9d1a03          VLDR     s2,[sp,#0xc]          ;662
00065e  ee300a41          VSUB.F32 s0,s0,s2              ;662
000662  ee221aa0          VMUL.F32 s2,s5,s1              ;664
000666  ee021a00          VMLA.F32 s2,s4,s0              ;664
00066a  ee316a21          VADD.F32 s12,s2,s3             ;664
00066e  ee861a86          VDIV.F32 s2,s13,s12            ;664
000672  ee256aa0          VMUL.F32 s12,s11,s1            ;666
000676  ee640a20          VMUL.F32 s1,s8,s1              ;667
00067a  ee056a00          VMLA.F32 s12,s10,s0            ;666
00067e  ee430a80          VMLA.F32 s1,s7,s0              ;667
000682  ee366a24          VADD.F32 s12,s12,s9            ;666
000686  ee300a83          VADD.F32 s0,s1,s6              ;667
00068a  eddd0a04          VLDR     s1,[sp,#0x10]         ;670
00068e  ee266a01          VMUL.F32 s12,s12,s2            ;666
000692  ee200a01          VMUL.F32 s0,s0,s2              ;667
000696  ee700a86          VADD.F32 s1,s1,s12             ;670
00069a  ee801a88          VDIV.F32 s2,s1,s16             ;670
00069e  ed8e1a00          VSTR     s2,[lr,#0]            ;670
0006a2  eddd0a05          VLDR     s1,[sp,#0x14]         ;671
0006a6  eb0c0e81          ADD      lr,r12,r1,LSL #2      ;671
0006aa  1c49              ADDS     r1,r1,#1              ;656
0006ac  ee300a80          VADD.F32 s0,s1,s0              ;671
0006b0  4288              CMP      r0,r1                 ;656
0006b2  eec00a08          VDIV.F32 s1,s0,s16             ;671
0006b6  edce0a00          VSTR     s1,[lr,#0]            ;671
0006ba  dcbc              BGT      |L6.1590|
                  |L6.1724|
0006bc  1c52              ADDS     r2,r2,#1              ;631
0006be  455a              CMP      r2,r11                ;631
0006c0  f6ffade0          BLT      |L6.644|
                  |L6.1732|
0006c4  2000              MOVS     r0,#0                 ;681
0006c6  e572              B        |L6.430|
;;;683    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221get_serializationSizeEv||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221get_serializationSizeEv PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_serializationSize()
;;;683    
;;;684          s32 PlanarTransformation_f32::get_serializationSize()
000000  f44f6080          MOV      r0,#0x400
;;;685          {
;;;686            // TODO: make the correct length
;;;687            return 512 + 16*SerializedBuffer::DESCRIPTION_STRING_LENGTH;
;;;688          }
000004  4770              BX       lr
;;;689    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3232set_initialPointsAreZeroCenteredEb||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3232set_initialPointsAreZeroCenteredEb PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_initialPointsAreZeroCentered(bool)
;;;483    
;;;484          Result PlanarTransformation_f32::set_initialPointsAreZeroCentered(const bool areTheyCentered)
000000  f8801038          STRB     r1,[r0,#0x38]
;;;485          {
;;;486            this->initialPointsAreZeroCentered = areTheyCentered;
;;;487            return RESULT_OK;
000004  2000              MOVS     r0,#0
;;;488          }
000006  4770              BX       lr
;;;489    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f323SetERKS2_||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f323SetERKS2_ PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::Set(const Anki::Embedded::Transformations::PlanarTransformation_f32&)
;;;358    
;;;359          Result PlanarTransformation_f32::Set(const PlanarTransformation_f32 &newTransformation)
000000  b5f0              PUSH     {r4-r7,lr}
;;;360          {
000002  460e              MOV      r6,r1
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  8847              LDRH     r7,[r0,#2]
00000a  8849              LDRH     r1,[r1,#2]
;;;361            Result lastResult;
;;;362    
;;;363            const TransformType originalType = this->get_transformType();
;;;364    
;;;365            if((lastResult = this->set_transformType(newTransformation.get_transformType())) != RESULT_OK) {
00000c  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3217set_transformTypeENS1_13TransformTypeE ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_transformType(Anki::Embedded::Transformations::TransformType)
000010  0005              MOVS     r5,r0
000012  d109              BNE      |L9.40|
000014  1d31              ADDS     r1,r6,#4
000016  1d20              ADDS     r0,r4,#4
000018  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE3SetERKS2_ ; Anki::Embedded::Array<float>::Set(const Anki::Embedded::Array<float>&)
00001c  2809              CMP      r0,#9
00001e  bf14              ITE      NE
000020  f04f65a0          MOVNE    r5,#0x5000000
000024  2500              MOVEQ    r5,#0
;;;366              this->set_transformType(originalType);
;;;367              return lastResult;
;;;368            }
;;;369    
;;;370            if((lastResult = this->set_homography(newTransformation.get_homography())) != RESULT_OK) {
000026  b135              CBZ      r5,|L9.54|
                  |L9.40|
;;;371              this->set_transformType(originalType);
000028  4639              MOV      r1,r7
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3217set_transformTypeENS1_13TransformTypeE ; Anki::Embedded::Transformations::PlanarTransformation_f32::set_transformType(Anki::Embedded::Transformations::TransformType)
;;;372              return lastResult;
;;;373            }
;;;374    
;;;375            this->centerOffset = newTransformation.get_centerOffset(1.0f);
;;;376    
;;;377            this->initialCorners = initialCorners;
;;;378    
;;;379            return RESULT_OK;
;;;380          }
000030  b003              ADD      sp,sp,#0xc
000032  4628              MOV      r0,r5                 ;372
000034  bdf0              POP      {r4-r7,pc}
                  |L9.54|
000036  f104053c          ADD      r5,r4,#0x3c           ;375
00003a  eeb70a00          VMOV.F32 s0,#1.00000000        ;375
00003e  4631              MOV      r1,r6                 ;375
000040  4668              MOV      r0,sp                 ;375
000042  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
000046  ed9d0a00          VLDR     s0,[sp,#0]            ;375
00004a  f1040c18          ADD      r12,r4,#0x18          ;377
00004e  ed850a00          VSTR     s0,[r5,#0]            ;377
000052  ed9d0a01          VLDR     s0,[sp,#4]            ;377
000056  4663              MOV      r3,r12                ;377
000058  ed850a01          VSTR     s0,[r5,#4]            ;377
00005c  2000              MOVS     r0,#0                 ;377
                  |L9.94|
00005e  eb0301c0          ADD      r1,r3,r0,LSL #3       ;377
000062  eb0c02c0          ADD      r2,r12,r0,LSL #3      ;377
000066  ed910a00          VLDR     s0,[r1,#0]            ;377
00006a  1c40              ADDS     r0,r0,#1              ;377
00006c  ed820a00          VSTR     s0,[r2,#0]            ;377
000070  ed910a01          VLDR     s0,[r1,#4]            ;377
000074  2804              CMP      r0,#4                 ;377
000076  ed820a01          VSTR     s0,[r2,#4]            ;377
00007a  dbf0              BLT      |L9.94|
00007c  b003              ADD      sp,sp,#0xc
00007e  2000              MOVS     r0,#0                 ;379
000080  bdf0              POP      {r4-r7,pc}
;;;381    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f324InitENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f324InitENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::Init(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
;;;69     
;;;70           Result PlanarTransformation_f32::Init(const TransformType transformType, const Quadrilateral<f32> &initialCorners, const Array<f32> &initialHomography, const Point<f32> &centerOffset, MemoryStack &memory)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;71           {
000004  b08e              SUB      sp,sp,#0x38
000006  461f              MOV      r7,r3
000008  e9ddc816          LDRD     r12,r8,[sp,#0x58]
;;;72             this->isValid = false;
00000c  2300              MOVS     r3,#0
00000e  4604              MOV      r4,r0                 ;71
000010  7003              STRB     r3,[r0,#0]
;;;73     
;;;74             AnkiConditionalErrorAndReturnValue(transformType==TRANSFORM_TRANSLATION || transformType==TRANSFORM_AFFINE || transformType==TRANSFORM_PROJECTIVE,
000012  f5b17f00          CMP      r1,#0x200
000016  bf1c              ITT      NE
000018  f5b16fc0          CMPNE    r1,#0x600
00001c  f5b16f00          CMPNE    r1,#0x800
000020  d00f              BEQ      |L10.66|
000022  204a              MOVS     r0,#0x4a
000024  4a43              LDR      r2,|L10.308|
000026  e9cd2000          STRD     r2,r0,[sp,#0]
00002a  9102              STR      r1,[sp,#8]
00002c  a342              ADR      r3,|L10.312|
00002e  a24f              ADR      r2,|L10.364|
000030  a155              ADR      r1,|L10.392|
000032  2005              MOVS     r0,#5
000034  f7fffffe          BL       _Anki_Log
;;;75               RESULT_FAIL_INVALID_PARAMETER, "PlanarTransformation_f32::Init", "Invalid transformType %d", transformType);
;;;76     
;;;77             this->transformType = transformType;
;;;78             this->centerOffset = centerOffset;
;;;79             this->initialCorners = initialCorners;
;;;80     
;;;81             this->initialPointsAreZeroCentered = false;
;;;82     
;;;83             this->homography = Eye<f32>(3, 3, memory);
;;;84     
;;;85             if(initialHomography.IsValid()) {
;;;86               this->homography.Set(initialHomography);
;;;87             }
;;;88     
;;;89             this->isValid = true;
;;;90     
;;;91             return RESULT_OK;
;;;92           }
000038  b00e              ADD      sp,sp,#0x38
00003a  f04f7040          MOV      r0,#0x3000000         ;74
00003e  e8bd87f0          POP      {r4-r10,pc}
                  |L10.66|
000042  8061              STRH     r1,[r4,#2]            ;77
000044  ed9c0a00          VLDR     s0,[r12,#0]           ;77
000048  f1040118          ADD      r1,r4,#0x18           ;79
00004c  ed840a0f          VSTR     s0,[r4,#0x3c]         ;79
000050  ed9c0a01          VLDR     s0,[r12,#4]           ;79
000054  2000              MOVS     r0,#0                 ;79
000056  ed840a10          VSTR     s0,[r4,#0x40]         ;79
                  |L10.90|
00005a  eb020cc0          ADD      r12,r2,r0,LSL #3      ;79
00005e  eb0105c0          ADD      r5,r1,r0,LSL #3       ;79
000062  ed9c0a00          VLDR     s0,[r12,#0]           ;79
000066  1c40              ADDS     r0,r0,#1              ;79
000068  ed850a00          VSTR     s0,[r5,#0]            ;79
00006c  ed9c0a01          VLDR     s0,[r12,#4]           ;79
000070  2804              CMP      r0,#4                 ;79
000072  ed850a01          VSTR     s0,[r5,#4]            ;79
000076  dbf0              BLT      |L10.90|
000078  f8843038          STRB     r3,[r4,#0x38]         ;81
00007c  2300              MOVS     r3,#0                 ;81
00007e  f04f0a03          MOV      r10,#3                ;83
000082  1d25              ADDS     r5,r4,#4              ;83
000084  ae07              ADD      r6,sp,#0x1c           ;83
000086  46d1              MOV      r9,r10                ;83
000088  461a              MOV      r2,r3                 ;83
00008a  4619              MOV      r1,r3                 ;83
00008c  a80c              ADD      r0,sp,#0x30           ;83
00008e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000092  6800              LDR      r0,[r0,#0]            ;83
000094  9000              STR      r0,[sp,#0]            ;83
000096  4643              MOV      r3,r8                 ;83
000098  464a              MOV      r2,r9                 ;83
00009a  4651              MOV      r1,r10                ;83
00009c  a802              ADD      r0,sp,#8              ;83
00009e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0000a2  f10d0808          ADD      r8,sp,#8              ;83
0000a6  4640              MOV      r0,r8                 ;83
0000a8  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
0000ac  b3a8              CBZ      r0,|L10.282|
0000ae  2100              MOVS     r1,#0                 ;83
0000b0  4640              MOV      r0,r8                 ;83
0000b2  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000b6  4681              MOV      r9,r0                 ;83
0000b8  4640              MOV      r0,r8                 ;83
0000ba  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
0000be  2000              MOVS     r0,#0                 ;83
0000c0  f1b90f00          CMP      r9,#0                 ;83
0000c4  bfc8              IT       GT                    ;83
0000c6  ed9f0a38          VLDRGT   s0,|L10.424|
0000ca  dd0c              BLE      |L10.230|
                  |L10.204|
0000cc  f8d82008          LDR      r2,[r8,#8]            ;83
0000d0  f8d81010          LDR      r1,[r8,#0x10]         ;83
0000d4  fb001102          MLA      r1,r0,r2,r1           ;83
0000d8  eb010180          ADD      r1,r1,r0,LSL #2       ;83
0000dc  1c40              ADDS     r0,r0,#1              ;83
0000de  ed810a00          VSTR     s0,[r1,#0]            ;83
0000e2  4581              CMP      r9,r0                 ;83
0000e4  dcf2              BGT      |L10.204|
                  |L10.230|
0000e6  f10d0808          ADD      r8,sp,#8              ;83
0000ea  e8b8100f          LDM      r8!,{r0-r3,r12}       ;83
0000ee  e8a6100f          STM      r6!,{r0-r3,r12}       ;83
0000f2  f10d081c          ADD      r8,sp,#0x1c           ;83
0000f6  e8b8100f          LDM      r8!,{r0-r3,r12}       ;83
0000fa  e8a5100f          STM      r5!,{r0-r3,r12}       ;83
0000fe  4638              MOV      r0,r7                 ;85
000100  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000104  b118              CBZ      r0,|L10.270|
000106  4639              MOV      r1,r7                 ;86
000108  1d20              ADDS     r0,r4,#4              ;86
00010a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE3SetERKS2_ ; Anki::Embedded::Array<float>::Set(const Anki::Embedded::Array<float>&)
                  |L10.270|
00010e  2001              MOVS     r0,#1                 ;89
000110  7020              STRB     r0,[r4,#0]            ;89
000112  b00e              ADD      sp,sp,#0x38
000114  2000              MOVS     r0,#0                 ;91
000116  e8bd87f0          POP      {r4-r10,pc}
                  |L10.282|
00011a  e7ff              B        |L10.284|
                  |L10.284|
00011c  213c              MOVS     r1,#0x3c
00011e  4823              LDR      r0,|L10.428|
000120  e9cd0100          STRD     r0,r1,[sp,#0]
000124  a322              ADR      r3,|L10.432|
000126  a232              ADR      r2,|L10.496|
000128  a135              ADR      r1,|L10.512|
00012a  2005              MOVS     r0,#5
00012c  f7fffffe          BL       _Anki_Log
000130  e7d9              B        |L10.230|
;;;93     
                          ENDP

000132  0000              DCW      0x0000
                  |L10.308|
                          DCD      ||.constdata||+0x87a
                  |L10.312|
000138  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\transformations.cpp",0
00013c  6f726574
000140  6563685c
000144  76697369
000148  6f6e5c72
00014c  6f626f74
000150  5c737263
000154  5c747261
000158  6e73666f
00015c  726d6174
000160  696f6e73
000164  2e637070
000168  00      
000169  00                DCB      0
00016a  00                DCB      0
00016b  00                DCB      0
                  |L10.364|
00016c  496e7661          DCB      "Invalid transformType %d",0
000170  6c696420
000174  7472616e
000178  73666f72
00017c  6d547970
000180  65202564
000184  00      
000185  00                DCB      0
000186  00                DCB      0
000187  00                DCB      0
                  |L10.392|
000188  506c616e          DCB      "PlanarTransformation_f32::Init",0
00018c  61725472
000190  616e7366
000194  6f726d61
000198  74696f6e
00019c  5f663332
0001a0  3a3a496e
0001a4  697400  
0001a7  00                DCB      0
                  |L10.424|
0001a8  3f800000          DCFS     0x3f800000 ; 1
                  |L10.428|
                          DCD      _ZZN4Anki8Embedded3EyeIfEENS_6ResultERNS0_5ArrayIT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Eye<float>(Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
                  |L10.432|
0001b0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/arrayP"
0001b4  6f726574
0001b8  6563685c
0001bc  636f6d6d
0001c0  6f6e5c69
0001c4  6e636c75
0001c8  64655c61
0001cc  6e6b692f
0001d0  636f6d6d
0001d4  6f6e2f72
0001d8  6f626f74
0001dc  2f617272
0001e0  617950  
0001e3  61747465          DCB      "atterns.h",0
0001e7  726e732e
0001eb  6800    
0001ed  00                DCB      0
0001ee  00                DCB      0
0001ef  00                DCB      0
                  |L10.496|
0001f0  6f757420          DCB      "out is invalid",0
0001f4  69732069
0001f8  6e76616c
0001fc  696400  
0001ff  00                DCB      0
                  |L10.512|
000200  45796500          DCB      "Eye",0

                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f326UpdateERKNS0_5ArrayIfEEfNS0_11MemoryStackENS1_13TransformTypeE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f326UpdateERKNS0_5ArrayIfEEfNS0_11MemoryStackENS1_13TransformTypeE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::Update(const Anki::Embedded::Array<float>&, float, Anki::Embedded::MemoryStack, Anki::Embedded::Transformations::TransformType)
;;;113    
;;;114          Result PlanarTransformation_f32::Update(const Array<f32> &update, const f32 scale, MemoryStack scratch, TransformType updateType)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;115          {
000004  4604              MOV      r4,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  b0b1              SUB      sp,sp,#0xc4
00000c  461e              MOV      r6,r3
00000e  4690              MOV      r8,r2
000010  eeb08a40          VMOV.F32 s16,s0
000014  4689              MOV      r9,r1
;;;116            AnkiConditionalErrorAndReturnValue(update.IsValid(),
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00001c  4fec              LDR      r7,|L11.976|
00001e  2800              CMP      r0,#0
000020  d015              BEQ      |L11.78|
;;;117              RESULT_FAIL_INVALID_OBJECT, "PlanarTransformation_f32::Update", "update is not valid");
;;;118    
;;;119            AnkiConditionalErrorAndReturnValue(update.get_size(0) == 1,
000022  2100              MOVS     r1,#0
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00002a  2801              CMP      r0,#1
00002c  d01b              BEQ      |L11.102|
00002e  2077              MOVS     r0,#0x77
000030  e9cd7000          STRD     r7,r0,[sp,#0]
000034  a3e7              ADR      r3,|L11.980|
000036  a2f4              ADR      r2,|L11.1032|
000038  a1fb              ADR      r1,|L11.1064|
00003a  2005              MOVS     r0,#5
00003c  f7fffffe          BL       _Anki_Log
000040  f04f60a0          MOV      r0,#0x5000000
                  |L11.68|
;;;120              RESULT_FAIL_INVALID_SIZE, "PlanarTransformation_f32::Update", "update is the incorrect size");
;;;121    
;;;122            if(updateType == TRANSFORM_UNKNOWN) {
;;;123              updateType = this->transformType;
;;;124            }
;;;125    
;;;126            // An Object of a given transformation type can only be updated with a simpler transformation
;;;127            if(this->transformType == TRANSFORM_TRANSLATION) {
;;;128              AnkiConditionalErrorAndReturnValue(updateType == TRANSFORM_TRANSLATION,
;;;129                RESULT_FAIL_INVALID_PARAMETER, "PlanarTransformation_f32::Update", "cannot update this transform with the update type %d", updateType);
;;;130            } else if(this->transformType == TRANSFORM_AFFINE) {
;;;131              AnkiConditionalErrorAndReturnValue(updateType == TRANSFORM_TRANSLATION || updateType == TRANSFORM_AFFINE,
;;;132                RESULT_FAIL_INVALID_PARAMETER, "PlanarTransformation_f32::Update", "cannot update this transform with the update type %d", updateType);
;;;133            } else if(this->transformType == TRANSFORM_PROJECTIVE) {
;;;134              AnkiConditionalErrorAndReturnValue(updateType == TRANSFORM_TRANSLATION|| updateType == TRANSFORM_AFFINE || updateType == TRANSFORM_PROJECTIVE,
;;;135                RESULT_FAIL_INVALID_PARAMETER, "PlanarTransformation_f32::Update", "cannot update this transform with the update type %d", updateType);
;;;136            } else {
;;;137              AnkiAssert(false);
;;;138            }
;;;139    
;;;140            const f32 * pUpdate = update[0];
;;;141    
;;;142            if(updateType == TRANSFORM_TRANSLATION) {
;;;143              AnkiConditionalErrorAndReturnValue(update.get_size(1) == TRANSFORM_TRANSLATION>>8,
;;;144                RESULT_FAIL_INVALID_SIZE, "PlanarTransformation_f32::Update", "update is the incorrect size");
;;;145    
;;;146              // this.tform(1:2,3) = this.tform(1:2,3) - update;
;;;147              homography[0][2] -= scale*pUpdate[0];
;;;148              homography[1][2] -= scale*pUpdate[1];
;;;149            } else { // if(updateType == TRANSFORM_TRANSLATION)
;;;150              Array<f32> updateArray(3,3,scratch);
;;;151    
;;;152              if(updateType == TRANSFORM_AFFINE) {
;;;153                AnkiConditionalErrorAndReturnValue(update.get_size(1) == TRANSFORM_AFFINE>>8,
;;;154                  RESULT_FAIL_INVALID_SIZE, "PlanarTransformation_f32::Update", "update is the incorrect size");
;;;155    
;;;156                // TODO: does this work with projective?
;;;157    
;;;158                updateArray[0][0] = 1.0f + pUpdate[0]; updateArray[0][1] = pUpdate[1];        updateArray[0][2] = pUpdate[2]*scale;
;;;159                updateArray[1][0] = pUpdate[3];        updateArray[1][1] = 1.0f + pUpdate[4]; updateArray[1][2] = pUpdate[5]*scale;
;;;160                updateArray[2][0] = 0.0f;              updateArray[2][1] = 0.0f;              updateArray[2][2] = 1.0f;
;;;161              } else if(updateType == TRANSFORM_PROJECTIVE) {
;;;162                AnkiConditionalErrorAndReturnValue(update.get_size(1) == TRANSFORM_PROJECTIVE>>8,
;;;163                  RESULT_FAIL_INVALID_SIZE, "PlanarTransformation_f32::Update", "update is the incorrect size");
;;;164    
;;;165                // TODO: does this work with affine?
;;;166    
;;;167                // tformUpdate = eye(3) + [update(1:3)'; update(4:6)'; update(7:8)' 0];
;;;168                updateArray[0][0] = 1.0f + pUpdate[0]; updateArray[0][1] = pUpdate[1];        updateArray[0][2] = pUpdate[2]*scale;
;;;169                updateArray[1][0] = pUpdate[3];        updateArray[1][1] = 1.0f + pUpdate[4]; updateArray[1][2] = pUpdate[5]*scale;
;;;170                updateArray[2][0] = pUpdate[6]/scale;  updateArray[2][1] = pUpdate[7]/scale;  updateArray[2][2] = 1.0f;
;;;171              } else {
;;;172                AnkiError("PlanarTransformation_f32::Update", "Unknown transformation type %d", updateType);
;;;173                return RESULT_FAIL_INVALID_PARAMETER;
;;;174              }
;;;175    
;;;176              // this.tform = this.tform*inv(tformUpdate);
;;;177              Invert3x3(
;;;178                updateArray[0][0], updateArray[0][1], updateArray[0][2],
;;;179                updateArray[1][0], updateArray[1][1], updateArray[1][2],
;;;180                updateArray[2][0], updateArray[2][1], updateArray[2][2]);
;;;181    
;;;182              Array<f32> newHomography(3,3,scratch);
;;;183    
;;;184              Matrix::Multiply(this->homography, updateArray, newHomography);
;;;185    
;;;186              if(!FLT_NEAR(newHomography[2][2], 1.0f)) {
;;;187                Matrix::DotDivide<f32,f32,f32>(newHomography, newHomography[2][2], newHomography);
;;;188              }
;;;189    
;;;190              this->homography.Set(newHomography);
;;;191            } // if(updateType == TRANSFORM_TRANSLATION) ... else
;;;192    
;;;193            return RESULT_OK;
;;;194          }
000044  b031              ADD      sp,sp,#0xc4
000046  ecbd8b02          VPOP     {d8}
00004a  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.78|
00004e  2074              MOVS     r0,#0x74              ;116
000050  e9cd7000          STRD     r7,r0,[sp,#0]         ;116
000054  a3df              ADR      r3,|L11.980|
000056  a2fd              ADR      r2,|L11.1100|
000058  a1f3              ADR      r1,|L11.1064|
00005a  2005              MOVS     r0,#5                 ;116
00005c  f7fffffe          BL       _Anki_Log
000060  f04f6080          MOV      r0,#0x4000000         ;116
000064  e7ee              B        |L11.68|
                  |L11.102|
000066  2e00              CMP      r6,#0                 ;122
000068  bf08              IT       EQ                    ;123
00006a  8866              LDRHEQ   r6,[r4,#2]            ;123
00006c  8860              LDRH     r0,[r4,#2]            ;127
00006e  f5b07f00          CMP      r0,#0x200             ;127
000072  d007              BEQ      |L11.132|
000074  f5b06fc0          CMP      r0,#0x600             ;130
000078  d015              BEQ      |L11.166|
00007a  f5b06f00          CMP      r0,#0x800             ;133
00007e  d025              BEQ      |L11.204|
000080  f000b839          B.W      |L11.246|
                  |L11.132|
000084  f5b67f00          CMP      r6,#0x200             ;128
000088  f0008035          BEQ.W    |L11.246|
00008c  2080              MOVS     r0,#0x80              ;128
00008e  9700              STR      r7,[sp,#0]            ;128
000090  e9cd0601          STRD     r0,r6,[sp,#4]         ;128
000094  a3cf              ADR      r3,|L11.980|
000096  a2f2              ADR      r2,|L11.1120|
000098  a1e3              ADR      r1,|L11.1064|
00009a  2005              MOVS     r0,#5                 ;128
00009c  f7fffffe          BL       _Anki_Log
0000a0  f04f7040          MOV      r0,#0x3000000         ;128
0000a4  e7ce              B        |L11.68|
                  |L11.166|
0000a6  f5b67f00          CMP      r6,#0x200             ;131
0000aa  bf18              IT       NE                    ;131
0000ac  f5b66fc0          CMPNE    r6,#0x600             ;131
0000b0  d021              BEQ      |L11.246|
0000b2  2083              MOVS     r0,#0x83              ;131
0000b4  9700              STR      r7,[sp,#0]            ;131
0000b6  e9cd0601          STRD     r0,r6,[sp,#4]         ;131
0000ba  a3c6              ADR      r3,|L11.980|
0000bc  a2e8              ADR      r2,|L11.1120|
0000be  a1da              ADR      r1,|L11.1064|
0000c0  2005              MOVS     r0,#5                 ;131
0000c2  f7fffffe          BL       _Anki_Log
0000c6  f04f7040          MOV      r0,#0x3000000         ;131
0000ca  e7bb              B        |L11.68|
                  |L11.204|
0000cc  f5b67f00          CMP      r6,#0x200             ;134
0000d0  bf1c              ITT      NE                    ;134
0000d2  f5b66fc0          CMPNE    r6,#0x600             ;134
0000d6  f5b66f00          CMPNE    r6,#0x800             ;134
0000da  d00c              BEQ      |L11.246|
0000dc  2086              MOVS     r0,#0x86              ;134
0000de  9700              STR      r7,[sp,#0]            ;134
0000e0  e9cd0601          STRD     r0,r6,[sp,#4]         ;134
0000e4  a3bb              ADR      r3,|L11.980|
0000e6  a2de              ADR      r2,|L11.1120|
0000e8  a1cf              ADR      r1,|L11.1064|
0000ea  2005              MOVS     r0,#5                 ;134
0000ec  f7fffffe          BL       _Anki_Log
0000f0  f04f7040          MOV      r0,#0x3000000         ;134
0000f4  e7a6              B        |L11.68|
                  |L11.246|
0000f6  2000              MOVS     r0,#0                 ;140
0000f8  f8d92008          LDR      r2,[r9,#8]            ;140
0000fc  f8d91010          LDR      r1,[r9,#0x10]         ;140
000100  f5b67f00          CMP      r6,#0x200             ;142
000104  fb001502          MLA      r5,r0,r2,r1           ;142
000108  d023              BEQ      |L11.338|
00010a  2300              MOVS     r3,#0                 ;150
00010c  461a              MOV      r2,r3                 ;150
00010e  2101              MOVS     r1,#1                 ;150
000110  a82e              ADD      r0,sp,#0xb8           ;150
000112  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000116  6800              LDR      r0,[r0,#0]            ;150
000118  2203              MOVS     r2,#3                 ;150
00011a  9000              STR      r0,[sp,#0]            ;150
00011c  4643              MOV      r3,r8                 ;150
00011e  4611              MOV      r1,r2                 ;150
000120  a80a              ADD      r0,sp,#0x28           ;150
000122  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000126  eef78a00          VMOV.F32 s17,#1.00000000       ;158
00012a  f5b66fc0          CMP      r6,#0x600             ;152
00012e  d03e              BEQ      |L11.430|
000130  f5b66f00          CMP      r6,#0x800             ;161
000134  f00080a3          BEQ.W    |L11.638|
000138  20ac              MOVS     r0,#0xac              ;172
00013a  9700              STR      r7,[sp,#0]            ;172
00013c  e9cd0601          STRD     r0,r6,[sp,#4]         ;172
000140  a3a4              ADR      r3,|L11.980|
000142  a2d5              ADR      r2,|L11.1176|
000144  a1b8              ADR      r1,|L11.1064|
000146  2005              MOVS     r0,#5                 ;172
000148  f7fffffe          BL       _Anki_Log
00014c  f04f7040          MOV      r0,#0x3000000         ;173
000150  e778              B        |L11.68|
                  |L11.338|
000152  2101              MOVS     r1,#1                 ;143
000154  4648              MOV      r0,r9                 ;143
000156  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00015a  2802              CMP      r0,#2                 ;143
00015c  d00b              BEQ      |L11.374|
00015e  208f              MOVS     r0,#0x8f              ;143
000160  e9cd7000          STRD     r7,r0,[sp,#0]         ;143
000164  a39b              ADR      r3,|L11.980|
000166  a2a8              ADR      r2,|L11.1032|
000168  a1af              ADR      r1,|L11.1064|
00016a  2005              MOVS     r0,#5                 ;143
00016c  f7fffffe          BL       _Anki_Log
000170  f04f60a0          MOV      r0,#0x5000000         ;143
000174  e766              B        |L11.68|
                  |L11.374|
000176  68e2              LDR      r2,[r4,#0xc]          ;143
000178  6961              LDR      r1,[r4,#0x14]         ;143
00017a  2000              MOVS     r0,#0                 ;147
00017c  fb001002          MLA      r0,r0,r2,r1           ;147
000180  edd50a00          VLDR     s1,[r5,#0]            ;147
000184  ed900a02          VLDR     s0,[r0,#8]            ;147
000188  ee080a60          VMLS.F32 s0,s16,s1             ;147
00018c  ed800a02          VSTR     s0,[r0,#8]            ;147
000190  68e2              LDR      r2,[r4,#0xc]          ;147
000192  6961              LDR      r1,[r4,#0x14]         ;147
000194  2001              MOVS     r0,#1                 ;148
000196  fb001002          MLA      r0,r0,r2,r1           ;148
00019a  edd50a01          VLDR     s1,[r5,#4]            ;148
00019e  ed900a02          VLDR     s0,[r0,#8]            ;148
0001a2  ee080a60          VMLS.F32 s0,s16,s1             ;148
0001a6  ed800a02          VSTR     s0,[r0,#8]            ;148
0001aa  f000b9d8          B.W      |L11.1374|
                  |L11.430|
0001ae  2101              MOVS     r1,#1                 ;153
0001b0  4648              MOV      r0,r9                 ;153
0001b2  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0001b6  2806              CMP      r0,#6                 ;153
0001b8  d00b              BEQ      |L11.466|
0001ba  2099              MOVS     r0,#0x99              ;153
0001bc  e9cd7000          STRD     r7,r0,[sp,#0]         ;153
0001c0  a384              ADR      r3,|L11.980|
0001c2  a291              ADR      r2,|L11.1032|
0001c4  a198              ADR      r1,|L11.1064|
0001c6  2005              MOVS     r0,#5                 ;153
0001c8  f7fffffe          BL       _Anki_Log
0001cc  f04f60a0          MOV      r0,#0x5000000         ;153
0001d0  e738              B        |L11.68|
                  |L11.466|
0001d2  ed950a00          VLDR     s0,[r5,#0]            ;158
0001d6  9a0e              LDR      r2,[sp,#0x38]         ;158
0001d8  990c              LDR      r1,[sp,#0x30]         ;158
0001da  2000              MOVS     r0,#0                 ;158
0001dc  fb002001          MLA      r0,r0,r1,r2           ;158
0001e0  ee300a28          VADD.F32 s0,s0,s17             ;158
0001e4  ed800a00          VSTR     s0,[r0,#0]            ;158
0001e8  9a0c              LDR      r2,[sp,#0x30]         ;158
0001ea  990e              LDR      r1,[sp,#0x38]         ;158
0001ec  2000              MOVS     r0,#0                 ;158
0001ee  fb001002          MLA      r0,r0,r2,r1           ;158
0001f2  ed950a01          VLDR     s0,[r5,#4]            ;158
0001f6  ed800a01          VSTR     s0,[r0,#4]            ;158
0001fa  ed950a02          VLDR     s0,[r5,#8]            ;158
0001fe  9a0c              LDR      r2,[sp,#0x30]         ;158
000200  990e              LDR      r1,[sp,#0x38]         ;158
000202  2000              MOVS     r0,#0                 ;158
000204  fb001002          MLA      r0,r0,r2,r1           ;158
000208  ee200a08          VMUL.F32 s0,s0,s16             ;158
00020c  ed800a02          VSTR     s0,[r0,#8]            ;158
000210  9a0c              LDR      r2,[sp,#0x30]         ;158
000212  990e              LDR      r1,[sp,#0x38]         ;158
000214  2001              MOVS     r0,#1                 ;159
000216  fb001002          MLA      r0,r0,r2,r1           ;159
00021a  ed950a03          VLDR     s0,[r5,#0xc]          ;159
00021e  ed800a00          VSTR     s0,[r0,#0]            ;159
000222  ed950a04          VLDR     s0,[r5,#0x10]         ;159
000226  9a0c              LDR      r2,[sp,#0x30]         ;159
000228  990e              LDR      r1,[sp,#0x38]         ;159
00022a  2001              MOVS     r0,#1                 ;159
00022c  fb001002          MLA      r0,r0,r2,r1           ;159
000230  ee300a28          VADD.F32 s0,s0,s17             ;159
000234  ed800a01          VSTR     s0,[r0,#4]            ;159
000238  ed950a05          VLDR     s0,[r5,#0x14]         ;159
00023c  9a0e              LDR      r2,[sp,#0x38]         ;159
00023e  990c              LDR      r1,[sp,#0x30]         ;159
000240  2001              MOVS     r0,#1                 ;159
000242  fb002001          MLA      r0,r0,r1,r2           ;159
000246  ee200a08          VMUL.F32 s0,s0,s16             ;159
00024a  ed800a02          VSTR     s0,[r0,#8]            ;159
00024e  9a0c              LDR      r2,[sp,#0x30]         ;159
000250  990e              LDR      r1,[sp,#0x38]         ;159
000252  2002              MOVS     r0,#2                 ;160
000254  fb001002          MLA      r0,r0,r2,r1           ;160
000258  ed9f0a97          VLDR     s0,|L11.1208|
00025c  ed800a00          VSTR     s0,[r0,#0]            ;160
000260  9a0c              LDR      r2,[sp,#0x30]         ;160
000262  990e              LDR      r1,[sp,#0x38]         ;160
000264  2002              MOVS     r0,#2                 ;160
000266  fb001002          MLA      r0,r0,r2,r1           ;160
00026a  ed800a01          VSTR     s0,[r0,#4]            ;160
00026e  9a0c              LDR      r2,[sp,#0x30]         ;160
000270  990e              LDR      r1,[sp,#0x38]         ;160
000272  2002              MOVS     r0,#2                 ;160
000274  fb001002          MLA      r0,r0,r2,r1           ;160
000278  edc08a02          VSTR     s17,[r0,#8]           ;160
00027c  e06c              B        |L11.856|
                  |L11.638|
00027e  2101              MOVS     r1,#1                 ;162
000280  4648              MOV      r0,r9                 ;162
000282  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000286  2808              CMP      r0,#8                 ;162
000288  d00b              BEQ      |L11.674|
00028a  20a2              MOVS     r0,#0xa2              ;162
00028c  e9cd7000          STRD     r7,r0,[sp,#0]         ;162
000290  a350              ADR      r3,|L11.980|
000292  a25d              ADR      r2,|L11.1032|
000294  a164              ADR      r1,|L11.1064|
000296  2005              MOVS     r0,#5                 ;162
000298  f7fffffe          BL       _Anki_Log
00029c  f04f60a0          MOV      r0,#0x5000000         ;162
0002a0  e6d0              B        |L11.68|
                  |L11.674|
0002a2  ed950a00          VLDR     s0,[r5,#0]            ;168
0002a6  9a0c              LDR      r2,[sp,#0x30]         ;168
0002a8  990e              LDR      r1,[sp,#0x38]         ;168
0002aa  2000              MOVS     r0,#0                 ;168
0002ac  fb001002          MLA      r0,r0,r2,r1           ;168
0002b0  ee300a28          VADD.F32 s0,s0,s17             ;168
0002b4  ed800a00          VSTR     s0,[r0,#0]            ;168
0002b8  9a0c              LDR      r2,[sp,#0x30]         ;168
0002ba  990e              LDR      r1,[sp,#0x38]         ;168
0002bc  2000              MOVS     r0,#0                 ;168
0002be  fb001002          MLA      r0,r0,r2,r1           ;168
0002c2  ed950a01          VLDR     s0,[r5,#4]            ;168
0002c6  ed800a01          VSTR     s0,[r0,#4]            ;168
0002ca  ed950a02          VLDR     s0,[r5,#8]            ;168
0002ce  9a0c              LDR      r2,[sp,#0x30]         ;168
0002d0  990e              LDR      r1,[sp,#0x38]         ;168
0002d2  2000              MOVS     r0,#0                 ;168
0002d4  fb001002          MLA      r0,r0,r2,r1           ;168
0002d8  ee200a08          VMUL.F32 s0,s0,s16             ;168
0002dc  ed800a02          VSTR     s0,[r0,#8]            ;168
0002e0  9a0c              LDR      r2,[sp,#0x30]         ;168
0002e2  990e              LDR      r1,[sp,#0x38]         ;168
0002e4  2001              MOVS     r0,#1                 ;169
0002e6  fb001002          MLA      r0,r0,r2,r1           ;169
0002ea  ed950a03          VLDR     s0,[r5,#0xc]          ;169
0002ee  ed800a00          VSTR     s0,[r0,#0]            ;169
0002f2  ed950a04          VLDR     s0,[r5,#0x10]         ;169
0002f6  9a0c              LDR      r2,[sp,#0x30]         ;169
0002f8  990e              LDR      r1,[sp,#0x38]         ;169
0002fa  2001              MOVS     r0,#1                 ;169
0002fc  fb001002          MLA      r0,r0,r2,r1           ;169
000300  ee300a28          VADD.F32 s0,s0,s17             ;169
000304  ed800a01          VSTR     s0,[r0,#4]            ;169
000308  ed950a05          VLDR     s0,[r5,#0x14]         ;169
00030c  9a0c              LDR      r2,[sp,#0x30]         ;169
00030e  990e              LDR      r1,[sp,#0x38]         ;169
000310  2001              MOVS     r0,#1                 ;169
000312  fb001002          MLA      r0,r0,r2,r1           ;169
000316  ee200a08          VMUL.F32 s0,s0,s16             ;169
00031a  ed800a02          VSTR     s0,[r0,#8]            ;169
00031e  ed950a06          VLDR     s0,[r5,#0x18]         ;170
000322  9a0c              LDR      r2,[sp,#0x30]         ;170
000324  990e              LDR      r1,[sp,#0x38]         ;170
000326  eec00a08          VDIV.F32 s1,s0,s16             ;170
00032a  2002              MOVS     r0,#2                 ;170
00032c  fb001002          MLA      r0,r0,r2,r1           ;170
000330  edc00a00          VSTR     s1,[r0,#0]            ;170
000334  ed950a07          VLDR     s0,[r5,#0x1c]         ;170
000338  9a0c              LDR      r2,[sp,#0x30]         ;170
00033a  990e              LDR      r1,[sp,#0x38]         ;170
00033c  eec00a08          VDIV.F32 s1,s0,s16             ;170
000340  2002              MOVS     r0,#2                 ;170
000342  fb001002          MLA      r0,r0,r2,r1           ;170
000346  edc00a01          VSTR     s1,[r0,#4]            ;170
00034a  9a0c              LDR      r2,[sp,#0x30]         ;170
00034c  990e              LDR      r1,[sp,#0x38]         ;170
00034e  2002              MOVS     r0,#2                 ;170
000350  fb001002          MLA      r0,r0,r2,r1           ;170
000354  edc08a02          VSTR     s17,[r0,#8]           ;170
                  |L11.856|
000358  9a0c              LDR      r2,[sp,#0x30]         ;170
00035a  990e              LDR      r1,[sp,#0x38]         ;170
00035c  2002              MOVS     r0,#2                 ;177
00035e  fb001c02          MLA      r12,r0,r2,r1          ;177
000362  9b0c              LDR      r3,[sp,#0x30]         ;177
000364  2001              MOVS     r0,#1                 ;177
000366  fb001303          MLA      r3,r0,r3,r1           ;177
00036a  f8dd9030          LDR      r9,[sp,#0x30]         ;177
00036e  f10c0508          ADD      r5,r12,#8             ;177
000372  1d1e              ADDS     r6,r3,#4              ;177
000374  1f2a              SUBS     r2,r5,#4              ;177
000376  9600              STR      r6,[sp,#0]            ;177
000378  e9cd2503          STRD     r2,r5,[sp,#0xc]       ;177
00037c  2000              MOVS     r0,#0                 ;177
00037e  fb001009          MLA      r0,r0,r9,r1           ;177
000382  f1030708          ADD      r7,r3,#8              ;177
000386  e9cd7c01          STRD     r7,r12,[sp,#4]        ;177
00038a  f1000908          ADD      r9,r0,#8              ;177
00038e  1d01              ADDS     r1,r0,#4              ;177
000390  464a              MOV      r2,r9                 ;177
000392  f7fffffe          BL       _ZN4Anki8Embedded9Invert3x3IfEEvRT_S3_S3_S3_S3_S3_S3_S3_S3_ ; Anki::Embedded::Invert3x3<float>(T1&, T1&, T1&, T1&, T1&, T1&, T1&, T1&, T1&)
000396  2300              MOVS     r3,#0                 ;182
000398  461a              MOV      r2,r3                 ;182
00039a  2101              MOVS     r1,#1                 ;182
00039c  a82e              ADD      r0,sp,#0xb8           ;182
00039e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0003a2  6800              LDR      r0,[r0,#0]            ;182
0003a4  2203              MOVS     r2,#3                 ;182
0003a6  9000              STR      r0,[sp,#0]            ;182
0003a8  4643              MOV      r3,r8                 ;182
0003aa  4611              MOV      r1,r2                 ;182
0003ac  a80f              ADD      r0,sp,#0x3c           ;182
0003ae  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0003b2  aa0f              ADD      r2,sp,#0x3c           ;184
0003b4  a90a              ADD      r1,sp,#0x28           ;184
0003b6  1d20              ADDS     r0,r4,#4              ;184
0003b8  f7fffffe          BL       _ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
0003bc  9a11              LDR      r2,[sp,#0x44]         ;184
0003be  9913              LDR      r1,[sp,#0x4c]         ;184
0003c0  2002              MOVS     r0,#2                 ;186
0003c2  fb001002          MLA      r0,r0,r2,r1           ;186
0003c6  493d              LDR      r1,|L11.1212|
0003c8  6880              LDR      r0,[r0,#8]            ;186
0003ca  4288              CMP      r0,r1                 ;186
0003cc  e078              B        |L11.1216|
0003ce  0000              DCW      0x0000
                  |L11.976|
                          DCD      ||.constdata||
                  |L11.980|
0003d4  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\transformations.cpp",0
0003d8  6f726574
0003dc  6563685c
0003e0  76697369
0003e4  6f6e5c72
0003e8  6f626f74
0003ec  5c737263
0003f0  5c747261
0003f4  6e73666f
0003f8  726d6174
0003fc  696f6e73
000400  2e637070
000404  00      
000405  00                DCB      0
000406  00                DCB      0
000407  00                DCB      0
                  |L11.1032|
000408  75706461          DCB      "update is the incorrect size",0
00040c  74652069
000410  73207468
000414  6520696e
000418  636f7272
00041c  65637420
000420  73697a65
000424  00      
000425  00                DCB      0
000426  00                DCB      0
000427  00                DCB      0
                  |L11.1064|
000428  506c616e          DCB      "PlanarTransformation_f32::Update",0
00042c  61725472
000430  616e7366
000434  6f726d61
000438  74696f6e
00043c  5f663332
000440  3a3a5570
000444  64617465
000448  00      
000449  00                DCB      0
00044a  00                DCB      0
00044b  00                DCB      0
                  |L11.1100|
00044c  75706461          DCB      "update is not valid",0
000450  74652069
000454  73206e6f
000458  74207661
00045c  6c696400
                  |L11.1120|
000460  63616e6e          DCB      "cannot update this transform with the update type %d",0
000464  6f742075
000468  70646174
00046c  65207468
000470  69732074
000474  72616e73
000478  666f726d
00047c  20776974
000480  68207468
000484  65207570
000488  64617465
00048c  20747970
000490  65202564
000494  00      
000495  00                DCB      0
000496  00                DCB      0
000497  00                DCB      0
                  |L11.1176|
000498  556e6b6e          DCB      "Unknown transformation type %d",0
00049c  6f776e20
0004a0  7472616e
0004a4  73666f72
0004a8  6d617469
0004ac  6f6e2074
0004b0  79706520
0004b4  256400  
0004b7  00                DCB      0
                  |L11.1208|
0004b8  00000000          DCFS     0x00000000 ; 0
                  |L11.1212|
                          DCD      0x3f7fff58
                  |L11.1216|
0004c0  bfc4              ITT      GT                    ;186
0004c2  4929              LDRGT    r1,|L11.1384|
0004c4  4281              CMPGT    r1,r0                 ;186
0004c6  dc46              BGT      |L11.1366|
0004c8  ae0f              ADD      r6,sp,#0x3c           ;187
0004ca  a814              ADD      r0,sp,#0x50           ;187
0004cc  e8b6102e          LDM      r6!,{r1-r3,r5,r12}    ;187
0004d0  e88d102e          STM      sp,{r1-r3,r5,r12}     ;187
0004d4  2500              MOVS     r5,#0                 ;187
0004d6  4669              MOV      r1,sp                 ;187
0004d8  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
0004dc  f8805030          STRB     r5,[r0,#0x30]         ;187
0004e0  4607              MOV      r7,r0                 ;187
0004e2  9a11              LDR      r2,[sp,#0x44]         ;187
0004e4  9913              LDR      r1,[sp,#0x4c]         ;187
0004e6  2002              MOVS     r0,#2                 ;187
0004e8  fb001002          MLA      r0,r0,r2,r1           ;187
0004ec  ae0f              ADD      r6,sp,#0x3c           ;187
0004ee  ed908a02          VLDR     s16,[r0,#8]           ;187
0004f2  e8b6102e          LDM      r6!,{r1-r3,r5,r12}    ;187
0004f6  e88d102e          STM      sp,{r1-r3,r5,r12}     ;187
0004fa  a821              ADD      r0,sp,#0x84           ;187
0004fc  4669              MOV      r1,sp                 ;187
0004fe  f7fffffe          BL       _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
000502  9900              LDR      r1,[sp,#0]            ;187
000504  2900              CMP      r1,#0                 ;187
000506  bfc4              ITT      GT                    ;187
000508  9901              LDRGT    r1,[sp,#4]            ;187
00050a  2900              CMPGT    r1,#0                 ;187
00050c  dd29              BLE      |L11.1378|
00050e  e9dd1200          LDRD     r1,r2,[sp,#0]         ;187
000512  4351              MULS     r1,r2,r1              ;187
000514  b329              CBZ      r1,|L11.1378|
000516  9b04              LDR      r3,[sp,#0x10]         ;187
000518  9a02              LDR      r2,[sp,#8]            ;187
00051a  2100              MOVS     r1,#0                 ;187
00051c  fb013102          MLA      r1,r1,r2,r3           ;187
                  |L11.1312|
000520  6301              STR      r1,[r0,#0x30]         ;187
000522  4683              MOV      r11,r0                ;187
000524  f100010c          ADD      r1,r0,#0xc            ;187
000528  6806              LDR      r6,[r0,#0]            ;187
00052a  69c5              LDR      r5,[r0,#0x1c]         ;187
00052c  e8911007          LDM      r1,{r0-r2,r12}        ;187
000530  e9dbe301          LDRD     lr,r3,[r11,#4]        ;187
000534  f10b0b20          ADD      r11,r11,#0x20         ;187
000538  962f              STR      r6,[sp,#0xbc]         ;187
00053a  e89b0f40          LDM      r11,{r6,r8-r11}       ;187
00053e  e88d1007          STM      sp,{r0-r2,r12}        ;187
000542  a904              ADD      r1,sp,#0x10           ;187
000544  4672              MOV      r2,lr                 ;187
000546  e8a10f60          STM      r1!,{r5,r6,r8-r11}    ;187
00054a  eeb00a48          VMOV.F32 s0,s16                ;187
00054e  4638              MOV      r0,r7                 ;187
000550  992f              LDR      r1,[sp,#0xbc]         ;187
000552  f7fffffe          BL       _ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_9DotDivideIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::DotDivide<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, T1, Anki::Embedded::ArraySlice<T3>)
                  |L11.1366|
000556  a90f              ADD      r1,sp,#0x3c           ;190
000558  1d20              ADDS     r0,r4,#4              ;190
00055a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE3SetERKS2_ ; Anki::Embedded::Array<float>::Set(const Anki::Embedded::Array<float>&)
                  |L11.1374|
00055e  2000              MOVS     r0,#0                 ;193
000560  e570              B        |L11.68|
                  |L11.1378|
000562  2100              MOVS     r1,#0                 ;193
000564  e7dc              B        |L11.1312|
;;;195    
                          ENDP

000566  0000              DCW      0x0000
                  |L11.1384|
                          DCD      0x3f800054

                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C2ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE                  ; Alternate entry point ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32__sub_object(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
;;;49     
;;;50           PlanarTransformation_f32::PlanarTransformation_f32(const TransformType transformType, const Quadrilateral<f32> &initialCorners, const Array<f32> &initialHomography, const Point<f32> &centerOffset, MemoryStack &memory)
;;;51           {
;;;52             this->Init(transformType, initialCorners, initialHomography, centerOffset, memory);
;;;53           }
;;;54     
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  b082              SUB      sp,sp,#8
000006  4698              MOV      r8,r3
000008  e9dd670a          LDRD     r6,r7,[sp,#0x28]
00000c  4691              MOV      r9,r2
00000e  468a              MOV      r10,r1
000010  1d00              ADDS     r0,r0,#4
000012  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
000016  3014              ADDS     r0,r0,#0x14
000018  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1Ev ; Anki::Embedded::Quadrilateral<float>::Quadrilateral()
00001c  ed9f0a09          VLDR     s0,|L12.68|
000020  f1a00518          SUB      r5,r0,#0x18
000024  ed800a09          VSTR     s0,[r0,#0x24]
000028  ed800a0a          VSTR     s0,[r0,#0x28]
00002c  4643              MOV      r3,r8
00002e  464a              MOV      r2,r9
000030  4651              MOV      r1,r10
000032  4628              MOV      r0,r5
000034  e9cd6700          STRD     r6,r7,[sp,#0]
000038  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f324InitENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::Init(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
00003c  b002              ADD      sp,sp,#8
00003e  4628              MOV      r0,r5
000040  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

                  |L12.68|
000044  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C2ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERNS0_11MemoryStackE                  ; Alternate entry point ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32__sub_object(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERNS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, Anki::Embedded::MemoryStack&)
;;;25         {
;;;26           PlanarTransformation_f32::PlanarTransformation_f32(const TransformType transformType, const Quadrilateral<f32> &initialCorners, const Array<f32> &initialHomography, MemoryStack &memory)
;;;27           {
;;;28             this->centerOffset = initialCorners.ComputeCenter<f32>();
;;;29     
;;;30             this->Init(transformType, initialCorners, initialHomography, centerOffset, memory);
;;;31           }
;;;32     
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4617              MOV      r7,r2
00000a  4689              MOV      r9,r1
00000c  1d00              ADDS     r0,r0,#4
00000e  9e0c              LDR      r6,[sp,#0x30]
000010  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
000014  3014              ADDS     r0,r0,#0x14
000016  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1Ev ; Anki::Embedded::Quadrilateral<float>::Quadrilateral()
00001a  ed9f0a12          VLDR     s0,|L13.100|
00001e  f1a00418          SUB      r4,r0,#0x18
000022  ed800a09          VSTR     s0,[r0,#0x24]
000026  f1000524          ADD      r5,r0,#0x24
00002a  ed800a0a          VSTR     s0,[r0,#0x28]
00002e  4639              MOV      r1,r7
000030  a802              ADD      r0,sp,#8
000032  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE13ComputeCenterIfEENS0_5PointIT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeCenter<float>() const
000036  ed9d0a02          VLDR     s0,[sp,#8]
00003a  f104003c          ADD      r0,r4,#0x3c
00003e  ed850a00          VSTR     s0,[r5,#0]
000042  ed9d0a03          VLDR     s0,[sp,#0xc]
000046  4643              MOV      r3,r8
000048  ed850a01          VSTR     s0,[r5,#4]
00004c  e9cd0600          STRD     r0,r6,[sp,#0]
000050  463a              MOV      r2,r7
000052  4649              MOV      r1,r9
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f324InitENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::Init(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
00005a  b005              ADD      sp,sp,#0x14
00005c  4620              MOV      r0,r4
00005e  e8bd83f0          POP      {r4-r9,pc}
                          ENDP

000062  0000              DCW      0x0000
                  |L13.100|
000064  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5PointIfEERNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C2ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5PointIfEERNS0_11MemoryStackE                  ; Alternate entry point ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32__sub_object(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5PointIfEERNS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
;;;54     
;;;55           PlanarTransformation_f32::PlanarTransformation_f32(const TransformType transformType, const Quadrilateral<f32> &initialCorners, const Point<f32> &centerOffset, MemoryStack &memory)
;;;56           {
;;;57             this->homography = Array<f32>();
;;;58     
;;;59             this->Init(transformType, initialCorners, homography, centerOffset, memory);
;;;60           }
;;;61     
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  461e              MOV      r6,r3
000008  4690              MOV      r8,r2
00000a  4689              MOV      r9,r1
00000c  1d00              ADDS     r0,r0,#4
00000e  9f0e              LDR      r7,[sp,#0x38]
000010  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
000014  3014              ADDS     r0,r0,#0x14
000016  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1Ev ; Anki::Embedded::Quadrilateral<float>::Quadrilateral()
00001a  ed9f0a11          VLDR     s0,|L14.96|
00001e  f1a00518          SUB      r5,r0,#0x18
000022  ed800a09          VSTR     s0,[r0,#0x24]
000026  ed800a0a          VSTR     s0,[r0,#0x28]
00002a  1d2c              ADDS     r4,r5,#4
00002c  a802              ADD      r0,sp,#8
00002e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
000032  6801              LDR      r1,[r0,#0]
000034  6021              STR      r1,[r4,#0]
000036  6841              LDR      r1,[r0,#4]
000038  6061              STR      r1,[r4,#4]
00003a  6881              LDR      r1,[r0,#8]
00003c  60a1              STR      r1,[r4,#8]
00003e  68c1              LDR      r1,[r0,#0xc]
000040  60e1              STR      r1,[r4,#0xc]
000042  6900              LDR      r0,[r0,#0x10]
000044  6120              STR      r0,[r4,#0x10]
000046  1d2b              ADDS     r3,r5,#4
000048  4642              MOV      r2,r8
00004a  4649              MOV      r1,r9
00004c  4628              MOV      r0,r5
00004e  e9cd6700          STRD     r6,r7,[sp,#0]
000052  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f324InitENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::Init(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
000056  b007              ADD      sp,sp,#0x1c
000058  4628              MOV      r0,r5
00005a  e8bd83f0          POP      {r4-r9,pc}
                          ENDP

00005e  0000              DCW      0x0000
                  |L14.96|
000060  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C2ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERNS0_11MemoryStackE                  ; Alternate entry point ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32__sub_object(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERNS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, Anki::Embedded::MemoryStack&)
;;;32     
;;;33           PlanarTransformation_f32::PlanarTransformation_f32(const TransformType transformType, const Quadrilateral<f32> &initialCorners, MemoryStack &memory)
;;;34           {
;;;35             this->homography = Array<f32>();
;;;36             this->centerOffset = initialCorners.ComputeCenter<f32>();
;;;37     
;;;38             this->Init(transformType, initialCorners, homography, centerOffset, memory);
;;;39           }
;;;40     
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  b08a              SUB      sp,sp,#0x28
000006  461e              MOV      r6,r3
000008  4617              MOV      r7,r2
00000a  4688              MOV      r8,r1
00000c  1d00              ADDS     r0,r0,#4
00000e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
000012  3014              ADDS     r0,r0,#0x14
000014  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1Ev ; Anki::Embedded::Quadrilateral<float>::Quadrilateral()
000018  ed9f0a18          VLDR     s0,|L15.124|
00001c  f1a00418          SUB      r4,r0,#0x18
000020  ed800a09          VSTR     s0,[r0,#0x24]
000024  ed800a0a          VSTR     s0,[r0,#0x28]
000028  1d25              ADDS     r5,r4,#4
00002a  a804              ADD      r0,sp,#0x10
00002c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
000030  6801              LDR      r1,[r0,#0]
000032  6029              STR      r1,[r5,#0]
000034  6841              LDR      r1,[r0,#4]
000036  6069              STR      r1,[r5,#4]
000038  6881              LDR      r1,[r0,#8]
00003a  60a9              STR      r1,[r5,#8]
00003c  68c1              LDR      r1,[r0,#0xc]
00003e  60e9              STR      r1,[r5,#0xc]
000040  6900              LDR      r0,[r0,#0x10]
000042  6128              STR      r0,[r5,#0x10]
000044  f104053c          ADD      r5,r4,#0x3c
000048  4639              MOV      r1,r7
00004a  a802              ADD      r0,sp,#8
00004c  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE13ComputeCenterIfEENS0_5PointIT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeCenter<float>() const
000050  ed9d0a02          VLDR     s0,[sp,#8]
000054  4628              MOV      r0,r5
000056  ed850a00          VSTR     s0,[r5,#0]
00005a  ed9d0a03          VLDR     s0,[sp,#0xc]
00005e  1d23              ADDS     r3,r4,#4
000060  ed850a01          VSTR     s0,[r5,#4]
000064  e9cd0600          STRD     r0,r6,[sp,#0]
000068  463a              MOV      r2,r7
00006a  4641              MOV      r1,r8
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f324InitENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::Init(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
000072  b00a              ADD      sp,sp,#0x28
000074  4620              MOV      r0,r4
000076  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

00007a  0000              DCW      0x0000
                  |L15.124|
00007c  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_5PointIfEERNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C2ENS1_13TransformTypeERKNS0_5PointIfEERNS0_11MemoryStackE                  ; Alternate entry point ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32__sub_object(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_5PointIfEERNS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
;;;61     
;;;62           PlanarTransformation_f32::PlanarTransformation_f32(const TransformType transformType, const Point<f32> &centerOffset, MemoryStack &memory)
;;;63           {
;;;64             this->homography = Array<f32>();
;;;65             this->initialCorners = Quadrilateral<f32>(Point<f32>(0.0f,0.0f), Point<f32>(0.0f,0.0f), Point<f32>(0.0f,0.0f), Point<f32>(0.0f,0.0f));
;;;66     
;;;67             this->Init(transformType, initialCorners, homography, centerOffset, memory);
;;;68           }
;;;69     
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  461e              MOV      r6,r3
000006  ed2d8b02          VPUSH    {d8}
00000a  b097              SUB      sp,sp,#0x5c
00000c  4617              MOV      r7,r2
00000e  4688              MOV      r8,r1
000010  1d00              ADDS     r0,r0,#4
000012  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
000016  3014              ADDS     r0,r0,#0x14
000018  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1Ev ; Anki::Embedded::Quadrilateral<float>::Quadrilateral()
00001c  ed9f8a29          VLDR     s16,|L16.196|
000020  f1a00418          SUB      r4,r0,#0x18
000024  ed808a09          VSTR     s16,[r0,#0x24]
000028  ed808a0a          VSTR     s16,[r0,#0x28]
00002c  1d25              ADDS     r5,r4,#4
00002e  a812              ADD      r0,sp,#0x48
000030  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
000034  6801              LDR      r1,[r0,#0]
000036  6029              STR      r1,[r5,#0]
000038  6841              LDR      r1,[r0,#4]
00003a  6069              STR      r1,[r5,#4]
00003c  6881              LDR      r1,[r0,#8]
00003e  60a9              STR      r1,[r5,#8]
000040  68c1              LDR      r1,[r0,#0xc]
000042  60e9              STR      r1,[r5,#0xc]
000044  6900              LDR      r0,[r0,#0x10]
000046  6128              STR      r0,[r5,#0x10]
000048  ed8d8a10          VSTR     s16,[sp,#0x40]
00004c  ed8d8a11          VSTR     s16,[sp,#0x44]
000050  ed8d8a0e          VSTR     s16,[sp,#0x38]
000054  ed8d8a0f          VSTR     s16,[sp,#0x3c]
000058  ed8d8a0c          VSTR     s16,[sp,#0x30]
00005c  ed8d8a0d          VSTR     s16,[sp,#0x34]
000060  ed8d8a0a          VSTR     s16,[sp,#0x28]
000064  a810              ADD      r0,sp,#0x40
000066  ed8d8a0b          VSTR     s16,[sp,#0x2c]
00006a  9000              STR      r0,[sp,#0]
00006c  f1040918          ADD      r9,r4,#0x18
000070  ab0e              ADD      r3,sp,#0x38
000072  aa0c              ADD      r2,sp,#0x30
000074  a90a              ADD      r1,sp,#0x28
000076  a802              ADD      r0,sp,#8
000078  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_ ; Anki::Embedded::Quadrilateral<float>::Quadrilateral(const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&)
00007c  4601              MOV      r1,r0
00007e  f04f0c00          MOV      r12,#0
                  |L16.130|
000082  eb0100cc          ADD      r0,r1,r12,LSL #3
000086  eb0905cc          ADD      r5,r9,r12,LSL #3
00008a  ed900a00          VLDR     s0,[r0,#0]
00008e  f10c0c01          ADD      r12,r12,#1
000092  ed850a00          VSTR     s0,[r5,#0]
000096  ed900a01          VLDR     s0,[r0,#4]
00009a  f1bc0f04          CMP      r12,#4
00009e  ed850a01          VSTR     s0,[r5,#4]
0000a2  dbee              BLT      |L16.130|
0000a4  e9cd7600          STRD     r7,r6,[sp,#0]
0000a8  1d23              ADDS     r3,r4,#4
0000aa  f1040218          ADD      r2,r4,#0x18
0000ae  4641              MOV      r1,r8
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f324InitENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::Init(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
0000b6  b017              ADD      sp,sp,#0x5c
0000b8  4620              MOV      r0,r4
0000ba  ecbd8b02          VPOP     {d8}
0000be  e8bd83f0          POP      {r4-r9,pc}
                          ENDP

0000c2  0000              DCW      0x0000
                  |L16.196|
0000c4  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C2ENS1_13TransformTypeERNS0_11MemoryStackE                  ; Alternate entry point ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32__sub_object(Anki::Embedded::Transformations::TransformType, Anki::Embedded::MemoryStack&)
                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERNS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32(Anki::Embedded::Transformations::TransformType, Anki::Embedded::MemoryStack&)
;;;40     
;;;41           PlanarTransformation_f32::PlanarTransformation_f32(const TransformType transformType, MemoryStack &memory)
;;;42           {
;;;43             this->homography = Array<f32>();
;;;44             this->initialCorners = Quadrilateral<f32>(Point<f32>(0.0f,0.0f), Point<f32>(0.0f,0.0f), Point<f32>(0.0f,0.0f), Point<f32>(0.0f,0.0f));
;;;45             this->centerOffset = initialCorners.ComputeCenter<f32>();
;;;46     
;;;47             this->Init(transformType, initialCorners, homography, centerOffset, memory);
;;;48           }
;;;49     
000000  b5f0              PUSH     {r4-r7,lr}
000002  4616              MOV      r6,r2
000004  ed2d8b02          VPUSH    {d8}
000008  b097              SUB      sp,sp,#0x5c
00000a  460f              MOV      r7,r1
00000c  1d00              ADDS     r0,r0,#4
00000e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
000012  3014              ADDS     r0,r0,#0x14
000014  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1Ev ; Anki::Embedded::Quadrilateral<float>::Quadrilateral()
000018  ed9f8a2f          VLDR     s16,|L17.216|
00001c  f1a00418          SUB      r4,r0,#0x18
000020  ed808a09          VSTR     s16,[r0,#0x24]
000024  ed808a0a          VSTR     s16,[r0,#0x28]
000028  1d25              ADDS     r5,r4,#4
00002a  a812              ADD      r0,sp,#0x48
00002c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
000030  6801              LDR      r1,[r0,#0]
000032  6029              STR      r1,[r5,#0]
000034  6841              LDR      r1,[r0,#4]
000036  6069              STR      r1,[r5,#4]
000038  6881              LDR      r1,[r0,#8]
00003a  60a9              STR      r1,[r5,#8]
00003c  68c1              LDR      r1,[r0,#0xc]
00003e  60e9              STR      r1,[r5,#0xc]
000040  6900              LDR      r0,[r0,#0x10]
000042  6128              STR      r0,[r5,#0x10]
000044  ed8d8a02          VSTR     s16,[sp,#8]
000048  ed8d8a03          VSTR     s16,[sp,#0xc]
00004c  ed8d8a10          VSTR     s16,[sp,#0x40]
000050  ed8d8a11          VSTR     s16,[sp,#0x44]
000054  ed8d8a0e          VSTR     s16,[sp,#0x38]
000058  ed8d8a0f          VSTR     s16,[sp,#0x3c]
00005c  ed8d8a0c          VSTR     s16,[sp,#0x30]
000060  a802              ADD      r0,sp,#8
000062  ed8d8a0d          VSTR     s16,[sp,#0x34]
000066  9000              STR      r0,[sp,#0]
000068  f1040518          ADD      r5,r4,#0x18
00006c  ab10              ADD      r3,sp,#0x40
00006e  aa0e              ADD      r2,sp,#0x38
000070  a90c              ADD      r1,sp,#0x30
000072  a804              ADD      r0,sp,#0x10
000074  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_ ; Anki::Embedded::Quadrilateral<float>::Quadrilateral(const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&)
000078  4601              MOV      r1,r0
00007a  2300              MOVS     r3,#0
                  |L17.124|
00007c  eb0100c3          ADD      r0,r1,r3,LSL #3
000080  eb050cc3          ADD      r12,r5,r3,LSL #3
000084  ed900a00          VLDR     s0,[r0,#0]
000088  1c5b              ADDS     r3,r3,#1
00008a  ed8c0a00          VSTR     s0,[r12,#0]
00008e  ed900a01          VLDR     s0,[r0,#4]
000092  2b04              CMP      r3,#4
000094  ed8c0a01          VSTR     s0,[r12,#4]
000098  dbf0              BLT      |L17.124|
00009a  f104053c          ADD      r5,r4,#0x3c
00009e  f1040118          ADD      r1,r4,#0x18
0000a2  a802              ADD      r0,sp,#8
0000a4  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE13ComputeCenterIfEENS0_5PointIT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeCenter<float>() const
0000a8  ed9d0a02          VLDR     s0,[sp,#8]
0000ac  4628              MOV      r0,r5
0000ae  ed850a00          VSTR     s0,[r5,#0]
0000b2  ed9d0a03          VLDR     s0,[sp,#0xc]
0000b6  1d23              ADDS     r3,r4,#4
0000b8  ed850a01          VSTR     s0,[r5,#4]
0000bc  e9cd0600          STRD     r0,r6,[sp,#0]
0000c0  f1040218          ADD      r2,r4,#0x18
0000c4  4639              MOV      r1,r7
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f324InitENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::Init(Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Point<float>&, Anki::Embedded::MemoryStack&)
0000cc  b017              ADD      sp,sp,#0x5c
0000ce  4620              MOV      r0,r4
0000d0  ecbd8b02          VPOP     {d8}
0000d4  bdf0              POP      {r4-r7,pc}
                          ENDP

0000d6  0000              DCW      0x0000
                  |L17.216|
0000d8  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1Ev||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C2Ev                  ; Alternate entry point ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32__sub_object()
                  _ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1Ev PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::PlanarTransformation_f32()
;;;93     
;;;94           PlanarTransformation_f32::PlanarTransformation_f32()
;;;95           {
;;;96             this->isValid = false;
;;;97           }
;;;98     
000000  b510              PUSH     {r4,lr}
000002  1d00              ADDS     r0,r0,#4
000004  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
000008  3014              ADDS     r0,r0,#0x14
00000a  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1Ev ; Anki::Embedded::Quadrilateral<float>::Quadrilateral()
00000e  f1a00118          SUB      r1,r0,#0x18
000012  3024              ADDS     r0,r0,#0x24
000014  ed9f0a04          VLDR     s0,|L18.40|
000018  ed800a00          VSTR     s0,[r0,#0]
00001c  ed800a01          VSTR     s0,[r0,#4]
000020  2000              MOVS     r0,#0
000022  7008              STRB     r0,[r1,#0]
000024  4608              MOV      r0,r1
000026  bd10              POP      {r4,pc}
                          ENDP

                  |L18.40|
000028  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15Transformations25ComputeHomographyFromQuadERKNS0_13QuadrilateralIfEERNS0_5ArrayIfEERbNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations25ComputeHomographyFromQuadERKNS0_13QuadrilateralIfEERNS0_5ArrayIfEERbNS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::ComputeHomographyFromQuad(const Anki::Embedded::Quadrilateral<float>&, Anki::Embedded::Array<float>&, bool&, Anki::Embedded::MemoryStack)
;;;697    
;;;698          Result ComputeHomographyFromQuad(const Quadrilateral<f32> &quad, Array<f32> &homography, bool &numericalFailure, MemoryStack scratch)
000000  b5f0              PUSH     {r4-r7,lr}
;;;699          {
000002  b09b              SUB      sp,sp,#0x6c
;;;700            Quadrilateral<f32> originalQuad(
000004  eeb70a00          VMOV.F32 s0,#1.00000000
000008  ed8d0a18          VSTR     s0,[sp,#0x60]
00000c  ed8d0a19          VSTR     s0,[sp,#0x64]
000010  eddf0a14          VLDR     s1,|L19.100|
000014  ed8d0a16          VSTR     s0,[sp,#0x58]
000018  edcd0a17          VSTR     s1,[sp,#0x5c]
00001c  edcd0a14          VSTR     s1,[sp,#0x50]
000020  ed8d0a15          VSTR     s0,[sp,#0x54]
000024  edcd0a12          VSTR     s1,[sp,#0x48]
000028  461c              MOV      r4,r3                 ;699
00002a  4615              MOV      r5,r2                 ;699
00002c  460e              MOV      r6,r1                 ;699
00002e  4607              MOV      r7,r0                 ;699
000030  f10d0c60          ADD      r12,sp,#0x60
000034  edcd0a13          VSTR     s1,[sp,#0x4c]
000038  ab16              ADD      r3,sp,#0x58
00003a  aa14              ADD      r2,sp,#0x50
00003c  a912              ADD      r1,sp,#0x48
00003e  a802              ADD      r0,sp,#8
000040  f8cdc000          STR      r12,[sp,#0]
000044  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_ ; Anki::Embedded::Quadrilateral<float>::Quadrilateral(const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&)
;;;701              Point<f32>(0,0),
;;;702              Point<f32>(0,1),
;;;703              Point<f32>(1,0),
;;;704              Point<f32>(1,1));
;;;705    
;;;706            return ComputeHomographyFromQuads(originalQuad, quad, homography, numericalFailure, scratch);
000048  4621              MOV      r1,r4
00004a  a80a              ADD      r0,sp,#0x28
00004c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000050  9000              STR      r0,[sp,#0]
000052  462b              MOV      r3,r5
000054  4632              MOV      r2,r6
000056  4639              MOV      r1,r7
000058  a802              ADD      r0,sp,#8
00005a  f7fffffe          BL       _ZN4Anki8Embedded15Transformations26ComputeHomographyFromQuadsERKNS0_13QuadrilateralIfEES5_RNS0_5ArrayIfEERbNS0_11MemoryStackE ; Anki::Embedded::Transformations::ComputeHomographyFromQuads(const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Quadrilateral<float>&, Anki::Embedded::Array<float>&, bool&, Anki::Embedded::MemoryStack)
;;;707          }
00005e  b01b              ADD      sp,sp,#0x6c
000060  bdf0              POP      {r4-r7,pc}
;;;708    
                          ENDP

000062  0000              DCW      0x0000
                  |L19.100|
000064  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15Transformations25ComputeHomographyFromQuadERKNS0_13QuadrilateralIsEERNS0_5ArrayIfEERbNS0_11MemoryStackE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15Transformations25ComputeHomographyFromQuadERKNS0_13QuadrilateralIsEERNS0_5ArrayIfEERbNS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::ComputeHomographyFromQuad(const Anki::Embedded::Quadrilateral<short>&, Anki::Embedded::Array<float>&, bool&, Anki::Embedded::MemoryStack)
;;;689    
;;;690          Result ComputeHomographyFromQuad(const Quadrilateral<s16> &quad, Array<f32> &homography, bool &numericalFailure, MemoryStack scratch)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;691          {
000004  b090              SUB      sp,sp,#0x40
000006  4605              MOV      r5,r0
000008  461e              MOV      r6,r3
00000a  4617              MOV      r7,r2
00000c  4688              MOV      r8,r1
;;;692            Quadrilateral<f32> quadF32;
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1Ev ; Anki::Embedded::Quadrilateral<float>::Quadrilateral()
;;;693            quadF32.SetCast<s16>(quad);
000014  466a              MOV      r2,sp
000016  2000              MOVS     r0,#0
                  |L20.24|
000018  eb050380          ADD      r3,r5,r0,LSL #2
00001c  eb020cc0          ADD      r12,r2,r0,LSL #3
000020  f9b34000          LDRSH    r4,[r3,#0]
000024  1c40              ADDS     r0,r0,#1
000026  ee004a10          VMOV     s0,r4
00002a  2804              CMP      r0,#4
00002c  eeb80ac0          VCVT.F32.S32 s0,s0
000030  ed8c0a00          VSTR     s0,[r12,#0]
000034  f9b31002          LDRSH    r1,[r3,#2]
000038  ee001a10          VMOV     s0,r1
00003c  eeb80ac0          VCVT.F32.S32 s0,s0
000040  ed8c0a01          VSTR     s0,[r12,#4]
000044  dbe8              BLT      |L20.24|
;;;694    
;;;695            return ComputeHomographyFromQuad(quadF32, homography, numericalFailure, scratch);
000046  4631              MOV      r1,r6
000048  a808              ADD      r0,sp,#0x20
00004a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00004e  4603              MOV      r3,r0
000050  463a              MOV      r2,r7
000052  4641              MOV      r1,r8
000054  4668              MOV      r0,sp
000056  f7fffffe          BL       _ZN4Anki8Embedded15Transformations25ComputeHomographyFromQuadERKNS0_13QuadrilateralIfEERNS0_5ArrayIfEERbNS0_11MemoryStackE ; Anki::Embedded::Transformations::ComputeHomographyFromQuad(const Anki::Embedded::Quadrilateral<float>&, Anki::Embedded::Array<float>&, bool&, Anki::Embedded::MemoryStack)
;;;696          }
00005a  b010              ADD      sp,sp,#0x40
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;697    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded15Transformations26ComputeHomographyFromQuadsERKNS0_13QuadrilateralIfEES5_RNS0_5ArrayIfEERbNS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15Transformations26ComputeHomographyFromQuadsERKNS0_13QuadrilateralIfEES5_RNS0_5ArrayIfEERbNS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::ComputeHomographyFromQuads(const Anki::Embedded::Quadrilateral<float>&, const Anki::Embedded::Quadrilateral<float>&, Anki::Embedded::Array<float>&, bool&, Anki::Embedded::MemoryStack)
;;;708    
;;;709          Result ComputeHomographyFromQuads(const Quadrilateral<f32> &originalQuad, const Quadrilateral<f32> &transformedQuad, Array<f32> &homography, bool &numericalFailure, MemoryStack scratch)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;710          {
000004  b0a5              SUB      sp,sp,#0x94
000006  4680              MOV      r8,r0
000008  469a              MOV      r10,r3
00000a  4616              MOV      r6,r2
00000c  460f              MOV      r7,r1
00000e  4610              MOV      r0,r2
000010  f8dd90b8          LDR      r9,[sp,#0xb8]
000014  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000018  2800              CMP      r0,#0
;;;711            Result lastResult;
;;;712    
;;;713            AnkiConditionalErrorAndReturnValue(AreValid(homography, scratch),
00001a  d063              BEQ      |L21.228|
00001c  4648              MOV      r0,r9
00001e  f7fffffe          BL       _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
000022  2800              CMP      r0,#0
000024  d05e              BEQ      |L21.228|
;;;714              RESULT_FAIL_INVALID_OBJECT, "ComputeHomographyFromQuads", "Invalid objects");
;;;715    
;;;716            if(!originalQuad.IsConvex() || !transformedQuad.IsConvex()) {
000026  4640              MOV      r0,r8
000028  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE8IsConvexEv ; Anki::Embedded::Quadrilateral<float>::IsConvex() const
00002c  2800              CMP      r0,#0
00002e  d069              BEQ      |L21.260|
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE8IsConvexEv ; Anki::Embedded::Quadrilateral<float>::IsConvex() const
000036  2800              CMP      r0,#0
000038  d064              BEQ      |L21.260|
;;;717              AnkiWarn("ComputeHomographyFromQuads", "Quad is not convex");
;;;718    
;;;719              homography.SetZero();
;;;720              homography[0][0] = 1;
;;;721              homography[1][1] = 1;
;;;722              homography[2][2] = 1;
;;;723    
;;;724              numericalFailure = true;
;;;725    
;;;726              return RESULT_OK;
;;;727            }
;;;728    
;;;729            FixedLengthList<Point<f32> > originalPoints(4, scratch);
00003a  2300              MOVS     r3,#0
00003c  461a              MOV      r2,r3
00003e  2101              MOVS     r1,#1
000040  a823              ADD      r0,sp,#0x8c
000042  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000046  6803              LDR      r3,[r0,#0]
000048  464a              MOV      r2,r9
00004a  2104              MOVS     r1,#4
00004c  a802              ADD      r0,sp,#8
00004e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;730            FixedLengthList<Point<f32> > transformedPoints(4, scratch);
000052  2300              MOVS     r3,#0
000054  461a              MOV      r2,r3
000056  2101              MOVS     r1,#1
000058  a824              ADD      r0,sp,#0x90
00005a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00005e  6803              LDR      r3,[r0,#0]
000060  464a              MOV      r2,r9
000062  2104              MOVS     r1,#4
000064  a80f              ADD      r0,sp,#0x3c
000066  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;731    
;;;732            for(s32 i=0; i<4; i++) {
00006a  2400              MOVS     r4,#0
                  |L21.108|
;;;733              originalPoints.PushBack(originalQuad[i]);
00006c  a802              ADD      r0,sp,#8
00006e  eb080bc4          ADD      r11,r8,r4,LSL #3
000072  9d05              LDR      r5,[sp,#0x14]
000074  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::get_maximumSize() const
000078  42a8              CMP      r0,r5
00007a  dd0c              BLE      |L21.150|
00007c  980e              LDR      r0,[sp,#0x38]
00007e  ed9b0a00          VLDR     s0,[r11,#0]
000082  eb0000c5          ADD      r0,r0,r5,LSL #3
000086  ed800a00          VSTR     s0,[r0,#0]
00008a  ed9b0a01          VLDR     s0,[r11,#4]
00008e  ed800a01          VSTR     s0,[r0,#4]
000092  1c68              ADDS     r0,r5,#1
000094  9005              STR      r0,[sp,#0x14]
                  |L21.150|
;;;734              transformedPoints.PushBack(transformedQuad[i]);
000096  a80f              ADD      r0,sp,#0x3c
000098  eb070bc4          ADD      r11,r7,r4,LSL #3
00009c  9d12              LDR      r5,[sp,#0x48]
00009e  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::get_maximumSize() const
0000a2  42a8              CMP      r0,r5
0000a4  dd0c              BLE      |L21.192|
0000a6  981b              LDR      r0,[sp,#0x6c]
0000a8  ed9b0a00          VLDR     s0,[r11,#0]
0000ac  eb0000c5          ADD      r0,r0,r5,LSL #3
0000b0  ed800a00          VSTR     s0,[r0,#0]
0000b4  ed9b0a01          VLDR     s0,[r11,#4]
0000b8  ed800a01          VSTR     s0,[r0,#4]
0000bc  1c68              ADDS     r0,r5,#1
0000be  9012              STR      r0,[sp,#0x48]
                  |L21.192|
0000c0  1c64              ADDS     r4,r4,#1              ;732
0000c2  2c04              CMP      r4,#4                 ;732
0000c4  dbd2              BLT      |L21.108|
;;;735            }
;;;736    
;;;737            if((lastResult = Matrix::EstimateHomography(originalPoints, transformedPoints, homography, numericalFailure, scratch)) != RESULT_OK)
0000c6  4649              MOV      r1,r9
0000c8  a81c              ADD      r0,sp,#0x70
0000ca  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0000ce  9000              STR      r0,[sp,#0]
0000d0  4653              MOV      r3,r10
0000d2  4632              MOV      r2,r6
0000d4  a90f              ADD      r1,sp,#0x3c
0000d6  a802              ADD      r0,sp,#8
0000d8  f7fffffe          BL       _ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE ; Anki::Embedded::Matrix::EstimateHomography<float>(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, Anki::Embedded::Array<T1>&, bool&, Anki::Embedded::MemoryStack)
;;;738              return lastResult;
;;;739    
;;;740            return RESULT_OK;
;;;741          } // Result ComputeHomographyFromQuad(FixedLengthList<Quadrilateral<s16> > quads, FixedLengthList<Array<f32> > &homographies, MemoryStack scratch)
0000dc  b025              ADD      sp,sp,#0x94
0000de  2800              CMP      r0,#0                 ;737
0000e0  e8bd8ff0          POP      {r4-r11,pc}
                  |L21.228|
0000e4  f24021c9          MOV      r1,#0x2c9             ;713
0000e8  4817              LDR      r0,|L21.328|
0000ea  e9cd0100          STRD     r0,r1,[sp,#0]         ;713
0000ee  a317              ADR      r3,|L21.332|
0000f0  a223              ADR      r2,|L21.384|
0000f2  a127              ADR      r1,|L21.400|
0000f4  2005              MOVS     r0,#5                 ;713
0000f6  f7fffffe          BL       _Anki_Log
0000fa  b025              ADD      sp,sp,#0x94
0000fc  f04f6080          MOV      r0,#0x4000000         ;713
000100  e8bd8ff0          POP      {r4-r11,pc}
                  |L21.260|
000104  4630              MOV      r0,r6                 ;719
000106  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
00010a  68b2              LDR      r2,[r6,#8]            ;719
00010c  6931              LDR      r1,[r6,#0x10]         ;719
00010e  2000              MOVS     r0,#0                 ;720
000110  fb001002          MLA      r0,r0,r2,r1           ;720
000114  eeb70a00          VMOV.F32 s0,#1.00000000        ;720
000118  ed800a00          VSTR     s0,[r0,#0]            ;720
00011c  68b2              LDR      r2,[r6,#8]            ;720
00011e  6931              LDR      r1,[r6,#0x10]         ;720
000120  2001              MOVS     r0,#1                 ;721
000122  fb001002          MLA      r0,r0,r2,r1           ;721
000126  ed800a01          VSTR     s0,[r0,#4]            ;721
00012a  68b2              LDR      r2,[r6,#8]            ;721
00012c  6931              LDR      r1,[r6,#0x10]         ;721
00012e  2002              MOVS     r0,#2                 ;722
000130  fb001002          MLA      r0,r0,r2,r1           ;722
000134  ed800a02          VSTR     s0,[r0,#8]            ;722
000138  2001              MOVS     r0,#1                 ;724
00013a  f88a0000          STRB     r0,[r10,#0]           ;724
00013e  b025              ADD      sp,sp,#0x94
000140  2000              MOVS     r0,#0                 ;726
000142  e8bd8ff0          POP      {r4-r11,pc}
;;;742    
                          ENDP

000146  0000              DCW      0x0000
                  |L21.328|
                          DCD      ||.constdata||+0x990
                  |L21.332|
00014c  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\transformations.cpp",0
000150  6f726574
000154  6563685c
000158  76697369
00015c  6f6e5c72
000160  6f626f74
000164  5c737263
000168  5c747261
00016c  6e73666f
000170  726d6174
000174  696f6e73
000178  2e637070
00017c  00      
00017d  00                DCB      0
00017e  00                DCB      0
00017f  00                DCB      0
                  |L21.384|
000180  496e7661          DCB      "Invalid objects",0
000184  6c696420
000188  6f626a65
00018c  63747300
                  |L21.400|
000190  436f6d70          DCB      "ComputeHomographyFromQuads",0
000194  75746548
000198  6f6d6f67
00019c  72617068
0001a0  7946726f
0001a4  6d517561
0001a8  647300  
0001ab  00                DCB      0

                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3212SerializeRawEPKcPPvRi||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3212SerializeRawEPKcPPvRi PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::SerializeRaw(const char*, void**, int&) const
;;;394    
;;;395          Result PlanarTransformation_f32::SerializeRaw(const char *objectName, void ** buffer, s32 &bufferLength) const
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;396          {
000004  4607              MOV      r7,r0
000006  b085              SUB      sp,sp,#0x14
000008  461d              MOV      r5,r3
00000a  4614              MOV      r4,r2
;;;397            if(SerializedBuffer::SerializeDescriptionStrings("PlanarTransformation_f32", objectName, buffer, bufferLength) != RESULT_OK)
00000c  a0a1              ADR      r0,|L22.660|
00000e  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeDescriptionStrings(const char*, const char*, void**, int&)
000012  2800              CMP      r0,#0
000014  f040813a          BNE.W    |L22.652|
;;;398              return RESULT_FAIL;
;;;399    
;;;400            if(SerializedBuffer::SerializeRawBasicType<bool>("isValid", this->isValid, buffer, bufferLength) != RESULT_OK)
000018  462b              MOV      r3,r5
00001a  4622              MOV      r2,r4
00001c  4639              MOV      r1,r7
00001e  a0a4              ADR      r0,|L22.688|
000020  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIbEENS_6ResultEPKcRKT_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeRawBasicType<bool>(const char*, const T1&, void**, int&)
000024  2800              CMP      r0,#0
000026  f0408131          BNE.W    |L22.652|
;;;401              return RESULT_FAIL;
;;;402    
;;;403            if(SerializedBuffer::SerializeRawBasicType<s32>("transformType", this->transformType, buffer, bufferLength) != RESULT_OK)
00002a  8878              LDRH     r0,[r7,#2]
00002c  9003              STR      r0,[sp,#0xc]
00002e  a1a2              ADR      r1,|L22.696|
000030  f10d080c          ADD      r8,sp,#0xc
000034  2601              MOVS     r6,#1
000036  462b              MOV      r3,r5
000038  4622              MOV      r2,r4
00003a  a0a3              ADR      r0,|L22.712|
00003c  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeDescriptionStrings(const char*, const char*, void**, int&)
000040  2800              CMP      r0,#0
000042  f0408123          BNE.W    |L22.652|
000046  6828              LDR      r0,[r5,#0]
000048  2808              CMP      r0,#8
00004a  db0c              BLT      |L22.102|
00004c  6821              LDR      r1,[r4,#0]
00004e  48a3              LDR      r0,|L22.732|
000050  6008              STR      r0,[r1,#0]
000052  6820              LDR      r0,[r4,#0]
000054  6046              STR      r6,[r0,#4]
000056  6820              LDR      r0,[r4,#0]
000058  f1000108          ADD      r1,r0,#8
00005c  6021              STR      r1,[r4,#0]
00005e  6828              LDR      r0,[r5,#0]
000060  f1a00108          SUB      r1,r0,#8
000064  6029              STR      r1,[r5,#0]
                  |L22.102|
000066  2204              MOVS     r2,#4
000068  4641              MOV      r1,r8
00006a  6820              LDR      r0,[r4,#0]
00006c  f7fffffe          BL       __aeabi_memcpy
000070  6820              LDR      r0,[r4,#0]
000072  1d01              ADDS     r1,r0,#4
000074  6021              STR      r1,[r4,#0]
000076  6828              LDR      r0,[r5,#0]
000078  1f01              SUBS     r1,r0,#4
;;;404              return RESULT_FAIL;
;;;405    
;;;406            if(SerializedBuffer::SerializeRawArray<f32>("homography", this->homography, buffer, bufferLength) != RESULT_OK)
00007a  f20f2964          ADR      r9,|L22.736|
00007e  1d3e              ADDS     r6,r7,#4
000080  4630              MOV      r0,r6
000082  6029              STR      r1,[r5,#0]
000084  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000088  f8df8260          LDR      r8,|L22.748|
00008c  2800              CMP      r0,#0
00008e  d017              BEQ      |L22.192|
000090  2100              MOVS     r1,#0
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000098  68b1              LDR      r1,[r6,#8]
00009a  2218              MOVS     r2,#0x18
00009c  fb002001          MLA      r0,r0,r1,r2
0000a0  6829              LDR      r1,[r5,#0]
0000a2  4281              CMP      r1,r0
0000a4  da17              BGE      |L22.214|
0000a6  21a4              MOVS     r1,#0xa4
0000a8  f8cd8000          STR      r8,[sp,#0]
0000ac  e9cd1001          STRD     r1,r0,[sp,#4]
0000b0  a38f              ADR      r3,|L22.752|
0000b2  a29e              ADR      r2,|L22.812|
0000b4  a1a5              ADR      r1,|L22.844|
0000b6  2005              MOVS     r0,#5
0000b8  f7fffffe          BL       _Anki_Log
0000bc  f000b8e6          B.W      |L22.652|
                  |L22.192|
0000c0  209c              MOVS     r0,#0x9c
0000c2  e9cd8000          STRD     r8,r0,[sp,#0]
0000c6  a38a              ADR      r3,|L22.752|
0000c8  a2a9              ADR      r2,|L22.880|
0000ca  a1b0              ADR      r1,|L22.908|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b8db          B.W      |L22.652|
                  |L22.214|
0000d6  462b              MOV      r3,r5
0000d8  4622              MOV      r2,r4
0000da  4649              MOV      r1,r9
0000dc  a0b6              ADR      r0,|L22.952|
0000de  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeDescriptionStrings(const char*, const char*, void**, int&)
0000e2  2800              CMP      r0,#0
0000e4  f04080d2          BNE.W    |L22.652|
0000e8  6828              LDR      r0,[r5,#0]
0000ea  2818              CMP      r0,#0x18
0000ec  db35              BLT      |L22.346|
0000ee  4630              MOV      r0,r6
0000f0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
0000f4  2800              CMP      r0,#0
0000f6  d06d              BEQ      |L22.468|
0000f8  2100              MOVS     r1,#0
0000fa  4630              MOV      r0,r6
0000fc  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000100  4680              MOV      r8,r0
000102  2101              MOVS     r1,#1
000104  4630              MOV      r0,r6
000106  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00010a  6829              LDR      r1,[r5,#0]
00010c  fb08f000          MUL      r0,r8,r0
000110  2908              CMP      r1,#8
000112  db04              BLT      |L22.286|
000114  6822              LDR      r2,[r4,#0]
000116  49aa              LDR      r1,|L22.960|
000118  6011              STR      r1,[r2,#0]
00011a  6821              LDR      r1,[r4,#0]
00011c  6048              STR      r0,[r1,#4]
                  |L22.286|
00011e  2100              MOVS     r1,#0
000120  4630              MOV      r0,r6
000122  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000126  6821              LDR      r1,[r4,#0]
000128  6088              STR      r0,[r1,#8]
00012a  2101              MOVS     r1,#1
00012c  4630              MOV      r0,r6
00012e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000132  6821              LDR      r1,[r4,#0]
000134  60c8              STR      r0,[r1,#0xc]
000136  6821              LDR      r1,[r4,#0]
000138  68b0              LDR      r0,[r6,#8]
00013a  6108              STR      r0,[r1,#0x10]
00013c  68f0              LDR      r0,[r6,#0xc]
00013e  9002              STR      r0,[sp,#8]
000140  a802              ADD      r0,sp,#8
000142  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer12get_rawFlagsEv ; Anki::Embedded::Flags::Buffer::get_rawFlags() const
000146  6821              LDR      r1,[r4,#0]
000148  6148              STR      r0,[r1,#0x14]
00014a  6820              LDR      r0,[r4,#0]
00014c  f1000118          ADD      r1,r0,#0x18
000150  6021              STR      r1,[r4,#0]
000152  6828              LDR      r0,[r5,#0]
000154  f1a00118          SUB      r1,r0,#0x18
000158  6029              STR      r1,[r5,#0]
                  |L22.346|
00015a  2100              MOVS     r1,#0
00015c  4630              MOV      r0,r6
00015e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000162  4680              MOV      r8,r0
000164  2101              MOVS     r1,#1
000166  4630              MOV      r0,r6
000168  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00016c  fb08f000          MUL      r0,r8,r0
000170  2800              CMP      r0,#0
000172  dd23              BLE      |L22.444|
000174  2100              MOVS     r1,#0
000176  4630              MOV      r0,r6
000178  f8d68008          LDR      r8,[r6,#8]
00017c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000180  fb08f200          MUL      r2,r8,r0
000184  68b3              LDR      r3,[r6,#8]
000186  6931              LDR      r1,[r6,#0x10]
000188  2000              MOVS     r0,#0
00018a  fb001103          MLA      r1,r0,r3,r1
00018e  6820              LDR      r0,[r4,#0]
000190  f7fffffe          BL       __aeabi_memcpy
000194  2100              MOVS     r1,#0
000196  4630              MOV      r0,r6
000198  f8d68008          LDR      r8,[r6,#8]
00019c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0001a0  6821              LDR      r1,[r4,#0]
0001a2  fb081100          MLA      r1,r8,r0,r1
0001a6  6021              STR      r1,[r4,#0]
0001a8  2100              MOVS     r1,#0
0001aa  4630              MOV      r0,r6
0001ac  f8d68008          LDR      r8,[r6,#8]
0001b0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0001b4  6829              LDR      r1,[r5,#0]
0001b6  fb081110          MLS      r1,r8,r0,r1
0001ba  6029              STR      r1,[r5,#0]
                  |L22.444|
;;;407              return RESULT_FAIL;
;;;408    
;;;409            if(SerializedBuffer::SerializeRawBasicType<Quadrilateral<f32> >("initialCorners", this->initialCorners, buffer, bufferLength) != RESULT_OK)
0001bc  a181              ADR      r1,|L22.964|
0001be  f1070818          ADD      r8,r7,#0x18
0001c2  2601              MOVS     r6,#1
0001c4  462b              MOV      r3,r5
0001c6  4622              MOV      r2,r4
0001c8  a03f              ADR      r0,|L22.712|
0001ca  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeDescriptionStrings(const char*, const char*, void**, int&)
0001ce  2800              CMP      r0,#0
0001d0  d15c              BNE      |L22.652|
0001d2  e00a              B        |L22.490|
                  |L22.468|
0001d4  214c              MOVS     r1,#0x4c
0001d6  487f              LDR      r0,|L22.980|
0001d8  e9cd0100          STRD     r0,r1,[sp,#0]
0001dc  a344              ADR      r3,|L22.752|
0001de  a27e              ADR      r2,|L22.984|
0001e0  a182              ADR      r1,|L22.1004|
0001e2  2005              MOVS     r0,#5
0001e4  f7fffffe          BL       _Anki_Log
0001e8  e7b7              B        |L22.346|
                  |L22.490|
0001ea  6828              LDR      r0,[r5,#0]
0001ec  2808              CMP      r0,#8
0001ee  db0d              BLT      |L22.524|
0001f0  6821              LDR      r1,[r4,#0]
0001f2  f44f1000          MOV      r0,#0x200000
0001f6  6008              STR      r0,[r1,#0]
0001f8  6820              LDR      r0,[r4,#0]
0001fa  6046              STR      r6,[r0,#4]
0001fc  6820              LDR      r0,[r4,#0]
0001fe  f1000108          ADD      r1,r0,#8
000202  6021              STR      r1,[r4,#0]
000204  6828              LDR      r0,[r5,#0]
000206  f1a00108          SUB      r1,r0,#8
00020a  6029              STR      r1,[r5,#0]
                  |L22.524|
00020c  2220              MOVS     r2,#0x20
00020e  4641              MOV      r1,r8
000210  6820              LDR      r0,[r4,#0]
000212  f7fffffe          BL       __aeabi_memcpy
000216  6820              LDR      r0,[r4,#0]
;;;410              return RESULT_FAIL;
;;;411    
;;;412            if(SerializedBuffer::SerializeRawBasicType<Point<f32> >("centerOffset", this->centerOffset, buffer, bufferLength) != RESULT_OK)
000218  f107083c          ADD      r8,r7,#0x3c
00021c  f1000120          ADD      r1,r0,#0x20
000220  6021              STR      r1,[r4,#0]
000222  6828              LDR      r0,[r5,#0]
000224  2601              MOVS     r6,#1
000226  f1a00120          SUB      r1,r0,#0x20
00022a  6029              STR      r1,[r5,#0]
00022c  a177              ADR      r1,|L22.1036|
00022e  462b              MOV      r3,r5
000230  4622              MOV      r2,r4
000232  a025              ADR      r0,|L22.712|
000234  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeDescriptionStrings(const char*, const char*, void**, int&)
000238  bb40              CBNZ     r0,|L22.652|
00023a  6828              LDR      r0,[r5,#0]
00023c  2808              CMP      r0,#8
00023e  db0c              BLT      |L22.602|
000240  6821              LDR      r1,[r4,#0]
000242  04f0              LSLS     r0,r6,#19
000244  6008              STR      r0,[r1,#0]
000246  6820              LDR      r0,[r4,#0]
000248  6046              STR      r6,[r0,#4]
00024a  6820              LDR      r0,[r4,#0]
00024c  f1000108          ADD      r1,r0,#8
000250  6021              STR      r1,[r4,#0]
000252  6828              LDR      r0,[r5,#0]
000254  f1a00108          SUB      r1,r0,#8
000258  6029              STR      r1,[r5,#0]
                  |L22.602|
00025a  2208              MOVS     r2,#8
00025c  4641              MOV      r1,r8
00025e  6820              LDR      r0,[r4,#0]
000260  f7fffffe          BL       __aeabi_memcpy
000264  6820              LDR      r0,[r4,#0]
;;;413              return RESULT_FAIL;
;;;414    
;;;415            if(SerializedBuffer::SerializeRawBasicType<bool>("initialPointsAreZeroCentered", this->initialPointsAreZeroCentered, buffer, bufferLength) != RESULT_OK)
000266  462b              MOV      r3,r5
000268  f1000108          ADD      r1,r0,#8
00026c  6021              STR      r1,[r4,#0]
00026e  6828              LDR      r0,[r5,#0]
000270  4622              MOV      r2,r4
000272  f1a00108          SUB      r1,r0,#8
000276  6029              STR      r1,[r5,#0]
000278  f1070138          ADD      r1,r7,#0x38
00027c  a067              ADR      r0,|L22.1052|
00027e  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIbEENS_6ResultEPKcRKT_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeRawBasicType<bool>(const char*, const T1&, void**, int&)
000282  2800              CMP      r0,#0
;;;416              return RESULT_FAIL;
;;;417    
;;;418            return RESULT_OK;
;;;419          }
000284  bf04              ITT      EQ
000286  b005              ADDEQ    sp,sp,#0x14
000288  e8bd83f0          POPEQ    {r4-r9,pc}
                  |L22.652|
00028c  2001              MOVS     r0,#1                 ;416
00028e  b005              ADD      sp,sp,#0x14
000290  e8bd83f0          POP      {r4-r9,pc}
;;;420    
                          ENDP

                  |L22.660|
000294  506c616e          DCB      "PlanarTransformation_f32",0
000298  61725472
00029c  616e7366
0002a0  6f726d61
0002a4  74696f6e
0002a8  5f663332
0002ac  00      
0002ad  00                DCB      0
0002ae  00                DCB      0
0002af  00                DCB      0
                  |L22.688|
0002b0  69735661          DCB      "isValid",0
0002b4  6c696400
                  |L22.696|
0002b8  7472616e          DCB      "transformType",0
0002bc  73666f72
0002c0  6d547970
0002c4  6500    
0002c6  00                DCB      0
0002c7  00                DCB      0
                  |L22.712|
0002c8  42617369          DCB      "Basic Type Buffer",0
0002cc  63205479
0002d0  70652042
0002d4  75666665
0002d8  7200    
0002da  00                DCB      0
0002db  00                DCB      0
                  |L22.732|
                          DCD      0x00040007
                  |L22.736|
0002e0  686f6d6f          DCB      "homography",0
0002e4  67726170
0002e8  687900  
0002eb  00                DCB      0
                  |L22.748|
                          DCD      _ZZN4Anki8Embedded16SerializedBuffer17SerializeRawArrayIfEENS_6ResultEPKcRKNS0_5ArrayIT_EEPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::SerializeRawArray<float>(const char*, const Anki::Embedded::Array<T1>&, void**, int&)::__PRETTY_FUNCTION__
                  |L22.752|
0002f0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/serial"
0002f4  6f726574
0002f8  6563685c
0002fc  636f6d6d
000300  6f6e5c69
000304  6e636c75
000308  64655c61
00030c  6e6b692f
000310  636f6d6d
000314  6f6e2f72
000318  6f626f74
00031c  2f736572
000320  69616c  
000323  697a652e          DCB      "ize.h",0
000327  6800    
000329  00                DCB      0
00032a  00                DCB      0
00032b  00                DCB      0
                  |L22.812|
00032c  62756666          DCB      "buffer needs at least %d bytes",0
000330  6572206e
000334  65656473
000338  20617420
00033c  6c656173
000340  74202564
000344  20627974
000348  657300  
00034b  00                DCB      0
                  |L22.844|
00034c  53657269          DCB      "SerializedBuffer::SerializeRawArray",0
000350  616c697a
000354  65644275
000358  66666572
00035c  3a3a5365
000360  7269616c
000364  697a6552
000368  61774172
00036c  72617900
                  |L22.880|
000370  696e2041          DCB      "in ArraySlice is not Valid",0
000374  72726179
000378  536c6963
00037c  65206973
000380  206e6f74
000384  2056616c
000388  696400  
00038b  00                DCB      0
                  |L22.908|
00038c  53657269          DCB      "SerializedBuffer::SerializeRawArraySlice",0
000390  616c697a
000394  65644275
000398  66666572
00039c  3a3a5365
0003a0  7269616c
0003a4  697a6552
0003a8  61774172
0003ac  72617953
0003b0  6c696365
0003b4  00      
0003b5  00                DCB      0
0003b6  00                DCB      0
0003b7  00                DCB      0
                  |L22.952|
0003b8  41727261          DCB      "Array",0
0003bc  7900    
0003be  00                DCB      0
0003bf  00                DCB      0
                  |L22.960|
                          DCD      0x0004000d
                  |L22.964|
0003c4  696e6974          DCB      "initialCorners",0
0003c8  69616c43
0003cc  6f726e65
0003d0  727300  
0003d3  00                DCB      0
                  |L22.980|
                          DCD      _ZZN4Anki8Embedded16SerializedBuffer12EncodedArray9SerializeIfEENS_6ResultEbRKNS0_5ArrayIT_EEPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::EncodedArray::Serialize<float>(bool, const Anki::Embedded::Array<T1>&, void**, int&)::__PRETTY_FUNCTION__
                  |L22.984|
0003d8  696e2041          DCB      "in Array is invalid",0
0003dc  72726179
0003e0  20697320
0003e4  696e7661
0003e8  6c696400
                  |L22.1004|
0003ec  53657269          DCB      "SerializedBuffer::EncodedArray",0
0003f0  616c697a
0003f4  65644275
0003f8  66666572
0003fc  3a3a456e
000400  636f6465
000404  64417272
000408  617900  
00040b  00                DCB      0
                  |L22.1036|
00040c  63656e74          DCB      "centerOffset",0
000410  65724f66
000414  66736574
000418  00      
000419  00                DCB      0
00041a  00                DCB      0
00041b  00                DCB      0
                  |L22.1052|
00041c  696e6974          DCB      "initialPointsAreZeroCentered",0
000420  69616c50
000424  6f696e74
000428  73417265
00042c  5a65726f
000430  43656e74
000434  65726564
000438  00      
000439  00                DCB      0
00043a  00                DCB      0
00043b  00                DCB      0

                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_homography() const
;;;466    
;;;467          const Array<f32>& PlanarTransformation_f32::get_homography() const
000000  1d00              ADDS     r0,r0,#4
;;;468          {
;;;469            return this->homography;
;;;470          }
000002  4770              BX       lr
;;;471    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3215TransformPointsERKNS0_5ArrayIfEES6_fbbRS4_S7_||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3215TransformPointsERKNS0_5ArrayIfEES6_fbbRS4_S7_ PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::TransformPoints(const Anki::Embedded::Array<float>&, const Anki::Embedded::Array<float>&, float, bool, bool, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&) const
;;;98     
;;;99           Result PlanarTransformation_f32::TransformPoints(
000000  b5f0              PUSH     {r4-r7,lr}
;;;100            const Array<f32> &xIn, const Array<f32> &yIn,
;;;101            const f32 scale,
;;;102            const bool inputPointsAreZeroCentered,
;;;103            const bool outputPointsAreZeroCentered,
;;;104            Array<f32> &xOut, Array<f32> &yOut) const
;;;105          {
000002  b085              SUB      sp,sp,#0x14
000004  4616              MOV      r6,r2
000006  e9dd450a          LDRD     r4,r5,[sp,#0x28]
00000a  460f              MOV      r7,r1
00000c  1d01              ADDS     r1,r0,#4
00000e  8842              LDRH     r2,[r0,#2]
000010  f8ddc030          LDR      r12,[sp,#0x30]
000014  e88d103a          STM      sp,{r1,r3-r5,r12}
000018  4613              MOV      r3,r2
;;;106            return TransformPointsStatic(
00001a  f100023c          ADD      r2,r0,#0x3c
00001e  4631              MOV      r1,r6
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221TransformPointsStaticERKNS0_5ArrayIfEES6_fRKNS0_5PointIfEENS1_13TransformTypeES6_bbRS4_SC_ ; Anki::Embedded::Transformations::PlanarTransformation_f32::TransformPointsStatic(const Anki::Embedded::Array<float>&, const Anki::Embedded::Array<float>&, float, const Anki::Embedded::Point<float>&, Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Array<float>&, bool, bool, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
;;;107              xIn, yIn,
;;;108              scale,
;;;109              this->centerOffset, this->get_transformType(), this->get_homography(),
;;;110              inputPointsAreZeroCentered, outputPointsAreZeroCentered,
;;;111              xOut, yOut);
;;;112          }
000026  b005              ADD      sp,sp,#0x14
000028  bdf0              POP      {r4-r7,pc}
;;;113    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
;;;501    
;;;502          Point<f32> PlanarTransformation_f32::get_centerOffset(const f32 scale) const
000000  ee102a10          VMOV     r2,s0
;;;503          {
;;;504            if(FLT_NEAR(scale,1.0f)) {
000004  4b0e              LDR      r3,|L25.64|
000006  edd10a0f          VLDR     s1,[r1,#0x3c]
00000a  441a              ADD      r2,r2,r3
00000c  b082              SUB      sp,sp,#8              ;503
00000e  2afb              CMP      r2,#0xfb
000010  bf3c              ITT      CC
000012  edc00a00          VSTRCC   s1,[r0,#0]
000016  ed910a10          VLDRCC   s0,[r1,#0x40]
00001a  d30d              BCC      |L25.56|
;;;505              return this->centerOffset;
;;;506            } else {
;;;507              const Point<f32> scaledOffset(this->centerOffset.x / scale, this->centerOffset.y / scale);
00001c  ee801a80          VDIV.F32 s2,s1,s0
000020  edd11a10          VLDR     s3,[r1,#0x40]
000024  eec10a80          VDIV.F32 s1,s3,s0
000028  ed8d1a00          VSTR     s2,[sp,#0]
00002c  edcd0a01          VSTR     s1,[sp,#4]
000030  ed801a00          VSTR     s2,[r0,#0]
000034  ed9d0a01          VLDR     s0,[sp,#4]
                  |L25.56|
000038  ed800a01          VSTR     s0,[r0,#4]
;;;508              return scaledOffset;
;;;509            }
;;;510          }
00003c  b002              ADD      sp,sp,#8
00003e  4770              BX       lr
;;;511    
                          ENDP

                  |L25.64|
                          DCD      0xc08000a7

                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3217get_transformTypeEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3217get_transformTypeEv PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_transformType() const
;;;451    
;;;452          TransformType PlanarTransformation_f32::get_transformType() const
000000  8840              LDRH     r0,[r0,#2]
;;;453          {
;;;454            return transformType;
;;;455          }
000002  4770              BX       lr
;;;456    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3218get_initialCornersEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3218get_initialCornersEv PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_initialCorners() const
;;;478    
;;;479          const Quadrilateral<f32>& PlanarTransformation_f32::get_initialCorners() const
000000  3018              ADDS     r0,r0,#0x18
;;;480          {
;;;481            return this->initialCorners;
;;;482          }
000002  4770              BX       lr
;;;483    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3222get_transformedCornersENS0_11MemoryStackE||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3222get_transformedCornersENS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_transformedCorners(Anki::Embedded::MemoryStack) const
;;;511    
;;;512          Quadrilateral<f32> PlanarTransformation_f32::get_transformedCorners(MemoryStack scratch) const
000000  b530              PUSH     {r4,r5,lr}
;;;513          {
000002  b087              SUB      sp,sp,#0x1c
000004  460c              MOV      r4,r1
000006  4605              MOV      r5,r0
;;;514            return this->Transform(this->get_initialCorners(), scratch);
000008  4611              MOV      r1,r2
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000010  4603              MOV      r3,r0
000012  f1040218          ADD      r2,r4,#0x18
000016  eeb70a00          VMOV.F32 s0,#1.00000000
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_13QuadrilateralIfEENS0_11MemoryStackEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::Transform(const Anki::Embedded::Quadrilateral<float>&, Anki::Embedded::MemoryStack, float) const
;;;515          }
000022  b007              ADD      sp,sp,#0x1c
000024  bd30              POP      {r4,r5,pc}
;;;516    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3226get_transformedOrientationENS0_11MemoryStackE||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3226get_transformedOrientationENS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_transformedOrientation(Anki::Embedded::MemoryStack) const
;;;516    
;;;517          f32 PlanarTransformation_f32::get_transformedOrientation(MemoryStack scratch) const
000000  b510              PUSH     {r4,lr}
;;;518          {
000002  b094              SUB      sp,sp,#0x50
000004  4604              MOV      r4,r0
;;;519            const Quadrilateral<f32> transformedCorners = this->Transform(this->get_initialCorners(), scratch);
000006  a808              ADD      r0,sp,#0x20
000008  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00000c  4603              MOV      r3,r0
00000e  f1040218          ADD      r2,r4,#0x18
000012  eeb70a00          VMOV.F32 s0,#1.00000000
000016  4621              MOV      r1,r4
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_13QuadrilateralIfEENS0_11MemoryStackEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::Transform(const Anki::Embedded::Quadrilateral<float>&, Anki::Embedded::MemoryStack, float) const
;;;520    
;;;521            const Point<f32> transformedCenter = transformedCorners.ComputeCenter<f32>();
00001e  4669              MOV      r1,sp
000020  a810              ADD      r0,sp,#0x40
000022  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE13ComputeCenterIfEENS0_5PointIT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeCenter<float>() const
;;;522    
;;;523            const Point<f32> rightMidpoint = Point<f32>(
000026  ed9d0a04          VLDR     s0,[sp,#0x10]
00002a  eddd0a06          VLDR     s1,[sp,#0x18]
00002e  ed9d1a05          VLDR     s2,[sp,#0x14]
000032  eddd1a07          VLDR     s3,[sp,#0x1c]
000036  ee700a20          VADD.F32 s1,s0,s1
00003a  eeb60a00          VMOV.F32 s0,#0.50000000
00003e  ee311a21          VADD.F32 s2,s2,s3
000042  ee600a80          VMUL.F32 s1,s1,s0
000046  ee210a00          VMUL.F32 s0,s2,s0
00004a  edcd0a12          VSTR     s1,[sp,#0x48]
00004e  ed8d0a13          VSTR     s0,[sp,#0x4c]
;;;524              (transformedCorners[Quadrilateral<f32>::TopRight].x + transformedCorners[Quadrilateral<f32>::BottomRight].x) / 2,
;;;525              (transformedCorners[Quadrilateral<f32>::TopRight].y + transformedCorners[Quadrilateral<f32>::BottomRight].y) / 2);
;;;526    
;;;527            const f32 dy = rightMidpoint.y - transformedCenter.y;
000052  ed9d1a11          VLDR     s2,[sp,#0x44]
000056  ee300a41          VSUB.F32 s0,s0,s2
;;;528            const f32 dx = rightMidpoint.x - transformedCenter.x;
00005a  ed9d1a10          VLDR     s2,[sp,#0x40]
00005e  ee700ac1          VSUB.F32 s1,s1,s2
;;;529    
;;;530            const f32 orientation = atan2_acc(dy, dx);
000062  f7fffffe          BL       _Z9atan2_accff ; atan2_acc(float, float)
;;;531    
;;;532            return orientation;
;;;533          }
000066  b014              ADD      sp,sp,#0x50
000068  bd10              POP      {r4,pc}
;;;534    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3233get_initialPointsAreZeroCeneteredEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3233get_initialPointsAreZeroCeneteredEv PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_initialPointsAreZeroCenetered() const
;;;489    
;;;490          bool PlanarTransformation_f32::get_initialPointsAreZeroCenetered() const
000000  f8900038          LDRB     r0,[r0,#0x38]
;;;491          {
;;;492            return this->initialPointsAreZeroCentered;
;;;493          }
000004  4770              BX       lr
;;;494    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3247VerifyTransformation_Projective_NearestNeighborERKNS0_5ArrayIhEERKNS0_13IntegerCountsERKNS0_9RectangleIfEES6_S9_ffihRiSE_SE_NS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3247VerifyTransformation_Projective_NearestNeighborERKNS0_5ArrayIhEERKNS0_13IntegerCountsERKNS0_9RectangleIfEES6_S9_ffihRiSE_SE_NS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::VerifyTransformation_Projective_NearestNeighbor(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::IntegerCounts&, const Anki::Embedded::Rectangle<float>&, const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::IntegerCounts&, float, float, int, unsigned char, int&, int&, int&, Anki::Embedded::MemoryStack) const
;;;742    
;;;743          Result PlanarTransformation_f32::VerifyTransformation_Projective_NearestNeighbor(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;744            const Array<u8> &templateImage,
;;;745            const IntegerCounts &templateIntegerCounts,
;;;746            const Rectangle<f32> &templateRegionOfInterest,
;;;747            const Array<u8> &nextImage,
;;;748            const IntegerCounts &nextImageHistogram,
;;;749            const f32 templateRegionHeight,
;;;750            const f32 templateRegionWidth,
;;;751            const s32 templateCoordinateIncrement,
;;;752            const u8 maxPixelDifference,
;;;753            s32 &meanAbsoluteDifference,
;;;754            s32 &numInBounds,
;;;755            s32 &numSimilarPixels,
;;;756            MemoryStack scratch) const
;;;757          {
000004  461f              MOV      r7,r3
000006  ed2d0b02          VPUSH    {d0}
00000a  ed2d8b10          VPUSH    {d8-d15}
00000e  b091              SUB      sp,sp,#0x44
000010  eeb09a60          VMOV.F32 s18,s1
000014  eef09a40          VMOV.F32 s19,s0
000018  e9dd4535          LDRD     r4,r5,[sp,#0xd4]
00001c  e9dd8932          LDRD     r8,r9,[sp,#0xc8]
;;;758            const s32 numStatisticsFractionalBits = 14;
;;;759            //const f32 lowPercentile = 0.1f;
;;;760            const f32 highPercentile = 0.95f;
;;;761    
;;;762            AnkiConditionalErrorAndReturnValue(AreEqualSize(templateImage, nextImage),
000020  9e30              LDR      r6,[sp,#0xc0]
000022  9824              LDR      r0,[sp,#0x90]
000024  4631              MOV      r1,r6
000026  f7fffffe          BL       _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIhEES3_EEbRKT_RKT0_ ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<unsigned char>>(const T1&, const T2&)
00002a  2800              CMP      r0,#0
00002c  f0008104          BEQ.W    |L31.568|
;;;763              RESULT_FAIL_INVALID_SIZE, "PlanarTransformation_f32::VerifyTransformation_Projective", "input images must be the same size");
;;;764    
;;;765            const s32 maxPixelDifferenceS32 = maxPixelDifference;
;;;766    
;;;767            const s32 nextImageHeight = nextImage.get_size(0);
000030  2100              MOVS     r1,#0
000032  4630              MOV      r0,r6
000034  f8cd9004          STR      r9,[sp,#4]
000038  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
;;;768            const s32 nextImageWidth = nextImage.get_size(1);
00003c  9010              STR      r0,[sp,#0x40]
00003e  2101              MOVS     r1,#1
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000046  4681              MOV      r9,r0
;;;769    
;;;770            const s32 whichScale = 0;
;;;771            const f32 scale = static_cast<f32>(1 << whichScale);
;;;772    
;;;773            const s32 initialImageScaleS32 = BASE_IMAGE_WIDTH / nextImageWidth;
000048  f44f70a0          MOV      r0,#0x140
00004c  fb90f0f9          SDIV     r0,r0,r9
;;;774            const f32 initialImageScaleF32 = static_cast<f32>(initialImageScaleS32);
000050  ee000a10          VMOV     s0,r0
000054  eef7fa00          VMOV.F32 s31,#1.00000000       ;771
;;;775    
;;;776            const Point<f32> centerOffsetScaled = this->get_centerOffset(initialImageScaleF32);
000058  a80e              ADD      r0,sp,#0x38
00005a  eef88ac0          VCVT.F32.S32 s17,s0                ;774
00005e  9923              LDR      r1,[sp,#0x8c]
000060  eeb00a68          VMOV.F32 s0,s17
000064  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
;;;777    
;;;778            const f32 roi_minX = templateRegionOfInterest.left - templateRegionWidth/2.0f;
000068  ed97aa00          VLDR     s20,[r7,#0]
00006c  eeb6fa00          VMOV.F32 s30,#0.50000000
;;;779            const f32 roi_maxX = templateRegionOfInterest.right - templateRegionWidth/2.0f;
000070  edd7aa01          VLDR     s21,[r7,#4]
000074  ee09aa4f          VMLS.F32 s20,s18,s30           ;778
;;;780            const f32 roi_minY = templateRegionOfInterest.top - templateRegionHeight/2.0f;
;;;781            const f32 roi_maxY = templateRegionOfInterest.bottom - templateRegionHeight/2.0f;
000078  ed97ba03          VLDR     s22,[r7,#0xc]
00007c  ee49aa4f          VMLS.F32 s21,s18,s30           ;779
000080  ed979a02          VLDR     s18,[r7,#8]           ;780
000084  ee09bacf          VMLS.F32 s22,s19,s30
000088  ee099acf          VMLS.F32 s18,s19,s30           ;780
;;;782    
;;;783            Meshgrid<f32> originalCoordinates(
00008c  ee3a0aca          VSUB.F32 s0,s21,s20
000090  ee300a2f          VADD.F32 s0,s0,s31
000094  eddf9ab0          VLDR     s19,|L31.856|
000098  ee300a29          VADD.F32 s0,s0,s19
00009c  f7fffffe          BL       __hardfp_floorf
0000a0  eebd0ac0          VCVT.S32.F32 s0,s0
0000a4  eef00a6a          VMOV.F32 s1,s21
0000a8  a80b              ADD      r0,sp,#0x2c
0000aa  ee101a10          VMOV     r1,s0
0000ae  eeb00a4a          VMOV.F32 s0,s20
0000b2  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
0000b6  ee3b0a49          VSUB.F32 s0,s22,s18
0000ba  e9ddb30c          LDRD     r11,r3,[sp,#0x30]
0000be  ee300a2f          VADD.F32 s0,s0,s31
0000c2  f8dda02c          LDR      r10,[sp,#0x2c]
0000c6  9300              STR      r3,[sp,#0]
0000c8  ee300a29          VADD.F32 s0,s0,s19
0000cc  f7fffffe          BL       __hardfp_floorf
0000d0  eebd0ac0          VCVT.S32.F32 s0,s0
0000d4  eef00a4b          VMOV.F32 s1,s22
0000d8  a808              ADD      r0,sp,#0x20
0000da  ee101a10          VMOV     r1,s0
0000de  eeb00a49          VMOV.F32 s0,s18
0000e2  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
0000e6  e9dd0108          LDRD     r0,r1,[sp,#0x20]
0000ea  9a0a              LDR      r2,[sp,#0x28]
0000ec  9b00              LDR      r3,[sp,#0]
;;;784              Linspace(roi_minX, roi_maxX, static_cast<s32>(FLT_FLOOR((roi_maxX-roi_minX+1)/(scale)))),
;;;785              Linspace(roi_minY, roi_maxY, static_cast<s32>(FLT_FLOOR((roi_maxY-roi_minY+1)/(scale)))));
;;;786    
;;;787            const f32 templateCoordinateIncrementF32 = static_cast<f32>(templateCoordinateIncrement);
0000ee  f8cda008          STR      r10,[sp,#8]
0000f2  e9cd0105          STRD     r0,r1,[sp,#0x14]
;;;788    
;;;789            const s32 xyReferenceMin = 0;
;;;790            const s32 xReferenceMax = nextImageWidth - 1;
0000f6  f1a90001          SUB      r0,r9,#1
0000fa  e9cd2007          STRD     r2,r0,[sp,#0x1c]
0000fe  e9cdb303          STRD     r11,r3,[sp,#0xc]
000102  ee008a10          VMOV     s0,r8                 ;787
;;;791            const s32 yReferenceMax = nextImageHeight - 1;
000106  9810              LDR      r0,[sp,#0x40]
000108  ee0e1a90          VMOV     s29,r1
00010c  1e40              SUBS     r0,r0,#1
;;;792    
;;;793            const LinearSequence<f32> &yGridVector = originalCoordinates.get_yGridVector();
;;;794            const LinearSequence<f32> &xGridVector = originalCoordinates.get_xGridVector();
;;;795    
;;;796            const f32 yGridStart = yGridVector.get_start();
;;;797            const f32 xGridStart = xGridVector.get_start();
;;;798    
;;;799            const f32 yGridDelta = yGridVector.get_increment() * templateCoordinateIncrementF32;
;;;800            const f32 xGridDelta = xGridVector.get_increment() * templateCoordinateIncrementF32;
;;;801    
;;;802            const s32 yIterationMax = yGridVector.get_size();
00010e  9905              LDR      r1,[sp,#0x14]
000110  eeb80ac0          VCVT.F32.S32 s0,s0                 ;787
000114  9009              STR      r0,[sp,#0x24]         ;787
;;;803            const s32 xIterationMax = xGridVector.get_size();
;;;804    
;;;805            const Array<f32> &homography = this->get_homography();
000116  9100              STR      r1,[sp,#0]
000118  ee002a90          VMOV     s1,r2
00011c  9823              LDR      r0,[sp,#0x8c]
00011e  ee0dba90          VMOV     s27,r11
000122  ee20ea80          VMUL.F32 s28,s1,s0             ;799
000126  ee003a90          VMOV     s1,r3                 ;799
00012a  68c2              LDR      r2,[r0,#0xc]          ;799
00012c  6941              LDR      r1,[r0,#0x14]         ;799
;;;806            const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2] / initialImageScaleF32;
00012e  2300              MOVS     r3,#0
000130  fb031002          MLA      r0,r3,r2,r1
000134  ee20da80          VMUL.F32 s26,s1,s0             ;800
000138  ed900a02          VLDR     s0,[r0,#8]
00013c  edd0ca00          VLDR     s25,[r0,#0]
000140  ed90ca01          VLDR     s24,[r0,#4]
000144  eec0ba28          VDIV.F32 s23,s0,s17
;;;807            const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2] / initialImageScaleF32;
000148  2001              MOVS     r0,#1
00014a  fb001002          MLA      r0,r0,r2,r1
00014e  46d1              MOV      r9,r10
000150  ed900a02          VLDR     s0,[r0,#8]
000154  ed90ba00          VLDR     s22,[r0,#0]
000158  edd0aa01          VLDR     s21,[r0,#4]
;;;808            const f32 h20 = homography[2][0] * initialImageScaleF32; const f32 h21 = homography[2][1] * initialImageScaleF32; const f32 h22 = homography[2][2] * initialImageScaleF32; // TODO: should h22 be scaled?
00015c  2002              MOVS     r0,#2
00015e  fb001002          MLA      r0,r0,r2,r1
000162  ee80aa28          VDIV.F32 s20,s0,s17            ;807
000166  ed900a00          VLDR     s0,[r0,#0]
00016a  ee609a28          VMUL.F32 s19,s0,s17
00016e  ed900a01          VLDR     s0,[r0,#4]
000172  ee209a28          VMUL.F32 s18,s0,s17
000176  ed900a02          VLDR     s0,[r0,#8]
00017a  ee608a28          VMUL.F32 s17,s0,s17
;;;809    
;;;810            //const s32 templateMeanS32 = Round<s32>(templateIntegerCounts.mean);
;;;811            //const s32 nextImageMeanS32 = Round<s32>(nextImageHistogram.mean);
;;;812    
;;;813            //const s32 templateStdDivisor = Round<s32>(static_cast<f32>((1 << numStatisticsFractionalBits)) / templateIntegerCounts.standardDeviation);
;;;814            //const s32 nextImageStdDivisor = Round<s32>(static_cast<f32>((1 << numStatisticsFractionalBits)) / nextImageHistogram.standardDeviation);
;;;815    
;;;816            //const s32 templateLowS32 = ComputePercentile(templateIntegerCounts, lowPercentile);
;;;817            const s32 templateHighS32 = templateIntegerCounts.ComputePercentile(highPercentile);
00017e  ed9f0a77          VLDR     s0,|L31.860|
000182  9825              LDR      r0,[sp,#0x94]
000184  f7fffffe          BL       _ZNK4Anki8Embedded13IntegerCounts17ComputePercentileEf ; Anki::Embedded::IntegerCounts::ComputePercentile(float) const
000188  ee000a10          VMOV     s0,r0
;;;818            const s32 templateHighDivisorS32 = 255*Round<s32>(static_cast<f32>(1 << numStatisticsFractionalBits) / static_cast<f32>(templateHighS32));
00018c  eef80ac0          VCVT.F32.S32 s1,s0
000190  ed9f8a73          VLDR     s16,|L31.864|
000194  ee880a20          VDIV.F32 s0,s16,s1
000198  f7fffffe          BL       _ZN4Anki8Embedded5RoundIiEET_f ; Anki::Embedded::Round<int>(float)
00019c  ebc02000          RSB      r0,r0,r0,LSL #8
;;;819    
;;;820            //const s32 nextImageLowS32 = ComputePercentile(nextImageHistogram, lowPercentile);
;;;821            const s32 nextImageHighS32 = nextImageHistogram.ComputePercentile(highPercentile);
0001a0  ed9f0a6e          VLDR     s0,|L31.860|
0001a4  900b              STR      r0,[sp,#0x2c]
0001a6  9831              LDR      r0,[sp,#0xc4]
0001a8  f7fffffe          BL       _ZNK4Anki8Embedded13IntegerCounts17ComputePercentileEf ; Anki::Embedded::IntegerCounts::ComputePercentile(float) const
0001ac  ee000a10          VMOV     s0,r0
;;;822            const s32 nextImageHighDivisorS32 = 255*Round<s32>(static_cast<f32>(1 << numStatisticsFractionalBits) / static_cast<f32>(nextImageHighS32));
0001b0  eef80ac0          VCVT.F32.S32 s1,s0
0001b4  ee880a20          VDIV.F32 s0,s16,s1
0001b8  f7fffffe          BL       _ZN4Anki8Embedded5RoundIiEET_f ; Anki::Embedded::Round<int>(float)
0001bc  ebc02000          RSB      r0,r0,r0,LSL #8
;;;823    
;;;824            numInBounds = 0;
0001c0  900a              STR      r0,[sp,#0x28]
0001c2  2000              MOVS     r0,#0
;;;825            numSimilarPixels = 0;
0001c4  6020              STR      r0,[r4,#0]
;;;826            s32 totalGrayvalueDifference = 0;
;;;827    
;;;828            // TODO: make the x and y limits from 1 to end-2
;;;829            //#if !defined(__EDG__)
;;;830            //        Matlab matlab(false);
;;;831            //        matlab.EvalString("template = zeros(240,320);");
;;;832            //        matlab.EvalString("warped = zeros(240,320);");
;;;833            //#endif
;;;834    
;;;835            f32 yOriginal = yGridStart;
;;;836            for(s32 y=0; y<yIterationMax; y+=templateCoordinateIncrement) {
0001c6  6028              STR      r0,[r5,#0]
0001c8  9900              LDR      r1,[sp,#0]
0001ca  4684              MOV      r12,r0                ;826
0001cc  2900              CMP      r1,#0
0001ce  f34080bb          BLE.W    |L31.840|
                  |L31.466|
;;;837              const u8 * restrict pTemplateImage = templateImage.Pointer(Round<s32>(y+templateRegionOfInterest.top), Round<s32>(templateRegionOfInterest.left));
0001d2  ee000a10          VMOV     s0,r0
0001d6  edd70a02          VLDR     s1,[r7,#8]
0001da  eeb80ac0          VCVT.F32.S32 s0,s0
0001de  ee300a80          VADD.F32 s0,s1,s0
0001e2  eeb50ac0          VCMPE.F32 s0,#0.0
0001e6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001ea  bfcc              ITE      GT
0001ec  ee300a0f          VADDGT.F32 s0,s0,s30
0001f0  ee300a4f          VSUBLE.F32 s0,s0,s30
0001f4  eebd0ac0          VCVT.S32.F32 s0,s0
0001f8  ee101a10          VMOV     r1,s0
0001fc  ed970a00          VLDR     s0,[r7,#0]
000200  eeb50ac0          VCMPE.F32 s0,#0.0
000204  eef1fa10          VMRS     APSR_nzcv,FPSCR
000208  bfcc              ITE      GT
00020a  ee300a0f          VADDGT.F32 s0,s0,s30
00020e  ee300a4f          VSUBLE.F32 s0,s0,s30
000212  eebd0ac0          VCVT.S32.F32 s0,s0
000216  9b24              LDR      r3,[sp,#0x90]
;;;838    
;;;839              f32 xOriginal = xGridStart;
000218  eeb08a6d          VMOV.F32 s16,s27
00021c  ee102a10          VMOV     r2,s0
000220  f8d3a010          LDR      r10,[r3,#0x10]
000224  689b              LDR      r3,[r3,#8]
000226  fb01a103          MLA      r1,r1,r3,r10
00022a  eb010e02          ADD      lr,r1,r2
;;;840    
;;;841              for(s32 x=0; x<xIterationMax; x+=templateCoordinateIncrement) {
00022e  2200              MOVS     r2,#0
000230  f1b90f00          CMP      r9,#0
000234  dc13              BGT      |L31.606|
000236  e080              B        |L31.826|
                  |L31.568|
000238  f24021fa          MOV      r1,#0x2fa             ;762
00023c  4849              LDR      r0,|L31.868|
00023e  e9cd0100          STRD     r0,r1,[sp,#0]         ;762
000242  a349              ADR      r3,|L31.872|
000244  a255              ADR      r2,|L31.924|
000246  a15e              ADR      r1,|L31.960|
000248  2005              MOVS     r0,#5                 ;762
00024a  f7fffffe          BL       _Anki_Log
00024e  f04f60a0          MOV      r0,#0x5000000         ;762
                  |L31.594|
;;;842                // TODO: These two could be strength reduced
;;;843                const f32 xTransformedRaw = h00*xOriginal + h01*yOriginal + h02;
;;;844                const f32 yTransformedRaw = h10*xOriginal + h11*yOriginal + h12;
;;;845    
;;;846                const f32 normalization = 1.0f / (h20*xOriginal + h21*yOriginal + h22);
;;;847    
;;;848                const s32 xTransformedS32 = Round<s32>( (xTransformedRaw * normalization) + centerOffsetScaled.x );
;;;849                const s32 yTransformedS32 = Round<s32>( (yTransformedRaw * normalization) + centerOffsetScaled.y );
;;;850    
;;;851                xOriginal += xGridDelta;
;;;852    
;;;853                // If out of bounds, continue
;;;854                if(xTransformedS32 < xyReferenceMin || xTransformedS32 > xReferenceMax || yTransformedS32 < xyReferenceMin || yTransformedS32 > yReferenceMax) {
;;;855                  continue;
;;;856                }
;;;857    
;;;858                numInBounds++;
;;;859    
;;;860                const s32 nextImagePixelValueRaw = *nextImage.Pointer(yTransformedS32, xTransformedS32);
;;;861                const s32 templatePixelValueRaw = pTemplateImage[x];
;;;862    
;;;863                const s32 nearestPixelValue  = (nextImagePixelValueRaw * nextImageHighDivisorS32) >> numStatisticsFractionalBits;
;;;864                const s32 templatePixelValue = (templatePixelValueRaw * templateHighDivisorS32) >> numStatisticsFractionalBits;
;;;865    
;;;866                const s32 grayvalueDifference = ABS(nearestPixelValue - templatePixelValue);
;;;867    
;;;868                //#if !defined(__EDG__)
;;;869                //            matlab.EvalString("template(%d,%d) = %d; warped(%d,%d) = %d;", yTransformedS32, xTransformedS32, templatePixelValue, yTransformedS32, xTransformedS32, nearestPixelValue);
;;;870                //#endif
;;;871    
;;;872                totalGrayvalueDifference += grayvalueDifference;
;;;873    
;;;874                if(grayvalueDifference <= maxPixelDifferenceS32) {
;;;875                  numSimilarPixels++;
;;;876                }
;;;877              } // for(s32 x=0; x<xIterationMax; x++)
;;;878    
;;;879              yOriginal += yGridDelta;
;;;880            } // for(s32 y=0; y<yIterationMax; y++)
;;;881    
;;;882            meanAbsoluteDifference = totalGrayvalueDifference / numInBounds;
;;;883    
;;;884            return RESULT_OK;
;;;885          }
000252  b011              ADD      sp,sp,#0x44
000254  ecbd8b10          VPOP     {d8-d15}
000258  b006              ADD      sp,sp,#0x18
00025a  e8bd8ff0          POP      {r4-r11,pc}
                  |L31.606|
00025e  ee2c0a88          VMUL.F32 s0,s25,s16            ;843
000262  ee0c0a2e          VMLA.F32 s0,s24,s29            ;843
000266  ee701a2b          VADD.F32 s3,s0,s23             ;843
00026a  ee2b0a08          VMUL.F32 s0,s22,s16            ;844
00026e  ee0a0aae          VMLA.F32 s0,s21,s29            ;844
000272  ee301a0a          VADD.F32 s2,s0,s20             ;844
000276  ee290a88          VMUL.F32 s0,s19,s16            ;846
00027a  ee090a2e          VMLA.F32 s0,s18,s29            ;846
00027e  ee300a28          VADD.F32 s0,s0,s17             ;846
000282  eecf0a80          VDIV.F32 s1,s31,s0             ;846
000286  ed9d0a0e          VLDR     s0,[sp,#0x38]         ;848
00028a  ee010aa0          VMLA.F32 s0,s3,s1              ;848
00028e  eeb50ac0          VCMPE.F32 s0,#0.0               ;848
000292  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;848
000296  bfcc              ITE      GT                    ;848
000298  ee300a0f          VADDGT.F32 s0,s0,s30             ;848
00029c  ee300a4f          VSUBLE.F32 s0,s0,s30             ;848
0002a0  eebd0ac0          VCVT.S32.F32 s0,s0                 ;848
0002a4  ee101a10          VMOV     r1,s0                 ;848
0002a8  ed9d0a0f          VLDR     s0,[sp,#0x3c]         ;849
0002ac  ee010a20          VMLA.F32 s0,s2,s1              ;849
0002b0  eeb50ac0          VCMPE.F32 s0,#0.0               ;849
0002b4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;849
0002b8  bfcc              ITE      GT                    ;849
0002ba  ee300a0f          VADDGT.F32 s0,s0,s30             ;849
0002be  ee300a4f          VSUBLE.F32 s0,s0,s30             ;849
0002c2  eebd0ac0          VCVT.S32.F32 s0,s0                 ;849
0002c6  ee388a0d          VADD.F32 s16,s16,s26           ;851
0002ca  2900              CMP      r1,#0                 ;854
0002cc  ee103a10          VMOV     r3,s0                 ;854
0002d0  bfa4              ITT      GE                    ;854
0002d2  f8dda020          LDRGE    r10,[sp,#0x20]        ;854
0002d6  458a              CMPGE    r10,r1                ;854
0002d8  db2c              BLT      |L31.820|
0002da  2b00              CMP      r3,#0                 ;854
0002dc  bfa4              ITT      GE                    ;854
0002de  f8dda024          LDRGE    r10,[sp,#0x24]        ;854
0002e2  459a              CMPGE    r10,r3                ;854
0002e4  db26              BLT      |L31.820|
0002e6  f8d4a000          LDR      r10,[r4,#0]           ;858
0002ea  f10a0a01          ADD      r10,r10,#1            ;858
0002ee  f8c4a000          STR      r10,[r4,#0]           ;858
0002f2  f8d6b008          LDR      r11,[r6,#8]           ;858
0002f6  f8d6a010          LDR      r10,[r6,#0x10]        ;858
0002fa  fb03a30b          MLA      r3,r3,r11,r10         ;858
0002fe  f8dda028          LDR      r10,[sp,#0x28]        ;863
000302  5c5b              LDRB     r3,[r3,r1]            ;860
000304  f81e1002          LDRB     r1,[lr,r2]            ;861
000308  fb03f30a          MUL      r3,r3,r10             ;863
00030c  f8dda02c          LDR      r10,[sp,#0x2c]        ;864
000310  139b              ASRS     r3,r3,#14             ;863
000312  fb01f10a          MUL      r1,r1,r10             ;864
000316  1389              ASRS     r1,r1,#14             ;864
000318  eba30a01          SUB      r10,r3,r1             ;866
00031c  f1ba0f00          CMP      r10,#0                ;866
000320  bfb8              IT       LT                    ;866
000322  eba10a03          SUBLT    r10,r1,r3             ;866
000326  44d4              ADD      r12,r12,r10           ;872
000328  9901              LDR      r1,[sp,#4]            ;874
00032a  458a              CMP      r10,r1                ;874
00032c  dc02              BGT      |L31.820|
00032e  6829              LDR      r1,[r5,#0]            ;875
000330  1c49              ADDS     r1,r1,#1              ;875
000332  6029              STR      r1,[r5,#0]            ;875
                  |L31.820|
000334  4442              ADD      r2,r2,r8              ;841
000336  454a              CMP      r2,r9                 ;841
000338  db91              BLT      |L31.606|
                  |L31.826|
00033a  ee7eea8e          VADD.F32 s29,s29,s28           ;879
00033e  9900              LDR      r1,[sp,#0]            ;836
000340  4440              ADD      r0,r0,r8              ;836
000342  4288              CMP      r0,r1                 ;836
000344  f6ffaf45          BLT      |L31.466|
                  |L31.840|
000348  6820              LDR      r0,[r4,#0]            ;882
00034a  fb9cf1f0          SDIV     r1,r12,r0             ;882
00034e  9834              LDR      r0,[sp,#0xd0]         ;882
000350  6001              STR      r1,[r0,#0]            ;884
000352  2000              MOVS     r0,#0                 ;884
000354  e77d              B        |L31.594|
;;;886    
                          ENDP

000356  0000              DCW      0x0000
                  |L31.856|
000358  3727c5ac          DCFS     0x3727c5ac ; 9.9999997473787516e-06
                  |L31.860|
00035c  3f733333          DCFS     0x3f733333 ; 0.94999998807907104
                  |L31.864|
000360  46800000          DCFS     0x46800000 ; 16384
                  |L31.868|
                          DCD      ||.constdata||+0x2ad
                  |L31.872|
000368  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\transformations.cpp",0
00036c  6f726574
000370  6563685c
000374  76697369
000378  6f6e5c72
00037c  6f626f74
000380  5c737263
000384  5c747261
000388  6e73666f
00038c  726d6174
000390  696f6e73
000394  2e637070
000398  00      
000399  00                DCB      0
00039a  00                DCB      0
00039b  00                DCB      0
                  |L31.924|
00039c  696e7075          DCB      "input images must be the same size",0
0003a0  7420696d
0003a4  61676573
0003a8  206d7573
0003ac  74206265
0003b0  20746865
0003b4  2073616d
0003b8  65207369
0003bc  7a6500  
0003bf  00                DCB      0
                  |L31.960|
0003c0  506c616e          DCB      "PlanarTransformation_f32::VerifyTransformation_Projecti"
0003c4  61725472
0003c8  616e7366
0003cc  6f726d61
0003d0  74696f6e
0003d4  5f663332
0003d8  3a3a5665
0003dc  72696679
0003e0  5472616e
0003e4  73666f72
0003e8  6d617469
0003ec  6f6e5f50
0003f0  726f6a65
0003f4  637469  
0003f7  766500            DCB      "ve",0
0003fa  00                DCB      0
0003fb  00                DCB      0

                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3249VerifyTransformation_Projective_LinearInterpolateERKNS0_5ArrayIhEERKNS0_9RectangleIfEES6_ffihRiSB_SB_NS0_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3249VerifyTransformation_Projective_LinearInterpolateERKNS0_5ArrayIhEERKNS0_9RectangleIfEES6_ffihRiSB_SB_NS0_11MemoryStackE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::VerifyTransformation_Projective_LinearInterpolate(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Rectangle<float>&, const Anki::Embedded::Array<unsigned char>&, float, float, int, unsigned char, int&, int&, int&, Anki::Embedded::MemoryStack) const
;;;886    
;;;887          Result PlanarTransformation_f32::VerifyTransformation_Projective_LinearInterpolate(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;888            const Array<u8> &templateImage,
;;;889            const Rectangle<f32> &templateRegionOfInterest,
;;;890            const Array<u8> &nextImage,
;;;891            const f32 templateRegionHeight,
;;;892            const f32 templateRegionWidth,
;;;893            const s32 templateCoordinateIncrement,
;;;894            const u8 maxPixelDifference,
;;;895            s32 &meanAbsoluteDifference,
;;;896            s32 &numInBounds,
;;;897            s32 &numSimilarPixels,
;;;898            MemoryStack scratch) const
;;;899          {
000004  469b              MOV      r11,r3
000006  ed2d0b02          VPUSH    {d0}
00000a  4692              MOV      r10,r2
;;;900            // This method is heavily based on Interp2_Projective
;;;901            // The call would be like: Interp2_Projective<u8,u8>(nextImage, originalCoordinates, interpolationHomography, centerOffset, nextImageTransformed2d, INTERPOLATE_LINEAR, 0);
;;;902    
;;;903            AnkiConditionalErrorAndReturnValue(AreEqualSize(templateImage, nextImage),
00000c  4619              MOV      r1,r3
00000e  ed2d8b10          VPUSH    {d8-d15}              ;899
000012  b093              SUB      sp,sp,#0x4c           ;899
000014  eef08a60          VMOV.F32 s17,s1                ;899
000018  eeb09a40          VMOV.F32 s18,s0                ;899
00001c  e9dd5432          LDRD     r5,r4,[sp,#0xc8]      ;899
000020  e9dd6835          LDRD     r6,r8,[sp,#0xd4]      ;899
000024  9826              LDR      r0,[sp,#0x98]
000026  f7fffffe          BL       _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIhEES3_EEbRKT_RKT0_ ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<unsigned char>>(const T1&, const T2&)
00002a  2800              CMP      r0,#0
00002c  f00080e5          BEQ.W    |L32.506|
;;;904              RESULT_FAIL_INVALID_SIZE, "PlanarTransformation_f32::VerifyTransformation_Projective", "input images must be the same size");
;;;905    
;;;906            const s32 maxPixelDifferenceS32 = maxPixelDifference;
;;;907    
;;;908            const s32 nextImageHeight = nextImage.get_size(0);
000030  2100              MOVS     r1,#0
000032  4658              MOV      r0,r11
000034  9410              STR      r4,[sp,#0x40]
000036  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00003a  ee0c0a90          VMOV     s25,r0
;;;909            const s32 nextImageWidth = nextImage.get_size(1);
00003e  2101              MOVS     r1,#1
000040  4658              MOV      r0,r11
000042  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000046  4604              MOV      r4,r0
;;;910    
;;;911            const s32 whichScale = 0;
;;;912            const f32 scale = static_cast<f32>(1 << whichScale);
;;;913    
;;;914            const s32 initialImageScaleS32 = BASE_IMAGE_WIDTH / nextImageWidth;
000048  f44f70a0          MOV      r0,#0x140
00004c  fb90f0f4          SDIV     r0,r0,r4
;;;915            const f32 initialImageScaleF32 = static_cast<f32>(initialImageScaleS32);
000050  ee000a10          VMOV     s0,r0
000054  eef7ba00          VMOV.F32 s23,#1.00000000       ;912
;;;916    
;;;917            const Point<f32> centerOffsetScaled = this->get_centerOffset(initialImageScaleF32);
000058  a80e              ADD      r0,sp,#0x38
00005a  eeb88ac0          VCVT.F32.S32 s16,s0                ;915
00005e  9925              LDR      r1,[sp,#0x94]
000060  eeb00a48          VMOV.F32 s0,s16
000064  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_centerOffset(float) const
;;;918    
;;;919            const f32 roi_minX = templateRegionOfInterest.left - templateRegionWidth/2.0f;
000068  edda9a00          VLDR     s19,[r10,#0]
00006c  eef6aa00          VMOV.F32 s21,#0.50000000
;;;920            const f32 roi_maxX = templateRegionOfInterest.right - templateRegionWidth/2.0f;
000070  ed9aaa01          VLDR     s20,[r10,#4]
000074  ee489aea          VMLS.F32 s19,s17,s21           ;919
;;;921            const f32 roi_minY = templateRegionOfInterest.top - templateRegionHeight/2.0f;
;;;922            const f32 roi_maxY = templateRegionOfInterest.bottom - templateRegionHeight/2.0f;
000078  ed9aba03          VLDR     s22,[r10,#0xc]
00007c  ee08aaea          VMLS.F32 s20,s17,s21           ;920
000080  edda8a02          VLDR     s17,[r10,#8]          ;921
000084  ee09ba6a          VMLS.F32 s22,s18,s21
000088  ee498a6a          VMLS.F32 s17,s18,s21           ;921
;;;923    
;;;924            Meshgrid<f32> originalCoordinates(
00008c  ee3a0a69          VSUB.F32 s0,s20,s19
000090  ee300a2b          VADD.F32 s0,s0,s23
000094  ed9fcad3          VLDR     s24,|L32.996|
000098  ee300a0c          VADD.F32 s0,s0,s24
00009c  f7fffffe          BL       __hardfp_floorf
0000a0  eebd0ac0          VCVT.S32.F32 s0,s0
0000a4  eef00a4a          VMOV.F32 s1,s20
0000a8  a80b              ADD      r0,sp,#0x2c
0000aa  ee101a10          VMOV     r1,s0
0000ae  eeb00a69          VMOV.F32 s0,s19
0000b2  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
0000b6  ee3b0a68          VSUB.F32 s0,s22,s17
0000ba  e9dd930c          LDRD     r9,r3,[sp,#0x30]
0000be  ee300a2b          VADD.F32 s0,s0,s23
0000c2  9f0b              LDR      r7,[sp,#0x2c]
0000c4  9300              STR      r3,[sp,#0]
0000c6  ee300a0c          VADD.F32 s0,s0,s24
0000ca  f7fffffe          BL       __hardfp_floorf
0000ce  eebd0ac0          VCVT.S32.F32 s0,s0
0000d2  eef00a4b          VMOV.F32 s1,s22
0000d6  a808              ADD      r0,sp,#0x20
0000d8  ee101a10          VMOV     r1,s0
0000dc  eeb00a68          VMOV.F32 s0,s17
0000e0  f7fffffe          BL       _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i ; Anki::Embedded::Linspace<float>(T1, T1, int)
;;;925              Linspace(roi_minX, roi_maxX, static_cast<s32>(FLT_FLOOR((roi_maxX-roi_minX+1)/(scale)))),
;;;926              Linspace(roi_minY, roi_maxY, static_cast<s32>(FLT_FLOOR((roi_maxY-roi_minY+1)/(scale)))));
;;;927    
;;;928            // Unused, remove?
;;;929            //const s32 outHeight = originalCoordinates.get_yGridVector().get_size();
;;;930            //const s32 outWidth = originalCoordinates.get_xGridVector().get_size();
;;;931    
;;;932            const f32 xyReferenceMin = 0.0f;
;;;933            const f32 xReferenceMax = static_cast<f32>(nextImageWidth) - 1.0f;
0000e4  ee004a10          VMOV     s0,r4
0000e8  e9dd0108          LDRD     r0,r1,[sp,#0x20]
0000ec  eeb80ac0          VCVT.F32.S32 s0,s0
0000f0  9a0a              LDR      r2,[sp,#0x28]
0000f2  9702              STR      r7,[sp,#8]
0000f4  9b00              LDR      r3,[sp,#0]
0000f6  9207              STR      r2,[sp,#0x1c]
0000f8  e9cd0105          STRD     r0,r1,[sp,#0x14]
0000fc  ee300a6b          VSUB.F32 s0,s0,s23
000100  e9cd9303          STRD     r9,r3,[sp,#0xc]
000104  ed8d0a09          VSTR     s0,[sp,#0x24]
;;;934            const f32 yReferenceMax = static_cast<f32>(nextImageHeight) - 1.0f;
000108  eeb80aec          VCVT.F32.S32 s0,s25
00010c  ee091a10          VMOV     s18,r1
000110  ee0c3a90          VMOV     s25,r3
;;;935    
;;;936            const LinearSequence<f32> &yGridVector = originalCoordinates.get_yGridVector();
;;;937            const LinearSequence<f32> &xGridVector = originalCoordinates.get_xGridVector();
;;;938    
;;;939            const f32 yGridStart = yGridVector.get_start();
;;;940            const f32 xGridStart = xGridVector.get_start();
;;;941    
;;;942            const f32 yGridDelta = yGridVector.get_increment();
;;;943            const f32 xGridDelta = xGridVector.get_increment();
;;;944    
;;;945            const s32 yIterationMax = yGridVector.get_size();
;;;946            const s32 xIterationMax = xGridVector.get_size();
;;;947    
;;;948            const Array<f32> &homography = this->get_homography();
;;;949            const f32 h00 = homography[0][0]; const f32 h01 = homography[0][1]; const f32 h02 = homography[0][2] / initialImageScaleF32;
000114  2300              MOVS     r3,#0
000116  ee300a6b          VSUB.F32 s0,s0,s23             ;934
00011a  ed8d0a08          VSTR     s0,[sp,#0x20]         ;934
00011e  e9cd0700          STRD     r0,r7,[sp,#0]         ;934
000122  e9cd920a          STRD     r9,r2,[sp,#0x28]      ;934
000126  9825              LDR      r0,[sp,#0x94]         ;934
000128  68c2              LDR      r2,[r0,#0xc]          ;934
00012a  6941              LDR      r1,[r0,#0x14]         ;934
00012c  fb031002          MLA      r0,r3,r2,r1           ;934
000130  ed900a00          VLDR     s0,[r0,#0]
000134  ed8d0a12          VSTR     s0,[sp,#0x48]
000138  ed900a01          VLDR     s0,[r0,#4]
00013c  ed8d0a11          VSTR     s0,[sp,#0x44]
000140  edd00a02          VLDR     s1,[r0,#8]
;;;950            const f32 h10 = homography[1][0]; const f32 h11 = homography[1][1]; const f32 h12 = homography[1][2] / initialImageScaleF32;
000144  2001              MOVS     r0,#1
000146  fb001002          MLA      r0,r0,r2,r1
00014a  ee800a88          VDIV.F32 s0,s1,s16             ;949
00014e  ed8d0a0d          VSTR     s0,[sp,#0x34]         ;949
000152  ed900a02          VLDR     s0,[r0,#8]
000156  edd0fa00          VLDR     s31,[r0,#0]
00015a  ed90fa01          VLDR     s30,[r0,#4]
;;;951            const f32 h20 = homography[2][0] * initialImageScaleF32; const f32 h21 = homography[2][1] * initialImageScaleF32; const f32 h22 = homography[2][2] * initialImageScaleF32; // TODO: should h22 be scaled?
00015e  2002              MOVS     r0,#2
000160  fb001002          MLA      r0,r0,r2,r1
000164  eec0ea08          VDIV.F32 s29,s0,s16            ;950
000168  ed900a00          VLDR     s0,[r0,#0]
00016c  ee20ea08          VMUL.F32 s28,s0,s16
000170  ed900a01          VLDR     s0,[r0,#4]
000174  ee60da08          VMUL.F32 s27,s0,s16
000178  ed900a02          VLDR     s0,[r0,#8]
;;;952    
;;;953            numInBounds = 0;
00017c  2000              MOVS     r0,#0
;;;954            numSimilarPixels = 0;
00017e  6030              STR      r0,[r6,#0]
;;;955            s32 totalGrayvalueDifference = 0;
000180  4607              MOV      r7,r0
;;;956    
;;;957            // TODO: make the x and y limits from 1 to end-2
;;;958    
;;;959            //Matlab matlab(false);
;;;960            //matlab.EvalString("template = zeros(240,320);");
;;;961            //matlab.EvalString("warped = zeros(240,320);");
;;;962    
;;;963            f32 yOriginal = yGridStart;
;;;964            for(s32 y=0; y<yIterationMax; y+=templateCoordinateIncrement) {
000182  4681              MOV      r9,r0
000184  f8c80000          STR      r0,[r8,#0]
000188  ee20da08          VMUL.F32 s26,s0,s16            ;951
00018c  9800              LDR      r0,[sp,#0]
00018e  2800              CMP      r0,#0
000190  f3408120          BLE.W    |L32.980|
                  |L32.404|
;;;965              const u8 * restrict pTemplateImage = templateImage.Pointer(Round<s32>(y+templateRegionOfInterest.top), Round<s32>(templateRegionOfInterest.left));
000194  ee009a10          VMOV     s0,r9
000198  edda0a02          VLDR     s1,[r10,#8]
00019c  eeb80ac0          VCVT.F32.S32 s0,s0
0001a0  ee300a80          VADD.F32 s0,s1,s0
0001a4  eeb50ac0          VCMPE.F32 s0,#0.0
0001a8  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001ac  bfcc              ITE      GT
0001ae  ee300a2a          VADDGT.F32 s0,s0,s21
0001b2  ee300a6a          VSUBLE.F32 s0,s0,s21
0001b6  eebd0ac0          VCVT.S32.F32 s0,s0
0001ba  ee100a10          VMOV     r0,s0
0001be  ed9a0a00          VLDR     s0,[r10,#0]
0001c2  eeb50ac0          VCMPE.F32 s0,#0.0
0001c6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001ca  bfcc              ITE      GT
0001cc  ee300a2a          VADDGT.F32 s0,s0,s21
0001d0  ee300a6a          VSUBLE.F32 s0,s0,s21
0001d4  eebd0ac0          VCVT.S32.F32 s0,s0
0001d8  9a26              LDR      r2,[sp,#0x98]
;;;966    
;;;967              f32 xOriginal = xGridStart;
;;;968    
;;;969              for(s32 x=0; x<xIterationMax; x+=templateCoordinateIncrement) {
0001da  2400              MOVS     r4,#0
0001dc  ee101a10          VMOV     r1,s0
0001e0  6913              LDR      r3,[r2,#0x10]
0001e2  6892              LDR      r2,[r2,#8]
0001e4  fb003002          MLA      r0,r0,r2,r3
0001e8  4408              ADD      r0,r0,r1
0001ea  900c              STR      r0,[sp,#0x30]         ;967
0001ec  9801              LDR      r0,[sp,#4]
0001ee  ed9d8a0a          VLDR     s16,[sp,#0x28]        ;967
0001f2  2800              CMP      r0,#0
0001f4  dc14              BGT      |L32.544|
0001f6  f000b8e0          B.W      |L32.954|
                  |L32.506|
0001fa  f2403187          MOV      r1,#0x387             ;903
0001fe  487a              LDR      r0,|L32.1000|
000200  e9cd0100          STRD     r0,r1,[sp,#0]         ;903
000204  a379              ADR      r3,|L32.1004|
000206  a286              ADR      r2,|L32.1056|
000208  a18e              ADR      r1,|L32.1092|
00020a  2005              MOVS     r0,#5                 ;903
00020c  f7fffffe          BL       _Anki_Log
000210  f04f60a0          MOV      r0,#0x5000000         ;903
                  |L32.532|
;;;970                // TODO: These two could be strength reduced
;;;971                const f32 xTransformedRaw = h00*xOriginal + h01*yOriginal + h02;
;;;972                const f32 yTransformedRaw = h10*xOriginal + h11*yOriginal + h12;
;;;973    
;;;974                const f32 normalization = 1.0f / (h20*xOriginal + h21*yOriginal + h22);
;;;975    
;;;976                const f32 xTransformed = (xTransformedRaw * normalization) + centerOffsetScaled.x;
;;;977                const f32 yTransformed = (yTransformedRaw * normalization) + centerOffsetScaled.y;
;;;978    
;;;979                xOriginal += xGridDelta * templateCoordinateIncrement;
;;;980    
;;;981                const f32 x0 = FLT_FLOOR(xTransformed);
;;;982                const f32 x1 = x0 + 1.0f; // ceilf(xTransformed);
;;;983    
;;;984                const f32 y0 = FLT_FLOOR(yTransformed);
;;;985                const f32 y1 = y0 + 1.0f; // ceilf(yTransformed);
;;;986    
;;;987                // If out of bounds, continue
;;;988                if(x0 < xyReferenceMin || x1 > xReferenceMax || y0 < xyReferenceMin || y1 > yReferenceMax) {
;;;989                  continue;
;;;990                }
;;;991    
;;;992                numInBounds++;
;;;993    
;;;994                const f32 alphaX = xTransformed - x0;
;;;995                const f32 alphaXinverse = 1 - alphaX;
;;;996    
;;;997                const f32 alphaY = yTransformed - y0;
;;;998                const f32 alphaYinverse = 1.0f - alphaY;
;;;999    
;;;1000               const s32 y0S32 = Round<s32>(y0);
;;;1001               const s32 y1S32 = Round<s32>(y1);
;;;1002               const s32 x0S32 = Round<s32>(x0);
;;;1003   
;;;1004               const u8 * restrict pReference_y0 = nextImage.Pointer(y0S32, x0S32);
;;;1005               const u8 * restrict pReference_y1 = nextImage.Pointer(y1S32, x0S32);
;;;1006   
;;;1007               const f32 pixelTL = *pReference_y0;
;;;1008               const f32 pixelTR = *(pReference_y0+1);
;;;1009               const f32 pixelBL = *pReference_y1;
;;;1010               const f32 pixelBR = *(pReference_y1+1);
;;;1011   
;;;1012               const s32 interpolatedPixelValue = Round<s32>(InterpolateBilinear2d<f32>(pixelTL, pixelTR, pixelBL, pixelBR, alphaY, alphaYinverse, alphaX, alphaXinverse));
;;;1013               const s32 templatePixelValue = pTemplateImage[x];
;;;1014               const s32 grayvalueDifference = ABS(interpolatedPixelValue - templatePixelValue);
;;;1015   
;;;1016               //matlab.EvalString("template(%d,%d) = %d; warped(%d,%d) = %d;", Round<s32>(y0), Round<s32>(x0), templatePixelValue, Round<s32>(y0), Round<s32>(x0), interpolatedPixelValue);
;;;1017   
;;;1018               totalGrayvalueDifference += grayvalueDifference;
;;;1019   
;;;1020               if(grayvalueDifference <= maxPixelDifferenceS32) {
;;;1021                 numSimilarPixels++;
;;;1022               }
;;;1023             } // for(s32 x=0; x<xIterationMax; x++)
;;;1024   
;;;1025             yOriginal += yGridDelta * templateCoordinateIncrement;
;;;1026           } // for(s32 y=0; y<yIterationMax; y++)
;;;1027   
;;;1028           meanAbsoluteDifference = totalGrayvalueDifference / numInBounds;
;;;1029   
;;;1030           return RESULT_OK;
;;;1031         } // Result PlanarTransformation_f32::VerifyTransformation_Projective_LinearInterpolate()
000214  b013              ADD      sp,sp,#0x4c
000216  ecbd8b10          VPOP     {d8-d15}
00021a  b006              ADD      sp,sp,#0x18
00021c  e8bd8ff0          POP      {r4-r11,pc}
                  |L32.544|
000220  ed9d0a12          VLDR     s0,[sp,#0x48]         ;971
000224  eddd0a11          VLDR     s1,[sp,#0x44]         ;971
000228  ed9daa0e          VLDR     s20,[sp,#0x38]        ;976
00022c  ee200a08          VMUL.F32 s0,s0,s16             ;971
000230  eddd9a0f          VLDR     s19,[sp,#0x3c]        ;977
000234  ee000a89          VMLA.F32 s0,s1,s18             ;971
000238  eddd0a0d          VLDR     s1,[sp,#0x34]         ;971
00023c  ee301a20          VADD.F32 s2,s0,s1              ;971
000240  ee2f0a88          VMUL.F32 s0,s31,s16            ;972
000244  ee0f0a09          VMLA.F32 s0,s30,s18            ;972
000248  ee700a2e          VADD.F32 s1,s0,s29             ;972
00024c  ee2e0a08          VMUL.F32 s0,s28,s16            ;974
000250  ee0d0a89          VMLA.F32 s0,s27,s18            ;974
000254  ee701a0d          VADD.F32 s3,s0,s26             ;974
000258  ee8b0aa1          VDIV.F32 s0,s23,s3             ;974
00025c  ee01aa00          VMLA.F32 s20,s2,s0             ;976
000260  ee409a80          VMLA.F32 s19,s1,s0             ;977
000264  ee005a10          VMOV     s0,r5                 ;979
000268  eeb80ac0          VCVT.F32.S32 s0,s0                 ;979
00026c  ee0c8a80          VMLA.F32 s16,s25,s0            ;979
000270  ee3a0a0c          VADD.F32 s0,s20,s24            ;981
000274  f7fffffe          BL       __hardfp_floorf
000278  eef08a40          VMOV.F32 s17,s0                ;981
00027c  ee390a8c          VADD.F32 s0,s19,s24            ;984
000280  ee38baab          VADD.F32 s22,s17,s23           ;982
000284  f7fffffe          BL       __hardfp_floorf
000288  ee700a2b          VADD.F32 s1,s0,s23             ;985
00028c  eef58ac0          VCMPE.F32 s17,#0.0              ;988
000290  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;988
000294  d37e              BCC      |L32.916|
000296  ed9d1a09          VLDR     s2,[sp,#0x24]         ;988
00029a  eeb4bac1          VCMPE.F32 s22,s2                ;988
00029e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;988
0002a2  dc77              BGT      |L32.916|
0002a4  eeb50ac0          VCMPE.F32 s0,#0.0               ;988
0002a8  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;988
0002ac  d372              BCC      |L32.916|
0002ae  ed9d1a08          VLDR     s2,[sp,#0x20]         ;988
0002b2  eef40ac1          VCMPE.F32 s1,s2                 ;988
0002b6  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;988
0002ba  dc79              BGT      |L32.944|
0002bc  ee3a1a68          VSUB.F32 s2,s20,s17            ;994
0002c0  ee791ac0          VSUB.F32 s3,s19,s0             ;997
0002c4  6830              LDR      r0,[r6,#0]            ;992
0002c6  eeb50ac0          VCMPE.F32 s0,#0.0               ;992
0002ca  ee3b2ac1          VSUB.F32 s4,s23,s2             ;995
0002ce  ee7b2ae1          VSUB.F32 s5,s23,s3             ;998
0002d2  1c40              ADDS     r0,r0,#1              ;992
0002d4  6030              STR      r0,[r6,#0]            ;992
0002d6  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;992
0002da  bfcc              ITE      GT                    ;992
0002dc  ee300a2a          VADDGT.F32 s0,s0,s21             ;992
0002e0  ee300a6a          VSUBLE.F32 s0,s0,s21             ;992
0002e4  eebd0ac0          VCVT.S32.F32 s0,s0                 ;992
0002e8  eef50ac0          VCMPE.F32 s1,#0.0               ;992
0002ec  ee103a10          VMOV     r3,s0                 ;992
0002f0  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;992
0002f4  bfcc              ITE      GT                    ;992
0002f6  ee300aaa          VADDGT.F32 s0,s1,s21             ;992
0002fa  ee300aea          VSUBLE.F32 s0,s1,s21             ;992
0002fe  eebd0ac0          VCVT.S32.F32 s0,s0                 ;992
000302  eef58ac0          VCMPE.F32 s17,#0.0              ;992
000306  ee10ca10          VMOV     r12,s0                ;992
00030a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;992
00030e  bfcc              ITE      GT                    ;992
000310  ee380aaa          VADDGT.F32 s0,s17,s21            ;992
000314  ee380aea          VSUBLE.F32 s0,s17,s21            ;992
000318  eebd0ac0          VCVT.S32.F32 s0,s0                 ;992
00031c  f8db2008          LDR      r2,[r11,#8]           ;992
000320  f8db1010          LDR      r1,[r11,#0x10]        ;992
000324  ee100a10          VMOV     r0,s0                 ;992
000328  fb031302          MLA      r3,r3,r2,r1           ;992
00032c  fb0c1102          MLA      r1,r12,r2,r1          ;992
000330  4403              ADD      r3,r3,r0              ;992
000332  4408              ADD      r0,r0,r1              ;992
000334  7819              LDRB     r1,[r3,#0]            ;1007
000336  ee001a10          VMOV     s0,r1                 ;1007
00033a  7859              LDRB     r1,[r3,#1]            ;1008
00033c  eef83a40          VCVT.F32.U32 s7,s0                 ;1007
000340  ee001a10          VMOV     s0,r1                 ;1008
000344  7801              LDRB     r1,[r0,#0]            ;1009
000346  7840              LDRB     r0,[r0,#1]            ;1010
000348  eef80a40          VCVT.F32.U32 s1,s0                 ;1008
00034c  ee001a10          VMOV     s0,r1                 ;1009
000350  ee623a23          VMUL.F32 s7,s4,s7              ;1009
000354  ee030a10          VMOV     s6,r0                 ;1010
000358  eeb80a40          VCVT.F32.U32 s0,s0                 ;1009
00035c  ee413a20          VMLA.F32 s7,s2,s1              ;1009
000360  eeb83a43          VCVT.F32.U32 s6,s6                 ;1010
000364  ee620a00          VMUL.F32 s1,s4,s0              ;1010
000368  ee410a03          VMLA.F32 s1,s2,s6              ;1010
00036c  ee220aa3          VMUL.F32 s0,s5,s7              ;1010
000370  ee010aa0          VMLA.F32 s0,s3,s1              ;1010
000374  eeb50ac0          VCMPE.F32 s0,#0.0               ;1010
000378  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1010
00037c  bfcc              ITE      GT                    ;1010
00037e  ee300a2a          VADDGT.F32 s0,s0,s21             ;1010
000382  ee300a6a          VSUBLE.F32 s0,s0,s21             ;1010
000386  eebd0ac0          VCVT.S32.F32 s0,s0                 ;1010
00038a  990c              LDR      r1,[sp,#0x30]         ;1013
00038c  ee100a10          VMOV     r0,s0                 ;1013
000390  5d0a              LDRB     r2,[r1,r4]            ;1013
000392  e000              B        |L32.918|
                  |L32.916|
000394  e00c              B        |L32.944|
                  |L32.918|
000396  1a81              SUBS     r1,r0,r2              ;1014
000398  2900              CMP      r1,#0                 ;1014
00039a  bfb8              IT       LT                    ;1014
00039c  1a11              SUBLT    r1,r2,r0              ;1014
00039e  440f              ADD      r7,r7,r1              ;1018
0003a0  9810              LDR      r0,[sp,#0x40]         ;1020
0003a2  4281              CMP      r1,r0                 ;1020
0003a4  dc04              BGT      |L32.944|
0003a6  f8d80000          LDR      r0,[r8,#0]            ;1021
0003aa  1c40              ADDS     r0,r0,#1              ;1021
0003ac  f8c80000          STR      r0,[r8,#0]            ;1021
                  |L32.944|
0003b0  9801              LDR      r0,[sp,#4]            ;969
0003b2  442c              ADD      r4,r4,r5              ;969
0003b4  4284              CMP      r4,r0                 ;969
0003b6  f6ffaf33          BLT      |L32.544|
                  |L32.954|
0003ba  ee005a10          VMOV     s0,r5                 ;1025
0003be  eddd0a0b          VLDR     s1,[sp,#0x2c]         ;1025
0003c2  9800              LDR      r0,[sp,#0]            ;964
0003c4  eeb80ac0          VCVT.F32.S32 s0,s0                 ;1025
0003c8  44a9              ADD      r9,r9,r5              ;964
0003ca  4581              CMP      r9,r0                 ;964
0003cc  ee009a80          VMLA.F32 s18,s1,s0             ;1025
0003d0  f6ffaee0          BLT      |L32.404|
                  |L32.980|
0003d4  6830              LDR      r0,[r6,#0]            ;1028
0003d6  fb97f1f0          SDIV     r1,r7,r0              ;1028
0003da  9834              LDR      r0,[sp,#0xd0]         ;1028
0003dc  6001              STR      r1,[r0,#0]            ;1030
0003de  2000              MOVS     r0,#0                 ;1030
0003e0  e718              B        |L32.532|
;;;1032       } // namespace Transformations
                          ENDP

0003e2  0000              DCW      0x0000
                  |L32.996|
0003e4  3727c5ac          DCFS     0x3727c5ac ; 9.9999997473787516e-06
                  |L32.1000|
                          DCD      ||.constdata||+0x46f
                  |L32.1004|
0003ec  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\transformations.cpp",0
0003f0  6f726574
0003f4  6563685c
0003f8  76697369
0003fc  6f6e5c72
000400  6f626f74
000404  5c737263
000408  5c747261
00040c  6e73666f
000410  726d6174
000414  696f6e73
000418  2e637070
00041c  00      
00041d  00                DCB      0
00041e  00                DCB      0
00041f  00                DCB      0
                  |L32.1056|
000420  696e7075          DCB      "input images must be the same size",0
000424  7420696d
000428  61676573
00042c  206d7573
000430  74206265
000434  20746865
000438  2073616d
00043c  65207369
000440  7a6500  
000443  00                DCB      0
                  |L32.1092|
000444  506c616e          DCB      "PlanarTransformation_f32::VerifyTransformation_Projecti"
000448  61725472
00044c  616e7366
000450  6f726d61
000454  74696f6e
000458  5f663332
00045c  3a3a5665
000460  72696679
000464  5472616e
000468  73666f72
00046c  6d617469
000470  6f6e5f50
000474  726f6a65
000478  637469  
00047b  766500            DCB      "ve",0
00047e  00                DCB      0
00047f  00                DCB      0

                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f325PrintEPKc||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f325PrintEPKc PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::Print(const char*) const
;;;195    
;;;196          Result PlanarTransformation_f32::Print(const char * const variableName) const
000000  b510              PUSH     {r4,lr}
;;;197          {
000002  4604              MOV      r4,r0
000004  b082              SUB      sp,sp,#8
;;;198            CoreTechPrint(variableName);
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;199            CoreTechPrint(": center");
00000c  a00d              ADR      r0,|L33.68|
00000e  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;200            this->centerOffset.Print();
000012  f104003c          ADD      r0,r4,#0x3c
000016  f7fffffe          BL       _ZNK4Anki8Embedded5PointIfE5PrintEv ; Anki::Embedded::Point<float>::Print() const
;;;201            CoreTechPrint(" initialCorners");
00001a  a00d              ADR      r0,|L33.80|
00001c  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;202            this->initialCorners.Print();
000020  f1040018          ADD      r0,r4,#0x18
000024  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE5PrintEv ; Anki::Embedded::Quadrilateral<float>::Print() const
;;;203            CoreTechPrint("\n");
000028  a00d              ADR      r0,|L33.96|
00002a  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;204    
;;;205            return this->homography.Print("homography");
00002e  4b0d              LDR      r3,|L33.100|
000030  2000              MOVS     r0,#0
000032  e9cd0300          STRD     r0,r3,[sp,#0]
000036  4602              MOV      r2,r0
000038  a10b              ADR      r1,|L33.104|
00003a  1d20              ADDS     r0,r4,#4
00003c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE5PrintEPKciiii ; Anki::Embedded::Array<float>::Print(const char*, int, int, int, int) const
;;;206          }
000040  b002              ADD      sp,sp,#8
000042  bd10              POP      {r4,pc}
;;;207    
                          ENDP

                  |L33.68|
000044  3a206365          DCB      ": center",0
000048  6e746572
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0
                  |L33.80|
000050  20696e69          DCB      " initialCorners",0
000054  7469616c
000058  436f726e
00005c  65727300
                  |L33.96|
000060  0a00              DCB      "\n",0
000062  00                DCB      0
000063  00                DCB      0
                  |L33.100|
                          DCD      0x07fffffe
                  |L33.104|
000068  686f6d6f          DCB      "homography",0
00006c  67726170
000070  687900  
000073  00                DCB      0

                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f327IsValidEv||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f327IsValidEv PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::IsValid() const
;;;347    
;;;348          bool PlanarTransformation_f32::IsValid() const
000000  7801              LDRB     r1,[r0,#0]
;;;349          {
;;;350            if(!this->isValid)
000002  2900              CMP      r1,#0
;;;351              return false;
000004  bf04              ITT      EQ
000006  2000              MOVEQ    r0,#0
;;;352    
;;;353            if(!this->homography.IsValid())
;;;354              return false;
;;;355    
;;;356            return true;
;;;357          }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;349
00000c  1d00              ADDS     r0,r0,#4              ;353
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000012  2800              CMP      r0,#0                 ;353
000014  bf18              IT       NE                    ;356
000016  2001              MOVNE    r0,#1                 ;356
000018  bd10              POP      {r4,pc}
;;;358    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329SerializeEPKcRNS0_16SerializedBufferE||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329SerializeEPKcRNS0_16SerializedBufferE PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::Serialize(const char*, Anki::Embedded::SerializedBuffer&) const
;;;381    
;;;382          Result PlanarTransformation_f32::Serialize(const char *objectName, SerializedBuffer &buffer) const
000000  b530              PUSH     {r4,r5,lr}
;;;383          {
000002  4694              MOV      r12,r2
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  f44f6380          MOV      r3,#0x400
;;;384            s32 totalDataLength = this->get_serializationSize();
;;;385    
;;;386            void *segment = buffer.Allocate("PlanarTransformation_f32", objectName, totalDataLength);
00000e  460a              MOV      r2,r1
000010  a109              ADR      r1,|L35.56|
000012  4660              MOV      r0,r12
000014  9300              STR      r3,[sp,#0]
000016  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer8AllocateEPKcS3_i ; Anki::Embedded::SerializedBuffer::Allocate(const char*, const char*, int)
;;;387    
;;;388            if(segment == NULL) {
00001a  9001              STR      r0,[sp,#4]
00001c  2800              CMP      r0,#0
;;;389              return RESULT_FAIL;
00001e  bf02              ITTT     EQ
000020  2001              MOVEQ    r0,#1
;;;390            }
;;;391    
;;;392            return SerializeRaw(objectName, &segment, totalDataLength);
;;;393          }
000022  b003              ADDEQ    sp,sp,#0xc
000024  bd30              POPEQ    {r4,r5,pc}
000026  466b              MOV      r3,sp                 ;392
000028  aa01              ADD      r2,sp,#4              ;392
00002a  4621              MOV      r1,r4                 ;392
00002c  4628              MOV      r0,r5                 ;392
00002e  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3212SerializeRawEPKcPPvRi ; Anki::Embedded::Transformations::PlanarTransformation_f32::SerializeRaw(const char*, void**, int&) const
000032  b003              ADD      sp,sp,#0xc
000034  bd30              POP      {r4,r5,pc}
;;;394    
                          ENDP

000036  0000              DCW      0x0000
                  |L35.56|
000038  506c616e          DCB      "PlanarTransformation_f32",0
00003c  61725472
000040  616e7366
000044  6f726d61
000048  74696f6e
00004c  5f663332
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_13QuadrilateralIfEENS0_11MemoryStackEf||, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_13QuadrilateralIfEENS0_11MemoryStackEf PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::Transform(const Anki::Embedded::Quadrilateral<float>&, Anki::Embedded::MemoryStack, float) const
;;;207    
;;;208          Quadrilateral<f32> PlanarTransformation_f32::Transform(const Quadrilateral<f32> &in, MemoryStack scratch, const f32 scale) const
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;209          {
000004  461d              MOV      r5,r3
000006  ed2d8b02          VPUSH    {d8}
00000a  b09e              SUB      sp,sp,#0x78
00000c  4617              MOV      r7,r2
00000e  460c              MOV      r4,r1
000010  4606              MOV      r6,r0
;;;210            Array<f32> xIn(1,4,scratch);
000012  2300              MOVS     r3,#0
000014  eeb08a40          VMOV.F32 s16,s0                ;209
000018  461a              MOV      r2,r3
00001a  2101              MOVS     r1,#1
00001c  a819              ADD      r0,sp,#0x64
00001e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000022  6800              LDR      r0,[r0,#0]
000024  9000              STR      r0,[sp,#0]
000026  462b              MOV      r3,r5
000028  2204              MOVS     r2,#4
00002a  2101              MOVS     r1,#1
00002c  a805              ADD      r0,sp,#0x14
00002e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;211            Array<f32> yIn(1,4,scratch);
000032  2300              MOVS     r3,#0
000034  461a              MOV      r2,r3
000036  2101              MOVS     r1,#1
000038  a81a              ADD      r0,sp,#0x68
00003a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00003e  6800              LDR      r0,[r0,#0]
000040  9000              STR      r0,[sp,#0]
000042  462b              MOV      r3,r5
000044  2204              MOVS     r2,#4
000046  2101              MOVS     r1,#1
000048  a80a              ADD      r0,sp,#0x28
00004a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;212            Array<f32> xOut(1,4,scratch);
00004e  2300              MOVS     r3,#0
000050  461a              MOV      r2,r3
000052  2101              MOVS     r1,#1
000054  a81b              ADD      r0,sp,#0x6c
000056  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00005a  6800              LDR      r0,[r0,#0]
00005c  9000              STR      r0,[sp,#0]
00005e  462b              MOV      r3,r5
000060  2204              MOVS     r2,#4
000062  2101              MOVS     r1,#1
000064  a80f              ADD      r0,sp,#0x3c
000066  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;213            Array<f32> yOut(1,4,scratch);
00006a  2300              MOVS     r3,#0
00006c  461a              MOV      r2,r3
00006e  2101              MOVS     r1,#1
000070  a81c              ADD      r0,sp,#0x70
000072  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000076  6800              LDR      r0,[r0,#0]
000078  9000              STR      r0,[sp,#0]
00007a  462b              MOV      r3,r5
00007c  2204              MOVS     r2,#4
00007e  2101              MOVS     r1,#1
000080  a814              ADD      r0,sp,#0x50
000082  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;214    
;;;215            for(s32 i=0; i<4; i++) {
000086  2300              MOVS     r3,#0
                  |L36.136|
000088  9907              LDR      r1,[sp,#0x1c]
00008a  9809              LDR      r0,[sp,#0x24]
;;;216              xIn[0][i] = in.corners[i].x;
00008c  f04f0c00          MOV      r12,#0
000090  fb0c0001          MLA      r0,r12,r1,r0
000094  eb070cc3          ADD      r12,r7,r3,LSL #3
000098  eb000083          ADD      r0,r0,r3,LSL #2
00009c  eddc0a00          VLDR     s1,[r12,#0]
;;;217              yIn[0][i] = in.corners[i].y;
0000a0  2500              MOVS     r5,#0
0000a2  edc00a00          VSTR     s1,[r0,#0]            ;216
0000a6  990c              LDR      r1,[sp,#0x30]         ;216
0000a8  980e              LDR      r0,[sp,#0x38]         ;216
0000aa  eddc0a01          VLDR     s1,[r12,#4]
0000ae  fb050001          MLA      r0,r5,r1,r0
0000b2  eb000083          ADD      r0,r0,r3,LSL #2
0000b6  1c5b              ADDS     r3,r3,#1              ;215
0000b8  edc00a00          VSTR     s1,[r0,#0]
0000bc  2b04              CMP      r3,#4                 ;215
0000be  dbe3              BLT      |L36.136|
;;;218            }
;;;219    
;;;220            TransformPoints(xIn, yIn, scale, this->initialPointsAreZeroCentered, false, xOut, yOut);
0000c0  f8941038          LDRB     r1,[r4,#0x38]
0000c4  2200              MOVS     r2,#0
0000c6  ad0f              ADD      r5,sp,#0x3c
0000c8  f10d0c50          ADD      r12,sp,#0x50
0000cc  1d20              ADDS     r0,r4,#4
0000ce  8863              LDRH     r3,[r4,#2]
0000d0  e88d1027          STM      sp,{r0-r2,r5,r12}
0000d4  af05              ADD      r7,sp,#0x14
0000d6  f10d0828          ADD      r8,sp,#0x28
0000da  eeb00a48          VMOV.F32 s0,s16
0000de  f104023c          ADD      r2,r4,#0x3c
0000e2  4641              MOV      r1,r8
0000e4  4638              MOV      r0,r7
0000e6  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221TransformPointsStaticERKNS0_5ArrayIfEES6_fRKNS0_5PointIfEENS1_13TransformTypeES6_bbRS4_SC_ ; Anki::Embedded::Transformations::PlanarTransformation_f32::TransformPointsStatic(const Anki::Embedded::Array<float>&, const Anki::Embedded::Array<float>&, float, const Anki::Embedded::Point<float>&, Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Array<float>&, bool, bool, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
;;;221    
;;;222            Quadrilateral<f32> out;
0000ea  4630              MOV      r0,r6
0000ec  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1Ev ; Anki::Embedded::Quadrilateral<float>::Quadrilateral()
;;;223    
;;;224            for(s32 i=0; i<4; i++) {
0000f0  2100              MOVS     r1,#0
                  |L36.242|
0000f2  f8ddc044          LDR      r12,[sp,#0x44]
0000f6  9b13              LDR      r3,[sp,#0x4c]
;;;225              out.corners[i].x = xOut[0][i];
0000f8  2200              MOVS     r2,#0
0000fa  fb02320c          MLA      r2,r2,r12,r3
0000fe  eb020281          ADD      r2,r2,r1,LSL #2
;;;226              out.corners[i].y = yOut[0][i];
000102  2300              MOVS     r3,#0
000104  ed920a00          VLDR     s0,[r2,#0]            ;225
000108  eb0002c1          ADD      r2,r0,r1,LSL #3       ;225
00010c  ed820a00          VSTR     s0,[r2,#0]            ;225
000110  f8ddc060          LDR      r12,[sp,#0x60]        ;225
000114  9c16              LDR      r4,[sp,#0x58]         ;225
000116  fb03c304          MLA      r3,r3,r4,r12          ;225
00011a  eb030381          ADD      r3,r3,r1,LSL #2
00011e  1c49              ADDS     r1,r1,#1              ;224
000120  ed930a00          VLDR     s0,[r3,#0]
000124  2904              CMP      r1,#4                 ;224
000126  ed820a01          VSTR     s0,[r2,#4]
00012a  dbe2              BLT      |L36.242|
;;;227            }
;;;228    
;;;229            return out;
;;;230          }
00012c  b01e              ADD      sp,sp,#0x78
00012e  ecbd8b02          VPOP     {d8}
000132  e8bd81f0          POP      {r4-r8,pc}
;;;231    
                          ENDP


                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_15FixedLengthListINS0_5PointIsEEEERS6_NS0_11MemoryStackEf||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_15FixedLengthListINS0_5PointIsEEEERS6_NS0_11MemoryStackEf PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::Transform(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>&, Anki::Embedded::MemoryStack, float) const
;;;302    
;;;303          Result PlanarTransformation_f32::Transform(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;304            const FixedLengthList<Point<s16> > &in,
;;;305            FixedLengthList<Point<s16> > &out,
;;;306            MemoryStack scratch,
;;;307            const f32 scale
;;;308            ) const
;;;309          {
000004  4605              MOV      r5,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  b09d              SUB      sp,sp,#0x74
00000c  eeb08a40          VMOV.F32 s16,s0
000010  4698              MOV      r8,r3
000012  4616              MOV      r6,r2
000014  460f              MOV      r7,r1
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
;;;310            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
00001c  f8df91ac          LDR      r9,|L37.460|
000020  2800              CMP      r0,#0
000022  d019              BEQ      |L37.88|
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
00002a  2800              CMP      r0,#0
00002c  d014              BEQ      |L37.88|
00002e  68fc              LDR      r4,[r7,#0xc]
;;;311              RESULT_FAIL_INVALID_OBJECT, "PlanarTransformation_f32::Transform", "Invalid objects");
;;;312    
;;;313            AnkiConditionalErrorAndReturnValue(in.get_size() == out.get_size(),
000030  68f0              LDR      r0,[r6,#0xc]
000032  4284              CMP      r4,r0
000034  d01d              BEQ      |L37.114|
000036  f2401039          MOV      r0,#0x139
00003a  e9cd9000          STRD     r9,r0,[sp,#0]
00003e  a364              ADR      r3,|L37.464|
000040  a270              ADR      r2,|L37.516|
000042  a17a              ADR      r1,|L37.556|
000044  2005              MOVS     r0,#5
000046  f7fffffe          BL       _Anki_Log
00004a  f04f60a0          MOV      r0,#0x5000000
                  |L37.78|
;;;314              RESULT_FAIL_INVALID_SIZE, "PlanarTransformation_f32::Transform", "input and output are different sizes");
;;;315    
;;;316            const s32 numPoints = in.get_size();
;;;317    
;;;318            Array<f32> xIn(1,numPoints,scratch,Flags::Buffer(false,false,false));
;;;319            Array<f32> yIn(1,numPoints,scratch,Flags::Buffer(false,false,false));
;;;320            Array<f32> xOut(1,numPoints,scratch,Flags::Buffer(false,false,false));
;;;321            Array<f32> yOut(1,numPoints,scratch,Flags::Buffer(false,false,false));
;;;322    
;;;323            const Point<s16> * restrict pIn = in.Pointer(0);
;;;324    
;;;325            f32 * restrict pXIn  = xIn.Pointer(0,0);
;;;326            f32 * restrict pYIn  = yIn.Pointer(0,0);
;;;327    
;;;328            for(s32 i=0; i<numPoints; i++) {
;;;329              pXIn[i] = pIn[i].x;
;;;330              pYIn[i] = pIn[i].y;
;;;331            }
;;;332    
;;;333            TransformPoints(xIn, yIn, scale, false, false, xOut, yOut);
;;;334    
;;;335            const f32 * restrict pXOut = xOut.Pointer(0,0);
;;;336            const f32 * restrict pYOut = yOut.Pointer(0,0);
;;;337    
;;;338            Point<s16> * restrict pOut = out.Pointer(0);
;;;339    
;;;340            for(s32 i=0; i<numPoints; i++) {
;;;341              pOut[i].x = static_cast<s16>(Round<s32>(pXOut[i]));
;;;342              pOut[i].y = static_cast<s16>(Round<s32>(pYOut[i]));
;;;343            }
;;;344    
;;;345            return RESULT_OK;
;;;346          }
00004e  b01d              ADD      sp,sp,#0x74
000050  ecbd8b02          VPOP     {d8}
000054  e8bd83f0          POP      {r4-r9,pc}
                  |L37.88|
000058  f44f709b          MOV      r0,#0x136             ;310
00005c  e9cd9000          STRD     r9,r0,[sp,#0]         ;310
000060  a35b              ADR      r3,|L37.464|
000062  a27b              ADR      r2,|L37.592|
000064  a171              ADR      r1,|L37.556|
000066  2005              MOVS     r0,#5                 ;310
000068  f7fffffe          BL       _Anki_Log
00006c  f04f6080          MOV      r0,#0x4000000         ;310
000070  e7ed              B        |L37.78|
                  |L37.114|
000072  2300              MOVS     r3,#0                 ;318
000074  461a              MOV      r2,r3                 ;318
000076  4619              MOV      r1,r3                 ;318
000078  a819              ADD      r0,sp,#0x64           ;318
00007a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00007e  6800              LDR      r0,[r0,#0]            ;318
000080  9000              STR      r0,[sp,#0]            ;318
000082  4643              MOV      r3,r8                 ;318
000084  4622              MOV      r2,r4                 ;318
000086  2101              MOVS     r1,#1                 ;318
000088  a805              ADD      r0,sp,#0x14           ;318
00008a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00008e  2300              MOVS     r3,#0                 ;319
000090  461a              MOV      r2,r3                 ;319
000092  4619              MOV      r1,r3                 ;319
000094  a81a              ADD      r0,sp,#0x68           ;319
000096  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00009a  6800              LDR      r0,[r0,#0]            ;319
00009c  9000              STR      r0,[sp,#0]            ;319
00009e  4643              MOV      r3,r8                 ;319
0000a0  4622              MOV      r2,r4                 ;319
0000a2  2101              MOVS     r1,#1                 ;319
0000a4  a80a              ADD      r0,sp,#0x28           ;319
0000a6  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0000aa  2300              MOVS     r3,#0                 ;320
0000ac  461a              MOV      r2,r3                 ;320
0000ae  4619              MOV      r1,r3                 ;320
0000b0  a81b              ADD      r0,sp,#0x6c           ;320
0000b2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000b6  6800              LDR      r0,[r0,#0]            ;320
0000b8  9000              STR      r0,[sp,#0]            ;320
0000ba  4643              MOV      r3,r8                 ;320
0000bc  4622              MOV      r2,r4                 ;320
0000be  2101              MOVS     r1,#1                 ;320
0000c0  a80f              ADD      r0,sp,#0x3c           ;320
0000c2  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0000c6  2300              MOVS     r3,#0                 ;321
0000c8  461a              MOV      r2,r3                 ;321
0000ca  4619              MOV      r1,r3                 ;321
0000cc  a81c              ADD      r0,sp,#0x70           ;321
0000ce  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000d2  6800              LDR      r0,[r0,#0]            ;321
0000d4  9000              STR      r0,[sp,#0]            ;321
0000d6  4643              MOV      r3,r8                 ;321
0000d8  4622              MOV      r2,r4                 ;321
0000da  2101              MOVS     r1,#1                 ;321
0000dc  a814              ADD      r0,sp,#0x50           ;321
0000de  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0000e2  2000              MOVS     r0,#0                 ;325
0000e4  9b07              LDR      r3,[sp,#0x1c]         ;325
0000e6  9a09              LDR      r2,[sp,#0x24]         ;325
0000e8  f8ddc030          LDR      r12,[sp,#0x30]        ;325
0000ec  fb002303          MLA      r3,r0,r3,r2           ;325
0000f0  9a0e              LDR      r2,[sp,#0x38]         ;325
0000f2  6b39              LDR      r1,[r7,#0x30]         ;325
0000f4  fb00220c          MLA      r2,r0,r12,r2          ;325
0000f8  2c00              CMP      r4,#0                 ;328
0000fa  dd18              BLE      |L37.302|
                  |L37.252|
0000fc  f931c020          LDRSH    r12,[r1,r0,LSL #2]    ;329
000100  ee00ca90          VMOV     s1,r12                ;329
000104  eb030c80          ADD      r12,r3,r0,LSL #2      ;329
000108  eef80ae0          VCVT.F32.S32 s1,s1                 ;329
00010c  edcc0a00          VSTR     s1,[r12,#0]           ;329
000110  eb010c80          ADD      r12,r1,r0,LSL #2      ;330
000114  f9bcc002          LDRSH    r12,[r12,#2]          ;330
000118  ee00ca90          VMOV     s1,r12                ;330
00011c  eb020c80          ADD      r12,r2,r0,LSL #2      ;330
000120  1c40              ADDS     r0,r0,#1              ;328
000122  eef80ae0          VCVT.F32.S32 s1,s1                 ;330
000126  4284              CMP      r4,r0                 ;328
000128  edcc0a00          VSTR     s1,[r12,#0]           ;330
00012c  dce6              BGT      |L37.252|
                  |L37.302|
00012e  2200              MOVS     r2,#0                 ;333
000130  4617              MOV      r7,r2                 ;333
000132  f10d083c          ADD      r8,sp,#0x3c           ;333
000136  f10d0c50          ADD      r12,sp,#0x50          ;333
00013a  1d28              ADDS     r0,r5,#4              ;333
00013c  886b              LDRH     r3,[r5,#2]            ;333
00013e  e88d1185          STM      sp,{r0,r2,r7,r8,r12}  ;333
000142  f10d0914          ADD      r9,sp,#0x14           ;333
000146  a90a              ADD      r1,sp,#0x28           ;333
000148  eeb00a48          VMOV.F32 s0,s16                ;333
00014c  f105023c          ADD      r2,r5,#0x3c           ;333
000150  4648              MOV      r0,r9                 ;333
000152  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221TransformPointsStaticERKNS0_5ArrayIfEES6_fRKNS0_5PointIfEENS1_13TransformTypeES6_bbRS4_SC_ ; Anki::Embedded::Transformations::PlanarTransformation_f32::TransformPointsStatic(const Anki::Embedded::Array<float>&, const Anki::Embedded::Array<float>&, float, const Anki::Embedded::Point<float>&, Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Array<float>&, bool, bool, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
000156  9a11              LDR      r2,[sp,#0x44]         ;333
000158  9913              LDR      r1,[sp,#0x4c]         ;333
00015a  2000              MOVS     r0,#0                 ;335
00015c  fb001c02          MLA      r12,r0,r2,r1          ;335
000160  9a16              LDR      r2,[sp,#0x58]         ;335
000162  9918              LDR      r1,[sp,#0x60]         ;335
000164  2c00              CMP      r4,#0                 ;340
000166  fb001302          MLA      r3,r0,r2,r1           ;340
00016a  6b32              LDR      r2,[r6,#0x30]         ;340
00016c  bfc8              IT       GT                    ;340
00016e  eddf0a3c          VLDRGT   s1,|L37.608|
000172  dd29              BLE      |L37.456|
                  |L37.372|
000174  eb0c0180          ADD      r1,r12,r0,LSL #2      ;341
000178  ed910a00          VLDR     s0,[r1,#0]            ;341
00017c  eeb50ac0          VCMPE.F32 s0,#0.0               ;341
000180  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;341
000184  bfcc              ITE      GT                    ;341
000186  ee300a20          VADDGT.F32 s0,s0,s1              ;341
00018a  ee300a60          VSUBLE.F32 s0,s0,s1              ;341
00018e  eebd0ac0          VCVT.S32.F32 s0,s0                 ;341
000192  ee101a10          VMOV     r1,s0                 ;341
000196  f8221020          STRH     r1,[r2,r0,LSL #2]     ;341
00019a  eb030180          ADD      r1,r3,r0,LSL #2       ;342
00019e  ed910a00          VLDR     s0,[r1,#0]            ;342
0001a2  eeb50ac0          VCMPE.F32 s0,#0.0               ;342
0001a6  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;342
0001aa  bfcc              ITE      GT                    ;342
0001ac  ee300a20          VADDGT.F32 s0,s0,s1              ;342
0001b0  ee300a60          VSUBLE.F32 s0,s0,s1              ;342
0001b4  eebd0ac0          VCVT.S32.F32 s0,s0                 ;342
0001b8  eb020580          ADD      r5,r2,r0,LSL #2       ;342
0001bc  1c40              ADDS     r0,r0,#1              ;340
0001be  ee101a10          VMOV     r1,s0                 ;340
0001c2  42a0              CMP      r0,r4                 ;340
0001c4  8069              STRH     r1,[r5,#2]            ;342
0001c6  dbd5              BLT      |L37.372|
                  |L37.456|
0001c8  2000              MOVS     r0,#0                 ;345
0001ca  e740              B        |L37.78|
;;;347    
                          ENDP

                  |L37.460|
                          DCD      ||.constdata||+0x19b
                  |L37.464|
0001d0  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\transformations.cpp",0
0001d4  6f726574
0001d8  6563685c
0001dc  76697369
0001e0  6f6e5c72
0001e4  6f626f74
0001e8  5c737263
0001ec  5c747261
0001f0  6e73666f
0001f4  726d6174
0001f8  696f6e73
0001fc  2e637070
000200  00      
000201  00                DCB      0
000202  00                DCB      0
000203  00                DCB      0
                  |L37.516|
000204  696e7075          DCB      "input and output are different sizes",0
000208  7420616e
00020c  64206f75
000210  74707574
000214  20617265
000218  20646966
00021c  66657265
000220  6e742073
000224  697a6573
000228  00      
000229  00                DCB      0
00022a  00                DCB      0
00022b  00                DCB      0
                  |L37.556|
00022c  506c616e          DCB      "PlanarTransformation_f32::Transform",0
000230  61725472
000234  616e7366
000238  6f726d61
00023c  74696f6e
000240  5f663332
000244  3a3a5472
000248  616e7366
00024c  6f726d00
                  |L37.592|
000250  496e7661          DCB      "Invalid objects",0
000254  6c696420
000258  6f626a65
00025c  63747300
                  |L37.608|
000260  3f000000          DCFS     0x3f000000 ; 0.5

                          AREA ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_5ArrayIhEERS4_NS0_11MemoryStackEf||, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_5ArrayIhEERS4_NS0_11MemoryStackEf PROC ; Anki::Embedded::Transformations::PlanarTransformation_f32::Transform(const Anki::Embedded::Array<unsigned char>&, Anki::Embedded::Array<unsigned char>&, Anki::Embedded::MemoryStack, float) const
;;;231    
;;;232          Result PlanarTransformation_f32::Transform(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;233            const Array<u8> &in,
;;;234            Array<u8> &out,
;;;235            MemoryStack scratch,
;;;236            const f32 scale) const
;;;237          {
000004  4607              MOV      r7,r0
000006  ed2d0b02          VPUSH    {d0}
00000a  4614              MOV      r4,r2
;;;238            Result lastResult;
;;;239    
;;;240            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
00000c  4eaa              LDR      r6,|L38.696|
00000e  460d              MOV      r5,r1                 ;237
000010  ed2d8b02          VPUSH    {d8}                  ;237
000014  b0a3              SUB      sp,sp,#0x8c           ;237
000016  6908              LDR      r0,[r1,#0x10]         ;237
000018  eeb08a40          VMOV.F32 s16,s0                ;237
00001c  2800              CMP      r0,#0                 ;237
00001e  d07d              BEQ      |L38.284|
000020  6828              LDR      r0,[r5,#0]            ;237
000022  2800              CMP      r0,#0                 ;237
000024  bfa4              ITT      GE                    ;237
000026  6868              LDRGE    r0,[r5,#4]            ;237
000028  2800              CMPGE    r0,#0                 ;237
00002a  db77              BLT      |L38.284|
00002c  6920              LDR      r0,[r4,#0x10]         ;237
00002e  2800              CMP      r0,#0                 ;237
000030  d074              BEQ      |L38.284|
000032  6820              LDR      r0,[r4,#0]            ;237
000034  2800              CMP      r0,#0                 ;237
000036  bfa4              ITT      GE                    ;237
000038  6860              LDRGE    r0,[r4,#4]            ;237
00003a  2800              CMPGE    r0,#0                 ;237
00003c  db7c              BLT      |L38.312|
;;;241              RESULT_FAIL_INVALID_OBJECT, "PlanarTransformation_f32::Transform", "Invalid objects");
;;;242    
;;;243            AnkiConditionalErrorAndReturnValue(AreEqualSize(in, out),
00003e  4611              MOV      r1,r2
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIhEES3_EEbRKT_RKT0_ ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<unsigned char>>(const T1&, const T2&)
000046  2800              CMP      r0,#0
000048  d069              BEQ      |L38.286|
00004a  6929              LDR      r1,[r5,#0x10]
00004c  f04f0900          MOV      r9,#0
000050  2900              CMP      r1,#0
000052  f000808e          BEQ.W    |L38.370|
000056  6828              LDR      r0,[r5,#0]
000058  2800              CMP      r0,#0
00005a  bfa4              ITT      GE
00005c  6868              LDRGE    r0,[r5,#4]
00005e  2800              CMPGE    r0,#0
000060  f2c08087          BLT.W    |L38.370|
000064  6920              LDR      r0,[r4,#0x10]
000066  2800              CMP      r0,#0
000068  f0008083          BEQ.W    |L38.370|
00006c  6822              LDR      r2,[r4,#0]
00006e  2a00              CMP      r2,#0
000070  bfa4              ITT      GE
000072  6862              LDRGE    r2,[r4,#4]
000074  2a00              CMPGE    r2,#0
000076  f2c0807c          BLT.W    |L38.370|
00007a  e9cd1000          STRD     r1,r0,[sp,#0]
00007e  2100              MOVS     r1,#0
000080  466a              MOV      r2,sp
                  |L38.130|
000082  1c48              ADDS     r0,r1,#1
000084  2802              CMP      r0,#2
000086  bfb8              IT       LT
000088  f8523021          LDRLT    r3,[r2,r1,LSL #2]
00008c  da06              BGE      |L38.156|
                  |L38.142|
00008e  f852c020          LDR      r12,[r2,r0,LSL #2]
000092  4563              CMP      r3,r12
000094  d06d              BEQ      |L38.370|
000096  1c40              ADDS     r0,r0,#1
000098  2802              CMP      r0,#2
00009a  dbf8              BLT      |L38.142|
                  |L38.156|
00009c  1c49              ADDS     r1,r1,#1
00009e  2902              CMP      r1,#2
0000a0  dbef              BLT      |L38.130|
;;;244              RESULT_FAIL_INVALID_SIZE, "PlanarTransformation_f32::Transform", "input and output are different sizes");
;;;245    
;;;246            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;247              RESULT_FAIL_ALIASED_MEMORY, "PlanarTransformation_f32::Transform", "in and out cannot be the same");
;;;248    
;;;249            const s32 arrHeight = in.get_size(0);
0000a2  2100              MOVS     r1,#0
0000a4  4628              MOV      r0,r5
0000a6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000aa  4680              MOV      r8,r0
;;;250            const s32 arrWidth = in.get_size(1);
0000ac  2101              MOVS     r1,#1
0000ae  4628              MOV      r0,r5
0000b0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000b4  4606              MOV      r6,r0
;;;251    
;;;252            Array<f32> homographyInv(3,3,scratch);
0000b6  2300              MOVS     r3,#0
0000b8  461a              MOV      r2,r3
0000ba  2101              MOVS     r1,#1
0000bc  a81e              ADD      r0,sp,#0x78
0000be  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000c2  6800              LDR      r0,[r0,#0]
0000c4  9000              STR      r0,[sp,#0]
0000c6  2203              MOVS     r2,#3
0000c8  4611              MOV      r1,r2
0000ca  a805              ADD      r0,sp,#0x14
0000cc  9b2a              LDR      r3,[sp,#0xa8]
0000ce  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;253            homographyInv.Set(this->homography);
0000d2  1d39              ADDS     r1,r7,#4
0000d4  a805              ADD      r0,sp,#0x14
0000d6  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE3SetERKS2_ ; Anki::Embedded::Array<float>::Set(const Anki::Embedded::Array<float>&)
0000da  9a07              LDR      r2,[sp,#0x1c]
0000dc  9909              LDR      r1,[sp,#0x24]
;;;254    
;;;255            Invert3x3(
0000de  2002              MOVS     r0,#2
0000e0  fb001002          MLA      r0,r0,r2,r1
0000e4  f8ddc01c          LDR      r12,[sp,#0x1c]
0000e8  9a09              LDR      r2,[sp,#0x24]
0000ea  2101              MOVS     r1,#1
0000ec  fb012c0c          MLA      r12,r1,r12,r2
0000f0  f10c0208          ADD      r2,r12,#8
0000f4  f8cdc07c          STR      r12,[sp,#0x7c]
0000f8  f8ddb01c          LDR      r11,[sp,#0x1c]
0000fc  f8dda024          LDR      r10,[sp,#0x24]
000100  f04f0c00          MOV      r12,#0
000104  fb0cac0b          MLA      r12,r12,r11,r10
000108  1d03              ADDS     r3,r0,#4
00010a  1f11              SUBS     r1,r2,#4
00010c  f1000e08          ADD      lr,r0,#8
000110  f10c0b08          ADD      r11,r12,#8
000114  f10c0a04          ADD      r10,r12,#4
000118  9100              STR      r1,[sp,#0]
00011a  e001              B        |L38.288|
                  |L38.284|
00011c  e00c              B        |L38.312|
                  |L38.286|
00011e  e01c              B        |L38.346|
                  |L38.288|
000120  e9cd2001          STRD     r2,r0,[sp,#4]
000124  e9cd3e03          STRD     r3,lr,[sp,#0xc]
000128  465a              MOV      r2,r11
00012a  4651              MOV      r1,r10
00012c  4660              MOV      r0,r12
00012e  9b1f              LDR      r3,[sp,#0x7c]
000130  f7fffffe          BL       _ZN4Anki8Embedded9Invert3x3IfEEvRT_S3_S3_S3_S3_S3_S3_S3_S3_ ; Anki::Embedded::Invert3x3<float>(T1&, T1&, T1&, T1&, T1&, T1&, T1&, T1&, T1&)
;;;256              homographyInv[0][0], homographyInv[0][1], homographyInv[0][2],
;;;257              homographyInv[1][0], homographyInv[1][1], homographyInv[1][2],
;;;258              homographyInv[2][0], homographyInv[2][1], homographyInv[2][2]);
;;;259    
;;;260            for(s32 y=0; y<3; y++) {
000134  2200              MOVS     r2,#0
000136  e027              B        |L38.392|
                  |L38.312|
000138  20f0              MOVS     r0,#0xf0              ;240
00013a  e9cd6000          STRD     r6,r0,[sp,#0]         ;240
00013e  a35f              ADR      r3,|L38.700|
000140  a26b              ADR      r2,|L38.752|
000142  a16f              ADR      r1,|L38.768|
000144  2005              MOVS     r0,#5                 ;240
000146  f7fffffe          BL       _Anki_Log
00014a  f04f6080          MOV      r0,#0x4000000         ;240
                  |L38.334|
;;;261              for(s32 x=0; x<3; x++) {
;;;262                homographyInv[y][x] /= homographyInv[2][2];
;;;263              }
;;;264            }
;;;265    
;;;266            //const s32 numPoints = in.get_size(0) * in.get_size(1);
;;;267    
;;;268            Array<f32> xIn(arrHeight,arrWidth,scratch);
;;;269            Array<f32> yIn(arrHeight,arrWidth,scratch);
;;;270            Array<f32> xTransformed(arrHeight,arrWidth,scratch);
;;;271            Array<f32> yTransformed(arrHeight,arrWidth,scratch);
;;;272    
;;;273            //s32 ci = 0;
;;;274            for(s32 y=0; y<arrHeight; y++) {
;;;275              f32 * restrict pXIn = xIn.Pointer(y,0);
;;;276              f32 * restrict pYIn = yIn.Pointer(y,0);
;;;277    
;;;278              for(s32 x=0; x<arrWidth; x++) {
;;;279                pXIn[x] = static_cast<f32>(x);
;;;280                pYIn[x] = static_cast<f32>(y);
;;;281              }
;;;282            }
;;;283    
;;;284            TransformPointsStatic(
;;;285              xIn, yIn, scale,
;;;286              this->centerOffset,
;;;287              this->get_transformType(), homographyInv,
;;;288              false, false,
;;;289              xTransformed, yTransformed);
;;;290    
;;;291            /*xIn.Print("xIn", 0,10,0,10);
;;;292            yIn.Print("yIn", 0,10,0,10);
;;;293    
;;;294            xTransformed.Print("xTransformed", 0,10,0,10);
;;;295            yTransformed.Print("yTransformed", 0,10,0,10);*/
;;;296    
;;;297            if((lastResult = Interp2<u8,u8>(in, xTransformed, yTransformed, out, INTERPOLATE_LINEAR, 0)) != RESULT_OK)
;;;298              return lastResult;
;;;299    
;;;300            return RESULT_OK;
;;;301          }
00014e  b023              ADD      sp,sp,#0x8c
000150  ecbd8b02          VPOP     {d8}
000154  b006              ADD      sp,sp,#0x18
000156  e8bd8ff0          POP      {r4-r11,pc}
                  |L38.346|
00015a  20f3              MOVS     r0,#0xf3              ;243
00015c  e9cd6000          STRD     r6,r0,[sp,#0]         ;243
000160  a356              ADR      r3,|L38.700|
000162  a270              ADR      r2,|L38.804|
000164  a166              ADR      r1,|L38.768|
000166  2005              MOVS     r0,#5                 ;243
000168  f7fffffe          BL       _Anki_Log
00016c  f04f60a0          MOV      r0,#0x5000000         ;243
000170  e7ed              B        |L38.334|
                  |L38.370|
000172  20f6              MOVS     r0,#0xf6              ;246
000174  e9cd6000          STRD     r6,r0,[sp,#0]         ;246
000178  a350              ADR      r3,|L38.700|
00017a  a274              ADR      r2,|L38.844|
00017c  a160              ADR      r1,|L38.768|
00017e  2005              MOVS     r0,#5                 ;246
000180  f7fffffe          BL       _Anki_Log
000184  4879              LDR      r0,|L38.876|
000186  e7e2              B        |L38.334|
                  |L38.392|
000188  2000              MOVS     r0,#0                 ;261
                  |L38.394|
00018a  9b07              LDR      r3,[sp,#0x1c]         ;261
00018c  9909              LDR      r1,[sp,#0x24]         ;261
00018e  f8ddc024          LDR      r12,[sp,#0x24]        ;261
000192  fb021103          MLA      r1,r2,r3,r1           ;261
000196  f8dda01c          LDR      r10,[sp,#0x1c]        ;261
00019a  2302              MOVS     r3,#2                 ;262
00019c  fb03c30a          MLA      r3,r3,r10,r12         ;262
0001a0  eb010180          ADD      r1,r1,r0,LSL #2       ;262
0001a4  edd30a02          VLDR     s1,[r3,#8]            ;262
0001a8  ed911a00          VLDR     s2,[r1,#0]            ;262
0001ac  1c40              ADDS     r0,r0,#1              ;261
0001ae  2803              CMP      r0,#3                 ;261
0001b0  eec11a20          VDIV.F32 s3,s2,s1              ;262
0001b4  edc11a00          VSTR     s3,[r1,#0]            ;262
0001b8  dbe7              BLT      |L38.394|
0001ba  1c52              ADDS     r2,r2,#1              ;260
0001bc  2a03              CMP      r2,#3                 ;260
0001be  dbe3              BLT      |L38.392|
0001c0  2300              MOVS     r3,#0                 ;268
0001c2  461a              MOV      r2,r3                 ;268
0001c4  2101              MOVS     r1,#1                 ;268
0001c6  a81e              ADD      r0,sp,#0x78           ;268
0001c8  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001cc  6800              LDR      r0,[r0,#0]            ;268
0001ce  9000              STR      r0,[sp,#0]            ;268
0001d0  4632              MOV      r2,r6                 ;268
0001d2  4641              MOV      r1,r8                 ;268
0001d4  a814              ADD      r0,sp,#0x50           ;268
0001d6  9b2a              LDR      r3,[sp,#0xa8]         ;268
0001d8  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0001dc  2300              MOVS     r3,#0                 ;269
0001de  461a              MOV      r2,r3                 ;269
0001e0  2101              MOVS     r1,#1                 ;269
0001e2  a820              ADD      r0,sp,#0x80           ;269
0001e4  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001e8  6800              LDR      r0,[r0,#0]            ;269
0001ea  9000              STR      r0,[sp,#0]            ;269
0001ec  4632              MOV      r2,r6                 ;269
0001ee  4641              MOV      r1,r8                 ;269
0001f0  a819              ADD      r0,sp,#0x64           ;269
0001f2  9b2a              LDR      r3,[sp,#0xa8]         ;269
0001f4  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0001f8  2300              MOVS     r3,#0                 ;270
0001fa  461a              MOV      r2,r3                 ;270
0001fc  2101              MOVS     r1,#1                 ;270
0001fe  a821              ADD      r0,sp,#0x84           ;270
000200  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000204  6800              LDR      r0,[r0,#0]            ;270
000206  9000              STR      r0,[sp,#0]            ;270
000208  4632              MOV      r2,r6                 ;270
00020a  4641              MOV      r1,r8                 ;270
00020c  a80a              ADD      r0,sp,#0x28           ;270
00020e  9b2a              LDR      r3,[sp,#0xa8]         ;270
000210  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000214  2300              MOVS     r3,#0                 ;271
000216  461a              MOV      r2,r3                 ;271
000218  2101              MOVS     r1,#1                 ;271
00021a  a822              ADD      r0,sp,#0x88           ;271
00021c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000220  6800              LDR      r0,[r0,#0]            ;271
000222  9000              STR      r0,[sp,#0]            ;271
000224  4632              MOV      r2,r6                 ;271
000226  4641              MOV      r1,r8                 ;271
000228  a80f              ADD      r0,sp,#0x3c           ;271
00022a  9b2a              LDR      r3,[sp,#0xa8]         ;271
00022c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000230  2100              MOVS     r1,#0                 ;274
000232  f1b80f00          CMP      r8,#0                 ;274
000236  dd20              BLE      |L38.634|
                  |L38.568|
000238  9a16              LDR      r2,[sp,#0x58]         ;274
00023a  9818              LDR      r0,[sp,#0x60]         ;274
00023c  9b1b              LDR      r3,[sp,#0x6c]         ;274
00023e  fb010202          MLA      r2,r1,r2,r0           ;274
000242  981d              LDR      r0,[sp,#0x74]         ;274
000244  fb010303          MLA      r3,r1,r3,r0           ;274
000248  2000              MOVS     r0,#0                 ;278
00024a  2e00              CMP      r6,#0                 ;278
00024c  dd12              BLE      |L38.628|
                  |L38.590|
00024e  ee000a90          VMOV     s1,r0                 ;279
000252  eb020c80          ADD      r12,r2,r0,LSL #2      ;279
000256  eef80ae0          VCVT.F32.S32 s1,s1                 ;279
00025a  edcc0a00          VSTR     s1,[r12,#0]           ;279
00025e  ee001a90          VMOV     s1,r1                 ;280
000262  eb030c80          ADD      r12,r3,r0,LSL #2      ;280
000266  1c40              ADDS     r0,r0,#1              ;278
000268  eef80ae0          VCVT.F32.S32 s1,s1                 ;280
00026c  4286              CMP      r6,r0                 ;278
00026e  edcc0a00          VSTR     s1,[r12,#0]           ;280
000272  dcec              BGT      |L38.590|
                  |L38.628|
000274  1c49              ADDS     r1,r1,#1              ;274
000276  4541              CMP      r1,r8                 ;274
000278  dbde              BLT      |L38.568|
                  |L38.634|
00027a  887b              LDRH     r3,[r7,#2]            ;274
00027c  a80f              ADD      r0,sp,#0x3c           ;284
00027e  a90a              ADD      r1,sp,#0x28           ;284
000280  f8cd9004          STR      r9,[sp,#4]            ;284
000284  f8cd9008          STR      r9,[sp,#8]            ;284
000288  e9cd1003          STRD     r1,r0,[sp,#0xc]       ;284
00028c  a805              ADD      r0,sp,#0x14           ;284
00028e  9000              STR      r0,[sp,#0]            ;284
000290  f107023c          ADD      r2,r7,#0x3c           ;284
000294  eeb00a48          VMOV.F32 s0,s16                ;284
000298  a919              ADD      r1,sp,#0x64           ;284
00029a  a814              ADD      r0,sp,#0x50           ;284
00029c  f7fffffe          BL       _ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221TransformPointsStaticERKNS0_5ArrayIfEES6_fRKNS0_5PointIfEENS1_13TransformTypeES6_bbRS4_SC_ ; Anki::Embedded::Transformations::PlanarTransformation_f32::TransformPointsStatic(const Anki::Embedded::Array<float>&, const Anki::Embedded::Array<float>&, float, const Anki::Embedded::Point<float>&, Anki::Embedded::Transformations::TransformType, const Anki::Embedded::Array<float>&, bool, bool, Anki::Embedded::Array<float>&, Anki::Embedded::Array<float>&)
0002a0  f8cd9000          STR      r9,[sp,#0]            ;297
0002a4  4623              MOV      r3,r4                 ;297
0002a6  aa0f              ADD      r2,sp,#0x3c           ;297
0002a8  a90a              ADD      r1,sp,#0x28           ;297
0002aa  4628              MOV      r0,r5                 ;297
0002ac  f8cd9004          STR      r9,[sp,#4]            ;297
0002b0  f7fffffe          BL       _ZN4Anki8Embedded7Interp2IhhEENS_6ResultERKNS0_5ArrayIT_EERKNS3_IfEESA_RNS3_IT0_EENS0_17InterpolationTypeESB_ ; Anki::Embedded::Interp2<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Array<float>&, Anki::Embedded::Array<T2>&, Anki::Embedded::InterpolationType, T2)
0002b4  2800              CMP      r0,#0                 ;297
0002b6  e74a              B        |L38.334|
;;;302    
                          ENDP

                  |L38.696|
                          DCD      ||.constdata||+0xc9
                  |L38.700|
0002bc  2e2e5c63          DCB      "..\\coretech\\vision\\robot\\src\\transformations.cpp",0
0002c0  6f726574
0002c4  6563685c
0002c8  76697369
0002cc  6f6e5c72
0002d0  6f626f74
0002d4  5c737263
0002d8  5c747261
0002dc  6e73666f
0002e0  726d6174
0002e4  696f6e73
0002e8  2e637070
0002ec  00      
0002ed  00                DCB      0
0002ee  00                DCB      0
0002ef  00                DCB      0
                  |L38.752|
0002f0  496e7661          DCB      "Invalid objects",0
0002f4  6c696420
0002f8  6f626a65
0002fc  63747300
                  |L38.768|
000300  506c616e          DCB      "PlanarTransformation_f32::Transform",0
000304  61725472
000308  616e7366
00030c  6f726d61
000310  74696f6e
000314  5f663332
000318  3a3a5472
00031c  616e7366
000320  6f726d00
                  |L38.804|
000324  696e7075          DCB      "input and output are different sizes",0
000328  7420616e
00032c  64206f75
000330  74707574
000334  20617265
000338  20646966
00033c  66657265
000340  6e742073
000344  697a6573
000348  00      
000349  00                DCB      0
00034a  00                DCB      0
00034b  00                DCB      0
                  |L38.844|
00034c  696e2061          DCB      "in and out cannot be the same",0
000350  6e64206f
000354  75742063
000358  616e6e6f
00035c  74206265
000360  20746865
000364  2073616d
000368  6500    
00036a  00                DCB      0
00036b  00                DCB      0
                  |L38.876|
                          DCD      0x01000003

                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f324InitENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f324InitENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.40||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.40||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.41||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.42||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.43||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5ArrayIfEERKNS0_5PointIfEERNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.44||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5PointIfEERNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_13QuadrilateralIfEERKNS0_5PointIfEERNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.45||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_5PointIfEERNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1ENS1_13TransformTypeERKNS0_5PointIfEERNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.46||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f32C1Ev||
                          DCD      0x00000001

                          AREA ||area_number.47||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3214get_homographyEv||
                          DCD      0x00000001

                          AREA ||area_number.48||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3217get_transformTypeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.48||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3217get_transformTypeEv||
                          DCD      0x00000001

                          AREA ||area_number.49||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221TransformPointsStaticERKNS0_5ArrayIfEES6_fRKNS0_5PointIfEENS1_13TransformTypeES6_bbRS4_SC_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.49||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221TransformPointsStaticERKNS0_5ArrayIfEES6_fRKNS0_5PointIfEENS1_13TransformTypeES6_bbRS4_SC_||
                          DCD      0x00000001

                          AREA ||area_number.50||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3215TransformPointsERKNS0_5ArrayIfEES6_fbbRS4_S7_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.50||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3215TransformPointsERKNS0_5ArrayIfEES6_fbbRS4_S7_||
                          DCD      0x00000001

                          AREA ||area_number.51||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f326UpdateERKNS0_5ArrayIfEEfNS0_11MemoryStackENS1_13TransformTypeE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f326UpdateERKNS0_5ArrayIfEEfNS0_11MemoryStackENS1_13TransformTypeE||
                          DCD      0x00000001

                          AREA ||area_number.52||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f325PrintEPKc||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.52||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f325PrintEPKc||
                          DCD      0x00000001

                          AREA ||area_number.53||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_13QuadrilateralIfEENS0_11MemoryStackEf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_13QuadrilateralIfEENS0_11MemoryStackEf||
                          DCD      0x00000001

                          AREA ||area_number.54||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_5ArrayIhEERS4_NS0_11MemoryStackEf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.54||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_5ArrayIhEERS4_NS0_11MemoryStackEf||
                          DCD      0x00000001

                          AREA ||area_number.55||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_15FixedLengthListINS0_5PointIsEEEERS6_NS0_11MemoryStackEf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.55||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329TransformERKNS0_15FixedLengthListINS0_5PointIsEEEERS6_NS0_11MemoryStackEf||
                          DCD      0x00000001

                          AREA ||area_number.56||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.56||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3216get_centerOffsetEf||
                          DCD      0x00000001

                          AREA ||area_number.57||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3247VerifyTransformation_Projective_NearestNeighborERKNS0_5ArrayIhEERKNS0_13IntegerCountsERKNS0_9RectangleIfEES6_S9_ffihRiSE_SE_NS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3247VerifyTransformation_Projective_NearestNeighborERKNS0_5ArrayIhEERKNS0_13IntegerCountsERKNS0_9RectangleIfEES6_S9_ffihRiSE_SE_NS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.58||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3249VerifyTransformation_Projective_LinearInterpolateERKNS0_5ArrayIhEERKNS0_9RectangleIfEES6_ffihRiSB_SB_NS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3249VerifyTransformation_Projective_LinearInterpolateERKNS0_5ArrayIhEERKNS0_9RectangleIfEES6_ffihRiSB_SB_NS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.59||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f327IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.59||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f327IsValidEv||
                          DCD      0x00000001

                          AREA ||area_number.60||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3217set_transformTypeENS1_13TransformTypeE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3217set_transformTypeENS1_13TransformTypeE||
                          DCD      0x00000001

                          AREA ||area_number.61||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3214set_homographyERKNS0_5ArrayIfEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.61||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3214set_homographyERKNS0_5ArrayIfEE||
                          DCD      0x00000001

                          AREA ||area_number.62||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f323SetERKS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.62||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f323SetERKS2_||
                          DCD      0x00000001

                          AREA ||area_number.63||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3212SerializeRawEPKcPPvRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.63||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3212SerializeRawEPKcPPvRi||
                          DCD      0x00000001

                          AREA ||area_number.64||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221get_serializationSizeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.64||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3221get_serializationSizeEv||
                          DCD      0x00000001

                          AREA ||area_number.65||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329SerializeEPKcRNS0_16SerializedBufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.65||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f329SerializeEPKcRNS0_16SerializedBufferE||
                          DCD      0x00000001

                          AREA ||area_number.66||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3211DeserializeEPcPPvRiRNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.66||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3211DeserializeEPcPPvRiRNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.67||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3218set_initialCornersERKNS0_13QuadrilateralIfEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.67||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3218set_initialCornersERKNS0_13QuadrilateralIfEE||
                          DCD      0x00000001

                          AREA ||area_number.68||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3218get_initialCornersEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.68||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3218get_initialCornersEv||
                          DCD      0x00000001

                          AREA ||area_number.69||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3232set_initialPointsAreZeroCenteredEb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.69||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3232set_initialPointsAreZeroCenteredEb||
                          DCD      0x00000001

                          AREA ||area_number.70||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3233get_initialPointsAreZeroCeneteredEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.70||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3233get_initialPointsAreZeroCeneteredEv||
                          DCD      0x00000001

                          AREA ||area_number.71||, LINKORDER=||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3216set_centerOffsetERKNS0_5PointIfEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.71||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations24PlanarTransformation_f3216set_centerOffsetERKNS0_5PointIfEE||
                          DCD      0x00000001

                          AREA ||area_number.72||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3222get_transformedCornersENS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.72||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3222get_transformedCornersENS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.73||, LINKORDER=||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3226get_transformedOrientationENS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.73||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3226get_transformedOrientationENS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.74||, LINKORDER=||i._ZN4Anki8Embedded15Transformations26ComputeHomographyFromQuadsERKNS0_13QuadrilateralIfEES5_RNS0_5ArrayIfEERbNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.74||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations26ComputeHomographyFromQuadsERKNS0_13QuadrilateralIfEES5_RNS0_5ArrayIfEERbNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.75||, LINKORDER=||i._ZN4Anki8Embedded15Transformations25ComputeHomographyFromQuadERKNS0_13QuadrilateralIfEERNS0_5ArrayIfEERbNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.75||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations25ComputeHomographyFromQuadERKNS0_13QuadrilateralIfEERNS0_5ArrayIfEERbNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.76||, LINKORDER=||i._ZN4Anki8Embedded15Transformations25ComputeHomographyFromQuadERKNS0_13QuadrilateralIsEERNS0_5ArrayIfEERbNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.76||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15Transformations25ComputeHomographyFromQuadERKNS0_13QuadrilateralIsEERNS0_5ArrayIfEERbNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  __PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a547261          DCB      0x3a,0x54,0x72,0x61
000020  6e73666f          DCB      0x6e,0x73,0x66,0x6f
000024  726d6174          DCB      0x72,0x6d,0x61,0x74
000028  696f6e73          DCB      0x69,0x6f,0x6e,0x73
00002c  3a3a506c          DCB      0x3a,0x3a,0x50,0x6c
000030  616e6172          DCB      0x61,0x6e,0x61,0x72
000034  5472616e          DCB      0x54,0x72,0x61,0x6e
000038  73666f72          DCB      0x73,0x66,0x6f,0x72
00003c  6d617469          DCB      0x6d,0x61,0x74,0x69
000040  6f6e5f66          DCB      0x6f,0x6e,0x5f,0x66
000044  33323a3a          DCB      0x33,0x32,0x3a,0x3a
000048  55706461          DCB      0x55,0x70,0x64,0x61
00004c  74652863          DCB      0x74,0x65,0x28,0x63
000050  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000054  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000058  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00005c  6d626564          DCB      0x6d,0x62,0x65,0x64
000060  6465643a          DCB      0x64,0x65,0x64,0x3a
000064  3a417272          DCB      0x3a,0x41,0x72,0x72
000068  61793c66          DCB      0x61,0x79,0x3c,0x66
00006c  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000070  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000074  20666c6f          DCB      0x20,0x66,0x6c,0x6f
000078  61742c20          DCB      0x61,0x74,0x2c,0x20
00007c  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000080  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000084  62656464          DCB      0x62,0x65,0x64,0x64
000088  65643a3a          DCB      0x65,0x64,0x3a,0x3a
00008c  4d656d6f          DCB      0x4d,0x65,0x6d,0x6f
000090  72795374          DCB      0x72,0x79,0x53,0x74
000094  61636b2c          DCB      0x61,0x63,0x6b,0x2c
000098  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00009c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000a0  6d626564          DCB      0x6d,0x62,0x65,0x64
0000a4  6465643a          DCB      0x64,0x65,0x64,0x3a
0000a8  3a547261          DCB      0x3a,0x54,0x72,0x61
0000ac  6e73666f          DCB      0x6e,0x73,0x66,0x6f
0000b0  726d6174          DCB      0x72,0x6d,0x61,0x74
0000b4  696f6e73          DCB      0x69,0x6f,0x6e,0x73
0000b8  3a3a5472          DCB      0x3a,0x3a,0x54,0x72
0000bc  616e7366          DCB      0x61,0x6e,0x73,0x66
0000c0  6f726d54          DCB      0x6f,0x72,0x6d,0x54
0000c4  79706529          DCB      0x79,0x70,0x65,0x29
0000c8  00                DCB      0x00
                  |symbol_number.236|
0000c9  416e6b            DCB      0x41,0x6e,0x6b
0000cc  693a3a52          DCB      0x69,0x3a,0x3a,0x52
0000d0  6573756c          DCB      0x65,0x73,0x75,0x6c
0000d4  7420416e          DCB      0x74,0x20,0x41,0x6e
0000d8  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0000dc  456d6265          DCB      0x45,0x6d,0x62,0x65
0000e0  64646564          DCB      0x64,0x64,0x65,0x64
0000e4  3a3a5472          DCB      0x3a,0x3a,0x54,0x72
0000e8  616e7366          DCB      0x61,0x6e,0x73,0x66
0000ec  6f726d61          DCB      0x6f,0x72,0x6d,0x61
0000f0  74696f6e          DCB      0x74,0x69,0x6f,0x6e
0000f4  733a3a50          DCB      0x73,0x3a,0x3a,0x50
0000f8  6c616e61          DCB      0x6c,0x61,0x6e,0x61
0000fc  72547261          DCB      0x72,0x54,0x72,0x61
000100  6e73666f          DCB      0x6e,0x73,0x66,0x6f
000104  726d6174          DCB      0x72,0x6d,0x61,0x74
000108  696f6e5f          DCB      0x69,0x6f,0x6e,0x5f
00010c  6633323a          DCB      0x66,0x33,0x32,0x3a
000110  3a547261          DCB      0x3a,0x54,0x72,0x61
000114  6e73666f          DCB      0x6e,0x73,0x66,0x6f
000118  726d2863          DCB      0x72,0x6d,0x28,0x63
00011c  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000120  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000124  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000128  6d626564          DCB      0x6d,0x62,0x65,0x64
00012c  6465643a          DCB      0x64,0x65,0x64,0x3a
000130  3a417272          DCB      0x3a,0x41,0x72,0x72
000134  61793c75          DCB      0x61,0x79,0x3c,0x75
000138  6e736967          DCB      0x6e,0x73,0x69,0x67
00013c  6e656420          DCB      0x6e,0x65,0x64,0x20
000140  63686172          DCB      0x63,0x68,0x61,0x72
000144  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000148  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00014c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000150  6d626564          DCB      0x6d,0x62,0x65,0x64
000154  6465643a          DCB      0x64,0x65,0x64,0x3a
000158  3a417272          DCB      0x3a,0x41,0x72,0x72
00015c  61793c75          DCB      0x61,0x79,0x3c,0x75
000160  6e736967          DCB      0x6e,0x73,0x69,0x67
000164  6e656420          DCB      0x6e,0x65,0x64,0x20
000168  63686172          DCB      0x63,0x68,0x61,0x72
00016c  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000170  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000174  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000178  6d626564          DCB      0x6d,0x62,0x65,0x64
00017c  6465643a          DCB      0x64,0x65,0x64,0x3a
000180  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
000184  6f727953          DCB      0x6f,0x72,0x79,0x53
000188  7461636b          DCB      0x74,0x61,0x63,0x6b
00018c  2c20666c          DCB      0x2c,0x20,0x66,0x6c
000190  6f617429          DCB      0x6f,0x61,0x74,0x29
000194  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000198  737400            DCB      0x73,0x74,0x00
                  |symbol_number.237|
00019b  41                DCB      0x41
00019c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0001a0  3a526573          DCB      0x3a,0x52,0x65,0x73
0001a4  756c7420          DCB      0x75,0x6c,0x74,0x20
0001a8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0001ac  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0001b0  62656464          DCB      0x62,0x65,0x64,0x64
0001b4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0001b8  5472616e          DCB      0x54,0x72,0x61,0x6e
0001bc  73666f72          DCB      0x73,0x66,0x6f,0x72
0001c0  6d617469          DCB      0x6d,0x61,0x74,0x69
0001c4  6f6e733a          DCB      0x6f,0x6e,0x73,0x3a
0001c8  3a506c61          DCB      0x3a,0x50,0x6c,0x61
0001cc  6e617254          DCB      0x6e,0x61,0x72,0x54
0001d0  72616e73          DCB      0x72,0x61,0x6e,0x73
0001d4  666f726d          DCB      0x66,0x6f,0x72,0x6d
0001d8  6174696f          DCB      0x61,0x74,0x69,0x6f
0001dc  6e5f6633          DCB      0x6e,0x5f,0x66,0x33
0001e0  323a3a54          DCB      0x32,0x3a,0x3a,0x54
0001e4  72616e73          DCB      0x72,0x61,0x6e,0x73
0001e8  666f726d          DCB      0x66,0x6f,0x72,0x6d
0001ec  28636f6e          DCB      0x28,0x63,0x6f,0x6e
0001f0  73742041          DCB      0x73,0x74,0x20,0x41
0001f4  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0001f8  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0001fc  65646465          DCB      0x65,0x64,0x64,0x65
000200  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000204  69786564          DCB      0x69,0x78,0x65,0x64
000208  4c656e67          DCB      0x4c,0x65,0x6e,0x67
00020c  74684c69          DCB      0x74,0x68,0x4c,0x69
000210  73743c41          DCB      0x73,0x74,0x3c,0x41
000214  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000218  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00021c  65646465          DCB      0x65,0x64,0x64,0x65
000220  643a3a50          DCB      0x64,0x3a,0x3a,0x50
000224  6f696e74          DCB      0x6f,0x69,0x6e,0x74
000228  3c736967          DCB      0x3c,0x73,0x69,0x67
00022c  6e656420          DCB      0x6e,0x65,0x64,0x20
000230  73686f72          DCB      0x73,0x68,0x6f,0x72
000234  743e3e20          DCB      0x74,0x3e,0x3e,0x20
000238  262c2041          DCB      0x26,0x2c,0x20,0x41
00023c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000240  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000244  65646465          DCB      0x65,0x64,0x64,0x65
000248  643a3a46          DCB      0x64,0x3a,0x3a,0x46
00024c  69786564          DCB      0x69,0x78,0x65,0x64
000250  4c656e67          DCB      0x4c,0x65,0x6e,0x67
000254  74684c69          DCB      0x74,0x68,0x4c,0x69
000258  73743c41          DCB      0x73,0x74,0x3c,0x41
00025c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000260  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000264  65646465          DCB      0x65,0x64,0x64,0x65
000268  643a3a50          DCB      0x64,0x3a,0x3a,0x50
00026c  6f696e74          DCB      0x6f,0x69,0x6e,0x74
000270  3c736967          DCB      0x3c,0x73,0x69,0x67
000274  6e656420          DCB      0x6e,0x65,0x64,0x20
000278  73686f72          DCB      0x73,0x68,0x6f,0x72
00027c  743e3e20          DCB      0x74,0x3e,0x3e,0x20
000280  262c2041          DCB      0x26,0x2c,0x20,0x41
000284  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000288  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00028c  65646465          DCB      0x65,0x64,0x64,0x65
000290  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
000294  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000298  79537461          DCB      0x79,0x53,0x74,0x61
00029c  636b2c20          DCB      0x63,0x6b,0x2c,0x20
0002a0  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0002a4  74292063          DCB      0x74,0x29,0x20,0x63
0002a8  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0002ac  00                DCB      0x00
                  |symbol_number.238|
0002ad  416e6b            DCB      0x41,0x6e,0x6b
0002b0  693a3a52          DCB      0x69,0x3a,0x3a,0x52
0002b4  6573756c          DCB      0x65,0x73,0x75,0x6c
0002b8  7420416e          DCB      0x74,0x20,0x41,0x6e
0002bc  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0002c0  456d6265          DCB      0x45,0x6d,0x62,0x65
0002c4  64646564          DCB      0x64,0x64,0x65,0x64
0002c8  3a3a5472          DCB      0x3a,0x3a,0x54,0x72
0002cc  616e7366          DCB      0x61,0x6e,0x73,0x66
0002d0  6f726d61          DCB      0x6f,0x72,0x6d,0x61
0002d4  74696f6e          DCB      0x74,0x69,0x6f,0x6e
0002d8  733a3a50          DCB      0x73,0x3a,0x3a,0x50
0002dc  6c616e61          DCB      0x6c,0x61,0x6e,0x61
0002e0  72547261          DCB      0x72,0x54,0x72,0x61
0002e4  6e73666f          DCB      0x6e,0x73,0x66,0x6f
0002e8  726d6174          DCB      0x72,0x6d,0x61,0x74
0002ec  696f6e5f          DCB      0x69,0x6f,0x6e,0x5f
0002f0  6633323a          DCB      0x66,0x33,0x32,0x3a
0002f4  3a566572          DCB      0x3a,0x56,0x65,0x72
0002f8  69667954          DCB      0x69,0x66,0x79,0x54
0002fc  72616e73          DCB      0x72,0x61,0x6e,0x73
000300  666f726d          DCB      0x66,0x6f,0x72,0x6d
000304  6174696f          DCB      0x61,0x74,0x69,0x6f
000308  6e5f5072          DCB      0x6e,0x5f,0x50,0x72
00030c  6f6a6563          DCB      0x6f,0x6a,0x65,0x63
000310  74697665          DCB      0x74,0x69,0x76,0x65
000314  5f4e6561          DCB      0x5f,0x4e,0x65,0x61
000318  72657374          DCB      0x72,0x65,0x73,0x74
00031c  4e656967          DCB      0x4e,0x65,0x69,0x67
000320  68626f72          DCB      0x68,0x62,0x6f,0x72
000324  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000328  73742041          DCB      0x73,0x74,0x20,0x41
00032c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000330  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000334  65646465          DCB      0x65,0x64,0x64,0x65
000338  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00033c  72726179          DCB      0x72,0x72,0x61,0x79
000340  3c756e73          DCB      0x3c,0x75,0x6e,0x73
000344  69676e65          DCB      0x69,0x67,0x6e,0x65
000348  64206368          DCB      0x64,0x20,0x63,0x68
00034c  61723e20          DCB      0x61,0x72,0x3e,0x20
000350  262c2063          DCB      0x26,0x2c,0x20,0x63
000354  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000358  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00035c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000360  6d626564          DCB      0x6d,0x62,0x65,0x64
000364  6465643a          DCB      0x64,0x65,0x64,0x3a
000368  3a496e74          DCB      0x3a,0x49,0x6e,0x74
00036c  65676572          DCB      0x65,0x67,0x65,0x72
000370  436f756e          DCB      0x43,0x6f,0x75,0x6e
000374  74732026          DCB      0x74,0x73,0x20,0x26
000378  2c20636f          DCB      0x2c,0x20,0x63,0x6f
00037c  6e737420          DCB      0x6e,0x73,0x74,0x20
000380  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000384  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000388  62656464          DCB      0x62,0x65,0x64,0x64
00038c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000390  52656374          DCB      0x52,0x65,0x63,0x74
000394  616e676c          DCB      0x61,0x6e,0x67,0x6c
000398  653c666c          DCB      0x65,0x3c,0x66,0x6c
00039c  6f61743e          DCB      0x6f,0x61,0x74,0x3e
0003a0  20262c20          DCB      0x20,0x26,0x2c,0x20
0003a4  636f6e73          DCB      0x63,0x6f,0x6e,0x73
0003a8  7420416e          DCB      0x74,0x20,0x41,0x6e
0003ac  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0003b0  456d6265          DCB      0x45,0x6d,0x62,0x65
0003b4  64646564          DCB      0x64,0x64,0x65,0x64
0003b8  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
0003bc  7261793c          DCB      0x72,0x61,0x79,0x3c
0003c0  756e7369          DCB      0x75,0x6e,0x73,0x69
0003c4  676e6564          DCB      0x67,0x6e,0x65,0x64
0003c8  20636861          DCB      0x20,0x63,0x68,0x61
0003cc  723e2026          DCB      0x72,0x3e,0x20,0x26
0003d0  2c20636f          DCB      0x2c,0x20,0x63,0x6f
0003d4  6e737420          DCB      0x6e,0x73,0x74,0x20
0003d8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0003dc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0003e0  62656464          DCB      0x62,0x65,0x64,0x64
0003e4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0003e8  496e7465          DCB      0x49,0x6e,0x74,0x65
0003ec  67657243          DCB      0x67,0x65,0x72,0x43
0003f0  6f756e74          DCB      0x6f,0x75,0x6e,0x74
0003f4  7320262c          DCB      0x73,0x20,0x26,0x2c
0003f8  20666c6f          DCB      0x20,0x66,0x6c,0x6f
0003fc  61742c20          DCB      0x61,0x74,0x2c,0x20
000400  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000404  742c2073          DCB      0x74,0x2c,0x20,0x73
000408  69676e65          DCB      0x69,0x67,0x6e,0x65
00040c  6420696e          DCB      0x64,0x20,0x69,0x6e
000410  742c2075          DCB      0x74,0x2c,0x20,0x75
000414  6e736967          DCB      0x6e,0x73,0x69,0x67
000418  6e656420          DCB      0x6e,0x65,0x64,0x20
00041c  63686172          DCB      0x63,0x68,0x61,0x72
000420  2c207369          DCB      0x2c,0x20,0x73,0x69
000424  676e6564          DCB      0x67,0x6e,0x65,0x64
000428  20696e74          DCB      0x20,0x69,0x6e,0x74
00042c  20262c20          DCB      0x20,0x26,0x2c,0x20
000430  7369676e          DCB      0x73,0x69,0x67,0x6e
000434  65642069          DCB      0x65,0x64,0x20,0x69
000438  6e742026          DCB      0x6e,0x74,0x20,0x26
00043c  2c207369          DCB      0x2c,0x20,0x73,0x69
000440  676e6564          DCB      0x67,0x6e,0x65,0x64
000444  20696e74          DCB      0x20,0x69,0x6e,0x74
000448  20262c20          DCB      0x20,0x26,0x2c,0x20
00044c  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000450  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000454  62656464          DCB      0x62,0x65,0x64,0x64
000458  65643a3a          DCB      0x65,0x64,0x3a,0x3a
00045c  4d656d6f          DCB      0x4d,0x65,0x6d,0x6f
000460  72795374          DCB      0x72,0x79,0x53,0x74
000464  61636b29          DCB      0x61,0x63,0x6b,0x29
000468  20636f6e          DCB      0x20,0x63,0x6f,0x6e
00046c  737400            DCB      0x73,0x74,0x00
                  |symbol_number.239|
00046f  41                DCB      0x41
000470  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000474  3a526573          DCB      0x3a,0x52,0x65,0x73
000478  756c7420          DCB      0x75,0x6c,0x74,0x20
00047c  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000480  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000484  62656464          DCB      0x62,0x65,0x64,0x64
000488  65643a3a          DCB      0x65,0x64,0x3a,0x3a
00048c  5472616e          DCB      0x54,0x72,0x61,0x6e
000490  73666f72          DCB      0x73,0x66,0x6f,0x72
000494  6d617469          DCB      0x6d,0x61,0x74,0x69
000498  6f6e733a          DCB      0x6f,0x6e,0x73,0x3a
00049c  3a506c61          DCB      0x3a,0x50,0x6c,0x61
0004a0  6e617254          DCB      0x6e,0x61,0x72,0x54
0004a4  72616e73          DCB      0x72,0x61,0x6e,0x73
0004a8  666f726d          DCB      0x66,0x6f,0x72,0x6d
0004ac  6174696f          DCB      0x61,0x74,0x69,0x6f
0004b0  6e5f6633          DCB      0x6e,0x5f,0x66,0x33
0004b4  323a3a56          DCB      0x32,0x3a,0x3a,0x56
0004b8  65726966          DCB      0x65,0x72,0x69,0x66
0004bc  79547261          DCB      0x79,0x54,0x72,0x61
0004c0  6e73666f          DCB      0x6e,0x73,0x66,0x6f
0004c4  726d6174          DCB      0x72,0x6d,0x61,0x74
0004c8  696f6e5f          DCB      0x69,0x6f,0x6e,0x5f
0004cc  50726f6a          DCB      0x50,0x72,0x6f,0x6a
0004d0  65637469          DCB      0x65,0x63,0x74,0x69
0004d4  76655f4c          DCB      0x76,0x65,0x5f,0x4c
0004d8  696e6561          DCB      0x69,0x6e,0x65,0x61
0004dc  72496e74          DCB      0x72,0x49,0x6e,0x74
0004e0  6572706f          DCB      0x65,0x72,0x70,0x6f
0004e4  6c617465          DCB      0x6c,0x61,0x74,0x65
0004e8  28636f6e          DCB      0x28,0x63,0x6f,0x6e
0004ec  73742041          DCB      0x73,0x74,0x20,0x41
0004f0  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0004f4  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0004f8  65646465          DCB      0x65,0x64,0x64,0x65
0004fc  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000500  72726179          DCB      0x72,0x72,0x61,0x79
000504  3c756e73          DCB      0x3c,0x75,0x6e,0x73
000508  69676e65          DCB      0x69,0x67,0x6e,0x65
00050c  64206368          DCB      0x64,0x20,0x63,0x68
000510  61723e20          DCB      0x61,0x72,0x3e,0x20
000514  262c2063          DCB      0x26,0x2c,0x20,0x63
000518  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
00051c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000520  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000524  6d626564          DCB      0x6d,0x62,0x65,0x64
000528  6465643a          DCB      0x64,0x65,0x64,0x3a
00052c  3a526563          DCB      0x3a,0x52,0x65,0x63
000530  74616e67          DCB      0x74,0x61,0x6e,0x67
000534  6c653c66          DCB      0x6c,0x65,0x3c,0x66
000538  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
00053c  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000540  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000544  73742041          DCB      0x73,0x74,0x20,0x41
000548  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00054c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000550  65646465          DCB      0x65,0x64,0x64,0x65
000554  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000558  72726179          DCB      0x72,0x72,0x61,0x79
00055c  3c756e73          DCB      0x3c,0x75,0x6e,0x73
000560  69676e65          DCB      0x69,0x67,0x6e,0x65
000564  64206368          DCB      0x64,0x20,0x63,0x68
000568  61723e20          DCB      0x61,0x72,0x3e,0x20
00056c  262c2066          DCB      0x26,0x2c,0x20,0x66
000570  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000574  2c20666c          DCB      0x2c,0x20,0x66,0x6c
000578  6f61742c          DCB      0x6f,0x61,0x74,0x2c
00057c  20736967          DCB      0x20,0x73,0x69,0x67
000580  6e656420          DCB      0x6e,0x65,0x64,0x20
000584  696e742c          DCB      0x69,0x6e,0x74,0x2c
000588  20756e73          DCB      0x20,0x75,0x6e,0x73
00058c  69676e65          DCB      0x69,0x67,0x6e,0x65
000590  64206368          DCB      0x64,0x20,0x63,0x68
000594  61722c20          DCB      0x61,0x72,0x2c,0x20
000598  7369676e          DCB      0x73,0x69,0x67,0x6e
00059c  65642069          DCB      0x65,0x64,0x20,0x69
0005a0  6e742026          DCB      0x6e,0x74,0x20,0x26
0005a4  2c207369          DCB      0x2c,0x20,0x73,0x69
0005a8  676e6564          DCB      0x67,0x6e,0x65,0x64
0005ac  20696e74          DCB      0x20,0x69,0x6e,0x74
0005b0  20262c20          DCB      0x20,0x26,0x2c,0x20
0005b4  7369676e          DCB      0x73,0x69,0x67,0x6e
0005b8  65642069          DCB      0x65,0x64,0x20,0x69
0005bc  6e742026          DCB      0x6e,0x74,0x20,0x26
0005c0  2c20416e          DCB      0x2c,0x20,0x41,0x6e
0005c4  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0005c8  456d6265          DCB      0x45,0x6d,0x62,0x65
0005cc  64646564          DCB      0x64,0x64,0x65,0x64
0005d0  3a3a4d65          DCB      0x3a,0x3a,0x4d,0x65
0005d4  6d6f7279          DCB      0x6d,0x6f,0x72,0x79
0005d8  53746163          DCB      0x53,0x74,0x61,0x63
0005dc  6b292063          DCB      0x6b,0x29,0x20,0x63
0005e0  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0005e4  00                DCB      0x00
                  |symbol_number.240|
0005e5  416e6b            DCB      0x41,0x6e,0x6b
0005e8  693a3a52          DCB      0x69,0x3a,0x3a,0x52
0005ec  6573756c          DCB      0x65,0x73,0x75,0x6c
0005f0  7420416e          DCB      0x74,0x20,0x41,0x6e
0005f4  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
0005f8  456d6265          DCB      0x45,0x6d,0x62,0x65
0005fc  64646564          DCB      0x64,0x64,0x65,0x64
000600  3a3a5472          DCB      0x3a,0x3a,0x54,0x72
000604  616e7366          DCB      0x61,0x6e,0x73,0x66
000608  6f726d61          DCB      0x6f,0x72,0x6d,0x61
00060c  74696f6e          DCB      0x74,0x69,0x6f,0x6e
000610  733a3a50          DCB      0x73,0x3a,0x3a,0x50
000614  6c616e61          DCB      0x6c,0x61,0x6e,0x61
000618  72547261          DCB      0x72,0x54,0x72,0x61
00061c  6e73666f          DCB      0x6e,0x73,0x66,0x6f
000620  726d6174          DCB      0x72,0x6d,0x61,0x74
000624  696f6e5f          DCB      0x69,0x6f,0x6e,0x5f
000628  6633323a          DCB      0x66,0x33,0x32,0x3a
00062c  3a446573          DCB      0x3a,0x44,0x65,0x73
000630  65726961          DCB      0x65,0x72,0x69,0x61
000634  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000638  28636861          DCB      0x28,0x63,0x68,0x61
00063c  72202a2c          DCB      0x72,0x20,0x2a,0x2c
000640  20766f69          DCB      0x20,0x76,0x6f,0x69
000644  64202a2a          DCB      0x64,0x20,0x2a,0x2a
000648  2c207369          DCB      0x2c,0x20,0x73,0x69
00064c  676e6564          DCB      0x67,0x6e,0x65,0x64
000650  20696e74          DCB      0x20,0x69,0x6e,0x74
000654  20262c20          DCB      0x20,0x26,0x2c,0x20
000658  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00065c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000660  62656464          DCB      0x62,0x65,0x64,0x64
000664  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000668  4d656d6f          DCB      0x4d,0x65,0x6d,0x6f
00066c  72795374          DCB      0x72,0x79,0x53,0x74
000670  61636b20          DCB      0x61,0x63,0x6b,0x20
000674  262900            DCB      0x26,0x29,0x00
                  |symbol_number.241|
000677  41                DCB      0x41
000678  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00067c  3a526573          DCB      0x3a,0x52,0x65,0x73
000680  756c7420          DCB      0x75,0x6c,0x74,0x20
000684  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000688  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00068c  62656464          DCB      0x62,0x65,0x64,0x64
000690  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000694  5472616e          DCB      0x54,0x72,0x61,0x6e
000698  73666f72          DCB      0x73,0x66,0x6f,0x72
00069c  6d617469          DCB      0x6d,0x61,0x74,0x69
0006a0  6f6e733a          DCB      0x6f,0x6e,0x73,0x3a
0006a4  3a506c61          DCB      0x3a,0x50,0x6c,0x61
0006a8  6e617254          DCB      0x6e,0x61,0x72,0x54
0006ac  72616e73          DCB      0x72,0x61,0x6e,0x73
0006b0  666f726d          DCB      0x66,0x6f,0x72,0x6d
0006b4  6174696f          DCB      0x61,0x74,0x69,0x6f
0006b8  6e5f6633          DCB      0x6e,0x5f,0x66,0x33
0006bc  323a3a73          DCB      0x32,0x3a,0x3a,0x73
0006c0  65745f74          DCB      0x65,0x74,0x5f,0x74
0006c4  72616e73          DCB      0x72,0x61,0x6e,0x73
0006c8  666f726d          DCB      0x66,0x6f,0x72,0x6d
0006cc  54797065          DCB      0x54,0x79,0x70,0x65
0006d0  28416e6b          DCB      0x28,0x41,0x6e,0x6b
0006d4  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0006d8  6d626564          DCB      0x6d,0x62,0x65,0x64
0006dc  6465643a          DCB      0x64,0x65,0x64,0x3a
0006e0  3a547261          DCB      0x3a,0x54,0x72,0x61
0006e4  6e73666f          DCB      0x6e,0x73,0x66,0x6f
0006e8  726d6174          DCB      0x72,0x6d,0x61,0x74
0006ec  696f6e73          DCB      0x69,0x6f,0x6e,0x73
0006f0  3a3a5472          DCB      0x3a,0x3a,0x54,0x72
0006f4  616e7366          DCB      0x61,0x6e,0x73,0x66
0006f8  6f726d54          DCB      0x6f,0x72,0x6d,0x54
0006fc  79706529          DCB      0x79,0x70,0x65,0x29
000700  00                DCB      0x00
                  |symbol_number.242|
000701  416e6b            DCB      0x41,0x6e,0x6b
000704  693a3a52          DCB      0x69,0x3a,0x3a,0x52
000708  6573756c          DCB      0x65,0x73,0x75,0x6c
00070c  7420416e          DCB      0x74,0x20,0x41,0x6e
000710  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000714  456d6265          DCB      0x45,0x6d,0x62,0x65
000718  64646564          DCB      0x64,0x64,0x65,0x64
00071c  3a3a5472          DCB      0x3a,0x3a,0x54,0x72
000720  616e7366          DCB      0x61,0x6e,0x73,0x66
000724  6f726d61          DCB      0x6f,0x72,0x6d,0x61
000728  74696f6e          DCB      0x74,0x69,0x6f,0x6e
00072c  733a3a50          DCB      0x73,0x3a,0x3a,0x50
000730  6c616e61          DCB      0x6c,0x61,0x6e,0x61
000734  72547261          DCB      0x72,0x54,0x72,0x61
000738  6e73666f          DCB      0x6e,0x73,0x66,0x6f
00073c  726d6174          DCB      0x72,0x6d,0x61,0x74
000740  696f6e5f          DCB      0x69,0x6f,0x6e,0x5f
000744  6633323a          DCB      0x66,0x33,0x32,0x3a
000748  3a547261          DCB      0x3a,0x54,0x72,0x61
00074c  6e73666f          DCB      0x6e,0x73,0x66,0x6f
000750  726d506f          DCB      0x72,0x6d,0x50,0x6f
000754  696e7473          DCB      0x69,0x6e,0x74,0x73
000758  53746174          DCB      0x53,0x74,0x61,0x74
00075c  69632863          DCB      0x69,0x63,0x28,0x63
000760  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000764  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000768  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00076c  6d626564          DCB      0x6d,0x62,0x65,0x64
000770  6465643a          DCB      0x64,0x65,0x64,0x3a
000774  3a417272          DCB      0x3a,0x41,0x72,0x72
000778  61793c66          DCB      0x61,0x79,0x3c,0x66
00077c  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000780  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000784  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000788  73742041          DCB      0x73,0x74,0x20,0x41
00078c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000790  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000794  65646465          DCB      0x65,0x64,0x64,0x65
000798  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00079c  72726179          DCB      0x72,0x72,0x61,0x79
0007a0  3c666c6f          DCB      0x3c,0x66,0x6c,0x6f
0007a4  61743e20          DCB      0x61,0x74,0x3e,0x20
0007a8  262c2066          DCB      0x26,0x2c,0x20,0x66
0007ac  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
0007b0  2c20636f          DCB      0x2c,0x20,0x63,0x6f
0007b4  6e737420          DCB      0x6e,0x73,0x74,0x20
0007b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0007bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0007c0  62656464          DCB      0x62,0x65,0x64,0x64
0007c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0007c8  506f696e          DCB      0x50,0x6f,0x69,0x6e
0007cc  743c666c          DCB      0x74,0x3c,0x66,0x6c
0007d0  6f61743e          DCB      0x6f,0x61,0x74,0x3e
0007d4  20262c20          DCB      0x20,0x26,0x2c,0x20
0007d8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0007dc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0007e0  62656464          DCB      0x62,0x65,0x64,0x64
0007e4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0007e8  5472616e          DCB      0x54,0x72,0x61,0x6e
0007ec  73666f72          DCB      0x73,0x66,0x6f,0x72
0007f0  6d617469          DCB      0x6d,0x61,0x74,0x69
0007f4  6f6e733a          DCB      0x6f,0x6e,0x73,0x3a
0007f8  3a547261          DCB      0x3a,0x54,0x72,0x61
0007fc  6e73666f          DCB      0x6e,0x73,0x66,0x6f
000800  726d5479          DCB      0x72,0x6d,0x54,0x79
000804  70652c20          DCB      0x70,0x65,0x2c,0x20
000808  636f6e73          DCB      0x63,0x6f,0x6e,0x73
00080c  7420416e          DCB      0x74,0x20,0x41,0x6e
000810  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000814  456d6265          DCB      0x45,0x6d,0x62,0x65
000818  64646564          DCB      0x64,0x64,0x65,0x64
00081c  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000820  7261793c          DCB      0x72,0x61,0x79,0x3c
000824  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000828  743e2026          DCB      0x74,0x3e,0x20,0x26
00082c  2c20626f          DCB      0x2c,0x20,0x62,0x6f
000830  6f6c2c20          DCB      0x6f,0x6c,0x2c,0x20
000834  626f6f6c          DCB      0x62,0x6f,0x6f,0x6c
000838  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00083c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000840  456d6265          DCB      0x45,0x6d,0x62,0x65
000844  64646564          DCB      0x64,0x64,0x65,0x64
000848  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
00084c  7261793c          DCB      0x72,0x61,0x79,0x3c
000850  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000854  743e2026          DCB      0x74,0x3e,0x20,0x26
000858  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00085c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000860  456d6265          DCB      0x45,0x6d,0x62,0x65
000864  64646564          DCB      0x64,0x64,0x65,0x64
000868  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
00086c  7261793c          DCB      0x72,0x61,0x79,0x3c
000870  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000874  743e2026          DCB      0x74,0x3e,0x20,0x26
000878  2900              DCB      0x29,0x00
                  |symbol_number.243|
00087a  416e              DCB      0x41,0x6e
00087c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000880  52657375          DCB      0x52,0x65,0x73,0x75
000884  6c742041          DCB      0x6c,0x74,0x20,0x41
000888  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00088c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000890  65646465          DCB      0x65,0x64,0x64,0x65
000894  643a3a54          DCB      0x64,0x3a,0x3a,0x54
000898  72616e73          DCB      0x72,0x61,0x6e,0x73
00089c  666f726d          DCB      0x66,0x6f,0x72,0x6d
0008a0  6174696f          DCB      0x61,0x74,0x69,0x6f
0008a4  6e733a3a          DCB      0x6e,0x73,0x3a,0x3a
0008a8  506c616e          DCB      0x50,0x6c,0x61,0x6e
0008ac  61725472          DCB      0x61,0x72,0x54,0x72
0008b0  616e7366          DCB      0x61,0x6e,0x73,0x66
0008b4  6f726d61          DCB      0x6f,0x72,0x6d,0x61
0008b8  74696f6e          DCB      0x74,0x69,0x6f,0x6e
0008bc  5f663332          DCB      0x5f,0x66,0x33,0x32
0008c0  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
0008c4  69742841          DCB      0x69,0x74,0x28,0x41
0008c8  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0008cc  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0008d0  65646465          DCB      0x65,0x64,0x64,0x65
0008d4  643a3a54          DCB      0x64,0x3a,0x3a,0x54
0008d8  72616e73          DCB      0x72,0x61,0x6e,0x73
0008dc  666f726d          DCB      0x66,0x6f,0x72,0x6d
0008e0  6174696f          DCB      0x61,0x74,0x69,0x6f
0008e4  6e733a3a          DCB      0x6e,0x73,0x3a,0x3a
0008e8  5472616e          DCB      0x54,0x72,0x61,0x6e
0008ec  73666f72          DCB      0x73,0x66,0x6f,0x72
0008f0  6d547970          DCB      0x6d,0x54,0x79,0x70
0008f4  652c2063          DCB      0x65,0x2c,0x20,0x63
0008f8  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0008fc  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000900  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000904  6d626564          DCB      0x6d,0x62,0x65,0x64
000908  6465643a          DCB      0x64,0x65,0x64,0x3a
00090c  3a517561          DCB      0x3a,0x51,0x75,0x61
000910  6472696c          DCB      0x64,0x72,0x69,0x6c
000914  61746572          DCB      0x61,0x74,0x65,0x72
000918  616c3c66          DCB      0x61,0x6c,0x3c,0x66
00091c  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000920  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000924  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000928  73742041          DCB      0x73,0x74,0x20,0x41
00092c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000930  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000934  65646465          DCB      0x65,0x64,0x64,0x65
000938  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00093c  72726179          DCB      0x72,0x72,0x61,0x79
000940  3c666c6f          DCB      0x3c,0x66,0x6c,0x6f
000944  61743e20          DCB      0x61,0x74,0x3e,0x20
000948  262c2063          DCB      0x26,0x2c,0x20,0x63
00094c  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000950  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000954  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000958  6d626564          DCB      0x6d,0x62,0x65,0x64
00095c  6465643a          DCB      0x64,0x65,0x64,0x3a
000960  3a506f69          DCB      0x3a,0x50,0x6f,0x69
000964  6e743c66          DCB      0x6e,0x74,0x3c,0x66
000968  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
00096c  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000970  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000974  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000978  6d626564          DCB      0x6d,0x62,0x65,0x64
00097c  6465643a          DCB      0x64,0x65,0x64,0x3a
000980  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
000984  6f727953          DCB      0x6f,0x72,0x79,0x53
000988  7461636b          DCB      0x74,0x61,0x63,0x6b
00098c  20262900          DCB      0x20,0x26,0x29,0x00
                  |symbol_number.244|
000990  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000994  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000998  73756c74          DCB      0x73,0x75,0x6c,0x74
00099c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0009a0  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0009a4  6d626564          DCB      0x6d,0x62,0x65,0x64
0009a8  6465643a          DCB      0x64,0x65,0x64,0x3a
0009ac  3a547261          DCB      0x3a,0x54,0x72,0x61
0009b0  6e73666f          DCB      0x6e,0x73,0x66,0x6f
0009b4  726d6174          DCB      0x72,0x6d,0x61,0x74
0009b8  696f6e73          DCB      0x69,0x6f,0x6e,0x73
0009bc  3a3a436f          DCB      0x3a,0x3a,0x43,0x6f
0009c0  6d707574          DCB      0x6d,0x70,0x75,0x74
0009c4  65486f6d          DCB      0x65,0x48,0x6f,0x6d
0009c8  6f677261          DCB      0x6f,0x67,0x72,0x61
0009cc  70687946          DCB      0x70,0x68,0x79,0x46
0009d0  726f6d51          DCB      0x72,0x6f,0x6d,0x51
0009d4  75616473          DCB      0x75,0x61,0x64,0x73
0009d8  28636f6e          DCB      0x28,0x63,0x6f,0x6e
0009dc  73742041          DCB      0x73,0x74,0x20,0x41
0009e0  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0009e4  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0009e8  65646465          DCB      0x65,0x64,0x64,0x65
0009ec  643a3a51          DCB      0x64,0x3a,0x3a,0x51
0009f0  75616472          DCB      0x75,0x61,0x64,0x72
0009f4  696c6174          DCB      0x69,0x6c,0x61,0x74
0009f8  6572616c          DCB      0x65,0x72,0x61,0x6c
0009fc  3c666c6f          DCB      0x3c,0x66,0x6c,0x6f
000a00  61743e20          DCB      0x61,0x74,0x3e,0x20
000a04  262c2063          DCB      0x26,0x2c,0x20,0x63
000a08  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000a0c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000a10  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000a14  6d626564          DCB      0x6d,0x62,0x65,0x64
000a18  6465643a          DCB      0x64,0x65,0x64,0x3a
000a1c  3a517561          DCB      0x3a,0x51,0x75,0x61
000a20  6472696c          DCB      0x64,0x72,0x69,0x6c
000a24  61746572          DCB      0x61,0x74,0x65,0x72
000a28  616c3c66          DCB      0x61,0x6c,0x3c,0x66
000a2c  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000a30  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000a34  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000a38  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000a3c  6d626564          DCB      0x6d,0x62,0x65,0x64
000a40  6465643a          DCB      0x64,0x65,0x64,0x3a
000a44  3a417272          DCB      0x3a,0x41,0x72,0x72
000a48  61793c66          DCB      0x61,0x79,0x3c,0x66
000a4c  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000a50  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000a54  20626f6f          DCB      0x20,0x62,0x6f,0x6f
000a58  6c20262c          DCB      0x6c,0x20,0x26,0x2c
000a5c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000a60  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000a64  6d626564          DCB      0x6d,0x62,0x65,0x64
000a68  6465643a          DCB      0x64,0x65,0x64,0x3a
000a6c  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
000a70  6f727953          DCB      0x6f,0x72,0x79,0x53
000a74  7461636b          DCB      0x74,0x61,0x63,0x6b
000a78  29000000          DCB      0x29,0x00,0x00,0x00
000a7c  41727261          DCB      0x41,0x72,0x72,0x61
000a80  793c5479          DCB      0x79,0x3c,0x54,0x79
000a84  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000a88  3a436f6d          DCB      0x3a,0x43,0x6f,0x6d
000a8c  70757465          DCB      0x70,0x75,0x74,0x65
000a90  52657175          DCB      0x52,0x65,0x71,0x75
000a94  69726564          DCB      0x69,0x72,0x65,0x64
000a98  53747269          DCB      0x53,0x74,0x72,0x69
000a9c  64650000          DCB      0x64,0x65,0x00,0x00
000aa0  496e7661          DCB      0x49,0x6e,0x76,0x61
000aa4  6c696420          DCB      0x6c,0x69,0x64,0x20
000aa8  73697a65          DCB      0x73,0x69,0x7a,0x65
000aac  00000000          DCB      0x00,0x00,0x00,0x00
000ab0  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000ab4  6f726574          DCB      0x6f,0x72,0x65,0x74
000ab8  6563685c          DCB      0x65,0x63,0x68,0x5c
000abc  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000ac0  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000ac4  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000ac8  64655c61          DCB      0x64,0x65,0x5c,0x61
000acc  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000ad0  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000ad4  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000ad8  6f626f74          DCB      0x6f,0x62,0x6f,0x74
000adc  2f617272          DCB      0x2f,0x61,0x72,0x72
000ae0  61793264          DCB      0x61,0x79,0x32,0x64
000ae4  2e680000          DCB      0x2e,0x68,0x00,0x00
000ae8  41727261          DCB      0x41,0x72,0x72,0x61
000aec  793c5479          DCB      0x79,0x3c,0x54,0x79
000af0  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000af4  3a676574          DCB      0x3a,0x67,0x65,0x74
000af8  5f73697a          DCB      0x5f,0x73,0x69,0x7a
000afc  65000000          DCB      0x65,0x00,0x00,0x00
000b00  4e656761          DCB      0x4e,0x65,0x67,0x61
000b04  74697665          DCB      0x74,0x69,0x76,0x65
000b08  2064696d          DCB      0x20,0x64,0x69,0x6d
000b0c  656e7369          DCB      0x65,0x6e,0x73,0x69
000b10  6f6e0000          DCB      0x6f,0x6e,0x00,0x00
000b14  41727261          DCB      0x41,0x72,0x72,0x61
000b18  793c5479          DCB      0x79,0x3c,0x54,0x79
000b1c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000b20  3a536574          DCB      0x3a,0x53,0x65,0x74
000b24  5a65726f          DCB      0x5a,0x65,0x72,0x6f
000b28  00000000          DCB      0x00,0x00,0x00,0x00
000b2c  41727261          DCB      0x41,0x72,0x72,0x61
000b30  793c5479          DCB      0x79,0x3c,0x54,0x79
000b34  70653e20          DCB      0x70,0x65,0x3e,0x20
000b38  6973206e          DCB      0x69,0x73,0x20,0x6e
000b3c  6f742076          DCB      0x6f,0x74,0x20,0x76
000b40  616c6964          DCB      0x61,0x6c,0x69,0x64
000b44  00000000          DCB      0x00,0x00,0x00,0x00
000b48  42617369          DCB      0x42,0x61,0x73,0x69
000b4c  63205479          DCB      0x63,0x20,0x54,0x79
000b50  70652042          DCB      0x70,0x65,0x20,0x42
000b54  75666665          DCB      0x75,0x66,0x66,0x65
000b58  72000000          DCB      0x72,0x00,0x00,0x00
000b5c  53657269          DCB      0x53,0x65,0x72,0x69
000b60  616c697a          DCB      0x61,0x6c,0x69,0x7a
000b64  65644275          DCB      0x65,0x64,0x42,0x75
000b68  66666572          DCB      0x66,0x66,0x65,0x72
000b6c  3a3a4465          DCB      0x3a,0x3a,0x44,0x65
000b70  73657269          DCB      0x73,0x65,0x72,0x69
000b74  616c697a          DCB      0x61,0x6c,0x69,0x7a
000b78  65526177          DCB      0x65,0x52,0x61,0x77
000b7c  42617369          DCB      0x42,0x61,0x73,0x69
000b80  63547970          DCB      0x63,0x54,0x79,0x70
000b84  65000000          DCB      0x65,0x00,0x00,0x00
000b88  556e7265          DCB      0x55,0x6e,0x72,0x65
000b8c  61736f6e          DCB      0x61,0x73,0x6f,0x6e
000b90  61626c65          DCB      0x61,0x62,0x6c,0x65
000b94  20646573          DCB      0x20,0x64,0x65,0x73
000b98  65726961          DCB      0x65,0x72,0x69,0x61
000b9c  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000ba0  64207661          DCB      0x64,0x20,0x76,0x61
000ba4  6c756573          DCB      0x6c,0x75,0x65,0x73
000ba8  00000000          DCB      0x00,0x00,0x00,0x00
000bac  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000bb0  6f726574          DCB      0x6f,0x72,0x65,0x74
000bb4  6563685c          DCB      0x65,0x63,0x68,0x5c
000bb8  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000bbc  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
000bc0  6e636c75          DCB      0x6e,0x63,0x6c,0x75
000bc4  64655c61          DCB      0x64,0x65,0x5c,0x61
000bc8  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
000bcc  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
000bd0  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
000bd4  6f626f74          DCB      0x6f,0x62,0x6f,0x74
000bd8  2f736572          DCB      0x2f,0x73,0x65,0x72
000bdc  69616c69          DCB      0x69,0x61,0x6c,0x69
000be0  7a652e68          DCB      0x7a,0x65,0x2e,0x68
000be4  00000000          DCB      0x00,0x00,0x00,0x00
000be8  4966206f          DCB      0x49,0x66,0x20,0x6f
000bec  75742069          DCB      0x75,0x74,0x20,0x69
000bf0  73206120          DCB      0x73,0x20,0x61,0x20
000bf4  726f7720          DCB      0x72,0x6f,0x77,0x20
000bf8  76656374          DCB      0x76,0x65,0x63,0x74
000bfc  6f722c20          DCB      0x6f,0x72,0x2c,0x20
000c00  7468656e          DCB      0x74,0x68,0x65,0x6e
000c04  206f7574          DCB      0x20,0x6f,0x75,0x74
000c08  2c207843          DCB      0x2c,0x20,0x78,0x43
000c0c  6f6f7264          DCB      0x6f,0x6f,0x72,0x64
000c10  696e6174          DCB      0x69,0x6e,0x61,0x74
000c14  65732c20          DCB      0x65,0x73,0x2c,0x20
000c18  616e6420          DCB      0x61,0x6e,0x64,0x20
000c1c  79436f6f          DCB      0x79,0x43,0x6f,0x6f
000c20  7264696e          DCB      0x72,0x64,0x69,0x6e
000c24  61746573          DCB      0x61,0x74,0x65,0x73
000c28  206d7573          DCB      0x20,0x6d,0x75,0x73
000c2c  7420616c          DCB      0x74,0x20,0x61,0x6c
000c30  6c206265          DCB      0x6c,0x20,0x62,0x65
000c34  2031784e          DCB      0x20,0x31,0x78,0x4e
000c38  00000000          DCB      0x00,0x00,0x00,0x00
000c3c  78436f6f          DCB      0x78,0x43,0x6f,0x6f
000c40  7264696e          DCB      0x72,0x64,0x69,0x6e
000c44  61746573          DCB      0x61,0x74,0x65,0x73
000c48  2c207943          DCB      0x2c,0x20,0x79,0x43
000c4c  6f6f7264          DCB      0x6f,0x6f,0x72,0x64
000c50  696e6174          DCB      0x69,0x6e,0x61,0x74
000c54  65732c20          DCB      0x65,0x73,0x2c,0x20
000c58  616e6420          DCB      0x61,0x6e,0x64,0x20
000c5c  72656665          DCB      0x72,0x65,0x66,0x65
000c60  72656e63          DCB      0x72,0x65,0x6e,0x63
000c64  65206361          DCB      0x65,0x20,0x63,0x61
000c68  6e6e6f74          DCB      0x6e,0x6e,0x6f,0x74
000c6c  20626520          DCB      0x20,0x62,0x65,0x20
000c70  74686520          DCB      0x74,0x68,0x65,0x20
000c74  73616d65          DCB      0x73,0x61,0x6d,0x65
000c78  20617320          DCB      0x20,0x61,0x73,0x20
000c7c  6f757400          DCB      0x6f,0x75,0x74,0x00
000c80  506c616e          DCB      0x50,0x6c,0x61,0x6e
000c84  61725472          DCB      0x61,0x72,0x54,0x72
000c88  616e7366          DCB      0x61,0x6e,0x73,0x66
000c8c  6f726d61          DCB      0x6f,0x72,0x6d,0x61
000c90  74696f6e          DCB      0x74,0x69,0x6f,0x6e
000c94  5f663332          DCB      0x5f,0x66,0x33,0x32
000c98  3a3a7365          DCB      0x3a,0x3a,0x73,0x65
000c9c  745f7472          DCB      0x74,0x5f,0x74,0x72
000ca0  616e7366          DCB      0x61,0x6e,0x73,0x66
000ca4  6f726d54          DCB      0x6f,0x72,0x6d,0x54
000ca8  79706500          DCB      0x79,0x70,0x65,0x00
000cac  556e6b6e          DCB      0x55,0x6e,0x6b,0x6e
000cb0  6f776e20          DCB      0x6f,0x77,0x6e,0x20
000cb4  7472616e          DCB      0x74,0x72,0x61,0x6e
000cb8  73666f72          DCB      0x73,0x66,0x6f,0x72
000cbc  6d617469          DCB      0x6d,0x61,0x74,0x69
000cc0  6f6e2074          DCB      0x6f,0x6e,0x20,0x74
000cc4  79706520          DCB      0x79,0x70,0x65,0x20
000cc8  25640000          DCB      0x25,0x64,0x00,0x00
000ccc  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
000cd0  6f726574          DCB      0x6f,0x72,0x65,0x74
000cd4  6563685c          DCB      0x65,0x63,0x68,0x5c
000cd8  76697369          DCB      0x76,0x69,0x73,0x69
000cdc  6f6e5c72          DCB      0x6f,0x6e,0x5c,0x72
000ce0  6f626f74          DCB      0x6f,0x62,0x6f,0x74
000ce4  5c737263          DCB      0x5c,0x73,0x72,0x63
000ce8  5c747261          DCB      0x5c,0x74,0x72,0x61
000cec  6e73666f          DCB      0x6e,0x73,0x66,0x6f
000cf0  726d6174          DCB      0x72,0x6d,0x61,0x74
000cf4  696f6e73          DCB      0x69,0x6f,0x6e,0x73
000cf8  2e637070          DCB      0x2e,0x63,0x70,0x70
000cfc  00000000          DCB      0x00,0x00,0x00,0x00
000d00  6f726967          DCB      0x6f,0x72,0x69,0x67
000d04  696e616c          DCB      0x69,0x6e,0x61,0x6c
000d08  506f696e          DCB      0x50,0x6f,0x69,0x6e
000d0c  74732061          DCB      0x74,0x73,0x20,0x61
000d10  6e642074          DCB      0x6e,0x64,0x20,0x74
000d14  72616e73          DCB      0x72,0x61,0x6e,0x73
000d18  666f726d          DCB      0x66,0x6f,0x72,0x6d
000d1c  6564506f          DCB      0x65,0x64,0x50,0x6f
000d20  696e7473          DCB      0x69,0x6e,0x74,0x73
000d24  206d7573          DCB      0x20,0x6d,0x75,0x73
000d28  74206265          DCB      0x74,0x20,0x62,0x65
000d2c  20746865          DCB      0x20,0x74,0x68,0x65
000d30  2073616d          DCB      0x20,0x73,0x61,0x6d
000d34  65207369          DCB      0x65,0x20,0x73,0x69
000d38  7a652c20          DCB      0x7a,0x65,0x2c,0x20
000d3c  616e6420          DCB      0x61,0x6e,0x64,0x20
000d40  68617665          DCB      0x68,0x61,0x76,0x65
000d44  20617420          DCB      0x20,0x61,0x74,0x20
000d48  6c656173          DCB      0x6c,0x65,0x61,0x73
000d4c  7420666f          DCB      0x74,0x20,0x66,0x6f
000d50  75722070          DCB      0x75,0x72,0x20,0x70
000d54  6f696e74          DCB      0x6f,0x69,0x6e,0x74
000d58  73206170          DCB      0x73,0x20,0x61,0x70
000d5c  69656365          DCB      0x69,0x65,0x63,0x65
000d60  2e00              DCB      0x2e,0x00

                          AREA ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Eii, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded14LinearSequenceIiEC2Eii                  ; Alternate entry point ; Anki::Embedded::LinearSequence<int>::LinearSequence__sub_object(int, int)
                  _ZN4Anki8Embedded14LinearSequenceIiEC1Eii PROC ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
;;;30     
;;;31         template<typename Type> LinearSequence<Type>::LinearSequence(const Type start, const Type end)
;;;32           : start(start), increment(1)
;;;33         {
;;;34           this->size = computeSize(this->start, this->increment, end);
;;;35         }
;;;36     
000000  b530              PUSH     {r4,r5,lr}
000002  4604              MOV      r4,r0
000004  2301              MOVS     r3,#1
000006  b083              SUB      sp,sp,#0xc
000008  e9c41301          STRD     r1,r3,[r4,#4]
00000c  4291              CMP      r1,r2
00000e  d017              BEQ      |L236.64|
000010  2500              MOVS     r5,#0
000012  429d              CMP      r5,r3
000014  da01              BGE      |L236.26|
000016  4291              CMP      r1,r2
000018  dd01              BLE      |L236.30|
                  |L236.26|
00001a  462b              MOV      r3,r5
00001c  e010              B        |L236.64|
                  |L236.30|
00001e  1a50              SUBS     r0,r2,r1
000020  1c40              ADDS     r0,r0,#1
000022  fb90f3f3          SDIV     r3,r0,r3
000026  2b00              CMP      r3,#0
000028  da0a              BGE      |L236.64|
00002a  2185              MOVS     r1,#0x85
00002c  4806              LDR      r0,|L236.72|
00002e  e9cd0100          STRD     r0,r1,[sp,#0]
000032  a306              ADR      r3,|L236.76|
000034  a214              ADR      r2,|L236.136|
000036  a11a              ADR      r1,|L236.160|
000038  2005              MOVS     r0,#5
00003a  f7fffffe          BL       _Anki_Log
00003e  462b              MOV      r3,r5
                  |L236.64|
000040  6023              STR      r3,[r4,#0]
000042  b003              ADD      sp,sp,#0xc
000044  4620              MOV      r0,r4
000046  bd30              POP      {r4,r5,pc}
                          ENDP

                  |L236.72|
                          DCD      _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
                  |L236.76|
00004c  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/sequen"
000050  6f726574
000054  6563685c
000058  636f6d6d
00005c  6f6e5c69
000060  6e636c75
000064  64655c61
000068  6e6b692f
00006c  636f6d6d
000070  6f6e2f72
000074  6f626f74
000078  2f736571
00007c  75656e  
00007f  6365732e          DCB      "ces.h",0
000083  6800    
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L236.136|
000088  73697a65          DCB      "size estimation failed",0
00008c  20657374
000090  696d6174
000094  696f6e20
000098  6661696c
00009c  656400  
00009f  00                DCB      0
                  |L236.160|
0000a0  4c696e65          DCB      "LinearSequence<Type>::computeSize",0
0000a4  61725365
0000a8  7175656e
0000ac  63653c54
0000b0  7970653e
0000b4  3a3a636f
0000b8  6d707574
0000bc  6553697a
0000c0  6500    
0000c2  00                DCB      0
0000c3  00                DCB      0

                          AREA ||area_number.237||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Eii, LINKORDER=||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.237||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<float>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L243.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L243.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L243.384|
000044  a25c              ADR      r2,|L243.440|
000046  a160              ADR      r1,|L243.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L243.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L243.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L243.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L243.384|
000080  a24d              ADR      r2,|L243.440|
000082  a157              ADR      r1,|L243.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L243.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L243.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L243.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L243.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L243.384|
0000c8  a251              ADR      r2,|L243.528|
0000ca  a156              ADR      r1,|L243.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L243.372|
                  |L243.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L243.384|
0000e0  a258              ADR      r2,|L243.580|
0000e2  a15f              ADR      r1,|L243.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L243.372|
                  |L243.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L243.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L243.384|
000110  a259              ADR      r2,|L243.632|
000112  a144              ADR      r1,|L243.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L243.372|
                  |L243.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L243.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L243.384|
00015a  a251              ADR      r2,|L243.672|
00015c  a140              ADR      r1,|L243.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L243.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L243.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L243.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L243.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L243.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L243.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L243.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L243.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L243.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L243.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L243.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L243.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L243.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L243.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.244||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.244||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfE3SetERKS2_||, COMGROUP=_ZN4Anki8Embedded5ArrayIfE3SetERKS2_, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfE3SetERKS2_ PROC ; Anki::Embedded::Array<float>::Set(const Anki::Embedded::Array<float>&)
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;656        {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
000008  b083              SUB      sp,sp,#0xc
00000a  2100              MOVS     r1,#0
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000012  4607              MOV      r7,r0
000014  2101              MOVS     r1,#1
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001c  4606              MOV      r6,r0
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000024  f8df80a4          LDR      r8,|L250.204|
000028  f04f0900          MOV      r9,#0
00002c  2800              CMP      r0,#0
;;;657          return this->SetCast<Type>(in);
00002e  d018              BEQ      |L250.98|
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000036  2800              CMP      r0,#0
000038  d013              BEQ      |L250.98|
00003a  6820              LDR      r0,[r4,#0]
00003c  42b8              CMP      r0,r7
00003e  bf04              ITT      EQ
000040  6861              LDREQ    r1,[r4,#4]
000042  42b1              CMPEQ    r1,r6
000044  d01b              BEQ      |L250.126|
000046  f44f7027          MOV      r0,#0x29c
00004a  e9cd8000          STRD     r8,r0,[sp,#0]
00004e  a320              ADR      r3,|L250.208|
000050  a22d              ADR      r2,|L250.264|
000052  a133              ADR      r1,|L250.288|
000054  2005              MOVS     r0,#5
000056  f7fffffe          BL       _Anki_Log
;;;658        }
00005a  b003              ADD      sp,sp,#0xc
00005c  4648              MOV      r0,r9
00005e  e8bd83f0          POP      {r4-r9,pc}
                  |L250.98|
000062  f2402099          MOV      r0,#0x299
000066  e9cd8000          STRD     r8,r0,[sp,#0]
00006a  a319              ADR      r3,|L250.208|
00006c  a231              ADR      r2,|L250.308|
00006e  a12c              ADR      r1,|L250.288|
000070  2005              MOVS     r0,#5
000072  f7fffffe          BL       _Anki_Log
000076  b003              ADD      sp,sp,#0xc
000078  4648              MOV      r0,r9
00007a  e8bd83f0          POP      {r4-r9,pc}
                  |L250.126|
00007e  2100              MOVS     r1,#0
000080  2800              CMP      r0,#0
000082  dd1e              BLE      |L250.194|
                  |L250.132|
000084  68aa              LDR      r2,[r5,#8]
000086  6928              LDR      r0,[r5,#0x10]
000088  68a3              LDR      r3,[r4,#8]
00008a  fb010202          MLA      r2,r1,r2,r0
00008e  6920              LDR      r0,[r4,#0x10]
000090  f8d4c004          LDR      r12,[r4,#4]
000094  fb010303          MLA      r3,r1,r3,r0
000098  2000              MOVS     r0,#0
00009a  f1bc0f00          CMP      r12,#0
00009e  dd0c              BLE      |L250.186|
                  |L250.160|
0000a0  eb020c80          ADD      r12,r2,r0,LSL #2
0000a4  ed9c0a00          VLDR     s0,[r12,#0]
0000a8  eb030c80          ADD      r12,r3,r0,LSL #2
0000ac  1c40              ADDS     r0,r0,#1
0000ae  ed8c0a00          VSTR     s0,[r12,#0]
0000b2  f8d4c004          LDR      r12,[r4,#4]
0000b6  4584              CMP      r12,r0
0000b8  dcf2              BGT      |L250.160|
                  |L250.186|
0000ba  6820              LDR      r0,[r4,#0]
0000bc  1c49              ADDS     r1,r1,#1
0000be  4288              CMP      r0,r1
0000c0  dce0              BGT      |L250.132|
                  |L250.194|
0000c2  6861              LDR      r1,[r4,#4]
0000c4  b003              ADD      sp,sp,#0xc
0000c6  4348              MULS     r0,r1,r0
0000c8  e8bd83f0          POP      {r4-r9,pc}
;;;659    
                          ENDP

                  |L250.204|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE7SetCastIfEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::SetCast<float>(const Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
                  |L250.208|
0000d0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
0000d4  6f726574
0000d8  6563685c
0000dc  636f6d6d
0000e0  6f6e5c69
0000e4  6e636c75
0000e8  64655c61
0000ec  6e6b692f
0000f0  636f6d6d
0000f4  6f6e2f72
0000f8  6f626f74
0000fc  2f617272
000100  617932  
000103  642e6800          DCB      "d.h",0
000107  00                DCB      0
                  |L250.264|
000108  41727261          DCB      "Array sizes don't match",0
00010c  79207369
000110  7a657320
000114  646f6e27
000118  74206d61
00011c  74636800
                  |L250.288|
000120  41727261          DCB      "Array<Type>::Set",0
000124  793c5479
000128  70653e3a
00012c  3a536574
000130  00      
000131  00                DCB      0
000132  00                DCB      0
000133  00                DCB      0
                  |L250.308|
000134  496e7661          DCB      "Invalid objects",0
000138  6c696420
00013c  6f626a65
000140  63747300

                          AREA ||area_number.251||, COMGROUP=_ZN4Anki8Embedded5ArrayIfE3SetERKS2_, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfE3SetERKS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.251||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfE3SetERKS2_||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded13QuadrilateralIfE13ComputeCenterIfEENS0_5PointIT_EEv||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE13ComputeCenterIfEENS0_5PointIT_EEv, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded13QuadrilateralIfE13ComputeCenterIfEENS0_5PointIT_EEv PROC ; Anki::Embedded::Quadrilateral<float>::ComputeCenter<float>() const
;;;260    
;;;261          template<typename OutType> Point<OutType> ComputeCenter() const;
000000  ed9f0a15          VLDR     s0,|L257.88|
000004  2200              MOVS     r2,#0
000006  ed800a00          VSTR     s0,[r0,#0]
00000a  ed800a01          VSTR     s0,[r0,#4]
                  |L257.14|
00000e  eb0103c2          ADD      r3,r1,r2,LSL #3
000012  ed900a00          VLDR     s0,[r0,#0]
000016  edd30a00          VLDR     s1,[r3,#0]
00001a  1c52              ADDS     r2,r2,#1
00001c  2a04              CMP      r2,#4
00001e  ee300a20          VADD.F32 s0,s0,s1
000022  ed800a00          VSTR     s0,[r0,#0]
000026  ed900a01          VLDR     s0,[r0,#4]
00002a  edd30a01          VLDR     s1,[r3,#4]
00002e  ee300a20          VADD.F32 s0,s0,s1
000032  ed800a01          VSTR     s0,[r0,#4]
000036  dbea              BLT      |L257.14|
000038  edd00a00          VLDR     s1,[r0,#0]
00003c  eeb50a00          VMOV.F32 s0,#0.25000000
000040  ee600a80          VMUL.F32 s1,s1,s0
000044  edc00a00          VSTR     s1,[r0,#0]
000048  edd00a01          VLDR     s1,[r0,#4]
00004c  ee200a80          VMUL.F32 s0,s1,s0
000050  ed800a01          VSTR     s0,[r0,#4]
000054  4770              BX       lr
;;;262    
;;;263          // WARNING:
;;;264          // The width and height of a floating point Rectangle is different than that of an integer rectangle.
;;;265          template<typename OutType> Rectangle<OutType> ComputeBoundingRectangle() const;
;;;266    
;;;267          // Returns a copy of this Quadrilateral with sorted corners, so they are clockwise around the centroid
;;;268          // Warning: This may give weird results for non-convex quadrilaterals
;;;269          template<typename OutType> Quadrilateral<OutType> ComputeClockwiseCorners() const;
;;;270    
;;;271          template<typename OutType> Quadrilateral<OutType> ComputeRotatedCorners(const f32 radians) const;
;;;272    
;;;273          bool IsConvex() const;
;;;274    
;;;275          bool operator== (const Quadrilateral<Type> &quad2) const;
;;;276    
;;;277          Quadrilateral<Type> operator+ (const Quadrilateral<Type> &quad2) const;
;;;278    
;;;279          Quadrilateral<Type> operator- (const Quadrilateral<Type> &quad2) const;
;;;280    
;;;281          inline Quadrilateral<Type>& operator= (const Quadrilateral<Type> &quad2);
;;;282    
;;;283          // Keeping this explicit to avoid accidental setting of quads of
;;;284          // different types
;;;285          template<typename InType> void SetCast(const Quadrilateral<InType> &quad2);
;;;286    
;;;287          inline const Point<Type>& operator[] (const s32 index) const;
;;;288          inline Point<Type>& operator[] (const s32 index);
;;;289        }; // class Quadrilateral<Type>
;;;290      } // namespace Embedded
;;;291    } // namespace Anki
;;;292    
;;;293    #endif // _ANKICORETECHEMBEDDED_COMMON_POINT_DECLARATIONS_H_
;;;20     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;21     #include "anki/common/robot/sequences_declarations.h"
;;;1      /**
;;;2      File: sequences_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      A Sequence is a mathematically-defined, ordered list. The sequence classes allow for operations on sequences, without requiring them to be explicitly evaluated.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/flags_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> class Array;
;;;23         template<typename Type> class FixedLengthList;
;;;24         template<typename Type> class ArraySlice;
;;;25         class MemoryStack;
;;;26     
;;;27         // #pragma mark --- Class Declarations ---
;;;28         template<typename Type> class Sequence
;;;29         {
;;;30         }; // class Sequence
;;;31     
;;;32         // A LinearSequence is like the result of a call to Matlab's linspace() It has a start, end, and
;;;33         // increment. It does not explicitly compute the values in the sequence, so does not require
;;;34         // much memory.
;;;35         //
;;;36         // WARNING:
;;;37         // The "end" of a LinearSequence is computed automatically, and is less-than-or-equal-to the
;;;38         // requested end.
;;;39         template<typename Type> class LinearSequence : public Sequence<Type>
;;;40         {
;;;41         public:
;;;42     
;;;43           LinearSequence();
;;;44     
;;;45           // Matlab equivalent: start:end
;;;46           LinearSequence(const Type start, const Type end);
;;;47     
;;;48           // Matlab equivalent: start:increment:end
;;;49           LinearSequence(const Type start, const Type increment, const Type end);
;;;50     
;;;51           // No Matlab equivalent
;;;52           // NOTE: end is unused. It is just present to prevent confusion with the other polymorphic constructors
;;;53           LinearSequence(const Type start, const Type increment, const Type end, const s32 size);
;;;54     
;;;55           // Explicitly evaluate each element of the sequence, and put the results in an Array.
;;;56           Array<Type> Evaluate(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;57           Result Evaluate(ArraySlice<Type> out) const;
;;;58     
;;;59           Type get_start() const;
;;;60     
;;;61           // NOTE: The increment is meaningless for LinearSequences of size 0 or 1.
;;;62           Type get_increment() const;
;;;63     
;;;64           // Note: End it not computed, as it is tempting to use it as a loop condition, but it is not safe
;;;65           // Type get_end() const;
;;;66     
;;;67           // Matlab equivalent: length(start:increment:end)
;;;68           s32 get_size() const;
;;;69     
;;;70         protected:
;;;71           // For speed, FixedLengthList is allowed to access protected members, instead of having to
;;;72           // construct a new LinearSequence every time an element is popped or pushed
;;;73           template<typename FixedLengthListType> friend class FixedLengthList;
;;;74     
;;;75           s32 size;
;;;76     
;;;77           Type start;
;;;78           Type increment;
;;;79     
;;;80           static s32 computeSize(const Type start, const Type increment, const Type end);
;;;81         }; // class LinearSequence
;;;82     
;;;83         // IndexSequence creates the input for slicing an Array
;;;84         // If start or end is less than 0, it is equivalent to (end+value)
;;;85         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type end, s32 arraySize);
;;;86         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type increment, Type end, s32 arraySize);
;;;87         LinearSequence<s32> IndexSequence(s32 arraySize); // Internally, it sets start==0, end=arraySize-1, like the Matlab colon operator array(:,:)
;;;88     
;;;89         // Linspace only works correctly for f32 and f64. To prevent misusage, trying ints will give a linker error.
;;;90         template<typename Type> LinearSequence<Type> Linspace(const Type start, const Type end, const s32 size);
;;;91     
;;;92         // These do not link, as they are unsafe
;;;93         template<> LinearSequence<u8> Linspace(const u8 start, const u8 end, const s32 size);
;;;94         template<> LinearSequence<s8> Linspace(const s8 start, const s8 end, const s32 size);
;;;95         template<> LinearSequence<u16> Linspace(const u16 start, const u16 end, const s32 size);
;;;96         template<> LinearSequence<s16> Linspace(const s16 start, const s16 end, const s32 size);
;;;97         template<> LinearSequence<u32> Linspace(const u32 start, const u32 end, const s32 size);
;;;98         template<> LinearSequence<s32> Linspace(const s32 start, const s32 end, const s32 size);
;;;99         template<> LinearSequence<u64> Linspace(const u64 start, const u64 end, const s32 size);
;;;100        template<> LinearSequence<s64> Linspace(const s64 start, const s64 end, const s32 size);
;;;101    
;;;102        // TODO: Logspace
;;;103        //template<typename Type> class Logspace : public Sequence<Type>
;;;104        //{
;;;105        //public:
;;;106        //protected:
;;;107        //};
;;;108    
;;;109        // A Meshgrid is like the result of a call to Matlab's meshgrid(). It is made of two
;;;110        // LinearSequence objects, so does not require much memory.
;;;111        template<typename Type> class Meshgrid
;;;112        {
;;;113        public:
;;;114          Meshgrid();
;;;115    
;;;116          // Matlab equivalent: meshgrid(xGridVector, yGridVector)
;;;117          Meshgrid(const LinearSequence<Type> xGridVector, const LinearSequence<Type> yGridVector);
;;;118    
;;;119          // Allocate an Array, and evaluate this Meshgrid object
;;;120          //
;;;121          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;122          // The first suffix X or Y is for the xGrid vs yGrid
;;;123          // The second suffix 1 or 2 is for 1D vs 2D output
;;;124          Array<Type> EvaluateX1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;125          Array<Type> EvaluateX2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;126          Array<Type> EvaluateY1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;127          Array<Type> EvaluateY2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;128    
;;;129          // Evaluate this Meshgrid object into a pre-allocated Array
;;;130          //
;;;131          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;132          Result EvaluateX1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;133          Result EvaluateX2(ArraySlice<Type> out) const;
;;;134          Result EvaluateY1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;135          Result EvaluateY2(ArraySlice<Type> out) const;
;;;136    
;;;137          s32 get_numElements() const;
;;;138    
;;;139          inline const LinearSequence<Type>& get_xGridVector() const;
;;;140    
;;;141          inline const LinearSequence<Type>& get_yGridVector() const;
;;;142    
;;;143        protected:
;;;144          LinearSequence<Type> xGridVector;
;;;145          LinearSequence<Type> yGridVector;
;;;146        };
;;;147      } // namespace Embedded
;;;148    } //namespace Anki
;;;149    
;;;150    #endif // #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;22     
;;;23     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;24     namespace cv
;;;25     {
;;;26       class Mat;
;;;27       template<typename Type> class Mat_;
;;;28     }
;;;29     #endif
;;;30     
;;;31     namespace Anki
;;;32     {
;;;33       namespace Embedded
;;;34       {
;;;35         template<typename Type> class ArraySlice;
;;;36         template<typename Type> class ConstArraySlice;
;;;37         template<typename Type> class ConstArraySliceExpression;
;;;38     
;;;39         const s32 ARRAY_FILE_HEADER_LENGTH = 32;
;;;40         const s32 ARRAY_FILE_HEADER_VALID_LENGTH = 14; //< How many characters are not spaces
;;;41         const char ARRAY_FILE_HEADER[ARRAY_FILE_HEADER_LENGTH+1] = "\x89" "AnkiEArray1.2                  ";
;;;42     
;;;43         // #pragma mark --- Array Class Declaration ---
;;;44     
;;;45         template<typename Type> class Array
;;;46         {
;;;47         public:
;;;48     
;;;49           // The stride is the "numCols*sizeof(Type)" rounded up by 16, plus any boundary padding
;;;50           static s32 ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags);
;;;51     
;;;52           // The minimum required memory is the size of a stride, times the number of rows
;;;53           static s32 ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags);
;;;54     
;;;55           // Initializes Array as invalid
;;;56           Array();
;;;57     
;;;58           // Constructor for a Array, pointing to user-allocated MemoryStack. This is the preferred
;;;59           // method for creating a new Array.
;;;60           //
;;;61           // Flags::Buffer.isFullyAllocated doesn't do anything
;;;62           Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;63     
;;;64           // Constructor for a Array, pointing to user-allocated data. This type of array is more
;;;65           // restrictive than most matrix libraries. For example, it may make it hard to convert from
;;;66           // OpenCV::Mat to Array, though the reverse is trivial.
;;;67           //
;;;68           // If following are true, then the contents of data will not be modified, and it will work as
;;;69           // a normal buffer without extra zeros as stride padding:
;;;70           // 1. (numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0
;;;71           // 2. reinterpret_cast<size_t>(data) % MEMORY_ALIGNMENT == 0
;;;72           // 3. numRows*numCols*sizeof(Type) <= dataLength
;;;73           //
;;;74           // If Flags::Buffer.isFullyAllocated == true, then the input data buffer's stride must be a
;;;75           // simple multiple
;;;76           Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags=Flags::Buffer(false,false,true));
;;;77     
;;;78           // Load an image from file. Requires OpenCV;
;;;79           static Array<Type> LoadImage(const char * filename, MemoryStack &memory);
;;;80     
;;;81           // Load or save an array saved as a debugStream.
;;;82           // compressionLevel can be from 0 (uncompressed) to 9 (most compressed). If OpenCV is not used, it must be zero.
;;;83           static Array<Type> LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory);
;;;84           static Array<Type> LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength); //< allocatedBuffer must be allocated and freed manually
;;;85           Result SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const;
;;;86     
;;;87           // Pointer to the data, at a given (y,x) location
;;;88           //
;;;89           // NOTE:
;;;90           // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;91           // inner loop, like: "Type * restrict pArray = Array.Pointer(5);", then index
;;;92           // pArray in the inner loop.
;;;93           inline const Type* Pointer(const s32 index0, const s32 index1) const;
;;;94           inline Type* Pointer(const s32 index0, const s32 index1);
;;;95     
;;;96           // Use this operator for normal C-style 2d matrix indexing. For example, "array[5][0] = 6;"
;;;97           // will set the element in the fifth row and first column to 6. This is the same as
;;;98           // "array.Pointer(5)[0] = 6;"
;;;99           //
;;;100          // NOTE:
;;;101          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;102          // inner loop, like: "Type * restrict pArray = Array[5];", then index
;;;103          // pArray in the inner loop.
;;;104          inline const Type * operator[](const s32 index0) const;
;;;105          inline Type * operator[](const s32 index0);
;;;106    
;;;107          // Pointer to the data, at a given (y,x) location
;;;108          //
;;;109          // NOTE:
;;;110          // The default order of coordinates for the Point() constructor is (x,y). So for example,
;;;111          // access Array[5][3] via Array.Pointer(Point<s16>(3,5))
;;;112          //
;;;113          // NOTE:
;;;114          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;115          // inner loop, like: "Type * restrict pArray = Array.Pointer(Point<s16>(5,0));", then index
;;;116          // pArray in the inner loop.
;;;117          inline const Type* Pointer(const Point<s16> &point) const;
;;;118          inline Type* Pointer(const Point<s16> &point);
;;;119    
;;;120          // Get the ith element, like Matlab's 1D indexing of a 2D array.
;;;121          // For example, the 5th element of Arrays of size (1,6) and (6,1) is the same;
;;;122          const Type& Element(const s32 elementIndex) const;
;;;123          Type& Element(const s32 elementIndex);
;;;124    
;;;125          // Return a slice accessor for this array, like the Matlab expression "array(1:5, 2:3:5)"
;;;126          //
;;;127          // NOTE:
;;;128          // If min or max is less than 0, it is equivalent to (end+value). For example, "Array(0,-1,3,5)"
;;;129          // is the same as "Array(0,arrayHeight-1,3,5)"
;;;130          ArraySlice<Type> operator() ();
;;;131          ArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;132          ArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX);
;;;133          ArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX);
;;;134          ConstArraySlice<Type> operator() () const;
;;;135          ConstArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const;
;;;136          ConstArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const;
;;;137          ConstArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const;
;;;138    
;;;139          // ArraySlice Transpose doesn't modify the data, it just sets an "isTransposed" flag.
;;;140          // Anything that uses ArraySliceExpression respects this flag. This doesn't include things
;;;141          // like Matrix::Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out) for example.
;;;142          ConstArraySliceExpression<Type> Transpose() const;
;;;143    
;;;144    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;145          // Copies the OpenCV Mat. If needed, it converts from color to grayscale by averaging the color channels.
;;;146          s32 Set(const cv::Mat_<Type> &in);
;;;147    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;148    
;;;149          // Use the simple OpenCV gui to display this array as an image
;;;150          // Does nothing is OpenCV is not available
;;;151          void Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues=false, const bool fitImageToWindow=false) const;
;;;152    
;;;153          // Print out the contents of this Array
;;;154          //
;;;155          // NOTE:
;;;156          // * If the min X or Y is less than zero, it will be treated as zero
;;;157          // * If the max X or Y is greater than the size of the array minus one, it will be treated as
;;;158          //   the size of the array minus one
;;;159          Result Print(const char * const variableName = "Array", const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;160          Result PrintAlternate(const char * const variableName = "Array", const s32 version=2, const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;161    
;;;162          // Checks if this array is equal to another array, up to some allowable
;;;163          // per-element varation, epsilon. If the arrays are not the same size,
;;;164          // false is returned.
;;;165          bool IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const;
;;;166    
;;;167          // Checks the basic parameters of this Array, and if it is allocated.
;;;168          bool IsValid() const;
;;;169    
;;;170          // Resize will use MemoryStack::Reallocate() to change the Array's size. It only works if this
;;;171          // Array was the last thing allocated. The reallocated memory will not be cleared
;;;172          //
;;;173          // WARNING:
;;;174          // This will not update any references to the memory, you must update all references manually.
;;;175          Result Resize(const s32 numRows, const s32 numCols, MemoryStack &memory);
;;;176    
;;;177          // Set every element in the Array to zero, including the stride padding.
;;;178          // Returns the number of bytes set to zero
;;;179          s32 SetZero();
;;;180    
;;;181          // Set every element in the Array to this value
;;;182          // Returns the number of values set
;;;183          s32 Set(const Type value);
;;;184    
;;;185          // Elementwise copies the input Array into this array. No memory is allocated.
;;;186          s32 Set(const Array<Type> &in);
;;;187    
;;;188          // Copy values to this Array.
;;;189          // If the input array does not contain enough elements, the remainder of this Array will be filled with zeros.
;;;190          // Returns the number of values set (not counting extra zeros)
;;;191          s32 Set(const Type * const values, const s32 numValues);
;;;192    
;;;193          // Read in the input, then cast it to this object's type
;;;194          //
;;;195          // WARNING:
;;;196          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;197          template<typename InType> s32 SetCast(const Array<InType> &in);
;;;198          template<typename InType> s32 SetCast(const InType * const values, const s32 numValues);
;;;199    
;;;200          // This is a shallow copy. There's no reference counting. Updating the data of one array will
;;;201          // update that of others (because they point to the same location in memory).
;;;202          // However, Resizing or other operations on one array won't update the others.
;;;203          Array& operator= (const Array & rightHandSide);
;;;204    
;;;205          // Similar to Matlabs size(matrix, dimension), and dimension is in {0,1}
;;;206          s32 get_size(s32 dimension) const;
;;;207    
;;;208          // Get the stride, which is the number of bytes between an element at (n,m) and an element at (n+1,m)
;;;209          s32 get_stride() const;
;;;210    
;;;211          // just size[0] * size[1]
;;;212          s32 get_numElements() const;
;;;213    
;;;214          // Return the flags that were used when this object was constructed.
;;;215          Flags::Buffer get_flags() const;
;;;216    
;;;217          // Equivalent to Pointer(0,0)
;;;218          //
;;;219          // These are for very low-level access to the buffers. Probably you want to be using one of
;;;220          // the Pointer() accessor methods instead of these.
;;;221          void* get_buffer();
;;;222          const void* get_buffer() const;
;;;223    
;;;224        protected:
;;;225          static const s32 HEADER_LENGTH = 8;
;;;226          static const s32 FOOTER_LENGTH = 8;
;;;227    
;;;228          s32 size[2];
;;;229          s32 stride;
;;;230          Flags::Buffer flags;
;;;231    
;;;232          Type * data;
;;;233    
;;;234          // Basic allocation method
;;;235          void* AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate);
;;;236    
;;;237          // Performs checks and sets appropriate parameters for this object
;;;238          Result InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags);
;;;239    
;;;240          // Set all the buffers and sizes to zero, to signal an invalid array
;;;241          void InvalidateArray();
;;;242    
;;;243          // If this object's Type is a basic type, this method prints out this object.
;;;244          Result PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;245    
;;;246          // If this object's Type is a string, this method prints out this object.
;;;247          Result PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;248        }; // class Array
;;;249    
;;;250        // #pragma mark --- FixedPointArray Class Declaration ---
;;;251    
;;;252        template<typename Type> class FixedPointArray : public Array<Type>
;;;253        {
;;;254        public:
;;;255          FixedPointArray();
;;;256    
;;;257          // Same as Array() constructor
;;;258          // This is the preferred method for constructing an FixedPointArray
;;;259          FixedPointArray(const s32 numRows, const s32 numCols, const s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;260    
;;;261          // Same as Array() constructor
;;;262          // This is the advanced method for constructing an FixedPointArray
;;;263          FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;264    
;;;265          s32 get_numFractionalBits() const;
;;;266    
;;;267        protected:
;;;268          s32 numFractionalBits;
;;;269        };
;;;270    
;;;271        // If you don't know the type of the Array you're loading, use this function directly, then cast it based on the read parameters
;;;272        Array<u8> LoadBinaryArray_UnknownType(
;;;273          const char * filename,
;;;274          MemoryStack *scratch,
;;;275          MemoryStack *memory,
;;;276          void * allocatedBuffer,
;;;277          const s32 allocatedBufferLength,
;;;278          u16  &basicType_sizeOfType,
;;;279          bool &basicType_isBasicType,
;;;280          bool &basicType_isInteger,
;;;281          bool &basicType_isSigned,
;;;282          bool &basicType_isFloat,
;;;283          bool &basicType_isString
;;;284          );
;;;285    
;;;286    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;287        // Returns a cv::Mat that mirrors the data in the input Array.
;;;288        // WARNING: If you copy the cv::Mat or assign it incorrectly, it will no longer mirror the input Array
;;;289        // WARNING: This const_casts the input array, so you can unsafely modify it via the output cv::Mat
;;;290        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out);
;;;291    #endif
;;;292      } // namespace Embedded
;;;293    } //namespace Anki
;;;294    
;;;295    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_DECLARATIONS_H_
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;1      /**
;;;2      File: utilities.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of utilities_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;14     
;;;15     #include "anki/common/robot/utilities_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;17     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;2      * File: trig_fast.h
;;;3      *
;;;4      * Author: Kevin Yoon
;;;5      * Created: 22-OCT-2012
;;;6      *
;;;7      * Some trig functions to supplement incomplete math libraries on embedded targets.
;;;8      * Error of all functions is less than +/- 0.01.
;;;9      * For bettery accuracy, lookup tables should be regenerated with u16.
;;;10     *
;;;11     **/
;;;12     #ifndef _TRIG_FAST_H
;;;13     #define _TRIG_FAST_H
;;;14     
;;;15     // When USE_SMALL_LUT defined, a smaller lookup table is used to conserve space.
;;;16     // USE_INTERPOLATION is also automatically defined, since without it answers are probably too wrong to be useful.
;;;17     // If USE_SMALL_LUT is not defined, a large LUT is used.
;;;18     //#define USE_SMALL_LUT
;;;19     
;;;20     // When defined, interpolates between lookup values for higher accuracy.
;;;21     #define USE_INTERPOLATION
;;;22     
;;;23     // Arctangent function based on lookup table
;;;24     // returns answer in radians
;;;25     float atan_fast(float x);
;;;26     
;;;27     // Arcsine function based on lookup table
;;;28     // returns answer in radians
;;;29     float asin_fast(float x);
;;;30     
;;;31     // Arctangent function which uses atan_fast
;;;32     // returns answer in radians
;;;33     float atan2_fast(float y, float x);
;;;34     
;;;35     // Arctangent function which uses asin from math.h
;;;36     // Useful on embedded systems that don't include atan2 in math.h
;;;37     // More accurate than atan2_fast.
;;;38     // Nothing particularly fast about this implementation.
;;;39     // returns answer in radians
;;;40     float atan2_acc(float y, float x);
;;;41     
;;;42     #endif
;;;19     
;;;20     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;21     #include "opencv2/core/core.hpp"
;;;22     #endif
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         //template<typename Type> inline Type RoundUp(const Type number, const Type multiple)
;;;29     
;;;30         // void* and size_t is a special case, good for aligning pointers
;;;31         inline const void* RoundUp(const void* number, const size_t multiple)
;;;32         {
;;;33           const size_t numberT = reinterpret_cast<size_t>(number);
;;;34           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;35         }
;;;36     
;;;37         inline void* RoundUp(void* number, const size_t multiple)
;;;38         {
;;;39           const size_t numberT = reinterpret_cast<size_t>(number);
;;;40           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;41         }
;;;42     
;;;43         template<> inline u32 RoundUp(const u32 number, const u32 multiple)
;;;44         {
;;;45           return (number + (multiple-1)) & ~(multiple-1);
;;;46         }
;;;47     
;;;48         template<> inline s32 RoundUp(const s32 number, const s32 multiple)
;;;49         {
;;;50           if(number <= 0) {
;;;51             return multiple*( number/multiple );
;;;52           } else {
;;;53             return multiple*( (number-1)/multiple + 1 );
;;;54           }
;;;55         }
;;;56     
;;;57     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;58         template<> inline unsigned long RoundUp(const unsigned long number, const unsigned long multiple)
;;;59         {
;;;60           return (number + (multiple-1)) & ~(multiple-1);
;;;61         }
;;;62     #endif
;;;63     
;;;64         template<> inline u32 RoundDown(const u32 number, const u32 multiple)
;;;65         {
;;;66           return multiple * (number/multiple);
;;;67         }
;;;68     
;;;69         template<> inline s32 RoundDown(const s32 number, const s32 multiple)
;;;70         {
;;;71           if(number < 0) {
;;;72             return multiple * ((number-multiple+1) / multiple);
;;;73           } else {
;;;74             return multiple * (number/multiple);
;;;75           }
;;;76         }
;;;77     
;;;78     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;79         template<> inline unsigned long RoundDown(const unsigned long number, const unsigned long multiple)
;;;80         {
;;;81           return multiple * (number/multiple);
;;;82         }
;;;83     #endif
;;;84     
;;;85         template<typename Type> Type ApproximateExp(const Type exponent, const s32 numTerms)
;;;86         {
;;;87           AnkiAssert(numTerms > 2);
;;;88     
;;;89           const Type exponentAbs = ABS(exponent);
;;;90     
;;;91           Type sum = static_cast<Type>(1) + exponentAbs;
;;;92     
;;;93           Type numerator = static_cast<Type>(exponentAbs);
;;;94           Type denominator = static_cast<Type>(1);
;;;95           for(s32 i=2; i<=numTerms; i++) {
;;;96             numerator *= exponentAbs;
;;;97             denominator *= i;
;;;98     
;;;99             sum += numerator / denominator;
;;;100          }
;;;101    
;;;102          if(exponent < 0) {
;;;103            sum = static_cast<Type>(1) / sum;
;;;104          }
;;;105    
;;;106          return sum;
;;;107        }
;;;108    
;;;109        template<typename Type> void Swap(Type &a, Type &b)
;;;110        {
;;;111          const Type tmp = a;
;;;112          a = b;
;;;113          b = tmp;
;;;114        } // template<typename Type> Swap(Type a, Type b)
;;;115    
;;;116        template<typename Type> u32 BinaryStringToUnsignedNumber(const FixedLengthList<Type> &bits, bool firstBitIsLow)
;;;117        {
;;;118          u32 number = 0;
;;;119    
;;;120          const s32 numBits = bits.get_size();
;;;121    
;;;122          for(s32 bit=0; bit<numBits; bit++) {
;;;123            if(firstBitIsLow) {
;;;124              if(bit == 0) {
;;;125                number += bits[bit];
;;;126              } else {
;;;127                number += bits[bit] << bit;
;;;128              }
;;;129            } else {
;;;130              if(bit == (numBits-1)) {
;;;131                number += bits[bit];
;;;132              } else {
;;;133                number += bits[bit] << (numBits - bit - 1);
;;;134              }
;;;135            }
;;;136          }
;;;137    
;;;138          return number;
;;;139        }
;;;140    
;;;141        template<typename Type> Type Determinant2x2(const Type a, const Type b, const Type c, const Type d)
;;;142        {
;;;143          return a*d - b*c;
;;;144        }
;;;145    
;;;146        template<typename Type> Type Determinant3x3(const Type a, const Type b, const Type c, const Type d, const Type e, const Type f, const Type g, const Type h, const Type i)
;;;147        {
;;;148          return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
;;;149        }
;;;150    
;;;151        template<typename Type> void Invert3x3(Type &a, Type &b, Type &c, Type &d, Type &e, Type &f, Type &g, Type &h, Type &i)
;;;152        {
;;;153          const Type determinant = Determinant3x3(a,b,c,d,e,f,g,h,i);
;;;154          const Type determinantInverse = static_cast<Type>(1) / determinant;
;;;155    
;;;156          const Type A =  (e*i - f*h);
;;;157          const Type B = -(d*i - f*g);
;;;158          const Type C =  (d*h - e*g);
;;;159          const Type D = -(b*i - c*h);
;;;160          const Type E =  (a*i - c*g);
;;;161          const Type F = -(a*h - b*g);
;;;162          const Type G =  (b*f - c*e);
;;;163          const Type H = -(a*f - c*d);
;;;164          const Type I =  (a*e - b*d);
;;;165    
;;;166          a = A * determinantInverse;
;;;167          b = D * determinantInverse;
;;;168          c = G * determinantInverse;
;;;169          d = B * determinantInverse;
;;;170          e = E * determinantInverse;
;;;171          f = H * determinantInverse;
;;;172          g = C * determinantInverse;
;;;173          h = F * determinantInverse;
;;;174          i = I * determinantInverse;
;;;175        }
;;;176    
;;;177        template<typename Type> void Cart2Pol(const Type x, const Type y, Type &rho, Type &theta)
;;;178        {
;;;179          if (x==0 && y==0) {
;;;180            theta = 0;
;;;181            rho = 0;
;;;182          } else {
;;;183            theta = atan2f(y, x);
;;;184            rho = sqrtf(x*x + y*y);
;;;185          }
;;;186        }
;;;187    
;;;188        template<typename Type> void Pol2Cart(const Type rho, const Type theta, Type &x, Type &y)
;;;189        {
;;;190          x = rho * cosf(theta);
;;;191          y = rho * sinf(theta);
;;;192        }
;;;193    
;;;194        inline s32 FloorS32(f32 x)
;;;195        {
;;;196          return static_cast<s32>(floorf(x));
;;;197        }
;;;198    
;;;199        inline s32 CeilS32(f32 x)
;;;200        {
;;;201          return static_cast<s32>(ceilf(x));
;;;202        }
;;;203    
;;;204    #if !defined(__EDG__)
;;;205        // Some platforms may not round to zero correctly, so do the function calls
;;;206        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(floorf(v + 0.5f)) : 0; }
;;;207        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(floorf(v + 0.5f)) : 0; }
;;;208        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(floorf(v + 0.5f)) : static_cast<s32>(ceilf(v - 0.5f)); }
;;;209        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(floorf(v + 0.5f)) : static_cast<s64>(ceilf(v - 0.5f)); }
;;;210        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;211        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;212    
;;;213        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(floor(v + 0.5)) : 0; }
;;;214        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(floor(v + 0.5)) : 0; }
;;;215        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(floor(v + 0.5)) : static_cast<s32>(ceil(v - 0.5)); }
;;;216        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(floor(v + 0.5)) : static_cast<s64>(ceil(v - 0.5)); }
;;;217        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;218        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;219    #else
;;;220        // The M4 rounds to zero correctly, without the function calls
;;;221        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(v + 0.5f) : 0; }
;;;222        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(v + 0.5f) : 0; }
;;;223        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(v + 0.5f) : static_cast<s32>(v - 0.5f); }
;;;224        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(v + 0.5f) : static_cast<s64>(v - 0.5f); }
;;;225        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;226        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;227    
;;;228        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(v + 0.5) : 0; }
;;;229        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(v + 0.5) : 0; }
;;;230        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(v + 0.5) : static_cast<s32>(v - 0.5); }
;;;231        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(v + 0.5) : static_cast<s64>(v - 0.5); }
;;;232        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;233        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;234    #endif
;;;235    
;;;236        // Most cases of RoundIfInteger are from int-to-int or float-to-float, so just do a normal cast
;;;237        template<typename Type> inline Type RoundIfInteger(const u8  v) { return static_cast<Type>(v); }
;;;238        template<typename Type> inline Type RoundIfInteger(const s8  v) { return static_cast<Type>(v); }
;;;239        template<typename Type> inline Type RoundIfInteger(const u16 v) { return static_cast<Type>(v); }
;;;240        template<typename Type> inline Type RoundIfInteger(const s16 v) { return static_cast<Type>(v); }
;;;241        template<typename Type> inline Type RoundIfInteger(const u32 v) { return static_cast<Type>(v); }
;;;242        template<typename Type> inline Type RoundIfInteger(const s32 v) { return static_cast<Type>(v); }
;;;243        template<typename Type> inline Type RoundIfInteger(const u64 v) { return static_cast<Type>(v); }
;;;244        template<typename Type> inline Type RoundIfInteger(const s64 v) { return static_cast<Type>(v); }
;;;245        template<typename Type> inline Type RoundIfInteger(const f32 v) { return static_cast<Type>(v); }
;;;246        template<typename Type> inline Type RoundIfInteger(const f64 v) { return static_cast<Type>(v); }
;;;247    
;;;248        // Specialize for cases with float-to-int
;;;249        template<> inline u8  RoundIfInteger(const f32 v) { return static_cast<u8> (Round<s32>(v)); }
;;;250        template<> inline s8  RoundIfInteger(const f32 v) { return static_cast<s8> (Round<s32>(v)); }
;;;251        template<> inline u16 RoundIfInteger(const f32 v) { return static_cast<u16>(Round<s32>(v)); }
;;;252        template<> inline s16 RoundIfInteger(const f32 v) { return static_cast<s16>(Round<s32>(v)); }
;;;253        template<> inline u32 RoundIfInteger(const f32 v) { return static_cast<u32>(Round<u32>(v)); }
;;;254        template<> inline s32 RoundIfInteger(const f32 v) { return static_cast<s32>(Round<s32>(v)); }
;;;255        template<> inline u64 RoundIfInteger(const f32 v) { return static_cast<u64>(Round<u64>(v)); }
;;;256        template<> inline s64 RoundIfInteger(const f32 v) { return static_cast<s64>(Round<s64>(v)); }
;;;257    
;;;258        template<> inline u8  RoundIfInteger(const f64 v) { return static_cast<u8> (Round<s32>(v)); }
;;;259        template<> inline s8  RoundIfInteger(const f64 v) { return static_cast<s8> (Round<s32>(v)); }
;;;260        template<> inline u16 RoundIfInteger(const f64 v) { return static_cast<u16>(Round<s32>(v)); }
;;;261        template<> inline s16 RoundIfInteger(const f64 v) { return static_cast<s16>(Round<s32>(v)); }
;;;262        template<> inline u32 RoundIfInteger(const f64 v) { return static_cast<u32>(Round<u32>(v)); }
;;;263        template<> inline s32 RoundIfInteger(const f64 v) { return static_cast<s32>(Round<s32>(v)); }
;;;264        template<> inline u64 RoundIfInteger(const f64 v) { return static_cast<u64>(Round<u64>(v)); }
;;;265        template<> inline s64 RoundIfInteger(const f64 v) { return static_cast<s64>(Round<s64>(v)); }
;;;266    
;;;267        // Floats and complex data types aren't specialized
;;;268        template<typename Type> inline Type saturate_cast(const u8  v) { return static_cast<Type>(v); }
;;;269        template<typename Type> inline Type saturate_cast(const s8  v) { return static_cast<Type>(v); }
;;;270        template<typename Type> inline Type saturate_cast(const u16 v) { return static_cast<Type>(v); }
;;;271        template<typename Type> inline Type saturate_cast(const s16 v) { return static_cast<Type>(v); }
;;;272        template<typename Type> inline Type saturate_cast(const u32 v) { return static_cast<Type>(v); }
;;;273        template<typename Type> inline Type saturate_cast(const s32 v) { return static_cast<Type>(v); }
;;;274        template<typename Type> inline Type saturate_cast(const u64 v) { return static_cast<Type>(v); }
;;;275        template<typename Type> inline Type saturate_cast(const s64 v) { return static_cast<Type>(v); }
;;;276        template<typename Type> inline Type saturate_cast(const f32 v) { return static_cast<Type>(v); }
;;;277        template<typename Type> inline Type saturate_cast(const f64 v) { return static_cast<Type>(v); }
;;;278    
;;;279        // Most saturate_cast calls are explicitly specialized
;;;280        template<> inline u8  saturate_cast<u8> (const u8  v) { return v; }
;;;281        template<> inline u8  saturate_cast<u8> (const u16 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;282        template<> inline u8  saturate_cast<u8> (const u32 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;283        template<> inline u8  saturate_cast<u8> (const u64 v) { return (u8)             MIN((u64)u8_MAX, (u64)v); }
;;;284        template<> inline u8  saturate_cast<u8> (const s8  v) { return (u8)                              MAX((s32)0, (s32)v);  }
;;;285        template<> inline u8  saturate_cast<u8> (const s16 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;286        template<> inline u8  saturate_cast<u8> (const s32 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;287        template<> inline u8  saturate_cast<u8> (const s64 v) { return (u8)             MIN((s64)u8_MAX, MAX((s64)0, (s64)v)); }
;;;288        template<> inline u8  saturate_cast<u8> (const f32 v) { return (u8) Round<s32>( MIN((f32)u8_MAX, MAX((f32)0, (f32)v)) ); }
;;;289        template<> inline u8  saturate_cast<u8> (const f64 v) { return (u8) Round<s32>( MIN((f64)u8_MAX, MAX((f64)0, (f64)v)) ); }
;;;290    
;;;291        template<> inline s8  saturate_cast<s8> (const u8  v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;292        template<> inline s8  saturate_cast<s8> (const u16 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;293        template<> inline s8  saturate_cast<s8> (const u32 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;294        template<> inline s8  saturate_cast<s8> (const u64 v) { return (s8)             MIN((u64)s8_MAX, (u64)v); }
;;;295        template<> inline s8  saturate_cast<s8> (const s8  v) { return v; }
;;;296        template<> inline s8  saturate_cast<s8> (const s16 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;297        template<> inline s8  saturate_cast<s8> (const s32 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;298        template<> inline s8  saturate_cast<s8> (const s64 v) { return (s8)             MIN((s64)s8_MAX, MAX((s64)s8_MIN, (s64)v)); }
;;;299        template<> inline s8  saturate_cast<s8> (const f32 v) { return (s8) Round<s32>( MIN((f32)s8_MAX, MAX((f32)s8_MIN, (f32)v)) ); }
;;;300        template<> inline s8  saturate_cast<s8> (const f64 v) { return (s8) Round<s32>( MIN((f64)s8_MAX, MAX((f64)s8_MIN, (f64)v)) ); }
;;;301    
;;;302        template<> inline u16 saturate_cast<u16>(const u8  v) { return v; }
;;;303        template<> inline u16 saturate_cast<u16>(const u16 v) { return v; }
;;;304        template<> inline u16 saturate_cast<u16>(const u32 v) { return (u16)             MIN((u32)u16_MAX, (u32)v); }
;;;305        template<> inline u16 saturate_cast<u16>(const u64 v) { return (u16)             MIN((u64)u16_MAX, (u64)v); }
;;;306        template<> inline u16 saturate_cast<u16>(const s8  v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;307        template<> inline u16 saturate_cast<u16>(const s16 v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;308        template<> inline u16 saturate_cast<u16>(const s32 v) { return (u16)             MIN((s32)u16_MAX, MAX((s32)0, (s32)v)); }
;;;309        template<> inline u16 saturate_cast<u16>(const s64 v) { return (u16)             MIN((s64)u16_MAX, MAX((s64)0, (s64)v)); }
;;;310        template<> inline u16 saturate_cast<u16>(const f32 v) { return (u16) Round<s32>( MIN((f32)u16_MAX, MAX((f32)0, (f32)v)) ); }
;;;311        template<> inline u16 saturate_cast<u16>(const f64 v) { return (u16) Round<s32>( MIN((f64)u16_MAX, MAX((f64)0, (f64)v)) ); }
;;;312    
;;;313        template<> inline s16 saturate_cast<s16>(const u8  v) { return v; }
;;;314        template<> inline s16 saturate_cast<s16>(const u16 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;315        template<> inline s16 saturate_cast<s16>(const u32 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;316        template<> inline s16 saturate_cast<s16>(const u64 v) { return (s16)             MIN((u64)s16_MAX, (u64)v); }
;;;317        template<> inline s16 saturate_cast<s16>(const s8  v) { return v; }
;;;318        template<> inline s16 saturate_cast<s16>(const s16 v) { return v; }
;;;319        template<> inline s16 saturate_cast<s16>(const s32 v) { return (s16)             MIN((s32)s16_MAX, MAX((s32)s16_MIN, (s32)v)); }
;;;320        template<> inline s16 saturate_cast<s16>(const s64 v) { return (s16)             MIN((s64)s16_MAX, MAX((s64)s16_MIN, (s64)v)); }
;;;321        template<> inline s16 saturate_cast<s16>(const f32 v) { return (s16) Round<s32>( MIN((f32)s16_MAX, MAX((f32)s16_MIN, (f32)v)) ); }
;;;322        template<> inline s16 saturate_cast<s16>(const f64 v) { return (s16) Round<s32>( MIN((f64)s16_MAX, MAX((f64)s16_MIN, (f64)v)) ); }
;;;323    
;;;324        template<> inline u32 saturate_cast<u32>(const u8  v) { return v; }
;;;325        template<> inline u32 saturate_cast<u32>(const u16 v) { return v; }
;;;326        template<> inline u32 saturate_cast<u32>(const u32 v) { return v; }
;;;327        template<> inline u32 saturate_cast<u32>(const u64 v) { return (u32)             MIN((u64)u32_MAX, (u64)v); }
;;;328        template<> inline u32 saturate_cast<u32>(const s8  v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;329        template<> inline u32 saturate_cast<u32>(const s16 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;330        template<> inline u32 saturate_cast<u32>(const s32 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;331        template<> inline u32 saturate_cast<u32>(const s64 v) { return (u32)             MIN((s64)u32_MAX, MAX((s64)0, (s64)v)); }
;;;332        template<> inline u32 saturate_cast<u32>(const f32 v) { return (u32) (v > (f32)0xFFFFFF7F) ? 0xFFFFFFFF : Round<u32>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;333        template<> inline u32 saturate_cast<u32>(const f64 v) { return (u32) Round<u32>( MIN((f64)u32_MAX, MAX((f64)0, (f64)v)) ); }
;;;334    
;;;335        template<> inline s32 saturate_cast<s32>(const u8  v) { return v; }
;;;336        template<> inline s32 saturate_cast<s32>(const u16 v) { return v; }
;;;337        template<> inline s32 saturate_cast<s32>(const u32 v) { return (s32)             MIN((u32)s32_MAX, (u32)v); }
;;;338        template<> inline s32 saturate_cast<s32>(const u64 v) { return (s32)             MIN((u64)s32_MAX, (u64)v); }
;;;339        template<> inline s32 saturate_cast<s32>(const s8  v) { return v; }
;;;340        template<> inline s32 saturate_cast<s32>(const s16 v) { return v; }
;;;341        template<> inline s32 saturate_cast<s32>(const s32 v) { return v; }
;;;342        template<> inline s32 saturate_cast<s32>(const s64 v) { return (s32)             MIN((s64)s32_MAX, MAX((s64)s32_MIN, (s64)v)); }
;;;343        template<> inline s32 saturate_cast<s32>(const f32 v) { return (s32) (v > (f32)0x7FFFFFBF) ? 0x7FFFFFFF : Round<s32>(MAX((f32)s32_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;344        template<> inline s32 saturate_cast<s32>(const f64 v) { return (s32) Round<s32>( MIN((f64)s32_MAX, MAX((f64)s32_MIN, (f64)v)) ); }
;;;345    
;;;346        template<> inline u64 saturate_cast<u64>(const u8  v) { return v; }
;;;347        template<> inline u64 saturate_cast<u64>(const u16 v) { return v; }
;;;348        template<> inline u64 saturate_cast<u64>(const u32 v) { return v; }
;;;349        template<> inline u64 saturate_cast<u64>(const u64 v) { return v; }
;;;350        template<> inline u64 saturate_cast<u64>(const s8  v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;351        template<> inline u64 saturate_cast<u64>(const s16 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;352        template<> inline u64 saturate_cast<u64>(const s32 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;353        template<> inline u64 saturate_cast<u64>(const s64 v) { return (u64)                               MAX((s64)0, (s64)v);  }
;;;354        template<> inline u64 saturate_cast<u64>(const f32 v) { return (u64) (v > (f32)0XFFFFFF7FFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;355        template<> inline u64 saturate_cast<u64>(const f64 v) { return (u64) (v > (f64)0xFFFFFFFFFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f64)0, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;356    
;;;357        template<> inline s64 saturate_cast<s64>(const u8  v) { return v; }
;;;358        template<> inline s64 saturate_cast<s64>(const u16 v) { return v; }
;;;359        template<> inline s64 saturate_cast<s64>(const u32 v) { return v; }
;;;360        template<> inline s64 saturate_cast<s64>(const u64 v) { return (s64)             MIN((u64)s64_MAX, (u64)v); }
;;;361        template<> inline s64 saturate_cast<s64>(const s8  v) { return v; }
;;;362        template<> inline s64 saturate_cast<s64>(const s16 v) { return v; }
;;;363        template<> inline s64 saturate_cast<s64>(const s32 v) { return v; }
;;;364        template<> inline s64 saturate_cast<s64>(const s64 v) { return v; }
;;;365        template<> inline s64 saturate_cast<s64>(const f32 v) { return (s64) (v > (f32)0x7FFFFFBFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f32)s64_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;366        template<> inline s64 saturate_cast<s64>(const f64 v) { return (s64) (v > (f64)0x7FFFFFFFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f64)s64_MIN, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;367    
;;;368        template<> inline f32 saturate_cast(const f64 v) { return (f32) MIN((f64)FLT_MAX, MAX(-(f64)FLT_MAX, (f64)v)); }
;;;369      } // namespace Embedded
;;;370    } // namespace Anki
;;;371    
;;;372    #endif // _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;18     #include "anki/common/robot/memory.h"
;;;1      /**
;;;19     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;20     #include "anki/common/robot/geometry.h"
;;;1      /**
;;;2      File: geometry.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of geometry_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/geometry_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/memory.h"
;;;1      /**
;;;18     #include "anki/common/robot/matrix.h"
;;;1      /**
;;;2      File: matrix.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of matrix_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;14     
;;;15     #include "anki/common/robot/matrix_declarations.h"
;;;1      /**
;;;2      File: matrix_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various Matrix operations, such as matrix multiply and addition.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;2      File: arraySlices_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      An array slice is a sub-array of an Array object.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Class Declarations ---
;;;23     
;;;24         template<typename Type> class ConstArraySlice;
;;;25         template<typename Type> class ArraySlice;
;;;26         template<typename Type> class ConstArraySliceExpression;
;;;27     
;;;28         // An ArraySlice is a simple indexing wrapper on top of an Array. The slice of an Array could be
;;;29         // a sub-rectangle of an array and/or skip every n-th element.
;;;30         //
;;;31         // For example, Array(0,3,-1,1,2,4) is the same as Matlab's array(1:3:end, 2:2:5).
;;;32         // (The Array indexing starts from zero vs Matlab's one, hence the different numbers).
;;;33         //
;;;34         // TODO: support non-int indexes
;;;35         // TODO: is there a better way of doing this than a completely different class, different only
;;;36         //       by const?
;;;37         template<typename Type> class ConstArraySlice
;;;38         {
;;;39         public:
;;;40           ConstArraySlice();
;;;41     
;;;42           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;43           ConstArraySlice(const Array<Type> &array);
;;;44     
;;;45           // It's probably easier to call array.operator() than this constructor directly
;;;46           ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;47     
;;;48           // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;49           ConstArraySliceExpression<Type> Transpose() const;
;;;50     
;;;51           bool IsValid() const;
;;;52     
;;;53           const LinearSequence<s32>& get_ySlice() const;
;;;54     
;;;55           const LinearSequence<s32>& get_xSlice() const;
;;;56     
;;;57           // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;58           // don't support the full ArraySlice type, and should be used with caution.
;;;59           const Array<Type>& get_array() const;
;;;60     
;;;61         protected:
;;;62           LinearSequence<s32> ySlice;
;;;63           LinearSequence<s32> xSlice;
;;;64     
;;;65           Array<Type> array;
;;;66     
;;;67           // For speed, this is a direct pointer to the Array's protected data
;;;68           const Type * constArrayData;
;;;69         }; // template<typename Type> class ArraySlice
;;;70     
;;;71         // A non-const version of ConstArraySlice, see ConstArraySlice for details
;;;72         //
;;;73         // WARNING: A "const ArraySlice" doesn't have a const Array. Only ConstArraySlice has a const
;;;74         //          Array. This allows for implicit conversion to non-const function parameters.
;;;75         template<typename Type> class ArraySlice : public ConstArraySlice<Type>
;;;76         {
;;;77         public:
;;;78           ArraySlice();
;;;79     
;;;80           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;81           // The Array parameter is not a reference, to allow for implicit conversion
;;;82           ArraySlice(Array<Type> array);
;;;83     
;;;84           // It's probably easier to call array.operator() than this constructor directly
;;;85           // The Array parameter is not a reference, to allow for implicit conversion
;;;86           ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;87     
;;;88           // If automaticTranspose==true, then you can set a MxN slice with a NxM input.
;;;89           // Matlab allows this for vectors, though this method will also work for
;;;90           // arbitrary-sized arrays.
;;;91           s32 Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
;;;92     
;;;93           // Explicitly evaluate the input LinearSequence into this ArraySlice
;;;94           s32 Set(const LinearSequence<Type> &input);
;;;95     
;;;96           // Set all values of this slice to the given value.
;;;97           //
;;;98           // For example, "array(0,-1,1,4).Set(5);" is the same as
;;;99           // Matlab's "array(1:end, 2:5) = 5;"
;;;100          s32 Set(const Type value);
;;;101    
;;;102          // Copy values to this ArraySlice.
;;;103          // numValues must be equal to the number of values in this slice
;;;104          // Returns the number of values set
;;;105          s32 Set(const Type * const values, const s32 numValues);
;;;106    
;;;107          // Read in the input, then cast it to this object's type
;;;108          //
;;;109          // WARNING:
;;;110          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;111          template<typename InType> s32 SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
;;;112          //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;113    
;;;114          // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;115          // don't support the full ArraySlice type, and should be used with caution.
;;;116          Array<Type>& get_array();
;;;117    
;;;118        protected:
;;;119    
;;;120          // For speed, this is a direct pointer to the Array's protected data
;;;121          Type * arrayData;
;;;122        }; // template<typename Type> class ArraySlice
;;;123    
;;;124        // An ConstArraySliceExpression is like a ConstArraySlice, but can also be transposed
;;;125        // It may have other abilities in the future, but will probably always be const
;;;126        template<typename Type> class ConstArraySliceExpression : public ConstArraySlice<Type>
;;;127        {
;;;128        public:
;;;129          ConstArraySliceExpression();
;;;130    
;;;131          ConstArraySliceExpression(const Array<Type> input, bool isTransposed=false);
;;;132    
;;;133          ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed=false);
;;;134    
;;;135          ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed=false);
;;;136    
;;;137          // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;138          // This object isn't modified, but the returned object is.
;;;139          ConstArraySliceExpression<Type> Transpose() const;
;;;140    
;;;141          bool get_isTransposed() const;
;;;142    
;;;143        protected:
;;;144          bool isTransposed;
;;;145        };
;;;146    
;;;147        // To simplify the creation of kernels using an ArraySlice, and to aid the compiler optimizer,
;;;148        // an ArraySliceLimits can be initialized at the beginning of the function, then used as the
;;;149        // limits for the inner loops.
;;;150    
;;;151        // The suffix of in# and out# refer to the number of input and output matrices.
;;;152        // If output == 0, then the output is a scalar.
;;;153    
;;;154        template<typename Type> class ArraySliceSimpleLimits
;;;155        {
;;;156        public:
;;;157          Type xStart;
;;;158          Type xIncrement;
;;;159          s32  xSize;
;;;160    
;;;161          Type yStart;
;;;162          Type yIncrement;
;;;163          s32  ySize;
;;;164    
;;;165          ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;166        };
;;;167    
;;;168        // In1 and out0 is a special, ultra-simple case, for one matrix input and a scalar output
;;;169        template<typename Type> class ArraySliceLimits_in1_out0
;;;170        {
;;;171        public:
;;;172          // Was this ArraySliceLimits initialized?
;;;173          bool isValid;
;;;174    
;;;175          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;176    
;;;177          ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;178        };
;;;179    
;;;180        // One input, one output
;;;181        template<typename Type> class ArraySliceLimits_in1_out1
;;;182        {
;;;183        public:
;;;184          // Was this ArraySliceLimits initialized?
;;;185          bool isValid;
;;;186    
;;;187          // Can a simple (non-transposed) iteration be performed?
;;;188          bool isSimpleIteration;
;;;189    
;;;190          // These are the current values for the coordinates in the input and output images
;;;191          s32 out1Y;
;;;192          s32 out1X;
;;;193          s32 in1Y;
;;;194          s32 in1X;
;;;195    
;;;196          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;197          s32 ySize;
;;;198          s32 xSize;
;;;199    
;;;200          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;201          // incremented every iteration of the inner loop
;;;202          s32 out1_xInnerIncrement;
;;;203          s32 in1_xInnerIncrement;
;;;204          s32 in1_yInnerIncrement;
;;;205    
;;;206          ArraySliceLimits_in1_out1(
;;;207            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;208            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;209    
;;;210          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;211          inline void OuterIncrementTop();
;;;212    
;;;213          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;214          inline void OuterIncrementBottom();
;;;215    
;;;216        protected:
;;;217          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;218    
;;;219          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;220          bool in1_isTransposed;
;;;221        };
;;;222    
;;;223        // Two inputs, one output
;;;224        template<typename Type> class ArraySliceLimits_in2_out1
;;;225        {
;;;226        public:
;;;227          // Was this ArraySliceLimits initialized?
;;;228          bool isValid;
;;;229    
;;;230          // Can a simple (non-transposed) iteration be performed?
;;;231          bool isSimpleIteration;
;;;232    
;;;233          // These are the current values for the coordinates in the input and output images
;;;234          s32 out1Y;
;;;235          s32 out1X;
;;;236          s32 in1Y;
;;;237          s32 in1X;
;;;238          s32 in2Y;
;;;239          s32 in2X;
;;;240    
;;;241          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;242          s32 ySize;
;;;243          s32 xSize;
;;;244    
;;;245          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;246          // incremented every iteration of the inner loop
;;;247          s32 out1_xInnerIncrement;
;;;248          s32 in1_xInnerIncrement;
;;;249          s32 in1_yInnerIncrement;
;;;250          s32 in2_xInnerIncrement;
;;;251          s32 in2_yInnerIncrement;
;;;252    
;;;253          ArraySliceLimits_in2_out1(
;;;254            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;255            const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed,
;;;256            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;257    
;;;258          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;259          inline void OuterIncrementTop();
;;;260    
;;;261          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;262          inline void OuterIncrementBottom();
;;;263    
;;;264        protected:
;;;265          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;266    
;;;267          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;268          bool in1_isTransposed;
;;;269    
;;;270          ArraySliceSimpleLimits<Type> rawIn2Limits;
;;;271          bool in2_isTransposed;
;;;272        };
;;;273      } // namespace Embedded
;;;274    } // namespace Anki
;;;275    
;;;276    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         namespace Matrix
;;;24         {
;;;25           // #pragma mark --- Declarations ---
;;;26     
;;;27           //
;;;28           // Simple matrix statistics
;;;29           //
;;;30     
;;;31           // Return the minimum element in this Array
;;;32           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat);
;;;33     
;;;34           // Return the maximum element in this Array
;;;35           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat);
;;;36     
;;;37           // Return the sum of every element in the Array
;;;38           template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat);
;;;39     
;;;40           // Return the mean of every element in the Array
;;;41           template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat);
;;;42     
;;;43           // Simultaneously compute the mean and variance of every element in the Array
;;;44           template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(const ConstArraySliceExpression<Array_Type> &mat,
;;;45             Accumulator_Type& mean, Accumulator_Type& var);
;;;46     
;;;47           //
;;;48           // Elementwise matrix operations
;;;49           //
;;;50     
;;;51           // Elementwise add two arrays. in1, in2, and out can be the same array
;;;52           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;53           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;54           template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;55     
;;;56           // Elementwise subtract two arrays. in1, in2, and out can be the same array
;;;57           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;58           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;59           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;60     
;;;61           // Elementwise multiply two arrays. in1, in2, and out can be the same array
;;;62           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;63           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;64           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;65     
;;;66           // Elementwise divide two arrays. in1, in2, and out can be the same array
;;;67           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;68           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;69           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;70     
;;;71           // Elementwise exponential on an array
;;;72           template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;73     
;;;74           // Elementwise square root on an array
;;;75           template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;76     
;;;77           //
;;;78           // Standard matrix operations
;;;79           //
;;;80     
;;;81           // Perform the matrix multiplication "out = in1 * in2"
;;;82           // Note that this is the naive O(n^3) Definition
;;;83           template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out);
;;;84     
;;;85           // Perform the matrix multiplication "out = in1 * in2'"
;;;86           // Note that this is the naive O(n^3) Definition
;;;87           // MultiplyTranspose has better access patterns than Multiply for certain types of arrays, so could be a lot faster (and easier to accelerate)
;;;88           template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out);
;;;89     
;;;90           //
;;;91           // Rotation Matrices
;;;92           //
;;;93     
;;;94           // TODO: Add other rotation-related math, like Rodrigues' formula, or Pose chaining...
;;;95     
;;;96           // Compute the three Euler angles from a given 3x3 Rotation Matrix.
;;;97           Result GetEulerAngles(const Array<f32>& R, f32& angle_x, f32& angle_y, f32& angle_z);
;;;98     
;;;99           //
;;;100          // Linear Algebra and Linear Solvers
;;;101          //
;;;102    
;;;103          // Compute the Cholesky-Banachiewicz decomposition, to return a lower-triangular matrix L such that A=L*L'
;;;104          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;105            Array<Type> &A_L,      //!< Input A Matrix and Output lower-triangular L matrix
;;;106            Array<Type> &Bt_Xt,    //!< Input B-transpose matrix and Output X-transpose solution
;;;107            bool realCholesky,     //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;108            bool &numericalFailure //!< If true, the solver failed because of numerical instability
;;;109            );
;;;110    
;;;111          // Compute the homography such that "transformedPoints = homography * originalPoints"
;;;112          //
;;;113          // WARNING: This uses the inhomogeneous solution and the Cholesky decomposition, therefore it
;;;114          //          will be incorrect if H_33 is zero, which happens in certain cases of lines at
;;;115          //          inifinty. For more details, see Multiple View Geometry 2nd Edition, Example 4.1
;;;116          template<typename Type> Result EstimateHomography(
;;;117            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;118            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;119            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;120            bool &numericalFailure, //!< Did the homography solver fail?
;;;121            MemoryStack scratch //!< Scratch memory
;;;122            );
;;;123    
;;;124          //template<typename InType, typename IntermediateType, typename OutType> Result CholeskyDecomposition(
;;;125          //  const Array<InType> &A,                    //!< Input A Matrix
;;;126          //  Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;127          //  Array<OutType> &L                          //!< Output lower-triangular L matrix
;;;128          //  );
;;;129    
;;;130          //template<typename InType, typename IntermediateType, typename OutType> Result SolveWithLowerTriangular(
;;;131          //  const Array<InType> &L,                          //!< Input lower-triangular L matrix (such as computed by CholeskyDecomposition)
;;;132          //  const Array<InType> &b,                          //!< Input b matrix
;;;133          //  const Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;134          //  Array<OutType> &x                                //!< Output x solution
;;;135          //  );
;;;136    
;;;137          // Solves Ax = b
;;;138          // Specifically, it uses SVD to minimize ||Ax - b||
;;;139          // Note that the A, b, and x matrices are transposed (this is because for large numbers of samples, transposed inputs are liable to be faster)
;;;140          //Result SolveLeastSquaresWithSVD_f32(Array<f32> &At, const Array<f32> &bt, Array<f32> &xt, MemoryStack scratch);
;;;141          //Result SolveLeastSquaresWithSVD_f64(Array<f64> &At, const Array<f64> &bt, Array<f64> &xt, MemoryStack scratch);
;;;142    
;;;143          //
;;;144          // Matrix structure operations
;;;145          //
;;;146    
;;;147          // matlab equivalent: out = reshape(in, [M,N]);
;;;148          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;149          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory);
;;;150    
;;;151          // matlab equivalent: out = in(:);
;;;152          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;153          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory);
;;;154    
;;;155          // Perform an immediate matrix transpose (unlike the lazy transpose of ArraySlice)
;;;156          // in and out must be different Array objects
;;;157          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out);
;;;158    
;;;159          // Rotate an array clockwise by 90, 180, or 270 degrees.
;;;160          // NOTE: Only works for a square matrix.
;;;161          // NOTE: In and out must be different arrays (unlike the interview question)
;;;162          template<typename InType, typename OutType> Result Rotate90( const Array<InType> &in, Array<OutType> &out);
;;;163          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out);
;;;164          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out);
;;;165    
;;;166          //
;;;167          // Misc matrix operations
;;;168          //
;;;169    
;;;170          // Works the same as the Matlab sort() for matrices.
;;;171          // InsertionSort(X) sorts each column of X in ascending order.
;;;172          // The minIndex and maxIndex are for the sortWhichDimension. maxIndex is automatically clipped to the size of the input Array.
;;;173          // NOTE: this currently uses insertion sort, so may be slow for large, badly-unsorted arrays
;;;174          template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;175    
;;;176          // Subsections less-than-or-equal-to insertionSortSize are sorted with insertion sort
;;;177          template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;178    
;;;179          // indexes must be allocated, but will be overwritten by InsertionSort()
;;;180          template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;181    
;;;182          template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;183    
;;;184          // For a square array, either:
;;;185          // 1. When lowerToUpper==true,  copies the lower (left)  triangle to the upper (right) triangle
;;;186          // 2. When lowerToUpper==false, copies the upper (right) triangle to the lower (left)  triangle
;;;187          // Functionally the same as OpenCV completeSymm()
;;;188          template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper = false);
;;;189    
;;;190          // There's probably no need to use these directly. Instead, use the normal Matrix:: operations, like Matrix::Add
;;;191          namespace Elementwise
;;;192          {
;;;193            template<typename InType, typename IntermediateType, typename OutType> class Add {
;;;194            public:
;;;195              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) + static_cast<IntermediateType>(value2));}
;;;196            };
;;;197    
;;;198            template<typename InType, typename IntermediateType, typename OutType> class Subtract {
;;;199            public:
;;;200              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) - static_cast<IntermediateType>(value2));}
;;;201            };
;;;202    
;;;203            template<typename InType, typename IntermediateType, typename OutType> class DotMultiply {
;;;204            public:
;;;205              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) * static_cast<IntermediateType>(value2));}
;;;206            };
;;;207    
;;;208            template<typename InType, typename IntermediateType, typename OutType> class DotDivide {
;;;209            public:
;;;210              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) / static_cast<IntermediateType>(value2));}
;;;211            };
;;;212    
;;;213            // Technically a unary operator, but we ignore the second parameter
;;;214            // TODO: if this is slow, make a unary version of ApplyOperation
;;;215            template<typename InType, typename IntermediateType, typename OutType> class Exp {
;;;216            public:
;;;217              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(expf(static_cast<IntermediateType>(value1)));}
;;;218            };
;;;219    
;;;220            template<typename InType, typename IntermediateType, typename OutType> class Sqrt {
;;;221            public:
;;;222              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(sqrtf(static_cast<IntermediateType>(value1)));}
;;;223            };
;;;224    
;;;225            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;226            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;227            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;228          } // namespace Elementwise
;;;229        } // namespace Matrix
;;;230      } // namespace Embedded
;;;231    } // namespace Anki
;;;232    
;;;233    #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;18     #include "anki/common/robot/memory.h"
;;;19     #include "anki/common/robot/errorHandling.h"
;;;20     #include "anki/common/robot/geometry.h"
;;;21     #include "anki/common/robot/utilities_c.h"
;;;22     #include "anki/common/robot/sequences.h"
;;;23     #include "anki/common/robot/matrix.h"
;;;24     #include "anki/common/robot/comparisons.h"
;;;25     
;;;26     #include "anki/common/shared/utilities_shared.h"
;;;27     
;;;28     #include "anki/common/robot/serialize_declarations.h"
;;;29     
;;;30     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;31     #include "opencv2/core/core.hpp"
;;;32     #include "opencv2/highgui/highgui.hpp"
;;;33     #include "opencv2/imgproc/imgproc.hpp"
;;;34     #include "opencv2/objdetect/objdetect.hpp"
;;;35     #endif
;;;36     
;;;37     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;38     #define ANKICORETECH_EMBEDDED_USE_MALLOC 1
;;;39     #define ANKICORETECH_EMBEDDED_USE_ZLIB 1
;;;40     #endif
;;;41     
;;;42     #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;43     #include "zlib.h"
;;;44     #endif
;;;45     
;;;46     namespace Anki
;;;47     {
;;;48       namespace Embedded
;;;49       {
;;;50         template<typename Type> class ArraySlice;
;;;51         template<typename Type> class ConstArraySlice;
;;;52         template<typename Type> class ConstArraySliceExpression;
;;;53     
;;;54         // #pragma mark --- Array Definitions ---
;;;55     
;;;56         template<typename Type> s32 Array<Type>::ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags)
;;;57         {
;;;58           AnkiConditionalErrorAndReturnValue(numCols >= 0,
;;;59             0, "Array<Type>::ComputeRequiredStride", "Invalid size");
;;;60     
;;;61           const s32 numColsCapped = MAX(numCols, 1);
;;;62     
;;;63           const s32 bufferRequired = static_cast<s32>(RoundUp<size_t>(sizeof(Type)*numColsCapped, MEMORY_ALIGNMENT));
;;;64     
;;;65           return bufferRequired;
;;;66         }
;;;67     
;;;68         template<typename Type> s32 Array<Type>::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags)
;;;69         {
;;;70           AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0,
;;;71             0, "Array<Type>::ComputeMinimumRequiredMemory", "Invalid size");
;;;72     
;;;73           const s32 numRowsCapped = MAX(numRows, 1);
;;;74     
;;;75           return numRowsCapped * Array<Type>::ComputeRequiredStride(numCols, flags);
;;;76         }
;;;77     
;;;78         template<typename Type> Array<Type>::Array()
;;;79         {
;;;80           InvalidateArray();
;;;81         }
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
;;;139        template<typename Type> Array<Type> Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;140        {
;;;141          Array<Type> newArray = Array<Type>();
;;;142    
;;;143    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;144          const cv::Mat cvImage = cv::imread(filename, CV_LOAD_IMAGE_GRAYSCALE);
;;;145    
;;;146          AnkiConditionalErrorAndReturnValue(cvImage.cols >= 0 && cvImage.rows >= 0,
;;;147            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;148    
;;;149          newArray = Array<Type>(cvImage.rows, cvImage.cols, memory);
;;;150    
;;;151          AnkiConditionalErrorAndReturnValue(newArray.IsValid(),
;;;152            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;153    
;;;154          const u8 * restrict pCvImage = cvImage.data;
;;;155    
;;;156          for(s32 y=0; y<cvImage.rows; y++) {
;;;157            Type * restrict pNewArray = newArray.Pointer(y, 0);
;;;158    
;;;159            for(s32 x=0; x<cvImage.cols; x++) {
;;;160              pNewArray[x] = static_cast<Type>(pCvImage[x]);
;;;161            }
;;;162    
;;;163            pCvImage += cvImage.step.buf[0];
;;;164          }
;;;165    #else
;;;166          AnkiError("Array<Type>::Array", "OpenCV is required to load an image from an image file");
;;;167    #endif
;;;168    
;;;169          return newArray;
;;;170        } // Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;171    
;;;172        template<typename Type> Array<Type> LoadBinaryArray_Generic(const char * filename, MemoryStack *scratch, MemoryStack *memory, void * allocatedBuffer, const s32 allocatedBufferLength)
;;;173        {
;;;174          u16  basicType_sizeOfType;
;;;175          bool basicType_isBasicType;
;;;176          bool basicType_isInteger;
;;;177          bool basicType_isSigned;
;;;178          bool basicType_isFloat;
;;;179          bool basicType_isString;
;;;180    
;;;181          Array<u8> rawArray = LoadBinaryArray_UnknownType(
;;;182            filename,
;;;183            scratch, memory,
;;;184            allocatedBuffer, allocatedBufferLength,
;;;185            basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString);
;;;186    
;;;187          // TODO: check that the types match
;;;188    
;;;189          Array<Type> newArray = *reinterpret_cast<Array<Type>*>( &rawArray );
;;;190    
;;;191          return newArray;
;;;192        } // / LoadBinaryArray_Generic()
;;;193    
;;;194        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;195        {
;;;196          return LoadBinaryArray_Generic<Type>(filename, &scratch, &memory, NULL, -1);
;;;197        } // Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;198    
;;;199        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength) //< allocatedBuffer must be freed manually
;;;200        {
;;;201          return LoadBinaryArray_Generic<Type>(filename, NULL, NULL, allocatedBuffer, allocatedBufferLength);
;;;202        } // LoadBinaryMalloc()
;;;203    
;;;204        template<typename Type> Result Array<Type>::SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const
;;;205        {
;;;206          AnkiConditionalErrorAndReturnValue(AreValid(*this, scratch) && filename,
;;;207            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::SaveBinary", "Invalid inputs");
;;;208    
;;;209          AnkiConditionalErrorAndReturnValue(compressionLevel >= 0 && compressionLevel <= 9,
;;;210            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::SaveBinary", "Invalid compression level");
;;;211    
;;;212          // If this is a string array, add the sizes of the null terminated strings (or zero otherwise)
;;;213          const s32 stringsLength = TotalArrayStringLengths<Type>(*this);
;;;214    
;;;215          const s32 serializedBufferLength = 4096 + ARRAY_FILE_HEADER_LENGTH + this->get_size(0) * this->get_stride() + stringsLength;
;;;216          void *buffer = scratch.Allocate(serializedBufferLength);
;;;217    
;;;218          AnkiConditionalErrorAndReturnValue(buffer,
;;;219            RESULT_FAIL_OUT_OF_MEMORY, "Array<Type>::SaveBinary", "Memory could not be allocated");
;;;220    
;;;221          SerializedBuffer toSave(buffer, serializedBufferLength);
;;;222    
;;;223          toSave.PushBack<Type>("Array", *this);
;;;224    
;;;225          s32 startIndex;
;;;226          u8 * bufferStart = reinterpret_cast<u8*>(toSave.get_memoryStack().get_validBufferStart(startIndex));
;;;227          const s32 validUsedBytes = toSave.get_memoryStack().get_usedBytes() - startIndex;
;;;228    
;;;229          // const s32 startDiff = static_cast<s32>( reinterpret_cast<size_t>(bufferStart) - reinterpret_cast<size_t>(toSave.get_memoryStack().get_buffer()) );
;;;230          // const s32 endDiff = toSave.get_memoryStack().get_totalBytes() - toSave.get_memoryStack().get_usedBytes();
;;;231    
;;;232          FILE *fp = fopen(filename, "wb");
;;;233    
;;;234          AnkiConditionalErrorAndReturnValue(fp,
;;;235            RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Could not open file %s", filename);
;;;236    
;;;237          if(compressionLevel > 0) {
;;;238    #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;239            char tmpTextHeader[ARRAY_FILE_HEADER_LENGTH+1];
;;;240            strncpy(tmpTextHeader, &ARRAY_FILE_HEADER[0], ARRAY_FILE_HEADER_LENGTH+1);
;;;241            snprintf(tmpTextHeader+ARRAY_FILE_HEADER_VALID_LENGTH+1, ARRAY_FILE_HEADER_LENGTH-ARRAY_FILE_HEADER_VALID_LENGTH, "z%s ", ZLIB_VERSION);
;;;242    
;;;243            const s32 originalLength = validUsedBytes + SERIALIZED_BUFFER_HEADER_LENGTH + SERIALIZED_BUFFER_FOOTER_LENGTH;
;;;244    
;;;245            uLongf compressedLength = 128 + saturate_cast<s32>(1.1 * originalLength);
;;;246    
;;;247            void * uncompressed = malloc(originalLength);
;;;248            void * compressed = malloc(compressedLength + 2*sizeof(s32));
;;;249    
;;;250            if(!uncompressed || !compressed) {
;;;251              if(uncompressed)
;;;252                free(uncompressed);
;;;253    
;;;254              if(compressed)
;;;255                free(compressed);
;;;256    
;;;257              AnkiError("Array<Type>::SaveBinary", "Out of memory");
;;;258    
;;;259              return RESULT_FAIL_OUT_OF_MEMORY;
;;;260            }
;;;261    
;;;262            // Copy the uncompressed data into one buffer
;;;263            {
;;;264              char * pUncompressed = reinterpret_cast<char*>(uncompressed);
;;;265    
;;;266              memcpy(pUncompressed, &SERIALIZED_BUFFER_HEADER[0], SERIALIZED_BUFFER_HEADER_LENGTH);
;;;267              pUncompressed += SERIALIZED_BUFFER_HEADER_LENGTH;
;;;268    
;;;269              memcpy(pUncompressed, bufferStart, validUsedBytes);
;;;270              pUncompressed += validUsedBytes;
;;;271    
;;;272              memcpy(pUncompressed, &SERIALIZED_BUFFER_FOOTER[0], SERIALIZED_BUFFER_FOOTER_LENGTH);
;;;273            }
;;;274    
;;;275            const s32 compressionResult = compress2(reinterpret_cast<Bytef*>(compressed) + 2*sizeof(s32), &compressedLength, reinterpret_cast<Bytef*>(uncompressed), originalLength, compressionLevel);
;;;276    
;;;277            if(compressionResult != Z_OK) {
;;;278              if(uncompressed)
;;;279                free(uncompressed);
;;;280    
;;;281              if(compressed)
;;;282                free(compressed);
;;;283    
;;;284              AnkiError("Array<Type>::SaveBinary", "Zlib error");
;;;285              return RESULT_FAIL_IO;
;;;286            }
;;;287    
;;;288            reinterpret_cast<s32*>(compressed)[0] = static_cast<s32>(originalLength);
;;;289            reinterpret_cast<s32*>(compressed)[1] = static_cast<s32>(compressedLength);
;;;290    
;;;291            const size_t bytesWrittenForTextHeader = fwrite(tmpTextHeader, 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;292    
;;;293            const size_t bytesWritten = fwrite(compressed, 1, compressedLength + 2*sizeof(s32), fp);
;;;294    
;;;295            if(uncompressed)
;;;296              free(uncompressed);
;;;297    
;;;298            if(compressed)
;;;299              free(compressed);
;;;300    
;;;301            AnkiConditionalErrorAndReturnValue(
;;;302              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;303              bytesWritten == (compressedLength + 2*sizeof(s32)),
;;;304              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;305    
;;;306    #else
;;;307            AnkiError("Array<Type>::SaveBinary", "Saving with compression requires zlib");
;;;308            return RESULT_FAIL;
;;;309    #endif
;;;310          } else {
;;;311            const size_t bytesWrittenForTextHeader = fwrite(&ARRAY_FILE_HEADER[0], 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;312    
;;;313            const size_t bytesWrittenForHeader = fwrite(&SERIALIZED_BUFFER_HEADER[0], 1, SERIALIZED_BUFFER_HEADER_LENGTH, fp);
;;;314    
;;;315            const size_t bytesWritten = fwrite(bufferStart, 1, validUsedBytes, fp);
;;;316    
;;;317            const size_t bytesWrittenForFooter = fwrite(&SERIALIZED_BUFFER_FOOTER[0], 1, SERIALIZED_BUFFER_FOOTER_LENGTH, fp);
;;;318    
;;;319            AnkiConditionalErrorAndReturnValue(
;;;320              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;321              bytesWrittenForHeader == SERIALIZED_BUFFER_HEADER_LENGTH &&
;;;322              bytesWritten == validUsedBytes &&
;;;323              bytesWrittenForFooter == SERIALIZED_BUFFER_FOOTER_LENGTH,
;;;324              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;325          }
;;;326    
;;;327          fclose(fp);
;;;328    
;;;329          return RESULT_OK;
;;;330        } // Array<Type>::SaveBinary(const char * filename, MemoryStack scratch)
;;;331    
;;;332        template<typename Type> const Type* Array<Type>::Pointer(const s32 index0, const s32 index1) const
;;;333        {
;;;334          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;335          AnkiAssert(this->IsValid());
;;;336    
;;;337          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride ) + index1;
;;;338        }
;;;339    
;;;340        template<typename Type> Type* Array<Type>::Pointer(const s32 index0, const s32 index1)
;;;341        {
;;;342          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;343          AnkiAssert(this->IsValid());
;;;344    
;;;345          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride ) + index1;
;;;346        }
;;;347    
;;;348        template<typename Type> inline const Type * Array<Type>::operator[](const s32 index0) const
;;;349        {
;;;350          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;351    
;;;352          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride );
;;;353        }
;;;354    
;;;355        template<typename Type> inline Type * Array<Type>::operator[](const s32 index0)
;;;356        {
;;;357          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;358    
;;;359          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride );
;;;360        }
;;;361    
;;;362        template<typename Type> const Type* Array<Type>::Pointer(const Point<s16> &point) const
;;;363        {
;;;364          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;365        }
;;;366    
;;;367        template<typename Type> Type* Array<Type>::Pointer(const Point<s16> &point)
;;;368        {
;;;369          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;370        }
;;;371    
;;;372        template<typename Type> const Type& Array<Type>::Element(const s32 elementIndex) const
;;;373        {
;;;374          const s32 index1 = elementIndex % size[1];
;;;375          const s32 index0 = (elementIndex - index1) / size[1];
;;;376    
;;;377          return *Pointer(index0, index1);
;;;378        }
;;;379    
;;;380        template<typename Type> Type& Array<Type>::Element(const s32 elementIndex)
;;;381        {
;;;382          const s32 index1 = elementIndex % size[1];
;;;383          const s32 index0 = (elementIndex - index1) / size[1];
;;;384    
;;;385          return *Pointer(index0, index1);
;;;386        }
;;;387    
;;;388        template<typename Type> ArraySlice<Type> Array<Type>::operator() ()
;;;389        {
;;;390          ArraySlice<Type> slice(*this);
;;;391    
;;;392          return slice;
;;;393        }
;;;394    
;;;395        template<typename Type> ArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;396        {
;;;397          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;398    
;;;399          return slice;
;;;400        }
;;;401    
;;;402        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX)
;;;403        {
;;;404          LinearSequence<s32> ySlice = IndexSequence<s32>(minY, 1, maxY, this->size[0]);
;;;405          LinearSequence<s32> xSlice = IndexSequence<s32>(minX, 1, maxX, this->size[1]);
;;;406    
;;;407          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;408    
;;;409          return slice;
;;;410        }
;;;411    
;;;412        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX)
;;;413        {
;;;414          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;415          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;416    
;;;417          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;418    
;;;419          return slice;
;;;420        }
;;;421    
;;;422        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() () const
;;;423        {
;;;424          ConstArraySlice<Type> slice(*this);
;;;425    
;;;426          return slice;
;;;427        }
;;;428    
;;;429        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const
;;;430        {
;;;431          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;432    
;;;433          return slice;
;;;434        }
;;;435    
;;;436        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const
;;;437        {
;;;438          LinearSequence<s32> ySlice = IndexSequence(minY, 1, maxY, this->size[0]);
;;;439          LinearSequence<s32> xSlice = IndexSequence(minX, 1, maxX, this->size[1]);
;;;440    
;;;441          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;442    
;;;443          return slice;
;;;444        }
;;;445    
;;;446        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const
;;;447        {
;;;448          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;449          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;450    
;;;451          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;452    
;;;453          return slice;
;;;454        }
;;;455    
;;;456        template<typename Type> ConstArraySliceExpression<Type> Array<Type>::Transpose() const
;;;457        {
;;;458          ConstArraySliceExpression<Type> expression(this->operator() ());
;;;459          expression.Transpose();
;;;460    
;;;461          return expression;
;;;462        }
;;;463    
;;;464    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;465        template<typename Type> s32 Array<Type>::Set(const cv::Mat_<Type> &in)
;;;466        {
;;;467          const s32 inHeight = in.rows;
;;;468          const s32 inWidth = in.cols;
;;;469    
;;;470          AnkiConditionalErrorAndReturnValue(inHeight != 0,
;;;471            0, "Array<Type>::Set", "input cv::Mat is invalid. If you use the release OpenCV libraries with the debug build, lots of things like file loading don't work.");
;;;472    
;;;473          const bool isColor = in.channels() == 3 || inWidth == this->size[1]*3;
;;;474    
;;;475          if(isColor) {
;;;476            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0],
;;;477              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;478          } else {
;;;479            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;480              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;481          }
;;;482    
;;;483          for(s32 y=0; y<this->size[0]; y++) {
;;;484            const Type * restrict pIn = reinterpret_cast<const Type*>(in.ptr(y,0));
;;;485            Type * restrict pThis = this->Pointer(y,0);
;;;486    
;;;487            // If grayscale, just copy. If color, convert to grayscale
;;;488            if(isColor) {
;;;489              for(s32 x=0; x<this->size[1]; x++) {
;;;490                pThis[x] = (pIn[3*x] + pIn[3*x + 1] + pIn[3*x + 2]) / 3;
;;;491              }
;;;492            } else {
;;;493              memcpy(pThis, pIn, inWidth*sizeof(Type));
;;;494            }
;;;495          }
;;;496    
;;;497          return this->size[0]*this->size[1];
;;;498        }
;;;499    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;500    
;;;501        template<typename Type> void Array<Type>::Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues, const bool fitImageToWindow) const
;;;502        {
;;;503    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;504          AnkiConditionalError(this->IsValid(), "Array<Type>::Show", "Array<Type> is not valid");
;;;505    
;;;506          if(fitImageToWindow) {
;;;507            cv::namedWindow(windowName, CV_WINDOW_NORMAL);
;;;508          } else {
;;;509            cv::namedWindow(windowName, CV_WINDOW_AUTOSIZE);
;;;510          }
;;;511    
;;;512          if(scaleValues) {
;;;513            cv::Mat_<f64> scaledArray;
;;;514    
;;;515            if(ArrayToCvMat(*this, &scaledArray) != RESULT_OK)
;;;516              return;
;;;517    
;;;518            const f64 minValue = Matrix::Min<Type>(*this);
;;;519            const f64 maxValue = Matrix::Max<Type>(*this);
;;;520            const f64 range = maxValue - minValue;
;;;521    
;;;522            scaledArray -= minValue;
;;;523            scaledArray /= range;
;;;524    
;;;525            cv::imshow(windowName, scaledArray);
;;;526          } else {
;;;527            cv::Mat_<Type> arrayCopy;
;;;528    
;;;529            if(ArrayToCvMat(*this, &arrayCopy) != RESULT_OK)
;;;530              return;
;;;531    
;;;532            cv::imshow(windowName, arrayCopy);
;;;533          }
;;;534    
;;;535          if(waitForKeypress) {
;;;536            cv::waitKey();
;;;537          }
;;;538    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;539        }
;;;540    
;;;541        template<typename Type> Result Array<Type>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;542        {
;;;543          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;544            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;545    
;;;546          CoreTechPrint(variableName);
;;;547          CoreTechPrint(":\n");
;;;548          for(s32 y=MAX(0,minY); y<MIN(maxY+1,size[0]); y++) {
;;;549            const Type * const pThisData = this->Pointer(y, 0);
;;;550            for(s32 x=MAX(0,minX); x<MIN(maxX+1,size[1]); x++) {
;;;551              pThisData[x].Print();
;;;552            }
;;;553            CoreTechPrint("\n");
;;;554          }
;;;555          CoreTechPrint("\n");
;;;556    
;;;557          return RESULT_OK;
;;;558        }
;;;559    
;;;560        template<typename Type> Result Array<Type>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;561        {
;;;562          return this->Print(variableName, minY, maxY, minX, maxX);
;;;563        }
;;;564    
;;;565        template<typename Type> bool Array<Type>::IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const
;;;566        {
;;;567          bool isSame = false;
;;;568          if(AreValid(*this, other)) {
;;;569            const s32 nrows = this->get_size(0);
;;;570            const s32 ncols = this->get_size(1);
;;;571    
;;;572            if(other.get_size(0)==nrows && other.get_size(1) == ncols) {
;;;573              isSame = true;
;;;574              for(s32 i=0; i<nrows && isSame; ++i) {
;;;575                const Type * restrict pThis  = this->Pointer(i,0);
;;;576                const Type * restrict pOther = other.Pointer(i,0);
;;;577    
;;;578                for(s32 j=0; j<ncols; ++j) {
;;;579                  if(!NEAR(pThis[j], pOther[j], epsilon)) {
;;;580                    isSame = false;
;;;581                    break;
;;;582                  }
;;;583                } // for j
;;;584              } // for i
;;;585            } // if sizes match
;;;586          } // if both valid
;;;587    
;;;588          return isSame;
;;;589        } // IsNearlyEqualTo()
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
;;;592        {
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
;;;602        }
;;;603    
;;;604        template<typename Type> Result Array<Type>::Resize(const s32 numRows, const s32 numCols, MemoryStack &memory)
;;;605        {
;;;606          AnkiConditionalErrorAndReturnValue(numCols > 0 && numRows > 0,
;;;607            RESULT_FAIL_INVALID_SIZE, "Array<Type>::Resize", "Invalid size");
;;;608    
;;;609          s32 numBytesAllocated = 0;
;;;610    
;;;611          this->data = reinterpret_cast<Type*>( AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, true) );
;;;612    
;;;613          // Don't clear the reallocated memory
;;;614          const bool clearMemory = this->flags.get_zeroAllocatedMemory();
;;;615          this->flags.set_zeroAllocatedMemory(false);
;;;616    
;;;617          const Result result = InitializeBuffer(numRows,
;;;618            numCols,
;;;619            this->data,
;;;620            numBytesAllocated,
;;;621            this->flags);
;;;622    
;;;623          this->flags.set_zeroAllocatedMemory(clearMemory);
;;;624    
;;;625          return result;
;;;626        }
;;;627    
;;;628        template<typename Type> s32 Array<Type>::SetZero()
;;;629        {
;;;630          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;631            0, "Array<Type>::SetZero", "Array<Type> is not valid");
;;;632    
;;;633          const s32 numBytes = this->get_size(0)*this->get_stride();
;;;634    
;;;635          memset(this->Pointer(0,0), 0, numBytes);
;;;636    
;;;637          return numBytes;
;;;638        }
;;;639    
;;;640        template<typename Type> s32 Array<Type>::Set(const Type value)
;;;641        {
;;;642          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;643            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;644    
;;;645          for(s32 y=0; y<size[0]; y++) {
;;;646            Type * restrict pThisData = Pointer(y, 0);
;;;647            for(s32 x=0; x<size[1]; x++) {
;;;648              pThisData[x] = value;
;;;649            }
;;;650          }
;;;651    
;;;652          return size[0]*size[1];
;;;653        }
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
;;;656        {
;;;657          return this->SetCast<Type>(in);
;;;658        }
;;;659    
;;;660        template<typename Type> template<typename InType> s32 Array<Type>::SetCast(const Array<InType> &in)
;;;661        {
;;;662          const s32 inHeight = in.get_size(0);
;;;663          const s32 inWidth = in.get_size(1);
;;;664    
;;;665          AnkiConditionalErrorAndReturnValue(AreValid(*this, in),
;;;666            0, "Array<Type>::Set", "Invalid objects");
;;;667    
;;;668          AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;669            0, "Array<Type>::Set", "Array sizes don't match");
;;;670    
;;;671          for(s32 y=0; y<size[0]; y++) {
;;;672            const InType * restrict pIn = in.Pointer(y, 0);
;;;673            Type * restrict pThisData = Pointer(y, 0);
;;;674    
;;;675            for(s32 x=0; x<size[1]; x++) {
;;;676              pThisData[x] = saturate_cast<Type>(pIn[x]);
;;;677            }
;;;678          }
;;;679    
;;;680          return size[0]*size[1];
;;;681        }
;;;682    
;;;683        template<typename InType> s32 SetCast(const InType * const values, const s32 numValues)
;;;684        {
;;;685          // This is a little tough to write a general case for, so this method should be specialized
;;;686          // for each relevant case
;;;687          AnkiAssert(false);
;;;688    
;;;689          return 0;
;;;690        }
;;;691    
;;;692        template<typename Type> s32 Array<Type>::Set(const Type * const values, const s32 numValues)
;;;693        {
;;;694          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;695            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;696    
;;;697          s32 numValuesSet = 0;
;;;698    
;;;699          for(s32 y=0; y<size[0]; y++) {
;;;700            u32 * restrict pThisData = reinterpret_cast<u32*>(Pointer(y, 0));
;;;701    
;;;702            const s32 numValuesThisRow = MAX(0, MIN(numValues - y*size[1], size[1]));
;;;703    
;;;704            if(numValuesThisRow > 0) {
;;;705              // For small data types, this may be too many bytes, but the stride padding should make
;;;706              // the writing okay (I think)
;;;707              const s32 numWordsToCopy = (sizeof(Type)*numValuesThisRow + 3) / 4;
;;;708    
;;;709              //memcpy(pThisData, values + y*size[1], numValuesThisRow*sizeof(Type));
;;;710              for(s32 x=0; x<numWordsToCopy; x++) {
;;;711                //AnkiAssert(reinterpret_cast<size_t>(values+y*size[1]) % 4 == 0);
;;;712                pThisData[x] = reinterpret_cast<const u32*>(values+y*size[1])[x];
;;;713              }
;;;714              numValuesSet += numValuesThisRow;
;;;715            }
;;;716    
;;;717            if(numValuesThisRow < size[1]) {
;;;718              memset(pThisData+numValuesThisRow*sizeof(Type), 0, (size[1]-numValuesThisRow)*sizeof(Type));
;;;719            }
;;;720          }
;;;721    
;;;722          return numValuesSet;
;;;723        }
;;;724    
;;;725        template<typename Type> Array<Type>& Array<Type>::operator= (const Array<Type> & rightHandSide)
;;;726        {
;;;727          this->size[0] = rightHandSide.size[0];
;;;728          this->size[1] = rightHandSide.size[1];
;;;729    
;;;730          this->stride = rightHandSide.stride;
;;;731          this->flags = rightHandSide.flags;
;;;732          this->data = rightHandSide.data;
;;;733    
;;;734          return *this;
;;;735        }
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
;;;738        {
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
;;;747    
;;;748        template<typename Type> s32 Array<Type>::get_stride() const
;;;749        {
;;;750          return stride;
;;;751        }
;;;752    
;;;753        template<typename Type> s32 Array<Type>::get_numElements() const
;;;754        {
;;;755          if(size[0] > 0 && size[1] > 0) {
;;;756            return size[0] * size[1];
;;;757          } else {
;;;758            return 0;
;;;759          }
;;;760        }
;;;761    
;;;762        template<typename Type> void* Array<Type>::get_buffer()
;;;763        {
;;;764          return data;
;;;765        }
;;;766    
;;;767        template<typename Type> const void* Array<Type>::get_buffer() const
;;;768        {
;;;769          return data;
;;;770        }
;;;771    
;;;772        template<typename Type> Flags::Buffer Array<Type>::get_flags() const
;;;773        {
;;;774          return flags;
;;;775        }
;;;776    
;;;777        template<typename Type> void* Array<Type>::AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate)
;;;778        {
;;;779          AnkiConditionalError(numRows >= 0 && stride > 0,
;;;780            "Array<Type>::AllocateBufferFromMemoryStack", "Invalid size");
;;;781    
;;;782          const s32 numRowsCapped = MAX(numRows, 1);
;;;783    
;;;784          this->stride = stride;
;;;785    
;;;786          const s32 numBytesRequested = numRowsCapped * this->stride;
;;;787    
;;;788          if(reAllocate) {
;;;789            return memory.Reallocate(this->data, numBytesRequested, numBytesAllocated);
;;;790          } else {
;;;791            return memory.Allocate(numBytesRequested, flags.get_zeroAllocatedMemory(), numBytesAllocated);
;;;792          }
;;;793        }
;;;794    
;;;795        template<typename Type> Result Array<Type>::InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags)
;;;796        {
;;;797          if(!rawData) {
;;;798            AnkiError("Anki.Array2d.initialize", "input data buffer is NULL");
;;;799            InvalidateArray();
;;;800            return RESULT_FAIL_UNINITIALIZED_MEMORY;
;;;801          }
;;;802    
;;;803          AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0 && dataLength >= MEMORY_ALIGNMENT,
;;;804            RESULT_FAIL_INVALID_SIZE, "Array<Type>::InitializeBuffer", "Negative dimension");
;;;805    
;;;806          AnkiConditionalErrorAndReturnValue(!flags.get_useBoundaryFillPatterns(),
;;;807            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::InitializeBuffer", "Fill patterns not supported for Array");
;;;808    
;;;809          this->flags = flags;
;;;810          this->size[0] = numRows;
;;;811          this->size[1] = numCols;
;;;812    
;;;813          // Initialize an empty array.
;;;814    
;;;815          this->data = reinterpret_cast<Type*>(rawData);
;;;816    
;;;817          const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData), MEMORY_ALIGNMENT) - reinterpret_cast<size_t>(rawData));
;;;818          const s32 requiredBytes = ComputeRequiredStride(numCols,flags)*numRows + extraAlignmentBytes;
;;;819    
;;;820          if(requiredBytes > dataLength) {
;;;821            AnkiError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
;;;822            InvalidateArray();
;;;823            return RESULT_FAIL_OUT_OF_MEMORY;
;;;824          }
;;;825    
;;;826          this->data = reinterpret_cast<Type*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
;;;827    
;;;828          //#if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;829          //      this->UpdateCvMatMirror(*this);
;;;830          //#endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;831    
;;;832          return RESULT_OK;
;;;833        } // Array<Type>::InitializeBuffer()
;;;834    
;;;835        // Set all the buffers and sizes to -1, to signal an invalid array
;;;836        template<typename Type> void Array<Type>::InvalidateArray()
;;;837        {
;;;838          this->size[0] = -1;
;;;839          this->size[1] = -1;
;;;840          this->stride = -1;
;;;841          this->data = NULL;
;;;842        } // void Array<Type>::InvalidateArray()
;;;843    
;;;844        template<typename Type> Result Array<Type>::PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX)  const
;;;845        {
;;;846          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;847            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;848    
;;;849          const s32 realMinX = MAX(0,minX);
;;;850          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;851          const s32 realMinY = MAX(0,minY);
;;;852          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;853    
;;;854          CoreTechPrint("%s type(int:%d,signed:%d,float:%d,sizeof:%d):\n", variableName, Flags::TypeCharacteristics<Type>::isInteger, Flags::TypeCharacteristics<Type>::isSigned, Flags::TypeCharacteristics<Type>::isFloat, sizeof(Type));
;;;855    
;;;856          for(s32 y=realMinY; y<realMaxY; y++) {
;;;857            const Type * const pThisData = this->Pointer(y, 0);
;;;858            for(s32 x=realMinX; x<realMaxX; x++) {
;;;859              if(Flags::TypeCharacteristics<Type>::isBasicType) {
;;;860                if(Flags::TypeCharacteristics<Type>::isInteger) {
;;;861                  CoreTechPrint("%d ", static_cast<s32>(pThisData[x]));
;;;862                } else {
;;;863                  if(version==1) {
;;;864                    CoreTechPrint("%f ", (float)pThisData[x]);
;;;865                  } else {
;;;866                    CoreTechPrint("%e ", (float)pThisData[x]);
;;;867                  }
;;;868                }
;;;869              } else {
;;;870                CoreTechPrint("! ");
;;;871              }
;;;872            }
;;;873            CoreTechPrint("\n");
;;;874          }
;;;875          CoreTechPrint("\n");
;;;876    
;;;877          return RESULT_OK;
;;;878        }
;;;879    
;;;880        template<typename Type> Result Array<Type>::PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;881        {
;;;882          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;883            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::PrintString", "Array<Type> is not valid");
;;;884    
;;;885          const s32 realMinX = MAX(0,minX);
;;;886          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;887          const s32 realMinY = MAX(0,minY);
;;;888          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;889    
;;;890          CoreTechPrint("%s:\n", variableName);
;;;891    
;;;892          for(s32 y=realMinY; y<realMaxY; y++) {
;;;893            const char * const * pThisData = this->Pointer(y, 0);
;;;894            for(s32 x=realMinX; x<realMaxX; x++) {
;;;895              const char * curString = pThisData[x];
;;;896              if(!curString) {
;;;897                CoreTechPrint("NULL, ");
;;;898              } else {
;;;899                CoreTechPrint("\"%s\", ", curString);
;;;900              }
;;;901            }
;;;902            CoreTechPrint("\n");
;;;903          }
;;;904          CoreTechPrint("\n");
;;;905    
;;;906          return RESULT_OK;
;;;907        }
;;;908    
;;;909        // #pragma mark --- FixedPointArray Definitions ---
;;;910    
;;;911        template<typename Type> FixedPointArray<Type>::FixedPointArray()
;;;912          : Array<Type>(), numFractionalBits(-1)
;;;913        {
;;;914        }
;;;915    
;;;916        template<typename Type> FixedPointArray<Type>::FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags)
;;;917          : Array<Type>(numRows, numCols, data, dataLength, flags), numFractionalBits(numFractionalBits)
;;;918        {
;;;919          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= (sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;920        }
;;;921    
;;;922        template<typename Type> FixedPointArray<Type>::FixedPointArray(s32 numRows, s32 numCols, s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags)
;;;923          : Array<Type>(numRows, numCols, memory, flags), numFractionalBits(numFractionalBits)
;;;924        {
;;;925          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= static_cast<s32>(sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;926        }
;;;927    
;;;928        template<typename Type> s32 FixedPointArray<Type>::get_numFractionalBits() const
;;;929        {
;;;930          return numFractionalBits;
;;;931        }
;;;932    
;;;933    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;934        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;935        {
;;;936          AnkiConditionalErrorAndReturnValue(in.IsValid() && out,
;;;937            RESULT_FAIL, "ArrayToCvMat", "This Array is invalid");
;;;938    
;;;939          out->refcount = NULL;
;;;940    
;;;941          // These two should be set, because if the Mat_ constructor was not called, these will not be initialized
;;;942          out->step.p = out->step.buf;
;;;943          out->size = &out->rows;
;;;944    
;;;945          *out = cv::Mat_<Type>(in.get_size(0), in.get_size(1), const_cast<Type*>(in.Pointer(0,0)), static_cast<size_t>(in.get_stride()));
;;;946    
;;;947          return RESULT_OK;
;;;948        } // template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;949    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;950    
;;;951        // #pragma mark --- Array Specializations ---
;;;952    
;;;953        template<> Result Array<bool>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;954        template<> Result Array<u8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;955        template<> Result Array<s8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;956        template<> Result Array<u16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;957        template<> Result Array<s16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;958        template<> Result Array<u32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;959        template<> Result Array<s32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;960        template<> Result Array<u64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;961        template<> Result Array<s64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;962        template<> Result Array<f32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;963        template<> Result Array<f64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;964        template<> Result Array<const char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;965        template<> Result Array<char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;966    
;;;967        template<> Result Array<f32>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;968        template<> Result Array<f64>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;969    
;;;970        template<> template<> s32 Array<u8>::SetCast(const s32 * const values, const s32 numValues);
;;;971        template<> template<> s32 Array<s16>::SetCast(const s32 * const values, const s32 numValues);
;;;972      } // namespace Embedded
;;;973    } //namespace Anki
;;;974    
;;;975    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;17     #include "anki/common/robot/arraySlices.h"
;;;1      /**
;;;2      File: arraySlices.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of arraySlices_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;14     
;;;15     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> ConstArraySlice<Type>::ConstArraySlice()
;;;23           : ySlice(LinearSequence<s32>()), xSlice(LinearSequence<s32>()), array(Array<Type>()), constArrayData(NULL)
;;;24         {
;;;25         }
;;;26     
;;;27         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array)
;;;28           : ySlice(LinearSequence<s32>(0,array.get_size(0)-1)), xSlice(LinearSequence<s32>(0,array.get_size(1)-1)), array(array)
;;;29         {
;;;30           if(array.get_numElements() == 0) {
;;;31             this->constArrayData = NULL;
;;;32           } else {
;;;33             this->constArrayData = array.Pointer(0,0);
;;;34           }
;;;35         }
;;;36     
;;;37         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;38           : ySlice(ySlice), xSlice(xSlice), array(array)
;;;39         {
;;;40           if(array.get_numElements() == 0) {
;;;41             this->constArrayData = NULL;
;;;42           } else {
;;;43             this->constArrayData = array.Pointer(0,0);
;;;44           }
;;;45         }
;;;46     
;;;47         template<typename Type> ConstArraySliceExpression<Type> ConstArraySlice<Type>::Transpose() const
;;;48         {
;;;49           ConstArraySliceExpression<Type> expression(*this, true);
;;;50     
;;;51           return expression;
;;;52         }
;;;53     
;;;54         template<typename Type> bool ConstArraySlice<Type>::IsValid() const
;;;55         {
;;;56           return this->array.IsValid();
;;;57         }
;;;58     
;;;59         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_ySlice() const
;;;60         {
;;;61           return ySlice;
;;;62         }
;;;63     
;;;64         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_xSlice() const
;;;65         {
;;;66           return xSlice;
;;;67         }
;;;68     
;;;69         template<typename Type> const Array<Type>& ConstArraySlice<Type>::get_array() const
;;;70         {
;;;71           return this->array;
;;;72         }
;;;73     
;;;74         template<typename Type> ArraySlice<Type>::ArraySlice()
;;;75           : ConstArraySlice<Type>(), arrayData(NULL)
;;;76         {
;;;77         }
;;;78     
;;;79         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array)
;;;80           : ConstArraySlice<Type>(array)
;;;81         {
;;;82           if(array.get_numElements() == 0) {
;;;83             this->arrayData = NULL;
;;;84           } else {
;;;85             this->arrayData = array.Pointer(0,0);
;;;86           }
;;;87         }
;;;88     
;;;89         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;90           : ConstArraySlice<Type>(array, ySlice, xSlice)
;;;91         {
;;;92           if(array.get_numElements() == 0) {
;;;93             this->arrayData = NULL;
;;;94           } else {
;;;95             this->arrayData = array.Pointer(0,0);
;;;96           }
;;;97         }
;;;98     
;;;99         template<typename Type> s32 ArraySlice<Type>::Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;100        {
;;;101          return this->SetCast<Type>(input, automaticTranspose);
;;;102        }
;;;103    
;;;104        template<typename Type> s32 ArraySlice<Type>::Set(const LinearSequence<Type> &input)
;;;105        {
;;;106          const Result result = input.Evaluate(*this);
;;;107          return (result==RESULT_OK) ? input.get_size() : 0;
;;;108        }
;;;109    
;;;110        template<typename Type> s32 ArraySlice<Type>::Set(const Type value)
;;;111        {
;;;112          Array<Type> &array = this->get_array();
;;;113    
;;;114          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;115            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;116    
;;;117          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;118    
;;;119          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;120            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;121    
;;;122          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;123            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;124            Type * restrict pMat = array.Pointer(y, 0);
;;;125    
;;;126            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;127              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;128              pMat[x] = value;
;;;129            }
;;;130          }
;;;131    
;;;132          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;133        }
;;;134    
;;;135        template<typename Type> s32 ArraySlice<Type>::Set(const Type * const values, const s32 numValues)
;;;136        {
;;;137          Array<Type> &array = this->get_array();
;;;138    
;;;139          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;140            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;141    
;;;142          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;143    
;;;144          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;145            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;146    
;;;147          AnkiConditionalErrorAndReturnValue(limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize == numValues,
;;;148            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;149    
;;;150          s32 ci = 0;
;;;151          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;152            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;153            Type * restrict pMat = array.Pointer(y, 0);
;;;154    
;;;155            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;156              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;157              pMat[x] = values[ci];
;;;158              ci++;
;;;159            }
;;;160          }
;;;161    
;;;162          AnkiAssert(ci == limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize);
;;;163    
;;;164          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;165        }
;;;166    
;;;167        template<typename Type> template<typename InType> s32 ArraySlice<Type>::SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;168        {
;;;169          AnkiConditionalErrorAndReturnValue(AreValid(*this, input),
;;;170            0, "ArraySlice<Type>::Set", "Invalid objects");
;;;171    
;;;172          AnkiConditionalErrorAndReturnValue(this->get_array().get_buffer() != input.get_array().get_buffer(),
;;;173            0, "ArraySlice<Type>::Set", "Arrays must be in different memory locations");
;;;174    
;;;175          ArraySliceLimits_in1_out1<s32> limits(
;;;176            input.get_ySlice(), input.get_xSlice(), input.get_isTransposed(),
;;;177            this->get_ySlice(), this->get_xSlice());
;;;178    
;;;179          if(!limits.isValid) {
;;;180            if(automaticTranspose) {
;;;181              // If we're allowed to transpose, give it another shot
;;;182              limits = ArraySliceLimits_in1_out1<s32> (input.get_ySlice(), input.get_xSlice(), !input.get_isTransposed(), this->get_ySlice(), this->get_xSlice());
;;;183    
;;;184              if(!limits.isValid) {
;;;185                AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;186                return 0;
;;;187              }
;;;188            } else {
;;;189              AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;190              return 0;
;;;191            }
;;;192          }
;;;193    
;;;194          Array<Type> &out1Array = this->get_array();
;;;195          const Array<InType> &in1Array = input.get_array();
;;;196    
;;;197          if(limits.isSimpleIteration) {
;;;198            // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;199    
;;;200            for(s32 y=0; y<limits.ySize; y++) {
;;;201              const InType * restrict pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;202              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;203    
;;;204              limits.OuterIncrementTop();
;;;205    
;;;206              for(s32 x=0; x<limits.xSize; x++) {
;;;207                pOut1[limits.out1X] = static_cast<Type>( pIn1[limits.in1X] );
;;;208    
;;;209                limits.out1X += limits.out1_xInnerIncrement;
;;;210                limits.in1X += limits.in1_xInnerIncrement;
;;;211              }
;;;212    
;;;213              limits.OuterIncrementBottom();
;;;214            }
;;;215          } else {
;;;216            for(s32 y=0; y<limits.ySize; y++) {
;;;217              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;218    
;;;219              limits.OuterIncrementTop();
;;;220    
;;;221              for(s32 x=0; x<limits.xSize; x++) {
;;;222                const InType pIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;223    
;;;224                pOut1[limits.out1X] = static_cast<Type>( pIn1 );
;;;225    
;;;226                limits.out1X += limits.out1_xInnerIncrement;
;;;227                limits.in1Y += limits.in1_yInnerIncrement;
;;;228              }
;;;229    
;;;230              limits.OuterIncrementBottom();
;;;231            }
;;;232          }
;;;233    
;;;234          return limits.ySize*limits.xSize;
;;;235        }
;;;236    
;;;237        template<typename Type> Array<Type>& ArraySlice<Type>::get_array()
;;;238        {
;;;239          return this->array;
;;;240        }
;;;241    
;;;242        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression()
;;;243          : ConstArraySlice<Type>(), isTransposed(false)
;;;244        {
;;;245        }
;;;246    
;;;247        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const Array<Type> input, bool isTransposed)
;;;248          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;249        {
;;;250        }
;;;251    
;;;252        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed)
;;;253          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;254        {
;;;255        }
;;;256    
;;;257        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed)
;;;258          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;259        {
;;;260        }
;;;261    
;;;262        template<typename Type> ConstArraySliceExpression<Type> ConstArraySliceExpression<Type>::Transpose() const
;;;263        {
;;;264          ConstArraySliceExpression<Type> expression(*this, !this->get_isTransposed());
;;;265    
;;;266          return expression;
;;;267        }
;;;268    
;;;269        template<typename Type> bool ConstArraySliceExpression<Type>::get_isTransposed() const
;;;270        {
;;;271          return isTransposed;
;;;272        }
;;;273    
;;;274        template<typename Type> ArraySliceSimpleLimits<Type>::ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;275          : xStart(in1_xSlice.get_start()), xIncrement(in1_xSlice.get_increment()), xSize(in1_xSlice.get_size()),
;;;276          yStart(in1_ySlice.get_start()), yIncrement(in1_ySlice.get_increment()), ySize(in1_ySlice.get_size())
;;;277        {
;;;278        }
;;;279    
;;;280        template<typename Type> ArraySliceLimits_in1_out0<Type>::ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;281          : isValid(true), rawIn1Limits(in1_ySlice, in1_xSlice)
;;;282        {
;;;283        } // ArraySliceLimits_in1_out0
;;;284    
;;;285        template<typename Type> ArraySliceLimits_in1_out1<Type>::ArraySliceLimits_in1_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;286          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;287          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;288          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed)
;;;289        {
;;;290          isValid = false;
;;;291    
;;;292          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;293    
;;;294          if(!in1_isTransposed) {
;;;295            if(rawOut1Limits.xSize == rawIn1Limits.xSize && rawOut1Limits.ySize == rawIn1Limits.ySize) {
;;;296              isValid = true;
;;;297              isSimpleIteration = true;
;;;298    
;;;299              this->in1Y = this->rawIn1Limits.yStart;
;;;300              this->out1Y = this->rawOut1Limits.yStart;
;;;301    
;;;302              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;303              this->in1_yInnerIncrement = 0;
;;;304            }
;;;305          } else { // if(!in1_isTransposed)
;;;306            if(rawOut1Limits.xSize == rawIn1Limits.ySize && rawOut1Limits.ySize == rawIn1Limits.xSize) {
;;;307              isValid = true;
;;;308              isSimpleIteration = false;
;;;309    
;;;310              this->in1X = this->rawIn1Limits.xStart;
;;;311              this->out1Y = this->rawOut1Limits.yStart;
;;;312    
;;;313              this->in1_xInnerIncrement = 0;
;;;314              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;315            }
;;;316          } // if(!in1_isTransposed) ... else
;;;317    
;;;318          if(!isValid) {
;;;319            AnkiError("ArraySliceLimits_in1_out1", "Subscripted assignment dimension mismatch");
;;;320            return;
;;;321          }
;;;322        } // ArraySliceLimits_in1_out1
;;;323    
;;;324        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;325        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;326        {
;;;327          if(isSimpleIteration) {
;;;328            this->in1X = this->rawIn1Limits.xStart;
;;;329            this->out1X = this->rawOut1Limits.xStart;
;;;330          } else { // if(isSimpleIteration)
;;;331            this->in1Y = this->rawIn1Limits.yStart;
;;;332            this->out1X = this->rawOut1Limits.xStart;
;;;333          } // if(isSimpleIteration) ... else
;;;334        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;335    
;;;336        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;337        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;338        {
;;;339          if(isSimpleIteration) {
;;;340            this->in1Y += this->rawIn1Limits.yIncrement;
;;;341            this->out1Y += this->rawOut1Limits.yIncrement;
;;;342          } else { // if(isSimpleIteration)
;;;343            this->in1X += this->rawIn1Limits.xIncrement;
;;;344            this->out1Y += this->rawOut1Limits.yIncrement;
;;;345          } // if(isSimpleIteration) ... else
;;;346        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;347    
;;;348        template<typename Type> ArraySliceLimits_in2_out1<Type>::ArraySliceLimits_in2_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;349          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;350          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;351          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed),
;;;352          rawIn2Limits(in2_ySlice, in2_xSlice), in2_isTransposed(in2_isTransposed)
;;;353        {
;;;354          isValid = false;
;;;355    
;;;356          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;357          this->in1_yInnerIncrement = 0;
;;;358          this->in1_xInnerIncrement = 0;
;;;359          this->in2_yInnerIncrement = 0;
;;;360          this->in2_xInnerIncrement = 0;
;;;361    
;;;362          if(!in1_isTransposed && !in2_isTransposed) {
;;;363            const bool sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;364    
;;;365            if(sizesMatch) {
;;;366              isValid = true;
;;;367              isSimpleIteration = true;
;;;368    
;;;369              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;370              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;371    
;;;372              this->in1Y = this->rawIn1Limits.yStart;
;;;373              this->in2Y = this->rawIn2Limits.yStart;
;;;374              this->out1Y = this->rawOut1Limits.yStart;
;;;375            }
;;;376          } else { // if(!in1_isTransposed)
;;;377            isSimpleIteration = false;
;;;378    
;;;379            bool sizesMatch = false;
;;;380    
;;;381            if(in1_isTransposed && in2_isTransposed) {
;;;382              sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;383              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;384              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;385            } else if(in1_isTransposed) {
;;;386              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;387              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;388              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;389            } else if(in2_isTransposed) {
;;;390              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;391              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;392              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;393            } else {
;;;394              AnkiAssert(false); // should not be possible
;;;395            }
;;;396    
;;;397            if(!sizesMatch) {
;;;398              AnkiError("ArraySliceLimits_in2_out1", "Subscripted assignment dimension mismatch");
;;;399              return;
;;;400            }
;;;401    
;;;402            isValid = true;
;;;403    
;;;404            this->in1X = this->rawIn1Limits.xStart;
;;;405            this->in1Y = this->rawIn1Limits.yStart;
;;;406            this->in2X = this->rawIn2Limits.xStart;
;;;407            this->in2Y = this->rawIn2Limits.yStart;
;;;408    
;;;409            this->out1Y = this->rawOut1Limits.yStart;
;;;410          } // if(!in1_isTransposed) ... else
;;;411        } // ArraySliceLimits_in1_out1
;;;412    
;;;413        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;414        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;415        {
;;;416          if(isSimpleIteration) {
;;;417            this->out1X = this->rawOut1Limits.xStart;
;;;418            this->in1X = this->rawIn1Limits.xStart;
;;;419            this->in2X = this->rawIn2Limits.xStart;
;;;420          } else { // if(isSimpleIteration)
;;;421            this->out1X = this->rawOut1Limits.xStart;
;;;422    
;;;423            if(in1_isTransposed) {
;;;424              this->in1Y = this->rawIn1Limits.yStart;
;;;425            } else {
;;;426              this->in1X = this->rawIn1Limits.xStart;
;;;427            }
;;;428    
;;;429            if(in2_isTransposed) {
;;;430              this->in2Y = this->rawIn2Limits.yStart;
;;;431            } else {
;;;432              this->in2X = this->rawIn2Limits.xStart;
;;;433            }
;;;434          } // if(isSimpleIteration) ... else
;;;435        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;436    
;;;437        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;438        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;439        {
;;;440          if(isSimpleIteration) {
;;;441            this->in1Y += this->rawIn1Limits.yIncrement;
;;;442            this->in2Y += this->rawIn2Limits.yIncrement;
;;;443            this->out1Y += this->rawOut1Limits.yIncrement;
;;;444          } else { // if(isSimpleIteration)
;;;445            this->out1Y += this->rawOut1Limits.yIncrement;
;;;446    
;;;447            if(in1_isTransposed) {
;;;448              this->in1X += this->rawIn1Limits.xIncrement;
;;;449            } else {
;;;450              this->in1Y += this->rawIn1Limits.yIncrement;
;;;451            }
;;;452    
;;;453            if(in2_isTransposed) {
;;;454              this->in2X += this->rawIn2Limits.xIncrement;
;;;455            } else {
;;;456              this->in2Y += this->rawIn2Limits.yIncrement;
;;;457            }
;;;458          } // if(isSimpleIteration) ... else
;;;459        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;460      } // namespace Embedded
;;;461    } // namespace Anki
;;;462    
;;;463    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;19     #include "anki/common/robot/benchmarking.h"
;;;1      /**
;;;2      File: benchmarkins.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Low-overhead benchmarking, based on a list of start and end events.
;;;7      
;;;8      The basic use of this benchmarking utility is as follows:
;;;9      1. InitBenchmarking()
;;;10     2. At the beginning of the section you want to benchmark, put BeginBenchmark("event type");
;;;11     3. At the end of the section you want to benchmark, put EndBenchmark("event type");
;;;12     4. When you're done running the program, call PrintBenchmarkResults() to print the results
;;;13     
;;;14     Copyright Anki, Inc. 2013
;;;15     For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;16     **/
;;;17     
;;;18     #ifndef _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;19     #define _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     
;;;21     #include "anki/common/robot/config.h"
;;;1      /**
;;;22     #include "anki/common/robot/fixedLengthList_declarations.h"
;;;1      /**
;;;2      File: fixedLengthList_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      A FixedLengthList is like a std::vector, but has a fixed maximum size. This maximum is allocated at contruction.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         class SerializedBuffer;
;;;24     
;;;25         // A FixedLengthList is a list with a fixed maximum size, which is allocated at construction.
;;;26         template<typename Type> class FixedLengthList : public ArraySlice<Type>
;;;27         {
;;;28         public:
;;;29           FixedLengthList();
;;;30     
;;;31           // Constructor for a FixedLengthList, pointing to user-allocated data.
;;;32           FixedLengthList(s32 maximumSize, void * data, s32 dataLength, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;33     
;;;34           // Constructor for a FixedLengthList, pointing to user-allocated MemoryStack
;;;35           FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;36     
;;;37           bool IsValid() const;
;;;38     
;;;39           // Resize will use MemoryStack::Reallocate() to change the FixedLengthList's size. It only works if this
;;;40           // FixedLengthList was the last thing allocated. The reallocated memory will not be cleared
;;;41           //
;;;42           // WARNING:
;;;43           // This will not update any references to the memory, you must update all references manually.
;;;44           Result Resize(s32 maximumSize, MemoryStack &memory);
;;;45     
;;;46           Result PushBack(const Type &value);
;;;47     
;;;48           // Will act as a normal pop, except when the list is empty. Then subsequent
;;;49           // calls will keep returning the first value in the list.
;;;50           Type PopBack();
;;;51     
;;;52           // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
;;;53           inline void Clear();
;;;54     
;;;55           // Does this ever need to be declared explicitly?
;;;56           //FixedLengthList& operator= (const FixedLengthList & rightHandSide);
;;;57     
;;;58           // Pointer to the data, at a given location
;;;59           inline Type* Pointer(const s32 index);
;;;60           inline const Type* Pointer(const s32 index) const;
;;;61     
;;;62           // Use this operator for normal C-style vector indexing. For example, "list[5] = 6;" will set
;;;63           // the element in the fifth row and first column to 6. This is the same as "*list.Pointer(5) =
;;;64           // 6;"
;;;65           //
;;;66           // NOTE:
;;;67           // Using this in a inner loop may be less efficient than using an explicit pointer with a
;;;68           // restrict keyword (Though the runtime cost isn't nearly as large as the [] operator for the
;;;69           // Array class). For speeding up performance-critical inner loops, use something like: "Type *
;;;70           // restrict pList = list.Pointer(0);" outside the inner loop, then index
;;;71           // pList in the inner loop.
;;;72           inline const Type& operator[](const s32 index) const;
;;;73           inline Type& operator[](const s32 index);
;;;74     
;;;75           // Print out the contents of this FixedLengthList
;;;76           Result Print(const char * const variableName = "FixedLengthList", const s32 minIndex = 0, const s32 maxIndex = 0x7FFFFFE) const;
;;;77     
;;;78           // Set every element in the Array to zero, including the stride padding, but not including the optional fill patterns (if they exist)
;;;79           // Returns the number of bytes set to zero
;;;80           inline s32 SetZero();
;;;81     
;;;82           // Read in the input, then cast it to this object's type
;;;83           //
;;;84           // WARNING:
;;;85           // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;86           template<typename InType> s32 SetCast(const FixedLengthList<InType> &input, bool automaticTranspose=true);
;;;87           //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;88     
;;;89           // The maximum size is set at object construction
;;;90           inline s32 get_maximumSize() const;
;;;91     
;;;92           // The current size changes as the FixedLengthList is used
;;;93           inline s32 get_size() const;
;;;94     
;;;95           // Attempt to set the size to newSize. Returns the value that was actually set.
;;;96           s32 set_size(s32 newSize);
;;;97     
;;;98         protected:
;;;99           // TODO: make less hacky
;;;100          friend class SerializedBuffer;
;;;101        }; // class FixedLengthList
;;;102      } // namespace Embedded
;;;103    } //namespace Anki
;;;104    
;;;105    #endif // _ANKICORETECHEMBEDDED_COMMON_FIXEDLENGTHLIST_DECLARATIONS_H_
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         const s32 MAX_BENCHMARK_EVENTS = 16000;
;;;29     
;;;30         typedef struct BenchmarkElement
;;;31         {
;;;32           // All times in microseconds, on all platforms
;;;33     
;;;34           static const s32 NAME_LENGTH = 64;
;;;35     
;;;36           // Inclusive includes all the time for all sub-benchmarks
;;;37           u32 inclusive_mean;
;;;38           u32 inclusive_min;
;;;39           u32 inclusive_max;
;;;40           u32 inclusive_total;
;;;41     
;;;42           // Exclusive does not include sub-benchmarks
;;;43           u32 exclusive_mean;
;;;44           u32 exclusive_min;
;;;45           u32 exclusive_max;
;;;46           u32 exclusive_total;
;;;47     
;;;48           // How many times was this element's name benchmarked?
;;;49           u32 numEvents;
;;;50     
;;;51           char name[BenchmarkElement::NAME_LENGTH];
;;;52     
;;;53           BenchmarkElement(const char * name);
;;;54     
;;;55           // Print with CoreTechPrint()
;;;56           void Print(const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;57     
;;;58           // Like snprintf(). Returns the number of characters printed, not including the final null byte.
;;;59           s32 Snprint(char * buffer, const s32 bufferLength, const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;60         } BenchmarkElement;
;;;61     
;;;62         typedef struct ShowBenchmarkParameters
;;;63         {
;;;64           char name[BenchmarkElement::NAME_LENGTH];
;;;65           bool showExclusiveTime;
;;;66           u8 red, green, blue;
;;;67     
;;;68           ShowBenchmarkParameters(
;;;69             const char * name,
;;;70             const bool showExclusiveTime,
;;;71             const u8 *color); //< Color is {R,G,B}
;;;72         } ShowBenchmarkParameters;
;;;73     
;;;74         // Call this before doing any benchmarking, to clear the buffer of benchmarkEvents.
;;;75         // Can be called multiple times.
;;;76         void InitBenchmarking();
;;;77     
;;;78         // Use these functions to add a new event to the list. These functions are very fast.
;;;79         //
;;;80         // WARNING: name must be in globally available memory
;;;81         //
;;;82         // WARNING: the character string must be less than BenchmarkElement::NAME_LENGTH bytes
;;;83         //
;;;84         // WARNING: Using the same name for different benchmark events
;;;85         //
;;;86         // WARNING: nesting BeginBenchmark() and EndBenchmark() events that have the same name won't work.
;;;87         // This is okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("b"); EndBenchmark("a");
;;;88         // This is not okay: BeginBenchmark("a"); BeginBenchmark("a"); EndBenchmark("a"); EndBenchmark("a");
;;;89         // This is not okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("a"); EndBenchmark("b");
;;;90         void BeginBenchmark(const char *name);
;;;91         void EndBenchmark(const char *name);
;;;92     
;;;93         // Compile all the benchmark events that were recorded
;;;94         FixedLengthList<BenchmarkElement> ComputeBenchmarkResults(MemoryStack &memory);
;;;95     
;;;96         // CoreTechPrint() the benchmark results
;;;97         // WARNING: This doesn't work well with multi-threaded programs
;;;98         Result PrintBenchmarkResults(const FixedLengthList<BenchmarkElement> &results, const bool verbose=true, const bool microseconds=true);
;;;99     
;;;100        // Compile and print out all the benchmark events that were recorded
;;;101        Result ComputeAndPrintBenchmarkResults(const bool verbose, const bool microseconds, MemoryStack scratch);
;;;102    
;;;103        // Use OpenCV to display a running benchmark
;;;104        // Requires a "TotalTime" benchmark event
;;;105        // namesToDisplay can be 11 or less names
;;;106        Result ShowBenchmarkResults(
;;;107          const FixedLengthList<BenchmarkElement> &results,
;;;108          const FixedLengthList<ShowBenchmarkParameters> &namesToDisplay,
;;;109          const f32 pixelsPerMillisecond,
;;;110          const s32 imageHeight,
;;;111          const s32 imageWidth);
;;;112    
;;;113        s32 GetNameIndex(const char * name, const FixedLengthList<BenchmarkElement> &outputResults);
;;;114      } // namespace Embedded
;;;115    } // namespace Anki
;;;116    
;;;117    #endif // _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     #include "anki/common/robot/comparisons.h"
;;;1      /**
;;;2      File: comparisons.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of comparisons_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;14     
;;;15     #include "anki/common/robot/comparisons_declarations.h"
;;;1      /**
;;;2      File: comparisons_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various elementwise tests, to ensure that the data of two Arrays is equal.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Declarations ---
;;;23         // Check every element of this array against the input array. If the arrays are different
;;;24         // sizes, uninitialized, or if any element is more different than the threshold, then
;;;25         // return false.
;;;26         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold = static_cast<Type>(0.0001));
;;;27     
;;;28         // Check every element of this array against the input array. If the arrays are different
;;;29         // sizes or uninitialized, return false. The percentThreshold is between 0.0 and 1.0. To
;;;30         // return false, an element must fail both thresholds. The percent threshold fails if an
;;;31         // element is more than a percentage different than its matching element (calulated from the
;;;32         // maximum of the two).
;;;33         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold = 0.01, const double absoluteThreshold = 0.0001);
;;;34     
;;;35         // If any of the input objects are not valid, then return false
;;;36         // NOTE: the objects must have an IsValid() method
;;;37         template<typename Type1> bool AreValid(const Type1 &object1);
;;;38         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2);
;;;39         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;40         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;41         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;42         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;43         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;44         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;45         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;46     
;;;47         // If the objects have different sizes or are uninitialized, then return false.
;;;48         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;49         template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2);
;;;50         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;51         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;52         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;53         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;54         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;55         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;56         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;57     
;;;58         // Check sizes against an input height and width
;;;59         template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1);
;;;60         template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2);
;;;61         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;62         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;63         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;64         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;65         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;66         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;67         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;68     
;;;69         // If the Arrays are aliased (pointing to the same location in memory) or uninitialized, then return false
;;;70         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;71         template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2);
;;;72         template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;73         template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;74         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;75         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;76         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;77         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;78         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;79       } // namespace Embedded
;;;80     } // namespace Anki
;;;81     
;;;82     #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark
;;;23     
;;;24         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold)
;;;25         {
;;;26           if(!AreEqualSize(array1, array2))
;;;27             return false;
;;;28     
;;;29           const s32 height = array1.get_size(0);
;;;30           const s32 width = array1.get_size(1);
;;;31     
;;;32           for(s32 y=0; y<height; y++) {
;;;33             const Type * const pArray1 = array1.Pointer(y, 0);
;;;34             const Type * const pArray2 = array2.Pointer(y, 0);
;;;35             for(s32 x=0; x<width; x++) {
;;;36               if(pArray1[x] > pArray2[x]) {
;;;37                 if((pArray1[x] - pArray2[x]) > threshold)
;;;38                   return false;
;;;39               } else {
;;;40                 if((pArray2[x] - pArray1[x]) > threshold)
;;;41                   return false;
;;;42               }
;;;43             }
;;;44           }
;;;45     
;;;46           return true;
;;;47         }
;;;48     
;;;49         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold, const double absoluteThreshold)
;;;50         {
;;;51           if(!AreEqualSize(array1, array2))
;;;52             return false;
;;;53     
;;;54           const s32 height = array1.get_size(0);
;;;55           const s32 width = array1.get_size(1);
;;;56     
;;;57           for(s32 y=0; y<height; y++) {
;;;58             const Type * const pArray1 = array1.Pointer(y, 0);
;;;59             const Type * const pArray2 = array2.Pointer(y, 0);
;;;60             for(s32 x=0; x<width; x++) {
;;;61               const double value1 = static_cast<double>(pArray1[x]);
;;;62               const double value2 = static_cast<double>(pArray2[x]);
;;;63               const double percentThresholdValue = percentThreshold * MAX(value1,value2);
;;;64     
;;;65               if(fabs(value1 - value2) > percentThresholdValue && fabs(value1 - value2) > absoluteThreshold)
;;;66                 return false;
;;;67             }
;;;68           }
;;;69     
;;;70           return true;
;;;71         }
;;;72     
;;;73         template<typename Type1> bool AreValid(const Type1 &object1)
;;;74         {
;;;75           if(!object1.IsValid())
;;;76             return false;
;;;77     
;;;78           return true;
;;;79         }
;;;80     
;;;81         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2)
;;;82         {
;;;83           if(!object1.IsValid() || !object2.IsValid())
;;;84             return false;
;;;85     
;;;86           return true;
;;;87         }
;;;88     
;;;89         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;90         {
;;;91           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid())
;;;92             return false;
;;;93     
;;;94           return true;
;;;95         }
;;;96     
;;;97         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;98         {
;;;99           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid())
;;;100            return false;
;;;101    
;;;102          return true;
;;;103        }
;;;104    
;;;105        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;106        {
;;;107          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid())
;;;108            return false;
;;;109    
;;;110          return true;
;;;111        }
;;;112    
;;;113        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;114        {
;;;115          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid())
;;;116            return false;
;;;117    
;;;118          return true;
;;;119        }
;;;120    
;;;121        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;122        {
;;;123          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid())
;;;124            return false;
;;;125    
;;;126          return true;
;;;127        }
;;;128    
;;;129        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;130        {
;;;131          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid())
;;;132            return false;
;;;133    
;;;134          return true;
;;;135        }
;;;136    
;;;137        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;138        {
;;;139          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid() || !object9.IsValid())
;;;140            return false;
;;;141    
;;;142          return true;
;;;143        }
;;;144    
;;;145        template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2)
;;;146        {
;;;147          if(!AreValid(object1, object2))
;;;148            return false;
;;;149    
;;;150          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1))
;;;151            return false;
;;;152    
;;;153          return true;
;;;154        }
;;;155    
;;;156        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;157        {
;;;158          if(!AreValid(object1, object2, object3))
;;;159            return false;
;;;160    
;;;161          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;162            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1))
;;;163            return false;
;;;164    
;;;165          return true;
;;;166        }
;;;167    
;;;168        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;169        {
;;;170          if(!AreValid(object1, object2, object3, object4))
;;;171            return false;
;;;172    
;;;173          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;174            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;175            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1))
;;;176            return false;
;;;177    
;;;178          return true;
;;;179        }
;;;180    
;;;181        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;182        {
;;;183          if(!AreValid(object1, object2, object3, object4, object5))
;;;184            return false;
;;;185    
;;;186          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;187            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;188            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;189            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1))
;;;190            return false;
;;;191    
;;;192          return true;
;;;193        }
;;;194    
;;;195        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;196        {
;;;197          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;198            return false;
;;;199    
;;;200          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;201            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;202            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;203            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;204            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1))
;;;205            return false;
;;;206    
;;;207          return true;
;;;208        }
;;;209    
;;;210        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;211        {
;;;212          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;213            return false;
;;;214    
;;;215          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;216            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;217            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;218            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;219            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;220            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1))
;;;221            return false;
;;;222    
;;;223          return true;
;;;224        }
;;;225    
;;;226        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;227        {
;;;228          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;229            return false;
;;;230    
;;;231          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;232            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;233            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;234            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;235            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;236            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;237            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1))
;;;238            return false;
;;;239    
;;;240          return true;
;;;241        }
;;;242    
;;;243        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;244        {
;;;245          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;246            return false;
;;;247    
;;;248          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;249            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;250            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;251            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;252            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;253            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;254            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1) ||
;;;255            object1.get_size(0) != object9.get_size(0) || object1.get_size(1) != object9.get_size(1))
;;;256            return false;
;;;257    
;;;258          return true;
;;;259        }
;;;260    
;;;261        template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1)
;;;262        {
;;;263          if(!AreValid(object1))
;;;264            return false;
;;;265    
;;;266          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;267            return false;
;;;268    
;;;269          return true;
;;;270        }
;;;271    
;;;272        template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2)
;;;273        {
;;;274          if(!AreValid(object1, object2))
;;;275            return false;
;;;276    
;;;277          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;278            return false;
;;;279    
;;;280          return AreEqualSize(object1, object2);
;;;281        }
;;;282    
;;;283        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;284        {
;;;285          if(!AreValid(object1, object2, object3))
;;;286            return false;
;;;287    
;;;288          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;289            return false;
;;;290    
;;;291          return AreEqualSize(object1, object2, object3);
;;;292        }
;;;293    
;;;294        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;295        {
;;;296          if(!AreValid(object1, object2, object3, object4))
;;;297            return false;
;;;298    
;;;299          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;300            return false;
;;;301    
;;;302          return AreEqualSize(object1, object2, object3, object4);
;;;303        }
;;;304    
;;;305        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;306        {
;;;307          if(!AreValid(object1, object2, object3, object4, object5))
;;;308            return false;
;;;309    
;;;310          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;311            return false;
;;;312    
;;;313          return AreEqualSize(object1, object2, object3, object4, object5);
;;;314        }
;;;315    
;;;316        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;317        {
;;;318          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;319            return false;
;;;320    
;;;321          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;322            return false;
;;;323    
;;;324          return AreEqualSize(object1, object2, object3, object4, object5, object6);
;;;325        }
;;;326    
;;;327        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;328        {
;;;329          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;330            return false;
;;;331    
;;;332          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;333            return false;
;;;334    
;;;335          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7);
;;;336        }
;;;337    
;;;338        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;339        {
;;;340          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;341            return false;
;;;342    
;;;343          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;344            return false;
;;;345    
;;;346          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8);
;;;347        }
;;;348    
;;;349        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;350        {
;;;351          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;352            return false;
;;;353    
;;;354          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;355            return false;
;;;356    
;;;357          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8, object9);
;;;358        }
;;;359    
;;;360        template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2)
;;;361        {
;;;362          if(!AreValid(object1, object2))
;;;363            return false;
;;;364    
;;;365          const size_t bufferPointers[] = {
;;;366            reinterpret_cast<size_t>(object1.get_buffer()),
;;;367            reinterpret_cast<size_t>(object2.get_buffer())};
;;;368    
;;;369          for(s32 i=0; i<2; i++) {
;;;370            for(s32 j=i+1; j<2; j++) {
;;;371              if(bufferPointers[i] == bufferPointers[j])
;;;372                return false;
;;;373            }
;;;374          }
;;;375    
;;;376          return true;
;;;377        }
;;;378    
;;;379        template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;380        {
;;;381          if(!AreValid(object1, object2, object3))
;;;382            return false;
;;;383    
;;;384          const size_t bufferPointers[] = {
;;;385            reinterpret_cast<size_t>(object1.get_buffer()),
;;;386            reinterpret_cast<size_t>(object2.get_buffer()),
;;;387            reinterpret_cast<size_t>(object3.get_buffer())};
;;;388    
;;;389          for(s32 i=0; i<3; i++) {
;;;390            for(s32 j=i+1; j<3; j++) {
;;;391              if(bufferPointers[i] == bufferPointers[j])
;;;392                return false;
;;;393            }
;;;394          }
;;;395    
;;;396          return true;
;;;397        }
;;;398    
;;;399        template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;400        {
;;;401          if(!AreValid(object1, object2, object3, object4))
;;;402            return false;
;;;403    
;;;404          const size_t bufferPointers[] = {
;;;405            reinterpret_cast<size_t>(object1.get_buffer()),
;;;406            reinterpret_cast<size_t>(object2.get_buffer()),
;;;407            reinterpret_cast<size_t>(object3.get_buffer()),
;;;408            reinterpret_cast<size_t>(object4.get_buffer())};
;;;409    
;;;410          for(s32 i=0; i<4; i++) {
;;;411            for(s32 j=i+1; j<4; j++) {
;;;412              if(bufferPointers[i] == bufferPointers[j])
;;;413                return false;
;;;414            }
;;;415          }
;;;416    
;;;417          return true;
;;;418        }
;;;419    
;;;420        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;421        {
;;;422          if(!AreValid(object1, object2, object3, object4, object5))
;;;423            return false;
;;;424    
;;;425          const size_t bufferPointers[] = {
;;;426            reinterpret_cast<size_t>(object1.get_buffer()),
;;;427            reinterpret_cast<size_t>(object2.get_buffer()),
;;;428            reinterpret_cast<size_t>(object3.get_buffer()),
;;;429            reinterpret_cast<size_t>(object4.get_buffer()),
;;;430            reinterpret_cast<size_t>(object5.get_buffer())};
;;;431    
;;;432          for(s32 i=0; i<5; i++) {
;;;433            for(s32 j=i+1; j<5; j++) {
;;;434              if(bufferPointers[i] == bufferPointers[j])
;;;435                return false;
;;;436            }
;;;437          }
;;;438    
;;;439          return true;
;;;440        }
;;;441    
;;;442        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;443        {
;;;444          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;445            return false;
;;;446    
;;;447          const size_t bufferPointers[] = {
;;;448            reinterpret_cast<size_t>(object1.get_buffer()),
;;;449            reinterpret_cast<size_t>(object2.get_buffer()),
;;;450            reinterpret_cast<size_t>(object3.get_buffer()),
;;;451            reinterpret_cast<size_t>(object4.get_buffer()),
;;;452            reinterpret_cast<size_t>(object5.get_buffer()),
;;;453            reinterpret_cast<size_t>(object6.get_buffer())};
;;;454    
;;;455          for(s32 i=0; i<6; i++) {
;;;456            for(s32 j=i+1; j<6; j++) {
;;;457              if(bufferPointers[i] == bufferPointers[j])
;;;458                return false;
;;;459            }
;;;460          }
;;;461    
;;;462          return true;
;;;463        }
;;;464    
;;;465        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;466        {
;;;467          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;468            return false;
;;;469    
;;;470          const size_t bufferPointers[] = {
;;;471            reinterpret_cast<size_t>(object1.get_buffer()),
;;;472            reinterpret_cast<size_t>(object2.get_buffer()),
;;;473            reinterpret_cast<size_t>(object3.get_buffer()),
;;;474            reinterpret_cast<size_t>(object4.get_buffer()),
;;;475            reinterpret_cast<size_t>(object5.get_buffer()),
;;;476            reinterpret_cast<size_t>(object6.get_buffer()),
;;;477            reinterpret_cast<size_t>(object7.get_buffer())};
;;;478    
;;;479          for(s32 i=0; i<7; i++) {
;;;480            for(s32 j=i+1; j<7; j++) {
;;;481              if(bufferPointers[i] == bufferPointers[j])
;;;482                return false;
;;;483            }
;;;484          }
;;;485    
;;;486          return true;
;;;487        }
;;;488    
;;;489        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;490        {
;;;491          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;492            return false;
;;;493    
;;;494          const size_t bufferPointers[] = {
;;;495            reinterpret_cast<size_t>(object1.get_buffer()),
;;;496            reinterpret_cast<size_t>(object2.get_buffer()),
;;;497            reinterpret_cast<size_t>(object3.get_buffer()),
;;;498            reinterpret_cast<size_t>(object4.get_buffer()),
;;;499            reinterpret_cast<size_t>(object5.get_buffer()),
;;;500            reinterpret_cast<size_t>(object6.get_buffer()),
;;;501            reinterpret_cast<size_t>(object7.get_buffer()),
;;;502            reinterpret_cast<size_t>(object8.get_buffer())};
;;;503    
;;;504          for(s32 i=0; i<8; i++) {
;;;505            for(s32 j=i+1; j<8; j++) {
;;;506              if(bufferPointers[i] == bufferPointers[j])
;;;507                return false;
;;;508            }
;;;509          }
;;;510    
;;;511          return true;
;;;512        }
;;;513    
;;;514        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;515        {
;;;516          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;517            return false;
;;;518    
;;;519          const size_t bufferPointers[] = {
;;;520            reinterpret_cast<size_t>(object1.get_buffer()),
;;;521            reinterpret_cast<size_t>(object2.get_buffer()),
;;;522            reinterpret_cast<size_t>(object3.get_buffer()),
;;;523            reinterpret_cast<size_t>(object4.get_buffer()),
;;;524            reinterpret_cast<size_t>(object5.get_buffer()),
;;;525            reinterpret_cast<size_t>(object6.get_buffer()),
;;;526            reinterpret_cast<size_t>(object7.get_buffer()),
;;;527            reinterpret_cast<size_t>(object8.get_buffer()),
;;;528            reinterpret_cast<size_t>(object9.get_buffer()) };
;;;529    
;;;530          for(s32 i=0; i<9; i++) {
;;;531            for(s32 j=i+1; j<9; j++) {
;;;532              if(bufferPointers[i] == bufferPointers[j])
;;;533                return false;
;;;534            }
;;;535          }
;;;536    
;;;537          return true;
;;;538        }
;;;539      } // namespace Embedded
;;;540    } // namespace Anki
;;;541    
;;;542    #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26         namespace Matrix
;;;27         {
;;;28           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;29           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;30           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;31           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;32     
;;;33           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;34           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;35           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;36           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;37     
;;;38           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;39           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;40           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;41           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;42     
;;;43           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;44           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;45           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;46           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;47     
;;;48           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;49           {
;;;50             const Array<Type> &array = mat.get_array();
;;;51     
;;;52             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;53               0, "Matrix::Min", "Array<Type> is not valid");
;;;54     
;;;55             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;56     
;;;57             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;58               0, "Matrix::Min", "Limits is not valid");
;;;59     
;;;60             Type minValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;61             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;62               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;63               const Type * restrict pMat = array.Pointer(y, 0);
;;;64     
;;;65               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;66                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;67                 minValue = MIN(minValue, pMat[x]);
;;;68               }
;;;69             }
;;;70     
;;;71             return minValue;
;;;72           } // template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;73     
;;;74           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;75           {
;;;76             const Array<Type> &array = mat.get_array();
;;;77     
;;;78             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;79               0, "Matrix::Max", "Array<Type> is not valid");
;;;80     
;;;81             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;82     
;;;83             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;84               0, "Matrix::Max", "Limits is not valid");
;;;85     
;;;86             Type maxValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;87             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;88               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;89               const Type * restrict pMat = array.Pointer(y, 0);
;;;90     
;;;91               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;92                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;93                 maxValue = MAX(maxValue, pMat[x]);
;;;94               }
;;;95             }
;;;96     
;;;97             return maxValue;
;;;98           } // template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;99     
;;;100          template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat)
;;;101          {
;;;102            const Array<Array_Type> &array = mat.get_array();
;;;103    
;;;104            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;105              0, "Matrix::Sum", "Array<Type> is not valid");
;;;106    
;;;107            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;108    
;;;109            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;110              0, "Matrix::Sum", "Limits is not valid");
;;;111    
;;;112            Accumulator_Type sum = 0;
;;;113            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;114              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;115              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;116    
;;;117              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;118                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;119                sum += pMat[x];
;;;120              }
;;;121            }
;;;122    
;;;123            return sum;
;;;124          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;125    
;;;126          template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;127          {
;;;128            const Accumulator_Type sum = Sum<Array_Type,Accumulator_Type>(mat);
;;;129            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;130            const Array_Type mean = static_cast<Array_Type>(sum / numElements);
;;;131    
;;;132            return mean;
;;;133          } // template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;134    
;;;135          template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(
;;;136            const ConstArraySliceExpression<Array_Type> &mat,
;;;137            Accumulator_Type& mean,
;;;138            Accumulator_Type& var)
;;;139          {
;;;140            const Array<Array_Type> &array = mat.get_array();
;;;141    
;;;142            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;143              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Array<Type> is not valid");
;;;144    
;;;145            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;146    
;;;147            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;148              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Limits is not valid");
;;;149    
;;;150            Accumulator_Type sum = 0;
;;;151            Accumulator_Type sumSq = 0;
;;;152            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;153              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;154              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;155    
;;;156              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;157                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;158                const Accumulator_Type val = static_cast<Accumulator_Type>(pMat[x]);
;;;159                sum   += val;
;;;160                sumSq += val*val;
;;;161              }
;;;162            }
;;;163    
;;;164            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;165    
;;;166            mean = sum / numElements;                  // mean = E[x]
;;;167            var  = (sumSq / numElements) - (mean*mean);  // var  = E[x^2] - E[x]^2
;;;168    
;;;169            return RESULT_OK;
;;;170          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;171    
;;;172          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;173          {
;;;174            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;175          } // template<typename Type> Result Add(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;176    
;;;177          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;178          {
;;;179            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;180          }
;;;181    
;;;182          template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;183          {
;;;184            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;185          }
;;;186    
;;;187          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;188          {
;;;189            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;190          } // template<typename Type> Result Subtract(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;191    
;;;192          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;193          {
;;;194            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;195          }
;;;196    
;;;197          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;198          {
;;;199            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;200          }
;;;201    
;;;202          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;203          {
;;;204            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;205          } // template<typename Type> Result DotMultiply(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;206    
;;;207          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;208          {
;;;209            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;210          }
;;;211    
;;;212          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;213          {
;;;214            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;215          }
;;;216    
;;;217          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;218          {
;;;219            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;220          } // template<typename Type> Result DotDivide(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;221    
;;;222          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;223          {
;;;224            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;225          }
;;;226    
;;;227          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;228          {
;;;229            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;230          }
;;;231    
;;;232          template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;233          {
;;;234            return Elementwise::ApplyOperation<InType, Elementwise::Exp<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;235          } // template<typename Type> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;236    
;;;237          template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;238          {
;;;239            return Elementwise::ApplyOperation<InType, Elementwise::Sqrt<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;240          }
;;;241    
;;;242          template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;243          {
;;;244            const s32 in1Height = in1.get_size(0);
;;;245            const s32 in1Width = in1.get_size(1);
;;;246    
;;;247            const s32 in2Height = in2.get_size(0);
;;;248            const s32 in2Width = in2.get_size(1);
;;;249            const s32 in2Stride = in2.get_stride();
;;;250    
;;;251            AnkiConditionalErrorAndReturnValue(in1Width == in2Height,
;;;252              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;253    
;;;254            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2Width, out),
;;;255              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;256    
;;;257            for(s32 y1=0; y1<in1Height; y1++) {
;;;258              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;259              OutType * restrict pOut = out.Pointer(y1, 0);
;;;260    
;;;261              for(s32 x2=0; x2<in2Width; x2++) {
;;;262                const u8 * restrict pIn2 = reinterpret_cast<const u8*>(in2.Pointer(0, x2));
;;;263    
;;;264                OutType accumulator = 0;
;;;265    
;;;266                s32 y2;
;;;267                for(y2=0; y2<in2Height-3; y2+=4) {
;;;268                  const InType in1_0 = pIn1[y2];
;;;269                  const InType in1_1 = pIn1[y2+1];
;;;270                  const InType in1_2 = pIn1[y2+2];
;;;271                  const InType in1_3 = pIn1[y2+3];
;;;272    
;;;273                  const InType in2_0 = *reinterpret_cast<const InType*>(pIn2);
;;;274                  const InType in2_1 = *reinterpret_cast<const InType*>(pIn2 + in2Stride);
;;;275                  const InType in2_2 = *reinterpret_cast<const InType*>(pIn2 + 2*in2Stride);
;;;276                  const InType in2_3 = *reinterpret_cast<const InType*>(pIn2 + 3*in2Stride);
;;;277    
;;;278                  accumulator +=
;;;279                    in1_0 * in2_0 +
;;;280                    in1_1 * in2_1 +
;;;281                    in1_2 * in2_2 +
;;;282                    in1_3 * in2_3;
;;;283    
;;;284                  pIn2 += 4*in2Stride;
;;;285                }
;;;286    
;;;287                for(; y2<in2Height; y2++) {
;;;288                  accumulator += pIn1[y2] * (*reinterpret_cast<const InType*>(pIn2));
;;;289    
;;;290                  pIn2 += in2Stride;
;;;291                }
;;;292    
;;;293                pOut[x2] = accumulator;
;;;294              }
;;;295            }
;;;296    
;;;297            return RESULT_OK;
;;;298          } // template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;299    
;;;300          template<typename InType, typename OutType> NO_INLINE Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;301          {
;;;302            const s32 in1Height = in1.get_size(0);
;;;303            const s32 in1Width = in1.get_size(1);
;;;304    
;;;305            const s32 in2TransposedHeight = in2Transposed.get_size(0);
;;;306            const s32 in2TransposedWidth = in2Transposed.get_size(1);
;;;307    
;;;308            AnkiConditionalErrorAndReturnValue(in1Width == in2TransposedWidth,
;;;309              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;310    
;;;311            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2TransposedHeight, out),
;;;312              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;313    
;;;314            for(s32 y1=0; y1<in1Height; y1++)
;;;315            {
;;;316              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;317    
;;;318              for(s32 y2=0; y2<in2TransposedHeight; y2++) {
;;;319                const InType * restrict pIn2 = in2Transposed.Pointer(y2, 0);
;;;320    
;;;321                OutType accumulator = 0;
;;;322    
;;;323                s32 x;
;;;324                for(x=0; x<in2TransposedWidth-3; x+=4) {
;;;325                  const InType in1_0 = pIn1[x];
;;;326                  const InType in1_1 = pIn1[x+1];
;;;327                  const InType in1_2 = pIn1[x+2];
;;;328                  const InType in1_3 = pIn1[x+3];
;;;329    
;;;330                  const InType in2_0 = pIn2[x];
;;;331                  const InType in2_1 = pIn2[x+1];
;;;332                  const InType in2_2 = pIn2[x+2];
;;;333                  const InType in2_3 = pIn2[x+3];
;;;334    
;;;335                  accumulator +=
;;;336                    in1_0 * in2_0 +
;;;337                    in1_1 * in2_1 +
;;;338                    in1_2 * in2_2 +
;;;339                    in1_3 * in2_3;
;;;340                }
;;;341    
;;;342                for(; x<in2TransposedWidth; x++) {
;;;343                  accumulator += pIn1[x] * pIn2[x];
;;;344                }
;;;345    
;;;346                *out.Pointer(y1, y2) = accumulator;
;;;347              }
;;;348            }
;;;349    
;;;350            return RESULT_OK;
;;;351          } // template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;352    
;;;353          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;354            Array<Type> &A_L,       //!< Input A Matrix and Output lower-triangular L matrix
;;;355            Array<Type> &Bt_Xt,     //!< Input B-transpose matrix and Output X-transpose solution
;;;356            bool realCholesky,      //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;357            bool &numericalFailure  //!< If true, the solver failed because of numerical instability
;;;358            )
;;;359          {
;;;360            const s32 matrixHeight = A_L.get_size(0);
;;;361            const s32 numSamples = Bt_Xt.get_size(0);
;;;362    
;;;363            numericalFailure = false;
;;;364    
;;;365            AnkiConditionalErrorAndReturnValue(AreValid(A_L, Bt_Xt),
;;;366              RESULT_FAIL_INVALID_OBJECT, "CholeskyDecomposition", "Invalid objects");
;;;367    
;;;368            AnkiConditionalErrorAndReturnValue(matrixHeight == A_L.get_size(1),
;;;369              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "A_L is not square");
;;;370    
;;;371            AnkiConditionalErrorAndReturnValue(Bt_Xt.get_size(1) == matrixHeight,
;;;372              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "Xt and Bt are the wrong sizes");
;;;373    
;;;374            // TODO: check if symmetric and positive-definite
;;;375    
;;;376            const Type minStableValue = Anki::Embedded::Flags::numeric_limits<Type>::epsilon();
;;;377    
;;;378            for(s32 i = 0; i < matrixHeight; i++) {
;;;379              // First, compute the non-diagonal values
;;;380              // This uses the results from the diagonal inverse computation from previous iterations of i
;;;381              Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;382    
;;;383              for(s32 j = 0; j < i; j++) {
;;;384                Type * restrict pAL_yj = A_L.Pointer(j, 0);
;;;385    
;;;386                Type sum = pAL_yi[j];
;;;387                for(s32 k = 0; k < j; k++) {
;;;388                  const Type value1 = pAL_yi[k];
;;;389                  const Type value2 = pAL_yj[k];
;;;390                  sum -= value1*value2;
;;;391                }
;;;392    
;;;393                pAL_yi[j] = sum*pAL_yj[j];
;;;394              } // for(s32 j = 0; j < i; j++)
;;;395    
;;;396              // Second, compute the inverse of the diagonal
;;;397              {
;;;398                Type sum = pAL_yi[i];
;;;399                for(s32 k = 0; k < i; k++) {
;;;400                  const Type value = pAL_yi[k];
;;;401                  sum -= value*value;
;;;402                }
;;;403    
;;;404                if(sum < minStableValue) {
;;;405                  numericalFailure = true;
;;;406                  return RESULT_OK;
;;;407                }
;;;408    
;;;409                // TODO: change this f32 square root to f64 if Type==f64
;;;410                const Type sumRoot = static_cast<Type>(sqrtf(static_cast<f32>(sum)));
;;;411                pAL_yi[i] = static_cast<Type>(1) / sumRoot;
;;;412              }
;;;413            } // for(s32 i = 0; i < m; i++)
;;;414    
;;;415            // Solve L*y = b via forward substitution
;;;416            for(s32 i = 0; i < matrixHeight; i++) {
;;;417              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;418              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;419    
;;;420              for(s32 j = 0; j < numSamples; j++) {
;;;421                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;422    
;;;423                Type sum = pBX_yj[i];
;;;424                for(s32 k = 0; k < i; k++) {
;;;425                  const Type value1 = pAL_yi[k];
;;;426                  const Type value2 = pBX_yj[k];
;;;427                  sum -= value1*value2;
;;;428                }
;;;429    
;;;430                pBX_yj[i] = sum*pAL_yi[i];
;;;431              }
;;;432            }
;;;433    
;;;434            // Solve L'*X = Y via back substitution
;;;435            for(s32 i = matrixHeight-1; i >= 0; i--) {
;;;436              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;437              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;438    
;;;439              for(s32 j = 0; j < numSamples; j++) {
;;;440                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;441    
;;;442                Type sum = pBX_yj[i];
;;;443                for(s32 k = matrixHeight-1; k > i; k-- ) {
;;;444                  const Type value1 = A_L[k][i];
;;;445                  const Type value2 = pBX_yj[k];
;;;446                  sum -= value1*value2;
;;;447                }
;;;448    
;;;449                pBX_yj[i] = sum*pAL_yi[i];
;;;450              }
;;;451            }
;;;452    
;;;453            if(realCholesky) {
;;;454              // Invert the diagonal values of L, and set upper triangular to zero
;;;455              for(s32 i = 0; i < matrixHeight; i++) {
;;;456                Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;457    
;;;458                pAL_yi[i] = static_cast<Type>(1) / pAL_yi[i];
;;;459    
;;;460                for(s32 j = i+1; j < matrixHeight; j++) {
;;;461                  pAL_yi[j] = 0;
;;;462                }
;;;463              }
;;;464            }
;;;465    
;;;466            return RESULT_OK;
;;;467          } // SolveLeastSquaresWithCholesky()
;;;468    
;;;469          template<typename Type> NO_INLINE Result EstimateHomography(
;;;470            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;471            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;472            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;473            bool &numericalFailure, //!< Did the homography solver fail?
;;;474            MemoryStack scratch //!< Scratch memory
;;;475            )
;;;476          {
;;;477            const Type MAX_SOLVE_DISTANCE = static_cast<Type>(0.1);
;;;478    
;;;479            //BeginBenchmark("EstimateHomography_init");
;;;480    
;;;481            const s32 numPoints = originalPoints.get_size();
;;;482    
;;;483            AnkiConditionalErrorAndReturnValue(AreValid(originalPoints, transformedPoints, homography, scratch),
;;;484              RESULT_FAIL_INVALID_OBJECT, "EstimateHomography", "Invalid objects");
;;;485    
;;;486            AnkiConditionalErrorAndReturnValue(transformedPoints.get_size() == numPoints && numPoints >= 4,
;;;487              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "originalPoints and transformedPoints must be the same size, and have at least four points apiece.");
;;;488    
;;;489            AnkiConditionalErrorAndReturnValue(AreEqualSize(3, 3, homography),
;;;490              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "homography must be 3x3");
;;;491    
;;;492            homography.SetZero();
;;;493            homography[0][0] = 1;
;;;494            homography[1][1] = 1;
;;;495            homography[2][2] = 1;
;;;496    
;;;497            Array<Type> A(8, 2*numPoints, scratch);
;;;498            Array<Type> bt(1, 2*numPoints, scratch);
;;;499    
;;;500            const Point<Type> * const pOriginalPoints = originalPoints.Pointer(0);
;;;501            const Point<Type> * const pTransformedPoints = transformedPoints.Pointer(0);
;;;502    
;;;503            Type * restrict pBt = bt.Pointer(0,0);
;;;504    
;;;505            //EndBenchmark("EstimateHomography_init");
;;;506    
;;;507            //BeginBenchmark("EstimateHomography_a&b");
;;;508    
;;;509            for(s32 i=0; i<numPoints; i++) {
;;;510              Type * restrict A_y1 = A.Pointer(2*i, 0);
;;;511              Type * restrict A_y2 = A.Pointer(2*i + 1, 0);
;;;512    
;;;513              const Type xi = pOriginalPoints[i].x;
;;;514              const Type yi = pOriginalPoints[i].y;
;;;515    
;;;516              const Type xp = pTransformedPoints[i].x;
;;;517              const Type yp = pTransformedPoints[i].y;
;;;518    
;;;519              A_y1[0] = 0;  A_y1[1] = 0;  A_y1[2] = 0; A_y1[3] = -xi; A_y1[4] = -yi; A_y1[5] = -1; A_y1[6] = xi*yp;  A_y1[7] = yi*yp;
;;;520              A_y2[0] = xi; A_y2[1] = yi; A_y2[2] = 1; A_y2[3] = 0;   A_y2[4] = 0;   A_y2[5] = 0;  A_y2[6] = -xi*xp; A_y2[7] = -yi*xp;
;;;521    
;;;522              pBt[2*i] = -yp;
;;;523              pBt[2*i + 1] = xp;
;;;524            }
;;;525    
;;;526            //EndBenchmark("EstimateHomography_a&b");
;;;527    
;;;528            //BeginBenchmark("EstimateHomography_At");
;;;529    
;;;530            Array<Type> At(2*numPoints, 8, scratch);
;;;531    
;;;532            Matrix::Transpose(A, At);
;;;533    
;;;534            //EndBenchmark("EstimateHomography_At");
;;;535    
;;;536            //BeginBenchmark("EstimateHomography_AtA");
;;;537    
;;;538            Array<Type> AtA(8, 8, scratch, Flags::Buffer(false,false,false));
;;;539            Array<Type> Atb(8, 1, scratch, Flags::Buffer(false,false,false));
;;;540    
;;;541            Matrix::Multiply(At, A, AtA);
;;;542    
;;;543            //EndBenchmark("EstimateHomography_AtA");
;;;544    
;;;545            //BeginBenchmark("EstimateHomography_Atb");
;;;546    
;;;547            Matrix::MultiplyTranspose(At, bt, Atb);
;;;548    
;;;549            //EndBenchmark("EstimateHomography_Atb");
;;;550    
;;;551            //BeginBenchmark("EstimateHomography_transposeAtb");
;;;552    
;;;553            Array<Type> Atbt(1, 8, scratch);
;;;554    
;;;555            Matrix::Transpose(Atb, Atbt);
;;;556    
;;;557            //EndBenchmark("EstimateHomography_transposeAtb");
;;;558    
;;;559            //BeginBenchmark("EstimateHomography_cholesky");
;;;560    
;;;561            const Result choleskyResult = SolveLeastSquaresWithCholesky(AtA, Atbt, false, numericalFailure);
;;;562    
;;;563            AnkiConditionalErrorAndReturnValue(choleskyResult == RESULT_OK,
;;;564              choleskyResult, "EstimateHomography", "SolveLeastSquaresWithCholesky failed");
;;;565    
;;;566            if(numericalFailure){
;;;567              AnkiWarn("EstimateHomography", "numericalFailure");
;;;568              return RESULT_OK;
;;;569            }
;;;570    
;;;571            Type * restrict pAtbt = Atbt.Pointer(0,0);
;;;572    
;;;573            homography[0][0] = pAtbt[0]; homography[0][1] = pAtbt[1]; homography[0][2] = pAtbt[2];
;;;574            homography[1][0] = pAtbt[3]; homography[1][1] = pAtbt[4]; homography[1][2] = pAtbt[5];
;;;575            homography[2][0] = pAtbt[6]; homography[2][1] = pAtbt[7]; homography[2][2] = static_cast<Type>(1);
;;;576    
;;;577            // Check that the solution is fairly close
;;;578            // TODO: make work for numPoints != 4
;;;579            if(numPoints == 4) {
;;;580              Array<Type> point1(3,1,scratch);
;;;581              Array<Type> point1Warped(3,1,scratch);
;;;582              for(s32 iPoint=0; iPoint<numPoints; iPoint++) {
;;;583                point1[0][0] = originalPoints[iPoint].x;
;;;584                point1[1][0] = originalPoints[iPoint].y;
;;;585                point1[2][0] = 1;
;;;586    
;;;587                Matrix::Multiply(homography, point1, point1Warped);
;;;588                point1Warped[0][0] /= point1Warped[2][0];
;;;589                point1Warped[1][0] /= point1Warped[2][0];
;;;590    
;;;591                const Type distance = sqrtf(powf(static_cast<f32>(transformedPoints[iPoint].x) - static_cast<f32>(point1Warped[0][0]), 2.0f) + powf(static_cast<f32>(transformedPoints[iPoint].y) - static_cast<f32>(point1Warped[1][0]), 2.0f));
;;;592    
;;;593                if(distance > MAX_SOLVE_DISTANCE) {
;;;594                  AnkiWarn("EstimateHomography", "Poor solution precision");
;;;595    
;;;596                  numericalFailure = true;
;;;597    
;;;598                  homography.SetZero();
;;;599                  homography[0][0] = 1;
;;;600                  homography[1][1] = 1;
;;;601                  homography[2][2] = 1;
;;;602    
;;;603                  return RESULT_OK;
;;;604                }
;;;605              }
;;;606            }
;;;607            //EndBenchmark("EstimateHomography_cholesky");
;;;608    
;;;609            return RESULT_OK;
;;;610          } // EstimateHomography()
;;;611    
;;;612          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;613          {
;;;614            const s32 inHeight = in.get_size(0);
;;;615            const s32 inWidth = in.get_size(1);
;;;616    
;;;617            const s32 outHeight = out.get_size(0);
;;;618            const s32 outWidth = out.get_size(1);
;;;619    
;;;620            AnkiConditionalErrorAndReturnValue((inHeight*inWidth) == (outHeight*outWidth),
;;;621              RESULT_FAIL_INVALID_SIZE, "Reshape", "Input and Output matrices are incompatible sizes");
;;;622    
;;;623            s32 inIndexY = 0;
;;;624            s32 inIndexX = 0;
;;;625    
;;;626            if(isColumnMajor) {
;;;627              for(s32 y = 0; y < outHeight; y++)
;;;628              {
;;;629                OutType * const pOut = out.Pointer(y,0);
;;;630    
;;;631                for(s32 x = 0; x < outWidth; x++) {
;;;632                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;633    
;;;634                  pOut[x] = static_cast<OutType>(curIn);
;;;635    
;;;636                  inIndexY++;
;;;637                  if(inIndexY >= inHeight) {
;;;638                    inIndexY = 0;
;;;639                    inIndexX++;
;;;640                  }
;;;641                }
;;;642              }
;;;643            } else { // if(isColumnMajor)
;;;644              for(s32 y = 0; y < outHeight; y++)
;;;645              {
;;;646                OutType * const pOut = out.Pointer(y,0);
;;;647    
;;;648                for(s32 x = 0; x < outWidth; x++) {
;;;649                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;650    
;;;651                  pOut[x] = static_cast<OutType>(curIn);
;;;652    
;;;653                  inIndexX++;
;;;654                  if(inIndexX >= inWidth) {
;;;655                    inIndexX = 0;
;;;656                    inIndexY++;
;;;657                  }
;;;658                }
;;;659              }
;;;660            } // if(isColumnMajor) ... else
;;;661    
;;;662            return RESULT_OK;
;;;663          } // Reshape()
;;;664    
;;;665          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory)
;;;666          {
;;;667            Array<OutType> out(newHeight, newWidth, memory);
;;;668    
;;;669            Reshape<InType, OutType>(isColumnMajor, in, out);
;;;670    
;;;671            return out;
;;;672          }
;;;673    
;;;674          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;675          {
;;;676            AnkiConditionalErrorAndReturnValue(out.get_size(0) == 1,
;;;677              RESULT_FAIL_INVALID_SIZE, "Vectorize", "Output is not 1xN");
;;;678    
;;;679            return Reshape<InType, OutType>(isColumnMajor, in, out);
;;;680          }
;;;681    
;;;682          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory)
;;;683          {
;;;684            const s32 inHeight = in.get_size(0);
;;;685            const s32 inWidth = in.get_size(1);
;;;686    
;;;687            Array<OutType> out(1, inHeight*inWidth, memory);
;;;688    
;;;689            Vectorize<InType, OutType>(isColumnMajor, in, out);
;;;690    
;;;691            return out;
;;;692          }
;;;693    
;;;694          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out)
;;;695          {
;;;696            const s32 inHeight = in.get_size(0);
;;;697            const s32 inWidth = in.get_size(1);
;;;698    
;;;699            const s32 outStride = out.get_stride();
;;;700    
;;;701            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;702              RESULT_FAIL_INVALID_OBJECT, "Transpose", "Invalid objects");
;;;703    
;;;704            AnkiConditionalErrorAndReturnValue(AreEqualSize(in.get_size(1), in.get_size(0), out),
;;;705              RESULT_FAIL_INVALID_SIZE, "Transpose", "out is not the correct size");
;;;706    
;;;707            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;708              RESULT_FAIL_ALIASED_MEMORY, "Transpose", "in and out cannot be the same array");
;;;709    
;;;710            for(s32 yIn=0; yIn<inHeight; yIn++) {
;;;711              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;712              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0,yIn));
;;;713    
;;;714              s32 xIn;
;;;715              s32 outOffset0 = 0;
;;;716    
;;;717              for(xIn=0; xIn<inWidth-1; xIn+=2) {
;;;718                const InType in0 = pIn[xIn];
;;;719                const InType in1 = pIn[xIn+1];
;;;720    
;;;721                const s32 outOffset1 = outOffset0 + outStride;
;;;722    
;;;723                *reinterpret_cast<OutType*>(pOut + outOffset0) = static_cast<OutType>(in0);
;;;724                *reinterpret_cast<OutType*>(pOut + outOffset1) = static_cast<OutType>(in1);
;;;725    
;;;726                outOffset0 += 2*outStride;
;;;727              }
;;;728    
;;;729              for(; xIn<inWidth; xIn++) {
;;;730                *out.Pointer(xIn,yIn) = static_cast<OutType>(pIn[xIn]);
;;;731              }
;;;732            }
;;;733    
;;;734            return RESULT_OK;
;;;735          } // Transpose()
;;;736    
;;;737          template<typename InType, typename OutType> Result Rotate90(const Array<InType> &in, Array<OutType> &out)
;;;738          {
;;;739            const s32 arrWidth = in.get_size(1);
;;;740    
;;;741            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;742              RESULT_FAIL_INVALID_OBJECT, "Rotate90", "Invalid objects");
;;;743    
;;;744            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;745              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;746    
;;;747            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;748              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;749    
;;;750            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;751              RESULT_FAIL_ALIASED_MEMORY, "Rotate90", "in and out cannot be the same array");
;;;752    
;;;753            const s32 outStride = out.get_stride();
;;;754    
;;;755            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;756              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;757              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0, arrWidth-yIn-1));
;;;758    
;;;759              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;760                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;761    
;;;762                pOut += outStride;
;;;763              }
;;;764            }
;;;765    
;;;766            return RESULT_OK;
;;;767          } // Rotate90()
;;;768    
;;;769          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out)
;;;770          {
;;;771            const s32 arrWidth = in.get_size(1);
;;;772    
;;;773            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;774              RESULT_FAIL_INVALID_OBJECT, "Rotate180", "Invalid objects");
;;;775    
;;;776            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;777              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;778    
;;;779            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;780              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;781    
;;;782            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;783              RESULT_FAIL_ALIASED_MEMORY, "Rotate180", "in and out cannot be the same array");
;;;784    
;;;785            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;786              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;787              OutType * restrict pOut = out.Pointer(arrWidth-yIn-1, 0);
;;;788    
;;;789              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;790                pOut[arrWidth-xIn-1] = static_cast<OutType>(pIn[xIn]);
;;;791              }
;;;792            }
;;;793    
;;;794            return RESULT_OK;
;;;795          } // Rotate180()
;;;796    
;;;797          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out)
;;;798          {
;;;799            const s32 arrWidth = in.get_size(1);
;;;800    
;;;801            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;802              RESULT_FAIL_INVALID_OBJECT, "Rotate270", "Invalid objects");
;;;803    
;;;804            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;805              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;806    
;;;807            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;808              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;809    
;;;810            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;811              RESULT_FAIL_ALIASED_MEMORY, "Rotate270", "in and out cannot be the same array");
;;;812    
;;;813            const s32 outStride = out.get_stride();
;;;814    
;;;815            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;816              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;817              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(arrWidth-1, yIn));
;;;818    
;;;819              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;820                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;821    
;;;822                pOut -= outStride;
;;;823              }
;;;824            }
;;;825    
;;;826            return RESULT_OK;
;;;827          } // Rotate270()
;;;828    
;;;829          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;830          {
;;;831            const s32 arrWidth = arr.get_size(1);
;;;832    
;;;833            for(s32 x=0; x<arrWidth; x++) {
;;;834              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;835                const Type valueToInsert = arr[y][x];
;;;836    
;;;837                s32 holePosition = y;
;;;838    
;;;839                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;840                  arr[holePosition][x] = arr[holePosition-1][x];
;;;841                  holePosition--;
;;;842                }
;;;843    
;;;844                arr[holePosition][x] = valueToInsert;
;;;845              }
;;;846            } // for(s32 x=0; x<arrWidth; x++)
;;;847          } // InsertionSort_sortAscendingDimension0()
;;;848    
;;;849          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;850          {
;;;851            const s32 arrWidth = arr.get_size(1);
;;;852    
;;;853            for(s32 x=0; x<arrWidth; x++) {
;;;854              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;855                const Type valueToInsert = arr[y][x];
;;;856    
;;;857                s32 holePosition = y;
;;;858    
;;;859                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;860                  arr[holePosition][x] = arr[holePosition-1][x];
;;;861                  holePosition--;
;;;862                }
;;;863    
;;;864                arr[holePosition][x] = valueToInsert;
;;;865              }
;;;866            } // for(s32 x=0; x<arrWidth; x++)
;;;867          } // InsertionSort_sortDescendingDimension0
;;;868    
;;;869          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;870          {
;;;871            const s32 arrHeight = arr.get_size(0);
;;;872    
;;;873            for(s32 y=0; y<arrHeight; y++) {
;;;874              Type * const pArr = arr[y];
;;;875    
;;;876              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;877                const Type valueToInsert = pArr[x];
;;;878    
;;;879                s32 holePosition = x;
;;;880    
;;;881                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;882                  pArr[holePosition] = pArr[holePosition-1];
;;;883                  holePosition--;
;;;884                }
;;;885    
;;;886                pArr[holePosition] = valueToInsert;
;;;887              }
;;;888            } // for(s32 x=0; x<arrWidth; x++)
;;;889          } // InsertionSort_sortAscendingDimension1()
;;;890    
;;;891          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;892          {
;;;893            const s32 arrHeight = arr.get_size(0);
;;;894    
;;;895            for(s32 y=0; y<arrHeight; y++) {
;;;896              Type * const pArr = arr[y];
;;;897    
;;;898              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;899                const Type valueToInsert = pArr[x];
;;;900    
;;;901                s32 holePosition = x;
;;;902    
;;;903                while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;904                  pArr[holePosition] = pArr[holePosition-1];
;;;905                  holePosition--;
;;;906                }
;;;907    
;;;908                pArr[holePosition] = valueToInsert;
;;;909              }
;;;910            } // for(s32 x=0; x<arrWidth; x++)
;;;911          } // InsertionSort_sortAscendingDimension1()
;;;912    
;;;913          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;914          {
;;;915            const s32 arrWidth = arr.get_size(1);
;;;916    
;;;917            for(s32 x=0; x<arrWidth; x++) {
;;;918              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;919                const Type valueToInsert = arr[y][x];
;;;920                const s32 indexToInsert = indexes[y][x];
;;;921    
;;;922                s32 holePosition = y;
;;;923    
;;;924                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;925                  arr[holePosition][x] = arr[holePosition-1][x];
;;;926                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;927                  holePosition--;
;;;928                }
;;;929    
;;;930                arr[holePosition][x] = valueToInsert;
;;;931                indexes[holePosition][x] = indexToInsert;
;;;932              }
;;;933            } // for(s32 x=0; x<arrWidth; x++)
;;;934          } // InsertionSort_sortAscendingDimension0()
;;;935    
;;;936          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;937          {
;;;938            const s32 arrWidth = arr.get_size(1);
;;;939    
;;;940            for(s32 x=0; x<arrWidth; x++) {
;;;941              indexes[0][x] = 0;
;;;942    
;;;943              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;944                const Type valueToInsert = arr[y][x];
;;;945                const s32 indexToInsert = indexes[y][x];
;;;946    
;;;947                s32 holePosition = y;
;;;948    
;;;949                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;950                  arr[holePosition][x] = arr[holePosition-1][x];
;;;951                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;952                  holePosition--;
;;;953                }
;;;954    
;;;955                arr[holePosition][x] = valueToInsert;
;;;956                indexes[holePosition][x] = indexToInsert;
;;;957              }
;;;958            } // for(s32 x=0; x<arrWidth; x++)
;;;959          } // InsertionSort_sortDescendingDimension0()
;;;960    
;;;961          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;962          {
;;;963            const s32 arrHeight = arr.get_size(0);
;;;964    
;;;965            for(s32 y=0; y<arrHeight; y++) {
;;;966              Type * const pArr = arr[y];
;;;967              s32 * const pIndexes = indexes[y];
;;;968    
;;;969              pIndexes[0] = 0;
;;;970    
;;;971              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;972                const Type valueToInsert = pArr[x];
;;;973                const s32 indexToInsert = pIndexes[x];
;;;974    
;;;975                s32 holePosition = x;
;;;976    
;;;977                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;978                  pArr[holePosition] = pArr[holePosition-1];
;;;979                  pIndexes[holePosition] = pIndexes[holePosition-1];
;;;980                  holePosition--;
;;;981                }
;;;982    
;;;983                pArr[holePosition] = valueToInsert;
;;;984                pIndexes[holePosition] = indexToInsert;
;;;985              }
;;;986            } // for(s32 x=0; x<arrWidth; x++)
;;;987          } // InsertionSort_sortAscendingDimension1()
;;;988    
;;;989          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;990          {
;;;991            const s32 arrHeight = arr.get_size(0);
;;;992    
;;;993            for(s32 y=0; y<arrHeight; y++) {
;;;994              Type * const pArr = arr[y];
;;;995              s32 * const pIndexes = indexes[y];
;;;996    
;;;997              pIndexes[0] = 0;
;;;998    
;;;999              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;1000               const Type valueToInsert = pArr[x];
;;;1001               const s32 indexToInsert = pIndexes[x];
;;;1002   
;;;1003               s32 holePosition = x;
;;;1004   
;;;1005               while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;1006                 pArr[holePosition] = pArr[holePosition-1];
;;;1007                 pIndexes[holePosition] = pIndexes[holePosition-1];
;;;1008                 holePosition--;
;;;1009               }
;;;1010   
;;;1011               pArr[holePosition] = valueToInsert;
;;;1012               pIndexes[holePosition] = indexToInsert;
;;;1013             }
;;;1014           } // for(s32 x=0; x<arrWidth; x++)
;;;1015         } // InsertionSort_sortDescendingDimension1()
;;;1016   
;;;1017         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1018         {
;;;1019           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1020             return;
;;;1021           }
;;;1022   
;;;1023           // Select the median value of the first, middle, and last elements as the pivot
;;;1024           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1025   
;;;1026           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1027   
;;;1028           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1029             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1030   
;;;1031           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1032             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1033   
;;;1034           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x))
;;;1035             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1036   
;;;1037           // Search from the beginning to before the moved pivot
;;;1038           s32 i = trueMinIndex;
;;;1039           s32 j = trueMaxIndex - 2;
;;;1040   
;;;1041           if(i >= j) {
;;;1042             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1043             // NOTE: This really means your insertionSortSize value is too low
;;;1044             return;
;;;1045           }
;;;1046   
;;;1047           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1048   
;;;1049           const Type pivot = *arr.Pointer(midIndex, x);
;;;1050   
;;;1051           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1052   
;;;1053           // Main partitioning loop
;;;1054           while(true) {
;;;1055             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1056             while(*arr.Pointer(i,x) < pivot) {
;;;1057               i++;
;;;1058             }
;;;1059   
;;;1060             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1061             while(*arr.Pointer(j,x) > pivot) {
;;;1062               j--;
;;;1063             }
;;;1064   
;;;1065             if(i < j) {
;;;1066               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1067               i++;
;;;1068               j--;
;;;1069             } else {
;;;1070               break;
;;;1071             }
;;;1072           }
;;;1073   
;;;1074           // Replace the pivot
;;;1075           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1076   
;;;1077           // Recurse
;;;1078           QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1079   
;;;1080           QuickSort_sortAscendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1081         } // QuickSort_sortAscendingDimension0
;;;1082   
;;;1083         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1084         {
;;;1085           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1086             return;
;;;1087           }
;;;1088   
;;;1089           // Select the median value of the first, middle, and last elements as the pivot
;;;1090           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1091   
;;;1092           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1093   
;;;1094           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1095             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1096   
;;;1097           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1098             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1099   
;;;1100           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x))
;;;1101             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1102   
;;;1103           // Search from the beginning to before the moved pivot
;;;1104           s32 i = trueMinIndex;
;;;1105           s32 j = trueMaxIndex - 2;
;;;1106   
;;;1107           if(i >= j) {
;;;1108             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1109             // NOTE: This really means your insertionSortSize value is too low
;;;1110             return;
;;;1111           }
;;;1112   
;;;1113           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1114   
;;;1115           const Type pivot = *arr.Pointer(midIndex, x);
;;;1116   
;;;1117           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1118   
;;;1119           // Main partitioning loop
;;;1120           while(true) {
;;;1121             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1122             while(*arr.Pointer(i,x) > pivot) {
;;;1123               i++;
;;;1124             }
;;;1125   
;;;1126             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1127             while(*arr.Pointer(j,x) < pivot) {
;;;1128               j--;
;;;1129             }
;;;1130   
;;;1131             if(i < j) {
;;;1132               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1133               i++;
;;;1134               j--;
;;;1135             } else {
;;;1136               break;
;;;1137             }
;;;1138           }
;;;1139   
;;;1140           // Replace the pivot
;;;1141           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1142   
;;;1143           // Recurse
;;;1144           QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1145   
;;;1146           QuickSort_sortDescendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1147         } // QuickSort_sortDescendingDimension0
;;;1148   
;;;1149         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1150         {
;;;1151           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1152             return;
;;;1153           }
;;;1154   
;;;1155           Type * restrict pArr = arr.Pointer(y,0);
;;;1156   
;;;1157           // Select the median value of the first, middle, and last elements as the pivot
;;;1158           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1159   
;;;1160           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1161   
;;;1162           if(pArr[midIndex] < pArr[trueMinIndex])
;;;1163             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1164   
;;;1165           if(pArr[trueMaxIndex] < pArr[trueMinIndex])
;;;1166             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1167   
;;;1168           if(pArr[trueMaxIndex] < pArr[midIndex])
;;;1169             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1170   
;;;1171           // Search from the beginning to before the moved pivot
;;;1172           s32 i = trueMinIndex;
;;;1173           s32 j = trueMaxIndex - 2;
;;;1174   
;;;1175           if(i >= j) {
;;;1176             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1177             // NOTE: This really means your insertionSortSize value is too low
;;;1178             return;
;;;1179           }
;;;1180   
;;;1181           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1182   
;;;1183           const Type pivot = pArr[midIndex];
;;;1184   
;;;1185           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1186   
;;;1187           // Main partitioning loop
;;;1188           while(true) {
;;;1189             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1190             while(pArr[i] < pivot) {
;;;1191               i++;
;;;1192             }
;;;1193   
;;;1194             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1195             while(pArr[j] > pivot) {
;;;1196               j--;
;;;1197             }
;;;1198   
;;;1199             if(i < j) {
;;;1200               Swap<Type>(pArr[i], pArr[j]);
;;;1201               i++;
;;;1202               j--;
;;;1203             } else {
;;;1204               break;
;;;1205             }
;;;1206           }
;;;1207   
;;;1208           // Replace the pivot
;;;1209           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1210   
;;;1211           // Recurse
;;;1212           QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1213   
;;;1214           QuickSort_sortAscendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1215         } // QuickSort_sortAscendingDimension1
;;;1216   
;;;1217         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1218         {
;;;1219           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1220             return;
;;;1221           }
;;;1222   
;;;1223           Type * restrict pArr = arr.Pointer(y,0);
;;;1224   
;;;1225           // Select the median value of the first, middle, and last elements as the pivot
;;;1226           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1227   
;;;1228           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1229   
;;;1230           if(pArr[midIndex] < pArr[trueMaxIndex])
;;;1231             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1232   
;;;1233           if(pArr[trueMinIndex] < pArr[trueMaxIndex])
;;;1234             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1235   
;;;1236           if(pArr[trueMinIndex] < pArr[midIndex])
;;;1237             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1238   
;;;1239           // Search from the beginning to before the moved pivot
;;;1240           s32 i = trueMinIndex;
;;;1241           s32 j = trueMaxIndex - 2;
;;;1242   
;;;1243           if(i >= j) {
;;;1244             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1245             // NOTE: This really means your insertionSortSize value is too low
;;;1246             return;
;;;1247           }
;;;1248   
;;;1249           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1250   
;;;1251           const Type pivot = pArr[midIndex];
;;;1252   
;;;1253           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1254   
;;;1255           // Main partitioning loop
;;;1256           while(true) {
;;;1257             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1258             while(pArr[i] > pivot) {
;;;1259               i++;
;;;1260             }
;;;1261   
;;;1262             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1263             while(pArr[j] < pivot) {
;;;1264               j--;
;;;1265             }
;;;1266   
;;;1267             if(i < j) {
;;;1268               Swap<Type>(pArr[i], pArr[j]);
;;;1269               i++;
;;;1270               j--;
;;;1271             } else {
;;;1272               break;
;;;1273             }
;;;1274           }
;;;1275   
;;;1276           // Replace the pivot
;;;1277           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1278   
;;;1279           // Recurse
;;;1280           QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1281   
;;;1282           QuickSort_sortDescendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1283         } // QuickSort_sortDescendingDimension1
;;;1284   
;;;1285         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1286         {
;;;1287           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1288             return;
;;;1289           }
;;;1290   
;;;1291           // Select the median value of the first, middle, and last elements as the pivot
;;;1292           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1293   
;;;1294           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1295   
;;;1296           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1297             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1298             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1299           }
;;;1300   
;;;1301           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1302             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1303             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1304           }
;;;1305   
;;;1306           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1307             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1308             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(midIndex, x));
;;;1309           }
;;;1310   
;;;1311           // Search from the beginning to before the moved pivot
;;;1312           s32 i = trueMinIndex;
;;;1313           s32 j = trueMaxIndex - 2;
;;;1314   
;;;1315           if(i >= j) {
;;;1316             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1317             // NOTE: This really means your insertionSortSize value is too low
;;;1318             return;
;;;1319           }
;;;1320   
;;;1321           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1322   
;;;1323           const Type pivot = *arr.Pointer(midIndex, x);
;;;1324   
;;;1325           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1326           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1327   
;;;1328           // Main partitioning loop
;;;1329           while(true) {
;;;1330             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1331             while(*arr.Pointer(i,x) < pivot) {
;;;1332               i++;
;;;1333             }
;;;1334   
;;;1335             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1336             while(*arr.Pointer(j,x) > pivot) {
;;;1337               j--;
;;;1338             }
;;;1339   
;;;1340             if(i < j) {
;;;1341               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1342               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1343               i++;
;;;1344               j--;
;;;1345             } else {
;;;1346               break;
;;;1347             }
;;;1348           }
;;;1349   
;;;1350           // Replace the pivot
;;;1351           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1352           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1353   
;;;1354           // Recurse
;;;1355           QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1356   
;;;1357           QuickSort_sortAscendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1358         } // QuickSort_sortAscendingDimension0
;;;1359   
;;;1360         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1361         {
;;;1362           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1363             return;
;;;1364           }
;;;1365   
;;;1366           // Select the median value of the first, middle, and last elements as the pivot
;;;1367           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1368   
;;;1369           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1370   
;;;1371           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1372             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1373             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1374           }
;;;1375   
;;;1376           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1377             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1378             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1379           }
;;;1380   
;;;1381           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1382             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1383             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(midIndex, x));
;;;1384           }
;;;1385   
;;;1386           // Search from the beginning to before the moved pivot
;;;1387           s32 i = trueMinIndex;
;;;1388           s32 j = trueMaxIndex - 2;
;;;1389   
;;;1390           if(i >= j) {
;;;1391             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1392             // NOTE: This really means your insertionSortSize value is too low
;;;1393             return;
;;;1394           }
;;;1395   
;;;1396           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1397   
;;;1398           const Type pivot = *arr.Pointer(midIndex, x);
;;;1399   
;;;1400           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1401           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1402   
;;;1403           // Main partitioning loop
;;;1404           while(true) {
;;;1405             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1406             while(*arr.Pointer(i,x) > pivot) {
;;;1407               i++;
;;;1408             }
;;;1409   
;;;1410             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1411             while(*arr.Pointer(j,x) < pivot) {
;;;1412               j--;
;;;1413             }
;;;1414   
;;;1415             if(i < j) {
;;;1416               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1417               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1418               i++;
;;;1419               j--;
;;;1420             } else {
;;;1421               break;
;;;1422             }
;;;1423           }
;;;1424   
;;;1425           // Replace the pivot
;;;1426           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1427           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1428   
;;;1429           // Recurse
;;;1430           QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1431   
;;;1432           QuickSort_sortDescendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1433         } // QuickSort_sortDescendingDimension0
;;;1434   
;;;1435         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1436         {
;;;1437           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1438             return;
;;;1439           }
;;;1440   
;;;1441           Type * restrict pArr = arr.Pointer(y,0);
;;;1442           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1443   
;;;1444           // Select the median value of the first, middle, and last elements as the pivot
;;;1445           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1446   
;;;1447           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1448   
;;;1449           if(pArr[midIndex] < pArr[trueMinIndex]) {
;;;1450             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1451             Swap<s32>(pIndexes[midIndex], pIndexes[trueMinIndex]);
;;;1452           }
;;;1453   
;;;1454           if(pArr[trueMaxIndex] < pArr[trueMinIndex]) {
;;;1455             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1456             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[trueMinIndex]);
;;;1457           }
;;;1458   
;;;1459           if(pArr[trueMaxIndex] < pArr[midIndex]) {
;;;1460             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1461             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[midIndex]);
;;;1462           }
;;;1463   
;;;1464           // Search from the beginning to before the moved pivot
;;;1465           s32 i = trueMinIndex;
;;;1466           s32 j = trueMaxIndex - 2;
;;;1467   
;;;1468           if(i >= j) {
;;;1469             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1470             // NOTE: This really means your insertionSortSize value is too low
;;;1471             return;
;;;1472           }
;;;1473   
;;;1474           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1475   
;;;1476           const Type pivot = pArr[midIndex];
;;;1477   
;;;1478           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1479           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1480   
;;;1481           // Main partitioning loop
;;;1482           while(true) {
;;;1483             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1484             while(pArr[i] < pivot) {
;;;1485               i++;
;;;1486             }
;;;1487   
;;;1488             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1489             while(pArr[j] > pivot) {
;;;1490               j--;
;;;1491             }
;;;1492   
;;;1493             if(i < j) {
;;;1494               Swap<Type>(pArr[i], pArr[j]);
;;;1495               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1496               i++;
;;;1497               j--;
;;;1498             } else {
;;;1499               break;
;;;1500             }
;;;1501           }
;;;1502   
;;;1503           // Replace the pivot
;;;1504           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1505           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1506   
;;;1507           // Recurse
;;;1508           QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1509   
;;;1510           QuickSort_sortAscendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1511         } // QuickSort_sortAscendingDimension1
;;;1512   
;;;1513         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1514         {
;;;1515           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1516             return;
;;;1517           }
;;;1518   
;;;1519           Type * restrict pArr = arr.Pointer(y,0);
;;;1520           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1521   
;;;1522           // Select the median value of the first, middle, and last elements as the pivot
;;;1523           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1524   
;;;1525           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1526   
;;;1527           if(pArr[midIndex] < pArr[trueMaxIndex]) {
;;;1528             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1529             Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex]);
;;;1530           }
;;;1531   
;;;1532           if(pArr[trueMinIndex] < pArr[trueMaxIndex]) {
;;;1533             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1534             Swap<s32>(pIndexes[trueMinIndex], pIndexes[trueMaxIndex]);
;;;1535           }
;;;1536   
;;;1537           if(pArr[trueMinIndex] < pArr[midIndex]) {
;;;1538             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1539             Swap<s32>(pIndexes[trueMinIndex], pIndexes[midIndex]);
;;;1540           }
;;;1541   
;;;1542           // Search from the beginning to before the moved pivot
;;;1543           s32 i = trueMinIndex;
;;;1544           s32 j = trueMaxIndex - 2;
;;;1545   
;;;1546           if(i >= j) {
;;;1547             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1548             // NOTE: This really means your insertionSortSize value is too low
;;;1549             return;
;;;1550           }
;;;1551   
;;;1552           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1553   
;;;1554           const Type pivot = pArr[midIndex];
;;;1555   
;;;1556           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1557           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1558   
;;;1559           // Main partitioning loop
;;;1560           while(true) {
;;;1561             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1562             while(pArr[i] > pivot) {
;;;1563               i++;
;;;1564             }
;;;1565   
;;;1566             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1567             while(pArr[j] < pivot) {
;;;1568               j--;
;;;1569             }
;;;1570   
;;;1571             if(i < j) {
;;;1572               Swap<Type>(pArr[i], pArr[j]);
;;;1573               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1574               i++;
;;;1575               j--;
;;;1576             } else {
;;;1577               break;
;;;1578             }
;;;1579           }
;;;1580   
;;;1581           // Replace the pivot
;;;1582           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1583           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1584   
;;;1585           // Recurse
;;;1586           QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1587   
;;;1588           QuickSort_sortDescendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1589         } // QuickSort_sortDescendingDimension1
;;;1590   
;;;1591         template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1592         {
;;;1593           // const s32 arrHeight = arr.get_size(0);
;;;1594           // const s32 arrWidth = arr.get_size(1);
;;;1595   
;;;1596           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1597             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1598   
;;;1599           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1600             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1601   
;;;1602           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1603           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1604   
;;;1605           if(sortWhichDimension == 0) {
;;;1606             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1607             if(sortAscending) {
;;;1608               InsertionSort_sortAscendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1609             } else { // if(sortAscending)
;;;1610               InsertionSort_sortDescendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1611             } // if(sortAscending) ... else
;;;1612           } else { // sortWhichDimension == 1
;;;1613             if(sortAscending) {
;;;1614               InsertionSort_sortAscendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1615             } else { // if(sortAscending)
;;;1616               InsertionSort_sortDescendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1617             } // if(sortAscending) ... else
;;;1618           } // if(sortWhichDimension == 0) ... else
;;;1619   
;;;1620           return RESULT_OK;
;;;1621         } // InsertionSort()
;;;1622   
;;;1623         template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1624         {
;;;1625           const s32 arrHeight = arr.get_size(0);
;;;1626           const s32 arrWidth = arr.get_size(1);
;;;1627   
;;;1628           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1629             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1630   
;;;1631           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1632             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1633   
;;;1634           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1635             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1636   
;;;1637           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1638           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1639   
;;;1640           if(sortWhichDimension == 0) {
;;;1641             for(s32 y=0; y<arrHeight; y++) {
;;;1642               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1643               for(s32 x=0; x<arrWidth; x++) {
;;;1644                 pIndexes[x] = y;
;;;1645               }
;;;1646             }
;;;1647   
;;;1648             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1649             if(sortAscending) {
;;;1650               InsertionSort_sortAscendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1651             } else { // if(sortAscending)
;;;1652               InsertionSort_sortDescendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1653             } // if(sortAscending) ... else
;;;1654           } else { // sortWhichDimension == 1
;;;1655             for(s32 y=0; y<arrHeight; y++) {
;;;1656               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1657               for(s32 x=0; x<arrWidth; x++) {
;;;1658                 pIndexes[x] = x;
;;;1659               }
;;;1660             }
;;;1661   
;;;1662             if(sortAscending) {
;;;1663               InsertionSort_sortAscendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1664             } else { // if(sortAscending)
;;;1665               InsertionSort_sortDescendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1666             } // if(sortAscending) ... else
;;;1667           } // if(sortWhichDimension == 0) ... else
;;;1668   
;;;1669           return RESULT_OK;
;;;1670         } // InsertionSort()
;;;1671   
;;;1672         template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1673         {
;;;1674           const s32 arrHeight = arr.get_size(0);
;;;1675           const s32 arrWidth = arr.get_size(1);
;;;1676   
;;;1677           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1678             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1679   
;;;1680           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1681             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1682   
;;;1683           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1684             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1685   
;;;1686           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1687           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1688   
;;;1689           if(sortWhichDimension == 0) {
;;;1690             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1691             if(sortAscending) {
;;;1692               for(s32 x=0; x<arrWidth; x++) {
;;;1693                 QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1694               }
;;;1695   
;;;1696               if(insertionSortSize > 1)
;;;1697                 InsertionSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1698             } else { // if(sortAscending)
;;;1699               for(s32 x=0; x<arrWidth; x++) {
;;;1700                 QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1701               }
;;;1702   
;;;1703               if(insertionSortSize > 1)
;;;1704                 InsertionSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1705             } // if(sortAscending) ... else
;;;1706           } else { // sortWhichDimension == 1
;;;1707             if(sortAscending) {
;;;1708               for(s32 y=0; y<arrHeight; y++) {
;;;1709                 QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1710               }
;;;1711   
;;;1712               if(insertionSortSize > 1)
;;;1713                 InsertionSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1714             } else { // if(sortAscending)
;;;1715               for(s32 y=0; y<arrHeight; y++) {
;;;1716                 QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1717               }
;;;1718   
;;;1719               if(insertionSortSize > 1)
;;;1720                 InsertionSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1721             } // if(sortAscending) ... else
;;;1722           } // if(sortWhichDimension == 0) ... else
;;;1723   
;;;1724           return RESULT_OK;
;;;1725         } // QuickSort()
;;;1726   
;;;1727         template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1728         {
;;;1729           const s32 arrHeight = arr.get_size(0);
;;;1730           const s32 arrWidth = arr.get_size(1);
;;;1731   
;;;1732           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1733             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1734   
;;;1735           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1736             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1737   
;;;1738           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1739             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1740   
;;;1741           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1742             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1743   
;;;1744           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1745           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1746   
;;;1747           if(sortWhichDimension == 0) {
;;;1748             for(s32 y=0; y<arrHeight; y++) {
;;;1749               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1750               for(s32 x=0; x<arrWidth; x++) {
;;;1751                 pIndexes[x] = y;
;;;1752               }
;;;1753             }
;;;1754   
;;;1755             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1756             if(sortAscending) {
;;;1757               for(s32 x=0; x<arrWidth; x++) {
;;;1758                 QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1759               }
;;;1760   
;;;1761               if(insertionSortSize > 1)
;;;1762                 InsertionSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1763             } else { // if(sortAscending)
;;;1764               for(s32 x=0; x<arrWidth; x++) {
;;;1765                 QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1766               }
;;;1767   
;;;1768               if(insertionSortSize > 1)
;;;1769                 InsertionSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1770             } // if(sortAscending) ... else
;;;1771           } else { // sortWhichDimension == 1
;;;1772             for(s32 y=0; y<arrHeight; y++) {
;;;1773               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1774               for(s32 x=0; x<arrWidth; x++) {
;;;1775                 pIndexes[x] = x;
;;;1776               }
;;;1777             }
;;;1778   
;;;1779             if(sortAscending) {
;;;1780               for(s32 y=0; y<arrHeight; y++) {
;;;1781                 QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1782               }
;;;1783   
;;;1784               if(insertionSortSize > 1)
;;;1785                 InsertionSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1786             } else { // if(sortAscending)
;;;1787               for(s32 y=0; y<arrHeight; y++) {
;;;1788                 QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1789               }
;;;1790   
;;;1791               if(insertionSortSize > 1)
;;;1792                 InsertionSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1793             } // if(sortAscending) ... else
;;;1794           } // if(sortWhichDimension == 0) ... else
;;;1795   
;;;1796           return RESULT_OK;
;;;1797         } // QuickSort()
;;;1798   
;;;1799         template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1800         {
;;;1801           AnkiConditionalErrorAndReturnValue(arr.get_size(0) == arr.get_size(1),
;;;1802             RESULT_FAIL_INVALID_SIZE, "MakeSymmetric", "Input array must be square");
;;;1803   
;;;1804           const s32 arrHeight = arr.get_size(0);
;;;1805           for(s32 y = 0; y < arrHeight; y++)
;;;1806           {
;;;1807             const s32 x0 = lowerToUpper ? (y+1)     : 0;
;;;1808             const s32 x1 = lowerToUpper ? arrHeight : y;
;;;1809   
;;;1810             for(s32 x = x0; x < x1; x++) {
;;;1811               *arr.Pointer(y,x) = *arr.Pointer(x,y);
;;;1812             }
;;;1813           }
;;;1814   
;;;1815           return RESULT_OK;
;;;1816         } // template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1817   
;;;1818         namespace Elementwise
;;;1819         {
;;;1820           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1821           {
;;;1822             const Array<InType> &in1Array = in1.get_array();
;;;1823             const Array<InType> &in2Array = in2.get_array();
;;;1824             Array<OutType> &out1Array = out.get_array();
;;;1825   
;;;1826             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, in2Array, out1Array),
;;;1827               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1828   
;;;1829             ArraySliceLimits_in2_out1<s32> limits(
;;;1830               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1831               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1832               out.get_ySlice(), out.get_xSlice());
;;;1833   
;;;1834             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1835               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1836   
;;;1837             if(limits.isSimpleIteration) {
;;;1838               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1839   
;;;1840               for(s32 y=0; y<limits.ySize; y++) {
;;;1841                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1842                 const InType * const pIn2 = in2Array.Pointer(limits.in2Y, 0);
;;;1843                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1844   
;;;1845                 limits.OuterIncrementTop();
;;;1846   
;;;1847                 for(s32 x=0; x<limits.xSize; x++) {
;;;1848                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], pIn2[limits.in2X]);
;;;1849   
;;;1850                   limits.in1X += limits.in1_xInnerIncrement;
;;;1851                   limits.in2X += limits.in2_xInnerIncrement;
;;;1852                   limits.out1X += limits.out1_xInnerIncrement;
;;;1853                 }
;;;1854   
;;;1855                 limits.OuterIncrementBottom();
;;;1856               }
;;;1857             } else { // if(limits.isSimpleIteration)
;;;1858               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1859   
;;;1860               for(s32 y=0; y<limits.ySize; y++) {
;;;1861                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1862   
;;;1863                 limits.OuterIncrementTop();
;;;1864   
;;;1865                 for(s32 x=0; x<limits.xSize; x++) {
;;;1866                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1867                   const InType valIn2 = *in2Array.Pointer(limits.in2Y, limits.in2X);
;;;1868   
;;;1869                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, valIn2);
;;;1870   
;;;1871                   limits.in1X += limits.in1_xInnerIncrement;
;;;1872                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1873                   limits.in2X += limits.in2_xInnerIncrement;
;;;1874                   limits.in2Y += limits.in2_yInnerIncrement;
;;;1875                   limits.out1X += limits.out1_xInnerIncrement;
;;;1876                 }
;;;1877   
;;;1878                 limits.OuterIncrementBottom();
;;;1879               }
;;;1880             } //   if(limits.isSimpleIteration)  ... else
;;;1881   
;;;1882             return RESULT_OK;
;;;1883           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1884   
;;;1885           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1886           {
;;;1887             const Array<InType> &in1Array = in1.get_array();
;;;1888             Array<OutType> &out1Array = out.get_array();
;;;1889   
;;;1890             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, out1Array),
;;;1891               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1892   
;;;1893             ArraySliceLimits_in1_out1<s32> limits(
;;;1894               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1895               out.get_ySlice(), out.get_xSlice());
;;;1896   
;;;1897             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1898               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1899   
;;;1900             if(limits.isSimpleIteration) {
;;;1901               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1902   
;;;1903               for(s32 y=0; y<limits.ySize; y++) {
;;;1904                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1905                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1906   
;;;1907                 limits.OuterIncrementTop();
;;;1908   
;;;1909                 for(s32 x=0; x<limits.xSize; x++) {
;;;1910                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], value2);
;;;1911   
;;;1912                   limits.in1X += limits.in1_xInnerIncrement;
;;;1913                   limits.out1X += limits.out1_xInnerIncrement;
;;;1914                 }
;;;1915   
;;;1916                 limits.OuterIncrementBottom();
;;;1917               }
;;;1918             } else { // if(limits.isSimpleIteration)
;;;1919               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1920   
;;;1921               for(s32 y=0; y<limits.ySize; y++) {
;;;1922                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1923   
;;;1924                 limits.OuterIncrementTop();
;;;1925   
;;;1926                 for(s32 x=0; x<limits.xSize; x++) {
;;;1927                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1928   
;;;1929                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, value2);
;;;1930   
;;;1931                   limits.in1X += limits.in1_xInnerIncrement;
;;;1932                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1933                   limits.out1X += limits.out1_xInnerIncrement;
;;;1934                 }
;;;1935   
;;;1936                 limits.OuterIncrementBottom();
;;;1937               }
;;;1938             } //   if(limits.isSimpleIteration)  ... else
;;;1939   
;;;1940             return RESULT_OK;
;;;1941           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1942   
;;;1943           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1944           {
;;;1945             const Array<InType> &in2Array = in2.get_array();
;;;1946             Array<OutType> &out1Array = out.get_array();
;;;1947   
;;;1948             AnkiConditionalErrorAndReturnValue(AreValid(in2Array, out1Array),
;;;1949               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1950   
;;;1951             ArraySliceLimits_in1_out1<s32> limits(
;;;1952               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1953               out.get_ySlice(), out.get_xSlice());
;;;1954   
;;;1955             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1956               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1957   
;;;1958             if(limits.isSimpleIteration) {
;;;1959               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1960   
;;;1961               for(s32 y=0; y<limits.ySize; y++) {
;;;1962                 const InType * const pIn2 = in2Array.Pointer(limits.in1Y, 0);
;;;1963                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1964   
;;;1965                 limits.OuterIncrementTop();
;;;1966   
;;;1967                 for(s32 x=0; x<limits.xSize; x++) {
;;;1968                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, pIn2[limits.in1X]);
;;;1969   
;;;1970                   limits.in1X += limits.in1_xInnerIncrement;
;;;1971                   limits.out1X += limits.out1_xInnerIncrement;
;;;1972                 }
;;;1973   
;;;1974                 limits.OuterIncrementBottom();
;;;1975               }
;;;1976             } else { // if(limits.isSimpleIteration)
;;;1977               // If either input is transposed, then we will do an inefficent loop iteration
;;;1978   
;;;1979               for(s32 y=0; y<limits.ySize; y++) {
;;;1980                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1981   
;;;1982                 limits.OuterIncrementTop();
;;;1983   
;;;1984                 for(s32 x=0; x<limits.xSize; x++) {
;;;1985                   const InType valIn2 = *in2Array.Pointer(limits.in1Y, limits.in1X);
;;;1986   
;;;1987                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, valIn2);
;;;1988   
;;;1989                   limits.in1X += limits.in1_xInnerIncrement;
;;;1990                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1991                   limits.out1X += limits.out1_xInnerIncrement;
;;;1992                 }
;;;1993   
;;;1994                 limits.OuterIncrementBottom();
;;;1995               }
;;;1996             } //   if(limits.isSimpleIteration)  ... else
;;;1997   
;;;1998             return RESULT_OK;
;;;1999           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;2000         } // namespace Elementwise
;;;2001       } // namespace Matrix
;;;2002     } // namespace Embedded
;;;2003   } // namespace Anki
;;;2004   
;;;2005   #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;19     
;;;20     #include "anki/common/shared/utilities_shared.h"
;;;1      /**
;;;2      File: utilities_shared.h
;;;3      Author: Kevin Yoon
;;;4      Created: 2014
;;;5      
;;;6      Copyright Anki, Inc. 2014
;;;7      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;8      **/
;;;9      
;;;10     #ifndef _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;11     #define _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;12     
;;;13     #include <stdarg.h>
;;;1      /* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
;;;14     
;;;15     namespace Anki
;;;16     {
;;;17       // For printing throughout Coretech libraries.
;;;18       // Calls printf() by default, but can be made to use an externally
;;;19       // defined function via SetCoreTechPrintFunctionPtr().
;;;20       int CoreTechPrint(const char * format, ...);
;;;21       int CoreTechPrint(const char * format, va_list argList);
;;;22     
;;;23       // Sets the function pointer that CoreTechPrint() uses.
;;;24       // Convenient for on-robot print which could be more complex
;;;25       // than just printf().
;;;26       void SetCoreTechPrintFunctionPtr( int (*fp)(const char * format, va_list) );
;;;27     } // namespace Anki
;;;28     
;;;29     #endif // _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26     #if 0
;;;27     #pragma mark --- 2D Point Implementations ---
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
;;;34         template<typename Type> Point<Type>::Point(const Type x, const Type y)
;;;35           : x(x), y(y)
;;;36         {
;;;37         }
;;;38     
;;;39         template<typename Type> Point<Type>::Point(const Point<Type>& pt)
;;;40           : x(pt.x), y(pt.y)
;;;41         {
;;;42         }
;;;43     
;;;44     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;45         template<typename Type> Point<Type>::Point(const cv::Point_<Type>& pt)
;;;46           : x(pt.x), y(pt.y)
;;;47         {
;;;48         }
;;;49     #endif
;;;50     
;;;51     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;52         template<typename Type> cv::Point_<Type> Point<Type>::get_CvPoint_() const
;;;53         {
;;;54           return cv::Point_<Type>(x,y);
;;;55         }
;;;56     #endif
;;;57     
;;;58         template<typename Type> template<typename InType> void Point<Type>::SetCast(const Point<InType> &in)
;;;59         {
;;;60           this->x = saturate_cast<Type>(in.x);
;;;61           this->y = saturate_cast<Type>(in.y);
;;;62         }
;;;63     
;;;64         template<typename Type> void Point<Type>::Print() const
;;;65         {
;;;66           CoreTechPrint("(%d,%d) ", this->x, this->y);
;;;67         }
;;;68     
;;;69         template<typename Type> bool Point<Type>::operator== (const Point<Type> &point2) const
;;;70         {
;;;71           if(this->x == point2.x && this->y == point2.y)
;;;72             return true;
;;;73     
;;;74           return false;
;;;75         }
;;;76     
;;;77         template<typename Type> Point<Type> Point<Type>::operator+ (const Point<Type> &point2) const
;;;78         {
;;;79           return Point<Type>(this->x+point2.x, this->y+point2.y);
;;;80         }
;;;81     
;;;82         template<typename Type> Point<Type> Point<Type>::operator- (const Point<Type> &point2) const
;;;83         {
;;;84           return Point<Type>(this->x-point2.x, this->y-point2.y);
;;;85         }
;;;86     
;;;87         template<typename Type> Point<Type> Point<Type>::operator- () const
;;;88         {
;;;89           return Point<Type>(-this->x, -this->y);
;;;90         }
;;;91     
;;;92         template<typename Type> Point<Type>& Point<Type>::operator*= (const Type value)
;;;93         {
;;;94           this->x *= value;
;;;95           this->y *= value;
;;;96           return *this;
;;;97         }
;;;98     
;;;99         template<typename Type> Point<Type>& Point<Type>::operator-= (const Type value)
;;;100        {
;;;101          this->x -= value;
;;;102          this->y -= value;
;;;103          return *this;
;;;104        }
;;;105    
;;;106        template<typename Type> Point<Type>& Point<Type>::operator+= (const Point<Type> &point2)
;;;107        {
;;;108          this->x += point2.x;
;;;109          this->y += point2.y;
;;;110          return *this;
;;;111        }
;;;112    
;;;113        template<typename Type> Point<Type>& Point<Type>::operator-= (const Point<Type> &point2)
;;;114        {
;;;115          this->x -= point2.x;
;;;116          this->y -= point2.y;
;;;117          return *this;
;;;118        }
;;;119    
;;;120        template<typename Type> inline Point<Type>& Point<Type>::operator= (const Point<Type> &point2)
;;;121        {
;;;122          this->x = point2.x;
;;;123          this->y = point2.y;
;;;124    
;;;125          return *this;
;;;126        }
;;;127    
;;;128        template<typename Type> f32 Point<Type>::Dist(const Point<Type> &point2) const
;;;129        {
;;;130          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) + (this->y - point2.y)*(this->y - point2.y));
;;;131        }
;;;132    
;;;133        template<typename Type> f32 Point<Type>::Length() const
;;;134        {
;;;135          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y)));
;;;136        }
;;;137    
;;;138        // #pragma mark --- Point Specializations ---
;;;139        template<> void Point<f32>::Print() const;
;;;140        template<> void Point<f64>::Print() const;
;;;141    
;;;142    #if 0
;;;143    #pragma mark --- 3D Point Implementations ---
;;;144    #endif
;;;145    
;;;146        template<typename Type> Point3<Type>::Point3()
;;;147          : x(static_cast<Type>(0)), y(static_cast<Type>(0)), z(static_cast<Type>(0))
;;;148        {
;;;149        }
;;;150    
;;;151        template<typename Type> Point3<Type>::Point3(const Type x, const Type y, const Type z)
;;;152          : x(x), y(y), z(z)
;;;153        {
;;;154        }
;;;155    
;;;156        template<typename Type> Point3<Type>::Point3(const Point3<Type>& pt)
;;;157          : x(pt.x), y(pt.y), z(pt.z)
;;;158        {
;;;159        }
;;;160    
;;;161    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;162        template<typename Type> Point3<Type>::Point3(const cv::Point3_<Type>& pt)
;;;163          : x(pt.x), y(pt.y), z(pt.z)
;;;164        {
;;;165        }
;;;166    #endif
;;;167    
;;;168    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;169        template<typename Type> cv::Point3_<Type> Point3<Type>::get_CvPoint_() const
;;;170        {
;;;171          return cv::Point3_<Type>(x,y,z);
;;;172        }
;;;173    #endif
;;;174    
;;;175        template<typename Type> void Point3<Type>::Print() const
;;;176        {
;;;177          CoreTechPrint("(%d,%d,%d) ", this->x, this->y, this->z);
;;;178        }
;;;179    
;;;180        template<typename Type> bool Point3<Type>::operator== (const Point3<Type> &point2) const
;;;181        {
;;;182          if(this->x == point2.x && this->y == point2.y && this->z == point2.z)
;;;183            return true;
;;;184    
;;;185          return false;
;;;186        }
;;;187    
;;;188        template<typename Type> Point3<Type> Point3<Type>::operator+ (const Point3<Type> &point2) const
;;;189        {
;;;190          return Point3<Type>(this->x+point2.x, this->y+point2.y, this->z+point2.z);
;;;191        }
;;;192    
;;;193        template<typename Type> Point3<Type> Point3<Type>::operator- (const Point3<Type> &point2) const
;;;194        {
;;;195          return Point3<Type>(this->x-point2.x, this->y-point2.y, this->z-point2.z);
;;;196        }
;;;197    
;;;198        template<typename Type> Point3<Type> Point3<Type>::operator- () const
;;;199        {
;;;200          return Point3<Type>(-this->x, -this->y, -this->z);
;;;201        }
;;;202    
;;;203        template<typename Type> Point3<Type>& Point3<Type>::operator*= (const Type value)
;;;204        {
;;;205          this->x *= value;
;;;206          this->y *= value;
;;;207          this->z *= value;
;;;208          return *this;
;;;209        }
;;;210    
;;;211        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Type value)
;;;212        {
;;;213          this->x -= value;
;;;214          this->y -= value;
;;;215          this->z -= value;
;;;216          return *this;
;;;217        }
;;;218    
;;;219        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Point3<Type> &point2)
;;;220        {
;;;221          this->x -= point2.x;
;;;222          this->y -= point2.y;
;;;223          this->z -= point2.z;
;;;224          return *this;
;;;225        }
;;;226    
;;;227        template<typename Type> inline Point3<Type>& Point3<Type>::operator= (const Point3<Type> &point2)
;;;228        {
;;;229          this->x = point2.x;
;;;230          this->y = point2.y;
;;;231          this->z = point2.z;
;;;232          return *this;
;;;233        }
;;;234    
;;;235        template<typename Type> f32 Point3<Type>::Dist(const Point3<Type> &point2) const
;;;236        {
;;;237          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) +
;;;238            (this->y - point2.y)*(this->y - point2.y) +
;;;239            (this->z - point2.z)*(this->z - point2.z));
;;;240        }
;;;241    
;;;242        template<typename Type> f32 Point3<Type>::Length() const
;;;243        {
;;;244          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y) + (this->z*this->z)));
;;;245        }
;;;246    
;;;247        template<typename Type> f32 Point3<Type>::MakeUnitLength()
;;;248        {
;;;249          const f32 L = this->Length();
;;;250          if(L != 0) {
;;;251            this->operator*=(1.f / L);
;;;252          }
;;;253          return L;
;;;254        }
;;;255    
;;;256        template<typename Type>
;;;257        Type DotProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;258        {
;;;259          return (point1.x*point2.x) + (point1.y*point2.y) + (point1.z*point2.z);
;;;260        }
;;;261    
;;;262        template<typename Type>
;;;263        Point3<Type> CrossProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;264        {
;;;265          return Point3<Type>(-point2.y*point1.z + point1.y*point2.z,
;;;266            point2.x*point1.z - point1.x*point2.z,
;;;267            -point2.x*point1.y + point1.x*point2.y);
;;;268        }
;;;269    
;;;270        template<typename Type>
;;;271        Point3<Type> operator* (const Array<Type>& M, const Point3<Type>& p)
;;;272        {
;;;273          // Matrix M must be 3x3
;;;274          AnkiAssert(AreEqualSize(3, 3, M));
;;;275    
;;;276          return Point3<Type>(M[0][0]*p.x + M[0][1]*p.y + M[0][2]*p.z,
;;;277            M[1][0]*p.x + M[1][1]*p.y + M[1][2]*p.z,
;;;278            M[2][0]*p.x + M[2][1]*p.y + M[2][2]*p.z);
;;;279        }
;;;280    
;;;281        // #pragma mark --- Point Specializations ---
;;;282        template<> void Point3<f32>::Print() const;
;;;283        template<> void Point3<f64>::Print() const;
;;;284    
;;;285    #if 0
;;;286    #pragma mark --- Pose Implementations ---
;;;287    #endif
;;;288    
;;;289        template<typename Type>
;;;290        Result ComputePoseDiff(const Array<Type>& R1, const Point3<Type>& T1,
;;;291          const Array<Type>& R2, const Point3<Type>& T2,
;;;292          Array<Type>& Rdiff, Point3<Type>& Tdiff,
;;;293          MemoryStack scratch)
;;;294        {
;;;295          // All the rotation matrices should be 3x3
;;;296          AnkiAssert(AreEqualSize(3, 3, R1));
;;;297          AnkiAssert(AreEqualSize(3, 3, R2));
;;;298          AnkiAssert(AreEqualSize(3, 3, Rdiff));
;;;299    
;;;300          Array<Type> invR1 = Array<Type>(3,3,scratch);
;;;301          Matrix::Transpose(R1, invR1);
;;;302    
;;;303          Matrix::Multiply(invR1, R2, Rdiff);
;;;304          Tdiff = invR1 * (T2 - T1);
;;;305    
;;;306          return RESULT_OK;
;;;307        }
;;;308    
;;;309    #if 0
;;;310    #pragma mark --- Rectangle Implementations ---
;;;311    #endif
;;;312    
;;;313        template<typename Type> Rectangle<Type>::Rectangle()
;;;314          : left(static_cast<Type>(0)), right(static_cast<Type>(0)), top(static_cast<Type>(0)), bottom(static_cast<Type>(0))
;;;315        {
;;;316        }
;;;317    
;;;318        template<typename Type> Rectangle<Type>::Rectangle(const Type left, const Type right, const Type top, const Type bottom)
;;;319          : left(left), right(right), top(top), bottom(bottom)
;;;320        {
;;;321        }
;;;322    
;;;323        template<typename Type> Rectangle<Type>::Rectangle(const Rectangle<Type>& rect)
;;;324          : left(rect.left), right(rect.right), top(rect.top), bottom(rect.bottom)
;;;325        {
;;;326        }
;;;327    
;;;328        template<typename Type> void Rectangle<Type>::Print() const
;;;329        {
;;;330          CoreTechPrint("(%d,%d)->(%d,%d) ", this->left, this->top, this->right, this->bottom);
;;;331        }
;;;332    
;;;333        template<typename Type> template<typename OutType> Point<OutType> Rectangle<Type>::ComputeCenter() const
;;;334        {
;;;335          Point<OutType> center(
;;;336            (static_cast<OutType>(this->left) + static_cast<OutType>(this->right)) / 2,
;;;337            (static_cast<OutType>(this->top) + static_cast<OutType>(this->bottom)) / 2);
;;;338    
;;;339          return center;
;;;340        }
;;;341    
;;;342        template<typename Type> template<typename OutType> Rectangle<OutType> Rectangle<Type>::ComputeScaledRectangle(const f32 scalePercent) const
;;;343        {
;;;344          const f32 width = static_cast<f32>(this->get_width());
;;;345          const f32 height = static_cast<f32>(this->get_height());
;;;346    
;;;347          const f32 scaledWidth = width * scalePercent;
;;;348          const f32 scaledHeight = height * scalePercent;
;;;349    
;;;350          const f32 dx2 = (scaledWidth - width) / 2.0f;
;;;351          const f32 dy2 = (scaledHeight - height) / 2.0f;
;;;352    
;;;353          Rectangle<OutType> scaledRect(
;;;354            static_cast<OutType>( static_cast<f32>(this->left)   - dx2 ),
;;;355            static_cast<OutType>( static_cast<f32>(this->right)  + dx2 ),
;;;356            static_cast<OutType>( static_cast<f32>(this->top)    - dy2 ),
;;;357            static_cast<OutType>( static_cast<f32>(this->bottom) + dy2 ));
;;;358    
;;;359          return scaledRect;
;;;360        }
;;;361    
;;;362        template<typename Type> bool Rectangle<Type>::operator== (const Rectangle<Type> &rectangle2) const
;;;363        {
;;;364          if(this->left == rectangle2.left && this->top == rectangle2.top && this->right == rectangle2.right && this->bottom == rectangle2.bottom)
;;;365            return true;
;;;366    
;;;367          return false;
;;;368        }
;;;369    
;;;370        template<typename Type> Rectangle<Type> Rectangle<Type>::operator+ (const Rectangle<Type> &rectangle2) const
;;;371        {
;;;372          return Rectangle<Type>(this->top+rectangle2.top, this->bottom+rectangle2.bottom, this->left+rectangle2.left, this->right+rectangle2.right);
;;;373        }
;;;374    
;;;375        template<typename Type> Rectangle<Type> Rectangle<Type>::operator- (const Rectangle<Type> &rectangle2) const
;;;376        {
;;;377          return Rectangle<Type>(this->top-rectangle2.top, this->bottom-rectangle2.bottom, this->left-rectangle2.left, this->right-rectangle2.right);
;;;378        }
;;;379    
;;;380        template<typename Type> inline Rectangle<Type>& Rectangle<Type>::operator= (const Rectangle<Type> &rect2)
;;;381        {
;;;382          this->left = rect2.left;
;;;383          this->right = rect2.right;
;;;384          this->top = rect2.top;
;;;385          this->bottom = rect2.bottom;
;;;386    
;;;387          return *this;
;;;388        }
;;;389    
;;;390        template<typename Type> Type Rectangle<Type>::get_width() const
;;;391        {
;;;392          return right - left;
;;;393        }
;;;394    
;;;395        template<typename Type> Type Rectangle<Type>::get_height() const
;;;396        {
;;;397          return bottom - top;
;;;398        }
;;;399    
;;;400        // #pragma mark --- Rectangle Specializations ---
;;;401        template<> void Rectangle<f32>::Print() const;
;;;402        template<> void Rectangle<f64>::Print() const;
;;;403    
;;;404        // #pragma mark --- Quadrilateral Definitions ---
;;;405    
;;;406        template<typename Type> Quadrilateral<Type>::Quadrilateral()
;;;407        {
;;;408          for(s32 i=0; i<4; i++) {
;;;409            corners[i] = Point<Type>();
;;;410          }
;;;411        }
;;;412    
;;;413        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Point<Type> &corner1, const Point<Type> &corner2, const Point<Type> &corner3, const Point<Type> &corner4)
;;;414        {
;;;415          corners[0] = corner1;
;;;416          corners[1] = corner2;
;;;417          corners[2] = corner3;
;;;418          corners[3] = corner4;
;;;419        }
;;;420    
;;;421        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Quadrilateral<Type>& quad2)
;;;422        {
;;;423          for(s32 i=0; i<4; i++) {
;;;424            this->corners[i] = quad2.corners[i];
;;;425          }
;;;426        }
;;;427    
;;;428        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Rectangle<Type>& rect)
;;;429        {
;;;430          this->corners[0].x = rect.left;   this->corners[0].y = rect.top;
;;;431          this->corners[1].x = rect.right;  this->corners[1].y = rect.top;
;;;432          this->corners[2].x = rect.left;   this->corners[2].y = rect.bottom;
;;;433          this->corners[3].x = rect.right;  this->corners[3].y = rect.bottom;
;;;434        }
;;;435    
;;;436        template<typename Type> void Quadrilateral<Type>::Print() const
;;;437        {
;;;438          CoreTechPrint("{(%d,%d), (%d,%d), (%d,%d), (%d,%d)} ",
;;;439            this->corners[0].x, this->corners[0].y,
;;;440            this->corners[1].x, this->corners[1].y,
;;;441            this->corners[2].x, this->corners[2].y,
;;;442            this->corners[3].x, this->corners[3].y);
;;;443        }
;;;444    
;;;445        template<typename Type> template<typename OutType> Point<OutType> Quadrilateral<Type>::ComputeCenter() const
;;;446        {
;;;447          Point<OutType> center(0, 0);
;;;448    
;;;449          for(s32 i=0; i<4; i++) {
;;;450            center.x += static_cast<OutType>(this->corners[i].x);
;;;451            center.y += static_cast<OutType>(this->corners[i].y);
;;;452          }
;;;453    
;;;454          center.x /= 4;
;;;455          center.y /= 4;
;;;456    
;;;457          return center;
;;;458        }
;;;459    
                          ENDP

000056  0000              DCW      0x0000
                  |L257.88|
000058  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.258||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE13ComputeCenterIfEENS0_5PointIT_EEv, LINKORDER=||t._ZNK4Anki8Embedded13QuadrilateralIfE13ComputeCenterIfEENS0_5PointIT_EEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.258||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded13QuadrilateralIfE13ComputeCenterIfEENS0_5PointIT_EEv||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded13QuadrilateralIfE8IsConvexEv||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE8IsConvexEv, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded13QuadrilateralIfE8IsConvexEv PROC ; Anki::Embedded::Quadrilateral<float>::IsConvex() const
;;;540    
;;;541        template<typename Type> bool Quadrilateral<Type>::IsConvex() const
000000  b5f0              PUSH     {r4-r7,lr}
;;;542        {
000002  4605              MOV      r5,r0
000004  ed2d8b04          VPUSH    {d8-d9}
000008  b0c9              SUB      sp,sp,#0x124
00000a  2201              MOVS     r2,#1
;;;543          Quadrilateral<Type> sortedQuad = this->ComputeClockwiseCorners<Type>();
00000c  af02              ADD      r7,sp,#8
00000e  2300              MOVS     r3,#0
000010  4611              MOV      r1,r2
000012  a83b              ADD      r0,sp,#0xec
000014  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000018  6803              LDR      r3,[r0,#0]
00001a  2280              MOVS     r2,#0x80
00001c  a90a              ADD      r1,sp,#0x28
00001e  a82a              ADD      r0,sp,#0xa8
000020  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
000024  2300              MOVS     r3,#0
000026  461a              MOV      r2,r3
000028  2101              MOVS     r1,#1
00002a  a846              ADD      r0,sp,#0x118
00002c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000030  6800              LDR      r0,[r0,#0]
000032  9000              STR      r0,[sp,#0]
000034  ab2a              ADD      r3,sp,#0xa8
000036  2204              MOVS     r2,#4
000038  2101              MOVS     r1,#1
00003a  a831              ADD      r0,sp,#0xc4
00003c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000040  2300              MOVS     r3,#0
000042  461a              MOV      r2,r3
000044  2101              MOVS     r1,#1
000046  a847              ADD      r0,sp,#0x11c
000048  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00004c  6800              LDR      r0,[r0,#0]
00004e  9000              STR      r0,[sp,#0]
000050  ab2a              ADD      r3,sp,#0xa8
000052  2204              MOVS     r2,#4
000054  2101              MOVS     r1,#1
000056  a836              ADD      r0,sp,#0xd8
000058  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00005c  4629              MOV      r1,r5
00005e  a83c              ADD      r0,sp,#0xf0
000060  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE13ComputeCenterIfEENS0_5PointIT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeCenter<float>() const
000064  2400              MOVS     r4,#0
000066  ed9f9a65          VLDR     s18,|L264.508|
                  |L264.106|
00006a  eb0500c4          ADD      r0,r5,r4,LSL #3
00006e  eddd0a3c          VLDR     s1,[sp,#0xf0]
000072  ed900a00          VLDR     s0,[r0,#0]
000076  9a33              LDR      r2,[sp,#0xcc]
000078  9935              LDR      r1,[sp,#0xd4]
00007a  ee708a60          VSUB.F32 s17,s0,s1
00007e  ed900a01          VLDR     s0,[r0,#4]
000082  eddd0a3d          VLDR     s1,[sp,#0xf4]
000086  2000              MOVS     r0,#0
000088  eef58ac0          VCMPE.F32 s17,#0.0
00008c  ee308a60          VSUB.F32 s16,s0,s1
000090  fb001002          MLA      r0,r0,r2,r1
000094  eef1fa10          VMRS     APSR_nzcv,FPSCR
000098  eb000684          ADD      r6,r0,r4,LSL #2
00009c  bf02              ITTT     EQ
00009e  eeb58ac0          VCMPEEQ.F32 s16,#0.0
0000a2  eef1fa10          VMRSEQ   APSR_nzcv,FPSCR
0000a6  ed869a00          VSTREQ   s18,[r6,#0]
0000aa  d016              BEQ      |L264.218|
0000ac  eef00a68          VMOV.F32 s1,s17
0000b0  eeb00a48          VMOV.F32 s0,s16
0000b4  f7fffffe          BL       __hardfp_atan2f
0000b8  ee680aa8          VMUL.F32 s1,s17,s17
0000bc  ed860a00          VSTR     s0,[r6,#0]
0000c0  ee480a08          VMLA.F32 s1,s16,s16
0000c4  eeb10ae0          VSQRT.F32 s0,s1
0000c8  eeb40a40          VCMP.F32 s0,s0
0000cc  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000d0  bf1c              ITT      NE
0000d2  eeb00a60          VMOVNE.F32 s0,s1
0000d6  f7fffffe          BLNE     __hardfp_sqrtf
                  |L264.218|
0000da  1c64              ADDS     r4,r4,#1
0000dc  2c04              CMP      r4,#4
0000de  dbc4              BLT      |L264.106|
0000e0  4847              LDR      r0,|L264.512|
0000e2  2400              MOVS     r4,#0
0000e4  e9cd4000          STRD     r4,r0,[sp,#0]
0000e8  2301              MOVS     r3,#1
0000ea  461a              MOV      r2,r3
0000ec  a936              ADD      r1,sp,#0xd8
0000ee  a831              ADD      r0,sp,#0xc4
0000f0  f7fffffe          BL       _ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)
0000f4  9938              LDR      r1,[sp,#0xe0]
0000f6  983a              LDR      r0,[sp,#0xe8]
0000f8  f50d7c88          ADD      r12,sp,#0x110
0000fc  fb040001          MLA      r0,r4,r1,r0
000100  ab42              ADD      r3,sp,#0x108
000102  68c1              LDR      r1,[r0,#0xc]
000104  aa40              ADD      r2,sp,#0x100
000106  eb0501c1          ADD      r1,r5,r1,LSL #3
00010a  ed910a00          VLDR     s0,[r1,#0]
00010e  edd10a01          VLDR     s1,[r1,#4]
000112  ed8d0a44          VSTR     s0,[sp,#0x110]
000116  edcd0a45          VSTR     s1,[sp,#0x114]
00011a  6881              LDR      r1,[r0,#8]
00011c  eb0501c1          ADD      r1,r5,r1,LSL #3
000120  ed910a00          VLDR     s0,[r1,#0]
000124  edd10a01          VLDR     s1,[r1,#4]
000128  ed8d0a42          VSTR     s0,[sp,#0x108]
00012c  edcd0a43          VSTR     s1,[sp,#0x10c]
000130  6841              LDR      r1,[r0,#4]
000132  eb0501c1          ADD      r1,r5,r1,LSL #3
000136  ed910a00          VLDR     s0,[r1,#0]
00013a  edd10a01          VLDR     s1,[r1,#4]
00013e  ed8d0a40          VSTR     s0,[sp,#0x100]
000142  edcd0a41          VSTR     s1,[sp,#0x104]
000146  6800              LDR      r0,[r0,#0]
000148  a93e              ADD      r1,sp,#0xf8
00014a  eb0500c0          ADD      r0,r5,r0,LSL #3
00014e  ed900a00          VLDR     s0,[r0,#0]
000152  edd00a01          VLDR     s1,[r0,#4]
000156  ed8d0a3e          VSTR     s0,[sp,#0xf8]
00015a  edcd0a3f          VSTR     s1,[sp,#0xfc]
00015e  4638              MOV      r0,r7
000160  f8cdc000          STR      r12,[sp,#0]
000164  f7fffffe          BL       _ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_ ; Anki::Embedded::Quadrilateral<float>::Quadrilateral(const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&)
;;;544    
;;;545          for(s32 iCorner=0; iCorner<4; iCorner++) {
;;;546            const Point<Type> &corner1 = sortedQuad[iCorner];
;;;547            const Point<Type> &corner2 = sortedQuad[(iCorner+1) % 4];
;;;548            const Point<Type> &corner3 = sortedQuad[(iCorner+2) % 4];
;;;549    
;;;550            const Type orientation =
;;;551              ((corner2.y - corner1.y) * (corner3.x - corner2.x)) -
;;;552              ((corner2.x - corner1.x) * (corner3.y - corner2.y));
;;;553    
;;;554            if((orientation - static_cast<Type>(0.001)) > 0) {
000168  eddf1a26          VLDR     s3,|L264.516|
00016c  2000              MOVS     r0,#0                 ;545
                  |L264.366|
00016e  a902              ADD      r1,sp,#8              ;546
000170  eb0102c0          ADD      r2,r1,r0,LSL #3       ;546
000174  460b              MOV      r3,r1                 ;547
000176  1c41              ADDS     r1,r0,#1              ;547
000178  ea4f7ce1          ASR      r12,r1,#31            ;547
00017c  eb017c9c          ADD      r12,r1,r12,LSR #30    ;547
000180  f02c0c03          BIC      r12,r12,#3            ;547
000184  eba1010c          SUB      r1,r1,r12             ;547
000188  eb0303c1          ADD      r3,r3,r1,LSL #3       ;547
00018c  1c81              ADDS     r1,r0,#2              ;548
00018e  17cc              ASRS     r4,r1,#31             ;548
000190  eb017494          ADD      r4,r1,r4,LSR #30      ;548
000194  f0240403          BIC      r4,r4,#3              ;548
000198  ed930a01          VLDR     s0,[r3,#4]            ;550
00019c  edd20a01          VLDR     s1,[r2,#4]            ;550
0001a0  f10d0c08          ADD      r12,sp,#8             ;548
0001a4  1b09              SUBS     r1,r1,r4              ;548
0001a6  eb0c01c1          ADD      r1,r12,r1,LSL #3      ;548
0001aa  ee301a60          VSUB.F32 s2,s0,s1              ;550
0001ae  ed912a00          VLDR     s4,[r1,#0]            ;550
0001b2  edd30a00          VLDR     s1,[r3,#0]            ;550
0001b6  ee322a60          VSUB.F32 s4,s4,s1              ;550
0001ba  ee211a02          VMUL.F32 s2,s2,s4              ;550
0001be  ed922a00          VLDR     s4,[r2,#0]            ;550
0001c2  ee700ac2          VSUB.F32 s1,s1,s4              ;550
0001c6  ed912a01          VLDR     s4,[r1,#4]            ;550
0001ca  ee320a40          VSUB.F32 s0,s4,s0              ;550
0001ce  ee001ac0          VMLS.F32 s2,s1,s0              ;550
0001d2  ee310a61          VSUB.F32 s0,s2,s3
0001d6  eeb50ac0          VCMPE.F32 s0,#0.0
0001da  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001de  dd04              BLE      |L264.490|
;;;555              return false;
;;;556            }
;;;557          }
;;;558    
;;;559          return true;
;;;560        }
0001e0  b049              ADD      sp,sp,#0x124
0001e2  2000              MOVS     r0,#0                 ;555
0001e4  ecbd8b04          VPOP     {d8-d9}
0001e8  bdf0              POP      {r4-r7,pc}
                  |L264.490|
0001ea  1c40              ADDS     r0,r0,#1              ;545
0001ec  2804              CMP      r0,#4                 ;545
0001ee  dbbe              BLT      |L264.366|
0001f0  b049              ADD      sp,sp,#0x124
0001f2  2001              MOVS     r0,#1                 ;559
0001f4  ecbd8b04          VPOP     {d8-d9}
0001f8  bdf0              POP      {r4-r7,pc}
;;;561    
                          ENDP

0001fa  0000              DCW      0x0000
                  |L264.508|
0001fc  00000000          DCFS     0x00000000 ; 0
                  |L264.512|
                          DCD      0x07fffffe
                  |L264.516|
000204  3a83126f          DCFS     0x3a83126f ; 0.0010000000474974513

                          AREA ||area_number.265||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE8IsConvexEv, LINKORDER=||t._ZNK4Anki8Embedded13QuadrilateralIfE8IsConvexEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.265||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded13QuadrilateralIfE8IsConvexEv||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC2EiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::FixedLengthList__sub_object(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;75     
;;;76         template<typename Type> FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;77           : ArraySlice<Type>(Array<Type>(1, maximumSize, memory, flags), LinearSequence<s32>(0,0), LinearSequence<s32>(0,0))
;;;78         {
;;;79           if(this->array.get_numElements() == 0) {
;;;80             this->arrayData = NULL;
;;;81           } else {
;;;82             this->arrayData = this->array.Pointer(0,0);
;;;83           }
;;;84     
;;;85           if(flags.get_isFullyAllocated()) {
;;;86             this->set_size(maximumSize);
;;;87           } else {
;;;88             this->set_size(0);
;;;89           }
;;;90         } // FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;91     
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  b08d              SUB      sp,sp,#0x34
000006  4604              MOV      r4,r0
000008  9810              LDR      r0,[sp,#0x40]
00000a  4613              MOV      r3,r2
00000c  468a              MOV      r10,r1
00000e  460a              MOV      r2,r1
000010  9000              STR      r0,[sp,#0]
000012  2101              MOVS     r1,#1
000014  a801              ADD      r0,sp,#4
000016  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00001a  f8d08010          LDR      r8,[r0,#0x10]
00001e  e8b002e0          LDM      r0!,{r5-r7,r9}
000022  2200              MOVS     r2,#0
000024  4611              MOV      r1,r2
000026  a806              ADD      r0,sp,#0x18
000028  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00002c  4683              MOV      r11,r0
00002e  2200              MOVS     r2,#0
000030  4611              MOV      r1,r2
000032  a809              ADD      r0,sp,#0x24
000034  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000038  e9db1200          LDRD     r1,r2,[r11,#0]
00003c  f8db3008          LDR      r3,[r11,#8]
000040  60a3              STR      r3,[r4,#8]
000042  e9c41200          STRD     r1,r2,[r4,#0]
000046  e9d01200          LDRD     r1,r2,[r0,#0]
00004a  6880              LDR      r0,[r0,#8]
00004c  f8c48028          STR      r8,[r4,#0x28]
000050  60e1              STR      r1,[r4,#0xc]
000052  e9c42004          STRD     r2,r0,[r4,#0x10]
000056  f1040018          ADD      r0,r4,#0x18
00005a  2200              MOVS     r2,#0
00005c  e8a002e0          STM      r0!,{r5-r7,r9}
000060  2d00              CMP      r5,#0
000062  bfc8              IT       GT
000064  2e00              CMPGT    r6,#0
000066  dd31              BLE      |L271.204|
000068  fb05f006          MUL      r0,r5,r6
00006c  2800              CMP      r0,#0
00006e  d02d              BEQ      |L271.204|
000070  2000              MOVS     r0,#0
000072  fb008007          MLA      r0,r0,r7,r8
000076  62e0              STR      r0,[r4,#0x2c]
                  |L271.120|
000078  2d00              CMP      r5,#0
00007a  bfc8              IT       GT
00007c  2e00              CMPGT    r6,#0
00007e  dd27              BLE      |L271.208|
000080  fb05f006          MUL      r0,r5,r6
000084  b320              CBZ      r0,|L271.208|
000086  2000              MOVS     r0,#0
000088  fb008007          MLA      r0,r0,r7,r8
00008c  6320              STR      r0,[r4,#0x30]
                  |L271.142|
00008e  2d00              CMP      r5,#0
000090  bfc8              IT       GT
000092  2e00              CMPGT    r6,#0
000094  dd1e              BLE      |L271.212|
000096  fb05f006          MUL      r0,r5,r6
00009a  b1d8              CBZ      r0,|L271.212|
00009c  2000              MOVS     r0,#0
00009e  fb008007          MLA      r0,r0,r7,r8
0000a2  6320              STR      r0,[r4,#0x30]
                  |L271.164|
0000a4  a810              ADD      r0,sp,#0x40
0000a6  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0000aa  b300              CBZ      r0,|L271.238|
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::get_maximumSize() const
0000b2  4601              MOV      r1,r0
0000b4  f1ba0f00          CMP      r10,#0
0000b8  bfac              ITE      GE
0000ba  4650              MOVGE    r0,r10
0000bc  2000              MOVLT    r0,#0
0000be  4288              CMP      r0,r1
0000c0  dd0a              BLE      |L271.216|
0000c2  4620              MOV      r0,r4
0000c4  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::get_maximumSize() const
0000c8  4682              MOV      r10,r0
0000ca  e00a              B        |L271.226|
                  |L271.204|
0000cc  62e2              STR      r2,[r4,#0x2c]
0000ce  e7d3              B        |L271.120|
                  |L271.208|
0000d0  6322              STR      r2,[r4,#0x30]
0000d2  e7dc              B        |L271.142|
                  |L271.212|
0000d4  6322              STR      r2,[r4,#0x30]
0000d6  e7e5              B        |L271.164|
                  |L271.216|
0000d8  f1ba0f00          CMP      r10,#0
0000dc  bfb8              IT       LT
0000de  f04f0a00          MOVLT    r10,#0
                  |L271.226|
0000e2  4620              MOV      r0,r4
0000e4  f8c4a00c          STR      r10,[r4,#0xc]
0000e8  b011              ADD      sp,sp,#0x44
0000ea  e8bd8ff0          POP      {r4-r11,pc}
                  |L271.238|
0000ee  2500              MOVS     r5,#0
0000f0  4620              MOV      r0,r4
0000f2  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::get_maximumSize() const
0000f6  42a8              CMP      r0,r5
0000f8  da03              BGE      |L271.258|
0000fa  4620              MOV      r0,r4
0000fc  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::get_maximumSize() const
000100  4605              MOV      r5,r0
                  |L271.258|
000102  60e5              STR      r5,[r4,#0xc]
000104  b011              ADD      sp,sp,#0x44
000106  4620              MOV      r0,r4
000108  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP


                          AREA ||area_number.272||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.272||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_5PointIfEEEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE PROC ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
;;;241    
;;;242          template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;243          {
000004  b082              SUB      sp,sp,#8
000006  460e              MOV      r6,r1
;;;244            const s32 in1Height = in1.get_size(0);
000008  2100              MOVS     r1,#0
00000a  9802              LDR      r0,[sp,#8]
00000c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
;;;245            const s32 in1Width = in1.get_size(1);
000010  9000              STR      r0,[sp,#0]
000012  2101              MOVS     r1,#1
000014  9802              LDR      r0,[sp,#8]
000016  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001a  4680              MOV      r8,r0
;;;246    
;;;247            const s32 in2Height = in2.get_size(0);
00001c  2100              MOVS     r1,#0
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000024  4605              MOV      r5,r0
;;;248            const s32 in2Width = in2.get_size(1);
000026  2101              MOVS     r1,#1
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
;;;249            const s32 in2Stride = in2.get_stride();
;;;250    
;;;251            AnkiConditionalErrorAndReturnValue(in1Width == in2Height,
00002e  f8df9124          LDR      r9,|L278.340|
000032  68b4              LDR      r4,[r6,#8]
000034  4607              MOV      r7,r0                 ;248
000036  45a8              CMP      r8,r5
000038  d00d              BEQ      |L278.86|
00003a  20fb              MOVS     r0,#0xfb
00003c  e9cd9000          STRD     r9,r0,[sp,#0]
000040  a345              ADR      r3,|L278.344|
000042  a253              ADR      r2,|L278.400|
000044  a15c              ADR      r1,|L278.440|
000046  2005              MOVS     r0,#5
000048  f7fffffe          BL       _Anki_Log
;;;252              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;253    
;;;254            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2Width, out),
;;;255              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;256    
;;;257            for(s32 y1=0; y1<in1Height; y1++) {
;;;258              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;259              OutType * restrict pOut = out.Pointer(y1, 0);
;;;260    
;;;261              for(s32 x2=0; x2<in2Width; x2++) {
;;;262                const u8 * restrict pIn2 = reinterpret_cast<const u8*>(in2.Pointer(0, x2));
;;;263    
;;;264                OutType accumulator = 0;
;;;265    
;;;266                s32 y2;
;;;267                for(y2=0; y2<in2Height-3; y2+=4) {
;;;268                  const InType in1_0 = pIn1[y2];
;;;269                  const InType in1_1 = pIn1[y2+1];
;;;270                  const InType in1_2 = pIn1[y2+2];
;;;271                  const InType in1_3 = pIn1[y2+3];
;;;272    
;;;273                  const InType in2_0 = *reinterpret_cast<const InType*>(pIn2);
;;;274                  const InType in2_1 = *reinterpret_cast<const InType*>(pIn2 + in2Stride);
;;;275                  const InType in2_2 = *reinterpret_cast<const InType*>(pIn2 + 2*in2Stride);
;;;276                  const InType in2_3 = *reinterpret_cast<const InType*>(pIn2 + 3*in2Stride);
;;;277    
;;;278                  accumulator +=
;;;279                    in1_0 * in2_0 +
;;;280                    in1_1 * in2_1 +
;;;281                    in1_2 * in2_2 +
;;;282                    in1_3 * in2_3;
;;;283    
;;;284                  pIn2 += 4*in2Stride;
;;;285                }
;;;286    
;;;287                for(; y2<in2Height; y2++) {
;;;288                  accumulator += pIn1[y2] * (*reinterpret_cast<const InType*>(pIn2));
;;;289    
;;;290                  pIn2 += in2Stride;
;;;291                }
;;;292    
;;;293                pOut[x2] = accumulator;
;;;294              }
;;;295            }
;;;296    
;;;297            return RESULT_OK;
;;;298          } // template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
00004c  b005              ADD      sp,sp,#0x14
00004e  f04f60a0          MOV      r0,#0x5000000         ;251
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L278.86|
000056  4601              MOV      r1,r0                 ;254
000058  9a04              LDR      r2,[sp,#0x10]         ;254
00005a  9800              LDR      r0,[sp,#0]            ;254
00005c  f7fffffe          BL       _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_ ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<float>>(int, int, const T1&)
000060  2800              CMP      r0,#0                 ;254
000062  d068              BEQ      |L278.310|
000064  9800              LDR      r0,[sp,#0]            ;257
000066  f04f0900          MOV      r9,#0                 ;257
00006a  2800              CMP      r0,#0                 ;257
00006c  dd5f              BLE      |L278.302|
00006e  eddf4a55          VLDR     s9,|L278.452|
000072  f1a50803          SUB      r8,r5,#3              ;267
000076  eb040a44          ADD      r10,r4,r4,LSL #1      ;276
                  |L278.122|
00007a  9802              LDR      r0,[sp,#8]            ;276
00007c  2300              MOVS     r3,#0                 ;261
00007e  2f00              CMP      r7,#0                 ;261
000080  6901              LDR      r1,[r0,#0x10]         ;261
000082  6880              LDR      r0,[r0,#8]            ;261
000084  fb091c00          MLA      r12,r9,r0,r1          ;261
000088  9804              LDR      r0,[sp,#0x10]         ;261
00008a  6901              LDR      r1,[r0,#0x10]         ;261
00008c  6880              LDR      r0,[r0,#8]            ;261
00008e  fb091b00          MLA      r11,r9,r0,r1          ;261
000092  dd47              BLE      |L278.292|
                  |L278.148|
000094  68b2              LDR      r2,[r6,#8]            ;261
000096  6931              LDR      r1,[r6,#0x10]         ;261
000098  2000              MOVS     r0,#0                 ;262
00009a  fb001002          MLA      r0,r0,r2,r1           ;262
00009e  2100              MOVS     r1,#0                 ;267
0000a0  eb000083          ADD      r0,r0,r3,LSL #2       ;267
0000a4  eeb00a64          VMOV.F32 s0,s9                 ;264
0000a8  f1b80f00          CMP      r8,#0                 ;267
0000ac  dd25              BLE      |L278.250|
                  |L278.174|
0000ae  eb0c0281          ADD      r2,r12,r1,LSL #2      ;268
0000b2  edd03a00          VLDR     s7,[r0,#0]            ;273
0000b6  ed924a00          VLDR     s8,[r2,#0]            ;268
0000ba  ed923a01          VLDR     s6,[r2,#4]            ;269
0000be  edd22a02          VLDR     s5,[r2,#8]            ;270
0000c2  ed922a03          VLDR     s4,[r2,#0xc]          ;271
0000c6  1902              ADDS     r2,r0,r4              ;274
0000c8  ee643a23          VMUL.F32 s7,s8,s7              ;278
0000cc  edd21a00          VLDR     s3,[r2,#0]            ;274
0000d0  eb000244          ADD      r2,r0,r4,LSL #1       ;275
0000d4  1d09              ADDS     r1,r1,#4              ;267
0000d6  ee433a21          VMLA.F32 s7,s6,s3              ;278
0000da  ed921a00          VLDR     s2,[r2,#0]            ;275
0000de  eb0a0200          ADD      r2,r10,r0             ;276
0000e2  eb000084          ADD      r0,r0,r4,LSL #2       ;284
0000e6  edd20a00          VLDR     s1,[r2,#0]            ;276
0000ea  4588              CMP      r8,r1                 ;267
0000ec  ee423a81          VMLA.F32 s7,s5,s2              ;278
0000f0  ee423a20          VMLA.F32 s7,s4,s1              ;278
0000f4  ee330a80          VADD.F32 s0,s7,s0              ;278
0000f8  dcd9              BGT      |L278.174|
                  |L278.250|
0000fa  42a9              CMP      r1,r5                 ;287
0000fc  da0b              BGE      |L278.278|
                  |L278.254|
0000fe  eb0c0281          ADD      r2,r12,r1,LSL #2      ;288
000102  ed901a00          VLDR     s2,[r0,#0]            ;288
000106  edd20a00          VLDR     s1,[r2,#0]            ;288
00010a  1c49              ADDS     r1,r1,#1              ;287
00010c  4420              ADD      r0,r0,r4              ;290
00010e  ee000a81          VMLA.F32 s0,s1,s2              ;288
000112  42a9              CMP      r1,r5                 ;287
000114  dbf3              BLT      |L278.254|
                  |L278.278|
000116  eb0b0083          ADD      r0,r11,r3,LSL #2      ;293
00011a  1c5b              ADDS     r3,r3,#1              ;261
00011c  ed800a00          VSTR     s0,[r0,#0]            ;293
000120  42bb              CMP      r3,r7                 ;261
000122  dbb7              BLT      |L278.148|
                  |L278.292|
000124  9800              LDR      r0,[sp,#0]            ;257
000126  f1090901          ADD      r9,r9,#1              ;257
00012a  4581              CMP      r9,r0                 ;257
00012c  dba5              BLT      |L278.122|
                  |L278.302|
00012e  b005              ADD      sp,sp,#0x14
000130  2000              MOVS     r0,#0                 ;297
000132  e8bd8ff0          POP      {r4-r11,pc}
                  |L278.310|
000136  20fe              MOVS     r0,#0xfe              ;254
000138  e9cd9000          STRD     r9,r0,[sp,#0]         ;254
00013c  a306              ADR      r3,|L278.344|
00013e  a222              ADR      r2,|L278.456|
000140  a11d              ADR      r1,|L278.440|
000142  2005              MOVS     r0,#5                 ;254
000144  f7fffffe          BL       _Anki_Log
000148  b005              ADD      sp,sp,#0x14
00014a  f04f60a0          MOV      r0,#0x5000000         ;254
00014e  e8bd8ff0          POP      {r4-r11,pc}
;;;299    
                          ENDP

000152  0000              DCW      0x0000
                  |L278.340|
                          DCD      _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L278.344|
000158  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
00015c  6f726574
000160  6563685c
000164  636f6d6d
000168  6f6e5c69
00016c  6e636c75
000170  64655c61
000174  6e6b692f
000178  636f6d6d
00017c  6f6e2f72
000180  6f626f74
000184  2f6d6174
000188  726978  
00018b  2e6800            DCB      ".h",0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L278.400|
000190  496e7075          DCB      "Input matrices are incompatible sizes",0
000194  74206d61
000198  74726963
00019c  65732061
0001a0  72652069
0001a4  6e636f6d
0001a8  70617469
0001ac  626c6520
0001b0  73697a65
0001b4  7300    
0001b6  00                DCB      0
0001b7  00                DCB      0
                  |L278.440|
0001b8  4d756c74          DCB      "Multiply",0
0001bc  69706c79
0001c0  00      
0001c1  00                DCB      0
0001c2  00                DCB      0
0001c3  00                DCB      0
                  |L278.452|
0001c4  00000000          DCFS     0x00000000 ; 0
                  |L278.456|
0001c8  496e7075          DCB      "Input and Output matrices are incompatible sizes",0
0001cc  7420616e
0001d0  64204f75
0001d4  74707574
0001d8  206d6174
0001dc  72696365
0001e0  73206172
0001e4  6520696e
0001e8  636f6d70
0001ec  61746962
0001f0  6c652073
0001f4  697a6573
0001f8  00      
0001f9  00                DCB      0
0001fa  00                DCB      0
0001fb  00                DCB      0

                          AREA ||area_number.279||, COMGROUP=_ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.279||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded9Invert3x3IfEEvRT_S3_S3_S3_S3_S3_S3_S3_S3_||, COMGROUP=_ZN4Anki8Embedded9Invert3x3IfEEvRT_S3_S3_S3_S3_S3_S3_S3_S3_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded9Invert3x3IfEEvRT_S3_S3_S3_S3_S3_S3_S3_S3_ PROC ; Anki::Embedded::Invert3x3<float>(T1&, T1&, T1&, T1&, T1&, T1&, T1&, T1&, T1&)
;;;150    
;;;151        template<typename Type> void Invert3x3(Type &a, Type &b, Type &c, Type &d, Type &e, Type &f, Type &g, Type &h, Type &i)
000000  b4f0              PUSH     {r4-r7}
;;;152        {
;;;153          const Type determinant = Determinant3x3(a,b,c,d,e,f,g,h,i);
;;;154          const Type determinantInverse = static_cast<Type>(1) / determinant;
000002  eef76a00          VMOV.F32 s13,#1.00000000
000006  e9dd4504          LDRD     r4,r5,[sp,#0x10]      ;152
00000a  e9dd6706          LDRD     r6,r7,[sp,#0x18]      ;152
00000e  f8ddc020          LDR      r12,[sp,#0x20]        ;153
000012  ed944a00          VLDR     s8,[r4,#0]            ;153
000016  edd33a00          VLDR     s7,[r3,#0]            ;153
00001a  ed9c2a00          VLDR     s4,[r12,#0]           ;153
00001e  ed953a00          VLDR     s6,[r5,#0]            ;153
000022  edd74a00          VLDR     s9,[r7,#0]            ;153
000026  ee245a02          VMUL.F32 s10,s8,s4             ;153
00002a  ee230a82          VMUL.F32 s0,s7,s4              ;153
00002e  edd62a00          VLDR     s5,[r6,#0]            ;153
000032  edd01a00          VLDR     s3,[r0,#0]            ;153
000036  ee035a64          VMLS.F32 s10,s6,s9             ;153
00003a  ee030a62          VMLS.F32 s0,s6,s5              ;153
00003e  ee635aa4          VMUL.F32 s11,s7,s9             ;153
000042  ed911a00          VLDR     s2,[r1,#0]            ;153
000046  edd20a00          VLDR     s1,[r2,#0]            ;153
;;;155    
;;;156          const Type A =  (e*i - f*h);
;;;157          const Type B = -(d*i - f*g);
;;;158          const Type C =  (d*h - e*g);
;;;159          const Type D = -(b*i - c*h);
;;;160          const Type E =  (a*i - c*g);
00004a  ee217a82          VMUL.F32 s14,s3,s4
00004e  ee256a21          VMUL.F32 s12,s10,s3
000052  ee445a62          VMLS.F32 s11,s8,s5
000056  ee007ae2          VMLS.F32 s14,s1,s5
00005a  ee016a40          VMLS.F32 s12,s2,s0
00005e  ee006aa5          VMLA.F32 s12,s1,s11
000062  ee860a86          VDIV.F32 s0,s13,s12            ;154
000066  ee236a22          VMUL.F32 s12,s6,s5             ;157
00006a  ee606aa4          VMUL.F32 s13,s1,s9             ;159
00006e  ee036ac2          VMLS.F32 s12,s7,s4             ;157
000072  ee416a42          VMLS.F32 s13,s2,s4             ;159
;;;161          const Type F = -(a*h - b*g);
000076  ee212a22          VMUL.F32 s4,s2,s5
;;;162          const Type G =  (b*f - c*e);
00007a  ee612a03          VMUL.F32 s5,s2,s6
00007e  ee012ae4          VMLS.F32 s4,s3,s9              ;161
000082  ee402ac4          VMLS.F32 s5,s1,s8
;;;163          const Type H = -(a*f - c*d);
000086  ee600aa3          VMUL.F32 s1,s1,s7
00008a  ee410ac3          VMLS.F32 s1,s3,s6
;;;164          const Type I =  (a*e - b*d);
00008e  ee611a84          VMUL.F32 s3,s3,s8
000092  ee411a63          VMLS.F32 s3,s2,s7
;;;165    
;;;166          a = A * determinantInverse;
000096  ee251a00          VMUL.F32 s2,s10,s0
;;;167          b = D * determinantInverse;
;;;168          c = G * determinantInverse;
;;;169          d = B * determinantInverse;
;;;170          e = E * determinantInverse;
;;;171          f = H * determinantInverse;
00009a  ee600a80          VMUL.F32 s1,s1,s0
00009e  ed801a00          VSTR     s2,[r0,#0]            ;166
0000a2  ee261a80          VMUL.F32 s2,s13,s0             ;167
0000a6  ed811a00          VSTR     s2,[r1,#0]            ;167
0000aa  ee221a80          VMUL.F32 s2,s5,s0              ;168
0000ae  ed821a00          VSTR     s2,[r2,#0]            ;168
0000b2  ee261a00          VMUL.F32 s2,s12,s0             ;169
0000b6  ed831a00          VSTR     s2,[r3,#0]            ;169
0000ba  ee271a00          VMUL.F32 s2,s14,s0             ;170
0000be  ed841a00          VSTR     s2,[r4,#0]            ;170
0000c2  edc50a00          VSTR     s1,[r5,#0]
;;;172          g = C * determinantInverse;
0000c6  ee650a80          VMUL.F32 s1,s11,s0
0000ca  edc60a00          VSTR     s1,[r6,#0]
;;;173          h = F * determinantInverse;
0000ce  ee620a00          VMUL.F32 s1,s4,s0
;;;174          i = I * determinantInverse;
0000d2  ee210a80          VMUL.F32 s0,s3,s0
0000d6  edc70a00          VSTR     s1,[r7,#0]            ;173
0000da  ed8c0a00          VSTR     s0,[r12,#0]
;;;175        }
0000de  bcf0              POP      {r4-r7}
0000e0  4770              BX       lr
;;;176    
                          ENDP


                          AREA ||area_number.286||, COMGROUP=_ZN4Anki8Embedded9Invert3x3IfEEvRT_S3_S3_S3_S3_S3_S3_S3_S3_, LINKORDER=||t._ZN4Anki8Embedded9Invert3x3IfEEvRT_S3_S3_S3_S3_S3_S3_S3_S3_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.286||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded9Invert3x3IfEEvRT_S3_S3_S3_S3_S3_S3_S3_S3_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded7Interp2IhhEENS_6ResultERKNS0_5ArrayIT_EERKNS3_IfEESA_RNS3_IT0_EENS0_17InterpolationTypeESB_||, COMGROUP=_ZN4Anki8Embedded7Interp2IhhEENS_6ResultERKNS0_5ArrayIT_EERKNS3_IfEESA_RNS3_IT0_EENS0_17InterpolationTypeESB_, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded7Interp2IhhEENS_6ResultERKNS0_5ArrayIT_EERKNS3_IfEESA_RNS3_IT0_EENS0_17InterpolationTypeESB_ PROC ; Anki::Embedded::Interp2<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Array<float>&, Anki::Embedded::Array<T2>&, Anki::Embedded::InterpolationType, T2)
;;;49     
;;;50         template<typename InType, typename OutType> Result Interp2(const Array<InType> &reference, const Array<f32> &xCoordinates, const Array<f32> &yCoordinates, Array<OutType> &out, const InterpolationType interpolationType, const OutType invalidValue)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;51         {
000004  4605              MOV      r5,r0
000006  ed2d8b0a          VPUSH    {d8-d12}
00000a  b087              SUB      sp,sp,#0x1c
00000c  461e              MOV      r6,r3
00000e  4691              MOV      r9,r2
000010  468b              MOV      r11,r1
;;;52           AnkiConditionalErrorAndReturnValue(interpolationType == INTERPOLATE_LINEAR,
000012  981a              LDR      r0,[sp,#0x68]
000014  4fe7              LDR      r7,|L292.948|
000016  2800              CMP      r0,#0
000018  d00f              BEQ      |L292.58|
00001a  2034              MOVS     r0,#0x34
00001c  e9cd7000          STRD     r7,r0,[sp,#0]
000020  a3e5              ADR      r3,|L292.952|
000022  a2f4              ADR      r2,|L292.1012|
000024  a1fd              ADR      r1,|L292.1052|
000026  2005              MOVS     r0,#5
000028  f7fffffe          BL       _Anki_Log
00002c  f04f7040          MOV      r0,#0x3000000
                  |L292.48|
;;;53             RESULT_FAIL_INVALID_PARAMETER, "Interp2", "Only INTERPOLATE_LINEAR is supported");
;;;54     
;;;55           AnkiConditionalErrorAndReturnValue(AreValid(reference, xCoordinates, yCoordinates, out),
;;;56             RESULT_FAIL_INVALID_OBJECT, "Interp2", "Invalid objects");
;;;57     
;;;58           const s32 referenceHeight = reference.get_size(0);
;;;59           const s32 referenceWidth = reference.get_size(1);
;;;60     
;;;61           const s32 outHeight = out.get_size(0);
;;;62           const s32 outWidth = out.get_size(1);
;;;63     
;;;64           const s32 numOutputElements = outHeight * outWidth;
;;;65     
;;;66           const bool isOutputOneDimensional = (out.get_size(0) == 1);
;;;67     
;;;68           AnkiConditionalErrorAndReturnValue(
;;;69             AreEqualSize(out, xCoordinates, yCoordinates),
;;;70             RESULT_FAIL_INVALID_SIZE, "Interp2", "xCoordinates, yCoordinates, and out must all be the same sizes");
;;;71     
;;;72           if(isOutputOneDimensional) {
;;;73             AnkiConditionalErrorAndReturnValue(
;;;74               AreEqualSize(1, numOutputElements, out),
;;;75               RESULT_FAIL_INVALID_SIZE, "Interp2", "If out is a row vector, then out, xCoordinates, and yCoordinates must all be 1xN");
;;;76           }
;;;77     
;;;78           AnkiConditionalErrorAndReturnValue(
;;;79             NotAliased(out, xCoordinates, yCoordinates, reference),
;;;80             RESULT_FAIL_ALIASED_MEMORY, "Interp2", "xCoordinates, yCoordinates, and reference cannot be the same as out");
;;;81     
;;;82           const f32 xyReferenceMin = 0.0f;
;;;83           const f32 xReferenceMax = static_cast<f32>(referenceWidth) - 1.0f;
;;;84           const f32 yReferenceMax = static_cast<f32>(referenceHeight) - 1.0f;
;;;85     
;;;86           //const s32 numValues = xCoordinates.get_size(1);
;;;87     
;;;88           const s32 yIterationMax = isOutputOneDimensional ? 1                    : outHeight;
;;;89           const s32 xIterationMax = isOutputOneDimensional ? (outHeight*outWidth) : outWidth;
;;;90     
;;;91           for(s32 y=0; y<yIterationMax; y++) {
;;;92             const f32 * restrict pXCoordinates = xCoordinates.Pointer(y,0);
;;;93             const f32 * restrict pYCoordinates = yCoordinates.Pointer(y,0);
;;;94     
;;;95             OutType * restrict pOut = out.Pointer(y,0);
;;;96     
;;;97             for(s32 x=0; x<xIterationMax; x++) {
;;;98               const f32 curX = pXCoordinates[x];
;;;99               const f32 curY = pYCoordinates[x];
;;;100    
;;;101              const f32 x0 = FLT_FLOOR(curX);
;;;102              const f32 x1 = ceilf(curX); // x0 + 1.0f;
;;;103    
;;;104              const f32 y0 = FLT_FLOOR(curY);
;;;105              const f32 y1 = ceilf(curY); // y0 + 1.0f;
;;;106    
;;;107              // If out of bounds, set as invalid and continue
;;;108              if(x0 < xyReferenceMin || x1 > xReferenceMax || y0 < xyReferenceMin || y1 > yReferenceMax) {
;;;109                pOut[x] = invalidValue;
;;;110                continue;
;;;111              }
;;;112    
;;;113              const f32 alphaX = curX - x0;
;;;114              const f32 alphaXinverse = 1 - alphaX;
;;;115    
;;;116              const f32 alphaY = curY - y0;
;;;117              const f32 alphaYinverse = 1.0f - alphaY;
;;;118    
;;;119              const s32 y0S32 = Round<s32>(y0);
;;;120              const s32 y1S32 = Round<s32>(y1);
;;;121              const s32 x0S32 = Round<s32>(x0);
;;;122    
;;;123              const InType * restrict pReference_y0 = reference.Pointer(y0S32, x0S32);
;;;124              const InType * restrict pReference_y1 = reference.Pointer(y1S32, x0S32);
;;;125    
;;;126              const f32 pixelTL = *pReference_y0;
;;;127              const f32 pixelTR = *(pReference_y0+1);
;;;128              const f32 pixelBL = *pReference_y1;
;;;129              const f32 pixelBR = *(pReference_y1+1);
;;;130    
;;;131              const f32 interpolatedPixelF32 = InterpolateBilinear2d<f32>(pixelTL, pixelTR, pixelBL, pixelBR, alphaY, alphaYinverse, alphaX, alphaXinverse);
;;;132    
;;;133              const OutType interpolatedPixel = RoundIfInteger<OutType>(interpolatedPixelF32);
;;;134    
;;;135              pOut[x] = interpolatedPixel;
;;;136            } // for(s32 x=0; x<xIterationMax; x++)
;;;137          } // for(s32 y=0; y<yIterationMax; y++)
;;;138    
;;;139          return RESULT_OK;
;;;140        } // Interp2
000030  b007              ADD      sp,sp,#0x1c
000032  ecbd8b0a          VPOP     {d8-d12}
000036  e8bd8ff0          POP      {r4-r11,pc}
                  |L292.58|
00003a  6928              LDR      r0,[r5,#0x10]
00003c  2800              CMP      r0,#0
00003e  d07d              BEQ      |L292.316|
000040  6828              LDR      r0,[r5,#0]
000042  2800              CMP      r0,#0
000044  bfa4              ITT      GE
000046  6868              LDRGE    r0,[r5,#4]
000048  2800              CMPGE    r0,#0
00004a  db77              BLT      |L292.316|
00004c  4608              MOV      r0,r1
00004e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000052  2800              CMP      r0,#0
000054  d072              BEQ      |L292.316|
000056  4648              MOV      r0,r9
000058  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00005c  2800              CMP      r0,#0
00005e  bf1c              ITT      NE
000060  6930              LDRNE    r0,[r6,#0x10]
000062  2800              CMPNE    r0,#0
000064  d07b              BEQ      |L292.350|
000066  6830              LDR      r0,[r6,#0]
000068  2800              CMP      r0,#0
00006a  bfa4              ITT      GE
00006c  6870              LDRGE    r0,[r6,#4]
00006e  2800              CMPGE    r0,#0
000070  db75              BLT      |L292.350|
000072  2100              MOVS     r1,#0                 ;58
000074  4628              MOV      r0,r5                 ;58
000076  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00007a  ee080a90          VMOV     s17,r0                ;58
00007e  2101              MOVS     r1,#1                 ;59
000080  4628              MOV      r0,r5                 ;59
000082  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000086  ee080a10          VMOV     s16,r0                ;59
00008a  2100              MOVS     r1,#0                 ;61
00008c  4630              MOV      r0,r6                 ;61
00008e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000092  9004              STR      r0,[sp,#0x10]         ;62
000094  2101              MOVS     r1,#1                 ;62
000096  4630              MOV      r0,r6                 ;62
000098  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00009c  4601              MOV      r1,r0                 ;62
00009e  9005              STR      r0,[sp,#0x14]         ;64
0000a0  9804              LDR      r0,[sp,#0x10]         ;64
0000a2  fb00fa01          MUL      r10,r0,r1             ;64
0000a6  2100              MOVS     r1,#0                 ;66
0000a8  4630              MOV      r0,r6                 ;66
0000aa  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000ae  2801              CMP      r0,#1                 ;66
0000b0  bf0c              ITE      EQ                    ;66
0000b2  2401              MOVEQ    r4,#1                 ;66
0000b4  2400              MOVNE    r4,#0                 ;66
0000b6  6930              LDR      r0,[r6,#0x10]         ;66
0000b8  2800              CMP      r0,#0                 ;66
0000ba  d05c              BEQ      |L292.374|
0000bc  6830              LDR      r0,[r6,#0]            ;66
0000be  2800              CMP      r0,#0                 ;66
0000c0  bfa4              ITT      GE                    ;66
0000c2  6870              LDRGE    r0,[r6,#4]            ;66
0000c4  2800              CMPGE    r0,#0                 ;66
0000c6  db56              BLT      |L292.374|
0000c8  4658              MOV      r0,r11                ;66
0000ca  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
0000ce  2800              CMP      r0,#0                 ;66
0000d0  d051              BEQ      |L292.374|
0000d2  4648              MOV      r0,r9                 ;66
0000d4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
0000d8  2800              CMP      r0,#0                 ;66
0000da  d04c              BEQ      |L292.374|
0000dc  2100              MOVS     r1,#0                 ;66
0000de  4630              MOV      r0,r6                 ;66
0000e0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000e4  4680              MOV      r8,r0                 ;66
0000e6  2100              MOVS     r1,#0                 ;66
0000e8  4658              MOV      r0,r11                ;66
0000ea  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000ee  4580              CMP      r8,r0                 ;66
0000f0  d141              BNE      |L292.374|
0000f2  2101              MOVS     r1,#1                 ;66
0000f4  4630              MOV      r0,r6                 ;66
0000f6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0000fa  4680              MOV      r8,r0                 ;66
0000fc  2101              MOVS     r1,#1                 ;66
0000fe  4658              MOV      r0,r11                ;66
000100  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000104  4580              CMP      r8,r0                 ;66
000106  d136              BNE      |L292.374|
000108  2100              MOVS     r1,#0                 ;66
00010a  4630              MOV      r0,r6                 ;66
00010c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000110  4680              MOV      r8,r0                 ;66
000112  2100              MOVS     r1,#0                 ;66
000114  4648              MOV      r0,r9                 ;66
000116  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00011a  4580              CMP      r8,r0                 ;66
00011c  d12b              BNE      |L292.374|
00011e  2101              MOVS     r1,#1                 ;66
000120  4630              MOV      r0,r6                 ;66
000122  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000126  4680              MOV      r8,r0                 ;66
000128  2101              MOVS     r1,#1                 ;66
00012a  4648              MOV      r0,r9                 ;66
00012c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000130  4580              CMP      r8,r0                 ;66
000132  d120              BNE      |L292.374|
000134  2c00              CMP      r4,#0                 ;72
000136  d03c              BEQ      |L292.434|
000138  46d0              MOV      r8,r10                ;73
00013a  e000              B        |L292.318|
                  |L292.316|
00013c  e00f              B        |L292.350|
                  |L292.318|
00013e  6930              LDR      r0,[r6,#0x10]         ;73
000140  2800              CMP      r0,#0                 ;73
000142  d02a              BEQ      |L292.410|
000144  6830              LDR      r0,[r6,#0]            ;73
000146  2800              CMP      r0,#0                 ;73
000148  bfa4              ITT      GE                    ;73
00014a  6870              LDRGE    r0,[r6,#4]            ;73
00014c  2800              CMPGE    r0,#0                 ;73
00014e  db24              BLT      |L292.410|
000150  2100              MOVS     r1,#0                 ;73
000152  4630              MOV      r0,r6                 ;73
000154  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000158  2801              CMP      r0,#1                 ;73
00015a  d11e              BNE      |L292.410|
00015c  e017              B        |L292.398|
                  |L292.350|
00015e  2037              MOVS     r0,#0x37              ;55
000160  e9cd7000          STRD     r7,r0,[sp,#0]         ;55
000164  a394              ADR      r3,|L292.952|
000166  a2af              ADR      r2,|L292.1060|
000168  a1ac              ADR      r1,|L292.1052|
00016a  2005              MOVS     r0,#5                 ;55
00016c  f7fffffe          BL       _Anki_Log
000170  f04f6080          MOV      r0,#0x4000000         ;55
000174  e75c              B        |L292.48|
                  |L292.374|
000176  2044              MOVS     r0,#0x44              ;68
000178  e9cd7000          STRD     r7,r0,[sp,#0]         ;68
00017c  a38e              ADR      r3,|L292.952|
00017e  a2ad              ADR      r2,|L292.1076|
000180  a1a6              ADR      r1,|L292.1052|
000182  2005              MOVS     r0,#5                 ;68
000184  f7fffffe          BL       _Anki_Log
000188  f04f60a0          MOV      r0,#0x5000000         ;68
00018c  e750              B        |L292.48|
                  |L292.398|
00018e  2101              MOVS     r1,#1                 ;68
000190  4630              MOV      r0,r6                 ;68
000192  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000196  4540              CMP      r0,r8                 ;68
000198  d00b              BEQ      |L292.434|
                  |L292.410|
00019a  2049              MOVS     r0,#0x49              ;73
00019c  e9cd7000          STRD     r7,r0,[sp,#0]         ;73
0001a0  a385              ADR      r3,|L292.952|
0001a2  4ab4              LDR      r2,|L292.1140|
0001a4  a19d              ADR      r1,|L292.1052|
0001a6  2005              MOVS     r0,#5                 ;73
0001a8  f7fffffe          BL       _Anki_Log
0001ac  f04f60a0          MOV      r0,#0x5000000         ;73
0001b0  e73e              B        |L292.48|
                  |L292.434|
0001b2  6930              LDR      r0,[r6,#0x10]         ;73
0001b4  2800              CMP      r0,#0                 ;73
0001b6  d052              BEQ      |L292.606|
0001b8  6830              LDR      r0,[r6,#0]            ;73
0001ba  2800              CMP      r0,#0                 ;73
0001bc  bfa4              ITT      GE                    ;73
0001be  6870              LDRGE    r0,[r6,#4]            ;73
0001c0  2800              CMPGE    r0,#0                 ;73
0001c2  db4c              BLT      |L292.606|
0001c4  4658              MOV      r0,r11                ;73
0001c6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
0001ca  b3e8              CBZ      r0,|L292.584|
0001cc  4648              MOV      r0,r9                 ;73
0001ce  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
0001d2  2800              CMP      r0,#0                 ;73
0001d4  bf1c              ITT      NE                    ;73
0001d6  6928              LDRNE    r0,[r5,#0x10]         ;73
0001d8  2800              CMPNE    r0,#0                 ;73
0001da  d040              BEQ      |L292.606|
0001dc  6829              LDR      r1,[r5,#0]            ;73
0001de  2900              CMP      r1,#0                 ;73
0001e0  bfa4              ITT      GE                    ;73
0001e2  6869              LDRGE    r1,[r5,#4]            ;73
0001e4  2900              CMPGE    r1,#0                 ;73
0001e6  db3a              BLT      |L292.606|
0001e8  6931              LDR      r1,[r6,#0x10]         ;73
0001ea  9100              STR      r1,[sp,#0]            ;73
0001ec  f8db1010          LDR      r1,[r11,#0x10]        ;73
0001f0  9101              STR      r1,[sp,#4]            ;73
0001f2  f8d91010          LDR      r1,[r9,#0x10]         ;73
0001f6  e9cd1002          STRD     r1,r0,[sp,#8]         ;73
0001fa  2100              MOVS     r1,#0                 ;73
0001fc  466a              MOV      r2,sp                 ;73
                  |L292.510|
0001fe  1c48              ADDS     r0,r1,#1              ;73
000200  2804              CMP      r0,#4                 ;73
000202  bfb8              IT       LT                    ;73
000204  f8523021          LDRLT    r3,[r2,r1,LSL #2]     ;73
000208  da06              BGE      |L292.536|
                  |L292.522|
00020a  f852c020          LDR      r12,[r2,r0,LSL #2]    ;73
00020e  4563              CMP      r3,r12                ;73
000210  d025              BEQ      |L292.606|
000212  1c40              ADDS     r0,r0,#1              ;73
000214  2804              CMP      r0,#4                 ;73
000216  dbf8              BLT      |L292.522|
                  |L292.536|
000218  1c49              ADDS     r1,r1,#1              ;73
00021a  2904              CMP      r1,#4                 ;73
00021c  dbef              BLT      |L292.510|
00021e  eeb80ac8          VCVT.F32.S32 s0,s16                ;83
000222  eeb7ba00          VMOV.F32 s22,#1.00000000       ;83
000226  2c00              CMP      r4,#0                 ;88
000228  ee30aa4b          VSUB.F32 s20,s0,s22            ;83
00022c  eeb80ae8          VCVT.F32.S32 s0,s17                ;84
000230  ee709a4b          VSUB.F32 s19,s0,s22            ;84
000234  bf14              ITE      NE                    ;88
000236  2001              MOVNE    r0,#1                 ;88
000238  9804              LDREQ    r0,[sp,#0x10]         ;88
00023a  9000              STR      r0,[sp,#0]            ;88
00023c  bf08              IT       EQ                    ;89
00023e  f8dda014          LDREQ    r10,[sp,#0x14]        ;89
000242  f04f0700          MOV      r7,#0                 ;91
000246  e000              B        |L292.586|
                  |L292.584|
000248  e009              B        |L292.606|
                  |L292.586|
00024a  f8cda004          STR      r10,[sp,#4]           ;91
00024e  2800              CMP      r0,#0                 ;91
000250  bfc4              ITT      GT                    ;101
000252  eddfaa89          VLDRGT   s21,|L292.1144|
000256  ed9f9a89          VLDRGT   s18,|L292.1148|
00025a  dc0b              BGT      |L292.628|
00025c  e128              B        |L292.1200|
                  |L292.606|
00025e  204e              MOVS     r0,#0x4e              ;78
000260  e9cd7000          STRD     r7,r0,[sp,#0]         ;78
000264  a354              ADR      r3,|L292.952|
000266  4a86              LDR      r2,|L292.1152|
000268  a16c              ADR      r1,|L292.1052|
00026a  2005              MOVS     r0,#5                 ;78
00026c  f7fffffe          BL       _Anki_Log
000270  4884              LDR      r0,|L292.1156|
000272  e6dd              B        |L292.48|
                  |L292.628|
000274  f8db1008          LDR      r1,[r11,#8]           ;78
000278  f8db0010          LDR      r0,[r11,#0x10]        ;78
00027c  2400              MOVS     r4,#0                 ;97
00027e  fb070001          MLA      r0,r7,r1,r0           ;97
000282  9003              STR      r0,[sp,#0xc]          ;97
000284  f8d91008          LDR      r1,[r9,#8]            ;97
000288  f8d90010          LDR      r0,[r9,#0x10]         ;97
00028c  fb070001          MLA      r0,r7,r1,r0           ;97
000290  9002              STR      r0,[sp,#8]            ;97
000292  68b1              LDR      r1,[r6,#8]            ;97
000294  6930              LDR      r0,[r6,#0x10]         ;97
000296  fb070801          MLA      r8,r7,r1,r0           ;97
00029a  9801              LDR      r0,[sp,#4]            ;97
00029c  2800              CMP      r0,#0                 ;97
00029e  dd7d              BLE      |L292.924|
                  |L292.672|
0002a0  9803              LDR      r0,[sp,#0xc]          ;98
0002a2  eb000084          ADD      r0,r0,r4,LSL #2       ;98
0002a6  ed90ca00          VLDR     s24,[r0,#0]           ;98
0002aa  9802              LDR      r0,[sp,#8]            ;99
0002ac  eb000084          ADD      r0,r0,r4,LSL #2       ;99
0002b0  ee3c0a2a          VADD.F32 s0,s24,s21            ;101
0002b4  edd0ba00          VLDR     s23,[r0,#0]           ;99
0002b8  f7fffffe          BL       __hardfp_floorf
0002bc  eeb08a40          VMOV.F32 s16,s0                ;101
0002c0  eeb00a4c          VMOV.F32 s0,s24                ;102
0002c4  f7fffffe          BL       __hardfp_ceilf
0002c8  eef0ca40          VMOV.F32 s25,s0                ;102
0002cc  ee3b0aaa          VADD.F32 s0,s23,s21            ;104
0002d0  f7fffffe          BL       __hardfp_floorf
0002d4  eef08a40          VMOV.F32 s17,s0                ;104
0002d8  eeb00a6b          VMOV.F32 s0,s23                ;105
0002dc  f7fffffe          BL       __hardfp_ceilf
0002e0  eeb58ac0          VCMPE.F32 s16,#0.0              ;108
0002e4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;108
0002e8  d30e              BCC      |L292.776|
0002ea  eef4caca          VCMPE.F32 s25,s20               ;108
0002ee  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;108
0002f2  dc09              BGT      |L292.776|
0002f4  eef58ac0          VCMPE.F32 s17,#0.0              ;108
0002f8  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;108
0002fc  d304              BCC      |L292.776|
0002fe  eeb40ae9          VCMPE.F32 s0,s19                ;108
000302  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;108
000306  dd01              BLE      |L292.780|
                  |L292.776|
000308  981b              LDR      r0,[sp,#0x6c]         ;110
00030a  e0c5              B        |L292.1176|
                  |L292.780|
00030c  ee7c0a48          VSUB.F32 s1,s24,s16            ;113
000310  ee3b1ae8          VSUB.F32 s2,s23,s17            ;116
000314  eef58ac0          VCMPE.F32 s17,#0.0              ;116
000318  ee7b1a60          VSUB.F32 s3,s22,s1             ;114
00031c  ee7b2a41          VSUB.F32 s5,s22,s2             ;117
000320  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;117
000324  bfcc              ITE      GT                    ;117
000326  ee382a89          VADDGT.F32 s4,s17,s18            ;117
00032a  ee382ac9          VSUBLE.F32 s4,s17,s18            ;117
00032e  eebd2ac2          VCVT.S32.F32 s4,s4                 ;117
000332  eeb50ac0          VCMPE.F32 s0,#0.0               ;117
000336  ee12ca10          VMOV     r12,s4                ;117
00033a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;117
00033e  bfcc              ITE      GT                    ;117
000340  ee300a09          VADDGT.F32 s0,s0,s18             ;117
000344  ee300a49          VSUBLE.F32 s0,s0,s18             ;117
000348  eebd0ac0          VCVT.S32.F32 s0,s0                 ;117
00034c  eeb58ac0          VCMPE.F32 s16,#0.0              ;117
000350  ee10aa10          VMOV     r10,s0                ;117
000354  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;117
000358  bfcc              ITE      GT                    ;117
00035a  ee380a09          VADDGT.F32 s0,s16,s18            ;117
00035e  ee380a49          VSUBLE.F32 s0,s16,s18            ;117
000362  eebd0ac0          VCVT.S32.F32 s0,s0                 ;117
000366  692b              LDR      r3,[r5,#0x10]         ;117
000368  68aa              LDR      r2,[r5,#8]            ;117
00036a  ee100a10          VMOV     r0,s0                 ;117
00036e  fb0c3102          MLA      r1,r12,r2,r3          ;117
000372  fb0a3202          MLA      r2,r10,r2,r3          ;117
000376  4401              ADD      r1,r1,r0              ;117
000378  4410              ADD      r0,r0,r2              ;117
00037a  780a              LDRB     r2,[r1,#0]            ;126
00037c  7849              LDRB     r1,[r1,#1]            ;127
00037e  ee002a10          VMOV     s0,r2                 ;126
000382  eeb83a40          VCVT.F32.U32 s6,s0                 ;126
000386  ee001a10          VMOV     s0,r1                 ;127
00038a  7801              LDRB     r1,[r0,#0]            ;128
00038c  7840              LDRB     r0,[r0,#1]            ;129
00038e  eeb82a40          VCVT.F32.U32 s4,s0                 ;127
000392  ee001a10          VMOV     s0,r1                 ;128
000396  eef83a40          VCVT.F32.U32 s7,s0                 ;128
00039a  e000              B        |L292.926|
                  |L292.924|
00039c  e083              B        |L292.1190|
                  |L292.926|
00039e  ee213a83          VMUL.F32 s6,s3,s6              ;129
0003a2  ee000a10          VMOV     s0,r0                 ;129
0003a6  ee611aa3          VMUL.F32 s3,s3,s7              ;129
0003aa  ee003a82          VMLA.F32 s6,s1,s4              ;129
0003ae  eeb80a40          VCVT.F32.U32 s0,s0                 ;129
0003b2  e069              B        |L292.1160|
                  |L292.948|
                          DCD      _ZZN4Anki8Embedded7Interp2IhhEENS_6ResultERKNS0_5ArrayIT_EERKNS3_IfEESA_RNS3_IT0_EENS0_17InterpolationTypeESB_E19__PRETTY_FUNCTION__ ; Anki::Embedded::Interp2<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Array<float>&, Anki::Embedded::Array<T2>&, Anki::Embedded::InterpolationType, T2)::__PRETTY_FUNCTION__
                  |L292.952|
0003b8  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/interp"
0003bc  6f726574
0003c0  6563685c
0003c4  636f6d6d
0003c8  6f6e5c69
0003cc  6e636c75
0003d0  64655c61
0003d4  6e6b692f
0003d8  636f6d6d
0003dc  6f6e2f72
0003e0  6f626f74
0003e4  2f696e74
0003e8  657270  
0003eb  6f6c6174          DCB      "olate.h",0
0003ef  652e6800
0003f3  00                DCB      0
                  |L292.1012|
0003f4  4f6e6c79          DCB      "Only INTERPOLATE_LINEAR is supported",0
0003f8  20494e54
0003fc  4552504f
000400  4c415445
000404  5f4c494e
000408  45415220
00040c  69732073
000410  7570706f
000414  72746564
000418  00      
000419  00                DCB      0
00041a  00                DCB      0
00041b  00                DCB      0
                  |L292.1052|
00041c  496e7465          DCB      "Interp2",0
000420  72703200
                  |L292.1060|
000424  496e7661          DCB      "Invalid objects",0
000428  6c696420
00042c  6f626a65
000430  63747300
                  |L292.1076|
000434  78436f6f          DCB      "xCoordinates, yCoordinates, and out must all be the sam"
000438  7264696e
00043c  61746573
000440  2c207943
000444  6f6f7264
000448  696e6174
00044c  65732c20
000450  616e6420
000454  6f757420
000458  6d757374
00045c  20616c6c
000460  20626520
000464  74686520
000468  73616d  
00046b  65207369          DCB      "e sizes",0
00046f  7a657300
000473  00                DCB      0
                  |L292.1140|
                          DCD      ||.constdata||+0xbe8
                  |L292.1144|
000478  3727c5ac          DCFS     0x3727c5ac ; 9.9999997473787516e-06
                  |L292.1148|
00047c  3f000000          DCFS     0x3f000000 ; 0.5
                  |L292.1152|
                          DCD      ||.constdata||+0xc3c
                  |L292.1156|
                          DCD      0x01000003
                  |L292.1160|
000488  ee401a80          VMLA.F32 s3,s1,s0              ;129
00048c  ee220a83          VMUL.F32 s0,s5,s6              ;129
000490  ee010a21          VMLA.F32 s0,s2,s3              ;129
000494  f7fffffe          BL       _ZN4Anki8Embedded5RoundIiEET_f ; Anki::Embedded::Round<int>(float)
                  |L292.1176|
000498  f8080004          STRB     r0,[r8,r4]            ;135
00049c  9801              LDR      r0,[sp,#4]            ;97
00049e  1c64              ADDS     r4,r4,#1              ;97
0004a0  4284              CMP      r4,r0                 ;97
0004a2  f6ffaefd          BLT      |L292.672|
                  |L292.1190|
0004a6  9800              LDR      r0,[sp,#0]            ;91
0004a8  1c7f              ADDS     r7,r7,#1              ;91
0004aa  4287              CMP      r7,r0                 ;91
0004ac  f6ffaee2          BLT      |L292.628|
                  |L292.1200|
0004b0  2000              MOVS     r0,#0                 ;139
0004b2  e5bd              B        |L292.48|
;;;141    
                          ENDP


                          AREA ||area_number.293||, COMGROUP=_ZN4Anki8Embedded7Interp2IhhEENS_6ResultERKNS0_5ArrayIT_EERKNS3_IfEESA_RNS3_IT0_EENS0_17InterpolationTypeESB_, LINKORDER=||t._ZN4Anki8Embedded7Interp2IhhEENS_6ResultERKNS0_5ArrayIT_EERKNS3_IfEESA_RNS3_IT0_EENS0_17InterpolationTypeESB_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.293||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded7Interp2IhhEENS_6ResultERKNS0_5ArrayIT_EERKNS3_IfEESA_RNS3_IT0_EENS0_17InterpolationTypeESB_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i||, COMGROUP=_ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i PROC ; Anki::Embedded::Linspace<float>(T1, T1, int)
;;;162    
;;;163        template<typename Type> LinearSequence<Type> Linspace(const Type start, const Type end, const s32 size)
000000  b086              SUB      sp,sp,#0x18
000002  f04f32ff          MOV      r2,#0xffffffff
000006  eebf1a00          VMOV.F32 s2,#-1.00000000
00000a  9200              STR      r2,[sp,#0]
00000c  ed8d1a01          VSTR     s2,[sp,#4]
000010  ed8d1a02          VSTR     s2,[sp,#8]
;;;164        {
;;;165          Type increment;
;;;166    
;;;167          LinearSequence<Type> sequence;
;;;168    
;;;169          if(ABS(end-start) <= Flags::numeric_limits<Type>::epsilon()) {
000014  ee301ac0          VSUB.F32 s2,s1,s0
000018  ed9f2a2e          VLDR     s4,|L299.212|
00001c  eeb51ac0          VCMPE.F32 s2,#0.0
000020  eef1fa10          VMRS     APSR_nzcv,FPSCR
000024  bfac              ITE      GE
000026  eef01a41          VMOVGE.F32 s3,s2
00002a  ee701a60          VSUBLT.F32 s3,s0,s1
00002e  eef41ac2          VCMPE.F32 s3,s4
000032  eef1fa10          VMRS     APSR_nzcv,FPSCR
000036  d810              BHI      |L299.90|
000038  9103              STR      r1,[sp,#0xc]          ;164
;;;170            sequence = LinearSequence<Type>(start, 0, end, size);
00003a  eddf0a27          VLDR     s1,|L299.216|
00003e  ed8d0a04          VSTR     s0,[sp,#0x10]
000042  edcd0a05          VSTR     s1,[sp,#0x14]
000046  9100              STR      r1,[sp,#0]
000048  ed8d0a01          VSTR     s0,[sp,#4]
00004c  ee102a10          VMOV     r2,s0
000050  ee103a90          VMOV     r3,s1
000054  edcd0a02          VSTR     s1,[sp,#8]
;;;171          } else {
000058  e028              B        |L299.172|
                  |L299.90|
;;;172            if(size <= 0) {
;;;173              // Empty sequence
;;;174              sequence = LinearSequence<Type>(start, 1, end, 0);
00005a  eef71a00          VMOV.F32 s3,#1.00000000
00005e  2900              CMP      r1,#0                 ;172
000060  dc0d              BGT      |L299.126|
000062  2100              MOVS     r1,#0
000064  9103              STR      r1,[sp,#0xc]
000066  ed8d0a04          VSTR     s0,[sp,#0x10]
00006a  edcd1a05          VSTR     s3,[sp,#0x14]
00006e  9100              STR      r1,[sp,#0]
000070  ee102a10          VMOV     r2,s0
000074  ee113a90          VMOV     r3,s3
000078  ed8d0a01          VSTR     s0,[sp,#4]
;;;175            } else if(size == 1) {
00007c  e027              B        |L299.206|
                  |L299.126|
00007e  2901              CMP      r1,#1
000080  d019              BEQ      |L299.182|
;;;176              // If size == 1, match output with Matlab
;;;177              sequence = LinearSequence<Type>(end, 1, end, size);
;;;178            } else {
;;;179              increment = (end-start) / (size-1);
000082  1e4a              SUBS     r2,r1,#1
000084  ee002a90          VMOV     s1,r2
000088  9103              STR      r1,[sp,#0xc]
00008a  ed8d0a04          VSTR     s0,[sp,#0x10]
00008e  eef81ae0          VCVT.F32.S32 s3,s1
;;;180              sequence = LinearSequence<Type>(start, increment, end, size);
000092  ee102a10          VMOV     r2,s0
000096  eec10a21          VDIV.F32 s1,s2,s3              ;179
00009a  edcd0a05          VSTR     s1,[sp,#0x14]         ;179
00009e  ee103a90          VMOV     r3,s1
0000a2  9100              STR      r1,[sp,#0]
0000a4  ed8d0a01          VSTR     s0,[sp,#4]
0000a8  edcd0a02          VSTR     s1,[sp,#8]
                  |L299.172|
;;;181            }
;;;182          }
;;;183    
;;;184          return sequence;
0000ac  6083              STR      r3,[r0,#8]
0000ae  e9c01200          STRD     r1,r2,[r0,#0]
;;;185        }
0000b2  b006              ADD      sp,sp,#0x18
0000b4  4770              BX       lr
                  |L299.182|
0000b6  9103              STR      r1,[sp,#0xc]
0000b8  edcd0a04          VSTR     s1,[sp,#0x10]
0000bc  edcd1a05          VSTR     s3,[sp,#0x14]
0000c0  ee102a90          VMOV     r2,s1                 ;177
0000c4  ee113a90          VMOV     r3,s3                 ;177
0000c8  9100              STR      r1,[sp,#0]            ;177
0000ca  edcd0a01          VSTR     s1,[sp,#4]            ;177
                  |L299.206|
0000ce  edcd1a02          VSTR     s3,[sp,#8]            ;177
0000d2  e7eb              B        |L299.172|
;;;186    
                          ENDP

                  |L299.212|
0000d4  34000000          DCFS     0x34000000 ; 1.1920928955078125e-07
                  |L299.216|
0000d8  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.300||, COMGROUP=_ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i, LINKORDER=||t._ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.300||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded8LinspaceIfEENS0_14LinearSequenceIT_EES3_S3_i||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE PROC ; Anki::Embedded::Matrix::Transpose<float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
;;;693    
;;;694          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;695          {
000004  460c              MOV      r4,r1
000006  b083              SUB      sp,sp,#0xc
000008  4607              MOV      r7,r0
;;;696            const s32 inHeight = in.get_size(0);
00000a  2100              MOVS     r1,#0
00000c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000010  4680              MOV      r8,r0
;;;697            const s32 inWidth = in.get_size(1);
000012  2101              MOVS     r1,#1
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001a  4606              MOV      r6,r0
00001c  4638              MOV      r0,r7
00001e  68a5              LDR      r5,[r4,#8]
000020  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
;;;698    
;;;699            const s32 outStride = out.get_stride();
;;;700    
;;;701            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
000024  f8df9148          LDR      r9,|L306.368|
000028  2800              CMP      r0,#0
00002a  d076              BEQ      |L306.282|
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000032  2800              CMP      r0,#0
000034  d071              BEQ      |L306.282|
;;;702              RESULT_FAIL_INVALID_OBJECT, "Transpose", "Invalid objects");
;;;703    
;;;704            AnkiConditionalErrorAndReturnValue(AreEqualSize(in.get_size(1), in.get_size(0), out),
000036  2100              MOVS     r1,#0
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00003e  4682              MOV      r10,r0
000040  2101              MOVS     r1,#1
000042  4638              MOV      r0,r7
000044  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000048  4622              MOV      r2,r4
00004a  4651              MOV      r1,r10
00004c  f7fffffe          BL       _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_ ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<float>>(int, int, const T1&)
000050  2800              CMP      r0,#0
000052  d073              BEQ      |L306.316|
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00005a  2800              CMP      r0,#0
;;;705              RESULT_FAIL_INVALID_SIZE, "Transpose", "out is not the correct size");
;;;706    
;;;707            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
00005c  d07b              BEQ      |L306.342|
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000064  2800              CMP      r0,#0
000066  d076              BEQ      |L306.342|
000068  6938              LDR      r0,[r7,#0x10]
00006a  9000              STR      r0,[sp,#0]
00006c  6920              LDR      r0,[r4,#0x10]
00006e  2100              MOVS     r1,#0
000070  466a              MOV      r2,sp
000072  9001              STR      r0,[sp,#4]
                  |L306.116|
000074  1c48              ADDS     r0,r1,#1
000076  2802              CMP      r0,#2
000078  bfb8              IT       LT
00007a  f8523021          LDRLT    r3,[r2,r1,LSL #2]
00007e  da06              BGE      |L306.142|
                  |L306.128|
000080  f852c020          LDR      r12,[r2,r0,LSL #2]
000084  4563              CMP      r3,r12
000086  d066              BEQ      |L306.342|
000088  1c40              ADDS     r0,r0,#1
00008a  2802              CMP      r0,#2
00008c  dbf8              BLT      |L306.128|
                  |L306.142|
00008e  1c49              ADDS     r1,r1,#1
000090  2902              CMP      r1,#2
000092  dbef              BLT      |L306.116|
;;;708              RESULT_FAIL_ALIASED_MEMORY, "Transpose", "in and out cannot be the same array");
;;;709    
;;;710            for(s32 yIn=0; yIn<inHeight; yIn++) {
000094  2200              MOVS     r2,#0
000096  f1b80f00          CMP      r8,#0
;;;711              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;712              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0,yIn));
;;;713    
;;;714              s32 xIn;
;;;715              s32 outOffset0 = 0;
;;;716    
;;;717              for(xIn=0; xIn<inWidth-1; xIn+=2) {
00009a  bfc8              IT       GT
00009c  f1a60a01          SUBGT    r10,r6,#1
0000a0  dd36              BLE      |L306.272|
                  |L306.162|
0000a2  68b9              LDR      r1,[r7,#8]            ;710
0000a4  6938              LDR      r0,[r7,#0x10]         ;710
0000a6  68a3              LDR      r3,[r4,#8]            ;710
0000a8  fb020c01          MLA      r12,r2,r1,r0          ;710
0000ac  6921              LDR      r1,[r4,#0x10]         ;710
0000ae  2000              MOVS     r0,#0                 ;712
0000b0  fb001003          MLA      r0,r0,r3,r1           ;712
0000b4  2100              MOVS     r1,#0                 ;715
0000b6  eb000982          ADD      r9,r0,r2,LSL #2       ;715
0000ba  4608              MOV      r0,r1
0000bc  f1ba0f00          CMP      r10,#0
0000c0  dd12              BLE      |L306.232|
                  |L306.194|
;;;718                const InType in0 = pIn[xIn];
0000c2  eb0c0380          ADD      r3,r12,r0,LSL #2
;;;719                const InType in1 = pIn[xIn+1];
;;;720    
;;;721                const s32 outOffset1 = outOffset0 + outStride;
;;;722    
;;;723                *reinterpret_cast<OutType*>(pOut + outOffset0) = static_cast<OutType>(in0);
0000c6  eb090b01          ADD      r11,r9,r1
0000ca  ed930a00          VLDR     s0,[r3,#0]            ;718
0000ce  edd30a01          VLDR     s1,[r3,#4]            ;719
0000d2  194b              ADDS     r3,r1,r5              ;721
;;;724                *reinterpret_cast<OutType*>(pOut + outOffset1) = static_cast<OutType>(in1);
0000d4  444b              ADD      r3,r3,r9
0000d6  ed8b0a00          VSTR     s0,[r11,#0]           ;723
0000da  1c80              ADDS     r0,r0,#2              ;717
0000dc  edc30a00          VSTR     s1,[r3,#0]
;;;725    
;;;726                outOffset0 += 2*outStride;
0000e0  eb010145          ADD      r1,r1,r5,LSL #1
0000e4  4582              CMP      r10,r0                ;717
0000e6  dcec              BGT      |L306.194|
                  |L306.232|
;;;727              }
;;;728    
;;;729              for(; xIn<inWidth; xIn++) {
0000e8  42b0              CMP      r0,r6
0000ea  da0e              BGE      |L306.266|
                  |L306.236|
0000ec  68a3              LDR      r3,[r4,#8]
0000ee  6921              LDR      r1,[r4,#0x10]
0000f0  fb001103          MLA      r1,r0,r3,r1
;;;730                *out.Pointer(xIn,yIn) = static_cast<OutType>(pIn[xIn]);
0000f4  eb0c0380          ADD      r3,r12,r0,LSL #2
0000f8  eb010182          ADD      r1,r1,r2,LSL #2
0000fc  ed930a00          VLDR     s0,[r3,#0]
000100  1c40              ADDS     r0,r0,#1              ;729
000102  ed810a00          VSTR     s0,[r1,#0]
000106  42b0              CMP      r0,r6                 ;729
000108  dbf0              BLT      |L306.236|
                  |L306.266|
00010a  1c52              ADDS     r2,r2,#1              ;710
00010c  4542              CMP      r2,r8                 ;710
00010e  dbc8              BLT      |L306.162|
                  |L306.272|
;;;731              }
;;;732            }
;;;733    
;;;734            return RESULT_OK;
;;;735          } // Transpose()
000110  b003              ADD      sp,sp,#0xc
000112  2000              MOVS     r0,#0                 ;734
000114  e8bd8ff0          POP      {r4-r11,pc}
000118  e7ff              B        |L306.282|
                  |L306.282|
00011a  f24020bd          MOV      r0,#0x2bd             ;701
00011e  e9cd9000          STRD     r9,r0,[sp,#0]         ;701
000122  a314              ADR      r3,|L306.372|
000124  a221              ADR      r2,|L306.428|
000126  a125              ADR      r1,|L306.444|
000128  2005              MOVS     r0,#5                 ;701
00012a  f7fffffe          BL       _Anki_Log
00012e  f04f6080          MOV      r0,#0x4000000         ;701
                  |L306.306|
000132  b003              ADD      sp,sp,#0xc
000134  e8bd8ff0          POP      {r4-r11,pc}
000138  e000              B        |L306.316|
00013a  e00c              B        |L306.342|
                  |L306.316|
00013c  f44f7030          MOV      r0,#0x2c0             ;704
000140  e9cd9000          STRD     r9,r0,[sp,#0]         ;704
000144  a30b              ADR      r3,|L306.372|
000146  a220              ADR      r2,|L306.456|
000148  a11c              ADR      r1,|L306.444|
00014a  2005              MOVS     r0,#5                 ;704
00014c  f7fffffe          BL       _Anki_Log
000150  f04f60a0          MOV      r0,#0x5000000         ;704
000154  e7ed              B        |L306.306|
                  |L306.342|
000156  f24020c3          MOV      r0,#0x2c3             ;707
00015a  e9cd9000          STRD     r9,r0,[sp,#0]         ;707
00015e  a305              ADR      r3,|L306.372|
000160  a220              ADR      r2,|L306.484|
000162  a116              ADR      r1,|L306.444|
000164  2005              MOVS     r0,#5                 ;707
000166  f7fffffe          BL       _Anki_Log
00016a  4827              LDR      r0,|L306.520|
00016c  e7e1              B        |L306.306|
;;;736    
                          ENDP

00016e  0000              DCW      0x0000
                  |L306.368|
                          DCD      _ZZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Transpose<float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L306.372|
000174  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000178  6f726574
00017c  6563685c
000180  636f6d6d
000184  6f6e5c69
000188  6e636c75
00018c  64655c61
000190  6e6b692f
000194  636f6d6d
000198  6f6e2f72
00019c  6f626f74
0001a0  2f6d6174
0001a4  726978  
0001a7  2e6800            DCB      ".h",0
0001aa  00                DCB      0
0001ab  00                DCB      0
                  |L306.428|
0001ac  496e7661          DCB      "Invalid objects",0
0001b0  6c696420
0001b4  6f626a65
0001b8  63747300
                  |L306.444|
0001bc  5472616e          DCB      "Transpose",0
0001c0  73706f73
0001c4  6500    
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L306.456|
0001c8  6f757420          DCB      "out is not the correct size",0
0001cc  6973206e
0001d0  6f742074
0001d4  68652063
0001d8  6f727265
0001dc  63742073
0001e0  697a6500
                  |L306.484|
0001e4  696e2061          DCB      "in and out cannot be the same array",0
0001e8  6e64206f
0001ec  75742063
0001f0  616e6e6f
0001f4  74206265
0001f8  20746865
0001fc  2073616d
000200  65206172
000204  72617900
                  |L306.520|
                          DCD      0x01000003

                          AREA ||area_number.307||, COMGROUP=_ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.307||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE PROC ; Anki::Embedded::Matrix::MultiplyTranspose<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
                  ||__tagsym$$noinline||
;;;299    
;;;300          template<typename InType, typename OutType> NO_INLINE Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;301          {
000004  460d              MOV      r5,r1
000006  b083              SUB      sp,sp,#0xc
000008  4616              MOV      r6,r2
00000a  4680              MOV      r8,r0
;;;302            const s32 in1Height = in1.get_size(0);
00000c  2100              MOVS     r1,#0
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000012  4681              MOV      r9,r0
;;;303            const s32 in1Width = in1.get_size(1);
000014  2101              MOVS     r1,#1
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001c  4682              MOV      r10,r0
;;;304    
;;;305            const s32 in2TransposedHeight = in2Transposed.get_size(0);
00001e  2100              MOVS     r1,#0
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000026  4607              MOV      r7,r0
;;;306            const s32 in2TransposedWidth = in2Transposed.get_size(1);
000028  2101              MOVS     r1,#1
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000030  4604              MOV      r4,r0
;;;307    
;;;308            AnkiConditionalErrorAndReturnValue(in1Width == in2TransposedWidth,
000032  f8dfb110          LDR      r11,|L313.324|
000036  45a2              CMP      r10,r4
000038  d00e              BEQ      |L313.88|
00003a  f44f709a          MOV      r0,#0x134
00003e  e9cdb000          STRD     r11,r0,[sp,#0]
000042  a341              ADR      r3,|L313.328|
000044  a24e              ADR      r2,|L313.384|
000046  a158              ADR      r1,|L313.424|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
;;;309              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;310    
;;;311            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2TransposedHeight, out),
;;;312              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;313    
;;;314            for(s32 y1=0; y1<in1Height; y1++)
;;;315            {
;;;316              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;317    
;;;318              for(s32 y2=0; y2<in2TransposedHeight; y2++) {
;;;319                const InType * restrict pIn2 = in2Transposed.Pointer(y2, 0);
;;;320    
;;;321                OutType accumulator = 0;
;;;322    
;;;323                s32 x;
;;;324                for(x=0; x<in2TransposedWidth-3; x+=4) {
;;;325                  const InType in1_0 = pIn1[x];
;;;326                  const InType in1_1 = pIn1[x+1];
;;;327                  const InType in1_2 = pIn1[x+2];
;;;328                  const InType in1_3 = pIn1[x+3];
;;;329    
;;;330                  const InType in2_0 = pIn2[x];
;;;331                  const InType in2_1 = pIn2[x+1];
;;;332                  const InType in2_2 = pIn2[x+2];
;;;333                  const InType in2_3 = pIn2[x+3];
;;;334    
;;;335                  accumulator +=
;;;336                    in1_0 * in2_0 +
;;;337                    in1_1 * in2_1 +
;;;338                    in1_2 * in2_2 +
;;;339                    in1_3 * in2_3;
;;;340                }
;;;341    
;;;342                for(; x<in2TransposedWidth; x++) {
;;;343                  accumulator += pIn1[x] * pIn2[x];
;;;344                }
;;;345    
;;;346                *out.Pointer(y1, y2) = accumulator;
;;;347              }
;;;348            }
;;;349    
;;;350            return RESULT_OK;
;;;351          } // template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
00004e  b003              ADD      sp,sp,#0xc
000050  f04f60a0          MOV      r0,#0x5000000         ;308
000054  e8bd8ff0          POP      {r4-r11,pc}
                  |L313.88|
000058  4632              MOV      r2,r6                 ;311
00005a  4639              MOV      r1,r7                 ;311
00005c  4648              MOV      r0,r9                 ;311
00005e  f7fffffe          BL       _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_ ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<float>>(int, int, const T1&)
000062  2800              CMP      r0,#0                 ;311
000064  d05f              BEQ      |L313.294|
000066  f04f0a00          MOV      r10,#0                ;314
00006a  f1b90f00          CMP      r9,#0                 ;314
00006e  bfc4              ITT      GT                    ;321
000070  eddf4a50          VLDRGT   s9,|L313.436|
000074  f1a40b03          SUBGT    r11,r4,#3             ;324
000078  dd51              BLE      |L313.286|
                  |L313.122|
00007a  f8d81008          LDR      r1,[r8,#8]            ;314
00007e  f8d80010          LDR      r0,[r8,#0x10]         ;314
000082  2200              MOVS     r2,#0                 ;318
000084  fb0a0c01          MLA      r12,r10,r1,r0         ;318
000088  2f00              CMP      r7,#0                 ;318
00008a  dd44              BLE      |L313.278|
                  |L313.140|
00008c  68a9              LDR      r1,[r5,#8]            ;318
00008e  6928              LDR      r0,[r5,#0x10]         ;318
000090  eeb00a64          VMOV.F32 s0,s9                 ;321
000094  fb020301          MLA      r3,r2,r1,r0           ;321
000098  2000              MOVS     r0,#0                 ;324
00009a  f1bb0f00          CMP      r11,#0                ;324
00009e  dd20              BLE      |L313.226|
                  |L313.160|
0000a0  eb0c0180          ADD      r1,r12,r0,LSL #2      ;325
0000a4  ed914a00          VLDR     s8,[r1,#0]            ;325
0000a8  ed912a01          VLDR     s4,[r1,#4]            ;326
0000ac  edd13a02          VLDR     s7,[r1,#8]            ;327
0000b0  ed913a03          VLDR     s6,[r1,#0xc]          ;328
0000b4  eb030180          ADD      r1,r3,r0,LSL #2       ;330
0000b8  1d00              ADDS     r0,r0,#4              ;324
0000ba  edd12a00          VLDR     s5,[r1,#0]            ;330
0000be  edd11a01          VLDR     s3,[r1,#4]            ;331
0000c2  ed911a02          VLDR     s2,[r1,#8]            ;332
0000c6  ee642a22          VMUL.F32 s5,s8,s5              ;335
0000ca  edd10a03          VLDR     s1,[r1,#0xc]          ;333
0000ce  4583              CMP      r11,r0                ;324
0000d0  ee422a21          VMLA.F32 s5,s4,s3              ;335
0000d4  ee432a81          VMLA.F32 s5,s7,s2              ;335
0000d8  ee432a20          VMLA.F32 s5,s6,s1              ;335
0000dc  ee320a80          VADD.F32 s0,s5,s0              ;335
0000e0  dcde              BGT      |L313.160|
                  |L313.226|
0000e2  42a0              CMP      r0,r4                 ;342
0000e4  da0c              BGE      |L313.256|
                  |L313.230|
0000e6  eb0c0180          ADD      r1,r12,r0,LSL #2      ;343
0000ea  edd10a00          VLDR     s1,[r1,#0]            ;343
0000ee  eb030180          ADD      r1,r3,r0,LSL #2       ;343
0000f2  1c40              ADDS     r0,r0,#1              ;342
0000f4  ed911a00          VLDR     s2,[r1,#0]            ;343
0000f8  42a0              CMP      r0,r4                 ;342
0000fa  ee000a81          VMLA.F32 s0,s1,s2              ;343
0000fe  dbf2              BLT      |L313.230|
                  |L313.256|
000100  68b1              LDR      r1,[r6,#8]            ;342
000102  6930              LDR      r0,[r6,#0x10]         ;342
000104  fb0a0001          MLA      r0,r10,r1,r0          ;342
000108  eb000082          ADD      r0,r0,r2,LSL #2       ;342
00010c  1c52              ADDS     r2,r2,#1              ;318
00010e  ed800a00          VSTR     s0,[r0,#0]            ;346
000112  42ba              CMP      r2,r7                 ;318
000114  dbba              BLT      |L313.140|
                  |L313.278|
000116  f10a0a01          ADD      r10,r10,#1            ;314
00011a  45ca              CMP      r10,r9                ;314
00011c  dbad              BLT      |L313.122|
                  |L313.286|
00011e  b003              ADD      sp,sp,#0xc
000120  2000              MOVS     r0,#0                 ;350
000122  e8bd8ff0          POP      {r4-r11,pc}
                  |L313.294|
000126  f2401037          MOV      r0,#0x137             ;311
00012a  e9cdb000          STRD     r11,r0,[sp,#0]        ;311
00012e  a306              ADR      r3,|L313.328|
000130  a221              ADR      r2,|L313.440|
000132  a11d              ADR      r1,|L313.424|
000134  2005              MOVS     r0,#5                 ;311
000136  f7fffffe          BL       _Anki_Log
00013a  b003              ADD      sp,sp,#0xc
00013c  f04f60a0          MOV      r0,#0x5000000         ;311
000140  e8bd8ff0          POP      {r4-r11,pc}
;;;352    
                          ENDP

                  |L313.324|
                          DCD      _ZZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::MultiplyTranspose<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L313.328|
000148  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
00014c  6f726574
000150  6563685c
000154  636f6d6d
000158  6f6e5c69
00015c  6e636c75
000160  64655c61
000164  6e6b692f
000168  636f6d6d
00016c  6f6e2f72
000170  6f626f74
000174  2f6d6174
000178  726978  
00017b  2e6800            DCB      ".h",0
00017e  00                DCB      0
00017f  00                DCB      0
                  |L313.384|
000180  496e7075          DCB      "Input matrices are incompatible sizes",0
000184  74206d61
000188  74726963
00018c  65732061
000190  72652069
000194  6e636f6d
000198  70617469
00019c  626c6520
0001a0  73697a65
0001a4  7300    
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L313.424|
0001a8  4d756c74          DCB      "Multiply",0
0001ac  69706c79
0001b0  00      
0001b1  00                DCB      0
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L313.436|
0001b4  00000000          DCFS     0x00000000 ; 0
                  |L313.440|
0001b8  496e7075          DCB      "Input and Output matrices are incompatible sizes",0
0001bc  7420616e
0001c0  64204f75
0001c4  74707574
0001c8  206d6174
0001cc  72696365
0001d0  73206172
0001d4  6520696e
0001d8  636f6d70
0001dc  61746962
0001e0  6c652073
0001e4  697a6573
0001e8  00      
0001e9  00                DCB      0
0001ea  00                DCB      0
0001eb  00                DCB      0

                          AREA ||area_number.314||, COMGROUP=_ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.314||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE||, COMGROUP=_ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE PROC ; Anki::Embedded::Matrix::EstimateHomography<float>(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, Anki::Embedded::Array<T1>&, bool&, Anki::Embedded::MemoryStack)
                  |symbol_number.401|
;;;468    
;;;469          template<typename Type> NO_INLINE Result EstimateHomography(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;470            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;471            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;472            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;473            bool &numericalFailure, //!< Did the homography solver fail?
;;;474            MemoryStack scratch //!< Scratch memory
;;;475            )
;;;476          {
000004  4607              MOV      r7,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  b0af              SUB      sp,sp,#0xbc
;;;477            const Type MAX_SOLVE_DISTANCE = static_cast<Type>(0.1);
;;;478    
;;;479            //BeginBenchmark("EstimateHomography_init");
;;;480    
;;;481            const s32 numPoints = originalPoints.get_size();
;;;482    
;;;483            AnkiConditionalErrorAndReturnValue(AreValid(originalPoints, transformedPoints, homography, scratch),
00000c  68c5              LDR      r5,[r0,#0xc]
00000e  983a              LDR      r0,[sp,#0xe8]
000010  9000              STR      r0,[sp,#0]
000012  4699              MOV      r9,r3                 ;476
000014  4614              MOV      r4,r2                 ;476
000016  460e              MOV      r6,r1                 ;476
000018  4638              MOV      r0,r7                 ;476
00001a  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::get_maximumSize() const
00001e  f8dfa424          LDR      r10,|L320.1092|
000022  4285              CMP      r5,r0
000024  dc3d              BGT      |L320.162|
000026  6ab8              LDR      r0,[r7,#0x28]
000028  b130              CBZ      r0,|L320.56|
00002a  69b8              LDR      r0,[r7,#0x18]
00002c  2800              CMP      r0,#0
00002e  bfa3              ITTTE    GE
000030  69f8              LDRGE    r0,[r7,#0x1c]
000032  2800              CMPGE    r0,#0
000034  2001              MOVGE    r0,#1
000036  2000              MOVLT    r0,#0
                  |L320.56|
000038  2800              CMP      r0,#0
00003a  d032              BEQ      |L320.162|
00003c  46b0              MOV      r8,r6
00003e  4630              MOV      r0,r6
000040  f8d6b00c          LDR      r11,[r6,#0xc]
000044  f7fffffe          BL       _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::get_maximumSize() const
000048  4583              CMP      r11,r0
00004a  dc2a              BGT      |L320.162|
00004c  f8d80028          LDR      r0,[r8,#0x28]
000050  b140              CBZ      r0,|L320.100|
000052  f8d80018          LDR      r0,[r8,#0x18]
000056  2800              CMP      r0,#0
000058  bfa3              ITTTE    GE
00005a  f8d8001c          LDRGE    r0,[r8,#0x1c]
00005e  2800              CMPGE    r0,#0
000060  2001              MOVGE    r0,#1
000062  2000              MOVLT    r0,#0
                  |L320.100|
000064  b1e8              CBZ      r0,|L320.162|
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00006c  b1c8              CBZ      r0,|L320.162|
00006e  9800              LDR      r0,[sp,#0]
000070  f7fffffe          BL       _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
000074  b1a8              CBZ      r0,|L320.162|
;;;484              RESULT_FAIL_INVALID_OBJECT, "EstimateHomography", "Invalid objects");
;;;485    
;;;486            AnkiConditionalErrorAndReturnValue(transformedPoints.get_size() == numPoints && numPoints >= 4,
000076  68f0              LDR      r0,[r6,#0xc]
000078  42a8              CMP      r0,r5
00007a  d101              BNE      |L320.128|
00007c  2d04              CMP      r5,#4
00007e  da1d              BGE      |L320.188|
                  |L320.128|
000080  f44f70f3          MOV      r0,#0x1e6
000084  e9cda000          STRD     r10,r0,[sp,#0]
000088  a3ef              ADR      r3,|L320.1096|
00008a  4afd              LDR      r2,|L320.1152|
00008c  a1fd              ADR      r1,|L320.1156|
00008e  2005              MOVS     r0,#5
000090  f7fffffe          BL       _Anki_Log
000094  f04f60a0          MOV      r0,#0x5000000
                  |L320.152|
;;;487              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "originalPoints and transformedPoints must be the same size, and have at least four points apiece.");
;;;488    
;;;489            AnkiConditionalErrorAndReturnValue(AreEqualSize(3, 3, homography),
;;;490              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "homography must be 3x3");
;;;491    
;;;492            homography.SetZero();
;;;493            homography[0][0] = 1;
;;;494            homography[1][1] = 1;
;;;495            homography[2][2] = 1;
;;;496    
;;;497            Array<Type> A(8, 2*numPoints, scratch);
;;;498            Array<Type> bt(1, 2*numPoints, scratch);
;;;499    
;;;500            const Point<Type> * const pOriginalPoints = originalPoints.Pointer(0);
;;;501            const Point<Type> * const pTransformedPoints = transformedPoints.Pointer(0);
;;;502    
;;;503            Type * restrict pBt = bt.Pointer(0,0);
;;;504    
;;;505            //EndBenchmark("EstimateHomography_init");
;;;506    
;;;507            //BeginBenchmark("EstimateHomography_a&b");
;;;508    
;;;509            for(s32 i=0; i<numPoints; i++) {
;;;510              Type * restrict A_y1 = A.Pointer(2*i, 0);
;;;511              Type * restrict A_y2 = A.Pointer(2*i + 1, 0);
;;;512    
;;;513              const Type xi = pOriginalPoints[i].x;
;;;514              const Type yi = pOriginalPoints[i].y;
;;;515    
;;;516              const Type xp = pTransformedPoints[i].x;
;;;517              const Type yp = pTransformedPoints[i].y;
;;;518    
;;;519              A_y1[0] = 0;  A_y1[1] = 0;  A_y1[2] = 0; A_y1[3] = -xi; A_y1[4] = -yi; A_y1[5] = -1; A_y1[6] = xi*yp;  A_y1[7] = yi*yp;
;;;520              A_y2[0] = xi; A_y2[1] = yi; A_y2[2] = 1; A_y2[3] = 0;   A_y2[4] = 0;   A_y2[5] = 0;  A_y2[6] = -xi*xp; A_y2[7] = -yi*xp;
;;;521    
;;;522              pBt[2*i] = -yp;
;;;523              pBt[2*i + 1] = xp;
;;;524            }
;;;525    
;;;526            //EndBenchmark("EstimateHomography_a&b");
;;;527    
;;;528            //BeginBenchmark("EstimateHomography_At");
;;;529    
;;;530            Array<Type> At(2*numPoints, 8, scratch);
;;;531    
;;;532            Matrix::Transpose(A, At);
;;;533    
;;;534            //EndBenchmark("EstimateHomography_At");
;;;535    
;;;536            //BeginBenchmark("EstimateHomography_AtA");
;;;537    
;;;538            Array<Type> AtA(8, 8, scratch, Flags::Buffer(false,false,false));
;;;539            Array<Type> Atb(8, 1, scratch, Flags::Buffer(false,false,false));
;;;540    
;;;541            Matrix::Multiply(At, A, AtA);
;;;542    
;;;543            //EndBenchmark("EstimateHomography_AtA");
;;;544    
;;;545            //BeginBenchmark("EstimateHomography_Atb");
;;;546    
;;;547            Matrix::MultiplyTranspose(At, bt, Atb);
;;;548    
;;;549            //EndBenchmark("EstimateHomography_Atb");
;;;550    
;;;551            //BeginBenchmark("EstimateHomography_transposeAtb");
;;;552    
;;;553            Array<Type> Atbt(1, 8, scratch);
;;;554    
;;;555            Matrix::Transpose(Atb, Atbt);
;;;556    
;;;557            //EndBenchmark("EstimateHomography_transposeAtb");
;;;558    
;;;559            //BeginBenchmark("EstimateHomography_cholesky");
;;;560    
;;;561            const Result choleskyResult = SolveLeastSquaresWithCholesky(AtA, Atbt, false, numericalFailure);
;;;562    
;;;563            AnkiConditionalErrorAndReturnValue(choleskyResult == RESULT_OK,
;;;564              choleskyResult, "EstimateHomography", "SolveLeastSquaresWithCholesky failed");
;;;565    
;;;566            if(numericalFailure){
;;;567              AnkiWarn("EstimateHomography", "numericalFailure");
;;;568              return RESULT_OK;
;;;569            }
;;;570    
;;;571            Type * restrict pAtbt = Atbt.Pointer(0,0);
;;;572    
;;;573            homography[0][0] = pAtbt[0]; homography[0][1] = pAtbt[1]; homography[0][2] = pAtbt[2];
;;;574            homography[1][0] = pAtbt[3]; homography[1][1] = pAtbt[4]; homography[1][2] = pAtbt[5];
;;;575            homography[2][0] = pAtbt[6]; homography[2][1] = pAtbt[7]; homography[2][2] = static_cast<Type>(1);
;;;576    
;;;577            // Check that the solution is fairly close
;;;578            // TODO: make work for numPoints != 4
;;;579            if(numPoints == 4) {
;;;580              Array<Type> point1(3,1,scratch);
;;;581              Array<Type> point1Warped(3,1,scratch);
;;;582              for(s32 iPoint=0; iPoint<numPoints; iPoint++) {
;;;583                point1[0][0] = originalPoints[iPoint].x;
;;;584                point1[1][0] = originalPoints[iPoint].y;
;;;585                point1[2][0] = 1;
;;;586    
;;;587                Matrix::Multiply(homography, point1, point1Warped);
;;;588                point1Warped[0][0] /= point1Warped[2][0];
;;;589                point1Warped[1][0] /= point1Warped[2][0];
;;;590    
;;;591                const Type distance = sqrtf(powf(static_cast<f32>(transformedPoints[iPoint].x) - static_cast<f32>(point1Warped[0][0]), 2.0f) + powf(static_cast<f32>(transformedPoints[iPoint].y) - static_cast<f32>(point1Warped[1][0]), 2.0f));
;;;592    
;;;593                if(distance > MAX_SOLVE_DISTANCE) {
;;;594                  AnkiWarn("EstimateHomography", "Poor solution precision");
;;;595    
;;;596                  numericalFailure = true;
;;;597    
;;;598                  homography.SetZero();
;;;599                  homography[0][0] = 1;
;;;600                  homography[1][1] = 1;
;;;601                  homography[2][2] = 1;
;;;602    
;;;603                  return RESULT_OK;
;;;604                }
;;;605              }
;;;606            }
;;;607            //EndBenchmark("EstimateHomography_cholesky");
;;;608    
;;;609            return RESULT_OK;
;;;610          } // EstimateHomography()
000098  b02f              ADD      sp,sp,#0xbc
00009a  ecbd8b02          VPOP     {d8}
00009e  e8bd8ff0          POP      {r4-r11,pc}
                  |L320.162|
0000a2  f24010e3          MOV      r0,#0x1e3             ;483
0000a6  e9cda000          STRD     r10,r0,[sp,#0]        ;483
0000aa  a3e7              ADR      r3,|L320.1096|
0000ac  a2fa              ADR      r2,|L320.1176|
0000ae  a1f5              ADR      r1,|L320.1156|
0000b0  2005              MOVS     r0,#5                 ;483
0000b2  f7fffffe          BL       _Anki_Log
0000b6  f04f6080          MOV      r0,#0x4000000         ;483
0000ba  e7ed              B        |L320.152|
                  |L320.188|
0000bc  2103              MOVS     r1,#3                 ;489
0000be  4622              MOV      r2,r4                 ;489
0000c0  4608              MOV      r0,r1                 ;489
0000c2  f7fffffe          BL       _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_ ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<float>>(int, int, const T1&)
0000c6  2800              CMP      r0,#0                 ;489
0000c8  f00080f5          BEQ.W    |L320.694|
0000cc  4620              MOV      r0,r4                 ;492
0000ce  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE7SetZeroEv ; Anki::Embedded::Array<float>::SetZero()
0000d2  68a2              LDR      r2,[r4,#8]            ;492
0000d4  6921              LDR      r1,[r4,#0x10]         ;492
0000d6  2000              MOVS     r0,#0                 ;493
0000d8  fb001002          MLA      r0,r0,r2,r1           ;493
0000dc  eeb78a00          VMOV.F32 s16,#1.00000000       ;493
0000e0  ed808a00          VSTR     s16,[r0,#0]           ;493
0000e4  68a2              LDR      r2,[r4,#8]            ;493
0000e6  6921              LDR      r1,[r4,#0x10]         ;493
0000e8  2001              MOVS     r0,#1                 ;494
0000ea  fb001002          MLA      r0,r0,r2,r1           ;494
0000ee  2300              MOVS     r3,#0                 ;497
0000f0  ed808a01          VSTR     s16,[r0,#4]           ;494
0000f4  68a2              LDR      r2,[r4,#8]            ;494
0000f6  6921              LDR      r1,[r4,#0x10]         ;494
0000f8  2002              MOVS     r0,#2                 ;495
0000fa  fb001002          MLA      r0,r0,r2,r1           ;495
0000fe  461a              MOV      r2,r3                 ;497
000100  ed808a02          VSTR     s16,[r0,#8]           ;495
000104  2101              MOVS     r1,#1                 ;497
000106  a82b              ADD      r0,sp,#0xac           ;497
000108  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00010c  006a              LSLS     r2,r5,#1              ;497
00010e  6800              LDR      r0,[r0,#0]            ;497
000110  e9cd0200          STRD     r0,r2,[sp,#0]         ;497
000114  4690              MOV      r8,r2                 ;497
000116  2108              MOVS     r1,#8                 ;497
000118  a807              ADD      r0,sp,#0x1c           ;497
00011a  9b3a              LDR      r3,[sp,#0xe8]         ;497
00011c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000120  2300              MOVS     r3,#0                 ;498
000122  461a              MOV      r2,r3                 ;498
000124  2101              MOVS     r1,#1                 ;498
000126  a82a              ADD      r0,sp,#0xa8           ;498
000128  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00012c  6800              LDR      r0,[r0,#0]            ;498
00012e  9000              STR      r0,[sp,#0]            ;498
000130  4642              MOV      r2,r8                 ;498
000132  2101              MOVS     r1,#1                 ;498
000134  a825              ADD      r0,sp,#0x94           ;498
000136  9b3a              LDR      r3,[sp,#0xe8]         ;498
000138  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00013c  9a27              LDR      r2,[sp,#0x9c]         ;498
00013e  9929              LDR      r1,[sp,#0xa4]         ;498
000140  2000              MOVS     r0,#0                 ;503
000142  fb001c02          MLA      r12,r0,r2,r1          ;503
000146  f8d7b030          LDR      r11,[r7,#0x30]        ;503
00014a  f8d68030          LDR      r8,[r6,#0x30]         ;503
00014e  4602              MOV      r2,r0                 ;509
000150  ed9f2ad5          VLDR     s4,|L320.1192|
000154  eeff2a00          VMOV.F32 s5,#-1.00000000       ;519
                  |L320.344|
000158  9b09              LDR      r3,[sp,#0x24]         ;519
00015a  990b              LDR      r1,[sp,#0x2c]         ;519
00015c  0050              LSLS     r0,r2,#1              ;510
00015e  fb001103          MLA      r1,r0,r3,r1           ;510
000162  2001              MOVS     r0,#1                 ;511
000164  f8dde024          LDR      lr,[sp,#0x24]         ;511
000168  9b0b              LDR      r3,[sp,#0x2c]         ;511
00016a  eb000042          ADD      r0,r0,r2,LSL #1       ;511
00016e  fb00300e          MLA      r0,r0,lr,r3           ;511
000172  eb0b03c2          ADD      r3,r11,r2,LSL #3      ;513
000176  edd30a00          VLDR     s1,[r3,#0]            ;513
00017a  ed930a01          VLDR     s0,[r3,#4]            ;514
00017e  eb0803c2          ADD      r3,r8,r2,LSL #3       ;516
000182  eeb13a60          VNEG.F32 s6,s1                 ;519
000186  edd31a00          VLDR     s3,[r3,#0]            ;516
00018a  ed931a01          VLDR     s2,[r3,#4]            ;517
00018e  ed812a00          VSTR     s4,[r1,#0]            ;519
000192  ed812a01          VSTR     s4,[r1,#4]            ;519
000196  ed812a02          VSTR     s4,[r1,#8]            ;519
00019a  ed813a03          VSTR     s6,[r1,#0xc]          ;519
00019e  eeb13a40          VNEG.F32 s6,s0                 ;519
0001a2  ed813a04          VSTR     s6,[r1,#0x10]         ;519
0001a6  ee203a81          VMUL.F32 s6,s1,s2              ;519
0001aa  edc12a05          VSTR     s5,[r1,#0x14]         ;519
0001ae  ed813a06          VSTR     s6,[r1,#0x18]         ;519
0001b2  ee203a01          VMUL.F32 s6,s0,s2              ;519
0001b6  ed813a07          VSTR     s6,[r1,#0x1c]         ;519
0001ba  edc00a00          VSTR     s1,[r0,#0]            ;520
0001be  ed800a01          VSTR     s0,[r0,#4]            ;520
0001c2  ed808a02          VSTR     s16,[r0,#8]           ;520
0001c6  ed802a03          VSTR     s4,[r0,#0xc]          ;520
0001ca  ee600ae1          VNMUL.F32 s1,s1,s3              ;520
0001ce  ed802a04          VSTR     s4,[r0,#0x10]         ;520
0001d2  ee200a61          VNMUL.F32 s0,s0,s3              ;520
0001d6  ed802a05          VSTR     s4,[r0,#0x14]         ;520
0001da  edc00a06          VSTR     s1,[r0,#0x18]         ;520
0001de  ed800a07          VSTR     s0,[r0,#0x1c]         ;520
0001e2  eb0c00c2          ADD      r0,r12,r2,LSL #3      ;522
0001e6  eeb10a41          VNEG.F32 s0,s2                 ;522
0001ea  ed800a00          VSTR     s0,[r0,#0]            ;522
0001ee  1c52              ADDS     r2,r2,#1              ;509
0001f0  edc01a01          VSTR     s3,[r0,#4]            ;523
0001f4  42aa              CMP      r2,r5                 ;509
0001f6  dbaf              BLT      |L320.344|
0001f8  2300              MOVS     r3,#0                 ;530
0001fa  461a              MOV      r2,r3                 ;530
0001fc  2101              MOVS     r1,#1                 ;530
0001fe  a82a              ADD      r0,sp,#0xa8           ;530
000200  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000204  6800              LDR      r0,[r0,#0]            ;530
000206  9000              STR      r0,[sp,#0]            ;530
000208  2208              MOVS     r2,#8                 ;530
00020a  a80c              ADD      r0,sp,#0x30           ;530
00020c  9b3a              LDR      r3,[sp,#0xe8]         ;530
00020e  9901              LDR      r1,[sp,#4]            ;530
000210  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000214  a90c              ADD      r1,sp,#0x30           ;532
000216  a807              ADD      r0,sp,#0x1c           ;532
000218  f7fffffe          BL       _ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE ; Anki::Embedded::Matrix::Transpose<float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
00021c  2300              MOVS     r3,#0                 ;538
00021e  461a              MOV      r2,r3                 ;538
000220  4619              MOV      r1,r3                 ;538
000222  a82a              ADD      r0,sp,#0xa8           ;538
000224  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000228  6800              LDR      r0,[r0,#0]            ;538
00022a  9000              STR      r0,[sp,#0]            ;538
00022c  2208              MOVS     r2,#8                 ;538
00022e  4611              MOV      r1,r2                 ;538
000230  a81b              ADD      r0,sp,#0x6c           ;538
000232  9b3a              LDR      r3,[sp,#0xe8]         ;538
000234  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000238  2300              MOVS     r3,#0                 ;539
00023a  461a              MOV      r2,r3                 ;539
00023c  4619              MOV      r1,r3                 ;539
00023e  a82b              ADD      r0,sp,#0xac           ;539
000240  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000244  6800              LDR      r0,[r0,#0]            ;539
000246  9000              STR      r0,[sp,#0]            ;539
000248  2201              MOVS     r2,#1                 ;539
00024a  2108              MOVS     r1,#8                 ;539
00024c  a820              ADD      r0,sp,#0x80           ;539
00024e  9b3a              LDR      r3,[sp,#0xe8]         ;539
000250  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000254  aa1b              ADD      r2,sp,#0x6c           ;541
000256  a907              ADD      r1,sp,#0x1c           ;541
000258  a80c              ADD      r0,sp,#0x30           ;541
00025a  f7fffffe          BL       _ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
00025e  aa20              ADD      r2,sp,#0x80           ;547
000260  a925              ADD      r1,sp,#0x94           ;547
000262  a80c              ADD      r0,sp,#0x30           ;547
000264  f7fffffe          BL       _ZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE ; Anki::Embedded::Matrix::MultiplyTranspose<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
000268  2300              MOVS     r3,#0                 ;553
00026a  461a              MOV      r2,r3                 ;553
00026c  2101              MOVS     r1,#1                 ;553
00026e  a82a              ADD      r0,sp,#0xa8           ;553
000270  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000274  6800              LDR      r0,[r0,#0]            ;553
000276  9000              STR      r0,[sp,#0]            ;553
000278  2208              MOVS     r2,#8                 ;553
00027a  2101              MOVS     r1,#1                 ;553
00027c  a816              ADD      r0,sp,#0x58           ;553
00027e  9b3a              LDR      r3,[sp,#0xe8]         ;553
000280  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000284  a916              ADD      r1,sp,#0x58           ;555
000286  a820              ADD      r0,sp,#0x80           ;555
000288  f7fffffe          BL       _ZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EE ; Anki::Embedded::Matrix::Transpose<float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
00028c  464b              MOV      r3,r9                 ;561
00028e  2200              MOVS     r2,#0                 ;561
000290  a916              ADD      r1,sp,#0x58           ;561
000292  a81b              ADD      r0,sp,#0x6c           ;561
000294  f7fffffe          BL       _ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)
000298  ea5f0800          MOVS     r8,r0                 ;561
00029c  d018              BEQ      |L320.720|
00029e  f2402033          MOV      r0,#0x233             ;563
0002a2  e9cda000          STRD     r10,r0,[sp,#0]        ;563
0002a6  a368              ADR      r3,|L320.1096|
0002a8  a280              ADR      r2,|L320.1196|
0002aa  a176              ADR      r1,|L320.1156|
0002ac  2005              MOVS     r0,#5                 ;563
0002ae  f7fffffe          BL       _Anki_Log
0002b2  4640              MOV      r0,r8                 ;563
0002b4  e6f0              B        |L320.152|
                  |L320.694|
0002b6  f24010e9          MOV      r0,#0x1e9             ;489
0002ba  e9cda000          STRD     r10,r0,[sp,#0]        ;489
0002be  a362              ADR      r3,|L320.1096|
0002c0  a284              ADR      r2,|L320.1236|
0002c2  a170              ADR      r1,|L320.1156|
0002c4  2005              MOVS     r0,#5                 ;489
0002c6  f7fffffe          BL       _Anki_Log
0002ca  f04f60a0          MOV      r0,#0x5000000         ;489
0002ce  e6e3              B        |L320.152|
                  |L320.720|
0002d0  f8990000          LDRB     r0,[r9,#0]            ;566
0002d4  2800              CMP      r0,#0                 ;566
0002d6  f040818b          BNE.W    |L320.1520|
0002da  9a18              LDR      r2,[sp,#0x60]         ;566
0002dc  991a              LDR      r1,[sp,#0x68]         ;566
0002de  68a3              LDR      r3,[r4,#8]            ;566
0002e0  fb001002          MLA      r0,r0,r2,r1           ;566
0002e4  6922              LDR      r2,[r4,#0x10]         ;566
0002e6  2100              MOVS     r1,#0                 ;573
0002e8  fb012103          MLA      r1,r1,r3,r2           ;573
0002ec  ed900a00          VLDR     s0,[r0,#0]            ;573
0002f0  ed810a00          VSTR     s0,[r1,#0]            ;573
0002f4  68a3              LDR      r3,[r4,#8]            ;573
0002f6  6922              LDR      r2,[r4,#0x10]         ;573
0002f8  2100              MOVS     r1,#0                 ;573
0002fa  fb012103          MLA      r1,r1,r3,r2           ;573
0002fe  ed900a01          VLDR     s0,[r0,#4]            ;573
000302  ed810a01          VSTR     s0,[r1,#4]            ;573
000306  68a3              LDR      r3,[r4,#8]            ;573
000308  6922              LDR      r2,[r4,#0x10]         ;573
00030a  2100              MOVS     r1,#0                 ;573
00030c  fb012103          MLA      r1,r1,r3,r2           ;573
000310  ed900a02          VLDR     s0,[r0,#8]            ;573
000314  ed810a02          VSTR     s0,[r1,#8]            ;573
000318  68a3              LDR      r3,[r4,#8]            ;573
00031a  6922              LDR      r2,[r4,#0x10]         ;573
00031c  2101              MOVS     r1,#1                 ;574
00031e  fb012103          MLA      r1,r1,r3,r2           ;574
000322  ed900a03          VLDR     s0,[r0,#0xc]          ;574
000326  ed810a00          VSTR     s0,[r1,#0]            ;574
00032a  68a3              LDR      r3,[r4,#8]            ;574
00032c  6922              LDR      r2,[r4,#0x10]         ;574
00032e  2101              MOVS     r1,#1                 ;574
000330  fb012103          MLA      r1,r1,r3,r2           ;574
000334  ed900a04          VLDR     s0,[r0,#0x10]         ;574
000338  ed810a01          VSTR     s0,[r1,#4]            ;574
00033c  68a3              LDR      r3,[r4,#8]            ;574
00033e  6922              LDR      r2,[r4,#0x10]         ;574
000340  2101              MOVS     r1,#1                 ;574
000342  fb012103          MLA      r1,r1,r3,r2           ;574
000346  ed900a05          VLDR     s0,[r0,#0x14]         ;574
00034a  ed810a02          VSTR     s0,[r1,#8]            ;574
00034e  68a3              LDR      r3,[r4,#8]            ;574
000350  6922              LDR      r2,[r4,#0x10]         ;574
000352  2102              MOVS     r1,#2                 ;575
000354  fb012103          MLA      r1,r1,r3,r2           ;575
000358  ed900a06          VLDR     s0,[r0,#0x18]         ;575
00035c  ed810a00          VSTR     s0,[r1,#0]            ;575
000360  68a3              LDR      r3,[r4,#8]            ;575
000362  6922              LDR      r2,[r4,#0x10]         ;575
000364  2102              MOVS     r1,#2                 ;575
000366  fb012103          MLA      r1,r1,r3,r2           ;575
00036a  ed900a07          VLDR     s0,[r0,#0x1c]         ;575
00036e  2002              MOVS     r0,#2                 ;575
000370  ed810a01          VSTR     s0,[r1,#4]            ;575
000374  68a2              LDR      r2,[r4,#8]            ;575
000376  6921              LDR      r1,[r4,#0x10]         ;575
000378  2d04              CMP      r5,#4                 ;579
00037a  fb001002          MLA      r0,r0,r2,r1           ;579
00037e  ed808a02          VSTR     s16,[r0,#8]           ;575
000382  d15d              BNE      |L320.1088|
000384  2300              MOVS     r3,#0                 ;580
000386  461a              MOV      r2,r3                 ;580
000388  2101              MOVS     r1,#1                 ;580
00038a  a82c              ADD      r0,sp,#0xb0           ;580
00038c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000390  6800              LDR      r0,[r0,#0]            ;580
000392  9000              STR      r0,[sp,#0]            ;580
000394  2201              MOVS     r2,#1                 ;580
000396  2103              MOVS     r1,#3                 ;580
000398  a811              ADD      r0,sp,#0x44           ;580
00039a  9b3a              LDR      r3,[sp,#0xe8]         ;580
00039c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0003a0  2300              MOVS     r3,#0                 ;581
0003a2  461a              MOV      r2,r3                 ;581
0003a4  2101              MOVS     r1,#1                 ;581
0003a6  a82d              ADD      r0,sp,#0xb4           ;581
0003a8  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0003ac  6800              LDR      r0,[r0,#0]            ;581
0003ae  9000              STR      r0,[sp,#0]            ;581
0003b0  2201              MOVS     r2,#1                 ;581
0003b2  2103              MOVS     r1,#3                 ;581
0003b4  a802              ADD      r0,sp,#8              ;581
0003b6  9b3a              LDR      r3,[sp,#0xe8]         ;581
0003b8  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0003bc  f8dfa12c          LDR      r10,|L320.1260|
0003c0  f04f0800          MOV      r8,#0                 ;582
                  |L320.964|
0003c4  6b38              LDR      r0,[r7,#0x30]         ;582
0003c6  9a13              LDR      r2,[sp,#0x4c]         ;582
0003c8  eb0000c8          ADD      r0,r0,r8,LSL #3       ;582
0003cc  9915              LDR      r1,[sp,#0x54]         ;582
0003ce  ed900a00          VLDR     s0,[r0,#0]            ;583
0003d2  2000              MOVS     r0,#0                 ;583
0003d4  fb001002          MLA      r0,r0,r2,r1           ;583
0003d8  ed800a00          VSTR     s0,[r0,#0]            ;583
0003dc  6b38              LDR      r0,[r7,#0x30]         ;583
0003de  9a13              LDR      r2,[sp,#0x4c]         ;583
0003e0  eb0000c8          ADD      r0,r0,r8,LSL #3       ;583
0003e4  9915              LDR      r1,[sp,#0x54]         ;583
0003e6  ed900a01          VLDR     s0,[r0,#4]            ;584
0003ea  2001              MOVS     r0,#1                 ;584
0003ec  fb001002          MLA      r0,r0,r2,r1           ;584
0003f0  ed800a00          VSTR     s0,[r0,#0]            ;584
0003f4  9a13              LDR      r2,[sp,#0x4c]         ;584
0003f6  9915              LDR      r1,[sp,#0x54]         ;584
0003f8  2002              MOVS     r0,#2                 ;585
0003fa  fb001002          MLA      r0,r0,r2,r1           ;585
0003fe  aa02              ADD      r2,sp,#8              ;587
000400  ed808a00          VSTR     s16,[r0,#0]           ;585
000404  a911              ADD      r1,sp,#0x44           ;587
000406  4620              MOV      r0,r4                 ;587
000408  f7fffffe          BL       _ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
00040c  9a04              LDR      r2,[sp,#0x10]         ;587
00040e  9906              LDR      r1,[sp,#0x18]         ;587
000410  2000              MOVS     r0,#0                 ;588
000412  fb001002          MLA      r0,r0,r2,r1           ;588
000416  9b04              LDR      r3,[sp,#0x10]         ;588
000418  9a06              LDR      r2,[sp,#0x18]         ;588
00041a  2102              MOVS     r1,#2                 ;588
00041c  fb012103          MLA      r1,r1,r3,r2           ;588
000420  edd00a00          VLDR     s1,[r0,#0]            ;588
000424  ed910a00          VLDR     s0,[r1,#0]            ;588
000428  ee801a80          VDIV.F32 s2,s1,s0              ;588
00042c  ed801a00          VSTR     s2,[r0,#0]            ;588
000430  9a04              LDR      r2,[sp,#0x10]         ;588
000432  9906              LDR      r1,[sp,#0x18]         ;588
000434  2001              MOVS     r0,#1                 ;589
000436  fb001002          MLA      r0,r0,r2,r1           ;589
00043a  2102              MOVS     r1,#2                 ;589
00043c  9b04              LDR      r3,[sp,#0x10]         ;589
00043e  e057              B        |L320.1264|
                  |L320.1088|
000440  e0d6              B        |L320.1520|
000442  0000              DCW      0x0000
                  |L320.1092|
                          DCD      _ZZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::EstimateHomography<float>(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, Anki::Embedded::Array<T1>&, bool&, Anki::Embedded::MemoryStack)::__PRETTY_FUNCTION__
                  |L320.1096|
000448  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
00044c  6f726574
000450  6563685c
000454  636f6d6d
000458  6f6e5c69
00045c  6e636c75
000460  64655c61
000464  6e6b692f
000468  636f6d6d
00046c  6f6e2f72
000470  6f626f74
000474  2f6d6174
000478  726978  
00047b  2e6800            DCB      ".h",0
00047e  00                DCB      0
00047f  00                DCB      0
                  |L320.1152|
                          DCD      ||.constdata||+0xd00
                  |L320.1156|
000484  45737469          DCB      "EstimateHomography",0
000488  6d617465
00048c  486f6d6f
000490  67726170
000494  687900  
000497  00                DCB      0
                  |L320.1176|
000498  496e7661          DCB      "Invalid objects",0
00049c  6c696420
0004a0  6f626a65
0004a4  63747300
                  |L320.1192|
0004a8  00000000          DCFS     0x00000000 ; 0
                  |L320.1196|
0004ac  536f6c76          DCB      "SolveLeastSquaresWithCholesky failed",0
0004b0  654c6561
0004b4  73745371
0004b8  75617265
0004bc  73576974
0004c0  6843686f
0004c4  6c65736b
0004c8  79206661
0004cc  696c6564
0004d0  00      
0004d1  00                DCB      0
0004d2  00                DCB      0
0004d3  00                DCB      0
                  |L320.1236|
0004d4  686f6d6f          DCB      "homography must be 3x3",0
0004d8  67726170
0004dc  6879206d
0004e0  75737420
0004e4  62652033
0004e8  783300  
0004eb  00                DCB      0
                  |L320.1260|
                          DCD      0x3dcccccd
                  |L320.1264|
0004f0  9a06              LDR      r2,[sp,#0x18]         ;589
0004f2  edd00a00          VLDR     s1,[r0,#0]            ;589
0004f6  fb012103          MLA      r1,r1,r3,r2           ;589
0004fa  ed910a00          VLDR     s0,[r1,#0]            ;589
0004fe  ee801a80          VDIV.F32 s2,s1,s0              ;589
000502  ed801a00          VSTR     s2,[r0,#0]            ;589
000506  6b30              LDR      r0,[r6,#0x30]         ;589
000508  9a04              LDR      r2,[sp,#0x10]         ;589
00050a  eb0000c8          ADD      r0,r0,r8,LSL #3       ;589
00050e  9906              LDR      r1,[sp,#0x18]         ;589
000510  ed900a00          VLDR     s0,[r0,#0]            ;591
000514  2000              MOVS     r0,#0                 ;591
000516  fb001002          MLA      r0,r0,r2,r1           ;591
00051a  edd00a00          VLDR     s1,[r0,#0]            ;591
00051e  ee300a60          VSUB.F32 s0,s0,s1              ;591
000522  eef00a00          VMOV.F32 s1,#2.00000000        ;591
000526  f7fffffe          BL       __hardfp_powf
00052a  6b30              LDR      r0,[r6,#0x30]         ;591
00052c  eef08a40          VMOV.F32 s17,s0                ;591
000530  eb0000c8          ADD      r0,r0,r8,LSL #3       ;591
000534  9a04              LDR      r2,[sp,#0x10]         ;591
000536  ed900a01          VLDR     s0,[r0,#4]            ;591
00053a  9906              LDR      r1,[sp,#0x18]         ;591
00053c  2001              MOVS     r0,#1                 ;591
00053e  fb001002          MLA      r0,r0,r2,r1           ;591
000542  edd00a00          VLDR     s1,[r0,#0]            ;591
000546  ee300a60          VSUB.F32 s0,s0,s1              ;591
00054a  eef00a00          VMOV.F32 s1,#2.00000000        ;591
00054e  f7fffffe          BL       __hardfp_powf
000552  ee380a80          VADD.F32 s0,s17,s0             ;591
000556  eef10ac0          VSQRT.F32 s1,s0                 ;591
00055a  eef40a60          VCMP.F32 s1,s1                 ;591
00055e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;591
000562  d003              BEQ      |L320.1388|
000564  f7fffffe          BL       __hardfp_sqrtf
000568  eef00a40          VMOV.F32 s1,s0                 ;591
                  |L320.1388|
00056c  ee100a90          VMOV     r0,s1                 ;591
000570  4550              CMP      r0,r10                ;593
000572  dd38              BLE      |L320.1510|
000574  2001              MOVS     r0,#1                 ;596
000576  f8890000          STRB     r0,[r9,#0]            ;596
00057a  4620              MOV      r0,r4                 ;596
00057c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000580  b318              CBZ      r0,|L320.1482|
000582  2100              MOVS     r1,#0                 ;596
000584  4620              MOV      r0,r4                 ;596
000586  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00058a  4601              MOV      r1,r0                 ;596
00058c  68a0              LDR      r0,[r4,#8]            ;596
00058e  6923              LDR      r3,[r4,#0x10]         ;596
000590  4341              MULS     r1,r0,r1              ;596
000592  2200              MOVS     r2,#0                 ;596
000594  fb023000          MLA      r0,r2,r0,r3           ;596
000598  f7fffffe          BL       __aeabi_memclr4
                  |L320.1436|
00059c  68a2              LDR      r2,[r4,#8]            ;596
00059e  6921              LDR      r1,[r4,#0x10]         ;596
0005a0  2000              MOVS     r0,#0                 ;599
0005a2  fb001002          MLA      r0,r0,r2,r1           ;599
0005a6  ed808a00          VSTR     s16,[r0,#0]           ;599
0005aa  68a2              LDR      r2,[r4,#8]            ;599
0005ac  6921              LDR      r1,[r4,#0x10]         ;599
0005ae  2001              MOVS     r0,#1                 ;600
0005b0  fb001002          MLA      r0,r0,r2,r1           ;600
0005b4  ed808a01          VSTR     s16,[r0,#4]           ;600
0005b8  68a2              LDR      r2,[r4,#8]            ;600
0005ba  6921              LDR      r1,[r4,#0x10]         ;600
0005bc  2002              MOVS     r0,#2                 ;601
0005be  fb001002          MLA      r0,r0,r2,r1           ;601
0005c2  ed808a02          VSTR     s16,[r0,#8]           ;601
0005c6  2000              MOVS     r0,#0                 ;603
0005c8  e566              B        |L320.152|
                  |L320.1482|
0005ca  f2402176          MOV      r1,#0x276             ;603
0005ce  4809              LDR      r0,|L320.1524|
0005d0  4b09              LDR      r3,|L320.1528|
0005d2  e9cd0100          STRD     r0,r1,[sp,#0]         ;603
0005d6  f103027c          ADD      r2,r3,#0x7c           ;603
0005da  f1a20118          SUB      r1,r2,#0x18           ;603
0005de  2005              MOVS     r0,#5                 ;603
0005e0  f7fffffe          BL       _Anki_Log
0005e4  e7da              B        |L320.1436|
                  |L320.1510|
0005e6  f1080801          ADD      r8,r8,#1              ;582
0005ea  4545              CMP      r5,r8                 ;582
0005ec  f73faeea          BGT      |L320.964|
                  |L320.1520|
0005f0  2000              MOVS     r0,#0                 ;609
0005f2  e551              B        |L320.152|
;;;611    
                          ENDP

                  |L320.1524|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::SetZero()::__PRETTY_FUNCTION__
                  |L320.1528|
                          DCD      ||.constdata||+0xab0

                          AREA ||area_number.321||, COMGROUP=_ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE, LINKORDER=||t._ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.321||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5PointIfEC1Ev||, COMGROUP=_ZN4Anki8Embedded5PointIfEC1Ev, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5PointIfEC2Ev                  ; Alternate entry point ; Anki::Embedded::Point<float>::Point__sub_object()
                  _ZN4Anki8Embedded5PointIfEC1Ev PROC ; Anki::Embedded::Point<float>::Point()
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
000000  ed9f0a03          VLDR     s0,|L327.16|
000004  ed800a00          VSTR     s0,[r0,#0]
000008  ed800a01          VSTR     s0,[r0,#4]
00000c  4770              BX       lr
                          ENDP

00000e  0000              DCW      0x0000
                  |L327.16|
000010  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.328||, COMGROUP=_ZN4Anki8Embedded5PointIfEC1Ev, LINKORDER=||t._ZN4Anki8Embedded5PointIfEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.328||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5PointIfEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIiEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<int>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L334.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L334.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L334.384|
000044  a25c              ADR      r2,|L334.440|
000046  a160              ADR      r1,|L334.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L334.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L334.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L334.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L334.384|
000080  a24d              ADR      r2,|L334.440|
000082  a157              ADR      r1,|L334.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L334.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L334.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L334.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L334.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L334.384|
0000c8  a251              ADR      r2,|L334.528|
0000ca  a156              ADR      r1,|L334.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L334.372|
                  |L334.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L334.384|
0000e0  a258              ADR      r2,|L334.580|
0000e2  a15f              ADR      r1,|L334.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L334.372|
                  |L334.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L334.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L334.384|
000110  a259              ADR      r2,|L334.632|
000112  a144              ADR      r1,|L334.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L334.372|
                  |L334.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L334.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L334.384|
00015a  a251              ADR      r2,|L334.672|
00015c  a140              ADR      r1,|L334.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L334.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L334.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L334.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L334.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L334.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L334.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L334.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L334.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L334.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L334.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L334.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L334.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L334.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L334.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.335||, COMGROUP=_ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.335||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfEC1Ev||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1Ev, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded5ArrayIfEC2Ev                  ; Alternate entry point ; Anki::Embedded::Array<float>::Array__sub_object()
                  _ZN4Anki8Embedded5ArrayIfEC1Ev PROC ; Anki::Embedded::Array<float>::Array()
;;;77     
;;;78         template<typename Type> Array<Type>::Array()
;;;79         {
;;;80           InvalidateArray();
;;;81         }
;;;82     
000000  b510              PUSH     {r4,lr}
000002  300c              ADDS     r0,r0,#0xc
000004  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000008  f04f31ff          MOV      r1,#0xffffffff
00000c  f8401d0c          STR      r1,[r0,#-0xc]!
000010  6041              STR      r1,[r0,#4]
000012  6081              STR      r1,[r0,#8]
000014  2100              MOVS     r1,#0
000016  6101              STR      r1,[r0,#0x10]
000018  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||area_number.342||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1Ev, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.342||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIfE7IsValidEv||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE7IsValidEv, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded5ArrayIfE7IsValidEv PROC ; Anki::Embedded::Array<float>::IsValid() const
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
000000  6901              LDR      r1,[r0,#0x10]
;;;592        {
000002  b131              CBZ      r1,|L348.18|
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
000004  6801              LDR      r1,[r0,#0]
000006  2900              CMP      r1,#0
000008  bfa1              ITTTT    GE
00000a  6840              LDRGE    r0,[r0,#4]
00000c  2800              CMPGE    r0,#0
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
00000e  2001              MOVGE    r0,#1
;;;602        }
000010  4770              BXGE     lr
                  |L348.18|
000012  2000              MOVS     r0,#0                 ;598
000014  4770              BX       lr
;;;603    
                          ENDP


                          AREA ||area_number.349||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE7IsValidEv, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIfE7IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.349||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIfE7IsValidEv||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi PROC ; Anki::Embedded::Array<float>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L355.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L355.56|
00000e  4b0b              LDR      r3,|L355.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f1030250          ADD      r2,r3,#0x50
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L355.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L355.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::get_size(int) const::__PRETTY_FUNCTION__
                  |L355.60|
                          DCD      ||.constdata||+0xab0

                          AREA ||area_number.356||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.356||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfE7SetZeroEv||, COMGROUP=_ZN4Anki8Embedded5ArrayIfE7SetZeroEv, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfE7SetZeroEv PROC ; Anki::Embedded::Array<float>::SetZero()
;;;627    
;;;628        template<typename Type> s32 Array<Type>::SetZero()
000000  b530              PUSH     {r4,r5,lr}
;;;629        {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
;;;630          AnkiConditionalErrorAndReturnValue(this->IsValid(),
000006  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00000a  b188              CBZ      r0,|L362.48|
;;;631            0, "Array<Type>::SetZero", "Array<Type> is not valid");
;;;632    
;;;633          const s32 numBytes = this->get_size(0)*this->get_stride();
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000014  4601              MOV      r1,r0
000016  68a0              LDR      r0,[r4,#8]
;;;634    
;;;635          memset(this->Pointer(0,0), 0, numBytes);
000018  2200              MOVS     r2,#0
00001a  fb01f500          MUL      r5,r1,r0              ;633
00001e  6921              LDR      r1,[r4,#0x10]         ;633
000020  fb021000          MLA      r0,r2,r0,r1           ;633
000024  4629              MOV      r1,r5
000026  f7fffffe          BL       __aeabi_memclr4
;;;636    
;;;637          return numBytes;
;;;638        }
00002a  b003              ADD      sp,sp,#0xc
00002c  4628              MOV      r0,r5                 ;637
00002e  bd30              POP      {r4,r5,pc}
                  |L362.48|
000030  f2402176          MOV      r1,#0x276             ;630
000034  4806              LDR      r0,|L362.80|
000036  4b07              LDR      r3,|L362.84|
000038  e9cd0100          STRD     r0,r1,[sp,#0]         ;630
00003c  f103027c          ADD      r2,r3,#0x7c           ;630
000040  f1a20118          SUB      r1,r2,#0x18           ;630
000044  2005              MOVS     r0,#5                 ;630
000046  f7fffffe          BL       _Anki_Log
00004a  b003              ADD      sp,sp,#0xc
00004c  2000              MOVS     r0,#0                 ;630
00004e  bd30              POP      {r4,r5,pc}
;;;639    
                          ENDP

                  |L362.80|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::SetZero()::__PRETTY_FUNCTION__
                  |L362.84|
                          DCD      ||.constdata||+0xab0

                          AREA ||area_number.363||, COMGROUP=_ZN4Anki8Embedded5ArrayIfE7SetZeroEv, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfE7SetZeroEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.363||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfE7SetZeroEv||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded13QuadrilateralIfEC1Ev||, COMGROUP=_ZN4Anki8Embedded13QuadrilateralIfEC1Ev, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded13QuadrilateralIfEC2Ev                  ; Alternate entry point ; Anki::Embedded::Quadrilateral<float>::Quadrilateral__sub_object()
                  _ZN4Anki8Embedded13QuadrilateralIfEC1Ev PROC ; Anki::Embedded::Quadrilateral<float>::Quadrilateral()
;;;405    
;;;406        template<typename Type> Quadrilateral<Type>::Quadrilateral()
;;;407        {
;;;408          for(s32 i=0; i<4; i++) {
;;;409            corners[i] = Point<Type>();
;;;410          }
;;;411        }
;;;412    
000000  b500              PUSH     {lr}
000002  b083              SUB      sp,sp,#0xc
000004  2304              MOVS     r3,#4
000006  2208              MOVS     r2,#8
000008  490c              LDR      r1,|L369.60|
00000a  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
00000e  ed9f0a0c          VLDR     s0,|L369.64|
000012  2100              MOVS     r1,#0
                  |L369.20|
000014  ed8d0a00          VSTR     s0,[sp,#0]
000018  ed8d0a01          VSTR     s0,[sp,#4]
00001c  eb0002c1          ADD      r2,r0,r1,LSL #3
000020  eddd0a00          VLDR     s1,[sp,#0]
000024  1c49              ADDS     r1,r1,#1
000026  edc20a00          VSTR     s1,[r2,#0]
00002a  eddd0a01          VLDR     s1,[sp,#4]
00002e  2904              CMP      r1,#4
000030  edc20a01          VSTR     s1,[r2,#4]
000034  dbee              BLT      |L369.20|
000036  b003              ADD      sp,sp,#0xc
000038  bd00              POP      {pc}
                          ENDP

00003a  0000              DCW      0x0000
                  |L369.60|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()
                  |L369.64|
000040  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.370||, COMGROUP=_ZN4Anki8Embedded13QuadrilateralIfEC1Ev, LINKORDER=||t._ZN4Anki8Embedded13QuadrilateralIfEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.370||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded13QuadrilateralIfEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_||, COMGROUP=_ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded13QuadrilateralIfEC2ERKNS0_5PointIfEES6_S6_S6_                  ; Alternate entry point ; Anki::Embedded::Quadrilateral<float>::Quadrilateral__sub_object(const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&)
                  _ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_ PROC ; Anki::Embedded::Quadrilateral<float>::Quadrilateral(const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&, const Anki::Embedded::Point<float>&)
;;;412    
;;;413        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Point<Type> &corner1, const Point<Type> &corner2, const Point<Type> &corner3, const Point<Type> &corner4)
;;;414        {
;;;415          corners[0] = corner1;
;;;416          corners[1] = corner2;
;;;417          corners[2] = corner3;
;;;418          corners[3] = corner4;
;;;419        }
;;;420    
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  461d              MOV      r5,r3
000006  4616              MOV      r6,r2
000008  460f              MOV      r7,r1
00000a  2304              MOVS     r3,#4
00000c  2208              MOVS     r2,#8
00000e  4913              LDR      r1,|L376.92|
000010  9c06              LDR      r4,[sp,#0x18]
000012  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
000016  ed970a00          VLDR     s0,[r7,#0]
00001a  ed800a00          VSTR     s0,[r0,#0]
00001e  ed970a01          VLDR     s0,[r7,#4]
000022  ed800a01          VSTR     s0,[r0,#4]
000026  ed960a00          VLDR     s0,[r6,#0]
00002a  ed800a02          VSTR     s0,[r0,#8]
00002e  ed960a01          VLDR     s0,[r6,#4]
000032  ed800a03          VSTR     s0,[r0,#0xc]
000036  ed950a00          VLDR     s0,[r5,#0]
00003a  ed800a04          VSTR     s0,[r0,#0x10]
00003e  ed950a01          VLDR     s0,[r5,#4]
000042  ed800a05          VSTR     s0,[r0,#0x14]
000046  ed940a00          VLDR     s0,[r4,#0]
00004a  ed800a06          VSTR     s0,[r0,#0x18]
00004e  ed940a01          VLDR     s0,[r4,#4]
000052  ed800a07          VSTR     s0,[r0,#0x1c]
000056  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

00005a  0000              DCW      0x0000
                  |L376.92|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()

                          AREA ||area_number.377||, COMGROUP=_ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_, LINKORDER=||t._ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.377||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded13QuadrilateralIfEC1ERKNS0_5PointIfEES6_S6_S6_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||, COMGROUP=_ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii PROC ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)
;;;1622   
;;;1623         template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1624         {
000004  b083              SUB      sp,sp,#0xc
000006  460c              MOV      r4,r1
000008  e9dd980c          LDRD     r9,r8,[sp,#0x30]
00000c  469b              MOV      r11,r3
00000e  4692              MOV      r10,r2
000010  4606              MOV      r6,r0
;;;1625           const s32 arrHeight = arr.get_size(0);
000012  2100              MOVS     r1,#0
000014  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000018  4607              MOV      r7,r0
;;;1626           const s32 arrWidth = arr.get_size(1);
00001a  2101              MOVS     r1,#1
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000022  4605              MOV      r5,r0
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00002a  2800              CMP      r0,#0
00002c  bf1c              ITT      NE
00002e  6920              LDRNE    r0,[r4,#0x10]
000030  2800              CMPNE    r0,#0
;;;1627   
;;;1628           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
000032  d01b              BEQ      |L383.108|
000034  6820              LDR      r0,[r4,#0]
000036  2800              CMP      r0,#0
000038  bfa4              ITT      GE
00003a  6860              LDRGE    r0,[r4,#4]
00003c  2800              CMPGE    r0,#0
00003e  db15              BLT      |L383.108|
;;;1629             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1630   
;;;1631           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
000040  f1ba0f00          CMP      r10,#0
000044  bf18              IT       NE
000046  f1ba0f01          CMPNE    r10,#1
00004a  d01f              BEQ      |L383.140|
00004c  f240615f          MOV      r1,#0x65f
000050  48e2              LDR      r0,|L383.988|
000052  e9cd0100          STRD     r0,r1,[sp,#0]
000056  a3e2              ADR      r3,|L383.992|
000058  a2ef              ADR      r2,|L383.1048|
00005a  a1f9              ADR      r1,|L383.1088|
00005c  2005              MOVS     r0,#5
00005e  f7fffffe          BL       _Anki_Log
;;;1632             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1633   
;;;1634           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1635             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1636   
;;;1637           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1638           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1639   
;;;1640           if(sortWhichDimension == 0) {
;;;1641             for(s32 y=0; y<arrHeight; y++) {
;;;1642               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1643               for(s32 x=0; x<arrWidth; x++) {
;;;1644                 pIndexes[x] = y;
;;;1645               }
;;;1646             }
;;;1647   
;;;1648             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1649             if(sortAscending) {
;;;1650               InsertionSort_sortAscendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1651             } else { // if(sortAscending)
;;;1652               InsertionSort_sortDescendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1653             } // if(sortAscending) ... else
;;;1654           } else { // sortWhichDimension == 1
;;;1655             for(s32 y=0; y<arrHeight; y++) {
;;;1656               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1657               for(s32 x=0; x<arrWidth; x++) {
;;;1658                 pIndexes[x] = x;
;;;1659               }
;;;1660             }
;;;1661   
;;;1662             if(sortAscending) {
;;;1663               InsertionSort_sortAscendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1664             } else { // if(sortAscending)
;;;1665               InsertionSort_sortDescendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1666             } // if(sortAscending) ... else
;;;1667           } // if(sortWhichDimension == 0) ... else
;;;1668   
;;;1669           return RESULT_OK;
;;;1670         } // InsertionSort()
000062  b003              ADD      sp,sp,#0xc
000064  f04f7040          MOV      r0,#0x3000000         ;1631
000068  e8bd8ff0          POP      {r4-r11,pc}
                  |L383.108|
00006c  f240615c          MOV      r1,#0x65c             ;1628
000070  48da              LDR      r0,|L383.988|
000072  e9cd0100          STRD     r0,r1,[sp,#0]         ;1628
000076  a3da              ADR      r3,|L383.992|
000078  a2f3              ADR      r2,|L383.1096|
00007a  a1f1              ADR      r1,|L383.1088|
00007c  2005              MOVS     r0,#5                 ;1628
00007e  f7fffffe          BL       _Anki_Log
000082  b003              ADD      sp,sp,#0xc
000084  f04f6080          MOV      r0,#0x4000000         ;1628
000088  e8bd8ff0          POP      {r4-r11,pc}
                  |L383.140|
00008c  4630              MOV      r0,r6
00008e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000092  2800              CMP      r0,#0
000094  bf1c              ITT      NE
000096  6920              LDRNE    r0,[r4,#0x10]
000098  2800              CMPNE    r0,#0
00009a  d027              BEQ      |L383.236|
00009c  6820              LDR      r0,[r4,#0]            ;1634
00009e  2800              CMP      r0,#0                 ;1634
0000a0  bfa4              ITT      GE                    ;1634
0000a2  6860              LDRGE    r0,[r4,#4]            ;1634
0000a4  2800              CMPGE    r0,#0                 ;1634
0000a6  db21              BLT      |L383.236|
0000a8  2100              MOVS     r1,#0                 ;1634
0000aa  4630              MOV      r0,r6                 ;1634
0000ac  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000b0  4601              MOV      r1,r0                 ;1634
0000b2  6820              LDR      r0,[r4,#0]            ;1634
0000b4  4281              CMP      r1,r0                 ;1634
0000b6  d119              BNE      |L383.236|
0000b8  2101              MOVS     r1,#1                 ;1634
0000ba  4630              MOV      r0,r6                 ;1634
0000bc  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000c0  4601              MOV      r1,r0                 ;1634
0000c2  6860              LDR      r0,[r4,#4]            ;1634
0000c4  4281              CMP      r1,r0                 ;1634
0000c6  d111              BNE      |L383.236|
0000c8  4651              MOV      r1,r10                ;1637
0000ca  4630              MOV      r0,r6                 ;1637
0000cc  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000d0  1e41              SUBS     r1,r0,#1              ;1637
0000d2  f1b90f00          CMP      r9,#0                 ;1637
0000d6  bfcc              ITE      GT                    ;1637
0000d8  4648              MOVGT    r0,r9                 ;1637
0000da  2000              MOVLE    r0,#0                 ;1637
0000dc  4281              CMP      r1,r0                 ;1637
0000de  dd15              BLE      |L383.268|
0000e0  f1b90f00          CMP      r9,#0                 ;1637
0000e4  bfd8              IT       LE                    ;1637
0000e6  f04f0900          MOVLE    r9,#0                 ;1637
0000ea  e015              B        |L383.280|
                  |L383.236|
0000ec  f2406162          MOV      r1,#0x662             ;1634
0000f0  48ba              LDR      r0,|L383.988|
0000f2  e9cd0100          STRD     r0,r1,[sp,#0]         ;1634
0000f6  a3ba              ADR      r3,|L383.992|
0000f8  a2d8              ADR      r2,|L383.1116|
0000fa  a1d1              ADR      r1,|L383.1088|
0000fc  2005              MOVS     r0,#5                 ;1634
0000fe  f7fffffe          BL       _Anki_Log
000102  b003              ADD      sp,sp,#0xc
000104  f04f60a0          MOV      r0,#0x5000000         ;1634
000108  e8bd8ff0          POP      {r4-r11,pc}
                  |L383.268|
00010c  4651              MOV      r1,r10                ;1637
00010e  4630              MOV      r0,r6                 ;1637
000110  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000114  f1a00901          SUB      r9,r0,#1              ;1637
                  |L383.280|
000118  4651              MOV      r1,r10                ;1638
00011a  4630              MOV      r0,r6                 ;1638
00011c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000120  1e41              SUBS     r1,r0,#1              ;1638
000122  f1b80f00          CMP      r8,#0                 ;1638
000126  bfcc              ITE      GT                    ;1638
000128  4640              MOVGT    r0,r8                 ;1638
00012a  2000              MOVLE    r0,#0                 ;1638
00012c  4281              CMP      r1,r0                 ;1638
00012e  dd05              BLE      |L383.316|
000130  f1b80f00          CMP      r8,#0                 ;1638
000134  bfd8              IT       LE                    ;1638
000136  f04f0800          MOVLE    r8,#0                 ;1638
00013a  e005              B        |L383.328|
                  |L383.316|
00013c  4651              MOV      r1,r10                ;1638
00013e  4630              MOV      r0,r6                 ;1638
000140  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000144  f1a00801          SUB      r8,r0,#1              ;1638
                  |L383.328|
000148  ea5f000a          MOVS     r0,r10                ;1640
00014c  f04f0a00          MOV      r10,#0                ;1640
000150  4651              MOV      r1,r10                ;1655
000152  d034              BEQ      |L383.446|
000154  2f00              CMP      r7,#0                 ;1655
000156  dd0e              BLE      |L383.374|
                  |L383.344|
000158  68a2              LDR      r2,[r4,#8]            ;1655
00015a  6920              LDR      r0,[r4,#0x10]         ;1655
00015c  fb010202          MLA      r2,r1,r2,r0           ;1655
000160  2000              MOVS     r0,#0                 ;1657
000162  2d00              CMP      r5,#0                 ;1657
000164  dd04              BLE      |L383.368|
                  |L383.358|
000166  f8420020          STR      r0,[r2,r0,LSL #2]     ;1658
00016a  1c40              ADDS     r0,r0,#1              ;1657
00016c  4285              CMP      r5,r0                 ;1657
00016e  dcfa              BGT      |L383.358|
                  |L383.368|
000170  1c49              ADDS     r1,r1,#1              ;1655
000172  42b9              CMP      r1,r7                 ;1655
000174  dbf0              BLT      |L383.344|
                  |L383.374|
000176  f1bb0f00          CMP      r11,#0                ;1662
00017a  f04f0100          MOV      r1,#0                 ;1662
00017e  4630              MOV      r0,r6                 ;1662
000180  d07e              BEQ      |L383.640|
000182  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000186  f1b00b00          SUBS     r11,r0,#0             ;1662
00018a  f04f0500          MOV      r5,#0                 ;1662
00018e  f340819a          BLE.W    |L383.1222|
                  |L383.402|
000192  68b1              LDR      r1,[r6,#8]            ;1662
000194  6930              LDR      r0,[r6,#0x10]         ;1662
000196  f1090201          ADD      r2,r9,#1              ;1662
00019a  fb050c01          MLA      r12,r5,r1,r0          ;1662
00019e  68a1              LDR      r1,[r4,#8]            ;1662
0001a0  6920              LDR      r0,[r4,#0x10]         ;1662
0001a2  4542              CMP      r2,r8                 ;1662
0001a4  fb050301          MLA      r3,r5,r1,r0           ;1662
0001a8  f8c3a000          STR      r10,[r3,#0]           ;1662
0001ac  dc69              BGT      |L383.642|
                  |L383.430|
0001ae  eb0c0082          ADD      r0,r12,r2,LSL #2      ;1662
0001b2  f8537022          LDR      r7,[r3,r2,LSL #2]     ;1662
0001b6  edd00a00          VLDR     s1,[r0,#0]            ;1662
0001ba  4611              MOV      r1,r2                 ;1662
0001bc  e0d6              B        |L383.876|
                  |L383.446|
0001be  2f00              CMP      r7,#0                 ;1641
0001c0  dd0e              BLE      |L383.480|
                  |L383.450|
0001c2  68a2              LDR      r2,[r4,#8]            ;1641
0001c4  6920              LDR      r0,[r4,#0x10]         ;1641
0001c6  fb010202          MLA      r2,r1,r2,r0           ;1641
0001ca  2000              MOVS     r0,#0                 ;1643
0001cc  2d00              CMP      r5,#0                 ;1643
0001ce  dd04              BLE      |L383.474|
                  |L383.464|
0001d0  f8421020          STR      r1,[r2,r0,LSL #2]     ;1644
0001d4  1c40              ADDS     r0,r0,#1              ;1643
0001d6  4285              CMP      r5,r0                 ;1643
0001d8  dcfa              BGT      |L383.464|
                  |L383.474|
0001da  1c49              ADDS     r1,r1,#1              ;1641
0001dc  42b9              CMP      r1,r7                 ;1641
0001de  dbf0              BLT      |L383.450|
                  |L383.480|
0001e0  f1bb0f00          CMP      r11,#0                ;1649
0001e4  f04f0101          MOV      r1,#1                 ;1649
0001e8  4630              MOV      r0,r6                 ;1649
0001ea  d059              BEQ      |L383.672|
0001ec  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0001f0  1e07              SUBS     r7,r0,#0              ;1649
0001f2  f04f0200          MOV      r2,#0                 ;1649
0001f6  dd52              BLE      |L383.670|
                  |L383.504|
0001f8  f1090001          ADD      r0,r9,#1              ;1649
0001fc  4540              CMP      r0,r8                 ;1649
0001fe  dc4b              BGT      |L383.664|
                  |L383.512|
000200  68b3              LDR      r3,[r6,#8]            ;1649
000202  6931              LDR      r1,[r6,#0x10]         ;1649
000204  fb001103          MLA      r1,r0,r3,r1           ;1649
000208  eb010182          ADD      r1,r1,r2,LSL #2       ;1649
00020c  68a3              LDR      r3,[r4,#8]            ;1649
00020e  edd10a00          VLDR     s1,[r1,#0]            ;1649
000212  6921              LDR      r1,[r4,#0x10]         ;1649
000214  fb001103          MLA      r1,r0,r3,r1           ;1649
000218  f8515022          LDR      r5,[r1,r2,LSL #2]     ;1649
00021c  4601              MOV      r1,r0                 ;1649
00021e  e013              B        |L383.584|
                  |L383.544|
000220  fb01330c          MLA      r3,r1,r12,r3          ;1649
000224  eb030382          ADD      r3,r3,r2,LSL #2       ;1649
000228  f1a10a01          SUB      r10,r1,#1             ;1649
00022c  ed830a00          VSTR     s0,[r3,#0]            ;1649
000230  f8d4c008          LDR      r12,[r4,#8]           ;1649
000234  6923              LDR      r3,[r4,#0x10]         ;1649
000236  fb0a3a0c          MLA      r10,r10,r12,r3        ;1649
00023a  fb01330c          MLA      r3,r1,r12,r3          ;1649
00023e  f85aa022          LDR      r10,[r10,r2,LSL #2]   ;1649
000242  f843a022          STR      r10,[r3,r2,LSL #2]    ;1649
000246  1e49              SUBS     r1,r1,#1              ;1649
                  |L383.584|
000248  4549              CMP      r1,r9                 ;1649
00024a  dd0f              BLE      |L383.620|
00024c  f8d6c008          LDR      r12,[r6,#8]           ;1649
000250  6933              LDR      r3,[r6,#0x10]         ;1649
000252  f1a10a01          SUB      r10,r1,#1             ;1649
000256  fb0a3a0c          MLA      r10,r10,r12,r3        ;1649
00025a  eb0a0a82          ADD      r10,r10,r2,LSL #2     ;1649
00025e  ed9a0a00          VLDR     s0,[r10,#0]           ;1649
000262  eeb40ae0          VCMPE.F32 s0,s1                 ;1649
000266  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1649
00026a  dcd9              BGT      |L383.544|
                  |L383.620|
00026c  f8d6c008          LDR      r12,[r6,#8]           ;1649
000270  6933              LDR      r3,[r6,#0x10]         ;1649
000272  fb01330c          MLA      r3,r1,r12,r3          ;1649
000276  eb030382          ADD      r3,r3,r2,LSL #2       ;1649
00027a  edc30a00          VSTR     s1,[r3,#0]            ;1649
00027e  e001              B        |L383.644|
                  |L383.640|
000280  e08e              B        |L383.928|
                  |L383.642|
000282  e088              B        |L383.918|
                  |L383.644|
000284  f8d4c008          LDR      r12,[r4,#8]           ;1649
000288  6923              LDR      r3,[r4,#0x10]         ;1649
00028a  1c40              ADDS     r0,r0,#1              ;1649
00028c  fb01310c          MLA      r1,r1,r12,r3          ;1649
000290  4540              CMP      r0,r8                 ;1649
000292  f8415022          STR      r5,[r1,r2,LSL #2]     ;1649
000296  ddb3              BLE      |L383.512|
                  |L383.664|
000298  1c52              ADDS     r2,r2,#1              ;1649
00029a  42ba              CMP      r2,r7                 ;1649
00029c  dbac              BLT      |L383.504|
                  |L383.670|
00029e  e112              B        |L383.1222|
                  |L383.672|
0002a0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0002a4  f1b00b00          SUBS     r11,r0,#0             ;1649
0002a8  f04f0200          MOV      r2,#0                 ;1649
0002ac  dd54              BLE      |L383.856|
                  |L383.686|
0002ae  68a3              LDR      r3,[r4,#8]            ;1649
0002b0  6921              LDR      r1,[r4,#0x10]         ;1649
0002b2  2000              MOVS     r0,#0                 ;1649
0002b4  fb001003          MLA      r0,r0,r3,r1           ;1649
0002b8  f840a022          STR      r10,[r0,r2,LSL #2]    ;1649
0002bc  f1090001          ADD      r0,r9,#1              ;1649
0002c0  4540              CMP      r0,r8                 ;1649
0002c2  dc46              BGT      |L383.850|
                  |L383.708|
0002c4  68b3              LDR      r3,[r6,#8]            ;1649
0002c6  6931              LDR      r1,[r6,#0x10]         ;1649
0002c8  fb001103          MLA      r1,r0,r3,r1           ;1649
0002cc  eb010182          ADD      r1,r1,r2,LSL #2       ;1649
0002d0  68a3              LDR      r3,[r4,#8]            ;1649
0002d2  edd10a00          VLDR     s1,[r1,#0]            ;1649
0002d6  6921              LDR      r1,[r4,#0x10]         ;1649
0002d8  fb001103          MLA      r1,r0,r3,r1           ;1649
0002dc  f8517022          LDR      r7,[r1,r2,LSL #2]     ;1649
0002e0  4601              MOV      r1,r0                 ;1649
0002e2  e012              B        |L383.778|
                  |L383.740|
0002e4  fb01330c          MLA      r3,r1,r12,r3          ;1649
0002e8  eb030382          ADD      r3,r3,r2,LSL #2       ;1649
0002ec  1e4d              SUBS     r5,r1,#1              ;1649
0002ee  ed830a00          VSTR     s0,[r3,#0]            ;1649
0002f2  f8d4c008          LDR      r12,[r4,#8]           ;1649
0002f6  6923              LDR      r3,[r4,#0x10]         ;1649
0002f8  fb05350c          MLA      r5,r5,r12,r3          ;1649
0002fc  fb01330c          MLA      r3,r1,r12,r3          ;1649
000300  f8555022          LDR      r5,[r5,r2,LSL #2]     ;1649
000304  f8435022          STR      r5,[r3,r2,LSL #2]     ;1649
000308  1e49              SUBS     r1,r1,#1              ;1649
                  |L383.778|
00030a  4549              CMP      r1,r9                 ;1649
00030c  dd0e              BLE      |L383.812|
00030e  f8d6c008          LDR      r12,[r6,#8]           ;1649
000312  6933              LDR      r3,[r6,#0x10]         ;1649
000314  1e4d              SUBS     r5,r1,#1              ;1649
000316  fb05350c          MLA      r5,r5,r12,r3          ;1649
00031a  eb050582          ADD      r5,r5,r2,LSL #2       ;1649
00031e  ed950a00          VLDR     s0,[r5,#0]            ;1649
000322  eeb40ae0          VCMPE.F32 s0,s1                 ;1649
000326  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1649
00032a  d3db              BCC      |L383.740|
                  |L383.812|
00032c  f8d6c008          LDR      r12,[r6,#8]           ;1649
000330  6933              LDR      r3,[r6,#0x10]         ;1649
000332  1c40              ADDS     r0,r0,#1              ;1649
000334  fb01330c          MLA      r3,r1,r12,r3          ;1649
000338  eb030382          ADD      r3,r3,r2,LSL #2       ;1649
00033c  4540              CMP      r0,r8                 ;1649
00033e  edc30a00          VSTR     s1,[r3,#0]            ;1649
000342  f8d4c008          LDR      r12,[r4,#8]           ;1649
000346  6923              LDR      r3,[r4,#0x10]         ;1649
000348  fb01310c          MLA      r1,r1,r12,r3          ;1649
00034c  f8417022          STR      r7,[r1,r2,LSL #2]     ;1649
000350  ddb8              BLE      |L383.708|
                  |L383.850|
000352  1c52              ADDS     r2,r2,#1              ;1649
000354  455a              CMP      r2,r11                ;1649
000356  dbaa              BLT      |L383.686|
                  |L383.856|
000358  e0b5              B        |L383.1222|
                  |L383.858|
00035a  ed800a00          VSTR     s0,[r0,#0]            ;1649
00035e  eb030081          ADD      r0,r3,r1,LSL #2       ;1649
000362  f8500c04          LDR      r0,[r0,#-4]           ;1649
000366  f8430021          STR      r0,[r3,r1,LSL #2]     ;1649
00036a  1e49              SUBS     r1,r1,#1              ;1649
                  |L383.876|
00036c  4549              CMP      r1,r9                 ;1649
00036e  dd08              BLE      |L383.898|
000370  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1649
000374  ed100a01          VLDR     s0,[r0,#-4]           ;1649
000378  eeb40ae0          VCMPE.F32 s0,s1                 ;1649
00037c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1649
000380  dceb              BGT      |L383.858|
                  |L383.898|
000382  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1649
000386  1c52              ADDS     r2,r2,#1              ;1649
000388  edc00a00          VSTR     s1,[r0,#0]            ;1649
00038c  f8437021          STR      r7,[r3,r1,LSL #2]     ;1649
000390  4542              CMP      r2,r8                 ;1649
000392  f77faf0c          BLE      |L383.430|
                  |L383.918|
000396  1c6d              ADDS     r5,r5,#1              ;1649
000398  455d              CMP      r5,r11                ;1649
00039a  f6ffaefa          BLT      |L383.402|
00039e  e092              B        |L383.1222|
                  |L383.928|
0003a0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0003a4  f1b00b00          SUBS     r11,r0,#0             ;1649
0003a8  f04f0500          MOV      r5,#0                 ;1649
0003ac  dd15              BLE      |L383.986|
                  |L383.942|
0003ae  68b1              LDR      r1,[r6,#8]            ;1649
0003b0  6930              LDR      r0,[r6,#0x10]         ;1649
0003b2  f1090201          ADD      r2,r9,#1              ;1649
0003b6  fb050c01          MLA      r12,r5,r1,r0          ;1649
0003ba  68a1              LDR      r1,[r4,#8]            ;1649
0003bc  6920              LDR      r0,[r4,#0x10]         ;1649
0003be  4542              CMP      r2,r8                 ;1649
0003c0  fb050301          MLA      r3,r5,r1,r0           ;1649
0003c4  f8c3a000          STR      r10,[r3,#0]           ;1649
0003c8  dc79              BGT      |L383.1214|
                  |L383.970|
0003ca  eb0c0082          ADD      r0,r12,r2,LSL #2      ;1649
0003ce  f8537022          LDR      r7,[r3,r2,LSL #2]     ;1649
0003d2  edd00a00          VLDR     s1,[r0,#0]            ;1649
0003d6  4611              MOV      r1,r2                 ;1649
0003d8  e05d              B        |L383.1174|
                  |L383.986|
0003da  e074              B        |L383.1222|
                  |L383.988|
                          DCD      _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::__PRETTY_FUNCTION__
                  |L383.992|
0003e0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
0003e4  6f726574
0003e8  6563685c
0003ec  636f6d6d
0003f0  6f6e5c69
0003f4  6e636c75
0003f8  64655c61
0003fc  6e6b692f
000400  636f6d6d
000404  6f6e2f72
000408  6f626f74
00040c  2f6d6174
000410  726978  
000413  2e6800            DCB      ".h",0
000416  00                DCB      0
000417  00                DCB      0
                  |L383.1048|
000418  736f7274          DCB      "sortWhichDimension must be zero or one",0
00041c  57686963
000420  6844696d
000424  656e7369
000428  6f6e206d
00042c  75737420
000430  6265207a
000434  65726f20
000438  6f72206f
00043c  6e6500  
00043f  00                DCB      0
                  |L383.1088|
000440  536f7274          DCB      "Sort",0
000444  00      
000445  00                DCB      0
000446  00                DCB      0
000447  00                DCB      0
                  |L383.1096|
000448  4f626a65          DCB      "Objects are invalid",0
00044c  63747320
000450  61726520
000454  696e7661
000458  6c696400
                  |L383.1116|
00045c  696e6465          DCB      "indexes must be the same size as arr",0
000460  78657320
000464  6d757374
000468  20626520
00046c  74686520
000470  73616d65
000474  2073697a
000478  65206173
00047c  20617272
000480  00      
000481  00                DCB      0
000482  00                DCB      0
000483  00                DCB      0
                  |L383.1156|
000484  ed800a00          VSTR     s0,[r0,#0]            ;1649
000488  eb030081          ADD      r0,r3,r1,LSL #2       ;1649
00048c  f8500c04          LDR      r0,[r0,#-4]           ;1649
000490  f8430021          STR      r0,[r3,r1,LSL #2]     ;1649
000494  1e49              SUBS     r1,r1,#1              ;1649
                  |L383.1174|
000496  4549              CMP      r1,r9                 ;1649
000498  dd08              BLE      |L383.1196|
00049a  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1649
00049e  ed100a01          VLDR     s0,[r0,#-4]           ;1649
0004a2  eeb40ae0          VCMPE.F32 s0,s1                 ;1649
0004a6  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1649
0004aa  d3eb              BCC      |L383.1156|
                  |L383.1196|
0004ac  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1649
0004b0  1c52              ADDS     r2,r2,#1              ;1649
0004b2  edc00a00          VSTR     s1,[r0,#0]            ;1649
0004b6  f8437021          STR      r7,[r3,r1,LSL #2]     ;1649
0004ba  4542              CMP      r2,r8                 ;1649
0004bc  dd85              BLE      |L383.970|
                  |L383.1214|
0004be  1c6d              ADDS     r5,r5,#1              ;1649
0004c0  455d              CMP      r5,r11                ;1649
0004c2  f6ffaf74          BLT      |L383.942|
                  |L383.1222|
0004c6  b003              ADD      sp,sp,#0xc
0004c8  2000              MOVS     r0,#0                 ;1669
0004ca  e8bd8ff0          POP      {r4-r11,pc}
;;;1671   
                          ENDP


                          AREA ||area_number.384||, COMGROUP=_ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii, LINKORDER=||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.384||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIbEENS_6ResultEPKcRKT_PPvRi||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIbEENS_6ResultEPKcRKT_PPvRi, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIbEENS_6ResultEPKcRKT_PPvRi PROC ; Anki::Embedded::SerializedBuffer::SerializeRawBasicType<bool>(const char*, const T1&, void**, int&)
;;;133    
;;;134        template<typename Type> Result SerializedBuffer::SerializeRawBasicType(const char *objectName, const Type &in, void ** buffer, s32 &bufferLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;135        {
;;;136          return SerializeRawBasicType(objectName, &in, 1, buffer, bufferLength);
000004  460f              MOV      r7,r1
000006  4601              MOV      r1,r0
000008  461d              MOV      r5,r3                 ;135
00000a  4614              MOV      r4,r2                 ;135
00000c  2601              MOVS     r6,#1
00000e  4812              LDR      r0,|L390.88|
000010  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer27SerializeDescriptionStringsEPKcS3_PPvRi ; Anki::Embedded::SerializedBuffer::SerializeDescriptionStrings(const char*, const char*, void**, int&)
000014  2800              CMP      r0,#0
000016  bf1c              ITT      NE
000018  2001              MOVNE    r0,#1
;;;137        }
00001a  e8bd81f0          POPNE    {r4-r8,pc}
00001e  6828              LDR      r0,[r5,#0]
000020  2808              CMP      r0,#8
000022  db0a              BLT      |L390.58|
000024  6821              LDR      r1,[r4,#0]
000026  480d              LDR      r0,|L390.92|
000028  6008              STR      r0,[r1,#0]
00002a  6821              LDR      r1,[r4,#0]
00002c  604e              STR      r6,[r1,#4]
00002e  6820              LDR      r0,[r4,#0]
000030  3008              ADDS     r0,r0,#8
000032  6020              STR      r0,[r4,#0]
000034  6828              LDR      r0,[r5,#0]
000036  3808              SUBS     r0,r0,#8
000038  6028              STR      r0,[r5,#0]
                  |L390.58|
00003a  4632              MOV      r2,r6
00003c  4639              MOV      r1,r7
00003e  6820              LDR      r0,[r4,#0]
000040  f7fffffe          BL       __aeabi_memcpy
000044  6820              LDR      r0,[r4,#0]
000046  1c40              ADDS     r0,r0,#1
000048  6020              STR      r0,[r4,#0]
00004a  6828              LDR      r0,[r5,#0]
00004c  1e40              SUBS     r0,r0,#1
00004e  6028              STR      r0,[r5,#0]
000050  2000              MOVS     r0,#0
000052  e8bd81f0          POP      {r4-r8,pc}
;;;138    
                          ENDP

000056  0000              DCW      0x0000
                  |L390.88|
                          DCD      ||.constdata||+0xb48
                  |L390.92|
                          DCD      0x00010003

                          AREA ||area_number.391||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIbEENS_6ResultEPKcRKT_PPvRi, LINKORDER=||t._ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIbEENS_6ResultEPKcRKT_PPvRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.391||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded16SerializedBuffer21SerializeRawBasicTypeIbEENS_6ResultEPKcRKT_PPvRi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRi||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRi, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRi PROC ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<bool>(char*, void**, int&)
;;;245    
;;;246        template<typename Type> Type SerializedBuffer::DeserializeRawBasicType(char *objectName, void ** buffer, s32 &bufferLength)
000000  b530              PUSH     {r4,r5,lr}
;;;247        {
000002  4614              MOV      r4,r2
;;;248          // TODO: check if description is valid
;;;249          DeserializeDescriptionStrings(NULL, objectName, buffer, bufferLength);
000004  4613              MOV      r3,r2
000006  460d              MOV      r5,r1                 ;247
000008  460a              MOV      r2,r1
00000a  4601              MOV      r1,r0
00000c  b08d              SUB      sp,sp,#0x34           ;247
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi ; Anki::Embedded::SerializedBuffer::DeserializeDescriptionStrings(char*, char*, void**, int&)
;;;250    
;;;251          // TODO: check if encoded type is valid
;;;252          u16 sizeOfType;
;;;253          bool isBasicType;
;;;254          bool isInteger;
;;;255          bool isSigned;
;;;256          bool isFloat;
;;;257          bool isString;
;;;258          s32 numElements;
;;;259          EncodedBasicTypeBuffer::Deserialize(true, sizeOfType, isBasicType, isInteger, isSigned, isFloat, isString, numElements, buffer, bufferLength);
000014  a807              ADD      r0,sp,#0x1c
000016  a90c              ADD      r1,sp,#0x30
000018  e9cd1002          STRD     r1,r0,[sp,#8]
00001c  a80b              ADD      r0,sp,#0x2c
00001e  a90a              ADD      r1,sp,#0x28
000020  e9cd1000          STRD     r1,r0,[sp,#0]
000024  e9cd5404          STRD     r5,r4,[sp,#0x10]
000028  ab09              ADD      r3,sp,#0x24
00002a  aa08              ADD      r2,sp,#0x20
00002c  a906              ADD      r1,sp,#0x18
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer22EncodedBasicTypeBuffer11DeserializeEbRtRbS4_S4_S4_S4_RiPPvS5_ ; Anki::Embedded::SerializedBuffer::EncodedBasicTypeBuffer::Deserialize(bool, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
;;;260    
;;;261          const Type var = *reinterpret_cast<Type*>(*buffer);
000034  682b              LDR      r3,[r5,#0]
;;;262    
;;;263          AnkiConditionalErrorAndReturnValue(sizeOfType < 10000 && numElements > 0 && numElements < 1000000,
000036  f8bd2018          LDRH     r2,[sp,#0x18]
00003a  f2427110          MOV      r1,#0x2710
00003e  7818              LDRB     r0,[r3,#0]            ;261
000040  428a              CMP      r2,r1
000042  d206              BCS      |L397.82|
000044  9907              LDR      r1,[sp,#0x1c]
000046  2900              CMP      r1,#0
000048  bfc4              ITT      GT
00004a  f8dfc038          LDRGT    r12,|L397.132|
00004e  458c              CMPGT    r12,r1
000050  dc0f              BGT      |L397.114|
                  |L397.82|
000052  f2401107          MOV      r1,#0x107
000056  480c              LDR      r0,|L397.136|
000058  4b0c              LDR      r3,|L397.140|
00005a  e9cd0100          STRD     r0,r1,[sp,#0]
00005e  f1a30224          SUB      r2,r3,#0x24
000062  f1a2012c          SUB      r1,r2,#0x2c
000066  2005              MOVS     r0,#5
000068  f7fffffe          BL       _Anki_Log
;;;264            Type(), "SerializedBuffer::DeserializeRawBasicType", "Unreasonable deserialized values");
;;;265    
;;;266          *buffer = reinterpret_cast<u8*>(*buffer) + sizeOfType*numElements;
;;;267          bufferLength -= sizeOfType*numElements;
;;;268    
;;;269          return var;
;;;270        }
00006c  b00d              ADD      sp,sp,#0x34
00006e  2000              MOVS     r0,#0                 ;263
000070  bd30              POP      {r4,r5,pc}
                  |L397.114|
000072  fb023301          MLA      r3,r2,r1,r3           ;266
000076  602b              STR      r3,[r5,#0]            ;267
000078  6823              LDR      r3,[r4,#0]            ;267
00007a  fb023111          MLS      r1,r2,r1,r3           ;267
00007e  6021              STR      r1,[r4,#0]            ;267
000080  b00d              ADD      sp,sp,#0x34
000082  bd30              POP      {r4,r5,pc}
;;;271    
                          ENDP

                  |L397.132|
                          DCD      0x000f4240
                  |L397.136|
                          DCD      _ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<bool>(char*, void**, int&)::__PRETTY_FUNCTION__
                  |L397.140|
                          DCD      ||.constdata||+0xbac

                          AREA ||area_number.398||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRi, LINKORDER=||t._ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.398||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded16SerializedBuffer19DeserializeRawArrayIfEENS0_5ArrayIT_EEPcPPvRiRNS0_11MemoryStackE||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer19DeserializeRawArrayIfEENS0_5ArrayIT_EEPcPPvRiRNS0_11MemoryStackE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded16SerializedBuffer19DeserializeRawArrayIfEENS0_5ArrayIT_EEPcPPvRiRNS0_11MemoryStackE PROC ; Anki::Embedded::SerializedBuffer::DeserializeRawArray<float>(char*, void**, int&, Anki::Embedded::MemoryStack&)
;;;300    
;;;301        template<typename Type> Array<Type> SerializedBuffer::DeserializeRawArray(char *objectName, void ** buffer, s32 &bufferLength, MemoryStack &memory)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;302        {
000004  b09b              SUB      sp,sp,#0x6c
000006  4604              MOV      r4,r0
000008  461d              MOV      r5,r3
00000a  4616              MOV      r6,r2
;;;303          // TODO: check if description is valid
;;;304          DeserializeDescriptionStrings(NULL, objectName, buffer, bufferLength);
00000c  2000              MOVS     r0,#0
00000e  f8dd8088          LDR      r8,[sp,#0x88]
000012  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer29DeserializeDescriptionStringsEPcS2_PPvRi ; Anki::Embedded::SerializedBuffer::DeserializeDescriptionStrings(char*, char*, void**, int&)
;;;305    
;;;306          // TODO: check if encoded type is valid
;;;307          s32 height;
;;;308          s32 width;
;;;309          s32 stride;
;;;310          Flags::Buffer flags;
000016  a814              ADD      r0,sp,#0x50
000018  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
;;;311          u16 basicType_sizeOfType;
;;;312          bool basicType_isBasicType;
;;;313          bool basicType_isInteger;
;;;314          bool basicType_isSigned;
;;;315          bool basicType_isFloat;
;;;316          bool basicType_isString;
;;;317          s32 basicType_numElements;
;;;318          EncodedArray::Deserialize(true, height, width, stride, flags, basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString, basicType_numElements, buffer, bufferLength);
00001c  a813              ADD      r0,sp,#0x4c
00001e  a91a              ADD      r1,sp,#0x68
000020  e9cd1006          STRD     r1,r0,[sp,#0x18]
000024  a819              ADD      r0,sp,#0x64
000026  a918              ADD      r1,sp,#0x60
000028  e9cd1004          STRD     r1,r0,[sp,#0x10]
00002c  aa17              ADD      r2,sp,#0x5c
00002e  a914              ADD      r1,sp,#0x50
000030  9203              STR      r2,[sp,#0xc]
000032  9100              STR      r1,[sp,#0]
000034  ab16              ADD      r3,sp,#0x58
000036  a812              ADD      r0,sp,#0x48
000038  e9cd0301          STRD     r0,r3,[sp,#4]
00003c  e9cd6508          STRD     r6,r5,[sp,#0x20]
000040  ab10              ADD      r3,sp,#0x40
000042  aa11              ADD      r2,sp,#0x44
000044  a90f              ADD      r1,sp,#0x3c
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       _ZN4Anki8Embedded16SerializedBuffer12EncodedArray11DeserializeEbRiS3_S3_RNS0_5Flags6BufferERtRbS8_S8_S8_S8_S3_PPvS3_ ; Anki::Embedded::SerializedBuffer::EncodedArray::Deserialize(bool, int&, int&, int&, Anki::Embedded::Flags::Buffer&, unsigned short&, bool&, bool&, bool&, bool&, bool&, int&, void**, int&)
;;;319    
;;;320          AnkiConditionalErrorAndReturnValue(
00004c  4853              LDR      r0,|L404.412|
00004e  f8ddc03c          LDR      r12,[sp,#0x3c]
000052  4f53              LDR      r7,|L404.416|
000054  4584              CMP      r12,r0
000056  d218              BCS      |L404.138|
000058  9a11              LDR      r2,[sp,#0x44]
00005a  2a00              CMP      r2,#0
00005c  bfa4              ITT      GE
00005e  f8df9144          LDRGE    r9,|L404.420|
000062  4591              CMPGE    r9,r2
000064  dd11              BLE      |L404.138|
000066  9910              LDR      r1,[sp,#0x40]
000068  2900              CMP      r1,#0
00006a  bfc8              IT       GT
00006c  4589              CMPGT    r9,r1
00006e  dd0c              BLE      |L404.138|
000070  f8bd3048          LDRH     r3,[sp,#0x48]
000074  2b00              CMP      r3,#0
000076  bf1c              ITT      NE
000078  f2427010          MOVNE    r0,#0x2710
00007c  4283              CMPNE    r3,r0
00007e  d204              BCS      |L404.138|
000080  9813              LDR      r0,[sp,#0x4c]
000082  2800              CMP      r0,#0
000084  bfa8              IT       GE
000086  4581              CMPGE    r9,r0
000088  dc0f              BGT      |L404.170|
                  |L404.138|
00008a  f44f70a0          MOV      r0,#0x140
00008e  e9cd7000          STRD     r7,r0,[sp,#0]
000092  a345              ADR      r3,|L404.424|
000094  a253              ADR      r2,|L404.484|
000096  a15c              ADR      r1,|L404.520|
000098  2005              MOVS     r0,#5
00009a  f7fffffe          BL       _Anki_Log
00009e  4620              MOV      r0,r4
0000a0  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
;;;321            height >= 0 && height < s32(1e9) &&
;;;322            width >= 0 && width < s32(2e9) &&
;;;323            stride > 0 && stride < s32(2e9) &&
;;;324            basicType_sizeOfType > 0 && basicType_sizeOfType < 10000 &&
;;;325            basicType_numElements >= 0 && basicType_numElements < s32(2e9),
;;;326            Array<Type>(), "SerializedBuffer::DeserializeRawArray", "Unreasonable deserialized values");
;;;327    
;;;328          if(width > 0) {
;;;329            AnkiConditionalErrorAndReturnValue(stride == RoundUp(width*sizeof(Type), MEMORY_ALIGNMENT),
;;;330              Array<Type>(), "SerializedBuffer::DeserializeRawArray", "Parsed stride is not reasonable");
;;;331          }
;;;332    
;;;333          AnkiConditionalErrorAndReturnValue(bufferLength >= (height*stride),
;;;334            Array<Type>(), "SerializedBuffer::DeserializeRawArray", "Not enought bytes left to set the array");
;;;335    
;;;336          Array<Type> out = Array<Type>(height, width, memory);
;;;337          
;;;338          AnkiConditionalErrorAndReturnValue(out.IsValid(),
;;;339            Array<Type>(), "SerializedBuffer::DeserializeRawArray", "Could not allocate array");
;;;340    
;;;341          const s32 numElements = out.get_size(0) * out.get_size(1);
;;;342    
;;;343          if(numElements > 0) {
;;;344            memcpy(out.Pointer(0,0), *buffer, height*stride);
;;;345    
;;;346            *buffer = reinterpret_cast<u8*>(*buffer) + height*stride;
;;;347            bufferLength -= height*stride;
;;;348    
;;;349            const Result stringCopyResult = CopyArrayStringsFromBuffer<Type>(out, buffer, bufferLength, memory);
;;;350    
;;;351            if(stringCopyResult != RESULT_OK) {
;;;352              return Array<Type>();
;;;353            }
;;;354          }
;;;355    
;;;356          return out;
;;;357        }
0000a4  b01b              ADD      sp,sp,#0x6c
0000a6  e8bd83f0          POP      {r4-r9,pc}
                  |L404.170|
0000aa  2a00              CMP      r2,#0                 ;328
0000ac  dd15              BLE      |L404.218|
0000ae  0090              LSLS     r0,r2,#2              ;329
0000b0  300f              ADDS     r0,r0,#0xf            ;329
0000b2  f020000f          BIC      r0,r0,#0xf            ;329
0000b6  4288              CMP      r0,r1                 ;329
0000b8  d00f              BEQ      |L404.218|
0000ba  f2401049          MOV      r0,#0x149             ;329
0000be  e9cd7000          STRD     r7,r0,[sp,#0]         ;329
0000c2  a339              ADR      r3,|L404.424|
0000c4  a25a              ADR      r2,|L404.560|
0000c6  a150              ADR      r1,|L404.520|
0000c8  2005              MOVS     r0,#5                 ;329
0000ca  f7fffffe          BL       _Anki_Log
0000ce  4620              MOV      r0,r4                 ;329
0000d0  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
0000d4  b01b              ADD      sp,sp,#0x6c
0000d6  e8bd83f0          POP      {r4-r9,pc}
                  |L404.218|
0000da  6828              LDR      r0,[r5,#0]            ;333
0000dc  fb0cf101          MUL      r1,r12,r1             ;333
0000e0  4288              CMP      r0,r1                 ;333
0000e2  da0f              BGE      |L404.260|
0000e4  f240104d          MOV      r0,#0x14d             ;333
0000e8  e9cd7000          STRD     r7,r0,[sp,#0]         ;333
0000ec  a32e              ADR      r3,|L404.424|
0000ee  a258              ADR      r2,|L404.592|
0000f0  a145              ADR      r1,|L404.520|
0000f2  2005              MOVS     r0,#5                 ;333
0000f4  f7fffffe          BL       _Anki_Log
0000f8  4620              MOV      r0,r4                 ;333
0000fa  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
0000fe  b01b              ADD      sp,sp,#0x6c
000100  e8bd83f0          POP      {r4-r9,pc}
                  |L404.260|
000104  2300              MOVS     r3,#0                 ;336
000106  461a              MOV      r2,r3                 ;336
000108  2101              MOVS     r1,#1                 ;336
00010a  a815              ADD      r0,sp,#0x54           ;336
00010c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000110  6800              LDR      r0,[r0,#0]            ;336
000112  9000              STR      r0,[sp,#0]            ;336
000114  4643              MOV      r3,r8                 ;336
000116  a80a              ADD      r0,sp,#0x28           ;336
000118  9a11              LDR      r2,[sp,#0x44]         ;336
00011a  990f              LDR      r1,[sp,#0x3c]         ;336
00011c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000120  a80a              ADD      r0,sp,#0x28           ;338
000122  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
000126  b340              CBZ      r0,|L404.378|
000128  2100              MOVS     r1,#0                 ;341
00012a  a80a              ADD      r0,sp,#0x28           ;341
00012c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000130  4607              MOV      r7,r0                 ;341
000132  2101              MOVS     r1,#1                 ;341
000134  a80a              ADD      r0,sp,#0x28           ;341
000136  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00013a  4378              MULS     r0,r7,r0              ;341
00013c  2800              CMP      r0,#0                 ;343
00013e  dd14              BLE      |L404.362|
000140  9a0e              LDR      r2,[sp,#0x38]         ;343
000142  990c              LDR      r1,[sp,#0x30]         ;343
000144  2000              MOVS     r0,#0                 ;344
000146  fb002001          MLA      r0,r0,r1,r2           ;344
00014a  e9dd120f          LDRD     r1,r2,[sp,#0x3c]      ;344
00014e  434a              MULS     r2,r1,r2              ;344
000150  6831              LDR      r1,[r6,#0]            ;344
000152  f7fffffe          BL       __aeabi_memcpy
000156  e9dd010f          LDRD     r0,r1,[sp,#0x3c]      ;346
00015a  6832              LDR      r2,[r6,#0]            ;346
00015c  fb002201          MLA      r2,r0,r1,r2           ;346
000160  6032              STR      r2,[r6,#0]            ;347
000162  682a              LDR      r2,[r5,#0]            ;347
000164  fb002011          MLS      r0,r0,r1,r2           ;347
000168  6028              STR      r0,[r5,#0]            ;347
                  |L404.362|
00016a  ad0a              ADD      r5,sp,#0x28           ;347
00016c  e8b5100f          LDM      r5!,{r0-r3,r12}       ;347
000170  e8a4100f          STM      r4!,{r0-r3,r12}       ;347
000174  b01b              ADD      sp,sp,#0x6c
000176  e8bd83f0          POP      {r4-r9,pc}
                  |L404.378|
00017a  f44f70a9          MOV      r0,#0x152             ;338
00017e  e9cd7000          STRD     r7,r0,[sp,#0]         ;338
000182  a309              ADR      r3,|L404.424|
000184  a23c              ADR      r2,|L404.632|
000186  a120              ADR      r1,|L404.520|
000188  2005              MOVS     r0,#5                 ;338
00018a  f7fffffe          BL       _Anki_Log
00018e  4620              MOV      r0,r4                 ;338
000190  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1Ev ; Anki::Embedded::Array<float>::Array()
000194  b01b              ADD      sp,sp,#0x6c
000196  e8bd83f0          POP      {r4-r9,pc}
;;;358    
                          ENDP

00019a  0000              DCW      0x0000
                  |L404.412|
                          DCD      0x3b9aca00
                  |L404.416|
                          DCD      _ZZN4Anki8Embedded16SerializedBuffer19DeserializeRawArrayIfEENS0_5ArrayIT_EEPcPPvRiRNS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawArray<float>(char*, void**, int&, Anki::Embedded::MemoryStack&)::__PRETTY_FUNCTION__
                  |L404.420|
                          DCD      0x77359400
                  |L404.424|
0001a8  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/serial"
0001ac  6f726574
0001b0  6563685c
0001b4  636f6d6d
0001b8  6f6e5c69
0001bc  6e636c75
0001c0  64655c61
0001c4  6e6b692f
0001c8  636f6d6d
0001cc  6f6e2f72
0001d0  6f626f74
0001d4  2f736572
0001d8  69616c  
0001db  697a652e          DCB      "ize.h",0
0001df  6800    
0001e1  00                DCB      0
0001e2  00                DCB      0
0001e3  00                DCB      0
                  |L404.484|
0001e4  556e7265          DCB      "Unreasonable deserialized values",0
0001e8  61736f6e
0001ec  61626c65
0001f0  20646573
0001f4  65726961
0001f8  6c697a65
0001fc  64207661
000200  6c756573
000204  00      
000205  00                DCB      0
000206  00                DCB      0
000207  00                DCB      0
                  |L404.520|
000208  53657269          DCB      "SerializedBuffer::DeserializeRawArray",0
00020c  616c697a
000210  65644275
000214  66666572
000218  3a3a4465
00021c  73657269
000220  616c697a
000224  65526177
000228  41727261
00022c  7900    
00022e  00                DCB      0
00022f  00                DCB      0
                  |L404.560|
000230  50617273          DCB      "Parsed stride is not reasonable",0
000234  65642073
000238  74726964
00023c  65206973
000240  206e6f74
000244  20726561
000248  736f6e61
00024c  626c6500
                  |L404.592|
000250  4e6f7420          DCB      "Not enought bytes left to set the array",0
000254  656e6f75
000258  67687420
00025c  62797465
000260  73206c65
000264  66742074
000268  6f207365
00026c  74207468
000270  65206172
000274  72617900
                  |L404.632|
000278  436f756c          DCB      "Could not allocate array",0
00027c  64206e6f
000280  7420616c
000284  6c6f6361
000288  74652061
00028c  72726179
000290  00      
000291  00                DCB      0
000292  00                DCB      0
000293  00                DCB      0

                          AREA ||area_number.405||, COMGROUP=_ZN4Anki8Embedded16SerializedBuffer19DeserializeRawArrayIfEENS0_5ArrayIT_EEPcPPvRiRNS0_11MemoryStackE, LINKORDER=||t._ZN4Anki8Embedded16SerializedBuffer19DeserializeRawArrayIfEENS0_5ArrayIT_EEPcPPvRiRNS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.405||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded16SerializedBuffer19DeserializeRawArrayIfEENS0_5ArrayIT_EEPcPPvRiRNS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi PROC ; Anki::Embedded::Array<unsigned char>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L411.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L411.56|
00000e  4b0b              LDR      r3,|L411.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f1030250          ADD      r2,r3,#0x50
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L411.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L411.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::get_size(int) const::__PRETTY_FUNCTION__
                  |L411.60|
                          DCD      ||.constdata||+0xab0

                          AREA ||area_number.412||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.412||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv||, COMGROUP=_ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<short>>::IsValid() const
;;;91     
;;;92         template<typename Type> bool FixedLengthList<Type>::IsValid() const
000000  68c2              LDR      r2,[r0,#0xc]
;;;93         {
;;;94           if(this->get_size() > this->get_maximumSize()) {
000002  69c1              LDR      r1,[r0,#0x1c]
000004  428a              CMP      r2,r1
000006  dc07              BGT      |L418.24|
000008  6a82              LDR      r2,[r0,#0x28]         ;93
00000a  b12a              CBZ      r2,|L418.24|
00000c  6980              LDR      r0,[r0,#0x18]         ;93
00000e  2800              CMP      r0,#0                 ;93
000010  bfa2              ITTT     GE                    ;93
000012  2900              CMPGE    r1,#0                 ;93
000014  2001              MOVGE    r0,#1                 ;93
;;;95             return false;
;;;96           }
;;;97     
;;;98           return ArraySlice<Type>::IsValid();
;;;99         } // bool FixedLengthList<Type>::IsValid() const
000016  4770              BXGE     lr
                  |L418.24|
000018  2000              MOVS     r0,#0
00001a  4770              BX       lr
;;;100    
                          ENDP


                          AREA ||area_number.419||, COMGROUP=_ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv, LINKORDER=||t._ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.419||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded15FixedLengthListINS0_5PointIsEEE7IsValidEv||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE||, COMGROUP=_ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15ConstArraySliceIfEC2ERKNS0_5ArrayIfEE                  ; Alternate entry point ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice__sub_object(const Anki::Embedded::Array<float>&)
                  _ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE PROC ; Anki::Embedded::ConstArraySlice<float>::ConstArraySlice(const Anki::Embedded::Array<float>&)
;;;26     
;;;27         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array)
;;;28           : ySlice(LinearSequence<s32>(0,array.get_size(0)-1)), xSlice(LinearSequence<s32>(0,array.get_size(1)-1)), array(array)
;;;29         {
;;;30           if(array.get_numElements() == 0) {
;;;31             this->constArrayData = NULL;
;;;32           } else {
;;;33             this->constArrayData = array.Pointer(0,0);
;;;34           }
;;;35         }
;;;36     
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
000006  2100              MOVS     r1,#0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00000e  1e42              SUBS     r2,r0,#1
000010  2100              MOVS     r1,#0
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000018  4605              MOV      r5,r0
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000022  1e42              SUBS     r2,r0,#1
000024  2100              MOVS     r1,#0
000026  f105000c          ADD      r0,r5,#0xc
00002a  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00002e  e894102e          LDM      r4,{r1-r3,r5,r12}
000032  380c              SUBS     r0,r0,#0xc
000034  f1000618          ADD      r6,r0,#0x18
000038  e8a6102e          STM      r6!,{r1-r3,r5,r12}
00003c  6821              LDR      r1,[r4,#0]
00003e  2900              CMP      r1,#0
000040  bfc4              ITT      GT
000042  6862              LDRGT    r2,[r4,#4]
000044  2a00              CMPGT    r2,#0
000046  dd08              BLE      |L425.90|
000048  4351              MULS     r1,r2,r1
00004a  b131              CBZ      r1,|L425.90|
00004c  68a3              LDR      r3,[r4,#8]
00004e  6922              LDR      r2,[r4,#0x10]
000050  2100              MOVS     r1,#0
000052  fb012103          MLA      r1,r1,r3,r2
                  |L425.86|
000056  62c1              STR      r1,[r0,#0x2c]
000058  bd70              POP      {r4-r6,pc}
                  |L425.90|
00005a  2100              MOVS     r1,#0
00005c  e7fb              B        |L425.86|
                          ENDP


                          AREA ||area_number.426||, COMGROUP=_ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE, LINKORDER=||t._ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.426||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15ConstArraySliceIfEC1ERKNS0_5ArrayIfEE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L432.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L432.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L432.384|
000044  a25c              ADR      r2,|L432.440|
000046  a160              ADR      r1,|L432.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L432.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  00c0              LSLS     r0,r0,#3
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L432.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L432.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L432.384|
000080  a24d              ADR      r2,|L432.440|
000082  a157              ADR      r1,|L432.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L432.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L432.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L432.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L432.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L432.384|
0000c8  a251              ADR      r2,|L432.528|
0000ca  a156              ADR      r1,|L432.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L432.372|
                  |L432.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L432.384|
0000e0  a258              ADR      r2,|L432.580|
0000e2  a15f              ADR      r1,|L432.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L432.372|
                  |L432.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L432.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L432.384|
000110  a259              ADR      r2,|L432.632|
000112  a144              ADR      r1,|L432.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L432.372|
                  |L432.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00f1              LSLS     r1,r6,#3
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L432.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L432.384|
00015a  a251              ADR      r2,|L432.672|
00015c  a140              ADR      r1,|L432.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L432.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L432.380|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L432.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L432.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L432.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L432.476|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L432.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L432.524|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L432.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L432.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L432.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L432.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L432.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L432.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.433||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.433||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv||, COMGROUP=_ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Point<float>>::get_maximumSize() const
;;;169    
;;;170        template<typename Type> inline s32 FixedLengthList<Type>::get_maximumSize() const
000000  69c0              LDR      r0,[r0,#0x1c]
;;;171        {
;;;172          return this->array.get_size(1);
;;;173        } // s32 FixedLengthList<Type>::get_maximumSize() const
000002  4770              BX       lr
;;;174    
                          ENDP


                          AREA ||area_number.440||, COMGROUP=_ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv, LINKORDER=||t._ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.440||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded15FixedLengthListINS0_5PointIfEEE15get_maximumSizeEv||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_9DotDivideIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_9DotDivideIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_9DotDivideIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE PROC ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::DotDivide<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, T1, Anki::Embedded::ArraySlice<T3>)
;;;1884   
;;;1885           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
000000  b40f              PUSH     {r0-r3}
;;;1886           {
000002  ed2d0b02          VPUSH    {d0}
000006  b5f0              PUSH     {r4-r7,lr}
000008  4606              MOV      r6,r0
00000a  ed2d8b02          VPUSH    {d8}
00000e  b099              SUB      sp,sp,#0x64
000010  f1000418          ADD      r4,r0,#0x18
000014  eeb08a40          VMOV.F32 s16,s0
000018  ad29              ADD      r5,sp,#0xa4
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
;;;1887             const Array<InType> &in1Array = in1.get_array();
;;;1888             Array<OutType> &out1Array = out.get_array();
;;;1889   
;;;1890             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, out1Array),
000020  4f96              LDR      r7,|L446.636|
000022  2800              CMP      r0,#0
000024  d043              BEQ      |L446.174|
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00002c  2800              CMP      r0,#0
00002e  d03e              BEQ      |L446.174|
000030  f8961030          LDRB     r1,[r6,#0x30]
000034  9a23              LDR      r2,[sp,#0x8c]
000036  9207              STR      r2,[sp,#0x1c]
000038  9a26              LDR      r2,[sp,#0x98]
00003a  9208              STR      r2,[sp,#0x20]
00003c  9a27              LDR      r2,[sp,#0x9c]
00003e  920c              STR      r2,[sp,#0x30]
000040  9a28              LDR      r2,[sp,#0xa0]
000042  920d              STR      r2,[sp,#0x34]
000044  9a26              LDR      r2,[sp,#0x98]
000046  920e              STR      r2,[sp,#0x38]
000048  9a24              LDR      r2,[sp,#0x90]
00004a  920f              STR      r2,[sp,#0x3c]
00004c  9a25              LDR      r2,[sp,#0x94]
00004e  9210              STR      r2,[sp,#0x40]
000050  9a23              LDR      r2,[sp,#0x8c]
000052  f106000c          ADD      r0,r6,#0xc
000056  9211              STR      r2,[sp,#0x44]         ;1886
000058  6843              LDR      r3,[r0,#4]            ;1886
00005a  9312              STR      r3,[sp,#0x48]         ;1886
00005c  6883              LDR      r3,[r0,#8]            ;1886
00005e  9313              STR      r3,[sp,#0x4c]         ;1886
000060  6800              LDR      r0,[r0,#0]            ;1886
000062  9014              STR      r0,[sp,#0x50]         ;1886
000064  6870              LDR      r0,[r6,#4]            ;1886
000066  9015              STR      r0,[sp,#0x54]         ;1886
000068  68b0              LDR      r0,[r6,#8]            ;1886
00006a  9016              STR      r0,[sp,#0x58]         ;1886
00006c  6830              LDR      r0,[r6,#0]            ;1886
00006e  9017              STR      r0,[sp,#0x5c]         ;1886
000070  f88d1060          STRB     r1,[sp,#0x60]         ;1886
000074  980d              LDR      r0,[sp,#0x34]         ;1886
000076  9009              STR      r0,[sp,#0x24]         ;1886
000078  2200              MOVS     r2,#0                 ;1886
00007a  2001              MOVS     r0,#1                 ;1886
00007c  2900              CMP      r1,#0                 ;1886
00007e  990e              LDR      r1,[sp,#0x38]         ;1886
000080  f88d2008          STRB     r2,[sp,#8]            ;1886
000084  d025              BEQ      |L446.210|
000086  9b17              LDR      r3,[sp,#0x5c]         ;1886
000088  4299              CMP      r1,r3                 ;1886
00008a  d135              BNE      |L446.248|
00008c  9b14              LDR      r3,[sp,#0x50]         ;1886
00008e  9911              LDR      r1,[sp,#0x44]         ;1886
000090  4299              CMP      r1,r3                 ;1886
000092  d131              BNE      |L446.248|
000094  f88d0008          STRB     r0,[sp,#8]            ;1886
000098  9812              LDR      r0,[sp,#0x48]         ;1886
00009a  9006              STR      r0,[sp,#0x18]         ;1886
00009c  980f              LDR      r0,[sp,#0x3c]         ;1886
00009e  f88d2009          STRB     r2,[sp,#9]            ;1886
0000a2  9003              STR      r0,[sp,#0xc]          ;1886
0000a4  9816              LDR      r0,[sp,#0x58]         ;1886
0000a6  920a              STR      r2,[sp,#0x28]         ;1886
0000a8  900b              STR      r0,[sp,#0x2c]         ;1886
0000aa  f000b895          B.W      |L446.472|
                  |L446.174|
0000ae  f2407062          MOV      r0,#0x762
0000b2  e9cd7000          STRD     r7,r0,[sp,#0]
0000b6  a372              ADR      r3,|L446.640|
0000b8  a27f              ADR      r2,|L446.696|
0000ba  a183              ADR      r1,|L446.712|
0000bc  2005              MOVS     r0,#5
0000be  f7fffffe          BL       _Anki_Log
0000c2  f04f6080          MOV      r0,#0x4000000
                  |L446.198|
;;;1891               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1892   
;;;1893             ArraySliceLimits_in1_out1<s32> limits(
;;;1894               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1895               out.get_ySlice(), out.get_xSlice());
;;;1896   
;;;1897             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1898               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1899   
;;;1900             if(limits.isSimpleIteration) {
;;;1901               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1902   
;;;1903               for(s32 y=0; y<limits.ySize; y++) {
;;;1904                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1905                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1906   
;;;1907                 limits.OuterIncrementTop();
;;;1908   
;;;1909                 for(s32 x=0; x<limits.xSize; x++) {
;;;1910                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], value2);
;;;1911   
;;;1912                   limits.in1X += limits.in1_xInnerIncrement;
;;;1913                   limits.out1X += limits.out1_xInnerIncrement;
;;;1914                 }
;;;1915   
;;;1916                 limits.OuterIncrementBottom();
;;;1917               }
;;;1918             } else { // if(limits.isSimpleIteration)
;;;1919               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1920   
;;;1921               for(s32 y=0; y<limits.ySize; y++) {
;;;1922                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1923   
;;;1924                 limits.OuterIncrementTop();
;;;1925   
;;;1926                 for(s32 x=0; x<limits.xSize; x++) {
;;;1927                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1928   
;;;1929                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, value2);
;;;1930   
;;;1931                   limits.in1X += limits.in1_xInnerIncrement;
;;;1932                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1933                   limits.out1X += limits.out1_xInnerIncrement;
;;;1934                 }
;;;1935   
;;;1936                 limits.OuterIncrementBottom();
;;;1937               }
;;;1938             } //   if(limits.isSimpleIteration)  ... else
;;;1939   
;;;1940             return RESULT_OK;
;;;1941           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
0000c6  b019              ADD      sp,sp,#0x64
0000c8  ecbd8b02          VPOP     {d8}
0000cc  bcf0              POP      {r4-r7}
0000ce  f85dfb1c          LDR      pc,[sp],#0x1c
                  |L446.210|
0000d2  9b14              LDR      r3,[sp,#0x50]
0000d4  4299              CMP      r1,r3
0000d6  d10f              BNE      |L446.248|
0000d8  9b17              LDR      r3,[sp,#0x5c]
0000da  9911              LDR      r1,[sp,#0x44]
0000dc  4299              CMP      r1,r3
0000de  d10b              BNE      |L446.248|
0000e0  f88d0008          STRB     r0,[sp,#8]
0000e4  f88d0009          STRB     r0,[sp,#9]
0000e8  9815              LDR      r0,[sp,#0x54]
0000ea  9005              STR      r0,[sp,#0x14]
0000ec  980f              LDR      r0,[sp,#0x3c]
0000ee  9003              STR      r0,[sp,#0xc]
0000f0  9813              LDR      r0,[sp,#0x4c]
0000f2  e9cd020a          STRD     r0,r2,[sp,#0x28]
0000f6  e012              B        |L446.286|
                  |L446.248|
0000f8  f240113f          MOV      r1,#0x13f
0000fc  487b              LDR      r0,|L446.748|
0000fe  e9cd0100          STRD     r0,r1,[sp,#0]
000102  a37b              ADR      r3,|L446.752|
000104  a289              ADR      r2,|L446.812|
000106  a194              ADR      r1,|L446.856|
000108  2005              MOVS     r0,#5
00010a  f7fffffe          BL       _Anki_Log
00010e  f89d0008          LDRB     r0,[sp,#8]            ;1897
000112  2800              CMP      r0,#0                 ;1897
000114  d046              BEQ      |L446.420|
000116  f89d0009          LDRB     r0,[sp,#9]            ;1900
00011a  2800              CMP      r0,#0                 ;1900
00011c  d05c              BEQ      |L446.472|
                  |L446.286|
00011e  9807              LDR      r0,[sp,#0x1c]         ;1903
000120  2600              MOVS     r6,#0                 ;1903
000122  2800              CMP      r0,#0                 ;1903
000124  f34080a8          BLE.W    |L446.632|
                  |L446.296|
000128  9805              LDR      r0,[sp,#0x14]         ;1903
00012a  68a2              LDR      r2,[r4,#8]            ;1903
00012c  6921              LDR      r1,[r4,#0x10]         ;1903
00012e  68ab              LDR      r3,[r5,#8]            ;1903
000130  fb001102          MLA      r1,r0,r2,r1           ;1903
000134  9803              LDR      r0,[sp,#0xc]          ;1903
000136  692a              LDR      r2,[r5,#0x10]         ;1903
000138  fb002203          MLA      r2,r0,r3,r2           ;1903
00013c  f89d0009          LDRB     r0,[sp,#9]            ;1903
000140  2800              CMP      r0,#0                 ;1903
000142  bf19              ITTEE    NE                    ;1903
000144  9812              LDRNE    r0,[sp,#0x48]         ;1903
000146  9006              STRNE    r0,[sp,#0x18]         ;1903
000148  9815              LDREQ    r0,[sp,#0x54]         ;1903
00014a  9005              STREQ    r0,[sp,#0x14]         ;1903
00014c  980c              LDR      r0,[sp,#0x30]         ;1903
00014e  9004              STR      r0,[sp,#0x10]         ;1909
000150  9b08              LDR      r3,[sp,#0x20]         ;1909
000152  2000              MOVS     r0,#0                 ;1909
000154  2b00              CMP      r3,#0                 ;1909
000156  dd19              BLE      |L446.396|
                  |L446.344|
000158  9b06              LDR      r3,[sp,#0x18]         ;1910
00015a  1c40              ADDS     r0,r0,#1              ;1909
00015c  eb010383          ADD      r3,r1,r3,LSL #2       ;1910
000160  ed930a00          VLDR     s0,[r3,#0]            ;1910
000164  9b04              LDR      r3,[sp,#0x10]         ;1910
000166  eec00a08          VDIV.F32 s1,s0,s16             ;1910
00016a  eb020383          ADD      r3,r2,r3,LSL #2       ;1910
00016e  edc30a00          VSTR     s1,[r3,#0]            ;1910
000172  f8ddc028          LDR      r12,[sp,#0x28]        ;1912
000176  9b06              LDR      r3,[sp,#0x18]         ;1912
000178  4463              ADD      r3,r3,r12             ;1912
00017a  9306              STR      r3,[sp,#0x18]         ;1913
00017c  f8ddc024          LDR      r12,[sp,#0x24]        ;1913
000180  9b04              LDR      r3,[sp,#0x10]         ;1913
000182  4463              ADD      r3,r3,r12             ;1913
000184  9304              STR      r3,[sp,#0x10]         ;1909
000186  9b08              LDR      r3,[sp,#0x20]         ;1909
000188  4283              CMP      r3,r0                 ;1909
00018a  dce5              BGT      |L446.344|
                  |L446.396|
00018c  f89d0009          LDRB     r0,[sp,#9]            ;1909
000190  b1a8              CBZ      r0,|L446.446|
000192  9916              LDR      r1,[sp,#0x58]         ;1909
000194  9805              LDR      r0,[sp,#0x14]         ;1909
000196  4408              ADD      r0,r0,r1              ;1909
000198  9005              STR      r0,[sp,#0x14]         ;1909
00019a  9910              LDR      r1,[sp,#0x40]         ;1909
00019c  9803              LDR      r0,[sp,#0xc]          ;1909
00019e  4408              ADD      r0,r0,r1              ;1909
0001a0  9003              STR      r0,[sp,#0xc]          ;1909
0001a2  e014              B        |L446.462|
                  |L446.420|
0001a4  f2407069          MOV      r0,#0x769             ;1897
0001a8  e9cd7000          STRD     r7,r0,[sp,#0]         ;1897
0001ac  a334              ADR      r3,|L446.640|
0001ae  a271              ADR      r2,|L446.884|
0001b0  a145              ADR      r1,|L446.712|
0001b2  2005              MOVS     r0,#5                 ;1897
0001b4  f7fffffe          BL       _Anki_Log
0001b8  f04f6080          MOV      r0,#0x4000000         ;1897
0001bc  e783              B        |L446.198|
                  |L446.446|
0001be  9913              LDR      r1,[sp,#0x4c]         ;1897
0001c0  9806              LDR      r0,[sp,#0x18]         ;1897
0001c2  4408              ADD      r0,r0,r1              ;1897
0001c4  9006              STR      r0,[sp,#0x18]         ;1897
0001c6  9910              LDR      r1,[sp,#0x40]         ;1897
0001c8  9803              LDR      r0,[sp,#0xc]          ;1897
0001ca  4408              ADD      r0,r0,r1              ;1897
0001cc  9003              STR      r0,[sp,#0xc]          ;1897
                  |L446.462|
0001ce  9807              LDR      r0,[sp,#0x1c]         ;1903
0001d0  1c76              ADDS     r6,r6,#1              ;1903
0001d2  42b0              CMP      r0,r6                 ;1903
0001d4  dca8              BGT      |L446.296|
0001d6  e04f              B        |L446.632|
                  |L446.472|
0001d8  9807              LDR      r0,[sp,#0x1c]         ;1921
0001da  2300              MOVS     r3,#0                 ;1921
0001dc  2800              CMP      r0,#0                 ;1921
0001de  dd4b              BLE      |L446.632|
                  |L446.480|
0001e0  9803              LDR      r0,[sp,#0xc]          ;1921
0001e2  68aa              LDR      r2,[r5,#8]            ;1921
0001e4  6929              LDR      r1,[r5,#0x10]         ;1921
0001e6  fb001c02          MLA      r12,r0,r2,r1          ;1921
0001ea  f89d0009          LDRB     r0,[sp,#9]            ;1921
0001ee  2800              CMP      r0,#0                 ;1921
0001f0  bf19              ITTEE    NE                    ;1921
0001f2  9812              LDRNE    r0,[sp,#0x48]         ;1921
0001f4  9006              STRNE    r0,[sp,#0x18]         ;1921
0001f6  9815              LDREQ    r0,[sp,#0x54]         ;1921
0001f8  9005              STREQ    r0,[sp,#0x14]         ;1921
0001fa  980c              LDR      r0,[sp,#0x30]         ;1921
0001fc  9004              STR      r0,[sp,#0x10]         ;1926
0001fe  9908              LDR      r1,[sp,#0x20]         ;1926
000200  2000              MOVS     r0,#0                 ;1926
000202  2900              CMP      r1,#0                 ;1926
000204  dd20              BLE      |L446.584|
                  |L446.518|
000206  e9dd2105          LDRD     r2,r1,[sp,#0x14]      ;1926
00020a  68a7              LDR      r7,[r4,#8]            ;1926
00020c  6926              LDR      r6,[r4,#0x10]         ;1926
00020e  1c40              ADDS     r0,r0,#1              ;1926
000210  fb026207          MLA      r2,r2,r7,r6           ;1926
000214  eb020181          ADD      r1,r2,r1,LSL #2       ;1926
000218  ed910a00          VLDR     s0,[r1,#0]            ;1927
00021c  9904              LDR      r1,[sp,#0x10]         ;1929
00021e  eec00a08          VDIV.F32 s1,s0,s16             ;1929
000222  eb0c0181          ADD      r1,r12,r1,LSL #2      ;1929
000226  edc10a00          VSTR     s1,[r1,#0]            ;1929
00022a  9a0a              LDR      r2,[sp,#0x28]         ;1931
00022c  9906              LDR      r1,[sp,#0x18]         ;1931
00022e  4411              ADD      r1,r1,r2              ;1931
000230  9106              STR      r1,[sp,#0x18]         ;1932
000232  9a0b              LDR      r2,[sp,#0x2c]         ;1932
000234  9905              LDR      r1,[sp,#0x14]         ;1932
000236  4411              ADD      r1,r1,r2              ;1932
000238  9105              STR      r1,[sp,#0x14]         ;1933
00023a  9a09              LDR      r2,[sp,#0x24]         ;1933
00023c  9904              LDR      r1,[sp,#0x10]         ;1933
00023e  4411              ADD      r1,r1,r2              ;1933
000240  9104              STR      r1,[sp,#0x10]         ;1926
000242  9908              LDR      r1,[sp,#0x20]         ;1926
000244  4281              CMP      r1,r0                 ;1926
000246  dcde              BGT      |L446.518|
                  |L446.584|
000248  f89d0009          LDRB     r0,[sp,#9]            ;1926
00024c  b140              CBZ      r0,|L446.608|
00024e  9916              LDR      r1,[sp,#0x58]         ;1926
000250  9805              LDR      r0,[sp,#0x14]         ;1926
000252  4408              ADD      r0,r0,r1              ;1926
000254  9005              STR      r0,[sp,#0x14]         ;1926
000256  9910              LDR      r1,[sp,#0x40]         ;1926
000258  9803              LDR      r0,[sp,#0xc]          ;1926
00025a  4408              ADD      r0,r0,r1              ;1926
00025c  9003              STR      r0,[sp,#0xc]          ;1926
00025e  e007              B        |L446.624|
                  |L446.608|
000260  9913              LDR      r1,[sp,#0x4c]         ;1926
000262  9806              LDR      r0,[sp,#0x18]         ;1926
000264  4408              ADD      r0,r0,r1              ;1926
000266  9006              STR      r0,[sp,#0x18]         ;1926
000268  9910              LDR      r1,[sp,#0x40]         ;1926
00026a  9803              LDR      r0,[sp,#0xc]          ;1926
00026c  4408              ADD      r0,r0,r1              ;1926
00026e  9003              STR      r0,[sp,#0xc]          ;1926
                  |L446.624|
000270  9807              LDR      r0,[sp,#0x1c]         ;1921
000272  1c5b              ADDS     r3,r3,#1              ;1921
000274  4298              CMP      r0,r3                 ;1921
000276  dcb3              BGT      |L446.480|
                  |L446.632|
000278  2000              MOVS     r0,#0                 ;1940
00027a  e724              B        |L446.198|
;;;1942   
                          ENDP

                  |L446.636|
                          DCD      _ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_9DotDivideIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::DotDivide<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, T1, Anki::Embedded::ArraySlice<T3>)::__PRETTY_FUNCTION__
                  |L446.640|
000280  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000284  6f726574
000288  6563685c
00028c  636f6d6d
000290  6f6e5c69
000294  6e636c75
000298  64655c61
00029c  6e6b692f
0002a0  636f6d6d
0002a4  6f6e2f72
0002a8  6f626f74
0002ac  2f6d6174
0002b0  726978  
0002b3  2e6800            DCB      ".h",0
0002b6  00                DCB      0
0002b7  00                DCB      0
                  |L446.696|
0002b8  496e7661          DCB      "Invalid objects",0
0002bc  6c696420
0002c0  6f626a65
0002c4  63747300
                  |L446.712|
0002c8  4d617472          DCB      "Matrix::Elementwise::ApplyOperation",0
0002cc  69783a3a
0002d0  456c656d
0002d4  656e7477
0002d8  6973653a
0002dc  3a417070
0002e0  6c794f70
0002e4  65726174
0002e8  696f6e00
                  |L446.748|
                          DCD      _ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)::__PRETTY_FUNCTION__
                  |L446.752|
0002f0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/arrayS"
0002f4  6f726574
0002f8  6563685c
0002fc  636f6d6d
000300  6f6e5c69
000304  6e636c75
000308  64655c61
00030c  6e6b692f
000310  636f6d6d
000314  6f6e2f72
000318  6f626f74
00031c  2f617272
000320  617953  
000323  6c696365          DCB      "lices.h",0
000327  732e6800
00032b  00                DCB      0
                  |L446.812|
00032c  53756273          DCB      "Subscripted assignment dimension mismatch",0
000330  63726970
000334  74656420
000338  61737369
00033c  676e6d65
000340  6e742064
000344  696d656e
000348  73696f6e
00034c  206d6973
000350  6d617463
000354  6800    
000356  00                DCB      0
000357  00                DCB      0
                  |L446.856|
000358  41727261          DCB      "ArraySliceLimits_in1_out1",0
00035c  79536c69
000360  63654c69
000364  6d697473
000368  5f696e31
00036c  5f6f7574
000370  3100    
000372  00                DCB      0
000373  00                DCB      0
                  |L446.884|
000374  4c696d69          DCB      "Limits is not valid",0
000378  74732069
00037c  73206e6f
000380  74207661
000384  6c696400

                          AREA ||area_number.447||, COMGROUP=_ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_9DotDivideIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_9DotDivideIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.447||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_9DotDivideIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_||, COMGROUP=_ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_ PROC ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<float>>(int, int, const T1&)
;;;260    
;;;261        template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1)
000000  b570              PUSH     {r4-r6,lr}
;;;262        {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;263          if(!AreValid(object1))
000008  4610              MOV      r0,r2
00000a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00000e  2800              CMP      r0,#0
;;;264            return false;
;;;265    
;;;266          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;267            return false;
;;;268    
;;;269          return true;
;;;270        }
000010  bf08              IT       EQ
000012  bd70              POPEQ    {r4-r6,pc}
000014  2100              MOVS     r1,#0                 ;266
000016  4630              MOV      r0,r6                 ;266
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001c  42a0              CMP      r0,r4                 ;266
00001e  d107              BNE      |L453.48|
000020  2101              MOVS     r1,#1                 ;266
000022  4630              MOV      r0,r6                 ;266
000024  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000028  42a8              CMP      r0,r5                 ;266
00002a  bf04              ITT      EQ                    ;269
00002c  2001              MOVEQ    r0,#1                 ;269
00002e  bd70              POPEQ    {r4-r6,pc}
                  |L453.48|
000030  2000              MOVS     r0,#0                 ;267
000032  bd70              POP      {r4-r6,pc}
;;;271    
                          ENDP


                          AREA ||area_number.454||, COMGROUP=_ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_, LINKORDER=||t._ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.454||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIfEEEEbiiRKT_||
                          DCD      0x00000001

                          AREA ||i._ZN4Anki8Embedded5RoundIiEET_f||, COMGROUP=_ZN4Anki8Embedded5RoundIiEET_f, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded5RoundIiEET_f PROC ; Anki::Embedded::Round<int>(float)
;;;222        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(v + 0.5f) : 0; }
;;;223        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(v + 0.5f) : static_cast<s32>(v - 0.5f); }
000000  eeb50ac0          VCMPE.F32 s0,#0.0
000004  eef60a00          VMOV.F32 s1,#0.50000000
000008  eef1fa10          VMRS     APSR_nzcv,FPSCR
00000c  dd06              BLE      |L460.28|
00000e  ee300a20          VADD.F32 s0,s0,s1
000012  eebd0ac0          VCVT.S32.F32 s0,s0
000016  ee100a10          VMOV     r0,s0
00001a  4770              BX       lr
                  |L460.28|
00001c  ee300a60          VSUB.F32 s0,s0,s1
000020  eebd0ac0          VCVT.S32.F32 s0,s0
000024  ee100a10          VMOV     r0,s0
000028  4770              BX       lr
;;;224        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(v + 0.5f) : static_cast<s64>(v - 0.5f); }
                          ENDP


                          AREA ||area_number.461||, COMGROUP=_ZN4Anki8Embedded5RoundIiEET_f, LINKORDER=||i._ZN4Anki8Embedded5RoundIiEET_f||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.461||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded5RoundIiEET_f||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIhEES3_EEbRKT_RKT0_||, COMGROUP=_ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIhEES3_EEbRKT_RKT0_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIhEES3_EEbRKT_RKT0_ PROC ; Anki::Embedded::AreEqualSize<Anki::Embedded::Array<unsigned char>, Anki::Embedded::Array<unsigned char>>(const T1&, const T2&)
;;;144    
;;;145        template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2)
000000  b570              PUSH     {r4-r6,lr}
;;;146        {
000002  4605              MOV      r5,r0
000004  6900              LDR      r0,[r0,#0x10]
000006  460c              MOV      r4,r1
000008  2800              CMP      r0,#0
00000a  d025              BEQ      |L467.88|
00000c  6828              LDR      r0,[r5,#0]
00000e  2800              CMP      r0,#0
000010  bfa4              ITT      GE
000012  6868              LDRGE    r0,[r5,#4]
000014  2800              CMPGE    r0,#0
000016  db1f              BLT      |L467.88|
000018  6920              LDR      r0,[r4,#0x10]
00001a  b1e8              CBZ      r0,|L467.88|
00001c  6820              LDR      r0,[r4,#0]
00001e  2800              CMP      r0,#0
000020  bfa4              ITT      GE
000022  6860              LDRGE    r0,[r4,#4]
000024  2800              CMPGE    r0,#0
000026  db17              BLT      |L467.88|
;;;147          if(!AreValid(object1, object2))
;;;148            return false;
;;;149    
;;;150          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1))
000028  2100              MOVS     r1,#0
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000030  4606              MOV      r6,r0
000032  2100              MOVS     r1,#0
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00003a  4286              CMP      r6,r0
00003c  d10c              BNE      |L467.88|
00003e  2101              MOVS     r1,#1
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000046  4605              MOV      r5,r0
000048  2101              MOVS     r1,#1
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000050  4285              CMP      r5,r0
;;;151            return false;
;;;152    
;;;153          return true;
000052  bf04              ITT      EQ
000054  2001              MOVEQ    r0,#1
;;;154        }
000056  bd70              POPEQ    {r4-r6,pc}
                  |L467.88|
000058  2000              MOVS     r0,#0                 ;151
00005a  bd70              POP      {r4-r6,pc}
;;;155    
                          ENDP


                          AREA ||area_number.468||, COMGROUP=_ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIhEES3_EEbRKT_RKT0_, LINKORDER=||t._ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIhEES3_EEbRKT_RKT0_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.468||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded12AreEqualSizeINS0_5ArrayIhEES3_EEbRKT_RKT0_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb||, COMGROUP=_ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb PROC ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)
;;;352    
;;;353          template<typename Type> Result SolveLeastSquaresWithCholesky(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;354            Array<Type> &A_L,       //!< Input A Matrix and Output lower-triangular L matrix
;;;355            Array<Type> &Bt_Xt,     //!< Input B-transpose matrix and Output X-transpose solution
;;;356            bool realCholesky,      //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;357            bool &numericalFailure  //!< If true, the solver failed because of numerical instability
;;;358            )
;;;359          {
000004  460e              MOV      r6,r1
000006  ed2d8b02          VPUSH    {d8}
00000a  b083              SUB      sp,sp,#0xc
00000c  4699              MOV      r9,r3
00000e  4604              MOV      r4,r0
;;;360            const s32 matrixHeight = A_L.get_size(0);
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000016  4605              MOV      r5,r0
;;;361            const s32 numSamples = Bt_Xt.get_size(0);
000018  2100              MOVS     r1,#0
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000020  4607              MOV      r7,r0
;;;362    
;;;363            numericalFailure = false;
000022  2000              MOVS     r0,#0
000024  f8890000          STRB     r0,[r9,#0]
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
;;;364    
;;;365            AnkiConditionalErrorAndReturnValue(AreValid(A_L, Bt_Xt),
00002e  f8df8258          LDR      r8,|L474.648|
000032  2800              CMP      r0,#0
000034  d01c              BEQ      |L474.112|
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE7IsValidEv ; Anki::Embedded::Array<float>::IsValid() const
00003c  2800              CMP      r0,#0
00003e  d017              BEQ      |L474.112|
;;;366              RESULT_FAIL_INVALID_OBJECT, "CholeskyDecomposition", "Invalid objects");
;;;367    
;;;368            AnkiConditionalErrorAndReturnValue(matrixHeight == A_L.get_size(1),
000040  2101              MOVS     r1,#1
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000048  42a8              CMP      r0,r5
00004a  d01e              BEQ      |L474.138|
00004c  f44f70b8          MOV      r0,#0x170
000050  e9cd8000          STRD     r8,r0,[sp,#0]
000054  a38d              ADR      r3,|L474.652|
000056  a29b              ADR      r2,|L474.708|
000058  a19f              ADR      r1,|L474.728|
00005a  2005              MOVS     r0,#5
00005c  f7fffffe          BL       _Anki_Log
000060  f04f60a0          MOV      r0,#0x5000000
                  |L474.100|
;;;369              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "A_L is not square");
;;;370    
;;;371            AnkiConditionalErrorAndReturnValue(Bt_Xt.get_size(1) == matrixHeight,
;;;372              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "Xt and Bt are the wrong sizes");
;;;373    
;;;374            // TODO: check if symmetric and positive-definite
;;;375    
;;;376            const Type minStableValue = Anki::Embedded::Flags::numeric_limits<Type>::epsilon();
;;;377    
;;;378            for(s32 i = 0; i < matrixHeight; i++) {
;;;379              // First, compute the non-diagonal values
;;;380              // This uses the results from the diagonal inverse computation from previous iterations of i
;;;381              Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;382    
;;;383              for(s32 j = 0; j < i; j++) {
;;;384                Type * restrict pAL_yj = A_L.Pointer(j, 0);
;;;385    
;;;386                Type sum = pAL_yi[j];
;;;387                for(s32 k = 0; k < j; k++) {
;;;388                  const Type value1 = pAL_yi[k];
;;;389                  const Type value2 = pAL_yj[k];
;;;390                  sum -= value1*value2;
;;;391                }
;;;392    
;;;393                pAL_yi[j] = sum*pAL_yj[j];
;;;394              } // for(s32 j = 0; j < i; j++)
;;;395    
;;;396              // Second, compute the inverse of the diagonal
;;;397              {
;;;398                Type sum = pAL_yi[i];
;;;399                for(s32 k = 0; k < i; k++) {
;;;400                  const Type value = pAL_yi[k];
;;;401                  sum -= value*value;
;;;402                }
;;;403    
;;;404                if(sum < minStableValue) {
;;;405                  numericalFailure = true;
;;;406                  return RESULT_OK;
;;;407                }
;;;408    
;;;409                // TODO: change this f32 square root to f64 if Type==f64
;;;410                const Type sumRoot = static_cast<Type>(sqrtf(static_cast<f32>(sum)));
;;;411                pAL_yi[i] = static_cast<Type>(1) / sumRoot;
;;;412              }
;;;413            } // for(s32 i = 0; i < m; i++)
;;;414    
;;;415            // Solve L*y = b via forward substitution
;;;416            for(s32 i = 0; i < matrixHeight; i++) {
;;;417              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;418              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;419    
;;;420              for(s32 j = 0; j < numSamples; j++) {
;;;421                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;422    
;;;423                Type sum = pBX_yj[i];
;;;424                for(s32 k = 0; k < i; k++) {
;;;425                  const Type value1 = pAL_yi[k];
;;;426                  const Type value2 = pBX_yj[k];
;;;427                  sum -= value1*value2;
;;;428                }
;;;429    
;;;430                pBX_yj[i] = sum*pAL_yi[i];
;;;431              }
;;;432            }
;;;433    
;;;434            // Solve L'*X = Y via back substitution
;;;435            for(s32 i = matrixHeight-1; i >= 0; i--) {
;;;436              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;437              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;438    
;;;439              for(s32 j = 0; j < numSamples; j++) {
;;;440                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;441    
;;;442                Type sum = pBX_yj[i];
;;;443                for(s32 k = matrixHeight-1; k > i; k-- ) {
;;;444                  const Type value1 = A_L[k][i];
;;;445                  const Type value2 = pBX_yj[k];
;;;446                  sum -= value1*value2;
;;;447                }
;;;448    
;;;449                pBX_yj[i] = sum*pAL_yi[i];
;;;450              }
;;;451            }
;;;452    
;;;453            if(realCholesky) {
;;;454              // Invert the diagonal values of L, and set upper triangular to zero
;;;455              for(s32 i = 0; i < matrixHeight; i++) {
;;;456                Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;457    
;;;458                pAL_yi[i] = static_cast<Type>(1) / pAL_yi[i];
;;;459    
;;;460                for(s32 j = i+1; j < matrixHeight; j++) {
;;;461                  pAL_yi[j] = 0;
;;;462                }
;;;463              }
;;;464            }
;;;465    
;;;466            return RESULT_OK;
;;;467          } // SolveLeastSquaresWithCholesky()
000064  b003              ADD      sp,sp,#0xc
000066  ecbd8b02          VPOP     {d8}
00006a  b004              ADD      sp,sp,#0x10
00006c  e8bd8ff0          POP      {r4-r11,pc}
                  |L474.112|
000070  f240106d          MOV      r0,#0x16d             ;365
000074  e9cd8000          STRD     r8,r0,[sp,#0]         ;365
000078  a384              ADR      r3,|L474.652|
00007a  a29d              ADR      r2,|L474.752|
00007c  a196              ADR      r1,|L474.728|
00007e  2005              MOVS     r0,#5                 ;365
000080  f7fffffe          BL       _Anki_Log
000084  f04f6080          MOV      r0,#0x4000000         ;365
000088  e7ec              B        |L474.100|
                  |L474.138|
00008a  2101              MOVS     r1,#1                 ;371
00008c  4630              MOV      r0,r6                 ;371
00008e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000092  42a8              CMP      r0,r5                 ;371
000094  d00c              BEQ      |L474.176|
000096  f2401073          MOV      r0,#0x173             ;371
00009a  e9cd8000          STRD     r8,r0,[sp,#0]         ;371
00009e  a37b              ADR      r3,|L474.652|
0000a0  a297              ADR      r2,|L474.768|
0000a2  a18d              ADR      r1,|L474.728|
0000a4  2005              MOVS     r0,#5                 ;371
0000a6  f7fffffe          BL       _Anki_Log
0000aa  f04f60a0          MOV      r0,#0x5000000         ;371
0000ae  e7d9              B        |L474.100|
                  |L474.176|
0000b0  eddf8a9b          VLDR     s17,|L474.800|
0000b4  f04f0800          MOV      r8,#0                 ;378
0000b8  eeb78a00          VMOV.F32 s16,#1.00000000       ;411
0000bc  2d00              CMP      r5,#0                 ;378
0000be  dd58              BLE      |L474.370|
                  |L474.192|
0000c0  68a1              LDR      r1,[r4,#8]            ;378
0000c2  6920              LDR      r0,[r4,#0x10]         ;378
0000c4  2200              MOVS     r2,#0                 ;383
0000c6  fb080101          MLA      r1,r8,r1,r0           ;383
0000ca  f1b80f00          CMP      r8,#0                 ;383
0000ce  dd22              BLE      |L474.278|
                  |L474.208|
0000d0  68a3              LDR      r3,[r4,#8]            ;383
0000d2  6920              LDR      r0,[r4,#0x10]         ;383
0000d4  eb010c82          ADD      r12,r1,r2,LSL #2      ;386
0000d8  fb020303          MLA      r3,r2,r3,r0           ;386
0000dc  ed9c0a00          VLDR     s0,[r12,#0]           ;386
0000e0  2000              MOVS     r0,#0                 ;387
0000e2  2a00              CMP      r2,#0                 ;387
0000e4  dd0c              BLE      |L474.256|
                  |L474.230|
0000e6  eb010a80          ADD      r10,r1,r0,LSL #2      ;388
0000ea  ed9a1a00          VLDR     s2,[r10,#0]           ;388
0000ee  eb030a80          ADD      r10,r3,r0,LSL #2      ;389
0000f2  1c40              ADDS     r0,r0,#1              ;387
0000f4  edda0a00          VLDR     s1,[r10,#0]           ;389
0000f8  4282              CMP      r2,r0                 ;387
0000fa  ee010a60          VMLS.F32 s0,s2,s1              ;390
0000fe  dcf2              BGT      |L474.230|
                  |L474.256|
000100  eb030082          ADD      r0,r3,r2,LSL #2       ;393
000104  1c52              ADDS     r2,r2,#1              ;383
000106  edd00a00          VLDR     s1,[r0,#0]            ;393
00010a  4542              CMP      r2,r8                 ;383
00010c  ee200a80          VMUL.F32 s0,s1,s0              ;393
000110  ed8c0a00          VSTR     s0,[r12,#0]           ;393
000114  dbdc              BLT      |L474.208|
                  |L474.278|
000116  eb010a88          ADD      r10,r1,r8,LSL #2      ;398
00011a  2000              MOVS     r0,#0                 ;399
00011c  ed9a0a00          VLDR     s0,[r10,#0]           ;398
000120  f1b80f00          CMP      r8,#0                 ;399
000124  dd08              BLE      |L474.312|
                  |L474.294|
000126  eb010280          ADD      r2,r1,r0,LSL #2       ;400
00012a  1c40              ADDS     r0,r0,#1              ;399
00012c  edd20a00          VLDR     s1,[r2,#0]            ;400
000130  4580              CMP      r8,r0                 ;399
000132  ee000ae0          VMLS.F32 s0,s1,s1              ;401
000136  dcf6              BGT      |L474.294|
                  |L474.312|
000138  eef48ac0          VCMPE.F32 s17,s0                ;404
00013c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;404
000140  dd04              BLE      |L474.332|
000142  2001              MOVS     r0,#1                 ;405
000144  f8890000          STRB     r0,[r9,#0]            ;405
000148  2000              MOVS     r0,#0                 ;406
00014a  e78b              B        |L474.100|
                  |L474.332|
00014c  eef10ac0          VSQRT.F32 s1,s0                 ;410
000150  eef40a60          VCMP.F32 s1,s1                 ;410
000154  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;410
000158  d003              BEQ      |L474.354|
00015a  f7fffffe          BL       __hardfp_sqrtf
00015e  eef00a40          VMOV.F32 s1,s0                 ;410
                  |L474.354|
000162  f1080801          ADD      r8,r8,#1              ;378
000166  ee880a20          VDIV.F32 s0,s16,s1             ;411
00016a  45a8              CMP      r8,r5                 ;378
00016c  ed8a0a00          VSTR     s0,[r10,#0]           ;411
000170  dba6              BLT      |L474.192|
                  |L474.370|
000172  2100              MOVS     r1,#0                 ;416
000174  2d00              CMP      r5,#0                 ;416
000176  dd2d              BLE      |L474.468|
                  |L474.376|
000178  68a2              LDR      r2,[r4,#8]            ;416
00017a  6920              LDR      r0,[r4,#0x10]         ;416
00017c  fb010c02          MLA      r12,r1,r2,r0          ;416
000180  2200              MOVS     r2,#0                 ;420
000182  2f00              CMP      r7,#0                 ;420
000184  bfc8              IT       GT                    ;430
000186  eb0c0981          ADDGT    r9,r12,r1,LSL #2      ;430
00018a  dd20              BLE      |L474.462|
                  |L474.396|
00018c  68b3              LDR      r3,[r6,#8]            ;420
00018e  6930              LDR      r0,[r6,#0x10]         ;420
000190  fb020303          MLA      r3,r2,r3,r0           ;420
000194  eb030881          ADD      r8,r3,r1,LSL #2       ;423
000198  2000              MOVS     r0,#0                 ;424
00019a  ed980a00          VLDR     s0,[r8,#0]            ;423
00019e  2900              CMP      r1,#0                 ;424
0001a0  dd0c              BLE      |L474.444|
                  |L474.418|
0001a2  eb0c0a80          ADD      r10,r12,r0,LSL #2     ;425
0001a6  ed9a1a00          VLDR     s2,[r10,#0]           ;425
0001aa  eb030a80          ADD      r10,r3,r0,LSL #2      ;426
0001ae  1c40              ADDS     r0,r0,#1              ;424
0001b0  edda0a00          VLDR     s1,[r10,#0]           ;426
0001b4  4281              CMP      r1,r0                 ;424
0001b6  ee010a60          VMLS.F32 s0,s2,s1              ;427
0001ba  dcf2              BGT      |L474.418|
                  |L474.444|
0001bc  edd90a00          VLDR     s1,[r9,#0]            ;430
0001c0  1c52              ADDS     r2,r2,#1              ;420
0001c2  42ba              CMP      r2,r7                 ;420
0001c4  ee200a80          VMUL.F32 s0,s1,s0              ;430
0001c8  ed880a00          VSTR     s0,[r8,#0]            ;430
0001cc  dbde              BLT      |L474.396|
                  |L474.462|
0001ce  1c49              ADDS     r1,r1,#1              ;416
0001d0  42a9              CMP      r1,r5                 ;416
0001d2  dbd1              BLT      |L474.376|
                  |L474.468|
0001d4  1e69              SUBS     r1,r5,#1              ;435
0001d6  d433              BMI      |L474.576|
                  |L474.472|
0001d8  68a2              LDR      r2,[r4,#8]            ;435
0001da  6920              LDR      r0,[r4,#0x10]         ;435
0001dc  fb010002          MLA      r0,r1,r2,r0           ;435
0001e0  2200              MOVS     r2,#0                 ;439
0001e2  2f00              CMP      r7,#0                 ;439
0001e4  bfc8              IT       GT                    ;449
0001e6  eb000a81          ADDGT    r10,r0,r1,LSL #2      ;449
0001ea  dd27              BLE      |L474.572|
                  |L474.492|
0001ec  68b3              LDR      r3,[r6,#8]            ;439
0001ee  6930              LDR      r0,[r6,#0x10]         ;439
0001f0  fb020303          MLA      r3,r2,r3,r0           ;439
0001f4  eb030981          ADD      r9,r3,r1,LSL #2       ;442
0001f8  1e68              SUBS     r0,r5,#1              ;443
0001fa  ed990a00          VLDR     s0,[r9,#0]            ;442
0001fe  4288              CMP      r0,r1                 ;443
000200  bfc4              ITT      GT                    ;443
000202  f8d4c010          LDRGT    r12,[r4,#0x10]        ;443
000206  f8d48008          LDRGT    r8,[r4,#8]            ;443
00020a  dd0e              BLE      |L474.554|
                  |L474.524|
00020c  fb00cb08          MLA      r11,r0,r8,r12         ;443
000210  eb0b0b81          ADD      r11,r11,r1,LSL #2     ;444
000214  ed9b1a00          VLDR     s2,[r11,#0]           ;444
000218  eb030b80          ADD      r11,r3,r0,LSL #2      ;445
00021c  1e40              SUBS     r0,r0,#1              ;443
00021e  eddb0a00          VLDR     s1,[r11,#0]           ;445
000222  4288              CMP      r0,r1                 ;443
000224  ee010a60          VMLS.F32 s0,s2,s1              ;446
000228  dcf0              BGT      |L474.524|
                  |L474.554|
00022a  edda0a00          VLDR     s1,[r10,#0]           ;449
00022e  1c52              ADDS     r2,r2,#1              ;439
000230  4297              CMP      r7,r2                 ;439
000232  ee200a80          VMUL.F32 s0,s1,s0              ;449
000236  ed890a00          VSTR     s0,[r9,#0]            ;449
00023a  dcd7              BGT      |L474.492|
                  |L474.572|
00023c  1e49              SUBS     r1,r1,#1              ;435
00023e  d5cb              BPL      |L474.472|
                  |L474.576|
000240  9807              LDR      r0,[sp,#0x1c]         ;453
000242  2800              CMP      r0,#0                 ;453
000244  bf1c              ITT      NE                    ;455
000246  2100              MOVNE    r1,#0                 ;455
000248  2d00              CMPNE    r5,#0                 ;455
00024a  bfc8              IT       GT                    ;461
00024c  ed9f0a35          VLDRGT   s0,|L474.804|
000250  dd18              BLE      |L474.644|
                  |L474.594|
000252  68a2              LDR      r2,[r4,#8]            ;453
000254  6920              LDR      r0,[r4,#0x10]         ;453
000256  fb010202          MLA      r2,r1,r2,r0           ;453
00025a  eb020081          ADD      r0,r2,r1,LSL #2       ;458
00025e  edd00a00          VLDR     s1,[r0,#0]            ;458
000262  ee881a20          VDIV.F32 s2,s16,s1             ;458
000266  ed801a00          VSTR     s2,[r0,#0]            ;458
00026a  1c48              ADDS     r0,r1,#1              ;460
00026c  4285              CMP      r5,r0                 ;460
00026e  dd06              BLE      |L474.638|
                  |L474.624|
000270  eb020380          ADD      r3,r2,r0,LSL #2       ;461
000274  1c40              ADDS     r0,r0,#1              ;460
000276  ed830a00          VSTR     s0,[r3,#0]            ;461
00027a  4285              CMP      r5,r0                 ;460
00027c  dcf8              BGT      |L474.624|
                  |L474.638|
00027e  1c49              ADDS     r1,r1,#1              ;455
000280  42a9              CMP      r1,r5                 ;455
000282  dbe6              BLT      |L474.594|
                  |L474.644|
000284  2000              MOVS     r0,#0                 ;466
000286  e6ed              B        |L474.100|
;;;468    
                          ENDP

                  |L474.648|
                          DCD      _ZZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)::__PRETTY_FUNCTION__
                  |L474.652|
00028c  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000290  6f726574
000294  6563685c
000298  636f6d6d
00029c  6f6e5c69
0002a0  6e636c75
0002a4  64655c61
0002a8  6e6b692f
0002ac  636f6d6d
0002b0  6f6e2f72
0002b4  6f626f74
0002b8  2f6d6174
0002bc  726978  
0002bf  2e6800            DCB      ".h",0
0002c2  00                DCB      0
0002c3  00                DCB      0
                  |L474.708|
0002c4  415f4c20          DCB      "A_L is not square",0
0002c8  6973206e
0002cc  6f742073
0002d0  71756172
0002d4  6500    
0002d6  00                DCB      0
0002d7  00                DCB      0
                  |L474.728|
0002d8  43686f6c          DCB      "CholeskyDecomposition",0
0002dc  65736b79
0002e0  4465636f
0002e4  6d706f73
0002e8  6974696f
0002ec  6e00    
0002ee  00                DCB      0
0002ef  00                DCB      0
                  |L474.752|
0002f0  496e7661          DCB      "Invalid objects",0
0002f4  6c696420
0002f8  6f626a65
0002fc  63747300
                  |L474.768|
000300  58742061          DCB      "Xt and Bt are the wrong sizes",0
000304  6e642042
000308  74206172
00030c  65207468
000310  65207772
000314  6f6e6720
000318  73697a65
00031c  7300    
00031e  00                DCB      0
00031f  00                DCB      0
                  |L474.800|
000320  34000000          DCFS     0x34000000 ; 1.1920928955078125e-07
                  |L474.804|
000324  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.475||, COMGROUP=_ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb, LINKORDER=||t._ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.475||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRb||
                          DCD      0x00000001

                          AREA ||.constdata__ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
00001c  696e6561          DCB      0x69,0x6e,0x65,0x61
000020  72536571          DCB      0x72,0x53,0x65,0x71
000024  75656e63          DCB      0x75,0x65,0x6e,0x63
000028  653c5479          DCB      0x65,0x3c,0x54,0x79
00002c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000030  3a636f6d          DCB      0x3a,0x63,0x6f,0x6d
000034  70757465          DCB      0x70,0x75,0x74,0x65
000038  53697a65          DCB      0x53,0x69,0x7a,0x65
00003c  28547970          DCB      0x28,0x54,0x79,0x70
000040  652c2054          DCB      0x65,0x2c,0x20,0x54
000044  7970652c          DCB      0x79,0x70,0x65,0x2c
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  6529205b          DCB      0x65,0x29,0x20,0x5b
000050  77697468          DCB      0x77,0x69,0x74,0x68
000054  20547970          DCB      0x20,0x54,0x79,0x70
000058  65203d20          DCB      0x65,0x20,0x3d,0x20
00005c  7369676e          DCB      0x73,0x69,0x67,0x6e
000060  65642069          DCB      0x65,0x64,0x20,0x69
000064  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded25ArraySliceLimits_in1_out1IiEC1ERKNS0_14LinearSequenceIiEES6_bS6_S6_E19__PRETTY_FUNCTION__ ; Anki::Embedded::ArraySliceLimits_in1_out1<int>::ArraySliceLimits_in1_out1(const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&, bool, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  79536c69          DCB      0x79,0x53,0x6c,0x69
000018  63654c69          DCB      0x63,0x65,0x4c,0x69
00001c  6d697473          DCB      0x6d,0x69,0x74,0x73
000020  5f696e31          DCB      0x5f,0x69,0x6e,0x31
000024  5f6f7574          DCB      0x5f,0x6f,0x75,0x74
000028  313c5479          DCB      0x31,0x3c,0x54,0x79
00002c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000030  3a417272          DCB      0x3a,0x41,0x72,0x72
000034  6179536c          DCB      0x61,0x79,0x53,0x6c
000038  6963654c          DCB      0x69,0x63,0x65,0x4c
00003c  696d6974          DCB      0x69,0x6d,0x69,0x74
000040  735f696e          DCB      0x73,0x5f,0x69,0x6e
000044  315f6f75          DCB      0x31,0x5f,0x6f,0x75
000048  74312863          DCB      0x74,0x31,0x28,0x63
00004c  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000050  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000054  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000058  6d626564          DCB      0x6d,0x62,0x65,0x64
00005c  6465643a          DCB      0x64,0x65,0x64,0x3a
000060  3a4c696e          DCB      0x3a,0x4c,0x69,0x6e
000064  65617253          DCB      0x65,0x61,0x72,0x53
000068  65717565          DCB      0x65,0x71,0x75,0x65
00006c  6e63653c          DCB      0x6e,0x63,0x65,0x3c
000070  54797065          DCB      0x54,0x79,0x70,0x65
000074  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000078  20636f6e          DCB      0x20,0x63,0x6f,0x6e
00007c  73742041          DCB      0x73,0x74,0x20,0x41
000080  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000084  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000088  65646465          DCB      0x65,0x64,0x64,0x65
00008c  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
000090  696e6561          DCB      0x69,0x6e,0x65,0x61
000094  72536571          DCB      0x72,0x53,0x65,0x71
000098  75656e63          DCB      0x75,0x65,0x6e,0x63
00009c  653c5479          DCB      0x65,0x3c,0x54,0x79
0000a0  70653e20          DCB      0x70,0x65,0x3e,0x20
0000a4  262c2062          DCB      0x26,0x2c,0x20,0x62
0000a8  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
0000ac  20636f6e          DCB      0x20,0x63,0x6f,0x6e
0000b0  73742041          DCB      0x73,0x74,0x20,0x41
0000b4  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000b8  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000bc  65646465          DCB      0x65,0x64,0x64,0x65
0000c0  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
0000c4  696e6561          DCB      0x69,0x6e,0x65,0x61
0000c8  72536571          DCB      0x72,0x53,0x65,0x71
0000cc  75656e63          DCB      0x75,0x65,0x6e,0x63
0000d0  653c5479          DCB      0x65,0x3c,0x54,0x79
0000d4  70653e20          DCB      0x70,0x65,0x3e,0x20
0000d8  262c2063          DCB      0x26,0x2c,0x20,0x63
0000dc  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
0000e0  20416e6b          DCB      0x20,0x41,0x6e,0x6b
0000e4  693a3a45          DCB      0x69,0x3a,0x3a,0x45
0000e8  6d626564          DCB      0x6d,0x62,0x65,0x64
0000ec  6465643a          DCB      0x64,0x65,0x64,0x3a
0000f0  3a4c696e          DCB      0x3a,0x4c,0x69,0x6e
0000f4  65617253          DCB      0x65,0x61,0x72,0x53
0000f8  65717565          DCB      0x65,0x71,0x75,0x65
0000fc  6e63653c          DCB      0x6e,0x63,0x65,0x3c
000100  54797065          DCB      0x54,0x79,0x70,0x65
000104  3e202629          DCB      0x3e,0x20,0x26,0x29
000108  205b7769          DCB      0x20,0x5b,0x77,0x69
00010c  74682054          DCB      0x74,0x68,0x20,0x54
000110  79706520          DCB      0x79,0x70,0x65,0x20
000114  3d207369          DCB      0x3d,0x20,0x73,0x69
000118  676e6564          DCB      0x67,0x6e,0x65,0x64
00011c  20696e74          DCB      0x20,0x69,0x6e,0x74
000120  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d207369          DCB      0x3d,0x20,0x73,0x69
000088  676e6564          DCB      0x67,0x6e,0x65,0x64
00008c  20696e74          DCB      0x20,0x69,0x6e,0x74
000090  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  7369676e          DCB      0x73,0x69,0x67,0x6e
0000bc  65642069          DCB      0x65,0x64,0x20,0x69
0000c0  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2073          DCB      0x20,0x3d,0x20,0x73
000094  69676e65          DCB      0x69,0x67,0x6e,0x65
000098  6420696e          DCB      0x64,0x20,0x69,0x6e
00009c  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000088  6f61745d          DCB      0x6f,0x61,0x74,0x5d
00008c  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::SetZero()::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  5365745a          DCB      0x53,0x65,0x74,0x5a
00002c  65726f28          DCB      0x65,0x72,0x6f,0x28
000030  29205b77          DCB      0x29,0x20,0x5b,0x77
000034  69746820          DCB      0x69,0x74,0x68,0x20
000038  54797065          DCB      0x54,0x79,0x70,0x65
00003c  203d2066          DCB      0x20,0x3d,0x20,0x66
000040  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000044  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000054  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000bc  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2066          DCB      0x20,0x3d,0x20,0x66
000094  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000098  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE7SetCastIfEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE7SetCastIfEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE7SetCastIfEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::SetCast<float>(const Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  53657443          DCB      0x53,0x65,0x74,0x43
00002c  61737428          DCB      0x61,0x73,0x74,0x28
000030  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000034  7420416e          DCB      0x74,0x20,0x41,0x6e
000038  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00003c  456d6265          DCB      0x45,0x6d,0x62,0x65
000040  64646564          DCB      0x64,0x64,0x65,0x64
000044  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000048  7261793c          DCB      0x72,0x61,0x79,0x3c
00004c  496e5479          DCB      0x49,0x6e,0x54,0x79
000050  70653e20          DCB      0x70,0x65,0x3e,0x20
000054  2629205b          DCB      0x26,0x29,0x20,0x5b
000058  77697468          DCB      0x77,0x69,0x74,0x68
00005c  20496e54          DCB      0x20,0x49,0x6e,0x54
000060  79706520          DCB      0x79,0x70,0x65,0x20
000064  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000068  6f61742c          DCB      0x6f,0x61,0x74,0x2c
00006c  20547970          DCB      0x20,0x54,0x79,0x70
000070  65203d20          DCB      0x65,0x20,0x3d,0x20
000074  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000078  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded16SerializedBuffer17SerializeRawArrayIfEENS_6ResultEPKcRKNS0_5ArrayIT_EEPPvRiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded16SerializedBuffer17SerializeRawArrayIfEENS_6ResultEPKcRKNS0_5ArrayIT_EEPPvRiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded16SerializedBuffer17SerializeRawArrayIfEENS_6ResultEPKcRKNS0_5ArrayIT_EEPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::SerializeRawArray<float>(const char*, const Anki::Embedded::Array<T1>&, void**, int&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a536572          DCB      0x3a,0x53,0x65,0x72
000020  69616c69          DCB      0x69,0x61,0x6c,0x69
000024  7a656442          DCB      0x7a,0x65,0x64,0x42
000028  75666665          DCB      0x75,0x66,0x66,0x65
00002c  723a3a53          DCB      0x72,0x3a,0x3a,0x53
000030  65726961          DCB      0x65,0x72,0x69,0x61
000034  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000038  52617741          DCB      0x52,0x61,0x77,0x41
00003c  72726179          DCB      0x72,0x72,0x61,0x79
000040  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000044  73742063          DCB      0x73,0x74,0x20,0x63
000048  68617220          DCB      0x68,0x61,0x72,0x20
00004c  2a2c2063          DCB      0x2a,0x2c,0x20,0x63
000050  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000054  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000058  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00005c  6d626564          DCB      0x6d,0x62,0x65,0x64
000060  6465643a          DCB      0x64,0x65,0x64,0x3a
000064  3a417272          DCB      0x3a,0x41,0x72,0x72
000068  61793c54          DCB      0x61,0x79,0x3c,0x54
00006c  7970653e          DCB      0x79,0x70,0x65,0x3e
000070  20262c20          DCB      0x20,0x26,0x2c,0x20
000074  766f6964          DCB      0x76,0x6f,0x69,0x64
000078  202a2a2c          DCB      0x20,0x2a,0x2a,0x2c
00007c  20736967          DCB      0x20,0x73,0x69,0x67
000080  6e656420          DCB      0x6e,0x65,0x64,0x20
000084  696e7420          DCB      0x69,0x6e,0x74,0x20
000088  2629205b          DCB      0x26,0x29,0x20,0x5b
00008c  77697468          DCB      0x77,0x69,0x74,0x68
000090  20547970          DCB      0x20,0x54,0x79,0x70
000094  65203d20          DCB      0x65,0x20,0x3d,0x20
000098  666c6f61          DCB      0x66,0x6c,0x6f,0x61
00009c  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIbEET_PcPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<bool>(char*, void**, int&)::__PRETTY_FUNCTION__
000000  54797065          DCB      0x54,0x79,0x70,0x65
000004  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000008  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00000c  6d626564          DCB      0x6d,0x62,0x65,0x64
000010  6465643a          DCB      0x64,0x65,0x64,0x3a
000014  3a536572          DCB      0x3a,0x53,0x65,0x72
000018  69616c69          DCB      0x69,0x61,0x6c,0x69
00001c  7a656442          DCB      0x7a,0x65,0x64,0x42
000020  75666665          DCB      0x75,0x66,0x66,0x65
000024  723a3a44          DCB      0x72,0x3a,0x3a,0x44
000028  65736572          DCB      0x65,0x73,0x65,0x72
00002c  69616c69          DCB      0x69,0x61,0x6c,0x69
000030  7a655261          DCB      0x7a,0x65,0x52,0x61
000034  77426173          DCB      0x77,0x42,0x61,0x73
000038  69635479          DCB      0x69,0x63,0x54,0x79
00003c  70652863          DCB      0x70,0x65,0x28,0x63
000040  68617220          DCB      0x68,0x61,0x72,0x20
000044  2a2c2076          DCB      0x2a,0x2c,0x20,0x76
000048  6f696420          DCB      0x6f,0x69,0x64,0x20
00004c  2a2a2c20          DCB      0x2a,0x2a,0x2c,0x20
000050  7369676e          DCB      0x73,0x69,0x67,0x6e
000054  65642069          DCB      0x65,0x64,0x20,0x69
000058  6e742026          DCB      0x6e,0x74,0x20,0x26
00005c  29205b77          DCB      0x29,0x20,0x5b,0x77
000060  69746820          DCB      0x69,0x74,0x68,0x20
000064  54797065          DCB      0x54,0x79,0x70,0x65
000068  203d2062          DCB      0x20,0x3d,0x20,0x62
00006c  6f6f6c5d          DCB      0x6f,0x6f,0x6c,0x5d
000070  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeIiEET_PcPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<int>(char*, void**, int&)::__PRETTY_FUNCTION__
000000  54797065          DCB      0x54,0x79,0x70,0x65
000004  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000008  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00000c  6d626564          DCB      0x6d,0x62,0x65,0x64
000010  6465643a          DCB      0x64,0x65,0x64,0x3a
000014  3a536572          DCB      0x3a,0x53,0x65,0x72
000018  69616c69          DCB      0x69,0x61,0x6c,0x69
00001c  7a656442          DCB      0x7a,0x65,0x64,0x42
000020  75666665          DCB      0x75,0x66,0x66,0x65
000024  723a3a44          DCB      0x72,0x3a,0x3a,0x44
000028  65736572          DCB      0x65,0x73,0x65,0x72
00002c  69616c69          DCB      0x69,0x61,0x6c,0x69
000030  7a655261          DCB      0x7a,0x65,0x52,0x61
000034  77426173          DCB      0x77,0x42,0x61,0x73
000038  69635479          DCB      0x69,0x63,0x54,0x79
00003c  70652863          DCB      0x70,0x65,0x28,0x63
000040  68617220          DCB      0x68,0x61,0x72,0x20
000044  2a2c2076          DCB      0x2a,0x2c,0x20,0x76
000048  6f696420          DCB      0x6f,0x69,0x64,0x20
00004c  2a2a2c20          DCB      0x2a,0x2a,0x2c,0x20
000050  7369676e          DCB      0x73,0x69,0x67,0x6e
000054  65642069          DCB      0x65,0x64,0x20,0x69
000058  6e742026          DCB      0x6e,0x74,0x20,0x26
00005c  29205b77          DCB      0x29,0x20,0x5b,0x77
000060  69746820          DCB      0x69,0x74,0x68,0x20
000064  54797065          DCB      0x54,0x79,0x70,0x65
000068  203d2073          DCB      0x20,0x3d,0x20,0x73
00006c  69676e65          DCB      0x69,0x67,0x6e,0x65
000070  6420696e          DCB      0x64,0x20,0x69,0x6e
000074  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded16SerializedBuffer19DeserializeRawArrayIfEENS0_5ArrayIT_EEPcPPvRiRNS0_11MemoryStackEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded16SerializedBuffer19DeserializeRawArrayIfEENS0_5ArrayIT_EEPcPPvRiRNS0_11MemoryStackEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded16SerializedBuffer19DeserializeRawArrayIfEENS0_5ArrayIT_EEPcPPvRiRNS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawArray<float>(char*, void**, int&, Anki::Embedded::MemoryStack&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e20          DCB      0x70,0x65,0x3e,0x20
00001c  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000020  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000024  62656464          DCB      0x62,0x65,0x64,0x64
000028  65643a3a          DCB      0x65,0x64,0x3a,0x3a
00002c  53657269          DCB      0x53,0x65,0x72,0x69
000030  616c697a          DCB      0x61,0x6c,0x69,0x7a
000034  65644275          DCB      0x65,0x64,0x42,0x75
000038  66666572          DCB      0x66,0x66,0x65,0x72
00003c  3a3a4465          DCB      0x3a,0x3a,0x44,0x65
000040  73657269          DCB      0x73,0x65,0x72,0x69
000044  616c697a          DCB      0x61,0x6c,0x69,0x7a
000048  65526177          DCB      0x65,0x52,0x61,0x77
00004c  41727261          DCB      0x41,0x72,0x72,0x61
000050  79286368          DCB      0x79,0x28,0x63,0x68
000054  6172202a          DCB      0x61,0x72,0x20,0x2a
000058  2c20766f          DCB      0x2c,0x20,0x76,0x6f
00005c  6964202a          DCB      0x69,0x64,0x20,0x2a
000060  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
000064  69676e65          DCB      0x69,0x67,0x6e,0x65
000068  6420696e          DCB      0x64,0x20,0x69,0x6e
00006c  7420262c          DCB      0x74,0x20,0x26,0x2c
000070  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000074  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000078  6d626564          DCB      0x6d,0x62,0x65,0x64
00007c  6465643a          DCB      0x64,0x65,0x64,0x3a
000080  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
000084  6f727953          DCB      0x6f,0x72,0x79,0x53
000088  7461636b          DCB      0x74,0x61,0x63,0x6b
00008c  20262920          DCB      0x20,0x26,0x29,0x20
000090  5b776974          DCB      0x5b,0x77,0x69,0x74
000094  68205479          DCB      0x68,0x20,0x54,0x79
000098  7065203d          DCB      0x70,0x65,0x20,0x3d
00009c  20666c6f          DCB      0x20,0x66,0x6c,0x6f
0000a0  61745d00          DCB      0x61,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeINS0_13QuadrilateralIfEEEET_PcPPvRiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeINS0_13QuadrilateralIfEEEET_PcPPvRiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeINS0_13QuadrilateralIfEEEET_PcPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<Anki::Embedded::Quadrilateral<float>>(char*, void**, int&)::__PRETTY_FUNCTION__
000000  54797065          DCB      0x54,0x79,0x70,0x65
000004  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000008  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00000c  6d626564          DCB      0x6d,0x62,0x65,0x64
000010  6465643a          DCB      0x64,0x65,0x64,0x3a
000014  3a536572          DCB      0x3a,0x53,0x65,0x72
000018  69616c69          DCB      0x69,0x61,0x6c,0x69
00001c  7a656442          DCB      0x7a,0x65,0x64,0x42
000020  75666665          DCB      0x75,0x66,0x66,0x65
000024  723a3a44          DCB      0x72,0x3a,0x3a,0x44
000028  65736572          DCB      0x65,0x73,0x65,0x72
00002c  69616c69          DCB      0x69,0x61,0x6c,0x69
000030  7a655261          DCB      0x7a,0x65,0x52,0x61
000034  77426173          DCB      0x77,0x42,0x61,0x73
000038  69635479          DCB      0x69,0x63,0x54,0x79
00003c  70652863          DCB      0x70,0x65,0x28,0x63
000040  68617220          DCB      0x68,0x61,0x72,0x20
000044  2a2c2076          DCB      0x2a,0x2c,0x20,0x76
000048  6f696420          DCB      0x6f,0x69,0x64,0x20
00004c  2a2a2c20          DCB      0x2a,0x2a,0x2c,0x20
000050  7369676e          DCB      0x73,0x69,0x67,0x6e
000054  65642069          DCB      0x65,0x64,0x20,0x69
000058  6e742026          DCB      0x6e,0x74,0x20,0x26
00005c  29205b77          DCB      0x29,0x20,0x5b,0x77
000060  69746820          DCB      0x69,0x74,0x68,0x20
000064  54797065          DCB      0x54,0x79,0x70,0x65
000068  203d2041          DCB      0x20,0x3d,0x20,0x41
00006c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000070  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000074  65646465          DCB      0x65,0x64,0x64,0x65
000078  643a3a51          DCB      0x64,0x3a,0x3a,0x51
00007c  75616472          DCB      0x75,0x61,0x64,0x72
000080  696c6174          DCB      0x69,0x6c,0x61,0x74
000084  6572616c          DCB      0x65,0x72,0x61,0x6c
000088  3c666c6f          DCB      0x3c,0x66,0x6c,0x6f
00008c  61743e5d          DCB      0x61,0x74,0x3e,0x5d
000090  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeINS0_5PointIfEEEET_PcPPvRiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeINS0_5PointIfEEEET_PcPPvRiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded16SerializedBuffer23DeserializeRawBasicTypeINS0_5PointIfEEEET_PcPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::DeserializeRawBasicType<Anki::Embedded::Point<float>>(char*, void**, int&)::__PRETTY_FUNCTION__
000000  54797065          DCB      0x54,0x79,0x70,0x65
000004  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000008  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00000c  6d626564          DCB      0x6d,0x62,0x65,0x64
000010  6465643a          DCB      0x64,0x65,0x64,0x3a
000014  3a536572          DCB      0x3a,0x53,0x65,0x72
000018  69616c69          DCB      0x69,0x61,0x6c,0x69
00001c  7a656442          DCB      0x7a,0x65,0x64,0x42
000020  75666665          DCB      0x75,0x66,0x66,0x65
000024  723a3a44          DCB      0x72,0x3a,0x3a,0x44
000028  65736572          DCB      0x65,0x73,0x65,0x72
00002c  69616c69          DCB      0x69,0x61,0x6c,0x69
000030  7a655261          DCB      0x7a,0x65,0x52,0x61
000034  77426173          DCB      0x77,0x42,0x61,0x73
000038  69635479          DCB      0x69,0x63,0x54,0x79
00003c  70652863          DCB      0x70,0x65,0x28,0x63
000040  68617220          DCB      0x68,0x61,0x72,0x20
000044  2a2c2076          DCB      0x2a,0x2c,0x20,0x76
000048  6f696420          DCB      0x6f,0x69,0x64,0x20
00004c  2a2a2c20          DCB      0x2a,0x2a,0x2c,0x20
000050  7369676e          DCB      0x73,0x69,0x67,0x6e
000054  65642069          DCB      0x65,0x64,0x20,0x69
000058  6e742026          DCB      0x6e,0x74,0x20,0x26
00005c  29205b77          DCB      0x29,0x20,0x5b,0x77
000060  69746820          DCB      0x69,0x74,0x68,0x20
000064  54797065          DCB      0x54,0x79,0x70,0x65
000068  203d2041          DCB      0x20,0x3d,0x20,0x41
00006c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000070  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000074  65646465          DCB      0x65,0x64,0x64,0x65
000078  643a3a50          DCB      0x64,0x3a,0x3a,0x50
00007c  6f696e74          DCB      0x6f,0x69,0x6e,0x74
000080  3c666c6f          DCB      0x3c,0x66,0x6c,0x6f
000084  61743e5d          DCB      0x61,0x74,0x3e,0x5d
000088  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded16SerializedBuffer12EncodedArray9SerializeIfEENS_6ResultEbRKNS0_5ArrayIT_EEPPvRiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded16SerializedBuffer12EncodedArray9SerializeIfEENS_6ResultEbRKNS0_5ArrayIT_EEPPvRiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded16SerializedBuffer12EncodedArray9SerializeIfEENS_6ResultEbRKNS0_5ArrayIT_EEPPvRiE19__PRETTY_FUNCTION__ ; Anki::Embedded::SerializedBuffer::EncodedArray::Serialize<float>(bool, const Anki::Embedded::Array<T1>&, void**, int&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a536572          DCB      0x3a,0x53,0x65,0x72
000020  69616c69          DCB      0x69,0x61,0x6c,0x69
000024  7a656442          DCB      0x7a,0x65,0x64,0x42
000028  75666665          DCB      0x75,0x66,0x66,0x65
00002c  723a3a45          DCB      0x72,0x3a,0x3a,0x45
000030  6e636f64          DCB      0x6e,0x63,0x6f,0x64
000034  65644172          DCB      0x65,0x64,0x41,0x72
000038  7261793a          DCB      0x72,0x61,0x79,0x3a
00003c  3a536572          DCB      0x3a,0x53,0x65,0x72
000040  69616c69          DCB      0x69,0x61,0x6c,0x69
000044  7a652862          DCB      0x7a,0x65,0x28,0x62
000048  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
00004c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000050  73742041          DCB      0x73,0x74,0x20,0x41
000054  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000058  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00005c  65646465          DCB      0x65,0x64,0x64,0x65
000060  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000064  72726179          DCB      0x72,0x72,0x61,0x79
000068  3c547970          DCB      0x3c,0x54,0x79,0x70
00006c  653e2026          DCB      0x65,0x3e,0x20,0x26
000070  2c20766f          DCB      0x2c,0x20,0x76,0x6f
000074  6964202a          DCB      0x69,0x64,0x20,0x2a
000078  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00007c  69676e65          DCB      0x69,0x67,0x6e,0x65
000080  6420696e          DCB      0x64,0x20,0x69,0x6e
000084  74202629          DCB      0x74,0x20,0x26,0x29
000088  205b7769          DCB      0x20,0x5b,0x77,0x69
00008c  74682054          DCB      0x74,0x68,0x20,0x54
000090  79706520          DCB      0x79,0x70,0x65,0x20
000094  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000098  6f61745d          DCB      0x6f,0x61,0x74,0x5d
00009c  00                DCB      0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  756e7369          DCB      0x75,0x6e,0x73,0x69
000054  676e6564          DCB      0x67,0x6e,0x65,0x64
000058  20636861          DCB      0x20,0x63,0x68,0x61
00005c  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_5PointIfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a506f          DCB      0x3a,0x3a,0x50,0x6f
000098  696e743c          DCB      0x69,0x6e,0x74,0x3c
00009c  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000a0  743e5d00          DCB      0x74,0x3e,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  506f696e          DCB      0x50,0x6f,0x69,0x6e
0000cc  743c666c          DCB      0x74,0x3c,0x66,0x6c
0000d0  6f61743e          DCB      0x6f,0x61,0x74,0x3e
0000d4  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_5PointIfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Point<float>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a50          DCB      0x64,0x3a,0x3a,0x50
0000a4  6f696e74          DCB      0x6f,0x69,0x6e,0x74
0000a8  3c666c6f          DCB      0x3c,0x66,0x6c,0x6f
0000ac  61743e5d          DCB      0x61,0x74,0x3e,0x5d
0000b0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_9DotDivideIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_9DotDivideIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix11Elementwise14ApplyOperationIfNS2_9DotDivideIfffEEfEENS_6ResultERKNS0_25ConstArraySliceExpressionIT_EES8_NS0_10ArraySliceIT1_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Elementwise::ApplyOperation<float, Anki::Embedded::Matrix::Elementwise::DotDivide<float, float, float>, float>(const Anki::Embedded::ConstArraySliceExpression<T1>&, T1, Anki::Embedded::ArraySlice<T3>)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a456c65          DCB      0x3a,0x45,0x6c,0x65
000028  6d656e74          DCB      0x6d,0x65,0x6e,0x74
00002c  77697365          DCB      0x77,0x69,0x73,0x65
000030  3a3a4170          DCB      0x3a,0x3a,0x41,0x70
000034  706c794f          DCB      0x70,0x6c,0x79,0x4f
000038  70657261          DCB      0x70,0x65,0x72,0x61
00003c  74696f6e          DCB      0x74,0x69,0x6f,0x6e
000040  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000044  73742041          DCB      0x73,0x74,0x20,0x41
000048  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00004c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000050  65646465          DCB      0x65,0x64,0x64,0x65
000054  643a3a43          DCB      0x64,0x3a,0x3a,0x43
000058  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
00005c  41727261          DCB      0x41,0x72,0x72,0x61
000060  79536c69          DCB      0x79,0x53,0x6c,0x69
000064  63654578          DCB      0x63,0x65,0x45,0x78
000068  70726573          DCB      0x70,0x72,0x65,0x73
00006c  73696f6e          DCB      0x73,0x69,0x6f,0x6e
000070  3c547970          DCB      0x3c,0x54,0x79,0x70
000074  653e2026          DCB      0x65,0x3e,0x20,0x26
000078  2c20496e          DCB      0x2c,0x20,0x49,0x6e
00007c  54797065          DCB      0x54,0x79,0x70,0x65
000080  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000084  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000088  456d6265          DCB      0x45,0x6d,0x62,0x65
00008c  64646564          DCB      0x64,0x64,0x65,0x64
000090  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000094  72617953          DCB      0x72,0x61,0x79,0x53
000098  6c696365          DCB      0x6c,0x69,0x63,0x65
00009c  3c4f7574          DCB      0x3c,0x4f,0x75,0x74
0000a0  54797065          DCB      0x54,0x79,0x70,0x65
0000a4  3e29205b          DCB      0x3e,0x29,0x20,0x5b
0000a8  77697468          DCB      0x77,0x69,0x74,0x68
0000ac  20496e54          DCB      0x20,0x49,0x6e,0x54
0000b0  79706520          DCB      0x79,0x70,0x65,0x20
0000b4  3d20666c          DCB      0x3d,0x20,0x66,0x6c
0000b8  6f61742c          DCB      0x6f,0x61,0x74,0x2c
0000bc  204f7065          DCB      0x20,0x4f,0x70,0x65
0000c0  7261746f          DCB      0x72,0x61,0x74,0x6f
0000c4  72203d20          DCB      0x72,0x20,0x3d,0x20
0000c8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000cc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000d0  62656464          DCB      0x62,0x65,0x64,0x64
0000d4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000d8  4d617472          DCB      0x4d,0x61,0x74,0x72
0000dc  69783a3a          DCB      0x69,0x78,0x3a,0x3a
0000e0  456c656d          DCB      0x45,0x6c,0x65,0x6d
0000e4  656e7477          DCB      0x65,0x6e,0x74,0x77
0000e8  6973653a          DCB      0x69,0x73,0x65,0x3a
0000ec  3a446f74          DCB      0x3a,0x44,0x6f,0x74
0000f0  44697669          DCB      0x44,0x69,0x76,0x69
0000f4  64653c66          DCB      0x64,0x65,0x3c,0x66
0000f8  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
0000fc  2c20666c          DCB      0x2c,0x20,0x66,0x6c
000100  6f61742c          DCB      0x6f,0x61,0x74,0x2c
000104  20666c6f          DCB      0x20,0x66,0x6c,0x6f
000108  61743e2c          DCB      0x61,0x74,0x3e,0x2c
00010c  204f7574          DCB      0x20,0x4f,0x75,0x74
000110  54797065          DCB      0x54,0x79,0x70,0x65
000114  203d2066          DCB      0x20,0x3d,0x20,0x66
000118  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
00011c  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a496e73          DCB      0x3a,0x49,0x6e,0x73
000028  65727469          DCB      0x65,0x72,0x74,0x69
00002c  6f6e536f          DCB      0x6f,0x6e,0x53,0x6f
000030  72742841          DCB      0x72,0x74,0x28,0x41
000034  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000038  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00003c  65646465          DCB      0x65,0x64,0x64,0x65
000040  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000044  72726179          DCB      0x72,0x72,0x61,0x79
000048  3c547970          DCB      0x3c,0x54,0x79,0x70
00004c  653e2026          DCB      0x65,0x3e,0x20,0x26
000050  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000054  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000058  456d6265          DCB      0x45,0x6d,0x62,0x65
00005c  64646564          DCB      0x64,0x64,0x65,0x64
000060  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000064  7261793c          DCB      0x72,0x61,0x79,0x3c
000068  7369676e          DCB      0x73,0x69,0x67,0x6e
00006c  65642069          DCB      0x65,0x64,0x20,0x69
000070  6e743e20          DCB      0x6e,0x74,0x3e,0x20
000074  262c2073          DCB      0x26,0x2c,0x20,0x73
000078  69676e65          DCB      0x69,0x67,0x6e,0x65
00007c  6420696e          DCB      0x64,0x20,0x69,0x6e
000080  742c2062          DCB      0x74,0x2c,0x20,0x62
000084  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
000088  20736967          DCB      0x20,0x73,0x69,0x67
00008c  6e656420          DCB      0x6e,0x65,0x64,0x20
000090  696e742c          DCB      0x69,0x6e,0x74,0x2c
000094  20736967          DCB      0x20,0x73,0x69,0x67
000098  6e656420          DCB      0x6e,0x65,0x64,0x20
00009c  696e7429          DCB      0x69,0x6e,0x74,0x29
0000a0  205b7769          DCB      0x20,0x5b,0x77,0x69
0000a4  74682054          DCB      0x74,0x68,0x20,0x54
0000a8  79706520          DCB      0x79,0x70,0x65,0x20
0000ac  3d20666c          DCB      0x3d,0x20,0x66,0x6c
0000b0  6f61745d          DCB      0x6f,0x61,0x74,0x5d
0000b4  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a4d756c          DCB      0x3a,0x4d,0x75,0x6c
000028  7469706c          DCB      0x74,0x69,0x70,0x6c
00002c  7928636f          DCB      0x79,0x28,0x63,0x6f
000030  6e737420          DCB      0x6e,0x73,0x74,0x20
000034  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000038  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00003c  62656464          DCB      0x62,0x65,0x64,0x64
000040  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000044  41727261          DCB      0x41,0x72,0x72,0x61
000048  793c5479          DCB      0x79,0x3c,0x54,0x79
00004c  70653e20          DCB      0x70,0x65,0x3e,0x20
000050  262c2063          DCB      0x26,0x2c,0x20,0x63
000054  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a417272          DCB      0x3a,0x41,0x72,0x72
00006c  61793c54          DCB      0x61,0x79,0x3c,0x54
000070  7970653e          DCB      0x79,0x70,0x65,0x3e
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00007c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000080  62656464          DCB      0x62,0x65,0x64,0x64
000084  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000088  41727261          DCB      0x41,0x72,0x72,0x61
00008c  793c4f75          DCB      0x79,0x3c,0x4f,0x75
000090  74547970          DCB      0x74,0x54,0x79,0x70
000094  653e2026          DCB      0x65,0x3e,0x20,0x26
000098  29205b77          DCB      0x29,0x20,0x5b,0x77
00009c  69746820          DCB      0x69,0x74,0x68,0x20
0000a0  496e5479          DCB      0x49,0x6e,0x54,0x79
0000a4  7065203d          DCB      0x70,0x65,0x20,0x3d
0000a8  20666c6f          DCB      0x20,0x66,0x6c,0x6f
0000ac  61742c20          DCB      0x61,0x74,0x2c,0x20
0000b0  4f757454          DCB      0x4f,0x75,0x74,0x54
0000b4  79706520          DCB      0x79,0x70,0x65,0x20
0000b8  3d20666c          DCB      0x3d,0x20,0x66,0x6c
0000bc  6f61745d          DCB      0x6f,0x61,0x74,0x5d
0000c0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix18EstimateHomographyIfEENS_6ResultERKNS0_15FixedLengthListINS0_5PointIT_EEEESA_RNS0_5ArrayIS6_EERbNS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::EstimateHomography<float>(const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Point<T1>>&, Anki::Embedded::Array<T1>&, bool&, Anki::Embedded::MemoryStack)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a457374          DCB      0x3a,0x45,0x73,0x74
000028  696d6174          DCB      0x69,0x6d,0x61,0x74
00002c  65486f6d          DCB      0x65,0x48,0x6f,0x6d
000030  6f677261          DCB      0x6f,0x67,0x72,0x61
000034  70687928          DCB      0x70,0x68,0x79,0x28
000038  636f6e73          DCB      0x63,0x6f,0x6e,0x73
00003c  7420416e          DCB      0x74,0x20,0x41,0x6e
000040  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000044  456d6265          DCB      0x45,0x6d,0x62,0x65
000048  64646564          DCB      0x64,0x64,0x65,0x64
00004c  3a3a4669          DCB      0x3a,0x3a,0x46,0x69
000050  7865644c          DCB      0x78,0x65,0x64,0x4c
000054  656e6774          DCB      0x65,0x6e,0x67,0x74
000058  684c6973          DCB      0x68,0x4c,0x69,0x73
00005c  743c416e          DCB      0x74,0x3c,0x41,0x6e
000060  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000064  456d6265          DCB      0x45,0x6d,0x62,0x65
000068  64646564          DCB      0x64,0x64,0x65,0x64
00006c  3a3a506f          DCB      0x3a,0x3a,0x50,0x6f
000070  696e743c          DCB      0x69,0x6e,0x74,0x3c
000074  54797065          DCB      0x54,0x79,0x70,0x65
000078  3e3e2026          DCB      0x3e,0x3e,0x20,0x26
00007c  2c20636f          DCB      0x2c,0x20,0x63,0x6f
000080  6e737420          DCB      0x6e,0x73,0x74,0x20
000084  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000088  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00008c  62656464          DCB      0x62,0x65,0x64,0x64
000090  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000094  46697865          DCB      0x46,0x69,0x78,0x65
000098  644c656e          DCB      0x64,0x4c,0x65,0x6e
00009c  6774684c          DCB      0x67,0x74,0x68,0x4c
0000a0  6973743c          DCB      0x69,0x73,0x74,0x3c
0000a4  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000a8  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000ac  62656464          DCB      0x62,0x65,0x64,0x64
0000b0  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000b4  506f696e          DCB      0x50,0x6f,0x69,0x6e
0000b8  743c5479          DCB      0x74,0x3c,0x54,0x79
0000bc  70653e3e          DCB      0x70,0x65,0x3e,0x3e
0000c0  20262c20          DCB      0x20,0x26,0x2c,0x20
0000c4  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000c8  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000cc  62656464          DCB      0x62,0x65,0x64,0x64
0000d0  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000d4  41727261          DCB      0x41,0x72,0x72,0x61
0000d8  793c5479          DCB      0x79,0x3c,0x54,0x79
0000dc  70653e20          DCB      0x70,0x65,0x3e,0x20
0000e0  262c2062          DCB      0x26,0x2c,0x20,0x62
0000e4  6f6f6c20          DCB      0x6f,0x6f,0x6c,0x20
0000e8  262c2041          DCB      0x26,0x2c,0x20,0x41
0000ec  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
0000f0  3a456d62          DCB      0x3a,0x45,0x6d,0x62
0000f4  65646465          DCB      0x65,0x64,0x64,0x65
0000f8  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
0000fc  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000100  79537461          DCB      0x79,0x53,0x74,0x61
000104  636b2920          DCB      0x63,0x6b,0x29,0x20
000108  5b776974          DCB      0x5b,0x77,0x69,0x74
00010c  68205479          DCB      0x68,0x20,0x54,0x79
000110  7065203d          DCB      0x70,0x65,0x20,0x3d
000114  20666c6f          DCB      0x20,0x66,0x6c,0x6f
000118  61745d00          DCB      0x61,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix9TransposeIffEENS_6ResultERKNS0_5ArrayIT_EERNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Transpose<float, float>(const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a547261          DCB      0x3a,0x54,0x72,0x61
000028  6e73706f          DCB      0x6e,0x73,0x70,0x6f
00002c  73652863          DCB      0x73,0x65,0x28,0x63
000030  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000034  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000038  693a3a45          DCB      0x69,0x3a,0x3a,0x45
00003c  6d626564          DCB      0x6d,0x62,0x65,0x64
000040  6465643a          DCB      0x64,0x65,0x64,0x3a
000044  3a417272          DCB      0x3a,0x41,0x72,0x72
000048  61793c54          DCB      0x61,0x79,0x3c,0x54
00004c  7970653e          DCB      0x79,0x70,0x65,0x3e
000050  20262c20          DCB      0x20,0x26,0x2c,0x20
000054  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000058  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00005c  62656464          DCB      0x62,0x65,0x64,0x64
000060  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000064  41727261          DCB      0x41,0x72,0x72,0x61
000068  793c4f75          DCB      0x79,0x3c,0x4f,0x75
00006c  74547970          DCB      0x74,0x54,0x79,0x70
000070  653e2026          DCB      0x65,0x3e,0x20,0x26
000074  29205b77          DCB      0x29,0x20,0x5b,0x77
000078  69746820          DCB      0x69,0x74,0x68,0x20
00007c  496e5479          DCB      0x49,0x6e,0x54,0x79
000080  7065203d          DCB      0x70,0x65,0x20,0x3d
000084  20666c6f          DCB      0x20,0x66,0x6c,0x6f
000088  61742c20          DCB      0x61,0x74,0x2c,0x20
00008c  4f757454          DCB      0x4f,0x75,0x74,0x54
000090  79706520          DCB      0x79,0x70,0x65,0x20
000094  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000098  6f61745d          DCB      0x6f,0x61,0x74,0x5d
00009c  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix17MultiplyTransposeIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::MultiplyTranspose<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a4d756c          DCB      0x3a,0x4d,0x75,0x6c
000028  7469706c          DCB      0x74,0x69,0x70,0x6c
00002c  79547261          DCB      0x79,0x54,0x72,0x61
000030  6e73706f          DCB      0x6e,0x73,0x70,0x6f
000034  73652863          DCB      0x73,0x65,0x28,0x63
000038  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
00003c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000040  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000044  6d626564          DCB      0x6d,0x62,0x65,0x64
000048  6465643a          DCB      0x64,0x65,0x64,0x3a
00004c  3a417272          DCB      0x3a,0x41,0x72,0x72
000050  61793c54          DCB      0x61,0x79,0x3c,0x54
000054  7970653e          DCB      0x79,0x70,0x65,0x3e
000058  20262c20          DCB      0x20,0x26,0x2c,0x20
00005c  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000060  7420416e          DCB      0x74,0x20,0x41,0x6e
000064  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000068  456d6265          DCB      0x45,0x6d,0x62,0x65
00006c  64646564          DCB      0x64,0x64,0x65,0x64
000070  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000074  7261793c          DCB      0x72,0x61,0x79,0x3c
000078  54797065          DCB      0x54,0x79,0x70,0x65
00007c  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000080  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000084  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000088  6d626564          DCB      0x6d,0x62,0x65,0x64
00008c  6465643a          DCB      0x64,0x65,0x64,0x3a
000090  3a417272          DCB      0x3a,0x41,0x72,0x72
000094  61793c4f          DCB      0x61,0x79,0x3c,0x4f
000098  75745479          DCB      0x75,0x74,0x54,0x79
00009c  70653e20          DCB      0x70,0x65,0x3e,0x20
0000a0  2629205b          DCB      0x26,0x29,0x20,0x5b
0000a4  77697468          DCB      0x77,0x69,0x74,0x68
0000a8  20496e54          DCB      0x20,0x49,0x6e,0x54
0000ac  79706520          DCB      0x79,0x70,0x65,0x20
0000b0  3d20666c          DCB      0x3d,0x20,0x66,0x6c
0000b4  6f61742c          DCB      0x6f,0x61,0x74,0x2c
0000b8  204f7574          DCB      0x20,0x4f,0x75,0x74
0000bc  54797065          DCB      0x54,0x79,0x70,0x65
0000c0  203d2066          DCB      0x20,0x3d,0x20,0x66
0000c4  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
0000c8  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix29SolveLeastSquaresWithCholeskyIfEENS_6ResultERNS0_5ArrayIT_EES7_bRbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::SolveLeastSquaresWithCholesky<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T1>&, bool, bool&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a536f6c          DCB      0x3a,0x53,0x6f,0x6c
000028  76654c65          DCB      0x76,0x65,0x4c,0x65
00002c  61737453          DCB      0x61,0x73,0x74,0x53
000030  71756172          DCB      0x71,0x75,0x61,0x72
000034  65735769          DCB      0x65,0x73,0x57,0x69
000038  74684368          DCB      0x74,0x68,0x43,0x68
00003c  6f6c6573          DCB      0x6f,0x6c,0x65,0x73
000040  6b792841          DCB      0x6b,0x79,0x28,0x41
000044  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000048  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00004c  65646465          DCB      0x65,0x64,0x64,0x65
000050  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000054  72726179          DCB      0x72,0x72,0x61,0x79
000058  3c547970          DCB      0x3c,0x54,0x79,0x70
00005c  653e2026          DCB      0x65,0x3e,0x20,0x26
000060  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000064  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000068  456d6265          DCB      0x45,0x6d,0x62,0x65
00006c  64646564          DCB      0x64,0x64,0x65,0x64
000070  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000074  7261793c          DCB      0x72,0x61,0x79,0x3c
000078  54797065          DCB      0x54,0x79,0x70,0x65
00007c  3e20262c          DCB      0x3e,0x20,0x26,0x2c
000080  20626f6f          DCB      0x20,0x62,0x6f,0x6f
000084  6c2c2062          DCB      0x6c,0x2c,0x20,0x62
000088  6f6f6c20          DCB      0x6f,0x6f,0x6c,0x20
00008c  2629205b          DCB      0x26,0x29,0x20,0x5b
000090  77697468          DCB      0x77,0x69,0x74,0x68
000094  20547970          DCB      0x20,0x54,0x79,0x70
000098  65203d20          DCB      0x65,0x20,0x3d,0x20
00009c  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000a0  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded7Interp2IhhEENS_6ResultERKNS0_5ArrayIT_EERKNS3_IfEESA_RNS3_IT0_EENS0_17InterpolationTypeESB_E19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded7Interp2IhhEENS_6ResultERKNS0_5ArrayIT_EERKNS3_IfEESA_RNS3_IT0_EENS0_17InterpolationTypeESB_E19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded7Interp2IhhEENS_6ResultERKNS0_5ArrayIT_EERKNS3_IfEESA_RNS3_IT0_EENS0_17InterpolationTypeESB_E19__PRETTY_FUNCTION__ ; Anki::Embedded::Interp2<unsigned char, unsigned char>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<float>&, const Anki::Embedded::Array<float>&, Anki::Embedded::Array<T2>&, Anki::Embedded::InterpolationType, T2)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a496e74          DCB      0x3a,0x49,0x6e,0x74
000020  65727032          DCB      0x65,0x72,0x70,0x32
000024  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000028  73742041          DCB      0x73,0x74,0x20,0x41
00002c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000030  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000034  65646465          DCB      0x65,0x64,0x64,0x65
000038  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00003c  72726179          DCB      0x72,0x72,0x61,0x79
000040  3c547970          DCB      0x3c,0x54,0x79,0x70
000044  653e2026          DCB      0x65,0x3e,0x20,0x26
000048  2c20636f          DCB      0x2c,0x20,0x63,0x6f
00004c  6e737420          DCB      0x6e,0x73,0x74,0x20
000050  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000054  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000058  62656464          DCB      0x62,0x65,0x64,0x64
00005c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000060  41727261          DCB      0x41,0x72,0x72,0x61
000064  793c666c          DCB      0x79,0x3c,0x66,0x6c
000068  6f61743e          DCB      0x6f,0x61,0x74,0x3e
00006c  20262c20          DCB      0x20,0x26,0x2c,0x20
000070  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000074  7420416e          DCB      0x74,0x20,0x41,0x6e
000078  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00007c  456d6265          DCB      0x45,0x6d,0x62,0x65
000080  64646564          DCB      0x64,0x64,0x65,0x64
000084  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000088  7261793c          DCB      0x72,0x61,0x79,0x3c
00008c  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000090  743e2026          DCB      0x74,0x3e,0x20,0x26
000094  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000098  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00009c  456d6265          DCB      0x45,0x6d,0x62,0x65
0000a0  64646564          DCB      0x64,0x64,0x65,0x64
0000a4  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
0000a8  7261793c          DCB      0x72,0x61,0x79,0x3c
0000ac  4f757454          DCB      0x4f,0x75,0x74,0x54
0000b0  7970653e          DCB      0x79,0x70,0x65,0x3e
0000b4  20262c20          DCB      0x20,0x26,0x2c,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  496e7465          DCB      0x49,0x6e,0x74,0x65
0000cc  72706f6c          DCB      0x72,0x70,0x6f,0x6c
0000d0  6174696f          DCB      0x61,0x74,0x69,0x6f
0000d4  6e547970          DCB      0x6e,0x54,0x79,0x70
0000d8  652c204f          DCB      0x65,0x2c,0x20,0x4f
0000dc  75745479          DCB      0x75,0x74,0x54,0x79
0000e0  70652920          DCB      0x70,0x65,0x29,0x20
0000e4  5b776974          DCB      0x5b,0x77,0x69,0x74
0000e8  6820496e          DCB      0x68,0x20,0x49,0x6e
0000ec  54797065          DCB      0x54,0x79,0x70,0x65
0000f0  203d2075          DCB      0x20,0x3d,0x20,0x75
0000f4  6e736967          DCB      0x6e,0x73,0x69,0x67
0000f8  6e656420          DCB      0x6e,0x65,0x64,0x20
0000fc  63686172          DCB      0x63,0x68,0x61,0x72
000100  2c204f75          DCB      0x2c,0x20,0x4f,0x75
000104  74547970          DCB      0x74,0x54,0x79,0x70
000108  65203d20          DCB      0x65,0x20,0x3d,0x20
00010c  756e7369          DCB      0x75,0x6e,0x73,0x69
000110  676e6564          DCB      0x67,0x6e,0x65,0x64
000114  20636861          DCB      0x20,0x63,0x68,0x61
000118  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded3EyeIfEENS_6ResultERNS0_5ArrayIT_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded3EyeIfEENS_6ResultERNS0_5ArrayIT_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded3EyeIfEENS_6ResultERNS0_5ArrayIT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Eye<float>(Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a457965          DCB      0x3a,0x45,0x79,0x65
000020  28416e6b          DCB      0x28,0x41,0x6e,0x6b
000024  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000028  6d626564          DCB      0x6d,0x62,0x65,0x64
00002c  6465643a          DCB      0x64,0x65,0x64,0x3a
000030  3a417272          DCB      0x3a,0x41,0x72,0x72
000034  61793c54          DCB      0x61,0x79,0x3c,0x54
000038  7970653e          DCB      0x79,0x70,0x65,0x3e
00003c  20262920          DCB      0x20,0x26,0x29,0x20
000040  5b776974          DCB      0x5b,0x77,0x69,0x74
000044  68205479          DCB      0x68,0x20,0x54,0x79
000048  7065203d          DCB      0x70,0x65,0x20,0x3d
00004c  20666c6f          DCB      0x20,0x66,0x6c,0x6f
000050  61745d00          DCB      0x61,0x74,0x5d,0x00
