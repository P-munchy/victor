; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\trig_fast.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\trig_fast.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\trig_fast.crf ..\coretech\common\robot\src\trig_fast.cpp]
                          THUMB

                          AREA ||i._Z10atan2_fastff||, CODE, READONLY, ALIGN=2

                  _Z10atan2_fastff PROC ; atan2_fast(float, float)
;;;248    
;;;249    float atan2_fast(float y, float x)
000000  eef50ac0          VCMPE.F32 s1,#0.0
;;;250    {
000004  b500              PUSH     {lr}
;;;251      AnkiAssert( !(y == 0 && x == 0) );
;;;252    
;;;253      if (x>0) {
000006  eef1fa10          VMRS     APSR_nzcv,FPSCR
00000a  dd07              BLE      |L1.28|
;;;254        return atan_fast(y/x);
00000c  ee801a20          VDIV.F32 s2,s0,s1
000010  f85deb04          POP      {lr}
000014  eeb00a41          VMOV.F32 s0,s2
000018  f7ffbffe          B.W      _Z9atan_fastf ; atan_fast(float)
                  |L1.28|
;;;255      } else if (y >= 0 && x < 0) {
;;;256        return atan_fast(y/x) + PI_F;
00001c  ed9f2a22          VLDR     s4,|L1.168|
000020  eeb50ac0          VCMPE.F32 s0,#0.0               ;255
000024  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;255
000028  db0d              BLT      |L1.70|
00002a  eef50ac0          VCMPE.F32 s1,#0.0               ;255
00002e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;255
000032  d208              BCS      |L1.70|
000034  ee801a20          VDIV.F32 s2,s0,s1
000038  eeb00a41          VMOV.F32 s0,s2
00003c  f7fffffe          BL       _Z9atan_fastf ; atan_fast(float)
000040  ee300a02          VADD.F32 s0,s0,s4
;;;257      } else if (y < 0 && x < 0) {
;;;258        return atan_fast(y/x) - PI_F;
;;;259      } else if (y > 0 && x == 0) {
;;;260        return PIDIV2_F;
;;;261      } else if (y < 0 && x == 0) {
;;;262        return -PIDIV2_F;
;;;263      }
;;;264    
;;;265      return 0;
;;;266    }
000044  bd00              POP      {pc}
                  |L1.70|
000046  eeb50ac0          VCMPE.F32 s0,#0.0               ;257
00004a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;257
00004e  bf3c              ITT      CC                    ;257
000050  eef50ac0          VCMPECC.F32 s1,#0.0               ;257
000054  eef1fa10          VMRSCC   APSR_nzcv,FPSCR       ;257
000058  d208              BCS      |L1.108|
00005a  ee801a20          VDIV.F32 s2,s0,s1              ;258
00005e  eeb00a41          VMOV.F32 s0,s2                 ;258
000062  f7fffffe          BL       _Z9atan_fastf ; atan_fast(float)
000066  ee300a42          VSUB.F32 s0,s0,s4              ;258
00006a  bd00              POP      {pc}
                  |L1.108|
00006c  eeb50ac0          VCMPE.F32 s0,#0.0               ;259
000070  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;259
000074  dd07              BLE      |L1.134|
000076  eef50ac0          VCMPE.F32 s1,#0.0               ;259
00007a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;259
00007e  bf04              ITT      EQ                    ;260
000080  ed9f0a0a          VLDREQ   s0,|L1.172|
000084  bd00              POPEQ    {pc}
                  |L1.134|
000086  eeb50ac0          VCMPE.F32 s0,#0.0               ;261
00008a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;261
00008e  d207              BCS      |L1.160|
000090  eef50ac0          VCMPE.F32 s1,#0.0               ;261
000094  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;261
000098  bf04              ITT      EQ                    ;262
00009a  ed9f0a05          VLDREQ   s0,|L1.176|
00009e  bd00              POPEQ    {pc}
                  |L1.160|
0000a0  ed9f0a04          VLDR     s0,|L1.180|
0000a4  bd00              POP      {pc}
;;;267    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L1.168|
0000a8  40490fdb          DCFS     0x40490fdb ; 3.1415927410125732
                  |L1.172|
0000ac  3fc90fdb          DCFS     0x3fc90fdb ; 1.5707963705062866
                  |L1.176|
0000b0  bfc90fdb          DCFS     0xbfc90fdb ; -1.5707963705062866
                  |L1.180|
0000b4  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._Z9asin_fastf||, CODE, READONLY, ALIGN=2

                  _Z9asin_fastf PROC ; asin_fast(float)
;;;195    
;;;196    float asin_fast(float x)
000000  ee100a10          VMOV     r0,s0
;;;197    {
;;;198      // Clip to valid range
;;;199      x = CLIP(x,-1,1);
000004  f1104f81          CMN      r0,#0x40800000
000008  bf34              ITE      CC
00000a  eef00a40          VMOVCC.F32 s1,s0
00000e  eeff0a00          VMOVCS.F32 s1,#-1.00000000
000012  ee100a90          VMOV     r0,s1
000016  f1b05f7e          CMP      r0,#0x3f800000
00001a  bfa8              IT       GE
00001c  eeb70a00          VMOVGE.F32 s0,#1.00000000
000020  da06              BGE      |L2.48|
000022  ee100a10          VMOV     r0,s0
000026  f1104f81          CMN      r0,#0x40800000
00002a  bf28              IT       CS
00002c  eebf0a00          VMOVCS.F32 s0,#-1.00000000
                  |L2.48|
;;;200    
;;;201    #ifdef USE_INTERPOLATION
;;;202      // Convert x to LUT index
;;;203      float x_lut_idx = ABS(x)*ASIN_LUT_INPUT_MULTIPLIER;
000030  eeb50ac0          VCMPE.F32 s0,#0.0
000034  eef1fa10          VMRS     APSR_nzcv,FPSCR
000038  bfac              ITE      GE
00003a  eef00a40          VMOVGE.F32 s1,s0
00003e  eef10a40          VNEGLT.F32 s1,s0
000042  eddf1a19          VLDR     s3,|L2.168|
;;;204      u8 x_lut_pre_idx = (int)(x_lut_idx);
;;;205      u8 x_lut_post_idx = x_lut_pre_idx + 1;
;;;206      float frac = x_lut_idx - (float)x_lut_pre_idx;
;;;207    
;;;208      // LUT accepts positive input only so need to remember sign so that we
;;;209      // can flip result if input is negative.
;;;210      u8 isNegative = x < 0 ? 1 : 0;
000046  eeb50ac0          VCMPE.F32 s0,#0.0
00004a  ee600aa1          VMUL.F32 s1,s1,s3              ;203
00004e  eebd1ae0          VCVT.S32.F32 s2,s1                 ;204
000052  ee110a10          VMOV     r0,s2                 ;204
000056  b2c0              UXTB     r0,r0                 ;204
000058  ee010a10          VMOV     s2,r0                 ;206
00005c  1c41              ADDS     r1,r0,#1              ;205
00005e  b2c9              UXTB     r1,r1                 ;205
000060  eeb81a41          VCVT.F32.U32 s2,s2                 ;206
000064  ee700ac1          VSUB.F32 s1,s1,s2              ;206
000068  eef1fa10          VMRS     APSR_nzcv,FPSCR
00006c  bf34              ITE      CC
00006e  2201              MOVCC    r2,#1
000070  2200              MOVCS    r2,#0
;;;211    
;;;212      // Check if input exceeds LUT range
;;;213      float lut_result;
;;;214      if (x_lut_post_idx >= ASIN_LUT_SIZE) {
000072  2965              CMP      r1,#0x65
;;;215        lut_result = PIDIV2_F;
000074  bf28              IT       CS
000076  ed9f0a0d          VLDRCS   s0,|L2.172|
00007a  d20f              BCS      |L2.156|
;;;216      } else {
;;;217        u8 asin_pre_res = asin_lut[x_lut_pre_idx];
00007c  4b0c              LDR      r3,|L2.176|
00007e  5c18              LDRB     r0,[r3,r0]
;;;218        u8 asin_post_res = asin_lut[x_lut_post_idx];
000080  5c59              LDRB     r1,[r3,r1]
;;;219    
;;;220        lut_result = ((float)(asin_post_res - asin_pre_res)*frac + asin_pre_res) / ASIN_LUT_OUTPUT_MULTIPLIER;
000082  1a09              SUBS     r1,r1,r0
000084  ee001a10          VMOV     s0,r1
000088  eeb82ac0          VCVT.F32.S32 s4,s0
00008c  ee000a10          VMOV     s0,r0
000090  eeb81a40          VCVT.F32.U32 s2,s0
000094  ee021a20          VMLA.F32 s2,s4,s1
000098  ee810a21          VDIV.F32 s0,s2,s3
                  |L2.156|
;;;221      }
;;;222    
;;;223    #else
;;;224    
;;;225      // Convert x to LUT index
;;;226      int x_lut_idx = (int)(ABS(x)*ASIN_LUT_INPUT_MULTIPLIER);
;;;227    
;;;228      // LUT accepts positive input only so need to remember sign so that we
;;;229      // can flip result if input is negative.
;;;230      u8 isNegative = x < 0 ? 1 : 0;
;;;231    
;;;232      // Check if input exceeds LUT range
;;;233      float lut_result;
;;;234      if (x_lut_idx >= ASIN_LUT_SIZE) {
;;;235        lut_result = PI_DIV2;
;;;236      } else {
;;;237        lut_result = (float)asin_lut[x_lut_idx] / ASIN_LUT_OUTPUT_MULTIPLIER;
;;;238      }
;;;239    
;;;240    #endif
;;;241    
;;;242      if (isNegative) {
00009c  2a00              CMP      r2,#0
;;;243        lut_result *= -1;
00009e  bf18              IT       NE
0000a0  eeb10a40          VNEGNE.F32 s0,s0
;;;244      }
;;;245    
;;;246      return lut_result;
;;;247    }
0000a4  4770              BX       lr
;;;248    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L2.168|
0000a8  42c80000          DCFS     0x42c80000 ; 100
                  |L2.172|
0000ac  3fc90fdb          DCFS     0x3fc90fdb ; 1.5707963705062866
                  |L2.176|
                          DCD      ||.constdata||

                          AREA ||i._Z9atan2_accff||, CODE, READONLY, ALIGN=2

                  _Z9atan2_accff PROC ; atan2_acc(float, float)
;;;267    
;;;268    float atan2_acc(float y, float x)
000000  b510              PUSH     {r4,lr}
;;;269    {
000002  ed2d8b04          VPUSH    {d8-d9}
000006  eeb08a60          VMOV.F32 s16,s1
00000a  eef08a40          VMOV.F32 s17,s0
;;;270      AnkiAssert(y != 0 || x != 0);
;;;271    
;;;272      float arg = y/x;
;;;273      float atan_val = asinf( arg / sqrtf(arg*arg + 1));
00000e  eef70a00          VMOV.F32 s1,#1.00000000
000012  ee889a88          VDIV.F32 s18,s17,s16           ;272
000016  ee490a09          VMLA.F32 s1,s18,s18
00001a  eeb10ae0          VSQRT.F32 s0,s1
00001e  eeb40a40          VCMP.F32 s0,s0
000022  eef1fa10          VMRS     APSR_nzcv,FPSCR
000026  bf1c              ITT      NE
000028  eeb00a60          VMOVNE.F32 s0,s1
00002c  f7fffffe          BLNE     __hardfp_sqrtf
000030  eec90a00          VDIV.F32 s1,s18,s0
000034  eeb00a60          VMOV.F32 s0,s1
000038  f7fffffe          BL       __hardfp_asinf
;;;274    
;;;275      if (x > 0) {
00003c  eeb58ac0          VCMPE.F32 s16,#0.0
000040  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;276        return atan_val;
;;;277      } else if (y >= 0 && x < 0) {
;;;278        return atan_val + PI_F;
;;;279      } else if (y < 0 && x < 0) {
;;;280        return atan_val - PI_F;
;;;281      } else if (y > 0 && x == 0) {
;;;282        return PIDIV2_F;
;;;283      }
;;;284      //else if (y < 0 && x == 0) {
;;;285      return -PIDIV2_F;
;;;286      //}
;;;287    }
000044  bfc4              ITT      GT
000046  ecbd8b04          VPOPGT   {d8-d9}
00004a  bd10              POPGT    {r4,pc}
00004c  eddf0a19          VLDR     s1,|L3.180|
000050  eef58ac0          VCMPE.F32 s17,#0.0              ;277
000054  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;277
000058  db09              BLT      |L3.110|
00005a  eeb58ac0          VCMPE.F32 s16,#0.0              ;277
00005e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;277
000062  bf3e              ITTT     CC                    ;278
000064  ee300a20          VADDCC.F32 s0,s0,s1              ;278
000068  ecbd8b04          VPOPCC   {d8-d9}
00006c  bd10              POPCC    {r4,pc}
                  |L3.110|
00006e  eef58ac0          VCMPE.F32 s17,#0.0              ;279
000072  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;279
000076  bf3f              ITTTT    CC                    ;279
000078  eeb58ac0          VCMPECC.F32 s16,#0.0              ;279
00007c  eef1fa10          VMRSCC   APSR_nzcv,FPSCR       ;279
000080  ee300a60          VSUBCC.F32 s0,s0,s1              ;280
000084  ecbd8b04          VPOPCC   {d8-d9}
000088  bf38              IT       CC
00008a  bd10              POPCC    {r4,pc}
00008c  eef58ac0          VCMPE.F32 s17,#0.0              ;281
000090  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;281
000094  dd09              BLE      |L3.170|
000096  eeb58ac0          VCMPE.F32 s16,#0.0              ;281
00009a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;281
00009e  bf02              ITTT     EQ                    ;282
0000a0  ed9f0a05          VLDREQ   s0,|L3.184|
0000a4  ecbd8b04          VPOPEQ   {d8-d9}
0000a8  bd10              POPEQ    {r4,pc}
                  |L3.170|
0000aa  ed9f0a04          VLDR     s0,|L3.188|
0000ae  ecbd8b04          VPOP     {d8-d9}
0000b2  bd10              POP      {r4,pc}
                          ENDP

                  |L3.180|
0000b4  40490fdb          DCFS     0x40490fdb ; 3.1415927410125732
                  |L3.184|
0000b8  3fc90fdb          DCFS     0x3fc90fdb ; 1.5707963705062866
                  |L3.188|
0000bc  bfc90fdb          DCFS     0xbfc90fdb ; -1.5707963705062866

                          AREA ||i._Z9atan_fastf||, CODE, READONLY, ALIGN=2

                  _Z9atan_fastf PROC ; atan_fast(float)
;;;113    // Approximates values beyond that with discrete step values. Clunky but fast and good enough. Trying to keep ~0.01 accuracy.
;;;114    float atan_fast(float x)
000000  eeb01a40          VMOV.F32 s2,s0
;;;115    {
;;;116      // LUT accepts positive input only so need to remember sign so that we
;;;117      // can flip result if input is negative.
;;;118      u8 isNegative = x < 0 ? 1 : 0;
000004  eeb51ac0          VCMPE.F32 s2,#0.0
000008  eef1fa10          VMRS     APSR_nzcv,FPSCR
00000c  bf34              ITE      CC
00000e  2201              MOVCC    r2,#1
000010  2200              MOVCS    r2,#0
;;;119    
;;;120    #ifdef DO_ATAN_DISCRETE_STEP_APPROX
;;;121      // Check if input is in discrete step approximation range
;;;122      float absx = ABS(x);
000012  eef11a41          VNEG.F32 s3,s2
000016  eeb51ac0          VCMPE.F32 s2,#0.0
00001a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00001e  bfac              ITE      GE
000020  eeb00a41          VMOVGE.F32 s0,s2
000024  eeb00a61          VMOVLT.F32 s0,s3
;;;123      if (absx >= ATAN_LUT_MAX_INPUT) {
000028  ee100a10          VMOV     r0,s0
00002c  4949              LDR      r1,|L4.340|
;;;124        float res;
;;;125    
;;;126        if (absx >= 600) {
;;;127          res = PIDIV2_F;
00002e  eddf0a4a          VLDR     s1,|L4.344|
000032  4288              CMP      r0,r1                 ;123
000034  db5d              BLT      |L4.242|
000036  ee100a10          VMOV     r0,s0                 ;126
00003a  4948              LDR      r1,|L4.348|
00003c  4281              CMP      r1,r0                 ;126
00003e  dd54              BLE      |L4.234|
;;;128        }
;;;129        else if (absx >= 120) {
000040  ee100a10          VMOV     r0,s0
000044  4946              LDR      r1,|L4.352|
000046  4281              CMP      r1,r0
000048  dc0a              BGT      |L4.96|
;;;130          res = SLOPE_TO_600 * (absx - 120) + ATAN120;
00004a  eddf0a46          VLDR     s1,|L4.356|
00004e  ee300a60          VSUB.F32 s0,s0,s1
000052  ed9f1a45          VLDR     s2,|L4.360|
000056  eef70a09          VMOV.F32 s1,#1.56250000
00005a  ee400a01          VMLA.F32 s1,s0,s2
00005e  e044              B        |L4.234|
                  |L4.96|
;;;131        }
;;;132        else if (absx >= 60) {
000060  ee100a10          VMOV     r0,s0
000064  4941              LDR      r1,|L4.364|
000066  4281              CMP      r1,r0
000068  dc08              BGT      |L4.124|
;;;133          res = SLOPE_TO_120 * (absx - 60) + ATAN60;
00006a  eddf0a41          VLDR     s1,|L4.368|
00006e  ee300a60          VSUB.F32 s0,s0,s1
000072  ed9f1a40          VLDR     s2,|L4.372|
000076  eddf0a40          VLDR     s1,|L4.376|
00007a  e00c              B        |L4.150|
                  |L4.124|
;;;134        }
;;;135        else if (absx >= 40) {
00007c  ee100a10          VMOV     r0,s0
000080  493e              LDR      r1,|L4.380|
000082  4281              CMP      r1,r0
000084  dc0a              BGT      |L4.156|
;;;136          res = SLOPE_TO_60 * (absx - 40) + ATAN40;
000086  eddf0a3e          VLDR     s1,|L4.384|
00008a  ed9f1a3e          VLDR     s2,|L4.388|
00008e  ee300a60          VSUB.F32 s0,s0,s1
000092  eddf0a3d          VLDR     s1,|L4.392|
                  |L4.150|
000096  ee400a01          VMLA.F32 s1,s0,s2
00009a  e026              B        |L4.234|
                  |L4.156|
;;;137        }
;;;138        else if (absx >= 30) {
00009c  ee100a10          VMOV     r0,s0
0000a0  493a              LDR      r1,|L4.396|
0000a2  4281              CMP      r1,r0
0000a4  dc08              BGT      |L4.184|
;;;139          res = SLOPE_TO_40 * (absx - 30) + ATAN30;
0000a6  eef30a0e          VMOV.F32 s1,#30.00000000
0000aa  ed9f1a39          VLDR     s2,|L4.400|
0000ae  ee300a60          VSUB.F32 s0,s0,s1
0000b2  eddf0a38          VLDR     s1,|L4.404|
0000b6  e7ee              B        |L4.150|
                  |L4.184|
;;;140        }
;;;141        else if (absx >= 25) {
0000b8  ee100a10          VMOV     r0,s0
0000bc  4936              LDR      r1,|L4.408|
0000be  4281              CMP      r1,r0
0000c0  dc08              BGT      |L4.212|
;;;142          res = SLOPE_TO_30 * (absx - 25) + ATAN25;
0000c2  eef30a09          VMOV.F32 s1,#25.00000000
0000c6  ed9f1a35          VLDR     s2,|L4.412|
0000ca  ee300a60          VSUB.F32 s0,s0,s1
0000ce  eddf0a34          VLDR     s1,|L4.416|
0000d2  e7e0              B        |L4.150|
                  |L4.212|
;;;143        }
;;;144        else {
;;;145          res = SLOPE_TO_25 * (absx - ATAN_LUT_MAX_INPUT) + ATAN_LUT_MAX;
0000d4  4833              LDR      r0,|L4.420|
0000d6  eef30a04          VMOV.F32 s1,#20.00000000
0000da  ee300a60          VSUB.F32 s0,s0,s1
0000de  edd00a00          VLDR     s1,[r0,#0]
0000e2  ed901a01          VLDR     s2,[r0,#4]
0000e6  ee410a00          VMLA.F32 s1,s2,s0
                  |L4.234|
;;;146        }
;;;147    
;;;148        if (isNegative) {
0000ea  b382              CBZ      r2,|L4.334|
                  |L4.236|
;;;149          res *= -1;
0000ec  eef10a60          VNEG.F32 s1,s1
0000f0  e02d              B        |L4.334|
                  |L4.242|
;;;150        }
;;;151    
;;;152        return res;
;;;153      }
;;;154    #endif
;;;155    
;;;156    #ifdef USE_INTERPOLATION
;;;157    
;;;158      // Convert x to LUT index
;;;159      float x_lut_idx = ABS(x)*ATAN_LUT_INPUT_MULTIPLIER;
0000f2  eeb51ac0          VCMPE.F32 s2,#0.0
0000f6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000fa  bfb8              IT       LT
0000fc  eeb01a61          VMOVLT.F32 s2,s3
000100  eeb10a04          VMOV.F32 s0,#5.00000000
000104  ee210a00          VMUL.F32 s0,s2,s0
;;;160      u8 x_lut_pre_idx = (int)(x_lut_idx);
000108  eebd1ac0          VCVT.S32.F32 s2,s0
00010c  ee110a10          VMOV     r0,s2
000110  b2c0              UXTB     r0,r0
;;;161      u8 x_lut_post_idx = x_lut_pre_idx + 1;
;;;162      float frac = x_lut_idx - (float)x_lut_pre_idx;
000112  ee010a10          VMOV     s2,r0
000116  1c41              ADDS     r1,r0,#1              ;161
000118  b2c9              UXTB     r1,r1                 ;161
00011a  eeb81a41          VCVT.F32.U32 s2,s2
;;;163    
;;;164      // Check if input exceeds LUT range
;;;165      float lut_result;
;;;166      if (x_lut_post_idx >= ATAN_LUT_SIZE) {
00011e  2965              CMP      r1,#0x65
000120  ee300a41          VSUB.F32 s0,s0,s2              ;162
000124  d211              BCS      |L4.330|
;;;167        lut_result = PIDIV2_F;
;;;168      } else {
;;;169        u8 atan_pre_res = atan_lut[x_lut_pre_idx];
000126  4b20              LDR      r3,|L4.424|
000128  5c18              LDRB     r0,[r3,r0]
;;;170        u8 atan_post_res = atan_lut[x_lut_post_idx];
00012a  5c59              LDRB     r1,[r3,r1]
;;;171    
;;;172        lut_result = ((float)(atan_post_res - atan_pre_res)*frac + atan_pre_res) / ATAN_LUT_OUTPUT_MULTIPLIER;
00012c  1a09              SUBS     r1,r1,r0
00012e  ee001a90          VMOV     s1,r1
000132  eef81ae0          VCVT.F32.S32 s3,s1
000136  ee000a90          VMOV     s1,r0
00013a  eeb81a60          VCVT.F32.U32 s2,s1
00013e  ee011a80          VMLA.F32 s2,s3,s0
000142  ed9f0a1a          VLDR     s0,|L4.428|
000146  eec10a00          VDIV.F32 s1,s2,s0
                  |L4.330|
;;;173      }
;;;174    
;;;175    #else
;;;176    
;;;177      // Convert x to LUT index
;;;178      int x_lut_idx = (int)(ABS(x)*ATAN_LUT_INPUT_MULTIPLIER);
;;;179    
;;;180      // Check if input exceeds LUT range
;;;181      float lut_result;
;;;182      if (x_lut_idx >= ATAN_LUT_SIZE) {
;;;183        lut_result = PI_DIV2;
;;;184      } else {
;;;185        lut_result = (float)atan_lut[x_lut_idx] / ATAN_LUT_OUTPUT_MULTIPLIER;
;;;186      }
;;;187    #endif
;;;188    
;;;189      if (isNegative) {
00014a  2a00              CMP      r2,#0
00014c  d1ce              BNE      |L4.236|
                  |L4.334|
;;;190        lut_result *= -1;
;;;191      }
;;;192    
;;;193      return lut_result;
00014e  eeb00a60          VMOV.F32 s0,s1
;;;194    }
000152  4770              BX       lr
;;;195    
                          ENDP

                  |L4.340|
                          DCD      0x41a00000
                  |L4.344|
000158  3fc90fdb          DCFS     0x3fc90fdb ; 1.5707963705062866
                  |L4.348|
                          DCD      0x44160000
                  |L4.352|
                          DCD      0x42f00000
                  |L4.356|
000164  42f00000          DCFS     0x42f00000 ; 120
                  |L4.360|
000168  3766b000          DCFS     0x3766b000 ; 1.3750046491622925e-05
                  |L4.364|
                          DCD      0x42700000
                  |L4.368|
000170  42700000          DCFS     0x42700000 ; 60
                  |L4.372|
000174  3912cccd          DCFS     0x3912cccd ; 0.00013999939255882055
                  |L4.376|
000178  3fc6ecc0          DCFS     0x3fc6ecc0 ; 1.5541000366210938
                  |L4.380|
                          DCD      0x42200000
                  |L4.384|
000180  42200000          DCFS     0x42200000 ; 40
                  |L4.388|
000184  39d994cd          DCFS     0x39d994cd ; 0.00041500330553390086
                  |L4.392|
000188  3fc5dcc6          DCFS     0x3fc5dcc6 ; 1.5457999706268311
                  |L4.396|
                          DCD      0x41f00000
                  |L4.400|
000190  3a599400          DCFS     0x3a599400 ; 0.00082999467849731445
                  |L4.404|
000194  3fc4cccd          DCFS     0x3fc4cccd ; 1.5375000238418579
                  |L4.408|
                          DCD      0x41c80000
                  |L4.412|
00019c  3aafa333          DCFS     0x3aafa333 ; 0.0013400077586993575
                  |L4.416|
0001a0  3fc3f141          DCFS     0x3fc3f141 ; 1.5307999849319458
                  |L4.420|
                          DCD      ||.data||
                  |L4.424|
                          DCD      ||.constdata||+0x65
                  |L4.428|
0001ac  42c80000          DCFS     0x42c80000 ; 100

                          AREA ||i.__sti___13_trig_fast_cpp_21420f07||, CODE, READONLY, ALIGN=2

                  __sti___13_trig_fast_cpp_21420f07 PROC
000000  4805              LDR      r0,|L5.24|
000002  ed9f0a04          VLDR     s0,|L5.20|
000006  ed800a00          VSTR     s0,[r0,#0]
00000a  ed9f0a04          VLDR     s0,|L5.28|
00000e  ed800a01          VSTR     s0,[r0,#4]
000012  4770              BX       lr
                          ENDP

                  |L5.20|
000014  3fc28f5c          DCFS     0x3fc28f5c ; 1.5199999809265137
                  |L5.24|
                          DCD      ||.data||
                  |L5.28|
00001c  3b0d8ecd          DCFS     0x3b0d8ecd ; 0.0021600008476525545

                          AREA ||.ARM.exidx||, LINKORDER=||i._Z9atan_fastf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._Z9atan_fastf||
                          DCD      0x00000001

                          AREA ||area_number.7||, LINKORDER=||i._Z9asin_fastf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z9asin_fastf||
                          DCD      0x00000001

                          AREA ||area_number.8||, LINKORDER=||i._Z10atan2_fastff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z10atan2_fastff||
                          DCD      0x00000001

                          AREA ||area_number.9||, LINKORDER=||i._Z9atan2_accff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z9atan2_accff||
                          DCD      0x00000001

                          AREA ||area_number.10||, LINKORDER=||i.__sti___13_trig_fast_cpp_21420f07||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___13_trig_fast_cpp_21420f07||
                          DCD      0x00000001

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  asin_lut
000000  00010203          DCB      0x00,0x01,0x02,0x03
000004  04050607          DCB      0x04,0x05,0x06,0x07
000008  08090a0b          DCB      0x08,0x09,0x0a,0x0b
00000c  0c0d0e0f          DCB      0x0c,0x0d,0x0e,0x0f
000010  10111213          DCB      0x10,0x11,0x12,0x13
000014  14151617          DCB      0x14,0x15,0x16,0x17
000018  18191a1b          DCB      0x18,0x19,0x1a,0x1b
00001c  1c1d1e20          DCB      0x1c,0x1d,0x1e,0x20
000020  21222324          DCB      0x21,0x22,0x23,0x24
000024  25262728          DCB      0x25,0x26,0x27,0x28
000028  292a2b2c          DCB      0x29,0x2a,0x2b,0x2c
00002c  2e2f3031          DCB      0x2e,0x2f,0x30,0x31
000030  32333436          DCB      0x32,0x33,0x34,0x36
000034  3738393a          DCB      0x37,0x38,0x39,0x3a
000038  3b3d3e3f          DCB      0x3b,0x3d,0x3e,0x3f
00003c  40424344          DCB      0x40,0x42,0x43,0x44
000040  45474849          DCB      0x45,0x47,0x48,0x49
000044  4b4c4e4f          DCB      0x4b,0x4c,0x4e,0x4f
000048  50525355          DCB      0x50,0x52,0x53,0x55
00004c  5658595b          DCB      0x56,0x58,0x59,0x5b
000050  5d5e6062          DCB      0x5d,0x5e,0x60,0x62
000054  6466686a          DCB      0x64,0x66,0x68,0x6a
000058  6c6e7072          DCB      0x6c,0x6e,0x70,0x72
00005c  75777a7d          DCB      0x75,0x77,0x7a,0x7d
000060  8185898f          DCB      0x81,0x85,0x89,0x8f
000064  9d                DCB      0x9d
                  atan_lut
000065  001426            DCB      0x00,0x14,0x26
000068  36434f58          DCB      0x36,0x43,0x4f,0x58
00006c  5f656a6f          DCB      0x5f,0x65,0x6a,0x6f
000070  7276787b          DCB      0x72,0x76,0x78,0x7b
000074  7d7f8082          DCB      0x7d,0x7f,0x80,0x82
000078  83858687          DCB      0x83,0x85,0x86,0x87
00007c  8889898a          DCB      0x88,0x89,0x89,0x8a
000080  8b8b8c8d          DCB      0x8b,0x8b,0x8c,0x8d
000084  8d8e8e8e          DCB      0x8d,0x8e,0x8e,0x8e
000088  8f8f9090          DCB      0x8f,0x8f,0x90,0x90
00008c  90919191          DCB      0x90,0x91,0x91,0x91
000090  92929292          DCB      0x92,0x92,0x92,0x92
000094  92939393          DCB      0x92,0x93,0x93,0x93
000098  93939494          DCB      0x93,0x93,0x94,0x94
00009c  94949494          DCB      0x94,0x94,0x94,0x94
0000a0  95959595          DCB      0x95,0x95,0x95,0x95
0000a4  95959596          DCB      0x95,0x95,0x95,0x96
0000a8  96969696          DCB      0x96,0x96,0x96,0x96
0000ac  96969696          DCB      0x96,0x96,0x96,0x96
0000b0  96979797          DCB      0x96,0x97,0x97,0x97
0000b4  97979797          DCB      0x97,0x97,0x97,0x97
0000b8  97979797          DCB      0x97,0x97,0x97,0x97
0000bc  97979798          DCB      0x97,0x97,0x97,0x98
0000c0  98989898          DCB      0x98,0x98,0x98,0x98
0000c4  98989898          DCB      0x98,0x98,0x98,0x98
0000c8  9898              DCB      0x98,0x98

                          AREA ||.data||, DATA, ALIGN=2

                  ATAN_LUT_MAX
                          DCD      0x00000000
                  SLOPE_TO_25
                          DCD      0x00000000

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___13_trig_fast_cpp_21420f07
