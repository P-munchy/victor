; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\usb_core.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\usb_core.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DANKICORETECH_EMBEDDED_USE_HEATSHRINK -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\usb_core.crf arm_hal\lib\usb\usb_core.c]
                          THUMB

                          AREA ||i.USB_OTG_ActiveRemoteWakeup||, CODE, READONLY, ALIGN=1

                  USB_OTG_ActiveRemoteWakeup PROC
;;;1948   */
;;;1949   void USB_OTG_ActiveRemoteWakeup(USB_OTG_CORE_HANDLE *pdev)
000000  b510              PUSH     {r4,lr}
;;;1950   {
000002  4604              MOV      r4,r0
;;;1951     
;;;1952     USB_OTG_DCTL_TypeDef     dctl;
;;;1953     USB_OTG_DSTS_TypeDef     dsts;
;;;1954     USB_OTG_PCGCCTL_TypeDef  power;  
;;;1955     
;;;1956     if (pdev->dev.DevRemoteWakeup) 
000004  f8d00118          LDR      r0,[r0,#0x118]
000008  2800              CMP      r0,#0                 ;1950
;;;1957     {
;;;1958       dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
;;;1959       if(dsts.b.suspsts == 1)
;;;1960       {
;;;1961         if(pdev->cfg.low_power)
;;;1962         {
;;;1963           /* un-gate USB Core clock */
;;;1964           power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
;;;1965           power.b.gatehclk = 0;
;;;1966           power.b.stoppclk = 0;
;;;1967           USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
;;;1968         }   
;;;1969         /* active Remote wakeup signaling */
;;;1970         dctl.d32 = 0;
;;;1971         dctl.b.rmtwkupsig = 1;
;;;1972         USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, 0, dctl.d32);
;;;1973         USB_OTG_BSP_mDelay(5);
;;;1974         USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
;;;1975       }
;;;1976     }
;;;1977   }
00000a  bf08              IT       EQ
00000c  bd10              POPEQ    {r4,pc}
00000e  6920              LDR      r0,[r4,#0x10]         ;1958
000010  6880              LDR      r0,[r0,#8]            ;1958
000012  f0100f01          TST      r0,#1                 ;1959
000016  bf08              IT       EQ
000018  bd10              POPEQ    {r4,pc}
00001a  7aa0              LDRB     r0,[r4,#0xa]          ;1961
00001c  b130              CBZ      r0,|L1.44|
00001e  f8d4010c          LDR      r0,[r4,#0x10c]        ;1964
000022  f8d4110c          LDR      r1,[r4,#0x10c]        ;1967
000026  f0200003          BIC      r0,r0,#3              ;1966
00002a  6008              STR      r0,[r1,#0]            ;1967
                  |L1.44|
00002c  6920              LDR      r0,[r4,#0x10]         ;1972
00002e  6841              LDR      r1,[r0,#4]            ;1972
000030  f0410101          ORR      r1,r1,#1              ;1972
000034  6041              STR      r1,[r0,#4]            ;1972
000036  2005              MOVS     r0,#5                 ;1973
000038  f7fffffe          BL       USB_OTG_BSP_mDelay
00003c  6920              LDR      r0,[r4,#0x10]         ;1974
00003e  6841              LDR      r1,[r0,#4]            ;1974
000040  f0210101          BIC      r1,r1,#1              ;1974
000044  6041              STR      r1,[r0,#4]            ;1974
000046  bd10              POP      {r4,pc}
;;;1978   
                          ENDP


                          AREA ||i.USB_OTG_CoreInit||, CODE, READONLY, ALIGN=2

                  USB_OTG_CoreInit PROC
;;;322    */
;;;323    USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;324    {
000004  4604              MOV      r4,r0
;;;325      USB_OTG_STS status = USB_OTG_OK;
000006  2700              MOVS     r7,#0
;;;326      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;327      USB_OTG_GCCFG_TypeDef    gccfg;
;;;328      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;329      
;;;330      usbcfg.d32 = 0;
;;;331      gccfg.d32 = 0;
;;;332      ahbcfg.d32 = 0;
;;;333      
;;;334      
;;;335      
;;;336      if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
000008  7a01              LDRB     r1,[r0,#8]
00000a  4e45              LDR      r6,|L2.288|
;;;337      {
;;;338        gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
00000c  68c0              LDR      r0,[r0,#0xc]
00000e  46b8              MOV      r8,r7                 ;330
000010  2901              CMP      r1,#1                 ;336
000012  d038              BEQ      |L2.134|
;;;339        gccfg.b.pwdn = 0;
;;;340        
;;;341        if (pdev->cfg.Sof_output)
;;;342        {
;;;343          gccfg.b.sofouten = 1;   
;;;344        }
;;;345        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
;;;346        
;;;347        /* Init The ULPI Interface */
;;;348        usbcfg.d32 = 0;
;;;349        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;350        
;;;351        usbcfg.b.physel            = 0; /* HS Interface */
;;;352    #ifdef USB_OTG_INTERNAL_VBUS_ENABLED
;;;353        usbcfg.b.ulpi_ext_vbus_drv = 0; /* Use internal VBUS */
;;;354    #else
;;;355    #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
;;;356        usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
;;;357    #endif
;;;358    #endif 
;;;359        usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
;;;360        
;;;361        usbcfg.b.ulpi_fsls = 0;
;;;362        usbcfg.b.ulpi_clk_sus_m = 0;
;;;363        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;364        
;;;365        /* Reset after a PHY select  */
;;;366        USB_OTG_CoreReset(pdev);
;;;367        
;;;368        if(pdev->cfg.dma_enable == 1)
;;;369        {
;;;370          
;;;371          ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
;;;372          ahbcfg.b.dmaenable = 1;
;;;373          USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
;;;374          
;;;375        }    
;;;376      }
;;;377      else /* FS interface (embedded Phy) */
;;;378      {
;;;379        
;;;380        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
000014  68c1              LDR      r1,[r0,#0xc]
;;;381        usbcfg.b.physel  = 1; /* FS Interface */
000016  f0410140          ORR      r1,r1,#0x40
;;;382        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
00001a  60c1              STR      r1,[r0,#0xc]
00001c  2500              MOVS     r5,#0
00001e  f8cd8000          STR      r8,[sp,#0]
                  |L2.34|
000022  2003              MOVS     r0,#3
000024  f7fffffe          BL       USB_OTG_BSP_uDelay
000028  68e0              LDR      r0,[r4,#0xc]
00002a  6900              LDR      r0,[r0,#0x10]
00002c  9000              STR      r0,[sp,#0]
00002e  1c6d              ADDS     r5,r5,#1
000030  42b5              CMP      r5,r6
000032  d818              BHI      |L2.102|
000034  9800              LDR      r0,[sp,#0]
000036  f0104f00          TST      r0,#0x80000000
00003a  d0f2              BEQ      |L2.34|
00003c  9900              LDR      r1,[sp,#0]
00003e  2000              MOVS     r0,#0
000040  f0410101          ORR      r1,r1,#1
000044  9100              STR      r1,[sp,#0]
000046  9900              LDR      r1,[sp,#0]
000048  68e2              LDR      r2,[r4,#0xc]
00004a  6111              STR      r1,[r2,#0x10]
00004c  68e1              LDR      r1,[r4,#0xc]          ;338
                  |L2.78|
00004e  690a              LDR      r2,[r1,#0x10]         ;338
000050  9200              STR      r2,[sp,#0]            ;338
000052  1c40              ADDS     r0,r0,#1              ;338
000054  42b0              CMP      r0,r6                 ;338
000056  d803              BHI      |L2.96|
000058  9a00              LDR      r2,[sp,#0]            ;338
00005a  f0120f01          TST      r2,#1                 ;338
00005e  d1f6              BNE      |L2.78|
                  |L2.96|
000060  2003              MOVS     r0,#3                 ;338
000062  f7fffffe          BL       USB_OTG_BSP_uDelay
                  |L2.102|
;;;383        /* Reset after a PHY select and set Host mode */
;;;384        USB_OTG_CoreReset(pdev);
;;;385        /* Deactivate the power down*/
;;;386        gccfg.d32 = 0;
;;;387        gccfg.b.pwdn = 1;
;;;388        
;;;389        gccfg.b.vbussensingA = 1 ;
;;;390        gccfg.b.vbussensingB = 1 ;     
;;;391    #ifndef VBUS_SENSING_ENABLED
;;;392        gccfg.b.disablevbussensing = 1; 
;;;393    #endif    
;;;394        
;;;395        if(pdev->cfg.Sof_output)
000066  7a61              LDRB     r1,[r4,#9]
000068  f44f2050          MOV      r0,#0xd0000           ;390
00006c  2900              CMP      r1,#0
;;;396        {
;;;397          gccfg.b.sofouten = 1;  
00006e  bf18              IT       NE
000070  f44f10e8          MOVNE    r0,#0x1d0000
;;;398        }
;;;399        
;;;400        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
000074  68e1              LDR      r1,[r4,#0xc]
000076  6388              STR      r0,[r1,#0x38]
;;;401        USB_OTG_BSP_mDelay(20);
000078  2014              MOVS     r0,#0x14
00007a  f7fffffe          BL       USB_OTG_BSP_mDelay
                  |L2.126|
;;;402      }
;;;403      /* case the HS core is working in FS mode */
;;;404      if(pdev->cfg.dma_enable == 1)
00007e  78e0              LDRB     r0,[r4,#3]
000080  2801              CMP      r0,#1
000082  d149              BNE      |L2.280|
000084  e040              B        |L2.264|
                  |L2.134|
000086  6b81              LDR      r1,[r0,#0x38]         ;338
000088  7a62              LDRB     r2,[r4,#9]            ;341
00008a  f4213180          BIC      r1,r1,#0x10000        ;339
00008e  2a00              CMP      r2,#0                 ;341
000090  bf18              IT       NE                    ;343
000092  f4411180          ORRNE    r1,r1,#0x100000       ;343
000096  6381              STR      r1,[r0,#0x38]         ;345
000098  68e0              LDR      r0,[r4,#0xc]          ;349
00009a  68c1              LDR      r1,[r0,#0xc]          ;349
00009c  f0210140          BIC      r1,r1,#0x40           ;361
0000a0  f4210194          BIC      r1,r1,#0x4a0000       ;361
0000a4  f4411180          ORR      r1,r1,#0x100000       ;362
0000a8  60c1              STR      r1,[r0,#0xc]          ;363
0000aa  2500              MOVS     r5,#0                 ;363
0000ac  f8cd8000          STR      r8,[sp,#0]            ;363
                  |L2.176|
0000b0  2003              MOVS     r0,#3                 ;363
0000b2  f7fffffe          BL       USB_OTG_BSP_uDelay
0000b6  68e0              LDR      r0,[r4,#0xc]          ;363
0000b8  6900              LDR      r0,[r0,#0x10]         ;363
0000ba  9000              STR      r0,[sp,#0]            ;363
0000bc  1c6d              ADDS     r5,r5,#1              ;363
0000be  42b5              CMP      r5,r6                 ;363
0000c0  d818              BHI      |L2.244|
0000c2  9800              LDR      r0,[sp,#0]            ;363
0000c4  f0104f00          TST      r0,#0x80000000        ;363
0000c8  d0f2              BEQ      |L2.176|
0000ca  9900              LDR      r1,[sp,#0]            ;363
0000cc  2000              MOVS     r0,#0                 ;363
0000ce  f0410101          ORR      r1,r1,#1              ;363
0000d2  9100              STR      r1,[sp,#0]            ;363
0000d4  9900              LDR      r1,[sp,#0]            ;363
0000d6  68e2              LDR      r2,[r4,#0xc]          ;363
0000d8  6111              STR      r1,[r2,#0x10]         ;363
0000da  68e1              LDR      r1,[r4,#0xc]          ;338
                  |L2.220|
0000dc  690a              LDR      r2,[r1,#0x10]         ;338
0000de  9200              STR      r2,[sp,#0]            ;338
0000e0  1c40              ADDS     r0,r0,#1              ;338
0000e2  42b0              CMP      r0,r6                 ;338
0000e4  d803              BHI      |L2.238|
0000e6  9a00              LDR      r2,[sp,#0]            ;338
0000e8  f0120f01          TST      r2,#1                 ;338
0000ec  d1f6              BNE      |L2.220|
                  |L2.238|
0000ee  2003              MOVS     r0,#3                 ;338
0000f0  f7fffffe          BL       USB_OTG_BSP_uDelay
                  |L2.244|
0000f4  78e0              LDRB     r0,[r4,#3]            ;368
0000f6  2801              CMP      r0,#1                 ;368
0000f8  d10e              BNE      |L2.280|
0000fa  68e1              LDR      r1,[r4,#0xc]          ;373
0000fc  f108000a          ADD      r0,r8,#0xa            ;371
000100  f0400020          ORR      r0,r0,#0x20           ;372
000104  6088              STR      r0,[r1,#8]            ;373
000106  e7ba              B        |L2.126|
                  |L2.264|
;;;405      {
;;;406        
;;;407        ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
000108  68e0              LDR      r0,[r4,#0xc]
00010a  6881              LDR      r1,[r0,#8]
;;;408        ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
00010c  f021011e          BIC      r1,r1,#0x1e
000110  310a              ADDS     r1,r1,#0xa
;;;409        ahbcfg.b.dmaenable = 1;
000112  f0410120          ORR      r1,r1,#0x20
;;;410        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
000116  6081              STR      r1,[r0,#8]
                  |L2.280|
;;;411        
;;;412      }
;;;413      /* initialize OTG features */
;;;414    #ifdef  USE_OTG_MODE
;;;415      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;416      usbcfg.b.hnpcap = 1;
;;;417      usbcfg.b.srpcap = 1;
;;;418      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;419      USB_OTG_EnableCommonInt(pdev);
;;;420    #endif
;;;421      return status;
000118  4638              MOV      r0,r7
;;;422    }
00011a  e8bd83f8          POP      {r3-r9,pc}
;;;423    /**
                          ENDP

00011e  0000              DCW      0x0000
                  |L2.288|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_CoreInitDev||, CODE, READONLY, ALIGN=2

                  USB_OTG_CoreInitDev PROC
;;;1193   */
;;;1194   USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1195   {
000004  4604              MOV      r4,r0
;;;1196     USB_OTG_STS             status       = USB_OTG_OK;
000006  2600              MOVS     r6,#0
;;;1197     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1198     uint32_t i;
;;;1199     USB_OTG_DCFG_TypeDef    dcfg;
;;;1200     USB_OTG_FSIZ_TypeDef    nptxfifosize;
;;;1201     USB_OTG_FSIZ_TypeDef    txfifosize;
;;;1202     USB_OTG_DIEPMSK_TypeDef msk;
;;;1203     USB_OTG_DTHRCTL_TypeDef dthrctl;  
;;;1204     
;;;1205     depctl.d32 = 0;
;;;1206     dcfg.d32 = 0;
;;;1207     nptxfifosize.d32 = 0;
;;;1208     txfifosize.d32 = 0;
;;;1209     msk.d32 = 0;
;;;1210     
;;;1211     /* Restart the Phy Clock */
;;;1212     USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
000008  f8d4210c          LDR      r2,[r4,#0x10c]
00000c  4635              MOV      r5,r6                 ;1205
00000e  4628              MOV      r0,r5                 ;1205
000010  4629              MOV      r1,r5                 ;1208
000012  6016              STR      r6,[r2,#0]
;;;1213     /* Device configuration register */
;;;1214     dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
000014  6922              LDR      r2,[r4,#0x10]
000016  6813              LDR      r3,[r2,#0]
;;;1215     dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
000018  f42353c0          BIC      r3,r3,#0x1800
;;;1216     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
00001c  6013              STR      r3,[r2,#0]
;;;1217     
;;;1218   #ifdef USB_OTG_FS_CORE
;;;1219     if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
;;;1220     {  
;;;1221       
;;;1222       /* Set Full speed phy */
;;;1223       USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
;;;1224       
;;;1225       /* set Rx FIFO size */
;;;1226       USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
;;;1227       
;;;1228       /* EP0 TX*/
;;;1229       nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
;;;1230       nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
;;;1231       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
;;;1232       
;;;1233       
;;;1234       /* EP1 TX*/
;;;1235       txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
;;;1236       txfifosize.b.depth = TX1_FIFO_FS_SIZE;
;;;1237       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
;;;1238       
;;;1239       
;;;1240       /* EP2 TX*/
;;;1241       txfifosize.b.startaddr += txfifosize.b.depth;
;;;1242       txfifosize.b.depth = TX2_FIFO_FS_SIZE;
;;;1243       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
;;;1244       
;;;1245       
;;;1246       /* EP3 TX*/  
;;;1247       txfifosize.b.startaddr += txfifosize.b.depth;
;;;1248       txfifosize.b.depth = TX3_FIFO_FS_SIZE;
;;;1249       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
;;;1250     }
;;;1251   #endif
;;;1252   #ifdef USB_OTG_HS_CORE
;;;1253     if(pdev->cfg.coreID == USB_OTG_HS_CORE_ID  )
00001e  7ae2              LDRB     r2,[r4,#0xb]
000020  2a00              CMP      r2,#0
000022  d13e              BNE      |L3.162|
;;;1254     {
;;;1255       
;;;1256       /* Set High speed phy */
;;;1257       
;;;1258       if(pdev->cfg.phy_itface  == USB_OTG_ULPI_PHY)
000024  7a22              LDRB     r2,[r4,#8]
000026  2a01              CMP      r2,#1
000028  f00080b0          BEQ.W    |L3.396|
00002c  6922              LDR      r2,[r4,#0x10]
;;;1259       {
;;;1260         USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_HIGH);
;;;1261       }
;;;1262       else /* set High speed phy in Full speed mode */
;;;1263       {
;;;1264         USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_HIGH_IN_FULL);
00002e  f04f0c01          MOV      r12,#1
000032  6813              LDR      r3,[r2,#0]
000034  f36c0301          BFI      r3,r12,#0,#2
000038  6013              STR      r3,[r2,#0]
                  |L3.58|
;;;1265       }
;;;1266       
;;;1267       /* set Rx FIFO size */
;;;1268       USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
00003a  68e3              LDR      r3,[r4,#0xc]
00003c  f44f7200          MOV      r2,#0x200
000040  625a              STR      r2,[r3,#0x24]
;;;1269       
;;;1270       /* EP0 TX*/
;;;1271       nptxfifosize.b.depth     = TX0_FIFO_HS_SIZE;
000042  2380              MOVS     r3,#0x80
000044  f363401f          BFI      r0,r3,#16,#16
000048  f362000f          BFI      r0,r2,#0,#16
;;;1272       nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;
;;;1273       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
00004c  68e2              LDR      r2,[r4,#0xc]
00004e  6290              STR      r0,[r2,#0x28]
;;;1274       
;;;1275       
;;;1276       /* EP1 TX*/
;;;1277       txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
000050  eb004010          ADD      r0,r0,r0,LSR #16
000054  f360010f          BFI      r1,r0,#0,#16
;;;1278       txfifosize.b.depth = TX1_FIFO_HS_SIZE;
000058  f44f70ba          MOV      r0,#0x174
00005c  f360411f          BFI      r1,r0,#16,#16
;;;1279       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
000060  68e0              LDR      r0,[r4,#0xc]
000062  f8c01104          STR      r1,[r0,#0x104]
;;;1280       
;;;1281       
;;;1282       /* EP2 TX*/
;;;1283       txfifosize.b.startaddr += txfifosize.b.depth;
000066  eb014011          ADD      r0,r1,r1,LSR #16
00006a  f360010f          BFI      r1,r0,#0,#16
;;;1284       txfifosize.b.depth = TX2_FIFO_HS_SIZE;
;;;1285       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
00006e  68e0              LDR      r0,[r4,#0xc]
000070  f365411f          BFI      r1,r5,#16,#16         ;1283
000074  f8c01108          STR      r1,[r0,#0x108]
;;;1286       
;;;1287       
;;;1288       /* EP3 TX*/  
;;;1289       txfifosize.b.startaddr += txfifosize.b.depth;
000078  eb014011          ADD      r0,r1,r1,LSR #16
00007c  f360010f          BFI      r1,r0,#0,#16
;;;1290       txfifosize.b.depth = TX3_FIFO_HS_SIZE;
;;;1291       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
000080  68e0              LDR      r0,[r4,#0xc]
000082  f8c0110c          STR      r1,[r0,#0x10c]
;;;1292       
;;;1293       /* EP4 TX*/
;;;1294       txfifosize.b.startaddr += txfifosize.b.depth;
000086  eb014011          ADD      r0,r1,r1,LSR #16
00008a  f360010f          BFI      r1,r0,#0,#16
;;;1295       txfifosize.b.depth = TX4_FIFO_HS_SIZE;
;;;1296       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[3], txfifosize.d32 );
00008e  68e0              LDR      r0,[r4,#0xc]
000090  f8c01110          STR      r1,[r0,#0x110]
;;;1297       
;;;1298       
;;;1299       /* EP5 TX*/  
;;;1300       txfifosize.b.startaddr += txfifosize.b.depth;
000094  eb014011          ADD      r0,r1,r1,LSR #16
000098  f360010f          BFI      r1,r0,#0,#16
;;;1301       txfifosize.b.depth = TX5_FIFO_HS_SIZE;
;;;1302       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[4], txfifosize.d32 );
00009c  68e0              LDR      r0,[r4,#0xc]
00009e  f8c01114          STR      r1,[r0,#0x114]
                  |L3.162|
;;;1303     }
;;;1304   #endif  
;;;1305     /* Flush the FIFOs */
;;;1306     USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
0000a2  2110              MOVS     r1,#0x10
0000a4  2000              MOVS     r0,#0
0000a6  9500              STR      r5,[sp,#0]
0000a8  9a00              LDR      r2,[sp,#0]
0000aa  f0420220          ORR      r2,r2,#0x20
0000ae  9200              STR      r2,[sp,#0]
0000b0  9a00              LDR      r2,[sp,#0]
0000b2  f361128a          BFI      r2,r1,#6,#5
0000b6  9200              STR      r2,[sp,#0]
0000b8  9900              LDR      r1,[sp,#0]
0000ba  68e2              LDR      r2,[r4,#0xc]
0000bc  6111              STR      r1,[r2,#0x10]
0000be  4f51              LDR      r7,|L3.516|
0000c0  68e1              LDR      r1,[r4,#0xc]          ;1268
                  |L3.194|
0000c2  690a              LDR      r2,[r1,#0x10]         ;1268
0000c4  9200              STR      r2,[sp,#0]            ;1268
0000c6  1c40              ADDS     r0,r0,#1              ;1268
0000c8  42b8              CMP      r0,r7                 ;1268
0000ca  d803              BHI      |L3.212|
0000cc  9a00              LDR      r2,[sp,#0]            ;1268
0000ce  f0120f20          TST      r2,#0x20              ;1268
0000d2  d1f6              BNE      |L3.194|
                  |L3.212|
0000d4  2003              MOVS     r0,#3                 ;1268
0000d6  f7fffffe          BL       USB_OTG_BSP_uDelay
0000da  2000              MOVS     r0,#0                 ;1268
0000dc  9500              STR      r5,[sp,#0]            ;1268
0000de  9900              LDR      r1,[sp,#0]            ;1268
0000e0  f0410110          ORR      r1,r1,#0x10           ;1268
0000e4  9100              STR      r1,[sp,#0]            ;1268
0000e6  9900              LDR      r1,[sp,#0]            ;1268
0000e8  68e2              LDR      r2,[r4,#0xc]          ;1268
0000ea  6111              STR      r1,[r2,#0x10]         ;1268
0000ec  68e1              LDR      r1,[r4,#0xc]          ;1268
                  |L3.238|
0000ee  690a              LDR      r2,[r1,#0x10]         ;1268
0000f0  9200              STR      r2,[sp,#0]            ;1268
0000f2  1c40              ADDS     r0,r0,#1              ;1268
0000f4  42b8              CMP      r0,r7                 ;1268
0000f6  d803              BHI      |L3.256|
0000f8  9a00              LDR      r2,[sp,#0]            ;1268
0000fa  f0120f10          TST      r2,#0x10              ;1268
0000fe  d1f6              BNE      |L3.238|
                  |L3.256|
000100  2003              MOVS     r0,#3                 ;1268
000102  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;1307     USB_OTG_FlushRxFifo(pdev);
;;;1308     /* Clear all pending Device Interrupts */
;;;1309     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
000106  6920              LDR      r0,[r4,#0x10]
000108  6105              STR      r5,[r0,#0x10]
;;;1310     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
00010a  6920              LDR      r0,[r4,#0x10]
00010c  6145              STR      r5,[r0,#0x14]
;;;1311     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
00010e  6920              LDR      r0,[r4,#0x10]
000110  f04f38ff          MOV      r8,#0xffffffff
000114  f8c08018          STR      r8,[r0,#0x18]
;;;1312     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
000118  6920              LDR      r0,[r4,#0x10]
00011a  61c5              STR      r5,[r0,#0x1c]
;;;1313     
;;;1314     for (i = 0; i < pdev->cfg.dev_endpoints; i++)
00011c  7861              LDRB     r1,[r4,#1]
00011e  2000              MOVS     r0,#0
;;;1315     {
;;;1316       depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[i]->DIEPCTL);
;;;1317       if (depctl.b.epena)
;;;1318       {
;;;1319         depctl.d32 = 0;
;;;1320         depctl.b.epdis = 1;
;;;1321         depctl.b.snak = 1;
;;;1322       }
;;;1323       else
;;;1324       {
;;;1325         depctl.d32 = 0;
;;;1326       }
;;;1327       USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
;;;1328       USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
;;;1329       USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
000120  27ff              MOVS     r7,#0xff
000122  f04f4c90          MOV      r12,#0x48000000       ;1321
000126  2900              CMP      r1,#0                 ;1314
000128  d911              BLS      |L3.334|
                  |L3.298|
00012a  eb040280          ADD      r2,r4,r0,LSL #2       ;1316
00012e  6993              LDR      r3,[r2,#0x18]         ;1316
000130  6819              LDR      r1,[r3,#0]            ;1316
000132  f0114f00          TST      r1,#0x80000000        ;1317
000136  bf14              ITE      NE                    ;1321
000138  4661              MOVNE    r1,r12                ;1321
00013a  4629              MOVEQ    r1,r5                 ;1325
00013c  6019              STR      r1,[r3,#0]            ;1327
00013e  6991              LDR      r1,[r2,#0x18]         ;1328
000140  610d              STR      r5,[r1,#0x10]         ;1328
000142  6991              LDR      r1,[r2,#0x18]
000144  608f              STR      r7,[r1,#8]
000146  7861              LDRB     r1,[r4,#1]            ;1314
000148  1c40              ADDS     r0,r0,#1              ;1314
00014a  4281              CMP      r1,r0                 ;1314
00014c  d8ed              BHI      |L3.298|
                  |L3.334|
;;;1330     }
;;;1331     for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
00014e  2000              MOVS     r0,#0
000150  b2c9              UXTB     r1,r1
000152  2900              CMP      r1,#0
000154  d911              BLS      |L3.378|
                  |L3.342|
;;;1332     {
;;;1333       USB_OTG_DEPCTL_TypeDef  depctl;
;;;1334       depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[i]->DOEPCTL);
000156  eb040280          ADD      r2,r4,r0,LSL #2
00015a  6d53              LDR      r3,[r2,#0x54]
00015c  6819              LDR      r1,[r3,#0]
;;;1335       if (depctl.b.epena)
00015e  f0114f00          TST      r1,#0x80000000
;;;1336       {
;;;1337         depctl.d32 = 0;
;;;1338         depctl.b.epdis = 1;
;;;1339         depctl.b.snak = 1;
000162  bf14              ITE      NE
000164  4661              MOVNE    r1,r12
;;;1340       }
;;;1341       else
;;;1342       {
;;;1343         depctl.d32 = 0;
000166  4629              MOVEQ    r1,r5
;;;1344       }
;;;1345       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
000168  6019              STR      r1,[r3,#0]
;;;1346       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
00016a  6d51              LDR      r1,[r2,#0x54]
00016c  610d              STR      r5,[r1,#0x10]
;;;1347       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
00016e  6d51              LDR      r1,[r2,#0x54]
000170  608f              STR      r7,[r1,#8]
000172  7861              LDRB     r1,[r4,#1]            ;1331
000174  1c40              ADDS     r0,r0,#1              ;1331
000176  4281              CMP      r1,r0                 ;1331
000178  d8ed              BHI      |L3.342|
                  |L3.378|
;;;1348     }
;;;1349     msk.d32 = 0;
;;;1350     msk.b.txfifoundrn = 1;
;;;1351     USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPMSK, msk.d32, msk.d32);
00017a  6920              LDR      r0,[r4,#0x10]
00017c  6901              LDR      r1,[r0,#0x10]
00017e  f4417180          ORR      r1,r1,#0x100
000182  6101              STR      r1,[r0,#0x10]
;;;1352     
;;;1353     if (pdev->cfg.dma_enable == 1)
000184  78e0              LDRB     r0,[r4,#3]
000186  2801              CMP      r0,#1
000188  d115              BNE      |L3.438|
00018a  e007              B        |L3.412|
                  |L3.396|
00018c  6922              LDR      r2,[r4,#0x10]
00018e  f04f0c00          MOV      r12,#0                ;1260
000192  6813              LDR      r3,[r2,#0]            ;1260
000194  f36c0301          BFI      r3,r12,#0,#2          ;1260
000198  6013              STR      r3,[r2,#0]            ;1260
00019a  e74e              B        |L3.58|
                  |L3.412|
;;;1354     {
;;;1355       dthrctl.d32 = 0;
;;;1356       dthrctl.b.non_iso_thr_en = 1;
;;;1357       dthrctl.b.iso_thr_en = 1;
00019c  2003              MOVS     r0,#3
;;;1358       dthrctl.b.tx_thr_len = 64;
00019e  f36f008a          BFC      r0,#2,#9
0001a2  f5007080          ADD      r0,r0,#0x100
;;;1359       dthrctl.b.rx_thr_en = 1;
0001a6  f4403080          ORR      r0,r0,#0x10000
;;;1360       dthrctl.b.rx_thr_len = 64;
;;;1361       USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DTHRCTL, dthrctl.d32);  
0001aa  6921              LDR      r1,[r4,#0x10]
0001ac  f36f4059          BFC      r0,#17,#9             ;1360
0001b0  f5000000          ADD      r0,r0,#0x800000       ;1360
0001b4  6308              STR      r0,[r1,#0x30]
                  |L3.438|
0001b6  68e0              LDR      r0,[r4,#0xc]
0001b8  6185              STR      r5,[r0,#0x18]
0001ba  68e1              LDR      r1,[r4,#0xc]
0001bc  f06f4080          MVN      r0,#0x40000000
0001c0  6148              STR      r0,[r1,#0x14]
0001c2  68e1              LDR      r1,[r4,#0xc]
0001c4  f8c18004          STR      r8,[r1,#4]
0001c8  68e1              LDR      r1,[r4,#0xc]
0001ca  6148              STR      r0,[r1,#0x14]
0001cc  68e1              LDR      r1,[r4,#0xc]
0001ce  480e              LDR      r0,|L3.520|
0001d0  6188              STR      r0,[r1,#0x18]
0001d2  78e0              LDRB     r0,[r4,#3]
0001d4  2800              CMP      r0,#0
0001d6  bf08              IT       EQ
0001d8  2510              MOVEQ    r5,#0x10
0001da  f4452087          ORR      r0,r5,#0x43800
0001de  f4402000          ORR      r0,r0,#0x80000
0001e2  68e1              LDR      r1,[r4,#0xc]
0001e4  f0400008          ORR      r0,r0,#8
0001e8  f4401040          ORR      r0,r0,#0x300000
0001ec  f0400004          ORR      r0,r0,#4
0001f0  698a              LDR      r2,[r1,#0x18]
0001f2  f0404080          ORR      r0,r0,#0x40000000
0001f6  4382              BICS     r2,r2,r0
0001f8  4310              ORRS     r0,r0,r2
0001fa  6188              STR      r0,[r1,#0x18]
;;;1362     }
;;;1363     USB_OTG_EnableDevInt(pdev);
;;;1364     return status;
0001fc  4630              MOV      r0,r6
;;;1365   }
0001fe  e8bd83f8          POP      {r3-r9,pc}
;;;1366   
                          ENDP

000202  0000              DCW      0x0000
                  |L3.516|
                          DCD      0x00030d40
                  |L3.520|
                          DCD      0x80000800

                          AREA ||i.USB_OTG_DisableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_DisableGlobalInt PROC
;;;446    */
;;;447    USB_OTG_STS USB_OTG_DisableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;448    {
;;;449      USB_OTG_STS status = USB_OTG_OK;
;;;450      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;451      ahbcfg.d32 = 0;
000002  2200              MOVS     r2,#0
;;;452      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
;;;453      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
000004  6881              LDR      r1,[r0,#8]
000006  f0210101          BIC      r1,r1,#1
00000a  6081              STR      r1,[r0,#8]
;;;454      return status;
00000c  4610              MOV      r0,r2
;;;455    }
00000e  4770              BX       lr
;;;456    
                          ENDP


                          AREA ||i.USB_OTG_EP0Activate||, CODE, READONLY, ALIGN=1

                  USB_OTG_EP0Activate PROC
;;;1447   */
;;;1448   USB_OTG_STS  USB_OTG_EP0Activate(USB_OTG_CORE_HANDLE *pdev)
000000  6901              LDR      r1,[r0,#0x10]
;;;1449   {
;;;1450     USB_OTG_STS             status = USB_OTG_OK;
000002  f04f0c00          MOV      r12,#0
;;;1451     USB_OTG_DSTS_TypeDef    dsts;
;;;1452     USB_OTG_DEPCTL_TypeDef  diepctl;
;;;1453     USB_OTG_DCTL_TypeDef    dctl;
;;;1454     
;;;1455     dctl.d32 = 0;
;;;1456     /* Read the Device Status and Endpoint 0 Control registers */
;;;1457     dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
000006  6889              LDR      r1,[r1,#8]
;;;1458     diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
000008  6983              LDR      r3,[r0,#0x18]
00000a  681a              LDR      r2,[r3,#0]
;;;1459     /* Set the MPS of the IN EP based on the enumeration speed */
;;;1460     switch (dsts.b.enumspd)
00000c  f3c10141          UBFX     r1,r1,#1,#2
000010  2900              CMP      r1,#0
000012  bf18              IT       NE
000014  2901              CMPNE    r1,#1
000016  d007              BEQ      |L5.40|
000018  2902              CMP      r1,#2
;;;1461     {
;;;1462     case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
;;;1463     case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
;;;1464     case DSTS_ENUMSPD_FS_PHY_48MHZ:
;;;1465       diepctl.b.mps = DEP0CTL_MPS_64;
;;;1466       break;
;;;1467     case DSTS_ENUMSPD_LS_PHY_6MHZ:
;;;1468       diepctl.b.mps = DEP0CTL_MPS_8;
00001a  bf04              ITT      EQ
00001c  f36f020a          BFCEQ    r2,#0,#11
000020  1cd2              ADDEQ    r2,r2,#3
000022  d003              BEQ      |L5.44|
000024  2903              CMP      r1,#3                 ;1460
000026  d101              BNE      |L5.44|
                  |L5.40|
000028  f36f020a          BFC      r2,#0,#11             ;1465
                  |L5.44|
;;;1469       break;
;;;1470     }
;;;1471     USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
00002c  601a              STR      r2,[r3,#0]
;;;1472     dctl.b.cgnpinnak = 1;
;;;1473     USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
00002e  6900              LDR      r0,[r0,#0x10]
000030  6841              LDR      r1,[r0,#4]
000032  f4417180          ORR      r1,r1,#0x100
000036  6041              STR      r1,[r0,#4]
;;;1474     return status;
000038  4660              MOV      r0,r12
;;;1475   }
00003a  4770              BX       lr
;;;1476   
                          ENDP


                          AREA ||i.USB_OTG_EP0StartXfer||, CODE, READONLY, ALIGN=1

                  USB_OTG_EP0StartXfer PROC
;;;1707   */
;;;1708   USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b470              PUSH     {r4-r6}
;;;1709   {
;;;1710     USB_OTG_STS                 status = USB_OTG_OK;
;;;1711     USB_OTG_DEPCTL_TypeDef      depctl;
;;;1712     USB_OTG_DEP0XFRSIZ_TypeDef  deptsiz;
;;;1713     USB_OTG_INEPREGS          *in_regs;
;;;1714     uint32_t fifoemptymsk = 0;
;;;1715     
;;;1716     depctl.d32   = 0;
;;;1717     deptsiz.d32  = 0;
;;;1718     /* IN endpoint */
;;;1719     if (ep->is_in == 1)
000002  784b              LDRB     r3,[r1,#1]
000004  2500              MOVS     r5,#0                 ;1710
000006  694a              LDR      r2,[r1,#0x14]
000008  2b01              CMP      r3,#1
00000a  d017              BEQ      |L6.60|
;;;1720     {
;;;1721       in_regs = pdev->regs.INEP_REGS[0];
;;;1722       depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
;;;1723       deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
;;;1724       /* Zero Length Packet? */
;;;1725       if (ep->xfer_len == 0)
;;;1726       {
;;;1727         deptsiz.b.xfersize = 0;
;;;1728         deptsiz.b.pktcnt = 1;
;;;1729         
;;;1730       }
;;;1731       else
;;;1732       {
;;;1733         if (ep->xfer_len > ep->maxpacket)
;;;1734         {
;;;1735           ep->xfer_len = ep->maxpacket;
;;;1736           deptsiz.b.xfersize = ep->maxpacket;
;;;1737         }
;;;1738         else
;;;1739         {
;;;1740           deptsiz.b.xfersize = ep->xfer_len;
;;;1741         }
;;;1742         deptsiz.b.pktcnt = 1;
;;;1743       }
;;;1744       USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
;;;1745       
;;;1746       if (pdev->cfg.dma_enable == 1)
;;;1747       {
;;;1748         USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
;;;1749       }
;;;1750       
;;;1751       /* EP enable, IN data in FIFO */
;;;1752       depctl.b.cnak = 1;
;;;1753       depctl.b.epena = 1;
;;;1754       USB_OTG_WRITE_REG32(&in_regs->DIEPCTL, depctl.d32);
;;;1755       
;;;1756       
;;;1757       
;;;1758       if (pdev->cfg.dma_enable == 0)
;;;1759       {
;;;1760         /* Enable the Tx FIFO Empty Interrupt for this EP */
;;;1761         if (ep->xfer_len > 0)
;;;1762         {
;;;1763           {
;;;1764             fifoemptymsk |= 1 << ep->num;
;;;1765             USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
;;;1766           }
;;;1767         }
;;;1768       }
;;;1769     }
;;;1770     else
;;;1771     {
;;;1772       /* OUT endpoint */
;;;1773       depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
00000c  780b              LDRB     r3,[r1,#0]
00000e  eb000c83          ADD      r12,r0,r3,LSL #2
000012  f8dc3054          LDR      r3,[r12,#0x54]
000016  681c              LDR      r4,[r3,#0]
;;;1774       deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
000018  691b              LDR      r3,[r3,#0x10]
;;;1775       /* Program the transfer size and packet count as follows:
;;;1776       * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
;;;1777       * pktcnt = N           */
;;;1778       if (ep->xfer_len == 0)
00001a  2a00              CMP      r2,#0
00001c  d042              BEQ      |L6.164|
;;;1779       {
;;;1780         deptsiz.b.xfersize = ep->maxpacket;
;;;1781         deptsiz.b.pktcnt = 1;
;;;1782       }
;;;1783       else
;;;1784       {
;;;1785         ep->xfer_len = ep->maxpacket;
00001e  688a              LDR      r2,[r1,#8]
;;;1786         deptsiz.b.xfersize = ep->maxpacket;
;;;1787         deptsiz.b.pktcnt = 1;
000020  614a              STR      r2,[r1,#0x14]
000022  f3620306          BFI      r3,r2,#0,#7           ;1786
000026  f42312c0          BIC      r2,r3,#0x180000
00002a  f5022200          ADD      r2,r2,#0x80000
                  |L6.46|
;;;1788       }
;;;1789       USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
00002e  f8dc3054          LDR      r3,[r12,#0x54]
000032  611a              STR      r2,[r3,#0x10]
;;;1790       if (pdev->cfg.dma_enable == 1)
000034  78c2              LDRB     r2,[r0,#3]
000036  2a01              CMP      r2,#1
000038  d142              BNE      |L6.192|
00003a  e03b              B        |L6.180|
                  |L6.60|
00003c  6983              LDR      r3,[r0,#0x18]         ;1722
00003e  681e              LDR      r6,[r3,#0]            ;1722
000040  f8d3c010          LDR      r12,[r3,#0x10]        ;1723
000044  2a00              CMP      r2,#0                 ;1725
000046  bf04              ITT      EQ                    ;1728
000048  f02c027f          BICEQ    r2,r12,#0x7f          ;1728
00004c  f42212c0          BICEQ    r2,r2,#0x180000       ;1728
000050  d009              BEQ      |L6.102|
000052  688c              LDR      r4,[r1,#8]            ;1733
000054  42a2              CMP      r2,r4                 ;1733
000056  bf86              ITTE     HI                    ;1736
000058  f3640c06          BFIHI    r12,r4,#0,#7          ;1736
00005c  614c              STRHI    r4,[r1,#0x14]         ;1736
00005e  f3620c06          BFILS    r12,r2,#0,#7          ;1740
000062  f42c12c0          BIC      r2,r12,#0x180000      ;1742
                  |L6.102|
000066  f5022200          ADD      r2,r2,#0x80000        ;1742
00006a  611a              STR      r2,[r3,#0x10]         ;1744
00006c  78c2              LDRB     r2,[r0,#3]            ;1746
00006e  2a01              CMP      r2,#1                 ;1746
000070  d108              BNE      |L6.132|
000072  f891c000          LDRB     r12,[r1,#0]           ;1748
000076  690a              LDR      r2,[r1,#0x10]         ;1748
000078  eb000c8c          ADD      r12,r0,r12,LSL #2     ;1748
00007c  f8dcc018          LDR      r12,[r12,#0x18]       ;1748
000080  f8cc2014          STR      r2,[r12,#0x14]        ;1748
                  |L6.132|
000084  f0464204          ORR      r2,r6,#0x84000000     ;1753
000088  601a              STR      r2,[r3,#0]            ;1754
00008a  78c2              LDRB     r2,[r0,#3]            ;1758
00008c  b9fa              CBNZ     r2,|L6.206|
00008e  694a              LDR      r2,[r1,#0x14]         ;1761
000090  b1ea              CBZ      r2,|L6.206|
000092  7809              LDRB     r1,[r1,#0]            ;1764
000094  6900              LDR      r0,[r0,#0x10]         ;1765
000096  2201              MOVS     r2,#1                 ;1764
000098  fa02f101          LSL      r1,r2,r1              ;1764
00009c  6b42              LDR      r2,[r0,#0x34]         ;1765
00009e  4311              ORRS     r1,r1,r2              ;1765
0000a0  6341              STR      r1,[r0,#0x34]         ;1765
0000a2  e014              B        |L6.206|
                  |L6.164|
0000a4  7a0a              LDRB     r2,[r1,#8]            ;1780
0000a6  f3620306          BFI      r3,r2,#0,#7           ;1780
0000aa  f42312c0          BIC      r2,r3,#0x180000       ;1781
0000ae  f5022200          ADD      r2,r2,#0x80000        ;1781
0000b2  e7bc              B        |L6.46|
                  |L6.180|
;;;1791       {
;;;1792         USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
0000b4  780b              LDRB     r3,[r1,#0]
0000b6  690a              LDR      r2,[r1,#0x10]
0000b8  eb000383          ADD      r3,r0,r3,LSL #2
0000bc  6d5b              LDR      r3,[r3,#0x54]
0000be  615a              STR      r2,[r3,#0x14]
                  |L6.192|
;;;1793       }
;;;1794       /* EP enable */
;;;1795       depctl.b.cnak = 1;
;;;1796       depctl.b.epena = 1;
;;;1797       USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
0000c0  7809              LDRB     r1,[r1,#0]
0000c2  f0444204          ORR      r2,r4,#0x84000000     ;1796
0000c6  eb000081          ADD      r0,r0,r1,LSL #2
0000ca  6d40              LDR      r0,[r0,#0x54]
0000cc  6002              STR      r2,[r0,#0]
                  |L6.206|
;;;1798       
;;;1799     }
;;;1800     return status;
0000ce  4628              MOV      r0,r5
;;;1801   }
0000d0  bc70              POP      {r4-r6}
0000d2  4770              BX       lr
;;;1802   
                          ENDP


                          AREA ||i.USB_OTG_EP0_OutStart||, CODE, READONLY, ALIGN=2

                  USB_OTG_EP0_OutStart PROC
;;;1919   */
;;;1920   void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
000000  6d42              LDR      r2,[r0,#0x54]
;;;1921   {
;;;1922     USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
;;;1923     doeptsize0.d32 = 0;
;;;1924     doeptsize0.b.supcnt = 3;
;;;1925     doeptsize0.b.pktcnt = 1;
;;;1926     doeptsize0.b.xfersize = 8 * 3;
000002  4908              LDR      r1,|L7.36|
;;;1927     USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPTSIZ, doeptsize0.d32 );
000004  6111              STR      r1,[r2,#0x10]
;;;1928     
;;;1929     if (pdev->cfg.dma_enable == 1)
000006  78c1              LDRB     r1,[r0,#3]
000008  2901              CMP      r1,#1
;;;1930     {
;;;1931       USB_OTG_DEPCTL_TypeDef  doepctl;
;;;1932       doepctl.d32 = 0;
;;;1933       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
;;;1934                           (uint32_t)&pdev->dev.setup_packet);
;;;1935       
;;;1936       /* EP enable */
;;;1937       doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
;;;1938       doepctl.b.epena = 1;
;;;1939       doepctl.d32 = 0x80008000;
;;;1940       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
;;;1941     }
;;;1942   }
00000a  bf18              IT       NE
00000c  4770              BXNE     lr
00000e  f20051cc          ADD      r1,r0,#0x5cc          ;1933
000012  6d42              LDR      r2,[r0,#0x54]         ;1933
000014  6151              STR      r1,[r2,#0x14]         ;1933
000016  6d40              LDR      r0,[r0,#0x54]         ;1937
000018  6801              LDR      r1,[r0,#0]            ;1937
00001a  f04f2180          MOV      r1,#0x80008000        ;1939
00001e  6001              STR      r1,[r0,#0]            ;1940
000020  4770              BX       lr
;;;1943   
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      0xc0080018

                          AREA ||i.USB_OTG_EPActivate||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPActivate PROC
;;;1482   */
;;;1483   USB_OTG_STS USB_OTG_EPActivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b470              PUSH     {r4-r6}
;;;1484   {
;;;1485     USB_OTG_STS status = USB_OTG_OK;
;;;1486     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1487     USB_OTG_DAINT_TypeDef  daintmsk;
;;;1488     __IO uint32_t *addr;
;;;1489     
;;;1490     
;;;1491     depctl.d32 = 0;
;;;1492     daintmsk.d32 = 0;
;;;1493     /* Read DEPCTLn register */
;;;1494     if (ep->is_in == 1)
;;;1495     {
;;;1496       addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
000002  f891c000          LDRB     r12,[r1,#0]
000006  2400              MOVS     r4,#0                 ;1485
000008  784e              LDRB     r6,[r1,#1]            ;1494
00000a  2501              MOVS     r5,#1                 ;1494
00000c  eb00028c          ADD      r2,r0,r12,LSL #2
;;;1497       daintmsk.ep.in = 1 << ep->num;
000010  fa05fc0c          LSL      r12,r5,r12
000014  4623              MOV      r3,r4                 ;1491
000016  2e01              CMP      r6,#1                 ;1494
000018  bf07              ITTEE    EQ                    ;1496
00001a  6992              LDREQ    r2,[r2,#0x18]         ;1496
00001c  f36c030f          BFIEQ    r3,r12,#0,#16         ;1496
;;;1498     }
;;;1499     else
;;;1500     {
;;;1501       addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
000020  6d52              LDRNE    r2,[r2,#0x54]
000022  f36c431f          BFINE    r3,r12,#16,#16
;;;1502       daintmsk.ep.out = 1 << ep->num;
;;;1503     }
;;;1504     /* If the EP is already active don't change the EP Control
;;;1505     * register. */
;;;1506     depctl.d32 = USB_OTG_READ_REG32(addr);
000026  f8d2c000          LDR      r12,[r2,#0]
;;;1507     if (!depctl.b.usbactep)
00002a  f41c4f00          TST      r12,#0x8000
00002e  d10d              BNE      |L8.76|
;;;1508     {
;;;1509       depctl.b.mps    = ep->maxpacket;
000030  890d              LDRH     r5,[r1,#8]
000032  f3650c0a          BFI      r12,r5,#0,#11
;;;1510       depctl.b.eptype = ep->type;
000036  78cd              LDRB     r5,[r1,#3]
;;;1511       depctl.b.txfnum = ep->tx_fifo_num;
000038  7989              LDRB     r1,[r1,#6]
00003a  f3654c93          BFI      r12,r5,#18,#2         ;1510
00003e  f3615c99          BFI      r12,r1,#22,#4
;;;1512       depctl.b.setd0pid = 1;
;;;1513       depctl.b.usbactep = 1;
000042  f44c4100          ORR      r1,r12,#0x8000
000046  f0415180          ORR      r1,r1,#0x10000000
;;;1514       USB_OTG_WRITE_REG32(addr, depctl.d32);
00004a  6011              STR      r1,[r2,#0]
                  |L8.76|
;;;1515     }
;;;1516     /* Enable the Interrupt for this EP */
;;;1517   #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED
;;;1518     if((ep->num == 1)&&(pdev->cfg.coreID == USB_OTG_HS_CORE_ID))
;;;1519     {
;;;1520       USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, 0, daintmsk.d32);
;;;1521     }
;;;1522     else
;;;1523   #endif   
;;;1524       USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, 0, daintmsk.d32);
00004c  6900              LDR      r0,[r0,#0x10]
00004e  69c1              LDR      r1,[r0,#0x1c]
000050  4319              ORRS     r1,r1,r3
000052  61c1              STR      r1,[r0,#0x1c]
;;;1525     return status;
000054  4620              MOV      r0,r4
;;;1526   }
000056  bc70              POP      {r4-r6}
000058  4770              BX       lr
;;;1527   
                          ENDP


                          AREA ||i.USB_OTG_EPClearStall||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPClearStall PROC
;;;1844   */
;;;1845   USB_OTG_STS USB_OTG_EPClearStall(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  f891c001          LDRB     r12,[r1,#1]
;;;1846   {
;;;1847     USB_OTG_STS status = USB_OTG_OK;
;;;1848     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1849     __IO uint32_t *depctl_addr;
;;;1850     
;;;1851     depctl.d32 = 0;
;;;1852     
;;;1853     if (ep->is_in == 1)
;;;1854     {
;;;1855       depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
000004  780a              LDRB     r2,[r1,#0]
000006  2300              MOVS     r3,#0                 ;1847
000008  eb000082          ADD      r0,r0,r2,LSL #2
00000c  f1bc0f01          CMP      r12,#1                ;1853
000010  bf0c              ITE      EQ
000012  6980              LDREQ    r0,[r0,#0x18]
;;;1856     }
;;;1857     else
;;;1858     {
;;;1859       depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
000014  6d40              LDRNE    r0,[r0,#0x54]
;;;1860     }
;;;1861     depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
000016  6802              LDR      r2,[r0,#0]
;;;1862     /* clear the stall bits */
;;;1863     depctl.b.stall = 0;
;;;1864     if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
000018  78c9              LDRB     r1,[r1,#3]
00001a  f4221200          BIC      r2,r2,#0x200000       ;1863
00001e  2903              CMP      r1,#3
000020  bf14              ITE      NE
000022  2902              CMPNE    r1,#2
;;;1865     {
;;;1866       depctl.b.setd0pid = 1; /* DATA0 */
000024  f0425280          ORREQ    r2,r2,#0x10000000
;;;1867     }
;;;1868     USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
000028  6002              STR      r2,[r0,#0]
;;;1869     return status;
00002a  4618              MOV      r0,r3
;;;1870   }
00002c  4770              BX       lr
;;;1871   
                          ENDP


                          AREA ||i.USB_OTG_EPDeactivate||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPDeactivate PROC
;;;1533   */
;;;1534   USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b430              PUSH     {r4,r5}
;;;1535   {
;;;1536     USB_OTG_STS status = USB_OTG_OK;
;;;1537     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1538     USB_OTG_DAINT_TypeDef  daintmsk;
;;;1539     __IO uint32_t *addr;
;;;1540     
;;;1541     depctl.d32 = 0;
;;;1542     daintmsk.d32 = 0;  
;;;1543     /* Read DEPCTLn register */
;;;1544     if (ep->is_in == 1)
000002  784d              LDRB     r5,[r1,#1]
000004  4603              MOV      r3,r0                 ;1535
;;;1545     {
;;;1546       addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
000006  7809              LDRB     r1,[r1,#0]
000008  2401              MOVS     r4,#1                 ;1544
00000a  eb030281          ADD      r2,r3,r1,LSL #2
00000e  f04f0c00          MOV      r12,#0                ;1541
;;;1547       daintmsk.ep.in = 1 << ep->num;
000012  fa04f101          LSL      r1,r4,r1
000016  4660              MOV      r0,r12                ;1542
000018  2d01              CMP      r5,#1                 ;1544
00001a  bf07              ITTEE    EQ                    ;1546
00001c  6992              LDREQ    r2,[r2,#0x18]         ;1546
00001e  f361000f          BFIEQ    r0,r1,#0,#16          ;1546
;;;1548     }
;;;1549     else
;;;1550     {
;;;1551       addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
000022  6d52              LDRNE    r2,[r2,#0x54]
000024  f361401f          BFINE    r0,r1,#16,#16
;;;1552       daintmsk.ep.out = 1 << ep->num;
;;;1553     }
;;;1554     depctl.b.usbactep = 0;
;;;1555     USB_OTG_WRITE_REG32(addr, depctl.d32);
000028  f8c2c000          STR      r12,[r2,#0]
;;;1556     /* Disable the Interrupt for this EP */
;;;1557     
;;;1558   #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED
;;;1559     if((ep->num == 1)&&(pdev->cfg.coreID == USB_OTG_HS_CORE_ID))
;;;1560     {
;;;1561       USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
;;;1562     }
;;;1563     else
;;;1564   #endif    
;;;1565       USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
00002c  6919              LDR      r1,[r3,#0x10]
00002e  69ca              LDR      r2,[r1,#0x1c]
000030  ea220000          BIC      r0,r2,r0
000034  61c8              STR      r0,[r1,#0x1c]
;;;1566     return status;
;;;1567   }
000036  bc30              POP      {r4,r5}
000038  4660              MOV      r0,r12                ;1566
00003a  4770              BX       lr
;;;1568   
                          ENDP


                          AREA ||i.USB_OTG_EPSetStall||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPSetStall PROC
;;;1808   */
;;;1809   USB_OTG_STS USB_OTG_EPSetStall(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  784b              LDRB     r3,[r1,#1]
;;;1810   {
;;;1811     USB_OTG_STS status = USB_OTG_OK;
;;;1812     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1813     __IO uint32_t *depctl_addr;
;;;1814     
;;;1815     depctl.d32 = 0;
;;;1816     if (ep->is_in == 1)
;;;1817     {
;;;1818       depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
000002  7809              LDRB     r1,[r1,#0]
000004  2200              MOVS     r2,#0                 ;1811
000006  eb000081          ADD      r0,r0,r1,LSL #2
00000a  2b01              CMP      r3,#1                 ;1816
00000c  d006              BEQ      |L11.28|
;;;1819       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
;;;1820       /* set the disable and stall bits */
;;;1821       if (depctl.b.epena)
;;;1822       {
;;;1823         depctl.b.epdis = 1;
;;;1824       }
;;;1825       depctl.b.stall = 1;
;;;1826       USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
;;;1827     }
;;;1828     else
;;;1829     {
;;;1830       depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
00000e  6d40              LDR      r0,[r0,#0x54]
;;;1831       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
000010  6801              LDR      r1,[r0,#0]
;;;1832       /* set the stall bit */
;;;1833       depctl.b.stall = 1;
000012  f4411100          ORR      r1,r1,#0x200000
;;;1834       USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
000016  6001              STR      r1,[r0,#0]
                  |L11.24|
;;;1835     }
;;;1836     return status;
000018  4610              MOV      r0,r2
;;;1837   }
00001a  4770              BX       lr
                  |L11.28|
00001c  6981              LDR      r1,[r0,#0x18]         ;1819
00001e  6808              LDR      r0,[r1,#0]            ;1819
000020  f0104f00          TST      r0,#0x80000000        ;1821
000024  bf18              IT       NE                    ;1823
000026  f0404080          ORRNE    r0,r0,#0x40000000     ;1823
00002a  f4401000          ORR      r0,r0,#0x200000       ;1825
00002e  6008              STR      r0,[r1,#0]            ;1826
000030  e7f2              B        |L11.24|
;;;1838   
                          ENDP


                          AREA ||i.USB_OTG_EPStartXfer||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPStartXfer PROC
;;;1575   */
;;;1576   USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b470              PUSH     {r4-r6}
;;;1577   {
;;;1578     USB_OTG_STS status = USB_OTG_OK;
;;;1579     USB_OTG_DEPCTL_TypeDef     depctl;
;;;1580     USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
;;;1581     USB_OTG_DSTS_TypeDef       dsts;    
;;;1582     uint32_t fifoemptymsk = 0;  
;;;1583     
;;;1584     depctl.d32 = 0;
;;;1585     deptsiz.d32 = 0;
;;;1586     /* IN endpoint */
;;;1587     if (ep->is_in == 1)
000002  f891c001          LDRB     r12,[r1,#1]
;;;1588     {
;;;1589       depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
000006  780b              LDRB     r3,[r1,#0]
000008  2500              MOVS     r5,#0                 ;1578
00000a  694a              LDR      r2,[r1,#0x14]         ;1587
00000c  eb000383          ADD      r3,r0,r3,LSL #2
000010  f1bc0f01          CMP      r12,#1                ;1587
000014  d019              BEQ      |L12.74|
;;;1590       deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
;;;1591       /* Zero Length Packet? */
;;;1592       if (ep->xfer_len == 0)
;;;1593       {
;;;1594         deptsiz.b.xfersize = 0;
;;;1595         deptsiz.b.pktcnt = 1;
;;;1596       }
;;;1597       else
;;;1598       {
;;;1599         /* Program the transfer size and packet count
;;;1600         * as follows: xfersize = N * maxpacket +
;;;1601         * short_packet pktcnt = N + (short_packet
;;;1602         * exist ? 1 : 0)
;;;1603         */
;;;1604         deptsiz.b.xfersize = ep->xfer_len;
;;;1605         deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
;;;1606         
;;;1607         if (ep->type == EP_TYPE_ISOC)
;;;1608         {
;;;1609           deptsiz.b.mc = 1;
;;;1610         }       
;;;1611       }
;;;1612       USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
;;;1613       
;;;1614       if (pdev->cfg.dma_enable == 1)
;;;1615       {
;;;1616         USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
;;;1617       }
;;;1618       else
;;;1619       {
;;;1620         if (ep->type != EP_TYPE_ISOC)
;;;1621         {
;;;1622           /* Enable the Tx FIFO Empty Interrupt for this EP */
;;;1623           if (ep->xfer_len > 0)
;;;1624           {
;;;1625             fifoemptymsk = 1 << ep->num;
;;;1626             USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
;;;1627           }
;;;1628         }
;;;1629       }
;;;1630       
;;;1631       
;;;1632       if (ep->type == EP_TYPE_ISOC)
;;;1633       {
;;;1634         dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
;;;1635         
;;;1636         if (((dsts.b.soffn)&0x1) == 0)
;;;1637         {
;;;1638           depctl.b.setd1pid = 1;
;;;1639         }
;;;1640         else
;;;1641         {
;;;1642           depctl.b.setd0pid = 1;
;;;1643         }
;;;1644       } 
;;;1645       
;;;1646       /* EP enable, IN data in FIFO */
;;;1647       depctl.b.cnak = 1;
;;;1648       depctl.b.epena = 1;
;;;1649       USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
;;;1650       
;;;1651       if (ep->type == EP_TYPE_ISOC)
;;;1652       {
;;;1653         USB_OTG_WritePacket(pdev, ep->xfer_buff, ep->num, ep->xfer_len);   
;;;1654       }    
;;;1655     }
;;;1656     else
;;;1657     {
;;;1658       /* OUT endpoint */
;;;1659       depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
000016  f8d3c054          LDR      r12,[r3,#0x54]
00001a  f8dc3000          LDR      r3,[r12,#0]
;;;1660       deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
00001e  f8dc4010          LDR      r4,[r12,#0x10]
;;;1661       /* Program the transfer size and packet count as follows:
;;;1662       * pktcnt = N
;;;1663       * xfersize = N * maxpacket
;;;1664       */
;;;1665       if (ep->xfer_len == 0)
000022  2a00              CMP      r2,#0
000024  d075              BEQ      |L12.274|
;;;1666       {
;;;1667         deptsiz.b.xfersize = ep->maxpacket;
;;;1668         deptsiz.b.pktcnt = 1;
;;;1669       }
;;;1670       else
;;;1671       {
;;;1672         deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
000026  688e              LDR      r6,[r1,#8]
000028  4432              ADD      r2,r2,r6
00002a  1e52              SUBS     r2,r2,#1
00002c  fbb2f2f6          UDIV     r2,r2,r6
000030  f36244dc          BFI      r4,r2,#19,#10
;;;1673         deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
000034  f3c442c9          UBFX     r2,r4,#19,#10
000038  4372              MULS     r2,r6,r2
00003a  f3620412          BFI      r4,r2,#0,#19
                  |L12.62|
;;;1674       }
;;;1675       USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
00003e  f8cc4010          STR      r4,[r12,#0x10]
;;;1676       
;;;1677       if (pdev->cfg.dma_enable == 1)
000042  78c2              LDRB     r2,[r0,#3]
000044  2a01              CMP      r2,#1
000046  d175              BNE      |L12.308|
000048  e06b              B        |L12.290|
                  |L12.74|
00004a  699c              LDR      r4,[r3,#0x18]         ;1589
00004c  f8d4c000          LDR      r12,[r4,#0]           ;1589
000050  6923              LDR      r3,[r4,#0x10]         ;1590
000052  b182              CBZ      r2,|L12.118|
000054  688e              LDR      r6,[r1,#8]            ;1605
000056  f3620312          BFI      r3,r2,#0,#19          ;1604
00005a  4432              ADD      r2,r2,r6              ;1605
00005c  1e52              SUBS     r2,r2,#1              ;1605
00005e  fbb2f2f6          UDIV     r2,r2,r6              ;1605
000062  f36243dc          BFI      r3,r2,#19,#10         ;1605
000066  78ca              LDRB     r2,[r1,#3]            ;1607
000068  2a01              CMP      r2,#1                 ;1607
00006a  bf04              ITT      EQ                    ;1609
00006c  f02342c0          BICEQ    r2,r3,#0x60000000     ;1609
000070  f1025300          ADDEQ    r3,r2,#0x20000000     ;1609
000074  e005              B        |L12.130|
                  |L12.118|
000076  f36f0312          BFC      r3,#0,#19             ;1594
00007a  f36f43dc          BFC      r3,#19,#10            ;1595
00007e  f5032300          ADD      r3,r3,#0x80000        ;1595
                  |L12.130|
000082  6123              STR      r3,[r4,#0x10]         ;1612
000084  78c2              LDRB     r2,[r0,#3]            ;1614
000086  2a01              CMP      r2,#1                 ;1614
000088  d019              BEQ      |L12.190|
00008a  78ca              LDRB     r2,[r1,#3]            ;1620
00008c  2a01              CMP      r2,#1                 ;1620
00008e  d01d              BEQ      |L12.204|
000090  694a              LDR      r2,[r1,#0x14]         ;1623
000092  b14a              CBZ      r2,|L12.168|
000094  780a              LDRB     r2,[r1,#0]            ;1625
000096  2301              MOVS     r3,#1                 ;1625
000098  4093              LSLS     r3,r3,r2              ;1625
00009a  6902              LDR      r2,[r0,#0x10]         ;1626
00009c  6b54              LDR      r4,[r2,#0x34]         ;1626
00009e  4323              ORRS     r3,r3,r4              ;1626
0000a0  6353              STR      r3,[r2,#0x34]         ;1626
                  |L12.162|
0000a2  78ca              LDRB     r2,[r1,#3]            ;1632
0000a4  2a01              CMP      r2,#1                 ;1632
0000a6  d011              BEQ      |L12.204|
                  |L12.168|
0000a8  780b              LDRB     r3,[r1,#0]            ;1649
0000aa  f04c4204          ORR      r2,r12,#0x84000000    ;1648
0000ae  eb000383          ADD      r3,r0,r3,LSL #2       ;1649
0000b2  699b              LDR      r3,[r3,#0x18]         ;1649
0000b4  601a              STR      r2,[r3,#0]            ;1649
0000b6  78ca              LDRB     r2,[r1,#3]            ;1651
0000b8  2a01              CMP      r2,#1                 ;1651
0000ba  d145              BNE      |L12.328|
0000bc  e010              B        |L12.224|
                  |L12.190|
0000be  780b              LDRB     r3,[r1,#0]            ;1616
0000c0  690a              LDR      r2,[r1,#0x10]         ;1616
0000c2  eb000383          ADD      r3,r0,r3,LSL #2       ;1616
0000c6  699b              LDR      r3,[r3,#0x18]         ;1616
0000c8  615a              STR      r2,[r3,#0x14]         ;1616
0000ca  e7ea              B        |L12.162|
                  |L12.204|
0000cc  6902              LDR      r2,[r0,#0x10]         ;1634
0000ce  6892              LDR      r2,[r2,#8]            ;1634
0000d0  f4127f80          TST      r2,#0x100             ;1636
0000d4  bf0c              ITE      EQ                    ;1638
0000d6  f04c5c00          ORREQ    r12,r12,#0x20000000   ;1638
0000da  f04c5c80          ORRNE    r12,r12,#0x10000000   ;1642
0000de  e7e3              B        |L12.168|
                  |L12.224|
0000e0  f891c000          LDRB     r12,[r1,#0]           ;1653
0000e4  68ca              LDR      r2,[r1,#0xc]          ;1653
0000e6  8a89              LDRH     r1,[r1,#0x14]         ;1653
0000e8  b28b              UXTH     r3,r1                 ;1653
0000ea  78c1              LDRB     r1,[r0,#3]            ;1653
0000ec  bb61              CBNZ     r1,|L12.328|
0000ee  eb00008c          ADD      r0,r0,r12,LSL #2      ;1653
0000f2  1cdb              ADDS     r3,r3,#3              ;1653
0000f4  2100              MOVS     r1,#0                 ;1653
0000f6  089b              LSRS     r3,r3,#2              ;1653
0000f8  f8d000d0          LDR      r0,[r0,#0xd0]         ;1653
0000fc  2b00              CMP      r3,#0                 ;1653
0000fe  d923              BLS      |L12.328|
                  |L12.256|
000100  f852cb04          LDR      r12,[r2],#4           ;1653
000104  f8c0c000          STR      r12,[r0,#0]           ;1653
000108  1c49              ADDS     r1,r1,#1              ;1653
00010a  428b              CMP      r3,r1                 ;1653
00010c  d8f8              BHI      |L12.256|
00010e  e01b              B        |L12.328|
000110  e7ff              B        |L12.274|
                  |L12.274|
000112  688a              LDR      r2,[r1,#8]            ;1667
000114  f3620412          BFI      r4,r2,#0,#19          ;1667
000118  f36f44dc          BFC      r4,#19,#10            ;1668
00011c  f5042400          ADD      r4,r4,#0x80000        ;1668
000120  e78d              B        |L12.62|
                  |L12.290|
;;;1678       {
;;;1679         USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
000122  f891c000          LDRB     r12,[r1,#0]
000126  690a              LDR      r2,[r1,#0x10]
000128  eb000c8c          ADD      r12,r0,r12,LSL #2
00012c  f8dcc054          LDR      r12,[r12,#0x54]
000130  f8cc2014          STR      r2,[r12,#0x14]
                  |L12.308|
;;;1680       }
;;;1681       
;;;1682       if (ep->type == EP_TYPE_ISOC)
000134  78ca              LDRB     r2,[r1,#3]
000136  2a01              CMP      r2,#1
000138  d009              BEQ      |L12.334|
                  |L12.314|
;;;1683       {
;;;1684         if (ep->even_odd_frame)
;;;1685         {
;;;1686           depctl.b.setd1pid = 1;
;;;1687         }
;;;1688         else
;;;1689         {
;;;1690           depctl.b.setd0pid = 1;
;;;1691         }
;;;1692       }
;;;1693       /* EP enable */
;;;1694       depctl.b.cnak = 1;
;;;1695       depctl.b.epena = 1;
;;;1696       USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
00013a  7809              LDRB     r1,[r1,#0]
00013c  f0434204          ORR      r2,r3,#0x84000000     ;1695
000140  eb000081          ADD      r0,r0,r1,LSL #2
000144  6d40              LDR      r0,[r0,#0x54]
000146  6002              STR      r2,[r0,#0]
                  |L12.328|
;;;1697     }
;;;1698     return status;
000148  4628              MOV      r0,r5
;;;1699   }
00014a  bc70              POP      {r4-r6}
00014c  4770              BX       lr
                  |L12.334|
00014e  794a              LDRB     r2,[r1,#5]            ;1684
000150  2a00              CMP      r2,#0                 ;1684
000152  bf14              ITE      NE                    ;1686
000154  f0435300          ORRNE    r3,r3,#0x20000000     ;1686
000158  f0435380          ORREQ    r3,r3,#0x10000000     ;1690
00015c  e7ed              B        |L12.314|
;;;1700   
                          ENDP


                          AREA ||i.USB_OTG_EnableDevInt||, CODE, READONLY, ALIGN=2

                  USB_OTG_EnableDevInt PROC
;;;1372   */
;;;1373   USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
000000  b410              PUSH     {r4}
;;;1374   {
;;;1375     USB_OTG_STS status = USB_OTG_OK;
;;;1376     USB_OTG_GINTMSK_TypeDef  intmsk;
;;;1377     
;;;1378     intmsk.d32 = 0;
;;;1379     
;;;1380     /* Disable all interrupts. */
;;;1381     USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
000002  68c3              LDR      r3,[r0,#0xc]
000004  2200              MOVS     r2,#0                 ;1375
000006  4611              MOV      r1,r2                 ;1378
000008  619a              STR      r2,[r3,#0x18]
;;;1382     /* Clear any pending interrupts */
;;;1383     USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
00000a  f8d0c00c          LDR      r12,[r0,#0xc]
00000e  f06f4380          MVN      r3,#0x40000000
000012  f8cc3014          STR      r3,[r12,#0x14]
000016  68c4              LDR      r4,[r0,#0xc]
000018  f04f3cff          MOV      r12,#0xffffffff
00001c  f8c4c004          STR      r12,[r4,#4]
000020  f8d0c00c          LDR      r12,[r0,#0xc]
000024  f8cc3014          STR      r3,[r12,#0x14]
000028  f8d0c00c          LDR      r12,[r0,#0xc]
00002c  4b0d              LDR      r3,|L13.100|
00002e  f8cc3018          STR      r3,[r12,#0x18]
;;;1384     /* Enable the common interrupts */
;;;1385     USB_OTG_EnableCommonInt(pdev);
;;;1386     
;;;1387     if (pdev->cfg.dma_enable == 0)
000032  78c3              LDRB     r3,[r0,#3]
000034  2b00              CMP      r3,#0
;;;1388     {
;;;1389       intmsk.b.rxstsqlvl = 1;
000036  bf08              IT       EQ
000038  2110              MOVEQ    r1,#0x10
;;;1390     }
;;;1391     
;;;1392     /* Enable interrupts matching to the Device mode ONLY */
;;;1393     intmsk.b.usbsuspend = 1;
00003a  f4412187          ORR      r1,r1,#0x43800
00003e  f4412100          ORR      r1,r1,#0x80000
;;;1394     intmsk.b.usbreset   = 1;
;;;1395     intmsk.b.enumdone   = 1;
;;;1396     intmsk.b.inepintr   = 1;
;;;1397     intmsk.b.outepintr  = 1;
;;;1398     intmsk.b.sofintr    = 1; 
;;;1399     
;;;1400     intmsk.b.incomplisoin    = 1; 
;;;1401     intmsk.b.incomplisoout    = 1;   
;;;1402   #ifdef VBUS_SENSING_ENABLED
;;;1403     intmsk.b.sessreqintr    = 1; 
;;;1404     intmsk.b.otgintr    = 1;    
;;;1405   #endif  
;;;1406     USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0410108          ORR      r1,r1,#8              ;1398
000048  f4411140          ORR      r1,r1,#0x300000       ;1398
00004c  f0410104          ORR      r1,r1,#4              ;1404
000050  6983              LDR      r3,[r0,#0x18]
000052  f0414180          ORR      r1,r1,#0x40000000     ;1404
000056  438b              BICS     r3,r3,r1
000058  4319              ORRS     r1,r1,r3
00005a  6181              STR      r1,[r0,#0x18]
;;;1407     return status;
;;;1408   }
00005c  bc10              POP      {r4}
00005e  4610              MOV      r0,r2                 ;1407
000060  4770              BX       lr
;;;1409   
                          ENDP

000062  0000              DCW      0x0000
                  |L13.100|
                          DCD      0x80000800

                          AREA ||i.USB_OTG_EnableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableGlobalInt PROC
;;;428    */
;;;429    USB_OTG_STS USB_OTG_EnableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;430    {
;;;431      USB_OTG_STS status = USB_OTG_OK;
;;;432      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;433      
;;;434      ahbcfg.d32 = 0;
000002  2200              MOVS     r2,#0
;;;435      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
;;;436      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
000004  6881              LDR      r1,[r0,#8]
000006  f0410101          ORR      r1,r1,#1
00000a  6081              STR      r1,[r0,#8]
;;;437      return status;
00000c  4610              MOV      r0,r2
;;;438    }
00000e  4770              BX       lr
;;;439    
                          ENDP


                          AREA ||i.USB_OTG_FlushRxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushRxFifo PROC
;;;493    */
;;;494    USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
000000  b538              PUSH     {r3-r5,lr}
;;;495    {
;;;496      USB_OTG_STS status = USB_OTG_OK;
000002  2400              MOVS     r4,#0
;;;497      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;498      uint32_t count = 0;
000004  4621              MOV      r1,r4
;;;499      
;;;500      greset.d32 = 0;
000006  9400              STR      r4,[sp,#0]
;;;501      greset.b.rxfflsh = 1;
000008  9a00              LDR      r2,[sp,#0]
00000a  f0420210          ORR      r2,r2,#0x10
00000e  9200              STR      r2,[sp,#0]
;;;502      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
000010  9a00              LDR      r2,[sp,#0]
000012  68c3              LDR      r3,[r0,#0xc]
000014  611a              STR      r2,[r3,#0x10]
;;;503      do
;;;504      {
;;;505        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
;;;506        if (++count > 200000)
000016  4b09              LDR      r3,|L15.60|
000018  68c2              LDR      r2,[r0,#0xc]          ;502
                  |L15.26|
00001a  f8d2c010          LDR      r12,[r2,#0x10]        ;505
00001e  f8cdc000          STR      r12,[sp,#0]           ;505
000022  1c49              ADDS     r1,r1,#1
000024  4299              CMP      r1,r3
000026  d804              BHI      |L15.50|
;;;507        {
;;;508          break;
;;;509        }
;;;510      }
;;;511      while (greset.b.rxfflsh == 1);
000028  f8ddc000          LDR      r12,[sp,#0]
00002c  f01c0f10          TST      r12,#0x10
000030  d1f3              BNE      |L15.26|
                  |L15.50|
;;;512      /* Wait for 3 PHY Clocks*/
;;;513      USB_OTG_BSP_uDelay(3);
000032  2003              MOVS     r0,#3
000034  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;514      return status;
000038  4620              MOV      r0,r4
;;;515    }
00003a  bd38              POP      {r3-r5,pc}
;;;516    
                          ENDP

                  |L15.60|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_FlushTxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushTxFifo PROC
;;;463    */
;;;464    USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
000000  b538              PUSH     {r3-r5,lr}
;;;465    {
;;;466      USB_OTG_STS status = USB_OTG_OK;
000002  2400              MOVS     r4,#0
;;;467      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;468      
;;;469      uint32_t count = 0;
000004  4622              MOV      r2,r4
;;;470      greset.d32 = 0;
000006  9400              STR      r4,[sp,#0]
;;;471      greset.b.txfflsh = 1;
000008  9b00              LDR      r3,[sp,#0]
00000a  f0430320          ORR      r3,r3,#0x20
00000e  9300              STR      r3,[sp,#0]
;;;472      greset.b.txfnum  = num;
000010  9b00              LDR      r3,[sp,#0]
000012  f361138a          BFI      r3,r1,#6,#5
000016  9300              STR      r3,[sp,#0]
;;;473      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
000018  9900              LDR      r1,[sp,#0]
00001a  68c3              LDR      r3,[r0,#0xc]
00001c  6119              STR      r1,[r3,#0x10]
;;;474      do
;;;475      {
;;;476        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
;;;477        if (++count > 200000)
00001e  4b09              LDR      r3,|L16.68|
000020  68c1              LDR      r1,[r0,#0xc]          ;473
                  |L16.34|
000022  f8d1c010          LDR      r12,[r1,#0x10]        ;476
000026  f8cdc000          STR      r12,[sp,#0]           ;476
00002a  1c52              ADDS     r2,r2,#1
00002c  429a              CMP      r2,r3
00002e  d804              BHI      |L16.58|
;;;478        {
;;;479          break;
;;;480        }
;;;481      }
;;;482      while (greset.b.txfflsh == 1);
000030  f8ddc000          LDR      r12,[sp,#0]
000034  f01c0f20          TST      r12,#0x20
000038  d1f3              BNE      |L16.34|
                  |L16.58|
;;;483      /* Wait for 3 PHY Clocks*/
;;;484      USB_OTG_BSP_uDelay(3);
00003a  2003              MOVS     r0,#3
00003c  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;485      return status;
000040  4620              MOV      r0,r4
;;;486    }
000042  bd38              POP      {r3-r5,pc}
;;;487    
                          ENDP

                  |L16.68|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_GetDeviceSpeed||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetDeviceSpeed PROC
;;;1416   */
;;;1417   enum USB_OTG_SPEED USB_OTG_GetDeviceSpeed (USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;1418   {
;;;1419     USB_OTG_DSTS_TypeDef  dsts;
;;;1420     enum USB_OTG_SPEED speed = USB_SPEED_UNKNOWN;
000002  2000              MOVS     r0,#0
;;;1421     
;;;1422     
;;;1423     dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
000004  6909              LDR      r1,[r1,#0x10]
000006  6889              LDR      r1,[r1,#8]
;;;1424     
;;;1425     switch (dsts.b.enumspd)
000008  f3c10141          UBFX     r1,r1,#1,#2
00000c  2900              CMP      r1,#0
;;;1426     {
;;;1427     case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
;;;1428       speed = USB_SPEED_HIGH;
00000e  bf04              ITT      EQ
000010  2003              MOVEQ    r0,#3
;;;1429       break;
;;;1430     case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
;;;1431     case DSTS_ENUMSPD_FS_PHY_48MHZ:
;;;1432       speed = USB_SPEED_FULL;
;;;1433       break;
;;;1434       
;;;1435     case DSTS_ENUMSPD_LS_PHY_6MHZ:
;;;1436       speed = USB_SPEED_LOW;
;;;1437       break;
;;;1438     }
;;;1439     
;;;1440     return speed;
;;;1441   }
000012  4770              BXEQ     lr
000014  2901              CMP      r1,#1                 ;1425
000016  d006              BEQ      |L17.38|
000018  2902              CMP      r1,#2                 ;1425
00001a  bf04              ITT      EQ                    ;1436
00001c  2001              MOVEQ    r0,#1                 ;1436
00001e  4770              BXEQ     lr
000020  2903              CMP      r1,#3                 ;1425
000022  bf18              IT       NE
000024  4770              BXNE     lr
                  |L17.38|
000026  2002              MOVS     r0,#2                 ;1432
000028  4770              BX       lr
;;;1442   /**
                          ENDP


                          AREA ||i.USB_OTG_GetEPStatus||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetEPStatus PROC
;;;2040   
;;;2041   uint32_t USB_OTG_GetEPStatus(USB_OTG_CORE_HANDLE *pdev ,USB_OTG_EP *ep)
000000  784a              LDRB     r2,[r1,#1]
;;;2042   {
;;;2043     USB_OTG_DEPCTL_TypeDef  depctl;
;;;2044     __IO uint32_t *depctl_addr;
;;;2045     uint32_t Status = 0;  
;;;2046     
;;;2047     depctl.d32 = 0;
;;;2048     if (ep->is_in == 1)
;;;2049     {
;;;2050       depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
000002  7809              LDRB     r1,[r1,#0]
000004  2a01              CMP      r2,#1                 ;2048
000006  eb000081          ADD      r0,r0,r1,LSL #2
00000a  d00f              BEQ      |L18.44|
;;;2051       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
;;;2052       
;;;2053       if (depctl.b.stall == 1)  
;;;2054         Status = USB_OTG_EP_TX_STALL;
;;;2055       else if (depctl.b.naksts == 1)
;;;2056         Status = USB_OTG_EP_TX_NAK;
;;;2057       else 
;;;2058         Status = USB_OTG_EP_TX_VALID;     
;;;2059       
;;;2060     }
;;;2061     else
;;;2062     {
;;;2063       depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
00000c  6d40              LDR      r0,[r0,#0x54]
;;;2064       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
00000e  6800              LDR      r0,[r0,#0]
;;;2065       if (depctl.b.stall == 1)  
000010  f4101f00          TST      r0,#0x200000
;;;2066         Status = USB_OTG_EP_RX_STALL;
000014  bf1c              ITT      NE
000016  f44f5080          MOVNE    r0,#0x1000
;;;2067       else if (depctl.b.naksts == 1)
;;;2068         Status = USB_OTG_EP_RX_NAK;
;;;2069       else 
;;;2070         Status = USB_OTG_EP_RX_VALID; 
;;;2071     } 
;;;2072     
;;;2073     /* Return the current status */
;;;2074     return Status;
;;;2075   }
00001a  4770              BXNE     lr
00001c  f4103f00          TST      r0,#0x20000           ;2067
000020  bf14              ITE      NE                    ;2068
000022  f44f5000          MOVNE    r0,#0x2000            ;2068
000026  f44f5040          MOVEQ    r0,#0x3000            ;2070
00002a  4770              BX       lr
                  |L18.44|
00002c  6980              LDR      r0,[r0,#0x18]         ;2050
00002e  6800              LDR      r0,[r0,#0]            ;2051
000030  f4101f00          TST      r0,#0x200000          ;2053
000034  bf1c              ITT      NE                    ;2054
000036  2010              MOVNE    r0,#0x10              ;2054
000038  4770              BXNE     lr
00003a  f4103f00          TST      r0,#0x20000           ;2055
00003e  bf14              ITE      NE                    ;2056
000040  2020              MOVNE    r0,#0x20              ;2056
000042  2030              MOVEQ    r0,#0x30              ;2058
000044  4770              BX       lr
;;;2076   
                          ENDP


                          AREA ||i.USB_OTG_GetMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetMode PROC
;;;553    */
;;;554    uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;555    {
;;;556      return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
000002  6940              LDR      r0,[r0,#0x14]
000004  f0000001          AND      r0,r0,#1
;;;557    }
000008  4770              BX       lr
;;;558    
                          ENDP


                          AREA ||i.USB_OTG_InitDevSpeed||, CODE, READONLY, ALIGN=1

                  USB_OTG_InitDevSpeed PROC
;;;1177   */
;;;1178   void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
000000  6900              LDR      r0,[r0,#0x10]
;;;1179   {
;;;1180     USB_OTG_DCFG_TypeDef   dcfg;
;;;1181     
;;;1182     dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
000002  6802              LDR      r2,[r0,#0]
;;;1183     dcfg.b.devspd = speed;
000004  f3610201          BFI      r2,r1,#0,#2
;;;1184     USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
000008  6002              STR      r2,[r0,#0]
;;;1185   }
00000a  4770              BX       lr
;;;1186   
                          ENDP


                          AREA ||i.USB_OTG_IsDeviceMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsDeviceMode PROC
;;;564    */
;;;565    uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
000002  6940              LDR      r0,[r0,#0x14]
000004  f0100f01          TST      r0,#1
;;;566    {
;;;567      return (USB_OTG_GetMode(pdev) != HOST_MODE);
000008  bf0c              ITE      EQ
00000a  2001              MOVEQ    r0,#1
00000c  2000              MOVNE    r0,#0
;;;568    }
00000e  4770              BX       lr
;;;569    
                          ENDP


                          AREA ||i.USB_OTG_IsHostMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsHostMode PROC
;;;575    */
;;;576    uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
000002  6940              LDR      r0,[r0,#0x14]
000004  f0100001          ANDS     r0,r0,#1
;;;577    {
;;;578      return (USB_OTG_GetMode(pdev) == HOST_MODE);
000008  bf18              IT       NE
00000a  2001              MOVNE    r0,#1
;;;579    }
00000c  4770              BX       lr
;;;580    
                          ENDP


                          AREA ||i.USB_OTG_ReadCoreItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadCoreItr PROC
;;;586    */
;;;587    uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;588    {
;;;589      uint32_t v = 0;
;;;590      v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
000002  6941              LDR      r1,[r0,#0x14]
;;;591      v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
000004  6980              LDR      r0,[r0,#0x18]
000006  4008              ANDS     r0,r0,r1
;;;592      return v;
;;;593    }
000008  4770              BX       lr
;;;594    
                          ENDP


                          AREA ||i.USB_OTG_ReadDevAllInEPItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadDevAllInEPItr PROC
;;;1906   */
;;;1907   uint32_t USB_OTG_ReadDevAllInEPItr(USB_OTG_CORE_HANDLE *pdev)
000000  6900              LDR      r0,[r0,#0x10]
;;;1908   {
;;;1909     uint32_t v;
;;;1910     v = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
000002  6981              LDR      r1,[r0,#0x18]
;;;1911     v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
000004  69c0              LDR      r0,[r0,#0x1c]
000006  4008              ANDS     r0,r0,r1
;;;1912     return (v & 0xffff);
000008  b280              UXTH     r0,r0
;;;1913   }
00000a  4770              BX       lr
;;;1914   
                          ENDP


                          AREA ||i.USB_OTG_ReadDevAllOutEp_itr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadDevAllOutEp_itr PROC
;;;1877   */
;;;1878   uint32_t USB_OTG_ReadDevAllOutEp_itr(USB_OTG_CORE_HANDLE *pdev)
000000  6900              LDR      r0,[r0,#0x10]
;;;1879   {
;;;1880     uint32_t v;
;;;1881     v  = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
000002  6981              LDR      r1,[r0,#0x18]
;;;1882     v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
000004  69c0              LDR      r0,[r0,#0x1c]
000006  4008              ANDS     r0,r0,r1
;;;1883     return ((v & 0xffff0000) >> 16);
000008  0c00              LSRS     r0,r0,#16
;;;1884   }
00000a  4770              BX       lr
;;;1885   
                          ENDP


                          AREA ||i.USB_OTG_ReadDevOutEP_itr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadDevOutEP_itr PROC
;;;1892   */
;;;1893   uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
000000  eb000181          ADD      r1,r0,r1,LSL #2
;;;1894   {
;;;1895     uint32_t v;
;;;1896     v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
000004  6d49              LDR      r1,[r1,#0x54]
000006  6889              LDR      r1,[r1,#8]
;;;1897     v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
000008  6900              LDR      r0,[r0,#0x10]
00000a  6940              LDR      r0,[r0,#0x14]
00000c  4008              ANDS     r0,r0,r1
;;;1898     return v;
;;;1899   }
00000e  4770              BX       lr
;;;1900   
                          ENDP


                          AREA ||i.USB_OTG_ReadOtgItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadOtgItr PROC
;;;600    */
;;;601    uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;602    {
;;;603      return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
000002  6840              LDR      r0,[r0,#4]
;;;604    }
000004  4770              BX       lr
;;;605    
                          ENDP


                          AREA ||i.USB_OTG_ReadPacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadPacket PROC
;;;196    */
;;;197    void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
000000  4684              MOV      r12,r0
;;;198                             uint8_t *dest, 
;;;199                             uint16_t len)
;;;200    {
;;;201      uint32_t i=0;
;;;202      uint32_t count32b = (len + 3) / 4;
000002  1cd0              ADDS     r0,r2,#3
000004  2300              MOVS     r3,#0                 ;201
000006  0880              LSRS     r0,r0,#2
;;;203      
;;;204      __IO uint32_t *fifo = pdev->regs.DFIFO[0];
;;;205      
;;;206      for ( i = 0; i < count32b; i++, dest += 4 )
000008  f8dc20d0          LDR      r2,[r12,#0xd0]
00000c  2800              CMP      r0,#0
00000e  d906              BLS      |L28.30|
                  |L28.16|
;;;207      {
;;;208        *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
000010  f8d2c000          LDR      r12,[r2,#0]
000014  1c5b              ADDS     r3,r3,#1              ;206
000016  f841cb04          STR      r12,[r1],#4
00001a  4298              CMP      r0,r3                 ;206
00001c  d8f8              BHI      |L28.16|
                  |L28.30|
;;;209        
;;;210      }
;;;211      return ((void *)dest);
00001e  4608              MOV      r0,r1
;;;212    }
000020  4770              BX       lr
;;;213    
                          ENDP


                          AREA ||i.USB_OTG_SelectCore||, CODE, READONLY, ALIGN=2

                  USB_OTG_SelectCore PROC
;;;220    */
;;;221    USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
000000  b430              PUSH     {r4,r5}
;;;222                                   USB_OTG_CORE_ID_TypeDef coreID)
;;;223    {
;;;224      uint32_t i , baseAddress = 0;
000002  2200              MOVS     r2,#0
;;;225      USB_OTG_STS status = USB_OTG_OK;
;;;226      
;;;227      pdev->cfg.dma_enable       = 0;
000004  70c2              STRB     r2,[r0,#3]
;;;228      
;;;229      /* at startup the core is in FS mode */
;;;230      pdev->cfg.speed            = USB_OTG_SPEED_FULL;
000006  f04f0c01          MOV      r12,#1
00000a  f880c002          STRB     r12,[r0,#2]
;;;231      pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
00000e  2540              MOVS     r5,#0x40
000010  8085              STRH     r5,[r0,#4]
;;;232      
;;;233      /* initialize device cfg following its address */
;;;234      if (coreID == USB_OTG_FS_CORE_ID)
;;;235      {
;;;236        baseAddress                = USB_OTG_FS_BASE_ADDR;
;;;237        pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
;;;238        pdev->cfg.host_channels    = 8 ;
;;;239        pdev->cfg.dev_endpoints    = 4 ;
;;;240        pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
;;;241        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
000012  2502              MOVS     r5,#2
000014  4614              MOV      r4,r2                 ;225
000016  4613              MOV      r3,r2                 ;227
000018  2901              CMP      r1,#1                 ;234
00001a  d001              BEQ      |L29.32|
;;;242        
;;;243    #ifdef USB_OTG_FS_SOF_OUTPUT_ENABLED    
;;;244        pdev->cfg.Sof_output       = 1;    
;;;245    #endif 
;;;246        
;;;247    #ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
;;;248        pdev->cfg.low_power        = 1;    
;;;249    #endif     
;;;250      }
;;;251      else if (coreID == USB_OTG_HS_CORE_ID)
00001c  b161              CBZ      r1,|L29.56|
00001e  e015              B        |L29.76|
                  |L29.32|
000020  f880c00b          STRB     r12,[r0,#0xb]         ;237
000024  2108              MOVS     r1,#8                 ;238
000026  7001              STRB     r1,[r0,#0]            ;238
000028  2104              MOVS     r1,#4                 ;239
00002a  f04f42a0          MOV      r2,#0x50000000        ;236
00002e  7041              STRB     r1,[r0,#1]            ;239
000030  1591              ASRS     r1,r2,#22             ;240
000032  80c1              STRH     r1,[r0,#6]            ;240
000034  7205              STRB     r5,[r0,#8]            ;241
000036  e009              B        |L29.76|
                  |L29.56|
;;;252      {
;;;253        baseAddress                = USB_OTG_HS_BASE_ADDR;
;;;254        pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
000038  72c3              STRB     r3,[r0,#0xb]
;;;255        pdev->cfg.host_channels    = 12 ;
00003a  210c              MOVS     r1,#0xc
00003c  7001              STRB     r1,[r0,#0]
;;;256        pdev->cfg.dev_endpoints    = 6 ;
00003e  2106              MOVS     r1,#6
000040  7041              STRB     r1,[r0,#1]
;;;257        pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
000042  f44f61a0          MOV      r1,#0x500
000046  4a23              LDR      r2,|L29.212|
000048  80c1              STRH     r1,[r0,#6]
;;;258        
;;;259    #ifdef USB_OTG_ULPI_PHY_ENABLED
;;;260        pdev->cfg.phy_itface       = USB_OTG_ULPI_PHY;
;;;261    #else    
;;;262    #ifdef USB_OTG_EMBEDDED_PHY_ENABLED
;;;263        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;
00004a  7205              STRB     r5,[r0,#8]
                  |L29.76|
;;;264    #endif  
;;;265    #endif      
;;;266        
;;;267    #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED    
;;;268        pdev->cfg.dma_enable       = 1;    
;;;269    #endif
;;;270        
;;;271    #ifdef USB_OTG_HS_SOF_OUTPUT_ENABLED    
;;;272        pdev->cfg.Sof_output       = 1;    
;;;273    #endif 
;;;274        
;;;275    #ifdef USB_OTG_HS_LOW_PWR_MGMT_SUPPORT    
;;;276        pdev->cfg.low_power        = 1;    
;;;277    #endif 
;;;278        
;;;279      }
;;;280      
;;;281      pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
;;;282        USB_OTG_CORE_GLOBAL_REGS_OFFSET);
;;;283      pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
00004c  f5026100          ADD      r1,r2,#0x800
000050  e9c02103          STRD     r2,r1,[r0,#0xc]
;;;284        USB_OTG_DEV_GLOBAL_REG_OFFSET);
;;;285      
;;;286      for (i = 0; i < pdev->cfg.dev_endpoints; i++)
000054  7843              LDRB     r3,[r0,#1]
000056  2100              MOVS     r1,#0
000058  2b00              CMP      r3,#0
00005a  d90e              BLS      |L29.122|
                  |L29.92|
;;;287      {
;;;288        pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
00005c  eb021c41          ADD      r12,r2,r1,LSL #5
000060  f50c6510          ADD      r5,r12,#0x900
000064  eb000381          ADD      r3,r0,r1,LSL #2
;;;289          (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
;;;290            (i * USB_OTG_EP_REG_OFFSET));
;;;291        pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
000068  f50c6c30          ADD      r12,r12,#0xb00
00006c  f8c3c054          STR      r12,[r3,#0x54]        ;286
000070  619d              STR      r5,[r3,#0x18]         ;286
000072  7843              LDRB     r3,[r0,#1]            ;286
000074  1c49              ADDS     r1,r1,#1              ;286
000076  428b              CMP      r3,r1                 ;286
000078  d8f0              BHI      |L29.92|
                  |L29.122|
;;;292          (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
;;;293            (i * USB_OTG_EP_REG_OFFSET));
;;;294      }
;;;295      pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
00007a  f5026180          ADD      r1,r2,#0x400
;;;296        USB_OTG_HOST_GLOBAL_REG_OFFSET);
;;;297      pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
00007e  6141              STR      r1,[r0,#0x14]
000080  3140              ADDS     r1,r1,#0x40
;;;298      
;;;299      for (i = 0; i < pdev->cfg.host_channels; i++)
000082  f8c010cc          STR      r1,[r0,#0xcc]
000086  7803              LDRB     r3,[r0,#0]
000088  2100              MOVS     r1,#0
00008a  2b00              CMP      r3,#0
00008c  d90b              BLS      |L29.166|
                  |L29.142|
;;;300      {
;;;301        pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
00008e  eb021341          ADD      r3,r2,r1,LSL #5
000092  eb000c81          ADD      r12,r0,r1,LSL #2
000096  f50363a0          ADD      r3,r3,#0x500
00009a  f8cc3090          STR      r3,[r12,#0x90]        ;299
00009e  7803              LDRB     r3,[r0,#0]            ;299
0000a0  1c49              ADDS     r1,r1,#1              ;299
0000a2  428b              CMP      r3,r1                 ;299
0000a4  d8f3              BHI      |L29.142|
                  |L29.166|
;;;302          USB_OTG_HOST_CHAN_REGS_OFFSET + \
;;;303            (i * USB_OTG_CHAN_REGS_OFFSET));
;;;304      }
;;;305      for (i = 0; i < pdev->cfg.host_channels; i++)
0000a6  2100              MOVS     r1,#0
0000a8  b2db              UXTB     r3,r3
0000aa  2b00              CMP      r3,#0
0000ac  d90b              BLS      |L29.198|
                  |L29.174|
;;;306      {
;;;307        pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
0000ae  eb023301          ADD      r3,r2,r1,LSL #12
0000b2  eb000c81          ADD      r12,r0,r1,LSL #2
0000b6  f5035380          ADD      r3,r3,#0x1000
0000ba  f8cc30d0          STR      r3,[r12,#0xd0]        ;305
0000be  7803              LDRB     r3,[r0,#0]            ;305
0000c0  1c49              ADDS     r1,r1,#1              ;305
0000c2  428b              CMP      r3,r1                 ;305
0000c4  d8f3              BHI      |L29.174|
                  |L29.198|
;;;308          (i * USB_OTG_DATA_FIFO_SIZE));
;;;309      }
;;;310      pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
0000c6  f5026160          ADD      r1,r2,#0xe00
;;;311      
;;;312      return status;
0000ca  f8c0110c          STR      r1,[r0,#0x10c]
0000ce  4620              MOV      r0,r4
;;;313    }
0000d0  bc30              POP      {r4,r5}
0000d2  4770              BX       lr
;;;314    
                          ENDP

                  |L29.212|
                          DCD      0x40040000

                          AREA ||i.USB_OTG_SetCurrentMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_SetCurrentMode PROC
;;;523    */
;;;524    USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
000000  b510              PUSH     {r4,lr}
;;;525    {
;;;526      USB_OTG_STS status = USB_OTG_OK;
;;;527      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;528      
;;;529      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
000002  68c2              LDR      r2,[r0,#0xc]
000004  2400              MOVS     r4,#0                 ;526
000006  68d0              LDR      r0,[r2,#0xc]
;;;530      
;;;531      usbcfg.b.force_host = 0;
;;;532      usbcfg.b.force_dev = 0;
;;;533      
;;;534      if ( mode == HOST_MODE)
000008  2901              CMP      r1,#1
00000a  f02040c0          BIC      r0,r0,#0x60000000     ;532
;;;535      {
;;;536        usbcfg.b.force_host = 1;
00000e  bf08              IT       EQ
000010  f0405000          ORREQ    r0,r0,#0x20000000
000014  d003              BEQ      |L30.30|
;;;537      }
;;;538      else if ( mode == DEVICE_MODE)
000016  2900              CMP      r1,#0
;;;539      {
;;;540        usbcfg.b.force_dev = 1;
000018  bf08              IT       EQ
00001a  f0404080          ORREQ    r0,r0,#0x40000000
                  |L30.30|
;;;541      }
;;;542      
;;;543      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
00001e  60d0              STR      r0,[r2,#0xc]
;;;544      USB_OTG_BSP_mDelay(50);
000020  2032              MOVS     r0,#0x32
000022  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;545      return status;
000026  4620              MOV      r0,r4
;;;546    }
000028  bd10              POP      {r4,pc}
;;;547    
                          ENDP


                          AREA ||i.USB_OTG_SetEPStatus||, CODE, READONLY, ALIGN=1

                  USB_OTG_SetEPStatus PROC
;;;2083   */
;;;2084   void USB_OTG_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep , uint32_t Status)
000000  b430              PUSH     {r4,r5}
;;;2085   {
;;;2086     USB_OTG_DEPCTL_TypeDef  depctl;
;;;2087     __IO uint32_t *depctl_addr;
;;;2088     
;;;2089     depctl.d32 = 0;
;;;2090     
;;;2091     /* Process for IN endpoint */
;;;2092     if (ep->is_in == 1)
000002  784d              LDRB     r5,[r1,#1]
;;;2093     {
;;;2094       depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
000004  780b              LDRB     r3,[r1,#0]
000006  2400              MOVS     r4,#0                 ;2089
000008  eb000c83          ADD      r12,r0,r3,LSL #2
00000c  2d01              CMP      r5,#1                 ;2092
00000e  d011              BEQ      |L31.52|
;;;2095       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
;;;2096       
;;;2097       if (Status == USB_OTG_EP_TX_STALL)  
;;;2098       {
;;;2099         USB_OTG_EPSetStall(pdev, ep); return;
;;;2100       }
;;;2101       else if (Status == USB_OTG_EP_TX_NAK)
;;;2102         depctl.b.snak = 1;
;;;2103       else if (Status == USB_OTG_EP_TX_VALID)
;;;2104       {
;;;2105         if (depctl.b.stall == 1)
;;;2106         {  
;;;2107           ep->even_odd_frame = 0;
;;;2108           USB_OTG_EPClearStall(pdev, ep);
;;;2109           return;
;;;2110         }      
;;;2111         depctl.b.cnak = 1;
;;;2112         depctl.b.usbactep = 1; 
;;;2113         depctl.b.epena = 1;
;;;2114       }
;;;2115       else if (Status == USB_OTG_EP_TX_DIS)
;;;2116         depctl.b.usbactep = 0;
;;;2117     } 
;;;2118     else /* Process for OUT endpoint */
;;;2119     {
;;;2120       depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
;;;2121       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
000010  f8dc3054          LDR      r3,[r12,#0x54]
000014  6818              LDR      r0,[r3,#0]
;;;2122       
;;;2123       if (Status == USB_OTG_EP_RX_STALL)  {
000016  f5b25f80          CMP      r2,#0x1000
;;;2124         depctl.b.stall = 1;
00001a  bf08              IT       EQ
00001c  f4401000          ORREQ    r0,r0,#0x200000
000020  d04b              BEQ      |L31.186|
;;;2125       }
;;;2126       else if (Status == USB_OTG_EP_RX_NAK)
000022  f5b25f00          CMP      r2,#0x2000
000026  d02e              BEQ      |L31.134|
;;;2127         depctl.b.snak = 1;
;;;2128       else if (Status == USB_OTG_EP_RX_VALID)
000028  f5b25f40          CMP      r2,#0x3000
00002c  d02e              BEQ      |L31.140|
;;;2129       {
;;;2130         if (depctl.b.stall == 1)
;;;2131         {  
;;;2132           ep->even_odd_frame = 0;
;;;2133           USB_OTG_EPClearStall(pdev, ep);
;;;2134           return;
;;;2135         }  
;;;2136         depctl.b.cnak = 1;
;;;2137         depctl.b.usbactep = 1;    
;;;2138         depctl.b.epena = 1;
;;;2139       }
;;;2140       else if (Status == USB_OTG_EP_RX_DIS)
00002e  2a00              CMP      r2,#0
000030  d041              BEQ      |L31.182|
000032  e042              B        |L31.186|
                  |L31.52|
000034  f8dc3018          LDR      r3,[r12,#0x18]        ;2095
000038  6818              LDR      r0,[r3,#0]            ;2095
00003a  2a10              CMP      r2,#0x10              ;2097
00003c  d005              BEQ      |L31.74|
00003e  2a20              CMP      r2,#0x20              ;2101
000040  d021              BEQ      |L31.134|
000042  2a30              CMP      r2,#0x30              ;2103
000044  d00c              BEQ      |L31.96|
000046  b382              CBZ      r2,|L31.170|
000048  e037              B        |L31.186|
                  |L31.74|
00004a  6818              LDR      r0,[r3,#0]            ;2115
00004c  f0104f00          TST      r0,#0x80000000        ;2115
000050  bf18              IT       NE                    ;2115
000052  f0404080          ORRNE    r0,r0,#0x40000000     ;2115
000056  f4401000          ORR      r0,r0,#0x200000       ;2115
00005a  6018              STR      r0,[r3,#0]            ;2115
;;;2141       {
;;;2142         depctl.b.usbactep = 0;    
;;;2143       }
;;;2144     }
;;;2145     
;;;2146     USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
;;;2147   }
00005c  bc30              POP      {r4,r5}
00005e  4770              BX       lr
                  |L31.96|
000060  f4101f00          TST      r0,#0x200000          ;2105
000064  d022              BEQ      |L31.172|
000066  714c              STRB     r4,[r1,#5]            ;2107
000068  f8dc2018          LDR      r2,[r12,#0x18]        ;2107
00006c  6810              LDR      r0,[r2,#0]            ;2107
00006e  78c9              LDRB     r1,[r1,#3]            ;2107
000070  f4201000          BIC      r0,r0,#0x200000       ;2107
000074  2903              CMP      r1,#3                 ;2107
000076  bf18              IT       NE                    ;2107
000078  2902              CMPNE    r1,#2                 ;2107
00007a  d101              BNE      |L31.128|
                  |L31.124|
00007c  f0405080          ORR      r0,r0,#0x10000000     ;2107
                  |L31.128|
000080  6010              STR      r0,[r2,#0]            ;2107
000082  bc30              POP      {r4,r5}
000084  4770              BX       lr
                  |L31.134|
000086  f0406000          ORR      r0,r0,#0x8000000      ;2127
00008a  e016              B        |L31.186|
                  |L31.140|
00008c  f4101f00          TST      r0,#0x200000          ;2130
000090  d00c              BEQ      |L31.172|
000092  714c              STRB     r4,[r1,#5]            ;2132
000094  f8dc2054          LDR      r2,[r12,#0x54]        ;2132
000098  6810              LDR      r0,[r2,#0]            ;2132
00009a  78c9              LDRB     r1,[r1,#3]            ;2132
00009c  f4201000          BIC      r0,r0,#0x200000       ;2132
0000a0  2903              CMP      r1,#3                 ;2132
0000a2  bf18              IT       NE                    ;2132
0000a4  2902              CMPNE    r1,#2                 ;2132
0000a6  d0e9              BEQ      |L31.124|
0000a8  e7ea              B        |L31.128|
                  |L31.170|
0000aa  e004              B        |L31.182|
                  |L31.172|
0000ac  f4404000          ORR      r0,r0,#0x8000         ;2138
0000b0  f0404004          ORR      r0,r0,#0x84000000     ;2138
0000b4  e001              B        |L31.186|
                  |L31.182|
0000b6  f4204000          BIC      r0,r0,#0x8000         ;2142
                  |L31.186|
0000ba  6018              STR      r0,[r3,#0]            ;2146
0000bc  bc30              POP      {r4,r5}
0000be  4770              BX       lr
;;;2148   
                          ENDP


                          AREA ||i.USB_OTG_StopDevice||, CODE, READONLY, ALIGN=2

                  USB_OTG_StopDevice PROC
;;;2011   */
;;;2012   void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2013   {
000002  4604              MOV      r4,r0
;;;2014     uint32_t i;
;;;2015     
;;;2016     pdev->dev.device_status = 1;
000004  2001              MOVS     r0,#1
000006  f8840112          STRB     r0,[r4,#0x112]
;;;2017     
;;;2018     for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
00000a  7861              LDRB     r1,[r4,#1]
00000c  2000              MOVS     r0,#0
00000e  2900              CMP      r1,#0
;;;2019     {
;;;2020       USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
000010  bf88              IT       HI
000012  22ff              MOVHI    r2,#0xff
000014  d909              BLS      |L32.42|
                  |L32.22|
000016  eb040180          ADD      r1,r4,r0,LSL #2
00001a  698b              LDR      r3,[r1,#0x18]
00001c  609a              STR      r2,[r3,#8]
;;;2021       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
00001e  6d49              LDR      r1,[r1,#0x54]
000020  608a              STR      r2,[r1,#8]
000022  7861              LDRB     r1,[r4,#1]            ;2018
000024  1c40              ADDS     r0,r0,#1              ;2018
000026  4281              CMP      r1,r0                 ;2018
000028  d8f5              BHI      |L32.22|
                  |L32.42|
;;;2022     }
;;;2023     
;;;2024     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
00002a  6920              LDR      r0,[r4,#0x10]
00002c  2600              MOVS     r6,#0
00002e  6106              STR      r6,[r0,#0x10]
;;;2025     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
000030  6920              LDR      r0,[r4,#0x10]
000032  6146              STR      r6,[r0,#0x14]
;;;2026     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
000034  6920              LDR      r0,[r4,#0x10]
000036  61c6              STR      r6,[r0,#0x1c]
;;;2027     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
000038  6921              LDR      r1,[r4,#0x10]
00003a  1e70              SUBS     r0,r6,#1
00003c  6188              STR      r0,[r1,#0x18]
00003e  4630              MOV      r0,r6
000040  9600              STR      r6,[sp,#0]
000042  9900              LDR      r1,[sp,#0]
000044  f0410110          ORR      r1,r1,#0x10
000048  9100              STR      r1,[sp,#0]
00004a  9900              LDR      r1,[sp,#0]
00004c  68e2              LDR      r2,[r4,#0xc]
00004e  6111              STR      r1,[r2,#0x10]
000050  4d15              LDR      r5,|L32.168|
000052  68e1              LDR      r1,[r4,#0xc]
                  |L32.84|
000054  690a              LDR      r2,[r1,#0x10]
000056  9200              STR      r2,[sp,#0]
000058  1c40              ADDS     r0,r0,#1
00005a  42a8              CMP      r0,r5
00005c  d803              BHI      |L32.102|
00005e  9a00              LDR      r2,[sp,#0]
000060  f0120f10          TST      r2,#0x10
000064  d1f6              BNE      |L32.84|
                  |L32.102|
000066  2003              MOVS     r0,#3
000068  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;2028     
;;;2029     /* Flush the FIFO */
;;;2030     USB_OTG_FlushRxFifo(pdev);
;;;2031     USB_OTG_FlushTxFifo(pdev ,  0x10 );  
00006c  2110              MOVS     r1,#0x10
00006e  2000              MOVS     r0,#0
000070  9600              STR      r6,[sp,#0]
000072  9a00              LDR      r2,[sp,#0]
000074  f0420220          ORR      r2,r2,#0x20
000078  9200              STR      r2,[sp,#0]
00007a  9a00              LDR      r2,[sp,#0]
00007c  f361128a          BFI      r2,r1,#6,#5
000080  9200              STR      r2,[sp,#0]
000082  9900              LDR      r1,[sp,#0]
000084  68e2              LDR      r2,[r4,#0xc]
000086  6111              STR      r1,[r2,#0x10]
000088  68e1              LDR      r1,[r4,#0xc]
                  |L32.138|
00008a  690a              LDR      r2,[r1,#0x10]
00008c  9200              STR      r2,[sp,#0]
00008e  1c40              ADDS     r0,r0,#1
000090  42a8              CMP      r0,r5
000092  d803              BHI      |L32.156|
000094  9a00              LDR      r2,[sp,#0]
000096  f0120f20          TST      r2,#0x20
00009a  d1f6              BNE      |L32.138|
                  |L32.156|
00009c  e8bd40f8          POP      {r3-r7,lr}
0000a0  2003              MOVS     r0,#3
0000a2  f7ffbffe          B.W      USB_OTG_BSP_uDelay
;;;2032   }
;;;2033   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L32.168|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_UngateClock||, CODE, READONLY, ALIGN=1

                  USB_OTG_UngateClock PROC
;;;1984   */
;;;1985   void USB_OTG_UngateClock(USB_OTG_CORE_HANDLE *pdev)
000000  7a81              LDRB     r1,[r0,#0xa]
;;;1986   {
000002  2900              CMP      r1,#0
;;;1987     if(pdev->cfg.low_power)
;;;1988     {
;;;1989       
;;;1990       USB_OTG_DSTS_TypeDef     dsts;
;;;1991       USB_OTG_PCGCCTL_TypeDef  power; 
;;;1992       
;;;1993       dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
;;;1994       
;;;1995       if(dsts.b.suspsts == 1)
;;;1996       {
;;;1997         /* un-gate USB Core clock */
;;;1998         power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
;;;1999         power.b.gatehclk = 0;
;;;2000         power.b.stoppclk = 0;
;;;2001         USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
;;;2002         
;;;2003       }
;;;2004     }
;;;2005   }
000004  bf08              IT       EQ
000006  4770              BXEQ     lr
000008  6901              LDR      r1,[r0,#0x10]         ;1993
00000a  6889              LDR      r1,[r1,#8]            ;1993
00000c  f0110f01          TST      r1,#1                 ;1995
000010  bf08              IT       EQ
000012  4770              BXEQ     lr
000014  f8d0110c          LDR      r1,[r0,#0x10c]        ;1998
000018  f8d0010c          LDR      r0,[r0,#0x10c]        ;2001
00001c  f0210103          BIC      r1,r1,#3              ;2000
000020  6001              STR      r1,[r0,#0]            ;2001
000022  4770              BX       lr
;;;2006   
                          ENDP


                          AREA ||i.USB_OTG_WritePacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_WritePacket PROC
;;;167    */
;;;168    USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
000000  b410              PUSH     {r4}
;;;169                                    uint8_t             *src, 
;;;170                                    uint8_t             ch_ep_num, 
;;;171                                    uint16_t            len)
;;;172    {
000002  4604              MOV      r4,r0
;;;173      USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;174      if (pdev->cfg.dma_enable == 0)
000006  f894c003          LDRB     r12,[r4,#3]
00000a  f1bc0f00          CMP      r12,#0
;;;175      {
;;;176        uint32_t count32b= 0 , i= 0;
;;;177        __IO uint32_t *fifo;
;;;178        
;;;179        count32b =  (len + 3) / 4;
;;;180        fifo = pdev->regs.DFIFO[ch_ep_num];
;;;181        for (i = 0; i < count32b; i++, src+=4)
;;;182        {
;;;183          USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
;;;184        }
;;;185      }
;;;186      return status;
;;;187    }
00000e  bf1c              ITT      NE
000010  bc10              POPNE    {r4}
000012  4770              BXNE     lr
000014  f04f0c00          MOV      r12,#0                ;176
000018  eb040282          ADD      r2,r4,r2,LSL #2       ;180
00001c  1cdb              ADDS     r3,r3,#3              ;179
00001e  089b              LSRS     r3,r3,#2              ;179
000020  f8d220d0          LDR      r2,[r2,#0xd0]         ;180
000024  2b00              CMP      r3,#0                 ;181
000026  bf9c              ITT      LS
000028  bc10              POPLS    {r4}
00002a  4770              BXLS     lr
                  |L34.44|
00002c  f8514b04          LDR      r4,[r1],#4            ;183
000030  6014              STR      r4,[r2,#0]            ;183
000032  f10c0c01          ADD      r12,r12,#1            ;181
000036  4563              CMP      r3,r12                ;181
000038  d8f8              BHI      |L34.44|
00003a  bc10              POP      {r4}
00003c  4770              BX       lr
;;;188    
                          ENDP


;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\usb\\usb_core.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___10_usb_core_c_0d2ec05c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REVSH|
#line 144
|__asm___10_usb_core_c_0d2ec05c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
