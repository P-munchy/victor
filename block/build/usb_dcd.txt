; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\usb_dcd.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\usb_dcd.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DANKICORETECH_EMBEDDED_USE_HEATSHRINK -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\usb_dcd.crf arm_hal\lib\usb\usb_dcd.c]
                          THUMB

                          AREA ||i.DCD_DevConnect||, CODE, READONLY, ALIGN=1

                  DCD_DevConnect PROC
;;;384    */
;;;385    void  DCD_DevConnect (USB_OTG_CORE_HANDLE *pdev)
000000  6900              LDR      r0,[r0,#0x10]
;;;386    {
;;;387    #ifndef USE_OTG_MODE
;;;388      USB_OTG_DCTL_TypeDef  dctl;
;;;389      dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
000002  6841              LDR      r1,[r0,#4]
;;;390      /* Connect device */
;;;391      dctl.b.sftdiscon  = 0;
000004  f0210102          BIC      r1,r1,#2
;;;392      USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
000008  6041              STR      r1,[r0,#4]
;;;393      USB_OTG_BSP_mDelay(3);
00000a  2003              MOVS     r0,#3
00000c  f7ffbffe          B.W      USB_OTG_BSP_mDelay
;;;394    #endif
;;;395    }
;;;396    
                          ENDP


                          AREA ||i.DCD_DevDisconnect||, CODE, READONLY, ALIGN=1

                  DCD_DevDisconnect PROC
;;;402    */
;;;403    void  DCD_DevDisconnect (USB_OTG_CORE_HANDLE *pdev)
000000  6900              LDR      r0,[r0,#0x10]
;;;404    {
;;;405    #ifndef USE_OTG_MODE
;;;406      USB_OTG_DCTL_TypeDef  dctl;
;;;407      dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
000002  6841              LDR      r1,[r0,#4]
;;;408      /* Disconnect device for 3ms */
;;;409      dctl.b.sftdiscon  = 1;
000004  f0410102          ORR      r1,r1,#2
;;;410      USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
000008  6041              STR      r1,[r0,#4]
;;;411      USB_OTG_BSP_mDelay(3);
00000a  2003              MOVS     r0,#3
00000c  f7ffbffe          B.W      USB_OTG_BSP_mDelay
;;;412    #endif
;;;413    }
;;;414    
                          ENDP


                          AREA ||i.DCD_EP_Close||, CODE, READONLY, ALIGN=1

                  DCD_EP_Close PROC
;;;193    */
;;;194    uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
000000  460b              MOV      r3,r1
;;;195    {
;;;196      USB_OTG_EP *ep;
;;;197      
;;;198      if ((ep_addr&0x80) == 0x80)
000002  f0110f80          TST      r1,#0x80
;;;199      {
;;;200        ep = &pdev->dev.in_ep[ep_addr & 0x7F];
000006  f001027f          AND      r2,r1,#0x7f
00000a  b510              PUSH     {r4,lr}               ;195
00000c  eb020182          ADD      r1,r2,r2,LSL #2
000010  eb0001c1          ADD      r1,r0,r1,LSL #3
000014  bf14              ITE      NE
000016  f501718e          ADDNE    r1,r1,#0x11c
;;;201      }
;;;202      else
;;;203      {
;;;204        ep = &pdev->dev.out_ep[ep_addr & 0x7F];
00001a  f501715d          ADDEQ    r1,r1,#0x374
;;;205      }
;;;206      ep->num   = ep_addr & 0x7F;
00001e  700a              STRB     r2,[r1,#0]
;;;207      ep->is_in = (0x80 & ep_addr) != 0;
000020  09da              LSRS     r2,r3,#7
000022  704a              STRB     r2,[r1,#1]
;;;208      USB_OTG_EPDeactivate(pdev , ep );
000024  f7fffffe          BL       USB_OTG_EPDeactivate
;;;209      return 0;
000028  2000              MOVS     r0,#0
;;;210    }
00002a  bd10              POP      {r4,pc}
;;;211    
                          ENDP


                          AREA ||i.DCD_EP_ClrStall||, CODE, READONLY, ALIGN=1

                  DCD_EP_ClrStall PROC
;;;322    */
;;;323    uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
000000  b510              PUSH     {r4,lr}
;;;324    {
000002  460a              MOV      r2,r1
;;;325      USB_OTG_EP *ep;
;;;326      if ((0x80 & epnum) == 0x80)
000004  f0110f80          TST      r1,#0x80
;;;327      {
;;;328        ep = &pdev->dev.in_ep[epnum & 0x7F];    
000008  f002037f          AND      r3,r2,#0x7f
00000c  bf14              ITE      NE
00000e  eb030183          ADDNE    r1,r3,r3,LSL #2
;;;329      }
;;;330      else
;;;331      {
;;;332        ep = &pdev->dev.out_ep[epnum];
000012  eb020182          ADDEQ    r1,r2,r2,LSL #2
000016  eb0001c1          ADD      r1,r0,r1,LSL #3
00001a  bf14              ITE      NE                    ;328
00001c  f501718e          ADDNE    r1,r1,#0x11c          ;328
000020  f501715d          ADDEQ    r1,r1,#0x374
;;;333      }
;;;334      
;;;335      ep->is_stall = 0;  
000024  f04f0c00          MOV      r12,#0
000028  f881c002          STRB     r12,[r1,#2]
;;;336      ep->num   = epnum & 0x7F;
00002c  700b              STRB     r3,[r1,#0]
;;;337      ep->is_in = ((epnum & 0x80) == 0x80);
00002e  09d2              LSRS     r2,r2,#7
000030  704a              STRB     r2,[r1,#1]
;;;338      
;;;339      USB_OTG_EPClearStall(pdev , ep);
000032  f7fffffe          BL       USB_OTG_EPClearStall
;;;340      return (0);
000036  2000              MOVS     r0,#0
;;;341    }
000038  bd10              POP      {r4,pc}
;;;342    
                          ENDP


                          AREA ||i.DCD_EP_Flush||, CODE, READONLY, ALIGN=1

                  DCD_EP_Flush PROC
;;;349    */
;;;350    uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
000000  b510              PUSH     {r4,lr}
;;;351    {
;;;352    
;;;353      if ((epnum & 0x80) == 0x80)
000002  f0110f80          TST      r1,#0x80
000006  d004              BEQ      |L5.18|
;;;354      {
;;;355        USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
000008  f001017f          AND      r1,r1,#0x7f
00000c  f7fffffe          BL       USB_OTG_FlushTxFifo
000010  e001              B        |L5.22|
                  |L5.18|
;;;356      }
;;;357      else
;;;358      {
;;;359        USB_OTG_FlushRxFifo(pdev);
000012  f7fffffe          BL       USB_OTG_FlushRxFifo
                  |L5.22|
;;;360      }
;;;361    
;;;362      return (0);
000016  2000              MOVS     r0,#0
;;;363    }
000018  bd10              POP      {r4,pc}
;;;364    
                          ENDP


                          AREA ||i.DCD_EP_Open||, CODE, READONLY, ALIGN=1

                  DCD_EP_Open PROC
;;;154    */
;;;155    uint32_t DCD_EP_Open(USB_OTG_CORE_HANDLE *pdev , 
000000  b570              PUSH     {r4-r6,lr}
;;;156                         uint8_t ep_addr,
;;;157                         uint16_t ep_mps,
;;;158                         uint8_t ep_type)
;;;159    {
000002  460c              MOV      r4,r1
;;;160      USB_OTG_EP *ep;
;;;161      
;;;162      if ((ep_addr & 0x80) == 0x80)
000004  f0110f80          TST      r1,#0x80
;;;163      {
;;;164        ep = &pdev->dev.in_ep[ep_addr & 0x7F];
000008  f0010c7f          AND      r12,r1,#0x7f
00000c  eb0c018c          ADD      r1,r12,r12,LSL #2
000010  eb0001c1          ADD      r1,r0,r1,LSL #3
000014  bf14              ITE      NE
000016  f501718e          ADDNE    r1,r1,#0x11c
;;;165      }
;;;166      else
;;;167      {
;;;168        ep = &pdev->dev.out_ep[ep_addr & 0x7F];
00001a  f501715d          ADDEQ    r1,r1,#0x374
;;;169      }
;;;170      ep->num   = ep_addr & 0x7F;
00001e  f881c000          STRB     r12,[r1,#0]
;;;171      
;;;172      ep->is_in = (0x80 & ep_addr) != 0;
000022  09e4              LSRS     r4,r4,#7
000024  704c              STRB     r4,[r1,#1]
;;;173      ep->maxpacket = ep_mps;
;;;174      ep->type = ep_type;
000026  608a              STR      r2,[r1,#8]
000028  70cb              STRB     r3,[r1,#3]
;;;175      if (ep->is_in)
;;;176      {
;;;177        /* Assign a Tx FIFO */
;;;178        ep->tx_fifo_num = ep->num;
00002a  bf18              IT       NE
00002c  f8a1c006          STRHNE   r12,[r1,#6]
;;;179      }
;;;180      /* Set initial data PID. */
;;;181      if (ep_type == USB_OTG_EP_BULK )
000030  2b02              CMP      r3,#2
;;;182      {
;;;183        ep->data_pid_start = 0;
000032  bf04              ITT      EQ
000034  2200              MOVEQ    r2,#0
000036  710a              STRBEQ   r2,[r1,#4]
;;;184      }
;;;185      USB_OTG_EPActivate(pdev , ep );
000038  f7fffffe          BL       USB_OTG_EPActivate
;;;186      return 0;
00003c  2000              MOVS     r0,#0
;;;187    }
00003e  bd70              POP      {r4-r6,pc}
;;;188    /**
                          ENDP


                          AREA ||i.DCD_EP_PrepareRx||, CODE, READONLY, ALIGN=1

                  DCD_EP_PrepareRx PROC
;;;220    */
;;;221    uint32_t   DCD_EP_PrepareRx( USB_OTG_CORE_HANDLE *pdev,
000000  f0010c7f          AND      r12,r1,#0x7f
;;;222                                uint8_t   ep_addr,
;;;223                                uint8_t *pbuf,                        
;;;224                                uint16_t  buf_len)
;;;225    {
;;;226      USB_OTG_EP *ep;
;;;227      
;;;228      ep = &pdev->dev.out_ep[ep_addr & 0x7F];
000004  eb0c018c          ADD      r1,r12,r12,LSL #2
000008  eb0001c1          ADD      r1,r0,r1,LSL #3
00000c  b510              PUSH     {r4,lr}               ;225
00000e  f501715d          ADD      r1,r1,#0x374
;;;229      
;;;230      /*setup and start the Xfer */
;;;231      ep->xfer_buff = pbuf;  
;;;232      ep->xfer_len = buf_len;
;;;233      ep->xfer_count = 0;
000012  614b              STR      r3,[r1,#0x14]
000014  60ca              STR      r2,[r1,#0xc]
000016  2300              MOVS     r3,#0
;;;234      ep->is_in = 0;
000018  618b              STR      r3,[r1,#0x18]
00001a  704b              STRB     r3,[r1,#1]
;;;235      ep->num = ep_addr & 0x7F;
00001c  f881c000          STRB     r12,[r1,#0]
;;;236      
;;;237      if (pdev->cfg.dma_enable == 1)
000020  78c3              LDRB     r3,[r0,#3]
000022  2b01              CMP      r3,#1
;;;238      {
;;;239        ep->dma_addr = (uint32_t)pbuf;  
000024  bf08              IT       EQ
000026  610a              STREQ    r2,[r1,#0x10]
;;;240      }
;;;241      
;;;242      if ( ep->num == 0 )
000028  f01c0fff          TST      r12,#0xff
00002c  d003              BEQ      |L7.54|
;;;243      {
;;;244        USB_OTG_EP0StartXfer(pdev , ep);
;;;245      }
;;;246      else
;;;247      {
;;;248        USB_OTG_EPStartXfer(pdev, ep );
00002e  f7fffffe          BL       USB_OTG_EPStartXfer
                  |L7.50|
;;;249      }
;;;250      return 0;
000032  2000              MOVS     r0,#0
;;;251    }
000034  bd10              POP      {r4,pc}
                  |L7.54|
000036  f7fffffe          BL       USB_OTG_EP0StartXfer
00003a  e7fa              B        |L7.50|
;;;252    
                          ENDP


                          AREA ||i.DCD_EP_SetAddress||, CODE, READONLY, ALIGN=1

                  DCD_EP_SetAddress PROC
;;;371    */
;;;372    void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
000000  6900              LDR      r0,[r0,#0x10]
;;;373    {
;;;374      USB_OTG_DCFG_TypeDef  dcfg;
;;;375      dcfg.d32 = 0;
000002  2200              MOVS     r2,#0
;;;376      dcfg.b.devaddr = address;
000004  f361120a          BFI      r2,r1,#4,#7
;;;377      USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
000008  6801              LDR      r1,[r0,#0]
00000a  4311              ORRS     r1,r1,r2
00000c  6001              STR      r1,[r0,#0]
;;;378    }
00000e  4770              BX       lr
;;;379    
                          ENDP


                          AREA ||i.DCD_EP_Stall||, CODE, READONLY, ALIGN=1

                  DCD_EP_Stall PROC
;;;295    */
;;;296    uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
000000  b510              PUSH     {r4,lr}
;;;297    {
000002  460a              MOV      r2,r1
;;;298      USB_OTG_EP *ep;
;;;299      if ((0x80 & epnum) == 0x80)
000004  f0110f80          TST      r1,#0x80
;;;300      {
;;;301        ep = &pdev->dev.in_ep[epnum & 0x7F];
000008  f002037f          AND      r3,r2,#0x7f
00000c  bf14              ITE      NE
00000e  eb030183          ADDNE    r1,r3,r3,LSL #2
;;;302      }
;;;303      else
;;;304      {
;;;305        ep = &pdev->dev.out_ep[epnum];
000012  eb020182          ADDEQ    r1,r2,r2,LSL #2
000016  eb0001c1          ADD      r1,r0,r1,LSL #3
00001a  bf14              ITE      NE                    ;301
00001c  f501718e          ADDNE    r1,r1,#0x11c          ;301
000020  f501715d          ADDEQ    r1,r1,#0x374
;;;306      }
;;;307    
;;;308      ep->is_stall = 1;
000024  f04f0c01          MOV      r12,#1
000028  f881c002          STRB     r12,[r1,#2]
;;;309      ep->num   = epnum & 0x7F;
00002c  700b              STRB     r3,[r1,#0]
;;;310      ep->is_in = ((epnum & 0x80) == 0x80);
00002e  09d2              LSRS     r2,r2,#7
000030  704a              STRB     r2,[r1,#1]
;;;311      
;;;312      USB_OTG_EPSetStall(pdev , ep);
000032  f7fffffe          BL       USB_OTG_EPSetStall
;;;313      return (0);
000036  2000              MOVS     r0,#0
;;;314    }
000038  bd10              POP      {r4,pc}
;;;315    
                          ENDP


                          AREA ||i.DCD_EP_Tx||, CODE, READONLY, ALIGN=1

                  DCD_EP_Tx PROC
;;;260    */
;;;261    uint32_t  DCD_EP_Tx ( USB_OTG_CORE_HANDLE *pdev,
000000  f0110c7f          ANDS     r12,r1,#0x7f
;;;262                         uint8_t   ep_addr,
;;;263                         uint8_t   *pbuf,
;;;264                         uint32_t   buf_len)
;;;265    {
;;;266      USB_OTG_EP *ep;
;;;267      
;;;268      ep = &pdev->dev.in_ep[ep_addr & 0x7F];
000004  eb0c018c          ADD      r1,r12,r12,LSL #2
000008  b510              PUSH     {r4,lr}               ;265
00000a  eb0001c1          ADD      r1,r0,r1,LSL #3
00000e  f501718e          ADD      r1,r1,#0x11c
;;;269      
;;;270      /* Setup and start the Transfer */
;;;271      ep->is_in = 1;
000012  f04f0401          MOV      r4,#1
000016  704c              STRB     r4,[r1,#1]
;;;272      ep->num = ep_addr & 0x7F;  
000018  f881c000          STRB     r12,[r1,#0]
;;;273      ep->xfer_buff = pbuf;
;;;274      ep->dma_addr = (uint32_t)pbuf;  
00001c  60ca              STR      r2,[r1,#0xc]
;;;275      ep->xfer_count = 0;
00001e  610a              STR      r2,[r1,#0x10]
000020  f04f0200          MOV      r2,#0
000024  e9c13205          STRD     r3,r2,[r1,#0x14]
000028  d003              BEQ      |L10.50|
;;;276      ep->xfer_len  = buf_len;
;;;277      
;;;278      if ( ep->num == 0 )
;;;279      {
;;;280        USB_OTG_EP0StartXfer(pdev , ep);
;;;281      }
;;;282      else
;;;283      {
;;;284        USB_OTG_EPStartXfer(pdev, ep );
00002a  f7fffffe          BL       USB_OTG_EPStartXfer
                  |L10.46|
;;;285      }
;;;286      return 0;
00002e  2000              MOVS     r0,#0
;;;287    }
000030  bd10              POP      {r4,pc}
                  |L10.50|
000032  f7fffffe          BL       USB_OTG_EP0StartXfer
000036  e7fa              B        |L10.46|
;;;288    
                          ENDP


                          AREA ||i.DCD_GetEPStatus||, CODE, READONLY, ALIGN=1

                  DCD_GetEPStatus PROC
;;;422    
;;;423    uint32_t DCD_GetEPStatus(USB_OTG_CORE_HANDLE *pdev ,uint8_t epnum)
000000  f0110f80          TST      r1,#0x80
;;;424    {
;;;425      USB_OTG_EP *ep;
;;;426      uint32_t Status = 0;  
;;;427      
;;;428      if ((0x80 & epnum) == 0x80)
;;;429      {
;;;430        ep = &pdev->dev.in_ep[epnum & 0x7F];    
000004  bf18              IT       NE
000006  f001017f          ANDNE    r1,r1,#0x7f
;;;431      }
;;;432      else
;;;433      {
;;;434        ep = &pdev->dev.out_ep[epnum];
00000a  eb010181          ADD      r1,r1,r1,LSL #2
00000e  eb0001c1          ADD      r1,r0,r1,LSL #3
000012  bf14              ITE      NE                    ;430
000014  f501718e          ADDNE    r1,r1,#0x11c          ;430
000018  f501715d          ADDEQ    r1,r1,#0x374
;;;435      }
;;;436      
;;;437      Status = USB_OTG_GetEPStatus(pdev ,ep);
00001c  f7ffbffe          B.W      USB_OTG_GetEPStatus
;;;438    
;;;439      /* Return the current status */
;;;440      return Status;
;;;441    }
;;;442    
                          ENDP


                          AREA ||i.DCD_Init||, CODE, READONLY, ALIGN=1

                  DCD_Init PROC
;;;90     
;;;91     void DCD_Init(USB_OTG_CORE_HANDLE *pdev , 
000000  b510              PUSH     {r4,lr}
;;;92                   USB_OTG_CORE_ID_TypeDef coreID)
;;;93     {
000002  4604              MOV      r4,r0
;;;94       uint32_t i;
;;;95       USB_OTG_EP *ep;
;;;96       
;;;97       USB_OTG_SelectCore (pdev , coreID);
000004  f7fffffe          BL       USB_OTG_SelectCore
;;;98       
;;;99       pdev->dev.device_status = USB_OTG_DEFAULT;
000008  f04f0c01          MOV      r12,#1
00000c  f884c112          STRB     r12,[r4,#0x112]
;;;100      pdev->dev.device_address = 0;
000010  2000              MOVS     r0,#0
000012  f8840114          STRB     r0,[r4,#0x114]
;;;101      
;;;102      /* Init ep structure */
;;;103      for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
000016  7861              LDRB     r1,[r4,#1]
;;;104      {
;;;105        ep = &pdev->dev.in_ep[i];
;;;106        /* Init ep structure */
;;;107        ep->is_in = 1;
;;;108        ep->num = i;
;;;109        ep->tx_fifo_num = i;
;;;110        /* Control until ep is actvated */
;;;111        ep->type = EP_TYPE_CTRL;
;;;112        ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
000018  2340              MOVS     r3,#0x40
00001a  4602              MOV      r2,r0                 ;103
00001c  2900              CMP      r1,#0                 ;103
00001e  d911              BLS      |L12.68|
                  |L12.32|
000020  eb020182          ADD      r1,r2,r2,LSL #2       ;105
000024  eb0401c1          ADD      r1,r4,r1,LSL #3       ;105
000028  f501718e          ADD      r1,r1,#0x11c          ;105
00002c  f881c001          STRB     r12,[r1,#1]           ;107
000030  700a              STRB     r2,[r1,#0]            ;108
000032  80ca              STRH     r2,[r1,#6]            ;109
000034  70c8              STRB     r0,[r1,#3]            ;111
000036  e9c13002          STRD     r3,r0,[r1,#8]         ;111
00003a  6148              STR      r0,[r1,#0x14]         ;103
00003c  7861              LDRB     r1,[r4,#1]            ;103
00003e  1c52              ADDS     r2,r2,#1              ;103
000040  4291              CMP      r1,r2                 ;103
000042  d8ed              BHI      |L12.32|
                  |L12.68|
;;;113        ep->xfer_buff = 0;
;;;114        ep->xfer_len = 0;
;;;115      }
;;;116      
;;;117      for (i = 0; i < pdev->cfg.dev_endpoints; i++)
000044  2200              MOVS     r2,#0
000046  b2c9              UXTB     r1,r1
000048  2900              CMP      r1,#0
00004a  d910              BLS      |L12.110|
                  |L12.76|
;;;118      {
;;;119        ep = &pdev->dev.out_ep[i];
00004c  eb020182          ADD      r1,r2,r2,LSL #2
000050  eb0401c1          ADD      r1,r4,r1,LSL #3
000054  f501715d          ADD      r1,r1,#0x374
;;;120        /* Init ep structure */
;;;121        ep->is_in = 0;
000058  7048              STRB     r0,[r1,#1]
;;;122        ep->num = i;
00005a  700a              STRB     r2,[r1,#0]
;;;123        ep->tx_fifo_num = i;
00005c  80ca              STRH     r2,[r1,#6]
;;;124        /* Control until ep is activated */
;;;125        ep->type = EP_TYPE_CTRL;
00005e  70c8              STRB     r0,[r1,#3]
000060  e9c13002          STRD     r3,r0,[r1,#8]
000064  6148              STR      r0,[r1,#0x14]         ;117
000066  7861              LDRB     r1,[r4,#1]            ;117
000068  1c52              ADDS     r2,r2,#1              ;117
00006a  4291              CMP      r1,r2                 ;117
00006c  d8ee              BHI      |L12.76|
                  |L12.110|
;;;126        ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
;;;127        ep->xfer_buff = 0;
;;;128        ep->xfer_len = 0;
;;;129      }
;;;130      
;;;131      USB_OTG_DisableGlobalInt(pdev);
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       USB_OTG_DisableGlobalInt
;;;132      
;;;133      /*Init the Core (common init.) */
;;;134      USB_OTG_CoreInit(pdev);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       USB_OTG_CoreInit
;;;135    
;;;136    
;;;137      /* Force Device Mode*/
;;;138      USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
00007a  2100              MOVS     r1,#0
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       USB_OTG_SetCurrentMode
;;;139      
;;;140      /* Init Device */
;;;141      USB_OTG_CoreInitDev(pdev);
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       USB_OTG_CoreInitDev
;;;142      
;;;143      
;;;144      /* Enable USB Global interrupt */
;;;145      USB_OTG_EnableGlobalInt(pdev);
000088  4620              MOV      r0,r4
00008a  e8bd4010          POP      {r4,lr}
00008e  f7ffbffe          B.W      USB_OTG_EnableGlobalInt
;;;146    }
;;;147    
                          ENDP


                          AREA ||i.DCD_SetEPStatus||, CODE, READONLY, ALIGN=1

                  DCD_SetEPStatus PROC
;;;449    */
;;;450    void DCD_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum , uint32_t Status)
000000  f0110f80          TST      r1,#0x80
;;;451    {
;;;452      USB_OTG_EP *ep;
;;;453      
;;;454      if ((0x80 & epnum) == 0x80)
;;;455      {
;;;456        ep = &pdev->dev.in_ep[epnum & 0x7F];    
000004  bf18              IT       NE
000006  f001017f          ANDNE    r1,r1,#0x7f
;;;457      }
;;;458      else
;;;459      {
;;;460        ep = &pdev->dev.out_ep[epnum];
00000a  eb010181          ADD      r1,r1,r1,LSL #2
00000e  eb0001c1          ADD      r1,r0,r1,LSL #3
000012  bf14              ITE      NE                    ;456
000014  f501718e          ADDNE    r1,r1,#0x11c          ;456
000018  f501715d          ADDEQ    r1,r1,#0x374
;;;461      }
;;;462      
;;;463       USB_OTG_SetEPStatus(pdev ,ep , Status);
00001c  f7ffbffe          B.W      USB_OTG_SetEPStatus
;;;464    }
;;;465    
                          ENDP


;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\usb\\usb_dcd.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_usb_dcd_c_DCD_Init____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___9_usb_dcd_c_DCD_Init____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_usb_dcd_c_DCD_Init____REVSH|
#line 144
|__asm___9_usb_dcd_c_DCD_Init____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
