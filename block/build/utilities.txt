; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\utilities.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\utilities.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\utilities.crf ..\coretech\common\robot\src\utilities.cpp]
                          THUMB

                          AREA ||i._ZN4Anki8Embedded10GetTimeF32Ev||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded10GetTimeF32Ev PROC ; Anki::Embedded::GetTimeF32()
;;;199    
;;;200        f32 GetTimeF32()
000000  b510              PUSH     {r4,lr}
;;;201        {
;;;202    #if defined(_MSC_VER)
;;;203          f32 timeInSeconds;
;;;204    
;;;205          static f32 frequency = 0;
;;;206          static LONGLONG startCounter = 0;
;;;207    
;;;208          LARGE_INTEGER counter;
;;;209    
;;;210          if(frequency == 0) {
;;;211            LARGE_INTEGER frequencyTmp;
;;;212            QueryPerformanceFrequency(&frequencyTmp);
;;;213            frequency = (f32)frequencyTmp.QuadPart;
;;;214          }
;;;215    
;;;216          QueryPerformanceCounter(&counter);
;;;217    
;;;218          // Subtract startSeconds, so the floating point number has reasonable precision
;;;219          if(startCounter == 0) {
;;;220            startCounter = counter.QuadPart;
;;;221          }
;;;222    
;;;223          timeInSeconds = (f32)(counter.QuadPart - startCounter) / frequency;
;;;224    #elif defined(__APPLE_CC__)
;;;225          struct timeval time;
;;;226    #     ifndef ANKI_IOS_BUILD
;;;227          // TODO: Fix build error when using this in an iOS build for arm architectures
;;;228          gettimeofday(&time, NULL);
;;;229    #     endif
;;;230          // Subtract startSeconds, so the floating point number has reasonable precision
;;;231          static long startSeconds = 0;
;;;232          if(startSeconds == 0) {
;;;233            startSeconds = time.tv_sec;
;;;234          }
;;;235    
;;;236          const f32 timeInSeconds = (f32)(time.tv_sec-startSeconds) + ((f32)time.tv_usec / 1000000.0f);
;;;237    #elif defined(__EDG__)  // ARM-MDK
;;;238          const f32 timeInSeconds = Anki::Cozmo::HAL::GetMicroCounter() / 1000000.0f;
000002  f7fffffe          BL       _ZN4Anki5Cozmo3HAL15GetMicroCounterEv ; Anki::Cozmo::HAL::GetMicroCounter()
000006  ee000a10          VMOV     s0,r0
00000a  ed9f1a03          VLDR     s2,|L1.24|
00000e  eef80a40          VCVT.F32.U32 s1,s0
000012  ee800a81          VDIV.F32 s0,s1,s2
;;;239    #else // Generic Unix
;;;240          timespec ts;
;;;241          clock_gettime(CLOCK_MONOTONIC, &ts);
;;;242          const f32 timeInSeconds = (f32)(ts.tv_sec) + (f32)(ts.tv_nsec)/1000000000.0f;
;;;243    #endif
;;;244    
;;;245          return timeInSeconds;
;;;246        } // f32 GetTimeF32()
000016  bd10              POP      {r4,pc}
;;;247    
                          ENDP

                  |L1.24|
000018  49742400          DCFS     0x49742400 ; 1000000

                          AREA ||i._ZN4Anki8Embedded10GetTimeF64Ev||, CODE, READONLY, ALIGN=3

                  _ZN4Anki8Embedded10GetTimeF64Ev PROC ; Anki::Embedded::GetTimeF64()
;;;247    
;;;248        f64 GetTimeF64()
000000  b510              PUSH     {r4,lr}
;;;249        {
;;;250    #if defined(_MSC_VER)
;;;251          f64 timeInSeconds;
;;;252    
;;;253          static f64 frequency = 0;
;;;254          static LONGLONG startCounter = 0;
;;;255    
;;;256          LARGE_INTEGER counter;
;;;257    
;;;258          if(frequency == 0) {
;;;259            LARGE_INTEGER frequencyTmp;
;;;260            QueryPerformanceFrequency(&frequencyTmp);
;;;261            frequency = (f64)frequencyTmp.QuadPart;
;;;262          }
;;;263    
;;;264          QueryPerformanceCounter(&counter);
;;;265    
;;;266          // Subtract startSeconds, so the floating point number has reasonable precision
;;;267          if(startCounter == 0) {
;;;268            startCounter = counter.QuadPart;
;;;269          }
;;;270    
;;;271          timeInSeconds = (f64)(counter.QuadPart - startCounter) / frequency;
;;;272    #elif defined(__APPLE_CC__)
;;;273          struct timeval time;
;;;274    #     ifndef ANKI_IOS_BUILD
;;;275          // TODO: Fix build error when using this in an iOS build for arm architectures
;;;276          gettimeofday(&time, NULL);
;;;277    #     endif
;;;278          
;;;279          // Subtract startSeconds, so the floating point number has reasonable precision
;;;280          static long startSeconds = 0;
;;;281          if(startSeconds == 0) {
;;;282            startSeconds = time.tv_sec;
;;;283          }
;;;284    
;;;285          const f64 timeInSeconds = (f64)(time.tv_sec-startSeconds) + ((f64)time.tv_usec / 1000000.0);
;;;286    #elif defined(__EDG__)  // ARM-MDK
;;;287          const f64 timeInSeconds = Anki::Cozmo::HAL::GetMicroCounter() * (1.0 / 1000000.0);
000002  f7fffffe          BL       _ZN4Anki5Cozmo3HAL15GetMicroCounterEv ; Anki::Cozmo::HAL::GetMicroCounter()
000006  f7fffffe          BL       __aeabi_ui2d
00000a  ed9f1b05          VLDR     d1,|L2.32|
00000e  ec532b11          VMOV     r2,r3,d1
000012  f7fffffe          BL       __aeabi_dmul
000016  ec410b10          VMOV     d0,r0,r1
;;;288    #else // Generic Unix
;;;289          timespec ts;
;;;290          clock_gettime(CLOCK_MONOTONIC, &ts);
;;;291          const f64 timeInSeconds = (f64)(ts.tv_sec) + (f64)(ts.tv_nsec) * (1.0 / 1000000000.0);
;;;292    #endif
;;;293    
;;;294          return timeInSeconds;
;;;295        } // f64 GetTimeF64()
00001a  bd10              POP      {r4,pc}
;;;296    
                          ENDP

                          DCD      0x00000000
                  |L2.32|
000020  a0b5ed8d          DCFD     0x3eb0c6f7a0b5ed8d ; 9.9999999999999995e-07
000024  3eb0c6f7

                          AREA ||i._ZN4Anki8Embedded10GetTimeU32Ev||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded10GetTimeU32Ev PROC ; Anki::Embedded::GetTimeU32()
;;;296    
;;;297        u32 GetTimeU32()
000000  f7ffbffe          B.W      _ZN4Anki5Cozmo3HAL15GetMicroCounterEv ; Anki::Cozmo::HAL::GetMicroCounter()
;;;298        {
;;;299    #if defined(_MSC_VER)
;;;300          static LONGLONG startCounter = 0;
;;;301    
;;;302          LARGE_INTEGER counter;
;;;303    
;;;304          QueryPerformanceCounter(&counter);
;;;305    
;;;306          // Subtract startCounter, so the floating point number has reasonable precision
;;;307          if(startCounter == 0) {
;;;308            startCounter = counter.QuadPart;
;;;309          }
;;;310    
;;;311          return static_cast<u32>((counter.QuadPart - startCounter) & 0xFFFFFFFF);
;;;312    #elif defined(__APPLE_CC__)
;;;313          struct timeval time;
;;;314    #     ifndef ANKI_IOS_BUILD
;;;315          // TODO: Fix build error when using this in an iOS build for arm architectures
;;;316          gettimeofday(&time, NULL);
;;;317    #     endif 
;;;318          
;;;319          // Subtract startSeconds, so the floating point number has reasonable precision
;;;320          static long startSeconds = 0;
;;;321          if(startSeconds == 0) {
;;;322            startSeconds = time.tv_sec;
;;;323          }
;;;324    
;;;325          return (u32)(time.tv_sec-startSeconds)*1000000 + (u32)time.tv_usec;
;;;326    #elif defined (__EDG__)  // MDK-ARM
;;;327          return Anki::Cozmo::HAL::GetMicroCounter();
;;;328    #else
;;;329          timespec ts;
;;;330          clock_gettime(CLOCK_MONOTONIC, &ts);
;;;331          return (u32)ts.tv_sec * 1000000 + (u32)(ts.tv_nsec/1000);
;;;332    #endif
;;;333        } // u32 GetTimeU32()
;;;334    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded11GetCpuUsageEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded11GetCpuUsageEv PROC ; Anki::Embedded::GetCpuUsage()
;;;351    
;;;352        f32 GetCpuUsage()
000000  ed9f0a01          VLDR     s0,|L4.8|
;;;353        {
;;;354          static bool firstCall = true;
;;;355    
;;;356          f64 percentUsage;
;;;357    
;;;358    #if defined(_MSC_VER)
;;;359    
;;;360          FILETIME idleTime;
;;;361          FILETIME kernelTime;
;;;362          FILETIME userTime;
;;;363          GetSystemTimes(&idleTime, &kernelTime, &userTime);
;;;364    
;;;365          static FILETIME lastIdleTime;
;;;366          static FILETIME lastKernelTime;
;;;367          static FILETIME lastUserTime;
;;;368          // static s32 numCpus;
;;;369    
;;;370          if(firstCall) {
;;;371            // SYSTEM_INFO sysinfo;
;;;372            // GetSystemInfo( &sysinfo );
;;;373            // numCpus = sysinfo.dwNumberOfProcessors;
;;;374    
;;;375            percentUsage = 0;
;;;376            firstCall = false;
;;;377          } else {
;;;378            const u64 idleDelta = FiletimeDelta(idleTime, lastIdleTime);
;;;379            const u64 kernelDelta = FiletimeDelta(kernelTime, lastKernelTime);
;;;380            const u64 userDelta = FiletimeDelta(userTime, lastUserTime);
;;;381    
;;;382            const u64 totalSystemDelta = kernelDelta + userDelta;
;;;383    
;;;384            //percentUsage = 100.0f * static_cast<f32>(numCpus) * static_cast<f32>(totalSystemDelta - idleDelta) / static_cast<f32>(totalSystemDelta);
;;;385            percentUsage = 100.0 * static_cast<f64>(totalSystemDelta - idleDelta) / static_cast<f64>(totalSystemDelta);
;;;386          }
;;;387    
;;;388          lastIdleTime = idleTime;
;;;389          lastKernelTime = kernelTime;
;;;390          lastUserTime = userTime;
;;;391    
;;;392    #elif defined(__EDG__)  // ARM-MDK
;;;393          // Cannot query on the M4
;;;394          percentUsage = 0;
;;;395    #else // Generic Unix or OSX
;;;396    
;;;397          const f64 numCpus = sysconf( _SC_NPROCESSORS_ONLN );
;;;398    
;;;399          f64 curCpuTime;
;;;400          f64 curTime;
;;;401    
;;;402          static f64 lastCpuTime;
;;;403          static f64 lastTime;
;;;404    
;;;405          struct rusage usage;
;;;406          getrusage(RUSAGE_SELF, &usage);
;;;407    
;;;408          curTime = GetTimeF64();
;;;409    
;;;410          // User + system (kernel) time
;;;411          curCpuTime =
;;;412            static_cast<f64>(usage.ru_utime.tv_sec) + static_cast<f64>(usage.ru_utime.tv_usec) / 1000000.0 +
;;;413            static_cast<f64>(usage.ru_stime.tv_sec) + static_cast<f64>(usage.ru_stime.tv_usec) / 1000000.0;
;;;414    
;;;415          if(firstCall) {
;;;416            percentUsage = 0;
;;;417            firstCall = false;
;;;418          } else {
;;;419            // TODO: Check that everything works, with the number of cores and everything
;;;420            percentUsage = 100.0 * (curCpuTime - lastCpuTime) / (curTime - lastTime) / numCpus;
;;;421          }
;;;422    
;;;423          lastCpuTime = curCpuTime;
;;;424          lastTime = curTime;
;;;425    #endif
;;;426    
;;;427          return static_cast<f32>(percentUsage);
;;;428        } // f32 GetCpuUsage()
000004  4770              BX       lr
;;;429      } // namespace Embedded
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
000008  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki8Embedded15FindBytePatternEPKviPKhi||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FindBytePatternEPKviPKhi PROC ; Anki::Embedded::FindBytePattern(const void*, int, const unsigned char*, int)
;;;151    
;;;152        s32 FindBytePattern(const void * restrict buffer, const s32 bufferLength, const u8 * restrict bytePattern, const s32 bytePatternLength)
000000  b470              PUSH     {r4-r6}
;;;153        {
;;;154          s32 curIndex = 0;
000002  2400              MOVS     r4,#0
;;;155          s32 numBytesInPatternFound = 0;
000004  46a4              MOV      r12,r4
;;;156    
;;;157          // Check if the bytePattern is valid
;;;158    #if ANKI_DEBUG_LEVEL >= ANKI_DEBUG_ERRORS_AND_WARNS_AND_ASSERTS
;;;159          for(s32 i=0; i<bytePatternLength; i++) {
;;;160            for(s32 j=0; j<bytePatternLength; j++) {
;;;161              if(i == j)
;;;162                continue;
;;;163    
;;;164              if(bytePattern[i] == bytePattern[j]) {
;;;165                AnkiError("FindBytePattern", "bytePattern is not unique");
;;;166                return -1;
;;;167              }
;;;168            }
;;;169          }
;;;170    #endif
;;;171    
;;;172          const u8 * restrict bufferU8 = reinterpret_cast<const u8*>(buffer);
;;;173    
;;;174          while(curIndex < bufferLength) {
000006  2900              CMP      r1,#0
000008  dd17              BLE      |L5.58|
                  |L5.10|
;;;175            if(bufferU8[curIndex] == bytePattern[numBytesInPatternFound]) {
00000a  5d05              LDRB     r5,[r0,r4]
00000c  f812600c          LDRB     r6,[r2,r12]
000010  42b5              CMP      r5,r6
000012  bf08              IT       EQ
000014  f10c0c01          ADDEQ    r12,r12,#1
000018  d007              BEQ      |L5.42|
;;;176              numBytesInPatternFound++;
;;;177            } else if(bufferU8[curIndex] == bytePattern[0]) {
00001a  f892c000          LDRB     r12,[r2,#0]
00001e  4565              CMP      r5,r12
;;;178              numBytesInPatternFound = 1;
000020  bf0c              ITE      EQ
000022  f04f0c01          MOVEQ    r12,#1
;;;179            } else {
;;;180              numBytesInPatternFound = 0;
000026  f04f0c00          MOVNE    r12,#0
                  |L5.42|
00002a  1c64              ADDS     r4,r4,#1
;;;181            }
;;;182    
;;;183            curIndex++;
;;;184    
;;;185            if(numBytesInPatternFound == bytePatternLength) {
00002c  459c              CMP      r12,r3
00002e  d102              BNE      |L5.54|
;;;186              return curIndex - bytePatternLength;
000030  1ae0              SUBS     r0,r4,r3
;;;187            }
;;;188          } // while(curIndex < bufferLength)
;;;189    
;;;190          return -1;
;;;191        }
000032  bc70              POP      {r4-r6}
000034  4770              BX       lr
                  |L5.54|
000036  428c              CMP      r4,r1                 ;174
000038  dbe7              BLT      |L5.10|
                  |L5.58|
00003a  bc70              POP      {r4-r6}
00003c  f04f30ff          MOV      r0,#0xffffffff        ;190
000040  4770              BX       lr
;;;192    
                          ENDP


                          AREA ||i._ZN4Anki8Embedded7RandS32Eii||, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded7RandS32Eii PROC ; Anki::Embedded::RandS32(int, int)
;;;192    
;;;193        s32 RandS32(const s32 minLimit, const s32 maxLimit)
000000  b570              PUSH     {r4-r6,lr}
;;;194        {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;195          const s32 num = (rand() % (maxLimit - minLimit + 1)) + minLimit;
000006  f7fffffe          BL       rand
00000a  1b29              SUBS     r1,r5,r4
00000c  1c49              ADDS     r1,r1,#1
00000e  fb90f2f1          SDIV     r2,r0,r1
000012  fb010012          MLS      r0,r1,r2,r0
000016  4420              ADD      r0,r0,r4
;;;196    
;;;197          return num;
;;;198        }
000018  bd70              POP      {r4-r6,pc}
;;;199    
                          ENDP


                          AREA ||i.__sti___13_utilities_cpp_61c45304||, CODE, READONLY, ALIGN=2

                  __sti___13_utilities_cpp_61c45304 PROC
000000  4803              LDR      r0,|L7.16|
000002  ed9f0a02          VLDR     s0,|L7.12|
000006  ed800a00          VSTR     s0,[r0,#0]
00000a  4770              BX       lr
                          ENDP

                  |L7.12|
00000c  423df6f2          DCFS     0x423df6f2 ; 47.491157531738281
                  |L7.16|
                          DCD      ||.data||

                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki8Embedded15FindBytePatternEPKviPKhi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded15FindBytePatternEPKviPKhi||
                          DCD      0x00000001

                          AREA ||area_number.9||, LINKORDER=||i._ZN4Anki8Embedded7RandS32Eii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded7RandS32Eii||
                          DCD      0x00000001

                          AREA ||area_number.10||, LINKORDER=||i._ZN4Anki8Embedded10GetTimeF32Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded10GetTimeF32Ev||
                          DCD      0x00000001

                          AREA ||area_number.11||, LINKORDER=||i._ZN4Anki8Embedded10GetTimeF64Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded10GetTimeF64Ev||
                          DCD      0x00000001

                          AREA ||area_number.12||, LINKORDER=||i._ZN4Anki8Embedded10GetTimeU32Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded10GetTimeU32Ev||
                          DCD      0x00000001

                          AREA ||area_number.13||, LINKORDER=||i._ZN4Anki8Embedded11GetCpuUsageEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki8Embedded11GetCpuUsageEv||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i.__sti___13_utilities_cpp_61c45304||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___13_utilities_cpp_61c45304||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  _ZN4Anki5Cozmo21ROBOT_BOUNDING_RADIUSE ; Anki::Cozmo::ROBOT_BOUNDING_RADIUS
                          DCD      0x00000000

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___13_utilities_cpp_61c45304
