; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\utilities_c.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\utilities_c.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\utilities_c.crf ..\coretech\common\robot\src\utilities_c.c]
                          THUMB

                          AREA ||i.ComputeCRC32||, CODE, READONLY, ALIGN=2

                  ComputeCRC32 PROC
;;;489    // Based off Hacker's delight, 2nd edition
;;;490    u32 ComputeCRC32(const void * data, const s32 dataLength, const u32 initialCRC)
000000  b410              PUSH     {r4}
;;;491    {
000002  4684              MOV      r12,r0
;;;492      s32 i = 0;
000004  2300              MOVS     r3,#0
;;;493      u32 crc = initialCRC;
000006  4610              MOV      r0,r2
;;;494    
;;;495      for(i=0; i<dataLength; i++) {
000008  2900              CMP      r1,#0
;;;496        const s32 index = i;
;;;497        const u32 byte = ((u8*)data)[index];
;;;498        //CoreTechPrint("%d\n", byte);
;;;499        crc = (crc >> 8) ^ crc32Table[(crc ^ byte) & 0xFF];
00000a  bfce              ITEE     GT
00000c  4c07              LDRGT    r4,|L1.44|
;;;500        //CoreTechPrint("%d (%d) = 0x%x\n", i, byte, crc);
;;;501      }
;;;502    
;;;503      // Technically, this should return ~crc, but that would make it wierd to chain multiple calls of this function
;;;504      return crc;
;;;505    }
00000e  bc10              POPLE    {r4}
000010  4770              BXLE     lr
                  |L1.18|
000012  f81c2003          LDRB     r2,[r12,r3]           ;497
000016  1c5b              ADDS     r3,r3,#1              ;499
000018  4042              EORS     r2,r2,r0              ;499
00001a  b2d2              UXTB     r2,r2                 ;499
00001c  4299              CMP      r1,r3                 ;495
00001e  f8542022          LDR      r2,[r4,r2,LSL #2]     ;499
000022  ea822010          EOR      r0,r2,r0,LSR #8       ;499
000026  dcf4              BGT      |L1.18|
000028  bc10              POP      {r4}
00002a  4770              BX       lr
                          ENDP

                  |L1.44|
                          DCD      ||area_number.16||

                          AREA ||i.IsOdd||, CODE, READONLY, ALIGN=1

                  IsOdd PROC
;;;440    
;;;441    s32 IsOdd(const s32 x)
000000  f0100001          ANDS     r0,r0,#1
;;;442    {
;;;443      if(((x>>1)<<1) == x)
;;;444        return 0;
;;;445      else
;;;446        return 1;
000004  bf18              IT       NE
000006  2001              MOVNE    r0,#1
;;;447    }
000008  4770              BX       lr
;;;448    
                          ENDP


                          AREA ||i.IsPowerOfTwo||, CODE, READONLY, ALIGN=1

                  IsPowerOfTwo PROC
                  |L3.0|
;;;431    
;;;432    s32 IsPowerOfTwo(u32 x)
000000  f0100f01          TST      r0,#1
;;;433    {
;;;434      // While x is even and greater than 1, keep dividing by two
;;;435      while (((x & 1) == 0) && x > 1)
000004  d103              BNE      |L3.14|
000006  2801              CMP      r0,#1
;;;436        x >>= 1;
000008  bf88              IT       HI
00000a  0840              LSRHI    r0,r0,#1
00000c  d8f8              BHI      |L3.0|
                  |L3.14|
;;;437    
;;;438      return (x == 1);
00000e  2801              CMP      r0,#1
000010  bf18              IT       NE
000012  2000              MOVNE    r0,#0
;;;439    }
000014  4770              BX       lr
;;;440    
                          ENDP


                          AREA ||i.Log2u32||, CODE, READONLY, ALIGN=1

                  Log2u32 PROC
;;;448    
;;;449    u32 Log2u32(u32 x)
000000  4601              MOV      r1,r0
;;;450    {
;;;451      u32 powerCount = 0;
000002  2000              MOVS     r0,#0
;;;452      // While x is even and greater than 1, keep dividing by two
;;;453      while (x >>= 1) {
000004  0849              LSRS     r1,r1,#1
;;;454        powerCount++;
;;;455      }
;;;456    
;;;457      return powerCount;
;;;458    }
000006  bf08              IT       EQ
000008  4770              BXEQ     lr
                  |L4.10|
00000a  1c40              ADDS     r0,r0,#1
00000c  0849              LSRS     r1,r1,#1              ;453
00000e  d1fc              BNE      |L4.10|
000010  4770              BX       lr
;;;459    
                          ENDP


                          AREA ||i.Log2u64||, CODE, READONLY, ALIGN=1

                  Log2u64 PROC
;;;459    
;;;460    u64 Log2u64(u64 x)
000000  4602              MOV      r2,r0
;;;461    {
000002  460b              MOV      r3,r1
000004  b410              PUSH     {r4}
000006  2000              MOVS     r0,#0
;;;462      u64 powerCount = 0;
;;;463      // While x is even and greater than 1, keep dividing by two
;;;464      while (x >>= 1) {
000008  ea5f0c53          LSRS     r12,r3,#1
00000c  ea4f0432          RRX      r4,r2
000010  4601              MOV      r1,r0                 ;461
000012  ea54020c          ORRS     r2,r4,r12
;;;465        powerCount++;
;;;466      }
;;;467    
;;;468      return powerCount;
;;;469    }
000016  bf04              ITT      EQ
000018  bc10              POPEQ    {r4}
00001a  4770              BXEQ     lr
                  |L5.28|
00001c  1c40              ADDS     r0,r0,#1
00001e  f1410100          ADC      r1,r1,#0
000022  ea5f025c          LSRS     r2,r12,#1             ;464
000026  ea4f0334          RRX      r3,r4                 ;464
00002a  4694              MOV      r12,r2                ;464
00002c  461c              MOV      r4,r3                 ;464
00002e  431a              ORRS     r2,r2,r3              ;464
000030  d1f4              BNE      |L5.28|
000032  bc10              POP      {r4}
000034  4770              BX       lr
;;;470    
                          ENDP


                          AREA ||i.PrintF64||, CODE, READONLY, ALIGN=3

                  PrintF64 PROC
;;;124    
;;;125    void PrintF64(int (*writeChar)(int), f64 value)
000000  b570              PUSH     {r4-r6,lr}
;;;126    {
000002  0004              MOVS     r4,r0
000004  ed2d8b0c          VPUSH    {d8-d13}
000008  eeb09a40          VMOV.F32 s18,s0
00000c  eef09a60          VMOV.F32 s19,s1
;;;127      const s32 maxDecimalDigits = 6;
;;;128      f64 decimalPart;
;;;129    
;;;130      s32 numDecimalDigitsUsed = 0;
000010  f04f0500          MOV      r5,#0
;;;131    
;;;132      // If null, default to putchar
;;;133      if (writeChar == 0) {
;;;134        writeChar = putchar;
;;;135      }
;;;136    
;;;137      if(value < 0.0) {
;;;138        writeChar('-');
;;;139        value = -value;
;;;140      }
;;;141    
;;;142      decimalPart = value - (f64)floorf(value);
;;;143    
;;;144      // Print the part before the decimal digit
;;;145    
;;;146      if(value > 10000000000.0) {
000014  ed9fdb96          VLDR     d13,|L6.624|
;;;147        const f64 topPart = (f64)value / 10000000000.0;
;;;148        PrintS32(writeChar, (s32)floorf(topPart));
;;;149        writeChar('.');
;;;150        writeChar('.');
;;;151        writeChar('.');
;;;152        return;
;;;153      }
;;;154    
;;;155      // If value is close enough to the ceil value, just print the ceil value.
;;;156      if (FLT_NEAR(value, ceilf(value))) {
000018  ed9fca97          VLDR     s24,|L6.632|
;;;157        PrintS32(writeChar, (s32)ceilf(value));
;;;158        writeChar('.');
;;;159        writeChar('0');
;;;160        return;
;;;161      }
;;;162    
;;;163      PrintS32(writeChar, (s32)floorf(value));
;;;164    
;;;165      // The remainder of this function prints the part after the decimal digit
;;;166      value = decimalPart;
;;;167    
;;;168      writeChar('.');
;;;169    
;;;170      if(value < (1.0f / powf(10.0f, maxDecimalDigits-1))) {
;;;171        writeChar('0');
;;;172    
;;;173        return;
;;;174      }
;;;175    
;;;176      // This loop prints out the part after the decimal point
;;;177      while(value > 0.0f && numDecimalDigitsUsed < maxDecimalDigits) {
;;;178        s32 curDigit;
;;;179    
;;;180        numDecimalDigitsUsed++;
;;;181    
;;;182        value *= 10.0f;
;;;183    
;;;184        if(value < (1.0f - FLOATING_POINT_COMPARISON_TOLERANCE)) {
;;;185          writeChar('0');
;;;186          continue;
;;;187        }
;;;188    
;;;189        if (FLT_NEAR(value, ceilf(value))) {
;;;190          curDigit = (s32) DBL_ROUND(value);
00001c  ed9fab98          VLDR     d10,|L6.640|
000020  ed9fbb99          VLDR     d11,|L6.648|
000024  bf08              IT       EQ                    ;134
000026  4c9a              LDREQ    r4,|L6.656|
000028  ec532b1b          VMOV     r2,r3,d11             ;137
00002c  ec510b19          VMOV     r0,r1,d9              ;137
000030  f7fffffe          BL       __aeabi_cdcmple
000034  d207              BCS      |L6.70|
000036  202d              MOVS     r0,#0x2d              ;138
000038  47a0              BLX      r4                    ;138
00003a  ec510b19          VMOV     r0,r1,d9              ;139
00003e  f7fffffe          BL       __aeabi_dneg
000042  ec410b19          VMOV     d9,r0,r1              ;139
                  |L6.70|
000046  ec510b19          VMOV     r0,r1,d9              ;142
00004a  f7fffffe          BL       __aeabi_d2f
00004e  4606              MOV      r6,r0                 ;142
000050  ee006a10          VMOV     s0,r6                 ;142
000054  f7fffffe          BL       __hardfp_floorf
000058  ee100a10          VMOV     r0,s0                 ;142
00005c  f7fffffe          BL       __aeabi_f2d
000060  ec532b19          VMOV     r2,r3,d9              ;142
000064  f7fffffe          BL       __aeabi_drsub
000068  ec410b18          VMOV     d8,r0,r1              ;142
00006c  ec532b1d          VMOV     r2,r3,d13             ;146
000070  ec510b19          VMOV     r0,r1,d9              ;146
000074  f7fffffe          BL       __aeabi_cdrcmple
000078  d21d              BCS      |L6.182|
00007a  ec532b1d          VMOV     r2,r3,d13             ;147
00007e  ec510b19          VMOV     r0,r1,d9              ;147
000082  f7fffffe          BL       __aeabi_ddiv
000086  f7fffffe          BL       __aeabi_d2f
00008a  ee000a10          VMOV     s0,r0                 ;148
00008e  f7fffffe          BL       __hardfp_floorf
000092  eebd0ac0          VCVT.S32.F32 s0,s0                 ;148
000096  4620              MOV      r0,r4                 ;148
000098  ee101a10          VMOV     r1,s0                 ;148
00009c  f7fffffe          BL       PrintS32
0000a0  202e              MOVS     r0,#0x2e              ;149
0000a2  47a0              BLX      r4                    ;149
0000a4  202e              MOVS     r0,#0x2e              ;150
0000a6  47a0              BLX      r4                    ;150
0000a8  ecbd8b0c          VPOP     {d8-d13}              ;151
0000ac  46a4              MOV      r12,r4                ;151
0000ae  202e              MOVS     r0,#0x2e              ;151
0000b0  e8bd4070          POP      {r4-r6,lr}            ;151
0000b4  4760              BX       r12                   ;151
                  |L6.182|
0000b6  ee006a10          VMOV     s0,r6                 ;156
0000ba  f7fffffe          BL       __hardfp_ceilf
0000be  ee300a4c          VSUB.F32 s0,s0,s24             ;156
0000c2  ee100a10          VMOV     r0,s0                 ;156
0000c6  f7fffffe          BL       __aeabi_f2d
0000ca  ec532b19          VMOV     r2,r3,d9              ;156
0000ce  f7fffffe          BL       __aeabi_cdcmple
0000d2  d222              BCS      |L6.282|
0000d4  ee006a10          VMOV     s0,r6                 ;156
0000d8  f7fffffe          BL       __hardfp_ceilf
0000dc  ee300a0c          VADD.F32 s0,s0,s24             ;156
0000e0  ee100a10          VMOV     r0,s0                 ;156
0000e4  f7fffffe          BL       __aeabi_f2d
0000e8  ec532b19          VMOV     r2,r3,d9              ;156
0000ec  f7fffffe          BL       __aeabi_cdrcmple
0000f0  d213              BCS      |L6.282|
0000f2  ee006a10          VMOV     s0,r6                 ;157
0000f6  f7fffffe          BL       __hardfp_ceilf
0000fa  eebd0ac0          VCVT.S32.F32 s0,s0                 ;157
0000fe  4620              MOV      r0,r4                 ;157
000100  ee101a10          VMOV     r1,s0                 ;157
000104  f7fffffe          BL       PrintS32
000108  202e              MOVS     r0,#0x2e              ;158
00010a  47a0              BLX      r4                    ;158
00010c  ecbd8b0c          VPOP     {d8-d13}              ;159
000110  46a4              MOV      r12,r4                ;159
000112  2030              MOVS     r0,#0x30              ;159
000114  e8bd4070          POP      {r4-r6,lr}            ;159
000118  4760              BX       r12                   ;159
                  |L6.282|
00011a  ee006a10          VMOV     s0,r6                 ;163
00011e  f7fffffe          BL       __hardfp_floorf
000122  eebd0ac0          VCVT.S32.F32 s0,s0                 ;163
000126  4620              MOV      r0,r4                 ;163
000128  ee101a10          VMOV     r1,s0                 ;163
00012c  f7fffffe          BL       PrintS32
000130  202e              MOVS     r0,#0x2e              ;168
000132  47a0              BLX      r4                    ;168
000134  eef10a04          VMOV.F32 s1,#5.00000000        ;170
000138  eeb20a04          VMOV.F32 s0,#10.00000000       ;170
00013c  f7fffffe          BL       __hardfp_powf
000140  eeb71a00          VMOV.F32 s2,#1.00000000        ;170
000144  eec10a00          VDIV.F32 s1,s2,s0              ;170
000148  ee100a90          VMOV     r0,s1                 ;170
00014c  f7fffffe          BL       __aeabi_f2d
000150  ec532b18          VMOV     r2,r3,d8              ;170
000154  f7fffffe          BL       __aeabi_cdrcmple
000158  bf24              ITT      CS                    ;182
00015a  ed9f9b4f          VLDRCS   d9,|L6.664|
00015e  ed9fdb50          VLDRCS   d13,|L6.672|
000162  d276              BCS      |L6.594|
000164  ecbd8b0c          VPOP     {d8-d13}              ;171
000168  46a4              MOV      r12,r4                ;171
00016a  2030              MOVS     r0,#0x30              ;171
00016c  e8bd4070          POP      {r4-r6,lr}            ;171
000170  4760              BX       r12                   ;171
                  |L6.370|
000172  ec532b19          VMOV     r2,r3,d9              ;182
000176  ec510b18          VMOV     r0,r1,d8              ;182
00017a  1c6d              ADDS     r5,r5,#1              ;182
00017c  f7fffffe          BL       __aeabi_dmul
000180  ec410b18          VMOV     d8,r0,r1              ;182
000184  ec532b1d          VMOV     r2,r3,d13             ;184
000188  f7fffffe          BL       __aeabi_cdcmple
00018c  d202              BCS      |L6.404|
00018e  2030              MOVS     r0,#0x30              ;185
000190  47a0              BLX      r4                    ;185
000192  e05e              B        |L6.594|
                  |L6.404|
000194  ec510b18          VMOV     r0,r1,d8              ;189
000198  f7fffffe          BL       __aeabi_d2f
00019c  4606              MOV      r6,r0                 ;189
00019e  ee006a10          VMOV     s0,r6                 ;189
0001a2  f7fffffe          BL       __hardfp_ceilf
0001a6  ee300a4c          VSUB.F32 s0,s0,s24             ;189
0001aa  ee100a10          VMOV     r0,s0                 ;189
0001ae  f7fffffe          BL       __aeabi_f2d
0001b2  ec532b18          VMOV     r2,r3,d8              ;189
0001b6  f7fffffe          BL       __aeabi_cdcmple
0001ba  d231              BCS      |L6.544|
0001bc  ee006a10          VMOV     s0,r6                 ;189
0001c0  f7fffffe          BL       __hardfp_ceilf
0001c4  ee300a0c          VADD.F32 s0,s0,s24             ;189
0001c8  ee100a10          VMOV     r0,s0                 ;189
0001cc  f7fffffe          BL       __aeabi_f2d
0001d0  ec532b18          VMOV     r2,r3,d8              ;189
0001d4  f7fffffe          BL       __aeabi_cdrcmple
0001d8  d222              BCS      |L6.544|
0001da  eeb00a4b          VMOV.F32 s0,s22
0001de  eef00a6b          VMOV.F32 s1,s23
0001e2  ec532b10          VMOV     r2,r3,d0
0001e6  ec510b18          VMOV     r0,r1,d8
0001ea  f7fffffe          BL       __aeabi_cdrcmple
0001ee  ec532b1a          VMOV     r2,r3,d10
0001f2  ec510b18          VMOV     r0,r1,d8
0001f6  d206              BCS      |L6.518|
0001f8  f7fffffe          BL       __aeabi_dadd
0001fc  ec410b10          VMOV     d0,r0,r1
000200  f7fffffe          BL       __hardfp_floor
000204  e005              B        |L6.530|
                  |L6.518|
000206  f7fffffe          BL       __aeabi_dsub
00020a  ec410b10          VMOV     d0,r0,r1
00020e  f7fffffe          BL       __hardfp_ceil
                  |L6.530|
000212  ec510b10          VMOV     r0,r1,d0
000216  f7fffffe          BL       __aeabi_d2iz
00021a  4606              MOV      r6,r0
;;;191          numDecimalDigitsUsed = maxDecimalDigits; // To exit while loop since this is the last digit we want to print
00021c  2506              MOVS     r5,#6
00021e  e007              B        |L6.560|
                  |L6.544|
;;;192        } else {
;;;193          curDigit = (s32)(floorf((f32)(value)));
000220  ee006a10          VMOV     s0,r6
000224  f7fffffe          BL       __hardfp_floorf
000228  eebd0ac0          VCVT.S32.F32 s0,s0
00022c  ee106a10          VMOV     r6,s0
                  |L6.560|
;;;194        }
;;;195    
;;;196        // This if statement should nenver be true, but it sometimes is on the myriad1. This will output "BUG".
;;;197        //if(value < 0.0f){
;;;198        //  writeChar('B');
;;;199        //  writeChar('U');
;;;200        //  writeChar('G');
;;;201        //  writeChar('4');
;;;202        //  return;
;;;203        //}
;;;204    
;;;205        //if(ABS(value) < 0.00000000001f){
;;;206        //  writeChar('B');
;;;207        //  writeChar('U');
;;;208        //  writeChar('G');
;;;209        //  writeChar('5');
;;;210        //  return;
;;;211        //}
;;;212    
;;;213        //if(curDigit < 0){
;;;214        //  writeChar('B');
;;;215        //  writeChar('U');
;;;216        //  writeChar('G');
;;;217        //  writeChar('6');
;;;218        //  return;
;;;219        //}
;;;220    
;;;221        writeChar(curDigit + 48);
000230  f1060030          ADD      r0,r6,#0x30
000234  47a0              BLX      r4
;;;222    
;;;223        value = value - (f32)curDigit;
000236  ee006a10          VMOV     s0,r6
00023a  eeb80ac0          VCVT.F32.S32 s0,s0
00023e  ee100a10          VMOV     r0,s0
000242  f7fffffe          BL       __aeabi_f2d
000246  ec532b18          VMOV     r2,r3,d8
00024a  f7fffffe          BL       __aeabi_drsub
00024e  ec410b18          VMOV     d8,r0,r1
                  |L6.594|
000252  ec532b1b          VMOV     r2,r3,d11             ;177
000256  ec510b18          VMOV     r0,r1,d8              ;177
00025a  f7fffffe          BL       __aeabi_cdrcmple
;;;224      }
;;;225    
;;;226      return;
;;;227    } // void printFloat(f32 value)
00025e  bf24              ITT      CS
000260  ecbd8b0c          VPOPCS   {d8-d13}
000264  bd70              POPCS    {r4-r6,pc}
000266  2d06              CMP      r5,#6                 ;177
000268  db83              BLT      |L6.370|
00026a  ecbd8b0c          VPOP     {d8-d13}
00026e  bd70              POP      {r4-r6,pc}
;;;228    
                          ENDP

                  |L6.624|
000270  20000000          DCFD     0x4202a05f20000000 ; 10000000000
000274  4202a05f
                  |L6.632|
000278  3727c5ac          DCFS     0x3727c5ac ; 9.9999997473787516e-06
                          DCD      0x00000000
                  |L6.640|
000280  00000000          DCFD     0x3fe0000000000000 ; 0.5
000284  3fe00000
                  |L6.648|
000288  00000000          DCFD     0x0000000000000000 ; 0
00028c  00000000
                  |L6.656|
                          DCD      putchar
                          DCD      0x00000000
                  |L6.664|
000298  00000000          DCFD     0x4024000000000000 ; 10
00029c  40240000
                  |L6.672|
0002a0  00000000          DCFD     0x3fefffeb00000000 ; 0.99998998641967773
0002a4  3fefffeb

                          AREA ||i.PrintF64WithExponent||, CODE, READONLY, ALIGN=2

                  PrintF64WithExponent PROC
;;;228    
;;;229    void PrintF64WithExponent(int (*writeChar)(int), f64 value)
000000  b538              PUSH     {r3-r5,lr}
;;;230    {
000002  0004              MOVS     r4,r0
;;;231      double significand;
;;;232      int exponent;
;;;233    
;;;234      // If null, default to putchar
;;;235      if (writeChar == 0) {
;;;236        writeChar = putchar;
000004  bf08              IT       EQ
000006  4c0f              LDREQ    r4,|L7.68|
;;;237      }
;;;238    
;;;239      significand = frexpf(value, &exponent);
000008  ec510b10          VMOV     r0,r1,d0
00000c  f7fffffe          BL       __aeabi_d2f
000010  ee000a10          VMOV     s0,r0
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       __hardfp_frexpf
00001a  ee100a10          VMOV     r0,s0
00001e  f7fffffe          BL       __aeabi_f2d
000022  ec410b10          VMOV     d0,r0,r1
;;;240    
;;;241      PrintF64(writeChar, significand);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       PrintF64
;;;242      writeChar('*');
00002c  202a              MOVS     r0,#0x2a
00002e  47a0              BLX      r4
;;;243      writeChar('2');
000030  2032              MOVS     r0,#0x32
000032  47a0              BLX      r4
;;;244      writeChar('^');
000034  205e              MOVS     r0,#0x5e
000036  47a0              BLX      r4
;;;245    
;;;246      PrintS32(writeChar, exponent);
000038  4620              MOV      r0,r4
00003a  9900              LDR      r1,[sp,#0]
00003c  f7fffffe          BL       PrintS32
;;;247    
;;;248      return;
;;;249    } // void printFloat(f32 value)
000040  bd38              POP      {r3-r5,pc}
;;;250    
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      putchar

                          AREA ||i.PrintS32||, CODE, READONLY, ALIGN=2

                  PrintS32 PROC
;;;289    
;;;290    void PrintS32(int (*writeChar)(int), s32 value)
000000  b570              PUSH     {r4-r6,lr}
;;;291    {
000002  460c              MOV      r4,r1
000004  b0b2              SUB      sp,sp,#0xc8
000006  4605              MOV      r5,r0
;;;292      int digits[MAX_PRINTF_DIGITS];
;;;293    
;;;294      s32 digitIndex = -1;
;;;295    
;;;296      for(digitIndex=0; digitIndex<MAX_PRINTF_DIGITS; digitIndex++) {
000008  2100              MOVS     r1,#0
00000a  4608              MOV      r0,r1
00000c  466e              MOV      r6,sp                 ;292
                  |L8.14|
;;;297        digits[digitIndex] = 0;
00000e  f8460021          STR      r0,[r6,r1,LSL #2]
000012  1c49              ADDS     r1,r1,#1
000014  2932              CMP      r1,#0x32              ;296
000016  dbfa              BLT      |L8.14|
;;;298      }
;;;299    
;;;300      // If null, default to putchar
;;;301      if (writeChar == 0) {
000018  2d00              CMP      r5,#0
;;;302        writeChar = putchar;
00001a  bf08              IT       EQ
00001c  4d17              LDREQ    r5,|L8.124|
;;;303      }
;;;304    
;;;305      if(value < 0) {
00001e  2c00              CMP      r4,#0
000020  da02              BGE      |L8.40|
;;;306        writeChar('-');
000022  202d              MOVS     r0,#0x2d
000024  47a8              BLX      r5
;;;307        value = -value;
000026  4264              RSBS     r4,r4,#0
                  |L8.40|
;;;308      }
;;;309    
;;;310      if(value == 0) {
000028  2c00              CMP      r4,#0
;;;311        writeChar('0');
;;;312        return;
;;;313      }
;;;314    
;;;315      digitIndex=0;
00002a  bf18              IT       NE
00002c  2100              MOVNE    r1,#0
;;;316      while(value > 0) {
;;;317        const s32 curDigit = (value - (10*(value/10)));
00002e  bfc8              IT       GT
000030  4b13              LDRGT    r3,|L8.128|
000032  d01e              BEQ      |L8.114|
000034  dd11              BLE      |L8.90|
                  |L8.54|
000036  fb832004          SMULL    r2,r0,r3,r4
00003a  ea4f02a0          ASR      r2,r0,#2
00003e  eba272e0          SUB      r2,r2,r0,ASR #31
000042  f1c20000          RSB      r0,r2,#0
000046  eb000080          ADD      r0,r0,r0,LSL #2
00004a  eb040040          ADD      r0,r4,r0,LSL #1
;;;318        //const int curDigit = ABS(value) % 10;
;;;319    
;;;320        // This if statement should never be true, but it sometimes is on the myriad1. This will output "BUG".
;;;321        //if(value < 0){
;;;322        //  // BUG1
;;;323        //  digits[digitIndex++] = 1;
;;;324        //  digits[digitIndex++] = 23;
;;;325        //  digits[digitIndex++] = 37;
;;;326        //  digits[digitIndex++] = 18;
;;;327        //  break;
;;;328        //}
;;;329    
;;;330        //if(value == 0){
;;;331        //  // BUG2
;;;332        //  digits[digitIndex++] = 2;
;;;333        //  digits[digitIndex++] = 23;
;;;334        //  digits[digitIndex++] = 37;
;;;335        //  digits[digitIndex++] = 18;
;;;336        //  break;
;;;337        //}
;;;338    
;;;339        //if(curDigit < 0){
;;;340        //  // BUG3
;;;341        //  digits[digitIndex++] = 3;
;;;342        //  digits[digitIndex++] = 23;
;;;343        //  digits[digitIndex++] = 37;
;;;344        //  digits[digitIndex++] = 18;
;;;345        //  break;
;;;346        //}
;;;347    
;;;348        digits[digitIndex++] = curDigit;
00004e  f8460021          STR      r0,[r6,r1,LSL #2]
000052  f1010101          ADD      r1,r1,#1
;;;349    
;;;350        value /= 10;
000056  1e14              SUBS     r4,r2,#0
000058  dced              BGT      |L8.54|
                  |L8.90|
;;;351      }
;;;352    
;;;353      digitIndex--;
00005a  1e4c              SUBS     r4,r1,#1
;;;354      for( ; digitIndex>=0; digitIndex--) {
;;;355        writeChar(digits[digitIndex] + 48);
;;;356      }
;;;357    
;;;358      return;
;;;359    } // void printInt(s32 value)
00005c  bf44              ITT      MI
00005e  b032              ADDMI    sp,sp,#0xc8
000060  bd70              POPMI    {r4-r6,pc}
                  |L8.98|
000062  f8560024          LDR      r0,[r6,r4,LSL #2]     ;355
000066  3030              ADDS     r0,r0,#0x30           ;355
000068  47a8              BLX      r5                    ;355
00006a  1e64              SUBS     r4,r4,#1              ;355
00006c  d5f9              BPL      |L8.98|
00006e  b032              ADD      sp,sp,#0xc8
000070  bd70              POP      {r4-r6,pc}
                  |L8.114|
000072  2030              MOVS     r0,#0x30              ;311
000074  47a8              BLX      r5                    ;311
000076  b032              ADD      sp,sp,#0xc8
000078  bd70              POP      {r4-r6,pc}
;;;360    
                          ENDP

00007a  0000              DCW      0x0000
                  |L8.124|
                          DCD      putchar
                  |L8.128|
                          DCD      0x66666667

                          AREA ||i.PrintU32Hex||, CODE, READONLY, ALIGN=2

                  PrintU32Hex PROC
;;;360    
;;;361    void PrintU32Hex(int (*writeChar)(int), u32 value)
000000  b570              PUSH     {r4-r6,lr}
;;;362    {
000002  b0b2              SUB      sp,sp,#0xc8
000004  4605              MOV      r5,r0
;;;363      int digits[MAX_PRINTF_DIGITS];
;;;364    
;;;365      s32 digitIndex = -1;
;;;366    
;;;367      for(digitIndex=0; digitIndex<MAX_PRINTF_DIGITS; digitIndex++) {
000006  2200              MOVS     r2,#0
000008  4610              MOV      r0,r2
00000a  466e              MOV      r6,sp                 ;363
                  |L9.12|
;;;368        digits[digitIndex] = 0;
00000c  f8460022          STR      r0,[r6,r2,LSL #2]
000010  1c52              ADDS     r2,r2,#1
000012  2a32              CMP      r2,#0x32              ;367
000014  dbfa              BLT      |L9.12|
;;;369      }
;;;370    
;;;371      // If null, default to putchar
;;;372      if (writeChar == 0) {
000016  2d00              CMP      r5,#0
;;;373        writeChar = putchar;
000018  bf08              IT       EQ
00001a  4d11              LDREQ    r5,|L9.96|
;;;374      }
;;;375    
;;;376      if(value == 0) {
00001c  2900              CMP      r1,#0
;;;377        writeChar('0');
;;;378        return;
;;;379      }
;;;380    
;;;381      digitIndex=0;
00001e  bf18              IT       NE
000020  2200              MOVNE    r2,#0
000022  d019              BEQ      |L9.88|
                  |L9.36|
;;;382      while(value > 0) {
;;;383        const s32 curDigit = (value - (16*(value/16)));
000024  0908              LSRS     r0,r1,#4
000026  4243              RSBS     r3,r0,#0
000028  eb011103          ADD      r1,r1,r3,LSL #4
;;;384        //const int curDigit = ABS(value) % 10;
;;;385    
;;;386        // This if statement should never be true, but it sometimes is on the myriad1. This will output "BUG".
;;;387        //if(value < 0){
;;;388        //  // BUG1
;;;389        //  digits[digitIndex++] = 1;
;;;390        //  digits[digitIndex++] = 23;
;;;391        //  digits[digitIndex++] = 37;
;;;392        //  digits[digitIndex++] = 18;
;;;393        //  break;
;;;394        //}
;;;395    
;;;396        //if(value == 0){
;;;397        //  // BUG2
;;;398        //  digits[digitIndex++] = 2;
;;;399        //  digits[digitIndex++] = 23;
;;;400        //  digits[digitIndex++] = 37;
;;;401        //  digits[digitIndex++] = 18;
;;;402        //  break;
;;;403        //}
;;;404    
;;;405        //if(curDigit < 0){
;;;406        //  // BUG3
;;;407        //  digits[digitIndex++] = 3;
;;;408        //  digits[digitIndex++] = 23;
;;;409        //  digits[digitIndex++] = 37;
;;;410        //  digits[digitIndex++] = 18;
;;;411        //  break;
;;;412        //}
;;;413    
;;;414        digits[digitIndex++] = curDigit;
00002c  f8461022          STR      r1,[r6,r2,LSL #2]
000030  1c52              ADDS     r2,r2,#1
;;;415    
;;;416        value /= 16;
000032  0001              MOVS     r1,r0
000034  d1f6              BNE      |L9.36|
;;;417      }
;;;418    
;;;419      digitIndex--;
000036  1e54              SUBS     r4,r2,#1
;;;420      for( ; digitIndex>=0; digitIndex--) {
;;;421        const s32 curDigit = digits[digitIndex];
;;;422        if(curDigit < 10) {
;;;423          writeChar(curDigit + 48);
;;;424        } else {
;;;425          writeChar(curDigit + 55);
;;;426        }
;;;427      }
;;;428    
;;;429      return;
;;;430    } // void printInt(s32 value)
000038  bf44              ITT      MI
00003a  b032              ADDMI    sp,sp,#0xc8
00003c  bd70              POPMI    {r4-r6,pc}
                  |L9.62|
00003e  f8561024          LDR      r1,[r6,r4,LSL #2]     ;421
000042  290a              CMP      r1,#0xa               ;422
000044  bfb4              ITE      LT                    ;423
000046  f1010030          ADDLT    r0,r1,#0x30           ;423
00004a  f1010037          ADDGE    r0,r1,#0x37           ;425
00004e  47a8              BLX      r5                    ;425
000050  1e64              SUBS     r4,r4,#1              ;425
000052  d5f4              BPL      |L9.62|
000054  b032              ADD      sp,sp,#0xc8
000056  bd70              POP      {r4-r6,pc}
                  |L9.88|
000058  2030              MOVS     r0,#0x30              ;377
00005a  47a8              BLX      r5                    ;377
00005c  b032              ADD      sp,sp,#0xc8
00005e  bd70              POP      {r4-r6,pc}
;;;431    
                          ENDP

                  |L9.96|
                          DCD      putchar

                          AREA ||i.SnprintfCommasS32||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  SnprintfCommasS32 PROC
;;;250    
;;;251    s32 SnprintfCommasS32(char *buffer, const s32 bufferLength, const s32 value)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;252    {
000004  b0a0              SUB      sp,sp,#0x80
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
00000a  4617              MOV      r7,r2
;;;253      s32 numberLength;
;;;254      s32 numCommas;
;;;255      s32 numWritten;
;;;256      s32 iOut;
;;;257    
;;;258      char tmpBuffer[128];
;;;259    
;;;260      snprintf(tmpBuffer, 128, "%d", value);
00000c  4613              MOV      r3,r2
00000e  a222              ADR      r2,|L10.152|
000010  2180              MOVS     r1,#0x80
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       __2snprintf
;;;261    
;;;262      numberLength = (s32)(strlen(tmpBuffer));
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       strlen
;;;263    
;;;264      if(value < 0)
;;;265        numCommas = (numberLength-2) / 3;
00001e  4e1f              LDR      r6,|L10.156|
000020  2f00              CMP      r7,#0                 ;264
000022  bfb4              ITE      LT
000024  1e81              SUBLT    r1,r0,#2
;;;266      else
;;;267        numCommas = (numberLength-1) / 3;
000026  1e41              SUBGE    r1,r0,#1
000028  fb861201          SMULL    r1,r2,r6,r1
00002c  eba272e2          SUB      r2,r2,r2,ASR #31
;;;268    
;;;269      if((numberLength + numCommas + 1) > bufferLength)
000030  eb000c02          ADD      r12,r0,r2
000034  f10c0101          ADD      r1,r12,#1
000038  42a9              CMP      r1,r5
;;;270        return 0;
00003a  bfc2              ITTT     GT
00003c  2000              MOVGT    r0,#0
;;;271    
;;;272      numWritten = 0;
;;;273      iOut = numberLength + numCommas - 1;
;;;274      while(iOut >= 0) {
;;;275        if(numWritten > 0 && (numWritten%3 == 0) && (tmpBuffer[numberLength - numWritten - 1] != '-')) {
;;;276          buffer[iOut] = ',';
;;;277          iOut--;
;;;278        }
;;;279    
;;;280        buffer[iOut] = tmpBuffer[numberLength - numWritten - 1];
;;;281        iOut--;
;;;282        numWritten++;
;;;283      }
;;;284    
;;;285      buffer[numberLength + numCommas] = '\0';
;;;286    
;;;287      return numberLength + numCommas;
;;;288    }
00003e  b020              ADDGT    sp,sp,#0x80
000040  e8bd81f0          POPGT    {r4-r8,pc}
000044  2200              MOVS     r2,#0                 ;272
000046  f1bc0101          SUBS     r1,r12,#1             ;273
00004a  bf5c              ITT      PL                    ;276
00004c  272c              MOVPL    r7,#0x2c              ;276
00004e  466d              MOVPL    r5,sp                 ;258
000050  d41a              BMI      |L10.136|
                  |L10.82|
000052  2a00              CMP      r2,#0                 ;275
000054  dd0f              BLE      |L10.118|
000056  fb868302          SMULL    r8,r3,r6,r2           ;275
00005a  eba373e3          SUB      r3,r3,r3,ASR #31      ;275
00005e  eba30383          SUB      r3,r3,r3,LSL #2       ;275
000062  42d3              CMN      r3,r2                 ;275
000064  d107              BNE      |L10.118|
000066  1a83              SUBS     r3,r0,r2              ;275
000068  442b              ADD      r3,r3,r5              ;275
00006a  f8133c01          LDRB     r3,[r3,#-1]           ;275
00006e  2b2d              CMP      r3,#0x2d              ;275
000070  bf1c              ITT      NE                    ;276
000072  5467              STRBNE   r7,[r4,r1]            ;276
000074  1e49              SUBNE    r1,r1,#1              ;276
                  |L10.118|
000076  1a83              SUBS     r3,r0,r2              ;280
000078  442b              ADD      r3,r3,r5              ;280
00007a  f1020201          ADD      r2,r2,#1              ;280
00007e  f8133c01          LDRB     r3,[r3,#-1]           ;280
000082  5463              STRB     r3,[r4,r1]            ;280
000084  1e49              SUBS     r1,r1,#1              ;280
000086  d5e4              BPL      |L10.82|
                  |L10.136|
000088  2000              MOVS     r0,#0                 ;285
00008a  f804000c          STRB     r0,[r4,r12]           ;285
00008e  b020              ADD      sp,sp,#0x80
000090  4660              MOV      r0,r12                ;285
000092  e8bd81f0          POP      {r4-r8,pc}
;;;289    
                          ENDP

000096  0000              DCW      0x0000
                  |L10.152|
000098  256400            DCB      "%d",0
00009b  00                DCB      0
                  |L10.156|
                          DCD      0x55555556

                          AREA ||i.explicitPrintf||, CODE, READONLY, ALIGN=2

                  explicitPrintf PROC
;;;20     #if 1
;;;21     void explicitPrintf(int (*writeChar)(int), int reverseEachFourCharacters, const char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;22     {
000002  e92d4ff0          PUSH     {r4-r11,lr}
000006  b0b3              SUB      sp,sp,#0xcc
000008  0007              MOVS     r7,r0
;;;23       const char * const formatStart = format;
00000a  9b3e              LDR      r3,[sp,#0xf8]
;;;24       int numCharacters;
;;;25       int i;
;;;26       va_list arguments;
;;;27     
;;;28       // If null, default to putchar
;;;29       if (writeChar == 0) {
;;;30         writeChar = putchar;
00000c  bf08              IT       EQ
00000e  4f76              LDREQ    r7,|L11.488|
;;;31       }
;;;32     
;;;33       // Count the number of characters
;;;34       numCharacters = 0;
000010  f04f0900          MOV      r9,#0
;;;35       while(*format != 0x00)
000014  7818              LDRB     r0,[r3,#0]
000016  b138              CBZ      r0,|L11.40|
                  |L11.24|
;;;36       {
;;;37         numCharacters++;
;;;38         format++;
000018  983e              LDR      r0,[sp,#0xf8]
00001a  f1090901          ADD      r9,r9,#1              ;35
00001e  1c40              ADDS     r0,r0,#1
000020  903e              STR      r0,[sp,#0xf8]         ;35
000022  7800              LDRB     r0,[r0,#0]            ;35
000024  2800              CMP      r0,#0                 ;35
000026  d1f7              BNE      |L11.24|
                  |L11.40|
;;;39       }
;;;40       format = formatStart;
;;;41     
;;;42       if(reverseEachFourCharacters)
000028  933e              STR      r3,[sp,#0xf8]
00002a  2900              CMP      r1,#0
00002c  bf18              IT       NE
00002e  f1090903          ADDNE    r9,r9,#3
;;;43         numCharacters += 3;
;;;44     
;;;45       numCharacters = MIN(numCharacters, PRINTF_BUFFER_SIZE-5);
000032  486e              LDR      r0,|L11.492|
000034  eb100009          ADDS     r0,r0,r9
000038  bfa8              IT       GE
00003a  f24039fb          MOVGE    r9,#0x3fb
00003e  f04f0c00          MOV      r12,#0
;;;46     
;;;47       // Reverse the string
;;;48       if(reverseEachFourCharacters) {
;;;49         for(i=0; i<numCharacters; i+=4) {
;;;50           printfBuffer[i] = format[i+3];
000042  f8dfb1ac          LDR      r11,|L11.496|
;;;51           if(format[i+3] == 0x00) {
;;;52             printfBuffer[i+1] = 0x00;
;;;53           } else {
;;;54             printfBuffer[i+1] = format[i+2];
;;;55             if(format[i+2] == 0x00) {
;;;56               printfBuffer[i+2] = 0x00;
;;;57             } else {
;;;58               printfBuffer[i+2] = format[i+1];
;;;59               if(format[i+1] == 0x00) {
;;;60                 printfBuffer[i+3] = 0x00;
;;;61               } else {
;;;62                 printfBuffer[i+3] = format[i];
;;;63               }
;;;64             }
;;;65           }
;;;66         }
;;;67       } else {
;;;68         for(i=0; i<numCharacters; i++) {
000046  4660              MOV      r0,r12
000048  b329              CBZ      r1,|L11.150|
00004a  f1b90f00          CMP      r9,#0                 ;49
00004e  dd2b              BLE      |L11.168|
                  |L11.80|
000050  1819              ADDS     r1,r3,r0              ;50
000052  78ca              LDRB     r2,[r1,#3]            ;50
000054  f84b2020          STR      r2,[r11,r0,LSL #2]    ;50
000058  78ca              LDRB     r2,[r1,#3]            ;51
00005a  2a00              CMP      r2,#0                 ;51
00005c  bf04              ITT      EQ                    ;52
00005e  eb0b0180          ADDEQ    r1,r11,r0,LSL #2      ;52
000062  f8c1c004          STREQ    r12,[r1,#4]           ;52
000066  d012              BEQ      |L11.142|
000068  eb0b0280          ADD      r2,r11,r0,LSL #2      ;54
00006c  788c              LDRB     r4,[r1,#2]            ;54
00006e  6054              STR      r4,[r2,#4]            ;55
000070  788c              LDRB     r4,[r1,#2]            ;55
000072  2c00              CMP      r4,#0                 ;55
000074  bf08              IT       EQ                    ;56
000076  f8c2c008          STREQ    r12,[r2,#8]           ;56
00007a  d008              BEQ      |L11.142|
00007c  784c              LDRB     r4,[r1,#1]            ;58
00007e  6094              STR      r4,[r2,#8]            ;59
000080  7849              LDRB     r1,[r1,#1]            ;59
000082  2900              CMP      r1,#0                 ;59
000084  bf0e              ITEE     EQ                    ;60
000086  f8c2c00c          STREQ    r12,[r2,#0xc]         ;60
00008a  5c19              LDRBNE   r1,[r3,r0]            ;62
00008c  60d1              STRNE    r1,[r2,#0xc]          ;62
                  |L11.142|
00008e  1d00              ADDS     r0,r0,#4              ;62
000090  4548              CMP      r0,r9                 ;49
000092  dbdd              BLT      |L11.80|
000094  e008              B        |L11.168|
                  |L11.150|
000096  f1b90f00          CMP      r9,#0
00009a  dd05              BLE      |L11.168|
                  |L11.156|
;;;69           printfBuffer[i] = format[i];
00009c  5c19              LDRB     r1,[r3,r0]
00009e  f84b1020          STR      r1,[r11,r0,LSL #2]
0000a2  1c40              ADDS     r0,r0,#1
0000a4  4581              CMP      r9,r0                 ;68
0000a6  dcf9              BGT      |L11.156|
                  |L11.168|
;;;70         }
;;;71       }
;;;72     
;;;73       va_start(arguments, format);
;;;74     
;;;75       for(i=0; i<numCharacters; i++) {
0000a8  2600              MOVS     r6,#0
0000aa  ac3f              ADD      r4,sp,#0xfc           ;73
0000ac  f1b90f00          CMP      r9,#0
0000b0  bfcf              ITEEE    GT
0000b2  46ea              MOVGT    r10,sp
;;;76         if(printfBuffer[i] == '%') {
;;;77           const char percentChar = printfBuffer[i+1];
;;;78           i++;
;;;79     
;;;80           if(percentChar == 'd') {
;;;81             const s32 value = va_arg(arguments, s32);
;;;82             PrintS32(writeChar, value);
;;;83             format++;
;;;84           } else if(percentChar == 'x') {
;;;85             const u32 value = va_arg(arguments, u32);
;;;86             PrintU32Hex(writeChar, value);
;;;87             format++;
;;;88           } else if(percentChar == 'f') {
;;;89             // TODO: should this be double?
;;;90             const f64 value = va_arg(arguments, f64);
;;;91             PrintF64(writeChar, value);
;;;92             format++;
;;;93           } else if(percentChar == 'e') {
;;;94             // TODO: should this be double?
;;;95             const f64 value = va_arg(arguments, f64);
;;;96             PrintF64WithExponent(writeChar, value);
;;;97             format++;
;;;98           } else if(percentChar == 's') {
;;;99             const char * stringArgument = va_arg(arguments, char*);
;;;100            while(*stringArgument != 0x00) {
;;;101              writeChar(*stringArgument);
;;;102              stringArgument++;
;;;103            }
;;;104          }
;;;105          else {
;;;106            if(printfBuffer[i] == 0x00)
;;;107              break;
;;;108    
;;;109            writeChar('%');
;;;110            writeChar(printfBuffer[i]);
;;;111          }
;;;112        } else {
;;;113          if(printfBuffer[i] == 0x00)
;;;114            break;
;;;115    
;;;116          writeChar(printfBuffer[i]);
;;;117        }
;;;118      } // for(i=0; i<numCharacters; i++)
;;;119    
;;;120      va_end(arguments);
;;;121    }
0000b4  b033              ADDLE    sp,sp,#0xcc
0000b6  e8bd0ff0          POPLE    {r4-r11}
0000ba  f85dfb14          LDRLE    pc,[sp],#0x14
                  |L11.190|
0000be  f85b0026          LDR      r0,[r11,r6,LSL #2]    ;76
0000c2  2825              CMP      r0,#0x25              ;76
0000c4  d00a              BEQ      |L11.220|
0000c6  2800              CMP      r0,#0                 ;113
0000c8  d003              BEQ      |L11.210|
0000ca  47b8              BLX      r7                    ;116
                  |L11.204|
0000cc  1c76              ADDS     r6,r6,#1              ;116
0000ce  454e              CMP      r6,r9                 ;75
0000d0  dbf5              BLT      |L11.190|
                  |L11.210|
0000d2  b033              ADD      sp,sp,#0xcc
0000d4  e8bd0ff0          POP      {r4-r11}
0000d8  f85dfb14          LDR      pc,[sp],#0x14
                  |L11.220|
0000dc  eb0b0086          ADD      r0,r11,r6,LSL #2      ;77
0000e0  1c76              ADDS     r6,r6,#1              ;77
0000e2  7900              LDRB     r0,[r0,#4]            ;77
0000e4  2864              CMP      r0,#0x64              ;80
0000e6  d011              BEQ      |L11.268|
0000e8  2878              CMP      r0,#0x78              ;84
0000ea  d013              BEQ      |L11.276|
0000ec  2866              CMP      r0,#0x66              ;88
0000ee  d03f              BEQ      |L11.368|
0000f0  2865              CMP      r0,#0x65              ;93
0000f2  d046              BEQ      |L11.386|
0000f4  2873              CMP      r0,#0x73              ;98
0000f6  d069              BEQ      |L11.460|
0000f8  f85b0026          LDR      r0,[r11,r6,LSL #2]    ;106
0000fc  2800              CMP      r0,#0                 ;106
0000fe  d0e8              BEQ      |L11.210|
000100  2025              MOVS     r0,#0x25              ;109
000102  47b8              BLX      r7                    ;109
000104  f85b0026          LDR      r0,[r11,r6,LSL #2]    ;110
000108  47b8              BLX      r7                    ;110
00010a  e7df              B        |L11.204|
                  |L11.268|
00010c  f8541b04          LDR      r1,[r4],#4            ;81
000110  4638              MOV      r0,r7                 ;82
000112  e058              B        |L11.454|
                  |L11.276|
000114  f8540b04          LDR      r0,[r4],#4            ;85
000118  2100              MOVS     r1,#0                 ;85
00011a  46b8              MOV      r8,r7                 ;86
00011c  460a              MOV      r2,r1                 ;86
                  |L11.286|
00011e  f84a2021          STR      r2,[r10,r1,LSL #2]    ;86
000122  1c49              ADDS     r1,r1,#1              ;86
000124  2932              CMP      r1,#0x32              ;86
000126  dbfa              BLT      |L11.286|
000128  f1b80f00          CMP      r8,#0                 ;86
00012c  bf08              IT       EQ                    ;86
00012e  f8df80b8          LDREQ    r8,|L11.488|
000132  2800              CMP      r0,#0                 ;86
000134  bf18              IT       NE                    ;86
000136  2100              MOVNE    r1,#0                 ;86
000138  d014              BEQ      |L11.356|
                  |L11.314|
00013a  0902              LSRS     r2,r0,#4              ;86
00013c  4253              RSBS     r3,r2,#0              ;86
00013e  eb001003          ADD      r0,r0,r3,LSL #4       ;86
000142  f84a0021          STR      r0,[r10,r1,LSL #2]    ;86
000146  1c49              ADDS     r1,r1,#1              ;86
000148  0010              MOVS     r0,r2                 ;86
00014a  d1f6              BNE      |L11.314|
00014c  1e4d              SUBS     r5,r1,#1              ;86
00014e  d40b              BMI      |L11.360|
                  |L11.336|
000150  f85a0025          LDR      r0,[r10,r5,LSL #2]    ;86
000154  280a              CMP      r0,#0xa               ;86
000156  bfb4              ITE      LT                    ;86
000158  3030              ADDLT    r0,r0,#0x30           ;86
00015a  3037              ADDGE    r0,r0,#0x37           ;86
00015c  47c0              BLX      r8                    ;86
00015e  1e6d              SUBS     r5,r5,#1              ;86
000160  d5f6              BPL      |L11.336|
000162  e001              B        |L11.360|
                  |L11.356|
000164  2030              MOVS     r0,#0x30              ;86
000166  47c0              BLX      r8                    ;86
                  |L11.360|
000168  983e              LDR      r0,[sp,#0xf8]         ;87
00016a  1c40              ADDS     r0,r0,#1              ;87
00016c  903e              STR      r0,[sp,#0xf8]         ;88
00016e  e7ad              B        |L11.204|
                  |L11.368|
000170  1de0              ADDS     r0,r4,#7              ;90
000172  f0200407          BIC      r4,r0,#7              ;90
000176  4638              MOV      r0,r7                 ;91
000178  ecb40b02          VLDM     r4!,{d0}              ;90
00017c  f7fffffe          BL       PrintF64
000180  e7f2              B        |L11.360|
                  |L11.386|
000182  1de0              ADDS     r0,r4,#7              ;95
000184  f0200407          BIC      r4,r0,#7              ;95
000188  003d              MOVS     r5,r7                 ;96
00018a  ecb40b02          VLDM     r4!,{d0}              ;95
00018e  bf08              IT       EQ                    ;95
000190  4d15              LDREQ    r5,|L11.488|
000192  ec510b10          VMOV     r0,r1,d0              ;95
000196  f7fffffe          BL       __aeabi_d2f
00019a  ee000a10          VMOV     s0,r0                 ;95
00019e  4668              MOV      r0,sp                 ;95
0001a0  f7fffffe          BL       __hardfp_frexpf
0001a4  ee100a10          VMOV     r0,s0                 ;95
0001a8  f7fffffe          BL       __aeabi_f2d
0001ac  ec410b10          VMOV     d0,r0,r1              ;95
0001b0  4628              MOV      r0,r5                 ;95
0001b2  f7fffffe          BL       PrintF64
0001b6  202a              MOVS     r0,#0x2a              ;95
0001b8  47a8              BLX      r5                    ;95
0001ba  2032              MOVS     r0,#0x32              ;95
0001bc  47a8              BLX      r5                    ;95
0001be  205e              MOVS     r0,#0x5e              ;95
0001c0  47a8              BLX      r5                    ;95
0001c2  4628              MOV      r0,r5                 ;95
0001c4  9900              LDR      r1,[sp,#0]            ;95
                  |L11.454|
0001c6  f7fffffe          BL       PrintS32
0001ca  e7cd              B        |L11.360|
                  |L11.460|
0001cc  f8545b04          LDR      r5,[r4],#4            ;99
0001d0  7828              LDRB     r0,[r5,#0]            ;100
0001d2  2800              CMP      r0,#0                 ;100
0001d4  f43faf7a          BEQ      |L11.204|
                  |L11.472|
0001d8  b2c0              UXTB     r0,r0                 ;101
0001da  47b8              BLX      r7                    ;101
0001dc  f8150f01          LDRB     r0,[r5,#1]!           ;100
0001e0  2800              CMP      r0,#0                 ;100
0001e2  d1f9              BNE      |L11.472|
0001e4  e772              B        |L11.204|
;;;122    
                          ENDP

0001e6  0000              DCW      0x0000
                  |L11.488|
                          DCD      putchar
                  |L11.492|
                          DCD      0xfffffc05
                  |L11.496|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  printfBuffer
                          %        4096

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ANY_CAMERA
                          DCD      0xffffffff

                          AREA ||area_number.16||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.constdata||
                  crc32Table
                          DCD      0x00000000
                          DCD      0x77073096
                          DCD      0xee0e612c
                          DCD      0x990951ba
                          DCD      0x076dc419
                          DCD      0x706af48f
                          DCD      0xe963a535
                          DCD      0x9e6495a3
                          DCD      0x0edb8832
                          DCD      0x79dcb8a4
                          DCD      0xe0d5e91e
                          DCD      0x97d2d988
                          DCD      0x09b64c2b
                          DCD      0x7eb17cbd
                          DCD      0xe7b82d07
                          DCD      0x90bf1d91
                          DCD      0x1db71064
                          DCD      0x6ab020f2
                          DCD      0xf3b97148
                          DCD      0x84be41de
                          DCD      0x1adad47d
                          DCD      0x6ddde4eb
                          DCD      0xf4d4b551
                          DCD      0x83d385c7
                          DCD      0x136c9856
                          DCD      0x646ba8c0
                          DCD      0xfd62f97a
                          DCD      0x8a65c9ec
                          DCD      0x14015c4f
                          DCD      0x63066cd9
                          DCD      0xfa0f3d63
                          DCD      0x8d080df5
                          DCD      0x3b6e20c8
                          DCD      0x4c69105e
                          DCD      0xd56041e4
                          DCD      0xa2677172
                          DCD      0x3c03e4d1
                          DCD      0x4b04d447
                          DCD      0xd20d85fd
                          DCD      0xa50ab56b
                          DCD      0x35b5a8fa
                          DCD      0x42b2986c
                          DCD      0xdbbbc9d6
                          DCD      0xacbcf940
                          DCD      0x32d86ce3
                          DCD      0x45df5c75
                          DCD      0xdcd60dcf
                          DCD      0xabd13d59
                          DCD      0x26d930ac
                          DCD      0x51de003a
                          DCD      0xc8d75180
                          DCD      0xbfd06116
                          DCD      0x21b4f4b5
                          DCD      0x56b3c423
                          DCD      0xcfba9599
                          DCD      0xb8bda50f
                          DCD      0x2802b89e
                          DCD      0x5f058808
                          DCD      0xc60cd9b2
                          DCD      0xb10be924
                          DCD      0x2f6f7c87
                          DCD      0x58684c11
                          DCD      0xc1611dab
                          DCD      0xb6662d3d
                          DCD      0x76dc4190
                          DCD      0x01db7106
                          DCD      0x98d220bc
                          DCD      0xefd5102a
                          DCD      0x71b18589
                          DCD      0x06b6b51f
                          DCD      0x9fbfe4a5
                          DCD      0xe8b8d433
                          DCD      0x7807c9a2
                          DCD      0x0f00f934
                          DCD      0x9609a88e
                          DCD      0xe10e9818
                          DCD      0x7f6a0dbb
                          DCD      0x086d3d2d
                          DCD      0x91646c97
                          DCD      0xe6635c01
                          DCD      0x6b6b51f4
                          DCD      0x1c6c6162
                          DCD      0x856530d8
                          DCD      0xf262004e
                          DCD      0x6c0695ed
                          DCD      0x1b01a57b
                          DCD      0x8208f4c1
                          DCD      0xf50fc457
                          DCD      0x65b0d9c6
                          DCD      0x12b7e950
                          DCD      0x8bbeb8ea
                          DCD      0xfcb9887c
                          DCD      0x62dd1ddf
                          DCD      0x15da2d49
                          DCD      0x8cd37cf3
                          DCD      0xfbd44c65
                          DCD      0x4db26158
                          DCD      0x3ab551ce
                          DCD      0xa3bc0074
                          DCD      0xd4bb30e2
                          DCD      0x4adfa541
                          DCD      0x3dd895d7
                          DCD      0xa4d1c46d
                          DCD      0xd3d6f4fb
                          DCD      0x4369e96a
                          DCD      0x346ed9fc
                          DCD      0xad678846
                          DCD      0xda60b8d0
                          DCD      0x44042d73
                          DCD      0x33031de5
                          DCD      0xaa0a4c5f
                          DCD      0xdd0d7cc9
                          DCD      0x5005713c
                          DCD      0x270241aa
                          DCD      0xbe0b1010
                          DCD      0xc90c2086
                          DCD      0x5768b525
                          DCD      0x206f85b3
                          DCD      0xb966d409
                          DCD      0xce61e49f
                          DCD      0x5edef90e
                          DCD      0x29d9c998
                          DCD      0xb0d09822
                          DCD      0xc7d7a8b4
                          DCD      0x59b33d17
                          DCD      0x2eb40d81
                          DCD      0xb7bd5c3b
                          DCD      0xc0ba6cad
                          DCD      0xedb88320
                          DCD      0x9abfb3b6
                          DCD      0x03b6e20c
                          DCD      0x74b1d29a
                          DCD      0xead54739
                          DCD      0x9dd277af
                          DCD      0x04db2615
                          DCD      0x73dc1683
                          DCD      0xe3630b12
                          DCD      0x94643b84
                          DCD      0x0d6d6a3e
                          DCD      0x7a6a5aa8
                          DCD      0xe40ecf0b
                          DCD      0x9309ff9d
                          DCD      0x0a00ae27
                          DCD      0x7d079eb1
                          DCD      0xf00f9344
                          DCD      0x8708a3d2
                          DCD      0x1e01f268
                          DCD      0x6906c2fe
                          DCD      0xf762575d
                          DCD      0x806567cb
                          DCD      0x196c3671
                          DCD      0x6e6b06e7
                          DCD      0xfed41b76
                          DCD      0x89d32be0
                          DCD      0x10da7a5a
                          DCD      0x67dd4acc
                          DCD      0xf9b9df6f
                          DCD      0x8ebeeff9
                          DCD      0x17b7be43
                          DCD      0x60b08ed5
                          DCD      0xd6d6a3e8
                          DCD      0xa1d1937e
                          DCD      0x38d8c2c4
                          DCD      0x4fdff252
                          DCD      0xd1bb67f1
                          DCD      0xa6bc5767
                          DCD      0x3fb506dd
                          DCD      0x48b2364b
                          DCD      0xd80d2bda
                          DCD      0xaf0a1b4c
                          DCD      0x36034af6
                          DCD      0x41047a60
                          DCD      0xdf60efc3
                          DCD      0xa867df55
                          DCD      0x316e8eef
                          DCD      0x4669be79
                          DCD      0xcb61b38c
                          DCD      0xbc66831a
                          DCD      0x256fd2a0
                          DCD      0x5268e236
                          DCD      0xcc0c7795
                          DCD      0xbb0b4703
                          DCD      0x220216b9
                          DCD      0x5505262f
                          DCD      0xc5ba3bbe
                          DCD      0xb2bd0b28
                          DCD      0x2bb45a92
                          DCD      0x5cb36a04
                          DCD      0xc2d7ffa7
                          DCD      0xb5d0cf31
                          DCD      0x2cd99e8b
                          DCD      0x5bdeae1d
                          DCD      0x9b64c2b0
                          DCD      0xec63f226
                          DCD      0x756aa39c
                          DCD      0x026d930a
                          DCD      0x9c0906a9
                          DCD      0xeb0e363f
                          DCD      0x72076785
                          DCD      0x05005713
                          DCD      0x95bf4a82
                          DCD      0xe2b87a14
                          DCD      0x7bb12bae
                          DCD      0x0cb61b38
                          DCD      0x92d28e9b
                          DCD      0xe5d5be0d
                          DCD      0x7cdcefb7
                          DCD      0x0bdbdf21
                          DCD      0x86d3d2d4
                          DCD      0xf1d4e242
                          DCD      0x68ddb3f8
                          DCD      0x1fda836e
                          DCD      0x81be16cd
                          DCD      0xf6b9265b
                          DCD      0x6fb077e1
                          DCD      0x18b74777
                          DCD      0x88085ae6
                          DCD      0xff0f6a70
                          DCD      0x66063bca
                          DCD      0x11010b5c
                          DCD      0x8f659eff
                          DCD      0xf862ae69
                          DCD      0x616bffd3
                          DCD      0x166ccf45
                          DCD      0xa00ae278
                          DCD      0xd70dd2ee
                          DCD      0x4e048354
                          DCD      0x3903b3c2
                          DCD      0xa7672661
                          DCD      0xd06016f7
                          DCD      0x4969474d
                          DCD      0x3e6e77db
                          DCD      0xaed16a4a
                          DCD      0xd9d65adc
                          DCD      0x40df0b66
                          DCD      0x37d83bf0
                          DCD      0xa9bcae53
                          DCD      0xdebb9ec5
                          DCD      0x47b2cf7f
                          DCD      0x30b5ffe9
                          DCD      0xbdbdf21c
                          DCD      0xcabac28a
                          DCD      0x53b39330
                          DCD      0x24b4a3a6
                          DCD      0xbad03605
                          DCD      0xcdd70693
                          DCD      0x54de5729
                          DCD      0x23d967bf
                          DCD      0xb3667a2e
                          DCD      0xc4614ab8
                          DCD      0x5d681b02
                          DCD      0x2a6f2b94
                          DCD      0xb40bbe37
                          DCD      0xc30c8ea1
                          DCD      0x5a05df1b
                          DCD      0x2d02ef8d
