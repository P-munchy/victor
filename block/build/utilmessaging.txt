; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\utilmessaging.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\utilmessaging.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DANKICORETECH_EMBEDDED_USE_HEATSHRINK -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\utilmessaging.crf ..\coretech\messaging\shared\src\utilMessaging.c]
                          THUMB

                          AREA ||i.ReadChar||, CODE, READONLY, ALIGN=1

                  ReadChar PROC
;;;142    // by the number of bytes written.
;;;143    void * ReadChar(unsigned char *dest, void *src)
000000  780a              LDRB     r2,[r1,#0]
;;;144    {
;;;145      memcpy((char *) dest, (char*) src, sizeof(*dest));
000002  7002              STRB     r2,[r0,#0]
;;;146      return((char *)src + sizeof(*dest));
000004  1c48              ADDS     r0,r1,#1
;;;147    }
000006  4770              BX       lr
;;;148    
                          ENDP


                          AREA ||i.ReadDouble||, CODE, READONLY, ALIGN=1

                  ReadDouble PROC
;;;160    // by the number of bytes written.
;;;161    void * ReadDouble(double *dest, void *src)
000000  680a              LDR      r2,[r1,#0]
;;;162    {
;;;163      memcpy((char *) dest, (char*) src, sizeof(*dest));
000002  6002              STR      r2,[r0,#0]
000004  684a              LDR      r2,[r1,#4]
000006  6042              STR      r2,[r0,#4]
;;;164      return((char *)src + sizeof(*dest));
000008  f1010008          ADD      r0,r1,#8
;;;165    }
00000c  4770              BX       lr
;;;166    
                          ENDP


                          AREA ||i.ReadFloat||, CODE, READONLY, ALIGN=1

                  ReadFloat PROC
;;;152    // standard and have the same byte order regardless of endianness of machine
;;;153    void * ReadFloat(float *dest, void *src)
000000  680a              LDR      r2,[r1,#0]
;;;154    {
;;;155      memcpy((char *) dest, (char*) src, sizeof(*dest));
000002  6002              STR      r2,[r0,#0]
;;;156      return((char *)src + sizeof(*dest));
000004  1d08              ADDS     r0,r1,#4
;;;157    }
000006  4770              BX       lr
;;;158    
                          ENDP


                          AREA ||i.ReadU16||, CODE, READONLY, ALIGN=1

                  ReadU16 PROC
;;;134    // Returns the src pointer incremented by the number of bytes written.
;;;135    void * ReadU16(unsigned short *dest, void *src)
000000  880a              LDRH     r2,[r1,#0]
;;;136    {
;;;137      memcpy((char *) dest, (char*) src, sizeof(*dest));
000002  8002              STRH     r2,[r0,#0]
;;;138      return((char *)src + sizeof(*dest));
000004  1c88              ADDS     r0,r1,#2
;;;139    }
000006  4770              BX       lr
;;;140    
                          ENDP


                          AREA ||i.ReadU32||, CODE, READONLY, ALIGN=1

                  ReadU32 PROC
;;;114    // Returns the src pointer incremented by the number of bytes written.
;;;115    void * ReadU32(unsigned int *dest, void *src)
000000  680a              LDR      r2,[r1,#0]
;;;116    {
;;;117      memcpy((char *) dest, (char*) src, sizeof(*dest));
000002  6002              STR      r2,[r0,#0]
;;;118      return((char *)src + sizeof(*dest));
000004  1d08              ADDS     r0,r1,#4
;;;119    }
000006  4770              BX       lr
;;;120    
                          ENDP


                          AREA ||i.ReadU64||, CODE, READONLY, ALIGN=1

                  ReadU64 PROC
;;;95     
;;;96     void * ReadU64(unsigned long long *dest, void *src) {
000000  680a              LDR      r2,[r1,#0]
;;;97       memcpy((char *)dest, (char*) src, sizeof(*dest));
000002  6002              STR      r2,[r0,#0]
000004  684a              LDR      r2,[r1,#4]
000006  6042              STR      r2,[r0,#4]
;;;98       return((char *)src + sizeof(*dest));
000008  f1010008          ADD      r0,r1,#8
;;;99     }
00000c  4770              BX       lr
;;;100    
                          ENDP


                          AREA ||i.UtilMsgPack||, CODE, READONLY, ALIGN=1

                  UtilMsgPack PROC
;;;175    //  and two ints use"ccfahii" as the packStr.
;;;176    UtilMsgError UtilMsgPack(void *dst, unsigned int dstBytes, unsigned int *bytesPacked, const char *packStr, ...)
000000  b40f              PUSH     {r0-r3}
;;;177    {
000002  e92d4ff0          PUSH     {r4-r11,lr}
000006  b085              SUB      sp,sp,#0x14
000008  4689              MOV      r9,r1
;;;178      long long int l; // 8 bytes
;;;179      int i;    //4 bytes
;;;180      float f;  //4 bytes
;;;181      double d; //8 bytes
;;;182      short h;  //2 bytes
;;;183      char c;   //1 byte
;;;184    
;;;185      int idx;
;;;186      int variableNum;
;;;187      char *temp = (char *) dst;
;;;188      va_list arglist;
;;;189      UtilMsgError error = UTILMSG_OK;
;;;190    	
;;;191      // Always set this first.  We want this to be valid even if we fail.
;;;192      if ( bytesPacked ) {
00000a  9910              LDR      r1,[sp,#0x40]
00000c  4680              MOV      r8,r0                 ;177
00000e  4604              MOV      r4,r0                 ;187
000010  f04f0a00          MOV      r10,#0                ;189
000014  4650              MOV      r0,r10
000016  2900              CMP      r1,#0
;;;193        *bytesPacked = 0;
000018  bf18              IT       NE
00001a  6008              STRNE    r0,[r1,#0]
;;;194      }
;;;195      
;;;196      // Don't even try to pack any data if the supplied buffer isnt allocated.
;;;197      if ( ( dst == NULL ) || ( dstBytes <= 0 ) )
00001c  f1b80f00          CMP      r8,#0
000020  bf18              IT       NE
000022  f1b90f00          CMPNE    r9,#0
000026  f00080c6          BEQ.W    |L7.438|
;;;198      {
;;;199    #ifndef UNIT_TEST
;;;200        assert(0);
;;;201    #endif
;;;202        
;;;203        return UTILMSG_ZEROBUFFER;
;;;204      }
;;;205      
;;;206      va_start(arglist, packStr);
00002a  ad12              ADD      r5,sp,#0x48
;;;207      for(idx = 0; (packStr[idx] != '\0') && (error == UTILMSG_OK); ++idx) {
00002c  f04f0b00          MOV      r11,#0
000030  e0b6              B        |L7.416|
                  |L7.50|
;;;208        
;;;209        // If we're writing an array, the variable corresponding to the 'a'
;;;210        // character contains the number we will write, and the character at the
;;;211        // following index represents the type.
;;;212        int numVariablesToWrite = 1; // By default, writing one variable at a time
000032  2101              MOVS     r1,#1
;;;213        void* arrPtr = NULL;
000034  2600              MOVS     r6,#0
;;;214        if(packStr[idx] == 'a') {
000036  9100              STR      r1,[sp,#0]
000038  2861              CMP      r0,#0x61
00003a  d11a              BNE      |L7.114|
;;;215          numVariablesToWrite = va_arg(arglist, int);
00003c  f8550b04          LDR      r0,[r5],#4
;;;216          
;;;217    #ifndef UNIT_TEST
;;;218          assert( ( numVariablesToWrite >= 0 ) && ( numVariablesToWrite <= UINT8_MAX ) );
000040  28ff              CMP      r0,#0xff
000042  d87a              BHI      |L7.314|
;;;219    #endif
;;;220          
;;;221          // We can only unpack the array size as an unsigned char, so make sure we're not packing more than 255 elements.
;;;222          numVariablesToWrite = ( ( numVariablesToWrite <= 0 ) ? 0 : ( ( numVariablesToWrite >= UINT8_MAX ) ? UINT8_MAX : numVariablesToWrite ) );
000044  2800              CMP      r0,#0
000046  bfd8              IT       LE
000048  2000              MOVLE    r0,#0
00004a  dd02              BLE      |L7.82|
00004c  28ff              CMP      r0,#0xff
00004e  bfa8              IT       GE
000050  20ff              MOVGE    r0,#0xff
                  |L7.82|
;;;223          
;;;224          // Check for buffer overrun prior to writing to the buffer.
;;;225          if ( ((temp - (char*)dst) + sizeof(char)) > dstBytes ) {
000052  9000              STR      r0,[sp,#0]
000054  eba40008          SUB      r0,r4,r8
000058  1c40              ADDS     r0,r0,#1
00005a  4548              CMP      r0,r9
00005c  d902              BLS      |L7.100|
;;;226            error = UTILMSG_BUFFEROVRN;
00005e  f04f0a02          MOV      r10,#2
;;;227            break;
000062  e0a5              B        |L7.432|
                  |L7.100|
000064  9800              LDR      r0,[sp,#0]
000066  f8040b01          STRB     r0,[r4],#1
;;;228          }
;;;229          
;;;230          temp = (char *)WriteChar(temp, (char) numVariablesToWrite); // change pack to always write out the num of array elements
;;;231          
;;;232          arrPtr = (void*)va_arg(arglist, void*);  // get pointer to the array
00006a  f8556b04          LDR      r6,[r5],#4
;;;233          idx++; // To go to type character for array
00006e  f10b0b01          ADD      r11,r11,#1
                  |L7.114|
;;;234        }
;;;235        
;;;236        // Write each variable (1 or for each one in array)
;;;237        for(variableNum = 0; variableNum < numVariablesToWrite; variableNum++) {
000072  9800              LDR      r0,[sp,#0]
000074  2700              MOVS     r7,#0
000076  2800              CMP      r0,#0
000078  dd7d              BLE      |L7.374|
                  |L7.122|
;;;238          
;;;239          // floats promoted to double and chars and shorts promoted to int
;;;240          switch(packStr[idx]) {   // Type to expect.
00007a  9811              LDR      r0,[sp,#0x44]
00007c  f810000b          LDRB     r0,[r0,r11]
000080  3863              SUBS     r0,r0,#0x63
000082  280a              CMP      r0,#0xa
000084  d278              BCS      |L7.376|
000086  e8dff000          TBB      [pc,r0]
00008a  592a              DCB      0x59,0x2a
00008c  81168147          DCB      0x81,0x16,0x81,0x47
000090  05818167          DCB      0x05,0x81,0x81,0x67
;;;241            case 'i':
;;;242              if(arrPtr) {
000094  2e00              CMP      r6,#0
;;;243                i = ((int*)arrPtr)[variableNum];
000096  bf14              ITE      NE
000098  f8560027          LDRNE    r0,[r6,r7,LSL #2]
;;;244              } else {
;;;245                i = va_arg(arglist, int);
00009c  f8550b04          LDREQ    r0,[r5],#4
;;;246              }
;;;247              
;;;248              // Make sure we have enough space in our buffer
;;;249              if ( ((temp - (char*)dst) + sizeof(i)) > dstBytes ) {
0000a0  eba40108          SUB      r1,r4,r8
0000a4  1d09              ADDS     r1,r1,#4
0000a6  4549              CMP      r1,r9
0000a8  d902              BLS      |L7.176|
                  |L7.170|
;;;250                error = UTILMSG_BUFFEROVRN;
0000aa  f04f0a02          MOV      r10,#2
;;;251                break;
0000ae  e075              B        |L7.412|
                  |L7.176|
0000b0  f8440b04          STR      r0,[r4],#4
;;;252              }
;;;253              
;;;254              temp = (char *)WriteU32(temp, i);
;;;255              break;
0000b4  e02c              B        |L7.272|
;;;256              
;;;257            case 'f':
;;;258              if(arrPtr) {
0000b6  2e00              CMP      r6,#0
;;;259                f = ((float*)arrPtr)[variableNum];
0000b8  bf18              IT       NE
0000ba  f8560027          LDRNE    r0,[r6,r7,LSL #2]
0000be  d108              BNE      |L7.210|
;;;260              } else {
;;;261                f = (float) va_arg(arglist, double);
0000c0  1de8              ADDS     r0,r5,#7
0000c2  f0200507          BIC      r5,r0,#7
0000c6  ecb50b02          VLDM     r5!,{d0}
0000ca  ec510b10          VMOV     r0,r1,d0
0000ce  f7fffffe          BL       __aeabi_d2f
                  |L7.210|
;;;262              }
;;;263              
;;;264              // Make sure we have enough space in our buffer
;;;265              if ( ((temp - (char*)dst) + sizeof(f)) > dstBytes ) {
0000d2  eba40108          SUB      r1,r4,r8
0000d6  1d09              ADDS     r1,r1,#4
0000d8  4549              CMP      r1,r9
0000da  d9e9              BLS      |L7.176|
0000dc  e7e5              B        |L7.170|
;;;266                error = UTILMSG_BUFFEROVRN;
;;;267                break;
;;;268              }
;;;269              
;;;270              temp = (char *)WriteFloat(temp, f);
;;;271              break;
;;;272              
;;;273            case 'd':
;;;274              if(arrPtr) {
0000de  2e00              CMP      r6,#0
;;;275                d = ((double*)arrPtr)[variableNum];
0000e0  bf1c              ITT      NE
0000e2  eb0600c7          ADDNE    r0,r6,r7,LSL #3
0000e6  ed900b00          VLDRNE   d0,[r0,#0]
0000ea  d104              BNE      |L7.246|
;;;276              } else {
;;;277                d = va_arg(arglist, double);
0000ec  1de8              ADDS     r0,r5,#7
0000ee  f0200507          BIC      r5,r0,#7
0000f2  ecb50b02          VLDM     r5!,{d0}
                  |L7.246|
;;;278              }
;;;279              
;;;280              // Make sure we have enough space in our buffer
;;;281              if ( ((temp - (char*)dst) + sizeof(d)) > dstBytes ) {
0000f6  eba40008          SUB      r0,r4,r8
0000fa  3008              ADDS     r0,r0,#8
0000fc  4548              CMP      r0,r9
0000fe  d8d4              BHI      |L7.170|
000100  ee100a10          VMOV     r0,s0
;;;282                error = UTILMSG_BUFFEROVRN;
;;;283                break;
;;;284              }
;;;285              
;;;286              temp = (char *)WriteDouble(temp, d);
000104  ed8d0b02          VSTR     d0,[sp,#8]
000108  6020              STR      r0,[r4,#0]
00010a  9803              LDR      r0,[sp,#0xc]
00010c  6060              STR      r0,[r4,#4]
                  |L7.270|
00010e  3408              ADDS     r4,r4,#8
                  |L7.272|
;;;287              break;
;;;288              
;;;289            case 'h':
;;;290              if(arrPtr) {
;;;291                h = ((short*)arrPtr)[variableNum];
;;;292              } else {
;;;293                h = (short) va_arg(arglist, int);
;;;294              }
;;;295              
;;;296              // Make sure we have enough space in our buffer
;;;297              if ( ((temp - (char*)dst) + sizeof(h)) > dstBytes ) {
;;;298                error = UTILMSG_BUFFEROVRN;
;;;299                break;
;;;300              }
;;;301              
;;;302              temp = (char *)WriteU16(temp, h);
;;;303              break;
;;;304              
;;;305            case 'c':
;;;306              if(arrPtr) {
;;;307                c = ((char*)arrPtr)[variableNum];
;;;308              } else {
;;;309                c = (char) va_arg(arglist, int);
;;;310              }
;;;311              
;;;312              // Make sure we have enough space in our buffer
;;;313              if ( ((temp - (char*)dst) + sizeof(c)) > dstBytes ) {
;;;314                error = UTILMSG_BUFFEROVRN;
;;;315                break;
;;;316              }
;;;317              
;;;318              temp = (char *)WriteChar(temp, c);
;;;319              break;
;;;320              
;;;321            case 'l':
;;;322              if(arrPtr) {
;;;323                l = ((long long int*)arrPtr)[variableNum];
;;;324              } else {
;;;325                l = (long long int)va_arg(arglist,long long int);
;;;326              }
;;;327              
;;;328              // Make sure we have enough space in our buffer
;;;329              if ( ((temp - (char*)dst) + sizeof(l)) > dstBytes ) {
;;;330                error = UTILMSG_BUFFEROVRN;
;;;331                break;
;;;332              }
;;;333              
;;;334              temp = (char*)WriteU64(temp, l);
;;;335              break;
;;;336              
;;;337            default:
;;;338              error = UTILMSG_INVALIDARG;
;;;339              break;
;;;340          }
;;;341          
;;;342          if (error != UTILMSG_OK) {
000110  f1ba0f00          CMP      r10,#0
000114  d142              BNE      |L7.412|
000116  e03c              B        |L7.402|
000118  2e00              CMP      r6,#0                 ;290
00011a  bf12              ITEE     NE                    ;291
00011c  f9360017          LDRSHNE  r0,[r6,r7,LSL #1]     ;291
000120  f8350b04          LDRHEQ   r0,[r5],#4            ;293
000124  b200              SXTHEQ   r0,r0                 ;293
000126  eba40108          SUB      r1,r4,r8              ;297
00012a  1c89              ADDS     r1,r1,#2              ;297
00012c  4549              CMP      r1,r9                 ;297
00012e  d8bc              BHI      |L7.170|
000130  f8ad0004          STRH     r0,[sp,#4]            ;302
000134  f8240b02          STRH     r0,[r4],#2            ;302
000138  e7ea              B        |L7.272|
                  |L7.314|
00013a  e03c              B        |L7.438|
00013c  2e00              CMP      r6,#0                 ;306
00013e  bf14              ITE      NE                    ;307
000140  5df0              LDRBNE   r0,[r6,r7]            ;307
000142  f8150b04          LDRBEQ   r0,[r5],#4            ;309
000146  eba40108          SUB      r1,r4,r8              ;313
00014a  1c49              ADDS     r1,r1,#1              ;313
00014c  4549              CMP      r1,r9                 ;313
00014e  bf98              IT       LS                    ;313
000150  f8040b01          STRBLS   r0,[r4],#1            ;313
000154  d8a9              BHI      |L7.170|
000156  e7db              B        |L7.272|
000158  2e00              CMP      r6,#0                 ;322
00015a  bf1c              ITT      NE                    ;323
00015c  eb0601c7          ADDNE    r1,r6,r7,LSL #3       ;323
000160  e9d10100          LDRDNE   r0,r1,[r1,#0]         ;323
000164  d106              BNE      |L7.372|
000166  1de8              ADDS     r0,r5,#7              ;325
000168  f0200207          BIC      r2,r0,#7              ;325
00016c  f1020508          ADD      r5,r2,#8              ;325
000170  e9d20100          LDRD     r0,r1,[r2,#0]         ;325
                  |L7.372|
000174  e001              B        |L7.378|
                  |L7.374|
000176  e011              B        |L7.412|
                  |L7.376|
000178  e008              B        |L7.396|
                  |L7.378|
00017a  eba40208          SUB      r2,r4,r8              ;329
00017e  3208              ADDS     r2,r2,#8              ;329
000180  454a              CMP      r2,r9                 ;329
000182  bf9c              ITT      LS                    ;329
000184  6020              STRLS    r0,[r4,#0]            ;329
000186  6061              STRLS    r1,[r4,#4]            ;329
000188  d88f              BHI      |L7.170|
00018a  e7c0              B        |L7.270|
                  |L7.396|
00018c  f04f0a03          MOV      r10,#3                ;338
000190  e004              B        |L7.412|
                  |L7.402|
000192  9800              LDR      r0,[sp,#0]            ;237
000194  1c7f              ADDS     r7,r7,#1              ;237
000196  4287              CMP      r7,r0                 ;237
000198  f6ffaf6f          BLT      |L7.122|
                  |L7.412|
00019c  f10b0b01          ADD      r11,r11,#1            ;207
                  |L7.416|
0001a0  9811              LDR      r0,[sp,#0x44]         ;207
0001a2  f810000b          LDRB     r0,[r0,r11]           ;207
0001a6  b118              CBZ      r0,|L7.432|
0001a8  f1ba0f00          CMP      r10,#0                ;207
0001ac  f43faf41          BEQ      |L7.50|
                  |L7.432|
;;;343            break;
;;;344          }
;;;345        }
;;;346      }
;;;347      
;;;348      va_end(arglist);
;;;349      
;;;350    #ifndef UNIT_TEST
;;;351      assert(error == UTILMSG_OK);
0001b0  f1ba0f00          CMP      r10,#0
0001b4  d001              BEQ      |L7.442|
                  |L7.438|
0001b6  f7fffffe          BL       abort
                  |L7.442|
;;;352    #endif
;;;353      
;;;354      // If they requested the num bytes written, fill it in.
;;;355      if ( bytesPacked ) {
0001ba  9810              LDR      r0,[sp,#0x40]
0001bc  2800              CMP      r0,#0
;;;356        *bytesPacked = ( temp - (char*)dst );
0001be  bf1c              ITT      NE
0001c0  eba40108          SUBNE    r1,r4,r8
0001c4  6001              STRNE    r1,[r0,#0]
;;;357      }
;;;358      
;;;359      return error;
0001c6  4650              MOV      r0,r10
;;;360    }
0001c8  b005              ADD      sp,sp,#0x14
0001ca  e8bd0ff0          POP      {r4-r11}
0001ce  f85dfb14          LDR      pc,[sp],#0x14
;;;361    
                          ENDP


                          AREA ||i.UtilMsgUnpack||, CODE, READONLY, ALIGN=1

                  UtilMsgUnpack PROC
;;;373    // UtilMsgUnpack(src, "ccfii", &c1, &c2, &f, &i1, &i2)
;;;374    UtilMsgError UtilMsgUnpack(const void *src, unsigned int srcBytes, unsigned int *bytesUnpacked, const char *packStr, ...)
000000  b40f              PUSH     {r0-r3}
;;;375    {
;;;376      unsigned long long l;
;;;377      unsigned long long *pL = 0;
;;;378      unsigned int i;    //4 bytes
;;;379      unsigned int *pI = 0;
;;;380      float f;  //4 bytes
;;;381      float *pF = 0;
;;;382      double d; //8 bytes
;;;383      double *pD = 0;
;;;384      unsigned short h;  //2 bytes
;;;385      unsigned short *pH = 0;
;;;386      unsigned char c;   //1 byte
;;;387      unsigned char *pC = 0;
;;;388    
;;;389      int idx;
;;;390      int variableNum;
;;;391      va_list arglist;
;;;392      char *temp = (char *) src;
000002  4602              MOV      r2,r0
000004  e92d4ff0          PUSH     {r4-r11,lr}           ;375
000008  f04f0a00          MOV      r10,#0                ;377
00000c  b08b              SUB      sp,sp,#0x2c           ;375
00000e  46d6              MOV      lr,r10                ;379
;;;393      UtilMsgError error = UTILMSG_OK;
;;;394      
;;;395      if ( bytesUnpacked ) {
000010  f8ddc058          LDR      r12,[sp,#0x58]
000014  46d1              MOV      r9,r10                ;381
000016  46d0              MOV      r8,r10                ;383
000018  4657              MOV      r7,r10                ;385
00001a  4656              MOV      r6,r10                ;387
00001c  4655              MOV      r5,r10                ;393
00001e  4653              MOV      r3,r10
000020  f1bc0f00          CMP      r12,#0
;;;396        *bytesUnpacked = 0;
000024  bf18              IT       NE
000026  f8cc3000          STRNE    r3,[r12,#0]
;;;397      }
;;;398      
;;;399      // Don't even try to pack any data if the supplied buffer isnt allocated.
;;;400      if ( ( src == NULL ) || ( srcBytes <= 0 ) )
00002a  2800              CMP      r0,#0
00002c  bf18              IT       NE
00002e  2900              CMPNE    r1,#0
000030  f00080b4          BEQ.W    |L8.412|
;;;401      {
;;;402    #ifndef UNIT_TEST
;;;403        assert(0);
;;;404    #endif
;;;405        
;;;406        return UTILMSG_ZEROBUFFER;
;;;407      }
;;;408     
;;;409      
;;;410      va_start(arglist, packStr);
000034  f10d0c60          ADD      r12,sp,#0x60
;;;411      
;;;412      for(idx = 0; (packStr[idx] != '\0') && (error == UTILMSG_OK); ++idx) {
000038  2300              MOVS     r3,#0
00003a  e0a7              B        |L8.396|
                  |L8.60|
;;;413        
;;;414        // If we're reading an array, the variable corresponding to the 'a'
;;;415        // character contains the number we will read, and the character at
;;;416        // the following index represents the type.
;;;417        int numVariablesToRead = 1; // By default, writing one variable at a time
00003c  2401              MOVS     r4,#1
;;;418        if(packStr[idx] == 'a') {
00003e  9401              STR      r4,[sp,#4]
000040  2b61              CMP      r3,#0x61
000042  d119              BNE      |L8.120|
;;;419          // Make sure we don't read past the end of the buffer
;;;420          if ( ((temp - (char*)src) + sizeof(char)) > srcBytes ) {
000044  1a13              SUBS     r3,r2,r0
000046  1c5b              ADDS     r3,r3,#1
000048  428b              CMP      r3,r1
00004a  d901              BLS      |L8.80|
;;;421            error = UTILMSG_BUFFEROVRN;
00004c  2502              MOVS     r5,#2
;;;422            break;
00004e  e0a4              B        |L8.410|
                  |L8.80|
000050  f8124b01          LDRB     r4,[r2],#1
000054  f88d4018          STRB     r4,[sp,#0x18]
;;;423          }
;;;424          
;;;425          temp = (char *)ReadChar(&c, temp);   // Read the number of things to read
;;;426          pC = (unsigned char *) va_arg(arglist, void *);
000058  f8dc6000          LDR      r6,[r12,#0]
00005c  f10c0304          ADD      r3,r12,#4
000060  469c              MOV      r12,r3
;;;427          *pC = c;    // Set this number in the struct. (Not really used for anything, but here for completeness.)
000062  7034              STRB     r4,[r6,#0]
;;;428          numVariablesToRead = (int)c;
000064  f89d4018          LDRB     r4,[sp,#0x18]
;;;429          if (numVariablesToRead == 0) {
000068  9401              STR      r4,[sp,#4]
00006a  b914              CBNZ     r4,|L8.114|
;;;430            // Empty array, no variables will be assigned.
;;;431            // Get the next variable in the arg list
;;;432            pC = (unsigned char *) va_arg(arglist, void *);
00006c  681e              LDR      r6,[r3,#0]
00006e  f10c0c04          ADD      r12,r12,#4
                  |L8.114|
;;;433          }
;;;434          idx++; // To go to type character for array
000072  9b00              LDR      r3,[sp,#0]
000074  1c5b              ADDS     r3,r3,#1
000076  9300              STR      r3,[sp,#0]
                  |L8.120|
;;;435        }
;;;436        
;;;437        // Write each variable (1 or for each one in array)
;;;438        for(variableNum = 0; variableNum < numVariablesToRead; variableNum++) {
000078  9b01              LDR      r3,[sp,#4]
00007a  2400              MOVS     r4,#0
00007c  2b00              CMP      r3,#0
00007e  dd7a              BLE      |L8.374|
                  |L8.128|
;;;439          
;;;440          // floats promoted to double and chars and shorts promoted to int
;;;441          switch(packStr[idx]) {   // Type to expect.
000080  f8ddb05c          LDR      r11,[sp,#0x5c]
000084  9b00              LDR      r3,[sp,#0]
000086  f81b3003          LDRB     r3,[r11,r3]
00008a  f1a30b63          SUB      r11,r3,#0x63
00008e  f1bb0f0a          CMP      r11,#0xa
000092  d272              BCS      |L8.378|
000094  e8dff00b          TBB      [pc,r11]
000098  4c297119          DCB      0x4c,0x29,0x71,0x19
00009c  713d0571          DCB      0x71,0x3d,0x05,0x71
0000a0  715b              DCB      0x71,0x5b
;;;442            case 'i':
;;;443              // Make sure we don't read past the end of the buffer
;;;444              if ( ((temp - (char*)src) + sizeof(i)) > srcBytes ) {
0000a2  1a13              SUBS     r3,r2,r0
0000a4  1d1b              ADDS     r3,r3,#4
0000a6  428b              CMP      r3,r1
0000a8  d901              BLS      |L8.174|
                  |L8.170|
;;;445                error = UTILMSG_BUFFEROVRN;
0000aa  2502              MOVS     r5,#2
;;;446                break;
0000ac  e06c              B        |L8.392|
                  |L8.174|
0000ae  f8523b04          LDR      r3,[r2],#4
;;;447              }
;;;448              
;;;449              temp = (char *)ReadU32(&i, temp);
;;;450              if(variableNum == 0) {
0000b2  9308              STR      r3,[sp,#0x20]
0000b4  2c00              CMP      r4,#0
;;;451                pI = (unsigned int *) va_arg(arglist, void *);
;;;452              } else {
;;;453                pI++;
0000b6  bf14              ITE      NE
0000b8  f10e0e04          ADDNE    lr,lr,#4
0000bc  f85ceb04          LDREQ    lr,[r12],#4           ;451
;;;454              }
;;;455              *pI = i;
0000c0  f8ce3000          STR      r3,[lr,#0]
                  |L8.196|
;;;456              break;
;;;457              
;;;458            case 'f':
;;;459              // Make sure we don't read past the end of the buffer
;;;460              if ( ((temp - (char*)src) + sizeof(f)) > srcBytes ) {
;;;461                error = UTILMSG_BUFFEROVRN;
;;;462                break;
;;;463              }
;;;464              
;;;465              temp = (char *)ReadFloat(&f, temp);
;;;466              if(variableNum == 0) {
;;;467                pF = (float *) va_arg(arglist, void *);
;;;468              } else {
;;;469                pF++;
;;;470              }
;;;471              *pF = f;
;;;472              break;
;;;473              
;;;474            case 'd':
;;;475              // Make sure we don't read past the end of the buffer
;;;476              if ( ((temp - (char*)src) + sizeof(d)) > srcBytes ) {
;;;477                error = UTILMSG_BUFFEROVRN;
;;;478                break;
;;;479              }
;;;480              
;;;481              temp = (char *)ReadDouble(&d, temp);
;;;482              if(variableNum == 0) {
;;;483                pD = (double *) va_arg(arglist, void *);
;;;484              } else {
;;;485                pD++;
;;;486              }
;;;487              *pD = d;
;;;488              break;
;;;489              
;;;490            case 'h':
;;;491              // Make sure we don't read past the end of the buffer
;;;492              if ( ((temp - (char*)src) + sizeof(h)) > srcBytes ) {
;;;493                error = UTILMSG_BUFFEROVRN;
;;;494                break;
;;;495              }
;;;496              
;;;497              temp = (char *)ReadU16(&h, temp);
;;;498              if(variableNum == 0) {
;;;499                pH = (unsigned short *) va_arg(arglist, void *);
;;;500              } else {
;;;501                pH++;
;;;502              }
;;;503              *pH = h;
;;;504              break;
;;;505              
;;;506            case 'c':
;;;507              // Make sure we don't read past the end of the buffer
;;;508              if ( ((temp - (char*)src) + sizeof(c)) > srcBytes ) {
;;;509                error = UTILMSG_BUFFEROVRN;
;;;510                break;
;;;511              }
;;;512              
;;;513              temp = (char *)ReadChar(&c, temp);
;;;514              if(variableNum == 0) {
;;;515                pC = (unsigned char *) va_arg(arglist, void *);
;;;516              } else {
;;;517                pC++;
;;;518              }
;;;519              *pC = c;
;;;520              break;
;;;521              
;;;522            case 'l':
;;;523              // Make sure we don't read past the end of the buffer
;;;524              if ( ((temp - (char*)src) + sizeof(l)) > srcBytes ) {
;;;525                error = UTILMSG_BUFFEROVRN;
;;;526                break;
;;;527              }
;;;528              
;;;529              temp = (char *)ReadU64(&l, temp);
;;;530              if(variableNum == 0) {
;;;531                pL = (unsigned long long *)va_arg(arglist, void *);
;;;532              }
;;;533              else {
;;;534                pL++;
;;;535              }
;;;536              *pL = l;
;;;537              break;
;;;538              
;;;539            default:
;;;540              error = UTILMSG_INVALIDARG;
;;;541              break;
;;;542          }
;;;543          
;;;544          // If we failed to unpack the data, bail out of the function.
;;;545          if (error != UTILMSG_OK) {
0000c4  2d00              CMP      r5,#0
0000c6  d15f              BNE      |L8.392|
0000c8  e059              B        |L8.382|
0000ca  1a13              SUBS     r3,r2,r0              ;460
0000cc  1d1b              ADDS     r3,r3,#4              ;460
0000ce  428b              CMP      r3,r1                 ;460
0000d0  d8eb              BHI      |L8.170|
0000d2  f8523b04          LDR      r3,[r2],#4            ;460
0000d6  9307              STR      r3,[sp,#0x1c]         ;466
0000d8  2c00              CMP      r4,#0                 ;466
0000da  bf14              ITE      NE                    ;469
0000dc  f1090904          ADDNE    r9,r9,#4              ;469
0000e0  f85c9b04          LDREQ    r9,[r12],#4           ;467
0000e4  f8c93000          STR      r3,[r9,#0]            ;466
0000e8  e7ec              B        |L8.196|
0000ea  1a13              SUBS     r3,r2,r0              ;476
0000ec  3308              ADDS     r3,r3,#8              ;476
0000ee  428b              CMP      r3,r1                 ;476
0000f0  d8db              BHI      |L8.170|
0000f2  6813              LDR      r3,[r2,#0]            ;476
0000f4  9304              STR      r3,[sp,#0x10]         ;476
0000f6  6853              LDR      r3,[r2,#4]            ;476
0000f8  3208              ADDS     r2,r2,#8              ;476
0000fa  9305              STR      r3,[sp,#0x14]         ;482
0000fc  2c00              CMP      r4,#0                 ;482
0000fe  bf14              ITE      NE                    ;485
000100  f1080808          ADDNE    r8,r8,#8              ;485
000104  f85c8b04          LDREQ    r8,[r12],#4           ;483
000108  ed9d0b04          VLDR     d0,[sp,#0x10]         ;487
00010c  ed880b00          VSTR     d0,[r8,#0]            ;487
000110  e7d8              B        |L8.196|
000112  1a13              SUBS     r3,r2,r0              ;492
000114  1c9b              ADDS     r3,r3,#2              ;492
000116  428b              CMP      r3,r1                 ;492
000118  d8c7              BHI      |L8.170|
00011a  f8323b02          LDRH     r3,[r2],#2            ;492
00011e  f8ad3024          STRH     r3,[sp,#0x24]         ;492
000122  2c00              CMP      r4,#0                 ;498
000124  bf14              ITE      NE                    ;501
000126  1cbf              ADDNE    r7,r7,#2              ;501
000128  f85c7b04          LDREQ    r7,[r12],#4           ;499
00012c  803b              STRH     r3,[r7,#0]            ;503
00012e  e7c9              B        |L8.196|
000130  1a13              SUBS     r3,r2,r0              ;508
000132  1c5b              ADDS     r3,r3,#1              ;508
000134  428b              CMP      r3,r1                 ;508
000136  d8b8              BHI      |L8.170|
000138  f8123b01          LDRB     r3,[r2],#1            ;508
00013c  f88d3018          STRB     r3,[sp,#0x18]         ;508
000140  2c00              CMP      r4,#0                 ;514
000142  bf14              ITE      NE                    ;517
000144  1c76              ADDNE    r6,r6,#1              ;517
000146  f85c6b04          LDREQ    r6,[r12],#4           ;515
00014a  7033              STRB     r3,[r6,#0]            ;519
00014c  e7ba              B        |L8.196|
00014e  1a13              SUBS     r3,r2,r0              ;524
000150  3308              ADDS     r3,r3,#8              ;524
000152  428b              CMP      r3,r1                 ;524
000154  d8a9              BHI      |L8.170|
000156  6813              LDR      r3,[r2,#0]            ;524
000158  9302              STR      r3,[sp,#8]            ;524
00015a  6853              LDR      r3,[r2,#4]            ;524
00015c  3208              ADDS     r2,r2,#8              ;524
00015e  9303              STR      r3,[sp,#0xc]          ;530
000160  2c00              CMP      r4,#0                 ;530
000162  bf14              ITE      NE                    ;534
000164  f10a0a08          ADDNE    r10,r10,#8            ;534
000168  f85cab04          LDREQ    r10,[r12],#4          ;531
00016c  e9dd3b02          LDRD     r3,r11,[sp,#8]        ;531
000170  e9ca3b00          STRD     r3,r11,[r10,#0]       ;531
000174  e7a6              B        |L8.196|
                  |L8.374|
000176  e007              B        |L8.392|
000178  e7ff              B        |L8.378|
                  |L8.378|
00017a  2503              MOVS     r5,#3                 ;540
00017c  e004              B        |L8.392|
                  |L8.382|
00017e  9b01              LDR      r3,[sp,#4]            ;438
000180  1c64              ADDS     r4,r4,#1              ;438
000182  429c              CMP      r4,r3                 ;438
000184  f6ffaf7c          BLT      |L8.128|
                  |L8.392|
000188  9b00              LDR      r3,[sp,#0]            ;412
00018a  1c5b              ADDS     r3,r3,#1              ;412
                  |L8.396|
00018c  9c17              LDR      r4,[sp,#0x5c]         ;412
00018e  9300              STR      r3,[sp,#0]            ;412
000190  5ce3              LDRB     r3,[r4,r3]            ;412
000192  b113              CBZ      r3,|L8.410|
000194  2d00              CMP      r5,#0                 ;412
000196  f43faf51          BEQ      |L8.60|
                  |L8.410|
;;;546            break;
;;;547          }
;;;548        }
;;;549      }
;;;550      
;;;551      va_end(arglist);
;;;552      
;;;553    #ifndef UNIT_TEST
;;;554      assert(error == UTILMSG_OK);
00019a  b10d              CBZ      r5,|L8.416|
                  |L8.412|
00019c  f7fffffe          BL       abort
                  |L8.416|
;;;555    #endif
;;;556      
;;;557      // Write out the number of bytes we unpacked if it was requested.
;;;558      if ( bytesUnpacked ) {
0001a0  9916              LDR      r1,[sp,#0x58]
0001a2  b111              CBZ      r1,|L8.426|
;;;559        *bytesUnpacked = ( temp - (char*)src );
0001a4  1a11              SUBS     r1,r2,r0
0001a6  9816              LDR      r0,[sp,#0x58]
0001a8  6001              STR      r1,[r0,#0]
                  |L8.426|
;;;560      }
;;;561      
;;;562      return error;
;;;563    }
0001aa  b00b              ADD      sp,sp,#0x2c
0001ac  4628              MOV      r0,r5                 ;562
0001ae  e8bd0ff0          POP      {r4-r11}
0001b2  f85dfb14          LDR      pc,[sp],#0x14
;;;564    
                          ENDP


                          AREA ||i.WriteChar||, CODE, READONLY, ALIGN=1

                  WriteChar PROC
;;;71     // by the number of bytes written.
;;;72     void * WriteChar(void *dest, unsigned char src)
000000  f8001b01          STRB     r1,[r0],#1
;;;73     {
;;;74       memcpy((char *)dest, (char*) &src, sizeof(src));
;;;75       return((char *)dest + sizeof(src));
;;;76     }
000004  4770              BX       lr
;;;77     
                          ENDP


                          AREA ||i.WriteDouble||, CODE, READONLY, ALIGN=1

                  WriteDouble PROC
;;;87     // standard and have the same byte order regardless of endianness of machine
;;;88     void * WriteDouble(void *dest, double src)
000000  b411              PUSH     {r0,r4}
;;;89     {
000002  ed2d0b02          VPUSH    {d0}
;;;90       memcpy((char *)dest, (char*) &src, sizeof(src));
000006  9900              LDR      r1,[sp,#0]
000008  6001              STR      r1,[r0,#0]
00000a  9901              LDR      r1,[sp,#4]
00000c  6041              STR      r1,[r0,#4]
;;;91       return((char *)dest + sizeof(src));
;;;92     }
00000e  b003              ADD      sp,sp,#0xc
000010  3008              ADDS     r0,r0,#8              ;91
000012  bc10              POP      {r4}
000014  4770              BX       lr
;;;93     
                          ENDP


                          AREA ||i.WriteFloat||, CODE, READONLY, ALIGN=1

                  WriteFloat PROC
;;;79     // standard and have the same byte order regardless of endianness of machine
;;;80     void * WriteFloat(void *dest, float src)
000000  ee101a10          VMOV     r1,s0
;;;81     {
;;;82       memcpy((char *)dest, (char*) &src, sizeof(src));
000004  f8401b04          STR      r1,[r0],#4
;;;83       return((char *)dest + sizeof(src));
;;;84     }
000008  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.WriteU16||, CODE, READONLY, ALIGN=1

                  WriteU16 PROC
;;;63     // Returns the pointer incremented by the number of bytes written.
;;;64     void * WriteU16(void *dest, unsigned short src)
000000  b403              PUSH     {r0,r1}
;;;65     {
;;;66       memcpy((char *)dest, (char*) &src, sizeof(src));
000002  f8bd1004          LDRH     r1,[sp,#4]
000006  f8201b02          STRH     r1,[r0],#2
;;;67       return((char *)dest + sizeof(src));
;;;68     }
00000a  b002              ADD      sp,sp,#8
00000c  4770              BX       lr
;;;69     
                          ENDP


                          AREA ||i.WriteU32||, CODE, READONLY, ALIGN=1

                  WriteU32 PROC
;;;44     // Returns the pointer incremented by the number of bytes written.
;;;45     void * WriteU32(void *dest, unsigned int src)
000000  f8401b04          STR      r1,[r0],#4
;;;46     {
;;;47       memcpy((char *)dest, (char*) &src, sizeof(src));
;;;48       return((char *)dest + sizeof(src));
;;;49     }
000004  4770              BX       lr
;;;50     
                          ENDP


                          AREA ||i.WriteU64||, CODE, READONLY, ALIGN=1

                  WriteU64 PROC
;;;26     
;;;27     void* WriteU64(void *dest, unsigned long long src) {
000000  6002              STR      r2,[r0,#0]
;;;28       memcpy((char *) dest, (char*)&src, sizeof(src));
000002  6043              STR      r3,[r0,#4]
;;;29       return((char *)dest + sizeof(src));
000004  3008              ADDS     r0,r0,#8
;;;30     }
000006  4770              BX       lr
;;;31     
                          ENDP

