; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\velocityprofilegenerator.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\velocityprofilegenerator.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\velocityprofilegenerator.crf ..\coretech\common\shared\src\velocityProfileGenerator.cpp]
                          THUMB

                          AREA ||i._ZN4Anki24VelocityProfileGenerator12StartProfileEfffffff||, CODE, READONLY, ALIGN=2

                  _ZN4Anki24VelocityProfileGenerator12StartProfileEfffffff PROC ; Anki::VelocityProfileGenerator::StartProfile(float, float, float, float, float, float, float)
;;;32       
;;;33       void VelocityProfileGenerator::StartProfile(float startVel, float startPos,
000000  b510              PUSH     {r4,lr}
000002  eef03ac1          VABS.F32 s7,s2
;;;34                                                   float maxSpeed, float accel,
;;;35                                                   float endVel, float endPos,
;;;36                                                   float timeStep)
;;;37       {
000006  ed2d8b08          VPUSH    {d8-d11}
00000a  eeb01ac2          VABS.F32 s2,s4
00000e  eeb02ac3          VABS.F32 s4,s6
000012  eeb03ac1          VABS.F32 s6,s2
000016  eeb04ae1          VABS.F32 s8,s3
;;;38         startVel_ = startVel;
00001a  ed800a00          VSTR     s0,[r0,#0]
;;;39         startPos_ = startPos;
00001e  edc00a01          VSTR     s1,[r0,#4]
;;;40         maxVel_ = fabs(maxSpeed);
000022  edc03a02          VSTR     s7,[r0,#8]
;;;41         accel_ = fabs(accel);
;;;42         endVel_ = fabs(endVel);
;;;43         endPos_ = endPos;
;;;44         timeStep_ = fabs(timeStep);
;;;45     
;;;46         assert(maxVel_ >= fabs(endVel_));
000026  eeb43ae3          VCMPE.F32 s6,s7
00002a  ed804a03          VSTR     s8,[r0,#0xc]          ;41
00002e  ed801a04          VSTR     s2,[r0,#0x10]         ;42
000032  eef1fa10          VMRS     APSR_nzcv,FPSCR
000036  edc02a05          VSTR     s5,[r0,#0x14]         ;43
00003a  4604              MOV      r4,r0                 ;37
00003c  ed802a06          VSTR     s4,[r0,#0x18]         ;44
000040  d809              BHI      |L1.86|
;;;47         assert(accel_ > 0);
000042  eeb54ac0          VCMPE.F32 s8,#0.0
000046  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;48         assert(timeStep_ > 0);
00004a  bfc4              ITT      GT
00004c  eeb52ac0          VCMPEGT.F32 s4,#0.0
000050  eef1fa10          VMRSGT   APSR_nzcv,FPSCR
000054  dc01              BGT      |L1.90|
                  |L1.86|
000056  f7fffffe          BL       abort
                  |L1.90|
;;;49         
;;;50         // Compute direction, maxVel, and endVel based on startPos and endPos
;;;51         float direction = 1;
;;;52         if (startPos > endPos) {
00005a  eeb02a60          VMOV.F32 s4,s1
00005e  eeb03a62          VMOV.F32 s6,s5
000062  eeb79a00          VMOV.F32 s18,#1.00000000       ;51
000066  eeb42ac3          VCMPE.F32 s4,s6
00006a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00006e  dd09              BLE      |L1.132|
;;;53           direction = -1;
;;;54           maxVel_ *= -1;
000070  eeb12a63          VNEG.F32 s4,s7
000074  ed842a02          VSTR     s4,[r4,#8]
;;;55           endVel_ *= -1;
000078  eeb11a41          VNEG.F32 s2,s2
00007c  eebf9a00          VMOV.F32 s18,#-1.00000000      ;53
000080  ed841a04          VSTR     s2,[r4,#0x10]
                  |L1.132|
;;;56         }
;;;57         maxReachableVel_ = maxVel_;
000084  ed941a02          VLDR     s2,[r4,#8]
;;;58         
;;;59         
;;;60         // Compute the distance that would be travelled if we went from
;;;61         // startVel to maxSpeed and then immediately to terminalVel
;;;62         // Calculate as two back-to-back trapezoids:
;;;63         // Trap1: h=(Vm-Vs)/a, b1=Vm, b2=Vs
;;;64         // Trap2: h=(Vm-Vf)/a, b1=Vm, b2=Vf
;;;65         // Distance: d
;;;66         // Max speed: Vm
;;;67         // End (final) speed: Vf
;;;68         // Start speed: Vs
;;;69         // Acceleration: a
;;;70         // d = ( 2*(Vm)^2 - (Vf)^2 - (Vs)^2 ) / (2 * a)
;;;71         float d = ( (2*maxVel_*maxVel_) - (endVel_*endVel_) - (startVel_*startVel_) ) / (2 * accel_);
000088  eef09a00          VMOV.F32 s19,#2.00000000
00008c  ed841a0c          VSTR     s2,[r4,#0x30]         ;57
000090  ee212a29          VMUL.F32 s4,s2,s19
000094  ee643a29          VMUL.F32 s7,s8,s19
;;;72         
;;;73         
;;;74         // If d is more than the distance that needs to be traversed then
;;;75         // know we can't reach maxVel before we need to decelerate.
;;;76         // Compute the max speed that actually can be reached.
;;;77         // By manipulating the formula above we get:
;;;78         //
;;;79         // V_max' = sqrt( (2 * a * d' + (V_f)^2 + (V_s)^2) / 2 )
;;;80         // where d' = ABS(laneChangePixelsRequired)
;;;81         // and V_max' = max speed that can be reached
;;;82         totalDistToTarget_ = endPos_ - startPos_;
000098  ee720ae0          VSUB.F32 s1,s5,s1
;;;83         if (fabs(d) > fabs(totalDistToTarget_)) {
;;;84           maxReachableVel_ = sqrt( ((2*accel*fabs(totalDistToTarget_)) + (endVel_*endVel_) + (startVel_*startVel_)) * 0.5f );
00009c  eef6aa00          VMOV.F32 s21,#0.50000000
0000a0  ee223a01          VMUL.F32 s6,s4,s2              ;71
0000a4  ed941a04          VLDR     s2,[r4,#0x10]         ;71
0000a8  edc40a0a          VSTR     s1,[r4,#0x28]         ;82
0000ac  eef00ae0          VABS.F32 s1,s1                 ;82
0000b0  ee013a41          VMLS.F32 s6,s2,s2              ;71
0000b4  ee003a40          VMLS.F32 s6,s0,s0              ;71
0000b8  ee832a23          VDIV.F32 s4,s6,s7              ;71
0000bc  eeb02ac2          VABS.F32 s4,s4                 ;71
0000c0  eeb42ae0          VCMPE.F32 s4,s1                 ;83
0000c4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;83
0000c8  dd18              BLE      |L1.252|
0000ca  ee611aa9          VMUL.F32 s3,s3,s19
0000ce  ee600aa1          VMUL.F32 s1,s1,s3
0000d2  ee410a01          VMLA.F32 s1,s2,s2
0000d6  ee400a00          VMLA.F32 s1,s0,s0
0000da  ee600aaa          VMUL.F32 s1,s1,s21
0000de  eeb10ae0          VSQRT.F32 s0,s1
0000e2  eeb40a40          VCMP.F32 s0,s0
0000e6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000ea  bf1c              ITT      NE
0000ec  eeb00a60          VMOVNE.F32 s0,s1
0000f0  f7fffffe          BLNE     __hardfp_sqrtf
;;;85           maxReachableVel_ *= direction;
0000f4  ee200a09          VMUL.F32 s0,s0,s18
0000f8  ed840a0c          VSTR     s0,[r4,#0x30]
                  |L1.252|
;;;86     #if(DEBUG_VPG)
;;;87           CoreTechPrint("VPG new V_max: %f (d = %f)\n", maxReachableVel_, d);
;;;88     #endif
;;;89         }
;;;90         
;;;91         // Compute distance required to decelerate from maxReachableVel_ (Vs) to endVel_ (Vf).
;;;92         // d = 1/2 a*t^2 + Vs*t , where t=(Vf-Vs)/a
;;;93         // But a is actually negative because we're decelering so t=(Vs-Vf)/a and
;;;94         // d = 1/2 * -a * ((Vs - Vf)/a)^2 + Vs * (Vs - Vf)/a
;;;95         // d = (Vs*Vs - Vf*Vf)/(2a)
;;;96         decelDistToTarget_ = 0;
0000fc  eddfba3a          VLDR     s23,|L1.488|
000100  edc4ba0b          VSTR     s23,[r4,#0x2c]
;;;97         if (fabs(maxReachableVel_) > fabs(endVel_)) {
000104  ed948a0c          VLDR     s16,[r4,#0x30]
000108  edd48a04          VLDR     s17,[r4,#0x10]
00010c  eeb00ac8          VABS.F32 s0,s16
000110  eef00ae8          VABS.F32 s1,s17
000114  eef40ac0          VCMPE.F32 s1,s0
000118  eef1fa10          VMRS     APSR_nzcv,FPSCR
00011c  d20b              BCS      |L1.310|
;;;98           decelDistToTarget_ = (maxReachableVel_*maxReachableVel_ - endVel_*endVel_) / (2*accel_);
00011e  ee280a08          VMUL.F32 s0,s16,s16
000122  edd40a03          VLDR     s1,[r4,#0xc]
000126  ee080ae8          VMLS.F32 s0,s17,s17
00012a  ee600aa9          VMUL.F32 s1,s1,s19
00012e  ee801a20          VDIV.F32 s2,s0,s1
000132  ed841a0b          VSTR     s2,[r4,#0x2c]
                  |L1.310|
;;;99         }
;;;100        
;;;101        // Compute change in velocity per timestep
;;;102        deltaVelPerTimeStepStart_ = accel_ * timeStep_ * direction;
000136  ed940a03          VLDR     s0,[r4,#0xc]
00013a  edd49a06          VLDR     s19,[r4,#0x18]
;;;103        deltaVelPerTimeStepEnd_ = -deltaVelPerTimeStepStart_;
;;;104        
;;;105        // Init state vars
;;;106        targetReached_ = false;
00013e  2000              MOVS     r0,#0
000140  ee200a29          VMUL.F32 s0,s0,s19             ;102
000144  ee20aa09          VMUL.F32 s20,s0,s18            ;102
000148  ed84aa07          VSTR     s20,[r4,#0x1c]        ;102
00014c  eeb1ba4a          VNEG.F32 s22,s20               ;103
000150  ed84ba08          VSTR     s22,[r4,#0x20]        ;103
000154  f8840035          STRB     r0,[r4,#0x35]
;;;107        isDecel_ = false;
000158  f8840034          STRB     r0,[r4,#0x34]
;;;108        currVel_ = startVel_;
00015c  ed949a00          VLDR     s18,[r4,#0]
000160  ee190a10          VMOV     r0,s18
000164  f7fffffe          BL       __aeabi_f2d
000168  e9c4010e          STRD     r0,r1,[r4,#0x38]
;;;109        currPos_ = startPos_;
00016c  6860              LDR      r0,[r4,#4]
00016e  f7fffffe          BL       __aeabi_f2d
;;;110        currTime_ = 0;
;;;111        
;;;112        startAccelDist_ = fabsf(0.5f * (maxReachableVel_ - startVel_) / deltaVelPerTimeStepStart_ * timeStep_) * (maxReachableVel_ >= 0 ? 1 : -1);
000172  ee380a49          VSUB.F32 s0,s16,s18
000176  eeb58ac0          VCMPE.F32 s16,#0.0
00017a  e9c40110          STRD     r0,r1,[r4,#0x40]      ;109
00017e  edc4ba09          VSTR     s23,[r4,#0x24]        ;110
000182  ee200a2a          VMUL.F32 s0,s0,s21
000186  eec00a0a          VDIV.F32 s1,s0,s20
00018a  ee200aa9          VMUL.F32 s0,s1,s19
00018e  eef00ac0          VABS.F32 s1,s0
000192  eef1fa10          VMRS     APSR_nzcv,FPSCR
000196  bfac              ITE      GE
000198  2001              MOVGE    r0,#1
00019a  f04f30ff          MOVLT    r0,#0xffffffff
00019e  ee000a10          VMOV     s0,r0
;;;113        endAccelDist_ = fabsf(0.5f * (endVel_ - maxReachableVel_) / deltaVelPerTimeStepEnd_ * timeStep_) * (maxReachableVel_ >= 0 ? 1 : -1);
0001a2  eeb58ac0          VCMPE.F32 s16,#0.0
0001a6  eeb80ac0          VCVT.F32.S32 s0,s0                 ;112
0001aa  ee200a80          VMUL.F32 s0,s1,s0              ;112
0001ae  ed840a12          VSTR     s0,[r4,#0x48]         ;112
0001b2  ee380ac8          VSUB.F32 s0,s17,s16
0001b6  ee200a2a          VMUL.F32 s0,s0,s21
0001ba  eec00a0b          VDIV.F32 s1,s0,s22
0001be  ee200aa9          VMUL.F32 s0,s1,s19
0001c2  eef00ac0          VABS.F32 s1,s0
0001c6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001ca  bfac              ITE      GE
0001cc  2001              MOVGE    r0,#1
0001ce  f04f30ff          MOVLT    r0,#0xffffffff
0001d2  ee000a10          VMOV     s0,r0
0001d6  eeb80ac0          VCVT.F32.S32 s0,s0
0001da  ee200a80          VMUL.F32 s0,s1,s0
0001de  ed840a13          VSTR     s0,[r4,#0x4c]
;;;114        
;;;115    #if(DEBUG_VPG)
;;;116        CoreTechPrint("VPG: startVel %f, startPos %f, maxSpeed %f, accel %f\n", startVel_, startPos_, maxVel_, accel_);
;;;117        CoreTechPrint("     endVel %f, endPos %f, timestep %f\n", endVel_, endPos_, timeStep_);
;;;118        CoreTechPrint("     deltaVel %f, maxReachableVel %f, totalDist %f, decelDistToTarget %f, dir %f\n", deltaVelPerTimeStepStart_, maxReachableVel_, totalDistToTarget_, decelDistToTarget_, direction);
;;;119    #endif
;;;120      }
0001e2  ecbd8b08          VPOP     {d8-d11}
0001e6  bd10              POP      {r4,pc}
;;;121      
                          ENDP

                  |L1.488|
0001e8  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki24VelocityProfileGenerator13TargetReachedEv||, CODE, READONLY, ALIGN=1

                  _ZN4Anki24VelocityProfileGenerator13TargetReachedEv PROC ; Anki::VelocityProfileGenerator::TargetReached()
;;;415      
;;;416      bool VelocityProfileGenerator::TargetReached()
000000  f8900035          LDRB     r0,[r0,#0x35]
;;;417      {
;;;418        return targetReached_;
;;;419      }
000004  4770              BX       lr
;;;420    
                          ENDP


                          AREA ||i._ZN4Anki24VelocityProfileGenerator17DumpProfileToFileEPKc||, CODE, READONLY, ALIGN=1

                  _ZN4Anki24VelocityProfileGenerator17DumpProfileToFileEPKc PROC ; Anki::VelocityProfileGenerator::DumpProfileToFile(const char*)
;;;397    
;;;398      void VelocityProfileGenerator::DumpProfileToFile(const char* filename)
000000  4770              BX       lr
;;;399      {
;;;400    #if(ENABLE_PROFILE_DUMP)
;;;401        float currVel, currPos;
;;;402    
;;;403        std::ofstream csvFile;
;;;404        csvFile.open(filename);
;;;405        csvFile << "Time, Position, Velocity\n";
;;;406        while (!targetReached_) {
;;;407          csvFile << currTime_ << ", " << currPos_ << ", " << currVel_ << "\n";
;;;408          Step(currVel, currPos);
;;;409        }
;;;410        csvFile << currTime_ << ", " << currPos_ << ", " << currVel_ << std::endl;
;;;411        csvFile.close();
;;;412    #endif
;;;413      }
;;;414      
                          ENDP


                          AREA ||i._ZN4Anki24VelocityProfileGenerator26StartProfile_fixedDurationEfffffffff||, CODE, READONLY, ALIGN=2

                  _ZN4Anki24VelocityProfileGenerator26StartProfile_fixedDurationEfffffffff PROC ; Anki::VelocityProfileGenerator::StartProfile_fixedDuration(float, float, float, float, float, float, float, float, float)
;;;200      // 3) vel_start and vel_mid are of opposite signs.
;;;201      bool VelocityProfileGenerator::StartProfile_fixedDuration(float pos_start, float vel_start, float acc_start_duration,
000000  b5f0              PUSH     {r4-r7,lr}
;;;202                                                                float pos_end, float acc_end_duration,
;;;203                                                                float vel_max,
;;;204                                                                float acc_max,
;;;205                                                                float duration,
;;;206                                                                float timeStep)
;;;207      {
000002  4604              MOV      r4,r0
000004  ed2d8b0e          VPUSH    {d8-d14}
000008  b085              SUB      sp,sp,#0x14
00000a  eef0ca40          VMOV.F32 s25,s0
;;;208        startVel_ = vel_start;
;;;209        startPos_ = pos_start;
;;;210        maxVel_ = fabsf(vel_max);
00000e  eeb0bae2          VABS.F32 s22,s5
000012  eeb0ca44          VMOV.F32 s24,s8                ;207
000016  eef09a42          VMOV.F32 s19,s4                ;207
00001a  eeb0aa41          VMOV.F32 s20,s2                ;207
00001e  eeb00acc          VABS.F32 s0,s24                ;207
000022  edc00a00          VSTR     s1,[r0,#0]            ;208
000026  edc0ca01          VSTR     s25,[r0,#4]           ;209
;;;211        endVel_ = 0;
00002a  eddfdada          VLDR     s27,|L4.916|
00002e  ed80ba02          VSTR     s22,[r0,#8]           ;210
000032  edc0da04          VSTR     s27,[r0,#0x10]
;;;212        endPos_ = pos_end;
000036  edc01a05          VSTR     s3,[r0,#0x14]
;;;213        timeStep_ = fabs(timeStep);
00003a  ed800a06          VSTR     s0,[r0,#0x18]
;;;214    
;;;215        acc_max = fabsf(acc_max);
;;;216        vel_max = fabsf(vel_max);
;;;217        
;;;218        // Check that the acceleration durations are valid given the total duration
;;;219        if (acc_start_duration + acc_end_duration > duration) {
00003e  ee3a0a29          VADD.F32 s0,s20,s19
000042  eef0bac3          VABS.F32 s23,s6                ;215
000046  eeb40ae3          VCMPE.F32 s0,s7
00004a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00004e  dd1d              BLE      |L4.140|
;;;220          CoreTechPrint("VPG FAIL: acc_start_duration + acc_end_duration exceeds total duration (%f + %f > %f)\n", acc_start_duration, acc_end_duration, duration);
000050  ee130a90          VMOV     r0,s7
000054  f7fffffe          BL       __aeabi_f2d
000058  4606              MOV      r6,r0
00005a  460f              MOV      r7,r1
00005c  ee190a90          VMOV     r0,s19
000060  f7fffffe          BL       __aeabi_f2d
000064  4604              MOV      r4,r0
000066  460d              MOV      r5,r1
000068  ee1a0a10          VMOV     r0,s20
00006c  f7fffffe          BL       __aeabi_f2d
000070  e88d00f0          STM      sp,{r4-r7}
000074  ec410b10          VMOV     d0,r0,r1
000078  48c7              LDR      r0,|L4.920|
00007a  ec532b10          VMOV     r2,r3,d0
00007e  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
;;;221          return false;
;;;222        }
;;;223        
;;;224        float ts = acc_start_duration;
;;;225        float te = acc_end_duration;
;;;226        float tm = duration - ts - te;
;;;227        
;;;228        // Compute distance to traverse
;;;229        float dist = pos_end - pos_start;
;;;230        
;;;231        // Figure out if vel_mid is +ve or -ve by setting it to 0 and seeing what distance is covered
;;;232        float distWhenVelMid0 = 0.5f*(vel_start * acc_start_duration);
;;;233        bool isVelMidGT0 = (dist >= distWhenVelMid0);
;;;234        
;;;235        // If accelerating to a vel_mid of 0 for the acc_start phase actually passes the end_pos,
;;;236        // then return false as this is probably not an intended profile.
;;;237        if (((dist > 0) == (distWhenVelMid0 > 0)) && (fabsf(distWhenVelMid0) > fabsf(dist))) {
;;;238          CoreTechPrint("VPG FAIL: end_pos reached during starting acc phase. Consider reducing acc_start duration or decreasing vel_start magnitude.\n");
;;;239          return false;
;;;240        }
;;;241        
;;;242        
;;;243        float distWhenVelMidIsVelStart = vel_start * (duration - acc_end_duration) + 0.5f*(vel_start * acc_end_duration);
;;;244        bool isVelMidGTVelStart = (dist >= distWhenVelMidIsVelStart);
;;;245        
;;;246        bool accStartCrosses0 = (vel_start < 0.f) == isVelMidGT0;
;;;247        
;;;248        float vs = vel_start;
;;;249        float vm;
;;;250       
;;;251        bool flipped = vs < 0;
;;;252        if (flipped) {
;;;253          vs = -vs;
;;;254          dist = -dist;
;;;255          isVelMidGT0 = !isVelMidGT0;
;;;256          isVelMidGTVelStart = !isVelMidGTVelStart;
;;;257        }
;;;258       
;;;259        // Compute vel_mid depending on which case we're dealing with
;;;260        if (accStartCrosses0) {
;;;261          // Case 3
;;;262          float A = -(0.5f*ts + tm + 0.5f*te);
;;;263          float B = vs*tm + 0.5f*vs*te + dist;
;;;264          float C = 0.5f*vs*vs*ts - vs*dist;
;;;265          float discr = B*B - 4*A*C;
;;;266          
;;;267          if (discr < 0){
;;;268            CoreTechPrint("WARNING: discr < 0  (A = %f, B = %f, C = %f)\n", A, B, C);
;;;269            return false;
;;;270          }
;;;271          
;;;272          float sqrtDiscr = sqrtf(discr);
;;;273          vm = (-B + sqrtDiscr) / (2*A);
;;;274          
;;;275          if (vm > 0) {
;;;276            // vm should be negative
;;;277            CoreTechPrint("WARNING: discr < 0  (A = %f, B = %f, C = %f)\n", A, B, C);
;;;278            return false;
;;;279          }
;;;280          
;;;281        } else {
;;;282          // Cases 1 and 2
;;;283          vm = (dist - (0.5f*vs*ts)) / (0.5f*ts + tm + 0.5f*te);
;;;284        }
;;;285        
;;;286        
;;;287        // Check if any velocity exceeds the max
;;;288        if ( (fabsf(vs) > vel_max) || (fabsf(vm) > vel_max)) {
;;;289          CoreTechPrint("WARNING: vs = %f, vm = %f, vel_max = %f\n", vs, vm, vel_max);
;;;290          return false;
;;;291        }
;;;292        
;;;293        // Check if any acceleration exceeds the max allowed
;;;294        float acc_start = fabsf(vm-vs)/ts;
;;;295        float acc_end = fabsf(vm/te);
;;;296        if ((acc_start > acc_max) || (acc_end > acc_max)) {
;;;297          CoreTechPrint("WARNING: acc_start = %f, acc_end = %f, acc_max = %f\n", acc_start, acc_end, acc_max);
;;;298          return false;
;;;299        }
;;;300        
;;;301        
;;;302        if (flipped) {
;;;303          vs = -vs;
;;;304          dist = -dist;
;;;305          isVelMidGT0 = !isVelMidGT0;
;;;306          isVelMidGTVelStart = !isVelMidGTVelStart;
;;;307          vm = -vm;
;;;308        }
;;;309        
;;;310        totalDistToTarget_ = dist;
;;;311        maxReachableVel_ = vm;
;;;312        deltaVelPerTimeStepStart_ = ((vm-vs)/ts) * timeStep;
;;;313        deltaVelPerTimeStepEnd_ = (-vm/te) * timeStep;
;;;314        decelDistToTarget_ = fabsf(0.5f*vm*te);
;;;315        
;;;316        // Init state vars
;;;317        targetReached_ = false;
;;;318        isDecel_ = false;
;;;319        currVel_ = vs;
;;;320        currPos_ = pos_start;
;;;321        currTime_ = 0;
;;;322    
;;;323        startAccelDist_ = fabsf(0.5f * (maxReachableVel_ - startVel_) * ts) * (maxReachableVel_ >= 0 ? 1 : -1);
;;;324        endAccelDist_ = fabsf(0.5f * (endVel_ - maxReachableVel_) * te) * (maxReachableVel_ >= 0 ? 1 : -1);
;;;325    
;;;326        
;;;327    #if(DEBUG_VPG)
;;;328        CoreTechPrint("VPG: startVel %f, startPos %f, endVel %f, endPos %f\n", startVel_, startPos_, endVel_, endPos_);
;;;329        CoreTechPrint("     ts %f, tm %f, te %f, total duration %f\n", ts, tm, te, duration);
;;;330        CoreTechPrint("     deltaVelStart %f, deltaVelEnd %f, maxReachableVel %f\n", deltaVelPerTimeStepStart_, deltaVelPerTimeStepEnd_, maxReachableVel_);
;;;331        CoreTechPrint("     totalDist %f, decelDistToTarget %f\n", totalDistToTarget_, decelDistToTarget_);
;;;332    #endif
;;;333        
;;;334        return true;
;;;335      }  
000082  b005              ADD      sp,sp,#0x14
000084  2000              MOVS     r0,#0                 ;221
000086  ecbd8b0e          VPOP     {d8-d14}
00008a  bdf0              POP      {r4-r7,pc}
                  |L4.140|
00008c  ee330aca          VSUB.F32 s0,s7,s20             ;226
000090  eeb6da00          VMOV.F32 s26,#0.50000000       ;232
000094  ee319aec          VSUB.F32 s18,s3,s25            ;229
000098  ee301a69          VSUB.F32 s2,s0,s19             ;226
00009c  ee200a8a          VMUL.F32 s0,s1,s20             ;232
0000a0  ee200a0d          VMUL.F32 s0,s0,s26             ;232
0000a4  eeb49ac0          VCMPE.F32 s18,s0                ;233
0000a8  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;233
0000ac  bfac              ITE      GE                    ;233
0000ae  2001              MOVGE    r0,#1                 ;233
0000b0  2000              MOVLT    r0,#0                 ;233
0000b2  eeb59ac0          VCMPE.F32 s18,#0.0              ;237
0000b6  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;237
0000ba  bfcc              ITE      GT                    ;237
0000bc  2101              MOVGT    r1,#1                 ;237
0000be  2100              MOVLE    r1,#0                 ;237
0000c0  eeb50ac0          VCMPE.F32 s0,#0.0               ;237
0000c4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;237
0000c8  bfcc              ITE      GT                    ;237
0000ca  2201              MOVGT    r2,#1                 ;237
0000cc  2200              MOVLE    r2,#0                 ;237
0000ce  4291              CMP      r1,r2                 ;237
0000d0  d10d              BNE      |L4.238|
0000d2  eeb00ac0          VABS.F32 s0,s0                 ;237
0000d6  eef01ac9          VABS.F32 s3,s18                ;237
0000da  eeb40ae1          VCMPE.F32 s0,s3                 ;237
0000de  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;237
0000e2  dd04              BLE      |L4.238|
0000e4  48ad              LDR      r0,|L4.924|
0000e6  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
0000ea  f000b8df          B.W      |L4.684|
                  |L4.238|
0000ee  eef50ac0          VCMPE.F32 s1,#0.0               ;246
0000f2  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;246
0000f6  bf34              ITE      CC                    ;246
0000f8  2100              MOVCC    r1,#0                 ;246
0000fa  2101              MOVCS    r1,#1                 ;246
0000fc  4048              EORS     r0,r0,r1              ;246
0000fe  eef50ac0          VCMPE.F32 s1,#0.0               ;251
000102  eeb08a60          VMOV.F32 s16,s1                ;248
000106  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;251
00010a  bf34              ITE      CC                    ;251
00010c  2501              MOVCC    r5,#1                 ;251
00010e  2500              MOVCS    r5,#0                 ;251
000110  2d00              CMP      r5,#0                 ;252
000112  bf1c              ITT      NE                    ;253
000114  eeb18a48          VNEGNE.F32 s16,s16               ;253
000118  eeb19a49          VNEGNE.F32 s18,s18               ;254
00011c  eeb00a4a          VMOV.F32 s0,s20                ;219
000120  2800              CMP      r0,#0                 ;260
000122  ee730ac0          VSUB.F32 s1,s7,s0              ;226
000126  eeb00a69          VMOV.F32 s0,s19                ;219
00012a  ee70aac0          VSUB.F32 s21,s1,s0             ;226
00012e  eef60a00          VMOV.F32 s1,#0.50000000        ;232
000132  eeb00a4a          VMOV.F32 s0,s20                ;219
000136  ee40aa20          VMLA.F32 s21,s0,s1             ;262
00013a  d054              BEQ      |L4.486|
00013c  eebe0a00          VMOV.F32 s0,#-0.50000000       ;262
000140  ee680a01          VMUL.F32 s1,s16,s2             ;263
000144  ee59aa80          VNMLS.F32 s21,s19,s0            ;262
000148  ee280a0d          VMUL.F32 s0,s16,s26            ;263
00014c  ee400a29          VMLA.F32 s1,s0,s19             ;263
000150  ee200a08          VMUL.F32 s0,s0,s16             ;264
000154  ee60ea0a          VMUL.F32 s29,s0,s20            ;264
000158  ee30ea89          VADD.F32 s28,s1,s18            ;263
00015c  eeb10a00          VMOV.F32 s0,#4.00000000        ;265
000160  ee48ea49          VMLS.F32 s29,s16,s18           ;264
000164  ee6e0a0e          VMUL.F32 s1,s28,s28            ;265
000168  ee2a0a80          VMUL.F32 s0,s21,s0             ;265
00016c  ee400a6e          VMLS.F32 s1,s0,s29             ;265
000170  eef50ac0          VCMPE.F32 s1,#0.0               ;267
000174  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;267
000178  d317              BCC      |L4.426|
00017a  eeb10ae0          VSQRT.F32 s0,s1                 ;272
00017e  eeb40a40          VCMP.F32 s0,s0                 ;272
000182  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;272
000186  bf1c              ITT      NE                    ;272
000188  eeb00a60          VMOVNE.F32 s0,s1                 ;272
00018c  f7fffffe          BLNE     __hardfp_sqrtf
000190  ee300a4e          VSUB.F32 s0,s0,s28             ;273
000194  eef00a00          VMOV.F32 s1,#2.00000000        ;273
000198  ee6a0aa0          VMUL.F32 s1,s21,s1             ;273
00019c  eec08a20          VDIV.F32 s17,s0,s1             ;273
0001a0  eef58ac0          VCMPE.F32 s17,#0.0              ;275
0001a4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;275
0001a8  dd27              BLE      |L4.506|
                  |L4.426|
0001aa  ee1e0a90          VMOV     r0,s29                ;277
0001ae  f7fffffe          BL       __aeabi_f2d
0001b2  4606              MOV      r6,r0                 ;277
0001b4  460f              MOV      r7,r1                 ;277
0001b6  ee1e0a10          VMOV     r0,s28                ;277
0001ba  f7fffffe          BL       __aeabi_f2d
0001be  4604              MOV      r4,r0                 ;277
0001c0  460d              MOV      r5,r1                 ;277
0001c2  ee1a0a90          VMOV     r0,s21                ;277
0001c6  f7fffffe          BL       __aeabi_f2d
0001ca  e88d00f0          STM      sp,{r4-r7}            ;277
0001ce  ec410b10          VMOV     d0,r0,r1              ;277
0001d2  a073              ADR      r0,|L4.928|
0001d4  ec532b10          VMOV     r2,r3,d0              ;277
0001d8  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
0001dc  b005              ADD      sp,sp,#0x14
0001de  2000              MOVS     r0,#0                 ;278
0001e0  ecbd8b0e          VPOP     {d8-d14}
0001e4  bdf0              POP      {r4-r7,pc}
                  |L4.486|
0001e6  ee680a0d          VMUL.F32 s1,s16,s26            ;283
0001ea  eeb00a49          VMOV.F32 s0,s18                ;283
0001ee  ee49aa8d          VMLA.F32 s21,s19,s26           ;283
0001f2  ee000aca          VMLS.F32 s0,s1,s20             ;283
0001f6  eec08a2a          VDIV.F32 s17,s0,s21            ;283
                  |L4.506|
0001fa  eeb00ac8          VABS.F32 s0,s16                ;288
0001fe  eeb40acb          VCMPE.F32 s0,s22                ;288
000202  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;288
000206  bfde              ITTT     LE                    ;288
000208  eeb00ae8          VABSLE.F32 s0,s17                ;288
00020c  eeb40acb          VCMPELE.F32 s0,s22                ;288
000210  eef1fa10          VMRSLE   APSR_nzcv,FPSCR       ;288
000214  dd1d              BLE      |L4.594|
000216  ee1b0a10          VMOV     r0,s22                ;289
00021a  f7fffffe          BL       __aeabi_f2d
00021e  4606              MOV      r6,r0                 ;289
000220  460f              MOV      r7,r1                 ;289
000222  ee180a90          VMOV     r0,s17                ;289
000226  f7fffffe          BL       __aeabi_f2d
00022a  4604              MOV      r4,r0                 ;289
00022c  460d              MOV      r5,r1                 ;289
00022e  ee180a10          VMOV     r0,s16                ;289
000232  f7fffffe          BL       __aeabi_f2d
000236  e88d00f0          STM      sp,{r4-r7}            ;289
00023a  ec410b10          VMOV     d0,r0,r1              ;289
00023e  a064              ADR      r0,|L4.976|
000240  ec532b10          VMOV     r2,r3,d0              ;289
000244  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
000248  b005              ADD      sp,sp,#0x14
00024a  2000              MOVS     r0,#0                 ;290
00024c  ecbd8b0e          VPOP     {d8-d14}
000250  bdf0              POP      {r4-r7,pc}
                  |L4.594|
000252  ee380ac8          VSUB.F32 s0,s17,s16            ;294
000256  eeb00ac0          VABS.F32 s0,s0                 ;294
00025a  eec0aa0a          VDIV.F32 s21,s0,s20            ;294
00025e  ee880aa9          VDIV.F32 s0,s17,s19            ;295
000262  eef4aaeb          VCMPE.F32 s21,s23               ;296
000266  eeb0bac0          VABS.F32 s22,s0                ;295
00026a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;296
00026e  bfdc              ITT      LE                    ;296
000270  eeb4baeb          VCMPELE.F32 s22,s23               ;296
000274  eef1fa10          VMRSLE   APSR_nzcv,FPSCR       ;296
000278  dd1d              BLE      |L4.694|
00027a  ee1b0a90          VMOV     r0,s23                ;297
00027e  f7fffffe          BL       __aeabi_f2d
000282  4606              MOV      r6,r0                 ;297
000284  460f              MOV      r7,r1                 ;297
000286  ee1b0a10          VMOV     r0,s22                ;297
00028a  f7fffffe          BL       __aeabi_f2d
00028e  4604              MOV      r4,r0                 ;297
000290  460d              MOV      r5,r1                 ;297
000292  ee1a0a90          VMOV     r0,s21                ;297
000296  f7fffffe          BL       __aeabi_f2d
00029a  e88d00f0          STM      sp,{r4-r7}            ;297
00029e  ec410b10          VMOV     d0,r0,r1              ;297
0002a2  a056              ADR      r0,|L4.1020|
0002a4  ec532b10          VMOV     r2,r3,d0              ;297
0002a8  f7fffffe          BL       _ZN4Anki13CoreTechPrintEPKcz ; Anki::CoreTechPrint(const char*, ...)
                  |L4.684|
0002ac  b005              ADD      sp,sp,#0x14
0002ae  2000              MOVS     r0,#0                 ;298
0002b0  ecbd8b0e          VPOP     {d8-d14}
0002b4  bdf0              POP      {r4-r7,pc}
                  |L4.694|
0002b6  b12d              CBZ      r5,|L4.708|
0002b8  eeb18a48          VNEG.F32 s16,s16               ;303
0002bc  eeb19a49          VNEG.F32 s18,s18               ;304
0002c0  eef18a68          VNEG.F32 s17,s17               ;307
                  |L4.708|
0002c4  ed849a0a          VSTR     s18,[r4,#0x28]        ;310
0002c8  ee780ac8          VSUB.F32 s1,s17,s16            ;312
0002cc  edc48a0c          VSTR     s17,[r4,#0x30]        ;311
0002d0  2000              MOVS     r0,#0                 ;317
0002d2  ee800a8a          VDIV.F32 s0,s1,s20             ;312
0002d6  eef10a68          VNEG.F32 s1,s17                ;313
0002da  ee200a0c          VMUL.F32 s0,s0,s24             ;312
0002de  ed840a07          VSTR     s0,[r4,#0x1c]         ;312
0002e2  ee800aa9          VDIV.F32 s0,s1,s19             ;313
0002e6  ee200a0c          VMUL.F32 s0,s0,s24             ;313
0002ea  ed840a08          VSTR     s0,[r4,#0x20]         ;313
0002ee  ee280a8d          VMUL.F32 s0,s17,s26            ;314
0002f2  ee200a29          VMUL.F32 s0,s0,s19             ;314
0002f6  eeb00ac0          VABS.F32 s0,s0                 ;314
0002fa  ed840a0b          VSTR     s0,[r4,#0x2c]         ;314
0002fe  f8840035          STRB     r0,[r4,#0x35]         ;317
000302  f8840034          STRB     r0,[r4,#0x34]         ;318
000306  ee180a10          VMOV     r0,s16                ;319
00030a  f7fffffe          BL       __aeabi_f2d
00030e  e9c4010e          STRD     r0,r1,[r4,#0x38]      ;319
000312  ee1c0a90          VMOV     r0,s25                ;320
000316  f7fffffe          BL       __aeabi_f2d
00031a  e9c40110          STRD     r0,r1,[r4,#0x40]      ;320
00031e  edc4da09          VSTR     s27,[r4,#0x24]        ;321
000322  ed940a00          VLDR     s0,[r4,#0]            ;323
000326  eef58ac0          VCMPE.F32 s17,#0.0              ;323
00032a  ee380ac0          VSUB.F32 s0,s17,s0             ;323
00032e  ee200a0d          VMUL.F32 s0,s0,s26             ;323
000332  ee200a0a          VMUL.F32 s0,s0,s20             ;323
000336  eef00ac0          VABS.F32 s1,s0                 ;323
00033a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;323
00033e  bfac              ITE      GE                    ;323
000340  2001              MOVGE    r0,#1                 ;323
000342  f04f30ff          MOVLT    r0,#0xffffffff        ;323
000346  ee000a10          VMOV     s0,r0                 ;323
00034a  eef58ac0          VCMPE.F32 s17,#0.0              ;324
00034e  eeb80ac0          VCVT.F32.S32 s0,s0                 ;323
000352  ee200a80          VMUL.F32 s0,s1,s0              ;323
000356  ed840a12          VSTR     s0,[r4,#0x48]         ;323
00035a  ed940a04          VLDR     s0,[r4,#0x10]         ;324
00035e  ee300a68          VSUB.F32 s0,s0,s17             ;324
000362  ee200a0d          VMUL.F32 s0,s0,s26             ;324
000366  ee200a29          VMUL.F32 s0,s0,s19             ;324
00036a  eef00ac0          VABS.F32 s1,s0                 ;324
00036e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;324
000372  bfac              ITE      GE                    ;324
000374  2001              MOVGE    r0,#1                 ;324
000376  f04f30ff          MOVLT    r0,#0xffffffff        ;324
00037a  ee000a10          VMOV     s0,r0                 ;324
00037e  2001              MOVS     r0,#1                 ;334
000380  eeb80ac0          VCVT.F32.S32 s0,s0                 ;324
000384  ee200a80          VMUL.F32 s0,s1,s0              ;324
000388  ed840a13          VSTR     s0,[r4,#0x4c]         ;324
00038c  b005              ADD      sp,sp,#0x14
00038e  ecbd8b0e          VPOP     {d8-d14}
000392  bdf0              POP      {r4-r7,pc}
;;;336      
                          ENDP

                  |L4.916|
000394  00000000          DCFS     0x00000000 ; 0
                  |L4.920|
                          DCD      ||.conststring||
                  |L4.924|
                          DCD      ||.conststring||+0x58
                  |L4.928|
0003a0  5741524e          DCB      "WARNING: discr < 0  (A = %f, B = %f, C = %f)\n",0
0003a4  494e473a
0003a8  20646973
0003ac  6372203c
0003b0  20302020
0003b4  2841203d
0003b8  2025662c
0003bc  2042203d
0003c0  2025662c
0003c4  2043203d
0003c8  20256629
0003cc  0a00    
0003ce  00                DCB      0
0003cf  00                DCB      0
                  |L4.976|
0003d0  5741524e          DCB      "WARNING: vs = %f, vm = %f, vel_max = %f\n",0
0003d4  494e473a
0003d8  20767320
0003dc  3d202566
0003e0  2c20766d
0003e4  203d2025
0003e8  662c2076
0003ec  656c5f6d
0003f0  6178203d
0003f4  2025660a
0003f8  00      
0003f9  00                DCB      0
0003fa  00                DCB      0
0003fb  00                DCB      0
                  |L4.1020|
0003fc  5741524e          DCB      "WARNING: acc_start = %f, acc_end = %f, acc_max = %f\n",0
000400  494e473a
000404  20616363
000408  5f737461
00040c  7274203d
000410  2025662c
000414  20616363
000418  5f656e64
00041c  203d2025
000420  662c2061
000424  63635f6d
000428  6178203d
00042c  2025660a
000430  00      
000431  00                DCB      0
000432  00                DCB      0
000433  00                DCB      0

                          AREA ||i._ZN4Anki24VelocityProfileGenerator4StepERfS1_||, CODE, READONLY, ALIGN=1

                  _ZN4Anki24VelocityProfileGenerator4StepERfS1_ PROC ; Anki::VelocityProfileGenerator::Step(float&, float&)
;;;336      
;;;337      float VelocityProfileGenerator::Step(float &currVel, float &currPos)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;338      {
000004  4604              MOV      r4,r0
000006  ed2d8b04          VPUSH    {d8-d9}
00000a  4615              MOV      r5,r2
00000c  460e              MOV      r6,r1
;;;339        currTime_ += timeStep_;
00000e  ed900a09          VLDR     s0,[r0,#0x24]
000012  edd00a06          VLDR     s1,[r0,#0x18]
000016  ee300a20          VADD.F32 s0,s0,s1
00001a  ed800a09          VSTR     s0,[r0,#0x24]
;;;340        
;;;341        // If target already reached, then return final position.
;;;342        if (targetReached_) {
00001e  f8900035          LDRB     r0,[r0,#0x35]
000022  b140              CBZ      r0,|L5.54|
;;;343          currVel = endVel_;
000024  ed940a04          VLDR     s0,[r4,#0x10]
000028  ed810a00          VSTR     s0,[r1,#0]
;;;344          currPos = endPos_;
00002c  ed940a05          VLDR     s0,[r4,#0x14]
000030  ed820a00          VSTR     s0,[r2,#0]
;;;345          return currTime_;
000034  e09a              B        |L5.364|
                  |L5.54|
;;;346        }
;;;347        
;;;348        // Update current velocity
;;;349        if (isDecel_) {
000036  f8940034          LDRB     r0,[r4,#0x34]
00003a  2800              CMP      r0,#0
00003c  d07e              BEQ      |L5.316|
;;;350          
;;;351          // If we're not already at endVel_...
;;;352          if (currVel_ != endVel_) {
00003e  6920              LDR      r0,[r4,#0x10]
000040  f7fffffe          BL       __aeabi_f2d
000044  ed941b0e          VLDR     d1,[r4,#0x38]
000048  ec532b11          VMOV     r2,r3,d1
00004c  f7fffffe          BL       __aeabi_cdcmpeq
000050  d029              BEQ      |L5.166|
;;;353            currVel_ += deltaVelPerTimeStepEnd_;
000052  6a20              LDR      r0,[r4,#0x20]
000054  f7fffffe          BL       __aeabi_f2d
000058  ed941b0e          VLDR     d1,[r4,#0x38]
00005c  ec532b11          VMOV     r2,r3,d1
000060  f7fffffe          BL       __aeabi_dadd
000064  ec410b18          VMOV     d8,r0,r1
000068  ed848b0e          VSTR     d8,[r4,#0x38]
;;;354            if ((maxReachableVel_ > endVel_) != (currVel_ > endVel_)) {
00006c  6920              LDR      r0,[r4,#0x10]
00006e  f7fffffe          BL       __aeabi_f2d
000072  ec532b18          VMOV     r2,r3,d8
000076  f7fffffe          BL       __aeabi_cdcmple
00007a  bf2c              ITE      CS
00007c  2000              MOVCS    r0,#0
00007e  2001              MOVCC    r0,#1
000080  edd40a0c          VLDR     s1,[r4,#0x30]
000084  ed940a04          VLDR     s0,[r4,#0x10]
000088  eef40ac0          VCMPE.F32 s1,s0
00008c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000090  bfcc              ITE      GT
000092  2101              MOVGT    r1,#1
000094  2100              MOVLE    r1,#0
000096  4288              CMP      r0,r1
000098  d005              BEQ      |L5.166|
                  |L5.154|
;;;355              currVel_ = endVel_;
;;;356            }
;;;357          }
;;;358          
;;;359        } else {
;;;360          // If we're not already at maxReachableVel_...
;;;361          if (currVel_ != maxReachableVel_) {
;;;362            currVel_ += deltaVelPerTimeStepStart_;
;;;363            if ((startVel_ > maxReachableVel_) != (currVel_ > maxReachableVel_)) {
;;;364              currVel_ = maxReachableVel_;
00009a  ee100a10          VMOV     r0,s0
00009e  f7fffffe          BL       __aeabi_f2d
0000a2  e9c4010e          STRD     r0,r1,[r4,#0x38]
                  |L5.166|
;;;365            }
;;;366          }
;;;367        }
;;;368        
;;;369        // Update position
;;;370        currPos_ += currVel_ * timeStep_;
0000a6  69a0              LDR      r0,[r4,#0x18]
0000a8  f7fffffe          BL       __aeabi_f2d
0000ac  ed949b0e          VLDR     d9,[r4,#0x38]
0000b0  ec532b19          VMOV     r2,r3,d9
0000b4  f7fffffe          BL       __aeabi_dmul
0000b8  ed941b10          VLDR     d1,[r4,#0x40]
0000bc  ec532b11          VMOV     r2,r3,d1
0000c0  f7fffffe          BL       __aeabi_dadd
0000c4  ec410b18          VMOV     d8,r0,r1
0000c8  ed848b10          VSTR     d8,[r4,#0x40]
;;;371        float currDistToTarget = endPos_ - currPos_;
0000cc  6960              LDR      r0,[r4,#0x14]
0000ce  f7fffffe          BL       __aeabi_f2d
0000d2  ec532b18          VMOV     r2,r3,d8
0000d6  f7fffffe          BL       __aeabi_dsub
0000da  f7fffffe          BL       __aeabi_d2f
0000de  ee000a10          VMOV     s0,r0
;;;372        
;;;373        // Check whether or not deceleration should begin
;;;374        if (fabs(currDistToTarget) < decelDistToTarget_) {
0000e2  ed941a0b          VLDR     s2,[r4,#0x2c]
0000e6  2701              MOVS     r7,#1                 ;354
0000e8  eef00ac0          VABS.F32 s1,s0                 ;354
0000ec  eef40ac1          VCMPE.F32 s1,s2
0000f0  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;375          isDecel_ = true;
0000f4  bf38              IT       CC
0000f6  f8847034          STRBCC   r7,[r4,#0x34]
;;;376        }
;;;377        
;;;378        // Check whether or not final position has been reached
;;;379        if ( ((currDistToTarget > 0) != (totalDistToTarget_ > 0)) || (isDecel_ && (currVel_ == endVel_)) ) {
0000fa  eeb50ac0          VCMPE.F32 s0,#0.0
0000fe  eef1fa10          VMRS     APSR_nzcv,FPSCR
000102  bfcc              ITE      GT
000104  2001              MOVGT    r0,#1
000106  2000              MOVLE    r0,#0
000108  ed940a0a          VLDR     s0,[r4,#0x28]
00010c  eeb50ac0          VCMPE.F32 s0,#0.0
000110  eef1fa10          VMRS     APSR_nzcv,FPSCR
000114  bfcc              ITE      GT
000116  2101              MOVGT    r1,#1
000118  2100              MOVLE    r1,#0
00011a  4288              CMP      r0,r1
00011c  d10a              BNE      |L5.308|
00011e  f8940034          LDRB     r0,[r4,#0x34]
000122  b1a8              CBZ      r0,|L5.336|
000124  6920              LDR      r0,[r4,#0x10]
000126  f7fffffe          BL       __aeabi_f2d
00012a  ec532b19          VMOV     r2,r3,d9
00012e  f7fffffe          BL       __aeabi_cdcmpeq
000132  d10d              BNE      |L5.336|
                  |L5.308|
;;;380          targetReached_ = true;
000134  f8847035          STRB     r7,[r4,#0x35]
;;;381          currVel_ = endVel_;
000138  6920              LDR      r0,[r4,#0x10]
00013a  e000              B        |L5.318|
                  |L5.316|
00013c  e01c              B        |L5.376|
                  |L5.318|
00013e  f7fffffe          BL       __aeabi_f2d
000142  e9c4010e          STRD     r0,r1,[r4,#0x38]
;;;382          currPos_ = endPos_;
000146  6960              LDR      r0,[r4,#0x14]
000148  f7fffffe          BL       __aeabi_f2d
00014c  e9c40110          STRD     r0,r1,[r4,#0x40]
                  |L5.336|
;;;383        }
;;;384        
;;;385        
;;;386    #if(DEBUG_VPG)
;;;387        CoreTechPrint("VPG::Step() - currVel %f, currPos %f, currDistToTarget %f, isDecel %d\n", currVel_, currPos_, currDistToTarget, isDecel_);
;;;388    #endif
;;;389        
;;;390        
;;;391        currVel = currVel_;
000150  ed940b0e          VLDR     d0,[r4,#0x38]
000154  ec510b10          VMOV     r0,r1,d0
000158  f7fffffe          BL       __aeabi_d2f
;;;392        currPos = currPos_;
00015c  6030              STR      r0,[r6,#0]
00015e  ed940b10          VLDR     d0,[r4,#0x40]
000162  ec510b10          VMOV     r0,r1,d0
000166  f7fffffe          BL       __aeabi_d2f
00016a  6028              STR      r0,[r5,#0]
                  |L5.364|
;;;393        return currTime_;
00016c  ed940a09          VLDR     s0,[r4,#0x24]
;;;394      }
000170  ecbd8b04          VPOP     {d8-d9}
000174  e8bd81f0          POP      {r4-r8,pc}
                  |L5.376|
000178  6b20              LDR      r0,[r4,#0x30]         ;361
00017a  f7fffffe          BL       __aeabi_f2d
00017e  ed941b0e          VLDR     d1,[r4,#0x38]         ;361
000182  ec532b11          VMOV     r2,r3,d1              ;361
000186  f7fffffe          BL       __aeabi_cdcmpeq
00018a  d08c              BEQ      |L5.166|
00018c  69e0              LDR      r0,[r4,#0x1c]         ;362
00018e  f7fffffe          BL       __aeabi_f2d
000192  ed941b0e          VLDR     d1,[r4,#0x38]         ;362
000196  ec532b11          VMOV     r2,r3,d1              ;362
00019a  f7fffffe          BL       __aeabi_dadd
00019e  ec410b18          VMOV     d8,r0,r1              ;362
0001a2  ed848b0e          VSTR     d8,[r4,#0x38]         ;362
0001a6  6b20              LDR      r0,[r4,#0x30]         ;363
0001a8  f7fffffe          BL       __aeabi_f2d
0001ac  ec532b18          VMOV     r2,r3,d8              ;363
0001b0  f7fffffe          BL       __aeabi_cdcmple
0001b4  bf2c              ITE      CS                    ;363
0001b6  2000              MOVCS    r0,#0                 ;363
0001b8  2001              MOVCC    r0,#1                 ;363
0001ba  edd40a00          VLDR     s1,[r4,#0]            ;363
0001be  ed940a0c          VLDR     s0,[r4,#0x30]         ;363
0001c2  eef40ac0          VCMPE.F32 s1,s0                 ;363
0001c6  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;363
0001ca  bfcc              ITE      GT                    ;363
0001cc  2101              MOVGT    r1,#1                 ;363
0001ce  2100              MOVLE    r1,#0                 ;363
0001d0  4288              CMP      r0,r1                 ;363
0001d2  f43faf68          BEQ      |L5.166|
0001d6  e760              B        |L5.154|
;;;395      
                          ENDP


                          AREA ||i._ZN4Anki24VelocityProfileGeneratorC1Ev||, CODE, READONLY, ALIGN=1

                  _ZN4Anki24VelocityProfileGeneratorC2Ev                  ; Alternate entry point ; Anki::VelocityProfileGenerator::VelocityProfileGenerator__sub_object()
                  _ZN4Anki24VelocityProfileGeneratorC1Ev PROC ; Anki::VelocityProfileGenerator::VelocityProfileGenerator()
;;;27      
;;;28       VelocityProfileGenerator::VelocityProfileGenerator()
;;;29       {
;;;30         targetReached_ = true;
;;;31       }
;;;32       
000000  2101              MOVS     r1,#1
000002  f8801035          STRB     r1,[r0,#0x35]
000006  4770              BX       lr
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki24VelocityProfileGeneratorC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki24VelocityProfileGeneratorC1Ev||
                          DCD      0x00000001

                          AREA ||area_number.8||, LINKORDER=||i._ZN4Anki24VelocityProfileGenerator12StartProfileEfffffff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki24VelocityProfileGenerator12StartProfileEfffffff||
                          DCD      0x00000001

                          AREA ||area_number.9||, LINKORDER=||i._ZN4Anki24VelocityProfileGenerator26StartProfile_fixedDurationEfffffffff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki24VelocityProfileGenerator26StartProfile_fixedDurationEfffffffff||
                          DCD      0x00000001

                          AREA ||area_number.10||, LINKORDER=||i._ZN4Anki24VelocityProfileGenerator4StepERfS1_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki24VelocityProfileGenerator4StepERfS1_||
                          DCD      0x00000001

                          AREA ||area_number.11||, LINKORDER=||i._ZN4Anki24VelocityProfileGenerator17DumpProfileToFileEPKc||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki24VelocityProfileGenerator17DumpProfileToFileEPKc||
                          DCD      0x00000001

                          AREA ||area_number.12||, LINKORDER=||i._ZN4Anki24VelocityProfileGenerator13TargetReachedEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki24VelocityProfileGenerator13TargetReachedEv||
                          DCD      0x00000001

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  56504720          DCB      "VPG FAIL: acc_start_duration + acc_end_duration exceeds"
000004  4641494c
000008  3a206163
00000c  635f7374
000010  6172745f
000014  64757261
000018  74696f6e
00001c  202b2061
000020  63635f65
000024  6e645f64
000028  75726174
00002c  696f6e20
000030  65786365
000034  656473  
000037  20746f74          DCB      " total duration (%f + %f > %f)\n",0
00003b  616c2064
00003f  75726174
000043  696f6e20
000047  28256620
00004b  2b202566
00004f  203e2025
000053  66290a00
000057  00                DCB      0
000058  56504720          DCB      "VPG FAIL: end_pos reached during starting acc phase. Co"
00005c  4641494c
000060  3a20656e
000064  645f706f
000068  73207265
00006c  61636865
000070  64206475
000074  72696e67
000078  20737461
00007c  7274696e
000080  67206163
000084  63207068
000088  6173652e
00008c  20436f  
00008f  6e736964          DCB      "nsider reducing acc_start duration or decreasing vel_st"
000093  65722072
000097  65647563
00009b  696e6720
00009f  6163635f
0000a3  73746172
0000a7  74206475
0000ab  72617469
0000af  6f6e206f
0000b3  72206465
0000b7  63726561
0000bb  73696e67
0000bf  2076656c
0000c3  5f7374  
0000c6  61727420          DCB      "art magnitude.\n",0
0000ca  6d61676e
0000ce  69747564
0000d2  652e0a00
