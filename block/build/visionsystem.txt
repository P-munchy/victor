; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\build\visionsystem.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\visionsystem.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F429X -DUSE_STDPERIPH_DRIVER -DSTM32F429_439xx -DUSE_DEFAULT_TIMEOUT_CALLBACK -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_FS -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DSTM32F429X --omf_browse=.\build\visionsystem.crf supervisor\src\visionSystem.cpp]
                          THUMB

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem12StopTrackingEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem12StopTrackingEv PROC ; Anki::Cozmo::VisionSystem::StopTracking()
;;;1493         
;;;1494         void StopTracking()
000000  b084              SUB      sp,sp,#0x10
;;;1495         {
;;;1496           SetMarkerToTrack(Vision::MARKER_UNKNOWN, 0.f, true);
000002  20f7              MOVS     r0,#0xf7
000004  490d              LDR      r1,|L1.60|
000006  f88d0008          STRB     r0,[sp,#8]
00000a  eebf0a00          VMOV.F32 s0,#-1.00000000
00000e  eddf0a0a          VLDR     s1,|L1.56|
000012  ed8d0a01          VSTR     s0,[sp,#4]
000016  7008              STRB     r0,[r1,#0]
000018  edc10a01          VSTR     s1,[r1,#4]
00001c  ed810a02          VSTR     s0,[r1,#8]
000020  eddd0a01          VLDR     s1,[sp,#4]
000024  2201              MOVS     r2,#1
000026  edc10a03          VSTR     s1,[r1,#0xc]
00002a  ed810a04          VSTR     s0,[r1,#0x10]
00002e  750a              STRB     r2,[r1,#0x14]
000030  4903              LDR      r1,|L1.64|
000032  70ca              STRB     r2,[r1,#3]
;;;1497         }
000034  b004              ADD      sp,sp,#0x10
000036  4770              BX       lr
;;;1498         
                          ENDP

                  |L1.56|
000038  00000000          DCFS     0x00000000 ; 0
                  |L1.60|
                          DCD      ||.bss||+0xb4
                  |L1.64|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem12TakeSnapshotENS_8Embedded9RectangleIiEEiRNS2_5ArrayIhEERb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem12TakeSnapshotENS_8Embedded9RectangleIiEEiRNS2_5ArrayIhEERb PROC ; Anki::Cozmo::VisionSystem::TakeSnapshot(Anki::Embedded::Rectangle<int>, int, Anki::Embedded::Array<unsigned char>&, bool&)
;;;1673         
;;;1674         Result TakeSnapshot(const Embedded::Rectangle<s32> roi, const s32 subsample,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1675                             Embedded::Array<u8>& snapshot, bool& readyFlag)
;;;1676         {
;;;1677           if(!isWaitingOnSnapshot_)
000004  4c3c              LDR      r4,|L2.248|
000006  4684              MOV      r12,r0                ;1676
000008  b088              SUB      sp,sp,#0x20           ;1676
00000a  7b20              LDRB     r0,[r4,#0xc]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754720isWaitingOnSnapshot_E
00000c  461d              MOV      r5,r3                 ;1676
00000e  2800              CMP      r0,#0
000010  f040806d          BNE.W    |L2.238|
;;;1678           {
;;;1679             snapshotROI_ = roi;
000014  4839              LDR      r0,|L2.252|
000016  f8dc3000          LDR      r3,[r12,#0]
;;;1680             
;;;1681             snapshotSubsample_ = subsample;
;;;1682             AnkiConditionalErrorAndReturnValue(snapshotSubsample_ >= 1,
00001a  4e39              LDR      r6,|L2.256|
00001c  6003              STR      r3,[r0,#0]
00001e  f8dc3004          LDR      r3,[r12,#4]
000022  6043              STR      r3,[r0,#4]
000024  f8dc3008          LDR      r3,[r12,#8]
000028  6083              STR      r3,[r0,#8]
00002a  f8dc300c          LDR      r3,[r12,#0xc]
00002e  60c3              STR      r3,[r0,#0xc]          ;1681
000030  6461              STR      r1,[r4,#0x44]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718snapshotSubsample_E
000032  2901              CMP      r1,#1
000034  da0f              BGE      |L2.86|
000036  f2406092          MOV      r0,#0x692
00003a  9600              STR      r6,[sp,#0]
00003c  e9cd0101          STRD     r0,r1,[sp,#4]
000040  a330              ADR      r3,|L2.260|
000042  a238              ADR      r2,|L2.292|
000044  a142              ADR      r1,|L2.336|
000046  2005              MOVS     r0,#5
000048  f7fffffe          BL       _Anki_Log
;;;1683                                                RESULT_FAIL_INVALID_PARAMETER,
;;;1684                                                "VisionSystem::TakeSnapshot()",
;;;1685                                                "Subsample must be >= 1. %d was specified!\n", snapshotSubsample_);
;;;1686   
;;;1687             snapshot_ = &snapshot;
;;;1688             
;;;1689             AnkiConditionalErrorAndReturnValue(snapshot_ != NULL, RESULT_FAIL_INVALID_OBJECT,
;;;1690                                                "VisionSystem::TakeSnapshot()", "NULL snapshot pointer!\n");
;;;1691             
;;;1692             AnkiConditionalErrorAndReturnValue(snapshot_->IsValid(),
;;;1693                                                RESULT_FAIL_INVALID_OBJECT,
;;;1694                                                "VisionSystem::TakeSnapshot()", "Invalid snapshot array!\n");
;;;1695             
;;;1696             const s32 nrowsSnap = snapshot_->get_size(0);
;;;1697             const s32 ncolsSnap = snapshot_->get_size(1);
;;;1698             
;;;1699             AnkiConditionalErrorAndReturnValue(nrowsSnap*snapshotSubsample_ == snapshotROI_.get_height() &&
;;;1700                                                ncolsSnap*snapshotSubsample_ == snapshotROI_.get_width(),
;;;1701                                                RESULT_FAIL_INVALID_SIZE,
;;;1702                                                "VisionSystem::TakeSnapshot()",
;;;1703                                                "Snapshot ROI size (%dx%d) subsampled by %d doesn't match snapshot array size (%dx%d)!\n",
;;;1704                                                snapshotROI_.get_height(), snapshotROI_.get_width(), snapshotSubsample_, nrowsSnap, ncolsSnap);
;;;1705             
;;;1706             isSnapshotReady_ = &readyFlag;
;;;1707             
;;;1708             AnkiConditionalErrorAndReturnValue(isSnapshotReady_ != NULL,
;;;1709                                                RESULT_FAIL_INVALID_OBJECT,
;;;1710                                                "VisionSystem::TakeSnapshot()",
;;;1711                                                "NULL isSnapshotReady pointer!\n");
;;;1712           
;;;1713             isWaitingOnSnapshot_ = true;
;;;1714             
;;;1715           } // if !isWaitingOnSnapshot_
;;;1716           
;;;1717           return RESULT_OK;
;;;1718         } // TakeSnapshot()
00004c  b008              ADD      sp,sp,#0x20
00004e  f04f7040          MOV      r0,#0x3000000         ;1682
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L2.86|
000056  4610              MOV      r0,r2                 ;1687
000058  64a2              STR      r2,[r4,#0x48]         ;1692  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff75479snapshot_E
00005a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
00005e  2800              CMP      r0,#0                 ;1692
000060  d033              BEQ      |L2.202|
000062  2100              MOVS     r1,#0                 ;1696
000064  6ca0              LDR      r0,[r4,#0x48]         ;1696  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff75479snapshot_E
000066  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00006a  4607              MOV      r7,r0                 ;1696
00006c  2101              MOVS     r1,#1                 ;1697
00006e  6ca0              LDR      r0,[r4,#0x48]         ;1697  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff75479snapshot_E
000070  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000074  4b21              LDR      r3,|L2.252|
000076  4602              MOV      r2,r0                 ;1697
000078  e9d31002          LDRD     r1,r0,[r3,#8]         ;1697
00007c  1a41              SUBS     r1,r0,r1              ;1697
00007e  6c60              LDR      r0,[r4,#0x44]         ;1699  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718snapshotSubsample_E
000080  fb07fc00          MUL      r12,r7,r0             ;1699
000084  4561              CMP      r1,r12                ;1699
000086  d107              BNE      |L2.152|
000088  e9d38c00          LDRD     r8,r12,[r3,#0]        ;1699
00008c  ebac0c08          SUB      r12,r12,r8            ;1699
000090  fb02f800          MUL      r8,r2,r0              ;1699
000094  45c4              CMP      r12,r8                ;1699
000096  d027              BEQ      |L2.232|
                  |L2.152|
000098  f8d3c004          LDR      r12,[r3,#4]           ;1699
00009c  681b              LDR      r3,[r3,#0]            ;1699
00009e  ebac0303          SUB      r3,r12,r3             ;1699
0000a2  e9cd3003          STRD     r3,r0,[sp,#0xc]       ;1699
0000a6  9600              STR      r6,[sp,#0]            ;1699
0000a8  e9cd7205          STRD     r7,r2,[sp,#0x14]      ;1699
0000ac  f24060a3          MOV      r0,#0x6a3             ;1699
0000b0  e9cd0101          STRD     r0,r1,[sp,#4]         ;1699
0000b4  a313              ADR      r3,|L2.260|
0000b6  4a2e              LDR      r2,|L2.368|
0000b8  a125              ADR      r1,|L2.336|
0000ba  2005              MOVS     r0,#5                 ;1699
0000bc  f7fffffe          BL       _Anki_Log
0000c0  b008              ADD      sp,sp,#0x20
0000c2  f04f60a0          MOV      r0,#0x5000000         ;1699
0000c6  e8bd81f0          POP      {r4-r8,pc}
                  |L2.202|
0000ca  f240609c          MOV      r0,#0x69c             ;1692
0000ce  e9cd6000          STRD     r6,r0,[sp,#0]         ;1692
0000d2  a30c              ADR      r3,|L2.260|
0000d4  a227              ADR      r2,|L2.372|
0000d6  a11e              ADR      r1,|L2.336|
0000d8  2005              MOVS     r0,#5                 ;1692
0000da  f7fffffe          BL       _Anki_Log
0000de  b008              ADD      sp,sp,#0x20
0000e0  f04f6080          MOV      r0,#0x4000000         ;1692
0000e4  e8bd81f0          POP      {r4-r8,pc}
                  |L2.232|
0000e8  2001              MOVS     r0,#1                 ;1713
0000ea  6425              STR      r5,[r4,#0x40]         ;1713  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754716isSnapshotReady_E
0000ec  7320              STRB     r0,[r4,#0xc]          ;1713
                  |L2.238|
0000ee  b008              ADD      sp,sp,#0x20
0000f0  2000              MOVS     r0,#0                 ;1717
0000f2  e8bd81f0          POP      {r4-r8,pc}
;;;1719         
                          ENDP

0000f6  0000              DCW      0x0000
                  |L2.248|
                          DCD      ||.data||
                  |L2.252|
                          DCD      ||.bss||+0x418
                  |L2.256|
                          DCD      ||.constdata||+0x2f96
                  |L2.260|
000104  73757065          DCB      "supervisor\\src\\visionSystem.cpp",0
000108  72766973
00010c  6f725c73
000110  72635c76
000114  6973696f
000118  6e537973
00011c  74656d2e
000120  63707000
                  |L2.292|
000124  53756273          DCB      "Subsample must be >= 1. %d was specified!\n",0
000128  616d706c
00012c  65206d75
000130  73742062
000134  65203e3d
000138  20312e20
00013c  25642077
000140  61732073
000144  70656369
000148  66696564
00014c  210a00  
00014f  00                DCB      0
                  |L2.336|
000150  56697369          DCB      "VisionSystem::TakeSnapshot()",0
000154  6f6e5379
000158  7374656d
00015c  3a3a5461
000160  6b65536e
000164  61707368
000168  6f742829
00016c  00      
00016d  00                DCB      0
00016e  00                DCB      0
00016f  00                DCB      0
                  |L2.368|
                          DCD      ||.constdata||+0x33b8
                  |L2.372|
000174  496e7661          DCB      "Invalid snapshot array!\n",0
000178  6c696420
00017c  736e6170
000180  73686f74
000184  20617272
000188  6179210a
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv PROC ; Anki::Cozmo::VisionSystem::VisionMemory::ResetBuffers()
;;;94             // WARNING: ResetBuffers should be used with caution
;;;95             static Result ResetBuffers()
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;96             {
000004  b0a3              SUB      sp,sp,#0x8c
;;;97               offchipScratch_ = MemoryStack(offchipBuffer, OFFCHIP_BUFFER_SIZE);
000006  2201              MOVS     r2,#1
000008  2300              MOVS     r3,#0
00000a  4611              MOV      r1,r2
00000c  a815              ADD      r0,sp,#0x54
00000e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000012  6803              LDR      r3,[r0,#0]
000014  4a71              LDR      r2,|L3.476|
000016  4972              LDR      r1,|L3.480|
000018  a80e              ADD      r0,sp,#0x38
00001a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
00001e  e890100e          LDM      r0,{r1-r3,r12}
000022  e9d05604          LDRD     r5,r6,[r0,#0x10]
000026  4c6f              LDR      r4,|L3.484|
000028  6980              LDR      r0,[r0,#0x18]
00002a  6125              STR      r5,[r4,#0x10]  ; _ZN4Anki5Cozmo12VisionSystem12VisionMemory15offchipScratch_E
00002c  e884100e          STM      r4,{r1-r3,r12}
;;;98               onchipScratch_  = MemoryStack(onchipBuffer, ONCHIP_BUFFER_SIZE);
000030  e9c46005          STRD     r6,r0,[r4,#0x14]
000034  2201              MOVS     r2,#1
000036  2300              MOVS     r3,#0
000038  4611              MOV      r1,r2
00003a  a815              ADD      r0,sp,#0x54
00003c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000040  6803              LDR      r3,[r0,#0]
000042  4a69              LDR      r2,|L3.488|
000044  4969              LDR      r1,|L3.492|
000046  a80e              ADD      r0,sp,#0x38
000048  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
00004c  e890100e          LDM      r0,{r1-r3,r12}
000050  e9d05604          LDRD     r5,r6,[r0,#0x10]
000054  6980              LDR      r0,[r0,#0x18]
000056  f104071c          ADD      r7,r4,#0x1c
00005a  62e5              STR      r5,[r4,#0x2c]  ; _ZN4Anki5Cozmo12VisionSystem12VisionMemory14onchipScratch_E
00005c  e8a7100e          STM      r7!,{r1-r3,r12}
;;;99               ccmScratch_     = MemoryStack(ccmBuffer, CCM_BUFFER_SIZE);
000060  e9c4600c          STRD     r6,r0,[r4,#0x30]
000064  2201              MOVS     r2,#1
000066  2300              MOVS     r3,#0
000068  4611              MOV      r1,r2
00006a  a815              ADD      r0,sp,#0x54
00006c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000070  6803              LDR      r3,[r0,#0]
000072  f24c3250          MOV      r2,#0xc350
000076  495e              LDR      r1,|L3.496|
000078  a80e              ADD      r0,sp,#0x38
00007a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
00007e  e890100e          LDM      r0,{r1-r3,r12}
000082  e9d05604          LDRD     r5,r6,[r0,#0x10]
000086  6980              LDR      r0,[r0,#0x18]
000088  64a5              STR      r5,[r4,#0x48]  ; _ZN4Anki5Cozmo12VisionSystem12VisionMemory11ccmScratch_E
00008a  e9c46013          STRD     r6,r0,[r4,#0x4c]
00008e  3438              ADDS     r4,r4,#0x38
;;;100    
;;;101              if(!offchipScratch_.IsValid() || !onchipScratch_.IsValid() || !ccmScratch_.IsValid()) {
000090  4854              LDR      r0,|L3.484|
000092  e8a4100e          STM      r4!,{r1-r3,r12}       ;99
000096  f7fffffe          BL       _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
00009a  2800              CMP      r0,#0
00009c  d06d              BEQ      |L3.378|
00009e  4855              LDR      r0,|L3.500|
0000a0  f7fffffe          BL       _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
0000a4  2800              CMP      r0,#0
0000a6  d068              BEQ      |L3.378|
0000a8  4853              LDR      r0,|L3.504|
0000aa  f7fffffe          BL       _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
0000ae  2800              CMP      r0,#0
0000b0  d063              BEQ      |L3.378|
;;;102                PRINT("Error: InitializeScratchBuffers\n");
;;;103                return RESULT_FAIL;
;;;104              }
;;;105    
;;;106              markers_ = FixedLengthList<VisionMarker>(VisionMemory::MAX_MARKERS, offchipScratch_);
0000b2  4c52              LDR      r4,|L3.508|
0000b4  a801              ADD      r0,sp,#4
0000b6  2300              MOVS     r3,#0
0000b8  9016              STR      r0,[sp,#0x58]
0000ba  f04f0a64          MOV      r10,#0x64
0000be  f1a40554          SUB      r5,r4,#0x54
0000c2  461a              MOV      r2,r3
0000c4  2101              MOVS     r1,#1
0000c6  a815              ADD      r0,sp,#0x54
0000c8  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000cc  6800              LDR      r0,[r0,#0]
0000ce  901c              STR      r0,[sp,#0x70]
0000d0  9000              STR      r0,[sp,#0]
0000d2  462b              MOV      r3,r5
0000d4  4652              MOV      r2,r10
0000d6  2101              MOVS     r1,#1
0000d8  a817              ADD      r0,sp,#0x5c
0000da  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0000de  e9d05600          LDRD     r5,r6,[r0,#0]
0000e2  e9d08702          LDRD     r8,r7,[r0,#8]
0000e6  2200              MOVS     r2,#0
0000e8  f8d09010          LDR      r9,[r0,#0x10]
0000ec  4611              MOV      r1,r2
0000ee  a81d              ADD      r0,sp,#0x74
0000f0  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
0000f4  4683              MOV      r11,r0
0000f6  2200              MOVS     r2,#0
0000f8  4611              MOV      r1,r2
0000fa  a820              ADD      r0,sp,#0x80
0000fc  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000100  e9db2300          LDRD     r2,r3,[r11,#0]
000104  f8db1008          LDR      r1,[r11,#8]
000108  9201              STR      r2,[sp,#4]
00010a  e9cd3102          STRD     r3,r1,[sp,#8]
00010e  e9d01200          LDRD     r1,r2,[r0,#0]
000112  6880              LDR      r0,[r0,#8]
000114  e9cd1204          STRD     r1,r2,[sp,#0x10]
000118  aa06              ADD      r2,sp,#0x18
00011a  2100              MOVS     r1,#0
00011c  e8a20161          STM      r2!,{r0,r5,r6,r8}
000120  e9cd790a          STRD     r7,r9,[sp,#0x28]
000124  2d00              CMP      r5,#0
000126  bfc8              IT       GT
000128  2e00              CMPGT    r6,#0
00012a  dd2d              BLE      |L3.392|
00012c  fb05f006          MUL      r0,r5,r6
000130  2800              CMP      r0,#0
000132  d029              BEQ      |L3.392|
000134  2000              MOVS     r0,#0
000136  fb009008          MLA      r0,r0,r8,r9
00013a  900c              STR      r0,[sp,#0x30]
                  |L3.316|
00013c  2d00              CMP      r5,#0
00013e  bfc8              IT       GT
000140  2e00              CMPGT    r6,#0
000142  dd23              BLE      |L3.396|
000144  fb05f006          MUL      r0,r5,r6
000148  b300              CBZ      r0,|L3.396|
00014a  2000              MOVS     r0,#0
00014c  fb009008          MLA      r0,r0,r8,r9
000150  900d              STR      r0,[sp,#0x34]
                  |L3.338|
000152  2d00              CMP      r5,#0
000154  bfc8              IT       GT
000156  2e00              CMPGT    r6,#0
000158  dd1a              BLE      |L3.400|
00015a  fb05f006          MUL      r0,r5,r6
00015e  b1b8              CBZ      r0,|L3.400|
000160  2000              MOVS     r0,#0
000162  fb009008          MLA      r0,r0,r8,r9
000166  900d              STR      r0,[sp,#0x34]
                  |L3.360|
000168  a81c              ADD      r0,sp,#0x70
00016a  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
00016e  b188              CBZ      r0,|L3.404|
000170  4651              MOV      r1,r10
000172  9816              LDR      r0,[sp,#0x58]
000174  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>::set_size(int)
000178  e010              B        |L3.412|
                  |L3.378|
00017a  a021              ADR      r0,|L3.512|
00017c  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;107    
;;;108              return RESULT_OK;
;;;109            }
000180  b023              ADD      sp,sp,#0x8c
000182  2001              MOVS     r0,#1                 ;103
000184  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.392|
000188  910c              STR      r1,[sp,#0x30]
00018a  e7d7              B        |L3.316|
                  |L3.396|
00018c  910d              STR      r1,[sp,#0x34]
00018e  e7e0              B        |L3.338|
                  |L3.400|
000190  910d              STR      r1,[sp,#0x34]
000192  e7e9              B        |L3.360|
                  |L3.404|
000194  2100              MOVS     r1,#0
000196  9816              LDR      r0,[sp,#0x58]
000198  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>::set_size(int)
                  |L3.412|
00019c  e9dd0101          LDRD     r0,r1,[sp,#4]
0001a0  4627              MOV      r7,r4
0001a2  9a03              LDR      r2,[sp,#0xc]
0001a4  60a2              STR      r2,[r4,#8]
0001a6  e9c70100          STRD     r0,r1,[r7,#0]
0001aa  e9dd0104          LDRD     r0,r1,[sp,#0x10]
0001ae  9a06              LDR      r2,[sp,#0x18]
0001b0  6162              STR      r2,[r4,#0x14]
0001b2  e9c70103          STRD     r0,r1,[r7,#0xc]
0001b6  9807              LDR      r0,[sp,#0x1c]
0001b8  f8440f18          STR      r0,[r4,#0x18]!
0001bc  9808              LDR      r0,[sp,#0x20]
0001be  6060              STR      r0,[r4,#4]
0001c0  9809              LDR      r0,[sp,#0x24]
0001c2  60a0              STR      r0,[r4,#8]
0001c4  980a              LDR      r0,[sp,#0x28]
0001c6  60e0              STR      r0,[r4,#0xc]
0001c8  980b              LDR      r0,[sp,#0x2c]
0001ca  6120              STR      r0,[r4,#0x10]
0001cc  980c              LDR      r0,[sp,#0x30]
0001ce  62f8              STR      r0,[r7,#0x2c]
0001d0  980d              LDR      r0,[sp,#0x34]
0001d2  6338              STR      r0,[r7,#0x30]         ;108
0001d4  b023              ADD      sp,sp,#0x8c
0001d6  2000              MOVS     r0,#0                 ;108
0001d8  e8bd8ff0          POP      {r4-r11,pc}
;;;110    
                          ENDP

                  |L3.476|
                          DCD      0x001e8480
                  |L3.480|
                          DCD      OFFCHIP
                  |L3.484|
                          DCD      ||.bss||
                  |L3.488|
                          DCD      0x00029810
                  |L3.492|
                          DCD      ONCHIP
                  |L3.496|
                          DCD      ||CCM||
                  |L3.500|
                          DCD      ||.bss||+0x1c
                  |L3.504|
                          DCD      ||.bss||+0x38
                  |L3.508|
                          DCD      ||.bss||+0x54
                  |L3.512|
000200  4572726f          DCB      "Error: InitializeScratchBuffers\n",0
000204  723a2049
000208  6e697469
00020c  616c697a
000210  65536372
000214  61746368
000218  42756666
00021c  6572730a
000220  00      
000221  00                DCB      0
000222  00                DCB      0
000223  00                DCB      0

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem13TrackTemplateERKNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEERKNS1_17TrackerParametersERNS2_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofERbNS2_11MemoryStackESI_SI_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem13TrackTemplateERKNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEERKNS1_17TrackerParametersERNS2_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofERbNS2_11MemoryStackESI_SI_ PROC ; Anki::Cozmo::VisionSystem::TrackTemplate(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, const Anki::Cozmo::VisionSystem::TrackerParameters&, Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof&, bool&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
;;;802    
;;;803          static Result TrackTemplate(const Array<u8> &grayscaleImage,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;804            const Quadrilateral<f32> &trackingQuad,
;;;805            const TrackerParameters &parameters,
;;;806            Tracker &tracker,
;;;807            bool &trackingSucceeded,
;;;808            MemoryStack ccmScratch,
;;;809            MemoryStack onchipScratch,
;;;810            MemoryStack offchipScratch)
;;;811          {
000004  4615              MOV      r5,r2
000006  ed2d8b02          VPUSH    {d8}
00000a  b0ab              SUB      sp,sp,#0xac
;;;812            BeginBenchmark("VisionSystem_TrackTemplate");
00000c  a0d0              ADR      r0,|L4.848|
00000e  e9ddba3c          LDRD     r11,r10,[sp,#0xf0]    ;811
000012  9c3a              LDR      r4,[sp,#0xe8]
000014  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
;;;813    
;;;814            AnkiAssert(parameters.isInitialized);
;;;815    
;;;816    #if USE_MATLAB_TRACKER
;;;817            return MatlabVisionProcessor::TrackTemplate(grayscaleImage, converged, ccmScratch);
;;;818    #endif
;;;819    
;;;820    #if DOCKING_ALGORITHM == DOCKING_LUCAS_KANADE_SLOW || DOCKING_ALGORITHM == DOCKING_LUCAS_KANADE_AFFINE || DOCKING_ALGORITHM == DOCKING_LUCAS_KANADE_PROJECTIVE
;;;821            // TODO: At some point template initialization should happen at full detection resolution
;;;822            //       but for now, we have to downsample to tracking resolution
;;;823            Array<u8> grayscaleImageSmall(parameters.trackingImageHeight, parameters.trackingImageWidth, ccmScratch);
;;;824            DownsampleHelper(grayscaleImage, grayscaleImageSmall, ccmScratch);
;;;825    
;;;826            //DebugStream::SendArray(grayscaleImageSmall);
;;;827    #endif
;;;828    
;;;829            trackingSucceeded = false;
000018  2600              MOVS     r6,#0
00001a  7026              STRB     r6,[r4,#0]
;;;830            s32 verify_meanAbsoluteDifference;
;;;831            s32 verify_numInBounds;
;;;832            s32 verify_numSimilarPixels;
;;;833    
;;;834    #if DOCKING_ALGORITHM == DOCKING_LUCAS_KANADE_SLOW
;;;835            const Result trackerResult = tracker.UpdateTrack(
;;;836              grayscaleImage,
;;;837              parameters.maxIterations,
;;;838              parameters.convergenceTolerance,
;;;839              parameters.useWeights,
;;;840              trackingSucceeded,
;;;841              onchipScratch);
;;;842    
;;;843    #elif DOCKING_ALGORITHM == DOCKING_LUCAS_KANADE_AFFINE
;;;844            const Result trackerResult = tracker.UpdateTrack(
;;;845              grayscaleImageSmall,
;;;846              parameters.maxIterations,
;;;847              parameters.convergenceTolerance,
;;;848              parameters.verify_maxPixelDifference,
;;;849              trackingSucceeded,
;;;850              verify_meanAbsoluteDifference,
;;;851              verify_numInBounds,
;;;852              verify_numSimilarPixels,
;;;853              onchipScratch);
;;;854    
;;;855            //tracker.get_transformation().Print("track");
;;;856    
;;;857    #elif DOCKING_ALGORITHM == DOCKING_LUCAS_KANADE_PROJECTIVE
;;;858            const Result trackerResult = tracker.UpdateTrack(
;;;859              grayscaleImageSmall,
;;;860              parameters.maxIterations,
;;;861              parameters.convergenceTolerance,
;;;862              parameters.verify_maxPixelDifference,
;;;863              trackingSucceeded,
;;;864              verify_meanAbsoluteDifference,
;;;865              verify_numInBounds,
;;;866              verify_numSimilarPixels,
;;;867              onchipScratch);
;;;868    
;;;869            //tracker.get_transformation().Print("track");
;;;870    
;;;871    #elif DOCKING_ALGORITHM == DOCKING_LUCAS_KANADE_SAMPLED_PROJECTIVE
;;;872    
;;;873            const Result trackerResult = tracker.UpdateTrack(
;;;874              grayscaleImage,
;;;875              parameters.maxIterations,
;;;876              parameters.convergenceTolerance,
;;;877              parameters.verify_maxPixelDifference,
;;;878              trackingSucceeded,
;;;879              verify_meanAbsoluteDifference,
;;;880              verify_numInBounds,
;;;881              verify_numSimilarPixels,
;;;882              onchipScratch);
;;;883    
;;;884            //tracker.get_transformation().Print("track");
;;;885    
;;;886    #elif DOCKING_ALGORITHM == DOCKING_BINARY_TRACKER
;;;887            s32 numMatches = -1;
;;;888    
;;;889            const Result trackerResult = tracker.UpdateTrack_Normal(
;;;890              grayscaleImage,
;;;891              parameters.edgeDetectionParams_update,
;;;892              parameters.matching_maxTranslationDistance,
;;;893              parameters.matching_maxProjectiveDistance,
;;;894              parameters.verify_maxTranslationDistance,
;;;895              parameters.verify_maxPixelDifference,
;;;896              parameters.verify_coordinateIncrement,
;;;897              numMatches,
;;;898              verify_meanAbsoluteDifference,
;;;899              verify_numInBounds,
;;;900              verify_numSimilarPixels,
;;;901              ccmScratch, offchipScratch);
;;;902    
;;;903            //tracker.get_transformation().Print("track");
;;;904    
;;;905            const s32 numTemplatePixels = tracker.get_numTemplatePixels();
;;;906    
;;;907            const f32 percentMatchedPixels = static_cast<f32>(numMatches) / static_cast<f32>(numTemplatePixels);
;;;908    
;;;909            if(percentMatchedPixels >= parameters.percentMatchedPixelsThreshold) {
;;;910              trackingSucceeded = true;
;;;911            } else {
;;;912              trackingSucceeded = false;
;;;913            }
;;;914    
;;;915    #elif DOCKING_ALGORITHM == DOCKING_LUCAS_KANADE_SAMPLED_PLANAR6DOF
;;;916    
;;;917            const Radians initAngleX(tracker.get_angleX());
00001c  9830              LDR      r0,[sp,#0xc0]
00001e  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleXEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleX() const
000022  ed900a00          VLDR     s0,[r0,#0]
000026  a81c              ADD      r0,sp,#0x70
000028  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
;;;918            const Radians initAngleY(tracker.get_angleY());
00002c  9830              LDR      r0,[sp,#0xc0]
00002e  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleYEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleY() const
000032  ed900a00          VLDR     s0,[r0,#0]
000036  a81e              ADD      r0,sp,#0x78
000038  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
;;;919            const Radians initAngleZ(tracker.get_angleZ());
00003c  9830              LDR      r0,[sp,#0xc0]
00003e  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleZEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleZ() const
000042  ed900a00          VLDR     s0,[r0,#0]
000046  a820              ADD      r0,sp,#0x80
000048  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
;;;920            const Point3<f32>& initTranslation = tracker.GetTranslation();
00004c  9830              LDR      r0,[sp,#0xc0]
00004e  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetTranslation() const
000052  4607              MOV      r7,r0
;;;921    
;;;922            bool converged = false;
000054  f88d60a4          STRB     r6,[sp,#0xa4]
;;;923            const Result trackerResult = tracker.UpdateTrack(grayscaleImage,
000058  4659              MOV      r1,r11
00005a  a805              ADD      r0,sp,#0x14
00005c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000060  aa1a              ADD      r2,sp,#0x68
000062  a91b              ADD      r1,sp,#0x6c
000064  9202              STR      r2,[sp,#8]
000066  e9cd1003          STRD     r1,r0,[sp,#0xc]
00006a  ab28              ADD      r3,sp,#0xa0
00006c  a829              ADD      r0,sp,#0xa4
00006e  e9cd0300          STRD     r0,r3,[sp,#0]
000072  7c2b              LDRB     r3,[r5,#0x10]
000074  edd50a0a          VLDR     s1,[r5,#0x28]
000078  ed950a09          VLDR     s0,[r5,#0x24]
00007c  69ea              LDR      r2,[r5,#0x1c]
00007e  992d              LDR      r1,[sp,#0xb4]
000080  9830              LDR      r0,[sp,#0xc0]
000082  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof11UpdateTrackERKNS0_5ArrayIhEEiffhRbRiS8_S8_NS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::UpdateTrack(const Anki::Embedded::Array<unsigned char>&, int, float, float, unsigned char, bool&, int&, int&, int&, Anki::Embedded::MemoryStack)
000086  4680              MOV      r8,r0
;;;924              parameters.maxIterations,
;;;925              parameters.convergenceTolerance_angle,
;;;926              parameters.convergenceTolerance_distance,
;;;927              parameters.verify_maxPixelDifference,
;;;928              converged,
;;;929              verify_meanAbsoluteDifference,
;;;930              verify_numInBounds,
;;;931              verify_numSimilarPixels,
;;;932              onchipScratch);
;;;933    
;;;934            // TODO: Do we care if converged == false?
;;;935    
;;;936            //
;;;937            // Go through a bunch of checks to see whether the tracking succeeded
;;;938            //
;;;939    
;;;940            if(fabs((initAngleX - tracker.get_angleX()).ToFloat()) > parameters.successTolerance_angle ||
000088  9830              LDR      r0,[sp,#0xc0]
00008a  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleXEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleX() const
00008e  ed900a00          VLDR     s0,[r0,#0]
000092  a91c              ADD      r1,sp,#0x70
000094  a822              ADD      r0,sp,#0x88
000096  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansEf ; Anki::operator -(const Anki::Radians&, float)
00009a  ed9d0a22          VLDR     s0,[sp,#0x88]
00009e  edd50a0e          VLDR     s1,[r5,#0x38]
0000a2  eeb00ac0          VABS.F32 s0,s0
0000a6  eeb40ae0          VCMPE.F32 s0,s1
0000aa  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000ae  dc27              BGT      |L4.256|
;;;941               fabs((initAngleY - tracker.get_angleY()).ToFloat()) > parameters.successTolerance_angle ||
0000b0  9830              LDR      r0,[sp,#0xc0]
0000b2  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleYEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleY() const
0000b6  ed900a00          VLDR     s0,[r0,#0]
0000ba  a91e              ADD      r1,sp,#0x78
0000bc  a824              ADD      r0,sp,#0x90
0000be  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansEf ; Anki::operator -(const Anki::Radians&, float)
0000c2  ed9d0a24          VLDR     s0,[sp,#0x90]
0000c6  edd50a0e          VLDR     s1,[r5,#0x38]
0000ca  eeb00ac0          VABS.F32 s0,s0
0000ce  eeb40ae0          VCMPE.F32 s0,s1
0000d2  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000d6  dc13              BGT      |L4.256|
;;;942               fabs((initAngleZ - tracker.get_angleZ()).ToFloat()) > parameters.successTolerance_angle)
0000d8  9830              LDR      r0,[sp,#0xc0]
0000da  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleZEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleZ() const
0000de  ed900a00          VLDR     s0,[r0,#0]
0000e2  a920              ADD      r1,sp,#0x80
0000e4  a826              ADD      r0,sp,#0x98
0000e6  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansEf ; Anki::operator -(const Anki::Radians&, float)
0000ea  ed9d0a26          VLDR     s0,[sp,#0x98]
0000ee  edd50a0e          VLDR     s1,[r5,#0x38]
0000f2  eeb00ac0          VABS.F32 s0,s0
0000f6  eeb40ae0          VCMPE.F32 s0,s1
0000fa  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000fe  dd05              BLE      |L4.268|
                  |L4.256|
;;;943            {
;;;944              PRINT("Tracker failed: angle(s) changed too much.\n");
000100  a09a              ADR      r0,|L4.876|
000102  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;945              trackingSucceeded = false;
000106  7026              STRB     r6,[r4,#0]
000108  f000b8e1          B.W      |L4.718|
                  |L4.268|
;;;946            }
;;;947            else if(tracker.GetTranslation().z < TrackerParameters::MIN_TRACKER_DISTANCE)
00010c  9830              LDR      r0,[sp,#0xc0]
00010e  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetTranslation() const
000112  ed900a02          VLDR     s0,[r0,#8]
000116  48a0              LDR      r0,|L4.920|
000118  edd00a00          VLDR     s1,[r0,#0]
00011c  eeb40ae0          VCMPE.F32 s0,s1
000120  eef1fa10          VMRS     APSR_nzcv,FPSCR
000124  d205              BCS      |L4.306|
;;;948            {
;;;949              PRINT("Tracker failed: final distance too close.\n");
000126  a09d              ADR      r0,|L4.924|
000128  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;950              trackingSucceeded = false;
00012c  7026              STRB     r6,[r4,#0]
00012e  f000b8ce          B.W      |L4.718|
                  |L4.306|
;;;951            }
;;;952            else if(tracker.GetTranslation().z > TrackerParameters::MAX_TRACKER_DISTANCE)
000132  9830              LDR      r0,[sp,#0xc0]
000134  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetTranslation() const
000138  ed900a02          VLDR     s0,[r0,#8]
00013c  48a2              LDR      r0,|L4.968|
00013e  edd00a00          VLDR     s1,[r0,#0]
000142  eeb40ae0          VCMPE.F32 s0,s1
000146  eef1fa10          VMRS     APSR_nzcv,FPSCR
00014a  dd05              BLE      |L4.344|
;;;953            {
;;;954              PRINT("Tracker failed: final distance too far away.\n");
00014c  a09f              ADR      r0,|L4.972|
00014e  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;955              trackingSucceeded = false;
000152  7026              STRB     r6,[r4,#0]
000154  f000b8bb          B.W      |L4.718|
                  |L4.344|
;;;956            }
;;;957            else if((initTranslation - tracker.GetTranslation()).Length() > parameters.successTolerance_distance)
000158  f10d0908          ADD      r9,sp,#8
00015c  9830              LDR      r0,[sp,#0xc0]
00015e  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetTranslation() const
000162  ed970a02          VLDR     s0,[r7,#8]
000166  edd00a02          VLDR     s1,[r0,#8]
00016a  edd01a00          VLDR     s3,[r0,#0]
00016e  ee301a60          VSUB.F32 s2,s0,s1
000172  ed970a01          VLDR     s0,[r7,#4]
000176  edd00a01          VLDR     s1,[r0,#4]
00017a  4648              MOV      r0,r9
00017c  ee700a60          VSUB.F32 s1,s0,s1
000180  ed970a00          VLDR     s0,[r7,#0]
000184  ee300a61          VSUB.F32 s0,s0,s3
000188  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
00018c  ed9d0a02          VLDR     s0,[sp,#8]
000190  eddd0a03          VLDR     s1,[sp,#0xc]
000194  ee200a00          VMUL.F32 s0,s0,s0
000198  ee000aa0          VMLA.F32 s0,s1,s1
00019c  eddd0a04          VLDR     s1,[sp,#0x10]
0001a0  ee000aa0          VMLA.F32 s0,s1,s1
0001a4  eef10ac0          VSQRT.F32 s1,s0
0001a8  eef40a60          VCMP.F32 s1,s1
0001ac  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001b0  d003              BEQ      |L4.442|
0001b2  f7fffffe          BL       __hardfp_sqrtf
0001b6  eef00a40          VMOV.F32 s1,s0
                  |L4.442|
0001ba  ed950a0f          VLDR     s0,[r5,#0x3c]
0001be  eef40ac0          VCMPE.F32 s1,s0
0001c2  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001c6  dd03              BLE      |L4.464|
;;;958            {
;;;959              PRINT("Tracker failed: position changed too much.\n");
0001c8  a08c              ADR      r0,|L4.1020|
0001ca  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;960              trackingSucceeded = false;
0001ce  e07d              B        |L4.716|
                  |L4.464|
;;;961            }
;;;962            else if(markerToTrack_.checkAngleX && fabs(tracker.get_angleX()) > TrackerParameters::MAX_BLOCK_DOCKING_ANGLE)
0001d0  4895              LDR      r0,|L4.1064|
0001d2  4f96              LDR      r7,|L4.1068|
0001d4  7d00              LDRB     r0,[r0,#0x14]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754714markerToTrack_E
0001d6  b190              CBZ      r0,|L4.510|
0001d8  9830              LDR      r0,[sp,#0xc0]
0001da  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleXEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleX() const
0001de  ed900a00          VLDR     s0,[r0,#0]
0001e2  edd70a00          VLDR     s1,[r7,#0]
0001e6  eeb00ac0          VABS.F32 s0,s0
0001ea  eeb40ae0          VCMPE.F32 s0,s1
0001ee  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001f2  dd04              BLE      |L4.510|
;;;963            {
;;;964              PRINT("Tracker failed: target X angle too large.\n");
0001f4  a08e              ADR      r0,|L4.1072|
0001f6  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;965              trackingSucceeded = false;
0001fa  7026              STRB     r6,[r4,#0]
0001fc  e067              B        |L4.718|
                  |L4.510|
;;;966            }
;;;967            else if(fabs(tracker.get_angleY()) > TrackerParameters::MAX_BLOCK_DOCKING_ANGLE)
0001fe  9830              LDR      r0,[sp,#0xc0]
000200  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleYEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleY() const
000204  ed900a00          VLDR     s0,[r0,#0]
000208  edd70a00          VLDR     s1,[r7,#0]
00020c  eeb00ac0          VABS.F32 s0,s0
000210  eeb40ae0          VCMPE.F32 s0,s1
000214  eef1fa10          VMRS     APSR_nzcv,FPSCR
000218  dd04              BLE      |L4.548|
;;;968            {
;;;969              PRINT("Tracker failed: target Y angle too large.\n");
00021a  a090              ADR      r0,|L4.1116|
00021c  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;970              trackingSucceeded = false;
000220  7026              STRB     r6,[r4,#0]
000222  e054              B        |L4.718|
                  |L4.548|
;;;971            }
;;;972            else if(fabs(tracker.get_angleZ()) > TrackerParameters::MAX_BLOCK_DOCKING_ANGLE)
000224  9830              LDR      r0,[sp,#0xc0]
000226  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleZEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleZ() const
00022a  ed900a00          VLDR     s0,[r0,#0]
00022e  edd70a00          VLDR     s1,[r7,#0]
000232  eeb00ac0          VABS.F32 s0,s0
000236  eeb40ae0          VCMPE.F32 s0,s1
00023a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00023e  dd04              BLE      |L4.586|
;;;973            {
;;;974              PRINT("Tracker failed: target Z angle too large.\n");
000240  a091              ADR      r0,|L4.1160|
000242  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;975              trackingSucceeded = false;
000246  7026              STRB     r6,[r4,#0]
000248  e041              B        |L4.718|
                  |L4.586|
;;;976            }
;;;977            else if(atan_fast(fabs(tracker.GetTranslation().x) / tracker.GetTranslation().z) > TrackerParameters::MAX_DOCKING_FOV_ANGLE)
00024a  9830              LDR      r0,[sp,#0xc0]
00024c  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetTranslation() const
000250  ed900a00          VLDR     s0,[r0,#0]
000254  9830              LDR      r0,[sp,#0xc0]
000256  eeb08ac0          VABS.F32 s16,s0
00025a  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetTranslation() const
00025e  edd00a02          VLDR     s1,[r0,#8]
000262  ee880a20          VDIV.F32 s0,s16,s1
000266  f7fffffe          BL       _Z9atan_fastf ; atan_fast(float)
00026a  4892              LDR      r0,|L4.1204|
00026c  edd00a00          VLDR     s1,[r0,#0]
000270  eeb40ae0          VCMPE.F32 s0,s1
000274  eef1fa10          VMRS     APSR_nzcv,FPSCR
000278  dd04              BLE      |L4.644|
;;;978            {
;;;979              PRINT("Tracker failed: FOV angle too large.\n");
00027a  a08f              ADR      r0,|L4.1208|
00027c  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;980              trackingSucceeded = false;
000280  7026              STRB     r6,[r4,#0]
000282  e024              B        |L4.718|
                  |L4.644|
;;;981            }
;;;982            else if( (static_cast<f32>(verify_numSimilarPixels) /
000284  9f1b              LDR      r7,[sp,#0x6c]
000286  f8dd9068          LDR      r9,[sp,#0x68]
00028a  ee007a10          VMOV     s0,r7
00028e  eeb81ac0          VCVT.F32.S32 s2,s0
000292  ee009a10          VMOV     s0,r9
000296  eeb80ac0          VCVT.F32.S32 s0,s0
00029a  eec10a00          VDIV.F32 s1,s2,s0
00029e  ed950a10          VLDR     s0,[r5,#0x40]
0002a2  eef40ac0          VCMPE.F32 s1,s0
0002a6  eef1fa10          VMRS     APSR_nzcv,FPSCR
;;;983              static_cast<f32>(verify_numInBounds)) < parameters.successTolerance_matchingPixelsFraction)
;;;984            {
;;;985              PRINT("Tracker failed: too many in-bounds pixels failed intensity verification (%d / %d < %f).\n",
;;;986                verify_numSimilarPixels, verify_numInBounds, parameters.successTolerance_matchingPixelsFraction);
;;;987              trackingSucceeded = false;
;;;988            }
;;;989            else {
;;;990              // Everything seems ok!
;;;991              trackingSucceeded = true;
0002aa  bf24              ITT      CS
0002ac  2001              MOVCS    r0,#1
0002ae  7020              STRBCS   r0,[r4,#0]
0002b0  d20d              BCS      |L4.718|
0002b2  ee100a10          VMOV     r0,s0                 ;985
0002b6  f7fffffe          BL       __aeabi_f2d
0002ba  ec410b10          VMOV     d0,r0,r1              ;985
0002be  464a              MOV      r2,r9                 ;985
0002c0  ed8d0b00          VSTR     d0,[sp,#0]            ;985
0002c4  4639              MOV      r1,r7                 ;985
0002c6  4886              LDR      r0,|L4.1248|
0002c8  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
                  |L4.716|
0002cc  7026              STRB     r6,[r4,#0]            ;960
                  |L4.718|
;;;992            }
;;;993    
;;;994    #else
;;;995    #error Unknown DOCKING_ALGORITHM!
;;;996    #endif
;;;997    
;;;998            if(trackerResult != RESULT_OK) {
0002ce  f1b80f00          CMP      r8,#0
;;;999              return RESULT_FAIL;
0002d2  bf1f              ITTTT    NE
0002d4  2001              MOVNE    r0,#1
;;;1000           }
;;;1001   
;;;1002           // Sanity check on tracker result
;;;1003   #if DOCKING_ALGORITHM != DOCKING_LUCAS_KANADE_SAMPLED_PLANAR6DOF
;;;1004   
;;;1005           // Check for a super shrunk or super large template
;;;1006           // (I don't think this works for planar 6dof homographies?  Try dividing by h22?)
;;;1007   #warning broken
;;;1008           /*{
;;;1009           // TODO: make not hacky
;;;1010           const Array<f32> &homography = tracker.get_transformation().get_homography();
;;;1011   
;;;1012           const s32 numValues = 4;
;;;1013           const s32 numMaxValues = 2;
;;;1014           f32 values[numValues] = {ABS(homography[0][0]), ABS(homography[0][1]), ABS(homography[1][0]), ABS(homography[1][1])};
;;;1015           s32 maxInds[numMaxValues] = {0, 1};
;;;1016           for(s32 i=1; i<numValues; i++) {
;;;1017           if(values[i] > values[maxInds[0]]) {
;;;1018           maxInds[0] = i;
;;;1019           }
;;;1020           }
;;;1021   
;;;1022           for(s32 i=0; i<numValues; i++) {
;;;1023           if(i == maxInds[0])
;;;1024           continue;
;;;1025   
;;;1026           if(values[i] > values[maxInds[1]]) {
;;;1027           maxInds[1] = i;
;;;1028           }
;;;1029           }
;;;1030   
;;;1031           const f32 secondValue = values[maxInds[1]];
;;;1032   
;;;1033           if(secondValue < 0.1f || secondValue > 40.0f) {
;;;1034           converged = false;
;;;1035           }
;;;1036           }*/
;;;1037   #endif // #if DOCKING_ALGORITHM != DOCKING_LUCAS_KANADE_SAMPLED_PLANAR6DOF
;;;1038   
;;;1039           EndBenchmark("VisionSystem_TrackTemplate");
;;;1040   
;;;1041           MatlabVisualization::SendTrack(grayscaleImage, tracker, trackingSucceeded, offchipScratch);
;;;1042   
;;;1043           //MatlabVisualization::SendTrackerPrediction_Compare(tracker, offchipScratch);
;;;1044   
;;;1045           DebugStream::SendTrackingUpdate(grayscaleImage, tracker, parameters, verify_meanAbsoluteDifference, static_cast<f32>(verify_numSimilarPixels) / static_cast<f32>(verify_numInBounds), ccmScratch, onchipScratch, offchipScratch);
;;;1046   
;;;1047           return RESULT_OK;
;;;1048         } // TrackTemplate()
0002d6  b02b              ADDNE    sp,sp,#0xac
0002d8  ecbd8b02          VPOPNE   {d8}
0002dc  b004              ADDNE    sp,sp,#0x10
0002de  bf18              IT       NE
0002e0  e8bd8ff0          POPNE    {r4-r11,pc}
0002e4  a01a              ADR      r0,|L4.848|
0002e6  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
0002ea  4651              MOV      r1,r10                ;1041
0002ec  a805              ADD      r0,sp,#0x14           ;1041
0002ee  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0002f2  4603              MOV      r3,r0                 ;1041
0002f4  7822              LDRB     r2,[r4,#0]            ;1041
0002f6  9930              LDR      r1,[sp,#0xc0]         ;1041
0002f8  982d              LDR      r0,[sp,#0xb4]         ;1041
0002fa  f7fffffe          BL       _ZN4Anki5Cozmo19MatlabVisualization9SendTrackERKNS_8Embedded5ArrayIhEERKNS2_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofEbNS2_11MemoryStackE ; Anki::Cozmo::MatlabVisualization::SendTrack(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof&, bool, Anki::Embedded::MemoryStack)
0002fe  4651              MOV      r1,r10                ;1045
000300  a813              ADD      r0,sp,#0x4c           ;1045
000302  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000306  4604              MOV      r4,r0                 ;1045
000308  4659              MOV      r1,r11                ;1045
00030a  a80c              ADD      r0,sp,#0x30           ;1045
00030c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000310  4606              MOV      r6,r0                 ;1045
000312  a805              ADD      r0,sp,#0x14           ;1045
000314  993b              LDR      r1,[sp,#0xec]         ;1045
000316  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00031a  ed9d0a1b          VLDR     s0,[sp,#0x6c]         ;1045
00031e  462a              MOV      r2,r5                 ;1045
000320  9930              LDR      r1,[sp,#0xc0]         ;1045
000322  eef80ac0          VCVT.F32.S32 s1,s0                 ;1045
000326  ed9d0a1a          VLDR     s0,[sp,#0x68]         ;1045
00032a  e9cd0600          STRD     r0,r6,[sp,#0]         ;1045
00032e  eeb81ac0          VCVT.F32.S32 s2,s0                 ;1045
000332  9828              LDR      r0,[sp,#0xa0]         ;1045
000334  9402              STR      r4,[sp,#8]            ;1045
000336  b2c3              UXTB     r3,r0                 ;1045
000338  ee800a81          VDIV.F32 s0,s1,s2              ;1045
00033c  982d              LDR      r0,[sp,#0xb4]         ;1045
00033e  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem11DebugStream18SendTrackingUpdateERKNS_8Embedded5ArrayIhEERKNS3_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofERKNS1_17TrackerParametersEhfNS3_11MemoryStackESF_SF_ ; Anki::Cozmo::VisionSystem::DebugStream::SendTrackingUpdate(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof&, const Anki::Cozmo::VisionSystem::TrackerParameters&, unsigned char, float, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
000342  b02b              ADD      sp,sp,#0xac
000344  2000              MOVS     r0,#0                 ;1047
000346  ecbd8b02          VPOP     {d8}
00034a  b004              ADD      sp,sp,#0x10
00034c  e8bd8ff0          POP      {r4-r11,pc}
;;;1049   
                          ENDP

                  |L4.848|
000350  56697369          DCB      "VisionSystem_TrackTemplate",0
000354  6f6e5379
000358  7374656d
00035c  5f547261
000360  636b5465
000364  6d706c61
000368  746500  
00036b  00                DCB      0
                  |L4.876|
00036c  54726163          DCB      "Tracker failed: angle(s) changed too much.\n",0
000370  6b657220
000374  6661696c
000378  65643a20
00037c  616e676c
000380  65287329
000384  20636861
000388  6e676564
00038c  20746f6f
000390  206d7563
000394  682e0a00
                  |L4.920|
                          DCD      _ZN4Anki5Cozmo12VisionSystem17TrackerParameters20MIN_TRACKER_DISTANCEE ; Anki::Cozmo::VisionSystem::TrackerParameters::MIN_TRACKER_DISTANCE
                  |L4.924|
00039c  54726163          DCB      "Tracker failed: final distance too close.\n",0
0003a0  6b657220
0003a4  6661696c
0003a8  65643a20
0003ac  66696e61
0003b0  6c206469
0003b4  7374616e
0003b8  63652074
0003bc  6f6f2063
0003c0  6c6f7365
0003c4  2e0a00  
0003c7  00                DCB      0
                  |L4.968|
                          DCD      _ZN4Anki5Cozmo12VisionSystem17TrackerParameters20MAX_TRACKER_DISTANCEE ; Anki::Cozmo::VisionSystem::TrackerParameters::MAX_TRACKER_DISTANCE
                  |L4.972|
0003cc  54726163          DCB      "Tracker failed: final distance too far away.\n",0
0003d0  6b657220
0003d4  6661696c
0003d8  65643a20
0003dc  66696e61
0003e0  6c206469
0003e4  7374616e
0003e8  63652074
0003ec  6f6f2066
0003f0  61722061
0003f4  7761792e
0003f8  0a00    
0003fa  00                DCB      0
0003fb  00                DCB      0
                  |L4.1020|
0003fc  54726163          DCB      "Tracker failed: position changed too much.\n",0
000400  6b657220
000404  6661696c
000408  65643a20
00040c  706f7369
000410  74696f6e
000414  20636861
000418  6e676564
00041c  20746f6f
000420  206d7563
000424  682e0a00
                  |L4.1064|
                          DCD      ||.bss||+0x9c
                  |L4.1068|
                          DCD      _ZN4Anki5Cozmo12VisionSystem17TrackerParameters23MAX_BLOCK_DOCKING_ANGLEE ; Anki::Cozmo::VisionSystem::TrackerParameters::MAX_BLOCK_DOCKING_ANGLE
                  |L4.1072|
000430  54726163          DCB      "Tracker failed: target X angle too large.\n",0
000434  6b657220
000438  6661696c
00043c  65643a20
000440  74617267
000444  65742058
000448  20616e67
00044c  6c652074
000450  6f6f206c
000454  61726765
000458  2e0a00  
00045b  00                DCB      0
                  |L4.1116|
00045c  54726163          DCB      "Tracker failed: target Y angle too large.\n",0
000460  6b657220
000464  6661696c
000468  65643a20
00046c  74617267
000470  65742059
000474  20616e67
000478  6c652074
00047c  6f6f206c
000480  61726765
000484  2e0a00  
000487  00                DCB      0
                  |L4.1160|
000488  54726163          DCB      "Tracker failed: target Z angle too large.\n",0
00048c  6b657220
000490  6661696c
000494  65643a20
000498  74617267
00049c  6574205a
0004a0  20616e67
0004a4  6c652074
0004a8  6f6f206c
0004ac  61726765
0004b0  2e0a00  
0004b3  00                DCB      0
                  |L4.1204|
                          DCD      _ZN4Anki5Cozmo12VisionSystem17TrackerParameters21MAX_DOCKING_FOV_ANGLEE ; Anki::Cozmo::VisionSystem::TrackerParameters::MAX_DOCKING_FOV_ANGLE
                  |L4.1208|
0004b8  54726163          DCB      "Tracker failed: FOV angle too large.\n",0
0004bc  6b657220
0004c0  6661696c
0004c4  65643a20
0004c8  464f5620
0004cc  616e676c
0004d0  6520746f
0004d4  6f206c61
0004d8  7267652e
0004dc  0a00    
0004de  00                DCB      0
0004df  00                DCB      0
                  |L4.1248|
                          DCD      ||.constdata||+0x335c

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem14GetVerticalFOVEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem14GetVerticalFOVEv PROC ; Anki::Cozmo::VisionSystem::GetVerticalFOV()
;;;1376   
;;;1377         f32 GetVerticalFOV() {
000000  4801              LDR      r0,|L5.8|
;;;1378           return headCamFOV_ver_;
000002  ed900a0b          VLDR     s0,[r0,#0x2c]
;;;1379         }
000006  4770              BX       lr
;;;1380   
                          ENDP

                  |L5.8|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem14LookForMarkersERKNS_8Embedded5ArrayIhEERKNS1_31DetectFiducialMarkersParametersERNS2_15FixedLengthListINS2_12VisionMarkerEEENS2_11MemoryStackESE_SE_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem14LookForMarkersERKNS_8Embedded5ArrayIhEERKNS1_31DetectFiducialMarkersParametersERNS2_15FixedLengthListINS2_12VisionMarkerEEENS2_11MemoryStackESE_SE_ PROC ; Anki::Cozmo::VisionSystem::LookForMarkers(const Anki::Embedded::Array<unsigned char>&, const Anki::Cozmo::VisionSystem::DetectFiducialMarkersParameters&, Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
;;;483    
;;;484          static Result LookForMarkers(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;485            const Array<u8> &grayscaleImage,
;;;486            const DetectFiducialMarkersParameters &parameters,
;;;487            FixedLengthList<VisionMarker> &markers,
;;;488            MemoryStack ccmScratch,
;;;489            MemoryStack onchipScratch,
;;;490            MemoryStack offchipScratch)
;;;491          {
000004  b0b5              SUB      sp,sp,#0xd4
000006  4615              MOV      r5,r2
000008  460c              MOV      r4,r1
;;;492            BeginBenchmark("VisionSystem_LookForMarkers");
00000a  a09c              ADR      r0,|L6.636|
00000c  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
;;;493    
;;;494            AnkiAssert(parameters.isInitialized);
;;;495    
;;;496            const s32 maxMarkers = markers.get_maximumSize();
;;;497    
;;;498            FixedLengthList<Array<f32> > homographies(maxMarkers, ccmScratch);
000010  a812              ADD      r0,sp,#0x48
000012  f8d5801c          LDR      r8,[r5,#0x1c]
000016  9001              STR      r0,[sp,#4]
000018  2300              MOVS     r3,#0
00001a  461a              MOV      r2,r3
00001c  2101              MOVS     r1,#1
00001e  a834              ADD      r0,sp,#0xd0
000020  9e38              LDR      r6,[sp,#0xe0]
000022  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000026  6800              LDR      r0,[r0,#0]
000028  9007              STR      r0,[sp,#0x1c]
00002a  9000              STR      r0,[sp,#0]
00002c  4633              MOV      r3,r6
00002e  4642              MOV      r2,r8
000030  2101              MOVS     r1,#1
000032  a802              ADD      r0,sp,#8
000034  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000038  f8d0a010          LDR      r10,[r0,#0x10]
00003c  e8b00ac0          LDM      r0!,{r6,r7,r9,r11}
000040  2200              MOVS     r2,#0
000042  4611              MOV      r1,r2
000044  a808              ADD      r0,sp,#0x20
000046  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00004a  2200              MOVS     r2,#0
00004c  9000              STR      r0,[sp,#0]
00004e  4611              MOV      r1,r2
000050  a80b              ADD      r0,sp,#0x2c
000052  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000056  4601              MOV      r1,r0
000058  9800              LDR      r0,[sp,#0]
00005a  2e00              CMP      r6,#0
00005c  e9d02300          LDRD     r2,r3,[r0,#0]
000060  6880              LDR      r0,[r0,#8]
000062  9212              STR      r2,[sp,#0x48]
000064  e9cd3013          STRD     r3,r0,[sp,#0x4c]
000068  e9d10200          LDRD     r0,r2,[r1,#0]
00006c  6889              LDR      r1,[r1,#8]
00006e  ab17              ADD      r3,sp,#0x5c
000070  f8cda070          STR      r10,[sp,#0x70]
000074  e8a30ac2          STM      r3!,{r1,r6,r7,r9,r11}
000078  e9cd0215          STRD     r0,r2,[sp,#0x54]
00007c  f04f0b00          MOV      r11,#0
000080  bfc8              IT       GT
000082  2f00              CMPGT    r7,#0
000084  dd25              BLE      |L6.210|
000086  fb06f007          MUL      r0,r6,r7
00008a  b310              CBZ      r0,|L6.210|
00008c  2000              MOVS     r0,#0
00008e  fb00a009          MLA      r0,r0,r9,r10
000092  901d              STR      r0,[sp,#0x74]
                  |L6.148|
000094  2e00              CMP      r6,#0
000096  bfc8              IT       GT
000098  2f00              CMPGT    r7,#0
00009a  dd1d              BLE      |L6.216|
00009c  fb06f007          MUL      r0,r6,r7
0000a0  b1d0              CBZ      r0,|L6.216|
0000a2  2000              MOVS     r0,#0
0000a4  fb00a009          MLA      r0,r0,r9,r10
0000a8  901e              STR      r0,[sp,#0x78]
                  |L6.170|
0000aa  2e00              CMP      r6,#0
0000ac  bfc8              IT       GT
0000ae  2f00              CMPGT    r7,#0
0000b0  dd15              BLE      |L6.222|
0000b2  fb06f007          MUL      r0,r6,r7
0000b6  b190              CBZ      r0,|L6.222|
0000b8  2000              MOVS     r0,#0
0000ba  fb00a009          MLA      r0,r0,r9,r10
0000be  901e              STR      r0,[sp,#0x78]
                  |L6.192|
0000c0  a807              ADD      r0,sp,#0x1c
0000c2  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0000c6  b168              CBZ      r0,|L6.228|
0000c8  4641              MOV      r1,r8
0000ca  9801              LDR      r0,[sp,#4]
0000cc  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Array<float>>::set_size(int)
0000d0  e00c              B        |L6.236|
                  |L6.210|
0000d2  f8cdb074          STR      r11,[sp,#0x74]
0000d6  e7dd              B        |L6.148|
                  |L6.216|
0000d8  f8cdb078          STR      r11,[sp,#0x78]
0000dc  e7e5              B        |L6.170|
                  |L6.222|
0000de  f8cdb078          STR      r11,[sp,#0x78]
0000e2  e7ed              B        |L6.192|
                  |L6.228|
0000e4  2100              MOVS     r1,#0
0000e6  9801              LDR      r0,[sp,#4]
0000e8  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Array<float>>::set_size(int)
                  |L6.236|
;;;499    
;;;500            markers.set_size(maxMarkers);
0000ec  4641              MOV      r1,r8
0000ee  4628              MOV      r0,r5
0000f0  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>::set_size(int)
;;;501            homographies.set_size(maxMarkers);
0000f4  4641              MOV      r1,r8
0000f6  a812              ADD      r0,sp,#0x48
0000f8  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Array<float>>::set_size(int)
;;;502    
;;;503            for(s32 i=0; i<maxMarkers; i++) {
0000fc  2600              MOVS     r6,#0
0000fe  f1b80f00          CMP      r8,#0
000102  dd1f              BLE      |L6.324|
                  |L6.260|
;;;504              Array<f32> newArray(3, 3, ccmScratch);
000104  2300              MOVS     r3,#0
000106  461a              MOV      r2,r3
000108  2101              MOVS     r1,#1
00010a  a806              ADD      r0,sp,#0x18
00010c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000110  6800              LDR      r0,[r0,#0]
000112  9000              STR      r0,[sp,#0]
000114  2203              MOVS     r2,#3
000116  4611              MOV      r1,r2
000118  a801              ADD      r0,sp,#4
00011a  9b38              LDR      r3,[sp,#0xe0]
00011c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000120  eb060186          ADD      r1,r6,r6,LSL #2
000124  981e              LDR      r0,[sp,#0x78]
000126  1c76              ADDS     r6,r6,#1              ;503
000128  eb000081          ADD      r0,r0,r1,LSL #2       ;503
00012c  9901              LDR      r1,[sp,#4]            ;503
00012e  6001              STR      r1,[r0,#0]            ;503
000130  9902              LDR      r1,[sp,#8]            ;503
000132  6041              STR      r1,[r0,#4]            ;503
000134  9903              LDR      r1,[sp,#0xc]          ;503
000136  6081              STR      r1,[r0,#8]            ;503
000138  9904              LDR      r1,[sp,#0x10]         ;503
00013a  60c1              STR      r1,[r0,#0xc]          ;503
00013c  9905              LDR      r1,[sp,#0x14]         ;503
00013e  6101              STR      r1,[r0,#0x10]         ;503
000140  45b0              CMP      r8,r6                 ;503
000142  dcdf              BGT      |L6.260|
                  |L6.324|
;;;505              homographies[i] = newArray;
;;;506            }
;;;507    
;;;508            MatlabVisualization::ResetFiducialDetection(grayscaleImage);
000144  9835              LDR      r0,[sp,#0xd4]
000146  f7fffffe          BL       _ZN4Anki5Cozmo19MatlabVisualization22ResetFiducialDetectionERKNS_8Embedded5ArrayIhEE ; Anki::Cozmo::MatlabVisualization::ResetFiducialDetection(const Anki::Embedded::Array<unsigned char>&)
;;;509    
;;;510    #if USE_MATLAB_DETECTOR
;;;511            const Result result = MatlabVisionProcessor::DetectMarkers(grayscaleImage, markers, homographies, ccmScratch);
;;;512    #else
;;;513            const Result result = DetectFiducialMarkers(
00014a  a82d              ADD      r0,sp,#0xb4
00014c  9943              LDR      r1,[sp,#0x10c]
00014e  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000152  4606              MOV      r6,r0
000154  a826              ADD      r0,sp,#0x98
000156  9942              LDR      r1,[sp,#0x108]
000158  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00015c  4607              MOV      r7,r0
00015e  a81f              ADD      r0,sp,#0x7c
000160  9938              LDR      r1,[sp,#0xe0]
000162  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000166  9611              STR      r6,[sp,#0x44]
000168  f8cdb038          STR      r11,[sp,#0x38]
00016c  e9cd070f          STRD     r0,r7,[sp,#0x3c]
000170  e9d42314          LDRD     r2,r3,[r4,#0x50]
000174  f8b4004c          LDRH     r0,[r4,#0x4c]
000178  ae0a              ADD      r6,sp,#0x28
00017a  6ba1              LDR      r1,[r4,#0x38]
00017c  c60f              STM      r6!,{r0-r3}
00017e  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
000182  ae06              ADD      r6,sp,#0x18
000184  6b20              LDR      r0,[r4,#0x30]
000186  6c63              LDR      r3,[r4,#0x44]
000188  c60f              STM      r6!,{r0-r3}
00018a  e9d40109          LDRD     r0,r1,[r4,#0x24]
00018e  8b23              LDRH     r3,[r4,#0x18]
000190  6ae2              LDR      r2,[r4,#0x2c]
000192  b21b              SXTH     r3,r3
000194  9205              STR      r2,[sp,#0x14]
000196  9302              STR      r3,[sp,#8]
000198  e9cd0103          STRD     r0,r1,[sp,#0xc]
00019c  8aa0              LDRH     r0,[r4,#0x14]
00019e  68e1              LDR      r1,[r4,#0xc]
0001a0  b200              SXTH     r0,r0
0001a2  e9cd1000          STRD     r1,r0,[sp,#0]
0001a6  edd41a17          VLDR     s3,[r4,#0x5c]
0001aa  ed941a16          VLDR     s2,[r4,#0x58]
0001ae  edd40a12          VLDR     s1,[r4,#0x48]
0001b2  ed940a0d          VLDR     s0,[r4,#0x34]
0001b6  aa12              ADD      r2,sp,#0x48
0001b8  4629              MOV      r1,r5
0001ba  6923              LDR      r3,[r4,#0x10]
0001bc  9835              LDR      r0,[sp,#0xd4]
0001be  f7fffffe          BL       _ZN4Anki8Embedded21DetectFiducialMarkersERKNS0_5ArrayIhEERNS0_15FixedLengthListINS0_12VisionMarkerEEERNS5_INS1_IfEEEEiissiiiifiiifiiiiffbNS0_11MemoryStackESC_SC_ ; Anki::Embedded::DetectFiducialMarkers(const Anki::Embedded::Array<unsigned char>&, Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>&, Anki::Embedded::FixedLengthList<Anki::Embedded::Array<float>>&, int, int, short, short, int, int, int, int, float, int, int, int, float, int, int, int, int, float, float, bool, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
;;;514              grayscaleImage,
;;;515              markers,
;;;516              homographies,
;;;517              parameters.scaleImage_numPyramidLevels, parameters.scaleImage_thresholdMultiplier,
;;;518              parameters.component1d_minComponentWidth, parameters.component1d_maxSkipDistance,
;;;519              parameters.component_minimumNumPixels, parameters.component_maximumNumPixels,
;;;520              parameters.component_sparseMultiplyThreshold, parameters.component_solidMultiplyThreshold,
;;;521              parameters.component_minHollowRatio,
;;;522              parameters.quads_minQuadArea, parameters.quads_quadSymmetryThreshold, parameters.quads_minDistanceFromImageEdge,
;;;523              parameters.decode_minContrastRatio,
;;;524              parameters.maxConnectedComponentSegments,
;;;525              parameters.maxExtractedQuads,
;;;526              parameters.quadRefinementIterations,
;;;527              parameters.numRefinementSamples,
;;;528              parameters.quadRefinementMaxCornerChange,
;;;529              parameters.quadRefinementMinCornerChange,
;;;530              false,
;;;531              ccmScratch, onchipScratch, offchipScratch);
;;;532    #endif
;;;533            
;;;534            if(result != RESULT_OK) {
0001c2  2800              CMP      r0,#0
;;;535              return result;
;;;536            }
;;;537    
;;;538            EndBenchmark("VisionSystem_LookForMarkers");
;;;539    
;;;540            DebugStream::SendFiducialDetection(grayscaleImage, markers, ccmScratch, onchipScratch, offchipScratch);
;;;541    
;;;542            for(s32 i_marker = 0; i_marker < markers.get_size(); ++i_marker) {
;;;543              const VisionMarker crntMarker = markers[i_marker];
;;;544    
;;;545              MatlabVisualization::SendFiducialDetection(crntMarker.corners, crntMarker.markerType);
;;;546            }
;;;547    
;;;548            MatlabVisualization::SendDrawNow();
;;;549    
;;;550            return RESULT_OK;
;;;551          } // LookForMarkers()
0001c4  bf1c              ITT      NE
0001c6  b039              ADDNE    sp,sp,#0xe4
0001c8  e8bd8ff0          POPNE    {r4-r11,pc}
0001cc  a02b              ADR      r0,|L6.636|
0001ce  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
0001d2  a81f              ADD      r0,sp,#0x7c           ;540
0001d4  9943              LDR      r1,[sp,#0x10c]        ;540
0001d6  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0001da  4604              MOV      r4,r0                 ;540
0001dc  a826              ADD      r0,sp,#0x98           ;540
0001de  9942              LDR      r1,[sp,#0x108]        ;540
0001e0  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0001e4  4606              MOV      r6,r0                 ;540
0001e6  a82d              ADD      r0,sp,#0xb4           ;540
0001e8  9938              LDR      r1,[sp,#0xe0]         ;540
0001ea  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0001ee  4602              MOV      r2,r0                 ;540
0001f0  4633              MOV      r3,r6                 ;540
0001f2  4629              MOV      r1,r5                 ;540
0001f4  9400              STR      r4,[sp,#0]            ;540
0001f6  9835              LDR      r0,[sp,#0xd4]         ;540
0001f8  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem11DebugStream21SendFiducialDetectionERKNS_8Embedded5ArrayIhEERKNS3_15FixedLengthListINS3_12VisionMarkerEEENS3_11MemoryStackESD_SD_ ; Anki::Cozmo::VisionSystem::DebugStream::SendFiducialDetection(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
0001fc  68e8              LDR      r0,[r5,#0xc]          ;542
0001fe  2600              MOVS     r6,#0                 ;542
000200  2800              CMP      r0,#0                 ;542
000202  bfc8              IT       GT                    ;543
000204  466f              MOVGT    r7,sp                 ;543
000206  dd32              BLE      |L6.622|
                  |L6.520|
000208  eb060246          ADD      r2,r6,r6,LSL #1       ;542
00020c  6b29              LDR      r1,[r5,#0x30]         ;542
00020e  eb0202c6          ADD      r2,r2,r6,LSL #3       ;542
000212  eb010482          ADD      r4,r1,r2,LSL #2       ;542
000216  4668              MOV      r0,sp                 ;543
000218  2304              MOVS     r3,#4                 ;543
00021a  2208              MOVS     r2,#8                 ;543
00021c  491e              LDR      r1,|L6.664|
00021e  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
000222  4603              MOV      r3,r0                 ;543
000224  2000              MOVS     r0,#0                 ;543
                  |L6.550|
000226  eb0401c0          ADD      r1,r4,r0,LSL #3       ;543
00022a  eb0302c0          ADD      r2,r3,r0,LSL #3       ;543
00022e  ed910a00          VLDR     s0,[r1,#0]            ;543
000232  1c40              ADDS     r0,r0,#1              ;543
000234  ed820a00          VSTR     s0,[r2,#0]            ;543
000238  ed910a01          VLDR     s0,[r1,#4]            ;543
00023c  2804              CMP      r0,#4                 ;543
00023e  ed820a01          VSTR     s0,[r2,#4]            ;543
000242  dbf0              BLT      |L6.550|
000244  f8940020          LDRB     r0,[r4,#0x20]         ;543
000248  f8830020          STRB     r0,[r3,#0x20]         ;543
00024c  ed940a09          VLDR     s0,[r4,#0x24]         ;543
000250  f1070120          ADD      r1,r7,#0x20           ;545
000254  ed830a09          VSTR     s0,[r3,#0x24]         ;545
000258  f8940028          LDRB     r0,[r4,#0x28]         ;545
00025c  f8830028          STRB     r0,[r3,#0x28]         ;545
000260  4668              MOV      r0,sp                 ;545
000262  f7fffffe          BL       _ZN4Anki5Cozmo19MatlabVisualization21SendFiducialDetectionERKNS_8Embedded13QuadrilateralIfEERKNS_6Vision10MarkerTypeE ; Anki::Cozmo::MatlabVisualization::SendFiducialDetection(const Anki::Embedded::Quadrilateral<float>&, const Anki::Vision::MarkerType&)
000266  68e8              LDR      r0,[r5,#0xc]          ;542
000268  1c76              ADDS     r6,r6,#1              ;542
00026a  4286              CMP      r6,r0                 ;542
00026c  dbcc              BLT      |L6.520|
                  |L6.622|
00026e  f7fffffe          BL       _ZN4Anki5Cozmo19MatlabVisualization11SendDrawNowEv ; Anki::Cozmo::MatlabVisualization::SendDrawNow()
000272  b039              ADD      sp,sp,#0xe4
000274  2000              MOVS     r0,#0                 ;550
000276  e8bd8ff0          POP      {r4-r11,pc}
;;;552    
                          ENDP

00027a  0000              DCW      0x0000
                  |L6.636|
00027c  56697369          DCB      "VisionSystem_LookForMarkers",0
000280  6f6e5379
000284  7374656d
000288  5f4c6f6f
00028c  6b466f72
000290  4d61726b
000294  65727300
                  |L6.664|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem16DownsampleHelperERKNS_8Embedded5ArrayIhEERS4_NS2_11MemoryStackE||, CODE, READONLY, ALIGN=1

                  _ZN4Anki5Cozmo12VisionSystem16DownsampleHelperERKNS_8Embedded5ArrayIhEERS4_NS2_11MemoryStackE PROC ; Anki::Cozmo::VisionSystem::DownsampleHelper(const Anki::Embedded::Array<unsigned char>&, Anki::Embedded::Array<unsigned char>&, Anki::Embedded::MemoryStack)
;;;1338   
;;;1339         u32 DownsampleHelper(const Array<u8>& in,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1340           Array<u8>& out,
;;;1341           MemoryStack scratch)
;;;1342         {
000004  460d              MOV      r5,r1
000006  b088              SUB      sp,sp,#0x20
000008  4617              MOV      r7,r2
00000a  4606              MOV      r6,r0
;;;1343           const s32 inWidth  = in.get_size(1);
00000c  2101              MOVS     r1,#1
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000012  4604              MOV      r4,r0
;;;1344           //const s32 inHeight = in.get_size(0);
;;;1345   
;;;1346           const s32 outWidth  = out.get_size(1);
000014  2101              MOVS     r1,#1
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
;;;1347           //const s32 outHeight = out.get_size(0);
;;;1348   
;;;1349           const u32 downsampleFactor = inWidth / outWidth;
00001c  fb94f4f0          SDIV     r4,r4,r0
;;;1350   
;;;1351           const u32 downsamplePower = Log2u32(downsampleFactor);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       Log2u32
000026  ea5f0800          MOVS     r8,r0
;;;1352   
;;;1353           if(downsamplePower > 0) {
00002a  d00a              BEQ      |L7.66|
;;;1354             //PRINT("Downsampling [%d x %d] frame by %d.\n", inWidth, inHeight, (1 << downsamplePower));
;;;1355   
;;;1356             ImageProcessing::DownsampleByPowerOfTwo<u8,u32,u8>(in,
00002c  4639              MOV      r1,r7
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000034  4603              MOV      r3,r0
000036  462a              MOV      r2,r5
000038  4641              MOV      r1,r8
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       _ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)
;;;1357               downsamplePower,
;;;1358               out,
;;;1359               scratch);
;;;1360           } else {
000040  e003              B        |L7.74|
                  |L7.66|
;;;1361             // No need to downsample, just copy the buffer
;;;1362             out.Set(in);
000042  4631              MOV      r1,r6
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhE3SetERKS2_ ; Anki::Embedded::Array<unsigned char>::Set(const Anki::Embedded::Array<unsigned char>&)
                  |L7.74|
;;;1363           }
;;;1364   
;;;1365           return downsampleFactor;
;;;1366         }
00004a  b008              ADD      sp,sp,#0x20
00004c  4620              MOV      r0,r4                 ;1365
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;1367   
                          ENDP


                          AREA ||i._ZN4Anki5Cozmo12VisionSystem16GetHorizontalFOVEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem16GetHorizontalFOVEv PROC ; Anki::Cozmo::VisionSystem::GetHorizontalFOV()
;;;1380   
;;;1381         f32 GetHorizontalFOV() {
000000  4801              LDR      r0,|L8.8|
;;;1382           return headCamFOV_hor_;
000002  ed900a0c          VLDR     s0,[r0,#0x30]
;;;1383         }
000006  4770              BX       lr
;;;1384   
                          ENDP

                  |L8.8|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem16SetImageSendModeENS0_15ImageSendMode_tENS_6Vision16CameraResolutionE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem16SetImageSendModeENS0_15ImageSendMode_tENS_6Vision16CameraResolutionE PROC ; Anki::Cozmo::VisionSystem::SetImageSendMode(Anki::Cozmo::ImageSendMode_t, Anki::Vision::CameraResolution)
;;;404    
;;;405          void SetImageSendMode(ImageSendMode_t mode, Vision::CameraResolution res)
000000  2901              CMP      r1,#1
;;;406          {
;;;407            if (res == Vision::CAMERA_RES_QVGA ||
;;;408              res == Vision::CAMERA_RES_QQVGA ||
000002  bf18              IT       NE
000004  2902              CMPNE    r1,#2
000006  d003              BEQ      |L9.16|
;;;409              res == Vision::CAMERA_RES_QQQVGA ||
000008  2903              CMP      r1,#3
;;;410              res == Vision::CAMERA_RES_QQQQVGA) {
00000a  bf1c              ITT      NE
00000c  2904              CMPNE    r1,#4
;;;411                imageSendMode_ = mode;
;;;412                nextSendImageResolution_ = res;
;;;413            }
;;;414          }
00000e  4770              BXNE     lr
                  |L9.16|
000010  4a01              LDR      r2,|L9.24|
000012  7110              STRB     r0,[r2,#4]            ;411
000014  7151              STRB     r1,[r2,#5]            ;412
000016  4770              BX       lr
;;;415    
                          ENDP

                  |L9.24|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfRKNS_8Embedded5PointIfEEfb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfRKNS_8Embedded5PointIfEEfb PROC ; Anki::Cozmo::VisionSystem::SetMarkerToTrack(const Anki::Vision::MarkerType&, float, const Anki::Embedded::Point<float>&, float, bool)
;;;1474   
;;;1475         Result SetMarkerToTrack(const Vision::MarkerType& markerTypeToTrack,
000000  4b0a              LDR      r3,|L10.44|
;;;1476                                 const f32 markerWidth_mm,
;;;1477                                 const Point2f& atImageCenter,
;;;1478                                 const f32 imageSearchRadius,
;;;1479                                 const bool checkAngleX)
;;;1480         {
;;;1481           newMarkerToTrack_.type              = markerTypeToTrack;
000002  7800              LDRB     r0,[r0,#0]
000004  7018              STRB     r0,[r3,#0]
;;;1482           newMarkerToTrack_.width_mm          = markerWidth_mm;
000006  ed830a01          VSTR     s0,[r3,#4]
00000a  ed910a00          VLDR     s0,[r1,#0]
;;;1483           newMarkerToTrack_.imageCenter       = atImageCenter;
;;;1484           newMarkerToTrack_.imageSearchRadius = imageSearchRadius;
;;;1485           newMarkerToTrack_.checkAngleX       = checkAngleX;
;;;1486           
;;;1487           // Next call to Update(), we will call UpdateMarkerToTrack() and
;;;1488           // actually replace the current markerToTrack_ with the one set here.
;;;1489           newMarkerToTrackWasProvided_ = true;
00000e  2001              MOVS     r0,#1
000010  ed830a02          VSTR     s0,[r3,#8]
000014  ed910a01          VLDR     s0,[r1,#4]
000018  4905              LDR      r1,|L10.48|
00001a  ed830a03          VSTR     s0,[r3,#0xc]
00001e  edc30a04          VSTR     s1,[r3,#0x10]         ;1484
000022  751a              STRB     r2,[r3,#0x14]         ;1485
000024  70c8              STRB     r0,[r1,#3]
;;;1490           
;;;1491           return RESULT_OK;
000026  2000              MOVS     r0,#0
;;;1492         }
000028  4770              BX       lr
;;;1493         
                          ENDP

00002a  0000              DCW      0x0000
                  |L10.44|
                          DCD      ||.bss||+0xb4
                  |L10.48|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfb PROC ; Anki::Cozmo::VisionSystem::SetMarkerToTrack(const Anki::Vision::MarkerType&, float, bool)
;;;1464   
;;;1465         Result SetMarkerToTrack(const Vision::MarkerType& markerTypeToTrack,
000000  b082              SUB      sp,sp,#8
;;;1466                                 const f32 markerWidth_mm,
;;;1467                                 const bool checkAngleX)
;;;1468         {
;;;1469           const Point2f imageCenter(-1.f, -1.f);
000002  eeff0a00          VMOV.F32 s1,#-1.00000000
000006  edcd0a00          VSTR     s1,[sp,#0]
00000a  4a0b              LDR      r2,|L11.56|
00000c  edcd0a01          VSTR     s1,[sp,#4]
000010  7800              LDRB     r0,[r0,#0]
000012  7010              STRB     r0,[r2,#0]
000014  ed820a01          VSTR     s0,[r2,#4]
000018  edc20a02          VSTR     s1,[r2,#8]
00001c  ed9d0a01          VLDR     s0,[sp,#4]
000020  2001              MOVS     r0,#1
000022  ed820a03          VSTR     s0,[r2,#0xc]
000026  edc20a04          VSTR     s1,[r2,#0x10]
00002a  7511              STRB     r1,[r2,#0x14]
00002c  4903              LDR      r1,|L11.60|
00002e  70c8              STRB     r0,[r1,#3]
000030  2000              MOVS     r0,#0
;;;1470           const f32     searchRadius = -1.f;
;;;1471           return SetMarkerToTrack(markerTypeToTrack, markerWidth_mm,
;;;1472             imageCenter, searchRadius, checkAngleX);
;;;1473         }
000032  b002              ADD      sp,sp,#8
000034  4770              BX       lr
;;;1474   
                          ENDP

000036  0000              DCW      0x0000
                  |L11.56|
                          DCD      ||.bss||+0xb4
                  |L11.60|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem18TakeSnapshotHelperERKNS_8Embedded5ArrayIhEE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem18TakeSnapshotHelperERKNS_8Embedded5ArrayIhEE PROC ; Anki::Cozmo::VisionSystem::TakeSnapshotHelper(const Anki::Embedded::Array<unsigned char>&)
;;;1720         
;;;1721         static Result TakeSnapshotHelper(const Embedded::Array<u8>& grayscaleImage)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1722         {
;;;1723           if(isWaitingOnSnapshot_) {
000004  4c32              LDR      r4,|L12.208|
000006  4605              MOV      r5,r0                 ;1722
000008  7b20              LDRB     r0,[r4,#0xc]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754720isWaitingOnSnapshot_E
00000a  2800              CMP      r0,#0
00000c  d05d              BEQ      |L12.202|
;;;1724             
;;;1725             const s32 nrowsFull = grayscaleImage.get_size(0);
00000e  2100              MOVS     r1,#0
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000016  4607              MOV      r7,r0
;;;1726             const s32 ncolsFull = grayscaleImage.get_size(1);
000018  2101              MOVS     r1,#1
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
;;;1727             
;;;1728             if(snapshotROI_.top    < 0 || snapshotROI_.top    >= nrowsFull-1 ||
000020  4e2c              LDR      r6,|L12.212|
000022  4602              MOV      r2,r0                 ;1726
000024  68b1              LDR      r1,[r6,#8]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712snapshotROI_E
000026  2900              CMP      r1,#0
000028  bfa4              ITT      GE
00002a  1e78              SUBGE    r0,r7,#1
00002c  4288              CMPGE    r0,r1
00002e  dd0f              BLE      |L12.80|
;;;1729                snapshotROI_.bottom < 0 || snapshotROI_.bottom >= nrowsFull-1 ||
000030  68f1              LDR      r1,[r6,#0xc]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712snapshotROI_E
000032  2900              CMP      r1,#0
000034  bfa8              IT       GE
000036  4288              CMPGE    r0,r1
000038  dd0a              BLE      |L12.80|
;;;1730                snapshotROI_.left   < 0 || snapshotROI_.left   >= ncolsFull-1 ||
00003a  6830              LDR      r0,[r6,#0]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712snapshotROI_E
00003c  2800              CMP      r0,#0
00003e  bfa4              ITT      GE
000040  1e51              SUBGE    r1,r2,#1
000042  4281              CMPGE    r1,r0
000044  dd04              BLE      |L12.80|
;;;1731                snapshotROI_.right  < 0 || snapshotROI_.right  >= ncolsFull-1)
000046  6870              LDR      r0,[r6,#4]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712snapshotROI_E
000048  2800              CMP      r0,#0
00004a  bfa8              IT       GE
00004c  4281              CMPGE    r1,r0
00004e  dc06              BGT      |L12.94|
                  |L12.80|
;;;1732             {
;;;1733               PRINT("VisionSystem::TakeSnapshotHelper(): Snapshot ROI out of bounds!\n");
000050  4821              LDR      r0,|L12.216|
000052  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;1734               return RESULT_FAIL_INVALID_SIZE;
000056  f04f60a0          MOV      r0,#0x5000000
;;;1735             }
;;;1736             
;;;1737             const s32 nrowsSnap = snapshot_->get_size(0);
;;;1738             const s32 ncolsSnap = snapshot_->get_size(1);
;;;1739             
;;;1740             for(s32 iFull=snapshotROI_.top, iSnap=0;
;;;1741                 iFull<snapshotROI_.bottom && iSnap<nrowsSnap;
;;;1742                 iFull+= snapshotSubsample_, ++iSnap)
;;;1743             {
;;;1744               const u8 * restrict pImageRow = grayscaleImage.Pointer(iFull,0);
;;;1745               u8 * restrict pSnapRow = snapshot_->Pointer(iSnap, 0);
;;;1746               
;;;1747               for(s32 jFull=snapshotROI_.left, jSnap=0;
;;;1748                   jFull<snapshotROI_.right && jSnap<ncolsSnap;
;;;1749                   jFull+= snapshotSubsample_, ++jSnap)
;;;1750               {
;;;1751                 pSnapRow[jSnap] = pImageRow[jFull];
;;;1752               }
;;;1753             }
;;;1754               
;;;1755             isWaitingOnSnapshot_ = false;
;;;1756             *isSnapshotReady_ = true;
;;;1757             
;;;1758           } // if isWaitingOnSnapshot_
;;;1759           
;;;1760           return RESULT_OK;
;;;1761           
;;;1762         } // TakeSnapshotHelper()
00005a  e8bd9ff0          POP      {r4-r12,pc}
                  |L12.94|
00005e  2100              MOVS     r1,#0                 ;1737
000060  6ca0              LDR      r0,[r4,#0x48]         ;1737  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff75479snapshot_E
000062  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000066  4607              MOV      r7,r0                 ;1737
000068  2101              MOVS     r1,#1                 ;1738
00006a  6ca0              LDR      r0,[r4,#0x48]         ;1738  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff75479snapshot_E
00006c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000070  46a6              MOV      lr,r4                 ;1723
000072  4682              MOV      r10,r0                ;1738
000074  e9de8b11          LDRD     r8,r11,[lr,#0x44]     ;1723
000078  2300              MOVS     r3,#0                 ;1740
00007a  f8d6c008          LDR      r12,[r6,#8]           ;1740  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712snapshotROI_E
00007e  e018              B        |L12.178|
                  |L12.128|
000080  68a9              LDR      r1,[r5,#8]            ;1740
000082  6928              LDR      r0,[r5,#0x10]         ;1740
000084  6832              LDR      r2,[r6,#0]            ;1747  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712snapshotROI_E
000086  fb0c0901          MLA      r9,r12,r1,r0          ;1747
00008a  f8db1008          LDR      r1,[r11,#8]           ;1747
00008e  f8db0010          LDR      r0,[r11,#0x10]        ;1747
000092  fb030401          MLA      r4,r3,r1,r0           ;1747
000096  2100              MOVS     r1,#0                 ;1747
000098  e004              B        |L12.164|
                  |L12.154|
00009a  f8190002          LDRB     r0,[r9,r2]            ;1751
00009e  5460              STRB     r0,[r4,r1]            ;1751
0000a0  4442              ADD      r2,r2,r8              ;1749
0000a2  1c49              ADDS     r1,r1,#1              ;1749
                  |L12.164|
0000a4  6870              LDR      r0,[r6,#4]            ;1748  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712snapshotROI_E
0000a6  4290              CMP      r0,r2                 ;1748
0000a8  bfc8              IT       GT                    ;1748
0000aa  458a              CMPGT    r10,r1                ;1748
0000ac  dcf5              BGT      |L12.154|
0000ae  44c4              ADD      r12,r12,r8            ;1742
0000b0  1c5b              ADDS     r3,r3,#1              ;1742
                  |L12.178|
0000b2  68f0              LDR      r0,[r6,#0xc]          ;1741  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712snapshotROI_E
0000b4  4560              CMP      r0,r12                ;1741
0000b6  bfc8              IT       GT                    ;1741
0000b8  429f              CMPGT    r7,r3                 ;1741
0000ba  dce1              BGT      |L12.128|
0000bc  2000              MOVS     r0,#0                 ;1755
0000be  f88e000c          STRB     r0,[lr,#0xc]          ;1755
0000c2  f8de1040          LDR      r1,[lr,#0x40]         ;1756  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754716isSnapshotReady_E
0000c6  2001              MOVS     r0,#1                 ;1756
0000c8  7008              STRB     r0,[r1,#0]            ;1756
                  |L12.202|
0000ca  2000              MOVS     r0,#0                 ;1760
0000cc  e8bd9ff0          POP      {r4-r12,pc}
;;;1763   
                          ENDP

                  |L12.208|
                          DCD      ||.data||
                  |L12.212|
                          DCD      ||.bss||+0x418
                  |L12.216|
                          DCD      ||.constdata||+0x3410

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem19GetVisionMarkerPoseERKNS_8Embedded12VisionMarkerEbRNS2_5ArrayIfEERNS2_6Point3IfEE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem19GetVisionMarkerPoseERKNS_8Embedded12VisionMarkerEbRNS2_5ArrayIfEERNS2_6Point3IfEE PROC ; Anki::Cozmo::VisionSystem::GetVisionMarkerPose(const Anki::Embedded::VisionMarker&, bool, Anki::Embedded::Array<float>&, Anki::Embedded::Point3<float>&)
;;;1652   
;;;1653         Result GetVisionMarkerPose(const Embedded::VisionMarker& marker,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1654           const bool ignoreOrientation,
;;;1655           Embedded::Array<f32>&  rotation,
;;;1656           Embedded::Point3<f32>& translation)
;;;1657         {
000004  b094              SUB      sp,sp,#0x50
000006  461e              MOV      r6,r3
000008  4617              MOV      r7,r2
00000a  460c              MOV      r4,r1
00000c  4680              MOV      r8,r0
;;;1658           Quadrilateral<f32> sortedQuad;
00000e  a804              ADD      r0,sp,#0x10
000010  2304              MOVS     r3,#4
000012  2208              MOVS     r2,#8
000014  492d              LDR      r1,|L13.204|
000016  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
00001a  ed9f0a2d          VLDR     s0,|L13.208|
00001e  f04f0c00          MOV      r12,#0
                  |L13.34|
000022  ed8d0a00          VSTR     s0,[sp,#0]
000026  ed8d0a01          VSTR     s0,[sp,#4]
00002a  eb0002cc          ADD      r2,r0,r12,LSL #3
00002e  eddd0a00          VLDR     s1,[sp,#0]
000032  f10c0c01          ADD      r12,r12,#1
000036  edc20a00          VSTR     s1,[r2,#0]
00003a  eddd0a01          VLDR     s1,[sp,#4]
00003e  f1bc0f04          CMP      r12,#4
000042  edc20a01          VSTR     s1,[r2,#4]
000046  dbec              BLT      |L13.34|
;;;1659           if(ignoreOrientation) {
000048  2c00              CMP      r4,#0
;;;1660             sortedQuad = marker.corners.ComputeClockwiseCorners<f32>();
;;;1661           } else {
;;;1662             sortedQuad = marker.corners;
00004a  bf04              ITT      EQ
00004c  a804              ADDEQ    r0,sp,#0x10
00004e  f04f0c00          MOVEQ    r12,#0
000052  d016              BEQ      |L13.130|
000054  ac04              ADD      r4,sp,#0x10           ;1660
000056  4641              MOV      r1,r8                 ;1660
000058  a80c              ADD      r0,sp,#0x30           ;1660
00005a  f7fffffe          BL       _ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv ; Anki::Embedded::Quadrilateral<float>::ComputeClockwiseCorners<float>() const
00005e  ab0c              ADD      r3,sp,#0x30           ;1660
000060  2000              MOVS     r0,#0                 ;1660
                  |L13.98|
000062  eb0301c0          ADD      r1,r3,r0,LSL #3       ;1660
000066  eb0402c0          ADD      r2,r4,r0,LSL #3       ;1660
00006a  ed910a00          VLDR     s0,[r1,#0]            ;1660
00006e  1c40              ADDS     r0,r0,#1              ;1660
000070  ed820a00          VSTR     s0,[r2,#0]            ;1660
000074  ed910a01          VLDR     s0,[r1,#4]            ;1660
000078  2804              CMP      r0,#4                 ;1660
00007a  ed820a01          VSTR     s0,[r2,#4]            ;1660
00007e  dbf0              BLT      |L13.98|
000080  e010              B        |L13.164|
                  |L13.130|
000082  eb0804cc          ADD      r4,r8,r12,LSL #3      ;1660
000086  eb0005cc          ADD      r5,r0,r12,LSL #3      ;1660
00008a  ed940a00          VLDR     s0,[r4,#0]            ;1660
00008e  f10c0c01          ADD      r12,r12,#1            ;1660
000092  ed850a00          VSTR     s0,[r5,#0]            ;1660
000096  ed940a01          VLDR     s0,[r4,#4]            ;1660
00009a  f1bc0f04          CMP      r12,#4                ;1660
00009e  ed850a01          VSTR     s0,[r5,#4]            ;1660
0000a2  dbee              BLT      |L13.130|
                  |L13.164|
;;;1663           }
;;;1664   
;;;1665           return P3P::computePose(sortedQuad,
0000a4  480b              LDR      r0,|L13.212|
0000a6  e9cd0700          STRD     r0,r7,[sp,#0]
0000aa  480b              LDR      r0,|L13.216|
0000ac  9602              STR      r6,[sp,#8]
0000ae  6a80              LDR      r0,[r0,#0x28]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712headCamInfo_E
0000b0  ec900a04          VLDM     r0,{s0-s3}
0000b4  4809              LDR      r0,|L13.220|
0000b6  f1000318          ADD      r3,r0,#0x18
0000ba  f100020c          ADD      r2,r0,#0xc
0000be  4601              MOV      r1,r0
0000c0  a804              ADD      r0,sp,#0x10
0000c2  f7fffffe          BL       _ZN4Anki8Embedded3P3P11computePoseIfEENS_6ResultERKNS0_13QuadrilateralIT_EERKNS0_6Point3IS5_EESC_SC_SC_ffffRNS0_5ArrayIS5_EERSA_ ; Anki::Embedded::P3P::computePose<float>(const Anki::Embedded::Quadrilateral<T1>&, const Anki::Embedded::Point3<T1>&, const Anki::Embedded::Point3<T1>&, const Anki::Embedded::Point3<T1>&, const Anki::Embedded::Point3<T1>&, float, float, float, float, Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)
;;;1666             canonicalMarker3d_[0], canonicalMarker3d_[1],
;;;1667             canonicalMarker3d_[2], canonicalMarker3d_[3],
;;;1668             headCamInfo_->focalLength_x, headCamInfo_->focalLength_y,
;;;1669             headCamInfo_->center_x, headCamInfo_->center_y,
;;;1670             rotation, translation);
;;;1671         } // GetVisionMarkerPose()
0000c6  b014              ADD      sp,sp,#0x50
0000c8  e8bd81f0          POP      {r4-r8,pc}
;;;1672         
                          ENDP

                  |L13.204|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()
                  |L13.208|
0000d0  00000000          DCFS     0x00000000 ; 0
                  |L13.212|
                          DCD      ||.bss||+0x2c8
                  |L13.216|
                          DCD      ||.data||
                  |L13.220|
                          DCD      ||.bss||+0x2a4

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem19StartDetectingFacesEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem19StartDetectingFacesEv PROC ; Anki::Cozmo::VisionSystem::StartDetectingFaces()
;;;1498         
;;;1499         Result StartDetectingFaces()
000000  4902              LDR      r1,|L14.12|
;;;1500         {
;;;1501           mode_ = VISION_MODE_DETECTING_FACES;
000002  2003              MOVS     r0,#3
000004  7208              STRB     r0,[r1,#8]
;;;1502           return RESULT_OK;
000006  2000              MOVS     r0,#0
;;;1503         }
000008  4770              BX       lr
;;;1504   
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem20GetCameraCalibrationEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem20GetCameraCalibrationEv PROC ; Anki::Cozmo::VisionSystem::GetCameraCalibration()
;;;1367   
;;;1368         const HAL::CameraInfo* GetCameraCalibration() {
000000  4801              LDR      r0,|L15.8|
;;;1369           // TODO: is just returning the pointer to HAL's camera info struct kosher?
;;;1370           return headCamInfo_;
000002  6a80              LDR      r0,[r0,#0x28]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712headCamInfo_E
;;;1371         }
000004  4770              BX       lr
;;;1372   
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      ||.data||

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem21GetObservedMarkerListEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem21GetObservedMarkerListEv PROC ; Anki::Cozmo::VisionSystem::GetObservedMarkerList()
;;;1504   
;;;1505         const Embedded::FixedLengthList<Embedded::VisionMarker>& GetObservedMarkerList()
000000  4800              LDR      r0,|L16.4|
;;;1506         {
;;;1507           return VisionMemory::markers_;
;;;1508         } // GetObservedMarkerList()
000002  4770              BX       lr
;;;1509   
                          ENDP

                  |L16.4|
                          DCD      ||.bss||+0x54

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded5ArrayIfEERKNS2_6Point3IfEERS4_RS8_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded5ArrayIfEERKNS2_6Point3IfEERS4_RS8_ PROC ; Anki::Cozmo::VisionSystem::GetWithRespectToRobot(const Anki::Embedded::Array<float>&, const Anki::Embedded::Point3<float>&, Anki::Embedded::Array<float>&, Anki::Embedded::Point3<float>&)
;;;1631   
;;;1632         Result GetWithRespectToRobot(const Embedded::Array<f32>&  rotationWrtCamera,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1633           const Embedded::Point3<f32>& translationWrtCamera,
;;;1634           Embedded::Array<f32>&        rotationWrtRobot,
;;;1635           Embedded::Point3<f32>&       translationWrtRobot)
;;;1636         {
000002  b08b              SUB      sp,sp,#0x2c
000004  ed9f0a23          VLDR     s0,|L17.148|
000008  460e              MOV      r6,r1
00000a  ed8d0a05          VSTR     s0,[sp,#0x14]
00000e  4605              MOV      r5,r0
000010  ed8d0a06          VSTR     s0,[sp,#0x18]
000014  461c              MOV      r4,r3
000016  4617              MOV      r7,r2
000018  ed8d0a07          VSTR     s0,[sp,#0x1c]
;;;1637           Point3<f32> TcamWrtRobot;
;;;1638   
;;;1639           Result lastResult;
;;;1640           if((lastResult = GetCamPoseWrtRobot(RcamWrtRobot_, TcamWrtRobot)) != RESULT_OK) {
00001c  a905              ADD      r1,sp,#0x14
00001e  481e              LDR      r0,|L17.152|
000020  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)
000024  2800              CMP      r0,#0
;;;1641             return lastResult;
;;;1642           }
;;;1643   
;;;1644           if((lastResult = Matrix::Multiply(RcamWrtRobot_, rotationWrtCamera, rotationWrtRobot)) != RESULT_OK) {
;;;1645             return lastResult;
;;;1646           }
;;;1647   
;;;1648           translationWrtRobot = RcamWrtRobot_*translationWrtCamera + TcamWrtRobot;
;;;1649   
;;;1650           return RESULT_OK;
;;;1651         }
000026  bf1c              ITT      NE
000028  b00b              ADDNE    sp,sp,#0x2c
00002a  bdf0              POPNE    {r4-r7,pc}
00002c  463a              MOV      r2,r7                 ;1644
00002e  4629              MOV      r1,r5                 ;1644
000030  4819              LDR      r0,|L17.152|
000032  f7fffffe          BL       _ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
000036  2800              CMP      r0,#0                 ;1644
000038  bf1c              ITT      NE
00003a  b00b              ADDNE    sp,sp,#0x2c
00003c  bdf0              POPNE    {r4-r7,pc}
00003e  ad08              ADD      r5,sp,#0x20           ;1648
000040  4632              MOV      r2,r6                 ;1648
000042  4915              LDR      r1,|L17.152|
000044  4668              MOV      r0,sp                 ;1648
000046  f7fffffe          BL       _ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_ ; Anki::Embedded::operator *<float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Point3<T1>&)
00004a  ed9d0a02          VLDR     s0,[sp,#8]            ;1648
00004e  eddd0a07          VLDR     s1,[sp,#0x1c]         ;1648
000052  eddd1a05          VLDR     s3,[sp,#0x14]         ;1648
000056  4628              MOV      r0,r5                 ;1648
000058  ee301a20          VADD.F32 s2,s0,s1              ;1648
00005c  ed9d0a01          VLDR     s0,[sp,#4]            ;1648
000060  eddd0a06          VLDR     s1,[sp,#0x18]         ;1648
000064  ee700a20          VADD.F32 s1,s0,s1              ;1648
000068  ed9d0a00          VLDR     s0,[sp,#0]            ;1648
00006c  ee300a21          VADD.F32 s0,s0,s3              ;1648
000070  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
000074  ed9d0a08          VLDR     s0,[sp,#0x20]         ;1648
000078  2000              MOVS     r0,#0                 ;1650
00007a  ed840a00          VSTR     s0,[r4,#0]            ;1650
00007e  ed9d0a09          VLDR     s0,[sp,#0x24]         ;1650
000082  ed840a01          VSTR     s0,[r4,#4]            ;1650
000086  ed9d0a0a          VLDR     s0,[sp,#0x28]         ;1650
00008a  ed840a02          VSTR     s0,[r4,#8]            ;1650
00008e  b00b              ADD      sp,sp,#0x2c
000090  bdf0              POP      {r4-r7,pc}
;;;1652   
                          ENDP

000092  0000              DCW      0x0000
                  |L17.148|
000094  00000000          DCFS     0x00000000 ; 0
                  |L17.152|
                          DCD      ||.bss||+0x88

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded6Point3IfEERS4_||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded6Point3IfEERS4_ PROC ; Anki::Cozmo::VisionSystem::GetWithRespectToRobot(const Anki::Embedded::Point3<float>&, Anki::Embedded::Point3<float>&)
;;;1616   
;;;1617         Result GetWithRespectToRobot(const Embedded::Point3<f32>& pointWrtCamera,
000000  b570              PUSH     {r4-r6,lr}
;;;1618           Embedded::Point3<f32>&       pointWrtRobot)
;;;1619         {
000002  b08c              SUB      sp,sp,#0x30
000004  ed9f0a1d          VLDR     s0,|L18.124|
000008  460c              MOV      r4,r1
00000a  ed8d0a05          VSTR     s0,[sp,#0x14]
00000e  4606              MOV      r6,r0
000010  ed8d0a06          VSTR     s0,[sp,#0x18]
000014  ed8d0a07          VSTR     s0,[sp,#0x1c]
;;;1620           Point3<f32> TcamWrtRobot;
;;;1621   
;;;1622           Result lastResult;
;;;1623           if((lastResult = GetCamPoseWrtRobot(RcamWrtRobot_, TcamWrtRobot)) != RESULT_OK) {
000018  a905              ADD      r1,sp,#0x14
00001a  4819              LDR      r0,|L18.128|
00001c  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)
000020  2800              CMP      r0,#0
;;;1624             return lastResult;
;;;1625           }
;;;1626   
;;;1627           pointWrtRobot = RcamWrtRobot_*pointWrtCamera + TcamWrtRobot;
;;;1628   
;;;1629           return RESULT_OK;
;;;1630         }
000022  bf1c              ITT      NE
000024  b00c              ADDNE    sp,sp,#0x30
000026  bd70              POPNE    {r4-r6,pc}
000028  ad08              ADD      r5,sp,#0x20           ;1627
00002a  4632              MOV      r2,r6                 ;1627
00002c  4914              LDR      r1,|L18.128|
00002e  4668              MOV      r0,sp                 ;1627
000030  f7fffffe          BL       _ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_ ; Anki::Embedded::operator *<float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Point3<T1>&)
000034  ed9d0a02          VLDR     s0,[sp,#8]            ;1627
000038  eddd0a07          VLDR     s1,[sp,#0x1c]         ;1627
00003c  eddd1a05          VLDR     s3,[sp,#0x14]         ;1627
000040  4628              MOV      r0,r5                 ;1627
000042  ee301a20          VADD.F32 s2,s0,s1              ;1627
000046  ed9d0a01          VLDR     s0,[sp,#4]            ;1627
00004a  eddd0a06          VLDR     s1,[sp,#0x18]         ;1627
00004e  ee700a20          VADD.F32 s1,s0,s1              ;1627
000052  ed9d0a00          VLDR     s0,[sp,#0]            ;1627
000056  ee300a21          VADD.F32 s0,s0,s3              ;1627
00005a  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
00005e  ed9d0a08          VLDR     s0,[sp,#0x20]         ;1627
000062  2000              MOVS     r0,#0                 ;1629
000064  ed840a00          VSTR     s0,[r4,#0]            ;1629
000068  ed9d0a09          VLDR     s0,[sp,#0x24]         ;1629
00006c  ed840a01          VSTR     s0,[r4,#4]            ;1629
000070  ed9d0a0a          VLDR     s0,[sp,#0x28]         ;1629
000074  ed840a02          VSTR     s0,[r4,#8]            ;1629
000078  b00c              ADD      sp,sp,#0x30
00007a  bd70              POP      {r4-r6,pc}
;;;1631   
                          ENDP

                  |L18.124|
00007c  00000000          DCFS     0x00000000 ; 0
                  |L18.128|
                          DCD      ||.bss||+0x88

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem22DownsampleAndSendImageERKNS_8Embedded5ArrayIhEE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem22DownsampleAndSendImageERKNS_8Embedded5ArrayIhEE PROC ; Anki::Cozmo::VisionSystem::DownsampleAndSendImage(const Anki::Embedded::Array<unsigned char>&)
;;;415    
;;;416          void DownsampleAndSendImage(const Array<u8> &img)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;417          {
;;;418            // Only downsample if normal capture res is QVGA
;;;419            if (imageSendMode_ != ISM_OFF && captureResolution_ == Vision::CAMERA_RES_QVGA) {
000004  493c              LDR      r1,|L19.248|
000006  4683              MOV      r11,r0                ;417
000008  b097              SUB      sp,sp,#0x5c           ;417
00000a  7908              LDRB     r0,[r1,#4]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754714imageSendMode_E
00000c  2800              CMP      r0,#0                 ;417
;;;420              
;;;421              // Time to send frame?
;;;422              static u8 streamFrameCnt = 0;
;;;423              if (imageSendMode_ == ISM_STREAM && streamFrameCnt++ != IMG_STREAM_SKIP_FRAMES) {
;;;424                return;
;;;425              }
;;;426              streamFrameCnt = 0;
;;;427              
;;;428              
;;;429              static u8 imgID = 0;
;;;430    
;;;431              // Downsample and split into image chunk message
;;;432              const u32 xRes = CameraModeInfo[nextSendImageResolution_].width;
;;;433              const u32 yRes = CameraModeInfo[nextSendImageResolution_].height;
;;;434    
;;;435              const u32 xSkip = 320 / xRes;
;;;436              const u32 ySkip = 240 / yRes;
;;;437    
;;;438              const u32 numTotalBytes = xRes*yRes;
;;;439    
;;;440              Messages::ImageChunk m;
;;;441              m.resolution = nextSendImageResolution_;
;;;442              m.imageId = ++imgID;
;;;443              m.chunkId = 0;
;;;444              m.chunkSize = IMAGE_CHUNK_SIZE;
;;;445    
;;;446              u32 totalByteCnt = 0;
;;;447              u32 chunkByteCnt = 0;
;;;448    
;;;449              //PRINT("Downsample: from %d x %d  to  %d x %d\n", img.get_size(1), img.get_size(0), xRes, yRes);
;;;450    
;;;451              u32 dataY = 0;
;;;452              for (u32 y = 0; y < 240; y += ySkip, dataY++)
;;;453              {
;;;454                const u8* restrict rowPtr = img.Pointer(y, 0);
;;;455    
;;;456                u32 dataX = 0;
;;;457                for (u32 x = 0; x < 320; x += xSkip, dataX++)
;;;458                {
;;;459                  m.data[chunkByteCnt] = rowPtr[x];
;;;460                  ++chunkByteCnt;
;;;461                  ++totalByteCnt;
;;;462    
;;;463                  if (chunkByteCnt == IMAGE_CHUNK_SIZE) {
;;;464                    //PRINT("Sending image chunk %d\n", m.chunkId);
;;;465                    HAL::RadioSendMessage(GET_MESSAGE_ID(Messages::ImageChunk), &m);
;;;466                    ++m.chunkId;
;;;467                    chunkByteCnt = 0;
;;;468                  } else if (totalByteCnt == numTotalBytes) {
;;;469                    // This should be the last message!
;;;470                    //PRINT("Sending LAST image chunk %d\n", m.chunkId);
;;;471                    m.chunkSize = chunkByteCnt;
;;;472                    HAL::RadioSendMessage(GET_MESSAGE_ID(Messages::ImageChunk), &m);
;;;473                  }
;;;474                }
;;;475              }
;;;476    
;;;477              // Turn off image sending if sending single image only.
;;;478              if (imageSendMode_ == ISM_SINGLE_SHOT) {
;;;479                imageSendMode_ = ISM_OFF;
;;;480              }
;;;481            }
;;;482          }
00000e  bf04              ITT      EQ
000010  b017              ADDEQ    sp,sp,#0x5c
000012  e8bd8ff0          POPEQ    {r4-r11,pc}
000016  7aca              LDRB     r2,[r1,#0xb]          ;419  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718captureResolution_E
000018  2a01              CMP      r2,#1                 ;419
00001a  bf1c              ITT      NE
00001c  b017              ADDNE    sp,sp,#0x5c
00001e  e8bd8ff0          POPNE    {r4-r11,pc}
000022  2801              CMP      r0,#1                 ;423
000024  d107              BNE      |L19.54|
000026  7988              LDRB     r0,[r1,#6]            ;423  ; streamFrameCnt
000028  1c42              ADDS     r2,r0,#1              ;423
00002a  718a              STRB     r2,[r1,#6]            ;423
00002c  2802              CMP      r0,#2                 ;423
00002e  bf1c              ITT      NE
000030  b017              ADDNE    sp,sp,#0x5c
000032  e8bd8ff0          POPNE    {r4-r11,pc}
                  |L19.54|
000036  2400              MOVS     r4,#0                 ;426
000038  4b2f              LDR      r3,|L19.248|
00003a  4930              LDR      r1,|L19.252|
00003c  f44f7ca0          MOV      r12,#0x140            ;435
000040  719c              STRB     r4,[r3,#6]            ;426
000042  7958              LDRB     r0,[r3,#5]            ;432  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754724nextSendImageResolution_E
000044  eb000240          ADD      r2,r0,r0,LSL #1       ;432
000048  eb010282          ADD      r2,r1,r2,LSL #2       ;432
00004c  8851              LDRH     r1,[r2,#2]            ;432
00004e  8892              LDRH     r2,[r2,#4]            ;433
000050  fbbcfaf1          UDIV     r10,r12,r1            ;435
000054  f04f0cf0          MOV      r12,#0xf0             ;436
000058  fbbcfcf2          UDIV     r12,r12,r2            ;436
00005c  f8cdc054          STR      r12,[sp,#0x54]        ;441
000060  f88d0003          STRB     r0,[sp,#3]            ;441
000064  79d8              LDRB     r0,[r3,#7]            ;442  ; imgID
000066  fb01f902          MUL      r9,r1,r2              ;438
00006a  1c40              ADDS     r0,r0,#1              ;442
00006c  71d8              STRB     r0,[r3,#7]            ;442
00006e  f88d0000          STRB     r0,[sp,#0]            ;442
000072  2050              MOVS     r0,#0x50              ;444
000074  f88d4001          STRB     r4,[sp,#1]            ;443
000078  2600              MOVS     r6,#0                 ;446
00007a  f88d0002          STRB     r0,[sp,#2]            ;444
00007e  4634              MOV      r4,r6                 ;447
000080  4637              MOV      r7,r6                 ;452
                  |L19.130|
000082  f8db1008          LDR      r1,[r11,#8]           ;452
000086  f8db0010          LDR      r0,[r11,#0x10]        ;452
00008a  2500              MOVS     r5,#0                 ;457
00008c  fb070801          MLA      r8,r7,r1,r0           ;457
                  |L19.144|
000090  eb0d0004          ADD      r0,sp,r4              ;459
000094  f8181005          LDRB     r1,[r8,r5]            ;459
000098  1c64              ADDS     r4,r4,#1              ;460
00009a  1c76              ADDS     r6,r6,#1              ;461
00009c  7101              STRB     r1,[r0,#4]            ;459
00009e  2c50              CMP      r4,#0x50              ;463
0000a0  d01b              BEQ      |L19.218|
0000a2  454e              CMP      r6,r9                 ;468
0000a4  d108              BNE      |L19.184|
0000a6  f88d4002          STRB     r4,[sp,#2]            ;471
0000aa  f7fffffe          BL       _ZN4Anki5Cozmo3HAL12GetTimeStampEv ; Anki::Cozmo::HAL::GetTimeStamp()
0000ae  4602              MOV      r2,r0                 ;472
0000b0  4669              MOV      r1,sp                 ;472
0000b2  2029              MOVS     r0,#0x29              ;472
0000b4  f7fffffe          BL       _ZN4Anki5Cozmo3HAL16RadioSendMessageENS0_8Messages2IDEPKvj ; Anki::Cozmo::HAL::RadioSendMessage(Anki::Cozmo::Messages::ID, const void*, unsigned)
                  |L19.184|
0000b8  4455              ADD      r5,r5,r10             ;457
0000ba  f5b57fa0          CMP      r5,#0x140             ;457
0000be  d3e7              BCC      |L19.144|
0000c0  9815              LDR      r0,[sp,#0x54]         ;452
0000c2  4407              ADD      r7,r7,r0              ;452
0000c4  2ff0              CMP      r7,#0xf0              ;452
0000c6  d3dc              BCC      |L19.130|
0000c8  480b              LDR      r0,|L19.248|
0000ca  7901              LDRB     r1,[r0,#4]            ;478  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754714imageSendMode_E
0000cc  2902              CMP      r1,#2                 ;478
0000ce  bf04              ITT      EQ                    ;479
0000d0  2100              MOVEQ    r1,#0                 ;479
0000d2  7101              STRBEQ   r1,[r0,#4]            ;479
0000d4  b017              ADD      sp,sp,#0x5c
0000d6  e8bd8ff0          POP      {r4-r11,pc}
                  |L19.218|
0000da  f7fffffe          BL       _ZN4Anki5Cozmo3HAL12GetTimeStampEv ; Anki::Cozmo::HAL::GetTimeStamp()
0000de  4602              MOV      r2,r0                 ;465
0000e0  4669              MOV      r1,sp                 ;465
0000e2  2029              MOVS     r0,#0x29              ;465
0000e4  f7fffffe          BL       _ZN4Anki5Cozmo3HAL16RadioSendMessageENS0_8Messages2IDEPKvj ; Anki::Cozmo::HAL::RadioSendMessage(Anki::Cozmo::Messages::ID, const void*, unsigned)
0000e8  f89d0001          LDRB     r0,[sp,#1]            ;466
0000ec  1c40              ADDS     r0,r0,#1              ;466
0000ee  f88d0001          STRB     r0,[sp,#1]            ;466
0000f2  2400              MOVS     r4,#0                 ;467
0000f4  e7e0              B        |L19.184|
;;;483    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L19.248|
                          DCD      ||.data||
                  |L19.252|
                          DCD      ||.constdata||+0x2ce4

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem22GetFaceDetectionParamsEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem22GetFaceDetectionParamsEv PROC ; Anki::Cozmo::VisionSystem::GetFaceDetectionParams()
;;;1384   
;;;1385         const FaceDetectionParameters& GetFaceDetectionParams() {
000000  4800              LDR      r0,|L20.4|
;;;1386           return faceDetectionParameters_;
;;;1387         }
000002  4770              BX       lr
;;;1388         
                          ENDP

                  |L20.4|
                          DCD      ||.bss||+0x3e8

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem22GetTrackingMarkerWidthEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem22GetTrackingMarkerWidthEv PROC ; Anki::Cozmo::VisionSystem::GetTrackingMarkerWidth()
;;;1372   
;;;1373         f32 GetTrackingMarkerWidth() {
000000  4801              LDR      r0,|L21.8|
;;;1374           return markerToTrack_.width_mm;
000002  ed900a01          VLDR     s0,[r0,#4]
;;;1375         }
000006  4770              BX       lr
;;;1376   
                          ENDP

                  |L21.8|
                          DCD      ||.bss||+0x9c

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem23TrackerPredictionUpdateERKNS_8Embedded5ArrayIhEENS2_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem23TrackerPredictionUpdateERKNS_8Embedded5ArrayIhEENS2_11MemoryStackE PROC ; Anki::Cozmo::VisionSystem::TrackerPredictionUpdate(const Anki::Embedded::Array<unsigned char>&, Anki::Embedded::MemoryStack)
;;;1055         //
;;;1056         static Result TrackerPredictionUpdate(const Array<u8>& grayscaleImage, MemoryStack scratch)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1057         {
000004  4605              MOV      r5,r0
000006  ed2d8b08          VPUSH    {d8-d11}
00000a  b0cf              SUB      sp,sp,#0x13c
00000c  460f              MOV      r7,r1
;;;1058           Result result = RESULT_OK;
00000e  2600              MOVS     r6,#0
;;;1059   
;;;1060           const Quadrilateral<f32> currentQuad = GetTrackerQuad(scratch);
000010  ac26              ADD      r4,sp,#0x98
000012  a817              ADD      r0,sp,#0x5c
000014  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000018  4601              MOV      r1,r0
00001a  a843              ADD      r0,sp,#0x10c
00001c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000020  4680              MOV      r8,r0
000022  49ce              LDR      r1,|L22.860|
000024  a806              ADD      r0,sp,#0x18
000026  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker26LucasKanadeTracker_Generic18get_transformationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_Generic::get_transformation() const
00002a  4642              MOV      r2,r8
00002c  a906              ADD      r1,sp,#0x18
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3222get_transformedCornersENS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_transformedCorners(Anki::Embedded::MemoryStack) const
;;;1061   
;;;1062           MatlabVisualization::SendTrackerPrediction_Before(grayscaleImage, currentQuad);
000034  a926              ADD      r1,sp,#0x98
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       _ZN4Anki5Cozmo19MatlabVisualization28SendTrackerPrediction_BeforeERKNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEE ; Anki::Cozmo::MatlabVisualization::SendTrackerPrediction_Before(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&)
;;;1063   
;;;1064           // Ask VisionState how much we've moved since last call (in robot coordinates)
;;;1065           Radians theta_robot;
00003c  a83e              ADD      r0,sp,#0xf8
00003e  f7fffffe          BL       _ZN4Anki7RadiansC1Ev ; Anki::Radians::Radians()
000042  4cc7              LDR      r4,|L22.864|
;;;1066           f32 T_fwd_robot, T_hor_robot;
;;;1067   
;;;1068           GetPoseChange(T_fwd_robot, T_hor_robot, theta_robot);
000044  f10d08f8          ADD      r8,sp,#0xf8
000048  a80a              ADD      r0,sp,#0x28
00004a  ed940a05          VLDR     s0,[r4,#0x14]
00004e  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
000052  f1a40538          SUB      r5,r4,#0x38
000056  4681              MOV      r9,r0
000058  ed950a05          VLDR     s0,[r5,#0x14]
00005c  a808              ADD      r0,sp,#0x20
00005e  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
000062  4601              MOV      r1,r0
000064  464a              MOV      r2,r9
000066  a806              ADD      r0,sp,#0x18
000068  f7fffffe          BL       _ZN4AnkimiERKNS_7RadiansES2_ ; Anki::operator -(const Anki::Radians&, const Anki::Radians&)
00006c  a906              ADD      r1,sp,#0x18
00006e  4640              MOV      r0,r8
000070  f7fffffe          BL       _ZN4Anki7RadiansaSERKS0_ ; Anki::Radians::operator =(const Anki::Radians&)
000074  ed950a02          VLDR     s0,[r5,#8]
000078  edd40a02          VLDR     s1,[r4,#8]
00007c  ee309a60          VSUB.F32 s18,s0,s1
000080  ed950a03          VLDR     s0,[r5,#0xc]
000084  edd40a03          VLDR     s1,[r4,#0xc]
000088  ee708a60          VSUB.F32 s17,s0,s1
00008c  ed940a05          VLDR     s0,[r4,#0x14]
000090  eeb10a40          VNEG.F32 s0,s0
000094  f7fffffe          BL       __hardfp_cosf
000098  eeb08a40          VMOV.F32 s16,s0
00009c  ed940a05          VLDR     s0,[r4,#0x14]
0000a0  eeb10a40          VNEG.F32 s0,s0
0000a4  f7fffffe          BL       __hardfp_sinf
0000a8  eef00a40          VMOV.F32 s1,s0
0000ac  ee29ba08          VMUL.F32 s22,s18,s16
0000b0  ee69ba20          VMUL.F32 s23,s18,s1
;;;1069   
;;;1070   #if DOCKING_ALGORITHM == DOCKING_LUCAS_KANADE_SAMPLED_PLANAR6DOF
;;;1071   
;;;1072   #if USE_MATLAB_TRACKER
;;;1073           MatlabVisionProcessor::UpdateTracker(T_fwd_robot, T_hor_robot,
;;;1074             theta_robot, theta_head);
;;;1075   #else
;;;1076           Radians theta_head2 = GetCurrentHeadAngle();
0000b4  a84a              ADD      r0,sp,#0x128
0000b6  ed950a09          VLDR     s0,[r5,#0x24]
0000ba  ee08bae0          VMLS.F32 s22,s17,s1
0000be  ee48ba88          VMLA.F32 s23,s17,s16
0000c2  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
;;;1077           Radians theta_head1 = GetPreviousHeadAngle();
0000c6  a84c              ADD      r0,sp,#0x130
0000c8  ed940a09          VLDR     s0,[r4,#0x24]
0000cc  f7fffffe          BL       _ZN4Anki7RadiansC1Ef ; Anki::Radians::Radians(float)
0000d0  ed9d0a4c          VLDR     s0,[sp,#0x130]
;;;1078   
;;;1079           const f32 cH1 = cosf(theta_head1.ToFloat());
0000d4  f7fffffe          BL       __hardfp_cosf
0000d8  eef0aa40          VMOV.F32 s21,s0
0000dc  ed9d0a4c          VLDR     s0,[sp,#0x130]
;;;1080           const f32 sH1 = sinf(theta_head1.ToFloat());
0000e0  f7fffffe          BL       __hardfp_sinf
0000e4  eeb0aa40          VMOV.F32 s20,s0
0000e8  ed9d0a4a          VLDR     s0,[sp,#0x128]
;;;1081   
;;;1082           const f32 cH2 = cosf(theta_head2.ToFloat());
0000ec  f7fffffe          BL       __hardfp_cosf
0000f0  eef08a40          VMOV.F32 s17,s0
0000f4  ed9d0a4a          VLDR     s0,[sp,#0x128]
;;;1083           const f32 sH2 = sinf(theta_head2.ToFloat());
0000f8  f7fffffe          BL       __hardfp_sinf
0000fc  eeb08a40          VMOV.F32 s16,s0
000100  ed9d0a3e          VLDR     s0,[sp,#0xf8]
;;;1084   
;;;1085           const f32 cR = cosf(theta_robot.ToFloat());
000104  f7fffffe          BL       __hardfp_cosf
000108  eeb09a40          VMOV.F32 s18,s0
00010c  ed9d0a3e          VLDR     s0,[sp,#0xf8]
;;;1086           const f32 sR = sinf(theta_robot.ToFloat());
000110  f7fffffe          BL       __hardfp_sinf
;;;1087   
;;;1088           // NOTE: these "geometry" entries were computed symbolically with Sage
;;;1089           // In the derivation, it was assumed the head and neck positions' Y
;;;1090           // components are zero.
;;;1091           //
;;;1092           // From Sage:
;;;1093           // [cos(thetaR)                 sin(thetaH1)*sin(thetaR)       cos(thetaH1)*sin(thetaR)]
;;;1094           // [-sin(thetaH2)*sin(thetaR)   cos(thetaR)*sin(thetaH1)*sin(thetaH2) + cos(thetaH1)*cH2  cos(thetaH1)*cos(thetaR)*sin(thetaH2) - cos(thetaH2)*sin(thetaH1)]
;;;1095           // [-cos(thetaH2)*sin(thetaR)   cos(thetaH2)*cos(thetaR)*sin(thetaH1) - cos(thetaH1)*sin(thetaH2) cos(thetaH1)*cos(thetaH2)*cos(thetaR) + sin(thetaH1)*sin(thetaH2)]
;;;1096           //
;;;1097           // T_blockRelHead_new =
;;;1098           // [T_hor*cos(thetaR) + (Hx*cos(thetaH1) - Hz*sin(thetaH1) + Nx)*sin(thetaR) - T_fwd*sin(thetaR)]
;;;1099           // [(Hx*cos(thetaH1) - Hz*sin(thetaH1) + Nx)*cos(thetaR)*sin(thetaH2) - (Hz*cos(thetaH1) + Hx*sin(thetaH1) + Nz)*cos(thetaH2) + (Hz*cos(thetaH2) + Hx*sin(thetaH2) + Nz)*cos(thetaH2) - (Hx*cos(thetaH2) - Hz*sin(thetaH2) + Nx)*sin(thetaH2) - (T_fwd*cos(thetaR) + T_hor*sin(thetaR))*sin(thetaH2)]
;;;1100           // [(Hx*cos(thetaH1) - Hz*sin(thetaH1) + Nx)*cos(thetaH2)*cos(thetaR) - (Hx*cos(thetaH2) - Hz*sin(thetaH2) + Nx)*cos(thetaH2) - (T_fwd*cos(thetaR) + T_hor*sin(thetaR))*cos(thetaH2) + (Hz*cos(thetaH1) + Hx*sin(thetaH1) + Nz)*sin(thetaH2) - (Hz*cos(thetaH2) + Hx*sin(thetaH2) + Nz)*sin(thetaH2)]
;;;1101   
;;;1102           AnkiAssert(HEAD_CAM_POSITION[1] == 0.f && NECK_JOINT_POSITION[1] == 0.f);
;;;1103           Array<f32> R_geometry = Array<f32>(3,3,scratch);
000114  2300              MOVS     r3,#0
000116  eef09a40          VMOV.F32 s19,s0                ;1086
00011a  461a              MOV      r2,r3
00011c  2101              MOVS     r1,#1
00011e  a84e              ADD      r0,sp,#0x138
000120  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000124  6800              LDR      r0,[r0,#0]
000126  2203              MOVS     r2,#3
000128  9000              STR      r0,[sp,#0]
00012a  463b              MOV      r3,r7
00012c  4611              MOV      r1,r2
00012e  a801              ADD      r0,sp,#4
000130  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000134  9a03              LDR      r2,[sp,#0xc]
000136  9905              LDR      r1,[sp,#0x14]
;;;1104           R_geometry[0][0] = cR;     R_geometry[0][1] = sH1*sR;             R_geometry[0][2] = cH1*sR;
000138  2000              MOVS     r0,#0
00013a  fb001002          MLA      r0,r0,r2,r1
00013e  ee2a0a29          VMUL.F32 s0,s20,s19
000142  ed809a00          VSTR     s18,[r0,#0]
000146  9a03              LDR      r2,[sp,#0xc]
000148  9905              LDR      r1,[sp,#0x14]
00014a  2000              MOVS     r0,#0
00014c  fb001002          MLA      r0,r0,r2,r1
000150  ed800a01          VSTR     s0,[r0,#4]
000154  9a03              LDR      r2,[sp,#0xc]
000156  9905              LDR      r1,[sp,#0x14]
000158  2000              MOVS     r0,#0
00015a  fb001002          MLA      r0,r0,r2,r1
00015e  ee2a0aa9          VMUL.F32 s0,s21,s19
000162  ed800a02          VSTR     s0,[r0,#8]
000166  9a03              LDR      r2,[sp,#0xc]
000168  9905              LDR      r1,[sp,#0x14]
;;;1105           R_geometry[1][0] = -sH2*sR; R_geometry[1][1] = cR*sH1*sH2 + cH1*cH2;  R_geometry[1][2] = cH1*cR*sH2 - cH2*sH1;
00016a  2001              MOVS     r0,#1
00016c  fb001002          MLA      r0,r0,r2,r1
000170  ee280a69          VNMUL.F32 s0,s16,s19
000174  ed800a00          VSTR     s0,[r0,#0]
000178  ee290a0a          VMUL.F32 s0,s18,s20
00017c  9a03              LDR      r2,[sp,#0xc]
00017e  9905              LDR      r1,[sp,#0x14]
000180  2001              MOVS     r0,#1
000182  ee200a08          VMUL.F32 s0,s0,s16
000186  fb001002          MLA      r0,r0,r2,r1
00018a  ee0a0aa8          VMLA.F32 s0,s21,s17
00018e  ed800a01          VSTR     s0,[r0,#4]
000192  ee2a0a89          VMUL.F32 s0,s21,s18
000196  9a03              LDR      r2,[sp,#0xc]
000198  9905              LDR      r1,[sp,#0x14]
00019a  2001              MOVS     r0,#1
00019c  ee200a08          VMUL.F32 s0,s0,s16
0001a0  fb001002          MLA      r0,r0,r2,r1
0001a4  ee080aca          VMLS.F32 s0,s17,s20
0001a8  ed800a02          VSTR     s0,[r0,#8]
0001ac  9a03              LDR      r2,[sp,#0xc]
0001ae  9905              LDR      r1,[sp,#0x14]
;;;1106           R_geometry[2][0] = -cH2*sR; R_geometry[2][1] = cH2*cR*sH1 - cH1*sH2;  R_geometry[2][2] = cH1*cH2*cR + sH1*sH2;
0001b0  2002              MOVS     r0,#2
0001b2  fb001002          MLA      r0,r0,r2,r1
0001b6  ee280ae9          VNMUL.F32 s0,s17,s19
0001ba  ed800a00          VSTR     s0,[r0,#0]
0001be  ee280a89          VMUL.F32 s0,s17,s18
0001c2  9a03              LDR      r2,[sp,#0xc]
0001c4  9905              LDR      r1,[sp,#0x14]
0001c6  2002              MOVS     r0,#2
0001c8  ee200a0a          VMUL.F32 s0,s0,s20
0001cc  fb001002          MLA      r0,r0,r2,r1
0001d0  ee0a0ac8          VMLS.F32 s0,s21,s16
0001d4  ed800a01          VSTR     s0,[r0,#4]
0001d8  ee2a0aa8          VMUL.F32 s0,s21,s17
0001dc  9a03              LDR      r2,[sp,#0xc]
0001de  9905              LDR      r1,[sp,#0x14]
0001e0  2002              MOVS     r0,#2
0001e2  ee200a09          VMUL.F32 s0,s0,s18
0001e6  fb001002          MLA      r0,r0,r2,r1
0001ea  ee0a0a08          VMLA.F32 s0,s20,s16
0001ee  ed800a02          VSTR     s0,[r0,#8]
;;;1107   
;;;1108           const f32 term1 = (HEAD_CAM_POSITION[0]*cH1 - HEAD_CAM_POSITION[2]*sH1 + NECK_JOINT_POSITION[0]);
0001f2  eddf0a5c          VLDR     s1,|L22.868|
0001f6  eeb91a08          VMOV.F32 s2,#-6.00000000
0001fa  eefa2a0a          VMOV.F32 s5,#-13.00000000
0001fe  ee2a0aa0          VMUL.F32 s0,s21,s1
;;;1109           const f32 term2 = (HEAD_CAM_POSITION[2]*cH1 + HEAD_CAM_POSITION[0]*sH1 + NECK_JOINT_POSITION[2]);
000202  ee2a2a81          VMUL.F32 s4,s21,s2
000206  ee0a0a41          VMLS.F32 s0,s20,s2             ;1108
00020a  ee0a2a20          VMLA.F32 s4,s20,s1
00020e  ee300a22          VADD.F32 s0,s0,s5              ;1108
000212  eddf1a55          VLDR     s3,|L22.872|
;;;1110           const f32 term3 = (HEAD_CAM_POSITION[2]*cH2 + HEAD_CAM_POSITION[0]*sH2 + NECK_JOINT_POSITION[2]);
000216  ee283a81          VMUL.F32 s6,s17,s2
00021a  ee322a21          VADD.F32 s4,s4,s3              ;1109
00021e  ee083a20          VMLA.F32 s6,s16,s1
;;;1111           const f32 term4 = (HEAD_CAM_POSITION[0]*cH2 - HEAD_CAM_POSITION[2]*sH2 + NECK_JOINT_POSITION[0]);
000222  ee680aa0          VMUL.F32 s1,s17,s1
000226  ee731a21          VADD.F32 s3,s6,s3              ;1110
00022a  ee480a41          VMLS.F32 s1,s16,s2
;;;1112           const f32 term5 = (T_fwd_robot*cR + T_hor_robot*sR);
;;;1113   
;;;1114           Point3<f32> T_geometry(T_hor_robot*cR + term1*sR - T_fwd_robot*sR,
00022e  ee2b3a89          VMUL.F32 s6,s23,s18
;;;1115             term1*cR*sH2 - term2*cH2 + term3*cH2 - term4*sH2 - term5*sH2,
;;;1116             term1*cH2*cR - term4*cH2 - term5*cH2 + term2*sH2 - term3*sH2);
;;;1117   
;;;1118           Array<f32> R_blockRelHead = Array<f32>(3,3,scratch);
000232  2300              MOVS     r3,#0
000234  461a              MOV      r2,r3
000236  2101              MOVS     r1,#1
000238  ee003a29          VMLA.F32 s6,s0,s19             ;1114
00023c  ee301aa2          VADD.F32 s2,s1,s5              ;1111
000240  ee602a09          VMUL.F32 s5,s0,s18             ;1114
000244  ee200a28          VMUL.F32 s0,s0,s17             ;1114
000248  ee6b0a09          VMUL.F32 s1,s22,s18            ;1112
00024c  a84e              ADD      r0,sp,#0x138
00024e  ee622a88          VMUL.F32 s5,s5,s16             ;1114
000252  ee200a09          VMUL.F32 s0,s0,s18             ;1114
000256  ee4b0aa9          VMLA.F32 s1,s23,s19            ;1112
00025a  ee0b3a69          VMLS.F32 s6,s22,s19            ;1114
00025e  ee422a68          VMLS.F32 s5,s4,s17             ;1114
000262  ee010a68          VMLS.F32 s0,s2,s17             ;1114
000266  ed8d3a38          VSTR     s6,[sp,#0xe0]         ;1114
00026a  ee412aa8          VMLA.F32 s5,s3,s17             ;1114
00026e  ee000ae8          VMLS.F32 s0,s1,s17             ;1114
000272  ee412a48          VMLS.F32 s5,s2,s16             ;1114
000276  ee020a08          VMLA.F32 s0,s4,s16             ;1114
00027a  ee402ac8          VMLS.F32 s5,s1,s16             ;1114
00027e  ee010ac8          VMLS.F32 s0,s3,s16             ;1114
000282  edcd2a39          VSTR     s5,[sp,#0xe4]         ;1114
000286  ed8d0a3a          VSTR     s0,[sp,#0xe8]         ;1114
00028a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00028e  6800              LDR      r0,[r0,#0]
000290  2203              MOVS     r2,#3
000292  9000              STR      r0,[sp,#0]
000294  463b              MOV      r3,r7
000296  4611              MOV      r1,r2
000298  a82e              ADD      r0,sp,#0xb8
00029a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1119           tracker_.GetRotationMatrix(R_blockRelHead);
00029e  2200              MOVS     r2,#0
0002a0  a92e              ADD      r1,sp,#0xb8
0002a2  f5a47008          SUB      r0,r4,#0x220
0002a6  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof17GetRotationMatrixERNS0_5ArrayIfEEb ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetRotationMatrix(Anki::Embedded::Array<float>&, bool) const
;;;1120           const Point3<f32>& T_blockRelHead = tracker_.GetTranslation();
0002aa  f5a47008          SUB      r0,r4,#0x220
0002ae  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetTranslation() const
0002b2  4605              MOV      r5,r0
;;;1121   
;;;1122           Array<f32> R_blockRelHead_new = Array<f32>(3,3,scratch);
0002b4  2300              MOVS     r3,#0
0002b6  461a              MOV      r2,r3
0002b8  2101              MOVS     r1,#1
0002ba  a84e              ADD      r0,sp,#0x138
0002bc  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0002c0  6800              LDR      r0,[r0,#0]
0002c2  2203              MOVS     r2,#3
0002c4  9000              STR      r0,[sp,#0]
0002c6  463b              MOV      r3,r7
0002c8  4611              MOV      r1,r2
0002ca  a833              ADD      r0,sp,#0xcc
0002cc  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;1123           Matrix::Multiply(R_geometry, R_blockRelHead, R_blockRelHead_new);
0002d0  aa33              ADD      r2,sp,#0xcc
0002d2  a92e              ADD      r1,sp,#0xb8
0002d4  a801              ADD      r0,sp,#4
0002d6  f7fffffe          BL       _ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
;;;1124   
;;;1125           Point3<f32> T_blockRelHead_new = R_geometry*T_blockRelHead + T_geometry;
0002da  ac40              ADD      r4,sp,#0x100
0002dc  462a              MOV      r2,r5
0002de  a901              ADD      r1,sp,#4
0002e0  a83b              ADD      r0,sp,#0xec
0002e2  f7fffffe          BL       _ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_ ; Anki::Embedded::operator *<float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Point3<T1>&)
0002e6  ed9d0a3d          VLDR     s0,[sp,#0xf4]
0002ea  eddd0a3a          VLDR     s1,[sp,#0xe8]
0002ee  eddd1a38          VLDR     s3,[sp,#0xe0]
0002f2  4620              MOV      r0,r4
0002f4  ee301a20          VADD.F32 s2,s0,s1
0002f8  ed9d0a3c          VLDR     s0,[sp,#0xf0]
0002fc  eddd0a39          VLDR     s1,[sp,#0xe4]
000300  ee700a20          VADD.F32 s1,s0,s1
000304  ed9d0a3b          VLDR     s0,[sp,#0xec]
000308  ee300a21          VADD.F32 s0,s0,s3
00030c  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
;;;1126   
;;;1127           if(tracker_.UpdateRotationAndTranslation(R_blockRelHead_new,
000310  4639              MOV      r1,r7
000312  a817              ADD      r0,sp,#0x5c
000314  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000318  4603              MOV      r3,r0
00031a  aa40              ADD      r2,sp,#0x100
00031c  a933              ADD      r1,sp,#0xcc
00031e  480f              LDR      r0,|L22.860|
000320  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof28UpdateRotationAndTranslationERKNS0_5ArrayIfEERKNS0_6Point3IfEENS0_11MemoryStackE ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::UpdateRotationAndTranslation(const Anki::Embedded::Array<float>&, const Anki::Embedded::Point3<float>&, Anki::Embedded::MemoryStack)
;;;1128             T_blockRelHead_new,
;;;1129             scratch) == RESULT_OK)
;;;1130           {
;;;1131             result = RESULT_OK;
;;;1132           }
;;;1133   
;;;1134   #endif // #if USE_MATLAB_TRACKER
;;;1135   
;;;1136   #else
;;;1137           const Quadrilateral<f32> sortedQuad  = currentQuad.ComputeClockwiseCorners<f32>();
;;;1138   
;;;1139           f32 dx = sortedQuad[3].x - sortedQuad[0].x;
;;;1140           f32 dy = sortedQuad[3].y - sortedQuad[0].y;
;;;1141           const f32 observedVerticalSize_pix = sqrtf( dx*dx + dy*dy );
;;;1142   
;;;1143           // Compare observed vertical size to actual block marker size (projected
;;;1144           // to be orthogonal to optical axis, using head angle) to approximate the
;;;1145           // distance to the marker along the camera's optical axis
;;;1146           Radians theta_head = GetCurrentHeadAngle();
;;;1147           const f32 cosHeadAngle = cosf(theta_head.ToFloat());
;;;1148           const f32 sinHeadAngle = sinf(theta_head.ToFloat());
;;;1149           const f32 d = (trackingMarkerWidth_mm* cosHeadAngle *
;;;1150             headCamInfo_->focalLength_y /
;;;1151             observedVerticalSize_pix);
;;;1152   
;;;1153           // Convert to how much we've moved along (and orthogonal to) the camera's optical axis
;;;1154           const f32 T_fwd_cam =  T_fwd_robot*cosHeadAngle;
;;;1155           const f32 T_ver_cam = -T_fwd_robot*sinHeadAngle;
;;;1156   
;;;1157           // Predict approximate horizontal shift from two things:
;;;1158           // 1. The rotation of the robot
;;;1159           //    Compute pixel-per-degree of the camera and multiply by degrees rotated
;;;1160           // 2. Convert horizontal shift of the robot to pixel shift, using
;;;1161           //    focal length
;;;1162           f32 horizontalShift_pix = (static_cast<f32>(headCamInfo_->ncols/2) * theta_robot.ToFloat() /
;;;1163             headCamFOV_hor_) + (T_hor_robot*headCamInfo_->focalLength_x/d);
;;;1164   
;;;1165           // Predict approximate scale change by comparing the distance to the
;;;1166           // object before and after forward motion
;;;1167           const f32 scaleChange = d / (d - T_fwd_cam);
;;;1168   
;;;1169           // Predict approximate vertical shift in the camera plane by comparing
;;;1170           // vertical motion (orthogonal to camera's optical axis) to the focal
;;;1171           // length
;;;1172           const f32 verticalShift_pix = T_ver_cam * headCamInfo_->focalLength_y/d;
;;;1173   
;;;1174           PRINT("Adjusting transformation: %.3fpix H shift for %.3fdeg rotation, "
;;;1175             "%.3f scaling and %.3f V shift for %.3f translation forward (%.3f cam)\n",
;;;1176             horizontalShift_pix, theta_robot.getDegrees(), scaleChange,
;;;1177             verticalShift_pix, T_fwd_robot, T_fwd_cam);
;;;1178   
;;;1179           // Adjust the Transformation
;;;1180           // Note: UpdateTransformation is doing *inverse* composition (thus using the negatives)
;;;1181           if(tracker_.get_transformation().get_transformType() == Transformations::TRANSFORM_TRANSLATION) {
;;;1182             Array<f32> update(1,2,scratch);
;;;1183             update[0][0] = -horizontalShift_pix;
;;;1184             update[0][1] = -verticalShift_pix;
;;;1185   
;;;1186   #if USE_MATLAB_TRACKER
;;;1187             MatlabVisionProcessor::UpdateTracker(update);
;;;1188   #else
;;;1189             tracker_.UpdateTransformation(update, 1.f, scratch,
;;;1190               Transformations::TRANSFORM_TRANSLATION);
;;;1191   #endif
;;;1192           }
;;;1193           else {
;;;1194             // Inverse update we are composing is:
;;;1195             //
;;;1196             //                  [s 0 0]^(-1)     [0 0 h_shift]^(-1)
;;;1197             //   updateMatrix = [0 s 0]       *  [0 0 v_shift]
;;;1198             //                  [0 0 1]          [0 0    1   ]
;;;1199             //
;;;1200             //      [1/s  0  -h_shift/s]   [ update_0  update_1  update_2 ]
;;;1201             //   =  [ 0  1/2 -v_shift/s] = [ update_3  update_4  update_5 ]
;;;1202             //      [ 0   0      1     ]   [    0         0         1     ]
;;;1203             //
;;;1204             // Note: UpdateTransformation adds 1.0 to the diagonal scale terms
;;;1205             Array<f32> update(1,6,scratch);
;;;1206             update.Set(0.f);
;;;1207             update[0][0] = 1.f/scaleChange - 1.f;               // first row, first col
;;;1208             update[0][2] = -horizontalShift_pix/scaleChange;    // first row, last col
;;;1209             update[0][4] = 1.f/scaleChange - 1.f;               // second row, second col
;;;1210             update[0][5] = -verticalShift_pix/scaleChange;      // second row, last col
;;;1211   
;;;1212   #if USE_MATLAB_TRACKER
;;;1213             MatlabVisionProcessor::UpdateTracker(update);
;;;1214   #else
;;;1215             tracker_.UpdateTransformation(update, 1.f, scratch,
;;;1216               Transformations::TRANSFORM_AFFINE);
;;;1217   #endif
;;;1218           } // if(tracker transformation type == TRANSLATION...)
;;;1219   
;;;1220   #endif // if DOCKING_ALGORITHM == DOCKING_LUCAS_KANADE_SAMPLED_PLANAR6DOF
;;;1221   
;;;1222           MatlabVisualization::SendTrackerPrediction_After(GetTrackerQuad(scratch));
000324  ac1e              ADD      r4,sp,#0x78
000326  4639              MOV      r1,r7
000328  a817              ADD      r0,sp,#0x5c
00032a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00032e  4601              MOV      r1,r0
000330  a843              ADD      r0,sp,#0x10c
000332  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000336  4605              MOV      r5,r0
000338  4908              LDR      r1,|L22.860|
00033a  a806              ADD      r0,sp,#0x18
00033c  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker26LucasKanadeTracker_Generic18get_transformationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_Generic::get_transformation() const
000340  462a              MOV      r2,r5
000342  a906              ADD      r1,sp,#0x18
000344  4620              MOV      r0,r4
000346  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3222get_transformedCornersENS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_transformedCorners(Anki::Embedded::MemoryStack) const
00034a  a81e              ADD      r0,sp,#0x78
00034c  f7fffffe          BL       _ZN4Anki5Cozmo19MatlabVisualization27SendTrackerPrediction_AfterERKNS_8Embedded13QuadrilateralIfEE ; Anki::Cozmo::MatlabVisualization::SendTrackerPrediction_After(const Anki::Embedded::Quadrilateral<float>&)
;;;1223   
;;;1224           return result;
;;;1225         } // TrackerPredictionUpdate()
000350  b04f              ADD      sp,sp,#0x13c
000352  4630              MOV      r0,r6                 ;1224
000354  ecbd8b08          VPOP     {d8-d11}
000358  e8bd83f0          POP      {r4-r9,pc}
;;;1226   
                          ENDP

                  |L22.860|
                          DCD      ||.bss||+0xec
                  |L22.864|
                          DCD      ||.bss||+0x30c
                  |L22.868|
000364  4099999a          DCFS     0x4099999a ; 4.8000001907348633
                  |L22.872|
000368  423ecccd          DCFS     0x423ecccd ; 47.700000762939453

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem24BrightnessNormalizeImageERNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem24BrightnessNormalizeImageERNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEE PROC ; Anki::Cozmo::VisionSystem::BrightnessNormalizeImage(Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&)
;;;553          // Divide image by mean of whatever is inside the trackingQuad
;;;554          static Result BrightnessNormalizeImage(Array<u8>& image, const Quadrilateral<f32>& quad)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;555          {
000004  4604              MOV      r4,r0
000006  ed2d8b04          VPUSH    {d8-d9}
00000a  b0b5              SUB      sp,sp,#0xd4
;;;556            //Debug: image.Show("OriginalImage", false);
;;;557            
;;;558    #define USE_VARIANCE 0
;;;559            
;;;560            // Compute mean of data inside the bounding box of the tracking quad
;;;561            const Rectangle<s32> bbox = quad.ComputeBoundingRectangle<s32>();
00000c  a828              ADD      r0,sp,#0xa0
00000e  ed910a00          VLDR     s0,[r1,#0]
000012  edd10a01          VLDR     s1,[r1,#4]
000016  2201              MOVS     r2,#1
000018  eebd0ac0          VCVT.S32.F32 s0,s0
00001c  eefd0ae0          VCVT.S32.F32 s1,s1
000020  ed8d0a28          VSTR     s0,[sp,#0xa0]
000024  ed8d0a29          VSTR     s0,[sp,#0xa4]
000028  edcd0a2a          VSTR     s1,[sp,#0xa8]
00002c  edcd0a2b          VSTR     s1,[sp,#0xac]
                  |L23.48|
000030  eb0103c2          ADD      r3,r1,r2,LSL #3
000034  f8d0c000          LDR      r12,[r0,#0]
000038  ed930a00          VLDR     s0,[r3,#0]
00003c  eebd0ac0          VCVT.S32.F32 s0,s0
000040  ee105a10          VMOV     r5,s0
000044  45ac              CMP      r12,r5
000046  bfa8              IT       GE
000048  ee10ca10          VMOVGE   r12,s0
00004c  f8c0c000          STR      r12,[r0,#0]
000050  ed930a00          VLDR     s0,[r3,#0]
000054  f8d0c004          LDR      r12,[r0,#4]
000058  eebd0ac0          VCVT.S32.F32 s0,s0
00005c  ee105a10          VMOV     r5,s0
000060  45ac              CMP      r12,r5
000062  bfd8              IT       LE
000064  ee10ca10          VMOVLE   r12,s0
000068  f8c0c004          STR      r12,[r0,#4]
00006c  ed930a01          VLDR     s0,[r3,#4]
000070  f8d0c008          LDR      r12,[r0,#8]
000074  eebd0ac0          VCVT.S32.F32 s0,s0
000078  ee105a10          VMOV     r5,s0
00007c  45ac              CMP      r12,r5
00007e  bfa8              IT       GE
000080  ee10ca10          VMOVGE   r12,s0
000084  f8c0c008          STR      r12,[r0,#8]
000088  ed930a01          VLDR     s0,[r3,#4]
00008c  f8d0c00c          LDR      r12,[r0,#0xc]
000090  eebd0ac0          VCVT.S32.F32 s0,s0
000094  ee103a10          VMOV     r3,s0
000098  459c              CMP      r12,r3
00009a  bfd8              IT       LE
00009c  ee10ca10          VMOVLE   r12,s0
0000a0  1c52              ADDS     r2,r2,#1
0000a2  f8c0c00c          STR      r12,[r0,#0xc]
0000a6  2a04              CMP      r2,#4
0000a8  dbc2              BLT      |L23.48|
0000aa  e9dd022a          LDRD     r0,r2,[sp,#0xa8]
0000ae  e9dd5628          LDRD     r5,r6,[sp,#0xa0]
0000b2  2301              MOVS     r3,#1
0000b4  6821              LDR      r1,[r4,#0]
0000b6  2800              CMP      r0,#0
0000b8  bfb8              IT       LT
0000ba  4408              ADDLT    r0,r1
0000bc  2a00              CMP      r2,#0
0000be  bfb8              IT       LT
0000c0  440a              ADDLT    r2,r1
0000c2  e9cd032d          STRD     r0,r3,[sp,#0xb4]
0000c6  4619              MOV      r1,r3
0000c8  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
0000cc  902c              STR      r0,[sp,#0xb0]
0000ce  e9dd122d          LDRD     r1,r2,[sp,#0xb4]
0000d2  9231              STR      r2,[sp,#0xc4]
0000d4  e9cd012f          STRD     r0,r1,[sp,#0xbc]
0000d8  2101              MOVS     r1,#1
0000da  6860              LDR      r0,[r4,#4]
0000dc  4632              MOV      r2,r6
0000de  2d00              CMP      r5,#0
0000e0  bfb8              IT       LT
0000e2  4405              ADDLT    r5,r0
0000e4  2a00              CMP      r2,#0
0000e6  bfb8              IT       LT
0000e8  1832              ADDLT    r2,r6,r0
0000ea  e9cd512d          STRD     r5,r1,[sp,#0xb4]
0000ee  4628              MOV      r0,r5
0000f0  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
0000f4  902c              STR      r0,[sp,#0xb0]
0000f6  e9dd122d          LDRD     r1,r2,[sp,#0xb4]
0000fa  9234              STR      r2,[sp,#0xd0]
0000fc  e9cd0132          STRD     r0,r1,[sp,#0xc8]
000100  e8941007          LDM      r4,{r0-r2,r12}
000104  e9dd562f          LDRD     r5,r6,[sp,#0xbc]
000108  6923              LDR      r3,[r4,#0x10]
00010a  e9cd5600          STRD     r5,r6,[sp,#0]
00010e  9f31              LDR      r7,[sp,#0xc4]
000110  e9dd5632          LDRD     r5,r6,[sp,#0xc8]
000114  9702              STR      r7,[sp,#8]
000116  9f34              LDR      r7,[sp,#0xd0]
000118  9705              STR      r7,[sp,#0x14]
00011a  f10d0818          ADD      r8,sp,#0x18
00011e  930a              STR      r3,[sp,#0x28]
000120  e8a81007          STM      r8!,{r0-r2,r12}
000124  e9cd5603          STRD     r5,r6,[sp,#0xc]
000128  2800              CMP      r0,#0
00012a  bfc8              IT       GT
00012c  2900              CMPGT    r1,#0
00012e  f34080ed          BLE.W    |L23.780|
000132  fb00fc01          MUL      r12,r0,r1
000136  f1bc0f00          CMP      r12,#0
00013a  bf1c              ITT      NE
00013c  f04f0c00          MOVNE    r12,#0
000140  fb0c3c02          MLANE    r12,r12,r2,r3
000144  f00080e2          BEQ.W    |L23.780|
                  |L23.328|
000148  f8cdc02c          STR      r12,[sp,#0x2c]
00014c  2800              CMP      r0,#0
00014e  bfc8              IT       GT
000150  2900              CMPGT    r1,#0
000152  f34080de          BLE.W    |L23.786|
000156  4348              MULS     r0,r1,r0
000158  2800              CMP      r0,#0
00015a  bf1c              ITT      NE
00015c  2000              MOVNE    r0,#0
00015e  fb003002          MLANE    r0,r0,r2,r3
000162  f00080d6          BEQ.W    |L23.786|
                  |L23.358|
000166  900c              STR      r0,[sp,#0x30]
000168  e9dd0100          LDRD     r0,r1,[sp,#0]
00016c  462b              MOV      r3,r5
00016e  46b4              MOV      r12,r6
000170  463d              MOV      r5,r7
000172  e9dd6706          LDRD     r6,r7,[sp,#0x18]
000176  f10d0868          ADD      r8,sp,#0x68
00017a  9a02              LDR      r2,[sp,#8]
00017c  9721              STR      r7,[sp,#0x84]
00017e  e8a8100f          STM      r8!,{r0-r3,r12}
000182  e9cd561f          STRD     r5,r6,[sp,#0x7c]
000186  f10d0820          ADD      r8,sp,#0x20
;;;562            
;;;563            ConstArraySlice<u8> imageROI = image(bbox.top, bbox.bottom, bbox.left, bbox.right);
00018a  462e              MOV      r6,r5
00018c  e8b8100f          LDM      r8!,{r0-r3,r12}
000190  f10d0888          ADD      r8,sp,#0x88
;;;564            
;;;565    #if USE_VARIANCE
;;;566            // Playing with normalizing using std. deviation as well
;;;567            s32 mean, var;
;;;568            Matrix::MeanAndVar<u8, s32>(imageROI, mean, var);
;;;569            const f32 stddev = sqrt(static_cast<f32>(var));
;;;570            const f32 oneTwentyEightOverStdDev = 128.f / stddev;
;;;571            //PRINT("Initial mean/std = %d / %.2f\n", mean, sqrt(static_cast<f32>(var)));
;;;572    #else
;;;573            const u8 mean = Matrix::Mean<u8, u32>(imageROI);
000194  ad0d              ADD      r5,sp,#0x34
000196  e8a8100f          STM      r8!,{r0-r3,r12}
00019a  e9dd231c          LDRD     r2,r3,[sp,#0x70]      ;563
00019e  e9dd011a          LDRD     r0,r1,[sp,#0x68]      ;563
0001a2  e9dd7e20          LDRD     r7,lr,[sp,#0x80]      ;563
0001a6  e9ddab24          LDRD     r10,r11,[sp,#0x90]    ;563
0001aa  e9dd8922          LDRD     r8,r9,[sp,#0x88]      ;563
0001ae  f8cde004          STR      lr,[sp,#4]
0001b2  f8ddc078          LDR      r12,[sp,#0x78]        ;563
0001b6  f04f0e00          MOV      lr,#0
0001ba  f8cde000          STR      lr,[sp,#0]
0001be  f8dde004          LDR      lr,[sp,#4]
0001c2  f8cde050          STR      lr,[sp,#0x50]
0001c6  e885100f          STM      r5,{r0-r3,r12}
0001ca  e9cd6712          STRD     r6,r7,[sp,#0x48]
0001ce  a815              ADD      r0,sp,#0x54
0001d0  ae13              ADD      r6,sp,#0x4c
0001d2  e8a00f00          STM      r0!,{r8-r11}
0001d6  f8dde000          LDR      lr,[sp,#0]
0001da  f88de064          STRB     lr,[sp,#0x64]
0001de  4630              MOV      r0,r6
0001e0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
0001e4  2800              CMP      r0,#0
0001e6  d07c              BEQ      |L23.738|
0001e8  2001              MOVS     r0,#1
0001ea  f88d0008          STRB     r0,[sp,#8]
0001ee  9811              LDR      r0,[sp,#0x44]
0001f0  9003              STR      r0,[sp,#0xc]
0001f2  9812              LDR      r0,[sp,#0x48]
0001f4  9004              STR      r0,[sp,#0x10]
0001f6  9810              LDR      r0,[sp,#0x40]
0001f8  9005              STR      r0,[sp,#0x14]
0001fa  980e              LDR      r0,[sp,#0x38]
0001fc  9006              STR      r0,[sp,#0x18]
0001fe  980f              LDR      r0,[sp,#0x3c]
000200  9007              STR      r0,[sp,#0x1c]
000202  980d              LDR      r0,[sp,#0x34]
000204  2100              MOVS     r1,#0
000206  460a              MOV      r2,r1
000208  9008              STR      r0,[sp,#0x20]
00020a  2800              CMP      r0,#0
00020c  bfc4              ITT      GT
00020e  6937              LDRGT    r7,[r6,#0x10]
000210  68b6              LDRGT    r6,[r6,#8]
000212  dd18              BLE      |L23.582|
                  |L23.532|
000214  e9dd0306          LDRD     r0,r3,[sp,#0x18]
000218  fb020003          MLA      r0,r2,r3,r0
00021c  fb007c06          MLA      r12,r0,r6,r7
000220  9b05              LDR      r3,[sp,#0x14]
000222  2000              MOVS     r0,#0
000224  2b00              CMP      r3,#0
000226  dd0a              BLE      |L23.574|
                  |L23.552|
000228  e9dd3803          LDRD     r3,r8,[sp,#0xc]
00022c  fb003308          MLA      r3,r0,r8,r3
000230  1c40              ADDS     r0,r0,#1
000232  f81c3003          LDRB     r3,[r12,r3]
000236  4419              ADD      r1,r1,r3
000238  9b05              LDR      r3,[sp,#0x14]
00023a  4283              CMP      r3,r0
00023c  dcf4              BGT      |L23.552|
                  |L23.574|
00023e  9808              LDR      r0,[sp,#0x20]
000240  1c52              ADDS     r2,r2,#1
000242  4290              CMP      r0,r2
000244  dce6              BGT      |L23.532|
                  |L23.582|
000246  68ea              LDR      r2,[r5,#0xc]
000248  6828              LDR      r0,[r5,#0]
;;;574            //PRINT("Initial mean = %d\n", mean);
;;;575    #endif
;;;576            
;;;577            //PRINT("quad mean = %d\n", mean);
;;;578            //const f32 oneOverMean = 1.f / static_cast<f32>(mean);
;;;579            
;;;580            // Remove mean (and variance) from image
;;;581            for(s32 i=0; i<image.get_size(0); ++i)
00024a  2500              MOVS     r5,#0
00024c  4350              MULS     r0,r2,r0
00024e  fbb1f0f0          UDIV     r0,r1,r0
000252  b2c6              UXTB     r6,r0
000254  4629              MOV      r1,r5
000256  4620              MOV      r0,r4
000258  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00025c  2800              CMP      r0,#0
00025e  dd4f              BLE      |L23.768|
000260  4f34              LDR      r7,|L23.820|
;;;582            {
;;;583              u8 * restrict img_i = image.Pointer(i, 0);
;;;584              
;;;585              for(s32 j=0; j<image.get_size(1); ++j)
;;;586              {
;;;587                f32 value = static_cast<f32>(img_i[j]);
;;;588                value -= static_cast<f32>(mean);
;;;589    #if USE_VARIANCE
;;;590                value *= oneTwentyEightOverStdDev;
;;;591    #endif
;;;592                value += 128.f;
000262  ed9f8a33          VLDR     s16,|L23.816|
000266  ed9f9a34          VLDR     s18,|L23.824|
00026a  eddf9a34          VLDR     s19,|L23.828|
00026e  eef68a00          VMOV.F32 s17,#0.50000000
                  |L23.626|
000272  68a1              LDR      r1,[r4,#8]
000274  6920              LDR      r0,[r4,#0x10]
000276  fb050201          MLA      r2,r5,r1,r0
00027a  6861              LDR      r1,[r4,#4]            ;585
00027c  2000              MOVS     r0,#0                 ;585
00027e  2900              CMP      r1,#0                 ;585
000280  dd37              BLE      |L23.754|
                  |L23.642|
000282  5c11              LDRB     r1,[r2,r0]            ;587
000284  ee006a90          VMOV     s1,r6                 ;588
000288  ee001a10          VMOV     s0,r1                 ;587
00028c  eef80a60          VCVT.F32.U32 s1,s1                 ;588
000290  eeb80a40          VCVT.F32.U32 s0,s0                 ;587
000294  ee300a60          VSUB.F32 s0,s0,s1              ;588
000298  ee300a08          VADD.F32 s0,s0,s16
00029c  eeb50ac0          VCMPE.F32 s0,#0.0
0002a0  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002a4  bf34              ITE      CC
0002a6  eef00a69          VMOVCC.F32 s1,s19
0002aa  eef00a40          VMOVCS.F32 s1,s0
0002ae  ee101a90          VMOV     r1,s1
0002b2  42b9              CMP      r1,r7
0002b4  bfc8              IT       GT
0002b6  eeb00a49          VMOVGT.F32 s0,s18
0002ba  dc06              BGT      |L23.714|
0002bc  eeb50ac0          VCMPE.F32 s0,#0.0
0002c0  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002c4  bf38              IT       CC
0002c6  eeb00a69          VMOVCC.F32 s0,s19
                  |L23.714|
0002ca  eeb50ac0          VCMPE.F32 s0,#0.0
0002ce  eef1fa10          VMRS     APSR_nzcv,FPSCR
0002d2  bfcc              ITE      GT
0002d4  ee300a28          VADDGT.F32 s0,s0,s17
0002d8  ee300a68          VSUBLE.F32 s0,s0,s17
0002dc  eebd0ac0          VCVT.S32.F32 s0,s0
0002e0  e000              B        |L23.740|
                  |L23.738|
0002e2  e018              B        |L23.790|
                  |L23.740|
0002e4  ee101a10          VMOV     r1,s0
;;;593                img_i[j] = saturate_cast<u8>(value) ;
0002e8  5411              STRB     r1,[r2,r0]
0002ea  6861              LDR      r1,[r4,#4]            ;585
0002ec  1c40              ADDS     r0,r0,#1              ;585
0002ee  4281              CMP      r1,r0                 ;585
0002f0  dcc7              BGT      |L23.642|
                  |L23.754|
0002f2  1c6d              ADDS     r5,r5,#1              ;581
0002f4  2100              MOVS     r1,#0                 ;581
0002f6  4620              MOV      r0,r4                 ;581
0002f8  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
0002fc  42a8              CMP      r0,r5                 ;581
0002fe  dcb8              BGT      |L23.626|
                  |L23.768|
;;;594              }
;;;595            }
;;;596            
;;;597            // Debug:
;;;598            /*
;;;599    #if USE_VARIANCE
;;;600            Matrix::MeanAndVar<u8, s32>(imageROI, mean, var);
;;;601            PRINT("Final mean/std = %d / %.2f\n", mean, sqrt(static_cast<f32>(var)));
;;;602    #else 
;;;603            PRINT("Final mean = %d\n", Matrix::Mean<u8,u32>(imageROI));
;;;604    #endif
;;;605             */
;;;606            
;;;607            //Debug: image.Show("NormalizedImage", true);
;;;608            
;;;609    #undef USE_VARIANCE
;;;610            return RESULT_OK;
;;;611            
;;;612          } // BrightnessNormalizeImage()
000300  b035              ADD      sp,sp,#0xd4
000302  2000              MOVS     r0,#0                 ;610
000304  ecbd8b04          VPOP     {d8-d9}
000308  e8bd8ff0          POP      {r4-r11,pc}
                  |L23.780|
00030c  f04f0c00          MOV      r12,#0
000310  e71a              B        |L23.328|
                  |L23.786|
000312  2000              MOVS     r0,#0
000314  e727              B        |L23.358|
                  |L23.790|
000316  2168              MOVS     r1,#0x68
000318  4809              LDR      r0,|L23.832|
00031a  e9cd0100          STRD     r0,r1,[sp,#0]
00031e  a309              ADR      r3,|L23.836|
000320  a216              ADR      r2,|L23.892|
000322  a11d              ADR      r1,|L23.920|
000324  2005              MOVS     r0,#5
000326  f7fffffe          BL       _Anki_Log
00032a  2100              MOVS     r1,#0
00032c  e78b              B        |L23.582|
;;;613          
                          ENDP

00032e  0000              DCW      0x0000
                  |L23.816|
000330  43000000          DCFS     0x43000000 ; 128
                  |L23.820|
                          DCD      0x437f0000
                  |L23.824|
000338  437f0000          DCFS     0x437f0000 ; 255
                  |L23.828|
00033c  00000000          DCFS     0x00000000 ; 0
                  |L23.832|
                          DCD      _ZZN4Anki8Embedded6Matrix3SumIhjEET0_RKNS0_25ConstArraySliceExpressionIT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Sum<unsigned char, unsigned>(const Anki::Embedded::ConstArraySliceExpression<T1>&)::__PRETTY_FUNCTION__
                  |L23.836|
000344  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000348  6f726574
00034c  6563685c
000350  636f6d6d
000354  6f6e5c69
000358  6e636c75
00035c  64655c61
000360  6e6b692f
000364  636f6d6d
000368  6f6e2f72
00036c  6f626f74
000370  2f6d6174
000374  726978  
000377  2e6800            DCB      ".h",0
00037a  00                DCB      0
00037b  00                DCB      0
                  |L23.892|
00037c  41727261          DCB      "Array<Type> is not valid",0
000380  793c5479
000384  70653e20
000388  6973206e
00038c  6f742076
000390  616c6964
000394  00      
000395  00                DCB      0
000396  00                DCB      0
000397  00                DCB      0
                  |L23.920|
000398  4d617472          DCB      "Matrix::Sum",0
00039c  69783a3a
0003a0  53756d00

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem24BrightnessNormalizeImageERNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEEfNS2_11MemoryStackE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem24BrightnessNormalizeImageERNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEEfNS2_11MemoryStackE PROC ; Anki::Cozmo::VisionSystem::BrightnessNormalizeImage(Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, float, Anki::Embedded::MemoryStack)
;;;614          
;;;615          static Result BrightnessNormalizeImage(Array<u8>& image, const Quadrilateral<f32>& quad,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;616            const f32 filterWidthFraction,
;;;617            MemoryStack scratch)
;;;618          {
000004  4614              MOV      r4,r2
000006  ed2d8b02          VPUSH    {d8}
00000a  eeb08a40          VMOV.F32 s16,s0
00000e  b092              SUB      sp,sp,#0x48
;;;619            if(filterWidthFraction > 0.f) {
000010  eeb58ac0          VCMPE.F32 s16,#0.0
000014  4605              MOV      r5,r0                 ;618
000016  eef1fa10          VMRS     APSR_nzcv,FPSCR
00001a  dd57              BLE      |L24.204|
00001c  ed910a06          VLDR     s0,[r1,#0x18]         ;618
000020  edd10a00          VLDR     s1,[r1,#0]            ;618
000024  ed911a01          VLDR     s2,[r1,#4]            ;618
000028  ee700a60          VSUB.F32 s1,s0,s1              ;618
00002c  ed910a07          VLDR     s0,[r1,#0x1c]         ;618
000030  edcd0a08          VSTR     s1,[sp,#0x20]         ;618
000034  ee300a41          VSUB.F32 s0,s0,s2              ;618
000038  ee600aa0          VMUL.F32 s1,s1,s1              ;618
00003c  ed8d0a09          VSTR     s0,[sp,#0x24]         ;618
000040  ed9d0a09          VLDR     s0,[sp,#0x24]         ;618
000044  ee400a00          VMLA.F32 s1,s0,s0              ;618
000048  eeb10ae0          VSQRT.F32 s0,s1                 ;618
00004c  eeb40a40          VCMP.F32 s0,s0                 ;618
000050  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;618
000054  bf1c              ITT      NE                    ;618
000056  eeb00a60          VMOVNE.F32 s0,s1                 ;618
00005a  f7fffffe          BLNE     __hardfp_sqrtf
;;;620              //Debug:
;;;621              image.Show("OriginalImage", false);
;;;622              
;;;623              // TODO: Add the ability to only normalize within the vicinity of the quad
;;;624              // Note that this requires templateQuad to be sorted!
;;;625              const s32 filterWidth = static_cast<s32>(filterWidthFraction*((quad[3] - quad[0]).Length()));
00005e  ee200a08          VMUL.F32 s0,s0,s16
;;;626              AnkiAssert(filterWidth > 0.f);
;;;627    
;;;628              Array<u8> imageNormalized(image.get_size(0), image.get_size(1), scratch);
000062  2300              MOVS     r3,#0
000064  461a              MOV      r2,r3
000066  2101              MOVS     r1,#1
000068  eebd0ac0          VCVT.S32.F32 s0,s0                 ;625
00006c  a807              ADD      r0,sp,#0x1c
00006e  ee106a10          VMOV     r6,s0                 ;625
000072  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000076  4607              MOV      r7,r0
000078  2101              MOVS     r1,#1
00007a  4628              MOV      r0,r5
00007c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000080  4680              MOV      r8,r0
000082  2100              MOVS     r1,#0
000084  4628              MOV      r0,r5
000086  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00008a  6839              LDR      r1,[r7,#0]
00008c  9100              STR      r1,[sp,#0]
00008e  4601              MOV      r1,r0
000090  4623              MOV      r3,r4
000092  4642              MOV      r2,r8
000094  a802              ADD      r0,sp,#8
000096  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;629    
;;;630              AnkiConditionalErrorAndReturnValue(imageNormalized.IsValid(),
00009a  a802              ADD      r0,sp,#8
00009c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
0000a0  b1d0              CBZ      r0,|L24.216|
;;;631                RESULT_FAIL_OUT_OF_MEMORY,
;;;632                "VisionSystem::BrightnessNormalizeImage",
;;;633                "Out of memory allocating imageNormalized.\n");
;;;634    
;;;635              BeginBenchmark("BoxFilterNormalize");
0000a2  a014              ADR      r0,|L24.244|
0000a4  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
;;;636    
;;;637              ImageProcessing::BoxFilterNormalize(image, filterWidth, static_cast<u8>(128),
0000a8  4621              MOV      r1,r4
0000aa  a80a              ADD      r0,sp,#0x28
0000ac  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0000b0  9000              STR      r0,[sp,#0]
0000b2  ab02              ADD      r3,sp,#8
0000b4  2280              MOVS     r2,#0x80
0000b6  4631              MOV      r1,r6
0000b8  4628              MOV      r0,r5
0000ba  f7fffffe          BL       _ZN4Anki8Embedded15ImageProcessing18BoxFilterNormalizeERKNS0_5ArrayIhEEihRS3_NS0_11MemoryStackE ; Anki::Embedded::ImageProcessing::BoxFilterNormalize(const Anki::Embedded::Array<unsigned char>&, int, unsigned char, Anki::Embedded::Array<unsigned char>&, Anki::Embedded::MemoryStack)
;;;638                imageNormalized, scratch);
;;;639    
;;;640              EndBenchmark("BoxFilterNormalize");
0000be  a00d              ADR      r0,|L24.244|
0000c0  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
;;;641    
;;;642              { // DEBUG
;;;643                /*
;;;644                static Matlab matlab(false);
;;;645                matlab.PutArray(grayscaleImage, "grayscaleImage");
;;;646                matlab.PutArray(grayscaleImageNormalized, "grayscaleImageNormalized");
;;;647                matlab.EvalString("subplot(121), imagesc(grayscaleImage), axis image, colorbar, "
;;;648                "subplot(122), imagesc(grayscaleImageNormalized), colorbar, axis image, "
;;;649                "colormap(gray)");
;;;650                */
;;;651    
;;;652                //image.Show("GrayscaleImage", false);
;;;653                //imageNormalized.Show("GrayscaleImageNormalized", false);
;;;654              }
;;;655    
;;;656              image.Set(imageNormalized);
0000c4  a902              ADD      r1,sp,#8
0000c6  4628              MOV      r0,r5
0000c8  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhE3SetERKS2_ ; Anki::Embedded::Array<unsigned char>::Set(const Anki::Embedded::Array<unsigned char>&)
                  |L24.204|
;;;657              
;;;658              //Debug:
;;;659              image.Show("NormalizedImage", true);
;;;660              
;;;661            } // if(filterWidthFraction > 0)
;;;662    
;;;663            return RESULT_OK;
0000cc  2000              MOVS     r0,#0
                  |L24.206|
;;;664          } // BrightnessNormalizeImage()
0000ce  b012              ADD      sp,sp,#0x48
0000d0  ecbd8b02          VPOP     {d8}
0000d4  e8bd81f0          POP      {r4-r8,pc}
                  |L24.216|
0000d8  f2402176          MOV      r1,#0x276             ;630
0000dc  480a              LDR      r0,|L24.264|
0000de  e9cd0100          STRD     r0,r1,[sp,#0]         ;630
0000e2  a30a              ADR      r3,|L24.268|
0000e4  a211              ADR      r2,|L24.300|
0000e6  a11c              ADR      r1,|L24.344|
0000e8  2005              MOVS     r0,#5                 ;630
0000ea  f7fffffe          BL       _Anki_Log
0000ee  4824              LDR      r0,|L24.384|
0000f0  e7ed              B        |L24.206|
;;;665    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L24.244|
0000f4  426f7846          DCB      "BoxFilterNormalize",0
0000f8  696c7465
0000fc  724e6f72
000100  6d616c69
000104  7a6500  
000107  00                DCB      0
                  |L24.264|
                          DCD      ||.constdata||+0x2d6a
                  |L24.268|
00010c  73757065          DCB      "supervisor\\src\\visionSystem.cpp",0
000110  72766973
000114  6f725c73
000118  72635c76
00011c  6973696f
000120  6e537973
000124  74656d2e
000128  63707000
                  |L24.300|
00012c  4f757420          DCB      "Out of memory allocating imageNormalized.\n",0
000130  6f66206d
000134  656d6f72
000138  7920616c
00013c  6c6f6361
000140  74696e67
000144  20696d61
000148  67654e6f
00014c  726d616c
000150  697a6564
000154  2e0a00  
000157  00                DCB      0
                  |L24.344|
000158  56697369          DCB      "VisionSystem::BrightnessNormalizeImage",0
00015c  6f6e5379
000160  7374656d
000164  3a3a4272
000168  69676874
00016c  6e657373
000170  4e6f726d
000174  616c697a
000178  65496d61
00017c  676500  
00017f  00                DCB      0
                  |L24.384|
                          DCD      0x01000001

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem28GetVisionMarkerPoseNearestToERKNS_8Embedded6Point3IfEERKNS_6Vision10MarkerTypeEfRNS2_5ArrayIfEERS4_Rb||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem28GetVisionMarkerPoseNearestToERKNS_8Embedded6Point3IfEERKNS_6Vision10MarkerTypeEfRNS2_5ArrayIfEERS4_Rb PROC ; Anki::Cozmo::VisionSystem::GetVisionMarkerPoseNearestTo(const Anki::Embedded::Point3<float>&, const Anki::Vision::MarkerType&, float, Anki::Embedded::Array<float>&, Anki::Embedded::Point3<float>&, bool&)
;;;1509   
;;;1510         Result GetVisionMarkerPoseNearestTo(const Embedded::Point3<f32>&  atPosition,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1511           const Vision::MarkerType&     withType,
;;;1512           const f32                     maxDistance_mm,
;;;1513           Embedded::Array<f32>&         rotationWrtRobot,
;;;1514           Embedded::Point3<f32>&        translationWrtRobot,
;;;1515           bool&                         markerFound)
;;;1516         {
000004  49ca              LDR      r1,|L25.816|
;;;1517           using namespace Embedded;
;;;1518   
;;;1519           Result lastResult = RESULT_OK;
;;;1520           markerFound = false;
000006  f04f0a00          MOV      r10,#0
00000a  ed2d0b02          VPUSH    {d0}                  ;1516
00000e  4607              MOV      r7,r0                 ;1516
000010  461e              MOV      r6,r3                 ;1516
000012  ed2d8b02          VPUSH    {d8}                  ;1516
000016  b0cd              SUB      sp,sp,#0x134          ;1516
000018  eeb08a40          VMOV.F32 s16,s0                ;1516
00001c  f8dd8178          LDR      r8,[sp,#0x178]
000020  f888a000          STRB     r10,[r8,#0]
;;;1521   
;;;1522           if(VisionMemory::markers_.get_size() > 0)
000024  68c8              LDR      r0,[r1,#0xc]
000026  2800              CMP      r0,#0
000028  f3408180          BLE.W    |L25.812|
;;;1523           {
;;;1524             FixedLengthList<VisionMarker*> markersWithType(VisionMemory::markers_.get_size(),
00002c  aa02              ADD      r2,sp,#8
00002e  e9cd020f          STRD     r0,r2,[sp,#0x3c]
000032  f1a10438          SUB      r4,r1,#0x38
000036  2300              MOVS     r3,#0
000038  461a              MOV      r2,r3
00003a  2101              MOVS     r1,#1
00003c  a84b              ADD      r0,sp,#0x12c
00003e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000042  6800              LDR      r0,[r0,#0]
000044  9000              STR      r0,[sp,#0]
000046  9001              STR      r0,[sp,#4]
000048  4623              MOV      r3,r4
00004a  2101              MOVS     r1,#1
00004c  a811              ADD      r0,sp,#0x44
00004e  9a0f              LDR      r2,[sp,#0x3c]
000050  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000054  e9d09102          LDRD     r9,r1,[r0,#8]
000058  e9d04500          LDRD     r4,r5,[r0,#0]
00005c  f8d0b010          LDR      r11,[r0,#0x10]
000060  2200              MOVS     r2,#0
000062  9100              STR      r1,[sp,#0]
000064  4611              MOV      r1,r2
000066  a816              ADD      r0,sp,#0x58
000068  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00006c  2200              MOVS     r2,#0
00006e  901c              STR      r0,[sp,#0x70]
000070  4611              MOV      r1,r2
000072  a819              ADD      r0,sp,#0x64
000074  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000078  4601              MOV      r1,r0
00007a  981c              LDR      r0,[sp,#0x70]
00007c  2c00              CMP      r4,#0
00007e  e9d02300          LDRD     r2,r3,[r0,#0]
000082  6880              LDR      r0,[r0,#8]
000084  9202              STR      r2,[sp,#8]
000086  e9cd3003          STRD     r3,r0,[sp,#0xc]
00008a  e9d10200          LDRD     r0,r2,[r1,#0]
00008e  6889              LDR      r1,[r1,#8]
000090  9107              STR      r1,[sp,#0x1c]
000092  e9cd0205          STRD     r0,r2,[sp,#0x14]
000096  9900              LDR      r1,[sp,#0]
000098  f8cdb030          STR      r11,[sp,#0x30]
00009c  e9cd910a          STRD     r9,r1,[sp,#0x28]
0000a0  e9cd4508          STRD     r4,r5,[sp,#0x20]
0000a4  bfc8              IT       GT
0000a6  2d00              CMPGT    r5,#0
0000a8  f34080a4          BLE.W    |L25.500|
0000ac  fb04f005          MUL      r0,r4,r5
0000b0  2800              CMP      r0,#0
0000b2  f000809f          BEQ.W    |L25.500|
0000b6  2000              MOVS     r0,#0
0000b8  fb00b009          MLA      r0,r0,r9,r11
0000bc  900d              STR      r0,[sp,#0x34]
                  |L25.190|
0000be  2c00              CMP      r4,#0
0000c0  bfc8              IT       GT
0000c2  2d00              CMPGT    r5,#0
0000c4  f3408099          BLE.W    |L25.506|
0000c8  fb04f005          MUL      r0,r4,r5
0000cc  2800              CMP      r0,#0
0000ce  f0008094          BEQ.W    |L25.506|
0000d2  2000              MOVS     r0,#0
0000d4  fb00b009          MLA      r0,r0,r9,r11
0000d8  900e              STR      r0,[sp,#0x38]
                  |L25.218|
0000da  2c00              CMP      r4,#0
0000dc  bfc8              IT       GT
0000de  2d00              CMPGT    r5,#0
0000e0  dd7e              BLE      |L25.480|
0000e2  fb04f005          MUL      r0,r4,r5
0000e6  2800              CMP      r0,#0
0000e8  d07a              BEQ      |L25.480|
0000ea  2000              MOVS     r0,#0
0000ec  fb00b009          MLA      r0,r0,r9,r11
0000f0  900e              STR      r0,[sp,#0x38]
                  |L25.242|
0000f2  a801              ADD      r0,sp,#4
0000f4  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0000f8  2800              CMP      r0,#0
0000fa  bf12              ITEE     NE
0000fc  e9dd100f          LDRDNE   r1,r0,[sp,#0x3c]
000100  2100              MOVEQ    r1,#0
000102  9810              LDREQ    r0,[sp,#0x40]
000104  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker*>::set_size(int)
000108  9909              LDR      r1,[sp,#0x24]
00010a  9805              LDR      r0,[sp,#0x14]
;;;1525               VisionMemory::onchipScratch_);
;;;1526   
;;;1527             AnkiConditionalErrorAndReturnValue(markersWithType.IsValid(),
00010c  4d89              LDR      r5,|L25.820|
00010e  4288              CMP      r0,r1
000110  dc79              BGT      |L25.518|
000112  980c              LDR      r0,[sp,#0x30]
000114  b128              CBZ      r0,|L25.290|
000116  9808              LDR      r0,[sp,#0x20]
000118  2800              CMP      r0,#0
00011a  bfa6              ITTE     GE
00011c  2900              CMPGE    r1,#0
00011e  2001              MOVGE    r0,#1
000120  2000              MOVLT    r0,#0
                  |L25.290|
000122  2800              CMP      r0,#0
000124  d06f              BEQ      |L25.518|
000126  4b82              LDR      r3,|L25.816|
;;;1528               RESULT_FAIL_MEMORY,
;;;1529               "GetVisionMarkerPoseNearestTo",
;;;1530               "Failed to allocate markersWithType FixedLengthList.");
;;;1531   
;;;1532             // Find all markers with specified type
;;;1533             s32 numFound = 0;
000128  2400              MOVS     r4,#0
00012a  f8ddc038          LDR      r12,[sp,#0x38]
;;;1534             VisionMarker  * restrict pMarker = VisionMemory::markers_.Pointer(0);
;;;1535             VisionMarker* * restrict pMarkerWithType = markersWithType.Pointer(0);
;;;1536   
;;;1537             for(s32 i=0; i<VisionMemory::markers_.get_size(); ++i)
00012e  68d9              LDR      r1,[r3,#0xc]
000130  6b1a              LDR      r2,[r3,#0x30]
000132  4620              MOV      r0,r4
000134  2900              CMP      r1,#0
000136  dd14              BLE      |L25.354|
                  |L25.312|
;;;1538             {
;;;1539               if(pMarker[i].markerType == withType) {
000138  eb000140          ADD      r1,r0,r0,LSL #1
00013c  eb0101c0          ADD      r1,r1,r0,LSL #3
000140  f8dd9148          LDR      r9,[sp,#0x148]
000144  eb020181          ADD      r1,r2,r1,LSL #2
000148  f891b020          LDRB     r11,[r1,#0x20]
00014c  f8999000          LDRB     r9,[r9,#0]
000150  45cb              CMP      r11,r9
;;;1540                 pMarkerWithType[numFound++] = pMarker + i;
000152  bf04              ITT      EQ
000154  f84c1024          STREQ    r1,[r12,r4,LSL #2]
000158  1c64              ADDEQ    r4,r4,#1
00015a  1c40              ADDS     r0,r0,#1              ;1537
00015c  68d9              LDR      r1,[r3,#0xc]          ;1537
00015e  4281              CMP      r1,r0                 ;1537
000160  dcea              BGT      |L25.312|
                  |L25.354|
;;;1541               }
;;;1542             }
;;;1543             markersWithType.set_size(numFound);
000162  4621              MOV      r1,r4
000164  a802              ADD      r0,sp,#8
000166  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker*>::set_size(int)
;;;1544   
;;;1545             // If any were found, find the one that is closest to the specified
;;;1546             // 3D point and within the specified max distance
;;;1547             if(numFound > 0) {
00016a  2c00              CMP      r4,#0
00016c  f34080de          BLE.W    |L25.812|
;;;1548               // Create a little MemoryStack for allocating temporary
;;;1549               // rotation matrix
;;;1550               const s32 SCRATCH_BUFFER_SIZE = 128;
;;;1551               char scratchBuffer[SCRATCH_BUFFER_SIZE];
;;;1552               MemoryStack scratch(scratchBuffer, SCRATCH_BUFFER_SIZE);
000170  2201              MOVS     r2,#1
000172  2300              MOVS     r3,#0
000174  4611              MOV      r1,r2
000176  a80f              ADD      r0,sp,#0x3c
000178  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00017c  6803              LDR      r3,[r0,#0]
00017e  2280              MOVS     r2,#0x80
000180  a910              ADD      r1,sp,#0x40
000182  a838              ADD      r0,sp,#0xe0
000184  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
000188  eddf8a6b          VLDR     s17,|L25.824|
;;;1553   
;;;1554               // Create temporary pose storage (wrt camera)
;;;1555               Point3<f32> translationWrtCamera;
;;;1556               Array<f32> rotationWrtCamera(3,3,scratch);
00018c  2300              MOVS     r3,#0
00018e  edcd8a3f          VSTR     s17,[sp,#0xfc]
000192  edcd8a40          VSTR     s17,[sp,#0x100]
000196  edcd8a41          VSTR     s17,[sp,#0x104]
00019a  461a              MOV      r2,r3
00019c  2101              MOVS     r1,#1
00019e  a84c              ADD      r0,sp,#0x130
0001a0  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0001a4  6800              LDR      r0,[r0,#0]
0001a6  2203              MOVS     r2,#3
0001a8  9000              STR      r0,[sp,#0]
0001aa  ab38              ADD      r3,sp,#0xe0
0001ac  4611              MOV      r1,r2
0001ae  a830              ADD      r0,sp,#0xc0
0001b0  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0001b4  9834              LDR      r0,[sp,#0xd0]
0001b6  b140              CBZ      r0,|L25.458|
0001b8  9830              LDR      r0,[sp,#0xc0]
0001ba  2800              CMP      r0,#0
0001bc  bfa1              ITTTT    GE
0001be  9831              LDRGE    r0,[sp,#0xc4]
0001c0  2800              CMPGE    r0,#0
;;;1557               AnkiConditionalErrorAndReturnValue(rotationWrtCamera.IsValid(),
;;;1558                 RESULT_FAIL_MEMORY,
;;;1559                 "GetVisionMarkerPoseNearestTo",
;;;1560                 "Failed to allocate rotationWrtCamera Array.");
;;;1561   
;;;1562               VisionMarker* const* restrict pMarkerWithType = markersWithType.Pointer(0);
;;;1563   
;;;1564               f32 closestDistance = maxDistance_mm;
;;;1565   
;;;1566               for(s32 i=0; i<numFound; ++i) {
0001c2  2500              MOVGE    r5,#0
0001c4  f8dd9038          LDRGE    r9,[sp,#0x38]
0001c8  da2a              BGE      |L25.544|
                  |L25.458|
0001ca  f2406015          MOV      r0,#0x615             ;1557
0001ce  e9cd5000          STRD     r5,r0,[sp,#0]         ;1557
0001d2  a35a              ADR      r3,|L25.828|
0001d4  a261              ADR      r2,|L25.860|
0001d6  a16c              ADR      r1,|L25.904|
0001d8  2005              MOVS     r0,#5                 ;1557
0001da  f7fffffe          BL       _Anki_Log
0001de  e001              B        |L25.484|
                  |L25.480|
0001e0  e00e              B        |L25.512|
0001e2  e010              B        |L25.518|
                  |L25.484|
0001e4  f04f7080          MOV      r0,#0x1000000         ;1557
                  |L25.488|
;;;1567                 // Compute this marker's pose WRT camera
;;;1568                 if((lastResult = GetVisionMarkerPose(*(pMarkerWithType[i]), true,
;;;1569                   rotationWrtCamera, translationWrtCamera)) != RESULT_OK) {
;;;1570                     return lastResult;
;;;1571                 }
;;;1572   
;;;1573                 // Convert it to pose WRT robot
;;;1574                 if((lastResult = GetWithRespectToRobot(rotationWrtCamera, translationWrtCamera,
;;;1575                   rotationWrtRobot, translationWrtRobot)) != RESULT_OK) {
;;;1576                     return lastResult;
;;;1577                 }
;;;1578   
;;;1579                 // See how far it is from the specified position
;;;1580                 const f32 currentDistance = (translationWrtRobot - atPosition).Length();
;;;1581                 if(currentDistance < closestDistance) {
;;;1582                   closestDistance = currentDistance;
;;;1583                   markerFound = true;
;;;1584                 }
;;;1585               } // for each marker with type
;;;1586             } // if numFound > 0
;;;1587           } // if(VisionMemory::markers_.get_size() > 0)
;;;1588   
;;;1589           return RESULT_OK;
;;;1590         } // GetVisionMarkerPoseNearestTo()
0001e8  b04d              ADD      sp,sp,#0x134
0001ea  ecbd8b02          VPOP     {d8}
0001ee  b006              ADD      sp,sp,#0x18
0001f0  e8bd8ff0          POP      {r4-r11,pc}
                  |L25.500|
0001f4  f8cda034          STR      r10,[sp,#0x34]
0001f8  e761              B        |L25.190|
                  |L25.506|
0001fa  f8cda038          STR      r10,[sp,#0x38]
0001fe  e76c              B        |L25.218|
                  |L25.512|
000200  f8cda038          STR      r10,[sp,#0x38]
000204  e775              B        |L25.242|
                  |L25.518|
000206  f24050f7          MOV      r0,#0x5f7             ;1527
00020a  e9cd5000          STRD     r5,r0,[sp,#0]         ;1527
00020e  a34b              ADR      r3,|L25.828|
000210  a265              ADR      r2,|L25.936|
000212  a15d              ADR      r1,|L25.904|
000214  2005              MOVS     r0,#5                 ;1527
000216  f7fffffe          BL       _Anki_Log
00021a  f04f7080          MOV      r0,#0x1000000         ;1527
00021e  e7e3              B        |L25.488|
                  |L25.544|
000220  f8590025          LDR      r0,[r9,r5,LSL #2]     ;1568
000224  ab3f              ADD      r3,sp,#0xfc           ;1568
000226  aa30              ADD      r2,sp,#0xc0           ;1568
000228  2101              MOVS     r1,#1                 ;1568
00022a  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem19GetVisionMarkerPoseERKNS_8Embedded12VisionMarkerEbRNS2_5ArrayIfEERNS2_6Point3IfEE ; Anki::Cozmo::VisionSystem::GetVisionMarkerPose(const Anki::Embedded::VisionMarker&, bool, Anki::Embedded::Array<float>&, Anki::Embedded::Point3<float>&)
00022e  2800              CMP      r0,#0                 ;1568
000230  d1da              BNE      |L25.488|
000232  a83f              ADD      r0,sp,#0xfc           ;1574
000234  9000              STR      r0,[sp,#0]            ;1574
000236  f8dda14c          LDR      r10,[sp,#0x14c]       ;1574
00023a  edcd8a35          VSTR     s17,[sp,#0xd4]        ;1574
00023e  edcd8a36          VSTR     s17,[sp,#0xd8]        ;1574
000242  f10d0bc0          ADD      r11,sp,#0xc0          ;1574
000246  edcd8a37          VSTR     s17,[sp,#0xdc]        ;1574
00024a  a935              ADD      r1,sp,#0xd4           ;1574
00024c  4863              LDR      r0,|L25.988|
00024e  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)
000252  bb78              CBNZ     r0,|L25.692|
000254  4652              MOV      r2,r10                ;1574
000256  4659              MOV      r1,r11                ;1574
000258  4860              LDR      r0,|L25.988|
00025a  f7fffffe          BL       _ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
00025e  bb48              CBNZ     r0,|L25.692|
000260  46b2              MOV      r10,r6                ;1574
000262  f50d7b90          ADD      r11,sp,#0x120         ;1574
000266  495d              LDR      r1,|L25.988|
000268  a842              ADD      r0,sp,#0x108          ;1574
00026a  9a00              LDR      r2,[sp,#0]            ;1574
00026c  f7fffffe          BL       _ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_ ; Anki::Embedded::operator *<float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Point3<T1>&)
000270  ed9d0a44          VLDR     s0,[sp,#0x110]        ;1574
000274  eddd0a37          VLDR     s1,[sp,#0xdc]         ;1574
000278  eddd1a35          VLDR     s3,[sp,#0xd4]         ;1574
00027c  4658              MOV      r0,r11                ;1574
00027e  ee301a20          VADD.F32 s2,s0,s1              ;1574
000282  ed9d0a43          VLDR     s0,[sp,#0x10c]        ;1574
000286  eddd0a36          VLDR     s1,[sp,#0xd8]         ;1574
00028a  ee700a20          VADD.F32 s1,s0,s1              ;1574
00028e  ed9d0a42          VLDR     s0,[sp,#0x108]        ;1574
000292  ee300a21          VADD.F32 s0,s0,s3              ;1574
000296  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
00029a  ed9d0a48          VLDR     s0,[sp,#0x120]        ;1574
00029e  2000              MOVS     r0,#0                 ;1574
0002a0  ed8a0a00          VSTR     s0,[r10,#0]           ;1574
0002a4  ed9d0a49          VLDR     s0,[sp,#0x124]        ;1574
0002a8  ed8a0a01          VSTR     s0,[r10,#4]           ;1574
0002ac  ed9d0a4a          VLDR     s0,[sp,#0x128]        ;1574
0002b0  ed8a0a02          VSTR     s0,[r10,#8]           ;1574
                  |L25.692|
0002b4  2800              CMP      r0,#0                 ;1574
0002b6  d197              BNE      |L25.488|
0002b8  ed960a02          VLDR     s0,[r6,#8]            ;1574
0002bc  edd70a02          VLDR     s1,[r7,#8]            ;1574
0002c0  edd71a00          VLDR     s3,[r7,#0]            ;1574
0002c4  a845              ADD      r0,sp,#0x114          ;1580
0002c6  ee301a60          VSUB.F32 s2,s0,s1              ;1580
0002ca  ed960a01          VLDR     s0,[r6,#4]            ;1580
0002ce  edd70a01          VLDR     s1,[r7,#4]            ;1580
0002d2  ee700a60          VSUB.F32 s1,s0,s1              ;1580
0002d6  ed960a00          VLDR     s0,[r6,#0]            ;1580
0002da  ee300a61          VSUB.F32 s0,s0,s3              ;1580
0002de  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
0002e2  ed9d0a45          VLDR     s0,[sp,#0x114]        ;1580
0002e6  ee600a00          VMUL.F32 s1,s0,s0              ;1580
0002ea  ed9d0a46          VLDR     s0,[sp,#0x118]        ;1580
0002ee  ee400a00          VMLA.F32 s1,s0,s0              ;1580
0002f2  ed9d0a47          VLDR     s0,[sp,#0x11c]        ;1580
0002f6  ee400a00          VMLA.F32 s1,s0,s0              ;1580
0002fa  eeb10ae0          VSQRT.F32 s0,s1                 ;1580
0002fe  eeb40a40          VCMP.F32 s0,s0                 ;1580
000302  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1580
000306  bf1c              ITT      NE                    ;1580
000308  eeb00a60          VMOVNE.F32 s0,s1                 ;1580
00030c  f7fffffe          BLNE     __hardfp_sqrtf
000310  eeb40ac8          VCMPE.F32 s0,s16                ;1581
000314  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1581
000318  d204              BCS      |L25.804|
00031a  2001              MOVS     r0,#1                 ;1583
00031c  eeb08a40          VMOV.F32 s16,s0                ;1582
000320  f8880000          STRB     r0,[r8,#0]            ;1583
                  |L25.804|
000324  1c6d              ADDS     r5,r5,#1              ;1566
000326  42a5              CMP      r5,r4                 ;1566
000328  f6ffaf7a          BLT      |L25.544|
                  |L25.812|
00032c  2000              MOVS     r0,#0                 ;1589
00032e  e75b              B        |L25.488|
;;;1591   
                          ENDP

                  |L25.816|
                          DCD      ||.bss||+0x54
                  |L25.820|
                          DCD      ||.constdata||+0x2e25
                  |L25.824|
000338  00000000          DCFS     0x00000000 ; 0
                  |L25.828|
00033c  73757065          DCB      "supervisor\\src\\visionSystem.cpp",0
000340  72766973
000344  6f725c73
000348  72635c76
00034c  6973696f
000350  6e537973
000354  74656d2e
000358  63707000
                  |L25.860|
00035c  4661696c          DCB      "Failed to allocate rotationWrtCamera Array.",0
000360  65642074
000364  6f20616c
000368  6c6f6361
00036c  74652072
000370  6f746174
000374  696f6e57
000378  72744361
00037c  6d657261
000380  20417272
000384  61792e00
                  |L25.904|
000388  47657456          DCB      "GetVisionMarkerPoseNearestTo",0
00038c  6973696f
000390  6e4d6172
000394  6b657250
000398  6f73654e
00039c  65617265
0003a0  7374546f
0003a4  00      
0003a5  00                DCB      0
0003a6  00                DCB      0
0003a7  00                DCB      0
                  |L25.936|
0003a8  4661696c          DCB      "Failed to allocate markersWithType FixedLengthList.",0
0003ac  65642074
0003b0  6f20616c
0003b4  6c6f6361
0003b8  7465206d
0003bc  61726b65
0003c0  72735769
0003c4  74685479
0003c8  70652046
0003cc  69786564
0003d0  4c656e67
0003d4  74684c69
0003d8  73742e00
                  |L25.988|
                          DCD      ||.bss||+0x88

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754713MarkerToTrack5ClearEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754713MarkerToTrack5ClearEv PROC ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
;;;241    
;;;242            void MarkerToTrack::Clear() {
000000  b082              SUB      sp,sp,#8
;;;243              type        = Anki::Vision::MARKER_UNKNOWN;
000002  21f7              MOVS     r1,#0xf7
;;;244              width_mm    = 0;
000004  ed9f0a0c          VLDR     s0,|L26.56|
000008  7001              STRB     r1,[r0,#0]            ;243
00000a  ed800a01          VSTR     s0,[r0,#4]
;;;245              imageCenter = Point2f(-1.f, -1.f);
00000e  eebf0a00          VMOV.F32 s0,#-1.00000000
000012  ed8d0a00          VSTR     s0,[sp,#0]
000016  ed8d0a01          VSTR     s0,[sp,#4]
00001a  eddd0a00          VLDR     s1,[sp,#0]
;;;246              imageSearchRadius = -1.f;
;;;247              checkAngleX = true;
00001e  2101              MOVS     r1,#1
000020  edc00a02          VSTR     s1,[r0,#8]
000024  eddd0a01          VLDR     s1,[sp,#4]
000028  edc00a03          VSTR     s1,[r0,#0xc]
00002c  ed800a04          VSTR     s0,[r0,#0x10]         ;246
000030  7501              STRB     r1,[r0,#0x14]
;;;248            }
000032  b002              ADD      sp,sp,#8
000034  4770              BX       lr
;;;249    
                          ENDP

000036  0000              DCW      0x0000
                  |L26.56|
000038  00000000          DCFS     0x00000000 ; 0

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem4InitEv||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem4InitEv PROC ; Anki::Cozmo::VisionSystem::Init()
;;;1388         
;;;1389         Result Init()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1390         {
;;;1391           Result result = RESULT_OK;
;;;1392   
;;;1393           if(!isInitialized_) {
000004  4d50              LDR      r5,|L27.328|
000006  f04f0800          MOV      r8,#0                 ;1391
00000a  ed2d8b02          VPUSH    {d8}                  ;1390
00000e  b08c              SUB      sp,sp,#0x30           ;1390
000010  7828              LDRB     r0,[r5,#0]  ; isInitialized_
000012  2800              CMP      r0,#0
000014  d17e              BNE      |L27.276|
;;;1394             captureResolution_ = Vision::CAMERA_RES_QVGA;
000016  2701              MOVS     r7,#1
000018  72ef              STRB     r7,[r5,#0xb]
;;;1395   
;;;1396             // WARNING: the order of these initializations matter!
;;;1397   
;;;1398             //
;;;1399             // Initialize the VisionSystem's state (i.e. its "private member variables")
;;;1400             //
;;;1401   
;;;1402             mode_                      = VISION_MODE_LOOKING_FOR_MARKERS;
00001a  722f              STRB     r7,[r5,#8]
;;;1403             markerToTrack_.Clear();
00001c  484b              LDR      r0,|L27.332|
00001e  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754713MarkerToTrack5ClearEv ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
;;;1404             numTrackFailures_          = 0;
000022  2600              MOVS     r6,#0
;;;1405   
;;;1406             wasCalledOnce_             = false;
000024  63ee              STR      r6,[r5,#0x3c]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754717numTrackFailures_E
000026  726e              STRB     r6,[r5,#9]
;;;1407             havePreviousRobotState_    = false;
000028  72ae              STRB     r6,[r5,#0xa]
;;;1408   
;;;1409             headCamInfo_ = HAL::GetHeadCamInfo();
00002a  f7fffffe          BL       _ZN4Anki5Cozmo3HAL14GetHeadCamInfoEv ; Anki::Cozmo::HAL::GetHeadCamInfo()
00002e  62a8              STR      r0,[r5,#0x28]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712headCamInfo_E
000030  0004              MOVS     r4,r0
;;;1410             if(headCamInfo_ == NULL) {
000032  d070              BEQ      |L27.278|
;;;1411               PRINT("Initialize() - HeadCam Info pointer is NULL!\n");
;;;1412               return RESULT_FAIL;
;;;1413             }
;;;1414   
;;;1415             // Compute FOV from focal length (currently used for tracker prediciton)
;;;1416             headCamFOV_ver_ = 2.f * atanf(static_cast<f32>(headCamInfo_->nrows) /
000034  8aa0              LDRH     r0,[r4,#0x14]
000036  eeb08a00          VMOV.F32 s16,#2.00000000
00003a  ee000a10          VMOV     s0,r0
00003e  eef80a40          VCVT.F32.U32 s1,s0
000042  ed940a01          VLDR     s0,[r4,#4]
000046  ee201a08          VMUL.F32 s2,s0,s16
00004a  ee800a81          VDIV.F32 s0,s1,s2
00004e  f7fffffe          BL       __hardfp_atanf
000052  ee200a08          VMUL.F32 s0,s0,s16
000056  ed850a0b          VSTR     s0,[r5,#0x2c]
;;;1417               (2.f * headCamInfo_->focalLength_y));
;;;1418             headCamFOV_hor_ = 2.f * atanf(static_cast<f32>(headCamInfo_->ncols) /
00005a  8ae0              LDRH     r0,[r4,#0x16]
00005c  ee000a10          VMOV     s0,r0
000060  eef80a40          VCVT.F32.U32 s1,s0
000064  ed940a00          VLDR     s0,[r4,#0]
000068  ee201a08          VMUL.F32 s2,s0,s16
00006c  ee800a81          VDIV.F32 s0,s1,s2
000070  f7fffffe          BL       __hardfp_atanf
000074  ee200a08          VMUL.F32 s0,s0,s16
;;;1419               (2.f * headCamInfo_->focalLength_x));
;;;1420   
;;;1421             exposureTime = 0.2f; // TODO: pick a reasonable start value
;;;1422             frameNumber = 0;
;;;1423   
;;;1424             detectionParameters_.Initialize();
000078  4836              LDR      r0,|L27.340|
00007a  ed850a0c          VSTR     s0,[r5,#0x30]         ;1418
00007e  ed9f0a34          VLDR     s0,|L27.336|
000082  ed850a0d          VSTR     s0,[r5,#0x34]         ;1421
000086  63ae              STR      r6,[r5,#0x38]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754711frameNumberE
000088  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem31DetectFiducialMarkersParameters10InitializeEv ; Anki::Cozmo::VisionSystem::DetectFiducialMarkersParameters::Initialize()
;;;1425             trackerParameters_.Initialize();
00008c  4832              LDR      r0,|L27.344|
00008e  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem17TrackerParameters10InitializeEv ; Anki::Cozmo::VisionSystem::TrackerParameters::Initialize()
;;;1426             faceDetectionParameters_.Initialize();
000092  4832              LDR      r0,|L27.348|
000094  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem23FaceDetectionParameters10InitializeEv ; Anki::Cozmo::VisionSystem::FaceDetectionParameters::Initialize()
000098  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv ; Anki::Cozmo::VisionSystem::VisionMemory::ResetBuffers()
;;;1427   
;;;1428             Simulator::Initialize();
;;;1429   
;;;1430   #ifdef RUN_SIMPLE_TRACKING_TEST
;;;1431             Anki::Cozmo::VisionSystem::SetMarkerToTrack(Vision::MARKER_FIRE, DEFAULT_BLOCK_MARKER_WIDTH_MM);
;;;1432   #endif
;;;1433   
;;;1434             result = VisionMemory::Initialize();
;;;1435             if(result != RESULT_OK) { return result; }
00009c  2800              CMP      r0,#0
;;;1436   
;;;1437             result = DebugStream::Initialize();
;;;1438             if(result != RESULT_OK) { return result; }
;;;1439   
;;;1440             result = MatlabVisualization::Initialize();
;;;1441             if(result != RESULT_OK) { return result; }
;;;1442   
;;;1443   #if USE_MATLAB_TRACKER || USE_MATLAB_DETECTOR
;;;1444             result = MatlabVisionProcessor::Initialize();
;;;1445             if(result != RESULT_OK) { return result; }
;;;1446   #endif
;;;1447   
;;;1448             RcamWrtRobot_ = Array<f32>(3,3,VisionMemory::onchipScratch_);
;;;1449             
;;;1450             markerToTrack_.Clear();
;;;1451             newMarkerToTrack_.Clear();
;;;1452             newMarkerToTrackWasProvided_ = false;
;;;1453   
;;;1454             isWaitingOnSnapshot_ = false;
;;;1455             isSnapshotReady_ = NULL;
;;;1456             snapshotROI_ = Rectangle<s32>(-1, -1, -1, -1);
;;;1457             snapshot_ = NULL;
;;;1458             
;;;1459             isInitialized_ = true;
;;;1460           }
;;;1461   
;;;1462           return result;
;;;1463         }
00009e  bf1e              ITTT     NE
0000a0  b00c              ADDNE    sp,sp,#0x30
0000a2  ecbd8b02          VPOPNE   {d8}
0000a6  e8bd81f0          POPNE    {r4-r8,pc}
0000aa  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem11DebugStream10InitializeEv ; Anki::Cozmo::VisionSystem::DebugStream::Initialize()
0000ae  2800              CMP      r0,#0                 ;1438
0000b0  d13f              BNE      |L27.306|
0000b2  f7fffffe          BL       _ZN4Anki5Cozmo19MatlabVisualization10InitializeEv ; Anki::Cozmo::MatlabVisualization::Initialize()
0000b6  ea5f0800          MOVS     r8,r0                 ;1440
0000ba  d13a              BNE      |L27.306|
0000bc  2300              MOVS     r3,#0                 ;1448
0000be  4c28              LDR      r4,|L27.352|
0000c0  461a              MOV      r2,r3                 ;1448
0000c2  2101              MOVS     r1,#1                 ;1448
0000c4  a801              ADD      r0,sp,#4              ;1448
0000c6  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000ca  6800              LDR      r0,[r0,#0]            ;1448
0000cc  2203              MOVS     r2,#3                 ;1448
0000ce  9000              STR      r0,[sp,#0]            ;1448
0000d0  f1a4036c          SUB      r3,r4,#0x6c           ;1448
0000d4  4611              MOV      r1,r2                 ;1448
0000d6  a806              ADD      r0,sp,#0x18           ;1448
0000d8  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0000dc  6801              LDR      r1,[r0,#0]            ;1448
0000de  6021              STR      r1,[r4,#0]            ;1448
0000e0  6841              LDR      r1,[r0,#4]            ;1448
0000e2  6061              STR      r1,[r4,#4]            ;1448
0000e4  6881              LDR      r1,[r0,#8]            ;1448
0000e6  60a1              STR      r1,[r4,#8]            ;1448
0000e8  68c1              LDR      r1,[r0,#0xc]          ;1448
0000ea  60e1              STR      r1,[r4,#0xc]          ;1448
0000ec  6900              LDR      r0,[r0,#0x10]         ;1448
0000ee  6120              STR      r0,[r4,#0x10]         ;1450
0000f0  f1040014          ADD      r0,r4,#0x14           ;1450
0000f4  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754713MarkerToTrack5ClearEv ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
0000f8  f104002c          ADD      r0,r4,#0x2c           ;1451
0000fc  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754713MarkerToTrack5ClearEv ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
000100  70ee              STRB     r6,[r5,#3]            ;1452
000102  732e              STRB     r6,[r5,#0xc]          ;1454
000104  f04f3cff          MOV      r12,#0xffffffff       ;1456
000108  642e              STR      r6,[r5,#0x40]         ;1456  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754716isSnapshotReady_E
00010a  e9cdcc04          STRD     r12,r12,[sp,#0x10]    ;1456
00010e  f5047064          ADD      r0,r4,#0x390          ;1456
000112  e001              B        |L27.280|
                  |L27.276|
000114  e00c              B        |L27.304|
                  |L27.278|
000116  e011              B        |L27.316|
                  |L27.280|
000118  e9cdcc02          STRD     r12,r12,[sp,#8]       ;1456
00011c  f8c0c000          STR      r12,[r0,#0]           ;1456
000120  9903              LDR      r1,[sp,#0xc]          ;1456
000122  6041              STR      r1,[r0,#4]            ;1456
000124  9904              LDR      r1,[sp,#0x10]         ;1456
000126  6081              STR      r1,[r0,#8]            ;1456
000128  9905              LDR      r1,[sp,#0x14]         ;1456
00012a  60c1              STR      r1,[r0,#0xc]          ;1457
00012c  64ae              STR      r6,[r5,#0x48]         ;1459  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff75479snapshot_E
00012e  702f              STRB     r7,[r5,#0]            ;1459
                  |L27.304|
000130  4640              MOV      r0,r8                 ;1462
                  |L27.306|
000132  b00c              ADD      sp,sp,#0x30
000134  ecbd8b02          VPOP     {d8}
000138  e8bd81f0          POP      {r4-r8,pc}
                  |L27.316|
00013c  a009              ADR      r0,|L27.356|
00013e  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
000142  2001              MOVS     r0,#1                 ;1412
000144  e7f5              B        |L27.306|
;;;1464   
                          ENDP

000146  0000              DCW      0x0000
                  |L27.328|
                          DCD      ||.data||
                  |L27.332|
                          DCD      ||.bss||+0x9c
                  |L27.336|
000150  3e4ccccd          DCFS     0x3e4ccccd ; 0.20000000298023224
                  |L27.340|
                          DCD      ||.bss||+0x344
                  |L27.344|
                          DCD      ||.bss||+0x3a4
                  |L27.348|
                          DCD      ||.bss||+0x3e8
                  |L27.352|
                          DCD      ||.bss||+0x88
                  |L27.356|
000164  496e6974          DCB      "Initialize() - HeadCam Info pointer is NULL!\n",0
000168  69616c69
00016c  7a652829
000170  202d2048
000174  65616443
000178  616d2049
00017c  6e666f20
000180  706f696e
000184  74657220
000188  6973204e
00018c  554c4c21
000190  0a00    
000192  00                DCB      0
000193  00                DCB      0

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem6UpdateENS0_8Messages10RobotStateE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem6UpdateENS0_8Messages10RobotStateE PROC ; Anki::Cozmo::VisionSystem::Update(Anki::Cozmo::Messages::RobotState)
;;;1917         // This is the regular Update() call
;;;1918         Result Update(const Messages::RobotState robotState)
000000  b40f              PUSH     {r0-r3}
;;;1919         {
000002  e92d4ff0          PUSH     {r4-r11,lr}
000006  ed2d8b04          VPUSH    {d8-d9}
00000a  f5ad7d6b          SUB      sp,sp,#0x3ac
;;;1920           Result lastResult = RESULT_OK;
;;;1921   
;;;1922           // This should be called from elsewhere first, but calling it again won't hurt
;;;1923           Init();
00000e  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem4InitEv ; Anki::Cozmo::VisionSystem::Init()
;;;1924   
;;;1925           frameNumber++;
000012  48fe              LDR      r0,|L28.1036|
000014  2701              MOVS     r7,#1
000016  6b81              LDR      r1,[r0,#0x38]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754711frameNumberE
000018  1c49              ADDS     r1,r1,#1
;;;1926   
;;;1927           // no-op on real hardware
;;;1928           if(!Simulator::IsFrameReady()) {
;;;1929             return RESULT_OK;
;;;1930           }
;;;1931           
;;;1932           // Make sure that we send the robot state message associated with the
;;;1933           // image we are about to process.
;;;1934           Messages::SendRobotStateMsg(&robotState);
00001a  6381              STR      r1,[r0,#0x38]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754711frameNumberE
00001c  a8f8              ADD      r0,sp,#0x3e0
00001e  f7fffffe          BL       _ZN4Anki5Cozmo8Messages17SendRobotStateMsgEPKNS1_10RobotStateE ; Anki::Cozmo::Messages::SendRobotStateMsg(const Anki::Cozmo::Messages::RobotState*)
000022  f50d7a78          ADD      r10,sp,#0x3e0
000026  48fa              LDR      r0,|L28.1040|
000028  e8ba037e          LDM      r10!,{r1-r6,r8,r9}
00002c  f10d0a14          ADD      r10,sp,#0x14
000030  e8aa0370          STM      r10!,{r4-r6,r8,r9}
000034  f50d6a80          ADD      r10,sp,#0x400
000038  e8ba1370          LDM      r10!,{r4-r6,r8,r9,r12}
00003c  e88d0370          STM      sp,{r4-r6,r8,r9}
000040  f5007435          ADD      r4,r0,#0x2d4
000044  e8944f70          LDM      r4,{r4-r6,r8-r11,lr}
000048  e9c045c3          STRD     r4,r5,[r0,#0x30c]
00004c  f5007445          ADD      r4,r0,#0x314
000050  e8a44f40          STM      r4!,{r6,r8-r11,lr}
000054  f500743d          ADD      r4,r0,#0x2f4
000058  f5007b4b          ADD      r11,r0,#0x32c
00005c  e8940770          LDM      r4,{r4-r6,r8-r10}
000060  e8ab0770          STM      r11!,{r4-r6,r8-r10}
000064  f10d0a14          ADD      r10,sp,#0x14
000068  e8ba0370          LDM      r10!,{r4-r6,r8,r9}
00006c  f5007a35          ADD      r10,r0,#0x2d4
000070  f500703d          ADD      r0,r0,#0x2f4
000074  e8aa037e          STM      r10!,{r1-r6,r8,r9}
000078  e89d0370          LDM      sp,{r4-r6,r8,r9}
00007c  e8a01370          STM      r0!,{r4-r6,r8,r9,r12}
000080  f8df9388          LDR      r9,|L28.1036|
000084  f8990009          LDRB     r0,[r9,#9]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754714wasCalledOnce_E
000088  2800              CMP      r0,#0
00008a  bf14              ITE      NE
00008c  f889700a          STRBNE   r7,[r9,#0xa]
000090  f8897009          STRBEQ   r7,[r9,#9]
000094  f8990003          LDRB     r0,[r9,#3]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754728newMarkerToTrackWasProvided_E
000098  4ede              LDR      r6,|L28.1044|
00009a  ed9f9adf          VLDR     s18,|L28.1048|
00009e  2400              MOVS     r4,#0
0000a0  f1a60b18          SUB      r11,r6,#0x18
0000a4  eef68a00          VMOV.F32 s17,#0.50000000
0000a8  2800              CMP      r0,#0
0000aa  d07d              BEQ      |L28.424|
0000ac  f8897008          STRB     r7,[r9,#8]
0000b0  f1a60018          SUB      r0,r6,#0x18
0000b4  f8c9403c          STR      r4,[r9,#0x3c]  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754717numTrackFailures_E
0000b8  7831              LDRB     r1,[r6,#0]
0000ba  7001              STRB     r1,[r0,#0]
0000bc  ed960a01          VLDR     s0,[r6,#4]
0000c0  ed800a01          VSTR     s0,[r0,#4]
0000c4  ed960a02          VLDR     s0,[r6,#8]
0000c8  ed800a02          VSTR     s0,[r0,#8]
0000cc  ed960a03          VLDR     s0,[r6,#0xc]
0000d0  ed800a03          VSTR     s0,[r0,#0xc]
0000d4  ed960a04          VLDR     s0,[r6,#0x10]
0000d8  ed800a04          VSTR     s0,[r0,#0x10]
0000dc  7d31              LDRB     r1,[r6,#0x14]
0000de  7501              STRB     r1,[r0,#0x14]
0000e0  f89b0000          LDRB     r0,[r11,#0]
0000e4  28f7              CMP      r0,#0xf7
0000e6  d071              BEQ      |L28.460|
0000e8  ed9b8a01          VLDR     s16,[r11,#4]
0000ec  eeb58ac0          VCMPE.F32 s16,#0.0
0000f0  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000f4  d80d              BHI      |L28.274|
0000f6  f2401175          MOV      r1,#0x175
0000fa  48c8              LDR      r0,|L28.1052|
0000fc  e9cd0100          STRD     r0,r1,[sp,#0]
000100  a3c7              ADR      r3,|L28.1056|
000102  a2cf              ADR      r2,|L28.1088|
000104  a1d6              ADR      r1,|L28.1120|
000106  2005              MOVS     r0,#5
000108  f7fffffe          BL       _Anki_Log
00010c  f04f7840          MOV      r8,#0x3000000
000110  e063              B        |L28.474|
                  |L28.274|
000112  ee689a28          VMUL.F32 s19,s16,s17
000116  4ddb              LDR      r5,|L28.1156|
000118  eeb01a49          VMOV.F32 s2,s18
;;;1935           
;;;1936           UpdateRobotState(robotState);
;;;1937           
;;;1938           // If SetMarkerToTrack() was called by main() during previous Update(),
;;;1939           // actually swap in the new marker now.
;;;1940           lastResult = UpdateMarkerToTrack();
;;;1941           AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK, lastResult,
;;;1942                                              "VisionSystem::Update()", "UpdateMarkerToTrack failed.\n");
;;;1943   
;;;1944           // Use the timestamp of passed-in robot state as our frame capture's
;;;1945           // timestamp.  This is not totally correct, since the image will be
;;;1946           // grabbed some (trivial?) number of cycles later, once we get to the
;;;1947           // CameraGetFrame() calls below.  But this enforces, for now, that we
;;;1948           // always send a RobotState message off to basestation with a matching
;;;1949           // timestamp to every VisionMarker message.
;;;1950           //const TimeStamp_t imageTimeStamp = HAL::GetTimeStamp();
;;;1951           const TimeStamp_t imageTimeStamp = robotState.timestamp;
;;;1952   
;;;1953           if(mode_ == VISION_MODE_IDLE) {
;;;1954             // Nothing to do, unless a snapshot was requested
;;;1955             
;;;1956             if(isWaitingOnSnapshot_) {
;;;1957               const s32 captureHeight = CameraModeInfo[captureResolution_].height;
;;;1958               const s32 captureWidth  = CameraModeInfo[captureResolution_].width;
;;;1959               
;;;1960               Array<u8> grayscaleImage(captureHeight, captureWidth,
;;;1961                                        VisionMemory::offchipScratch_, Flags::Buffer(false,false,false));
;;;1962               
;;;1963               HAL::CameraGetFrame(reinterpret_cast<u8*>(grayscaleImage.get_buffer()),
;;;1964                                   captureResolution_, false);
;;;1965               
;;;1966               if((lastResult = TakeSnapshotHelper(grayscaleImage)) != RESULT_OK) {
;;;1967                 PRINT("VisionSystem::Update(): TakeSnapshotHelper() failed.\n");
;;;1968                 return lastResult;
;;;1969               }
;;;1970             }
;;;1971             
;;;1972           }
;;;1973           else if(mode_ == VISION_MODE_LOOKING_FOR_MARKERS) {
;;;1974             Simulator::SetDetectionReadyTime(); // no-op on real hardware
;;;1975   
;;;1976             VisionMemory::ResetBuffers();
;;;1977   
;;;1978             //MemoryStack offchipScratch_local(VisionMemory::offchipScratch_);
;;;1979   
;;;1980             const s32 captureHeight = CameraModeInfo[captureResolution_].height;
;;;1981             const s32 captureWidth  = CameraModeInfo[captureResolution_].width;
;;;1982   
;;;1983             Array<u8> grayscaleImage(captureHeight, captureWidth,
;;;1984               VisionMemory::offchipScratch_, Flags::Buffer(false,false,false));
;;;1985   
;;;1986             HAL::CameraGetFrame(reinterpret_cast<u8*>(grayscaleImage.get_buffer()),
;;;1987               captureResolution_, false);
;;;1988             
;;;1989             if((lastResult = TakeSnapshotHelper(grayscaleImage)) != RESULT_OK) {
;;;1990               PRINT("VisionSystem::Update(): TakeSnapshotHelper() failed.\n");
;;;1991               return lastResult;
;;;1992             }
;;;1993             
;;;1994             BeginBenchmark("VisionSystem_CameraImagingPipeline");
;;;1995   
;;;1996             if(vignettingCorrection == VignettingCorrection_Software) {
;;;1997               BeginBenchmark("VisionSystem_CameraImagingPipeline_Vignetting");
;;;1998   
;;;1999               MemoryStack onchipScratch_local = VisionMemory::onchipScratch_;
;;;2000               FixedLengthList<f32> polynomialParameters(5, onchipScratch_local, Flags::Buffer(false, false, true));
;;;2001   
;;;2002               for(s32 i=0; i<5; i++)
;;;2003                 polynomialParameters[i] = vignettingCorrectionParameters[i];
;;;2004   
;;;2005               CorrectVignetting(grayscaleImage, polynomialParameters);
;;;2006   
;;;2007               EndBenchmark("VisionSystem_CameraImagingPipeline_Vignetting");
;;;2008             } // if(vignettingCorrection == VignettingCorrection_Software)
;;;2009   
;;;2010             if(autoExposure_enabled && (frameNumber % autoExposure_adjustEveryNFrames) == 0) {
;;;2011               BeginBenchmark("VisionSystem_CameraImagingPipeline_AutoExposure");
;;;2012   
;;;2013               ComputeBestCameraParameters(
;;;2014                 grayscaleImage,
;;;2015                 Rectangle<s32>(0, grayscaleImage.get_size(1)-1, 0, grayscaleImage.get_size(0)-1),
;;;2016                 autoExposure_integerCountsIncrement,
;;;2017                 autoExposure_highValue,
;;;2018                 autoExposure_percentileToMakeHigh,
;;;2019                 autoExposure_minExposureTime, autoExposure_maxExposureTime,
;;;2020                 autoExposure_tooHighPercentMultiplier,
;;;2021                 exposureTime,
;;;2022                 VisionMemory::ccmScratch_);
;;;2023   
;;;2024               EndBenchmark("VisionSystem_CameraImagingPipeline_AutoExposure");
;;;2025             }
;;;2026   
;;;2027             HAL::CameraSetParameters(exposureTime, vignettingCorrection == VignettingCorrection_CameraHardware);
;;;2028   
;;;2029             EndBenchmark("VisionSystem_CameraImagingPipeline");
;;;2030   
;;;2031             DownsampleAndSendImage(grayscaleImage);
;;;2032   
;;;2033             if((lastResult = LookForMarkers(grayscaleImage,
;;;2034               detectionParameters_,
;;;2035               VisionMemory::markers_,
;;;2036               VisionMemory::ccmScratch_,
;;;2037               VisionMemory::onchipScratch_,
;;;2038               VisionMemory::offchipScratch_)) != RESULT_OK)
;;;2039             {
;;;2040               return lastResult;
;;;2041             }
;;;2042   
;;;2043             const s32 numMarkers = VisionMemory::markers_.get_size();
;;;2044             bool isTrackingMarkerFound = false;
;;;2045             for(s32 i_marker = 0; i_marker < numMarkers; ++i_marker)
;;;2046             {
;;;2047               const VisionMarker& crntMarker = VisionMemory::markers_[i_marker];
;;;2048   
;;;2049               if (!Localization::IsOnRamp() && !IMUFilter::IsPickedUp()) {
;;;2050                 // Create a vision marker message and process it (which just queues it
;;;2051                 // in the mailbox to be picked up and sent out by main execution)
;;;2052                 {
;;;2053                   Messages::VisionMarker msg;
;;;2054                   msg.timestamp  = imageTimeStamp;
;;;2055                   msg.markerType = crntMarker.markerType;
;;;2056   
;;;2057                   msg.x_imgLowerLeft = crntMarker.corners[Quadrilateral<f32>::BottomLeft].x;
;;;2058                   msg.y_imgLowerLeft = crntMarker.corners[Quadrilateral<f32>::BottomLeft].y;
;;;2059   
;;;2060                   msg.x_imgUpperLeft = crntMarker.corners[Quadrilateral<f32>::TopLeft].x;
;;;2061                   msg.y_imgUpperLeft = crntMarker.corners[Quadrilateral<f32>::TopLeft].y;
;;;2062   
;;;2063                   msg.x_imgUpperRight = crntMarker.corners[Quadrilateral<f32>::TopRight].x;
;;;2064                   msg.y_imgUpperRight = crntMarker.corners[Quadrilateral<f32>::TopRight].y;
;;;2065   
;;;2066                   msg.x_imgLowerRight = crntMarker.corners[Quadrilateral<f32>::BottomRight].x;
;;;2067                   msg.y_imgLowerRight = crntMarker.corners[Quadrilateral<f32>::BottomRight].y;
;;;2068   
;;;2069                   HAL::RadioSendMessage(GET_MESSAGE_ID(Messages::VisionMarker),&msg);
;;;2070                 }
;;;2071               }
;;;2072   
;;;2073               // Was the desired marker found? If so, start tracking it.
;;;2074               if(markerToTrack_.IsSpecified() && !isTrackingMarkerFound &&
;;;2075                 markerToTrack_.Matches(crntMarker))
;;;2076               {
;;;2077                 // We will start tracking the _first_ marker of the right type that
;;;2078                 // we see.
;;;2079                 // TODO: Something smarter to track the one closest to the image center or to the expected location provided by the basestation?
;;;2080                 isTrackingMarkerFound = true;
;;;2081   
;;;2082                 // I'd rather only initialize trackingQuad_ if InitTemplate() succeeds, but
;;;2083                 // InitTemplate downsamples it for the time being, since we're still doing template
;;;2084                 // initialization at tracking resolution instead of the eventual goal of doing it at
;;;2085                 // full detection resolution.
;;;2086                 trackingQuad_ = crntMarker.corners;
;;;2087   
;;;2088                 // Normalize the image
;;;2089                 // NOTE: This will change grayscaleImage!
;;;2090                 if(trackerParameters_.normalizationFilterWidthFraction < 0.f) {
;;;2091                   // Faster: normalize using mean of quad
;;;2092                   lastResult = BrightnessNormalizeImage(grayscaleImage, trackingQuad_);
;;;2093                 } else {
;;;2094                   // Slower: normalize using local averages
;;;2095                   // NOTE: This is currently off-chip for memory reasons, so it's slow!
;;;2096                   lastResult = BrightnessNormalizeImage(grayscaleImage, trackingQuad_,
;;;2097                                                         trackerParameters_.normalizationFilterWidthFraction,
;;;2098                                                         VisionMemory::offchipScratch_);
;;;2099                 }
;;;2100                 
;;;2101                 AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK, lastResult,
;;;2102                                                    "VisionSystem::Update::BrightnessNormalizeImage",
;;;2103                                                    "BrightnessNormalizeImage failed.\n");
;;;2104                 
;;;2105                 if((lastResult = InitTemplate(grayscaleImage,
;;;2106                   trackingQuad_,
;;;2107                   trackerParameters_,
;;;2108                   tracker_,
;;;2109                   VisionMemory::ccmScratch_,
;;;2110                   VisionMemory::onchipScratch_, //< NOTE: onchip is a reference
;;;2111                   VisionMemory::offchipScratch_)) != RESULT_OK)
;;;2112                 {
;;;2113                   return lastResult;
;;;2114                 }
;;;2115   
;;;2116                 // Template initialization succeeded, switch to tracking mode:
;;;2117                 // TODO: Log or issue message?
;;;2118                 mode_ = VISION_MODE_TRACKING;
;;;2119               } // if(isTrackingMarkerSpecified && !isTrackingMarkerFound && markerType == markerToTrack)
;;;2120             } // for(each marker)
;;;2121           } else if(mode_ == VISION_MODE_TRACKING) {
;;;2122             Simulator::SetTrackingReadyTime(); // no-op on real hardware
;;;2123   
;;;2124             //
;;;2125             // Capture image for tracking
;;;2126             //
;;;2127   
;;;2128             MemoryStack offchipScratch_local(VisionMemory::offchipScratch_);
;;;2129             MemoryStack onchipScratch_local(VisionMemory::onchipScratch_);
;;;2130   
;;;2131             const s32 captureHeight = CameraModeInfo[captureResolution_].height;
;;;2132             const s32 captureWidth  = CameraModeInfo[captureResolution_].width;
;;;2133   
;;;2134             Array<u8> grayscaleImage(captureHeight, captureWidth,
;;;2135               onchipScratch_local, Flags::Buffer(false,false,false));
;;;2136   
;;;2137             HAL::CameraGetFrame(reinterpret_cast<u8*>(grayscaleImage.get_buffer()),
;;;2138               captureResolution_, false);
;;;2139             
;;;2140             if((lastResult = TakeSnapshotHelper(grayscaleImage)) != RESULT_OK) {
;;;2141               PRINT("VisionSystem::Update(): TakeSnapshotHelper() failed.\n");
;;;2142               return lastResult;
;;;2143             }
;;;2144   
;;;2145             BeginBenchmark("VisionSystem_CameraImagingPipeline");
;;;2146   
;;;2147             if(vignettingCorrection == VignettingCorrection_Software) {
;;;2148               BeginBenchmark("VisionSystem_CameraImagingPipeline_Vignetting");
;;;2149   
;;;2150               MemoryStack onchipScratch_local = VisionMemory::onchipScratch_;
;;;2151               FixedLengthList<f32> polynomialParameters(5, onchipScratch_local, Flags::Buffer(false, false, true));
;;;2152   
;;;2153               for(s32 i=0; i<5; i++)
;;;2154                 polynomialParameters[i] = vignettingCorrectionParameters[i];
;;;2155   
;;;2156               CorrectVignetting(grayscaleImage, polynomialParameters);
;;;2157   
;;;2158               EndBenchmark("VisionSystem_CameraImagingPipeline_Vignetting");
;;;2159             } // if(vignettingCorrection == VignettingCorrection_Software)
;;;2160   
;;;2161             // TODO: allow tracking to work with exposure changes
;;;2162             /*if(autoExposure_enabled && (frameNumber % autoExposure_adjustEveryNFrames) == 0) {
;;;2163             BeginBenchmark("VisionSystem_CameraImagingPipeline_AutoExposure");
;;;2164   
;;;2165             ComputeBestCameraParameters(
;;;2166             grayscaleImage,
;;;2167             Rectangle<s32>(0, grayscaleImage.get_size(1)-1, 0, grayscaleImage.get_size(0)-1),
;;;2168             autoExposure_integerCountsIncrement,
;;;2169             autoExposure_highValue,
;;;2170             autoExposure_percentileToMakeHigh,
;;;2171             autoExposure_minExposureTime, autoExposure_maxExposureTime,
;;;2172             autoExposure_tooHighPercentMultiplier,
;;;2173             exposureTime,
;;;2174             VisionMemory::ccmScratch_);
;;;2175   
;;;2176             EndBenchmark("VisionSystem_CameraImagingPipeline_AutoExposure");
;;;2177             }*/
;;;2178   
;;;2179             EndBenchmark("VisionSystem_CameraImagingPipeline");
;;;2180   
;;;2181             HAL::CameraSetParameters(exposureTime, vignettingCorrection == VignettingCorrection_CameraHardware);
;;;2182   
;;;2183             DownsampleAndSendImage(grayscaleImage);
;;;2184             
;;;2185             // Normalize the image
;;;2186             // NOTE: This will change grayscaleImage!
;;;2187             if(trackerParameters_.normalizationFilterWidthFraction < 0.f) {
;;;2188               // Faster: normalize using mean of quad
;;;2189               lastResult = BrightnessNormalizeImage(grayscaleImage, trackingQuad_);
;;;2190             } else {
;;;2191               // Slower: normalize using local averages
;;;2192               // NOTE: This is currently off-chip for memory reasons, so it's slow!
;;;2193               lastResult = BrightnessNormalizeImage(grayscaleImage, trackingQuad_,
;;;2194                                                     trackerParameters_.normalizationFilterWidthFraction,
;;;2195                                                     VisionMemory::offchipScratch_);
;;;2196             }
;;;2197             
;;;2198             AnkiConditionalErrorAndReturnValue(lastResult == RESULT_OK, lastResult,
;;;2199                                                "VisionSystem::Update::BrightnessNormalizeImage",
;;;2200                                                "BrightnessNormalizeImage failed.\n");
;;;2201   
;;;2202             //
;;;2203             // Tracker Prediction
;;;2204             //
;;;2205             // Adjust the tracker transformation by approximately how much we
;;;2206             // think we've moved since the last tracking call.
;;;2207             //
;;;2208   
;;;2209             if((lastResult =TrackerPredictionUpdate(grayscaleImage, onchipScratch_local)) != RESULT_OK) {
;;;2210               PRINT("VisionSystem::Update(): TrackTemplate() failed.\n");
;;;2211               return lastResult;
;;;2212             }
;;;2213   
;;;2214             //
;;;2215             // Update the tracker transformation using this image
;;;2216             //
;;;2217   
;;;2218             // Set by TrackTemplate() call
;;;2219             bool converged = false;
;;;2220   
;;;2221             if((lastResult = TrackTemplate(grayscaleImage,
;;;2222               trackingQuad_,
;;;2223               trackerParameters_,
;;;2224               tracker_,
;;;2225               converged,
;;;2226               VisionMemory::ccmScratch_,
;;;2227               onchipScratch_local,
;;;2228               offchipScratch_local)) != RESULT_OK) {
;;;2229                 PRINT("VisionSystem::Update(): TrackTemplate() failed.\n");
;;;2230                 return lastResult;
;;;2231             }
;;;2232   
;;;2233             //
;;;2234             // Create docking error signal from tracker
;;;2235             //
;;;2236   
;;;2237             Messages::DockingErrorSignal dockErrMsg;
;;;2238             dockErrMsg.timestamp = imageTimeStamp;
;;;2239             dockErrMsg.didTrackingSucceed = static_cast<u8>(converged);
;;;2240   
;;;2241             if(converged)
;;;2242             {
;;;2243               Quadrilateral<f32> currentQuad = GetTrackerQuad(VisionMemory::onchipScratch_);
;;;2244               FillDockErrMsg(currentQuad, dockErrMsg, VisionMemory::onchipScratch_);
;;;2245               
;;;2246               // Send tracker quad if image streaming
;;;2247               if (imageSendMode_ == ISM_STREAM) {
;;;2248                 f32 scale = 1.f;
;;;2249                 for (u8 s = (u8)Vision::CAMERA_RES_QVGA; s<(u8)nextSendImageResolution_; ++s) {
;;;2250                   scale *= 0.5f;
;;;2251                 }
;;;2252                 
;;;2253                 Messages::TrackerQuad m;
;;;2254                 m.topLeft_x = static_cast<u16>(currentQuad[Quadrilateral<f32>::TopLeft].x * scale);
;;;2255                 m.topLeft_y = static_cast<u16>(currentQuad[Quadrilateral<f32>::TopLeft].y * scale);
;;;2256                 m.topRight_x = static_cast<u16>(currentQuad[Quadrilateral<f32>::TopRight].x * scale);
;;;2257                 m.topRight_y = static_cast<u16>(currentQuad[Quadrilateral<f32>::TopRight].y * scale);
;;;2258                 m.bottomRight_x = static_cast<u16>(currentQuad[Quadrilateral<f32>::BottomRight].x * scale);
;;;2259                 m.bottomRight_y = static_cast<u16>(currentQuad[Quadrilateral<f32>::BottomRight].y * scale);
;;;2260                 m.bottomLeft_x = static_cast<u16>(currentQuad[Quadrilateral<f32>::BottomLeft].x * scale);
;;;2261                 m.bottomLeft_y = static_cast<u16>(currentQuad[Quadrilateral<f32>::BottomLeft].y * scale);
;;;2262                 
;;;2263                 HAL::RadioSendMessage(GET_MESSAGE_ID(Messages::TrackerQuad), &m);
;;;2264               }
;;;2265   
;;;2266               // Reset the failure counter
;;;2267               numTrackFailures_ = 0;
;;;2268             }
;;;2269             else {
;;;2270               numTrackFailures_ += 1;
;;;2271   
;;;2272               if(numTrackFailures_ == MAX_TRACKING_FAILURES) {
;;;2273                 // This resets docking, puttings us back in VISION_MODE_LOOKING_FOR_MARKERS mode
;;;2274                 SetMarkerToTrack(markerToTrack_.type,
;;;2275                   markerToTrack_.width_mm,
;;;2276                   markerToTrack_.imageCenter,
;;;2277                   markerToTrack_.imageSearchRadius,
;;;2278                   markerToTrack_.checkAngleX);
;;;2279               }
;;;2280             }
;;;2281   
;;;2282             Messages::ProcessDockingErrorSignalMessage(dockErrMsg);
;;;2283             
;;;2284           } else if(mode_ == VISION_MODE_DETECTING_FACES) {
;;;2285             Simulator::SetFaceDetectionReadyTime();
;;;2286             
;;;2287             VisionMemory::ResetBuffers();
;;;2288             
;;;2289             AnkiConditionalErrorAndReturnValue(faceDetectionParameters_.isInitialized, RESULT_FAIL,
;;;2290                                                "VisionSystem::Update::FaceDetectionParametersNotInitialized",
;;;2291                                                "Face detection parameters not initialized before Update() in DETECTING_FACES mode.\n");
;;;2292             
;;;2293             const s32 captureHeight = CameraModeInfo[captureResolution_].height;
;;;2294             const s32 captureWidth  = CameraModeInfo[captureResolution_].width;
;;;2295             
;;;2296             Array<u8> grayscaleImage(captureHeight, captureWidth,
;;;2297                                      VisionMemory::offchipScratch_, Flags::Buffer(false,false,false));
;;;2298             
;;;2299             HAL::CameraGetFrame(reinterpret_cast<u8*>(grayscaleImage.get_buffer()),
;;;2300                                 captureResolution_, false);
;;;2301             
;;;2302             BeginBenchmark("VisionSystem_CameraImagingPipeline");
;;;2303             
;;;2304             if(vignettingCorrection == VignettingCorrection_Software) {
;;;2305               BeginBenchmark("VisionSystem_CameraImagingPipeline_Vignetting");
;;;2306               
;;;2307               MemoryStack onchipScratch_local = VisionMemory::onchipScratch_;
;;;2308               FixedLengthList<f32> polynomialParameters(5, onchipScratch_local, Flags::Buffer(false, false, true));
;;;2309               
;;;2310               for(s32 i=0; i<5; i++)
;;;2311                 polynomialParameters[i] = vignettingCorrectionParameters[i];
;;;2312               
;;;2313               CorrectVignetting(grayscaleImage, polynomialParameters);
;;;2314               
;;;2315               EndBenchmark("VisionSystem_CameraImagingPipeline_Vignetting");
;;;2316             } // if(vignettingCorrection == VignettingCorrection_Software)
;;;2317             
;;;2318             if(autoExposure_enabled && (frameNumber % autoExposure_adjustEveryNFrames) == 0) {
;;;2319               BeginBenchmark("VisionSystem_CameraImagingPipeline_AutoExposure");
;;;2320               
;;;2321               ComputeBestCameraParameters(
;;;2322                                           grayscaleImage,
;;;2323                                           Rectangle<s32>(0, grayscaleImage.get_size(1)-1, 0, grayscaleImage.get_size(0)-1),
;;;2324                                           autoExposure_integerCountsIncrement,
;;;2325                                           autoExposure_highValue,
;;;2326                                           autoExposure_percentileToMakeHigh,
;;;2327                                           autoExposure_minExposureTime, autoExposure_maxExposureTime,
;;;2328                                           autoExposure_tooHighPercentMultiplier,
;;;2329                                           exposureTime,
;;;2330                                           VisionMemory::ccmScratch_);
;;;2331               
;;;2332               EndBenchmark("VisionSystem_CameraImagingPipeline_AutoExposure");
;;;2333             }
;;;2334             
;;;2335             HAL::CameraSetParameters(exposureTime, vignettingCorrection == VignettingCorrection_CameraHardware);
;;;2336             
;;;2337             EndBenchmark("VisionSystem_CameraImagingPipeline");
;;;2338             
;;;2339             Array<u8> smallImage(
;;;2340                                  faceDetectionParameters_.faceDetectionHeight,
;;;2341                                  faceDetectionParameters_.faceDetectionWidth,
;;;2342                                  VisionMemory::onchipScratch_, Flags::Buffer(false,false,false));
;;;2343             
;;;2344             DownsampleHelper(grayscaleImage, smallImage, VisionMemory::ccmScratch_);
;;;2345             
;;;2346             DownsampleAndSendImage(smallImage);
;;;2347             
;;;2348             const FixedLengthList<Classifier::CascadeClassifier::Stage> &stages = FixedLengthList<Classifier::CascadeClassifier::Stage>(lbpcascade_frontalface_stages_length, const_cast<Classifier::CascadeClassifier::Stage*>(&lbpcascade_frontalface_stages_data[0]), lbpcascade_frontalface_stages_length*sizeof(Classifier::CascadeClassifier::Stage) + MEMORY_ALIGNMENT_RAW, Flags::Buffer(false,false,true));
;;;2349             const FixedLengthList<Classifier::CascadeClassifier::DTree> &classifiers = FixedLengthList<Classifier::CascadeClassifier::DTree>(lbpcascade_frontalface_classifiers_length, const_cast<Classifier::CascadeClassifier::DTree*>(&lbpcascade_frontalface_classifiers_data[0]), lbpcascade_frontalface_classifiers_length*sizeof(Classifier::CascadeClassifier::DTree) + MEMORY_ALIGNMENT_RAW, Flags::Buffer(false,false,true));
;;;2350             const FixedLengthList<Classifier::CascadeClassifier::DTreeNode> &nodes =  FixedLengthList<Classifier::CascadeClassifier::DTreeNode>(lbpcascade_frontalface_nodes_length, const_cast<Classifier::CascadeClassifier::DTreeNode*>(&lbpcascade_frontalface_nodes_data[0]), lbpcascade_frontalface_nodes_length*sizeof(Classifier::CascadeClassifier::DTreeNode) + MEMORY_ALIGNMENT_RAW, Flags::Buffer(false,false,true));;
;;;2351             const FixedLengthList<f32> &leaves = FixedLengthList<f32>(lbpcascade_frontalface_leaves_length, const_cast<f32*>(&lbpcascade_frontalface_leaves_data[0]), lbpcascade_frontalface_leaves_length*sizeof(f32) + MEMORY_ALIGNMENT_RAW, Flags::Buffer(false,false,true));
;;;2352             const FixedLengthList<s32> &subsets = FixedLengthList<s32>(lbpcascade_frontalface_subsets_length, const_cast<s32*>(&lbpcascade_frontalface_subsets_data[0]), lbpcascade_frontalface_subsets_length*sizeof(s32) + MEMORY_ALIGNMENT_RAW, Flags::Buffer(false,false,true));
;;;2353             const FixedLengthList<Rectangle<s32> > &featureRectangles = FixedLengthList<Rectangle<s32> >(lbpcascade_frontalface_featureRectangles_length, const_cast<Rectangle<s32>*>(reinterpret_cast<const Rectangle<s32>*>(&lbpcascade_frontalface_featureRectangles_data[0])), lbpcascade_frontalface_featureRectangles_length*sizeof(Rectangle<s32>) + MEMORY_ALIGNMENT_RAW, Flags::Buffer(false,false,true));
;;;2354             
;;;2355             Classifier::CascadeClassifier_LBP cc(
;;;2356                                                  lbpcascade_frontalface_isStumpBased,
;;;2357                                                  lbpcascade_frontalface_stageType,
;;;2358                                                  lbpcascade_frontalface_featureType,
;;;2359                                                  lbpcascade_frontalface_ncategories,
;;;2360                                                  lbpcascade_frontalface_origWinHeight,
;;;2361                                                  lbpcascade_frontalface_origWinWidth,
;;;2362                                                  stages,
;;;2363                                                  classifiers,
;;;2364                                                  nodes,
;;;2365                                                  leaves,
;;;2366                                                  subsets,
;;;2367                                                  featureRectangles,
;;;2368                                                  VisionMemory::ccmScratch_);
;;;2369             
;;;2370             FixedLengthList<Rectangle<s32> > detectedFaces(faceDetectionParameters_.MAX_CANDIDATES, VisionMemory::offchipScratch_);
;;;2371             
;;;2372             lastResult = cc.DetectMultiScale(
;;;2373                                              smallImage,
;;;2374                                              static_cast<f32>(faceDetectionParameters_.scaleFactor),
;;;2375                                              faceDetectionParameters_.minNeighbors,
;;;2376                                              faceDetectionParameters_.minHeight,
;;;2377                                              faceDetectionParameters_.minWidth,
;;;2378                                              faceDetectionParameters_.maxHeight,
;;;2379                                              faceDetectionParameters_.maxWidth,
;;;2380                                              detectedFaces,
;;;2381                                              VisionMemory::onchipScratch_,
;;;2382                                              VisionMemory::offchipScratch_);
;;;2383             
;;;2384             f32 sendScale = 1.f;
;;;2385             if (imageSendMode_ == ISM_STREAM) {
;;;2386               const u8 scaleFactor = (1 << CameraModeInfo[faceDetectionParameters_.detectionResolution].downsamplePower[nextSendImageResolution_]);
;;;2387               
;;;2388               if(scaleFactor > 1) {
;;;2389                 // Send additional downsampled image, marked for visualization
;;;2390                 sendScale /= static_cast<f32>(scaleFactor);
;;;2391               }
;;;2392             }
;;;2393             
;;;2394             const s32 numFaces = detectedFaces.get_size();
;;;2395             for(s32 i_face = 0; i_face < numFaces; ++i_face)
;;;2396             {
;;;2397               Messages::FaceDetection msg;
;;;2398               const Rectangle<s32>& currentFace = detectedFaces[i_face];
;;;2399               msg.width       = static_cast<u16>(currentFace.get_width());
;;;2400               msg.height      = static_cast<u16>(currentFace.get_height());
;;;2401               msg.x_upperLeft = static_cast<u16>(currentFace.left);
;;;2402               msg.y_upperLeft = static_cast<u16>(currentFace.top);
;;;2403               msg.visualize   = static_cast<u8>(false);
;;;2404               
;;;2405               if (imageSendMode_ == ISM_STREAM) {
;;;2406                 
;;;2407                 if(sendScale != 1.f) {
;;;2408                   // Send additional downsampled message, marked for visualization
;;;2409                   Messages::FaceDetection debugMsg;
;;;2410                   debugMsg.x_upperLeft = static_cast<u16>(static_cast<f32>(msg.x_upperLeft) * sendScale);
;;;2411                   debugMsg.y_upperLeft = static_cast<u16>(static_cast<f32>(msg.y_upperLeft) * sendScale);
;;;2412                   debugMsg.width       = static_cast<u16>(static_cast<f32>(msg.width)  * sendScale);
;;;2413                   debugMsg.height      = static_cast<u16>(static_cast<f32>(msg.height) * sendScale);
;;;2414                   debugMsg.visualize   = static_cast<u8>(true);
;;;2415                   
;;;2416                   HAL::RadioSendMessage(GET_MESSAGE_ID(Messages::FaceDetection), &debugMsg);
;;;2417                   
;;;2418                 } else {
;;;2419                   // Send original message, marked for visualization
;;;2420                   msg.visualize = static_cast<u8>(true);
;;;2421                 }
;;;2422               } // if imageSendMode_ == ISM_STREAM
;;;2423               
;;;2424               // Process the face detection message (i.e. drop it off for main
;;;2425               // execution to deal with if we are tracking)
;;;2426               Messages::ProcessFaceDetectionMessage(msg);
;;;2427               
;;;2428               // Also send a copy to the basestation
;;;2429               HAL::RadioSendMessage(GET_MESSAGE_ID(Messages::FaceDetection), &msg);
;;;2430               
;;;2431             } // for each face detection
;;;2432             
;;;2433             DebugStream::SendFaceDetections(
;;;2434                                             grayscaleImage,
;;;2435                                             detectedFaces,
;;;2436                                             smallImage.get_size(1),
;;;2437                                             VisionMemory::ccmScratch_,
;;;2438                                             VisionMemory::onchipScratch_,
;;;2439                                             VisionMemory::offchipScratch_);
;;;2440             
;;;2441           } else {
;;;2442             PRINT("VisionSystem::Update(): reached default case in switch statement.");
;;;2443             return RESULT_FAIL;
;;;2444           } // if(converged)
;;;2445   
;;;2446           return lastResult;
;;;2447         } // Update() [Real]
00011c  ee680a68          VNMUL.F32 s1,s16,s17
000120  ee280a68          VNMUL.F32 s0,s16,s17
000124  a802              ADD      r0,sp,#8
000126  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
00012a  ed900a00          VLDR     s0,[r0,#0]
00012e  46a8              MOV      r8,r5
000130  ed850a00          VSTR     s0,[r5,#0]
000134  ed900a01          VLDR     s0,[r0,#4]
000138  eeb01a49          VMOV.F32 s2,s18
00013c  ed850a01          VSTR     s0,[r5,#4]
000140  ed900a02          VLDR     s0,[r0,#8]
000144  eef00a69          VMOV.F32 s1,s19
000148  ed850a02          VSTR     s0,[r5,#8]
00014c  f108050c          ADD      r5,r8,#0xc
000150  ee280a68          VNMUL.F32 s0,s16,s17
000154  a802              ADD      r0,sp,#8
000156  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
00015a  ed900a00          VLDR     s0,[r0,#0]
00015e  eeb01a49          VMOV.F32 s2,s18
000162  ed850a00          VSTR     s0,[r5,#0]
000166  ed900a01          VLDR     s0,[r0,#4]
00016a  ee680a68          VNMUL.F32 s1,s16,s17
00016e  ed850a01          VSTR     s0,[r5,#4]
000172  ed900a02          VLDR     s0,[r0,#8]
000176  a802              ADD      r0,sp,#8
000178  ed850a02          VSTR     s0,[r5,#8]
00017c  350c              ADDS     r5,r5,#0xc
00017e  eeb00a69          VMOV.F32 s0,s19
000182  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
000186  ed900a00          VLDR     s0,[r0,#0]
00018a  eeb01a49          VMOV.F32 s2,s18
00018e  ed850a00          VSTR     s0,[r5,#0]
000192  ed900a01          VLDR     s0,[r0,#4]
000196  eef00a69          VMOV.F32 s1,s19
00019a  ed850a01          VSTR     s0,[r5,#4]
00019e  ed900a02          VLDR     s0,[r0,#8]
0001a2  ed850a02          VSTR     s0,[r5,#8]
0001a6  e000              B        |L28.426|
                  |L28.424|
0001a8  e015              B        |L28.470|
                  |L28.426|
0001aa  eeb00a69          VMOV.F32 s0,s19
0001ae  a802              ADD      r0,sp,#8
0001b0  f7fffffe          BL       _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
0001b4  ed900a00          VLDR     s0,[r0,#0]
0001b8  ed880a09          VSTR     s0,[r8,#0x24]
0001bc  ed900a01          VLDR     s0,[r0,#4]
0001c0  ed880a0a          VSTR     s0,[r8,#0x28]
0001c4  ed900a02          VLDR     s0,[r0,#8]
0001c8  ed880a0b          VSTR     s0,[r8,#0x2c]
                  |L28.460|
0001cc  4891              LDR      r0,|L28.1044|
0001ce  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754713MarkerToTrack5ClearEv ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
0001d2  f8894003          STRB     r4,[r9,#3]
                  |L28.470|
0001d6  f04f0800          MOV      r8,#0
                  |L28.474|
0001da  f1b80f00          CMP      r8,#0                 ;1941
0001de  d00c              BEQ      |L28.506|
0001e0  f2407195          MOV      r1,#0x795             ;1941
0001e4  48a8              LDR      r0,|L28.1160|
0001e6  e9cd0100          STRD     r0,r1,[sp,#0]         ;1941
0001ea  a38d              ADR      r3,|L28.1056|
0001ec  a2a7              ADR      r2,|L28.1164|
0001ee  a1af              ADR      r1,|L28.1196|
0001f0  2005              MOVS     r0,#5                 ;1941
0001f2  f7fffffe          BL       _Anki_Log
0001f6  f000bda9          B.W      |L28.3404|
                  |L28.506|
0001fa  98f8              LDR      r0,[sp,#0x3e0]        ;1951
0001fc  90a6              STR      r0,[sp,#0x298]        ;1953
0001fe  f8990008          LDRB     r0,[r9,#8]            ;1953  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff75475mode_E
000202  4db0              LDR      r5,|L28.1220|
000204  b188              CBZ      r0,|L28.554|
000206  f1a50814          SUB      r8,r5,#0x14           ;2003
00020a  2801              CMP      r0,#1                 ;1973
00020c  d041              BEQ      |L28.658|
00020e  eeb78a00          VMOV.F32 s16,#1.00000000       ;2248
000212  2802              CMP      r0,#2                 ;2121
000214  f00084cb          BEQ.W    |L28.2990|
000218  2803              CMP      r0,#3                 ;2284
00021a  f0008664          BEQ.W    |L28.3814|
00021e  f20570c4          ADD      r0,r5,#0x7c4          ;2442
000222  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
000226  f000be96          B.W      |L28.3926|
                  |L28.554|
00022a  f899000c          LDRB     r0,[r9,#0xc]          ;1956  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754720isWaitingOnSnapshot_E
00022e  2800              CMP      r0,#0                 ;1956
000230  f000858c          BEQ.W    |L28.3404|
000234  f899000b          LDRB     r0,[r9,#0xb]          ;1957  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718captureResolution_E
000238  2300              MOVS     r3,#0                 ;1960
00023a  eb000040          ADD      r0,r0,r0,LSL #1       ;1957
00023e  eb050080          ADD      r0,r5,r0,LSL #2       ;1957
000242  461a              MOV      r2,r3                 ;1960
000244  8884              LDRH     r4,[r0,#4]            ;1957
000246  8845              LDRH     r5,[r0,#2]            ;1958
000248  4619              MOV      r1,r3                 ;1960
00024a  a806              ADD      r0,sp,#0x18           ;1960
00024c  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000250  6800              LDR      r0,[r0,#0]            ;1960
000252  9000              STR      r0,[sp,#0]            ;1960
000254  4b6e              LDR      r3,|L28.1040|
000256  462a              MOV      r2,r5                 ;1960
000258  4621              MOV      r1,r4                 ;1960
00025a  a801              ADD      r0,sp,#4              ;1960
00025c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000260  2200              MOVS     r2,#0                 ;1963
000262  f899100b          LDRB     r1,[r9,#0xb]          ;1963  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718captureResolution_E
000266  9805              LDR      r0,[sp,#0x14]         ;1963
000268  f7fffffe          BL       _ZN4Anki5Cozmo3HAL14CameraGetFrameEPhNS_6Vision16CameraResolutionEb ; Anki::Cozmo::HAL::CameraGetFrame(unsigned char*, Anki::Vision::CameraResolution, bool)
00026c  a801              ADD      r0,sp,#4              ;1966
00026e  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem18TakeSnapshotHelperERKNS_8Embedded5ArrayIhEE ; Anki::Cozmo::VisionSystem::TakeSnapshotHelper(const Anki::Embedded::Array<unsigned char>&)
000272  ea5f0800          MOVS     r8,r0                 ;1966
000276  f0008569          BEQ.W    |L28.3404|
00027a  a093              ADR      r0,|L28.1224|
00027c  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
000280  4640              MOV      r0,r8                 ;1968
                  |L28.642|
000282  f50d7d6b          ADD      sp,sp,#0x3ac
000286  ecbd8b04          VPOP     {d8-d9}
00028a  e8bd0ff0          POP      {r4-r11}
00028e  f85dfb14          LDR      pc,[sp],#0x14
                  |L28.658|
000292  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv ; Anki::Cozmo::VisionSystem::VisionMemory::ResetBuffers()
000296  f899000b          LDRB     r0,[r9,#0xb]          ;1980  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718captureResolution_E
00029a  2300              MOVS     r3,#0                 ;1983
00029c  eb000040          ADD      r0,r0,r0,LSL #1       ;1980
0002a0  eb050080          ADD      r0,r5,r0,LSL #2       ;1980
0002a4  461a              MOV      r2,r3                 ;1983
0002a6  8886              LDRH     r6,[r0,#4]            ;1980
0002a8  8845              LDRH     r5,[r0,#2]            ;1981
0002aa  4619              MOV      r1,r3                 ;1983
0002ac  a8a7              ADD      r0,sp,#0x29c          ;1983
0002ae  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0002b2  6800              LDR      r0,[r0,#0]            ;1983
0002b4  9000              STR      r0,[sp,#0]            ;1983
0002b6  4b56              LDR      r3,|L28.1040|
0002b8  462a              MOV      r2,r5                 ;1983
0002ba  4631              MOV      r1,r6                 ;1983
0002bc  a876              ADD      r0,sp,#0x1d8          ;1983
0002be  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0002c2  2200              MOVS     r2,#0                 ;1986
0002c4  f899100b          LDRB     r1,[r9,#0xb]          ;1986  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718captureResolution_E
0002c8  987a              LDR      r0,[sp,#0x1e8]        ;1986
0002ca  f7fffffe          BL       _ZN4Anki5Cozmo3HAL14CameraGetFrameEPhNS_6Vision16CameraResolutionEb ; Anki::Cozmo::HAL::CameraGetFrame(unsigned char*, Anki::Vision::CameraResolution, bool)
0002ce  a876              ADD      r0,sp,#0x1d8          ;1989
0002d0  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem18TakeSnapshotHelperERKNS_8Embedded5ArrayIhEE ; Anki::Cozmo::VisionSystem::TakeSnapshotHelper(const Anki::Embedded::Array<unsigned char>&)
0002d4  0005              MOVS     r5,r0                 ;1989
0002d6  f0408494          BNE.W    |L28.3074|
0002da  a089              ADR      r0,|L28.1280|
0002dc  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
0002e0  f8990001          LDRB     r0,[r9,#1]            ;1996  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754720vignettingCorrectionE
0002e4  2802              CMP      r0,#2                 ;1996
0002e6  d126              BNE      |L28.822|
0002e8  a08e              ADR      r0,|L28.1316|
0002ea  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
0002ee  4999              LDR      r1,|L28.1364|
0002f0  a80d              ADD      r0,sp,#0x34           ;1999
0002f2  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0002f6  2200              MOVS     r2,#0                 ;2000
0002f8  2301              MOVS     r3,#1                 ;2000
0002fa  4611              MOV      r1,r2                 ;2000
0002fc  a814              ADD      r0,sp,#0x50           ;2000
0002fe  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000302  6803              LDR      r3,[r0,#0]            ;2000
000304  aa0d              ADD      r2,sp,#0x34           ;2000
000306  2105              MOVS     r1,#5                 ;2000
000308  4668              MOV      r0,sp                 ;2000
00030a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIfEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<float>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
00030e  2000              MOVS     r0,#0                 ;2002
                  |L28.784|
000310  990c              LDR      r1,[sp,#0x30]         ;2002
000312  eb080280          ADD      r2,r8,r0,LSL #2       ;2003
000316  eb010180          ADD      r1,r1,r0,LSL #2       ;2003
00031a  ed920a00          VLDR     s0,[r2,#0]            ;2003
00031e  1c40              ADDS     r0,r0,#1              ;2002
000320  ed810a00          VSTR     s0,[r1,#0]            ;2003
000324  2805              CMP      r0,#5                 ;2002
000326  dbf3              BLT      |L28.784|
000328  4669              MOV      r1,sp                 ;2005
00032a  a876              ADD      r0,sp,#0x1d8          ;2005
00032c  f7fffffe          BL       _ZN4Anki8Embedded17CorrectVignettingERNS0_5ArrayIhEERKNS0_15FixedLengthListIfEE ; Anki::Embedded::CorrectVignetting(Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::FixedLengthList<float>&)
000330  a07c              ADR      r0,|L28.1316|
000332  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
                  |L28.822|
000336  f8d91024          LDR      r1,[r9,#0x24]         ;2010  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754731autoExposure_adjustEveryNFramesE
00033a  f8d90038          LDR      r0,[r9,#0x38]         ;2010  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754711frameNumberE
00033e  fb90f2f1          SDIV     r2,r0,r1              ;2010
000342  fb010012          MLS      r0,r1,r2,r0           ;2010
000346  2800              CMP      r0,#0                 ;2010
000348  d131              BNE      |L28.942|
00034a  a083              ADR      r0,|L28.1368|
00034c  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
000350  498d              LDR      r1,|L28.1416|
000352  a806              ADD      r0,sp,#0x18           ;2013
000354  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000358  9000              STR      r0,[sp,#0]            ;2013
00035a  ad02              ADD      r5,sp,#8              ;2013
00035c  f04f0a00          MOV      r10,#0                ;2013
000360  2101              MOVS     r1,#1                 ;2013
000362  a876              ADD      r0,sp,#0x1d8          ;2013
000364  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000368  f1a00801          SUB      r8,r0,#1              ;2013
00036c  2600              MOVS     r6,#0                 ;2013
00036e  4631              MOV      r1,r6                 ;2013
000370  a876              ADD      r0,sp,#0x1d8          ;2013
000372  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000376  1e40              SUBS     r0,r0,#1              ;2013
000378  e9cd6004          STRD     r6,r0,[sp,#0x10]      ;2013
00037c  9a00              LDR      r2,[sp,#0]            ;2013
00037e  4883              LDR      r0,|L28.1420|
000380  e9cd0200          STRD     r0,r2,[sp,#0]         ;2013
000384  e9cda802          STRD     r10,r8,[sp,#8]        ;2013
000388  edd91a08          VLDR     s3,[r9,#0x20]         ;2013
00038c  ed991a06          VLDR     s2,[r9,#0x18]         ;2013
000390  edd90a05          VLDR     s1,[r9,#0x14]         ;2013
000394  ed990a07          VLDR     s0,[r9,#0x1c]         ;2013
000398  f8993002          LDRB     r3,[r9,#2]            ;2013  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754722autoExposure_highValueE
00039c  4629              MOV      r1,r5                 ;2013
00039e  a876              ADD      r0,sp,#0x1d8          ;2013
0003a0  f8d92010          LDR      r2,[r9,#0x10]         ;2013  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754735autoExposure_integerCountsIncrementE
0003a4  f7fffffe          BL       _ZN4Anki8Embedded27ComputeBestCameraParametersERKNS0_5ArrayIhEERKNS0_9RectangleIiEEihffffRfNS0_11MemoryStackE ; Anki::Embedded::ComputeBestCameraParameters(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Rectangle<int>&, int, unsigned char, float, float, float, float, float&, Anki::Embedded::MemoryStack)
0003a8  a06b              ADR      r0,|L28.1368|
0003aa  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
                  |L28.942|
0003ae  f8990001          LDRB     r0,[r9,#1]            ;2027  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754720vignettingCorrectionE
0003b2  2801              CMP      r0,#1                 ;2027
0003b4  bf18              IT       NE                    ;2027
0003b6  2000              MOVNE    r0,#0                 ;2027
0003b8  ed990a0d          VLDR     s0,[r9,#0x34]         ;2027
0003bc  f7fffffe          BL       _ZN4Anki5Cozmo3HAL19CameraSetParametersEfb ; Anki::Cozmo::HAL::CameraSetParameters(float, bool)
0003c0  a04f              ADR      r0,|L28.1280|
0003c2  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
0003c6  a876              ADD      r0,sp,#0x1d8          ;2031
0003c8  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem22DownsampleAndSendImageERKNS_8Embedded5ArrayIhEE ; Anki::Cozmo::VisionSystem::DownsampleAndSendImage(const Anki::Embedded::Array<unsigned char>&)
0003cc  4910              LDR      r1,|L28.1040|
0003ce  a890              ADD      r0,sp,#0x240          ;2033
0003d0  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0003d4  4606              MOV      r6,r0                 ;2033
0003d6  495f              LDR      r1,|L28.1364|
0003d8  a889              ADD      r0,sp,#0x224          ;2033
0003da  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0003de  4605              MOV      r5,r0                 ;2033
0003e0  4969              LDR      r1,|L28.1416|
0003e2  a882              ADD      r0,sp,#0x208          ;2033
0003e4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0003e8  4a69              LDR      r2,|L28.1424|
0003ea  e9cd5600          STRD     r5,r6,[sp,#0]         ;2033
0003ee  4603              MOV      r3,r0                 ;2033
0003f0  f502713c          ADD      r1,r2,#0x2f0          ;2033
0003f4  a876              ADD      r0,sp,#0x1d8          ;2033
0003f6  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem14LookForMarkersERKNS_8Embedded5ArrayIhEERKNS1_31DetectFiducialMarkersParametersERNS2_15FixedLengthListINS2_12VisionMarkerEEENS2_11MemoryStackESE_SE_ ; Anki::Cozmo::VisionSystem::LookForMarkers(const Anki::Embedded::Array<unsigned char>&, const Anki::Cozmo::VisionSystem::DetectFiducialMarkersParameters&, Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
0003fa  ea5f0800          MOVS     r8,r0                 ;2033
0003fe  f47faf40          BNE      |L28.642|
000402  2600              MOVS     r6,#0                 ;2044
000404  4862              LDR      r0,|L28.1424|
000406  4635              MOV      r5,r6                 ;2045
000408  e0c4              B        |L28.1428|
00040a  0000              DCW      0x0000
                  |L28.1036|
                          DCD      ||.data||
                  |L28.1040|
                          DCD      ||.bss||
                  |L28.1044|
                          DCD      ||.bss||+0xb4
                  |L28.1048|
000418  00000000          DCFS     0x00000000 ; 0
                  |L28.1052|
                          DCD      ||.constdata||+0x2d2c
                  |L28.1056|
000420  73757065          DCB      "supervisor\\src\\visionSystem.cpp",0
000424  72766973
000428  6f725c73
00042c  72635c76
000430  6973696f
000434  6e537973
000438  74656d2e
00043c  63707000
                  |L28.1088|
000440  496e7661          DCB      "Invalid marker width specified.",0
000444  6c696420
000448  6d61726b
00044c  65722077
000450  69647468
000454  20737065
000458  63696669
00045c  65642e00
                  |L28.1120|
000460  56697369          DCB      "VisionSystem::UpdateMarkerToTrack()",0
000464  6f6e5379
000468  7374656d
00046c  3a3a5570
000470  64617465
000474  4d61726b
000478  6572546f
00047c  54726163
000480  6b282900
                  |L28.1156|
                          DCD      ||.bss||+0x2a4
                  |L28.1160|
                          DCD      ||.constdata||+0x302e
                  |L28.1164|
00048c  55706461          DCB      "UpdateMarkerToTrack failed.\n",0
000490  74654d61
000494  726b6572
000498  546f5472
00049c  61636b20
0004a0  6661696c
0004a4  65642e0a
0004a8  00      
0004a9  00                DCB      0
0004aa  00                DCB      0
0004ab  00                DCB      0
                  |L28.1196|
0004ac  56697369          DCB      "VisionSystem::Update()",0
0004b0  6f6e5379
0004b4  7374656d
0004b8  3a3a5570
0004bc  64617465
0004c0  282900  
0004c3  00                DCB      0
                  |L28.1220|
                          DCD      ||.constdata||+0x2ce4
                  |L28.1224|
0004c8  56697369          DCB      "VisionSystem::Update(): TakeSnapshotHelper() failed.\n",0
0004cc  6f6e5379
0004d0  7374656d
0004d4  3a3a5570
0004d8  64617465
0004dc  28293a20
0004e0  54616b65
0004e4  536e6170
0004e8  73686f74
0004ec  48656c70
0004f0  65722829
0004f4  20666169
0004f8  6c65642e
0004fc  0a00    
0004fe  00                DCB      0
0004ff  00                DCB      0
                  |L28.1280|
000500  56697369          DCB      "VisionSystem_CameraImagingPipeline",0
000504  6f6e5379
000508  7374656d
00050c  5f43616d
000510  65726149
000514  6d616769
000518  6e675069
00051c  70656c69
000520  6e6500  
000523  00                DCB      0
                  |L28.1316|
000524  56697369          DCB      "VisionSystem_CameraImagingPipeline_Vignetting",0
000528  6f6e5379
00052c  7374656d
000530  5f43616d
000534  65726149
000538  6d616769
00053c  6e675069
000540  70656c69
000544  6e655f56
000548  69676e65
00054c  7474696e
000550  6700    
000552  00                DCB      0
000553  00                DCB      0
                  |L28.1364|
                          DCD      ||.bss||+0x1c
                  |L28.1368|
000558  56697369          DCB      "VisionSystem_CameraImagingPipeline_AutoExposure",0
00055c  6f6e5379
000560  7374656d
000564  5f43616d
000568  65726149
00056c  6d616769
000570  6e675069
000574  70656c69
000578  6e655f41
00057c  75746f45
000580  78706f73
000584  75726500
                  |L28.1416|
                          DCD      ||.bss||+0x38
                  |L28.1420|
                          DCD      ||.data||+0x34
                  |L28.1424|
                          DCD      ||.bss||+0x54
                  |L28.1428|
000594  f8d0a00c          LDR      r10,[r0,#0xc]         ;2045
000598  f1ba0f00          CMP      r10,#0                ;2045
00059c  bfc4              ITT      GT                    ;2045
00059e  ed9f8afe          VLDRGT   s16,|L28.2456|
0005a2  eddf8afe          VLDRGT   s17,|L28.2460|
0005a6  f34083d1          BLE.W    |L28.3404|
                  |L28.1450|
0005aa  48fd              LDR      r0,|L28.2464|
0005ac  eb050145          ADD      r1,r5,r5,LSL #1       ;2045
0005b0  eb0101c5          ADD      r1,r1,r5,LSL #3       ;2045
0005b4  6b00              LDR      r0,[r0,#0x30]         ;2045
0005b6  eb000481          ADD      r4,r0,r1,LSL #2       ;2045
0005ba  f7fffffe          BL       _ZN4Anki5Cozmo12Localization8IsOnRampEv ; Anki::Cozmo::Localization::IsOnRamp()
0005be  bb78              CBNZ     r0,|L28.1568|
0005c0  f7fffffe          BL       _ZN4Anki5Cozmo9IMUFilter10IsPickedUpEv ; Anki::Cozmo::IMUFilter::IsPickedUp()
0005c4  bb60              CBNZ     r0,|L28.1568|
0005c6  98a6              LDR      r0,[sp,#0x298]        ;2054
0005c8  9000              STR      r0,[sp,#0]            ;2055
0005ca  f8940020          LDRB     r0,[r4,#0x20]         ;2055
0005ce  f8ad0024          STRH     r0,[sp,#0x24]         ;2055
0005d2  ed940a02          VLDR     s0,[r4,#8]            ;2057
0005d6  ed8d0a03          VSTR     s0,[sp,#0xc]          ;2057
0005da  ed940a03          VLDR     s0,[r4,#0xc]          ;2058
0005de  ed8d0a04          VSTR     s0,[sp,#0x10]         ;2058
0005e2  ed940a00          VLDR     s0,[r4,#0]            ;2060
0005e6  ed8d0a01          VSTR     s0,[sp,#4]            ;2060
0005ea  ed940a01          VLDR     s0,[r4,#4]            ;2061
0005ee  ed8d0a02          VSTR     s0,[sp,#8]            ;2061
0005f2  ed940a04          VLDR     s0,[r4,#0x10]         ;2063
0005f6  ed8d0a05          VSTR     s0,[sp,#0x14]         ;2063
0005fa  ed940a05          VLDR     s0,[r4,#0x14]         ;2064
0005fe  ed8d0a06          VSTR     s0,[sp,#0x18]         ;2064
000602  ed940a06          VLDR     s0,[r4,#0x18]         ;2066
000606  ed8d0a07          VSTR     s0,[sp,#0x1c]         ;2066
00060a  ed940a07          VLDR     s0,[r4,#0x1c]         ;2067
00060e  ed8d0a08          VSTR     s0,[sp,#0x20]         ;2067
000612  f7fffffe          BL       _ZN4Anki5Cozmo3HAL12GetTimeStampEv ; Anki::Cozmo::HAL::GetTimeStamp()
000616  4602              MOV      r2,r0                 ;2069
000618  4669              MOV      r1,sp                 ;2069
00061a  201e              MOVS     r0,#0x1e              ;2069
00061c  f7fffffe          BL       _ZN4Anki5Cozmo3HAL16RadioSendMessageENS0_8Messages2IDEPKvj ; Anki::Cozmo::HAL::RadioSendMessage(Anki::Cozmo::Messages::ID, const void*, unsigned)
                  |L28.1568|
000620  4fe0              LDR      r7,|L28.2468|
000622  7838              LDRB     r0,[r7,#0]            ;2069
000624  28f7              CMP      r0,#0xf7              ;2069
000626  bf14              ITE      NE                    ;2069
000628  2101              MOVNE    r1,#1                 ;2069
00062a  2100              MOVEQ    r1,#0                 ;2069
00062c  43b1              BICS     r1,r1,r6              ;2074
00062e  f00082b8          BEQ.W    |L28.2978|
000632  f8941020          LDRB     r1,[r4,#0x20]         ;2074
000636  4623              MOV      r3,r4                 ;2075
000638  f04f0900          MOV      r9,#0                 ;2075
00063c  4281              CMP      r1,r0                 ;2075
00063e  f04082b0          BNE.W    |L28.2978|
000642  ed970a02          VLDR     s0,[r7,#8]            ;2075
000646  eeb50ac0          VCMPE.F32 s0,#0.0               ;2075
00064a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;2075
00064e  bfa1              ITTTT    GE                    ;2075
000650  ed970a03          VLDRGE   s0,[r7,#0xc]          ;2075
000654  eeb50ac0          VCMPEGE.F32 s0,#0.0               ;2075
000658  eef1fa10          VMRSGE   APSR_nzcv,FPSCR       ;2075
00065c  ed970a04          VLDRGE   s0,[r7,#0x10]         ;2075
000660  bfa4              ITT      GE                    ;2075
000662  eeb50ac0          VCMPEGE.F32 s0,#0.0               ;2075
000666  eef1fa10          VMRSGE   APSR_nzcv,FPSCR       ;2075
00066a  dd52              BLE      |L28.1810|
00066c  ed8d9a00          VSTR     s18,[sp,#0]           ;2075
000670  4668              MOV      r0,sp                 ;2075
000672  ed8d9a01          VSTR     s18,[sp,#4]           ;2075
000676  2100              MOVS     r1,#0                 ;2075
                  |L28.1656|
000678  eb0302c1          ADD      r2,r3,r1,LSL #3       ;2075
00067c  ed900a00          VLDR     s0,[r0,#0]            ;2075
000680  edd20a00          VLDR     s1,[r2,#0]            ;2075
000684  1c49              ADDS     r1,r1,#1              ;2075
000686  2904              CMP      r1,#4                 ;2075
000688  ee300a20          VADD.F32 s0,s0,s1              ;2075
00068c  ed800a00          VSTR     s0,[r0,#0]            ;2075
000690  ed900a01          VLDR     s0,[r0,#4]            ;2075
000694  edd20a01          VLDR     s1,[r2,#4]            ;2075
000698  ee300a20          VADD.F32 s0,s0,s1              ;2075
00069c  ed800a01          VSTR     s0,[r0,#4]            ;2075
0006a0  dbea              BLT      |L28.1656|
0006a2  ed900a00          VLDR     s0,[r0,#0]            ;2075
0006a6  ee200a08          VMUL.F32 s0,s0,s16             ;2075
0006aa  ed800a00          VSTR     s0,[r0,#0]            ;2075
0006ae  ed900a01          VLDR     s0,[r0,#4]            ;2075
0006b2  ee200a08          VMUL.F32 s0,s0,s16             ;2075
0006b6  ed800a01          VSTR     s0,[r0,#4]            ;2075
0006ba  ed9d0a00          VLDR     s0,[sp,#0]            ;2075
0006be  edd70a02          VLDR     s1,[r7,#8]            ;2075
0006c2  ed971a03          VLDR     s2,[r7,#0xc]          ;2075
0006c6  ee700a60          VSUB.F32 s1,s0,s1              ;2075
0006ca  ed9d0a01          VLDR     s0,[sp,#4]            ;2075
0006ce  edcd0a02          VSTR     s1,[sp,#8]            ;2075
0006d2  ee300a41          VSUB.F32 s0,s0,s2              ;2075
0006d6  ed8d0a03          VSTR     s0,[sp,#0xc]          ;2075
0006da  ee200aa0          VMUL.F32 s0,s1,s1              ;2075
0006de  eddd0a03          VLDR     s1,[sp,#0xc]          ;2075
0006e2  ee000aa0          VMLA.F32 s0,s1,s1              ;2075
0006e6  eef10ac0          VSQRT.F32 s1,s0                 ;2075
0006ea  eef40a60          VCMP.F32 s1,s1                 ;2075
0006ee  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;2075
0006f2  d003              BEQ      |L28.1788|
0006f4  f7fffffe          BL       __hardfp_sqrtf
0006f8  eef00a40          VMOV.F32 s1,s0                 ;2075
                  |L28.1788|
0006fc  ed970a04          VLDR     s0,[r7,#0x10]         ;2075
000700  eeb40ae0          VCMPE.F32 s0,s1                 ;2075
000704  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;2075
000708  bfd8              IT       LE                    ;2075
00070a  f1b90f00          CMPLE    r9,#0                 ;2075
00070e  f0008248          BEQ.W    |L28.2978|
                  |L28.1810|
000712  2601              MOVS     r6,#1                 ;2080
000714  4ba4              LDR      r3,|L28.2472|
000716  2000              MOVS     r0,#0                 ;2086
                  |L28.1816|
000718  eb0401c0          ADD      r1,r4,r0,LSL #3       ;2086
00071c  eb0302c0          ADD      r2,r3,r0,LSL #3       ;2086
000720  ed910a00          VLDR     s0,[r1,#0]            ;2086
000724  1c40              ADDS     r0,r0,#1              ;2086
000726  ed820a00          VSTR     s0,[r2,#0]            ;2086
00072a  ed910a01          VLDR     s0,[r1,#4]            ;2086
00072e  2804              CMP      r0,#4                 ;2086
000730  ed820a01          VSTR     s0,[r2,#4]            ;2086
000734  dbf0              BLT      |L28.1816|
000736  f8df8274          LDR      r8,|L28.2476|
00073a  ed980a03          VLDR     s0,[r8,#0xc]          ;2090
00073e  eeb50ac0          VCMPE.F32 s0,#0.0               ;2090
000742  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;2090
000746  d205              BCS      |L28.1876|
000748  f5a87136          SUB      r1,r8,#0x2d8          ;2092
00074c  a876              ADD      r0,sp,#0x1d8          ;2092
00074e  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem24BrightnessNormalizeImageERNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEE ; Anki::Cozmo::VisionSystem::BrightnessNormalizeImage(Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&)
000752  e00a              B        |L28.1898|
                  |L28.1876|
000754  4996              LDR      r1,|L28.2480|
000756  4668              MOV      r0,sp                 ;2096
000758  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00075c  4602              MOV      r2,r0                 ;2096
00075e  ed980a03          VLDR     s0,[r8,#0xc]          ;2096
000762  4991              LDR      r1,|L28.2472|
000764  a876              ADD      r0,sp,#0x1d8          ;2096
000766  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem24BrightnessNormalizeImageERNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEEfNS2_11MemoryStackE ; Anki::Cozmo::VisionSystem::BrightnessNormalizeImage(Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, float, Anki::Embedded::MemoryStack)
                  |L28.1898|
00076a  0004              MOVS     r4,r0                 ;2096
00076c  d00d              BEQ      |L28.1930|
00076e  4891              LDR      r0,|L28.2484|
000770  f6400135          MOV      r1,#0x835             ;2101
000774  f2af3358          ADR      r3,|L28.1056|
000778  e9cd0100          STRD     r0,r1,[sp,#0]         ;2101
00077c  a28e              ADR      r2,|L28.2488|
00077e  a197              ADR      r1,|L28.2524|
000780  2005              MOVS     r0,#5                 ;2101
000782  f7fffffe          BL       _Anki_Log
000786  4620              MOV      r0,r4                 ;2101
000788  e57b              B        |L28.642|
                  |L28.1930|
00078a  a876              ADD      r0,sp,#0x1d8          ;2105
00078c  90a5              STR      r0,[sp,#0x294]        ;2105
00078e  4886              LDR      r0,|L28.2472|
000790  9007              STR      r0,[sp,#0x1c]         ;2105
000792  f1000420          ADD      r4,r0,#0x20           ;2105
000796  f1a00194          SUB      r1,r0,#0x94           ;2105
00079a  a897              ADD      r0,sp,#0x25c          ;2105
00079c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0007a0  9000              STR      r0,[sp,#0]            ;2105
0007a2  f1a40bd0          SUB      r11,r4,#0xd0          ;2105
0007a6  f1a401ec          SUB      r1,r4,#0xec           ;2105
0007aa  a87b              ADD      r0,sp,#0x1ec          ;2105
0007ac  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0007b0  4681              MOV      r9,r0                 ;2105
0007b2  a89e              ADD      r0,sp,#0x278          ;2105
0007b4  9900              LDR      r1,[sp,#0]            ;2105
0007b6  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
0007ba  f8d81030          LDR      r1,[r8,#0x30]         ;2105
0007be  e9cd1003          STRD     r1,r0,[sp,#0xc]       ;2105
0007c2  e9cdb905          STRD     r11,r9,[sp,#0x14]     ;2105
0007c6  f8d81034          LDR      r1,[r8,#0x34]         ;2105
0007ca  f8d8202c          LDR      r2,[r8,#0x2c]         ;2105
0007ce  f44f6000          MOV      r0,#0x800             ;2105
0007d2  e9cd0100          STRD     r0,r1,[sp,#0]         ;2105
0007d6  9202              STR      r2,[sp,#8]            ;2105
0007d8  488c              LDR      r0,|L28.2572|
0007da  ed973a01          VLDR     s6,[r7,#4]            ;2105
0007de  f8d83018          LDR      r3,[r8,#0x18]         ;2105
0007e2  6a80              LDR      r0,[r0,#0x28]         ;2105  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712headCamInfo_E
0007e4  ed980a05          VLDR     s0,[r8,#0x14]         ;2105
0007e8  eef00a68          VMOV.F32 s1,s17                ;2105
0007ec  ec901a04          VLDM     r0,{s2-s5}            ;2105
0007f0  a808              ADD      r0,sp,#0x20           ;2105
0007f2  9a07              LDR      r2,[sp,#0x1c]         ;2105
0007f4  99a5              LDR      r1,[sp,#0x294]        ;2105
0007f6  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1ERKNS0_5ArrayIhEERKNS0_13QuadrilateralIfEEfiNS0_15Transformations13TransformTypeEifiifffffNS0_11MemoryStackERSD_SD_ ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, float, int, Anki::Embedded::Transformations::TransformType, int, float, int, int, float, float, float, float, float, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack&, Anki::Embedded::MemoryStack)
0007fa  8801              LDRH     r1,[r0,#0]            ;2105
0007fc  8021              STRH     r1,[r4,#0]            ;2105
0007fe  6841              LDR      r1,[r0,#4]            ;2105
000800  6061              STR      r1,[r4,#4]            ;2105
000802  6881              LDR      r1,[r0,#8]            ;2105
000804  60a1              STR      r1,[r4,#8]            ;2105
000806  68c1              LDR      r1,[r0,#0xc]          ;2105
000808  60e1              STR      r1,[r4,#0xc]          ;2105
00080a  ed900a04          VLDR     s0,[r0,#0x10]         ;2105
00080e  f1040318          ADD      r3,r4,#0x18           ;2105
000812  ed840a04          VSTR     s0,[r4,#0x10]         ;2105
000816  ed900a05          VLDR     s0,[r0,#0x14]         ;2105
00081a  f1000118          ADD      r1,r0,#0x18           ;2105
00081e  ed840a05          VSTR     s0,[r4,#0x14]         ;2105
000822  7e02              LDRB     r2,[r0,#0x18]         ;2105
000824  7622              STRB     r2,[r4,#0x18]         ;2105
000826  8b42              LDRH     r2,[r0,#0x1a]         ;2105
000828  8362              STRH     r2,[r4,#0x1a]         ;2105
00082a  f8d0c01c          LDR      r12,[r0,#0x1c]        ;2105
00082e  f8c4c01c          STR      r12,[r4,#0x1c]        ;2105
000832  f8d0c020          LDR      r12,[r0,#0x20]        ;2105
000836  f8c4c020          STR      r12,[r4,#0x20]        ;2105
00083a  f8d0c024          LDR      r12,[r0,#0x24]        ;2105
00083e  f8c4c024          STR      r12,[r4,#0x24]        ;2105
000842  f8d0c028          LDR      r12,[r0,#0x28]        ;2105
000846  f8c4c028          STR      r12,[r4,#0x28]        ;2105
00084a  f8d0c02c          LDR      r12,[r0,#0x2c]        ;2105
00084e  f1030918          ADD      r9,r3,#0x18           ;2105
000852  f1010818          ADD      r8,r1,#0x18           ;2105
000856  2200              MOVS     r2,#0                 ;2105
000858  f8c4c02c          STR      r12,[r4,#0x2c]        ;2105
                  |L28.2140|
00085c  eb080cc2          ADD      r12,r8,r2,LSL #3      ;2105
000860  eb0907c2          ADD      r7,r9,r2,LSL #3       ;2105
000864  ed9c0a00          VLDR     s0,[r12,#0]           ;2105
000868  1c52              ADDS     r2,r2,#1              ;2105
00086a  ed870a00          VSTR     s0,[r7,#0]            ;2105
00086e  ed9c0a01          VLDR     s0,[r12,#4]           ;2105
000872  2a04              CMP      r2,#4                 ;2105
000874  ed870a01          VSTR     s0,[r7,#4]            ;2105
000878  dbf0              BLT      |L28.2140|
00087a  f8912038          LDRB     r2,[r1,#0x38]         ;2105
00087e  f8832038          STRB     r2,[r3,#0x38]         ;2105
000882  ed910a0f          VLDR     s0,[r1,#0x3c]         ;2105
000886  ed830a0f          VSTR     s0,[r3,#0x3c]         ;2105
00088a  ed910a10          VLDR     s0,[r1,#0x40]         ;2105
00088e  4621              MOV      r1,r4                 ;2105
000890  ed830a10          VSTR     s0,[r3,#0x40]         ;2105
000894  ed900a17          VLDR     s0,[r0,#0x5c]         ;2105
000898  ed840a17          VSTR     s0,[r4,#0x5c]         ;2105
00089c  ed900a18          VLDR     s0,[r0,#0x60]         ;2105
0008a0  ed840a18          VSTR     s0,[r4,#0x60]         ;2105
0008a4  ed900a19          VLDR     s0,[r0,#0x64]         ;2105
0008a8  ed840a19          VSTR     s0,[r4,#0x64]         ;2105
0008ac  ed900a1a          VLDR     s0,[r0,#0x68]         ;2105
0008b0  ed840a1a          VSTR     s0,[r4,#0x68]         ;2105
0008b4  ed900a1b          VLDR     s0,[r0,#0x6c]         ;2105
0008b8  ed840a1b          VSTR     s0,[r4,#0x6c]         ;2105
0008bc  f8902070          LDRB     r2,[r0,#0x70]         ;2105
0008c0  f8842070          STRB     r2,[r4,#0x70]         ;2105
0008c4  ed900a1d          VLDR     s0,[r0,#0x74]         ;2105
0008c8  ed840a1d          VSTR     s0,[r4,#0x74]         ;2105
0008cc  ed900a1e          VLDR     s0,[r0,#0x78]         ;2105
0008d0  ed840a1e          VSTR     s0,[r4,#0x78]         ;2105
0008d4  ed900a1f          VLDR     s0,[r0,#0x7c]         ;2105
0008d8  ed840a1f          VSTR     s0,[r4,#0x7c]         ;2105
0008dc  ed900a20          VLDR     s0,[r0,#0x80]         ;2105
0008e0  ed840a20          VSTR     s0,[r4,#0x80]         ;2105
0008e4  ed900a21          VLDR     s0,[r0,#0x84]         ;2105
0008e8  ed840a21          VSTR     s0,[r4,#0x84]         ;2105
0008ec  ed900a22          VLDR     s0,[r0,#0x88]         ;2105
0008f0  ed840a22          VSTR     s0,[r4,#0x88]         ;2105
0008f4  ed900a23          VLDR     s0,[r0,#0x8c]         ;2105
0008f8  ed840a23          VSTR     s0,[r4,#0x8c]         ;2105
0008fc  ed900a24          VLDR     s0,[r0,#0x90]         ;2105
000900  ed840a24          VSTR     s0,[r4,#0x90]         ;2105
000904  ed900a25          VLDR     s0,[r0,#0x94]         ;2105
000908  ed840a25          VSTR     s0,[r4,#0x94]         ;2105
00090c  f8902098          LDRB     r2,[r0,#0x98]         ;2105
000910  f8842098          STRB     r2,[r4,#0x98]         ;2105
000914  ed900a27          VLDR     s0,[r0,#0x9c]         ;2105
000918  f10402b4          ADD      r2,r4,#0xb4           ;2105
00091c  ed810a27          VSTR     s0,[r1,#0x9c]         ;2105
000920  ed900a28          VLDR     s0,[r0,#0xa0]         ;2105
000924  ed810a28          VSTR     s0,[r1,#0xa0]         ;2105
000928  ed900a29          VLDR     s0,[r0,#0xa4]         ;2105
00092c  ed810a29          VSTR     s0,[r1,#0xa4]         ;2105
000930  ed900a2a          VLDR     s0,[r0,#0xa8]         ;2105
000934  ed840a2a          VSTR     s0,[r4,#0xa8]         ;2105
000938  ed900a2b          VLDR     s0,[r0,#0xac]         ;2105
00093c  ed840a2b          VSTR     s0,[r4,#0xac]         ;2105
000940  ed900a2c          VLDR     s0,[r0,#0xb0]         ;2105
000944  ed840a2c          VSTR     s0,[r4,#0xb0]         ;2105
000948  e9d0132d          LDRD     r1,r3,[r0,#0xb4]      ;2105
00094c  f8d0c0bc          LDR      r12,[r0,#0xbc]        ;2105
000950  f8c4c0bc          STR      r12,[r4,#0xbc]        ;2105
000954  e9c21300          STRD     r1,r3,[r2,#0]         ;2105
000958  e9d01330          LDRD     r1,r3,[r0,#0xc0]      ;2105
00095c  f8d0c0c8          LDR      r12,[r0,#0xc8]        ;2105
000960  f8c4c0c8          STR      r12,[r4,#0xc8]        ;2105
000964  e9c21303          STRD     r1,r3,[r2,#0xc]       ;2105
000968  f8d030cc          LDR      r3,[r0,#0xcc]         ;2105
00096c  f8c430cc          STR      r3,[r4,#0xcc]         ;2105
000970  f8d030d0          LDR      r3,[r0,#0xd0]         ;2105
000974  f8c430d0          STR      r3,[r4,#0xd0]         ;2105
000978  f8d030d4          LDR      r3,[r0,#0xd4]         ;2105
00097c  f8c430d4          STR      r3,[r4,#0xd4]         ;2105
000980  f8d030d8          LDR      r3,[r0,#0xd8]         ;2105
000984  f8c430d8          STR      r3,[r4,#0xd8]         ;2105
000988  f8d030dc          LDR      r3,[r0,#0xdc]         ;2105
00098c  f8c430dc          STR      r3,[r4,#0xdc]         ;2105
000990  f8d010e0          LDR      r1,[r0,#0xe0]         ;2105
000994  62d1              STR      r1,[r2,#0x2c]         ;2105
000996  e03b              B        |L28.2576|
                  |L28.2456|
000998  3e800000          DCFS     0x3e800000 ; 0.25
                  |L28.2460|
00099c  3dcccccd          DCFS     0x3dcccccd ; 0.10000000149011612
                  |L28.2464|
                          DCD      ||.bss||+0x54
                  |L28.2468|
                          DCD      ||.bss||+0x9c
                  |L28.2472|
                          DCD      ||.bss||+0xcc
                  |L28.2476|
                          DCD      ||.bss||+0x3a4
                  |L28.2480|
                          DCD      ||.bss||
                  |L28.2484|
                          DCD      ||.constdata||+0x302e
                  |L28.2488|
0009b8  42726967          DCB      "BrightnessNormalizeImage failed.\n",0
0009bc  68746e65
0009c0  73734e6f
0009c4  726d616c
0009c8  697a6549
0009cc  6d616765
0009d0  20666169
0009d4  6c65642e
0009d8  0a00    
0009da  00                DCB      0
0009db  00                DCB      0
                  |L28.2524|
0009dc  56697369          DCB      "VisionSystem::Update::BrightnessNormalizeImage",0
0009e0  6f6e5379
0009e4  7374656d
0009e8  3a3a5570
0009ec  64617465
0009f0  3a3a4272
0009f4  69676874
0009f8  6e657373
0009fc  4e6f726d
000a00  616c697a
000a04  65496d61
000a08  676500  
000a0b  00                DCB      0
                  |L28.2572|
                          DCD      ||.data||
                  |L28.2576|
000a10  f8d010e4          LDR      r1,[r0,#0xe4]         ;2105
000a14  6311              STR      r1,[r2,#0x30]         ;2105
000a16  e9d0133a          LDRD     r1,r3,[r0,#0xe8]      ;2105
000a1a  3234              ADDS     r2,r2,#0x34           ;2105
000a1c  f8d0c0f0          LDR      r12,[r0,#0xf0]        ;2105
000a20  f8c4c0f0          STR      r12,[r4,#0xf0]        ;2105
000a24  e9c21300          STRD     r1,r3,[r2,#0]         ;2105
000a28  e9d0133d          LDRD     r1,r3,[r0,#0xf4]      ;2105
000a2c  f8d0c0fc          LDR      r12,[r0,#0xfc]        ;2105
000a30  f8c4c0fc          STR      r12,[r4,#0xfc]        ;2105
000a34  e9c21303          STRD     r1,r3,[r2,#0xc]       ;2105
000a38  f8d03100          LDR      r3,[r0,#0x100]        ;2105
000a3c  f8c43100          STR      r3,[r4,#0x100]        ;2105
000a40  f8d03104          LDR      r3,[r0,#0x104]        ;2105
000a44  f8c43104          STR      r3,[r4,#0x104]        ;2105
000a48  f8d03108          LDR      r3,[r0,#0x108]        ;2105
000a4c  f8c43108          STR      r3,[r4,#0x108]        ;2105
000a50  f8d0310c          LDR      r3,[r0,#0x10c]        ;2105
000a54  f8c4310c          STR      r3,[r4,#0x10c]        ;2105
000a58  f8d03110          LDR      r3,[r0,#0x110]        ;2105
000a5c  f8c43110          STR      r3,[r4,#0x110]        ;2105
000a60  f8d01114          LDR      r1,[r0,#0x114]        ;2105
000a64  62d1              STR      r1,[r2,#0x2c]         ;2105
000a66  f8d01118          LDR      r1,[r0,#0x118]        ;2105
000a6a  6311              STR      r1,[r2,#0x30]         ;2105
000a6c  e9d01347          LDRD     r1,r3,[r0,#0x11c]     ;2105
000a70  3234              ADDS     r2,r2,#0x34           ;2105
000a72  f8d0c124          LDR      r12,[r0,#0x124]       ;2105
000a76  f8c4c124          STR      r12,[r4,#0x124]       ;2105
000a7a  e9c21300          STRD     r1,r3,[r2,#0]         ;2105
000a7e  e9d0134a          LDRD     r1,r3,[r0,#0x128]     ;2105
000a82  f8d0c130          LDR      r12,[r0,#0x130]       ;2105
000a86  f8c4c130          STR      r12,[r4,#0x130]       ;2105
000a8a  e9c21303          STRD     r1,r3,[r2,#0xc]       ;2105
000a8e  f8d03134          LDR      r3,[r0,#0x134]        ;2105
000a92  f8c43134          STR      r3,[r4,#0x134]        ;2105
000a96  f8d03138          LDR      r3,[r0,#0x138]        ;2105
000a9a  f8c43138          STR      r3,[r4,#0x138]        ;2105
000a9e  f8d0313c          LDR      r3,[r0,#0x13c]        ;2105
000aa2  f8c4313c          STR      r3,[r4,#0x13c]        ;2105
000aa6  f8d03140          LDR      r3,[r0,#0x140]        ;2105
000aaa  f8c43140          STR      r3,[r4,#0x140]        ;2105
000aae  f8d03144          LDR      r3,[r0,#0x144]        ;2105
000ab2  f8c43144          STR      r3,[r4,#0x144]        ;2105
000ab6  f8d01148          LDR      r1,[r0,#0x148]        ;2105
000aba  62d1              STR      r1,[r2,#0x2c]         ;2105
000abc  f8d0114c          LDR      r1,[r0,#0x14c]        ;2105
000ac0  6311              STR      r1,[r2,#0x30]         ;2105
000ac2  e9d01354          LDRD     r1,r3,[r0,#0x150]     ;2105
000ac6  3234              ADDS     r2,r2,#0x34           ;2105
000ac8  f8d0c158          LDR      r12,[r0,#0x158]       ;2105
000acc  f8c4c158          STR      r12,[r4,#0x158]       ;2105
000ad0  e9c21300          STRD     r1,r3,[r2,#0]         ;2105
000ad4  e9d01357          LDRD     r1,r3,[r0,#0x15c]     ;2105
000ad8  f8d0c164          LDR      r12,[r0,#0x164]       ;2105
000adc  f8c4c164          STR      r12,[r4,#0x164]       ;2105
000ae0  e9c21303          STRD     r1,r3,[r2,#0xc]       ;2105
000ae4  f8d03168          LDR      r3,[r0,#0x168]        ;2105
000ae8  f8c43168          STR      r3,[r4,#0x168]        ;2105
000aec  f8d0316c          LDR      r3,[r0,#0x16c]        ;2105
000af0  f8c4316c          STR      r3,[r4,#0x16c]        ;2105
000af4  f8d03170          LDR      r3,[r0,#0x170]        ;2105
000af8  f8c43170          STR      r3,[r4,#0x170]        ;2105
000afc  f8d03174          LDR      r3,[r0,#0x174]        ;2105
000b00  f8c43174          STR      r3,[r4,#0x174]        ;2105
000b04  f8d03178          LDR      r3,[r0,#0x178]        ;2105
000b08  f8c43178          STR      r3,[r4,#0x178]        ;2105
000b0c  f8d0117c          LDR      r1,[r0,#0x17c]        ;2105
000b10  62d1              STR      r1,[r2,#0x2c]         ;2105
000b12  f8d01180          LDR      r1,[r0,#0x180]        ;2105
000b16  6311              STR      r1,[r2,#0x30]         ;2105
000b18  e9d01361          LDRD     r1,r3,[r0,#0x184]     ;2105
000b1c  f8d0c18c          LDR      r12,[r0,#0x18c]       ;2105
000b20  3234              ADDS     r2,r2,#0x34           ;2105
000b22  f8c4c18c          STR      r12,[r4,#0x18c]       ;2105
000b26  e9c21300          STRD     r1,r3,[r2,#0]         ;2105
000b2a  e9d01364          LDRD     r1,r3,[r0,#0x190]     ;2105
000b2e  f8d0c198          LDR      r12,[r0,#0x198]       ;2105
000b32  f8c4c198          STR      r12,[r4,#0x198]       ;2105
000b36  e9c21303          STRD     r1,r3,[r2,#0xc]       ;2105
000b3a  f8d0319c          LDR      r3,[r0,#0x19c]        ;2105
000b3e  f8c4319c          STR      r3,[r4,#0x19c]        ;2105
000b42  f8d031a0          LDR      r3,[r0,#0x1a0]        ;2105
000b46  f8c431a0          STR      r3,[r4,#0x1a0]        ;2105
000b4a  f8d031a4          LDR      r3,[r0,#0x1a4]        ;2105
000b4e  f8c431a4          STR      r3,[r4,#0x1a4]        ;2105
000b52  f8d031a8          LDR      r3,[r0,#0x1a8]        ;2105
000b56  f8c431a8          STR      r3,[r4,#0x1a8]        ;2105
000b5a  f8d031ac          LDR      r3,[r0,#0x1ac]        ;2105
000b5e  f8c431ac          STR      r3,[r4,#0x1ac]        ;2105
000b62  f8d011b0          LDR      r1,[r0,#0x1b0]        ;2105
000b66  62d1              STR      r1,[r2,#0x2c]         ;2105
000b68  f8d001b4          LDR      r0,[r0,#0x1b4]        ;2105
000b6c  6310              STR      r0,[r2,#0x30]         ;2105
000b6e  4620              MOV      r0,r4                 ;2105
000b70  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof7IsValidEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::IsValid() const
000b74  2800              CMP      r0,#0                 ;2105
000b76  bf08              IT       EQ                    ;2105
000b78  f04f0801          MOVEQ    r8,#1                 ;2105
000b7c  d00a              BEQ      |L28.2964|
000b7e  4659              MOV      r1,r11                ;2105
000b80  a87b              ADD      r0,sp,#0x1ec          ;2105
000b82  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000b86  4602              MOV      r2,r0                 ;2105
000b88  4621              MOV      r1,r4                 ;2105
000b8a  98a5              LDR      r0,[sp,#0x294]        ;2105
000b8c  f7fffffe          BL       _ZN4Anki5Cozmo19MatlabVisualization13SendTrackInitERKNS_8Embedded5ArrayIhEERKNS2_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofENS2_11MemoryStackE ; Anki::Cozmo::MatlabVisualization::SendTrackInit(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof&, Anki::Embedded::MemoryStack)
000b90  f04f0800          MOV      r8,#0                 ;2105
                  |L28.2964|
000b94  f1b80f00          CMP      r8,#0                 ;2105
000b98  f04080d8          BNE.W    |L28.3404|
000b9c  49fe              LDR      r1,|L28.3992|
000b9e  2002              MOVS     r0,#2                 ;2118
000ba0  7208              STRB     r0,[r1,#8]            ;2118
                  |L28.2978|
000ba2  1c6d              ADDS     r5,r5,#1              ;2045
000ba4  4555              CMP      r5,r10                ;2045
000ba6  f6ffad00          BLT      |L28.1450|
000baa  f000b8cf          B.W      |L28.3404|
                  |L28.2990|
000bae  49fb              LDR      r1,|L28.3996|
000bb0  a837              ADD      r0,sp,#0xdc           ;2128
000bb2  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000bb6  49fa              LDR      r1,|L28.4000|
000bb8  a81a              ADD      r0,sp,#0x68           ;2129
000bba  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000bbe  f899000b          LDRB     r0,[r9,#0xb]          ;2131  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718captureResolution_E
000bc2  2300              MOVS     r3,#0                 ;2134
000bc4  eb000040          ADD      r0,r0,r0,LSL #1       ;2131
000bc8  eb050080          ADD      r0,r5,r0,LSL #2       ;2131
000bcc  461a              MOV      r2,r3                 ;2134
000bce  f8b0a004          LDRH     r10,[r0,#4]           ;2131
000bd2  8845              LDRH     r5,[r0,#2]            ;2132
000bd4  4619              MOV      r1,r3                 ;2134
000bd6  a862              ADD      r0,sp,#0x188          ;2134
000bd8  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000bdc  6800              LDR      r0,[r0,#0]            ;2134
000bde  9000              STR      r0,[sp,#0]            ;2134
000be0  ab1a              ADD      r3,sp,#0x68           ;2134
000be2  462a              MOV      r2,r5                 ;2134
000be4  4651              MOV      r1,r10                ;2134
000be6  a804              ADD      r0,sp,#0x10           ;2134
000be8  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000bec  2200              MOVS     r2,#0                 ;2137
000bee  f899100b          LDRB     r1,[r9,#0xb]          ;2137  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718captureResolution_E
000bf2  9808              LDR      r0,[sp,#0x20]         ;2137
000bf4  f7fffffe          BL       _ZN4Anki5Cozmo3HAL14CameraGetFrameEPhNS_6Vision16CameraResolutionEb ; Anki::Cozmo::HAL::CameraGetFrame(unsigned char*, Anki::Vision::CameraResolution, bool)
000bf8  a804              ADD      r0,sp,#0x10           ;2140
000bfa  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem18TakeSnapshotHelperERKNS_8Embedded5ArrayIhEE ; Anki::Cozmo::VisionSystem::TakeSnapshotHelper(const Anki::Embedded::Array<unsigned char>&)
000bfe  0005              MOVS     r5,r0                 ;2140
000c00  d006              BEQ      |L28.3088|
                  |L28.3074|
000c02  f2af703c          ADR      r0,|L28.1224|
000c06  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
000c0a  4628              MOV      r0,r5                 ;2142
000c0c  f7ffbb39          B        |L28.642|
                  |L28.3088|
000c10  f2af7014          ADR      r0,|L28.1280|
000c14  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
000c18  f8990001          LDRB     r0,[r9,#1]            ;2147  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754720vignettingCorrectionE
000c1c  2802              CMP      r0,#2                 ;2147
000c1e  d128              BNE      |L28.3186|
000c20  f2af7000          ADR      r0,|L28.1316|
000c24  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
000c28  49dd              LDR      r1,|L28.4000|
000c2a  a821              ADD      r0,sp,#0x84           ;2150
000c2c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000c30  2200              MOVS     r2,#0                 ;2151
000c32  2301              MOVS     r3,#1                 ;2151
000c34  4611              MOV      r1,r2                 ;2151
000c36  4668              MOV      r0,sp                 ;2151
000c38  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000c3c  6803              LDR      r3,[r0,#0]            ;2151
000c3e  aa21              ADD      r2,sp,#0x84           ;2151
000c40  2105              MOVS     r1,#5                 ;2151
000c42  a809              ADD      r0,sp,#0x24           ;2151
000c44  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIfEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<float>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000c48  2000              MOVS     r0,#0                 ;2153
                  |L28.3146|
000c4a  9915              LDR      r1,[sp,#0x54]         ;2153
000c4c  eb080280          ADD      r2,r8,r0,LSL #2       ;2154
000c50  eb010180          ADD      r1,r1,r0,LSL #2       ;2154
000c54  ed920a00          VLDR     s0,[r2,#0]            ;2154
000c58  1c40              ADDS     r0,r0,#1              ;2153
000c5a  ed810a00          VSTR     s0,[r1,#0]            ;2154
000c5e  2805              CMP      r0,#5                 ;2153
000c60  dbf3              BLT      |L28.3146|
000c62  a909              ADD      r1,sp,#0x24           ;2156
000c64  a804              ADD      r0,sp,#0x10           ;2156
000c66  f7fffffe          BL       _ZN4Anki8Embedded17CorrectVignettingERNS0_5ArrayIhEERKNS0_15FixedLengthListIfEE ; Anki::Embedded::CorrectVignetting(Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::FixedLengthList<float>&)
000c6a  f2af7048          ADR      r0,|L28.1316|
000c6e  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
                  |L28.3186|
000c72  f2af7074          ADR      r0,|L28.1280|
000c76  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
000c7a  f8990001          LDRB     r0,[r9,#1]            ;2181  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754720vignettingCorrectionE
000c7e  2801              CMP      r0,#1                 ;2181
000c80  bf18              IT       NE                    ;2181
000c82  2000              MOVNE    r0,#0                 ;2181
000c84  ed990a0d          VLDR     s0,[r9,#0x34]         ;2181
000c88  f7fffffe          BL       _ZN4Anki5Cozmo3HAL19CameraSetParametersEfb ; Anki::Cozmo::HAL::CameraSetParameters(float, bool)
000c8c  a804              ADD      r0,sp,#0x10           ;2183
000c8e  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem22DownsampleAndSendImageERKNS_8Embedded5ArrayIhEE ; Anki::Cozmo::VisionSystem::DownsampleAndSendImage(const Anki::Embedded::Array<unsigned char>&)
000c92  4dc4              LDR      r5,|L28.4004|
000c94  ed950a03          VLDR     s0,[r5,#0xc]          ;2187
000c98  eeb50ac0          VCMPE.F32 s0,#0.0               ;2187
000c9c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;2187
000ca0  d205              BCS      |L28.3246|
000ca2  f5a57136          SUB      r1,r5,#0x2d8          ;2189
000ca6  a804              ADD      r0,sp,#0x10           ;2189
000ca8  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem24BrightnessNormalizeImageERNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEE ; Anki::Cozmo::VisionSystem::BrightnessNormalizeImage(Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&)
000cac  e00a              B        |L28.3268|
                  |L28.3246|
000cae  49bb              LDR      r1,|L28.3996|
000cb0  a809              ADD      r0,sp,#0x24           ;2193
000cb2  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000cb6  4602              MOV      r2,r0                 ;2193
000cb8  ed950a03          VLDR     s0,[r5,#0xc]          ;2193
000cbc  49ba              LDR      r1,|L28.4008|
000cbe  a804              ADD      r0,sp,#0x10           ;2193
000cc0  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem24BrightnessNormalizeImageERNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEEfNS2_11MemoryStackE ; Anki::Cozmo::VisionSystem::BrightnessNormalizeImage(Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, float, Anki::Embedded::MemoryStack)
                  |L28.3268|
000cc4  0005              MOVS     r5,r0                 ;2193
000cc6  d00e              BEQ      |L28.3302|
000cc8  48b8              LDR      r0,|L28.4012|
000cca  f6400196          MOV      r1,#0x896             ;2198
000cce  f6af03b0          ADR      r3,|L28.1056|
000cd2  f2af321c          ADR      r2,|L28.2488|
000cd6  e9cd0100          STRD     r0,r1,[sp,#0]         ;2198
000cda  f2af3100          ADR      r1,|L28.2524|
000cde  2005              MOVS     r0,#5                 ;2198
000ce0  f7fffffe          BL       _Anki_Log
000ce4  e00c              B        |L28.3328|
                  |L28.3302|
000ce6  a91a              ADD      r1,sp,#0x68           ;2209
000ce8  a830              ADD      r0,sp,#0xc0           ;2209
000cea  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000cee  4601              MOV      r1,r0                 ;2209
000cf0  a804              ADD      r0,sp,#0x10           ;2209
000cf2  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem23TrackerPredictionUpdateERKNS_8Embedded5ArrayIhEENS2_11MemoryStackE ; Anki::Cozmo::VisionSystem::TrackerPredictionUpdate(const Anki::Embedded::Array<unsigned char>&, Anki::Embedded::MemoryStack)
000cf6  0005              MOVS     r5,r0                 ;2209
000cf8  d005              BEQ      |L28.3334|
000cfa  a0ad              ADR      r0,|L28.4016|
000cfc  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
                  |L28.3328|
000d00  4628              MOV      r0,r5                 ;2211
000d02  f7ffbabe          B        |L28.642|
                  |L28.3334|
000d06  f88d4184          STRB     r4,[sp,#0x184]        ;2219
000d0a  a937              ADD      r1,sp,#0xdc           ;2221
000d0c  a845              ADD      r0,sp,#0x114          ;2221
000d0e  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000d12  4680              MOV      r8,r0                 ;2221
000d14  a91a              ADD      r1,sp,#0x68           ;2221
000d16  a83e              ADD      r0,sp,#0xf8           ;2221
000d18  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000d1c  4605              MOV      r5,r0                 ;2221
000d1e  49b1              LDR      r1,|L28.4068|
000d20  a830              ADD      r0,sp,#0xc0           ;2221
000d22  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000d26  a961              ADD      r1,sp,#0x184          ;2221
000d28  e9cd1000          STRD     r1,r0,[sp,#0]         ;2221
000d2c  4bae              LDR      r3,|L28.4072|
000d2e  e9cd5802          STRD     r5,r8,[sp,#8]         ;2221
000d32  f503722e          ADD      r2,r3,#0x2b8          ;2221
000d36  f5a27136          SUB      r1,r2,#0x2d8          ;2221
000d3a  a804              ADD      r0,sp,#0x10           ;2221
000d3c  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem13TrackTemplateERKNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEERKNS1_17TrackerParametersERNS2_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofERbNS2_11MemoryStackESI_SI_ ; Anki::Cozmo::VisionSystem::TrackTemplate(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Quadrilateral<float>&, const Anki::Cozmo::VisionSystem::TrackerParameters&, Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof&, bool&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
000d40  ea5f0800          MOVS     r8,r0                 ;2221
000d44  d005              BEQ      |L28.3410|
000d46  a09a              ADR      r0,|L28.4016|
000d48  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
                  |L28.3404|
000d4c  4640              MOV      r0,r8                 ;2230
000d4e  f7ffba98          B        |L28.642|
                  |L28.3410|
000d52  98a6              LDR      r0,[sp,#0x298]        ;2238
000d54  902a              STR      r0,[sp,#0xa8]         ;2239
000d56  f89d0184          LDRB     r0,[sp,#0x184]        ;2239
000d5a  f88d00bc          STRB     r0,[sp,#0xbc]         ;2239
000d5e  2800              CMP      r0,#0                 ;2241
000d60  d07d              BEQ      |L28.3678|
000d62  ad22              ADD      r5,sp,#0x88           ;2243
000d64  498e              LDR      r1,|L28.4000|
000d66  a84c              ADD      r0,sp,#0x130          ;2243
000d68  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000d6c  4601              MOV      r1,r0                 ;2243
000d6e  a85a              ADD      r0,sp,#0x168          ;2243
000d70  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000d74  4606              MOV      r6,r0                 ;2243
000d76  499c              LDR      r1,|L28.4072|
000d78  a809              ADD      r0,sp,#0x24           ;2243
000d7a  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker26LucasKanadeTracker_Generic18get_transformationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_Generic::get_transformation() const
000d7e  4632              MOV      r2,r6                 ;2243
000d80  a909              ADD      r1,sp,#0x24           ;2243
000d82  4628              MOV      r0,r5                 ;2243
000d84  f7fffffe          BL       _ZNK4Anki8Embedded15Transformations24PlanarTransformation_f3222get_transformedCornersENS0_11MemoryStackE ; Anki::Embedded::Transformations::PlanarTransformation_f32::get_transformedCorners(Anki::Embedded::MemoryStack) const
000d88  4985              LDR      r1,|L28.4000|
000d8a  a853              ADD      r0,sp,#0x14c          ;2244
000d8c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000d90  f88d40bd          STRB     r4,[sp,#0xbd]         ;2244
000d94  4894              LDR      r0,|L28.4072|
000d96  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetTranslation() const
000d9a  ed900a00          VLDR     s0,[r0,#0]            ;2244
000d9e  4892              LDR      r0,|L28.4072|
000da0  ed8d0a2b          VSTR     s0,[sp,#0xac]         ;2244
000da4  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetTranslation() const
000da8  ed900a01          VLDR     s0,[r0,#4]            ;2244
000dac  488e              LDR      r0,|L28.4072|
000dae  ed8d0a2c          VSTR     s0,[sp,#0xb0]         ;2244
000db2  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof14GetTranslationEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::GetTranslation() const
000db6  ed900a02          VLDR     s0,[r0,#8]            ;2244
000dba  488b              LDR      r0,|L28.4072|
000dbc  ed8d0a2d          VSTR     s0,[sp,#0xb4]         ;2244
000dc0  f7fffffe          BL       _ZNK4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dof10get_angleYEv ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::get_angleY() const
000dc4  ed900a00          VLDR     s0,[r0,#0]            ;2244
000dc8  ed8d0a2e          VSTR     s0,[sp,#0xb8]         ;2244
000dcc  f8990004          LDRB     r0,[r9,#4]            ;2247  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754714imageSendMode_E
000dd0  2801              CMP      r0,#1                 ;2247
000dd2  d162              BNE      |L28.3738|
000dd4  f8991005          LDRB     r1,[r9,#5]            ;2249  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754724nextSendImageResolution_E
000dd8  2901              CMP      r1,#1                 ;2249
000dda  d905              BLS      |L28.3560|
                  |L28.3548|
000ddc  ee288a28          VMUL.F32 s16,s16,s17           ;2250
000de0  1c40              ADDS     r0,r0,#1              ;2249
000de2  b2c0              UXTB     r0,r0                 ;2249
000de4  4281              CMP      r1,r0                 ;2249
000de6  d8f9              BHI      |L28.3548|
                  |L28.3560|
000de8  ed9d0a22          VLDR     s0,[sp,#0x88]         ;2254
000dec  ee200a08          VMUL.F32 s0,s0,s16             ;2254
000df0  eebc0ac0          VCVT.U32.F32 s0,s0                 ;2254
000df4  ee100a10          VMOV     r0,s0                 ;2254
000df8  f8ad0000          STRH     r0,[sp,#0]            ;2254
000dfc  ed9d0a23          VLDR     s0,[sp,#0x8c]         ;2255
000e00  ee200a08          VMUL.F32 s0,s0,s16             ;2255
000e04  eebc0ac0          VCVT.U32.F32 s0,s0                 ;2255
000e08  ee100a10          VMOV     r0,s0                 ;2255
000e0c  f8ad0002          STRH     r0,[sp,#2]            ;2255
000e10  ed9d0a26          VLDR     s0,[sp,#0x98]         ;2256
000e14  ee200a08          VMUL.F32 s0,s0,s16             ;2256
000e18  eebc0ac0          VCVT.U32.F32 s0,s0                 ;2256
000e1c  ee100a10          VMOV     r0,s0                 ;2256
000e20  f8ad0004          STRH     r0,[sp,#4]            ;2256
000e24  ed9d0a27          VLDR     s0,[sp,#0x9c]         ;2257
000e28  ee200a08          VMUL.F32 s0,s0,s16             ;2257
000e2c  eebc0ac0          VCVT.U32.F32 s0,s0                 ;2257
000e30  ee100a10          VMOV     r0,s0                 ;2257
000e34  f8ad0006          STRH     r0,[sp,#6]            ;2257
000e38  ed9d0a28          VLDR     s0,[sp,#0xa0]         ;2258
000e3c  ee200a08          VMUL.F32 s0,s0,s16             ;2258
000e40  eebc0ac0          VCVT.U32.F32 s0,s0                 ;2258
000e44  ee100a10          VMOV     r0,s0                 ;2258
000e48  f8ad0008          STRH     r0,[sp,#8]            ;2258
000e4c  ed9d0a29          VLDR     s0,[sp,#0xa4]         ;2259
000e50  ee200a08          VMUL.F32 s0,s0,s16             ;2259
000e54  eebc0ac0          VCVT.U32.F32 s0,s0                 ;2259
000e58  ee100a10          VMOV     r0,s0                 ;2259
000e5c  e000              B        |L28.3680|
                  |L28.3678|
000e5e  e01f              B        |L28.3744|
                  |L28.3680|
000e60  f8ad000a          STRH     r0,[sp,#0xa]          ;2259
000e64  ed9d0a24          VLDR     s0,[sp,#0x90]         ;2260
000e68  ee200a08          VMUL.F32 s0,s0,s16             ;2260
000e6c  eebc0ac0          VCVT.U32.F32 s0,s0                 ;2260
000e70  ee100a10          VMOV     r0,s0                 ;2260
000e74  f8ad000c          STRH     r0,[sp,#0xc]          ;2260
000e78  ed9d0a25          VLDR     s0,[sp,#0x94]         ;2261
000e7c  ee200a08          VMUL.F32 s0,s0,s16             ;2261
000e80  eebc0ac0          VCVT.U32.F32 s0,s0                 ;2261
000e84  ee100a10          VMOV     r0,s0                 ;2261
000e88  f8ad000e          STRH     r0,[sp,#0xe]          ;2261
000e8c  f7fffffe          BL       _ZN4Anki5Cozmo3HAL12GetTimeStampEv ; Anki::Cozmo::HAL::GetTimeStamp()
000e90  4602              MOV      r2,r0                 ;2263
000e92  4669              MOV      r1,sp                 ;2263
000e94  202a              MOVS     r0,#0x2a              ;2263
000e96  f7fffffe          BL       _ZN4Anki5Cozmo3HAL16RadioSendMessageENS0_8Messages2IDEPKvj ; Anki::Cozmo::HAL::RadioSendMessage(Anki::Cozmo::Messages::ID, const void*, unsigned)
                  |L28.3738|
000e9a  f8c9403c          STR      r4,[r9,#0x3c]         ;2268  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754717numTrackFailures_E
000e9e  e01e              B        |L28.3806|
                  |L28.3744|
000ea0  f8d9003c          LDR      r0,[r9,#0x3c]         ;2270  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754717numTrackFailures_E
000ea4  1c40              ADDS     r0,r0,#1              ;2270
000ea6  f8c9003c          STR      r0,[r9,#0x3c]         ;2272  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754717numTrackFailures_E
000eaa  2801              CMP      r0,#1                 ;2272
000eac  d117              BNE      |L28.3806|
000eae  eddb0a01          VLDR     s1,[r11,#4]           ;2274
000eb2  ed9b0a04          VLDR     s0,[r11,#0x10]        ;2274
000eb6  f89b2014          LDRB     r2,[r11,#0x14]        ;2274  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754714markerToTrack_E
000eba  f89b1000          LDRB     r1,[r11,#0]           ;2274
000ebe  7031              STRB     r1,[r6,#0]            ;2274
000ec0  edc60a01          VSTR     s1,[r6,#4]            ;2274
000ec4  eddb0a02          VLDR     s1,[r11,#8]           ;2274
000ec8  edc60a02          VSTR     s1,[r6,#8]            ;2274
000ecc  eddb0a03          VLDR     s1,[r11,#0xc]         ;2274
000ed0  edc60a03          VSTR     s1,[r6,#0xc]          ;2274
000ed4  ed860a04          VSTR     s0,[r6,#0x10]         ;2274
000ed8  7532              STRB     r2,[r6,#0x14]         ;2274
000eda  f8897003          STRB     r7,[r9,#3]            ;2274
                  |L28.3806|
000ede  a82a              ADD      r0,sp,#0xa8           ;2282
000ee0  f7fffffe          BL       _ZN4Anki5Cozmo8Messages32ProcessDockingErrorSignalMessageERKNS1_18DockingErrorSignalE ; Anki::Cozmo::Messages::ProcessDockingErrorSignalMessage(const Anki::Cozmo::Messages::DockingErrorSignal&)
000ee4  e732              B        |L28.3404|
                  |L28.3814|
000ee6  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv ; Anki::Cozmo::VisionSystem::VisionMemory::ResetBuffers()
000eea  4840              LDR      r0,|L28.4076|
000eec  7800              LDRB     r0,[r0,#0]            ;2289  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754724faceDetectionParameters_E
000eee  b328              CBZ      r0,|L28.3900|
000ef0  f899000b          LDRB     r0,[r9,#0xb]          ;2293  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718captureResolution_E
000ef4  2300              MOVS     r3,#0                 ;2296
000ef6  eb000140          ADD      r1,r0,r0,LSL #1       ;2293
000efa  483d              LDR      r0,|L28.4080|
000efc  461a              MOV      r2,r3                 ;2296
000efe  eb000081          ADD      r0,r0,r1,LSL #2       ;2293
000f02  4619              MOV      r1,r3                 ;2296
000f04  8885              LDRH     r5,[r0,#4]            ;2293
000f06  8846              LDRH     r6,[r0,#2]            ;2294
000f08  a8be              ADD      r0,sp,#0x2f8          ;2296
000f0a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000f0e  6800              LDR      r0,[r0,#0]            ;2296
000f10  9000              STR      r0,[sp,#0]            ;2296
000f12  4b22              LDR      r3,|L28.3996|
000f14  4632              MOV      r2,r6                 ;2296
000f16  4629              MOV      r1,r5                 ;2296
000f18  a8a0              ADD      r0,sp,#0x280          ;2296
000f1a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000f1e  2200              MOVS     r2,#0                 ;2299
000f20  f899100b          LDRB     r1,[r9,#0xb]          ;2299  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718captureResolution_E
000f24  98a4              LDR      r0,[sp,#0x290]        ;2299
000f26  f7fffffe          BL       _ZN4Anki5Cozmo3HAL14CameraGetFrameEPhNS_6Vision16CameraResolutionEb ; Anki::Cozmo::HAL::CameraGetFrame(unsigned char*, Anki::Vision::CameraResolution, bool)
000f2a  f6af202c          ADR      r0,|L28.1280|
000f2e  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
000f32  f8990001          LDRB     r0,[r9,#1]            ;2304  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754720vignettingCorrectionE
000f36  2802              CMP      r0,#2                 ;2304
000f38  d010              BEQ      |L28.3932|
000f3a  e086              B        |L28.4170|
                  |L28.3900|
000f3c  481b              LDR      r0,|L28.4012|
000f3e  f64001f1          MOV      r1,#0x8f1             ;2289
000f42  f6af3324          ADR      r3,|L28.1056|
000f46  e9cd0100          STRD     r0,r1,[sp,#0]         ;2289
000f4a  f2004226          ADD      r2,r0,#0x426          ;2289
000f4e  a129              ADR      r1,|L28.4084|
000f50  2005              MOVS     r0,#5                 ;2289
000f52  f7fffffe          BL       _Anki_Log
                  |L28.3926|
000f56  2001              MOVS     r0,#1                 ;2443
000f58  f7ffb993          B        |L28.642|
                  |L28.3932|
000f5c  f6af203c          ADR      r0,|L28.1316|
000f60  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
000f64  490e              LDR      r1,|L28.4000|
000f66  4668              MOV      r0,sp                 ;2307
000f68  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
000f6c  2200              MOVS     r2,#0                 ;2308
000f6e  2301              MOVS     r3,#1                 ;2308
000f70  4611              MOV      r1,r2                 ;2308
000f72  a807              ADD      r0,sp,#0x1c           ;2308
000f74  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000f78  6803              LDR      r3,[r0,#0]            ;2308
000f7a  466a              MOV      r2,sp                 ;2308
000f7c  2105              MOVS     r1,#5                 ;2308
000f7e  a8aa              ADD      r0,sp,#0x2a8          ;2308
000f80  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIfEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::FixedLengthList<float>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000f84  2000              MOVS     r0,#0                 ;2310
                  |L28.3974|
000f86  99b6              LDR      r1,[sp,#0x2d8]        ;2310
000f88  eb080280          ADD      r2,r8,r0,LSL #2       ;2311
000f8c  eb010180          ADD      r1,r1,r0,LSL #2       ;2311
000f90  ed920a00          VLDR     s0,[r2,#0]            ;2311
000f94  e04c              B        |L28.4144|
000f96  0000              DCW      0x0000
                  |L28.3992|
                          DCD      ||.data||
                  |L28.3996|
                          DCD      ||.bss||
                  |L28.4000|
                          DCD      ||.bss||+0x1c
                  |L28.4004|
                          DCD      ||.bss||+0x3a4
                  |L28.4008|
                          DCD      ||.bss||+0xcc
                  |L28.4012|
                          DCD      ||.constdata||+0x302e
                  |L28.4016|
000fb0  56697369          DCB      "VisionSystem::Update(): TrackTemplate() failed.\n",0
000fb4  6f6e5379
000fb8  7374656d
000fbc  3a3a5570
000fc0  64617465
000fc4  28293a20
000fc8  54726163
000fcc  6b54656d
000fd0  706c6174
000fd4  65282920
000fd8  6661696c
000fdc  65642e0a
000fe0  00      
000fe1  00                DCB      0
000fe2  00                DCB      0
000fe3  00                DCB      0
                  |L28.4068|
                          DCD      ||.bss||+0x38
                  |L28.4072|
                          DCD      ||.bss||+0xec
                  |L28.4076|
                          DCD      ||.bss||+0x3e8
                  |L28.4080|
                          DCD      ||.constdata||+0x2ce4
                  |L28.4084|
000ff4  56697369          DCB      "VisionSystem::Update::FaceDetectionParametersNotInitial"
000ff8  6f6e5379
000ffc  7374656d
001000  3a3a5570
001004  64617465
001008  3a3a4661
00100c  63654465
001010  74656374
001014  696f6e50
001018  6172616d
00101c  65746572
001020  734e6f74
001024  496e6974
001028  69616c  
00102b  697a6564          DCB      "ized",0
00102f  00      
                  |L28.4144|
001030  1c40              ADDS     r0,r0,#1              ;2310
001032  ed810a00          VSTR     s0,[r1,#0]            ;2310
001036  2805              CMP      r0,#5                 ;2310
001038  dba5              BLT      |L28.3974|
00103a  a9aa              ADD      r1,sp,#0x2a8          ;2313
00103c  a8a0              ADD      r0,sp,#0x280          ;2313
00103e  f7fffffe          BL       _ZN4Anki8Embedded17CorrectVignettingERNS0_5ArrayIhEERKNS0_15FixedLengthListIfEE ; Anki::Embedded::CorrectVignetting(Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::FixedLengthList<float>&)
001042  f6af3020          ADR      r0,|L28.1316|
001046  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
                  |L28.4170|
00104a  f8d91024          LDR      r1,[r9,#0x24]         ;2318  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754731autoExposure_adjustEveryNFramesE
00104e  f8d90038          LDR      r0,[r9,#0x38]         ;2318  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754711frameNumberE
001052  fb90f2f1          SDIV     r2,r0,r1              ;2318
001056  fb010012          MLS      r0,r1,r2,r0           ;2318
00105a  bb90              CBNZ     r0,|L28.4290|
00105c  f6af3008          ADR      r0,|L28.1368|
001060  f7fffffe          BL       _ZN4Anki8Embedded14BeginBenchmarkEPKc ; Anki::Embedded::BeginBenchmark(const char*)
001064  49fe              LDR      r1,|L28.5216|
001066  a8aa              ADD      r0,sp,#0x2a8          ;2321
001068  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00106c  4683              MOV      r11,r0                ;2321
00106e  ad02              ADD      r5,sp,#8              ;2321
001070  f04f0a00          MOV      r10,#0                ;2321
001074  2101              MOVS     r1,#1                 ;2321
001076  a8a0              ADD      r0,sp,#0x280          ;2321
001078  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00107c  f1a00801          SUB      r8,r0,#1              ;2321
001080  2600              MOVS     r6,#0                 ;2321
001082  4631              MOV      r1,r6                 ;2321
001084  a8a0              ADD      r0,sp,#0x280          ;2321
001086  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00108a  1e40              SUBS     r0,r0,#1              ;2321
00108c  e9cd6004          STRD     r6,r0,[sp,#0x10]      ;2321
001090  48f4              LDR      r0,|L28.5220|
001092  e9cd0b00          STRD     r0,r11,[sp,#0]        ;2321
001096  e9cda802          STRD     r10,r8,[sp,#8]        ;2321
00109a  edd91a08          VLDR     s3,[r9,#0x20]         ;2321
00109e  ed991a06          VLDR     s2,[r9,#0x18]         ;2321
0010a2  edd90a05          VLDR     s1,[r9,#0x14]         ;2321
0010a6  ed990a07          VLDR     s0,[r9,#0x1c]         ;2321
0010aa  f8993002          LDRB     r3,[r9,#2]            ;2321  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754722autoExposure_highValueE
0010ae  4629              MOV      r1,r5                 ;2321
0010b0  a8a0              ADD      r0,sp,#0x280          ;2321
0010b2  f8d92010          LDR      r2,[r9,#0x10]         ;2321  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754735autoExposure_integerCountsIncrementE
0010b6  f7fffffe          BL       _ZN4Anki8Embedded27ComputeBestCameraParametersERKNS0_5ArrayIhEERKNS0_9RectangleIiEEihffffRfNS0_11MemoryStackE ; Anki::Embedded::ComputeBestCameraParameters(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::Rectangle<int>&, int, unsigned char, float, float, float, float, float&, Anki::Embedded::MemoryStack)
0010ba  f6af3064          ADR      r0,|L28.1368|
0010be  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
                  |L28.4290|
0010c2  f8990001          LDRB     r0,[r9,#1]            ;2335  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754720vignettingCorrectionE
0010c6  2801              CMP      r0,#1                 ;2335
0010c8  bf18              IT       NE                    ;2335
0010ca  2000              MOVNE    r0,#0                 ;2335
0010cc  49e6              LDR      r1,|L28.5224|
0010ce  ed910a0d          VLDR     s0,[r1,#0x34]         ;2335
0010d2  f7fffffe          BL       _ZN4Anki5Cozmo3HAL19CameraSetParametersEfb ; Anki::Cozmo::HAL::CameraSetParameters(float, bool)
0010d6  f6af30d8          ADR      r0,|L28.1280|
0010da  f7fffffe          BL       _ZN4Anki8Embedded12EndBenchmarkEPKc ; Anki::Embedded::EndBenchmark(const char*)
0010de  2300              MOVS     r3,#0                 ;2339
0010e0  461a              MOV      r2,r3                 ;2339
0010e2  4619              MOV      r1,r3                 ;2339
0010e4  a8be              ADD      r0,sp,#0x2f8          ;2339
0010e6  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0010ea  6800              LDR      r0,[r0,#0]            ;2339
0010ec  9000              STR      r0,[sp,#0]            ;2339
0010ee  48df              LDR      r0,|L28.5228|
0010f0  f5a07373          SUB      r3,r0,#0x3cc          ;2339
0010f4  e9d01201          LDRD     r1,r2,[r0,#4]         ;2339
0010f8  a8a5              ADD      r0,sp,#0x294          ;2339
0010fa  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0010fe  aea0              ADD      r6,sp,#0x280          ;2344
001100  ada5              ADD      r5,sp,#0x294          ;2344
001102  49d7              LDR      r1,|L28.5216|
001104  a8b7              ADD      r0,sp,#0x2dc          ;2344
001106  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00110a  4680              MOV      r8,r0                 ;2344
00110c  2101              MOVS     r1,#1                 ;2344
00110e  4630              MOV      r0,r6                 ;2344
001110  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
001114  4681              MOV      r9,r0                 ;2344
001116  2101              MOVS     r1,#1                 ;2344
001118  4628              MOV      r0,r5                 ;2344
00111a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00111e  fb99f0f0          SDIV     r0,r9,r0              ;2344
001122  f7fffffe          BL       Log2u32
001126  ea5f0900          MOVS     r9,r0                 ;2344
00112a  d00a              BEQ      |L28.4418|
00112c  4641              MOV      r1,r8                 ;2344
00112e  4668              MOV      r0,sp                 ;2344
001130  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
001134  4603              MOV      r3,r0                 ;2344
001136  462a              MOV      r2,r5                 ;2344
001138  4649              MOV      r1,r9                 ;2344
00113a  4630              MOV      r0,r6                 ;2344
00113c  f7fffffe          BL       _ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)
001140  e003              B        |L28.4426|
                  |L28.4418|
001142  4631              MOV      r1,r6                 ;2344
001144  4628              MOV      r0,r5                 ;2344
001146  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhE3SetERKS2_ ; Anki::Embedded::Array<unsigned char>::Set(const Anki::Embedded::Array<unsigned char>&)
                  |L28.4426|
00114a  a8a5              ADD      r0,sp,#0x294          ;2346
00114c  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem22DownsampleAndSendImageERKNS_8Embedded5ArrayIhEE ; Anki::Cozmo::VisionSystem::DownsampleAndSendImage(const Anki::Embedded::Array<unsigned char>&)
001150  2014              MOVS     r0,#0x14              ;2348
001152  2200              MOVS     r2,#0                 ;2348
001154  9002              STR      r0,[sp,#8]            ;2348
001156  f50d7abe          ADD      r10,sp,#0x17c         ;2348
00115a  4ec5              LDR      r6,|L28.5232|
00115c  f44f7580          MOV      r5,#0x100             ;2348
001160  2301              MOVS     r3,#1                 ;2348
001162  4611              MOV      r1,r2                 ;2348
001164  a8be              ADD      r0,sp,#0x2f8          ;2348
001166  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00116a  6801              LDR      r1,[r0,#0]            ;2348
00116c  9108              STR      r1,[sp,#0x20]         ;2348
00116e  e9cd5100          STRD     r5,r1,[sp,#0]         ;2348
001172  4633              MOV      r3,r6                 ;2348
001174  2101              MOVS     r1,#1                 ;2348
001176  a803              ADD      r0,sp,#0xc            ;2348
001178  9a02              LDR      r2,[sp,#8]            ;2348
00117a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEEC1EiiPviNS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::Stage>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)
00117e  4601              MOV      r1,r0                 ;2348
001180  2200              MOVS     r2,#0                 ;2348
001182  e8b10960          LDM      r1!,{r5,r6,r8,r11}    ;2348
001186  f8d09010          LDR      r9,[r0,#0x10]         ;2348
00118a  4611              MOV      r1,r2                 ;2348
00118c  a8aa              ADD      r0,sp,#0x2a8          ;2348
00118e  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
001192  2200              MOVS     r2,#0                 ;2348
001194  9000              STR      r0,[sp,#0]            ;2348
001196  4611              MOV      r1,r2                 ;2348
001198  a8ad              ADD      r0,sp,#0x2b4          ;2348
00119a  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00119e  9b00              LDR      r3,[sp,#0]            ;2348
0011a0  2d00              CMP      r5,#0                 ;2348
0011a2  e9d31200          LDRD     r1,r2,[r3,#0]         ;2348
0011a6  689b              LDR      r3,[r3,#8]            ;2348
0011a8  9361              STR      r3,[sp,#0x184]        ;2348
0011aa  e9cd125f          STRD     r1,r2,[sp,#0x17c]     ;2348
0011ae  e9d01200          LDRD     r1,r2,[r0,#0]         ;2348
0011b2  6883              LDR      r3,[r0,#8]            ;2348
0011b4  a862              ADD      r0,sp,#0x188          ;2348
0011b6  f8cd91a4          STR      r9,[sp,#0x1a4]        ;2348
0011ba  e8a0096e          STM      r0!,{r1-r3,r5,r6,r8,r11};2348
0011be  bfc8              IT       GT                    ;2348
0011c0  2e00              CMPGT    r6,#0                 ;2348
0011c2  dd25              BLE      |L28.4624|
0011c4  fb05f006          MUL      r0,r5,r6              ;2348
0011c8  b310              CBZ      r0,|L28.4624|
0011ca  2000              MOVS     r0,#0                 ;2348
0011cc  fb009008          MLA      r0,r0,r8,r9           ;2348
0011d0  906a              STR      r0,[sp,#0x1a8]        ;2348
                  |L28.4562|
0011d2  2d00              CMP      r5,#0                 ;2348
0011d4  bfc8              IT       GT                    ;2348
0011d6  2e00              CMPGT    r6,#0                 ;2348
0011d8  dd1c              BLE      |L28.4628|
0011da  fb05f006          MUL      r0,r5,r6              ;2348
0011de  b1c8              CBZ      r0,|L28.4628|
0011e0  2000              MOVS     r0,#0                 ;2348
0011e2  fb009008          MLA      r0,r0,r8,r9           ;2348
0011e6  906b              STR      r0,[sp,#0x1ac]        ;2348
                  |L28.4584|
0011e8  2d00              CMP      r5,#0                 ;2348
0011ea  bfc8              IT       GT                    ;2348
0011ec  2e00              CMPGT    r6,#0                 ;2348
0011ee  dd13              BLE      |L28.4632|
0011f0  fb05f006          MUL      r0,r5,r6              ;2348
0011f4  b180              CBZ      r0,|L28.4632|
0011f6  2000              MOVS     r0,#0                 ;2348
0011f8  fb009008          MLA      r0,r0,r8,r9           ;2348
0011fc  906b              STR      r0,[sp,#0x1ac]        ;2348
                  |L28.4606|
0011fe  a808              ADD      r0,sp,#0x20           ;2348
001200  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
001204  b150              CBZ      r0,|L28.4636|
001206  4650              MOV      r0,r10                ;2348
001208  9902              LDR      r1,[sp,#8]            ;2348
00120a  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5StageEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Classifier::CascadeClassifier::Stage>::set_size(int)
00120e  e009              B        |L28.4644|
                  |L28.4624|
001210  946a              STR      r4,[sp,#0x1a8]        ;2348
001212  e7de              B        |L28.4562|
                  |L28.4628|
001214  946b              STR      r4,[sp,#0x1ac]        ;2348
001216  e7e7              B        |L28.4584|
                  |L28.4632|
001218  946b              STR      r4,[sp,#0x1ac]        ;2348
00121a  e7f0              B        |L28.4606|
                  |L28.4636|
00121c  2100              MOVS     r1,#0                 ;2348
00121e  4650              MOV      r0,r10                ;2348
001220  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5StageEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Classifier::CascadeClassifier::Stage>::set_size(int)
                  |L28.4644|
001224  208b              MOVS     r0,#0x8b              ;2349
001226  f8cda2bc          STR      r10,[sp,#0x2bc]       ;2349
00122a  2200              MOVS     r2,#0                 ;2349
00122c  9002              STR      r0,[sp,#8]            ;2349
00122e  f50d7ad8          ADD      r10,sp,#0x1b0         ;2349
001232  4e90              LDR      r6,|L28.5236|
001234  f44f750f          MOV      r5,#0x23c             ;2349
001238  2301              MOVS     r3,#1                 ;2349
00123a  4611              MOV      r1,r2                 ;2349
00123c  a8be              ADD      r0,sp,#0x2f8          ;2349
00123e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
001242  6800              LDR      r0,[r0,#0]            ;2349
001244  9008              STR      r0,[sp,#0x20]         ;2349
001246  e9cd5000          STRD     r5,r0,[sp,#0]         ;2349
00124a  4633              MOV      r3,r6                 ;2349
00124c  2101              MOVS     r1,#1                 ;2349
00124e  a803              ADD      r0,sp,#0xc            ;2349
001250  9a02              LDR      r2,[sp,#8]            ;2349
001252  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEEC1EiiPviNS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTree>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)
001256  f8d09010          LDR      r9,[r0,#0x10]         ;2349
00125a  e8b00960          LDM      r0!,{r5,r6,r8,r11}    ;2349
00125e  2200              MOVS     r2,#0                 ;2349
001260  4611              MOV      r1,r2                 ;2349
001262  a8aa              ADD      r0,sp,#0x2a8          ;2349
001264  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
001268  2200              MOVS     r2,#0                 ;2349
00126a  9000              STR      r0,[sp,#0]            ;2349
00126c  4611              MOV      r1,r2                 ;2349
00126e  a8b0              ADD      r0,sp,#0x2c0          ;2349
001270  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
001274  9a00              LDR      r2,[sp,#0]            ;2349
001276  4603              MOV      r3,r0                 ;2349
001278  2d00              CMP      r5,#0                 ;2349
00127a  e9d20100          LDRD     r0,r1,[r2,#0]         ;2349
00127e  6892              LDR      r2,[r2,#8]            ;2349
001280  926e              STR      r2,[sp,#0x1b8]        ;2349
001282  e9cd016c          STRD     r0,r1,[sp,#0x1b0]     ;2349
001286  e9d30100          LDRD     r0,r1,[r3,#0]         ;2349
00128a  689a              LDR      r2,[r3,#8]            ;2349
00128c  ab6f              ADD      r3,sp,#0x1bc          ;2349
00128e  f8cd91d8          STR      r9,[sp,#0x1d8]        ;2349
001292  e8a30967          STM      r3!,{r0-r2,r5,r6,r8,r11};2349
001296  bfc8              IT       GT                    ;2349
001298  2e00              CMPGT    r6,#0                 ;2349
00129a  dd25              BLE      |L28.4840|
00129c  fb05f006          MUL      r0,r5,r6              ;2349
0012a0  b310              CBZ      r0,|L28.4840|
0012a2  2000              MOVS     r0,#0                 ;2349
0012a4  fb009008          MLA      r0,r0,r8,r9           ;2349
0012a8  9077              STR      r0,[sp,#0x1dc]        ;2349
                  |L28.4778|
0012aa  2d00              CMP      r5,#0                 ;2349
0012ac  bfc8              IT       GT                    ;2349
0012ae  2e00              CMPGT    r6,#0                 ;2349
0012b0  dd1c              BLE      |L28.4844|
0012b2  fb05f006          MUL      r0,r5,r6              ;2349
0012b6  b1c8              CBZ      r0,|L28.4844|
0012b8  2000              MOVS     r0,#0                 ;2349
0012ba  fb009008          MLA      r0,r0,r8,r9           ;2349
0012be  9078              STR      r0,[sp,#0x1e0]        ;2349
                  |L28.4800|
0012c0  2d00              CMP      r5,#0                 ;2349
0012c2  bfc8              IT       GT                    ;2349
0012c4  2e00              CMPGT    r6,#0                 ;2349
0012c6  dd13              BLE      |L28.4848|
0012c8  fb05f006          MUL      r0,r5,r6              ;2349
0012cc  b180              CBZ      r0,|L28.4848|
0012ce  2000              MOVS     r0,#0                 ;2349
0012d0  fb009008          MLA      r0,r0,r8,r9           ;2349
0012d4  9078              STR      r0,[sp,#0x1e0]        ;2349
                  |L28.4822|
0012d6  a808              ADD      r0,sp,#0x20           ;2349
0012d8  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0012dc  b150              CBZ      r0,|L28.4852|
0012de  4650              MOV      r0,r10                ;2349
0012e0  9902              LDR      r1,[sp,#8]            ;2349
0012e2  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5DTreeEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Classifier::CascadeClassifier::DTree>::set_size(int)
0012e6  e009              B        |L28.4860|
                  |L28.4840|
0012e8  9477              STR      r4,[sp,#0x1dc]        ;2349
0012ea  e7de              B        |L28.4778|
                  |L28.4844|
0012ec  9478              STR      r4,[sp,#0x1e0]        ;2349
0012ee  e7e7              B        |L28.4800|
                  |L28.4848|
0012f0  9478              STR      r4,[sp,#0x1e0]        ;2349
0012f2  e7f0              B        |L28.4822|
                  |L28.4852|
0012f4  2100              MOVS     r1,#0                 ;2349
0012f6  4650              MOV      r0,r10                ;2349
0012f8  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5DTreeEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Classifier::CascadeClassifier::DTree>::set_size(int)
                  |L28.4860|
0012fc  208b              MOVS     r0,#0x8b              ;2350
0012fe  f8cda2c0          STR      r10,[sp,#0x2c0]       ;2350
001302  2200              MOVS     r2,#0                 ;2350
001304  9002              STR      r0,[sp,#8]            ;2350
001306  f50d7af2          ADD      r10,sp,#0x1e4         ;2350
00130a  4e5b              LDR      r6,|L28.5240|
00130c  f44f650c          MOV      r5,#0x8c0             ;2350
001310  2301              MOVS     r3,#1                 ;2350
001312  4611              MOV      r1,r2                 ;2350
001314  a8be              ADD      r0,sp,#0x2f8          ;2350
001316  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00131a  6801              LDR      r1,[r0,#0]            ;2350
00131c  9108              STR      r1,[sp,#0x20]         ;2350
00131e  e9cd5100          STRD     r5,r1,[sp,#0]         ;2350
001322  4633              MOV      r3,r6                 ;2350
001324  2101              MOVS     r1,#1                 ;2350
001326  a803              ADD      r0,sp,#0xc            ;2350
001328  9a02              LDR      r2,[sp,#8]            ;2350
00132a  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEEC1EiiPviNS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)
00132e  4601              MOV      r1,r0                 ;2350
001330  2200              MOVS     r2,#0                 ;2350
001332  e8b10960          LDM      r1!,{r5,r6,r8,r11}    ;2350
001336  f8d09010          LDR      r9,[r0,#0x10]         ;2350
00133a  4611              MOV      r1,r2                 ;2350
00133c  a8aa              ADD      r0,sp,#0x2a8          ;2350
00133e  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
001342  2200              MOVS     r2,#0                 ;2350
001344  9000              STR      r0,[sp,#0]            ;2350
001346  4611              MOV      r1,r2                 ;2350
001348  a8b1              ADD      r0,sp,#0x2c4          ;2350
00134a  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00134e  9b00              LDR      r3,[sp,#0]            ;2350
001350  2d00              CMP      r5,#0                 ;2350
001352  e9d31200          LDRD     r1,r2,[r3,#0]         ;2350
001356  689b              LDR      r3,[r3,#8]            ;2350
001358  937b              STR      r3,[sp,#0x1ec]        ;2350
00135a  e9cd1279          STRD     r1,r2,[sp,#0x1e4]     ;2350
00135e  e9d01200          LDRD     r1,r2,[r0,#0]         ;2350
001362  6883              LDR      r3,[r0,#8]            ;2350
001364  a87c              ADD      r0,sp,#0x1f0          ;2350
001366  f8cd920c          STR      r9,[sp,#0x20c]        ;2350
00136a  e8a0096e          STM      r0!,{r1-r3,r5,r6,r8,r11};2350
00136e  bfc8              IT       GT                    ;2350
001370  2e00              CMPGT    r6,#0                 ;2350
001372  dd25              BLE      |L28.5056|
001374  fb05f006          MUL      r0,r5,r6              ;2350
001378  b310              CBZ      r0,|L28.5056|
00137a  2000              MOVS     r0,#0                 ;2350
00137c  fb009008          MLA      r0,r0,r8,r9           ;2350
001380  9084              STR      r0,[sp,#0x210]        ;2350
                  |L28.4994|
001382  2d00              CMP      r5,#0                 ;2350
001384  bfc8              IT       GT                    ;2350
001386  2e00              CMPGT    r6,#0                 ;2350
001388  dd1c              BLE      |L28.5060|
00138a  fb05f006          MUL      r0,r5,r6              ;2350
00138e  b1c8              CBZ      r0,|L28.5060|
001390  2000              MOVS     r0,#0                 ;2350
001392  fb009008          MLA      r0,r0,r8,r9           ;2350
001396  9085              STR      r0,[sp,#0x214]        ;2350
                  |L28.5016|
001398  2d00              CMP      r5,#0                 ;2350
00139a  bfc8              IT       GT                    ;2350
00139c  2e00              CMPGT    r6,#0                 ;2350
00139e  dd13              BLE      |L28.5064|
0013a0  fb05f006          MUL      r0,r5,r6              ;2350
0013a4  b180              CBZ      r0,|L28.5064|
0013a6  2000              MOVS     r0,#0                 ;2350
0013a8  fb009008          MLA      r0,r0,r8,r9           ;2350
0013ac  9085              STR      r0,[sp,#0x214]        ;2350
                  |L28.5038|
0013ae  a808              ADD      r0,sp,#0x20           ;2350
0013b0  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0013b4  b150              CBZ      r0,|L28.5068|
0013b6  4650              MOV      r0,r10                ;2350
0013b8  9902              LDR      r1,[sp,#8]            ;2350
0013ba  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier9DTreeNodeEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>::set_size(int)
0013be  e009              B        |L28.5076|
                  |L28.5056|
0013c0  9484              STR      r4,[sp,#0x210]        ;2350
0013c2  e7de              B        |L28.4994|
                  |L28.5060|
0013c4  9485              STR      r4,[sp,#0x214]        ;2350
0013c6  e7e7              B        |L28.5016|
                  |L28.5064|
0013c8  9485              STR      r4,[sp,#0x214]        ;2350
0013ca  e7f0              B        |L28.5038|
                  |L28.5068|
0013cc  2100              MOVS     r1,#0                 ;2350
0013ce  4650              MOV      r0,r10                ;2350
0013d0  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier9DTreeNodeEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>::set_size(int)
                  |L28.5076|
0013d4  f8cda2c4          STR      r10,[sp,#0x2c4]       ;2351
0013d8  2200              MOVS     r2,#0                 ;2351
0013da  f50d7b46          ADD      r11,sp,#0x318         ;2351
0013de  f44f758b          MOV      r5,#0x116             ;2351
0013e2  f8dfa098          LDR      r10,|L28.5244|
0013e6  f44f668d          MOV      r6,#0x468             ;2351
0013ea  2301              MOVS     r3,#1                 ;2351
0013ec  4611              MOV      r1,r2                 ;2351
0013ee  a8be              ADD      r0,sp,#0x2f8          ;2351
0013f0  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0013f4  6800              LDR      r0,[r0,#0]            ;2351
0013f6  2200              MOVS     r2,#0                 ;2351
0013f8  9004              STR      r0,[sp,#0x10]         ;2351
0013fa  4611              MOV      r1,r2                 ;2351
0013fc  a8b2              ADD      r0,sp,#0x2c8          ;2351
0013fe  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
001402  4681              MOV      r9,r0                 ;2351
001404  2200              MOVS     r2,#0                 ;2351
001406  4611              MOV      r1,r2                 ;2351
001408  a8aa              ADD      r0,sp,#0x2a8          ;2351
00140a  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00140e  4680              MOV      r8,r0                 ;2351
001410  9804              LDR      r0,[sp,#0x10]         ;2351
001412  4653              MOV      r3,r10                ;2351
001414  e9cd6000          STRD     r6,r0,[sp,#0]         ;2351
001418  462a              MOV      r2,r5                 ;2351
00141a  2101              MOVS     r1,#1                 ;2351
00141c  a805              ADD      r0,sp,#0x14           ;2351
00141e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiPviNS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)
001422  e9cd8902          STRD     r8,r9,[sp,#8]         ;2351
001426  e9d01203          LDRD     r1,r2,[r0,#0xc]       ;2351
00142a  e9cd1200          STRD     r1,r2,[sp,#0]         ;2351
00142e  e9d01200          LDRD     r1,r2,[r0,#0]         ;2351
001432  6883              LDR      r3,[r0,#8]            ;2351
001434  4658              MOV      r0,r11                ;2351
001436  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEERKNS0_14LinearSequenceIiEES8_ ; Anki::Embedded::ArraySlice<float>::ArraySlice(Anki::Embedded::Array<float>, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
00143a  4682              MOV      r10,r0                ;2351
00143c  6980              LDR      r0,[r0,#0x18]         ;2351
00143e  2800              CMP      r0,#0                 ;2351
001440  bfc4              ITT      GT                    ;2351
001442  f8da101c          LDRGT    r1,[r10,#0x1c]        ;2351
001446  2900              CMPGT    r1,#0                 ;2351
001448  dd2e              BLE      |L28.5288|
00144a  4348              MULS     r0,r1,r0              ;2351
00144c  b360              CBZ      r0,|L28.5288|
00144e  f8da2020          LDR      r2,[r10,#0x20]        ;2351
001452  f8da1028          LDR      r1,[r10,#0x28]        ;2351
001456  2000              MOVS     r0,#0                 ;2351
001458  fb001002          MLA      r0,r0,r2,r1           ;2351
00145c  e010              B        |L28.5248|
00145e  0000              DCW      0x0000
                  |L28.5216|
                          DCD      ||.bss||+0x38
                  |L28.5220|
                          DCD      ||.data||+0x34
                  |L28.5224|
                          DCD      ||.data||
                  |L28.5228|
                          DCD      ||.bss||+0x3e8
                  |L28.5232|
                          DCD      ||.constdata||
                  |L28.5236|
                          DCD      ||.constdata||+0x1b0
                  |L28.5240|
                          DCD      ||.constdata||+0x420
                  |L28.5244|
                          DCD      ||.constdata||+0xdd0
                  |L28.5248|
001480  f8ca0030          STR      r0,[r10,#0x30]        ;2351
                  |L28.5252|
001484  a804              ADD      r0,sp,#0x10           ;2351
001486  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
00148a  b180              CBZ      r0,|L28.5294|
00148c  2101              MOVS     r1,#1                 ;2351
00148e  f10a0018          ADD      r0,r10,#0x18          ;2351
001492  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
001496  42a8              CMP      r0,r5                 ;2351
001498  da11              BGE      |L28.5310|
                  |L28.5274|
00149a  2101              MOVS     r1,#1                 ;2351
00149c  f10a0018          ADD      r0,r10,#0x18          ;2351
0014a0  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0014a4  4605              MOV      r5,r0                 ;2351
0014a6  e00a              B        |L28.5310|
                  |L28.5288|
0014a8  f8ca4030          STR      r4,[r10,#0x30]        ;2351
0014ac  e7ea              B        |L28.5252|
                  |L28.5294|
0014ae  2500              MOVS     r5,#0                 ;2351
0014b0  2101              MOVS     r1,#1                 ;2351
0014b2  f10a0018          ADD      r0,r10,#0x18          ;2351
0014b6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0014ba  42a8              CMP      r0,r5                 ;2351
0014bc  dbed              BLT      |L28.5274|
                  |L28.5310|
0014be  f8ca500c          STR      r5,[r10,#0xc]         ;2352
0014c2  a886              ADD      r0,sp,#0x218          ;2352
0014c4  9003              STR      r0,[sp,#0xc]          ;2352
0014c6  f44f608b          MOV      r0,#0x458             ;2352
0014ca  2200              MOVS     r2,#0                 ;2352
0014cc  9002              STR      r0,[sp,#8]            ;2352
0014ce  4efd              LDR      r6,|L28.6340|
0014d0  f2411570          MOV      r5,#0x1170            ;2352
0014d4  2301              MOVS     r3,#1                 ;2352
0014d6  4611              MOV      r1,r2                 ;2352
0014d8  a8be              ADD      r0,sp,#0x2f8          ;2352
0014da  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0014de  6800              LDR      r0,[r0,#0]            ;2352
0014e0  9009              STR      r0,[sp,#0x24]         ;2352
0014e2  e9cd5000          STRD     r5,r0,[sp,#0]         ;2352
0014e6  4633              MOV      r3,r6                 ;2352
0014e8  2101              MOVS     r1,#1                 ;2352
0014ea  a804              ADD      r0,sp,#0x10           ;2352
0014ec  9a02              LDR      r2,[sp,#8]            ;2352
0014ee  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiEC1EiiPviNS0_5Flags6BufferE ; Anki::Embedded::Array<int>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)
0014f2  f8d09010          LDR      r9,[r0,#0x10]         ;2352
0014f6  e8b00960          LDM      r0!,{r5,r6,r8,r11}    ;2352
0014fa  2200              MOVS     r2,#0                 ;2352
0014fc  4611              MOV      r1,r2                 ;2352
0014fe  a8aa              ADD      r0,sp,#0x2a8          ;2352
001500  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
001504  2200              MOVS     r2,#0                 ;2352
001506  9000              STR      r0,[sp,#0]            ;2352
001508  4611              MOV      r1,r2                 ;2352
00150a  a8b2              ADD      r0,sp,#0x2c8          ;2352
00150c  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
001510  9b00              LDR      r3,[sp,#0]            ;2352
001512  4684              MOV      r12,r0                ;2352
001514  a989              ADD      r1,sp,#0x224          ;2352
001516  e9d30200          LDRD     r0,r2,[r3,#0]         ;2352
00151a  689b              LDR      r3,[r3,#8]            ;2352
00151c  e9cd0286          STRD     r0,r2,[sp,#0x218]     ;2352
001520  9388              STR      r3,[sp,#0x220]        ;2352
001522  e9dc0200          LDRD     r0,r2,[r12,#0]        ;2352
001526  f8dc3008          LDR      r3,[r12,#8]           ;2352
00152a  f8cd9240          STR      r9,[sp,#0x240]        ;2352
00152e  e8a1096d          STM      r1!,{r0,r2,r3,r5,r6,r8,r11};2352
001532  2d00              CMP      r5,#0                 ;2352
001534  bfc8              IT       GT                    ;2352
001536  2e00              CMPGT    r6,#0                 ;2352
001538  dd69              BLE      |L28.5646|
00153a  fb05f006          MUL      r0,r5,r6              ;2352
00153e  b3e8              CBZ      r0,|L28.5564|
001540  2000              MOVS     r0,#0                 ;2352
001542  fb009008          MLA      r0,r0,r8,r9           ;2352
001546  9091              STR      r0,[sp,#0x244]        ;2352
                  |L28.5448|
001548  2d00              CMP      r5,#0                 ;2352
00154a  bfc8              IT       GT                    ;2352
00154c  2e00              CMPGT    r6,#0                 ;2352
00154e  dd60              BLE      |L28.5650|
001550  fb05f006          MUL      r0,r5,r6              ;2352
001554  b398              CBZ      r0,|L28.5566|
001556  2000              MOVS     r0,#0                 ;2352
001558  fb009008          MLA      r0,r0,r8,r9           ;2352
00155c  9092              STR      r0,[sp,#0x248]        ;2352
                  |L28.5470|
00155e  2d00              CMP      r5,#0                 ;2352
001560  bfc8              IT       GT                    ;2352
001562  2e00              CMPGT    r6,#0                 ;2352
001564  dd57              BLE      |L28.5654|
001566  fb05f006          MUL      r0,r5,r6              ;2352
00156a  b348              CBZ      r0,|L28.5568|
00156c  2000              MOVS     r0,#0                 ;2352
00156e  fb009008          MLA      r0,r0,r8,r9           ;2352
001572  9092              STR      r0,[sp,#0x248]        ;2352
                  |L28.5492|
001574  a809              ADD      r0,sp,#0x24           ;2352
001576  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
00157a  2800              CMP      r0,#0                 ;2352
00157c  bf12              ITEE     NE                    ;2352
00157e  e9dd1002          LDRDNE   r1,r0,[sp,#8]         ;2352
001582  2100              MOVEQ    r1,#0                 ;2352
001584  9803              LDREQ    r0,[sp,#0xc]          ;2352
001586  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi ; Anki::Embedded::FixedLengthList<int>::set_size(int)
00158a  9803              LDR      r0,[sp,#0xc]          ;2352
00158c  9008              STR      r0,[sp,#0x20]         ;2353
00158e  a8d3              ADD      r0,sp,#0x34c          ;2353
001590  2200              MOVS     r2,#0                 ;2353
001592  9007              STR      r0,[sp,#0x1c]         ;2353
001594  2688              MOVS     r6,#0x88              ;2353
001596  f8df8330          LDR      r8,|L28.6344|
00159a  f44f6909          MOV      r9,#0x890             ;2353
00159e  2301              MOVS     r3,#1                 ;2353
0015a0  4611              MOV      r1,r2                 ;2353
0015a2  a8be              ADD      r0,sp,#0x2f8          ;2353
0015a4  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0015a8  6800              LDR      r0,[r0,#0]            ;2353
0015aa  2200              MOVS     r2,#0                 ;2353
0015ac  9006              STR      r0,[sp,#0x18]         ;2353
0015ae  4611              MOV      r1,r2                 ;2353
0015b0  a8e7              ADD      r0,sp,#0x39c          ;2353
0015b2  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
0015b6  2200              MOVS     r2,#0                 ;2353
0015b8  4611              MOV      r1,r2                 ;2353
0015ba  e002              B        |L28.5570|
                  |L28.5564|
0015bc  e027              B        |L28.5646|
                  |L28.5566|
0015be  e028              B        |L28.5650|
                  |L28.5568|
0015c0  e029              B        |L28.5654|
                  |L28.5570|
0015c2  9004              STR      r0,[sp,#0x10]         ;2353
0015c4  a8b2              ADD      r0,sp,#0x2c8          ;2353
0015c6  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
0015ca  2101              MOVS     r1,#1                 ;2353
0015cc  9102              STR      r1,[sp,#8]            ;2353
0015ce  9005              STR      r0,[sp,#0x14]         ;2353
0015d0  9906              LDR      r1,[sp,#0x18]         ;2353
0015d2  a8ad              ADD      r0,sp,#0x2b4          ;2353
0015d4  9103              STR      r1,[sp,#0xc]          ;2353
0015d6  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
0015da  f1a0050c          SUB      r5,r0,#0xc            ;2353
0015de  f04f30ff          MOV      r0,#0xffffffff        ;2353
0015e2  6028              STR      r0,[r5,#0]            ;2353
0015e4  6068              STR      r0,[r5,#4]            ;2353
0015e6  612c              STR      r4,[r5,#0x10]         ;2353
0015e8  f8dfb2e0          LDR      r11,|L28.6348|
0015ec  60a8              STR      r0,[r5,#8]            ;2353
0015ee  f0180f0f          TST      r8,#0xf               ;2353
0015f2  d012              BEQ      |L28.5658|
0015f4  2010              MOVS     r0,#0x10              ;2353
0015f6  2157              MOVS     r1,#0x57              ;2353
0015f8  f8cdb000          STR      r11,[sp,#0]           ;2353
0015fc  e9cd1001          STRD     r1,r0,[sp,#4]         ;2353
001600  a3b3              ADR      r3,|L28.6352|
001602  a2c1              ADR      r2,|L28.6408|
001604  a1cd              ADR      r1,|L28.6460|
001606  2005              MOVS     r0,#5                 ;2353
001608  f7fffffe          BL       _Anki_Log
00160c  e040              B        |L28.5776|
                  |L28.5646|
00160e  9491              STR      r4,[sp,#0x244]        ;2353
001610  e79a              B        |L28.5448|
                  |L28.5650|
001612  9492              STR      r4,[sp,#0x248]        ;2353
001614  e7a3              B        |L28.5470|
                  |L28.5654|
001616  9492              STR      r4,[sp,#0x248]        ;2353
001618  e7ac              B        |L28.5492|
                  |L28.5658|
00161a  4630              MOV      r0,r6                 ;2353
00161c  9903              LDR      r1,[sp,#0xc]          ;2353
00161e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)
001622  60a8              STR      r0,[r5,#8]            ;2353
001624  f5b06f09          CMP      r0,#0x890             ;2353
001628  dd09              BLE      |L28.5694|
00162a  205c              MOVS     r0,#0x5c              ;2353
00162c  e9cdb000          STRD     r11,r0,[sp,#0]        ;2353
001630  a3a7              ADR      r3,|L28.6352|
001632  a2c6              ADR      r2,|L28.6476|
001634  a1c9              ADR      r1,|L28.6492|
001636  2005              MOVS     r0,#5                 ;2353
001638  f7fffffe          BL       _Anki_Log
00163c  e028              B        |L28.5776|
                  |L28.5694|
00163e  a803              ADD      r0,sp,#0xc            ;2353
001640  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
001644  b1d8              CBZ      r0,|L28.5758|
001646  68a8              LDR      r0,[r5,#8]            ;2353
001648  f5b06f09          CMP      r0,#0x890             ;2353
00164c  dd09              BLE      |L28.5730|
00164e  2062              MOVS     r0,#0x62              ;2353
001650  e9cdb000          STRD     r11,r0,[sp,#0]        ;2353
001654  a39e              ADR      r3,|L28.6352|
001656  4ac6              LDR      r2,|L28.6512|
001658  a1c0              ADR      r1,|L28.6492|
00165a  2005              MOVS     r0,#5                 ;2353
00165c  f7fffffe          BL       _Anki_Log
001660  e016              B        |L28.5776|
                  |L28.5730|
001662  a803              ADD      r0,sp,#0xc            ;2353
001664  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
001668  b148              CBZ      r0,|L28.5758|
00166a  206e              MOVS     r0,#0x6e              ;2353
00166c  e9cdb000          STRD     r11,r0,[sp,#0]        ;2353
001670  a397              ADR      r3,|L28.6352|
001672  4ac0              LDR      r2,|L28.6516|
001674  a1b9              ADR      r1,|L28.6492|
001676  2005              MOVS     r0,#5                 ;2353
001678  f7fffffe          BL       _Anki_Log
00167c  e008              B        |L28.5776|
                  |L28.5758|
00167e  9803              LDR      r0,[sp,#0xc]          ;2353
001680  4643              MOV      r3,r8                 ;2353
001682  e9cd9000          STRD     r9,r0,[sp,#0]         ;2353
001686  4632              MOV      r2,r6                 ;2353
001688  4628              MOV      r0,r5                 ;2353
00168a  9902              LDR      r1,[sp,#8]            ;2353
00168c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE16InitializeBufferEiiPviNS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)
                  |L28.5776|
001690  e9dd1004          LDRD     r1,r0,[sp,#0x10]      ;2353
001694  e9cd0102          STRD     r0,r1,[sp,#8]         ;2353
001698  e9d50103          LDRD     r0,r1,[r5,#0xc]       ;2353
00169c  e9cd0100          STRD     r0,r1,[sp,#0]         ;2353
0016a0  e9d51200          LDRD     r1,r2,[r5,#0]         ;2353
0016a4  68ab              LDR      r3,[r5,#8]            ;2353
0016a6  9807              LDR      r0,[sp,#0x1c]         ;2353
0016a8  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceINS0_9RectangleIiEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_ ; Anki::Embedded::ArraySlice<Anki::Embedded::Rectangle<int>>::ArraySlice(Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
0016ac  4605              MOV      r5,r0                 ;2353
0016ae  6980              LDR      r0,[r0,#0x18]         ;2353
0016b0  2800              CMP      r0,#0                 ;2353
0016b2  bfc4              ITT      GT                    ;2353
0016b4  69e9              LDRGT    r1,[r5,#0x1c]         ;2353
0016b6  2900              CMPGT    r1,#0                 ;2353
0016b8  dd10              BLE      |L28.5852|
0016ba  4348              MULS     r0,r1,r0              ;2353
0016bc  b170              CBZ      r0,|L28.5852|
0016be  6a2a              LDR      r2,[r5,#0x20]         ;2353
0016c0  6aa9              LDR      r1,[r5,#0x28]         ;2353
0016c2  2000              MOVS     r0,#0                 ;2353
0016c4  fb001002          MLA      r0,r0,r2,r1           ;2353
0016c8  6328              STR      r0,[r5,#0x30]         ;2353
                  |L28.5834|
0016ca  a806              ADD      r0,sp,#0x18           ;2353
0016cc  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0016d0  b130              CBZ      r0,|L28.5856|
0016d2  4631              MOV      r1,r6                 ;2353
0016d4  4628              MOV      r0,r5                 ;2353
0016d6  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_9RectangleIiEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Rectangle<int>>::set_size(int)
0016da  e005              B        |L28.5864|
                  |L28.5852|
0016dc  632c              STR      r4,[r5,#0x30]         ;2353
0016de  e7f4              B        |L28.5834|
                  |L28.5856|
0016e0  2100              MOVS     r1,#0                 ;2353
0016e2  4628              MOV      r0,r5                 ;2353
0016e4  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_9RectangleIiEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Rectangle<int>>::set_size(int)
                  |L28.5864|
0016e8  4aa3              LDR      r2,|L28.6520|
0016ea  9808              LDR      r0,[sp,#0x20]         ;2355
0016ec  f8cda018          STR      r10,[sp,#0x18]        ;2355
0016f0  9209              STR      r2,[sp,#0x24]         ;2355
0016f2  e9cd0507          STRD     r0,r5,[sp,#0x1c]      ;2355
0016f6  e9dd12af          LDRD     r1,r2,[sp,#0x2bc]     ;2355
0016fa  ae02              ADD      r6,sp,#8              ;2355
0016fc  2018              MOVS     r0,#0x18              ;2355
0016fe  9bb1              LDR      r3,[sp,#0x2c4]        ;2355
001700  c60f              STM      r6!,{r0-r3}           ;2355
001702  f44f7180          MOV      r1,#0x100             ;2355
001706  e9cd1000          STRD     r1,r0,[sp,#0]         ;2355
00170a  2301              MOVS     r3,#1                 ;2355
00170c  2200              MOVS     r2,#0                 ;2355
00170e  4619              MOV      r1,r3                 ;2355
001710  a80a              ADD      r0,sp,#0x28           ;2355
001712  f7fffffe          BL       _ZN4Anki8Embedded10Classifier21CascadeClassifier_LBPC1EbiiiiiRKNS0_15FixedLengthListINS1_17CascadeClassifier5StageEEERKNS3_INS4_5DTreeEEERKNS3_INS4_9DTreeNodeEEERKNS3_IfEERKNS3_IiEERKNS3_INS0_9RectangleIiEEEERNS0_11MemoryStackE ; Anki::Embedded::Classifier::CascadeClassifier_LBP::CascadeClassifier_LBP(bool, int, int, int, int, int, const Anki::Embedded::FixedLengthList<Anki::Embedded::Classifier::CascadeClassifier::Stage>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Classifier::CascadeClassifier::DTree>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>&, const Anki::Embedded::FixedLengthList<float>&, const Anki::Embedded::FixedLengthList<int>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Rectangle<int>>&, Anki::Embedded::MemoryStack&)
001716  a893              ADD      r0,sp,#0x24c          ;2370
001718  f8dfb260          LDR      r11,|L28.6524|
00171c  9008              STR      r0,[sp,#0x20]         ;2370
00171e  2300              MOVS     r3,#0                 ;2370
001720  f5ab797a          SUB      r9,r11,#0x3e8         ;2370
001724  461a              MOV      r2,r3                 ;2370
001726  2101              MOVS     r1,#1                 ;2370
001728  a8be              ADD      r0,sp,#0x2f8          ;2370
00172a  f8db802c          LDR      r8,[r11,#0x2c]        ;2370  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754724faceDetectionParameters_E
00172e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
001732  6800              LDR      r0,[r0,#0]            ;2370
001734  2200              MOVS     r2,#0                 ;2370
001736  9006              STR      r0,[sp,#0x18]         ;2370
001738  4611              MOV      r1,r2                 ;2370
00173a  a8b2              ADD      r0,sp,#0x2c8          ;2370
00173c  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
001740  2200              MOVS     r2,#0                 ;2370
001742  9002              STR      r0,[sp,#8]            ;2370
001744  4611              MOV      r1,r2                 ;2370
001746  a8af              ADD      r0,sp,#0x2bc          ;2370
001748  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
00174c  2101              MOVS     r1,#1                 ;2370
00174e  9003              STR      r0,[sp,#0xc]          ;2370
001750  9109              STR      r1,[sp,#0x24]         ;2370
001752  a8ad              ADD      r0,sp,#0x2b4          ;2370
001754  9e06              LDR      r6,[sp,#0x18]         ;2370
001756  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00175a  f1a0050c          SUB      r5,r0,#0xc            ;2370
00175e  f04f30ff          MOV      r0,#0xffffffff        ;2370
001762  6028              STR      r0,[r5,#0]            ;2370
001764  6068              STR      r0,[r5,#4]            ;2370
001766  612c              STR      r4,[r5,#0x10]         ;2370
001768  60a8              STR      r0,[r5,#8]            ;2370
00176a  f1b80f00          CMP      r8,#0                 ;2370
00176e  da0a              BGE      |L28.6022|
001770  217d              MOVS     r1,#0x7d              ;2370
001772  4883              LDR      r0,|L28.6528|
001774  e9cd0100          STRD     r0,r1,[sp,#0]         ;2370
001778  a355              ADR      r3,|L28.6352|
00177a  a274              ADR      r2,|L28.6476|
00177c  a177              ADR      r1,|L28.6492|
00177e  2005              MOVS     r0,#5                 ;2370
001780  f7fffffe          BL       _Anki_Log
001784  e029              B        |L28.6106|
                  |L28.6022|
001786  4631              MOV      r1,r6                 ;2370
001788  4640              MOV      r0,r8                 ;2370
00178a  9407              STR      r4,[sp,#0x1c]         ;2370
00178c  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)
001790  f1b00a00          SUBS     r10,r0,#0             ;2370
001794  a807              ADD      r0,sp,#0x1c           ;2370
001796  e9cd0604          STRD     r0,r6,[sp,#0x10]      ;2370
00179a  dc0a              BGT      |L28.6066|
00179c  f240310b          MOV      r1,#0x30b             ;2370
0017a0  4878              LDR      r0,|L28.6532|
0017a2  e9cd0100          STRD     r0,r1,[sp,#0]         ;2370
0017a6  a34a              ADR      r3,|L28.6352|
0017a8  a268              ADR      r2,|L28.6476|
0017aa  a177              ADR      r1,|L28.6536|
0017ac  2005              MOVS     r0,#5                 ;2370
0017ae  f7fffffe          BL       _Anki_Log
                  |L28.6066|
0017b2  a805              ADD      r0,sp,#0x14           ;2370
0017b4  f8c5a008          STR      r10,[r5,#8]           ;2370
0017b8  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
0017bc  4602              MOV      r2,r0                 ;2370
0017be  4651              MOV      r1,r10                ;2370
0017c0  4648              MOV      r0,r9                 ;2370
0017c2  9b04              LDR      r3,[sp,#0x10]         ;2370
0017c4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0017c8  9907              LDR      r1,[sp,#0x1c]         ;2370
0017ca  4603              MOV      r3,r0                 ;2370
0017cc  9100              STR      r1,[sp,#0]            ;2370
0017ce  9601              STR      r6,[sp,#4]            ;2370
0017d0  4642              MOV      r2,r8                 ;2370
0017d2  4628              MOV      r0,r5                 ;2370
0017d4  9909              LDR      r1,[sp,#0x24]         ;2370
0017d6  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE16InitializeBufferEiiPviNS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)
                  |L28.6106|
0017da  e9dd1002          LDRD     r1,r0,[sp,#8]         ;2370
0017de  e9cd0102          STRD     r0,r1,[sp,#8]         ;2370
0017e2  e9d50103          LDRD     r0,r1,[r5,#0xc]       ;2370
0017e6  e9cd0100          STRD     r0,r1,[sp,#0]         ;2370
0017ea  e9d51200          LDRD     r1,r2,[r5,#0]         ;2370
0017ee  68ab              LDR      r3,[r5,#8]            ;2370
0017f0  9808              LDR      r0,[sp,#0x20]         ;2370
0017f2  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceINS0_9RectangleIiEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_ ; Anki::Embedded::ArraySlice<Anki::Embedded::Rectangle<int>>::ArraySlice(Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
0017f6  4605              MOV      r5,r0                 ;2370
0017f8  6980              LDR      r0,[r0,#0x18]         ;2370
0017fa  2800              CMP      r0,#0                 ;2370
0017fc  bfc4              ITT      GT                    ;2370
0017fe  69e9              LDRGT    r1,[r5,#0x1c]         ;2370
001800  2900              CMPGT    r1,#0                 ;2370
001802  dd10              BLE      |L28.6182|
001804  4348              MULS     r0,r1,r0              ;2370
001806  b170              CBZ      r0,|L28.6182|
001808  6a2a              LDR      r2,[r5,#0x20]         ;2370
00180a  6aa9              LDR      r1,[r5,#0x28]         ;2370
00180c  2000              MOVS     r0,#0                 ;2370
00180e  fb001002          MLA      r0,r0,r2,r1           ;2370
001812  6328              STR      r0,[r5,#0x30]         ;2370
                  |L28.6164|
001814  a806              ADD      r0,sp,#0x18           ;2370
001816  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
00181a  b130              CBZ      r0,|L28.6186|
00181c  4641              MOV      r1,r8                 ;2370
00181e  4628              MOV      r0,r5                 ;2370
001820  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_9RectangleIiEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Rectangle<int>>::set_size(int)
001824  e005              B        |L28.6194|
                  |L28.6182|
001826  632c              STR      r4,[r5,#0x30]         ;2370
001828  e7f4              B        |L28.6164|
                  |L28.6186|
00182a  2100              MOVS     r1,#0                 ;2370
00182c  4628              MOV      r0,r5                 ;2370
00182e  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_9RectangleIiEEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::Rectangle<int>>::set_size(int)
                  |L28.6194|
001832  4960              LDR      r1,|L28.6580|
001834  a8bf              ADD      r0,sp,#0x2fc          ;2372
001836  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
00183a  4605              MOV      r5,r0                 ;2372
00183c  495e              LDR      r1,|L28.6584|
00183e  a8b7              ADD      r0,sp,#0x2dc          ;2372
001840  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
001844  ed9b0b04          VLDR     d0,[r11,#0x10]        ;2372
001848  4606              MOV      r6,r0                 ;2372
00184a  ec510b10          VMOV     r0,r1,d0              ;2372
00184e  f7fffffe          BL       __aeabi_d2f
001852  ee000a10          VMOV     s0,r0                 ;2372
001856  f8db0028          LDR      r0,[r11,#0x28]        ;2372  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754724faceDetectionParameters_E
00185a  e9cd6504          STRD     r6,r5,[sp,#0x10]      ;2372
00185e  a993              ADD      r1,sp,#0x24c          ;2372
001860  e9cd0102          STRD     r0,r1,[sp,#8]         ;2372
001864  e9db0108          LDRD     r0,r1,[r11,#0x20]     ;2372
001868  e9cd0100          STRD     r0,r1,[sp,#0]         ;2372
00186c  e9db2306          LDRD     r2,r3,[r11,#0x18]     ;2372
001870  a9a5              ADD      r1,sp,#0x294          ;2372
001872  a80a              ADD      r0,sp,#0x28           ;2372
001874  f7fffffe          BL       _ZN4Anki8Embedded10Classifier21CascadeClassifier_LBP16DetectMultiScaleERKNS0_5ArrayIhEEfiiiiiRNS0_15FixedLengthListINS0_9RectangleIiEEEENS0_11MemoryStackESC_ ; Anki::Embedded::Classifier::CascadeClassifier_LBP::DetectMultiScale(const Anki::Embedded::Array<unsigned char>&, float, int, int, int, int, int, Anki::Embedded::FixedLengthList<Anki::Embedded::Rectangle<int>>&, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
001878  4e50              LDR      r6,|L28.6588|
00187a  4680              MOV      r8,r0                 ;2372
00187c  7930              LDRB     r0,[r6,#4]            ;2385  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754714imageSendMode_E
00187e  2801              CMP      r0,#1                 ;2385
001880  d116              BNE      |L28.6320|
001882  f89b0001          LDRB     r0,[r11,#1]           ;2386  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754724faceDetectionParameters_E
001886  eb000140          ADD      r1,r0,r0,LSL #1       ;2386
00188a  484d              LDR      r0,|L28.6592|
00188c  eb000081          ADD      r0,r0,r1,LSL #2       ;2386
001890  7971              LDRB     r1,[r6,#5]            ;2386  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754724nextSendImageResolution_E
001892  4408              ADD      r0,r0,r1              ;2386
001894  7980              LDRB     r0,[r0,#6]            ;2386
001896  fa07f000          LSL      r0,r7,r0              ;2386
00189a  b2c0              UXTB     r0,r0                 ;2386
00189c  2801              CMP      r0,#1                 ;2388
00189e  d907              BLS      |L28.6320|
0018a0  ee000a10          VMOV     s0,r0                 ;2390
0018a4  eef80a40          VCVT.F32.U32 s1,s0                 ;2390
0018a8  ee880a20          VDIV.F32 s0,s16,s1             ;2390
0018ac  eeb08a40          VMOV.F32 s16,s0                ;2390
                  |L28.6320|
0018b0  f8dd9258          LDR      r9,[sp,#0x258]        ;2395
0018b4  2500              MOVS     r5,#0                 ;2395
0018b6  f1b90f00          CMP      r9,#0                 ;2395
0018ba  dd01              BLE      |L28.6336|
                  |L28.6332|
0018bc  989f              LDR      r0,[sp,#0x27c]        ;2395
0018be  e081              B        |L28.6596|
                  |L28.6336|
0018c0  e0ec              B        |L28.6812|
0018c2  0000              DCW      0x0000
                  |L28.6340|
                          DCD      ||.constdata||+0x1270
                  |L28.6344|
                          DCD      ||.constdata||+0x2410
                  |L28.6348|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L28.6352|
0018d0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
0018d4  6f726574
0018d8  6563685c
0018dc  636f6d6d
0018e0  6f6e5c69
0018e4  6e636c75
0018e8  64655c61
0018ec  6e6b692f
0018f0  636f6d6d
0018f4  6f6e2f72
0018f8  6f626f74
0018fc  2f617272
001900  617932  
001903  642e6800          DCB      "d.h",0
001907  00                DCB      0
                  |L28.6408|
001908  49662066          DCB      "If fully allocated, data must be %d byte aligned",0
00190c  756c6c79
001910  20616c6c
001914  6f636174
001918  65642c20
00191c  64617461
001920  206d7573
001924  74206265
001928  20256420
00192c  62797465
001930  20616c69
001934  676e6564
001938  00      
001939  00                DCB      0
00193a  00                DCB      0
00193b  00                DCB      0
                  |L28.6460|
00193c  41727261          DCB      "Array::Array",0
001940  793a3a41
001944  72726179
001948  00      
001949  00                DCB      0
00194a  00                DCB      0
00194b  00                DCB      0
                  |L28.6476|
00194c  496e7661          DCB      "Invalid size",0
001950  6c696420
001954  73697a65
001958  00      
001959  00                DCB      0
00195a  00                DCB      0
00195b  00                DCB      0
                  |L28.6492|
00195c  41727261          DCB      "Array<Type>::Array",0
001960  793c5479
001964  70653e3a
001968  3a417272
00196c  617900  
00196f  00                DCB      0
                  |L28.6512|
                          DCD      ||.constdata||+0x3164
                  |L28.6516|
                          DCD      ||.constdata||+0x32bc
                  |L28.6520|
                          DCD      ||.bss||+0x38
                  |L28.6524|
                          DCD      ||.bss||+0x3e8
                  |L28.6528|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L28.6532|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L28.6536|
001988  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
00198c  793c5479
001990  70653e3a
001994  3a416c6c
001998  6f636174
00199c  65427566
0019a0  66657246
0019a4  726f6d4d
0019a8  656d6f72
0019ac  79537461
0019b0  636b00  
0019b3  00                DCB      0
                  |L28.6580|
                          DCD      ||.bss||
                  |L28.6584|
                          DCD      ||.bss||+0x1c
                  |L28.6588|
                          DCD      ||.data||
                  |L28.6592|
                          DCD      ||.constdata||+0x2ce4
                  |L28.6596|
0019c4  eb001005          ADD      r0,r0,r5,LSL #4       ;2395
0019c8  8881              LDRH     r1,[r0,#4]            ;2395
0019ca  8802              LDRH     r2,[r0,#0]            ;2395
0019cc  1a89              SUBS     r1,r1,r2              ;2395
0019ce  b289              UXTH     r1,r1                 ;2399
0019d0  f8ad1004          STRH     r1,[sp,#4]            ;2399
0019d4  8982              LDRH     r2,[r0,#0xc]          ;2399
0019d6  8903              LDRH     r3,[r0,#8]            ;2399
0019d8  1ad2              SUBS     r2,r2,r3              ;2399
0019da  b293              UXTH     r3,r2                 ;2400
0019dc  f8ad3006          STRH     r3,[sp,#6]            ;2400
0019e0  8802              LDRH     r2,[r0,#0]            ;2401
0019e2  b292              UXTH     r2,r2                 ;2401
0019e4  f8ad2000          STRH     r2,[sp,#0]            ;2401
0019e8  8900              LDRH     r0,[r0,#8]            ;2402
0019ea  f88d4008          STRB     r4,[sp,#8]            ;2403
0019ee  b280              UXTH     r0,r0                 ;2402
0019f0  f8ad0002          STRH     r0,[sp,#2]            ;2402
0019f4  f896c004          LDRB     r12,[r6,#4]           ;2405  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754714imageSendMode_E
0019f8  f1bc0f01          CMP      r12,#1                ;2405
0019fc  d140              BNE      |L28.6784|
0019fe  ee18ca10          VMOV     r12,s16               ;2407
001a02  f1bc5f7e          CMP      r12,#0x3f800000       ;2407
001a06  bf08              IT       EQ                    ;2420
001a08  f88d7008          STRBEQ   r7,[sp,#8]            ;2420
001a0c  d038              BEQ      |L28.6784|
001a0e  ee002a10          VMOV     s0,r2                 ;2410
001a12  f88d7014          STRB     r7,[sp,#0x14]         ;2414
001a16  eeb80a40          VCVT.F32.U32 s0,s0                 ;2410
001a1a  ee200a08          VMUL.F32 s0,s0,s16             ;2410
001a1e  eebc0ac0          VCVT.U32.F32 s0,s0                 ;2410
001a22  ee102a10          VMOV     r2,s0                 ;2410
001a26  ee000a10          VMOV     s0,r0                 ;2411
001a2a  f8ad200c          STRH     r2,[sp,#0xc]          ;2410
001a2e  eeb80a40          VCVT.F32.U32 s0,s0                 ;2411
001a32  ee200a08          VMUL.F32 s0,s0,s16             ;2411
001a36  eebc0ac0          VCVT.U32.F32 s0,s0                 ;2411
001a3a  ee100a10          VMOV     r0,s0                 ;2411
001a3e  ee001a10          VMOV     s0,r1                 ;2412
001a42  f8ad000e          STRH     r0,[sp,#0xe]          ;2411
001a46  eeb80a40          VCVT.F32.U32 s0,s0                 ;2412
001a4a  ee200a08          VMUL.F32 s0,s0,s16             ;2412
001a4e  eebc0ac0          VCVT.U32.F32 s0,s0                 ;2412
001a52  ee100a10          VMOV     r0,s0                 ;2412
001a56  ee003a10          VMOV     s0,r3                 ;2413
001a5a  f8ad0010          STRH     r0,[sp,#0x10]         ;2412
001a5e  eeb80a40          VCVT.F32.U32 s0,s0                 ;2413
001a62  ee200a08          VMUL.F32 s0,s0,s16             ;2413
001a66  eebc0ac0          VCVT.U32.F32 s0,s0                 ;2413
001a6a  ee100a10          VMOV     r0,s0                 ;2413
001a6e  f8ad0012          STRH     r0,[sp,#0x12]         ;2413
001a72  f7fffffe          BL       _ZN4Anki5Cozmo3HAL12GetTimeStampEv ; Anki::Cozmo::HAL::GetTimeStamp()
001a76  4602              MOV      r2,r0                 ;2416
001a78  a903              ADD      r1,sp,#0xc            ;2416
001a7a  202d              MOVS     r0,#0x2d              ;2416
001a7c  f7fffffe          BL       _ZN4Anki5Cozmo3HAL16RadioSendMessageENS0_8Messages2IDEPKvj ; Anki::Cozmo::HAL::RadioSendMessage(Anki::Cozmo::Messages::ID, const void*, unsigned)
                  |L28.6784|
001a80  4668              MOV      r0,sp                 ;2426
001a82  f7fffffe          BL       _ZN4Anki5Cozmo8Messages27ProcessFaceDetectionMessageERKNS1_13FaceDetectionE ; Anki::Cozmo::Messages::ProcessFaceDetectionMessage(const Anki::Cozmo::Messages::FaceDetection&)
001a86  f7fffffe          BL       _ZN4Anki5Cozmo3HAL12GetTimeStampEv ; Anki::Cozmo::HAL::GetTimeStamp()
001a8a  4602              MOV      r2,r0                 ;2429
001a8c  4669              MOV      r1,sp                 ;2429
001a8e  202d              MOVS     r0,#0x2d              ;2429
001a90  f7fffffe          BL       _ZN4Anki5Cozmo3HAL16RadioSendMessageENS0_8Messages2IDEPKvj ; Anki::Cozmo::HAL::RadioSendMessage(Anki::Cozmo::Messages::ID, const void*, unsigned)
001a94  1c6d              ADDS     r5,r5,#1              ;2395
001a96  454d              CMP      r5,r9                 ;2395
001a98  f6ffaf10          BLT      |L28.6332|
                  |L28.6812|
001a9c  490e              LDR      r1,|L28.6872|
001a9e  a8e0              ADD      r0,sp,#0x380          ;2433
001aa0  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
001aa4  4605              MOV      r5,r0                 ;2433
001aa6  490d              LDR      r1,|L28.6876|
001aa8  a8b7              ADD      r0,sp,#0x2dc          ;2433
001aaa  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
001aae  4604              MOV      r4,r0                 ;2433
001ab0  490b              LDR      r1,|L28.6880|
001ab2  a8bf              ADD      r0,sp,#0x2fc          ;2433
001ab4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1ERKS1_ ; Anki::Embedded::MemoryStack::MemoryStack(const Anki::Embedded::MemoryStack&)
001ab8  4606              MOV      r6,r0                 ;2433
001aba  2101              MOVS     r1,#1                 ;2433
001abc  a8a5              ADD      r0,sp,#0x294          ;2433
001abe  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
001ac2  4602              MOV      r2,r0                 ;2433
001ac4  4633              MOV      r3,r6                 ;2433
001ac6  a993              ADD      r1,sp,#0x24c          ;2433
001ac8  a8a0              ADD      r0,sp,#0x280          ;2433
001aca  e9cd4500          STRD     r4,r5,[sp,#0]         ;2433
001ace  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem11DebugStream18SendFaceDetectionsERKNS_8Embedded5ArrayIhEERKNS3_15FixedLengthListINS3_9RectangleIiEEEEiNS3_11MemoryStackESE_SE_ ; Anki::Cozmo::VisionSystem::DebugStream::SendFaceDetections(const Anki::Embedded::Array<unsigned char>&, const Anki::Embedded::FixedLengthList<Anki::Embedded::Rectangle<int>>&, int, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack, Anki::Embedded::MemoryStack)
001ad2  f7ffb93b          B        |L28.3404|
;;;2448   
                          ENDP

001ad6  0000              DCW      0x0000
                  |L28.6872|
                          DCD      ||.bss||
                  |L28.6876|
                          DCD      ||.bss||+0x1c
                  |L28.6880|
                          DCD      ||.bss||+0x38

                          AREA ||i._ZN4Anki5Cozmo12VisionSystem9SetParamsEiffhf||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem9SetParamsEiffhf PROC ; Anki::Cozmo::VisionSystem::SetParams(int, float, float, unsigned char, float)
;;;2451         
;;;2452         void SetParams(const s32 integerCountsIncrement,
000000  b530              PUSH     {r4,r5,lr}
;;;2453                        const f32 minExposureTime,
;;;2454                        const f32 maxExposureTime,
;;;2455                        const u8 highValue,
;;;2456                        const f32 percentileToMakeHigh)
;;;2457         {
;;;2458           autoExposure_integerCountsIncrement = integerCountsIncrement;
000002  4a1b              LDR      r2,|L29.112|
000004  4605              MOV      r5,r0
000006  ed2d8b06          VPUSH    {d8-d10}              ;2457
00000a  b087              SUB      sp,sp,#0x1c           ;2457
;;;2459           autoExposure_minExposureTime = minExposureTime;
00000c  eeb0aa40          VMOV.F32 s20,s0
;;;2460           autoExposure_maxExposureTime = maxExposureTime;
000010  eeb08a60          VMOV.F32 s16,s1
000014  6110              STR      r0,[r2,#0x10]         ;2459  ; _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754735autoExposure_integerCountsIncrementE
000016  ed820a05          VSTR     s0,[r2,#0x14]         ;2459
00001a  edc20a06          VSTR     s1,[r2,#0x18]
;;;2461           autoExposure_highValue = highValue;
00001e  7091              STRB     r1,[r2,#2]
000020  460c              MOV      r4,r1
;;;2462           autoExposure_percentileToMakeHigh = percentileToMakeHigh;
000022  ed821a07          VSTR     s2,[r2,#0x1c]
;;;2463           
;;;2464           PRINT("Changed VisionSystem params: integerCountsInc %d, minExpTime %f, maxExpTime %f, highVal %d, percToMakeHigh %f\n",
000026  ee110a10          VMOV     r0,s2
00002a  f7fffffe          BL       __aeabi_f2d
00002e  ec410b19          VMOV     d9,r0,r1
000032  eef00a48          VMOV.F32 s1,s16
000036  ee100a90          VMOV     r0,s1
00003a  f7fffffe          BL       __aeabi_f2d
00003e  ec410b18          VMOV     d8,r0,r1
000042  eeb00a4a          VMOV.F32 s0,s20
000046  ee100a10          VMOV     r0,s0
00004a  f7fffffe          BL       __aeabi_f2d
00004e  ec410b10          VMOV     d0,r0,r1
000052  ed8d9b04          VSTR     d9,[sp,#0x10]
000056  9402              STR      r4,[sp,#8]
000058  ed8d8b00          VSTR     d8,[sp,#0]
00005c  ec532b10          VMOV     r2,r3,d0
000060  4629              MOV      r1,r5
000062  4804              LDR      r0,|L29.116|
000064  f7fffffe          BL       _ZN4Anki5Cozmo8Messages8SendTextEPKcz ; Anki::Cozmo::Messages::SendText(const char*, ...)
;;;2465                 autoExposure_integerCountsIncrement,
;;;2466                 autoExposure_minExposureTime,
;;;2467                 autoExposure_maxExposureTime,
;;;2468                 autoExposure_highValue,
;;;2469                 autoExposure_percentileToMakeHigh);
;;;2470         }
000068  b007              ADD      sp,sp,#0x1c
00006a  ecbd8b06          VPOP     {d8-d10}
00006e  bd30              POP      {r4,r5,pc}
;;;2471         
                          ENDP

                  |L29.112|
                          DCD      ||.data||
                  |L29.116|
                          DCD      ||.constdata||+0x34ec

                          AREA ||i.__sti___16_visionSystem_cpp||, CODE, READONLY, ALIGN=2

                  __sti___16_visionSystem_cpp PROC
000000  b530              PUSH     {r4,r5,lr}
000002  483b              LDR      r0,|L30.240|
000004  ed9f0a39          VLDR     s0,|L30.236|
000008  ed2d8b02          VPUSH    {d8}
00000c  b083              SUB      sp,sp,#0xc
00000e  ed800a13          VSTR     s0,[r0,#0x4c]
000012  4838              LDR      r0,|L30.244|
000014  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1Ev ; Anki::Embedded::MemoryStack::MemoryStack()
000018  4837              LDR      r0,|L30.248|
00001a  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1Ev ; Anki::Embedded::MemoryStack::MemoryStack()
00001e  4837              LDR      r0,|L30.252|
000020  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1Ev ; Anki::Embedded::MemoryStack::MemoryStack()
000024  4836              LDR      r0,|L30.256|
000026  f04f34ff          MOV      r4,#0xffffffff
00002a  2500              MOVS     r5,#0
00002c  6004              STR      r4,[r0,#0]
00002e  6044              STR      r4,[r0,#4]
000030  6084              STR      r4,[r0,#8]
000032  60c4              STR      r4,[r0,#0xc]
000034  6104              STR      r4,[r0,#0x10]
000036  6144              STR      r4,[r0,#0x14]
000038  3024              ADDS     r0,r0,#0x24
00003a  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00003e  f8404d0c          STR      r4,[r0,#-0xc]!
000042  2100              MOVS     r1,#0
000044  6044              STR      r4,[r0,#4]
000046  6105              STR      r5,[r0,#0x10]
000048  6084              STR      r4,[r0,#8]
00004a  3818              SUBS     r0,r0,#0x18
00004c  62c5              STR      r5,[r0,#0x2c]
00004e  6305              STR      r5,[r0,#0x30]
000050  f7fffffe          BL       _ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>::set_size(int)
000054  482b              LDR      r0,|L30.260|
000056  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
00005a  f8404d0c          STR      r4,[r0,#-0xc]!
00005e  ed9f8a2b          VLDR     s16,|L30.268|
000062  6044              STR      r4,[r0,#4]
000064  6105              STR      r5,[r0,#0x10]
000066  6084              STR      r4,[r0,#8]
000068  4827              LDR      r0,|L30.264|
00006a  ed808a02          VSTR     s16,[r0,#8]
00006e  ed808a03          VSTR     s16,[r0,#0xc]
000072  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754713MarkerToTrack5ClearEv ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
000076  4826              LDR      r0,|L30.272|
000078  ed808a02          VSTR     s16,[r0,#8]
00007c  ed808a03          VSTR     s16,[r0,#0xc]
000080  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754713MarkerToTrack5ClearEv ; Anki::Cozmo::VisionSystem::<unnamed>::MarkerToTrack::Clear()
000084  4823              LDR      r0,|L30.276|
000086  2304              MOVS     r3,#4
000088  2208              MOVS     r2,#8
00008a  4923              LDR      r1,|L30.280|
00008c  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
000090  2100              MOVS     r1,#0
                  |L30.146|
000092  ed8d8a00          VSTR     s16,[sp,#0]
000096  ed8d8a01          VSTR     s16,[sp,#4]
00009a  eb0002c1          ADD      r2,r0,r1,LSL #3
00009e  ed9d0a00          VLDR     s0,[sp,#0]
0000a2  1c49              ADDS     r1,r1,#1
0000a4  ed820a00          VSTR     s0,[r2,#0]
0000a8  ed9d0a01          VLDR     s0,[sp,#4]
0000ac  2904              CMP      r1,#4
0000ae  ed820a01          VSTR     s0,[r2,#4]
0000b2  dbee              BLT      |L30.146|
0000b4  4819              LDR      r0,|L30.284|
0000b6  f7fffffe          BL       _ZN4Anki8Embedded15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofC1Ev ; Anki::Embedded::TemplateTracker::LucasKanadeTracker_SampledPlanar6dof::LucasKanadeTracker_SampledPlanar6dof()
0000ba  2304              MOVS     r3,#4
0000bc  220c              MOVS     r2,#0xc
0000be  4918              LDR      r1,|L30.288|
0000c0  4818              LDR      r0,|L30.292|
0000c2  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
0000c6  4818              LDR      r0,|L30.296|
0000c8  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem31DetectFiducialMarkersParametersC1Ev ; Anki::Cozmo::VisionSystem::DetectFiducialMarkersParameters::DetectFiducialMarkersParameters()
0000cc  4817              LDR      r0,|L30.300|
0000ce  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem17TrackerParametersC1Ev ; Anki::Cozmo::VisionSystem::TrackerParameters::TrackerParameters()
0000d2  4817              LDR      r0,|L30.304|
0000d4  f7fffffe          BL       _ZN4Anki5Cozmo12VisionSystem23FaceDetectionParametersC1Ev ; Anki::Cozmo::VisionSystem::FaceDetectionParameters::FaceDetectionParameters()
0000d8  4816              LDR      r0,|L30.308|
0000da  6005              STR      r5,[r0,#0]
0000dc  6045              STR      r5,[r0,#4]
0000de  6085              STR      r5,[r0,#8]
0000e0  60c5              STR      r5,[r0,#0xc]
0000e2  b003              ADD      sp,sp,#0xc
0000e4  ecbd8b02          VPOP     {d8}
0000e8  bd30              POP      {r4,r5,pc}
                          ENDP

0000ea  0000              DCW      0x0000
                  |L30.236|
0000ec  423df6f2          DCFS     0x423df6f2 ; 47.491157531738281
                  |L30.240|
                          DCD      ||.data||
                  |L30.244|
                          DCD      ||.bss||
                  |L30.248|
                          DCD      ||.bss||+0x1c
                  |L30.252|
                          DCD      ||.bss||+0x38
                  |L30.256|
                          DCD      ||.bss||+0x54
                  |L30.260|
                          DCD      ||.bss||+0x94
                  |L30.264|
                          DCD      ||.bss||+0x9c
                  |L30.268|
00010c  00000000          DCFS     0x00000000 ; 0
                  |L30.272|
                          DCD      ||.bss||+0xb4
                  |L30.276|
                          DCD      ||.bss||+0xcc
                  |L30.280|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()
                  |L30.284|
                          DCD      ||.bss||+0xec
                  |L30.288|
                          DCD      _ZN4Anki8Embedded6Point3IfEC1Ev ; Anki::Embedded::Point3<float>::Point3()
                  |L30.292|
                          DCD      ||.bss||+0x2a4
                  |L30.296|
                          DCD      ||.bss||+0x344
                  |L30.300|
                          DCD      ||.bss||+0x3a4
                  |L30.304|
                          DCD      ||.bss||+0x3e8
                  |L30.308|
                          DCD      ||.bss||+0x418

                          AREA ||t._ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE||, CODE, READONLY, ALIGN=2

                  _ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE PROC ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)
;;;1592         template<typename PRECISION>
;;;1593         static Result GetCamPoseWrtRobot(Array<PRECISION>& RcamWrtRobot,
000000  b530              PUSH     {r4,r5,lr}
;;;1594           Point3<PRECISION>& TcamWrtRobot)
;;;1595         {
000002  460d              MOV      r5,r1
000004  ed2d8b02          VPUSH    {d8}
000008  b083              SUB      sp,sp,#0xc
00000a  4604              MOV      r4,r0
;;;1596           AnkiConditionalErrorAndReturnValue(RcamWrtRobot.get_size(0)==3 &&
00000c  2100              MOVS     r1,#0
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000012  2803              CMP      r0,#3
000014  d105              BNE      |L31.34|
000016  2101              MOVS     r1,#1
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001e  2803              CMP      r0,#3
000020  d010              BEQ      |L31.68|
                  |L31.34|
000022  f240613c          MOV      r1,#0x63c
000026  483f              LDR      r0,|L31.292|
000028  e9cd0100          STRD     r0,r1,[sp,#0]
00002c  a33e              ADR      r3,|L31.296|
00002e  a246              ADR      r2,|L31.328|
000030  a14f              ADR      r1,|L31.368|
000032  2005              MOVS     r0,#5
000034  f7fffffe          BL       _Anki_Log
;;;1597             RcamWrtRobot.get_size(1)==3,
;;;1598             RESULT_FAIL_INVALID_SIZE,
;;;1599             "VisionSystem::GetCamPoseWrtRobot",
;;;1600             "Rotation matrix must already be 3x3.");
;;;1601   
;;;1602           const f32 headAngle = HeadController::GetAngleRad();
;;;1603           const f32 cosH = cosf(headAngle);
;;;1604           const f32 sinH = sinf(headAngle);
;;;1605   
;;;1606           RcamWrtRobot[0][0] = 0;  RcamWrtRobot[0][1] = sinH;  RcamWrtRobot[0][2] = cosH;
;;;1607           RcamWrtRobot[1][0] = -1; RcamWrtRobot[1][1] = 0;     RcamWrtRobot[1][2] = 0;
;;;1608           RcamWrtRobot[2][0] = 0;  RcamWrtRobot[2][1] = -cosH; RcamWrtRobot[2][2] = sinH;
;;;1609   
;;;1610           TcamWrtRobot.x = HEAD_CAM_POSITION[0]*cosH - HEAD_CAM_POSITION[2]*sinH + NECK_JOINT_POSITION[0];
;;;1611           TcamWrtRobot.y = 0;
;;;1612           TcamWrtRobot.z = HEAD_CAM_POSITION[2]*cosH + HEAD_CAM_POSITION[0]*sinH + NECK_JOINT_POSITION[2];
;;;1613   
;;;1614           return RESULT_OK;
;;;1615         }
000038  b003              ADD      sp,sp,#0xc
00003a  f04f60a0          MOV      r0,#0x5000000         ;1596
00003e  ecbd8b02          VPOP     {d8}
000042  bd30              POP      {r4,r5,pc}
                  |L31.68|
000044  f7fffffe          BL       _ZN4Anki5Cozmo14HeadController11GetAngleRadEv ; Anki::Cozmo::HeadController::GetAngleRad()
000048  eef08a40          VMOV.F32 s17,s0                ;1602
00004c  f7fffffe          BL       __hardfp_cosf
000050  eeb08a40          VMOV.F32 s16,s0                ;1603
000054  eeb00a68          VMOV.F32 s0,s17                ;1604
000058  f7fffffe          BL       __hardfp_sinf
00005c  68a2              LDR      r2,[r4,#8]            ;1604
00005e  6921              LDR      r1,[r4,#0x10]         ;1604
000060  2000              MOVS     r0,#0                 ;1606
000062  fb001002          MLA      r0,r0,r2,r1           ;1606
000066  eddf0a4b          VLDR     s1,|L31.404|
00006a  eebf1a00          VMOV.F32 s2,#-1.00000000       ;1607
00006e  edc00a00          VSTR     s1,[r0,#0]            ;1606
000072  68a2              LDR      r2,[r4,#8]            ;1606
000074  6921              LDR      r1,[r4,#0x10]         ;1606
000076  2000              MOVS     r0,#0                 ;1606
000078  fb001002          MLA      r0,r0,r2,r1           ;1606
00007c  eef91a08          VMOV.F32 s3,#-6.00000000       ;1610
000080  ed800a01          VSTR     s0,[r0,#4]            ;1606
000084  68a2              LDR      r2,[r4,#8]            ;1606
000086  6921              LDR      r1,[r4,#0x10]         ;1606
000088  2000              MOVS     r0,#0                 ;1606
00008a  fb001002          MLA      r0,r0,r2,r1           ;1606
00008e  eefa2a0a          VMOV.F32 s5,#-13.00000000      ;1610
000092  ed808a02          VSTR     s16,[r0,#8]           ;1606
000096  68a2              LDR      r2,[r4,#8]            ;1606
000098  6921              LDR      r1,[r4,#0x10]         ;1606
00009a  2001              MOVS     r0,#1                 ;1607
00009c  fb001002          MLA      r0,r0,r2,r1           ;1607
0000a0  ed801a00          VSTR     s2,[r0,#0]            ;1607
0000a4  68a2              LDR      r2,[r4,#8]            ;1607
0000a6  6921              LDR      r1,[r4,#0x10]         ;1607
0000a8  2001              MOVS     r0,#1                 ;1607
0000aa  fb001002          MLA      r0,r0,r2,r1           ;1607
0000ae  eeb11a48          VNEG.F32 s2,s16                ;1608
0000b2  edc00a01          VSTR     s1,[r0,#4]            ;1607
0000b6  68a2              LDR      r2,[r4,#8]            ;1607
0000b8  6921              LDR      r1,[r4,#0x10]         ;1607
0000ba  2001              MOVS     r0,#1                 ;1607
0000bc  fb001002          MLA      r0,r0,r2,r1           ;1607
0000c0  edc00a02          VSTR     s1,[r0,#8]            ;1607
0000c4  68a2              LDR      r2,[r4,#8]            ;1607
0000c6  6921              LDR      r1,[r4,#0x10]         ;1607
0000c8  2002              MOVS     r0,#2                 ;1608
0000ca  fb001002          MLA      r0,r0,r2,r1           ;1608
0000ce  edc00a00          VSTR     s1,[r0,#0]            ;1608
0000d2  68a2              LDR      r2,[r4,#8]            ;1608
0000d4  6921              LDR      r1,[r4,#0x10]         ;1608
0000d6  2002              MOVS     r0,#2                 ;1608
0000d8  fb001002          MLA      r0,r0,r2,r1           ;1608
0000dc  ed801a01          VSTR     s2,[r0,#4]            ;1608
0000e0  ed9f1a2d          VLDR     s2,|L31.408|
0000e4  68a2              LDR      r2,[r4,#8]            ;1610
0000e6  6921              LDR      r1,[r4,#0x10]         ;1610
0000e8  ee282a01          VMUL.F32 s4,s16,s2             ;1610
0000ec  2002              MOVS     r0,#2                 ;1608
0000ee  fb001002          MLA      r0,r0,r2,r1           ;1608
0000f2  ee002a61          VMLS.F32 s4,s0,s3              ;1610
0000f6  ed800a02          VSTR     s0,[r0,#8]            ;1608
0000fa  2000              MOVS     r0,#0                 ;1614
0000fc  ee322a22          VADD.F32 s4,s4,s5              ;1610
000100  ed852a00          VSTR     s4,[r5,#0]            ;1610
000104  edc50a01          VSTR     s1,[r5,#4]            ;1611
000108  ee680a21          VMUL.F32 s1,s16,s3             ;1612
00010c  ee400a01          VMLA.F32 s1,s0,s2              ;1612
000110  ed9f0a22          VLDR     s0,|L31.412|
000114  ee300a80          VADD.F32 s0,s1,s0              ;1612
000118  ed850a02          VSTR     s0,[r5,#8]            ;1612
00011c  b003              ADD      sp,sp,#0xc
00011e  ecbd8b02          VPOP     {d8}
000122  bd30              POP      {r4,r5,pc}
;;;1616   
                          ENDP

                  |L31.292|
                          DCD      ||.constdata||+0x2f03
                  |L31.296|
000128  73757065          DCB      "supervisor\\src\\visionSystem.cpp",0
00012c  72766973
000130  6f725c73
000134  72635c76
000138  6973696f
00013c  6e537973
000140  74656d2e
000144  63707000
                  |L31.328|
000148  526f7461          DCB      "Rotation matrix must already be 3x3.",0
00014c  74696f6e
000150  206d6174
000154  72697820
000158  6d757374
00015c  20616c72
000160  65616479
000164  20626520
000168  3378332e
00016c  00      
00016d  00                DCB      0
00016e  00                DCB      0
00016f  00                DCB      0
                  |L31.368|
000170  56697369          DCB      "VisionSystem::GetCamPoseWrtRobot",0
000174  6f6e5379
000178  7374656d
00017c  3a3a4765
000180  7443616d
000184  506f7365
000188  57727452
00018c  6f626f74
000190  00      
000191  00                DCB      0
000192  00                DCB      0
000193  00                DCB      0
                  |L31.404|
000194  00000000          DCFS     0x00000000 ; 0
                  |L31.408|
000198  4099999a          DCFS     0x4099999a ; 4.8000001907348633
                  |L31.412|
00019c  423ecccd          DCFS     0x423ecccd ; 47.700000762939453

                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem12VisionMemory12ResetBuffersEv||
                          DCD      0x00000001

                          AREA ||area_number.33||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem16SetImageSendModeENS0_15ImageSendMode_tENS_6Vision16CameraResolutionE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.33||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem16SetImageSendModeENS0_15ImageSendMode_tENS_6Vision16CameraResolutionE||
                          DCD      0x00000001

                          AREA ||area_number.34||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem22DownsampleAndSendImageERKNS_8Embedded5ArrayIhEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem22DownsampleAndSendImageERKNS_8Embedded5ArrayIhEE||
                          DCD      0x00000001

                          AREA ||area_number.35||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem24BrightnessNormalizeImageERNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.35||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem24BrightnessNormalizeImageERNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEE||
                          DCD      0x00000001

                          AREA ||area_number.36||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem24BrightnessNormalizeImageERNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEEfNS2_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.36||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem24BrightnessNormalizeImageERNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEEfNS2_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.37||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem16DownsampleHelperERKNS_8Embedded5ArrayIhEERS4_NS2_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.37||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem16DownsampleHelperERKNS_8Embedded5ArrayIhEERS4_NS2_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||area_number.38||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem20GetCameraCalibrationEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.38||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem20GetCameraCalibrationEv||
                          DCD      0x00000001

                          AREA ||area_number.39||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem22GetTrackingMarkerWidthEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.39||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem22GetTrackingMarkerWidthEv||
                          DCD      0x00000001

                          AREA ||area_number.40||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem14GetVerticalFOVEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.40||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem14GetVerticalFOVEv||
                          DCD      0x00000001

                          AREA ||area_number.41||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem16GetHorizontalFOVEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.41||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem16GetHorizontalFOVEv||
                          DCD      0x00000001

                          AREA ||area_number.42||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem22GetFaceDetectionParamsEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.42||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem22GetFaceDetectionParamsEv||
                          DCD      0x00000001

                          AREA ||area_number.43||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem4InitEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.43||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem4InitEv||
                          DCD      0x00000001

                          AREA ||area_number.44||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfRKNS_8Embedded5PointIfEEfb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.44||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfRKNS_8Embedded5PointIfEEfb||
                          DCD      0x00000001

                          AREA ||area_number.45||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.45||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem16SetMarkerToTrackERKNS_6Vision10MarkerTypeEfb||
                          DCD      0x00000001

                          AREA ||area_number.46||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem12StopTrackingEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.46||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem12StopTrackingEv||
                          DCD      0x00000001

                          AREA ||area_number.47||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem19StartDetectingFacesEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem19StartDetectingFacesEv||
                          DCD      0x00000001

                          AREA ||area_number.48||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem21GetObservedMarkerListEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.48||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem21GetObservedMarkerListEv||
                          DCD      0x00000001

                          AREA ||area_number.49||, LINKORDER=||t._ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.49||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EE||
                          DCD      0x00000001

                          AREA ||area_number.50||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded5ArrayIfEERKNS2_6Point3IfEERS4_RS8_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.50||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded5ArrayIfEERKNS2_6Point3IfEERS4_RS8_||
                          DCD      0x00000001

                          AREA ||area_number.51||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem19GetVisionMarkerPoseERKNS_8Embedded12VisionMarkerEbRNS2_5ArrayIfEERNS2_6Point3IfEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem19GetVisionMarkerPoseERKNS_8Embedded12VisionMarkerEbRNS2_5ArrayIfEERNS2_6Point3IfEE||
                          DCD      0x00000001

                          AREA ||area_number.52||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem28GetVisionMarkerPoseNearestToERKNS_8Embedded6Point3IfEERKNS_6Vision10MarkerTypeEfRNS2_5ArrayIfEERS4_Rb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.52||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem28GetVisionMarkerPoseNearestToERKNS_8Embedded6Point3IfEERKNS_6Vision10MarkerTypeEfRNS2_5ArrayIfEERS4_Rb||
                          DCD      0x00000001

                          AREA ||area_number.53||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded6Point3IfEERS4_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.53||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem21GetWithRespectToRobotERKNS_8Embedded6Point3IfEERS4_||
                          DCD      0x00000001

                          AREA ||area_number.54||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem12TakeSnapshotENS_8Embedded9RectangleIiEEiRNS2_5ArrayIhEERb||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.54||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem12TakeSnapshotENS_8Embedded9RectangleIiEEiRNS2_5ArrayIhEERb||
                          DCD      0x00000001

                          AREA ||area_number.55||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem18TakeSnapshotHelperERKNS_8Embedded5ArrayIhEE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.55||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem18TakeSnapshotHelperERKNS_8Embedded5ArrayIhEE||
                          DCD      0x00000001

                          AREA ||area_number.56||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem6UpdateENS0_8Messages10RobotStateE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.56||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem6UpdateENS0_8Messages10RobotStateE||
                          DCD      0x00000001

                          AREA ||area_number.57||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem9SetParamsEiffhf||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem9SetParamsEiffhf||
                          DCD      0x00000001

                          AREA ||area_number.58||, LINKORDER=||i.__sti___16_visionSystem_cpp||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.__sti___16_visionSystem_cpp||
                          DCD      0x00000001

                          AREA ||area_number.59||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754713MarkerToTrack5ClearEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.59||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754713MarkerToTrack5ClearEv||
                          DCD      0x00000001

                          AREA ||area_number.60||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem14LookForMarkersERKNS_8Embedded5ArrayIhEERKNS1_31DetectFiducialMarkersParametersERNS2_15FixedLengthListINS2_12VisionMarkerEEENS2_11MemoryStackESE_SE_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem14LookForMarkersERKNS_8Embedded5ArrayIhEERKNS1_31DetectFiducialMarkersParametersERNS2_15FixedLengthListINS2_12VisionMarkerEEENS2_11MemoryStackESE_SE_||
                          DCD      0x00000001

                          AREA ||area_number.61||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem13TrackTemplateERKNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEERKNS1_17TrackerParametersERNS2_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofERbNS2_11MemoryStackESI_SI_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.61||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem13TrackTemplateERKNS_8Embedded5ArrayIhEERKNS2_13QuadrilateralIfEERKNS1_17TrackerParametersERNS2_15TemplateTracker36LucasKanadeTracker_SampledPlanar6dofERbNS2_11MemoryStackESI_SI_||
                          DCD      0x00000001

                          AREA ||area_number.62||, LINKORDER=||i._ZN4Anki5Cozmo12VisionSystem23TrackerPredictionUpdateERKNS_8Embedded5ArrayIhEENS2_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.62||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Anki5Cozmo12VisionSystem23TrackerPredictionUpdateERKNS_8Embedded5ArrayIhEENS2_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  _ZN4Anki5Cozmo12VisionSystem12VisionMemory15offchipScratch_E ; Anki::Cozmo::VisionSystem::VisionMemory::offchipScratch_
                          %        28
                  _ZN4Anki5Cozmo12VisionSystem12VisionMemory14onchipScratch_E ; Anki::Cozmo::VisionSystem::VisionMemory::onchipScratch_
                          %        28
                  _ZN4Anki5Cozmo12VisionSystem12VisionMemory11ccmScratch_E ; Anki::Cozmo::VisionSystem::VisionMemory::ccmScratch_
                          %        28
                  _ZN4Anki5Cozmo12VisionSystem12VisionMemory8markers_E ; Anki::Cozmo::VisionSystem::VisionMemory::markers_
                          %        52
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754713RcamWrtRobot_E ; Anki::Cozmo::VisionSystem::<unnamed>::RcamWrtRobot_
                          %        20
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754714markerToTrack_E ; Anki::Cozmo::VisionSystem::<unnamed>::markerToTrack_
                          %        24
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754717newMarkerToTrack_E ; Anki::Cozmo::VisionSystem::<unnamed>::newMarkerToTrack_
                          %        24
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754713trackingQuad_E ; Anki::Cozmo::VisionSystem::<unnamed>::trackingQuad_
                          %        32
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff75478tracker_E ; Anki::Cozmo::VisionSystem::<unnamed>::tracker_
                          %        440
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718canonicalMarker3d_E ; Anki::Cozmo::VisionSystem::<unnamed>::canonicalMarker3d_
                          %        48
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754711robotState_E ; Anki::Cozmo::VisionSystem::<unnamed>::robotState_
                          %        56
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754715prevRobotState_E ; Anki::Cozmo::VisionSystem::<unnamed>::prevRobotState_
                          %        56
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754720detectionParameters_E ; Anki::Cozmo::VisionSystem::<unnamed>::detectionParameters_
                          %        96
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718trackerParameters_E ; Anki::Cozmo::VisionSystem::<unnamed>::trackerParameters_
                          %        68
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754724faceDetectionParameters_E ; Anki::Cozmo::VisionSystem::<unnamed>::faceDetectionParameters_
                          %        48
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712snapshotROI_E ; Anki::Cozmo::VisionSystem::<unnamed>::snapshotROI_
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=4

                  lbpcascade_frontalface_stages_data
                          DCD      0x00000000
                          DCD      0x00000003
000008  bf40898f          DCFS     0xbf40898f ; -0.75209897756576538
                          DCD      0x00000003
                          DCD      0x00000004
000014  bef974a3          DCFS     0xbef974a3 ; -0.48721799254417419
                          DCD      0x00000007
                          DCD      0x00000004
000020  bf946213          DCFS     0xbf946213 ; -1.1592429876327515
                          DCD      0x0000000b
                          DCD      0x00000005
00002c  bf419956          DCFS     0xbf419956 ; -0.75624597072601318
                          DCD      0x00000010
                          DCD      0x00000005
000038  bf4efcdf          DCFS     0xbf4efcdf ; -0.80854600667953491
                          DCD      0x00000015
                          DCD      0x00000005
000044  bf0e14f0          DCFS     0xbf0e14f0 ; -0.55500698089599609
                          DCD      0x0000001a
                          DCD      0x00000005
000050  bf60ae10          DCFS     0xbf60ae10 ; -0.87765598297119141
                          DCD      0x0000001f
                          DCD      0x00000006
00005c  bf8e958e          DCFS     0xbf8e958e ; -1.1139390468597412
                          DCD      0x00000025
                          DCD      0x00000007
000068  bf530a1c          DCFS     0xbf530a1c ; -0.82437300682067871
                          DCD      0x0000002c
                          DCD      0x00000007
000074  bf9ca2ec          DCFS     0xbf9ca2ec ; -1.223721981048584
                          DCD      0x00000033
                          DCD      0x00000007
000080  bf0def52          DCFS     0xbf0def52 ; -0.55443298816680908
                          DCD      0x0000003a
                          DCD      0x00000007
00008c  bf3756a8          DCFS     0xbf3756a8 ; -0.71616601943969727
                          DCD      0x00000041
                          DCD      0x00000008
000098  bf2ca5be          DCFS     0xbf2ca5be ; -0.67440402507781982
                          DCD      0x00000049
                          DCD      0x00000009
0000a4  bf9a2489          DCFS     0xbf9a2489 ; -1.2042399644851685
                          DCD      0x00000052
                          DCD      0x0000000a
0000b0  bf571855          DCFS     0xbf571855 ; -0.84021502733230591
                          DCD      0x0000005c
                          DCD      0x00000009
0000bc  bf994602          DCFS     0xbf994602 ; -1.1974489688873291
                          DCD      0x00000065
                          DCD      0x00000009
0000c8  bf12c54c          DCFS     0xbf12c54c ; -0.57332301139831543
                          DCD      0x0000006e
                          DCD      0x00000009
0000d4  befa8199          DCFS     0xbefa8199 ; -0.48927000164985657
                          DCD      0x00000077
                          DCD      0x0000000a
0000e0  bf175925          DCFS     0xbf175925 ; -0.59120398759841919
                          DCD      0x00000081
                          DCD      0x0000000a
0000ec  bf42e4b0          DCFS     0xbf42e4b0 ; -0.76130199432373047
                          %        192
                  lbpcascade_frontalface_classifiers_data
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          DCD      0x00000001
                          %        64
                          DCD      0x00000000
                  lbpcascade_frontalface_nodes_data
                          DCD      0x0000002e
000424  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000000d
000434  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000002
000444  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000054
000454  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000015
000464  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000006a
000474  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000030
000484  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000002f
000494  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000000c
0004a4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000001a
0004b4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000008
0004c4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000060
0004d4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000021
0004e4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000039
0004f4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000007d
000504  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000035
000514  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000003c
000524  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000007
000534  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000062
000544  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000002c
000554  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000018
000564  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000002a
000574  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000006
000584  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000003d
000594  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000007b
0005a4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000009
0005b4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000069
0005c4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000001e
0005d4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000023
0005e4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000077
0005f4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000052
000604  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000034
000614  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000063
000624  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000012
000634  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000006f
000644  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000005c
000654  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000033
000664  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000001c
000674  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000070
000684  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000045
000694  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000013
0006a4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000049
0006b4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000007e
0006c4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000002d
0006d4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000072
0006e4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000061
0006f4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000019
000704  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000022
000714  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000086
000724  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000010
000734  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000004a
000744  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000071
000754  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000006e
000764  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000025
000774  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000029
000784  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000075
000794  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000041
0007a4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000038
0007b4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000014
0007c4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000000f
0007d4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000081
0007e4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000066
0007f4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000058
000804  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000003b
000814  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000001b
000824  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000001d
000834  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000080
000844  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000046
000854  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000004
000864  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000004c
000874  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000007c
000884  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000036
000894  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000005f
0008a4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000027
0008b4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000078
0008c4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000059
0008d4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000000e
0008e4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000043
0008f4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000056
000904  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000050
000914  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000004b
000924  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000037
000934  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000047
000944  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000001f
000954  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000028
000964  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000006d
000974  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000082
000984  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000042
000994  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000031
0009a4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000085
0009b4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000000
0009c4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000067
0009d4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000002b
0009e4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000005a
0009f4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000068
000a04  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000055
000a14  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000018
000a24  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000004e
000a34  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000005
000a44  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000000b
000a54  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000020
000a64  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000007a
000a74  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000044
000a84  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000003a
000a94  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000005e
000aa4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000057
000ab4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000007f
000ac4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000003
000ad4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000004f
000ae4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000074
000af4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000084
000b04  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000003e
000b14  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000017
000b24  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000004d
000b34  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000016
000b44  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000048
000b54  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000032
000b64  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000006c
000b74  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000005c
000b84  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000051
000b94  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000001
000ba4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000079
000bb4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000026
000bc4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000011
000bd4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000064
000be4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000003f
000bf4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000065
000c04  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000076
000c14  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000005c
000c24  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000000a
000c34  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000083
000c44  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000053
000c54  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000087
000c64  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000073
000c74  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000040
000c84  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x00000024
000c94  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000005d
000ca4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000005b
000cb4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0x0000006b
000cc4  00000000          DCFS     0x00000000 ; 0
                          DCD      0x00000000
                          DCD      0xffffffff
                          %        256
                  lbpcascade_frontalface_leaves_data
000dd0  bf278195          DCFS     0xbf278195 ; -0.65432101488113403
000dd4  3f638e3b          DCFS     0x3f638e3b ; 0.88888901472091675
000dd8  bf461fc1          DCFS     0xbf461fc1 ; -0.77392202615737915
000ddc  3f3a553b          DCFS     0x3f3a553b ; 0.72786301374435425
000de0  bf34f484          DCFS     0xbf34f484 ; -0.70685601234436035
000de4  3f2d185d          DCFS     0x3f2d185d ; 0.67615300416946411
000de8  bf4ef199          DCFS     0xbf4ef199 ; -0.80837398767471313
000dec  3f44c101          DCFS     0x3f44c101 ; 0.76857000589370728
000df0  bf45144d          DCFS     0xbf45144d ; -0.76984101533889771
000df4  3f28c75c          DCFS     0x3f28c75c ; 0.65929198265075684
000df8  bf402afe          DCFS     0xbf402afe ; -0.75065600872039795
000dfc  3f0b61cc          DCFS     0x3f0b61cc ; 0.54446101188659668
000e00  bf4710ba          DCFS     0xbf4710ba ; -0.77759897708892822
000e04  3f0bea70          DCFS     0x3f0bea70 ; 0.54654598236083984
000e08  bf0f687b          DCFS     0xbf0f687b ; -0.56018799543380737
000e0c  3f46393f          DCFS     0x3f46393f ; 0.77431100606918335
000e10  bf1cc9b8          DCFS     0xbf1cc9b8 ; -0.61245298385620117
000e14  3f32a3df          DCFS     0x3f32a3df ; 0.69781297445297241
000e18  bf1c87fd          DCFS     0xbf1c87fd ; -0.61145001649856567
000e1c  3f275d03          DCFS     0x3f275d03 ; 0.65376299619674683
000e20  bf2f76e6          DCFS     0xbf2f76e6 ; -0.68540799617767334
000e24  3f0a52ac          DCFS     0x3f0a52ac ; 0.54032397270202637
000e28  becf6a72          DCFS     0xbecf6a72 ; -0.4051089882850647
000e2c  3f4226b3          DCFS     0x3f4226b3 ; 0.75840300321578979
000e30  bf3d230c          DCFS     0xbf3d230c ; -0.7388160228729248
000e34  3f08b9bb          DCFS     0x3f08b9bb ; 0.5340840220451355
000e38  bf2885f5          DCFS     0xbf2885f5 ; -0.65829402208328247
000e3c  3f08b0f2          DCFS     0x3f08b0f2 ; 0.53394997119903564
000e40  bf191f2e          DCFS     0xbf191f2e ; -0.59813201427459717
000e44  3f084817          DCFS     0x3f084817 ; 0.53235000371932983
000e48  bf265e78          DCFS     0xbf265e78 ; -0.64987897872924805
000e4c  3efb9043          DCFS     0x3efb9043 ; 0.49133500456809998
000e50  bf071f36          DCFS     0xbf071f36 ; -0.52781999111175537
000e54  3f31d3bb          DCFS     0x3f31d3bb ; 0.6946370005607605
000e58  bf054962          DCFS     0xbf054962 ; -0.52065098285675049
000e5c  3f220bc4          DCFS     0x3f220bc4 ; 0.63299202919006348
000e60  bf406940          DCFS     0xbf406940 ; -0.75160598754882812
000e64  3ed8adef          DCFS     0x3ed8adef ; 0.42320200800895691
000e68  bf4390fb          DCFS     0xbf4390fb ; -0.76393097639083862
000e6c  3ed32075          DCFS     0x3ed32075 ; 0.41235700249671936
000e70  bf032b24          DCFS     0xbf032b24 ; -0.51237702369689941
000e74  3f144556          DCFS     0x3f144556 ; 0.57918298244476318
000e78  bec0ac9f          DCFS     0xbec0ac9f ; -0.37631699442863464
000e7c  3f3ad5ae          DCFS     0x3f3ad5ae ; 0.72982299327850342
000e80  bf0907ea          DCFS     0xbf0907ea ; -0.53527700901031494
000e84  3f10e1f8          DCFS     0x3f10e1f8 ; 0.5659480094909668
000e88  bf115dc4          DCFS     0xbf115dc4 ; -0.56783699989318848
000e8c  3efe071c          DCFS     0x3efe071c ; 0.49614799022674561
000e90  bf12148c          DCFS     0xbf12148c ; -0.57062602043151855
000e94  3eea19eb          DCFS     0x3eea19eb ; 0.45722898840904236
000e98  bf08d25f          DCFS     0xbf08d25f ; -0.53446000814437866
000e9c  3eef357e          DCFS     0x3eef357e ; 0.4672049880027771
000ea0  bf452104          DCFS     0xbf452104 ; -0.7700350284576416
000ea4  3f182a35          DCFS     0x3f182a35 ; 0.5943940281867981
000ea8  bf011e32          DCFS     0xbf011e32 ; -0.50436699390411377
000eac  3f1d78f7          DCFS     0x3f1d78f7 ; 0.61512702703475952
000eb0  bf2e492c          DCFS     0xbf2e492c ; -0.68080401420593262
000eb4  3eeef7a1          DCFS     0x3eeef7a1 ; 0.46673300862312317
000eb8  befc4ae8          DCFS     0xbefc4ae8 ; -0.49275898933410645
000ebc  3f0a49d4          DCFS     0x3f0a49d4 ; 0.54018902778625488
000ec0  bf24feac          DCFS     0xbf24feac ; -0.64451098442077637
000ec4  3ed876e2          DCFS     0x3ed876e2 ; 0.42278200387954712
000ec8  bf07dfa0          DCFS     0xbf07dfa0 ; -0.53075599670410156
000ecc  3f20359c          DCFS     0x3f20359c ; 0.62581801414489746
000ed0  bf05d3cc          DCFS     0xbf05d3cc ; -0.52276301383972168
000ed4  3f01460b          DCFS     0x3f01460b ; 0.50497502088546753
000ed8  beff28a6          DCFS     0xbeff28a6 ; -0.49835699796676636
000edc  3f02b991          DCFS     0x3f02b991 ; 0.51064401865005493
000ee0  beff8833          DCFS     0xbeff8833 ; -0.49908599257469177
000ee4  3f018c8f          DCFS     0x3f018c8f ; 0.50605100393295288
000ee8  bf11cad1          DCFS     0xbf11cad1 ; -0.56950098276138306
000eec  3ee46046          DCFS     0x3ee46046 ; 0.44604700803756714
000ef0  bf28b6e9          DCFS     0xbf28b6e9 ; -0.65904098749160767
000ef4  3eb92924          DCFS     0x3eb92924 ; 0.36164200305938721
000ef8  befe9b39          DCFS     0xbefe9b39 ; -0.49727800488471985
000efc  3f1a4b02          DCFS     0x3f1a4b02 ; 0.60270702838897705
000f00  bee06af4          DCFS     0xbee06af4 ; -0.4383159875869751
000f04  3f18bc5a          DCFS     0x3f18bc5a ; 0.59662401676177979
000f08  bf237c03          DCFS     0xbf237c03 ; -0.63861101865768433
000f0c  3ecbac71          DCFS     0x3ecbac71 ; 0.39779999852180481
000f10  bf0d209f          DCFS     0xbf0d209f ; -0.55127900838851929
000f14  3edb3e14          DCFS     0x3edb3e14 ; 0.42820799350738525
000f18  bf2451fc          DCFS     0xbf2451fc ; -0.6418759822845459
000f1c  3eb5c0db          DCFS     0x3eb5c0db ; 0.35498699545860291
000f20  bef7e7c0          DCFS     0xbef7e7c0 ; -0.48418998718261719
000f24  3eef00ac          DCFS     0x3eef00ac ; 0.46680200099945068
000f28  bf15e81d          DCFS     0xbf15e81d ; -0.58557301759719849
000f2c  3ec69caa          DCFS     0x3ec69caa ; 0.38791400194168091
000f30  be80f239          DCFS     0xbe80f239 ; -0.2518480122089386
000f34  3f35782d          DCFS     0x3f35782d ; 0.70886498689651489
000f38  bedc55eb          DCFS     0xbedc55eb ; -0.43034300208091736
000f3c  3f074092          DCFS     0x3f074092 ; 0.52832901477813721
000f40  beda16c6          DCFS     0xbeda16c6 ; -0.42595499753952026
000f44  3f0b48e4          DCFS     0x3f0b48e4 ; 0.54408097267150879
000f48  bf0f80cb          DCFS     0xbf0f80cb ; -0.5605589747428894
000f4c  3ed819f4          DCFS     0x3ed819f4 ; 0.42207300662994385
000f50  bf04ee9e          DCFS     0xbf04ee9e ; -0.51926600933074951
000f54  3ee145d8          DCFS     0x3ee145d8 ; 0.43998599052429199
000f58  bf0055b9          DCFS     0xbf0055b9 ; -0.50130802392959595
000f5c  3ee9ff2e          DCFS     0x3ee9ff2e ; 0.45702499151229858
000f60  beed20d1          DCFS     0xbeed20d1 ; -0.46314099431037903
000f64  3ef542c4          DCFS     0x3ef542c4 ; 0.47902500629425049
000f68  beca39c5          DCFS     0xbeca39c5 ; -0.39497199654579163
000f6c  3f1bb331          DCFS     0x3f1bb331 ; 0.60820299386978149
000f70  bef89f1f          DCFS     0xbef89f1f ; -0.48558899760246277
000f74  3ef502cd          DCFS     0x3ef502cd ; 0.47853699326515198
000f78  beec8f11          DCFS     0xbeec8f11 ; -0.46202901005744934
000f7c  3eff789a          DCFS     0x3eff789a ; 0.49896699190139771
000f80  bf245e4e          DCFS     0xbf245e4e ; -0.64206397533416748
000f84  3eb99115          DCFS     0x3eb99115 ; 0.36243501305580139
000f88  bef6ca25          DCFS     0xbef6ca25 ; -0.48201099038124084
000f8c  3eed2a63          DCFS     0x3eed2a63 ; 0.46321401000022888
000f90  bee4a2db          DCFS     0xbee4a2db ; -0.44655498862266541
000f94  3f0194f2          DCFS     0x3f0194f2 ; 0.50617897510528564
000f98  bf04e10d          DCFS     0xbf04e10d ; -0.51905900239944458
000f9c  3ee3675e          DCFS     0x3ee3675e ; 0.44414800405502319
000fa0  bedd610b          DCFS     0xbedd610b ; -0.43238100409507751
000fa4  3f10fe15          DCFS     0x3f10fe15 ; 0.56637698411941528
000fa8  beeaf167          DCFS     0xbeeaf167 ; -0.45887300372123718
000fac  3ee8ced5          DCFS     0x3ee8ced5 ; 0.45470300316810608
000fb0  bf05984a          DCFS     0xbf05984a ; -0.52185499668121338
000fb4  3ed27ce1          DCFS     0x3ed27ce1 ; 0.41110900044441223
000fb8  befbe76d          DCFS     0xbefbe76d ; -0.49200001358985901
000fbc  3edd8751          DCFS     0x3edd8751 ; 0.43267300724983215
000fc0  bee61f3a          DCFS     0xbee61f3a ; -0.44945698976516724
000fc4  3ee3c383          DCFS     0x3ee3c383 ; 0.44485101103782654
000fc8  bf04a116          DCFS     0xbf04a116 ; -0.51808297634124756
000fcc  3ec71d82          DCFS     0x3ec71d82 ; 0.38889700174331665
000fd0  bf1bae04          DCFS     0xbf1bae04 ; -0.6081240177154541
000fd4  3eaaa92e          DCFS     0x3eaaa92e ; 0.33332198858261108
000fd8  be3750c2          DCFS     0xbe3750c2 ; -0.17901900410652161
000fdc  3f291ce3          DCFS     0x3f291ce3 ; 0.66059702634811401
000fe0  bebc77de          DCFS     0xbebc77de ; -0.36810201406478882
000fe4  3f0393de          DCFS     0x3f0393de ; 0.51397502422332764
000fe8  bea4b8e1          DCFS     0xbea4b8e1 ; -0.32172301411628723
000fec  3f1dfddf          DCFS     0x3f1dfddf ; 0.61715501546859741
000ff0  bedfe975          DCFS     0xbedfe975 ; -0.43732801079750061
000ff4  3edf23ab          DCFS     0x3edf23ab ; 0.43581900000572205
000ff8  bee1871e          DCFS     0xbee1871e ; -0.44048398733139038
000ffc  3eeb951c          DCFS     0x3eeb951c ; 0.46012198925018311
001000  bedbdc48          DCFS     0xbedbdc48 ; -0.42941498756408691
001004  3ee3f35a          DCFS     0x3ee3f35a ; 0.44521600008010864
001008  becb6b90          DCFS     0xbecb6b90 ; -0.39730501174926758
00100c  3ef88d4c          DCFS     0x3ef88d4c ; 0.48545300960540771
001010  bf34998d          DCFS     0xbf34998d ; -0.70546799898147583
001014  3e8a233a          DCFS     0x3e8a233a ; 0.26980000734329224
001018  bf17313c          DCFS     0xbf17313c ; -0.59059500694274902
00101c  3f029c02          DCFS     0x3f029c02 ; 0.51019299030303955
001020  bee3cc8e          DCFS     0xbee3cc8e ; -0.44492000341415405
001024  3ee5eca2          DCFS     0x3ee5eca2 ; 0.44907099008560181
001028  bef052d6          DCFS     0xbef052d6 ; -0.46938198804855347
00102c  3ecfed85          DCFS     0x3ecfed85 ; 0.40610900521278381
001030  beb85682          DCFS     0xbeb85682 ; -0.3600350022315979
001034  3f01712a          DCFS     0x3f01712a ; 0.50563299655914307
001038  bee458ac          DCFS     0xbee458ac ; -0.44598901271820068
00103c  3ed39475          DCFS     0x3ed39475 ; 0.41324201226234436
001040  bee4a9ac          DCFS     0xbee4a9ac ; -0.44660699367523193
001044  3ed3b731          DCFS     0x3ed3b731 ; 0.41350701451301575
001048  beadd26b          DCFS     0xbeadd26b ; -0.33949598670005798
00104c  3f10dc87          DCFS     0x3f10dc87 ; 0.56586498022079468
001050  bf08dee3          DCFS     0xbf08dee3 ; -0.53465098142623901
001054  3eb7867f          DCFS     0x3eb7867f ; 0.35844799876213074
001058  bee038e3          DCFS     0xbee038e3 ; -0.43793401122093201
00105c  3ed32181          DCFS     0x3ed32181 ; 0.41236498951911926
001060  be88c133          DCFS     0xbe88c133 ; -0.26709899306297302
001064  3f19f645          DCFS     0x3f19f645 ; 0.6014140248298645
001068  bed478c8          DCFS     0xbed478c8 ; -0.41498398780822754
00106c  3eef264a          DCFS     0x3eef264a ; 0.46708899736404419
001070  beff470f          DCFS     0xbeff470f ; -0.49858900904655457
001074  3ebe7147          DCFS     0x3ebe7147 ; 0.37195798754692078
001078  bee9eb42          DCFS     0xbee9eb42 ; -0.45687299966812134
00107c  3ecb0caa          DCFS     0x3ecb0caa ; 0.39658099412918091
001080  bef4445b          DCFS     0xbef4445b ; -0.47708401083946228
001084  3ec5c3df          DCFS     0x3ec5c3df ; 0.38626000285148621
001088  bef9bd40          DCFS     0xbef9bd40 ; -0.48777198791503906
00108c  3ec17bfa          DCFS     0x3ec17bfa ; 0.37789899110794067
001090  bebe8c69          DCFS     0xbebe8c69 ; -0.37216499447822571
001094  3effb69a          DCFS     0x3effb69a ; 0.49944001436233521
001098  bec96e59          DCFS     0xbec96e59 ; -0.39342001080513
00109c  3ef434a0          DCFS     0x3ef434a0 ; 0.47696399688720703
0010a0  bedd5a5c          DCFS     0xbedd5a5c ; -0.43233001232147217
0010a4  3ede518f          DCFS     0x3ede518f ; 0.43421599268913269
0010a8  beffa7eb          DCFS     0xbeffa7eb ; -0.49932798743247986
0010ac  3ebbaade          DCFS     0x3ebbaade ; 0.36653798818588257
0010b0  bea97bd9          DCFS     0xbea97bd9 ; -0.33102300763130188
0010b4  3f0ffd93          DCFS     0x3f0ffd93 ; 0.56246298551559448
0010b8  bf06d2ed          DCFS     0xbf06d2ed ; -0.52665597200393677
0010bc  3ebdaa50          DCFS     0x3ebdaa50 ; 0.37044000625610352
0010c0  bed599cc          DCFS     0xbed599cc ; -0.41718900203704834
0010c4  3ee87875          DCFS     0x3ee87875 ; 0.45404401421546936
0010c8  bee94db6          DCFS     0xbee94db6 ; -0.45567101240158081
0010cc  3ebda87a          DCFS     0x3ebda87a ; 0.3704259991645813
0010d0  bed62542          DCFS     0xbed62542 ; -0.41825300455093384
0010d4  3eda7b70          DCFS     0x3eda7b70 ; 0.42672300338745117
0010d8  beb99e73          DCFS     0xbeb99e73 ; -0.36253699660301208
0010dc  3eefdac7          DCFS     0x3eefdac7 ; 0.46846601366996765
0010e0  bef2d688          DCFS     0xbef2d688 ; -0.47429299354553223
0010e4  3ebce725          DCFS     0x3ebce725 ; 0.36895099282264709
0010e8  bebbb689          DCFS     0xbebbb689 ; -0.36662700772285461
0010ec  3eea80ae          DCFS     0x3eea80ae ; 0.45801299810409546
0010f0  bee9dcf9          DCFS     0xbee9dcf9 ; -0.45676401257514954
0010f4  3ec768be          DCFS     0x3ec768be ; 0.38947099447250366
0010f8  becf9f45          DCFS     0xbecf9f45 ; -0.4055120050907135
0010fc  3f0c7dd4          DCFS     0x3f0c7dd4 ; 0.54879498481750488
001100  bec1f0c3          DCFS     0xbec1f0c3 ; -0.3787899911403656
001104  3ee809d5          DCFS     0x3ee809d5 ; 0.45320001244544983
001108  beda06c8          DCFS     0xbeda06c8 ; -0.42583298683166504
00110c  3ed72ecf          DCFS     0x3ed72ecf ; 0.42027899622917175
001110  bee98634          DCFS     0xbee98634 ; -0.45610201358795166
001114  3eccf0d8          DCFS     0x3eccf0d8 ; 0.40027499198913574
001118  bedce93e          DCFS     0xbedce93e ; -0.43146699666976929
00111c  3ed1389b          DCFS     0x3ed1389b ; 0.40863499045372009
001120  bed5bc88          DCFS     0xbed5bc88 ; -0.41745400428771973
001124  3ed997e5          DCFS     0x3ed997e5 ; 0.42498698830604553
001128  bedd40ee          DCFS     0xbedd40ee ; -0.43213599920272827
00112c  3ed17375          DCFS     0x3ed17375 ; 0.40908399224281311
001130  bf007885          DCFS     0xbf007885 ; -0.50183898210525513
001134  3ebd91cd          DCFS     0x3ebd91cd ; 0.37025299668312073
001138  bf00f5d3          DCFS     0xbf00f5d3 ; -0.50375097990036011
00113c  3eb686e8          DCFS     0x3eb686e8 ; 0.35649800300598145
001140  be7ab218          DCFS     0xbe7ab218 ; -0.2448199987411499
001144  3f11a815          DCFS     0x3f11a815 ; 0.56897097826004028
001148  beed3954          DCFS     0xbeed3954 ; -0.46332800388336182
00114c  3eb7b3b7          DCFS     0x3eb7b3b7 ; 0.3587929904460907
001150  bebf0846          DCFS     0xbebf0846 ; -0.37310999631881714
001154  3edbabeb          DCFS     0x3edbabeb ; 0.42904600501060486
001158  bebb5611          DCFS     0xbebb5611 ; -0.36589100956916809
00115c  3ee94a90          DCFS     0x3ee94a90 ; 0.45564699172973633
001160  bf057cf6          DCFS     0xbf057cf6 ; -0.52143800258636475
001164  3ea4ead1          DCFS     0x3ea4ead1 ; 0.32210400700569153
001168  bedb994e          DCFS     0xbedb994e ; -0.42890399694442749
00116c  3ecd0dd0          DCFS     0x3ecd0dd0 ; 0.40049600601196289
001170  beec9f73          DCFS     0xbeec9f73 ; -0.46215400099754333
001174  3ec43c9f          DCFS     0x3ec43c9f ; 0.38327500224113464
001178  bebe0807          DCFS     0xbebe0807 ; -0.37115499377250671
00117c  3eec2b95          DCFS     0x3eec2b95 ; 0.46127000451087952
001180  bf049fe8          DCFS     0xbf049fe8 ; -0.51806497573852539
001184  3ea423fb          DCFS     0x3ea423fb ; 0.32058700919151306
001188  be84bd98          DCFS     0xbe84bd98 ; -0.25925898551940918
00118c  3f16596d          DCFS     0x3f16596d ; 0.58730202913284302
001190  bec29f17          DCFS     0xbec29f17 ; -0.38012000918388367
001194  3ef19aa6          DCFS     0x3ef19aa6 ; 0.47188299894332886
001198  beb3aabd          DCFS     0xbeb3aabd ; -0.35091200470924377
00119c  3f026d59          DCFS     0x3f026d59 ; 0.50948101282119751
0011a0  bed0520d          DCFS     0xbed0520d ; -0.40687599778175354
0011a4  3ed37692          DCFS     0x3ed37692 ; 0.4130139946937561
0011a8  bee95358          DCFS     0xbee95358 ; -0.45571398735046387
0011ac  3eb53cbc          DCFS     0x3eb53cbc ; 0.35397899150848389
0011b0  bed2d4d4          DCFS     0xbed2d4d4 ; -0.41177999973297119
0011b4  3ed2df2f          DCFS     0x3ed2df2f ; 0.41185900568962097
0011b8  becd3ae7          DCFS     0xbecd3ae7 ; -0.40084001421928406
0011bc  3ece9468          DCFS     0x3ece9468 ; 0.40347599983215332
0011c0  bf11c572          DCFS     0xbf11c572 ; -0.56941902637481689
0011c4  3e97cbb4          DCFS     0x3e97cbb4 ; 0.29647600650787354
0011c8  bea399f6          DCFS     0xbea399f6 ; -0.31953400373458862
0011cc  3f0786e4          DCFS     0x3f0786e4 ; 0.52940201759338379
0011d0  beac4e2f          DCFS     0xbeac4e2f ; -0.33653399348258972
0011d4  3f01ba1b          DCFS     0x3f01ba1b ; 0.50674599409103394
0011d8  bed745e1          DCFS     0xbed745e1 ; -0.42045500874519348
0011dc  3f043e42          DCFS     0x3f043e42 ; 0.51657497882843018
0011e0  bec0a47f          DCFS     0xbec0a47f ; -0.37625500559806824
0011e4  3ed0a7c6          DCFS     0x3ed0a7c6 ; 0.40753000974655151
0011e8  bed9c77a          DCFS     0xbed9c77a ; -0.42535001039505005
0011ec  3ebee06e          DCFS     0x3ebee06e ; 0.37280601263046265
0011f0  beb86c22          DCFS     0xbeb86c22 ; -0.36019998788833618
0011f4  3ee9a390          DCFS     0x3ee9a390 ; 0.45632600784301758
0011f8  bece8e3f          DCFS     0xbece8e3f ; -0.40342900156974792
0011fc  3ed508b3          DCFS     0x3ed508b3 ; 0.4160819947719574
001200  beb963dc          DCFS     0xbeb963dc ; -0.36208999156951904
001204  3eeb3850          DCFS     0x3eeb3850 ; 0.45941400527954102
001208  bec7e026          DCFS     0xbec7e026 ; -0.39038199186325073
00120c  3ee054ac          DCFS     0x3ee054ac ; 0.43814599514007568
001210  beb7e1da          DCFS     0xbeb7e1da ; -0.35914498567581177
001214  3eecc0be          DCFS     0x3eecc0be ; 0.46240800619125366
001218  bedc0a6c          DCFS     0xbedc0a6c ; -0.42976701259613037
00121c  3ecdfe11          DCFS     0x3ecdfe11 ; 0.40232899785041809
001220  bf129c88          DCFS     0xbf129c88 ; -0.57270097732543945
001224  3e996441          DCFS     0x3e996441 ; 0.2995930016040802
                          %        72
                  lbpcascade_frontalface_subsets_data
                          DCD      0xfbffaaab
                          DCD      0xffffabbf
                          DCD      0xaaff22b3
                          DCD      0xb3ff222b
                          DCD      0xffffabaf
                          DCD      0xffffbfff
                          DCD      0x22ff22ab
                          DCD      0xffffa23b
                          DCD      0xf640fe42
                          DCD      0xd220ee62
                          DCD      0xff66ffff
                          DCD      0xfffbffff
                          DCD      0xe155ff02
                          DCD      0xf475fff7
                          DCD      0xfff7ffff
                          DCD      0xffffffff
                          DCD      0xea4ec3ea
                          DCD      0xcac2cb2b
                          DCD      0xb0408896
                          DCD      0xf7d6f38a
                          DCD      0x40e58190
                          DCD      0xf8000002
                          DCD      0xd3ccebff
                          DCD      0xffe7bbbf
                          DCD      0x7fffffff
                          DCD      0x73ff7fff
                          DCD      0xdfffffff
                          DCD      0x7fff7fff
                          DCD      0x2bff020a
                          DCD      0x3f3f1fff
                          DCD      0x0e7f020b
                          DCD      0x7fff6f7f
                          DCD      0x7fffffff
                          DCD      0x0fafbf8f
                          DCD      0x6fffffff
                          DCD      0x0f2f2b2f
                          DCD      0x6fffffff
                          DCD      0xf7ff77ff
                          DCD      0xefffffff
                          DCD      0x2fbfffbf
                          DCD      0xfa26f4c0
                          DCD      0x6004fcae
                          DCD      0xeefbda90
                          DCD      0xcd55def3
                          DCD      0xf4b6fc9c
                          DCD      0x9c57ffff
                          DCD      0xddf6d2f9
                          DCD      0xfffbffff
                          DCD      0xd064f2f0
                          DCD      0xfffdfffd
                          DCD      0x41502411
                          DCD      0xf1dd77f7
                          DCD      0xfffeffdf
                          DCD      0xffffffff
                          DCD      0xf314ff3f
                          DCD      0xfbdfffdf
                          DCD      0xffffabaf
                          DCD      0xffffafbb
                          DCD      0xf9fda2aa
                          DCD      0xd3ff22a2
                          DCD      0xffffafaf
                          DCD      0xffff6fff
                          DCD      0xf6ffaaaa
                          DCD      0xf7ffaeab
                          DCD      0xeef3efef
                          DCD      0x0aeeffef
                          DCD      0xeff777ca
                          DCD      0xe6e2ffff
                          DCD      0xe7ff7f7f
                          DCD      0x40fdfffe
                          DCD      0xeee7fff7
                          DCD      0xe7ffffff
                          DCD      0xfcffc3fc
                          DCD      0x39de7f6f
                          DCD      0xfcfdfcfc
                          DCD      0xffecdfff
                          DCD      0xf7fffdf5
                          DCD      0xfcff7f9f
                          DCD      0xfdfeffe8
                          DCD      0xf5b7ffff
                          DCD      0xfffffeef
                          DCD      0xf7efffef
                          DCD      0x6fefaa8a
                          DCD      0x8387ef26
                          DCD      0xf7fffefd
                          DCD      0x7ff77fef
                          DCD      0xfedf724e
                          DCD      0x4147e70f
                          DCD      0xfffffb07
                          DCD      0x6f7fffbf
                          DCD      0xfebfffae
                          DCD      0xfbf7ffff
                          DCD      0xf7ff7f15
                          DCD      0x777ff777
                          DCD      0xffffff06
                          DCD      0xf6fffbff
                          DCD      0xcc40e550
                          DCD      0xfb6bf7ea
                          DCD      0xffbef6ff
                          DCD      0xfffffeff
                          DCD      0x57555c55
                          DCD      0xeff7ff7f
                          DCD      0xffd777f3
                          DCD      0xfff7ffff
                          DCD      0xffffcdef
                          DCD      0xffffffcf
                          DCD      0xdfbf6aee
                          DCD      0xfffdaa8a
                          DCD      0xffff67af
                          DCD      0xffffafff
                          DCD      0xffee64ac
                          DCD      0xfbae0f00
                          DCD      0xefefff7f
                          DCD      0xe4ffff7f
                          DCD      0xeceffe0c
                          DCD      0xa0fcfffe
                          DCD      0xfffff7c1
                          DCD      0xc4fbfffd
                          DCD      0xe2dad440
                          DCD      0xe0f2f7e3
                          DCD      0x213f2927
                          DCD      0x27f36f7f
                          DCD      0xafffbfff
                          DCD      0xbfdf2fff
                          DCD      0x771f1f3e
                          DCD      0x3effffff
                          DCD      0xfdffbf5f
                          DCD      0xffffffff
                          DCD      0xdffff514
                          DCD      0x3476b735
                          DCD      0xfefeffdc
                          DCD      0xfebfffff
                          DCD      0xf577f754
                          DCD      0xf5f5ff75
                          DCD      0xfeffffd4
                          DCD      0xfdffff3e
                          DCD      0xffffffff
                          DCD      0xfc3efa67
                          DCD      0xbefee666
                          DCD      0x30006022
                          DCD      0xff7fff25
                          DCD      0xfd7ff545
                          DCD      0xffff6567
                          DCD      0xe057c477
                          DCD      0xd4c4fe4c
                          DCD      0x5054fed7
                          DCD      0xfff2fdf7
                          DCD      0xfeff7ff7
                          DCD      0x58cdc7cc
                          DCD      0xf5fdfff7
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0xffff7ff7
                          DCD      0x3bff3b22
                          DCD      0xffffffbf
                          DCD      0x37bfbb2b
                          DCD      0xff7fffff
                          DCD      0xbfbbffff
                          DCD      0xffffffff
                          DCD      0x2bbe373b
                          DCD      0xfae7c26f
                          DCD      0x7f7beedf
                          DCD      0xc2393aee
                          DCD      0x30bbfaff
                          DCD      0x42f54045
                          DCD      0xfc7ed4f7
                          DCD      0xc397b2bf
                          DCD      0xf467f5ff
                          DCD      0xffffbbff
                          DCD      0xffffafff
                          DCD      0xefffa8bb
                          DCD      0xf7ffaafb
                          DCD      0xffffbbbf
                          DCD      0xffffffff
                          DCD      0xffffaabb
                          DCD      0xffffaaaa
                          DCD      0xcfffeeef
                          DCD      0x82ef0eaa
                          DCD      0xefefaf2b
                          DCD      0x28ae2a2a
                          DCD      0x7fffff7f
                          DCD      0x67bf0fff
                          DCD      0xbeffff3f
                          DCD      0xefff6fbf
                          DCD      0xfbfffcd2
                          DCD      0xffffe7ff
                          DCD      0xfffffff8
                          DCD      0xfac2fcd8
                          DCD      0xffffafff
                          DCD      0xbfffafff
                          DCD      0xfcf7fee8
                          DCD      0xfefee4e0
                          DCD      0xf7bfbf27
                          DCD      0x3bbfaff7
                          DCD      0xaeff2e0b
                          DCD      0x8e3bffff
                          DCD      0xafbb3422
                          DCD      0x363efff7
                          DCD      0xaeff2528
                          DCD      0xafbfffb7
                          DCD      0xfaafdaaf
                          DCD      0xffbff7ff
                          DCD      0x4ae526da
                          DCD      0xb0afa82e
                          DCD      0x487f6425
                          DCD      0xfdd7c657
                          DCD      0x01ff2456
                          DCD      0xf6f3c467
                          DCD      0x40006c68
                          DCD      0x0c507dfd
                          DCD      0xfdf8fef7
                          DCD      0xfdffffff
                          DCD      0xd0f0f8ec
                          DCD      0xf9f4ff7f
                          DCD      0xd6dbffff
                          DCD      0xfffbf7ff
                          DCD      0xaaa035fb
                          DCD      0xcee87fff
                          DCD      0xffff3fff
                          DCD      0xfdf4bff4
                          DCD      0xefeffffd
                          DCD      0xaff6ffff
                          DCD      0xbfbbffff
                          DCD      0xffec7ffd
                          DCD      0xc060ff30
                          DCD      0xf454f77f
                          DCD      0xe5f7bf77
                          DCD      0xf7fffffd
                          DCD      0xfcf7ffcc
                          DCD      0xffffff7f
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0x319f7735
                          DCD      0xfdf77fbd
                          DCD      0xfe727fff
                          DCD      0xe6bf77ff
                          DCD      0xefff7f74
                          DCD      0x7d77f77f
                          DCD      0xffdfbd3c
                          DCD      0xfef6ff6f
                          DCD      0xbf107770
                          DCD      0xbf987fbf
                          DCD      0x7fbc7fff
                          DCD      0xffeefff7
                          DCD      0xbbfe7ff4
                          DCD      0xfffffffd
                          DCD      0xffdbf7f4
                          DCD      0xfff4b744
                          DCD      0xbffaf7ff
                          DCD      0xbffbffff
                          DCD      0xffffffff
                          DCD      0xb3b2aefa
                          DCD      0xffaebfef
                          DCD      0xffffffff
                          DCD      0xebffefbe
                          DCD      0x22b2aaaa
                          DCD      0xd5dcfdcc
                          DCD      0xd5f4ff9c
                          DCD      0xdfcfffac
                          DCD      0xddfeefcd
                          DCD      0xddfcddfd
                          DCD      0xdcf5ffd5
                          DCD      0xfdfedffc
                          DCD      0xfddcffff
                          DCD      0x86aabff3
                          DCD      0x0282aff6
                          DCD      0xeffef7f3
                          DCD      0xffe67eec
                          DCD      0x0f8ecfff
                          DCD      0x4f007fef
                          DCD      0x747dafff
                          DCD      0xcfffffaf
                          DCD      0xef28f130
                          DCD      0xa321b100
                          DCD      0x54ff51b0
                          DCD      0xf5d5f910
                          DCD      0xdf67ff99
                          DCD      0xffb1fb33
                          DCD      0xfdf57cd1
                          DCD      0xddfff5e7
                          DCD      0x3c9400d4
                          DCD      0xdbdc91f5
                          DCD      0x368b3afd
                          DCD      0xbf9f31df
                          DCD      0x928130b8
                          DCD      0xaed7a0e8
                          DCD      0x7ffd7bdb
                          DCD      0x3fa803bd
                          DCD      0xd8dfd2ba
                          DCD      0xff14d0d6
                          DCD      0xf78f5cd2
                          DCD      0xdc084cc4
                          DCD      0x59c2fafa
                          DCD      0xd10ed5ae
                          DCD      0xfb3dfdb2
                          DCD      0xb0f3cea2
                          DCD      0xca42cd20
                          DCD      0xf3f6ffff
                          DCD      0xfffffefa
                          DCD      0xfbfbffff
                          DCD      0xf7753b10
                          DCD      0xfff7ffff
                          DCD      0xfd7fff76
                          DCD      0xffffffff
                          DCD      0xffbb3735
                          DCD      0xe77b6f7f
                          DCD      0xeffff7f7
                          DCD      0xfbf9ffbf
                          DCD      0xfef73f35
                          DCD      0xffff7f7b
                          DCD      0xfbbf5f45
                          DCD      0xffff8d3f
                          DCD      0xfb79efff
                          DCD      0xf900ee92
                          DCD      0xf1c02ddd
                          DCD      0xff40ad7c
                          DCD      0x588466fe
                          DCD      0x7bc0cdfd
                          DCD      0x7e8c38ff
                          DCD      0x2fcc20ef
                          DCD      0xceeaafa3
                          DCD      0x2ee2ffed
                          DCD      0xfefe7def
                          DCD      0xaeaefffe
                          DCD      0x0e6f25db
                          DCD      0x4e6f7ffd
                          DCD      0xd67fc7df
                          DCD      0xe4dffcb3
                          DCD      0xe0ebe280
                          DCD      0x0066f28a
                          DCD      0xacc72002
                          DCD      0x867feeee
                          DCD      0xf4efc723
                          DCD      0x036ff7fb
                          DCD      0xf777f733
                          DCD      0xc1effffb
                          DCD      0xe37ff373
                          DCD      0x4022e633
                          DCD      0x9de5a041
                          DCD      0x5160cc60
                          DCD      0xdebfbeff
                          DCD      0xebbf7faf
                          DCD      0x55fbf0c0
                          DCD      0xc0e3f673
                          DCD      0xf150fdbc
                          DCD      0x9da0dd00
                          DCD      0x9ffffff7
                          DCD      0xd101f5c8
                          DCD      0x5779df7d
                          DCD      0xffd577bb
                          DCD      0x57fdffff
                          DCD      0xffbb9ebb
                          DCD      0xffff9f0d
                          DCD      0x5dbfffbf
                          DCD      0xfeff7ff7
                          DCD      0xfbffffff
                          DCD      0x7ff53d14
                          DCD      0x5577ff75
                          DCD      0xeffd5c44
                          DCD      0xfdebffcb
                          DCD      0xffe3e731
                          DCD      0xf7ff2fb7
                          DCD      0xffff7fff
                          DCD      0xffa7ff37
                          DCD      0xffeef5fd
                          DCD      0xfffff777
                          DCD      0xffffdfd9
                          DCD      0xfdff4101
                          DCD      0xaef78f7b
                          DCD      0xaee6ff3e
                          DCD      0xbfff6fd7
                          DCD      0xefeeef6c
                          DCD      0xcfbfcfef
                          DCD      0x67fe1fff
                          DCD      0xfd7fbff7
                          DCD      0xf7f7bdbe
                          DCD      0x2b7f273f
                          DCD      0xf7ff2ff3
                          DCD      0xbbff22bf
                          DCD      0xf1fb1ef7
                          DCD      0x273f3f3f
                          DCD      0x7fffbfff
                          DCD      0xbbff3bbf
                          DCD      0xffffbfff
                          DCD      0xed7ff7f7
                          DCD      0xe6ecfff5
                          DCD      0xf47ef860
                          DCD      0xeaecfa7f
                          DCD      0x47d7ffd6
                          DCD      0xc4f7fffc
                          DCD      0x34e7c464
                          DCD      0xe6eefff2
                          DCD      0xaaefe2ff
                          DCD      0x75f3efff
                          DCD      0xeee2e68a
                          DCD      0xe2f7eaee
                          DCD      0x06d7164d
                          DCD      0xdfc76efd
                          DCD      0xd5d4400d
                          DCD      0xd7f7465b
                          DCD      0xd3fbefee
                          DCD      0xcaf4739f
                          DCD      0xec6e8284
                          DCD      0xf8bcfbfe
                          DCD      0xbbe46b14
                          DCD      0x90ec1411
                          DCD      0x7fefbac9
                          DCD      0xfffbfbef
                          DCD      0xfb74d754
                          DCD      0xfffefffe
                          DCD      0xffffffff
                          DCD      0xfbfeffff
                          DCD      0xfffdbdd9
                          DCD      0xffffffdf
                          DCD      0xfffc9d9c
                          DCD      0xefbcbf54
                          DCD      0x1600bf30
                          DCD      0x9f20ed10
                          DCD      0x7f77fd34
                          DCD      0xffedd7f4
                          DCD      0x2f213f33
                          DCD      0xb7b8fdf9
                          DCD      0x2fae3faf
                          DCD      0xffbbffdd
                          DCD      0x2ebe2f1f
                          DCD      0xeeb6b7f7
                          DCD      0x1fff6b1f
                          DCD      0xe7faeffd
                          DCD      0xaffc5f71
                          DCD      0xcdffefff
                          DCD      0xfffd4d7f
                          DCD      0xefffaf3f
                          DCD      0xe301d700
                          DCD      0xf5c0c7c1
                          DCD      0xebb7830c
                          DCD      0xffffaa4e
                          DCD      0xe104fff0
                          DCD      0xd1f0c0bc
                          DCD      0xfba4a484
                          DCD      0xdd1caf81
                          DCD      0xfdfffdf7
                          DCD      0xe3aaffef
                          DCD      0xab27aa70
                          DCD      0x842ffaab
                          DCD      0xffb5fffb
                          DCD      0x83fdffbb
                          DCD      0xf2f1d2a0
                          DCD      0xc01bdeab
                          DCD      0xce482ddc
                          DCD      0xf80000fc
                          DCD      0xaf9319dd
                          DCD      0xbfff0ed9
                          DCD      0xdb0cdddc
                          DCD      0xa9a000bc
                          DCD      0xad55bbaf
                          DCD      0x8a090ca9
                          DCD      0xeeff6f0d
                          DCD      0x71ff7fff
                          DCD      0xffffbf6e
                          DCD      0x98d2afea
                          DCD      0xbabebfee
                          DCD      0xafffffef
                          DCD      0xefffefae
                          DCD      0xa8bbee8c
                          DCD      0x4a47ffff
                          DCD      0x4040fe22
                          DCD      0xff66ffcf
                          DCD      0x0000eac6
                          DCD      0xef77ffff
                          DCD      0xfd65fff5
                          DCD      0xb7d7ff5f
                          DCD      0x4745ff0f
                          DCD      0xd197c1ec
                          DCD      0xdb7790ee
                          DCD      0xdd8094ae
                          DCD      0xffc26882
                          DCD      0x8bf989ef
                          DCD      0xba931296
                          DCD      0x89958fdf
                          DCD      0xff475051
                          DCD      0xbfffbb2b
                          DCD      0x77ff7a7f
                          DCD      0xaebfaeef
                          DCD      0xbf7afbbf
                          DCD      0xabb3b32b
                          DCD      0x33bf777f
                          DCD      0xaf2b0b2b
                          DCD      0xbfbfff7f
                          DCD      0xfafbff73
                          DCD      0x8338fb06
                          DCD      0xb82f71a0
                          DCD      0x21a262fb
                          DCD      0xfbffcfbb
                          DCD      0xafffffba
                          DCD      0xb1f74182
                          DCD      0xd1b3f7b3
                          DCD      0xfe77ef06
                          DCD      0x03ffeeef
                          DCD      0xeeb3a6aa
                          DCD      0xf5f3eea3
                          DCD      0x7c357242
                          DCD      0x657e7d1f
                          DCD      0xf767ce24
                          DCD      0xf1fffb8e
                          DCD      0xccdc405c
                          DCD      0x35ec5cf5
                          DCD      0x9fe6bfff
                          DCD      0x0dd84d77
                          DCD      0x5c7047ac
                          DCD      0xddbcdcfb
                          DCD      0xeab2cce8
                          DCD      0xffba1faf
                          DCD      0xfa204140
                          DCD      0xf7c8c0c0
                          DCD      0x1d800205
                          DCD      0xf1562142
                          DCD      0x38004367
                          DCD      0xb8b56262
                          DCD      0xdb025763
                          DCD      0x7f635511
                          DCD      0xf6fffeff
                          DCD      0x7b73e189
                          DCD      0xb262be36
                          DCD      0x2000f7bf
                          DCD      0xc0e0ce57
                          DCD      0x367c7f45
                          DCD      0x4462d66e
                          DCD      0xf000fffb
                          DCD      0xf7fb8c59
                          DCD      0x5fff6f57
                          DCD      0xaffffff7
                          DCD      0x6ef3fffd
                          DCD      0xbdf7cc44
                          DCD      0x5dffff7d
                          DCD      0xec1e4cd8
                          DCD      0xf7dfefbf
                          DCD      0xffffffff
                          DCD      0x3f30ac6c
                          DCD      0xbef8e5b4
                          DCD      0xda64f284
                          DCD      0xdfd7fdf5
                          DCD      0x2e77ffff
                          DCD      0xcdf533d8
                          DCD      0xfffffebf
                          DCD      0xefeecdef
                          DCD      0xef02c9ee
                          DCD      0xd0d902c2
                          DCD      0xfeee8140
                          DCD      0x0e06308f
                          DCD      0x4c06a92f
                          DCD      0x5021c4ff
                          DCD      0xc667c8e7
                          DCD      0x011000c0
                          DCD      0xd370187d
                          DCD      0x237d7f9d
                          DCD      0x57e70bf7
                          DCD      0x22500f90
                          DCD      0x9ba01d5e
                          DCD      0x33fcf9fe
                          DCD      0xbb1b009b
                          DCD      0xebefff71
                          DCD      0x6faeefa7
                          DCD      0xcefdbdba
                          DCD      0xeacafeda
                          DCD      0xe3efd7fb
                          DCD      0x88efff7f
                          DCD      0xc0fd70a0
                          DCD      0xc37bfaf3
                          DCD      0xce46eede
                          DCD      0xdc9cefff
                          DCD      0xeccc7fcf
                          DCD      0xea402eac
                          DCD      0xc75070dd
                          DCD      0xedfdefbf
                          DCD      0x9fbb6ffb
                          DCD      0xfb46be9b
                          DCD      0x4fff7fdf
                          DCD      0x7fff35ff
                          DCD      0xfdffff7f
                          DCD      0xffff44ff
                          DCD      0xccff44e8
                          DCD      0xffffffff
                          DCD      0x767f45df
                          DCD      0x1fff55f7
                          DCD      0x5550f500
                          DCD      0xf510f590
                          DCD      0xdffdfdfd
                          DCD      0xf7cdf5f7
                          DCD      0x5d04b7f1
                          DCD      0xfaf4eff7
                          DCD      0xffdfffd7
                          DCD      0xfffffdff
                          DCD      0x9def5455
                          DCD      0x7d7f3f1f
                          DCD      0x7effffff
                          DCD      0x56f67f3f
                          DCD      0xff7d4510
                          DCD      0xfd77bf55
                          DCD      0xfdfc8edd
                          DCD      0xfebf7f7f
                          DCD      0xdb7fcea2
                          DCD      0xe1d9ffa6
                          DCD      0xea6be604
                          DCD      0xe4fffeee
                          DCD      0x10713645
                          DCD      0x72777617
                          DCD      0xff3fbb0f
                          DCD      0xf7ffefff
                          DCD      0xcffbeddf
                          DCD      0xffffff5f
                          DCD      0xdef7fef9
                          DCD      0xe060ea40
                          DCD      0xfefff74f
                          DCD      0x773fff77
                          DCD      0xfdff3d4d
                          DCD      0xf6fff777
                          DCD      0x00001830
                          DCD      0x19f01bf3
                          DCD      0x57777ffd
                          DCD      0x79fe08b1
                          DCD      0xa0205531
                          DCD      0xffb76eef
                          DCD      0xbf703fff
                          DCD      0xfbbf0bfb
                          DCD      0xfd83df81
                          DCD      0xffcdef76
                          DCD      0x6e77ff8f
                          DCD      0xe6ec6f45
                          DCD      0xe7357fbf
                          DCD      0xefe4ef48
                          DCD      0xbf21f707
                          DCD      0xcecec000
                          DCD      0xf900c0f4
                          DCD      0xfd7c06fc
                          DCD      0x7bfffebd
                          DCD      0xfffd1edb
                          DCD      0xdfb19c9b
                          DCD      0xeabb2d3c
                          DCD      0xbef6bf9f
                          DCD      0xbfff28df
                          DCD      0xef7fe89f
                          DCD      0x522d8368
                          DCD      0xafffedc1
                          DCD      0x2d230e22
                          DCD      0x3ffffb3f
                          DCD      0xef2dfb37
                          DCD      0xe737fb73
                          DCD      0x0a2fae23
                          DCD      0xd08cd8cf
                          DCD      0xf8a89f7f
                          DCD      0x7dfbffef
                          DCD      0xf308bfcb
                          DCD      0xbdfdecfe
                          DCD      0xffffbfff
                          DCD      0xcfefecff
                          DCD      0xe8aeeedd
                          DCD      0xcaefea22
                          DCD      0x00ece7fb
                          DCD      0xe2ee6f0a
                          DCD      0x02ceefce
                          DCD      0xb7bd7765
                          DCD      0xb2fff7ff
                          DCD      0xfbeff66e
                          DCD      0xe3fef6df
                          DCD      0xaede07f3
                          DCD      0x8edeaef7
                          DCD      0xbefeef75
                          DCD      0xeefcfce9
                          DCD      0xbffbcff7
                          DCD      0xcde7d7ff
                          DCD      0x7ffbffef
                          DCD      0xfffbffff
                          DCD      0x5501f104
                          DCD      0x7135ffaf
                          DCD      0x7fb77e13
                          DCD      0xf77ffb6f
                          DCD      0xe1b4fcfc
                          DCD      0xfeb6f7ff
                          DCD      0xfd7fbdbf
                          DCD      0xffffffbf
                          DCD      0xf3ffd393
                          DCD      0x00a0e322
                          DCD      0xf1e75350
                          DCD      0xd385f573
                          DCD      0x75b17bc1
                          DCD      0xff17ffc1
                          DCD      0x36f331b1
                          DCD      0xf4abf0bb
                          DCD      0xdc889cd4
                          DCD      0xd8e019f8
                          DCD      0xeffcbced
                          DCD      0xddefbe75
                          DCD      0xe5bcf8b8
                          DCD      0xfffdf7f5
                          DCD      0xea9cfab8
                          DCD      0x888c08ba
                          DCD      0x3820d0f4
                          DCD      0xbdf70f7e
                          DCD      0x4f70bf75
                          DCD      0xfbf71df9
                          DCD      0xaee8f8b3
                          DCD      0xa337fab2
                          DCD      0xdbb1bdbe
                          DCD      0x2bb909b5
                          DCD      0xfefad8bf
                          DCD      0xf1b0f3de
                          DCD      0x5c8ef086
                          DCD      0xfb10f1cc
                          DCD      0xc86ccc8c
                          DCD      0xb2013087
                          DCD      0xe040a0aa
                          DCD      0xfa18bbcb
                          DCD      0xd8e7ab2a
                          DCD      0x53c6448b
                          DCD      0xc804ddd4
                          DCD      0x7059bccc
                          DCD      0xe244032a
                          DCD      0x2158080d
                          DCD      0x8d0c84ab
                          DCD      0xeeeff3bf
                          DCD      0xebfb85af
                          DCD      0x6ee7aeaf
                          DCD      0xffffffa6
                          DCD      0x8bff8e0e
                          DCD      0x377f6677
                          DCD      0x0eff4f3b
                          DCD      0x77fffffd
                          DCD      0xd7fdcf3b
                          DCD      0x024050d0
                          DCD      0xf7c9c178
                          DCD      0x165559cd
                          DCD      0x775e4369
                          DCD      0xe00a99be
                          DCD      0x9dfb2788
                          DCD      0x3019fafb
                          DCD      0x3fb9048a
                          DCD      0xffffea7f
                          DCD      0x7fffaeff
                          DCD      0x7fbfa2ba
                          DCD      0xffbb2aa2
                          DCD      0xffffbfbe
                          DCD      0xfffffeff
                          DCD      0xf3ffaaa8
                          DCD      0xfbbf8aaa
                          DCD      0xf7d7f3e4
                          DCD      0xe23cd14b
                          DCD      0x781e4a24
                          DCD      0xfaced9ca
                          DCD      0xd9c0f530
                          DCD      0xd10011a1
                          DCD      0xbb94f928
                          DCD      0xf7f5b3ed
                          DCD      0xf73fff10
                          DCD      0x95e1bb55
                          DCD      0x7dd5e5f1
                          DCD      0xf799f714
                          DCD      0xfefffeb1
                          DCD      0x8bf7fde3
                          DCD      0x9ddcf595
                          DCD      0xcdfbdcd5
                          DCD      0xce67dcee
                          DCD      0xc57cffed
                          DCD      0xedfffe77
                          DCD      0xdd7fff7f
                          DCD      0xc86df0e8
                          DCD      0x88f1fdfd
                          DCD      0xfdfffcff
                          DCD      0xfbdfffff
                          DCD      0xf8eff2ff
                          DCD      0xb7efb6f7
                          DCD      0x42b2f2de
                          DCD      0xb077fe77
                          DCD      0x42564002
                          DCD      0xee47446f
                          DCD      0x5230267b
                          DCD      0xf7afde77
                          DCD      0x99d098dc
                          DCD      0xffdc15d8
                          DCD      0xf9519111
                          DCD      0xdf3d91dc
                          DCD      0xa29894b8
                          DCD      0x99910040
                          DCD      0xeb98affc
                          DCD      0xbfed39bd
                          DCD      0xfaeba68a
                          DCD      0x12e28a2a
                          DCD      0xffff7e01
                          DCD      0x718b8a30
                          DCD      0x7e32ef73
                          DCD      0xf072f477
                          DCD      0xdaf53f01
                          DCD      0xfab7f3e6
                          DCD      0xee6fefa7
                          DCD      0xeaec6fff
                          DCD      0x9e2de3fa
                          DCD      0xfcfffeef
                          DCD      0x83f7fcdb
                          DCD      0x4447ffff
                          DCD      0xf777f7d7
                          DCD      0xf6effdfb
                          DCD      0x708041da
                          DCD      0xd9f090d0
                          DCD      0x9010590d
                          DCD      0xfdf44db4
                          DCD      0xc028ccb1
                          DCD      0xd894ab78
                          DCD      0xdd3af6db
                          DCD      0x3f313961
                          DCD      0xc4bfcc40
                          DCD      0x40e4eff6
                          DCD      0xecfeee84
                          DCD      0xeceeff5f
                          DCD      0x41b7d4d5
                          DCD      0x4577f7b7
                          DCD      0xf8bf50b2
                          DCD      0xf7f7f7bf
                          DCD      0xeeffafaf
                          DCD      0xdfdf9ef5
                          DCD      0x6bffefdf
                          DCD      0xe9fdefab
                          DCD      0xfffffdef
                          DCD      0xffffaf8f
                          DCD      0xffffafe7
                          DCD      0xa2eee602
                          DCD      0xb069c4c0
                          DCD      0x755b4abf
                          DCD      0x73af32ff
                          DCD      0x1fff2af1
                          DCD      0xb6eba2b9
                          DCD      0xddf8a1f0
                          DCD      0x1b3dac3b
                          DCD      0x3b9b1abb
                          DCD      0xaeeb2f01
                          DCD      0x89feae77
                          DCD      0xfcfe6b4f
                          DCD      0xfee37a37
                          DCD      0xdbb53d44
                          DCD      0xcffffebd
                          DCD      0xeff2be4c
                          DCD      0xfeefc7d9
                          DCD      0x7af34f6f
                          DCD      0xffffbfbf
                          DCD      0xb3ffcfef
                          DCD      0xffffbfea
                          DCD      0x02ba4eef
                          DCD      0xbeff7eff
                          DCD      0xd1ef4cff
                          DCD      0xddff67be
                          DCD      0xdfff9deb
                          DCD      0x406bf7ff
                          DCD      0xd3ff7050
                          DCD      0xc673f6cb
                          DCD      0x83db7b9f
                          DCD      0x4cf0e5cf
                          DCD      0x76d752d6
                          DCD      0xc4f7f9d7
                          DCD      0xcf2febcf
                          DCD      0x0a0ea10b
                          DCD      0xee7fdc44
                          DCD      0xfb46c036
                          DCD      0x27e38edf
                          DCD      0x2506408e
                          DCD      0x40c2c737
                          DCD      0x57d7edcb
                          DCD      0xfbe4bc30
                          DCD      0xfc000468
                          DCD      0xabb34099
                          DCD      0xcdd50a78
                          DCD      0xdb0df0f0
                          DCD      0xb9a1501d
                          DCD      0xbf8222bb
                          DCD      0x3e2e053d
                          DCD      0xfcc7fe2a
                          DCD      0xdf9b10e9
                          DCD      0x8158de0a
                          DCD      0xaa52511e
                          DCD      0xf91bd2ce
                          DCD      0xb8b9bb81
                          DCD      0xbeabfed2
                          DCD      0x806afb83
                          DCD      0xfbffef05
                          DCD      0x776faf6f
                          DCD      0x6efded47
                          DCD      0x3273fbe3
                          DCD      0xfffff540
                          DCD      0x7757b759
                          DCD      0xefb7fd40
                          DCD      0x7377af73
                          DCD      0x464c9490
                          DCD      0xfb58d2d4
                          DCD      0xdb8811bd
                          DCD      0xdfdcf365
                          DCD      0xb325f3e8
                          DCD      0x9d9aa304
                          DCD      0xcacce9ad
                          DCD      0xaa98c8dc
                          DCD      0xeeffffdf
                          DCD      0xfb52efb7
                          DCD      0xd8e2ffc1
                          DCD      0xf042ea42
                          DCD      0xfe57ff5f
                          DCD      0xb0776f77
                          DCD      0xdf5b537b
                          DCD      0xf7e7e744
                          DCD      0x14606c34
                          DCD      0x18100100
                          DCD      0xdf2eafff
                          DCD      0x5f6107ed
                          DCD      0xbf95f7d1
                          DCD      0x38b10fb9
                          DCD      0xad3befab
                          DCD      0xbb3bab1f
                          DCD      0xdd04e942
                          DCD      0xf3ca84e8
                          DCD      0xfa00490c
                          DCD      0xfda80802
                          DCD      0xb9007b36
                          DCD      0x2a100361
                          DCD      0x1b405e73
                          DCD      0xfb7b4713
                          DCD      0xe72bffca
                          DCD      0x2089f24a
                          DCD      0xd7d7e820
                          DCD      0xd1c5e6e2
                          DCD      0xf041f242
                          DCD      0x000220a0
                          DCD      0xf511ff02
                          DCD      0xf3cff6ef
                          DCD      0xc2d0c6c4
                          DCD      0xdcda0306
                          DCD      0x9842141f
                          DCD      0xa2cac17f
                          DCD      0x506056fe
                          DCD      0xfc61a0c7
                          DCD      0xbdd8facf
                          DCD      0xda374f5b
                          DCD      0xa9a3f690
                          DCD      0xe383e680
                          DCD      0x95ffe9b0
                          DCD      0xd1f5d5b1
                          DCD      0x954fefa8
                          DCD      0x9fe9f5a3
                          DCD      0xcffffebb
                          DCD      0xab9bf6bf
                          DCD      0x18502490
                          DCD      0xdd4884bc
                          DCD      0x0323729f
                          DCD      0xffec3f78
                          DCD      0xef01a993
                          DCD      0xfb8d30d2
                          DCD      0x6f8db9ab
                          DCD      0x3f0f200a
                          DCD      0x00001010
                          DCD      0xb4ec94cf
                          DCD      0xcd88d1bc
                          DCD      0xf9fc59c4
                          DCD      0x6d9028b4
                          DCD      0xfb9480e8
                          DCD      0xfa98badc
                          DCD      0xbff808a8
                          DCD      0xeeffefef
                          DCD      0xceeedbbf
                          DCD      0xffef6f6b
                          DCD      0xffef7ffe
                          DCD      0x47fffefd
                          DCD      0x44f7ff6f
                          DCD      0x7cffb7fd
                          DCD      0xffdfffef
                          DCD      0xffffcf4f
                          DCD      0xdfffef5f
                          DCD      0x7fffeb5f
                          DCD      0x7effff7f
                          DCD      0xfdbfbe8c
                          DCD      0xcc5ffd4d
                          DCD      0xecffc488
                          DCD      0xacfffeff
                          DCD      0x7fff7b3f
                          DCD      0xffffaefb
                          DCD      0xfeffbb7b
                          DCD      0x73fbaafa
                          DCD      0xffffbeba
                          DCD      0xffffffff
                          DCD      0xff7fbabb
                          DCD      0xfbf78b3f
                          DCD      0xf6bff65f
                          DCD      0x339fe66f
                          DCD      0x626e7a7b
                          DCD      0x20adfaac
                          DCD      0xe36ff744
                          DCD      0xe54ffe0f
                          DCD      0x50b7e700
                          DCD      0xf063f5f3
                          DCD      0xf291e62e
                          DCD      0xf0ffa2ef
                          DCD      0xe2a0b68e
                          DCD      0xd0c5d2ef
                          DCD      0xb345f201
                          DCD      0x53115141
                          DCD      0xff53f83a
                          DCD      0xf33fffef
                          DCD      0xe937c8a6
                          DCD      0x88aacb67
                          DCD      0xfcefa000
                          DCD      0xe9dfe9ea
                          DCD      0xc8fbf803
                          DCD      0x80b9e2af
                          DCD      0x84d9be59
                          DCD      0xc1dbd5ff
                          DCD      0xda9b575c
                          DCD      0xfd1f1313
                          DCD      0x5e3f41f0
                          DCD      0xe5ff38ca
                          DCD      0xf9b9bbd4
                          DCD      0xaa6a013b
                          DCD      0xd9f6f4d8
                          DCD      0xc0c0ca4a
                          DCD      0xff7fd6b3
                          DCD      0x3f11712b
                          DCD      0xdafbf1e0
                          DCD      0xf109fdb4
                          DCD      0xff3ffffd
                          DCD      0xddbfffa5
                          DCD      0xc4bab1a3
                          DCD      0x9dbffddb
                          DCD      0xeb3cb1fc
                          DCD      0xbfb914f4
                          DCD      0x6665fef5
                          DCD      0x15bd6ded
                          DCD      0x95acbcbe
                          DCD      0xffb57d3f
                          DCD      0xe4b9fffe
                          DCD      0xbfcf0a90
                          DCD      0x8a2e8aba
                          DCD      0xeed61d9c
                          DCD      0x9d16155e
                          DCD      0xfff4110c
                          DCD      0x029925b1
                          DCD      0xe4f60908
                          DCD      0x558f88b0
                          DCD      0xbfc7979f
                          DCD      0xfbfff7f3
                          DCD      0x00e2f963
                          DCD      0xf77f9730
                          DCD      0xb031a7e0
                          DCD      0x79fe5dcb
                          DCD      0x84bdd7f5
                          DCD      0x57d3e1e0
                          DCD      0xd0eff7c3
                          DCD      0xefbd2f23
                          DCD      0xffe7ef8f
                          DCD      0xffeeee23
                          DCD      0xedcfafe8
                          DCD      0xffeff17f
                          DCD      0xbffee704
                          DCD      0xdfdff3ee
                          DCD      0xeacf2622
                          DCD      0xfffff747
                          DCD      0xf337331e
                          DCD      0xdfe6eaba
                          DCD      0x2232af3f
                          DCD      0xf67fe305
                          DCD      0x76dd7751
                          DCD      0xc5f5ef8e
                          DCD      0xf3dffefb
                          DCD      0xf070f8f8
                          DCD      0xb0b42ced
                          DCD      0xd9bdfbff
                          DCD      0x3d5dfefd
                          DCD      0xb220fbf8
                          DCD      0xb8b434f2
                          DCD      0xa4d1989e
                          DCD      0x28b7e2ef
                          DCD      0xddd8cfb8
                          DCD      0xfdf88cfc
                          DCD      0xfff99fb7
                          DCD      0xfffe4dfb
                          DCD      0xaa9094ec
                          DCD      0xfed0cfed
                          DCD      0x8d80c8a8
                          DCD      0xb3bd08d9
                          DCD      0xdaabcce7
                          DCD      0xdb53ec5f
                          DCD      0x6276b222
                          DCD      0x3000ea79
                          DCD      0x78324272
                          DCD      0xe652ce4f
                          DCD      0xd052fafb
                          DCD      0xff02ffdb
                          DCD      0x50c090f4
                          DCD      0xbef94edd
                          DCD      0x75cdbfde
                          DCD      0xaffb0ade
                          DCD      0x919ea59c
                          DCD      0xb8cb48eb
                          DCD      0xbb3ea7fc
                          DCD      0xbdef2a8e
                          DCD      0x04100110
                          DCD      0x48340379
                          DCD      0xedd5bd1d
                          DCD      0x3f5c5ab0
                          DCD      0x2f9cafb6
                          DCD      0xef93ff36
                          DCD      0x26a23fbb
                          DCD      0xbbbb3bda
                          DCD      0xdf6fd860
                          DCD      0x9eedfffe
                          DCD      0xf63fffa8
                          DCD      0xdffdfebe
                          DCD      0xdf7cfefb
                          DCD      0xb0feffd3
                          DCD      0xe952d7f0
                          DCD      0xc0e8fa56
                          %        64
                  lbpcascade_frontalface_featureRectangles_data
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x00000000
                          DCD      0x00000005
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000000
                          DCD      0x00000006
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000001
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x00000001
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x00000001
                          DCD      0x00000008
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x00000004
                          DCD      0x00000007
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x0000000b
                          DCD      0x0000000f
                          DCD      0x00000000
                          DCD      0x00000008
                          DCD      0x0000000c
                          DCD      0x00000010
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000000e
                          DCD      0x00000011
                          DCD      0x00000001
                          DCD      0x00000006
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x00000001
                          DCD      0x00000003
                          DCD      0x00000001
                          DCD      0x00000003
                          DCD      0x00000001
                          DCD      0x00000004
                          DCD      0x00000003
                          DCD      0x00000004
                          DCD      0x00000001
                          DCD      0x00000005
                          DCD      0x00000007
                          DCD      0x0000000b
                          DCD      0x00000001
                          DCD      0x00000003
                          DCD      0x0000000c
                          DCD      0x0000000e
                          DCD      0x00000001
                          DCD      0x00000005
                          DCD      0x0000000d
                          DCD      0x0000000e
                          DCD      0x00000001
                          DCD      0x00000005
                          DCD      0x0000000e
                          DCD      0x00000011
                          DCD      0x00000001
                          DCD      0x00000004
                          DCD      0x00000011
                          DCD      0x00000013
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000001
                          DCD      0x00000003
                          DCD      0x00000002
                          DCD      0x00000006
                          DCD      0x00000002
                          DCD      0x00000008
                          DCD      0x00000002
                          DCD      0x00000006
                          DCD      0x00000003
                          DCD      0x00000007
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000007
                          DCD      0x00000008
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x0000000b
                          DCD      0x0000000e
                          DCD      0x00000002
                          DCD      0x00000005
                          DCD      0x00000011
                          DCD      0x00000013
                          DCD      0x00000003
                          DCD      0x00000005
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000003
                          DCD      0x0000000a
                          DCD      0x00000001
                          DCD      0x00000004
                          DCD      0x00000003
                          DCD      0x00000005
                          DCD      0x00000007
                          DCD      0x00000008
                          DCD      0x00000003
                          DCD      0x00000005
                          DCD      0x00000007
                          DCD      0x0000000b
                          DCD      0x00000003
                          DCD      0x00000005
                          DCD      0x00000012
                          DCD      0x00000014
                          DCD      0x00000004
                          DCD      0x00000006
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x00000004
                          DCD      0x00000006
                          DCD      0x00000003
                          DCD      0x00000004
                          DCD      0x00000004
                          DCD      0x00000006
                          DCD      0x00000006
                          DCD      0x00000007
                          DCD      0x00000004
                          DCD      0x00000006
                          DCD      0x00000006
                          DCD      0x0000000b
                          DCD      0x00000004
                          DCD      0x00000009
                          DCD      0x00000007
                          DCD      0x00000009
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000008
                          DCD      0x0000000b
                          DCD      0x00000004
                          DCD      0x00000006
                          DCD      0x00000012
                          DCD      0x00000014
                          DCD      0x00000005
                          DCD      0x00000007
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000005
                          DCD      0x00000009
                          DCD      0x00000003
                          DCD      0x00000007
                          DCD      0x00000005
                          DCD      0x00000007
                          DCD      0x00000006
                          DCD      0x0000000b
                          DCD      0x00000005
                          DCD      0x00000007
                          DCD      0x00000009
                          DCD      0x0000000b
                          DCD      0x00000005
                          DCD      0x00000007
                          DCD      0x0000000a
                          DCD      0x0000000c
                          DCD      0x00000006
                          DCD      0x0000000a
                          DCD      0x00000003
                          DCD      0x00000007
                          DCD      0x00000006
                          DCD      0x0000000a
                          DCD      0x00000004
                          DCD      0x00000007
                          DCD      0x00000006
                          DCD      0x00000008
                          DCD      0x00000005
                          DCD      0x00000008
                          DCD      0x00000006
                          DCD      0x00000008
                          DCD      0x00000005
                          DCD      0x0000000a
                          DCD      0x00000006
                          DCD      0x0000000a
                          DCD      0x00000005
                          DCD      0x00000008
                          DCD      0x00000006
                          DCD      0x0000000a
                          DCD      0x00000006
                          DCD      0x00000008
                          DCD      0x00000006
                          DCD      0x0000000a
                          DCD      0x00000006
                          DCD      0x0000000a
                          DCD      0x00000006
                          DCD      0x00000007
                          DCD      0x00000012
                          DCD      0x00000014
                          DCD      0x00000006
                          DCD      0x00000008
                          DCD      0x00000015
                          DCD      0x00000016
                          DCD      0x00000007
                          DCD      0x0000000a
                          DCD      0x00000000
                          DCD      0x00000007
                          DCD      0x00000007
                          DCD      0x00000009
                          DCD      0x00000004
                          DCD      0x00000007
                          DCD      0x00000007
                          DCD      0x0000000c
                          DCD      0x00000009
                          DCD      0x0000000a
                          DCD      0x00000007
                          DCD      0x00000009
                          DCD      0x00000015
                          DCD      0x00000016
                          DCD      0x00000008
                          DCD      0x00000009
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000a
                          DCD      0x00000005
                          DCD      0x00000007
                          DCD      0x00000008
                          DCD      0x0000000b
                          DCD      0x00000005
                          DCD      0x00000007
                          DCD      0x00000008
                          DCD      0x0000000b
                          DCD      0x00000011
                          DCD      0x00000012
                          DCD      0x00000008
                          DCD      0x00000009
                          DCD      0x00000012
                          DCD      0x00000014
                          DCD      0x00000009
                          DCD      0x0000000e
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x00000009
                          DCD      0x0000000b
                          DCD      0x00000002
                          DCD      0x00000008
                          DCD      0x00000009
                          DCD      0x0000000a
                          DCD      0x00000005
                          DCD      0x00000006
                          DCD      0x00000009
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x0000000c
                          DCD      0x00000009
                          DCD      0x0000000a
                          DCD      0x00000010
                          DCD      0x00000011
                          DCD      0x00000009
                          DCD      0x0000000b
                          DCD      0x00000010
                          DCD      0x00000011
                          DCD      0x00000009
                          DCD      0x0000000a
                          DCD      0x00000011
                          DCD      0x00000012
                          DCD      0x00000009
                          DCD      0x0000000a
                          DCD      0x00000012
                          DCD      0x00000013
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x00000005
                          DCD      0x00000007
                          DCD      0x0000000a
                          DCD      0x0000000d
                          DCD      0x00000005
                          DCD      0x00000008
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x00000007
                          DCD      0x0000000c
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x00000008
                          DCD      0x00000009
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x00000009
                          DCD      0x0000000a
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x0000000a
                          DCD      0x0000000c
                          DCD      0x0000000a
                          DCD      0x0000000d
                          DCD      0x0000000e
                          DCD      0x00000011
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x0000000f
                          DCD      0x00000010
                          DCD      0x0000000a
                          DCD      0x0000000c
                          DCD      0x0000000f
                          DCD      0x00000010
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x00000010
                          DCD      0x00000011
                          DCD      0x0000000a
                          DCD      0x0000000c
                          DCD      0x00000010
                          DCD      0x00000011
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x00000011
                          DCD      0x00000012
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x00000015
                          DCD      0x00000016
                          DCD      0x0000000b
                          DCD      0x0000000d
                          DCD      0x00000003
                          DCD      0x00000005
                          DCD      0x0000000b
                          DCD      0x0000000c
                          DCD      0x00000005
                          DCD      0x00000007
                          DCD      0x0000000b
                          DCD      0x0000000e
                          DCD      0x00000005
                          DCD      0x00000008
                          DCD      0x0000000b
                          DCD      0x0000000f
                          DCD      0x00000005
                          DCD      0x0000000b
                          DCD      0x0000000b
                          DCD      0x0000000c
                          DCD      0x00000006
                          DCD      0x00000007
                          DCD      0x0000000b
                          DCD      0x0000000d
                          DCD      0x00000007
                          DCD      0x00000009
                          DCD      0x0000000b
                          DCD      0x0000000c
                          DCD      0x00000008
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x0000000c
                          DCD      0x0000000a
                          DCD      0x0000000b
                          DCD      0x0000000b
                          DCD      0x0000000c
                          DCD      0x0000000a
                          DCD      0x0000000c
                          DCD      0x0000000b
                          DCD      0x0000000c
                          DCD      0x0000000f
                          DCD      0x00000010
                          DCD      0x0000000b
                          DCD      0x0000000c
                          DCD      0x00000011
                          DCD      0x00000012
                          DCD      0x0000000b
                          DCD      0x0000000c
                          DCD      0x00000012
                          DCD      0x00000013
                          DCD      0x0000000c
                          DCD      0x0000000e
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x0000000c
                          DCD      0x0000000e
                          DCD      0x00000001
                          DCD      0x00000006
                          DCD      0x0000000c
                          DCD      0x00000010
                          DCD      0x00000002
                          DCD      0x00000003
                          DCD      0x0000000c
                          DCD      0x0000000d
                          DCD      0x00000003
                          DCD      0x00000006
                          DCD      0x0000000c
                          DCD      0x0000000f
                          DCD      0x00000007
                          DCD      0x0000000b
                          DCD      0x0000000c
                          DCD      0x0000000f
                          DCD      0x0000000a
                          DCD      0x0000000c
                          DCD      0x0000000c
                          DCD      0x0000000d
                          DCD      0x0000000b
                          DCD      0x0000000c
                          DCD      0x0000000c
                          DCD      0x0000000f
                          DCD      0x0000000c
                          DCD      0x0000000e
                          DCD      0x0000000c
                          DCD      0x00000010
                          DCD      0x0000000e
                          DCD      0x00000011
                          DCD      0x0000000c
                          DCD      0x0000000d
                          DCD      0x00000011
                          DCD      0x00000012
                          DCD      0x0000000c
                          DCD      0x0000000e
                          DCD      0x00000015
                          DCD      0x00000016
                          DCD      0x0000000d
                          DCD      0x0000000f
                          DCD      0x00000006
                          DCD      0x0000000b
                          DCD      0x0000000d
                          DCD      0x00000010
                          DCD      0x00000007
                          DCD      0x0000000c
                          DCD      0x0000000d
                          DCD      0x00000010
                          DCD      0x0000000b
                          DCD      0x0000000d
                          DCD      0x0000000d
                          DCD      0x0000000f
                          DCD      0x00000011
                          DCD      0x00000013
                          DCD      0x0000000d
                          DCD      0x00000010
                          DCD      0x00000011
                          DCD      0x00000013
                          DCD      0x0000000d
                          DCD      0x0000000e
                          DCD      0x00000012
                          DCD      0x00000014
                          DCD      0x0000000d
                          DCD      0x0000000f
                          DCD      0x00000012
                          DCD      0x00000014
                          DCD      0x0000000e
                          DCD      0x00000010
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x0000000e
                          DCD      0x0000000f
                          DCD      0x00000001
                          DCD      0x00000004
                          DCD      0x0000000e
                          DCD      0x00000011
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x0000000e
                          DCD      0x00000010
                          DCD      0x00000007
                          DCD      0x00000008
                          DCD      0x0000000e
                          DCD      0x00000010
                          DCD      0x0000000d
                          DCD      0x0000000e
                          DCD      0x0000000e
                          DCD      0x00000011
                          DCD      0x0000000d
                          DCD      0x00000010
                          DCD      0x0000000e
                          DCD      0x00000010
                          DCD      0x00000011
                          DCD      0x00000013
                          DCD      0x0000000f
                          DCD      0x00000011
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x0000000f
                          DCD      0x00000011
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x0000000f
                          DCD      0x00000012
                          DCD      0x00000004
                          DCD      0x00000006
                          DCD      0x0000000f
                          DCD      0x00000012
                          DCD      0x00000004
                          DCD      0x0000000a
                          DCD      0x0000000f
                          DCD      0x00000012
                          DCD      0x00000006
                          DCD      0x00000008
                          DCD      0x0000000f
                          DCD      0x00000012
                          DCD      0x0000000b
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x00000012
                          DCD      0x0000000d
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x00000011
                          DCD      0x00000011
                          DCD      0x00000013
                          DCD      0x0000000f
                          DCD      0x00000012
                          DCD      0x00000011
                          DCD      0x00000013
                          DCD      0x00000010
                          DCD      0x00000012
                          DCD      0x00000001
                          DCD      0x00000004
                          DCD      0x00000010
                          DCD      0x00000012
                          DCD      0x00000003
                          DCD      0x00000007
                          DCD      0x00000010
                          DCD      0x00000011
                          DCD      0x00000006
                          DCD      0x00000007
                          DCD      0x00000010
                          DCD      0x00000012
                          DCD      0x00000010
                          DCD      0x00000012
                          DCD      0x00000011
                          DCD      0x00000013
                          DCD      0x00000001
                          DCD      0x00000003
                          DCD      0x00000011
                          DCD      0x00000013
                          DCD      0x00000001
                          DCD      0x00000006
                          DCD      0x00000011
                          DCD      0x00000013
                          DCD      0x0000000c
                          DCD      0x0000000e
                          DCD      0x00000012
                          DCD      0x00000014
                          DCD      0x00000000
                          DCD      0x00000002
                          %        64
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754730vignettingCorrectionParametersE ; Anki::Cozmo::VisionSystem::<unnamed>::vignettingCorrectionParameters
002cd0  00000000          DCFS     0x00000000 ; 0
002cd4  00000000          DCFS     0x00000000 ; 0
002cd8  00000000          DCFS     0x00000000 ; 0
002cdc  00000000          DCFS     0x00000000 ; 0
002ce0  00000000          DCFS     0x00000000 ; 0
                  _ZN4Anki5Cozmo12VisionSystem14CameraModeInfoE ; Anki::Cozmo::VisionSystem::CameraModeInfo
002ce4  ba00              DCB      0xba,0x00
002ce6  0280              DCW      0x0280
002ce8  01e0              DCW      0x01e0
002cea  0001              DCB      0x00,0x01
002cec  02030400          DCB      0x02,0x03,0x04,0x00
002cf0  bc00              DCB      0xbc,0x00
002cf2  0140              DCW      0x0140
002cf4  00f0              DCW      0x00f0
002cf6  0000              DCB      0x00,0x00
002cf8  01020300          DCB      0x01,0x02,0x03,0x00
002cfc  b800              DCB      0xb8,0x00
002cfe  00a0              DCW      0x00a0
002d00  0078              DCW      0x0078
002d02  0000              DCB      0x00,0x00
002d04  00010200          DCB      0x00,0x01,0x02,0x00
002d08  bd00              DCB      0xbd,0x00
002d0a  0050              DCW      0x0050
002d0c  003c              DCW      0x003c
002d0e  0000              DCB      0x00,0x00
002d10  00000100          DCB      0x00,0x00,0x01,0x00
002d14  b700              DCB      0xb7,0x00
002d16  0028              DCW      0x0028
002d18  001e              DCW      0x001e
002d1a  0000              DCB      0x00,0x00
002d1c  00000000          DCB      0x00,0x00,0x00,0x00
                          %        12
                  __PRETTY_FUNCTION__
002d2c  416e6b69          DCB      0x41,0x6e,0x6b,0x69
002d30  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
002d34  73756c74          DCB      0x73,0x75,0x6c,0x74
002d38  20416e6b          DCB      0x20,0x41,0x6e,0x6b
002d3c  693a3a43          DCB      0x69,0x3a,0x3a,0x43
002d40  6f7a6d6f          DCB      0x6f,0x7a,0x6d,0x6f
002d44  3a3a5669          DCB      0x3a,0x3a,0x56,0x69
002d48  73696f6e          DCB      0x73,0x69,0x6f,0x6e
002d4c  53797374          DCB      0x53,0x79,0x73,0x74
002d50  656d3a3a          DCB      0x65,0x6d,0x3a,0x3a
002d54  55706461          DCB      0x55,0x70,0x64,0x61
002d58  74654d61          DCB      0x74,0x65,0x4d,0x61
002d5c  726b6572          DCB      0x72,0x6b,0x65,0x72
002d60  546f5472          DCB      0x54,0x6f,0x54,0x72
002d64  61636b28          DCB      0x61,0x63,0x6b,0x28
002d68  2900              DCB      0x29,0x00
                  |symbol_number.300|
002d6a  416e              DCB      0x41,0x6e
002d6c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
002d70  52657375          DCB      0x52,0x65,0x73,0x75
002d74  6c742041          DCB      0x6c,0x74,0x20,0x41
002d78  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
002d7c  3a436f7a          DCB      0x3a,0x43,0x6f,0x7a
002d80  6d6f3a3a          DCB      0x6d,0x6f,0x3a,0x3a
002d84  56697369          DCB      0x56,0x69,0x73,0x69
002d88  6f6e5379          DCB      0x6f,0x6e,0x53,0x79
002d8c  7374656d          DCB      0x73,0x74,0x65,0x6d
002d90  3a3a4272          DCB      0x3a,0x3a,0x42,0x72
002d94  69676874          DCB      0x69,0x67,0x68,0x74
002d98  6e657373          DCB      0x6e,0x65,0x73,0x73
002d9c  4e6f726d          DCB      0x4e,0x6f,0x72,0x6d
002da0  616c697a          DCB      0x61,0x6c,0x69,0x7a
002da4  65496d61          DCB      0x65,0x49,0x6d,0x61
002da8  67652841          DCB      0x67,0x65,0x28,0x41
002dac  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
002db0  3a456d62          DCB      0x3a,0x45,0x6d,0x62
002db4  65646465          DCB      0x65,0x64,0x64,0x65
002db8  643a3a41          DCB      0x64,0x3a,0x3a,0x41
002dbc  72726179          DCB      0x72,0x72,0x61,0x79
002dc0  3c756e73          DCB      0x3c,0x75,0x6e,0x73
002dc4  69676e65          DCB      0x69,0x67,0x6e,0x65
002dc8  64206368          DCB      0x64,0x20,0x63,0x68
002dcc  61723e20          DCB      0x61,0x72,0x3e,0x20
002dd0  262c2063          DCB      0x26,0x2c,0x20,0x63
002dd4  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
002dd8  20416e6b          DCB      0x20,0x41,0x6e,0x6b
002ddc  693a3a45          DCB      0x69,0x3a,0x3a,0x45
002de0  6d626564          DCB      0x6d,0x62,0x65,0x64
002de4  6465643a          DCB      0x64,0x65,0x64,0x3a
002de8  3a517561          DCB      0x3a,0x51,0x75,0x61
002dec  6472696c          DCB      0x64,0x72,0x69,0x6c
002df0  61746572          DCB      0x61,0x74,0x65,0x72
002df4  616c3c66          DCB      0x61,0x6c,0x3c,0x66
002df8  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
002dfc  3e20262c          DCB      0x3e,0x20,0x26,0x2c
002e00  20666c6f          DCB      0x20,0x66,0x6c,0x6f
002e04  61742c20          DCB      0x61,0x74,0x2c,0x20
002e08  416e6b69          DCB      0x41,0x6e,0x6b,0x69
002e0c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
002e10  62656464          DCB      0x62,0x65,0x64,0x64
002e14  65643a3a          DCB      0x65,0x64,0x3a,0x3a
002e18  4d656d6f          DCB      0x4d,0x65,0x6d,0x6f
002e1c  72795374          DCB      0x72,0x79,0x53,0x74
002e20  61636b29          DCB      0x61,0x63,0x6b,0x29
002e24  00                DCB      0x00
                  |symbol_number.301|
002e25  416e6b            DCB      0x41,0x6e,0x6b
002e28  693a3a52          DCB      0x69,0x3a,0x3a,0x52
002e2c  6573756c          DCB      0x65,0x73,0x75,0x6c
002e30  7420416e          DCB      0x74,0x20,0x41,0x6e
002e34  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
002e38  436f7a6d          DCB      0x43,0x6f,0x7a,0x6d
002e3c  6f3a3a56          DCB      0x6f,0x3a,0x3a,0x56
002e40  6973696f          DCB      0x69,0x73,0x69,0x6f
002e44  6e537973          DCB      0x6e,0x53,0x79,0x73
002e48  74656d3a          DCB      0x74,0x65,0x6d,0x3a
002e4c  3a476574          DCB      0x3a,0x47,0x65,0x74
002e50  56697369          DCB      0x56,0x69,0x73,0x69
002e54  6f6e4d61          DCB      0x6f,0x6e,0x4d,0x61
002e58  726b6572          DCB      0x72,0x6b,0x65,0x72
002e5c  506f7365          DCB      0x50,0x6f,0x73,0x65
002e60  4e656172          DCB      0x4e,0x65,0x61,0x72
002e64  65737454          DCB      0x65,0x73,0x74,0x54
002e68  6f28636f          DCB      0x6f,0x28,0x63,0x6f
002e6c  6e737420          DCB      0x6e,0x73,0x74,0x20
002e70  416e6b69          DCB      0x41,0x6e,0x6b,0x69
002e74  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
002e78  62656464          DCB      0x62,0x65,0x64,0x64
002e7c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
002e80  506f696e          DCB      0x50,0x6f,0x69,0x6e
002e84  74333c66          DCB      0x74,0x33,0x3c,0x66
002e88  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
002e8c  3e20262c          DCB      0x3e,0x20,0x26,0x2c
002e90  20636f6e          DCB      0x20,0x63,0x6f,0x6e
002e94  73742041          DCB      0x73,0x74,0x20,0x41
002e98  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
002e9c  3a566973          DCB      0x3a,0x56,0x69,0x73
002ea0  696f6e3a          DCB      0x69,0x6f,0x6e,0x3a
002ea4  3a4d6172          DCB      0x3a,0x4d,0x61,0x72
002ea8  6b657254          DCB      0x6b,0x65,0x72,0x54
002eac  79706520          DCB      0x79,0x70,0x65,0x20
002eb0  262c2066          DCB      0x26,0x2c,0x20,0x66
002eb4  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
002eb8  2c20416e          DCB      0x2c,0x20,0x41,0x6e
002ebc  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
002ec0  456d6265          DCB      0x45,0x6d,0x62,0x65
002ec4  64646564          DCB      0x64,0x64,0x65,0x64
002ec8  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
002ecc  7261793c          DCB      0x72,0x61,0x79,0x3c
002ed0  666c6f61          DCB      0x66,0x6c,0x6f,0x61
002ed4  743e2026          DCB      0x74,0x3e,0x20,0x26
002ed8  2c20416e          DCB      0x2c,0x20,0x41,0x6e
002edc  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
002ee0  456d6265          DCB      0x45,0x6d,0x62,0x65
002ee4  64646564          DCB      0x64,0x64,0x65,0x64
002ee8  3a3a506f          DCB      0x3a,0x3a,0x50,0x6f
002eec  696e7433          DCB      0x69,0x6e,0x74,0x33
002ef0  3c666c6f          DCB      0x3c,0x66,0x6c,0x6f
002ef4  61743e20          DCB      0x61,0x74,0x3e,0x20
002ef8  262c2062          DCB      0x26,0x2c,0x20,0x62
002efc  6f6f6c20          DCB      0x6f,0x6f,0x6c,0x20
002f00  262900            DCB      0x26,0x29,0x00
                  _ZZN4Anki5Cozmo12VisionSystem18GetCamPoseWrtRobotIfEENS_6ResultERNS_8Embedded5ArrayIT_EERNS4_6Point3IS6_EEE19__PRETTY_FUNCTION__ ; Anki::Cozmo::VisionSystem::GetCamPoseWrtRobot<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Point3<T1>&)::__PRETTY_FUNCTION__
002f03  41                DCB      0x41
002f04  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
002f08  3a526573          DCB      0x3a,0x52,0x65,0x73
002f0c  756c7420          DCB      0x75,0x6c,0x74,0x20
002f10  416e6b69          DCB      0x41,0x6e,0x6b,0x69
002f14  3a3a436f          DCB      0x3a,0x3a,0x43,0x6f
002f18  7a6d6f3a          DCB      0x7a,0x6d,0x6f,0x3a
002f1c  3a566973          DCB      0x3a,0x56,0x69,0x73
002f20  696f6e53          DCB      0x69,0x6f,0x6e,0x53
002f24  79737465          DCB      0x79,0x73,0x74,0x65
002f28  6d3a3a47          DCB      0x6d,0x3a,0x3a,0x47
002f2c  65744361          DCB      0x65,0x74,0x43,0x61
002f30  6d506f73          DCB      0x6d,0x50,0x6f,0x73
002f34  65577274          DCB      0x65,0x57,0x72,0x74
002f38  526f626f          DCB      0x52,0x6f,0x62,0x6f
002f3c  7428416e          DCB      0x74,0x28,0x41,0x6e
002f40  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
002f44  456d6265          DCB      0x45,0x6d,0x62,0x65
002f48  64646564          DCB      0x64,0x64,0x65,0x64
002f4c  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
002f50  7261793c          DCB      0x72,0x61,0x79,0x3c
002f54  54797065          DCB      0x54,0x79,0x70,0x65
002f58  3e20262c          DCB      0x3e,0x20,0x26,0x2c
002f5c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
002f60  693a3a45          DCB      0x69,0x3a,0x3a,0x45
002f64  6d626564          DCB      0x6d,0x62,0x65,0x64
002f68  6465643a          DCB      0x64,0x65,0x64,0x3a
002f6c  3a506f69          DCB      0x3a,0x50,0x6f,0x69
002f70  6e74333c          DCB      0x6e,0x74,0x33,0x3c
002f74  54797065          DCB      0x54,0x79,0x70,0x65
002f78  3e202629          DCB      0x3e,0x20,0x26,0x29
002f7c  205b7769          DCB      0x20,0x5b,0x77,0x69
002f80  74682050          DCB      0x74,0x68,0x20,0x50
002f84  52454349          DCB      0x52,0x45,0x43,0x49
002f88  53494f4e          DCB      0x53,0x49,0x4f,0x4e
002f8c  203d2066          DCB      0x20,0x3d,0x20,0x66
002f90  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
002f94  5d00              DCB      0x5d,0x00
                  |symbol_number.302|
002f96  416e              DCB      0x41,0x6e
002f98  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
002f9c  52657375          DCB      0x52,0x65,0x73,0x75
002fa0  6c742041          DCB      0x6c,0x74,0x20,0x41
002fa4  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
002fa8  3a436f7a          DCB      0x3a,0x43,0x6f,0x7a
002fac  6d6f3a3a          DCB      0x6d,0x6f,0x3a,0x3a
002fb0  56697369          DCB      0x56,0x69,0x73,0x69
002fb4  6f6e5379          DCB      0x6f,0x6e,0x53,0x79
002fb8  7374656d          DCB      0x73,0x74,0x65,0x6d
002fbc  3a3a5461          DCB      0x3a,0x3a,0x54,0x61
002fc0  6b65536e          DCB      0x6b,0x65,0x53,0x6e
002fc4  61707368          DCB      0x61,0x70,0x73,0x68
002fc8  6f742841          DCB      0x6f,0x74,0x28,0x41
002fcc  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
002fd0  3a456d62          DCB      0x3a,0x45,0x6d,0x62
002fd4  65646465          DCB      0x65,0x64,0x64,0x65
002fd8  643a3a52          DCB      0x64,0x3a,0x3a,0x52
002fdc  65637461          DCB      0x65,0x63,0x74,0x61
002fe0  6e676c65          DCB      0x6e,0x67,0x6c,0x65
002fe4  3c736967          DCB      0x3c,0x73,0x69,0x67
002fe8  6e656420          DCB      0x6e,0x65,0x64,0x20
002fec  696e743e          DCB      0x69,0x6e,0x74,0x3e
002ff0  2c207369          DCB      0x2c,0x20,0x73,0x69
002ff4  676e6564          DCB      0x67,0x6e,0x65,0x64
002ff8  20696e74          DCB      0x20,0x69,0x6e,0x74
002ffc  2c20416e          DCB      0x2c,0x20,0x41,0x6e
003000  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
003004  456d6265          DCB      0x45,0x6d,0x62,0x65
003008  64646564          DCB      0x64,0x64,0x65,0x64
00300c  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
003010  7261793c          DCB      0x72,0x61,0x79,0x3c
003014  756e7369          DCB      0x75,0x6e,0x73,0x69
003018  676e6564          DCB      0x67,0x6e,0x65,0x64
00301c  20636861          DCB      0x20,0x63,0x68,0x61
003020  723e2026          DCB      0x72,0x3e,0x20,0x26
003024  2c20626f          DCB      0x2c,0x20,0x62,0x6f
003028  6f6c2026          DCB      0x6f,0x6c,0x20,0x26
00302c  2900              DCB      0x29,0x00
                  |symbol_number.303|
00302e  416e              DCB      0x41,0x6e
003030  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
003034  52657375          DCB      0x52,0x65,0x73,0x75
003038  6c742041          DCB      0x6c,0x74,0x20,0x41
00303c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
003040  3a436f7a          DCB      0x3a,0x43,0x6f,0x7a
003044  6d6f3a3a          DCB      0x6d,0x6f,0x3a,0x3a
003048  56697369          DCB      0x56,0x69,0x73,0x69
00304c  6f6e5379          DCB      0x6f,0x6e,0x53,0x79
003050  7374656d          DCB      0x73,0x74,0x65,0x6d
003054  3a3a5570          DCB      0x3a,0x3a,0x55,0x70
003058  64617465          DCB      0x64,0x61,0x74,0x65
00305c  28416e6b          DCB      0x28,0x41,0x6e,0x6b
003060  693a3a43          DCB      0x69,0x3a,0x3a,0x43
003064  6f7a6d6f          DCB      0x6f,0x7a,0x6d,0x6f
003068  3a3a4d65          DCB      0x3a,0x3a,0x4d,0x65
00306c  73736167          DCB      0x73,0x73,0x61,0x67
003070  65733a3a          DCB      0x65,0x73,0x3a,0x3a
003074  526f626f          DCB      0x52,0x6f,0x62,0x6f
003078  74537461          DCB      0x74,0x53,0x74,0x61
00307c  74652900          DCB      0x74,0x65,0x29,0x00
003080  4c696e65          DCB      0x4c,0x69,0x6e,0x65
003084  61725365          DCB      0x61,0x72,0x53,0x65
003088  7175656e          DCB      0x71,0x75,0x65,0x6e
00308c  63653c54          DCB      0x63,0x65,0x3c,0x54
003090  7970653e          DCB      0x79,0x70,0x65,0x3e
003094  3a3a636f          DCB      0x3a,0x3a,0x63,0x6f
003098  6d707574          DCB      0x6d,0x70,0x75,0x74
00309c  6553697a          DCB      0x65,0x53,0x69,0x7a
0030a0  65000000          DCB      0x65,0x00,0x00,0x00
0030a4  73697a65          DCB      0x73,0x69,0x7a,0x65
0030a8  20657374          DCB      0x20,0x65,0x73,0x74
0030ac  696d6174          DCB      0x69,0x6d,0x61,0x74
0030b0  696f6e20          DCB      0x69,0x6f,0x6e,0x20
0030b4  6661696c          DCB      0x66,0x61,0x69,0x6c
0030b8  65640000          DCB      0x65,0x64,0x00,0x00
0030bc  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
0030c0  6f726574          DCB      0x6f,0x72,0x65,0x74
0030c4  6563685c          DCB      0x65,0x63,0x68,0x5c
0030c8  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
0030cc  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
0030d0  6e636c75          DCB      0x6e,0x63,0x6c,0x75
0030d4  64655c61          DCB      0x64,0x65,0x5c,0x61
0030d8  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
0030dc  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
0030e0  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
0030e4  6f626f74          DCB      0x6f,0x62,0x6f,0x74
0030e8  2f736571          DCB      0x2f,0x73,0x65,0x71
0030ec  75656e63          DCB      0x75,0x65,0x6e,0x63
0030f0  65732e68          DCB      0x65,0x73,0x2e,0x68
0030f4  00000000          DCB      0x00,0x00,0x00,0x00
0030f8  41727261          DCB      0x41,0x72,0x72,0x61
0030fc  793c5479          DCB      0x79,0x3c,0x54,0x79
003100  70653e3a          DCB      0x70,0x65,0x3e,0x3a
003104  3a436f6d          DCB      0x3a,0x43,0x6f,0x6d
003108  70757465          DCB      0x70,0x75,0x74,0x65
00310c  52657175          DCB      0x52,0x65,0x71,0x75
003110  69726564          DCB      0x69,0x72,0x65,0x64
003114  53747269          DCB      0x53,0x74,0x72,0x69
003118  64650000          DCB      0x64,0x65,0x00,0x00
00311c  496e7661          DCB      0x49,0x6e,0x76,0x61
003120  6c696420          DCB      0x6c,0x69,0x64,0x20
003124  73697a65          DCB      0x73,0x69,0x7a,0x65
003128  00000000          DCB      0x00,0x00,0x00,0x00
00312c  2e2e5c63          DCB      0x2e,0x2e,0x5c,0x63
003130  6f726574          DCB      0x6f,0x72,0x65,0x74
003134  6563685c          DCB      0x65,0x63,0x68,0x5c
003138  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
00313c  6f6e5c69          DCB      0x6f,0x6e,0x5c,0x69
003140  6e636c75          DCB      0x6e,0x63,0x6c,0x75
003144  64655c61          DCB      0x64,0x65,0x5c,0x61
003148  6e6b692f          DCB      0x6e,0x6b,0x69,0x2f
00314c  636f6d6d          DCB      0x63,0x6f,0x6d,0x6d
003150  6f6e2f72          DCB      0x6f,0x6e,0x2f,0x72
003154  6f626f74          DCB      0x6f,0x62,0x6f,0x74
003158  2f617272          DCB      0x2f,0x61,0x72,0x72
00315c  61793264          DCB      0x61,0x79,0x32,0x64
003160  2e680000          DCB      0x2e,0x68,0x00,0x00
003164  69662074          DCB      0x69,0x66,0x20,0x74
003168  68652064          DCB      0x68,0x65,0x20,0x64
00316c  61746120          DCB      0x61,0x74,0x61,0x20
003170  62756666          DCB      0x62,0x75,0x66,0x66
003174  65722062          DCB      0x65,0x72,0x20,0x62
003178  65696e67          DCB      0x65,0x69,0x6e,0x67
00317c  20706173          DCB      0x20,0x70,0x61,0x73
003180  73656420          DCB      0x73,0x65,0x64,0x20
003184  696e2064          DCB      0x69,0x6e,0x20,0x64
003188  6f65736e          DCB      0x6f,0x65,0x73,0x6e
00318c  27742063          DCB      0x27,0x74,0x20,0x63
003190  6f6e7461          DCB      0x6f,0x6e,0x74,0x61
003194  696e2061          DCB      0x69,0x6e,0x20,0x61
003198  20726177          DCB      0x20,0x72,0x61,0x77
00319c  20627566          DCB      0x20,0x62,0x75,0x66
0031a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0031a4  20746865          DCB      0x20,0x74,0x68,0x65
0031a8  20646174          DCB      0x20,0x64,0x61,0x74
0031ac  614c656e          DCB      0x61,0x4c,0x65,0x6e
0031b0  67746820          DCB      0x67,0x74,0x68,0x20
0031b4  6d757374          DCB      0x6d,0x75,0x73,0x74
0031b8  20626520          DCB      0x20,0x62,0x65,0x20
0031bc  67726561          DCB      0x67,0x72,0x65,0x61
0031c0  7465722d          DCB      0x74,0x65,0x72,0x2d
0031c4  7468616e          DCB      0x74,0x68,0x61,0x6e
0031c8  2d6f722d          DCB      0x2d,0x6f,0x72,0x2d
0031cc  65717561          DCB      0x65,0x71,0x75,0x61
0031d0  6c2d746f          DCB      0x6c,0x2d,0x74,0x6f
0031d4  20746865          DCB      0x20,0x74,0x68,0x65
0031d8  20737472          DCB      0x20,0x73,0x74,0x72
0031dc  69646500          DCB      0x69,0x64,0x65,0x00
0031e0  69662074          DCB      0x69,0x66,0x20,0x74
0031e4  68652064          DCB      0x68,0x65,0x20,0x64
0031e8  61746120          DCB      0x61,0x74,0x61,0x20
0031ec  62756666          DCB      0x62,0x75,0x66,0x66
0031f0  65722062          DCB      0x65,0x72,0x20,0x62
0031f4  65696e67          DCB      0x65,0x69,0x6e,0x67
0031f8  20706173          DCB      0x20,0x70,0x61,0x73
0031fc  73656420          DCB      0x73,0x65,0x64,0x20
003200  696e2064          DCB      0x69,0x6e,0x20,0x64
003204  6f65736e          DCB      0x6f,0x65,0x73,0x6e
003208  27742063          DCB      0x27,0x74,0x20,0x63
00320c  6f6e7461          DCB      0x6f,0x6e,0x74,0x61
003210  696e2061          DCB      0x69,0x6e,0x20,0x61
003214  20726177          DCB      0x20,0x72,0x61,0x77
003218  20627566          DCB      0x20,0x62,0x75,0x66
00321c  6665722c          DCB      0x66,0x65,0x72,0x2c
003220  20746865          DCB      0x20,0x74,0x68,0x65
003224  20737472          DCB      0x20,0x73,0x74,0x72
003228  69646520          DCB      0x69,0x64,0x65,0x20
00322c  6d757374          DCB      0x6d,0x75,0x73,0x74
003230  20626520          DCB      0x20,0x62,0x65,0x20
003234  73696d70          DCB      0x73,0x69,0x6d,0x70
003238  6c650000          DCB      0x6c,0x65,0x00,0x00
00323c  69662074          DCB      0x69,0x66,0x20,0x74
003240  68652064          DCB      0x68,0x65,0x20,0x64
003244  61746120          DCB      0x61,0x74,0x61,0x20
003248  62756666          DCB      0x62,0x75,0x66,0x66
00324c  65722062          DCB      0x65,0x72,0x20,0x62
003250  65696e67          DCB      0x65,0x69,0x6e,0x67
003254  20706173          DCB      0x20,0x70,0x61,0x73
003258  73656420          DCB      0x73,0x65,0x64,0x20
00325c  696e2064          DCB      0x69,0x6e,0x20,0x64
003260  6f65736e          DCB      0x6f,0x65,0x73,0x6e
003264  27742063          DCB      0x27,0x74,0x20,0x63
003268  6f6e7461          DCB      0x6f,0x6e,0x74,0x61
00326c  696e2061          DCB      0x69,0x6e,0x20,0x61
003270  20726177          DCB      0x20,0x72,0x61,0x77
003274  20627566          DCB      0x20,0x62,0x75,0x66
003278  6665722c          DCB      0x66,0x65,0x72,0x2c
00327c  20286e75          DCB      0x20,0x28,0x6e,0x75
003280  6d436f6c          DCB      0x6d,0x43,0x6f,0x6c
003284  732a7369          DCB      0x73,0x2a,0x73,0x69
003288  7a656f66          DCB      0x7a,0x65,0x6f,0x66
00328c  28547970          DCB      0x28,0x54,0x79,0x70
003290  65292920          DCB      0x65,0x29,0x29,0x20
003294  6d6f6420          DCB      0x6d,0x6f,0x64,0x20
003298  4d454d4f          DCB      0x4d,0x45,0x4d,0x4f
00329c  52595f41          DCB      0x52,0x59,0x5f,0x41
0032a0  4c49474e          DCB      0x4c,0x49,0x47,0x4e
0032a4  4d454e54          DCB      0x4d,0x45,0x4e,0x54
0032a8  206d7573          DCB      0x20,0x6d,0x75,0x73
0032ac  74206571          DCB      0x74,0x20,0x65,0x71
0032b0  75616c20          DCB      0x75,0x61,0x6c,0x20
0032b4  7a65726f          DCB      0x7a,0x65,0x72,0x6f
0032b8  00000000          DCB      0x00,0x00,0x00,0x00
0032bc  69662074          DCB      0x69,0x66,0x20,0x74
0032c0  68652064          DCB      0x68,0x65,0x20,0x64
0032c4  61746120          DCB      0x61,0x74,0x61,0x20
0032c8  62756666          DCB      0x62,0x75,0x66,0x66
0032cc  65722062          DCB      0x65,0x72,0x20,0x62
0032d0  65696e67          DCB      0x65,0x69,0x6e,0x67
0032d4  20706173          DCB      0x20,0x70,0x61,0x73
0032d8  73656420          DCB      0x73,0x65,0x64,0x20
0032dc  696e2064          DCB      0x69,0x6e,0x20,0x64
0032e0  6f65736e          DCB      0x6f,0x65,0x73,0x6e
0032e4  27742063          DCB      0x27,0x74,0x20,0x63
0032e8  6f6e7461          DCB      0x6f,0x6e,0x74,0x61
0032ec  696e2061          DCB      0x69,0x6e,0x20,0x61
0032f0  20726177          DCB      0x20,0x72,0x61,0x77
0032f4  20627566          DCB      0x20,0x62,0x75,0x66
0032f8  6665722c          DCB      0x66,0x65,0x72,0x2c
0032fc  20666c61          DCB      0x20,0x66,0x6c,0x61
003300  67732e67          DCB      0x67,0x73,0x2e,0x67
003304  65745f75          DCB      0x65,0x74,0x5f,0x75
003308  7365426f          DCB      0x73,0x65,0x42,0x6f
00330c  756e6461          DCB      0x75,0x6e,0x64,0x61
003310  72794669          DCB      0x72,0x79,0x46,0x69
003314  6c6c5061          DCB      0x6c,0x6c,0x50,0x61
003318  74746572          DCB      0x74,0x74,0x65,0x72
00331c  6e73206d          DCB      0x6e,0x73,0x20,0x6d
003320  75737420          DCB      0x75,0x73,0x74,0x20
003324  62652066          DCB      0x62,0x65,0x20,0x66
003328  616c7365          DCB      0x61,0x6c,0x73,0x65
00332c  00000000          DCB      0x00,0x00,0x00,0x00
003330  41727261          DCB      0x41,0x72,0x72,0x61
003334  793c5479          DCB      0x79,0x3c,0x54,0x79
003338  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00333c  3a676574          DCB      0x3a,0x67,0x65,0x74
003340  5f73697a          DCB      0x5f,0x73,0x69,0x7a
003344  65000000          DCB      0x65,0x00,0x00,0x00
003348  4e656761          DCB      0x4e,0x65,0x67,0x61
00334c  74697665          DCB      0x74,0x69,0x76,0x65
003350  2064696d          DCB      0x20,0x64,0x69,0x6d
003354  656e7369          DCB      0x65,0x6e,0x73,0x69
003358  6f6e0000          DCB      0x6f,0x6e,0x00,0x00
00335c  54726163          DCB      0x54,0x72,0x61,0x63
003360  6b657220          DCB      0x6b,0x65,0x72,0x20
003364  6661696c          DCB      0x66,0x61,0x69,0x6c
003368  65643a20          DCB      0x65,0x64,0x3a,0x20
00336c  746f6f20          DCB      0x74,0x6f,0x6f,0x20
003370  6d616e79          DCB      0x6d,0x61,0x6e,0x79
003374  20696e2d          DCB      0x20,0x69,0x6e,0x2d
003378  626f756e          DCB      0x62,0x6f,0x75,0x6e
00337c  64732070          DCB      0x64,0x73,0x20,0x70
003380  6978656c          DCB      0x69,0x78,0x65,0x6c
003384  73206661          DCB      0x73,0x20,0x66,0x61
003388  696c6564          DCB      0x69,0x6c,0x65,0x64
00338c  20696e74          DCB      0x20,0x69,0x6e,0x74
003390  656e7369          DCB      0x65,0x6e,0x73,0x69
003394  74792076          DCB      0x74,0x79,0x20,0x76
003398  65726966          DCB      0x65,0x72,0x69,0x66
00339c  69636174          DCB      0x69,0x63,0x61,0x74
0033a0  696f6e20          DCB      0x69,0x6f,0x6e,0x20
0033a4  28256420          DCB      0x28,0x25,0x64,0x20
0033a8  2f202564          DCB      0x2f,0x20,0x25,0x64
0033ac  203c2025          DCB      0x20,0x3c,0x20,0x25
0033b0  66292e0a          DCB      0x66,0x29,0x2e,0x0a
0033b4  00000000          DCB      0x00,0x00,0x00,0x00
0033b8  536e6170          DCB      0x53,0x6e,0x61,0x70
0033bc  73686f74          DCB      0x73,0x68,0x6f,0x74
0033c0  20524f49          DCB      0x20,0x52,0x4f,0x49
0033c4  2073697a          DCB      0x20,0x73,0x69,0x7a
0033c8  65202825          DCB      0x65,0x20,0x28,0x25
0033cc  64782564          DCB      0x64,0x78,0x25,0x64
0033d0  29207375          DCB      0x29,0x20,0x73,0x75
0033d4  6273616d          DCB      0x62,0x73,0x61,0x6d
0033d8  706c6564          DCB      0x70,0x6c,0x65,0x64
0033dc  20627920          DCB      0x20,0x62,0x79,0x20
0033e0  25642064          DCB      0x25,0x64,0x20,0x64
0033e4  6f65736e          DCB      0x6f,0x65,0x73,0x6e
0033e8  2774206d          DCB      0x27,0x74,0x20,0x6d
0033ec  61746368          DCB      0x61,0x74,0x63,0x68
0033f0  20736e61          DCB      0x20,0x73,0x6e,0x61
0033f4  7073686f          DCB      0x70,0x73,0x68,0x6f
0033f8  74206172          DCB      0x74,0x20,0x61,0x72
0033fc  72617920          DCB      0x72,0x61,0x79,0x20
003400  73697a65          DCB      0x73,0x69,0x7a,0x65
003404  20282564          DCB      0x20,0x28,0x25,0x64
003408  78256429          DCB      0x78,0x25,0x64,0x29
00340c  210a0000          DCB      0x21,0x0a,0x00,0x00
003410  56697369          DCB      0x56,0x69,0x73,0x69
003414  6f6e5379          DCB      0x6f,0x6e,0x53,0x79
003418  7374656d          DCB      0x73,0x74,0x65,0x6d
00341c  3a3a5461          DCB      0x3a,0x3a,0x54,0x61
003420  6b65536e          DCB      0x6b,0x65,0x53,0x6e
003424  61707368          DCB      0x61,0x70,0x73,0x68
003428  6f744865          DCB      0x6f,0x74,0x48,0x65
00342c  6c706572          DCB      0x6c,0x70,0x65,0x72
003430  28293a20          DCB      0x28,0x29,0x3a,0x20
003434  536e6170          DCB      0x53,0x6e,0x61,0x70
003438  73686f74          DCB      0x73,0x68,0x6f,0x74
00343c  20524f49          DCB      0x20,0x52,0x4f,0x49
003440  206f7574          DCB      0x20,0x6f,0x75,0x74
003444  206f6620          DCB      0x20,0x6f,0x66,0x20
003448  626f756e          DCB      0x62,0x6f,0x75,0x6e
00344c  6473210a          DCB      0x64,0x73,0x21,0x0a
003450  00000000          DCB      0x00,0x00,0x00,0x00
003454  46616365          DCB      0x46,0x61,0x63,0x65
003458  20646574          DCB      0x20,0x64,0x65,0x74
00345c  65637469          DCB      0x65,0x63,0x74,0x69
003460  6f6e2070          DCB      0x6f,0x6e,0x20,0x70
003464  6172616d          DCB      0x61,0x72,0x61,0x6d
003468  65746572          DCB      0x65,0x74,0x65,0x72
00346c  73206e6f          DCB      0x73,0x20,0x6e,0x6f
003470  7420696e          DCB      0x74,0x20,0x69,0x6e
003474  69746961          DCB      0x69,0x74,0x69,0x61
003478  6c697a65          DCB      0x6c,0x69,0x7a,0x65
00347c  64206265          DCB      0x64,0x20,0x62,0x65
003480  666f7265          DCB      0x66,0x6f,0x72,0x65
003484  20557064          DCB      0x20,0x55,0x70,0x64
003488  61746528          DCB      0x61,0x74,0x65,0x28
00348c  2920696e          DCB      0x29,0x20,0x69,0x6e
003490  20444554          DCB      0x20,0x44,0x45,0x54
003494  45435449          DCB      0x45,0x43,0x54,0x49
003498  4e475f46          DCB      0x4e,0x47,0x5f,0x46
00349c  41434553          DCB      0x41,0x43,0x45,0x53
0034a0  206d6f64          DCB      0x20,0x6d,0x6f,0x64
0034a4  652e0a00          DCB      0x65,0x2e,0x0a,0x00
0034a8  56697369          DCB      0x56,0x69,0x73,0x69
0034ac  6f6e5379          DCB      0x6f,0x6e,0x53,0x79
0034b0  7374656d          DCB      0x73,0x74,0x65,0x6d
0034b4  3a3a5570          DCB      0x3a,0x3a,0x55,0x70
0034b8  64617465          DCB      0x64,0x61,0x74,0x65
0034bc  28293a20          DCB      0x28,0x29,0x3a,0x20
0034c0  72656163          DCB      0x72,0x65,0x61,0x63
0034c4  68656420          DCB      0x68,0x65,0x64,0x20
0034c8  64656661          DCB      0x64,0x65,0x66,0x61
0034cc  756c7420          DCB      0x75,0x6c,0x74,0x20
0034d0  63617365          DCB      0x63,0x61,0x73,0x65
0034d4  20696e20          DCB      0x20,0x69,0x6e,0x20
0034d8  73776974          DCB      0x73,0x77,0x69,0x74
0034dc  63682073          DCB      0x63,0x68,0x20,0x73
0034e0  74617465          DCB      0x74,0x61,0x74,0x65
0034e4  6d656e74          DCB      0x6d,0x65,0x6e,0x74
0034e8  2e000000          DCB      0x2e,0x00,0x00,0x00
0034ec  4368616e          DCB      0x43,0x68,0x61,0x6e
0034f0  67656420          DCB      0x67,0x65,0x64,0x20
0034f4  56697369          DCB      0x56,0x69,0x73,0x69
0034f8  6f6e5379          DCB      0x6f,0x6e,0x53,0x79
0034fc  7374656d          DCB      0x73,0x74,0x65,0x6d
003500  20706172          DCB      0x20,0x70,0x61,0x72
003504  616d733a          DCB      0x61,0x6d,0x73,0x3a
003508  20696e74          DCB      0x20,0x69,0x6e,0x74
00350c  65676572          DCB      0x65,0x67,0x65,0x72
003510  436f756e          DCB      0x43,0x6f,0x75,0x6e
003514  7473496e          DCB      0x74,0x73,0x49,0x6e
003518  63202564          DCB      0x63,0x20,0x25,0x64
00351c  2c206d69          DCB      0x2c,0x20,0x6d,0x69
003520  6e457870          DCB      0x6e,0x45,0x78,0x70
003524  54696d65          DCB      0x54,0x69,0x6d,0x65
003528  2025662c          DCB      0x20,0x25,0x66,0x2c
00352c  206d6178          DCB      0x20,0x6d,0x61,0x78
003530  45787054          DCB      0x45,0x78,0x70,0x54
003534  696d6520          DCB      0x69,0x6d,0x65,0x20
003538  25662c20          DCB      0x25,0x66,0x2c,0x20
00353c  68696768          DCB      0x68,0x69,0x67,0x68
003540  56616c20          DCB      0x56,0x61,0x6c,0x20
003544  25642c20          DCB      0x25,0x64,0x2c,0x20
003548  70657263          DCB      0x70,0x65,0x72,0x63
00354c  546f4d61          DCB      0x54,0x6f,0x4d,0x61
003550  6b654869          DCB      0x6b,0x65,0x48,0x69
003554  67682025          DCB      0x67,0x68,0x20,0x25
003558  660a00            DCB      0x66,0x0a,0x00

                          AREA ||area_number.67||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.67||, ||.constdata||
                  _ZN4Anki5Cozmo19NECK_JOINT_POSITIONE ; Anki::Cozmo::NECK_JOINT_POSITION
000000  c1500000          DCFS     0xc1500000 ; -13
000004  00000000          DCFS     0x00000000 ; 0
000008  423ecccd          DCFS     0x423ecccd ; 47.700000762939453

                          AREA ||area_number.68||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.68||, ||.constdata||
                  _ZN4Anki5Cozmo17HEAD_CAM_POSITIONE ; Anki::Cozmo::HEAD_CAM_POSITION
000000  4099999a          DCFS     0x4099999a ; 4.8000001907348633
000004  00000000          DCFS     0x00000000 ; 0
000008  c0c00000          DCFS     0xc0c00000 ; -6

                          AREA ||.data||, DATA, ALIGN=2

                  isInitialized_
000000  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754720vignettingCorrectionE ; Anki::Cozmo::VisionSystem::<unnamed>::vignettingCorrection
000001  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754722autoExposure_highValueE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_highValue
000002  fa                DCB      0xfa
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754728newMarkerToTrackWasProvided_E ; Anki::Cozmo::VisionSystem::<unnamed>::newMarkerToTrackWasProvided_
000003  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754714imageSendMode_E ; Anki::Cozmo::VisionSystem::<unnamed>::imageSendMode_
000004  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754724nextSendImageResolution_E ; Anki::Cozmo::VisionSystem::<unnamed>::nextSendImageResolution_
000005  06                DCB      0x06
                  streamFrameCnt
000006  00                DCB      0x00
                  imgID
000007  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff75475mode_E ; Anki::Cozmo::VisionSystem::<unnamed>::mode_
000008  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754714wasCalledOnce_E ; Anki::Cozmo::VisionSystem::<unnamed>::wasCalledOnce_
000009  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754723havePreviousRobotState_E ; Anki::Cozmo::VisionSystem::<unnamed>::havePreviousRobotState_
00000a  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718captureResolution_E ; Anki::Cozmo::VisionSystem::<unnamed>::captureResolution_
00000b  00                DCB      0x00
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754720isWaitingOnSnapshot_E ; Anki::Cozmo::VisionSystem::<unnamed>::isWaitingOnSnapshot_
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754735autoExposure_integerCountsIncrementE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_integerCountsIncrement
                          DCD      0x00000003
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754728autoExposure_minExposureTimeE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_minExposureTime
000014  3ca3d70a          DCFS     0x3ca3d70a ; 0.019999999552965164
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754728autoExposure_maxExposureTimeE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_maxExposureTime
000018  3f000000          DCFS     0x3f000000 ; 0.5
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754733autoExposure_percentileToMakeHighE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_percentileToMakeHigh
00001c  3f733333          DCFS     0x3f733333 ; 0.94999998807907104
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754737autoExposure_tooHighPercentMultiplierE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_tooHighPercentMultiplier
000020  3f333333          DCFS     0x3f333333 ; 0.69999998807907104
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754731autoExposure_adjustEveryNFramesE ; Anki::Cozmo::VisionSystem::<unnamed>::autoExposure_adjustEveryNFrames
                          DCD      0x00000002
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712headCamInfo_E ; Anki::Cozmo::VisionSystem::<unnamed>::headCamInfo_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754715headCamFOV_ver_E ; Anki::Cozmo::VisionSystem::<unnamed>::headCamFOV_ver_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754715headCamFOV_hor_E ; Anki::Cozmo::VisionSystem::<unnamed>::headCamFOV_hor_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754712exposureTimeE ; Anki::Cozmo::VisionSystem::<unnamed>::exposureTime
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754711frameNumberE ; Anki::Cozmo::VisionSystem::<unnamed>::frameNumber
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754717numTrackFailures_E ; Anki::Cozmo::VisionSystem::<unnamed>::numTrackFailures_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754716isSnapshotReady_E ; Anki::Cozmo::VisionSystem::<unnamed>::isSnapshotReady_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff754718snapshotSubsample_E ; Anki::Cozmo::VisionSystem::<unnamed>::snapshotSubsample_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo12VisionSystem40_GLOBAL__N__16_visionSystem_cpp_b6ff75479snapshot_E ; Anki::Cozmo::VisionSystem::<unnamed>::snapshot_
                          DCD      0x00000000
                  _ZN4Anki5Cozmo21ROBOT_BOUNDING_RADIUSE ; Anki::Cozmo::ROBOT_BOUNDING_RADIUS
                          DCD      0x00000000

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___16_visionSystem_cpp

                          AREA ||CCM||, DATA, ALIGN=0

                  _ZN4Anki5Cozmo12VisionSystem12VisionMemory9ccmBufferE ; Anki::Cozmo::VisionSystem::VisionMemory::ccmBuffer
                          %        50000

                          AREA OFFCHIP, DATA, ALIGN=0

                  _ZN4Anki5Cozmo12VisionSystem12VisionMemory13offchipBufferE ; Anki::Cozmo::VisionSystem::VisionMemory::offchipBuffer
                          %        2000000

                          AREA ONCHIP, DATA, ALIGN=0

                  _ZN4Anki5Cozmo12VisionSystem12VisionMemory12onchipBufferE ; Anki::Cozmo::VisionSystem::VisionMemory::onchipBuffer
                          %        170000

                          AREA ||t._ZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferE PROC ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)
;;;794    
;;;795        template<typename Type> Result Array<Type>::InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;796        {
000004  b083              SUB      sp,sp,#0xc
;;;797          if(!rawData) {
;;;798            AnkiError("Anki.Array2d.initialize", "input data buffer is NULL");
000006  f8df90f8          LDR      r9,|L200.256|
00000a  f8dd8030          LDR      r8,[sp,#0x30]         ;796
00000e  001d              MOVS     r5,r3                 ;796
000010  4693              MOV      r11,r2                ;796
000012  460e              MOV      r6,r1                 ;796
000014  4604              MOV      r4,r0                 ;796
000016  f04f3aff          MOV      r10,#0xffffffff       ;796
00001a  d016              BEQ      |L200.74|
;;;799            InvalidateArray();
;;;800            return RESULT_FAIL_UNINITIALIZED_MEMORY;
;;;801          }
;;;802    
;;;803          AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0 && dataLength >= MEMORY_ALIGNMENT,
00001c  f1bb0f00          CMP      r11,#0
000020  bfa8              IT       GE
000022  2e00              CMPGE    r6,#0
000024  db02              BLT      |L200.44|
000026  f1b80f10          CMP      r8,#0x10
00002a  d224              BCS      |L200.118|
                  |L200.44|
00002c  f2403023          MOV      r0,#0x323
000030  e9cd9000          STRD     r9,r0,[sp,#0]
000034  a333              ADR      r3,|L200.260|
000036  a241              ADR      r2,|L200.316|
000038  a145              ADR      r1,|L200.336|
00003a  2005              MOVS     r0,#5
00003c  f7fffffe          BL       _Anki_Log
;;;804            RESULT_FAIL_INVALID_SIZE, "Array<Type>::InitializeBuffer", "Negative dimension");
;;;805    
;;;806          AnkiConditionalErrorAndReturnValue(!flags.get_useBoundaryFillPatterns(),
;;;807            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::InitializeBuffer", "Fill patterns not supported for Array");
;;;808    
;;;809          this->flags = flags;
;;;810          this->size[0] = numRows;
;;;811          this->size[1] = numCols;
;;;812    
;;;813          // Initialize an empty array.
;;;814    
;;;815          this->data = reinterpret_cast<Type*>(rawData);
;;;816    
;;;817          const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData), MEMORY_ALIGNMENT) - reinterpret_cast<size_t>(rawData));
;;;818          const s32 requiredBytes = ComputeRequiredStride(numCols,flags)*numRows + extraAlignmentBytes;
;;;819    
;;;820          if(requiredBytes > dataLength) {
;;;821            AnkiError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
;;;822            InvalidateArray();
;;;823            return RESULT_FAIL_OUT_OF_MEMORY;
;;;824          }
;;;825    
;;;826          this->data = reinterpret_cast<Type*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
;;;827    
;;;828          //#if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;829          //      this->UpdateCvMatMirror(*this);
;;;830          //#endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;831    
;;;832          return RESULT_OK;
;;;833        } // Array<Type>::InitializeBuffer()
000040  b003              ADD      sp,sp,#0xc
000042  f04f60a0          MOV      r0,#0x5000000         ;803
000046  e8bd8ff0          POP      {r4-r11,pc}
                  |L200.74|
00004a  f240301e          MOV      r0,#0x31e             ;798
00004e  e9cd9000          STRD     r9,r0,[sp,#0]         ;798
000052  a32c              ADR      r3,|L200.260|
000054  a246              ADR      r2,|L200.368|
000056  a14d              ADR      r1,|L200.396|
000058  2005              MOVS     r0,#5                 ;798
00005a  f7fffffe          BL       _Anki_Log
00005e  f8c4a000          STR      r10,[r4,#0]           ;798
000062  f8c4a004          STR      r10,[r4,#4]           ;798
000066  2000              MOVS     r0,#0                 ;798
000068  f8c4a008          STR      r10,[r4,#8]           ;800
00006c  6120              STR      r0,[r4,#0x10]         ;800
00006e  b003              ADD      sp,sp,#0xc
000070  484c              LDR      r0,|L200.420|
000072  e8bd8ff0          POP      {r4-r11,pc}
                  |L200.118|
000076  a80d              ADD      r0,sp,#0x34           ;806
000078  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
00007c  2800              CMP      r0,#0                 ;806
00007e  d00e              BEQ      |L200.158|
000080  f2403026          MOV      r0,#0x326             ;806
000084  e9cd9000          STRD     r9,r0,[sp,#0]         ;806
000088  a31e              ADR      r3,|L200.260|
00008a  a247              ADR      r2,|L200.424|
00008c  a130              ADR      r1,|L200.336|
00008e  2005              MOVS     r0,#5                 ;806
000090  f7fffffe          BL       _Anki_Log
000094  b003              ADD      sp,sp,#0xc
000096  f04f7040          MOV      r0,#0x3000000         ;806
00009a  e8bd8ff0          POP      {r4-r11,pc}
                  |L200.158|
00009e  980d              LDR      r0,[sp,#0x34]         ;809
0000a0  e9c40503          STRD     r0,r5,[r4,#0xc]       ;809
0000a4  f105000f          ADD      r0,r5,#0xf            ;809
0000a8  e9c46b00          STRD     r6,r11,[r4,#0]        ;817
0000ac  f020000f          BIC      r0,r0,#0xf            ;817
0000b0  1b47              SUBS     r7,r0,r5              ;817
0000b2  4658              MOV      r0,r11                ;818
0000b4  990d              LDR      r1,[sp,#0x34]         ;818
0000b6  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferE ; Anki::Embedded::Array<int>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)
0000ba  fb007006          MLA      r0,r0,r6,r7           ;818
0000be  4540              CMP      r0,r8                 ;820
0000c0  dd17              BLE      |L200.242|
0000c2  f2403135          MOV      r1,#0x335             ;821
0000c6  f8cd9000          STR      r9,[sp,#0]            ;821
0000ca  e9cd1001          STRD     r1,r0,[sp,#4]         ;821
0000ce  a30d              ADR      r3,|L200.260|
0000d0  a23f              ADR      r2,|L200.464|
0000d2  a12e              ADR      r1,|L200.396|
0000d4  2005              MOVS     r0,#5                 ;821
0000d6  f7fffffe          BL       _Anki_Log
0000da  f8c4a000          STR      r10,[r4,#0]           ;821
0000de  f8c4a004          STR      r10,[r4,#4]           ;821
0000e2  2000              MOVS     r0,#0                 ;821
0000e4  f8c4a008          STR      r10,[r4,#8]           ;823
0000e8  6120              STR      r0,[r4,#0x10]         ;823
0000ea  b003              ADD      sp,sp,#0xc
0000ec  4848              LDR      r0,|L200.528|
0000ee  e8bd8ff0          POP      {r4-r11,pc}
                  |L200.242|
0000f2  19e8              ADDS     r0,r5,r7              ;826
0000f4  6120              STR      r0,[r4,#0x10]         ;832
0000f6  b003              ADD      sp,sp,#0xc
0000f8  2000              MOVS     r0,#0                 ;832
0000fa  e8bd8ff0          POP      {r4-r11,pc}
;;;834    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L200.256|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L200.260|
000104  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000108  6f726574
00010c  6563685c
000110  636f6d6d
000114  6f6e5c69
000118  6e636c75
00011c  64655c61
000120  6e6b692f
000124  636f6d6d
000128  6f6e2f72
00012c  6f626f74
000130  2f617272
000134  617932  
000137  642e6800          DCB      "d.h",0
00013b  00                DCB      0
                  |L200.316|
00013c  4e656761          DCB      "Negative dimension",0
000140  74697665
000144  2064696d
000148  656e7369
00014c  6f6e00  
00014f  00                DCB      0
                  |L200.336|
000150  41727261          DCB      "Array<Type>::InitializeBuffer",0
000154  793c5479
000158  70653e3a
00015c  3a496e69
000160  7469616c
000164  697a6542
000168  75666665
00016c  7200    
00016e  00                DCB      0
00016f  00                DCB      0
                  |L200.368|
000170  696e7075          DCB      "input data buffer is NULL",0
000174  74206461
000178  74612062
00017c  75666665
000180  72206973
000184  204e554c
000188  4c00    
00018a  00                DCB      0
00018b  00                DCB      0
                  |L200.396|
00018c  416e6b69          DCB      "Anki.Array2d.initialize",0
000190  2e417272
000194  61793264
000198  2e696e69
00019c  7469616c
0001a0  697a6500
                  |L200.420|
                          DCD      0x01000002
                  |L200.424|
0001a8  46696c6c          DCB      "Fill patterns not supported for Array",0
0001ac  20706174
0001b0  7465726e
0001b4  73206e6f
0001b8  74207375
0001bc  70706f72
0001c0  74656420
0001c4  666f7220
0001c8  41727261
0001cc  7900    
0001ce  00                DCB      0
0001cf  00                DCB      0
                  |L200.464|
0001d0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0001d4  74206461
0001d8  74612062
0001dc  75666665
0001e0  72206973
0001e4  206e6f74
0001e8  206c6172
0001ec  67652065
0001f0  6e6f7567
0001f4  682e2025
0001f8  64206279
0001fc  74657320
000200  69732072
000204  657175  
000207  69726564          DCB      "ired.",0
00020b  2e00    
00020d  00                DCB      0
00020e  00                DCB      0
00020f  00                DCB      0
                  |L200.528|
                          DCD      0x01000001

                          AREA ||area_number.201||, COMGROUP=_ZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.201||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferE PROC ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)
;;;794    
;;;795        template<typename Type> Result Array<Type>::InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;796        {
000004  b083              SUB      sp,sp,#0xc
;;;797          if(!rawData) {
;;;798            AnkiError("Anki.Array2d.initialize", "input data buffer is NULL");
000006  f8df90f8          LDR      r9,|L207.256|
00000a  f8dd8030          LDR      r8,[sp,#0x30]         ;796
00000e  001d              MOVS     r5,r3                 ;796
000010  4693              MOV      r11,r2                ;796
000012  460e              MOV      r6,r1                 ;796
000014  4604              MOV      r4,r0                 ;796
000016  f04f3aff          MOV      r10,#0xffffffff       ;796
00001a  d016              BEQ      |L207.74|
;;;799            InvalidateArray();
;;;800            return RESULT_FAIL_UNINITIALIZED_MEMORY;
;;;801          }
;;;802    
;;;803          AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0 && dataLength >= MEMORY_ALIGNMENT,
00001c  f1bb0f00          CMP      r11,#0
000020  bfa8              IT       GE
000022  2e00              CMPGE    r6,#0
000024  db02              BLT      |L207.44|
000026  f1b80f10          CMP      r8,#0x10
00002a  d224              BCS      |L207.118|
                  |L207.44|
00002c  f2403023          MOV      r0,#0x323
000030  e9cd9000          STRD     r9,r0,[sp,#0]
000034  a333              ADR      r3,|L207.260|
000036  a241              ADR      r2,|L207.316|
000038  a145              ADR      r1,|L207.336|
00003a  2005              MOVS     r0,#5
00003c  f7fffffe          BL       _Anki_Log
;;;804            RESULT_FAIL_INVALID_SIZE, "Array<Type>::InitializeBuffer", "Negative dimension");
;;;805    
;;;806          AnkiConditionalErrorAndReturnValue(!flags.get_useBoundaryFillPatterns(),
;;;807            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::InitializeBuffer", "Fill patterns not supported for Array");
;;;808    
;;;809          this->flags = flags;
;;;810          this->size[0] = numRows;
;;;811          this->size[1] = numCols;
;;;812    
;;;813          // Initialize an empty array.
;;;814    
;;;815          this->data = reinterpret_cast<Type*>(rawData);
;;;816    
;;;817          const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData), MEMORY_ALIGNMENT) - reinterpret_cast<size_t>(rawData));
;;;818          const s32 requiredBytes = ComputeRequiredStride(numCols,flags)*numRows + extraAlignmentBytes;
;;;819    
;;;820          if(requiredBytes > dataLength) {
;;;821            AnkiError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
;;;822            InvalidateArray();
;;;823            return RESULT_FAIL_OUT_OF_MEMORY;
;;;824          }
;;;825    
;;;826          this->data = reinterpret_cast<Type*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
;;;827    
;;;828          //#if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;829          //      this->UpdateCvMatMirror(*this);
;;;830          //#endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;831    
;;;832          return RESULT_OK;
;;;833        } // Array<Type>::InitializeBuffer()
000040  b003              ADD      sp,sp,#0xc
000042  f04f60a0          MOV      r0,#0x5000000         ;803
000046  e8bd8ff0          POP      {r4-r11,pc}
                  |L207.74|
00004a  f240301e          MOV      r0,#0x31e             ;798
00004e  e9cd9000          STRD     r9,r0,[sp,#0]         ;798
000052  a32c              ADR      r3,|L207.260|
000054  a246              ADR      r2,|L207.368|
000056  a14d              ADR      r1,|L207.396|
000058  2005              MOVS     r0,#5                 ;798
00005a  f7fffffe          BL       _Anki_Log
00005e  f8c4a000          STR      r10,[r4,#0]           ;798
000062  f8c4a004          STR      r10,[r4,#4]           ;798
000066  2000              MOVS     r0,#0                 ;798
000068  f8c4a008          STR      r10,[r4,#8]           ;800
00006c  6120              STR      r0,[r4,#0x10]         ;800
00006e  b003              ADD      sp,sp,#0xc
000070  484c              LDR      r0,|L207.420|
000072  e8bd8ff0          POP      {r4-r11,pc}
                  |L207.118|
000076  a80d              ADD      r0,sp,#0x34           ;806
000078  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
00007c  2800              CMP      r0,#0                 ;806
00007e  d00e              BEQ      |L207.158|
000080  f2403026          MOV      r0,#0x326             ;806
000084  e9cd9000          STRD     r9,r0,[sp,#0]         ;806
000088  a31e              ADR      r3,|L207.260|
00008a  a247              ADR      r2,|L207.424|
00008c  a130              ADR      r1,|L207.336|
00008e  2005              MOVS     r0,#5                 ;806
000090  f7fffffe          BL       _Anki_Log
000094  b003              ADD      sp,sp,#0xc
000096  f04f7040          MOV      r0,#0x3000000         ;806
00009a  e8bd8ff0          POP      {r4-r11,pc}
                  |L207.158|
00009e  980d              LDR      r0,[sp,#0x34]         ;809
0000a0  e9c40503          STRD     r0,r5,[r4,#0xc]       ;809
0000a4  f105000f          ADD      r0,r5,#0xf            ;809
0000a8  e9c46b00          STRD     r6,r11,[r4,#0]        ;817
0000ac  f020000f          BIC      r0,r0,#0xf            ;817
0000b0  1b47              SUBS     r7,r0,r5              ;817
0000b2  4658              MOV      r0,r11                ;818
0000b4  990d              LDR      r1,[sp,#0x34]         ;818
0000b6  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferE ; Anki::Embedded::Array<float>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)
0000ba  fb007006          MLA      r0,r0,r6,r7           ;818
0000be  4540              CMP      r0,r8                 ;820
0000c0  dd17              BLE      |L207.242|
0000c2  f2403135          MOV      r1,#0x335             ;821
0000c6  f8cd9000          STR      r9,[sp,#0]            ;821
0000ca  e9cd1001          STRD     r1,r0,[sp,#4]         ;821
0000ce  a30d              ADR      r3,|L207.260|
0000d0  a23f              ADR      r2,|L207.464|
0000d2  a12e              ADR      r1,|L207.396|
0000d4  2005              MOVS     r0,#5                 ;821
0000d6  f7fffffe          BL       _Anki_Log
0000da  f8c4a000          STR      r10,[r4,#0]           ;821
0000de  f8c4a004          STR      r10,[r4,#4]           ;821
0000e2  2000              MOVS     r0,#0                 ;821
0000e4  f8c4a008          STR      r10,[r4,#8]           ;823
0000e8  6120              STR      r0,[r4,#0x10]         ;823
0000ea  b003              ADD      sp,sp,#0xc
0000ec  4848              LDR      r0,|L207.528|
0000ee  e8bd8ff0          POP      {r4-r11,pc}
                  |L207.242|
0000f2  19e8              ADDS     r0,r5,r7              ;826
0000f4  6120              STR      r0,[r4,#0x10]         ;832
0000f6  b003              ADD      sp,sp,#0xc
0000f8  2000              MOVS     r0,#0                 ;832
0000fa  e8bd8ff0          POP      {r4-r11,pc}
;;;834    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L207.256|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L207.260|
000104  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000108  6f726574
00010c  6563685c
000110  636f6d6d
000114  6f6e5c69
000118  6e636c75
00011c  64655c61
000120  6e6b692f
000124  636f6d6d
000128  6f6e2f72
00012c  6f626f74
000130  2f617272
000134  617932  
000137  642e6800          DCB      "d.h",0
00013b  00                DCB      0
                  |L207.316|
00013c  4e656761          DCB      "Negative dimension",0
000140  74697665
000144  2064696d
000148  656e7369
00014c  6f6e00  
00014f  00                DCB      0
                  |L207.336|
000150  41727261          DCB      "Array<Type>::InitializeBuffer",0
000154  793c5479
000158  70653e3a
00015c  3a496e69
000160  7469616c
000164  697a6542
000168  75666665
00016c  7200    
00016e  00                DCB      0
00016f  00                DCB      0
                  |L207.368|
000170  696e7075          DCB      "input data buffer is NULL",0
000174  74206461
000178  74612062
00017c  75666665
000180  72206973
000184  204e554c
000188  4c00    
00018a  00                DCB      0
00018b  00                DCB      0
                  |L207.396|
00018c  416e6b69          DCB      "Anki.Array2d.initialize",0
000190  2e417272
000194  61793264
000198  2e696e69
00019c  7469616c
0001a0  697a6500
                  |L207.420|
                          DCD      0x01000002
                  |L207.424|
0001a8  46696c6c          DCB      "Fill patterns not supported for Array",0
0001ac  20706174
0001b0  7465726e
0001b4  73206e6f
0001b8  74207375
0001bc  70706f72
0001c0  74656420
0001c4  666f7220
0001c8  41727261
0001cc  7900    
0001ce  00                DCB      0
0001cf  00                DCB      0
                  |L207.464|
0001d0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0001d4  74206461
0001d8  74612062
0001dc  75666665
0001e0  72206973
0001e4  206e6f74
0001e8  206c6172
0001ec  67652065
0001f0  6e6f7567
0001f4  682e2025
0001f8  64206279
0001fc  74657320
000200  69732072
000204  657175  
000207  69726564          DCB      "ired.",0
00020b  2e00    
00020d  00                DCB      0
00020e  00                DCB      0
00020f  00                DCB      0
                  |L207.528|
                          DCD      0x01000001

                          AREA ||area_number.208||, COMGROUP=_ZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.208||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<float>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4699              MOV      r9,r3
000008  4690              MOV      r8,r2
00000a  468b              MOV      r11,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  9e0e              LDR      r6,[sp,#0x38]
000010  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000014  f1a0040c          SUB      r4,r0,#0xc
000018  f04f30ff          MOV      r0,#0xffffffff
00001c  6020              STR      r0,[r4,#0]
00001e  6060              STR      r0,[r4,#4]
000020  60a0              STR      r0,[r4,#8]
000022  2000              MOVS     r0,#0
000024  6120              STR      r0,[r4,#0x10]
000026  f1b80f00          CMP      r8,#0
00002a  bfa8              IT       GE
00002c  f1bb0f00          CMPGE    r11,#0
000030  da0a              BGE      |L214.72|
000032  217d              MOVS     r1,#0x7d
000034  481d              LDR      r0,|L214.172|
000036  e9cd0100          STRD     r0,r1,[sp,#0]
00003a  a31d              ADR      r3,|L214.176|
00003c  a22a              ADR      r2,|L214.232|
00003e  a12e              ADR      r1,|L214.248|
000040  2005              MOVS     r0,#5
000042  f7fffffe          BL       _Anki_Log
000046  e02c              B        |L214.162|
                  |L214.72|
000048  9002              STR      r0,[sp,#8]
00004a  465d              MOV      r5,r11
00004c  4631              MOV      r1,r6
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferE ; Anki::Embedded::Array<float>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)
000054  1e07              SUBS     r7,r0,#0
000056  f10d0a08          ADD      r10,sp,#8
00005a  9603              STR      r6,[sp,#0xc]
00005c  dc0a              BGT      |L214.116|
00005e  f240310b          MOV      r1,#0x30b
000062  482a              LDR      r0,|L214.268|
000064  e9cd0100          STRD     r0,r1,[sp,#0]
000068  a311              ADR      r3,|L214.176|
00006a  a21f              ADR      r2,|L214.232|
00006c  a128              ADR      r1,|L214.272|
00006e  2005              MOVS     r0,#5
000070  f7fffffe          BL       _Anki_Log
                  |L214.116|
000074  2d01              CMP      r5,#1
000076  bfd8              IT       LE
000078  2501              MOVLE    r5,#1
00007a  437d              MULS     r5,r7,r5
00007c  a803              ADD      r0,sp,#0xc
00007e  60a7              STR      r7,[r4,#8]
000080  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
000084  4602              MOV      r2,r0
000086  4653              MOV      r3,r10
000088  4629              MOV      r1,r5
00008a  4648              MOV      r0,r9
00008c  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
000090  9902              LDR      r1,[sp,#8]
000092  4603              MOV      r3,r0
000094  9100              STR      r1,[sp,#0]
000096  9601              STR      r6,[sp,#4]
000098  4642              MOV      r2,r8
00009a  4659              MOV      r1,r11
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferE ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)
                  |L214.162|
0000a2  b005              ADD      sp,sp,#0x14
0000a4  4620              MOV      r0,r4
0000a6  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

0000aa  0000              DCW      0x0000
                  |L214.172|
                          DCD      _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L214.176|
0000b0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
0000b4  6f726574
0000b8  6563685c
0000bc  636f6d6d
0000c0  6f6e5c69
0000c4  6e636c75
0000c8  64655c61
0000cc  6e6b692f
0000d0  636f6d6d
0000d4  6f6e2f72
0000d8  6f626f74
0000dc  2f617272
0000e0  617932  
0000e3  642e6800          DCB      "d.h",0
0000e7  00                DCB      0
                  |L214.232|
0000e8  496e7661          DCB      "Invalid size",0
0000ec  6c696420
0000f0  73697a65
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L214.248|
0000f8  41727261          DCB      "Array<Type>::Array",0
0000fc  793c5479
000100  70653e3a
000104  3a417272
000108  617900  
00010b  00                DCB      0
                  |L214.268|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L214.272|
000110  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
000114  793c5479
000118  70653e3a
00011c  3a416c6c
000120  6f636174
000124  65427566
000128  66657246
00012c  726f6d4d
000130  656d6f72
000134  79537461
000138  636b00  
00013b  00                DCB      0

                          AREA ||area_number.215||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.215||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||, COMGROUP=_ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii PROC ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)
;;;1622   
;;;1623         template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1624         {
000004  b083              SUB      sp,sp,#0xc
000006  460c              MOV      r4,r1
000008  e9dd670c          LDRD     r6,r7,[sp,#0x30]
00000c  469a              MOV      r10,r3
00000e  4693              MOV      r11,r2
000010  4680              MOV      r8,r0
;;;1625           const s32 arrHeight = arr.get_size(0);
000012  2100              MOVS     r1,#0
000014  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000018  4681              MOV      r9,r0
;;;1626           const s32 arrWidth = arr.get_size(1);
00001a  2101              MOVS     r1,#1
00001c  4640              MOV      r0,r8
00001e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000022  4605              MOV      r5,r0
000024  f8d80010          LDR      r0,[r8,#0x10]
000028  2800              CMP      r0,#0
00002a  d026              BEQ      |L221.122|
00002c  f8d80000          LDR      r0,[r8,#0]
000030  2800              CMP      r0,#0
000032  bfa4              ITT      GE
000034  f8d80004          LDRGE    r0,[r8,#4]
000038  2800              CMPGE    r0,#0
00003a  db1e              BLT      |L221.122|
00003c  6920              LDR      r0,[r4,#0x10]
00003e  2800              CMP      r0,#0
000040  d01b              BEQ      |L221.122|
000042  6820              LDR      r0,[r4,#0]
000044  2800              CMP      r0,#0
000046  bfa4              ITT      GE
000048  6860              LDRGE    r0,[r4,#4]
00004a  2800              CMPGE    r0,#0
00004c  db15              BLT      |L221.122|
;;;1627   
;;;1628           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1629             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1630   
;;;1631           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
00004e  f1bb0f00          CMP      r11,#0
000052  bf18              IT       NE
000054  f1bb0f01          CMPNE    r11,#1
000058  d01f              BEQ      |L221.154|
00005a  f240615f          MOV      r1,#0x65f
00005e  48e7              LDR      r0,|L221.1020|
000060  e9cd0100          STRD     r0,r1,[sp,#0]
000064  a3e6              ADR      r3,|L221.1024|
000066  a2f4              ADR      r2,|L221.1080|
000068  a1fd              ADR      r1,|L221.1120|
00006a  2005              MOVS     r0,#5
00006c  f7fffffe          BL       _Anki_Log
;;;1632             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1633   
;;;1634           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1635             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1636   
;;;1637           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1638           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1639   
;;;1640           if(sortWhichDimension == 0) {
;;;1641             for(s32 y=0; y<arrHeight; y++) {
;;;1642               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1643               for(s32 x=0; x<arrWidth; x++) {
;;;1644                 pIndexes[x] = y;
;;;1645               }
;;;1646             }
;;;1647   
;;;1648             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1649             if(sortAscending) {
;;;1650               InsertionSort_sortAscendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1651             } else { // if(sortAscending)
;;;1652               InsertionSort_sortDescendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1653             } // if(sortAscending) ... else
;;;1654           } else { // sortWhichDimension == 1
;;;1655             for(s32 y=0; y<arrHeight; y++) {
;;;1656               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1657               for(s32 x=0; x<arrWidth; x++) {
;;;1658                 pIndexes[x] = x;
;;;1659               }
;;;1660             }
;;;1661   
;;;1662             if(sortAscending) {
;;;1663               InsertionSort_sortAscendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1664             } else { // if(sortAscending)
;;;1665               InsertionSort_sortDescendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1666             } // if(sortAscending) ... else
;;;1667           } // if(sortWhichDimension == 0) ... else
;;;1668   
;;;1669           return RESULT_OK;
;;;1670         } // InsertionSort()
000070  b003              ADD      sp,sp,#0xc
000072  f04f7040          MOV      r0,#0x3000000         ;1631
000076  e8bd8ff0          POP      {r4-r11,pc}
                  |L221.122|
00007a  f240615c          MOV      r1,#0x65c             ;1628
00007e  48df              LDR      r0,|L221.1020|
000080  e9cd0100          STRD     r0,r1,[sp,#0]         ;1628
000084  a3de              ADR      r3,|L221.1024|
000086  a2f8              ADR      r2,|L221.1128|
000088  a1f5              ADR      r1,|L221.1120|
00008a  2005              MOVS     r0,#5                 ;1628
00008c  f7fffffe          BL       _Anki_Log
000090  b003              ADD      sp,sp,#0xc
000092  f04f6080          MOV      r0,#0x4000000         ;1628
000096  e8bd8ff0          POP      {r4-r11,pc}
                  |L221.154|
00009a  2100              MOVS     r1,#0
00009c  4640              MOV      r0,r8
00009e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000a2  4601              MOV      r1,r0
0000a4  6820              LDR      r0,[r4,#0]
0000a6  4281              CMP      r1,r0
0000a8  d107              BNE      |L221.186|
0000aa  2101              MOVS     r1,#1
0000ac  4640              MOV      r0,r8
0000ae  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000b2  4601              MOV      r1,r0
0000b4  6860              LDR      r0,[r4,#4]
0000b6  4281              CMP      r1,r0
0000b8  d00f              BEQ      |L221.218|
                  |L221.186|
0000ba  f2406162          MOV      r1,#0x662             ;1634
0000be  48cf              LDR      r0,|L221.1020|
0000c0  e9cd0100          STRD     r0,r1,[sp,#0]         ;1634
0000c4  a3ce              ADR      r3,|L221.1024|
0000c6  a2ed              ADR      r2,|L221.1148|
0000c8  a1e5              ADR      r1,|L221.1120|
0000ca  2005              MOVS     r0,#5                 ;1634
0000cc  f7fffffe          BL       _Anki_Log
0000d0  b003              ADD      sp,sp,#0xc
0000d2  f04f60a0          MOV      r0,#0x5000000         ;1634
0000d6  e8bd8ff0          POP      {r4-r11,pc}
                  |L221.218|
0000da  4659              MOV      r1,r11                ;1637
0000dc  4640              MOV      r0,r8                 ;1637
0000de  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000e2  1e41              SUBS     r1,r0,#1              ;1637
0000e4  2e00              CMP      r6,#0                 ;1637
0000e6  bfcc              ITE      GT                    ;1637
0000e8  4630              MOVGT    r0,r6                 ;1637
0000ea  2000              MOVLE    r0,#0                 ;1637
0000ec  4281              CMP      r1,r0                 ;1637
0000ee  dd03              BLE      |L221.248|
0000f0  2e00              CMP      r6,#0                 ;1637
0000f2  bfd8              IT       LE                    ;1637
0000f4  2600              MOVLE    r6,#0                 ;1637
0000f6  e004              B        |L221.258|
                  |L221.248|
0000f8  4659              MOV      r1,r11                ;1637
0000fa  4640              MOV      r0,r8                 ;1637
0000fc  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000100  1e46              SUBS     r6,r0,#1              ;1637
                  |L221.258|
000102  4659              MOV      r1,r11                ;1638
000104  4640              MOV      r0,r8                 ;1638
000106  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00010a  1e41              SUBS     r1,r0,#1              ;1638
00010c  2f00              CMP      r7,#0                 ;1638
00010e  bfcc              ITE      GT                    ;1638
000110  4638              MOVGT    r0,r7                 ;1638
000112  2000              MOVLE    r0,#0                 ;1638
000114  4281              CMP      r1,r0                 ;1638
000116  dd03              BLE      |L221.288|
000118  2f00              CMP      r7,#0                 ;1638
00011a  bfd8              IT       LE                    ;1638
00011c  2700              MOVLE    r7,#0                 ;1638
00011e  e004              B        |L221.298|
                  |L221.288|
000120  4659              MOV      r1,r11                ;1638
000122  4640              MOV      r0,r8                 ;1638
000124  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000128  1e47              SUBS     r7,r0,#1              ;1638
                  |L221.298|
00012a  ea5f000b          MOVS     r0,r11                ;1640
00012e  f04f0b00          MOV      r11,#0                ;1640
000132  4659              MOV      r1,r11                ;1655
000134  d037              BEQ      |L221.422|
000136  f1b90f00          CMP      r9,#0                 ;1655
00013a  dd0e              BLE      |L221.346|
                  |L221.316|
00013c  68a2              LDR      r2,[r4,#8]            ;1655
00013e  6920              LDR      r0,[r4,#0x10]         ;1655
000140  fb010202          MLA      r2,r1,r2,r0           ;1655
000144  2000              MOVS     r0,#0                 ;1657
000146  2d00              CMP      r5,#0                 ;1657
000148  dd04              BLE      |L221.340|
                  |L221.330|
00014a  f8420020          STR      r0,[r2,r0,LSL #2]     ;1658
00014e  1c40              ADDS     r0,r0,#1              ;1657
000150  4285              CMP      r5,r0                 ;1657
000152  dcfa              BGT      |L221.330|
                  |L221.340|
000154  1c49              ADDS     r1,r1,#1              ;1655
000156  4549              CMP      r1,r9                 ;1655
000158  dbf0              BLT      |L221.316|
                  |L221.346|
00015a  f1ba0f00          CMP      r10,#0                ;1662
00015e  f04f0100          MOV      r1,#0                 ;1662
000162  4640              MOV      r0,r8                 ;1662
000164  f0008116          BEQ.W    |L221.916|
000168  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00016c  f1b00a00          SUBS     r10,r0,#0             ;1662
000170  f04f0500          MOV      r5,#0                 ;1662
000174  f34081a4          BLE.W    |L221.1216|
                  |L221.376|
000178  f8d81008          LDR      r1,[r8,#8]            ;1662
00017c  f8d80010          LDR      r0,[r8,#0x10]         ;1662
000180  1c72              ADDS     r2,r6,#1              ;1662
000182  fb050c01          MLA      r12,r5,r1,r0          ;1662
000186  68a1              LDR      r1,[r4,#8]            ;1662
000188  6920              LDR      r0,[r4,#0x10]         ;1662
00018a  42ba              CMP      r2,r7                 ;1662
00018c  fb050301          MLA      r3,r5,r1,r0           ;1662
000190  f8c3b000          STR      r11,[r3,#0]           ;1662
000194  dc79              BGT      |L221.650|
                  |L221.406|
000196  eb0c0082          ADD      r0,r12,r2,LSL #2      ;1662
00019a  f8539022          LDR      r9,[r3,r2,LSL #2]     ;1662
00019e  edd00a00          VLDR     s1,[r0,#0]            ;1662
0001a2  4611              MOV      r1,r2                 ;1662
0001a4  e0dc              B        |L221.864|
                  |L221.422|
0001a6  f1b90f00          CMP      r9,#0                 ;1641
0001aa  dd0e              BLE      |L221.458|
                  |L221.428|
0001ac  68a2              LDR      r2,[r4,#8]            ;1641
0001ae  6920              LDR      r0,[r4,#0x10]         ;1641
0001b0  fb010202          MLA      r2,r1,r2,r0           ;1641
0001b4  2000              MOVS     r0,#0                 ;1643
0001b6  2d00              CMP      r5,#0                 ;1643
0001b8  dd04              BLE      |L221.452|
                  |L221.442|
0001ba  f8421020          STR      r1,[r2,r0,LSL #2]     ;1644
0001be  1c40              ADDS     r0,r0,#1              ;1643
0001c0  4285              CMP      r5,r0                 ;1643
0001c2  dcfa              BGT      |L221.442|
                  |L221.452|
0001c4  1c49              ADDS     r1,r1,#1              ;1641
0001c6  4549              CMP      r1,r9                 ;1641
0001c8  dbf0              BLT      |L221.428|
                  |L221.458|
0001ca  f1ba0f00          CMP      r10,#0                ;1649
0001ce  d05d              BEQ      |L221.652|
0001d0  2101              MOVS     r1,#1                 ;1649
0001d2  4640              MOV      r0,r8                 ;1649
0001d4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0001d8  f1b00900          SUBS     r9,r0,#0              ;1649
0001dc  f04f0200          MOV      r2,#0                 ;1649
0001e0  dd52              BLE      |L221.648|
                  |L221.482|
0001e2  1c70              ADDS     r0,r6,#1              ;1649
0001e4  42b8              CMP      r0,r7                 ;1649
0001e6  dc4c              BGT      |L221.642|
                  |L221.488|
0001e8  f8d83008          LDR      r3,[r8,#8]            ;1649
0001ec  f8d81010          LDR      r1,[r8,#0x10]         ;1649
0001f0  fb001103          MLA      r1,r0,r3,r1           ;1649
0001f4  eb010182          ADD      r1,r1,r2,LSL #2       ;1649
0001f8  68a3              LDR      r3,[r4,#8]            ;1649
0001fa  edd10a00          VLDR     s1,[r1,#0]            ;1649
0001fe  6921              LDR      r1,[r4,#0x10]         ;1649
000200  fb001103          MLA      r1,r0,r3,r1           ;1649
000204  f8515022          LDR      r5,[r1,r2,LSL #2]     ;1649
000208  4601              MOV      r1,r0                 ;1649
00020a  e013              B        |L221.564|
                  |L221.524|
00020c  fb01330c          MLA      r3,r1,r12,r3          ;1649
000210  eb030382          ADD      r3,r3,r2,LSL #2       ;1649
000214  f1a10a01          SUB      r10,r1,#1             ;1649
000218  ed830a00          VSTR     s0,[r3,#0]            ;1649
00021c  f8d4c008          LDR      r12,[r4,#8]           ;1649
000220  6923              LDR      r3,[r4,#0x10]         ;1649
000222  fb0a3a0c          MLA      r10,r10,r12,r3        ;1649
000226  fb01330c          MLA      r3,r1,r12,r3          ;1649
00022a  f85aa022          LDR      r10,[r10,r2,LSL #2]   ;1649
00022e  f843a022          STR      r10,[r3,r2,LSL #2]    ;1649
000232  1e49              SUBS     r1,r1,#1              ;1649
                  |L221.564|
000234  42b1              CMP      r1,r6                 ;1649
000236  dd10              BLE      |L221.602|
000238  f8d8c008          LDR      r12,[r8,#8]           ;1649
00023c  f8d83010          LDR      r3,[r8,#0x10]         ;1649
000240  f1a10a01          SUB      r10,r1,#1             ;1649
000244  fb0a3a0c          MLA      r10,r10,r12,r3        ;1649
000248  eb0a0a82          ADD      r10,r10,r2,LSL #2     ;1649
00024c  ed9a0a00          VLDR     s0,[r10,#0]           ;1649
000250  eeb40ae0          VCMPE.F32 s0,s1                 ;1649
000254  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1649
000258  dcd8              BGT      |L221.524|
                  |L221.602|
00025a  f8d8c008          LDR      r12,[r8,#8]           ;1649
00025e  f8d83010          LDR      r3,[r8,#0x10]         ;1649
000262  1c40              ADDS     r0,r0,#1              ;1649
000264  fb01330c          MLA      r3,r1,r12,r3          ;1649
000268  eb030382          ADD      r3,r3,r2,LSL #2       ;1649
00026c  42b8              CMP      r0,r7                 ;1649
00026e  edc30a00          VSTR     s1,[r3,#0]            ;1649
000272  f8d4c008          LDR      r12,[r4,#8]           ;1649
000276  6923              LDR      r3,[r4,#0x10]         ;1649
000278  fb01310c          MLA      r1,r1,r12,r3          ;1649
00027c  f8415022          STR      r5,[r1,r2,LSL #2]     ;1649
000280  ddb2              BLE      |L221.488|
                  |L221.642|
000282  1c52              ADDS     r2,r2,#1              ;1649
000284  454a              CMP      r2,r9                 ;1649
000286  dbac              BLT      |L221.482|
                  |L221.648|
000288  e11a              B        |L221.1216|
                  |L221.650|
00028a  e07e              B        |L221.906|
                  |L221.652|
00028c  4645              MOV      r5,r8                 ;1652
00028e  2101              MOVS     r1,#1                 ;1652
000290  4640              MOV      r0,r8                 ;1652
000292  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000296  f1b00a00          SUBS     r10,r0,#0             ;1652
00029a  f04f0200          MOV      r2,#0                 ;1652
00029e  dd55              BLE      |L221.844|
                  |L221.672|
0002a0  68a3              LDR      r3,[r4,#8]            ;1652
0002a2  6921              LDR      r1,[r4,#0x10]         ;1652
0002a4  2000              MOVS     r0,#0                 ;1652
0002a6  fb001003          MLA      r0,r0,r3,r1           ;1652
0002aa  f840b022          STR      r11,[r0,r2,LSL #2]    ;1652
0002ae  1c70              ADDS     r0,r6,#1              ;1652
0002b0  42b8              CMP      r0,r7                 ;1652
0002b2  dc48              BGT      |L221.838|
                  |L221.692|
0002b4  68ab              LDR      r3,[r5,#8]            ;1652
0002b6  6929              LDR      r1,[r5,#0x10]         ;1652
0002b8  fb001103          MLA      r1,r0,r3,r1           ;1652
0002bc  eb010182          ADD      r1,r1,r2,LSL #2       ;1652
0002c0  68a3              LDR      r3,[r4,#8]            ;1652
0002c2  edd10a00          VLDR     s1,[r1,#0]            ;1652
0002c6  6921              LDR      r1,[r4,#0x10]         ;1652
0002c8  fb001103          MLA      r1,r0,r3,r1           ;1652
0002cc  f8519022          LDR      r9,[r1,r2,LSL #2]     ;1652
0002d0  4601              MOV      r1,r0                 ;1652
0002d2  e013              B        |L221.764|
                  |L221.724|
0002d4  fb01330c          MLA      r3,r1,r12,r3          ;1652
0002d8  eb030382          ADD      r3,r3,r2,LSL #2       ;1652
0002dc  f1a10801          SUB      r8,r1,#1              ;1652
0002e0  ed830a00          VSTR     s0,[r3,#0]            ;1652
0002e4  f8d4c008          LDR      r12,[r4,#8]           ;1652
0002e8  6923              LDR      r3,[r4,#0x10]         ;1652
0002ea  fb08380c          MLA      r8,r8,r12,r3          ;1652
0002ee  fb01330c          MLA      r3,r1,r12,r3          ;1652
0002f2  f8588022          LDR      r8,[r8,r2,LSL #2]     ;1652
0002f6  f8438022          STR      r8,[r3,r2,LSL #2]     ;1652
0002fa  1e49              SUBS     r1,r1,#1              ;1652
                  |L221.764|
0002fc  42b1              CMP      r1,r6                 ;1652
0002fe  dd0f              BLE      |L221.800|
000300  f8d5c008          LDR      r12,[r5,#8]           ;1652
000304  692b              LDR      r3,[r5,#0x10]         ;1652
000306  f1a10801          SUB      r8,r1,#1              ;1652
00030a  fb08380c          MLA      r8,r8,r12,r3          ;1652
00030e  eb080882          ADD      r8,r8,r2,LSL #2       ;1652
000312  ed980a00          VLDR     s0,[r8,#0]            ;1652
000316  eeb40ae0          VCMPE.F32 s0,s1                 ;1652
00031a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1652
00031e  d3d9              BCC      |L221.724|
                  |L221.800|
000320  f8d5c008          LDR      r12,[r5,#8]           ;1652
000324  692b              LDR      r3,[r5,#0x10]         ;1652
000326  1c40              ADDS     r0,r0,#1              ;1652
000328  fb01330c          MLA      r3,r1,r12,r3          ;1652
00032c  eb030382          ADD      r3,r3,r2,LSL #2       ;1652
000330  42b8              CMP      r0,r7                 ;1652
000332  edc30a00          VSTR     s1,[r3,#0]            ;1652
000336  f8d4c008          LDR      r12,[r4,#8]           ;1652
00033a  6923              LDR      r3,[r4,#0x10]         ;1652
00033c  fb01310c          MLA      r1,r1,r12,r3          ;1652
000340  f8419022          STR      r9,[r1,r2,LSL #2]     ;1652
000344  ddb6              BLE      |L221.692|
                  |L221.838|
000346  1c52              ADDS     r2,r2,#1              ;1652
000348  4552              CMP      r2,r10                ;1652
00034a  dba9              BLT      |L221.672|
                  |L221.844|
00034c  e0b8              B        |L221.1216|
                  |L221.846|
00034e  ed800a00          VSTR     s0,[r0,#0]            ;1652
000352  eb030081          ADD      r0,r3,r1,LSL #2       ;1652
000356  f8500c04          LDR      r0,[r0,#-4]           ;1652
00035a  f8430021          STR      r0,[r3,r1,LSL #2]     ;1652
00035e  1e49              SUBS     r1,r1,#1              ;1652
                  |L221.864|
000360  42b1              CMP      r1,r6                 ;1652
000362  dd08              BLE      |L221.886|
000364  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1652
000368  ed100a01          VLDR     s0,[r0,#-4]           ;1652
00036c  eeb40ae0          VCMPE.F32 s0,s1                 ;1652
000370  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1652
000374  dceb              BGT      |L221.846|
                  |L221.886|
000376  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1652
00037a  1c52              ADDS     r2,r2,#1              ;1652
00037c  edc00a00          VSTR     s1,[r0,#0]            ;1652
000380  f8439021          STR      r9,[r3,r1,LSL #2]     ;1652
000384  42ba              CMP      r2,r7                 ;1652
000386  f77faf06          BLE      |L221.406|
                  |L221.906|
00038a  1c6d              ADDS     r5,r5,#1              ;1652
00038c  4555              CMP      r5,r10                ;1652
00038e  f6ffaef3          BLT      |L221.376|
000392  e095              B        |L221.1216|
                  |L221.916|
000394  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000398  f1b00a00          SUBS     r10,r0,#0             ;1652
00039c  f04f0500          MOV      r5,#0                 ;1652
0003a0  dd2b              BLE      |L221.1018|
                  |L221.930|
0003a2  f8d81008          LDR      r1,[r8,#8]            ;1652
0003a6  f8d80010          LDR      r0,[r8,#0x10]         ;1652
0003aa  1c72              ADDS     r2,r6,#1              ;1652
0003ac  fb050c01          MLA      r12,r5,r1,r0          ;1652
0003b0  68a1              LDR      r1,[r4,#8]            ;1652
0003b2  6920              LDR      r0,[r4,#0x10]         ;1652
0003b4  42ba              CMP      r2,r7                 ;1652
0003b6  fb050301          MLA      r3,r5,r1,r0           ;1652
0003ba  f8c3b000          STR      r11,[r3,#0]           ;1652
0003be  dc7b              BGT      |L221.1208|
                  |L221.960|
0003c0  eb0c0082          ADD      r0,r12,r2,LSL #2      ;1652
0003c4  f8539022          LDR      r9,[r3,r2,LSL #2]     ;1652
0003c8  edd00a00          VLDR     s1,[r0,#0]            ;1652
0003cc  4611              MOV      r1,r2                 ;1652
0003ce  e008              B        |L221.994|
                  |L221.976|
0003d0  ed800a00          VSTR     s0,[r0,#0]            ;1652
0003d4  eb030081          ADD      r0,r3,r1,LSL #2       ;1652
0003d8  f8500c04          LDR      r0,[r0,#-4]           ;1652
0003dc  f8430021          STR      r0,[r3,r1,LSL #2]     ;1652
0003e0  1e49              SUBS     r1,r1,#1              ;1652
                  |L221.994|
0003e2  42b1              CMP      r1,r6                 ;1652
0003e4  dd08              BLE      |L221.1016|
0003e6  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1652
0003ea  ed100a01          VLDR     s0,[r0,#-4]           ;1652
0003ee  eeb40ae0          VCMPE.F32 s0,s1                 ;1652
0003f2  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;1652
0003f6  d3eb              BCC      |L221.976|
                  |L221.1016|
0003f8  e055              B        |L221.1190|
                  |L221.1018|
0003fa  e061              B        |L221.1216|
                  |L221.1020|
                          DCD      _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::__PRETTY_FUNCTION__
                  |L221.1024|
000400  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000404  6f726574
000408  6563685c
00040c  636f6d6d
000410  6f6e5c69
000414  6e636c75
000418  64655c61
00041c  6e6b692f
000420  636f6d6d
000424  6f6e2f72
000428  6f626f74
00042c  2f6d6174
000430  726978  
000433  2e6800            DCB      ".h",0
000436  00                DCB      0
000437  00                DCB      0
                  |L221.1080|
000438  736f7274          DCB      "sortWhichDimension must be zero or one",0
00043c  57686963
000440  6844696d
000444  656e7369
000448  6f6e206d
00044c  75737420
000450  6265207a
000454  65726f20
000458  6f72206f
00045c  6e6500  
00045f  00                DCB      0
                  |L221.1120|
000460  536f7274          DCB      "Sort",0
000464  00      
000465  00                DCB      0
000466  00                DCB      0
000467  00                DCB      0
                  |L221.1128|
000468  4f626a65          DCB      "Objects are invalid",0
00046c  63747320
000470  61726520
000474  696e7661
000478  6c696400
                  |L221.1148|
00047c  696e6465          DCB      "indexes must be the same size as arr",0
000480  78657320
000484  6d757374
000488  20626520
00048c  74686520
000490  73616d65
000494  2073697a
000498  65206173
00049c  20617272
0004a0  00      
0004a1  00                DCB      0
0004a2  00                DCB      0
0004a3  00                DCB      0
0004a4  e008              B        |L221.1208|
                  |L221.1190|
0004a6  eb0c0081          ADD      r0,r12,r1,LSL #2      ;1652
0004aa  1c52              ADDS     r2,r2,#1              ;1652
0004ac  edc00a00          VSTR     s1,[r0,#0]            ;1652
0004b0  f8439021          STR      r9,[r3,r1,LSL #2]     ;1652
0004b4  42ba              CMP      r2,r7                 ;1652
0004b6  dd83              BLE      |L221.960|
                  |L221.1208|
0004b8  1c6d              ADDS     r5,r5,#1              ;1652
0004ba  4555              CMP      r5,r10                ;1652
0004bc  f6ffaf71          BLT      |L221.930|
                  |L221.1216|
0004c0  b003              ADD      sp,sp,#0xc
0004c2  2000              MOVS     r0,#0                 ;1669
0004c4  e8bd8ff0          POP      {r4-r11,pc}
;;;1671   
                          ENDP


                          AREA ||area_number.222||, COMGROUP=_ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii, LINKORDER=||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.222||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIhEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<unsigned char>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L228.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L228.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L228.384|
000044  a25c              ADR      r2,|L228.440|
000046  a160              ADR      r1,|L228.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L228.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  300f              ADDS     r0,r0,#0xf
000064  f020050f          BIC      r5,r0,#0xf
000068  a804              ADD      r0,sp,#0x10
00006a  e9cd0902          STRD     r0,r9,[sp,#8]
00006e  2d00              CMP      r5,#0
000070  dc0a              BGT      |L228.136|
000072  f240310b          MOV      r1,#0x30b
000076  4859              LDR      r0,|L228.476|
000078  e9cd0100          STRD     r0,r1,[sp,#0]
00007c  a340              ADR      r3,|L228.384|
00007e  a24e              ADR      r2,|L228.440|
000080  a157              ADR      r1,|L228.480|
000082  2005              MOVS     r0,#5
000084  f7fffffe          BL       _Anki_Log
                  |L228.136|
000088  4638              MOV      r0,r7
00008a  2f01              CMP      r7,#1
00008c  bfd8              IT       LE
00008e  2001              MOVLE    r0,#1
000090  60a5              STR      r5,[r4,#8]
000092  4345              MULS     r5,r0,r5
000094  a803              ADD      r0,sp,#0xc
000096  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009a  4602              MOV      r2,r0
00009c  4629              MOV      r1,r5
00009e  4640              MOV      r0,r8
0000a0  9b02              LDR      r3,[sp,#8]
0000a2  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a6  f8cd900c          STR      r9,[sp,#0xc]
0000aa  f8dd8010          LDR      r8,[sp,#0x10]
0000ae  f8df915c          LDR      r9,|L228.524|
0000b2  0005              MOVS     r5,r0
0000b4  d00e              BEQ      |L228.212|
0000b6  f1b80f10          CMP      r8,#0x10
0000ba  d21e              BCS      |L228.250|
0000bc  f2403023          MOV      r0,#0x323
0000c0  e9cd9000          STRD     r9,r0,[sp,#0]
0000c4  a32e              ADR      r3,|L228.384|
0000c6  a252              ADR      r2,|L228.528|
0000c8  a156              ADR      r1,|L228.548|
0000ca  2005              MOVS     r0,#5
0000cc  f7fffffe          BL       _Anki_Log
0000d0  f000b84f          B.W      |L228.370|
                  |L228.212|
0000d4  f240301e          MOV      r0,#0x31e
0000d8  e9cd9000          STRD     r9,r0,[sp,#0]
0000dc  a328              ADR      r3,|L228.384|
0000de  a259              ADR      r2,|L228.580|
0000e0  a15f              ADR      r1,|L228.608|
0000e2  2005              MOVS     r0,#5
0000e4  f7fffffe          BL       _Anki_Log
0000e8  f8c4b000          STR      r11,[r4,#0]
0000ec  f8c4b004          STR      r11,[r4,#4]
0000f0  f8c4b008          STR      r11,[r4,#8]
0000f4  f8c4a010          STR      r10,[r4,#0x10]
0000f8  e03b              B        |L228.370|
                  |L228.250|
0000fa  a803              ADD      r0,sp,#0xc
0000fc  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000100  2800              CMP      r0,#0
000102  d00a              BEQ      |L228.282|
000104  f2403026          MOV      r0,#0x326
000108  e9cd9000          STRD     r9,r0,[sp,#0]
00010c  a31c              ADR      r3,|L228.384|
00010e  a25a              ADR      r2,|L228.632|
000110  a144              ADR      r1,|L228.548|
000112  2005              MOVS     r0,#5
000114  f7fffffe          BL       _Anki_Log
000118  e02b              B        |L228.370|
                  |L228.282|
00011a  9903              LDR      r1,[sp,#0xc]
00011c  e9c41503          STRD     r1,r5,[r4,#0xc]
000120  f105000f          ADD      r0,r5,#0xf
000124  f020000f          BIC      r0,r0,#0xf
000128  e9c47600          STRD     r7,r6,[r4,#0]
00012c  1b40              SUBS     r0,r0,r5
00012e  2e01              CMP      r6,#1
000130  bfd8              IT       LE
000132  2601              MOVLE    r6,#1
000134  f106010f          ADD      r1,r6,#0xf
000138  f021010f          BIC      r1,r1,#0xf
00013c  fb010107          MLA      r1,r1,r7,r0
000140  4541              CMP      r1,r8
000142  bfdc              ITT      LE
000144  1829              ADDLE    r1,r5,r0
000146  6121              STRLE    r1,[r4,#0x10]
000148  dd13              BLE      |L228.370|
00014a  f2403035          MOV      r0,#0x335
00014e  f8cd9000          STR      r9,[sp,#0]
000152  e9cd0101          STRD     r0,r1,[sp,#4]
000156  a30a              ADR      r3,|L228.384|
000158  a251              ADR      r2,|L228.672|
00015a  a141              ADR      r1,|L228.608|
00015c  2005              MOVS     r0,#5
00015e  f7fffffe          BL       _Anki_Log
000162  f8c4b000          STR      r11,[r4,#0]
000166  f8c4b004          STR      r11,[r4,#4]
00016a  f8c4b008          STR      r11,[r4,#8]
00016e  f8c4a010          STR      r10,[r4,#0x10]
                  |L228.370|
000172  b005              ADD      sp,sp,#0x14
000174  4620              MOV      r0,r4
000176  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

00017a  0000              DCW      0x0000
                  |L228.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L228.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L228.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L228.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L228.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L228.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L228.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L228.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L228.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L228.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L228.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L228.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L228.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.229||, COMGROUP=_ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.229||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIhE3SetERKS2_||, COMGROUP=_ZN4Anki8Embedded5ArrayIhE3SetERKS2_, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIhE3SetERKS2_ PROC ; Anki::Embedded::Array<unsigned char>::Set(const Anki::Embedded::Array<unsigned char>&)
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;656        {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
000008  b083              SUB      sp,sp,#0xc
00000a  2100              MOVS     r1,#0
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000012  4607              MOV      r7,r0
000014  2101              MOVS     r1,#1
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00001c  4606              MOV      r6,r0
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000024  f8df8094          LDR      r8,|L235.188|
000028  f04f0900          MOV      r9,#0
00002c  2800              CMP      r0,#0
;;;657          return this->SetCast<Type>(in);
00002e  d018              BEQ      |L235.98|
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000036  2800              CMP      r0,#0
000038  d013              BEQ      |L235.98|
00003a  6820              LDR      r0,[r4,#0]
00003c  42b8              CMP      r0,r7
00003e  bf04              ITT      EQ
000040  6861              LDREQ    r1,[r4,#4]
000042  42b1              CMPEQ    r1,r6
000044  d01b              BEQ      |L235.126|
000046  f44f7027          MOV      r0,#0x29c
00004a  e9cd8000          STRD     r8,r0,[sp,#0]
00004e  a31c              ADR      r3,|L235.192|
000050  a229              ADR      r2,|L235.248|
000052  a12f              ADR      r1,|L235.272|
000054  2005              MOVS     r0,#5
000056  f7fffffe          BL       _Anki_Log
;;;658        }
00005a  b003              ADD      sp,sp,#0xc
00005c  4648              MOV      r0,r9
00005e  e8bd83f0          POP      {r4-r9,pc}
                  |L235.98|
000062  f2402099          MOV      r0,#0x299
000066  e9cd8000          STRD     r8,r0,[sp,#0]
00006a  a315              ADR      r3,|L235.192|
00006c  a22d              ADR      r2,|L235.292|
00006e  a128              ADR      r1,|L235.272|
000070  2005              MOVS     r0,#5
000072  f7fffffe          BL       _Anki_Log
000076  b003              ADD      sp,sp,#0xc
000078  4648              MOV      r0,r9
00007a  e8bd83f0          POP      {r4-r9,pc}
                  |L235.126|
00007e  2100              MOVS     r1,#0
000080  2800              CMP      r0,#0
000082  dd16              BLE      |L235.178|
                  |L235.132|
000084  68aa              LDR      r2,[r5,#8]
000086  6928              LDR      r0,[r5,#0x10]
000088  fb010c02          MLA      r12,r1,r2,r0
00008c  68a2              LDR      r2,[r4,#8]
00008e  6920              LDR      r0,[r4,#0x10]
000090  fb010302          MLA      r3,r1,r2,r0
000094  6862              LDR      r2,[r4,#4]
000096  2000              MOVS     r0,#0
000098  2a00              CMP      r2,#0
00009a  dd06              BLE      |L235.170|
                  |L235.156|
00009c  f81c2000          LDRB     r2,[r12,r0]
0000a0  541a              STRB     r2,[r3,r0]
0000a2  6862              LDR      r2,[r4,#4]
0000a4  1c40              ADDS     r0,r0,#1
0000a6  4282              CMP      r2,r0
0000a8  dcf8              BGT      |L235.156|
                  |L235.170|
0000aa  6820              LDR      r0,[r4,#0]
0000ac  1c49              ADDS     r1,r1,#1
0000ae  4288              CMP      r0,r1
0000b0  dce8              BGT      |L235.132|
                  |L235.178|
0000b2  6861              LDR      r1,[r4,#4]
0000b4  b003              ADD      sp,sp,#0xc
0000b6  4348              MULS     r0,r1,r0
0000b8  e8bd83f0          POP      {r4-r9,pc}
;;;659    
                          ENDP

                  |L235.188|
                          DCD      _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
                  |L235.192|
0000c0  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
0000c4  6f726574
0000c8  6563685c
0000cc  636f6d6d
0000d0  6f6e5c69
0000d4  6e636c75
0000d8  64655c61
0000dc  6e6b692f
0000e0  636f6d6d
0000e4  6f6e2f72
0000e8  6f626f74
0000ec  2f617272
0000f0  617932  
0000f3  642e6800          DCB      "d.h",0
0000f7  00                DCB      0
                  |L235.248|
0000f8  41727261          DCB      "Array sizes don't match",0
0000fc  79207369
000100  7a657320
000104  646f6e27
000108  74206d61
00010c  74636800
                  |L235.272|
000110  41727261          DCB      "Array<Type>::Set",0
000114  793c5479
000118  70653e3a
00011c  3a536574
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L235.292|
000124  496e7661          DCB      "Invalid objects",0
000128  6c696420
00012c  6f626a65
000130  63747300

                          AREA ||area_number.236||, COMGROUP=_ZN4Anki8Embedded5ArrayIhE3SetERKS2_, LINKORDER=||t._ZN4Anki8Embedded5ArrayIhE3SetERKS2_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.236||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIhE3SetERKS2_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L242.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L242.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.243||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.243||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_12VisionMarkerEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE16InitializeBufferEiiPviNS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE16InitializeBufferEiiPviNS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE16InitializeBufferEiiPviNS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)
;;;794    
;;;795        template<typename Type> Result Array<Type>::InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;796        {
000004  b083              SUB      sp,sp,#0xc
;;;797          if(!rawData) {
;;;798            AnkiError("Anki.Array2d.initialize", "input data buffer is NULL");
000006  f8df90f8          LDR      r9,|L249.256|
00000a  f8dd8030          LDR      r8,[sp,#0x30]         ;796
00000e  001d              MOVS     r5,r3                 ;796
000010  4693              MOV      r11,r2                ;796
000012  460e              MOV      r6,r1                 ;796
000014  4604              MOV      r4,r0                 ;796
000016  f04f3aff          MOV      r10,#0xffffffff       ;796
00001a  d016              BEQ      |L249.74|
;;;799            InvalidateArray();
;;;800            return RESULT_FAIL_UNINITIALIZED_MEMORY;
;;;801          }
;;;802    
;;;803          AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0 && dataLength >= MEMORY_ALIGNMENT,
00001c  f1bb0f00          CMP      r11,#0
000020  bfa8              IT       GE
000022  2e00              CMPGE    r6,#0
000024  db02              BLT      |L249.44|
000026  f1b80f10          CMP      r8,#0x10
00002a  d224              BCS      |L249.118|
                  |L249.44|
00002c  f2403023          MOV      r0,#0x323
000030  e9cd9000          STRD     r9,r0,[sp,#0]
000034  a333              ADR      r3,|L249.260|
000036  a241              ADR      r2,|L249.316|
000038  a145              ADR      r1,|L249.336|
00003a  2005              MOVS     r0,#5
00003c  f7fffffe          BL       _Anki_Log
;;;804            RESULT_FAIL_INVALID_SIZE, "Array<Type>::InitializeBuffer", "Negative dimension");
;;;805    
;;;806          AnkiConditionalErrorAndReturnValue(!flags.get_useBoundaryFillPatterns(),
;;;807            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::InitializeBuffer", "Fill patterns not supported for Array");
;;;808    
;;;809          this->flags = flags;
;;;810          this->size[0] = numRows;
;;;811          this->size[1] = numCols;
;;;812    
;;;813          // Initialize an empty array.
;;;814    
;;;815          this->data = reinterpret_cast<Type*>(rawData);
;;;816    
;;;817          const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData), MEMORY_ALIGNMENT) - reinterpret_cast<size_t>(rawData));
;;;818          const s32 requiredBytes = ComputeRequiredStride(numCols,flags)*numRows + extraAlignmentBytes;
;;;819    
;;;820          if(requiredBytes > dataLength) {
;;;821            AnkiError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
;;;822            InvalidateArray();
;;;823            return RESULT_FAIL_OUT_OF_MEMORY;
;;;824          }
;;;825    
;;;826          this->data = reinterpret_cast<Type*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
;;;827    
;;;828          //#if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;829          //      this->UpdateCvMatMirror(*this);
;;;830          //#endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;831    
;;;832          return RESULT_OK;
;;;833        } // Array<Type>::InitializeBuffer()
000040  b003              ADD      sp,sp,#0xc
000042  f04f60a0          MOV      r0,#0x5000000         ;803
000046  e8bd8ff0          POP      {r4-r11,pc}
                  |L249.74|
00004a  f240301e          MOV      r0,#0x31e             ;798
00004e  e9cd9000          STRD     r9,r0,[sp,#0]         ;798
000052  a32c              ADR      r3,|L249.260|
000054  a246              ADR      r2,|L249.368|
000056  a14d              ADR      r1,|L249.396|
000058  2005              MOVS     r0,#5                 ;798
00005a  f7fffffe          BL       _Anki_Log
00005e  f8c4a000          STR      r10,[r4,#0]           ;798
000062  f8c4a004          STR      r10,[r4,#4]           ;798
000066  2000              MOVS     r0,#0                 ;798
000068  f8c4a008          STR      r10,[r4,#8]           ;800
00006c  6120              STR      r0,[r4,#0x10]         ;800
00006e  b003              ADD      sp,sp,#0xc
000070  484c              LDR      r0,|L249.420|
000072  e8bd8ff0          POP      {r4-r11,pc}
                  |L249.118|
000076  a80d              ADD      r0,sp,#0x34           ;806
000078  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
00007c  2800              CMP      r0,#0                 ;806
00007e  d00e              BEQ      |L249.158|
000080  f2403026          MOV      r0,#0x326             ;806
000084  e9cd9000          STRD     r9,r0,[sp,#0]         ;806
000088  a31e              ADR      r3,|L249.260|
00008a  a247              ADR      r2,|L249.424|
00008c  a130              ADR      r1,|L249.336|
00008e  2005              MOVS     r0,#5                 ;806
000090  f7fffffe          BL       _Anki_Log
000094  b003              ADD      sp,sp,#0xc
000096  f04f7040          MOV      r0,#0x3000000         ;806
00009a  e8bd8ff0          POP      {r4-r11,pc}
                  |L249.158|
00009e  980d              LDR      r0,[sp,#0x34]         ;809
0000a0  e9c40503          STRD     r0,r5,[r4,#0xc]       ;809
0000a4  f105000f          ADD      r0,r5,#0xf            ;809
0000a8  e9c46b00          STRD     r6,r11,[r4,#0]        ;817
0000ac  f020000f          BIC      r0,r0,#0xf            ;817
0000b0  1b47              SUBS     r7,r0,r5              ;817
0000b2  4658              MOV      r0,r11                ;818
0000b4  990d              LDR      r1,[sp,#0x34]         ;818
0000b6  f7fffffe          BL       _ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferE ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)
0000ba  fb007006          MLA      r0,r0,r6,r7           ;818
0000be  4540              CMP      r0,r8                 ;820
0000c0  dd17              BLE      |L249.242|
0000c2  f2403135          MOV      r1,#0x335             ;821
0000c6  f8cd9000          STR      r9,[sp,#0]            ;821
0000ca  e9cd1001          STRD     r1,r0,[sp,#4]         ;821
0000ce  a30d              ADR      r3,|L249.260|
0000d0  a23f              ADR      r2,|L249.464|
0000d2  a12e              ADR      r1,|L249.396|
0000d4  2005              MOVS     r0,#5                 ;821
0000d6  f7fffffe          BL       _Anki_Log
0000da  f8c4a000          STR      r10,[r4,#0]           ;821
0000de  f8c4a004          STR      r10,[r4,#4]           ;821
0000e2  2000              MOVS     r0,#0                 ;821
0000e4  f8c4a008          STR      r10,[r4,#8]           ;823
0000e8  6120              STR      r0,[r4,#0x10]         ;823
0000ea  b003              ADD      sp,sp,#0xc
0000ec  4848              LDR      r0,|L249.528|
0000ee  e8bd8ff0          POP      {r4-r11,pc}
                  |L249.242|
0000f2  19e8              ADDS     r0,r5,r7              ;826
0000f4  6120              STR      r0,[r4,#0x10]         ;832
0000f6  b003              ADD      sp,sp,#0xc
0000f8  2000              MOVS     r0,#0                 ;832
0000fa  e8bd8ff0          POP      {r4-r11,pc}
;;;834    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L249.256|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L249.260|
000104  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000108  6f726574
00010c  6563685c
000110  636f6d6d
000114  6f6e5c69
000118  6e636c75
00011c  64655c61
000120  6e6b692f
000124  636f6d6d
000128  6f6e2f72
00012c  6f626f74
000130  2f617272
000134  617932  
000137  642e6800          DCB      "d.h",0
00013b  00                DCB      0
                  |L249.316|
00013c  4e656761          DCB      "Negative dimension",0
000140  74697665
000144  2064696d
000148  656e7369
00014c  6f6e00  
00014f  00                DCB      0
                  |L249.336|
000150  41727261          DCB      "Array<Type>::InitializeBuffer",0
000154  793c5479
000158  70653e3a
00015c  3a496e69
000160  7469616c
000164  697a6542
000168  75666665
00016c  7200    
00016e  00                DCB      0
00016f  00                DCB      0
                  |L249.368|
000170  696e7075          DCB      "input data buffer is NULL",0
000174  74206461
000178  74612062
00017c  75666665
000180  72206973
000184  204e554c
000188  4c00    
00018a  00                DCB      0
00018b  00                DCB      0
                  |L249.396|
00018c  416e6b69          DCB      "Anki.Array2d.initialize",0
000190  2e417272
000194  61793264
000198  2e696e69
00019c  7469616c
0001a0  697a6500
                  |L249.420|
                          DCD      0x01000002
                  |L249.424|
0001a8  46696c6c          DCB      "Fill patterns not supported for Array",0
0001ac  20706174
0001b0  7465726e
0001b4  73206e6f
0001b8  74207375
0001bc  70706f72
0001c0  74656420
0001c4  666f7220
0001c8  41727261
0001cc  7900    
0001ce  00                DCB      0
0001cf  00                DCB      0
                  |L249.464|
0001d0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0001d4  74206461
0001d8  74612062
0001dc  75666665
0001e0  72206973
0001e4  206e6f74
0001e8  206c6172
0001ec  67652065
0001f0  6e6f7567
0001f4  682e2025
0001f8  64206279
0001fc  74657320
000200  69732072
000204  657175  
000207  69726564          DCB      "ired.",0
00020b  2e00    
00020d  00                DCB      0
00020e  00                DCB      0
00020f  00                DCB      0
                  |L249.528|
                          DCD      0x01000001

                          AREA ||area_number.250||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE16InitializeBufferEiiPviNS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE16InitializeBufferEiiPviNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.250||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE16InitializeBufferEiiPviNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_9RectangleIiEEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_9RectangleIiEEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_9RectangleIiEEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Rectangle<int>>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L256.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L256.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.257||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_9RectangleIiEEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_9RectangleIiEEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.257||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_9RectangleIiEEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListIfEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIfEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListIfEC2EiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::FixedLengthList<float>::FixedLengthList__sub_object(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded15FixedLengthListIfEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::FixedLengthList<float>::FixedLengthList(int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;75     
;;;76         template<typename Type> FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;77           : ArraySlice<Type>(Array<Type>(1, maximumSize, memory, flags), LinearSequence<s32>(0,0), LinearSequence<s32>(0,0))
;;;78         {
;;;79           if(this->array.get_numElements() == 0) {
;;;80             this->arrayData = NULL;
;;;81           } else {
;;;82             this->arrayData = this->array.Pointer(0,0);
;;;83           }
;;;84     
;;;85           if(flags.get_isFullyAllocated()) {
;;;86             this->set_size(maximumSize);
;;;87           } else {
;;;88             this->set_size(0);
;;;89           }
;;;90         } // FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
;;;91     
000000  e92d41ff          PUSH     {r0-r8,lr}
000004  4690              MOV      r8,r2
000006  b090              SUB      sp,sp,#0x40
000008  460d              MOV      r5,r1
00000a  4604              MOV      r4,r0
00000c  2200              MOVS     r2,#0
00000e  4611              MOV      r1,r2
000010  a80c              ADD      r0,sp,#0x30
000012  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000016  4607              MOV      r7,r0
000018  2200              MOVS     r2,#0
00001a  4611              MOV      r1,r2
00001c  a809              ADD      r0,sp,#0x24
00001e  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiEC1Eii ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
000022  4606              MOV      r6,r0
000024  9813              LDR      r0,[sp,#0x4c]
000026  9000              STR      r0,[sp,#0]
000028  4643              MOV      r3,r8
00002a  462a              MOV      r2,r5
00002c  2101              MOVS     r1,#1
00002e  a804              ADD      r0,sp,#0x10
000030  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000034  e9cd6702          STRD     r6,r7,[sp,#8]
000038  e9d01203          LDRD     r1,r2,[r0,#0xc]
00003c  e9cd1200          STRD     r1,r2,[sp,#0]
000040  e9d01200          LDRD     r1,r2,[r0,#0]
000044  6883              LDR      r3,[r0,#8]
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       _ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEERKNS0_14LinearSequenceIiEES8_ ; Anki::Embedded::ArraySlice<float>::ArraySlice(Anki::Embedded::Array<float>, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
00004c  4604              MOV      r4,r0
00004e  6980              LDR      r0,[r0,#0x18]
000050  2800              CMP      r0,#0
000052  bfc4              ITT      GT
000054  69e2              LDRGT    r2,[r4,#0x1c]
000056  2a00              CMPGT    r2,#0
000058  dd1f              BLE      |L263.154|
00005a  4350              MULS     r0,r2,r0
00005c  b1e8              CBZ      r0,|L263.154|
00005e  6a22              LDR      r2,[r4,#0x20]
000060  6aa1              LDR      r1,[r4,#0x28]
000062  2000              MOVS     r0,#0
000064  fb001002          MLA      r0,r0,r2,r1
                  |L263.104|
000068  6320              STR      r0,[r4,#0x30]
00006a  a813              ADD      r0,sp,#0x4c
00006c  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
000070  b1a8              CBZ      r0,|L263.158|
000072  2101              MOVS     r1,#1
000074  f1040018          ADD      r0,r4,#0x18
000078  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00007c  4601              MOV      r1,r0
00007e  2d00              CMP      r5,#0
000080  bfac              ITE      GE
000082  4628              MOVGE    r0,r5
000084  2000              MOVLT    r0,#0
000086  4288              CMP      r0,r1
000088  dc11              BGT      |L263.174|
00008a  2d00              CMP      r5,#0
00008c  bfb8              IT       LT
00008e  2500              MOVLT    r5,#0
                  |L263.144|
000090  4620              MOV      r0,r4
000092  60e5              STR      r5,[r4,#0xc]
000094  b014              ADD      sp,sp,#0x50
000096  e8bd81f0          POP      {r4-r8,pc}
                  |L263.154|
00009a  2000              MOVS     r0,#0
00009c  e7e4              B        |L263.104|
                  |L263.158|
00009e  2500              MOVS     r5,#0
0000a0  2101              MOVS     r1,#1
0000a2  f1040018          ADD      r0,r4,#0x18
0000a6  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000aa  42a8              CMP      r0,r5
0000ac  daf0              BGE      |L263.144|
                  |L263.174|
0000ae  2101              MOVS     r1,#1
0000b0  f1040018          ADD      r0,r4,#0x18
0000b4  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
0000b8  4605              MOV      r5,r0
0000ba  e7e9              B        |L263.144|
                          ENDP


                          AREA ||area_number.264||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIfEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListIfEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.264||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListIfEC1EiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||, COMGROUP=_ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE PROC ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)
;;;241    
;;;242          template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;243          {
000004  b082              SUB      sp,sp,#8
000006  460e              MOV      r6,r1
;;;244            const s32 in1Height = in1.get_size(0);
000008  2100              MOVS     r1,#0
00000a  9802              LDR      r0,[sp,#8]
00000c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
;;;245            const s32 in1Width = in1.get_size(1);
000010  9000              STR      r0,[sp,#0]
000012  2101              MOVS     r1,#1
000014  9802              LDR      r0,[sp,#8]
000016  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00001a  4680              MOV      r8,r0
;;;246    
;;;247            const s32 in2Height = in2.get_size(0);
00001c  2100              MOVS     r1,#0
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
000024  4605              MOV      r5,r0
;;;248            const s32 in2Width = in2.get_size(1);
000026  2101              MOVS     r1,#1
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
;;;249            const s32 in2Stride = in2.get_stride();
;;;250    
;;;251            AnkiConditionalErrorAndReturnValue(in1Width == in2Height,
00002e  f8dfa150          LDR      r10,|L270.384|
000032  68b4              LDR      r4,[r6,#8]
000034  4607              MOV      r7,r0                 ;248
000036  45a8              CMP      r8,r5
000038  d00d              BEQ      |L270.86|
00003a  20fb              MOVS     r0,#0xfb
00003c  e9cda000          STRD     r10,r0,[sp,#0]
000040  a350              ADR      r3,|L270.388|
000042  a25e              ADR      r2,|L270.444|
000044  a167              ADR      r1,|L270.484|
000046  2005              MOVS     r0,#5
000048  f7fffffe          BL       _Anki_Log
;;;252              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;253    
;;;254            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2Width, out),
;;;255              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;256    
;;;257            for(s32 y1=0; y1<in1Height; y1++) {
;;;258              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;259              OutType * restrict pOut = out.Pointer(y1, 0);
;;;260    
;;;261              for(s32 x2=0; x2<in2Width; x2++) {
;;;262                const u8 * restrict pIn2 = reinterpret_cast<const u8*>(in2.Pointer(0, x2));
;;;263    
;;;264                OutType accumulator = 0;
;;;265    
;;;266                s32 y2;
;;;267                for(y2=0; y2<in2Height-3; y2+=4) {
;;;268                  const InType in1_0 = pIn1[y2];
;;;269                  const InType in1_1 = pIn1[y2+1];
;;;270                  const InType in1_2 = pIn1[y2+2];
;;;271                  const InType in1_3 = pIn1[y2+3];
;;;272    
;;;273                  const InType in2_0 = *reinterpret_cast<const InType*>(pIn2);
;;;274                  const InType in2_1 = *reinterpret_cast<const InType*>(pIn2 + in2Stride);
;;;275                  const InType in2_2 = *reinterpret_cast<const InType*>(pIn2 + 2*in2Stride);
;;;276                  const InType in2_3 = *reinterpret_cast<const InType*>(pIn2 + 3*in2Stride);
;;;277    
;;;278                  accumulator +=
;;;279                    in1_0 * in2_0 +
;;;280                    in1_1 * in2_1 +
;;;281                    in1_2 * in2_2 +
;;;282                    in1_3 * in2_3;
;;;283    
;;;284                  pIn2 += 4*in2Stride;
;;;285                }
;;;286    
;;;287                for(; y2<in2Height; y2++) {
;;;288                  accumulator += pIn1[y2] * (*reinterpret_cast<const InType*>(pIn2));
;;;289    
;;;290                  pIn2 += in2Stride;
;;;291                }
;;;292    
;;;293                pOut[x2] = accumulator;
;;;294              }
;;;295            }
;;;296    
;;;297            return RESULT_OK;
;;;298          } // template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
00004c  b005              ADD      sp,sp,#0x14
00004e  f04f60a0          MOV      r0,#0x5000000         ;251
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L270.86|
000056  f8dd8010          LDR      r8,[sp,#0x10]
00005a  f8dd9000          LDR      r9,[sp,#0]
00005e  f8d80010          LDR      r0,[r8,#0x10]
000062  2800              CMP      r0,#0
000064  d07d              BEQ      |L270.354|
000066  f8d80000          LDR      r0,[r8,#0]
00006a  2800              CMP      r0,#0
00006c  bfa4              ITT      GE
00006e  f8d80004          LDRGE    r0,[r8,#4]
000072  2800              CMPGE    r0,#0
000074  db75              BLT      |L270.354|
000076  2100              MOVS     r1,#0
000078  4640              MOV      r0,r8
00007a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00007e  4548              CMP      r0,r9
000080  d16f              BNE      |L270.354|
000082  2101              MOVS     r1,#1
000084  4640              MOV      r0,r8
000086  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi ; Anki::Embedded::Array<float>::get_size(int) const
00008a  42b8              CMP      r0,r7
00008c  d169              BNE      |L270.354|
00008e  9800              LDR      r0,[sp,#0]            ;257
000090  f04f0900          MOV      r9,#0                 ;257
000094  2800              CMP      r0,#0                 ;257
000096  dd5f              BLE      |L270.344|
000098  eddf4a55          VLDR     s9,|L270.496|
00009c  f1a50803          SUB      r8,r5,#3              ;267
0000a0  eb040a44          ADD      r10,r4,r4,LSL #1      ;276
                  |L270.164|
0000a4  9802              LDR      r0,[sp,#8]            ;276
0000a6  6901              LDR      r1,[r0,#0x10]         ;276
0000a8  6880              LDR      r0,[r0,#8]            ;276
0000aa  fb091c00          MLA      r12,r9,r0,r1          ;276
0000ae  9804              LDR      r0,[sp,#0x10]         ;276
0000b0  6901              LDR      r1,[r0,#0x10]         ;276
0000b2  6880              LDR      r0,[r0,#8]            ;276
0000b4  fb091b00          MLA      r11,r9,r0,r1          ;276
0000b8  2100              MOVS     r1,#0                 ;261
0000ba  2f00              CMP      r7,#0                 ;261
0000bc  dd47              BLE      |L270.334|
                  |L270.190|
0000be  68b3              LDR      r3,[r6,#8]            ;261
0000c0  6932              LDR      r2,[r6,#0x10]         ;261
0000c2  2000              MOVS     r0,#0                 ;262
0000c4  fb002003          MLA      r0,r0,r3,r2           ;262
0000c8  2200              MOVS     r2,#0                 ;267
0000ca  eb000081          ADD      r0,r0,r1,LSL #2       ;267
0000ce  eeb00a64          VMOV.F32 s0,s9                 ;264
0000d2  f1b80f00          CMP      r8,#0                 ;267
0000d6  dd25              BLE      |L270.292|
                  |L270.216|
0000d8  eb0c0382          ADD      r3,r12,r2,LSL #2      ;268
0000dc  edd03a00          VLDR     s7,[r0,#0]            ;273
0000e0  ed934a00          VLDR     s8,[r3,#0]            ;268
0000e4  ed933a01          VLDR     s6,[r3,#4]            ;269
0000e8  ed932a02          VLDR     s4,[r3,#8]            ;270
0000ec  edd30a03          VLDR     s1,[r3,#0xc]          ;271
0000f0  1903              ADDS     r3,r0,r4              ;274
0000f2  ee643a23          VMUL.F32 s7,s8,s7              ;278
0000f6  edd32a00          VLDR     s5,[r3,#0]            ;274
0000fa  eb000344          ADD      r3,r0,r4,LSL #1       ;275
0000fe  1d12              ADDS     r2,r2,#4              ;267
000100  ee433a22          VMLA.F32 s7,s6,s5              ;278
000104  edd31a00          VLDR     s3,[r3,#0]            ;275
000108  eb0a0300          ADD      r3,r10,r0             ;276
00010c  eb000084          ADD      r0,r0,r4,LSL #2       ;284
000110  ed931a00          VLDR     s2,[r3,#0]            ;276
000114  4590              CMP      r8,r2                 ;267
000116  ee423a21          VMLA.F32 s7,s4,s3              ;278
00011a  ee403a81          VMLA.F32 s7,s1,s2              ;278
00011e  ee330a80          VADD.F32 s0,s7,s0              ;278
000122  dcd9              BGT      |L270.216|
                  |L270.292|
000124  42aa              CMP      r2,r5                 ;287
000126  da0b              BGE      |L270.320|
                  |L270.296|
000128  eb0c0382          ADD      r3,r12,r2,LSL #2      ;288
00012c  ed901a00          VLDR     s2,[r0,#0]            ;288
000130  edd30a00          VLDR     s1,[r3,#0]            ;288
000134  1c52              ADDS     r2,r2,#1              ;287
000136  4420              ADD      r0,r0,r4              ;290
000138  ee000a81          VMLA.F32 s0,s1,s2              ;288
00013c  42aa              CMP      r2,r5                 ;287
00013e  dbf3              BLT      |L270.296|
                  |L270.320|
000140  eb0b0081          ADD      r0,r11,r1,LSL #2      ;293
000144  1c49              ADDS     r1,r1,#1              ;261
000146  ed800a00          VSTR     s0,[r0,#0]            ;293
00014a  42b9              CMP      r1,r7                 ;261
00014c  dbb7              BLT      |L270.190|
                  |L270.334|
00014e  9800              LDR      r0,[sp,#0]            ;257
000150  f1090901          ADD      r9,r9,#1              ;257
000154  4581              CMP      r9,r0                 ;257
000156  dba5              BLT      |L270.164|
                  |L270.344|
000158  b005              ADD      sp,sp,#0x14
00015a  2000              MOVS     r0,#0                 ;297
00015c  e8bd8ff0          POP      {r4-r11,pc}
000160  e7ff              B        |L270.354|
                  |L270.354|
000162  20fe              MOVS     r0,#0xfe              ;254
000164  e9cda000          STRD     r10,r0,[sp,#0]        ;254
000168  a306              ADR      r3,|L270.388|
00016a  a222              ADR      r2,|L270.500|
00016c  a11d              ADR      r1,|L270.484|
00016e  2005              MOVS     r0,#5                 ;254
000170  f7fffffe          BL       _Anki_Log
000174  b005              ADD      sp,sp,#0x14
000176  f04f60a0          MOV      r0,#0x5000000         ;254
00017a  e8bd8ff0          POP      {r4-r11,pc}
;;;299    
                          ENDP

00017e  0000              DCW      0x0000
                  |L270.384|
                          DCD      _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
                  |L270.388|
000184  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/matrix"
000188  6f726574
00018c  6563685c
000190  636f6d6d
000194  6f6e5c69
000198  6e636c75
00019c  64655c61
0001a0  6e6b692f
0001a4  636f6d6d
0001a8  6f6e2f72
0001ac  6f626f74
0001b0  2f6d6174
0001b4  726978  
0001b7  2e6800            DCB      ".h",0
0001ba  00                DCB      0
0001bb  00                DCB      0
                  |L270.444|
0001bc  496e7075          DCB      "Input matrices are incompatible sizes",0
0001c0  74206d61
0001c4  74726963
0001c8  65732061
0001cc  72652069
0001d0  6e636f6d
0001d4  70617469
0001d8  626c6520
0001dc  73697a65
0001e0  7300    
0001e2  00                DCB      0
0001e3  00                DCB      0
                  |L270.484|
0001e4  4d756c74          DCB      "Multiply",0
0001e8  69706c79
0001ec  00      
0001ed  00                DCB      0
0001ee  00                DCB      0
0001ef  00                DCB      0
                  |L270.496|
0001f0  00000000          DCFS     0x00000000 ; 0
                  |L270.500|
0001f4  496e7075          DCB      "Input and Output matrices are incompatible sizes",0
0001f8  7420616e
0001fc  64204f75
000200  74707574
000204  206d6174
000208  72696365
00020c  73206172
000210  6520696e
000214  636f6d70
000218  61746962
00021c  6c652073
000220  697a6573
000224  00      
000225  00                DCB      0
000226  00                DCB      0
000227  00                DCB      0

                          AREA ||area_number.271||, COMGROUP=_ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE, LINKORDER=||t._ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.271||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_||, COMGROUP=_ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_ PROC ; Anki::Embedded::operator *<float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Point3<T1>&)
;;;270        template<typename Type>
;;;271        Point3<Type> operator* (const Array<Type>& M, const Point3<Type>& p)
000000  b430              PUSH     {r4,r5}
000002  f8d1c008          LDR      r12,[r1,#8]
000006  690b              LDR      r3,[r1,#0x10]
;;;272        {
;;;273          // Matrix M must be 3x3
;;;274          AnkiAssert(AreEqualSize(3, 3, M));
;;;275    
;;;276          return Point3<Type>(M[0][0]*p.x + M[0][1]*p.y + M[0][2]*p.z,
000008  2402              MOVS     r4,#2
00000a  fb04310c          MLA      r1,r4,r12,r3
00000e  ed920a00          VLDR     s0,[r2,#0]
000012  edd10a00          VLDR     s1,[r1,#0]
000016  ed922a01          VLDR     s4,[r2,#4]
00001a  edd21a02          VLDR     s3,[r2,#8]
00001e  ee201a80          VMUL.F32 s2,s1,s0
000022  edd10a01          VLDR     s1,[r1,#4]
000026  ee001a82          VMLA.F32 s2,s1,s4
00002a  edd10a02          VLDR     s1,[r1,#8]
00002e  2101              MOVS     r1,#1
000030  fb01310c          MLA      r1,r1,r12,r3
000034  ee001aa1          VMLA.F32 s2,s1,s3
000038  edd10a00          VLDR     s1,[r1,#0]
00003c  edd12a01          VLDR     s5,[r1,#4]
000040  ee600a80          VMUL.F32 s1,s1,s0
000044  ee420a82          VMLA.F32 s1,s5,s4
000048  edd12a02          VLDR     s5,[r1,#8]
00004c  2100              MOVS     r1,#0
00004e  fb01310c          MLA      r1,r1,r12,r3
000052  ee420aa1          VMLA.F32 s1,s5,s3
000056  edd12a00          VLDR     s5,[r1,#0]
00005a  ee220a80          VMUL.F32 s0,s5,s0
00005e  edd12a01          VLDR     s5,[r1,#4]
000062  ee020a82          VMLA.F32 s0,s5,s4
000066  ed912a02          VLDR     s4,[r1,#8]
00006a  bc30              POP      {r4,r5}
00006c  ee020a21          VMLA.F32 s0,s4,s3
000070  f7ffbffe          B.W      _ZN4Anki8Embedded6Point3IfEC1Efff ; Anki::Embedded::Point3<float>::Point3(float, float, float)
;;;277            M[1][0]*p.x + M[1][1]*p.y + M[1][2]*p.z,
;;;278            M[2][0]*p.x + M[2][1]*p.y + M[2][2]*p.z);
;;;279        }
;;;280    
                          ENDP


                          AREA ||area_number.278||, COMGROUP=_ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_, LINKORDER=||t._ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.278||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8EmbeddedmlIfEENS0_6Point3IT_EERKNS0_5ArrayIS3_EERKS4_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5PointIfEC1Ev||, COMGROUP=_ZN4Anki8Embedded5PointIfEC1Ev, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5PointIfEC2Ev                  ; Alternate entry point ; Anki::Embedded::Point<float>::Point__sub_object()
                  _ZN4Anki8Embedded5PointIfEC1Ev PROC ; Anki::Embedded::Point<float>::Point()
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
000000  ed9f0a03          VLDR     s0,|L284.16|
000004  ed800a00          VSTR     s0,[r0,#0]
000008  ed800a01          VSTR     s0,[r0,#4]
00000c  4770              BX       lr
                          ENDP

00000e  0000              DCW      0x0000
                  |L284.16|
000010  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.285||, COMGROUP=_ZN4Anki8Embedded5PointIfEC1Ev, LINKORDER=||t._ZN4Anki8Embedded5PointIfEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.285||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5PointIfEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii PROC ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
;;;105    
;;;106        template<typename Type> s32 LinearSequence<Type>::computeSize(const Type start, const Type increment, const Type end)
000000  4290              CMP      r0,r2
;;;107        {
;;;108          if(start == end) {
;;;109            return 1;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;110          } else {
;;;111            if(ABS(increment) <= Flags::numeric_limits<Type>::epsilon()) {
;;;112              return 0;
;;;113            }
;;;114          }
;;;115    
;;;116          // 10:-1:12
;;;117          if(increment < 0 && start < end) {
;;;118            return 0;
;;;119          }
;;;120    
;;;121          // 12:1:10
;;;122          if(increment > 0 && start > end) {
;;;123            return 0;
;;;124          }
;;;125    
;;;126          const Type minLimit = MIN(start, end);
;;;127          const Type maxLimit = MAX(start, end);
;;;128          const Type incrementMagnitude = ABS(increment);
;;;129    
;;;130          const Type validRange = maxLimit - minLimit;
;;;131          const s32 size = (validRange+incrementMagnitude) / incrementMagnitude;
;;;132    
;;;133          AnkiConditionalErrorAndReturnValue(size >= 0,
;;;134            0, "LinearSequence<Type>::computeSize", "size estimation failed");
;;;135    
;;;136          return size;
;;;137        }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;107
00000a  2400              MOVS     r4,#0                 ;107
00000c  424b              RSBS     r3,r1,#0              ;111
00000e  b082              SUB      sp,sp,#8              ;107
000010  2900              CMP      r1,#0                 ;111
000012  bfac              ITE      GE                    ;111
000014  468c              MOVGE    r12,r1                ;111
000016  469c              MOVLT    r12,r3                ;111
000018  4564              CMP      r4,r12                ;111
00001a  da03              BGE      |L291.36|
00001c  2900              CMP      r1,#0                 ;117
00001e  da04              BGE      |L291.42|
000020  4290              CMP      r0,r2                 ;117
000022  da05              BGE      |L291.48|
                  |L291.36|
000024  b002              ADD      sp,sp,#8
000026  2000              MOVS     r0,#0                 ;123
000028  bd10              POP      {r4,pc}
                  |L291.42|
00002a  bf18              IT       NE                    ;122
00002c  4290              CMPNE    r0,r2                 ;122
00002e  dcf9              BGT      |L291.36|
                  |L291.48|
000030  4290              CMP      r0,r2                 ;126
000032  bfb4              ITE      LT                    ;126
000034  4684              MOVLT    r12,r0                ;126
000036  4694              MOVGE    r12,r2                ;126
000038  bfd8              IT       LE                    ;127
00003a  4610              MOVLE    r0,r2                 ;127
00003c  2900              CMP      r1,#0                 ;128
00003e  bfb8              IT       LT                    ;128
000040  4619              MOVLT    r1,r3                 ;128
000042  eba0000c          SUB      r0,r0,r12             ;130
000046  4408              ADD      r0,r0,r1              ;131
000048  fb90f0f1          SDIV     r0,r0,r1              ;131
00004c  2800              CMP      r0,#0                 ;133
00004e  bfa4              ITT      GE
000050  b002              ADDGE    sp,sp,#8
000052  bd10              POPGE    {r4,pc}
000054  2185              MOVS     r1,#0x85              ;133
000056  4807              LDR      r0,|L291.116|
000058  4b07              LDR      r3,|L291.120|
00005a  e9cd0100          STRD     r0,r1,[sp,#0]         ;133
00005e  f1a30218          SUB      r2,r3,#0x18           ;133
000062  f1a20124          SUB      r1,r2,#0x24           ;133
000066  2005              MOVS     r0,#5                 ;133
000068  f7fffffe          BL       _Anki_Log
00006c  b002              ADD      sp,sp,#8
00006e  2000              MOVS     r0,#0                 ;133
000070  bd10              POP      {r4,pc}
;;;138    
                          ENDP

000072  0000              DCW      0x0000
                  |L291.116|
                          DCD      _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
                  |L291.120|
                          DCD      ||.constdata||+0x30bc

                          AREA ||area_number.292||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii, LINKORDER=||t._ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.292||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Eii, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded14LinearSequenceIiEC2Eii                  ; Alternate entry point ; Anki::Embedded::LinearSequence<int>::LinearSequence__sub_object(int, int)
                  _ZN4Anki8Embedded14LinearSequenceIiEC1Eii PROC ; Anki::Embedded::LinearSequence<int>::LinearSequence(int, int)
;;;30     
;;;31         template<typename Type> LinearSequence<Type>::LinearSequence(const Type start, const Type end)
;;;32           : start(start), increment(1)
;;;33         {
;;;34           this->size = computeSize(this->start, this->increment, end);
;;;35         }
;;;36     
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4608              MOV      r0,r1
000006  2101              MOVS     r1,#1
000008  e9c40101          STRD     r0,r1,[r4,#4]
00000c  f7fffffe          BL       _ZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiii ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)
000010  6020              STR      r0,[r4,#0]
000012  4620              MOV      r0,r4
000014  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||area_number.299||, COMGROUP=_ZN4Anki8Embedded14LinearSequenceIiEC1Eii, LINKORDER=||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.299||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded14LinearSequenceIiEC1Eii||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferE PROC ; Anki::Embedded::Array<int>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)
;;;55     
;;;56         template<typename Type> s32 Array<Type>::ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags)
000000  b500              PUSH     {lr}
;;;57         {
000002  b083              SUB      sp,sp,#0xc
;;;58           AnkiConditionalErrorAndReturnValue(numCols >= 0,
000004  2800              CMP      r0,#0
000006  da0e              BGE      |L305.38|
000008  213a              MOVS     r1,#0x3a
00000a  480b              LDR      r0,|L305.56|
00000c  4b0b              LDR      r3,|L305.60|
00000e  e9cd0100          STRD     r0,r1,[sp,#0]
000012  f1a30210          SUB      r2,r3,#0x10
000016  f1a20124          SUB      r1,r2,#0x24
00001a  2005              MOVS     r0,#5
00001c  f7fffffe          BL       _Anki_Log
;;;59             0, "Array<Type>::ComputeRequiredStride", "Invalid size");
;;;60     
;;;61           const s32 numColsCapped = MAX(numCols, 1);
;;;62     
;;;63           const s32 bufferRequired = static_cast<s32>(RoundUp<size_t>(sizeof(Type)*numColsCapped, MEMORY_ALIGNMENT));
;;;64     
;;;65           return bufferRequired;
;;;66         }
000020  b003              ADD      sp,sp,#0xc
000022  2000              MOVS     r0,#0                 ;58
000024  bd00              POP      {pc}
                  |L305.38|
000026  2801              CMP      r0,#1                 ;61
000028  bfd8              IT       LE                    ;61
00002a  2001              MOVLE    r0,#1                 ;61
00002c  0080              LSLS     r0,r0,#2              ;63
00002e  300f              ADDS     r0,r0,#0xf            ;63
000030  b003              ADD      sp,sp,#0xc
000032  f020000f          BIC      r0,r0,#0xf
000036  bd00              POP      {pc}
;;;67     
                          ENDP

                  |L305.56|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L305.60|
                          DCD      ||.constdata||+0x312c

                          AREA ||area_number.306||, COMGROUP=_ZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.306||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIiEC1EiiPviNS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIiEC1EiiPviNS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIiEC2EiiPviNS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<int>::Array__sub_object(int, int, void*, int, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIiEC1EiiPviNS0_5Flags6BufferE PROC ; Anki::Embedded::Array<int>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  b083              SUB      sp,sp,#0xc
000006  4699              MOV      r9,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  9d0a              LDR      r5,[sp,#0x28]
000010  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000014  f1a0040c          SUB      r4,r0,#0xc
000018  f04f30ff          MOV      r0,#0xffffffff
00001c  6020              STR      r0,[r4,#0]
00001e  6060              STR      r0,[r4,#4]
000020  60a0              STR      r0,[r4,#8]
000022  2000              MOVS     r0,#0
000024  f8df80f8          LDR      r8,|L312.288|
000028  6120              STR      r0,[r4,#0x10]
00002a  f0190f0f          TST      r9,#0xf
00002e  d00d              BEQ      |L312.76|
000030  2010              MOVS     r0,#0x10
000032  2157              MOVS     r1,#0x57
000034  f8cd8000          STR      r8,[sp,#0]
000038  e9cd1001          STRD     r1,r0,[sp,#4]
00003c  a339              ADR      r3,|L312.292|
00003e  a247              ADR      r2,|L312.348|
000040  a153              ADR      r1,|L312.400|
000042  2005              MOVS     r0,#5
000044  f7fffffe          BL       _Anki_Log
000048  f000b84d          B.W      |L312.230|
                  |L312.76|
00004c  4630              MOV      r0,r6
00004e  990b              LDR      r1,[sp,#0x2c]
000050  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferE ; Anki::Embedded::Array<int>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)
000054  60a0              STR      r0,[r4,#8]
000056  2e00              CMP      r6,#0
000058  bfa2              ITTT     GE
00005a  2f00              CMPGE    r7,#0
00005c  4378              MULGE    r0,r7,r0
00005e  4285              CMPGE    r5,r0
000060  da0c              BGE      |L312.124|
000062  205c              MOVS     r0,#0x5c
000064  e9cd8000          STRD     r8,r0,[sp,#0]
000068  a32e              ADR      r3,|L312.292|
00006a  a24d              ADR      r2,|L312.416|
00006c  a150              ADR      r1,|L312.432|
00006e  2005              MOVS     r0,#5
000070  f7fffffe          BL       _Anki_Log
000074  b003              ADD      sp,sp,#0xc
000076  4620              MOV      r0,r4
000078  e8bd83f0          POP      {r4-r9,pc}
                  |L312.124|
00007c  a80b              ADD      r0,sp,#0x2c
00007e  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
000082  2800              CMP      r0,#0
000084  d041              BEQ      |L312.266|
000086  2f01              CMP      r7,#1
000088  d010              BEQ      |L312.172|
00008a  68a1              LDR      r1,[r4,#8]
00008c  00b0              LSLS     r0,r6,#2
00008e  4281              CMP      r1,r0
000090  d01c              BEQ      |L312.204|
000092  2067              MOVS     r0,#0x67
000094  e9cd8000          STRD     r8,r0,[sp,#0]
000098  a322              ADR      r3,|L312.292|
00009a  4a4a              LDR      r2,|L312.452|
00009c  a144              ADR      r1,|L312.432|
00009e  2005              MOVS     r0,#5
0000a0  f7fffffe          BL       _Anki_Log
0000a4  b003              ADD      sp,sp,#0xc
0000a6  4620              MOV      r0,r4
0000a8  e8bd83f0          POP      {r4-r9,pc}
                  |L312.172|
0000ac  68a0              LDR      r0,[r4,#8]
0000ae  42a8              CMP      r0,r5
0000b0  dd1d              BLE      |L312.238|
0000b2  2062              MOVS     r0,#0x62
0000b4  e9cd8000          STRD     r8,r0,[sp,#0]
0000b8  a31a              ADR      r3,|L312.292|
0000ba  4a43              LDR      r2,|L312.456|
0000bc  a13c              ADR      r1,|L312.432|
0000be  2005              MOVS     r0,#5
0000c0  f7fffffe          BL       _Anki_Log
0000c4  b003              ADD      sp,sp,#0xc
0000c6  4620              MOV      r0,r4
0000c8  e8bd83f0          POP      {r4-r9,pc}
                  |L312.204|
0000cc  200f              MOVS     r0,#0xf
0000ce  ea100f86          TST      r0,r6,LSL #2
0000d2  d00c              BEQ      |L312.238|
0000d4  206a              MOVS     r0,#0x6a
0000d6  e9cd8000          STRD     r8,r0,[sp,#0]
0000da  a312              ADR      r3,|L312.292|
0000dc  4a3b              LDR      r2,|L312.460|
0000de  a134              ADR      r1,|L312.432|
0000e0  2005              MOVS     r0,#5
0000e2  f7fffffe          BL       _Anki_Log
                  |L312.230|
0000e6  b003              ADD      sp,sp,#0xc
0000e8  4620              MOV      r0,r4
0000ea  e8bd83f0          POP      {r4-r9,pc}
                  |L312.238|
0000ee  a80b              ADD      r0,sp,#0x2c
0000f0  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
0000f4  b148              CBZ      r0,|L312.266|
0000f6  206e              MOVS     r0,#0x6e
0000f8  e9cd8000          STRD     r8,r0,[sp,#0]
0000fc  a309              ADR      r3,|L312.292|
0000fe  4a34              LDR      r2,|L312.464|
000100  a12b              ADR      r1,|L312.432|
000102  2005              MOVS     r0,#5
000104  f7fffffe          BL       _Anki_Log
000108  e7ed              B        |L312.230|
                  |L312.266|
00010a  980b              LDR      r0,[sp,#0x2c]
00010c  464b              MOV      r3,r9
00010e  e9cd5000          STRD     r5,r0,[sp,#0]
000112  4632              MOV      r2,r6
000114  4639              MOV      r1,r7
000116  4620              MOV      r0,r4
000118  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferE ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)
00011c  e7e3              B        |L312.230|
                          ENDP

00011e  0000              DCW      0x0000
                  |L312.288|
                          DCD      _ZZN4Anki8Embedded5ArrayIiEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L312.292|
000124  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000128  6f726574
00012c  6563685c
000130  636f6d6d
000134  6f6e5c69
000138  6e636c75
00013c  64655c61
000140  6e6b692f
000144  636f6d6d
000148  6f6e2f72
00014c  6f626f74
000150  2f617272
000154  617932  
000157  642e6800          DCB      "d.h",0
00015b  00                DCB      0
                  |L312.348|
00015c  49662066          DCB      "If fully allocated, data must be %d byte aligned",0
000160  756c6c79
000164  20616c6c
000168  6f636174
00016c  65642c20
000170  64617461
000174  206d7573
000178  74206265
00017c  20256420
000180  62797465
000184  20616c69
000188  676e6564
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L312.400|
000190  41727261          DCB      "Array::Array",0
000194  793a3a41
000198  72726179
00019c  00      
00019d  00                DCB      0
00019e  00                DCB      0
00019f  00                DCB      0
                  |L312.416|
0001a0  496e7661          DCB      "Invalid size",0
0001a4  6c696420
0001a8  73697a65
0001ac  00      
0001ad  00                DCB      0
0001ae  00                DCB      0
0001af  00                DCB      0
                  |L312.432|
0001b0  41727261          DCB      "Array<Type>::Array",0
0001b4  793c5479
0001b8  70653e3a
0001bc  3a417272
0001c0  617900  
0001c3  00                DCB      0
                  |L312.452|
                          DCD      ||.constdata||+0x31e0
                  |L312.456|
                          DCD      ||.constdata||+0x3164
                  |L312.460|
                          DCD      ||.constdata||+0x323c
                  |L312.464|
                          DCD      ||.constdata||+0x32bc

                          AREA ||area_number.313||, COMGROUP=_ZN4Anki8Embedded5ArrayIiEC1EiiPviNS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIiEC1EiiPviNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.313||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIiEC1EiiPviNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<int>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L319.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L319.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.320||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.320||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListIiE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Point3IfEC1Ev||, COMGROUP=_ZN4Anki8Embedded6Point3IfEC1Ev, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded6Point3IfEC2Ev                  ; Alternate entry point ; Anki::Embedded::Point3<float>::Point3__sub_object()
                  _ZN4Anki8Embedded6Point3IfEC1Ev PROC ; Anki::Embedded::Point3<float>::Point3()
;;;145    
;;;146        template<typename Type> Point3<Type>::Point3()
;;;147          : x(static_cast<Type>(0)), y(static_cast<Type>(0)), z(static_cast<Type>(0))
;;;148        {
;;;149        }
;;;150    
000000  ed9f0a04          VLDR     s0,|L326.20|
000004  ed800a00          VSTR     s0,[r0,#0]
000008  ed800a01          VSTR     s0,[r0,#4]
00000c  ed800a02          VSTR     s0,[r0,#8]
000010  4770              BX       lr
                          ENDP

000012  0000              DCW      0x0000
                  |L326.20|
000014  00000000          DCFS     0x00000000 ; 0

                          AREA ||area_number.327||, COMGROUP=_ZN4Anki8Embedded6Point3IfEC1Ev, LINKORDER=||t._ZN4Anki8Embedded6Point3IfEC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.327||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Point3IfEC1Ev||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded6Point3IfEC1Efff||, COMGROUP=_ZN4Anki8Embedded6Point3IfEC1Efff, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded6Point3IfEC2Efff                  ; Alternate entry point ; Anki::Embedded::Point3<float>::Point3__sub_object(float, float, float)
                  _ZN4Anki8Embedded6Point3IfEC1Efff PROC ; Anki::Embedded::Point3<float>::Point3(float, float, float)
;;;150    
;;;151        template<typename Type> Point3<Type>::Point3(const Type x, const Type y, const Type z)
;;;152          : x(x), y(y), z(z)
;;;153        {
;;;154        }
;;;155    
000000  ed800a00          VSTR     s0,[r0,#0]
000004  edc00a01          VSTR     s1,[r0,#4]
000008  ed801a02          VSTR     s2,[r0,#8]
00000c  4770              BX       lr
                          ENDP


                          AREA ||area_number.334||, COMGROUP=_ZN4Anki8Embedded6Point3IfEC1Efff, LINKORDER=||t._ZN4Anki8Embedded6Point3IfEC1Efff||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.334||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded6Point3IfEC1Efff||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferE PROC ; Anki::Embedded::Array<float>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)
;;;55     
;;;56         template<typename Type> s32 Array<Type>::ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags)
000000  b500              PUSH     {lr}
;;;57         {
000002  b083              SUB      sp,sp,#0xc
;;;58           AnkiConditionalErrorAndReturnValue(numCols >= 0,
000004  2800              CMP      r0,#0
000006  da0e              BGE      |L340.38|
000008  213a              MOVS     r1,#0x3a
00000a  480b              LDR      r0,|L340.56|
00000c  4b0b              LDR      r3,|L340.60|
00000e  e9cd0100          STRD     r0,r1,[sp,#0]
000012  f1a30210          SUB      r2,r3,#0x10
000016  f1a20124          SUB      r1,r2,#0x24
00001a  2005              MOVS     r0,#5
00001c  f7fffffe          BL       _Anki_Log
;;;59             0, "Array<Type>::ComputeRequiredStride", "Invalid size");
;;;60     
;;;61           const s32 numColsCapped = MAX(numCols, 1);
;;;62     
;;;63           const s32 bufferRequired = static_cast<s32>(RoundUp<size_t>(sizeof(Type)*numColsCapped, MEMORY_ALIGNMENT));
;;;64     
;;;65           return bufferRequired;
;;;66         }
000020  b003              ADD      sp,sp,#0xc
000022  2000              MOVS     r0,#0                 ;58
000024  bd00              POP      {pc}
                  |L340.38|
000026  2801              CMP      r0,#1                 ;61
000028  bfd8              IT       LE                    ;61
00002a  2001              MOVLE    r0,#1                 ;61
00002c  0080              LSLS     r0,r0,#2              ;63
00002e  300f              ADDS     r0,r0,#0xf            ;63
000030  b003              ADD      sp,sp,#0xc
000032  f020000f          BIC      r0,r0,#0xf
000036  bd00              POP      {pc}
;;;67     
                          ENDP

                  |L340.56|
                          DCD      _ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L340.60|
                          DCD      ||.constdata||+0x312c

                          AREA ||area_number.341||, COMGROUP=_ZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.341||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIfEC1EiiPviNS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiPviNS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIfEC2EiiPviNS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<float>::Array__sub_object(int, int, void*, int, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIfEC1EiiPviNS0_5Flags6BufferE PROC ; Anki::Embedded::Array<float>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  b083              SUB      sp,sp,#0xc
000006  4699              MOV      r9,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  9d0a              LDR      r5,[sp,#0x28]
000010  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000014  f1a0040c          SUB      r4,r0,#0xc
000018  f04f30ff          MOV      r0,#0xffffffff
00001c  6020              STR      r0,[r4,#0]
00001e  6060              STR      r0,[r4,#4]
000020  60a0              STR      r0,[r4,#8]
000022  2000              MOVS     r0,#0
000024  f8df80f8          LDR      r8,|L347.288|
000028  6120              STR      r0,[r4,#0x10]
00002a  f0190f0f          TST      r9,#0xf
00002e  d00d              BEQ      |L347.76|
000030  2010              MOVS     r0,#0x10
000032  2157              MOVS     r1,#0x57
000034  f8cd8000          STR      r8,[sp,#0]
000038  e9cd1001          STRD     r1,r0,[sp,#4]
00003c  a339              ADR      r3,|L347.292|
00003e  a247              ADR      r2,|L347.348|
000040  a153              ADR      r1,|L347.400|
000042  2005              MOVS     r0,#5
000044  f7fffffe          BL       _Anki_Log
000048  f000b84d          B.W      |L347.230|
                  |L347.76|
00004c  4630              MOV      r0,r6
00004e  990b              LDR      r1,[sp,#0x2c]
000050  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferE ; Anki::Embedded::Array<float>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)
000054  60a0              STR      r0,[r4,#8]
000056  2e00              CMP      r6,#0
000058  bfa2              ITTT     GE
00005a  2f00              CMPGE    r7,#0
00005c  4378              MULGE    r0,r7,r0
00005e  4285              CMPGE    r5,r0
000060  da0c              BGE      |L347.124|
000062  205c              MOVS     r0,#0x5c
000064  e9cd8000          STRD     r8,r0,[sp,#0]
000068  a32e              ADR      r3,|L347.292|
00006a  a24d              ADR      r2,|L347.416|
00006c  a150              ADR      r1,|L347.432|
00006e  2005              MOVS     r0,#5
000070  f7fffffe          BL       _Anki_Log
000074  b003              ADD      sp,sp,#0xc
000076  4620              MOV      r0,r4
000078  e8bd83f0          POP      {r4-r9,pc}
                  |L347.124|
00007c  a80b              ADD      r0,sp,#0x2c
00007e  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
000082  2800              CMP      r0,#0
000084  d041              BEQ      |L347.266|
000086  2f01              CMP      r7,#1
000088  d010              BEQ      |L347.172|
00008a  68a1              LDR      r1,[r4,#8]
00008c  00b0              LSLS     r0,r6,#2
00008e  4281              CMP      r1,r0
000090  d01c              BEQ      |L347.204|
000092  2067              MOVS     r0,#0x67
000094  e9cd8000          STRD     r8,r0,[sp,#0]
000098  a322              ADR      r3,|L347.292|
00009a  4a4a              LDR      r2,|L347.452|
00009c  a144              ADR      r1,|L347.432|
00009e  2005              MOVS     r0,#5
0000a0  f7fffffe          BL       _Anki_Log
0000a4  b003              ADD      sp,sp,#0xc
0000a6  4620              MOV      r0,r4
0000a8  e8bd83f0          POP      {r4-r9,pc}
                  |L347.172|
0000ac  68a0              LDR      r0,[r4,#8]
0000ae  42a8              CMP      r0,r5
0000b0  dd1d              BLE      |L347.238|
0000b2  2062              MOVS     r0,#0x62
0000b4  e9cd8000          STRD     r8,r0,[sp,#0]
0000b8  a31a              ADR      r3,|L347.292|
0000ba  4a43              LDR      r2,|L347.456|
0000bc  a13c              ADR      r1,|L347.432|
0000be  2005              MOVS     r0,#5
0000c0  f7fffffe          BL       _Anki_Log
0000c4  b003              ADD      sp,sp,#0xc
0000c6  4620              MOV      r0,r4
0000c8  e8bd83f0          POP      {r4-r9,pc}
                  |L347.204|
0000cc  200f              MOVS     r0,#0xf
0000ce  ea100f86          TST      r0,r6,LSL #2
0000d2  d00c              BEQ      |L347.238|
0000d4  206a              MOVS     r0,#0x6a
0000d6  e9cd8000          STRD     r8,r0,[sp,#0]
0000da  a312              ADR      r3,|L347.292|
0000dc  4a3b              LDR      r2,|L347.460|
0000de  a134              ADR      r1,|L347.432|
0000e0  2005              MOVS     r0,#5
0000e2  f7fffffe          BL       _Anki_Log
                  |L347.230|
0000e6  b003              ADD      sp,sp,#0xc
0000e8  4620              MOV      r0,r4
0000ea  e8bd83f0          POP      {r4-r9,pc}
                  |L347.238|
0000ee  a80b              ADD      r0,sp,#0x2c
0000f0  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
0000f4  b148              CBZ      r0,|L347.266|
0000f6  206e              MOVS     r0,#0x6e
0000f8  e9cd8000          STRD     r8,r0,[sp,#0]
0000fc  a309              ADR      r3,|L347.292|
0000fe  4a34              LDR      r2,|L347.464|
000100  a12b              ADR      r1,|L347.432|
000102  2005              MOVS     r0,#5
000104  f7fffffe          BL       _Anki_Log
000108  e7ed              B        |L347.230|
                  |L347.266|
00010a  980b              LDR      r0,[sp,#0x2c]
00010c  464b              MOV      r3,r9
00010e  e9cd5000          STRD     r5,r0,[sp,#0]
000112  4632              MOV      r2,r6
000114  4639              MOV      r1,r7
000116  4620              MOV      r0,r4
000118  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferE ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)
00011c  e7e3              B        |L347.230|
                          ENDP

00011e  0000              DCW      0x0000
                  |L347.288|
                          DCD      _ZZN4Anki8Embedded5ArrayIfEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L347.292|
000124  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000128  6f726574
00012c  6563685c
000130  636f6d6d
000134  6f6e5c69
000138  6e636c75
00013c  64655c61
000140  6e6b692f
000144  636f6d6d
000148  6f6e2f72
00014c  6f626f74
000150  2f617272
000154  617932  
000157  642e6800          DCB      "d.h",0
00015b  00                DCB      0
                  |L347.348|
00015c  49662066          DCB      "If fully allocated, data must be %d byte aligned",0
000160  756c6c79
000164  20616c6c
000168  6f636174
00016c  65642c20
000170  64617461
000174  206d7573
000178  74206265
00017c  20256420
000180  62797465
000184  20616c69
000188  676e6564
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L347.400|
000190  41727261          DCB      "Array::Array",0
000194  793a3a41
000198  72726179
00019c  00      
00019d  00                DCB      0
00019e  00                DCB      0
00019f  00                DCB      0
                  |L347.416|
0001a0  496e7661          DCB      "Invalid size",0
0001a4  6c696420
0001a8  73697a65
0001ac  00      
0001ad  00                DCB      0
0001ae  00                DCB      0
0001af  00                DCB      0
                  |L347.432|
0001b0  41727261          DCB      "Array<Type>::Array",0
0001b4  793c5479
0001b8  70653e3a
0001bc  3a417272
0001c0  617900  
0001c3  00                DCB      0
                  |L347.452|
                          DCD      ||.constdata||+0x31e0
                  |L347.456|
                          DCD      ||.constdata||+0x3164
                  |L347.460|
                          DCD      ||.constdata||+0x323c
                  |L347.464|
                          DCD      ||.constdata||+0x32bc

                          AREA ||area_number.348||, COMGROUP=_ZN4Anki8Embedded5ArrayIfEC1EiiPviNS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIfEC1EiiPviNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.348||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIfEC1EiiPviNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIfE8get_sizeEi PROC ; Anki::Embedded::Array<float>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L354.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L354.56|
00000e  4b0b              LDR      r3,|L354.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f5037207          ADD      r2,r3,#0x21c
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L354.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L354.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::get_size(int) const::__PRETTY_FUNCTION__
                  |L354.60|
                          DCD      ||.constdata||+0x312c

                          AREA ||area_number.355||, COMGROUP=_ZNK4Anki8Embedded5ArrayIfE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.355||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIfE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv PROC ; Anki::Embedded::Quadrilateral<float>::ComputeClockwiseCorners<float>() const
;;;268          // Warning: This may give weird results for non-convex quadrilaterals
;;;269          template<typename OutType> Quadrilateral<OutType> ComputeClockwiseCorners() const;
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  460d              MOV      r5,r1
000006  ed2d8b04          VPUSH    {d8-d9}
00000a  b0c5              SUB      sp,sp,#0x114
00000c  4680              MOV      r8,r0
00000e  2201              MOVS     r2,#1
000010  2300              MOVS     r3,#0
000012  4611              MOV      r1,r2
000014  a841              ADD      r0,sp,#0x104
000016  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00001a  6803              LDR      r3,[r0,#0]
00001c  2280              MOVS     r2,#0x80
00001e  a902              ADD      r1,sp,#8
000020  a822              ADD      r0,sp,#0x88
000022  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStackC1EPviNS0_5Flags6BufferE ; Anki::Embedded::MemoryStack::MemoryStack(void*, int, Anki::Embedded::Flags::Buffer)
000026  2300              MOVS     r3,#0
000028  461a              MOV      r2,r3
00002a  2101              MOVS     r1,#1
00002c  a842              ADD      r0,sp,#0x108
00002e  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000032  6800              LDR      r0,[r0,#0]
000034  9000              STR      r0,[sp,#0]
000036  ab22              ADD      r3,sp,#0x88
000038  2204              MOVS     r2,#4
00003a  2101              MOVS     r1,#1
00003c  a829              ADD      r0,sp,#0xa4
00003e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000042  2001              MOVS     r0,#1
000044  2300              MOVS     r3,#0
000046  4601              MOV      r1,r0
000048  9040              STR      r0,[sp,#0x100]
00004a  ac2e              ADD      r4,sp,#0xb8
00004c  f04f0b04          MOV      r11,#4
000050  f10d0a88          ADD      r10,sp,#0x88
000054  461a              MOV      r2,r3
000056  a843              ADD      r0,sp,#0x10c
000058  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
00005c  6806              LDR      r6,[r0,#0]
00005e  f104000c          ADD      r0,r4,#0xc
000062  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000066  f1a0040c          SUB      r4,r0,#0xc
00006a  f04f30ff          MOV      r0,#0xffffffff
00006e  6020              STR      r0,[r4,#0]
000070  6060              STR      r0,[r4,#4]
000072  2700              MOVS     r7,#0
000074  6127              STR      r7,[r4,#0x10]
000076  60a0              STR      r0,[r4,#8]
000078  4631              MOV      r1,r6
00007a  4658              MOV      r0,r11
00007c  9733              STR      r7,[sp,#0xcc]
00007e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferE ; Anki::Embedded::Array<int>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)
000082  f1b00900          SUBS     r9,r0,#0
000086  a833              ADD      r0,sp,#0xcc
000088  e9cd603e          STRD     r6,r0,[sp,#0xf8]
00008c  dc0a              BGT      |L361.164|
00008e  f240310b          MOV      r1,#0x30b
000092  4874              LDR      r0,|L361.612|
000094  e9cd0100          STRD     r0,r1,[sp,#0]
000098  a373              ADR      r3,|L361.616|
00009a  a281              ADR      r2,|L361.672|
00009c  a184              ADR      r1,|L361.688|
00009e  2005              MOVS     r0,#5
0000a0  f7fffffe          BL       _Anki_Log
                  |L361.164|
0000a4  a83e              ADD      r0,sp,#0xf8
0000a6  f8c49008          STR      r9,[r4,#8]
0000aa  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
0000ae  4602              MOV      r2,r0
0000b0  4649              MOV      r1,r9
0000b2  4650              MOV      r0,r10
0000b4  9b3f              LDR      r3,[sp,#0xfc]
0000b6  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000ba  9601              STR      r6,[sp,#4]
0000bc  9933              LDR      r1,[sp,#0xcc]
0000be  4603              MOV      r3,r0
0000c0  9100              STR      r1,[sp,#0]
0000c2  465a              MOV      r2,r11
0000c4  4620              MOV      r0,r4
0000c6  9940              LDR      r1,[sp,#0x100]
0000c8  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferE ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)
0000cc  a834              ADD      r0,sp,#0xd0
0000ce  462b              MOV      r3,r5
0000d0  ed9f9a82          VLDR     s18,|L361.732|
0000d4  2100              MOVS     r1,#0
0000d6  ed8d9a34          VSTR     s18,[sp,#0xd0]
0000da  ed8d9a35          VSTR     s18,[sp,#0xd4]
                  |L361.222|
0000de  eb0302c1          ADD      r2,r3,r1,LSL #3
0000e2  ed900a00          VLDR     s0,[r0,#0]
0000e6  edd20a00          VLDR     s1,[r2,#0]
0000ea  1c49              ADDS     r1,r1,#1
0000ec  2904              CMP      r1,#4
0000ee  ee300a20          VADD.F32 s0,s0,s1
0000f2  ed800a00          VSTR     s0,[r0,#0]
0000f6  ed900a01          VLDR     s0,[r0,#4]
0000fa  edd20a01          VLDR     s1,[r2,#4]
0000fe  ee300a20          VADD.F32 s0,s0,s1
000102  ed800a01          VSTR     s0,[r0,#4]
000106  dbea              BLT      |L361.222|
000108  edd00a00          VLDR     s1,[r0,#0]
00010c  eeb50a00          VMOV.F32 s0,#0.25000000
000110  2400              MOVS     r4,#0
000112  ee600a80          VMUL.F32 s1,s1,s0
000116  edc00a00          VSTR     s1,[r0,#0]
00011a  edd00a01          VLDR     s1,[r0,#4]
00011e  ee200a80          VMUL.F32 s0,s1,s0
000122  ed800a01          VSTR     s0,[r0,#4]
                  |L361.294|
000126  eb0500c4          ADD      r0,r5,r4,LSL #3
00012a  eddd0a34          VLDR     s1,[sp,#0xd0]
00012e  ed900a00          VLDR     s0,[r0,#0]
000132  9a2b              LDR      r2,[sp,#0xac]
000134  992d              LDR      r1,[sp,#0xb4]
000136  ee708a60          VSUB.F32 s17,s0,s1
00013a  ed900a01          VLDR     s0,[r0,#4]
00013e  eddd0a35          VLDR     s1,[sp,#0xd4]
000142  2000              MOVS     r0,#0
000144  eef58ac0          VCMPE.F32 s17,#0.0
000148  ee308a60          VSUB.F32 s16,s0,s1
00014c  fb001002          MLA      r0,r0,r2,r1
000150  eef1fa10          VMRS     APSR_nzcv,FPSCR
000154  eb000684          ADD      r6,r0,r4,LSL #2
000158  bf02              ITTT     EQ
00015a  eeb58ac0          VCMPEEQ.F32 s16,#0.0
00015e  eef1fa10          VMRSEQ   APSR_nzcv,FPSCR
000162  ed869a00          VSTREQ   s18,[r6,#0]
000166  d016              BEQ      |L361.406|
000168  eef00a68          VMOV.F32 s1,s17
00016c  eeb00a48          VMOV.F32 s0,s16
000170  f7fffffe          BL       __hardfp_atan2f
000174  ee680aa8          VMUL.F32 s1,s17,s17
000178  ed860a00          VSTR     s0,[r6,#0]
00017c  ee480a08          VMLA.F32 s1,s16,s16
000180  eeb10ae0          VSQRT.F32 s0,s1
000184  eeb40a40          VCMP.F32 s0,s0
000188  eef1fa10          VMRS     APSR_nzcv,FPSCR
00018c  bf1c              ITT      NE
00018e  eeb00a60          VMOVNE.F32 s0,s1
000192  f7fffffe          BLNE     __hardfp_sqrtf
                  |L361.406|
000196  1c64              ADDS     r4,r4,#1
000198  2c04              CMP      r4,#4
00019a  dbc4              BLT      |L361.294|
00019c  4850              LDR      r0,|L361.736|
00019e  2301              MOVS     r3,#1
0001a0  e9cd7000          STRD     r7,r0,[sp,#0]
0001a4  461a              MOV      r2,r3
0001a6  a92e              ADD      r1,sp,#0xb8
0001a8  a829              ADD      r0,sp,#0xa4
0001aa  f7fffffe          BL       _ZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibii ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)
0001ae  9930              LDR      r1,[sp,#0xc0]
0001b0  9832              LDR      r0,[sp,#0xc8]
0001b2  2304              MOVS     r3,#4
0001b4  fb070001          MLA      r0,r7,r1,r0
0001b8  2208              MOVS     r2,#8
0001ba  6801              LDR      r1,[r0,#0]
0001bc  eb0501c1          ADD      r1,r5,r1,LSL #3
0001c0  ed910a00          VLDR     s0,[r1,#0]
0001c4  edd10a01          VLDR     s1,[r1,#4]
0001c8  ed8d0a36          VSTR     s0,[sp,#0xd8]
0001cc  edcd0a37          VSTR     s1,[sp,#0xdc]
0001d0  6841              LDR      r1,[r0,#4]
0001d2  eb0501c1          ADD      r1,r5,r1,LSL #3
0001d6  ed910a00          VLDR     s0,[r1,#0]
0001da  edd10a01          VLDR     s1,[r1,#4]
0001de  ed8d0a38          VSTR     s0,[sp,#0xe0]
0001e2  edcd0a39          VSTR     s1,[sp,#0xe4]
0001e6  6881              LDR      r1,[r0,#8]
0001e8  eb0501c1          ADD      r1,r5,r1,LSL #3
0001ec  ed910a00          VLDR     s0,[r1,#0]
0001f0  edd10a01          VLDR     s1,[r1,#4]
0001f4  ed8d0a3a          VSTR     s0,[sp,#0xe8]
0001f8  edcd0a3b          VSTR     s1,[sp,#0xec]
0001fc  68c0              LDR      r0,[r0,#0xc]
0001fe  4939              LDR      r1,|L361.740|
000200  eb0500c0          ADD      r0,r5,r0,LSL #3
000204  ed900a00          VLDR     s0,[r0,#0]
000208  edd00a01          VLDR     s1,[r0,#4]
00020c  ed8d0a3c          VSTR     s0,[sp,#0xf0]
000210  edcd0a3d          VSTR     s1,[sp,#0xf4]
000214  4640              MOV      r0,r8
000216  f7fffffe          BL       __aeabi_vec_ctor_nocookie_nodtor
00021a  ed9d0a36          VLDR     s0,[sp,#0xd8]
00021e  ed800a00          VSTR     s0,[r0,#0]
000222  ed9d0a37          VLDR     s0,[sp,#0xdc]
000226  ed800a01          VSTR     s0,[r0,#4]
00022a  ed9d0a38          VLDR     s0,[sp,#0xe0]
00022e  ed800a02          VSTR     s0,[r0,#8]
000232  ed9d0a39          VLDR     s0,[sp,#0xe4]
000236  ed800a03          VSTR     s0,[r0,#0xc]
00023a  ed9d0a3a          VLDR     s0,[sp,#0xe8]
00023e  ed800a04          VSTR     s0,[r0,#0x10]
000242  ed9d0a3b          VLDR     s0,[sp,#0xec]
000246  ed800a05          VSTR     s0,[r0,#0x14]
00024a  ed9d0a3c          VLDR     s0,[sp,#0xf0]
00024e  ed800a06          VSTR     s0,[r0,#0x18]
000252  ed9d0a3d          VLDR     s0,[sp,#0xf4]
000256  ed800a07          VSTR     s0,[r0,#0x1c]
00025a  b045              ADD      sp,sp,#0x114
00025c  ecbd8b04          VPOP     {d8-d9}
000260  e8bd8ff0          POP      {r4-r11,pc}
;;;270    
;;;271          template<typename OutType> Quadrilateral<OutType> ComputeRotatedCorners(const f32 radians) const;
;;;272    
;;;273          bool IsConvex() const;
;;;274    
;;;275          bool operator== (const Quadrilateral<Type> &quad2) const;
;;;276    
;;;277          Quadrilateral<Type> operator+ (const Quadrilateral<Type> &quad2) const;
;;;278    
;;;279          Quadrilateral<Type> operator- (const Quadrilateral<Type> &quad2) const;
;;;280    
;;;281          inline Quadrilateral<Type>& operator= (const Quadrilateral<Type> &quad2);
;;;282    
;;;283          // Keeping this explicit to avoid accidental setting of quads of
;;;284          // different types
;;;285          template<typename InType> void SetCast(const Quadrilateral<InType> &quad2);
;;;286    
;;;287          inline const Point<Type>& operator[] (const s32 index) const;
;;;288          inline Point<Type>& operator[] (const s32 index);
;;;289        }; // class Quadrilateral<Type>
;;;290      } // namespace Embedded
;;;291    } // namespace Anki
;;;292    
;;;293    #endif // _ANKICORETECHEMBEDDED_COMMON_POINT_DECLARATIONS_H_
;;;20     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;21     #include "anki/common/robot/sequences_declarations.h"
;;;1      /**
;;;2      File: sequences_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      A Sequence is a mathematically-defined, ordered list. The sequence classes allow for operations on sequences, without requiring them to be explicitly evaluated.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/flags_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> class Array;
;;;23         template<typename Type> class FixedLengthList;
;;;24         template<typename Type> class ArraySlice;
;;;25         class MemoryStack;
;;;26     
;;;27         // #pragma mark --- Class Declarations ---
;;;28         template<typename Type> class Sequence
;;;29         {
;;;30         }; // class Sequence
;;;31     
;;;32         // A LinearSequence is like the result of a call to Matlab's linspace() It has a start, end, and
;;;33         // increment. It does not explicitly compute the values in the sequence, so does not require
;;;34         // much memory.
;;;35         //
;;;36         // WARNING:
;;;37         // The "end" of a LinearSequence is computed automatically, and is less-than-or-equal-to the
;;;38         // requested end.
;;;39         template<typename Type> class LinearSequence : public Sequence<Type>
;;;40         {
;;;41         public:
;;;42     
;;;43           LinearSequence();
;;;44     
;;;45           // Matlab equivalent: start:end
;;;46           LinearSequence(const Type start, const Type end);
;;;47     
;;;48           // Matlab equivalent: start:increment:end
;;;49           LinearSequence(const Type start, const Type increment, const Type end);
;;;50     
;;;51           // No Matlab equivalent
;;;52           // NOTE: end is unused. It is just present to prevent confusion with the other polymorphic constructors
;;;53           LinearSequence(const Type start, const Type increment, const Type end, const s32 size);
;;;54     
;;;55           // Explicitly evaluate each element of the sequence, and put the results in an Array.
;;;56           Array<Type> Evaluate(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;57           Result Evaluate(ArraySlice<Type> out) const;
;;;58     
;;;59           Type get_start() const;
;;;60     
;;;61           // NOTE: The increment is meaningless for LinearSequences of size 0 or 1.
;;;62           Type get_increment() const;
;;;63     
;;;64           // Note: End it not computed, as it is tempting to use it as a loop condition, but it is not safe
;;;65           // Type get_end() const;
;;;66     
;;;67           // Matlab equivalent: length(start:increment:end)
;;;68           s32 get_size() const;
;;;69     
;;;70         protected:
;;;71           // For speed, FixedLengthList is allowed to access protected members, instead of having to
;;;72           // construct a new LinearSequence every time an element is popped or pushed
;;;73           template<typename FixedLengthListType> friend class FixedLengthList;
;;;74     
;;;75           s32 size;
;;;76     
;;;77           Type start;
;;;78           Type increment;
;;;79     
;;;80           static s32 computeSize(const Type start, const Type increment, const Type end);
;;;81         }; // class LinearSequence
;;;82     
;;;83         // IndexSequence creates the input for slicing an Array
;;;84         // If start or end is less than 0, it is equivalent to (end+value)
;;;85         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type end, s32 arraySize);
;;;86         template<typename Type> LinearSequence<Type> IndexSequence(Type start, Type increment, Type end, s32 arraySize);
;;;87         LinearSequence<s32> IndexSequence(s32 arraySize); // Internally, it sets start==0, end=arraySize-1, like the Matlab colon operator array(:,:)
;;;88     
;;;89         // Linspace only works correctly for f32 and f64. To prevent misusage, trying ints will give a linker error.
;;;90         template<typename Type> LinearSequence<Type> Linspace(const Type start, const Type end, const s32 size);
;;;91     
;;;92         // These do not link, as they are unsafe
;;;93         template<> LinearSequence<u8> Linspace(const u8 start, const u8 end, const s32 size);
;;;94         template<> LinearSequence<s8> Linspace(const s8 start, const s8 end, const s32 size);
;;;95         template<> LinearSequence<u16> Linspace(const u16 start, const u16 end, const s32 size);
;;;96         template<> LinearSequence<s16> Linspace(const s16 start, const s16 end, const s32 size);
;;;97         template<> LinearSequence<u32> Linspace(const u32 start, const u32 end, const s32 size);
;;;98         template<> LinearSequence<s32> Linspace(const s32 start, const s32 end, const s32 size);
;;;99         template<> LinearSequence<u64> Linspace(const u64 start, const u64 end, const s32 size);
;;;100        template<> LinearSequence<s64> Linspace(const s64 start, const s64 end, const s32 size);
;;;101    
;;;102        // TODO: Logspace
;;;103        //template<typename Type> class Logspace : public Sequence<Type>
;;;104        //{
;;;105        //public:
;;;106        //protected:
;;;107        //};
;;;108    
;;;109        // A Meshgrid is like the result of a call to Matlab's meshgrid(). It is made of two
;;;110        // LinearSequence objects, so does not require much memory.
;;;111        template<typename Type> class Meshgrid
;;;112        {
;;;113        public:
;;;114          Meshgrid();
;;;115    
;;;116          // Matlab equivalent: meshgrid(xGridVector, yGridVector)
;;;117          Meshgrid(const LinearSequence<Type> xGridVector, const LinearSequence<Type> yGridVector);
;;;118    
;;;119          // Allocate an Array, and evaluate this Meshgrid object
;;;120          //
;;;121          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;122          // The first suffix X or Y is for the xGrid vs yGrid
;;;123          // The second suffix 1 or 2 is for 1D vs 2D output
;;;124          Array<Type> EvaluateX1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;125          Array<Type> EvaluateX2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;126          Array<Type> EvaluateY1(bool isOutColumnMajor, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;127          Array<Type> EvaluateY2(MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false)) const;
;;;128    
;;;129          // Evaluate this Meshgrid object into a pre-allocated Array
;;;130          //
;;;131          // If isOutColumnMajor==true, then the output vector will be column-major(like Matlab)
;;;132          Result EvaluateX1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;133          Result EvaluateX2(ArraySlice<Type> out) const;
;;;134          Result EvaluateY1(bool isOutColumnMajor, ArraySlice<Type> out) const;
;;;135          Result EvaluateY2(ArraySlice<Type> out) const;
;;;136    
;;;137          s32 get_numElements() const;
;;;138    
;;;139          inline const LinearSequence<Type>& get_xGridVector() const;
;;;140    
;;;141          inline const LinearSequence<Type>& get_yGridVector() const;
;;;142    
;;;143        protected:
;;;144          LinearSequence<Type> xGridVector;
;;;145          LinearSequence<Type> yGridVector;
;;;146        };
;;;147      } // namespace Embedded
;;;148    } //namespace Anki
;;;149    
;;;150    #endif // #ifndef _ANKICORETECHEMBEDDED_COMMON_SEQUENCES_DECLARATIONS_H_
;;;22     
;;;23     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;24     namespace cv
;;;25     {
;;;26       class Mat;
;;;27       template<typename Type> class Mat_;
;;;28     }
;;;29     #endif
;;;30     
;;;31     namespace Anki
;;;32     {
;;;33       namespace Embedded
;;;34       {
;;;35         template<typename Type> class ArraySlice;
;;;36         template<typename Type> class ConstArraySlice;
;;;37         template<typename Type> class ConstArraySliceExpression;
;;;38     
;;;39         const s32 ARRAY_FILE_HEADER_LENGTH = 32;
;;;40         const s32 ARRAY_FILE_HEADER_VALID_LENGTH = 14; //< How many characters are not spaces
;;;41         const char ARRAY_FILE_HEADER[ARRAY_FILE_HEADER_LENGTH+1] = "\x89" "AnkiEArray1.2                  ";
;;;42     
;;;43         // #pragma mark --- Array Class Declaration ---
;;;44     
;;;45         template<typename Type> class Array
;;;46         {
;;;47         public:
;;;48     
;;;49           // The stride is the "numCols*sizeof(Type)" rounded up by 16, plus any boundary padding
;;;50           static s32 ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags);
;;;51     
;;;52           // The minimum required memory is the size of a stride, times the number of rows
;;;53           static s32 ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags);
;;;54     
;;;55           // Initializes Array as invalid
;;;56           Array();
;;;57     
;;;58           // Constructor for a Array, pointing to user-allocated MemoryStack. This is the preferred
;;;59           // method for creating a new Array.
;;;60           //
;;;61           // Flags::Buffer.isFullyAllocated doesn't do anything
;;;62           Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;63     
;;;64           // Constructor for a Array, pointing to user-allocated data. This type of array is more
;;;65           // restrictive than most matrix libraries. For example, it may make it hard to convert from
;;;66           // OpenCV::Mat to Array, though the reverse is trivial.
;;;67           //
;;;68           // If following are true, then the contents of data will not be modified, and it will work as
;;;69           // a normal buffer without extra zeros as stride padding:
;;;70           // 1. (numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0
;;;71           // 2. reinterpret_cast<size_t>(data) % MEMORY_ALIGNMENT == 0
;;;72           // 3. numRows*numCols*sizeof(Type) <= dataLength
;;;73           //
;;;74           // If Flags::Buffer.isFullyAllocated == true, then the input data buffer's stride must be a
;;;75           // simple multiple
;;;76           Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags=Flags::Buffer(false,false,true));
;;;77     
;;;78           // Load an image from file. Requires OpenCV;
;;;79           static Array<Type> LoadImage(const char * filename, MemoryStack &memory);
;;;80     
;;;81           // Load or save an array saved as a debugStream.
;;;82           // compressionLevel can be from 0 (uncompressed) to 9 (most compressed). If OpenCV is not used, it must be zero.
;;;83           static Array<Type> LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory);
;;;84           static Array<Type> LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength); //< allocatedBuffer must be allocated and freed manually
;;;85           Result SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const;
;;;86     
;;;87           // Pointer to the data, at a given (y,x) location
;;;88           //
;;;89           // NOTE:
;;;90           // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;91           // inner loop, like: "Type * restrict pArray = Array.Pointer(5);", then index
;;;92           // pArray in the inner loop.
;;;93           inline const Type* Pointer(const s32 index0, const s32 index1) const;
;;;94           inline Type* Pointer(const s32 index0, const s32 index1);
;;;95     
;;;96           // Use this operator for normal C-style 2d matrix indexing. For example, "array[5][0] = 6;"
;;;97           // will set the element in the fifth row and first column to 6. This is the same as
;;;98           // "array.Pointer(5)[0] = 6;"
;;;99           //
;;;100          // NOTE:
;;;101          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;102          // inner loop, like: "Type * restrict pArray = Array[5];", then index
;;;103          // pArray in the inner loop.
;;;104          inline const Type * operator[](const s32 index0) const;
;;;105          inline Type * operator[](const s32 index0);
;;;106    
;;;107          // Pointer to the data, at a given (y,x) location
;;;108          //
;;;109          // NOTE:
;;;110          // The default order of coordinates for the Point() constructor is (x,y). So for example,
;;;111          // access Array[5][3] via Array.Pointer(Point<s16>(3,5))
;;;112          //
;;;113          // NOTE:
;;;114          // Using this in a inner loop is very inefficient. Instead, declare a pointer outside the
;;;115          // inner loop, like: "Type * restrict pArray = Array.Pointer(Point<s16>(5,0));", then index
;;;116          // pArray in the inner loop.
;;;117          inline const Type* Pointer(const Point<s16> &point) const;
;;;118          inline Type* Pointer(const Point<s16> &point);
;;;119    
;;;120          // Get the ith element, like Matlab's 1D indexing of a 2D array.
;;;121          // For example, the 5th element of Arrays of size (1,6) and (6,1) is the same;
;;;122          const Type& Element(const s32 elementIndex) const;
;;;123          Type& Element(const s32 elementIndex);
;;;124    
;;;125          // Return a slice accessor for this array, like the Matlab expression "array(1:5, 2:3:5)"
;;;126          //
;;;127          // NOTE:
;;;128          // If min or max is less than 0, it is equivalent to (end+value). For example, "Array(0,-1,3,5)"
;;;129          // is the same as "Array(0,arrayHeight-1,3,5)"
;;;130          ArraySlice<Type> operator() ();
;;;131          ArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;132          ArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX);
;;;133          ArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX);
;;;134          ConstArraySlice<Type> operator() () const;
;;;135          ConstArraySlice<Type> operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const;
;;;136          ConstArraySlice<Type> operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const;
;;;137          ConstArraySlice<Type> operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const;
;;;138    
;;;139          // ArraySlice Transpose doesn't modify the data, it just sets an "isTransposed" flag.
;;;140          // Anything that uses ArraySliceExpression respects this flag. This doesn't include things
;;;141          // like Matrix::Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out) for example.
;;;142          ConstArraySliceExpression<Type> Transpose() const;
;;;143    
;;;144    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;145          // Copies the OpenCV Mat. If needed, it converts from color to grayscale by averaging the color channels.
;;;146          s32 Set(const cv::Mat_<Type> &in);
;;;147    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;148    
;;;149          // Use the simple OpenCV gui to display this array as an image
;;;150          // Does nothing is OpenCV is not available
;;;151          void Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues=false, const bool fitImageToWindow=false) const;
;;;152    
;;;153          // Print out the contents of this Array
;;;154          //
;;;155          // NOTE:
;;;156          // * If the min X or Y is less than zero, it will be treated as zero
;;;157          // * If the max X or Y is greater than the size of the array minus one, it will be treated as
;;;158          //   the size of the array minus one
;;;159          Result Print(const char * const variableName = "Array", const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;160          Result PrintAlternate(const char * const variableName = "Array", const s32 version=2, const s32 minY = 0, const s32 maxY = 0x7FFFFFE, const s32 minX = 0, const s32 maxX = 0x7FFFFFE) const;
;;;161    
;;;162          // Checks if this array is equal to another array, up to some allowable
;;;163          // per-element varation, epsilon. If the arrays are not the same size,
;;;164          // false is returned.
;;;165          bool IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const;
;;;166    
;;;167          // Checks the basic parameters of this Array, and if it is allocated.
;;;168          bool IsValid() const;
;;;169    
;;;170          // Resize will use MemoryStack::Reallocate() to change the Array's size. It only works if this
;;;171          // Array was the last thing allocated. The reallocated memory will not be cleared
;;;172          //
;;;173          // WARNING:
;;;174          // This will not update any references to the memory, you must update all references manually.
;;;175          Result Resize(const s32 numRows, const s32 numCols, MemoryStack &memory);
;;;176    
;;;177          // Set every element in the Array to zero, including the stride padding.
;;;178          // Returns the number of bytes set to zero
;;;179          s32 SetZero();
;;;180    
;;;181          // Set every element in the Array to this value
;;;182          // Returns the number of values set
;;;183          s32 Set(const Type value);
;;;184    
;;;185          // Elementwise copies the input Array into this array. No memory is allocated.
;;;186          s32 Set(const Array<Type> &in);
;;;187    
;;;188          // Copy values to this Array.
;;;189          // If the input array does not contain enough elements, the remainder of this Array will be filled with zeros.
;;;190          // Returns the number of values set (not counting extra zeros)
;;;191          s32 Set(const Type * const values, const s32 numValues);
;;;192    
;;;193          // Read in the input, then cast it to this object's type
;;;194          //
;;;195          // WARNING:
;;;196          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;197          template<typename InType> s32 SetCast(const Array<InType> &in);
;;;198          template<typename InType> s32 SetCast(const InType * const values, const s32 numValues);
;;;199    
;;;200          // This is a shallow copy. There's no reference counting. Updating the data of one array will
;;;201          // update that of others (because they point to the same location in memory).
;;;202          // However, Resizing or other operations on one array won't update the others.
;;;203          Array& operator= (const Array & rightHandSide);
;;;204    
;;;205          // Similar to Matlabs size(matrix, dimension), and dimension is in {0,1}
;;;206          s32 get_size(s32 dimension) const;
;;;207    
;;;208          // Get the stride, which is the number of bytes between an element at (n,m) and an element at (n+1,m)
;;;209          s32 get_stride() const;
;;;210    
;;;211          // just size[0] * size[1]
;;;212          s32 get_numElements() const;
;;;213    
;;;214          // Return the flags that were used when this object was constructed.
;;;215          Flags::Buffer get_flags() const;
;;;216    
;;;217          // Equivalent to Pointer(0,0)
;;;218          //
;;;219          // These are for very low-level access to the buffers. Probably you want to be using one of
;;;220          // the Pointer() accessor methods instead of these.
;;;221          void* get_buffer();
;;;222          const void* get_buffer() const;
;;;223    
;;;224        protected:
;;;225          static const s32 HEADER_LENGTH = 8;
;;;226          static const s32 FOOTER_LENGTH = 8;
;;;227    
;;;228          s32 size[2];
;;;229          s32 stride;
;;;230          Flags::Buffer flags;
;;;231    
;;;232          Type * data;
;;;233    
;;;234          // Basic allocation method
;;;235          void* AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate);
;;;236    
;;;237          // Performs checks and sets appropriate parameters for this object
;;;238          Result InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags);
;;;239    
;;;240          // Set all the buffers and sizes to zero, to signal an invalid array
;;;241          void InvalidateArray();
;;;242    
;;;243          // If this object's Type is a basic type, this method prints out this object.
;;;244          Result PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;245    
;;;246          // If this object's Type is a string, this method prints out this object.
;;;247          Result PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;248        }; // class Array
;;;249    
;;;250        // #pragma mark --- FixedPointArray Class Declaration ---
;;;251    
;;;252        template<typename Type> class FixedPointArray : public Array<Type>
;;;253        {
;;;254        public:
;;;255          FixedPointArray();
;;;256    
;;;257          // Same as Array() constructor
;;;258          // This is the preferred method for constructing an FixedPointArray
;;;259          FixedPointArray(const s32 numRows, const s32 numCols, const s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;260    
;;;261          // Same as Array() constructor
;;;262          // This is the advanced method for constructing an FixedPointArray
;;;263          FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;264    
;;;265          s32 get_numFractionalBits() const;
;;;266    
;;;267        protected:
;;;268          s32 numFractionalBits;
;;;269        };
;;;270    
;;;271        // If you don't know the type of the Array you're loading, use this function directly, then cast it based on the read parameters
;;;272        Array<u8> LoadBinaryArray_UnknownType(
;;;273          const char * filename,
;;;274          MemoryStack *scratch,
;;;275          MemoryStack *memory,
;;;276          void * allocatedBuffer,
;;;277          const s32 allocatedBufferLength,
;;;278          u16  &basicType_sizeOfType,
;;;279          bool &basicType_isBasicType,
;;;280          bool &basicType_isInteger,
;;;281          bool &basicType_isSigned,
;;;282          bool &basicType_isFloat,
;;;283          bool &basicType_isString
;;;284          );
;;;285    
;;;286    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;287        // Returns a cv::Mat that mirrors the data in the input Array.
;;;288        // WARNING: If you copy the cv::Mat or assign it incorrectly, it will no longer mirror the input Array
;;;289        // WARNING: This const_casts the input array, so you can unsafely modify it via the output cv::Mat
;;;290        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out);
;;;291    #endif
;;;292      } // namespace Embedded
;;;293    } //namespace Anki
;;;294    
;;;295    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_DECLARATIONS_H_
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;2      File: arraySlices_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      An array slice is a sub-array of an Array object.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Class Declarations ---
;;;23     
;;;24         template<typename Type> class ConstArraySlice;
;;;25         template<typename Type> class ArraySlice;
;;;26         template<typename Type> class ConstArraySliceExpression;
;;;27     
;;;28         // An ArraySlice is a simple indexing wrapper on top of an Array. The slice of an Array could be
;;;29         // a sub-rectangle of an array and/or skip every n-th element.
;;;30         //
;;;31         // For example, Array(0,3,-1,1,2,4) is the same as Matlab's array(1:3:end, 2:2:5).
;;;32         // (The Array indexing starts from zero vs Matlab's one, hence the different numbers).
;;;33         //
;;;34         // TODO: support non-int indexes
;;;35         // TODO: is there a better way of doing this than a completely different class, different only
;;;36         //       by const?
;;;37         template<typename Type> class ConstArraySlice
;;;38         {
;;;39         public:
;;;40           ConstArraySlice();
;;;41     
;;;42           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;43           ConstArraySlice(const Array<Type> &array);
;;;44     
;;;45           // It's probably easier to call array.operator() than this constructor directly
;;;46           ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;47     
;;;48           // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;49           ConstArraySliceExpression<Type> Transpose() const;
;;;50     
;;;51           bool IsValid() const;
;;;52     
;;;53           const LinearSequence<s32>& get_ySlice() const;
;;;54     
;;;55           const LinearSequence<s32>& get_xSlice() const;
;;;56     
;;;57           // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;58           // don't support the full ArraySlice type, and should be used with caution.
;;;59           const Array<Type>& get_array() const;
;;;60     
;;;61         protected:
;;;62           LinearSequence<s32> ySlice;
;;;63           LinearSequence<s32> xSlice;
;;;64     
;;;65           Array<Type> array;
;;;66     
;;;67           // For speed, this is a direct pointer to the Array's protected data
;;;68           const Type * constArrayData;
;;;69         }; // template<typename Type> class ArraySlice
;;;70     
;;;71         // A non-const version of ConstArraySlice, see ConstArraySlice for details
;;;72         //
;;;73         // WARNING: A "const ArraySlice" doesn't have a const Array. Only ConstArraySlice has a const
;;;74         //          Array. This allows for implicit conversion to non-const function parameters.
;;;75         template<typename Type> class ArraySlice : public ConstArraySlice<Type>
;;;76         {
;;;77         public:
;;;78           ArraySlice();
;;;79     
;;;80           // Directly convert an array to an ArraySlice, so all Arrays can be used as input
;;;81           // The Array parameter is not a reference, to allow for implicit conversion
;;;82           ArraySlice(Array<Type> array);
;;;83     
;;;84           // It's probably easier to call array.operator() than this constructor directly
;;;85           // The Array parameter is not a reference, to allow for implicit conversion
;;;86           ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice);
;;;87     
;;;88           // If automaticTranspose==true, then you can set a MxN slice with a NxM input.
;;;89           // Matlab allows this for vectors, though this method will also work for
;;;90           // arbitrary-sized arrays.
;;;91           s32 Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose=true);
;;;92     
;;;93           // Explicitly evaluate the input LinearSequence into this ArraySlice
;;;94           s32 Set(const LinearSequence<Type> &input);
;;;95     
;;;96           // Set all values of this slice to the given value.
;;;97           //
;;;98           // For example, "array(0,-1,1,4).Set(5);" is the same as
;;;99           // Matlab's "array(1:end, 2:5) = 5;"
;;;100          s32 Set(const Type value);
;;;101    
;;;102          // Copy values to this ArraySlice.
;;;103          // numValues must be equal to the number of values in this slice
;;;104          // Returns the number of values set
;;;105          s32 Set(const Type * const values, const s32 numValues);
;;;106    
;;;107          // Read in the input, then cast it to this object's type
;;;108          //
;;;109          // WARNING:
;;;110          // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;111          template<typename InType> s32 SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose);
;;;112          //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;113    
;;;114          // Get the raw Array from the Slice. This is mainly useful for interfacing with functions that
;;;115          // don't support the full ArraySlice type, and should be used with caution.
;;;116          Array<Type>& get_array();
;;;117    
;;;118        protected:
;;;119    
;;;120          // For speed, this is a direct pointer to the Array's protected data
;;;121          Type * arrayData;
;;;122        }; // template<typename Type> class ArraySlice
;;;123    
;;;124        // An ConstArraySliceExpression is like a ConstArraySlice, but can also be transposed
;;;125        // It may have other abilities in the future, but will probably always be const
;;;126        template<typename Type> class ConstArraySliceExpression : public ConstArraySlice<Type>
;;;127        {
;;;128        public:
;;;129          ConstArraySliceExpression();
;;;130    
;;;131          ConstArraySliceExpression(const Array<Type> input, bool isTransposed=false);
;;;132    
;;;133          ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed=false);
;;;134    
;;;135          ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed=false);
;;;136    
;;;137          // ArraySlice Transpose doesn't modify the data, it just sets a flag
;;;138          // This object isn't modified, but the returned object is.
;;;139          ConstArraySliceExpression<Type> Transpose() const;
;;;140    
;;;141          bool get_isTransposed() const;
;;;142    
;;;143        protected:
;;;144          bool isTransposed;
;;;145        };
;;;146    
;;;147        // To simplify the creation of kernels using an ArraySlice, and to aid the compiler optimizer,
;;;148        // an ArraySliceLimits can be initialized at the beginning of the function, then used as the
;;;149        // limits for the inner loops.
;;;150    
;;;151        // The suffix of in# and out# refer to the number of input and output matrices.
;;;152        // If output == 0, then the output is a scalar.
;;;153    
;;;154        template<typename Type> class ArraySliceSimpleLimits
;;;155        {
;;;156        public:
;;;157          Type xStart;
;;;158          Type xIncrement;
;;;159          s32  xSize;
;;;160    
;;;161          Type yStart;
;;;162          Type yIncrement;
;;;163          s32  ySize;
;;;164    
;;;165          ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;166        };
;;;167    
;;;168        // In1 and out0 is a special, ultra-simple case, for one matrix input and a scalar output
;;;169        template<typename Type> class ArraySliceLimits_in1_out0
;;;170        {
;;;171        public:
;;;172          // Was this ArraySliceLimits initialized?
;;;173          bool isValid;
;;;174    
;;;175          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;176    
;;;177          ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice);
;;;178        };
;;;179    
;;;180        // One input, one output
;;;181        template<typename Type> class ArraySliceLimits_in1_out1
;;;182        {
;;;183        public:
;;;184          // Was this ArraySliceLimits initialized?
;;;185          bool isValid;
;;;186    
;;;187          // Can a simple (non-transposed) iteration be performed?
;;;188          bool isSimpleIteration;
;;;189    
;;;190          // These are the current values for the coordinates in the input and output images
;;;191          s32 out1Y;
;;;192          s32 out1X;
;;;193          s32 in1Y;
;;;194          s32 in1X;
;;;195    
;;;196          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;197          s32 ySize;
;;;198          s32 xSize;
;;;199    
;;;200          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;201          // incremented every iteration of the inner loop
;;;202          s32 out1_xInnerIncrement;
;;;203          s32 in1_xInnerIncrement;
;;;204          s32 in1_yInnerIncrement;
;;;205    
;;;206          ArraySliceLimits_in1_out1(
;;;207            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;208            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;209    
;;;210          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;211          inline void OuterIncrementTop();
;;;212    
;;;213          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;214          inline void OuterIncrementBottom();
;;;215    
;;;216        protected:
;;;217          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;218    
;;;219          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;220          bool in1_isTransposed;
;;;221        };
;;;222    
;;;223        // Two inputs, one output
;;;224        template<typename Type> class ArraySliceLimits_in2_out1
;;;225        {
;;;226        public:
;;;227          // Was this ArraySliceLimits initialized?
;;;228          bool isValid;
;;;229    
;;;230          // Can a simple (non-transposed) iteration be performed?
;;;231          bool isSimpleIteration;
;;;232    
;;;233          // These are the current values for the coordinates in the input and output images
;;;234          s32 out1Y;
;;;235          s32 out1X;
;;;236          s32 in1Y;
;;;237          s32 in1X;
;;;238          s32 in2Y;
;;;239          s32 in2X;
;;;240    
;;;241          // The loops will be based on these iterators (these should match with the output's and inputs' sizes)
;;;242          s32 ySize;
;;;243          s32 xSize;
;;;244    
;;;245          // Depending on whether ths input is transposed or not, either its X or Y coordinate should be
;;;246          // incremented every iteration of the inner loop
;;;247          s32 out1_xInnerIncrement;
;;;248          s32 in1_xInnerIncrement;
;;;249          s32 in1_yInnerIncrement;
;;;250          s32 in2_xInnerIncrement;
;;;251          s32 in2_yInnerIncrement;
;;;252    
;;;253          ArraySliceLimits_in2_out1(
;;;254            const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed,
;;;255            const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed,
;;;256            const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice);
;;;257    
;;;258          // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out# and in# values for X and Y.
;;;259          inline void OuterIncrementTop();
;;;260    
;;;261          // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out# and in# values for X and Y.
;;;262          inline void OuterIncrementBottom();
;;;263    
;;;264        protected:
;;;265          ArraySliceSimpleLimits<Type> rawOut1Limits;
;;;266    
;;;267          ArraySliceSimpleLimits<Type> rawIn1Limits;
;;;268          bool in1_isTransposed;
;;;269    
;;;270          ArraySliceSimpleLimits<Type> rawIn2Limits;
;;;271          bool in2_isTransposed;
;;;272        };
;;;273      } // namespace Embedded
;;;274    } // namespace Anki
;;;275    
;;;276    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_DECLARATIONS_H_
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         class SerializedBuffer;
;;;24     
;;;25         // A FixedLengthList is a list with a fixed maximum size, which is allocated at construction.
;;;26         template<typename Type> class FixedLengthList : public ArraySlice<Type>
;;;27         {
;;;28         public:
;;;29           FixedLengthList();
;;;30     
;;;31           // Constructor for a FixedLengthList, pointing to user-allocated data.
;;;32           FixedLengthList(s32 maximumSize, void * data, s32 dataLength, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;33     
;;;34           // Constructor for a FixedLengthList, pointing to user-allocated MemoryStack
;;;35           FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false,false));
;;;36     
;;;37           bool IsValid() const;
;;;38     
;;;39           // Resize will use MemoryStack::Reallocate() to change the FixedLengthList's size. It only works if this
;;;40           // FixedLengthList was the last thing allocated. The reallocated memory will not be cleared
;;;41           //
;;;42           // WARNING:
;;;43           // This will not update any references to the memory, you must update all references manually.
;;;44           Result Resize(s32 maximumSize, MemoryStack &memory);
;;;45     
;;;46           Result PushBack(const Type &value);
;;;47     
;;;48           // Will act as a normal pop, except when the list is empty. Then subsequent
;;;49           // calls will keep returning the first value in the list.
;;;50           Type PopBack();
;;;51     
;;;52           // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
;;;53           inline void Clear();
;;;54     
;;;55           // Does this ever need to be declared explicitly?
;;;56           //FixedLengthList& operator= (const FixedLengthList & rightHandSide);
;;;57     
;;;58           // Pointer to the data, at a given location
;;;59           inline Type* Pointer(const s32 index);
;;;60           inline const Type* Pointer(const s32 index) const;
;;;61     
;;;62           // Use this operator for normal C-style vector indexing. For example, "list[5] = 6;" will set
;;;63           // the element in the fifth row and first column to 6. This is the same as "*list.Pointer(5) =
;;;64           // 6;"
;;;65           //
;;;66           // NOTE:
;;;67           // Using this in a inner loop may be less efficient than using an explicit pointer with a
;;;68           // restrict keyword (Though the runtime cost isn't nearly as large as the [] operator for the
;;;69           // Array class). For speeding up performance-critical inner loops, use something like: "Type *
;;;70           // restrict pList = list.Pointer(0);" outside the inner loop, then index
;;;71           // pList in the inner loop.
;;;72           inline const Type& operator[](const s32 index) const;
;;;73           inline Type& operator[](const s32 index);
;;;74     
;;;75           // Print out the contents of this FixedLengthList
;;;76           Result Print(const char * const variableName = "FixedLengthList", const s32 minIndex = 0, const s32 maxIndex = 0x7FFFFFE) const;
;;;77     
;;;78           // Set every element in the Array to zero, including the stride padding, but not including the optional fill patterns (if they exist)
;;;79           // Returns the number of bytes set to zero
;;;80           inline s32 SetZero();
;;;81     
;;;82           // Read in the input, then cast it to this object's type
;;;83           //
;;;84           // WARNING:
;;;85           // This should be kept explicit, to prevent accidental casting between different datatypes.
;;;86           template<typename InType> s32 SetCast(const FixedLengthList<InType> &input, bool automaticTranspose=true);
;;;87           //template<typename InType> s32 SetCast(const InType * const values, const s32 numValues); // TODO: implement
;;;88     
;;;89           // The maximum size is set at object construction
;;;90           inline s32 get_maximumSize() const;
;;;91     
;;;92           // The current size changes as the FixedLengthList is used
;;;93           inline s32 get_size() const;
;;;94     
;;;95           // Attempt to set the size to newSize. Returns the value that was actually set.
;;;96           s32 set_size(s32 newSize);
;;;97     
;;;98         protected:
;;;99           // TODO: make less hacky
;;;100          friend class SerializedBuffer;
;;;101        }; // class FixedLengthList
;;;102      } // namespace Embedded
;;;103    } //namespace Anki
;;;104    
;;;105    #endif // _ANKICORETECHEMBEDDED_COMMON_FIXEDLENGTHLIST_DECLARATIONS_H_
;;;19     
;;;20     namespace Anki
;;;21     {
;;;22       namespace Embedded
;;;23       {
;;;24         // A 1d, run-length encoded piece of a 2d component
;;;25         // The type is for storing the ID. u16 is enough for QVGA, but VGA and above need s32
;;;26         template<typename Type> class ConnectedComponentSegment
;;;27         {
;;;28         public:
;;;29           // xStart, xEnd, y use array indexes, meaning the first pixel is at (0,0), not (0.5,0.5) like true coordinates
;;;30           s16 xStart, xEnd, y;
;;;31           Type id;
;;;32     
;;;33           ConnectedComponentSegment();
;;;34     
;;;35           ConnectedComponentSegment(const s16 xStart, const s16 xEnd, const s16 y = -1, const Type id = 0);
;;;36     
;;;37           // Returns a positive s64 if a > b, a negative s64 is a < b, or zero if they are identical
;;;38           // The ordering of components is first by id (the ids are sorted in increasing value, but with zero at the end {1...MAX_VALUE,0}), then y, then xStart
;;;39           // TODO: Doublecheck that this is correct for corner cases
;;;40           static inline s64 Compare(const ConnectedComponentSegment<Type> &a, const ConnectedComponentSegment<Type> &b);
;;;41     
;;;42           void Print() const;
;;;43     
;;;44           bool operator== (const ConnectedComponentSegment &component2) const;
;;;45         }; // class ConnectedComponentSegment
;;;46     
;;;47         // Template for ConnectedComponents. See ConnectedComponents for documentation.
;;;48         template<typename Type> class ConnectedComponentsTemplate
;;;49         {
;;;50         public:
;;;51     
;;;52           static Result Extract1dComponents(const u8 * restrict binaryImageRow, const s16 binaryImageWidth, const s16 minComponentWidth, const s16 maxSkipDistance, FixedLengthList<ConnectedComponentSegment<Type> > &extractedComponents);
;;;53     
;;;54           ConnectedComponentsTemplate();
;;;55     
;;;56           ConnectedComponentsTemplate(const Type maxComponentSegments, const s16 maxImageWidth, MemoryStack &memory);
;;;57     
;;;58           Result Extract2dComponents_FullImage(const Array<u8> &binaryImage, const s16 minComponentWidth, const s16 maxSkipDistance, MemoryStack scratch);
;;;59     
;;;60           Result Extract2dComponents_PerRow_Initialize(MemoryStack &fastMemory, MemoryStack &slowerMemory, MemoryStack &slowestMemory);
;;;61           Result Extract2dComponents_PerRow_NextRow(const u8 * restrict binaryImageRow, const s32 imageWidth, const s16 whichRow, const s16 minComponentWidth, const s16 maxSkipDistance);
;;;62           Result Extract2dComponents_PerRow_Finalize();
;;;63     
;;;64           Result SortConnectedComponentSegments();
;;;65     
;;;66           Result SortConnectedComponentSegmentsById(MemoryStack scratch);
;;;67     
;;;68           Result CompressConnectedComponentSegmentIds(MemoryStack scratch);
;;;69     
;;;70           Result ComputeComponentSizes(FixedLengthList<s32> &componentSizes);
;;;71     
;;;72           Result ComputeComponentCentroids(FixedLengthList<Point<s16> > &componentCentroids, MemoryStack scratch);
;;;73     
;;;74           Result ComputeComponentBoundingBoxes(FixedLengthList<Rectangle<s16> > &componentBoundingBoxes);
;;;75     
;;;76           Result ComputeNumComponentSegmentsForEachId(FixedLengthList<s32> &numComponentSegments);
;;;77     
;;;78           Result InvalidateSmallOrLargeComponents(const s32 minimumNumPixels, const s32 maximumNumPixels, MemoryStack scratch);
;;;79     
;;;80           Result InvalidateSolidOrSparseComponents(const s32 sparseMultiplyThreshold, const s32 solidMultiplyThreshold, MemoryStack scratch);
;;;81     
;;;82           Result InvalidateFilledCenterComponents_shrunkRectangle(const s32 percentHorizontal, const s32 percentVertical, MemoryStack scratch);
;;;83     
;;;84           Result InvalidateFilledCenterComponents_hollowRows(const f32 minHollowRatio, MemoryStack scratch);
;;;85     
;;;86           Result PushBack(const ConnectedComponentSegment<Type> &value);
;;;87     
;;;88           // Note that this is a const-only accessor function. The ConnectedComponets class keeps a lot
;;;89           // of tabs on sorting and maximumId and such, so no one else should be directly modifying the
;;;90           // buffers.
;;;91           inline const ConnectedComponentSegment<Type>* Pointer(const s32 index) const;
;;;92           inline const ConnectedComponentSegment<Type>& operator[](const s32 index) const;
;;;93     
;;;94           bool IsValid() const;
;;;95     
;;;96           Result Print() const;
;;;97     
;;;98           Type get_maximumId() const;
;;;99     
;;;100          s32 get_size() const;
;;;101    
;;;102          bool get_isSortedInId() const;
;;;103          bool get_isSortedInY() const;
;;;104          bool get_isSortedInX() const;
;;;105    
;;;106        protected:
;;;107          enum State
;;;108          {
;;;109            STATE_INVALID,
;;;110            STATE_CONSTRUCTED,
;;;111            STATE_INITIALIZED,
;;;112            STATE_FINALIZED
;;;113          };
;;;114    
;;;115          FixedLengthList<ConnectedComponentSegment<Type> > components;
;;;116          FixedLengthList<ConnectedComponentSegment<Type> > currentComponents1d;
;;;117          FixedLengthList<ConnectedComponentSegment<Type> > previousComponents1d;
;;;118          FixedLengthList<ConnectedComponentSegment<Type> > newPreviousComponents1d;
;;;119          FixedLengthList<Type> equivalentComponents;
;;;120    
;;;121          State curState;
;;;122    
;;;123          bool isSortedInId;
;;;124          bool isSortedInY;
;;;125          bool isSortedInX;
;;;126    
;;;127          Type maximumId;
;;;128          s32 maxImageWidth;
;;;129          s32 maxComponentSegments;
;;;130    
;;;131          // Iterate through components, and update the maximum id
;;;132          Result FindMaximumId();
;;;133        }; // class ConnectedComponentsTemplate
;;;134    
;;;135        // A ConnectedComponents class holds a list of ConnectedComponentSegment<Type> objects
;;;136        // It can incrementally parse an input binary image per-row, updating its global list as it goes
;;;137        // It also contains various utilities to remove poor-quality components
;;;138        class ConnectedComponents
;;;139        {
;;;140        public:
;;;141    
;;;142          ConnectedComponents();
;;;143    
;;;144          // Constructor for a ConnectedComponents, pointing to user-allocated MemoryStack
;;;145          // The memory should remain valid for the entire life of the object
;;;146          ConnectedComponents(const s32 maxComponentSegments, const s16 maxImageWidth, MemoryStack &memory); //< This default constructor creates a u16 object
;;;147          ConnectedComponents(const s32 maxComponentSegments, const s16 maxImageWidth, const bool useU16, MemoryStack &memory);
;;;148    
;;;149          // Extract 2d connected components from binaryImage All extracted components are stored in a
;;;150          // single list of ComponentSegments
;;;151          Result Extract2dComponents_FullImage(const Array<u8> &binaryImage, const s16 minComponentWidth, const s16 maxSkipDistance, MemoryStack scratch);
;;;152    
;;;153          // Methods to parse an input binary image per-row, updating this object's global list as it goes
;;;154          //
;;;155          // WARNING:
;;;156          // The memory allocated in Extract2dComponents_PerRow_Initialize() must be valid until
;;;157          // Extract2dComponents_PerRow_Finalize() is called. It does not have to be in the same
;;;158          // location as the memory used by the constructor
;;;159          // Note: fastMemory and slowMemory can be the same object pointing to the same memory
;;;160          Result Extract2dComponents_PerRow_Initialize(MemoryStack &fastMemory, MemoryStack &slowerMemory, MemoryStack &slowestMemory);
;;;161          Result Extract2dComponents_PerRow_NextRow(const u8 * restrict binaryImageRow, const s32 imageWidth, const s16 whichRow, const s16 minComponentWidth, const s16 maxSkipDistance);
;;;162          Result Extract2dComponents_PerRow_Finalize();
;;;163    
;;;164          // Sort the components by id (the ids are sorted in increasing value, but with zero at the end {1...MAX_VALUE,0}), then y, then xStart
;;;165          // WARNING: This method is really slow if called first. If you have the memory available, call SortConnectedComponentSegmentsById() first.
;;;166          Result SortConnectedComponentSegments();
;;;167    
;;;168          // Sort the components by id. This will retain the original ordering as well, so if the
;;;169          // components are already sorted in y, the output of this method will be sorted in id and y.
;;;170          // Requires numValidComponentSegments*sizeof(ConnectedComponentSegment<u16>) bytes of scratch
;;;171          Result SortConnectedComponentSegmentsById(MemoryStack scratch);
;;;172    
;;;173          // The list of components may have unused ids. This function compresses the set of ids, so that
;;;174          // max(ids) == numberOfUniqueValues(ids). For example, the list of ids {0,4,5,7} would be
;;;175          // changed to {0,1,2,3}.
;;;176          //
;;;177          // For a ConnectedComponent that has a maximum id of N, this function requires
;;;178          // 3n + 1 bytes of scratch.
;;;179          //
;;;180          // TODO: If scratch usage is a bigger issue than computation time, this could be done with a bitmask
;;;181          Result CompressConnectedComponentSegmentIds(MemoryStack scratch);
;;;182    
;;;183          // Iterate through components, and compute the number of pixels for each component
;;;184          // componentSizes must be at least sizeof(s32)*(maximumdId+1) bytes
;;;185          // NOTE: this is probably inefficient, compared with interlacing the loops in a kernel
;;;186          Result ComputeComponentSizes(FixedLengthList<s32> &componentSizes);
;;;187    
;;;188          // Iterate through components, and compute the centroid of each component componentCentroids
;;;189          // must be at least sizeof(Point<s16>)*(maximumdId+1) bytes
;;;190          // NOTE: this is probably inefficient, compared with interlacing the loops in a kernel
;;;191          //
;;;192          // For a ConnectedComponent that has a maximum id of N, this function requires
;;;193          // 4n + 4 bytes of scratch.
;;;194          Result ComputeComponentCentroids(FixedLengthList<Point<s16> > &componentCentroids, MemoryStack scratch);
;;;195    
;;;196          // Iterate through components, and compute bounding box for each component
;;;197          // componentBoundingBoxes must be at least sizeof(Rectangle<s16>)*(maximumdId+1) bytes
;;;198          // NOTE: this is probably inefficient, compared with interlacing the loops in a kernel
;;;199          Result ComputeComponentBoundingBoxes(FixedLengthList<Rectangle<s16> > &componentBoundingBoxes);
;;;200    
;;;201          // Iterate through components, and compute the number of componentSegments that have each id
;;;202          // componentSizes must be at least sizeof(s32)*(maximumdId+1) bytes
;;;203          // NOTE: this is probably inefficient, compared with interlacing the loops in a kernel
;;;204          Result ComputeNumComponentSegmentsForEachId(FixedLengthList<s32> &numComponentSegments);
;;;205    
;;;206          // Goes through the list components, and computes the number of pixels for each.
;;;207          // For any componentId with less than minimumNumPixels pixels, all ConnectedComponentSegment<u16> with that id will have their ids set to zero
;;;208          //
;;;209          // For a ConnectedComponent that has a maximum id of N, this function requires
;;;210          // 4n + 4 bytes of scratch.
;;;211          Result InvalidateSmallOrLargeComponents(const s32 minimumNumPixels, const s32 maximumNumPixels, MemoryStack scratch);
;;;212    
;;;213          // Goes through the list components, and computes the "solidness", which is the ratio of
;;;214          // "numPixels / (boundingWidth*boundingHeight)". For any componentId with that is too solid or
;;;215          // sparse (opposite of solid), all ConnectedComponentSegment<u16> with that id will have their ids
;;;216          // set to zero
;;;217          //
;;;218          // The SQ26.5 parameter sparseMultiplyThreshold is set so that a component is invalid if
;;;219          // "sparseMultiplyThreshold*numPixels < boundingWidth*boundingHeight". A resonable value is
;;;220          // between 5<<5 = 160 and 100<<5 = 3200.
;;;221          //
;;;222          // The SQ26.5 parameter solidMultiplyThreshold is set so that a component is invalid if
;;;223          // "solidMultiplyThreshold*numPixels > boundingWidth*boundingHeight". A resonable value is
;;;224          // between 1.5*pow(2,5) = 48 and 5<<5 = 160.
;;;225          //
;;;226          // NOTE: This can overflow if the number of pixels is greater than 2^26 (a bit more Ultra-HD
;;;227          //       resolution)
;;;228          //
;;;229          // For a ConnectedComponent that has a maximum id of N, this function requires 8N + 8 bytes
;;;230          // of scratch.
;;;231          Result InvalidateSolidOrSparseComponents(const s32 sparseMultiplyThreshold, const s32 solidMultiplyThreshold, MemoryStack scratch);
;;;232    
;;;233          // If a component doesn't have a hollow center, it's not a fiducial. Based on a component's
;;;234          // centroid, and its maximum extent, this method makes sure no componentSegment is inside of
;;;235          // an inner rectangle. For example, take a component centered at (50,50), that is 20 pixels
;;;236          // wide and high. If percentHorizontal=0.5 and percentVertical=0.25, then no componentSegment
;;;237          // should intersect the rectangle between (40,45) and (60,55).
;;;238          //
;;;239          // percentHorizontal and percentVertical are SQ23.8,
;;;240          // and should range from (0.0, 1.0), non-inclusive
;;;241          //
;;;242          // For a ConnectedComponent that has a maximum id of N, this function requires 10N + 10 bytes
;;;243          // of scratch.
;;;244          Result InvalidateFilledCenterComponents_shrunkRectangle(const s32 percentHorizontal, const s32 percentVertical, MemoryStack scratch);
;;;245    
;;;246          // Go along each row of components. Find the maximum difference between the end of one
;;;247          // component and the start of the next. The amount of space in the center of a component is
;;;248          // approximated as the sum of the per-row max distances, divided by the number of filled pixels.
;;;249          //
;;;250          // For example:
;;;251          // If minHollowRatio==0.5, this means that a component must have at least half as many interior as exterior pixels.
;;;252          // If minHollowRatio==1.0, this means that a component must have at least an equal number of interior and exterior pixels.
;;;253          // If minHollowRatio==2.0, this means that a component must have at least twice as many interior as exterior pixels.
;;;254          // TODO: what is a reasonable value? 1.0?
;;;255          Result InvalidateFilledCenterComponents_hollowRows(const f32 minHollowRatio, MemoryStack scratch);
;;;256    
;;;257          bool IsValid() const;
;;;258    
;;;259          Result Print() const;
;;;260    
;;;261          s32 get_maximumId() const;
;;;262    
;;;263          s32 get_size() const;
;;;264    
;;;265          bool get_useU16() const;
;;;266    
;;;267          bool get_isSortedInId() const;
;;;268          bool get_isSortedInY() const;
;;;269          bool get_isSortedInX() const;
;;;270    
;;;271          const ConnectedComponentsTemplate<u16>* get_componentsU16() const;
;;;272          const ConnectedComponentsTemplate<s32>* get_componentsS32() const;
;;;273    
;;;274          ConnectedComponentsTemplate<u16>* get_componentsU16();
;;;275          ConnectedComponentsTemplate<s32>* get_componentsS32();
;;;276    
;;;277        protected:
;;;278          // Only one of these classes will be initialized, based on the constructor
;;;279          bool useU16;
;;;280          ConnectedComponentsTemplate<u16> componentsU16;
;;;281          ConnectedComponentsTemplate<s32> componentsS32;
;;;282        }; // class ConnectedComponents
;;;283      } // namespace Embedded
;;;284    } // namespace Anki
;;;285    
;;;286    #endif // _ANKICORETECHEMBEDDED_VISION_VISIONKERNELS_CONNECTEDCOMPONENTS_DECLARATIONS_H_
;;;16     
;;;17     #include "anki/common/types.h"
;;;1      /**
;;;18     #include "anki/common/robot/memory.h"
;;;1      /**
;;;19     #include "anki/common/robot/fixedLengthList.h"
;;;1      /**
;;;2      File: fixedLengthList.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of fixedLenghtList_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_H_
;;;14     
;;;15     #include "anki/common/robot/fixedLengthList_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;1      /**
;;;2      File: utilities.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of utilities_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;14     
;;;15     #include "anki/common/robot/utilities_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;17     #include "anki/common/robot/utilities_c.h"
;;;1      /**
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;2      * File: trig_fast.h
;;;3      *
;;;4      * Author: Kevin Yoon
;;;5      * Created: 22-OCT-2012
;;;6      *
;;;7      * Some trig functions to supplement incomplete math libraries on embedded targets.
;;;8      * Error of all functions is less than +/- 0.01.
;;;9      * For bettery accuracy, lookup tables should be regenerated with u16.
;;;10     *
;;;11     **/
;;;12     #ifndef _TRIG_FAST_H
;;;13     #define _TRIG_FAST_H
;;;14     
;;;15     // When USE_SMALL_LUT defined, a smaller lookup table is used to conserve space.
;;;16     // USE_INTERPOLATION is also automatically defined, since without it answers are probably too wrong to be useful.
;;;17     // If USE_SMALL_LUT is not defined, a large LUT is used.
;;;18     //#define USE_SMALL_LUT
;;;19     
;;;20     // When defined, interpolates between lookup values for higher accuracy.
;;;21     #define USE_INTERPOLATION
;;;22     
;;;23     // Arctangent function based on lookup table
;;;24     // returns answer in radians
;;;25     float atan_fast(float x);
;;;26     
;;;27     // Arcsine function based on lookup table
;;;28     // returns answer in radians
;;;29     float asin_fast(float x);
;;;30     
;;;31     // Arctangent function which uses atan_fast
;;;32     // returns answer in radians
;;;33     float atan2_fast(float y, float x);
;;;34     
;;;35     // Arctangent function which uses asin from math.h
;;;36     // Useful on embedded systems that don't include atan2 in math.h
;;;37     // More accurate than atan2_fast.
;;;38     // Nothing particularly fast about this implementation.
;;;39     // returns answer in radians
;;;40     float atan2_acc(float y, float x);
;;;41     
;;;42     #endif
;;;19     
;;;20     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;21     #include "opencv2/core/core.hpp"
;;;22     #endif
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         //template<typename Type> inline Type RoundUp(const Type number, const Type multiple)
;;;29     
;;;30         // void* and size_t is a special case, good for aligning pointers
;;;31         inline const void* RoundUp(const void* number, const size_t multiple)
;;;32         {
;;;33           const size_t numberT = reinterpret_cast<size_t>(number);
;;;34           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;35         }
;;;36     
;;;37         inline void* RoundUp(void* number, const size_t multiple)
;;;38         {
;;;39           const size_t numberT = reinterpret_cast<size_t>(number);
;;;40           return reinterpret_cast<void*>( (numberT + (multiple-1)) & ~(multiple-1) );
;;;41         }
;;;42     
;;;43         template<> inline u32 RoundUp(const u32 number, const u32 multiple)
;;;44         {
;;;45           return (number + (multiple-1)) & ~(multiple-1);
;;;46         }
;;;47     
;;;48         template<> inline s32 RoundUp(const s32 number, const s32 multiple)
;;;49         {
;;;50           if(number <= 0) {
;;;51             return multiple*( number/multiple );
;;;52           } else {
;;;53             return multiple*( (number-1)/multiple + 1 );
;;;54           }
;;;55         }
;;;56     
;;;57     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;58         template<> inline unsigned long RoundUp(const unsigned long number, const unsigned long multiple)
;;;59         {
;;;60           return (number + (multiple-1)) & ~(multiple-1);
;;;61         }
;;;62     #endif
;;;63     
;;;64         template<> inline u32 RoundDown(const u32 number, const u32 multiple)
;;;65         {
;;;66           return multiple * (number/multiple);
;;;67         }
;;;68     
;;;69         template<> inline s32 RoundDown(const s32 number, const s32 multiple)
;;;70         {
;;;71           if(number < 0) {
;;;72             return multiple * ((number-multiple+1) / multiple);
;;;73           } else {
;;;74             return multiple * (number/multiple);
;;;75           }
;;;76         }
;;;77     
;;;78     #if defined(__APPLE_CC__) || defined(__GNUC__)
;;;79         template<> inline unsigned long RoundDown(const unsigned long number, const unsigned long multiple)
;;;80         {
;;;81           return multiple * (number/multiple);
;;;82         }
;;;83     #endif
;;;84     
;;;85         template<typename Type> Type ApproximateExp(const Type exponent, const s32 numTerms)
;;;86         {
;;;87           AnkiAssert(numTerms > 2);
;;;88     
;;;89           const Type exponentAbs = ABS(exponent);
;;;90     
;;;91           Type sum = static_cast<Type>(1) + exponentAbs;
;;;92     
;;;93           Type numerator = static_cast<Type>(exponentAbs);
;;;94           Type denominator = static_cast<Type>(1);
;;;95           for(s32 i=2; i<=numTerms; i++) {
;;;96             numerator *= exponentAbs;
;;;97             denominator *= i;
;;;98     
;;;99             sum += numerator / denominator;
;;;100          }
;;;101    
;;;102          if(exponent < 0) {
;;;103            sum = static_cast<Type>(1) / sum;
;;;104          }
;;;105    
;;;106          return sum;
;;;107        }
;;;108    
;;;109        template<typename Type> void Swap(Type &a, Type &b)
;;;110        {
;;;111          const Type tmp = a;
;;;112          a = b;
;;;113          b = tmp;
;;;114        } // template<typename Type> Swap(Type a, Type b)
;;;115    
;;;116        template<typename Type> u32 BinaryStringToUnsignedNumber(const FixedLengthList<Type> &bits, bool firstBitIsLow)
;;;117        {
;;;118          u32 number = 0;
;;;119    
;;;120          const s32 numBits = bits.get_size();
;;;121    
;;;122          for(s32 bit=0; bit<numBits; bit++) {
;;;123            if(firstBitIsLow) {
;;;124              if(bit == 0) {
;;;125                number += bits[bit];
;;;126              } else {
;;;127                number += bits[bit] << bit;
;;;128              }
;;;129            } else {
;;;130              if(bit == (numBits-1)) {
;;;131                number += bits[bit];
;;;132              } else {
;;;133                number += bits[bit] << (numBits - bit - 1);
;;;134              }
;;;135            }
;;;136          }
;;;137    
;;;138          return number;
;;;139        }
;;;140    
;;;141        template<typename Type> Type Determinant2x2(const Type a, const Type b, const Type c, const Type d)
;;;142        {
;;;143          return a*d - b*c;
;;;144        }
;;;145    
;;;146        template<typename Type> Type Determinant3x3(const Type a, const Type b, const Type c, const Type d, const Type e, const Type f, const Type g, const Type h, const Type i)
;;;147        {
;;;148          return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
;;;149        }
;;;150    
;;;151        template<typename Type> void Invert3x3(Type &a, Type &b, Type &c, Type &d, Type &e, Type &f, Type &g, Type &h, Type &i)
;;;152        {
;;;153          const Type determinant = Determinant3x3(a,b,c,d,e,f,g,h,i);
;;;154          const Type determinantInverse = static_cast<Type>(1) / determinant;
;;;155    
;;;156          const Type A =  (e*i - f*h);
;;;157          const Type B = -(d*i - f*g);
;;;158          const Type C =  (d*h - e*g);
;;;159          const Type D = -(b*i - c*h);
;;;160          const Type E =  (a*i - c*g);
;;;161          const Type F = -(a*h - b*g);
;;;162          const Type G =  (b*f - c*e);
;;;163          const Type H = -(a*f - c*d);
;;;164          const Type I =  (a*e - b*d);
;;;165    
;;;166          a = A * determinantInverse;
;;;167          b = D * determinantInverse;
;;;168          c = G * determinantInverse;
;;;169          d = B * determinantInverse;
;;;170          e = E * determinantInverse;
;;;171          f = H * determinantInverse;
;;;172          g = C * determinantInverse;
;;;173          h = F * determinantInverse;
;;;174          i = I * determinantInverse;
;;;175        }
;;;176    
;;;177        template<typename Type> void Cart2Pol(const Type x, const Type y, Type &rho, Type &theta)
;;;178        {
;;;179          if (x==0 && y==0) {
;;;180            theta = 0;
;;;181            rho = 0;
;;;182          } else {
;;;183            theta = atan2f(y, x);
;;;184            rho = sqrtf(x*x + y*y);
;;;185          }
;;;186        }
;;;187    
;;;188        template<typename Type> void Pol2Cart(const Type rho, const Type theta, Type &x, Type &y)
;;;189        {
;;;190          x = rho * cosf(theta);
;;;191          y = rho * sinf(theta);
;;;192        }
;;;193    
;;;194        inline s32 FloorS32(f32 x)
;;;195        {
;;;196          return static_cast<s32>(floorf(x));
;;;197        }
;;;198    
;;;199        inline s32 CeilS32(f32 x)
;;;200        {
;;;201          return static_cast<s32>(ceilf(x));
;;;202        }
;;;203    
;;;204    #if !defined(__EDG__)
;;;205        // Some platforms may not round to zero correctly, so do the function calls
;;;206        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(floorf(v + 0.5f)) : 0; }
;;;207        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(floorf(v + 0.5f)) : 0; }
;;;208        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(floorf(v + 0.5f)) : static_cast<s32>(ceilf(v - 0.5f)); }
;;;209        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(floorf(v + 0.5f)) : static_cast<s64>(ceilf(v - 0.5f)); }
;;;210        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;211        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;212    
;;;213        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(floor(v + 0.5)) : 0; }
;;;214        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(floor(v + 0.5)) : 0; }
;;;215        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(floor(v + 0.5)) : static_cast<s32>(ceil(v - 0.5)); }
;;;216        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(floor(v + 0.5)) : static_cast<s64>(ceil(v - 0.5)); }
;;;217        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;218        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;219    #else
;;;220        // The M4 rounds to zero correctly, without the function calls
;;;221        template<> inline u32 Round<u32> (const f32 v) { return (v > 0) ? static_cast<u32>(v + 0.5f) : 0; }
;;;222        template<> inline u64 Round<u64> (const f32 v) { return (v > 0) ? static_cast<u64>(v + 0.5f) : 0; }
;;;223        template<> inline s32 Round<s32> (const f32 v) { return (v > 0) ? static_cast<s32>(v + 0.5f) : static_cast<s32>(v - 0.5f); }
;;;224        template<> inline s64 Round<s64> (const f32 v) { return (v > 0) ? static_cast<s64>(v + 0.5f) : static_cast<s64>(v - 0.5f); }
;;;225        template<> inline f32 Round<f32> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;226        template<> inline f64 Round<f64> (const f32 v) { return (v > 0) ? floorf(v + 0.5f) : ceilf(v - 0.5f); }
;;;227    
;;;228        template<> inline u32 Round<u32> (const f64 v) { return (v > 0) ? static_cast<u32>(v + 0.5) : 0; }
;;;229        template<> inline u64 Round<u64> (const f64 v) { return (v > 0) ? static_cast<u64>(v + 0.5) : 0; }
;;;230        template<> inline s32 Round<s32> (const f64 v) { return (v > 0) ? static_cast<s32>(v + 0.5) : static_cast<s32>(v - 0.5); }
;;;231        template<> inline s64 Round<s64> (const f64 v) { return (v > 0) ? static_cast<s64>(v + 0.5) : static_cast<s64>(v - 0.5); }
;;;232        template<> inline f32 Round<f32> (const f64 v) { return (v > 0) ? static_cast<f32>(floor(v + 0.5)) : static_cast<f32>(ceil(v - 0.5)); }
;;;233        template<> inline f64 Round<f64> (const f64 v) { return (v > 0) ? floor(v + 0.5) : ceil(v - 0.5); }
;;;234    #endif
;;;235    
;;;236        // Most cases of RoundIfInteger are from int-to-int or float-to-float, so just do a normal cast
;;;237        template<typename Type> inline Type RoundIfInteger(const u8  v) { return static_cast<Type>(v); }
;;;238        template<typename Type> inline Type RoundIfInteger(const s8  v) { return static_cast<Type>(v); }
;;;239        template<typename Type> inline Type RoundIfInteger(const u16 v) { return static_cast<Type>(v); }
;;;240        template<typename Type> inline Type RoundIfInteger(const s16 v) { return static_cast<Type>(v); }
;;;241        template<typename Type> inline Type RoundIfInteger(const u32 v) { return static_cast<Type>(v); }
;;;242        template<typename Type> inline Type RoundIfInteger(const s32 v) { return static_cast<Type>(v); }
;;;243        template<typename Type> inline Type RoundIfInteger(const u64 v) { return static_cast<Type>(v); }
;;;244        template<typename Type> inline Type RoundIfInteger(const s64 v) { return static_cast<Type>(v); }
;;;245        template<typename Type> inline Type RoundIfInteger(const f32 v) { return static_cast<Type>(v); }
;;;246        template<typename Type> inline Type RoundIfInteger(const f64 v) { return static_cast<Type>(v); }
;;;247    
;;;248        // Specialize for cases with float-to-int
;;;249        template<> inline u8  RoundIfInteger(const f32 v) { return static_cast<u8> (Round<s32>(v)); }
;;;250        template<> inline s8  RoundIfInteger(const f32 v) { return static_cast<s8> (Round<s32>(v)); }
;;;251        template<> inline u16 RoundIfInteger(const f32 v) { return static_cast<u16>(Round<s32>(v)); }
;;;252        template<> inline s16 RoundIfInteger(const f32 v) { return static_cast<s16>(Round<s32>(v)); }
;;;253        template<> inline u32 RoundIfInteger(const f32 v) { return static_cast<u32>(Round<u32>(v)); }
;;;254        template<> inline s32 RoundIfInteger(const f32 v) { return static_cast<s32>(Round<s32>(v)); }
;;;255        template<> inline u64 RoundIfInteger(const f32 v) { return static_cast<u64>(Round<u64>(v)); }
;;;256        template<> inline s64 RoundIfInteger(const f32 v) { return static_cast<s64>(Round<s64>(v)); }
;;;257    
;;;258        template<> inline u8  RoundIfInteger(const f64 v) { return static_cast<u8> (Round<s32>(v)); }
;;;259        template<> inline s8  RoundIfInteger(const f64 v) { return static_cast<s8> (Round<s32>(v)); }
;;;260        template<> inline u16 RoundIfInteger(const f64 v) { return static_cast<u16>(Round<s32>(v)); }
;;;261        template<> inline s16 RoundIfInteger(const f64 v) { return static_cast<s16>(Round<s32>(v)); }
;;;262        template<> inline u32 RoundIfInteger(const f64 v) { return static_cast<u32>(Round<u32>(v)); }
;;;263        template<> inline s32 RoundIfInteger(const f64 v) { return static_cast<s32>(Round<s32>(v)); }
;;;264        template<> inline u64 RoundIfInteger(const f64 v) { return static_cast<u64>(Round<u64>(v)); }
;;;265        template<> inline s64 RoundIfInteger(const f64 v) { return static_cast<s64>(Round<s64>(v)); }
;;;266    
;;;267        // Floats and complex data types aren't specialized
;;;268        template<typename Type> inline Type saturate_cast(const u8  v) { return static_cast<Type>(v); }
;;;269        template<typename Type> inline Type saturate_cast(const s8  v) { return static_cast<Type>(v); }
;;;270        template<typename Type> inline Type saturate_cast(const u16 v) { return static_cast<Type>(v); }
;;;271        template<typename Type> inline Type saturate_cast(const s16 v) { return static_cast<Type>(v); }
;;;272        template<typename Type> inline Type saturate_cast(const u32 v) { return static_cast<Type>(v); }
;;;273        template<typename Type> inline Type saturate_cast(const s32 v) { return static_cast<Type>(v); }
;;;274        template<typename Type> inline Type saturate_cast(const u64 v) { return static_cast<Type>(v); }
;;;275        template<typename Type> inline Type saturate_cast(const s64 v) { return static_cast<Type>(v); }
;;;276        template<typename Type> inline Type saturate_cast(const f32 v) { return static_cast<Type>(v); }
;;;277        template<typename Type> inline Type saturate_cast(const f64 v) { return static_cast<Type>(v); }
;;;278    
;;;279        // Most saturate_cast calls are explicitly specialized
;;;280        template<> inline u8  saturate_cast<u8> (const u8  v) { return v; }
;;;281        template<> inline u8  saturate_cast<u8> (const u16 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;282        template<> inline u8  saturate_cast<u8> (const u32 v) { return (u8)             MIN((u32)u8_MAX, (u32)v); }
;;;283        template<> inline u8  saturate_cast<u8> (const u64 v) { return (u8)             MIN((u64)u8_MAX, (u64)v); }
;;;284        template<> inline u8  saturate_cast<u8> (const s8  v) { return (u8)                              MAX((s32)0, (s32)v);  }
;;;285        template<> inline u8  saturate_cast<u8> (const s16 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;286        template<> inline u8  saturate_cast<u8> (const s32 v) { return (u8)             MIN((s32)u8_MAX, MAX((s32)0, (s32)v)); }
;;;287        template<> inline u8  saturate_cast<u8> (const s64 v) { return (u8)             MIN((s64)u8_MAX, MAX((s64)0, (s64)v)); }
;;;288        template<> inline u8  saturate_cast<u8> (const f32 v) { return (u8) Round<s32>( MIN((f32)u8_MAX, MAX((f32)0, (f32)v)) ); }
;;;289        template<> inline u8  saturate_cast<u8> (const f64 v) { return (u8) Round<s32>( MIN((f64)u8_MAX, MAX((f64)0, (f64)v)) ); }
;;;290    
;;;291        template<> inline s8  saturate_cast<s8> (const u8  v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;292        template<> inline s8  saturate_cast<s8> (const u16 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;293        template<> inline s8  saturate_cast<s8> (const u32 v) { return (s8)             MIN((u32)s8_MAX, (u32)v); }
;;;294        template<> inline s8  saturate_cast<s8> (const u64 v) { return (s8)             MIN((u64)s8_MAX, (u64)v); }
;;;295        template<> inline s8  saturate_cast<s8> (const s8  v) { return v; }
;;;296        template<> inline s8  saturate_cast<s8> (const s16 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;297        template<> inline s8  saturate_cast<s8> (const s32 v) { return (s8)             MIN((s32)s8_MAX, MAX((s32)s8_MIN, (s32)v)); }
;;;298        template<> inline s8  saturate_cast<s8> (const s64 v) { return (s8)             MIN((s64)s8_MAX, MAX((s64)s8_MIN, (s64)v)); }
;;;299        template<> inline s8  saturate_cast<s8> (const f32 v) { return (s8) Round<s32>( MIN((f32)s8_MAX, MAX((f32)s8_MIN, (f32)v)) ); }
;;;300        template<> inline s8  saturate_cast<s8> (const f64 v) { return (s8) Round<s32>( MIN((f64)s8_MAX, MAX((f64)s8_MIN, (f64)v)) ); }
;;;301    
;;;302        template<> inline u16 saturate_cast<u16>(const u8  v) { return v; }
;;;303        template<> inline u16 saturate_cast<u16>(const u16 v) { return v; }
;;;304        template<> inline u16 saturate_cast<u16>(const u32 v) { return (u16)             MIN((u32)u16_MAX, (u32)v); }
;;;305        template<> inline u16 saturate_cast<u16>(const u64 v) { return (u16)             MIN((u64)u16_MAX, (u64)v); }
;;;306        template<> inline u16 saturate_cast<u16>(const s8  v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;307        template<> inline u16 saturate_cast<u16>(const s16 v) { return (u16)                               MAX((s32)0, (s32)v);  }
;;;308        template<> inline u16 saturate_cast<u16>(const s32 v) { return (u16)             MIN((s32)u16_MAX, MAX((s32)0, (s32)v)); }
;;;309        template<> inline u16 saturate_cast<u16>(const s64 v) { return (u16)             MIN((s64)u16_MAX, MAX((s64)0, (s64)v)); }
;;;310        template<> inline u16 saturate_cast<u16>(const f32 v) { return (u16) Round<s32>( MIN((f32)u16_MAX, MAX((f32)0, (f32)v)) ); }
;;;311        template<> inline u16 saturate_cast<u16>(const f64 v) { return (u16) Round<s32>( MIN((f64)u16_MAX, MAX((f64)0, (f64)v)) ); }
;;;312    
;;;313        template<> inline s16 saturate_cast<s16>(const u8  v) { return v; }
;;;314        template<> inline s16 saturate_cast<s16>(const u16 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;315        template<> inline s16 saturate_cast<s16>(const u32 v) { return (s16)             MIN((u32)s16_MAX, (u32)v); }
;;;316        template<> inline s16 saturate_cast<s16>(const u64 v) { return (s16)             MIN((u64)s16_MAX, (u64)v); }
;;;317        template<> inline s16 saturate_cast<s16>(const s8  v) { return v; }
;;;318        template<> inline s16 saturate_cast<s16>(const s16 v) { return v; }
;;;319        template<> inline s16 saturate_cast<s16>(const s32 v) { return (s16)             MIN((s32)s16_MAX, MAX((s32)s16_MIN, (s32)v)); }
;;;320        template<> inline s16 saturate_cast<s16>(const s64 v) { return (s16)             MIN((s64)s16_MAX, MAX((s64)s16_MIN, (s64)v)); }
;;;321        template<> inline s16 saturate_cast<s16>(const f32 v) { return (s16) Round<s32>( MIN((f32)s16_MAX, MAX((f32)s16_MIN, (f32)v)) ); }
;;;322        template<> inline s16 saturate_cast<s16>(const f64 v) { return (s16) Round<s32>( MIN((f64)s16_MAX, MAX((f64)s16_MIN, (f64)v)) ); }
;;;323    
;;;324        template<> inline u32 saturate_cast<u32>(const u8  v) { return v; }
;;;325        template<> inline u32 saturate_cast<u32>(const u16 v) { return v; }
;;;326        template<> inline u32 saturate_cast<u32>(const u32 v) { return v; }
;;;327        template<> inline u32 saturate_cast<u32>(const u64 v) { return (u32)             MIN((u64)u32_MAX, (u64)v); }
;;;328        template<> inline u32 saturate_cast<u32>(const s8  v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;329        template<> inline u32 saturate_cast<u32>(const s16 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;330        template<> inline u32 saturate_cast<u32>(const s32 v) { return (u32)                               MAX((s32)0, (s32)v);  }
;;;331        template<> inline u32 saturate_cast<u32>(const s64 v) { return (u32)             MIN((s64)u32_MAX, MAX((s64)0, (s64)v)); }
;;;332        template<> inline u32 saturate_cast<u32>(const f32 v) { return (u32) (v > (f32)0xFFFFFF7F) ? 0xFFFFFFFF : Round<u32>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;333        template<> inline u32 saturate_cast<u32>(const f64 v) { return (u32) Round<u32>( MIN((f64)u32_MAX, MAX((f64)0, (f64)v)) ); }
;;;334    
;;;335        template<> inline s32 saturate_cast<s32>(const u8  v) { return v; }
;;;336        template<> inline s32 saturate_cast<s32>(const u16 v) { return v; }
;;;337        template<> inline s32 saturate_cast<s32>(const u32 v) { return (s32)             MIN((u32)s32_MAX, (u32)v); }
;;;338        template<> inline s32 saturate_cast<s32>(const u64 v) { return (s32)             MIN((u64)s32_MAX, (u64)v); }
;;;339        template<> inline s32 saturate_cast<s32>(const s8  v) { return v; }
;;;340        template<> inline s32 saturate_cast<s32>(const s16 v) { return v; }
;;;341        template<> inline s32 saturate_cast<s32>(const s32 v) { return v; }
;;;342        template<> inline s32 saturate_cast<s32>(const s64 v) { return (s32)             MIN((s64)s32_MAX, MAX((s64)s32_MIN, (s64)v)); }
;;;343        template<> inline s32 saturate_cast<s32>(const f32 v) { return (s32) (v > (f32)0x7FFFFFBF) ? 0x7FFFFFFF : Round<s32>(MAX((f32)s32_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;344        template<> inline s32 saturate_cast<s32>(const f64 v) { return (s32) Round<s32>( MIN((f64)s32_MAX, MAX((f64)s32_MIN, (f64)v)) ); }
;;;345    
;;;346        template<> inline u64 saturate_cast<u64>(const u8  v) { return v; }
;;;347        template<> inline u64 saturate_cast<u64>(const u16 v) { return v; }
;;;348        template<> inline u64 saturate_cast<u64>(const u32 v) { return v; }
;;;349        template<> inline u64 saturate_cast<u64>(const u64 v) { return v; }
;;;350        template<> inline u64 saturate_cast<u64>(const s8  v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;351        template<> inline u64 saturate_cast<u64>(const s16 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;352        template<> inline u64 saturate_cast<u64>(const s32 v) { return (u64)                               MAX((s32)0, (s32)v);  }
;;;353        template<> inline u64 saturate_cast<u64>(const s64 v) { return (u64)                               MAX((s64)0, (s64)v);  }
;;;354        template<> inline u64 saturate_cast<u64>(const f32 v) { return (u64) (v > (f32)0XFFFFFF7FFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f32)0, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;355        template<> inline u64 saturate_cast<u64>(const f64 v) { return (u64) (v > (f64)0xFFFFFFFFFFFFFBFFULL) ? 0xFFFFFFFFFFFFFFFFULL : Round<u64>(MAX((f64)0, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;356    
;;;357        template<> inline s64 saturate_cast<s64>(const u8  v) { return v; }
;;;358        template<> inline s64 saturate_cast<s64>(const u16 v) { return v; }
;;;359        template<> inline s64 saturate_cast<s64>(const u32 v) { return v; }
;;;360        template<> inline s64 saturate_cast<s64>(const u64 v) { return (s64)             MIN((u64)s64_MAX, (u64)v); }
;;;361        template<> inline s64 saturate_cast<s64>(const s8  v) { return v; }
;;;362        template<> inline s64 saturate_cast<s64>(const s16 v) { return v; }
;;;363        template<> inline s64 saturate_cast<s64>(const s32 v) { return v; }
;;;364        template<> inline s64 saturate_cast<s64>(const s64 v) { return v; }
;;;365        template<> inline s64 saturate_cast<s64>(const f32 v) { return (s64) (v > (f32)0x7FFFFFBFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f32)s64_MIN, (f32)v)); } // Due to precision issues, this cast is a little wierd
;;;366        template<> inline s64 saturate_cast<s64>(const f64 v) { return (s64) (v > (f64)0x7FFFFFFFFFFFFDFFLL) ? 0x7FFFFFFFFFFFFFFFLL : Round<s64>(MAX((f64)s64_MIN, (f64)v)); } // Due to precision issues, this cast is a little wierd
;;;367    
;;;368        template<> inline f32 saturate_cast(const f64 v) { return (f32) MIN((f64)FLT_MAX, MAX(-(f64)FLT_MAX, (f64)v)); }
;;;369      } // namespace Embedded
;;;370    } // namespace Anki
;;;371    
;;;372    #endif // _ANKICORETECHEMBEDDED_COMMON_UTILITIES_H_
;;;18     #include "anki/common/robot/memory.h"
;;;1      /**
;;;19     #include "anki/common/robot/errorHandling.h"
;;;1      /**
;;;20     #include "anki/common/robot/geometry.h"
;;;1      /**
;;;2      File: geometry.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of geometry_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_POINT_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/geometry_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/memory.h"
;;;1      /**
;;;18     #include "anki/common/robot/matrix.h"
;;;1      /**
;;;2      File: matrix.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of matrix_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;14     
;;;15     #include "anki/common/robot/matrix_declarations.h"
;;;1      /**
;;;2      File: matrix_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various Matrix operations, such as matrix multiply and addition.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;18     
;;;19     namespace Anki
;;;20     {
;;;21       namespace Embedded
;;;22       {
;;;23         namespace Matrix
;;;24         {
;;;25           // #pragma mark --- Declarations ---
;;;26     
;;;27           //
;;;28           // Simple matrix statistics
;;;29           //
;;;30     
;;;31           // Return the minimum element in this Array
;;;32           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat);
;;;33     
;;;34           // Return the maximum element in this Array
;;;35           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat);
;;;36     
;;;37           // Return the sum of every element in the Array
;;;38           template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat);
;;;39     
;;;40           // Return the mean of every element in the Array
;;;41           template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat);
;;;42     
;;;43           // Simultaneously compute the mean and variance of every element in the Array
;;;44           template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(const ConstArraySliceExpression<Array_Type> &mat,
;;;45             Accumulator_Type& mean, Accumulator_Type& var);
;;;46     
;;;47           //
;;;48           // Elementwise matrix operations
;;;49           //
;;;50     
;;;51           // Elementwise add two arrays. in1, in2, and out can be the same array
;;;52           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;53           template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;54           template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;55     
;;;56           // Elementwise subtract two arrays. in1, in2, and out can be the same array
;;;57           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;58           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;59           template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;60     
;;;61           // Elementwise multiply two arrays. in1, in2, and out can be the same array
;;;62           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;63           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;64           template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;65     
;;;66           // Elementwise divide two arrays. in1, in2, and out can be the same array
;;;67           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;68           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;69           template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;70     
;;;71           // Elementwise exponential on an array
;;;72           template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;73     
;;;74           // Elementwise square root on an array
;;;75           template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out);
;;;76     
;;;77           //
;;;78           // Standard matrix operations
;;;79           //
;;;80     
;;;81           // Perform the matrix multiplication "out = in1 * in2"
;;;82           // Note that this is the naive O(n^3) Definition
;;;83           template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out);
;;;84     
;;;85           // Perform the matrix multiplication "out = in1 * in2'"
;;;86           // Note that this is the naive O(n^3) Definition
;;;87           // MultiplyTranspose has better access patterns than Multiply for certain types of arrays, so could be a lot faster (and easier to accelerate)
;;;88           template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out);
;;;89     
;;;90           //
;;;91           // Rotation Matrices
;;;92           //
;;;93     
;;;94           // TODO: Add other rotation-related math, like Rodrigues' formula, or Pose chaining...
;;;95     
;;;96           // Compute the three Euler angles from a given 3x3 Rotation Matrix.
;;;97           Result GetEulerAngles(const Array<f32>& R, f32& angle_x, f32& angle_y, f32& angle_z);
;;;98     
;;;99           //
;;;100          // Linear Algebra and Linear Solvers
;;;101          //
;;;102    
;;;103          // Compute the Cholesky-Banachiewicz decomposition, to return a lower-triangular matrix L such that A=L*L'
;;;104          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;105            Array<Type> &A_L,      //!< Input A Matrix and Output lower-triangular L matrix
;;;106            Array<Type> &Bt_Xt,    //!< Input B-transpose matrix and Output X-transpose solution
;;;107            bool realCholesky,     //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;108            bool &numericalFailure //!< If true, the solver failed because of numerical instability
;;;109            );
;;;110    
;;;111          // Compute the homography such that "transformedPoints = homography * originalPoints"
;;;112          //
;;;113          // WARNING: This uses the inhomogeneous solution and the Cholesky decomposition, therefore it
;;;114          //          will be incorrect if H_33 is zero, which happens in certain cases of lines at
;;;115          //          inifinty. For more details, see Multiple View Geometry 2nd Edition, Example 4.1
;;;116          template<typename Type> Result EstimateHomography(
;;;117            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;118            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;119            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;120            bool &numericalFailure, //!< Did the homography solver fail?
;;;121            MemoryStack scratch //!< Scratch memory
;;;122            );
;;;123    
;;;124          //template<typename InType, typename IntermediateType, typename OutType> Result CholeskyDecomposition(
;;;125          //  const Array<InType> &A,                    //!< Input A Matrix
;;;126          //  Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;127          //  Array<OutType> &L                          //!< Output lower-triangular L matrix
;;;128          //  );
;;;129    
;;;130          //template<typename InType, typename IntermediateType, typename OutType> Result SolveWithLowerTriangular(
;;;131          //  const Array<InType> &L,                          //!< Input lower-triangular L matrix (such as computed by CholeskyDecomposition)
;;;132          //  const Array<InType> &b,                          //!< Input b matrix
;;;133          //  const Array<IntermediateType> &diagonalInverses, //!< Vector of the inverses of the diagonals of L
;;;134          //  Array<OutType> &x                                //!< Output x solution
;;;135          //  );
;;;136    
;;;137          // Solves Ax = b
;;;138          // Specifically, it uses SVD to minimize ||Ax - b||
;;;139          // Note that the A, b, and x matrices are transposed (this is because for large numbers of samples, transposed inputs are liable to be faster)
;;;140          //Result SolveLeastSquaresWithSVD_f32(Array<f32> &At, const Array<f32> &bt, Array<f32> &xt, MemoryStack scratch);
;;;141          //Result SolveLeastSquaresWithSVD_f64(Array<f64> &At, const Array<f64> &bt, Array<f64> &xt, MemoryStack scratch);
;;;142    
;;;143          //
;;;144          // Matrix structure operations
;;;145          //
;;;146    
;;;147          // matlab equivalent: out = reshape(in, [M,N]);
;;;148          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;149          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory);
;;;150    
;;;151          // matlab equivalent: out = in(:);
;;;152          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out);
;;;153          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory);
;;;154    
;;;155          // Perform an immediate matrix transpose (unlike the lazy transpose of ArraySlice)
;;;156          // in and out must be different Array objects
;;;157          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out);
;;;158    
;;;159          // Rotate an array clockwise by 90, 180, or 270 degrees.
;;;160          // NOTE: Only works for a square matrix.
;;;161          // NOTE: In and out must be different arrays (unlike the interview question)
;;;162          template<typename InType, typename OutType> Result Rotate90( const Array<InType> &in, Array<OutType> &out);
;;;163          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out);
;;;164          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out);
;;;165    
;;;166          //
;;;167          // Misc matrix operations
;;;168          //
;;;169    
;;;170          // Works the same as the Matlab sort() for matrices.
;;;171          // InsertionSort(X) sorts each column of X in ascending order.
;;;172          // The minIndex and maxIndex are for the sortWhichDimension. maxIndex is automatically clipped to the size of the input Array.
;;;173          // NOTE: this currently uses insertion sort, so may be slow for large, badly-unsorted arrays
;;;174          template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;175    
;;;176          // Subsections less-than-or-equal-to insertionSortSize are sorted with insertion sort
;;;177          template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;178    
;;;179          // indexes must be allocated, but will be overwritten by InsertionSort()
;;;180          template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE);
;;;181    
;;;182          template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension=0, const bool sortAscending=true, const s32 minIndex=0, const s32 maxIndex=0x7FFFFFE, const s32 insertionSortSize=10);
;;;183    
;;;184          // For a square array, either:
;;;185          // 1. When lowerToUpper==true,  copies the lower (left)  triangle to the upper (right) triangle
;;;186          // 2. When lowerToUpper==false, copies the upper (right) triangle to the lower (left)  triangle
;;;187          // Functionally the same as OpenCV completeSymm()
;;;188          template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper = false);
;;;189    
;;;190          // There's probably no need to use these directly. Instead, use the normal Matrix:: operations, like Matrix::Add
;;;191          namespace Elementwise
;;;192          {
;;;193            template<typename InType, typename IntermediateType, typename OutType> class Add {
;;;194            public:
;;;195              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) + static_cast<IntermediateType>(value2));}
;;;196            };
;;;197    
;;;198            template<typename InType, typename IntermediateType, typename OutType> class Subtract {
;;;199            public:
;;;200              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) - static_cast<IntermediateType>(value2));}
;;;201            };
;;;202    
;;;203            template<typename InType, typename IntermediateType, typename OutType> class DotMultiply {
;;;204            public:
;;;205              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) * static_cast<IntermediateType>(value2));}
;;;206            };
;;;207    
;;;208            template<typename InType, typename IntermediateType, typename OutType> class DotDivide {
;;;209            public:
;;;210              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(static_cast<IntermediateType>(value1) / static_cast<IntermediateType>(value2));}
;;;211            };
;;;212    
;;;213            // Technically a unary operator, but we ignore the second parameter
;;;214            // TODO: if this is slow, make a unary version of ApplyOperation
;;;215            template<typename InType, typename IntermediateType, typename OutType> class Exp {
;;;216            public:
;;;217              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(expf(static_cast<IntermediateType>(value1)));}
;;;218            };
;;;219    
;;;220            template<typename InType, typename IntermediateType, typename OutType> class Sqrt {
;;;221            public:
;;;222              static inline OutType BinaryElementwiseOperation(const InType value1, const InType value2) {return static_cast<OutType>(sqrtf(static_cast<IntermediateType>(value1)));}
;;;223            };
;;;224    
;;;225            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;226            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out);
;;;227            template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out);
;;;228          } // namespace Elementwise
;;;229        } // namespace Matrix
;;;230      } // namespace Embedded
;;;231    } // namespace Anki
;;;232    
;;;233    #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;2      File: array2d.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of array2d_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;14     
;;;15     #include "anki/common/robot/array2d_declarations.h"
;;;16     
;;;17     #include "anki/common/robot/utilities.h"
;;;18     #include "anki/common/robot/memory.h"
;;;19     #include "anki/common/robot/errorHandling.h"
;;;20     #include "anki/common/robot/geometry.h"
;;;21     #include "anki/common/robot/utilities_c.h"
;;;22     #include "anki/common/robot/sequences.h"
;;;23     #include "anki/common/robot/matrix.h"
;;;24     #include "anki/common/robot/comparisons.h"
;;;25     
;;;26     #include "anki/common/shared/utilities_shared.h"
;;;27     
;;;28     #include "anki/common/robot/serialize_declarations.h"
;;;29     
;;;30     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;31     #include "opencv2/core/core.hpp"
;;;32     #include "opencv2/highgui/highgui.hpp"
;;;33     #include "opencv2/imgproc/imgproc.hpp"
;;;34     #include "opencv2/objdetect/objdetect.hpp"
;;;35     #endif
;;;36     
;;;37     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;38     #define ANKICORETECH_EMBEDDED_USE_MALLOC 1
;;;39     #define ANKICORETECH_EMBEDDED_USE_ZLIB 1
;;;40     #endif
;;;41     
;;;42     #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;43     #include "zlib.h"
;;;44     #endif
;;;45     
;;;46     namespace Anki
;;;47     {
;;;48       namespace Embedded
;;;49       {
;;;50         template<typename Type> class ArraySlice;
;;;51         template<typename Type> class ConstArraySlice;
;;;52         template<typename Type> class ConstArraySliceExpression;
;;;53     
;;;54         // #pragma mark --- Array Definitions ---
;;;55     
;;;56         template<typename Type> s32 Array<Type>::ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags)
;;;57         {
;;;58           AnkiConditionalErrorAndReturnValue(numCols >= 0,
;;;59             0, "Array<Type>::ComputeRequiredStride", "Invalid size");
;;;60     
;;;61           const s32 numColsCapped = MAX(numCols, 1);
;;;62     
;;;63           const s32 bufferRequired = static_cast<s32>(RoundUp<size_t>(sizeof(Type)*numColsCapped, MEMORY_ALIGNMENT));
;;;64     
;;;65           return bufferRequired;
;;;66         }
;;;67     
;;;68         template<typename Type> s32 Array<Type>::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const Flags::Buffer flags)
;;;69         {
;;;70           AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0,
;;;71             0, "Array<Type>::ComputeMinimumRequiredMemory", "Invalid size");
;;;72     
;;;73           const s32 numRowsCapped = MAX(numRows, 1);
;;;74     
;;;75           return numRowsCapped * Array<Type>::ComputeRequiredStride(numCols, flags);
;;;76         }
;;;77     
;;;78         template<typename Type> Array<Type>::Array()
;;;79         {
;;;80           InvalidateArray();
;;;81         }
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
;;;139        template<typename Type> Array<Type> Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;140        {
;;;141          Array<Type> newArray = Array<Type>();
;;;142    
;;;143    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;144          const cv::Mat cvImage = cv::imread(filename, CV_LOAD_IMAGE_GRAYSCALE);
;;;145    
;;;146          AnkiConditionalErrorAndReturnValue(cvImage.cols >= 0 && cvImage.rows >= 0,
;;;147            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;148    
;;;149          newArray = Array<Type>(cvImage.rows, cvImage.cols, memory);
;;;150    
;;;151          AnkiConditionalErrorAndReturnValue(newArray.IsValid(),
;;;152            newArray, "Array<Type>::LoadImage", "Invalid size");
;;;153    
;;;154          const u8 * restrict pCvImage = cvImage.data;
;;;155    
;;;156          for(s32 y=0; y<cvImage.rows; y++) {
;;;157            Type * restrict pNewArray = newArray.Pointer(y, 0);
;;;158    
;;;159            for(s32 x=0; x<cvImage.cols; x++) {
;;;160              pNewArray[x] = static_cast<Type>(pCvImage[x]);
;;;161            }
;;;162    
;;;163            pCvImage += cvImage.step.buf[0];
;;;164          }
;;;165    #else
;;;166          AnkiError("Array<Type>::Array", "OpenCV is required to load an image from an image file");
;;;167    #endif
;;;168    
;;;169          return newArray;
;;;170        } // Array<Type>::LoadImage(const char * filename, MemoryStack &memory)
;;;171    
;;;172        template<typename Type> Array<Type> LoadBinaryArray_Generic(const char * filename, MemoryStack *scratch, MemoryStack *memory, void * allocatedBuffer, const s32 allocatedBufferLength)
;;;173        {
;;;174          u16  basicType_sizeOfType;
;;;175          bool basicType_isBasicType;
;;;176          bool basicType_isInteger;
;;;177          bool basicType_isSigned;
;;;178          bool basicType_isFloat;
;;;179          bool basicType_isString;
;;;180    
;;;181          Array<u8> rawArray = LoadBinaryArray_UnknownType(
;;;182            filename,
;;;183            scratch, memory,
;;;184            allocatedBuffer, allocatedBufferLength,
;;;185            basicType_sizeOfType, basicType_isBasicType, basicType_isInteger, basicType_isSigned, basicType_isFloat, basicType_isString);
;;;186    
;;;187          // TODO: check that the types match
;;;188    
;;;189          Array<Type> newArray = *reinterpret_cast<Array<Type>*>( &rawArray );
;;;190    
;;;191          return newArray;
;;;192        } // / LoadBinaryArray_Generic()
;;;193    
;;;194        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;195        {
;;;196          return LoadBinaryArray_Generic<Type>(filename, &scratch, &memory, NULL, -1);
;;;197        } // Array<Type>::LoadBinary(const char * filename, MemoryStack scratch, MemoryStack &memory)
;;;198    
;;;199        template<typename Type> Array<Type> Array<Type>::LoadBinary(const char * filename, void * allocatedBuffer, const s32 allocatedBufferLength) //< allocatedBuffer must be freed manually
;;;200        {
;;;201          return LoadBinaryArray_Generic<Type>(filename, NULL, NULL, allocatedBuffer, allocatedBufferLength);
;;;202        } // LoadBinaryMalloc()
;;;203    
;;;204        template<typename Type> Result Array<Type>::SaveBinary(const char * filename, const s32 compressionLevel, MemoryStack scratch) const
;;;205        {
;;;206          AnkiConditionalErrorAndReturnValue(AreValid(*this, scratch) && filename,
;;;207            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::SaveBinary", "Invalid inputs");
;;;208    
;;;209          AnkiConditionalErrorAndReturnValue(compressionLevel >= 0 && compressionLevel <= 9,
;;;210            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::SaveBinary", "Invalid compression level");
;;;211    
;;;212          // If this is a string array, add the sizes of the null terminated strings (or zero otherwise)
;;;213          const s32 stringsLength = TotalArrayStringLengths<Type>(*this);
;;;214    
;;;215          const s32 serializedBufferLength = 4096 + ARRAY_FILE_HEADER_LENGTH + this->get_size(0) * this->get_stride() + stringsLength;
;;;216          void *buffer = scratch.Allocate(serializedBufferLength);
;;;217    
;;;218          AnkiConditionalErrorAndReturnValue(buffer,
;;;219            RESULT_FAIL_OUT_OF_MEMORY, "Array<Type>::SaveBinary", "Memory could not be allocated");
;;;220    
;;;221          SerializedBuffer toSave(buffer, serializedBufferLength);
;;;222    
;;;223          toSave.PushBack<Type>("Array", *this);
;;;224    
;;;225          s32 startIndex;
;;;226          u8 * bufferStart = reinterpret_cast<u8*>(toSave.get_memoryStack().get_validBufferStart(startIndex));
;;;227          const s32 validUsedBytes = toSave.get_memoryStack().get_usedBytes() - startIndex;
;;;228    
;;;229          // const s32 startDiff = static_cast<s32>( reinterpret_cast<size_t>(bufferStart) - reinterpret_cast<size_t>(toSave.get_memoryStack().get_buffer()) );
;;;230          // const s32 endDiff = toSave.get_memoryStack().get_totalBytes() - toSave.get_memoryStack().get_usedBytes();
;;;231    
;;;232          FILE *fp = fopen(filename, "wb");
;;;233    
;;;234          AnkiConditionalErrorAndReturnValue(fp,
;;;235            RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Could not open file %s", filename);
;;;236    
;;;237          if(compressionLevel > 0) {
;;;238    #if ANKICORETECH_EMBEDDED_USE_ZLIB
;;;239            char tmpTextHeader[ARRAY_FILE_HEADER_LENGTH+1];
;;;240            strncpy(tmpTextHeader, &ARRAY_FILE_HEADER[0], ARRAY_FILE_HEADER_LENGTH+1);
;;;241            snprintf(tmpTextHeader+ARRAY_FILE_HEADER_VALID_LENGTH+1, ARRAY_FILE_HEADER_LENGTH-ARRAY_FILE_HEADER_VALID_LENGTH, "z%s ", ZLIB_VERSION);
;;;242    
;;;243            const s32 originalLength = validUsedBytes + SERIALIZED_BUFFER_HEADER_LENGTH + SERIALIZED_BUFFER_FOOTER_LENGTH;
;;;244    
;;;245            uLongf compressedLength = 128 + saturate_cast<s32>(1.1 * originalLength);
;;;246    
;;;247            void * uncompressed = malloc(originalLength);
;;;248            void * compressed = malloc(compressedLength + 2*sizeof(s32));
;;;249    
;;;250            if(!uncompressed || !compressed) {
;;;251              if(uncompressed)
;;;252                free(uncompressed);
;;;253    
;;;254              if(compressed)
;;;255                free(compressed);
;;;256    
;;;257              AnkiError("Array<Type>::SaveBinary", "Out of memory");
;;;258    
;;;259              return RESULT_FAIL_OUT_OF_MEMORY;
;;;260            }
;;;261    
;;;262            // Copy the uncompressed data into one buffer
;;;263            {
;;;264              char * pUncompressed = reinterpret_cast<char*>(uncompressed);
;;;265    
;;;266              memcpy(pUncompressed, &SERIALIZED_BUFFER_HEADER[0], SERIALIZED_BUFFER_HEADER_LENGTH);
;;;267              pUncompressed += SERIALIZED_BUFFER_HEADER_LENGTH;
;;;268    
;;;269              memcpy(pUncompressed, bufferStart, validUsedBytes);
;;;270              pUncompressed += validUsedBytes;
;;;271    
;;;272              memcpy(pUncompressed, &SERIALIZED_BUFFER_FOOTER[0], SERIALIZED_BUFFER_FOOTER_LENGTH);
;;;273            }
;;;274    
;;;275            const s32 compressionResult = compress2(reinterpret_cast<Bytef*>(compressed) + 2*sizeof(s32), &compressedLength, reinterpret_cast<Bytef*>(uncompressed), originalLength, compressionLevel);
;;;276    
;;;277            if(compressionResult != Z_OK) {
;;;278              if(uncompressed)
;;;279                free(uncompressed);
;;;280    
;;;281              if(compressed)
;;;282                free(compressed);
;;;283    
;;;284              AnkiError("Array<Type>::SaveBinary", "Zlib error");
;;;285              return RESULT_FAIL_IO;
;;;286            }
;;;287    
;;;288            reinterpret_cast<s32*>(compressed)[0] = static_cast<s32>(originalLength);
;;;289            reinterpret_cast<s32*>(compressed)[1] = static_cast<s32>(compressedLength);
;;;290    
;;;291            const size_t bytesWrittenForTextHeader = fwrite(tmpTextHeader, 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;292    
;;;293            const size_t bytesWritten = fwrite(compressed, 1, compressedLength + 2*sizeof(s32), fp);
;;;294    
;;;295            if(uncompressed)
;;;296              free(uncompressed);
;;;297    
;;;298            if(compressed)
;;;299              free(compressed);
;;;300    
;;;301            AnkiConditionalErrorAndReturnValue(
;;;302              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;303              bytesWritten == (compressedLength + 2*sizeof(s32)),
;;;304              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;305    
;;;306    #else
;;;307            AnkiError("Array<Type>::SaveBinary", "Saving with compression requires zlib");
;;;308            return RESULT_FAIL;
;;;309    #endif
;;;310          } else {
;;;311            const size_t bytesWrittenForTextHeader = fwrite(&ARRAY_FILE_HEADER[0], 1, ARRAY_FILE_HEADER_LENGTH, fp);
;;;312    
;;;313            const size_t bytesWrittenForHeader = fwrite(&SERIALIZED_BUFFER_HEADER[0], 1, SERIALIZED_BUFFER_HEADER_LENGTH, fp);
;;;314    
;;;315            const size_t bytesWritten = fwrite(bufferStart, 1, validUsedBytes, fp);
;;;316    
;;;317            const size_t bytesWrittenForFooter = fwrite(&SERIALIZED_BUFFER_FOOTER[0], 1, SERIALIZED_BUFFER_FOOTER_LENGTH, fp);
;;;318    
;;;319            AnkiConditionalErrorAndReturnValue(
;;;320              bytesWrittenForTextHeader == ARRAY_FILE_HEADER_LENGTH &&
;;;321              bytesWrittenForHeader == SERIALIZED_BUFFER_HEADER_LENGTH &&
;;;322              bytesWritten == validUsedBytes &&
;;;323              bytesWrittenForFooter == SERIALIZED_BUFFER_FOOTER_LENGTH,
;;;324              RESULT_FAIL_IO, "Array<Type>::SaveBinary", "Save failed");
;;;325          }
;;;326    
;;;327          fclose(fp);
;;;328    
;;;329          return RESULT_OK;
;;;330        } // Array<Type>::SaveBinary(const char * filename, MemoryStack scratch)
;;;331    
;;;332        template<typename Type> const Type* Array<Type>::Pointer(const s32 index0, const s32 index1) const
;;;333        {
;;;334          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;335          AnkiAssert(this->IsValid());
;;;336    
;;;337          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride ) + index1;
;;;338        }
;;;339    
;;;340        template<typename Type> Type* Array<Type>::Pointer(const s32 index0, const s32 index1)
;;;341        {
;;;342          AnkiAssert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1]);
;;;343          AnkiAssert(this->IsValid());
;;;344    
;;;345          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride ) + index1;
;;;346        }
;;;347    
;;;348        template<typename Type> inline const Type * Array<Type>::operator[](const s32 index0) const
;;;349        {
;;;350          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;351    
;;;352          return reinterpret_cast<const Type*>( reinterpret_cast<const char*>(this->data) + index0*stride );
;;;353        }
;;;354    
;;;355        template<typename Type> inline Type * Array<Type>::operator[](const s32 index0)
;;;356        {
;;;357          AnkiAssert(index0 >= 0 && index0 < this->size[0]);
;;;358    
;;;359          return reinterpret_cast<Type*>( reinterpret_cast<char*>(this->data) + index0*stride );
;;;360        }
;;;361    
;;;362        template<typename Type> const Type* Array<Type>::Pointer(const Point<s16> &point) const
;;;363        {
;;;364          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;365        }
;;;366    
;;;367        template<typename Type> Type* Array<Type>::Pointer(const Point<s16> &point)
;;;368        {
;;;369          return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
;;;370        }
;;;371    
;;;372        template<typename Type> const Type& Array<Type>::Element(const s32 elementIndex) const
;;;373        {
;;;374          const s32 index1 = elementIndex % size[1];
;;;375          const s32 index0 = (elementIndex - index1) / size[1];
;;;376    
;;;377          return *Pointer(index0, index1);
;;;378        }
;;;379    
;;;380        template<typename Type> Type& Array<Type>::Element(const s32 elementIndex)
;;;381        {
;;;382          const s32 index1 = elementIndex % size[1];
;;;383          const s32 index0 = (elementIndex - index1) / size[1];
;;;384    
;;;385          return *Pointer(index0, index1);
;;;386        }
;;;387    
;;;388        template<typename Type> ArraySlice<Type> Array<Type>::operator() ()
;;;389        {
;;;390          ArraySlice<Type> slice(*this);
;;;391    
;;;392          return slice;
;;;393        }
;;;394    
;;;395        template<typename Type> ArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;396        {
;;;397          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;398    
;;;399          return slice;
;;;400        }
;;;401    
;;;402        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX)
;;;403        {
;;;404          LinearSequence<s32> ySlice = IndexSequence<s32>(minY, 1, maxY, this->size[0]);
;;;405          LinearSequence<s32> xSlice = IndexSequence<s32>(minX, 1, maxX, this->size[1]);
;;;406    
;;;407          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;408    
;;;409          return slice;
;;;410        }
;;;411    
;;;412        template<typename Type> ArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX)
;;;413        {
;;;414          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;415          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;416    
;;;417          ArraySlice<Type> slice(*this, ySlice, xSlice);
;;;418    
;;;419          return slice;
;;;420        }
;;;421    
;;;422        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() () const
;;;423        {
;;;424          ConstArraySlice<Type> slice(*this);
;;;425    
;;;426          return slice;
;;;427        }
;;;428    
;;;429        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice) const
;;;430        {
;;;431          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;432    
;;;433          return slice;
;;;434        }
;;;435    
;;;436        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 maxY, s32 minX, s32 maxX) const
;;;437        {
;;;438          LinearSequence<s32> ySlice = IndexSequence(minY, 1, maxY, this->size[0]);
;;;439          LinearSequence<s32> xSlice = IndexSequence(minX, 1, maxX, this->size[1]);
;;;440    
;;;441          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;442    
;;;443          return slice;
;;;444        }
;;;445    
;;;446        template<typename Type> ConstArraySlice<Type> Array<Type>::operator() (s32 minY, s32 incrementY, s32 maxY, s32 minX, s32 incrementX, s32 maxX) const
;;;447        {
;;;448          LinearSequence<s32> ySlice = IndexSequence(minY, incrementY, maxY, this->size[0]);
;;;449          LinearSequence<s32> xSlice = IndexSequence(minX, incrementX, maxX, this->size[1]);
;;;450    
;;;451          ConstArraySlice<Type> slice(*this, ySlice, xSlice);
;;;452    
;;;453          return slice;
;;;454        }
;;;455    
;;;456        template<typename Type> ConstArraySliceExpression<Type> Array<Type>::Transpose() const
;;;457        {
;;;458          ConstArraySliceExpression<Type> expression(this->operator() ());
;;;459          expression.Transpose();
;;;460    
;;;461          return expression;
;;;462        }
;;;463    
;;;464    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;465        template<typename Type> s32 Array<Type>::Set(const cv::Mat_<Type> &in)
;;;466        {
;;;467          const s32 inHeight = in.rows;
;;;468          const s32 inWidth = in.cols;
;;;469    
;;;470          AnkiConditionalErrorAndReturnValue(inHeight != 0,
;;;471            0, "Array<Type>::Set", "input cv::Mat is invalid. If you use the release OpenCV libraries with the debug build, lots of things like file loading don't work.");
;;;472    
;;;473          const bool isColor = in.channels() == 3 || inWidth == this->size[1]*3;
;;;474    
;;;475          if(isColor) {
;;;476            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0],
;;;477              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;478          } else {
;;;479            AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;480              0, "Array<Type>::Set", "input cv::Mat is the incorrect size.");
;;;481          }
;;;482    
;;;483          for(s32 y=0; y<this->size[0]; y++) {
;;;484            const Type * restrict pIn = reinterpret_cast<const Type*>(in.ptr(y,0));
;;;485            Type * restrict pThis = this->Pointer(y,0);
;;;486    
;;;487            // If grayscale, just copy. If color, convert to grayscale
;;;488            if(isColor) {
;;;489              for(s32 x=0; x<this->size[1]; x++) {
;;;490                pThis[x] = (pIn[3*x] + pIn[3*x + 1] + pIn[3*x + 2]) / 3;
;;;491              }
;;;492            } else {
;;;493              memcpy(pThis, pIn, inWidth*sizeof(Type));
;;;494            }
;;;495          }
;;;496    
;;;497          return this->size[0]*this->size[1];
;;;498        }
;;;499    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;500    
;;;501        template<typename Type> void Array<Type>::Show(const char * const windowName, const bool waitForKeypress, const bool scaleValues, const bool fitImageToWindow) const
;;;502        {
;;;503    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;504          AnkiConditionalError(this->IsValid(), "Array<Type>::Show", "Array<Type> is not valid");
;;;505    
;;;506          if(fitImageToWindow) {
;;;507            cv::namedWindow(windowName, CV_WINDOW_NORMAL);
;;;508          } else {
;;;509            cv::namedWindow(windowName, CV_WINDOW_AUTOSIZE);
;;;510          }
;;;511    
;;;512          if(scaleValues) {
;;;513            cv::Mat_<f64> scaledArray;
;;;514    
;;;515            if(ArrayToCvMat(*this, &scaledArray) != RESULT_OK)
;;;516              return;
;;;517    
;;;518            const f64 minValue = Matrix::Min<Type>(*this);
;;;519            const f64 maxValue = Matrix::Max<Type>(*this);
;;;520            const f64 range = maxValue - minValue;
;;;521    
;;;522            scaledArray -= minValue;
;;;523            scaledArray /= range;
;;;524    
;;;525            cv::imshow(windowName, scaledArray);
;;;526          } else {
;;;527            cv::Mat_<Type> arrayCopy;
;;;528    
;;;529            if(ArrayToCvMat(*this, &arrayCopy) != RESULT_OK)
;;;530              return;
;;;531    
;;;532            cv::imshow(windowName, arrayCopy);
;;;533          }
;;;534    
;;;535          if(waitForKeypress) {
;;;536            cv::waitKey();
;;;537          }
;;;538    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;539        }
;;;540    
;;;541        template<typename Type> Result Array<Type>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;542        {
;;;543          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;544            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;545    
;;;546          CoreTechPrint(variableName);
;;;547          CoreTechPrint(":\n");
;;;548          for(s32 y=MAX(0,minY); y<MIN(maxY+1,size[0]); y++) {
;;;549            const Type * const pThisData = this->Pointer(y, 0);
;;;550            for(s32 x=MAX(0,minX); x<MIN(maxX+1,size[1]); x++) {
;;;551              pThisData[x].Print();
;;;552            }
;;;553            CoreTechPrint("\n");
;;;554          }
;;;555          CoreTechPrint("\n");
;;;556    
;;;557          return RESULT_OK;
;;;558        }
;;;559    
;;;560        template<typename Type> Result Array<Type>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;561        {
;;;562          return this->Print(variableName, minY, maxY, minX, maxX);
;;;563        }
;;;564    
;;;565        template<typename Type> bool Array<Type>::IsNearlyEqualTo(const Array<Type>& other, const Type epsilon) const
;;;566        {
;;;567          bool isSame = false;
;;;568          if(AreValid(*this, other)) {
;;;569            const s32 nrows = this->get_size(0);
;;;570            const s32 ncols = this->get_size(1);
;;;571    
;;;572            if(other.get_size(0)==nrows && other.get_size(1) == ncols) {
;;;573              isSame = true;
;;;574              for(s32 i=0; i<nrows && isSame; ++i) {
;;;575                const Type * restrict pThis  = this->Pointer(i,0);
;;;576                const Type * restrict pOther = other.Pointer(i,0);
;;;577    
;;;578                for(s32 j=0; j<ncols; ++j) {
;;;579                  if(!NEAR(pThis[j], pOther[j], epsilon)) {
;;;580                    isSame = false;
;;;581                    break;
;;;582                  }
;;;583                } // for j
;;;584              } // for i
;;;585            } // if sizes match
;;;586          } // if both valid
;;;587    
;;;588          return isSame;
;;;589        } // IsNearlyEqualTo()
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
;;;592        {
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
;;;602        }
;;;603    
;;;604        template<typename Type> Result Array<Type>::Resize(const s32 numRows, const s32 numCols, MemoryStack &memory)
;;;605        {
;;;606          AnkiConditionalErrorAndReturnValue(numCols > 0 && numRows > 0,
;;;607            RESULT_FAIL_INVALID_SIZE, "Array<Type>::Resize", "Invalid size");
;;;608    
;;;609          s32 numBytesAllocated = 0;
;;;610    
;;;611          this->data = reinterpret_cast<Type*>( AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, true) );
;;;612    
;;;613          // Don't clear the reallocated memory
;;;614          const bool clearMemory = this->flags.get_zeroAllocatedMemory();
;;;615          this->flags.set_zeroAllocatedMemory(false);
;;;616    
;;;617          const Result result = InitializeBuffer(numRows,
;;;618            numCols,
;;;619            this->data,
;;;620            numBytesAllocated,
;;;621            this->flags);
;;;622    
;;;623          this->flags.set_zeroAllocatedMemory(clearMemory);
;;;624    
;;;625          return result;
;;;626        }
;;;627    
;;;628        template<typename Type> s32 Array<Type>::SetZero()
;;;629        {
;;;630          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;631            0, "Array<Type>::SetZero", "Array<Type> is not valid");
;;;632    
;;;633          const s32 numBytes = this->get_size(0)*this->get_stride();
;;;634    
;;;635          memset(this->Pointer(0,0), 0, numBytes);
;;;636    
;;;637          return numBytes;
;;;638        }
;;;639    
;;;640        template<typename Type> s32 Array<Type>::Set(const Type value)
;;;641        {
;;;642          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;643            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;644    
;;;645          for(s32 y=0; y<size[0]; y++) {
;;;646            Type * restrict pThisData = Pointer(y, 0);
;;;647            for(s32 x=0; x<size[1]; x++) {
;;;648              pThisData[x] = value;
;;;649            }
;;;650          }
;;;651    
;;;652          return size[0]*size[1];
;;;653        }
;;;654    
;;;655        template<typename Type> s32 Array<Type>::Set(const Array<Type> &in)
;;;656        {
;;;657          return this->SetCast<Type>(in);
;;;658        }
;;;659    
;;;660        template<typename Type> template<typename InType> s32 Array<Type>::SetCast(const Array<InType> &in)
;;;661        {
;;;662          const s32 inHeight = in.get_size(0);
;;;663          const s32 inWidth = in.get_size(1);
;;;664    
;;;665          AnkiConditionalErrorAndReturnValue(AreValid(*this, in),
;;;666            0, "Array<Type>::Set", "Invalid objects");
;;;667    
;;;668          AnkiConditionalErrorAndReturnValue(inHeight == this->size[0] && inWidth == this->size[1],
;;;669            0, "Array<Type>::Set", "Array sizes don't match");
;;;670    
;;;671          for(s32 y=0; y<size[0]; y++) {
;;;672            const InType * restrict pIn = in.Pointer(y, 0);
;;;673            Type * restrict pThisData = Pointer(y, 0);
;;;674    
;;;675            for(s32 x=0; x<size[1]; x++) {
;;;676              pThisData[x] = saturate_cast<Type>(pIn[x]);
;;;677            }
;;;678          }
;;;679    
;;;680          return size[0]*size[1];
;;;681        }
;;;682    
;;;683        template<typename InType> s32 SetCast(const InType * const values, const s32 numValues)
;;;684        {
;;;685          // This is a little tough to write a general case for, so this method should be specialized
;;;686          // for each relevant case
;;;687          AnkiAssert(false);
;;;688    
;;;689          return 0;
;;;690        }
;;;691    
;;;692        template<typename Type> s32 Array<Type>::Set(const Type * const values, const s32 numValues)
;;;693        {
;;;694          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;695            0, "Array<Type>::Set", "Array<Type> is not valid");
;;;696    
;;;697          s32 numValuesSet = 0;
;;;698    
;;;699          for(s32 y=0; y<size[0]; y++) {
;;;700            u32 * restrict pThisData = reinterpret_cast<u32*>(Pointer(y, 0));
;;;701    
;;;702            const s32 numValuesThisRow = MAX(0, MIN(numValues - y*size[1], size[1]));
;;;703    
;;;704            if(numValuesThisRow > 0) {
;;;705              // For small data types, this may be too many bytes, but the stride padding should make
;;;706              // the writing okay (I think)
;;;707              const s32 numWordsToCopy = (sizeof(Type)*numValuesThisRow + 3) / 4;
;;;708    
;;;709              //memcpy(pThisData, values + y*size[1], numValuesThisRow*sizeof(Type));
;;;710              for(s32 x=0; x<numWordsToCopy; x++) {
;;;711                //AnkiAssert(reinterpret_cast<size_t>(values+y*size[1]) % 4 == 0);
;;;712                pThisData[x] = reinterpret_cast<const u32*>(values+y*size[1])[x];
;;;713              }
;;;714              numValuesSet += numValuesThisRow;
;;;715            }
;;;716    
;;;717            if(numValuesThisRow < size[1]) {
;;;718              memset(pThisData+numValuesThisRow*sizeof(Type), 0, (size[1]-numValuesThisRow)*sizeof(Type));
;;;719            }
;;;720          }
;;;721    
;;;722          return numValuesSet;
;;;723        }
;;;724    
;;;725        template<typename Type> Array<Type>& Array<Type>::operator= (const Array<Type> & rightHandSide)
;;;726        {
;;;727          this->size[0] = rightHandSide.size[0];
;;;728          this->size[1] = rightHandSide.size[1];
;;;729    
;;;730          this->stride = rightHandSide.stride;
;;;731          this->flags = rightHandSide.flags;
;;;732          this->data = rightHandSide.data;
;;;733    
;;;734          return *this;
;;;735        }
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
;;;738        {
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
;;;747    
;;;748        template<typename Type> s32 Array<Type>::get_stride() const
;;;749        {
;;;750          return stride;
;;;751        }
;;;752    
;;;753        template<typename Type> s32 Array<Type>::get_numElements() const
;;;754        {
;;;755          if(size[0] > 0 && size[1] > 0) {
;;;756            return size[0] * size[1];
;;;757          } else {
;;;758            return 0;
;;;759          }
;;;760        }
;;;761    
;;;762        template<typename Type> void* Array<Type>::get_buffer()
;;;763        {
;;;764          return data;
;;;765        }
;;;766    
;;;767        template<typename Type> const void* Array<Type>::get_buffer() const
;;;768        {
;;;769          return data;
;;;770        }
;;;771    
;;;772        template<typename Type> Flags::Buffer Array<Type>::get_flags() const
;;;773        {
;;;774          return flags;
;;;775        }
;;;776    
;;;777        template<typename Type> void* Array<Type>::AllocateBufferFromMemoryStack(const s32 numRows, const s32 stride, MemoryStack &memory, s32 &numBytesAllocated, const Flags::Buffer flags, bool reAllocate)
;;;778        {
;;;779          AnkiConditionalError(numRows >= 0 && stride > 0,
;;;780            "Array<Type>::AllocateBufferFromMemoryStack", "Invalid size");
;;;781    
;;;782          const s32 numRowsCapped = MAX(numRows, 1);
;;;783    
;;;784          this->stride = stride;
;;;785    
;;;786          const s32 numBytesRequested = numRowsCapped * this->stride;
;;;787    
;;;788          if(reAllocate) {
;;;789            return memory.Reallocate(this->data, numBytesRequested, numBytesAllocated);
;;;790          } else {
;;;791            return memory.Allocate(numBytesRequested, flags.get_zeroAllocatedMemory(), numBytesAllocated);
;;;792          }
;;;793        }
;;;794    
;;;795        template<typename Type> Result Array<Type>::InitializeBuffer(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const Flags::Buffer flags)
;;;796        {
;;;797          if(!rawData) {
;;;798            AnkiError("Anki.Array2d.initialize", "input data buffer is NULL");
;;;799            InvalidateArray();
;;;800            return RESULT_FAIL_UNINITIALIZED_MEMORY;
;;;801          }
;;;802    
;;;803          AnkiConditionalErrorAndReturnValue(numCols >= 0 && numRows >= 0 && dataLength >= MEMORY_ALIGNMENT,
;;;804            RESULT_FAIL_INVALID_SIZE, "Array<Type>::InitializeBuffer", "Negative dimension");
;;;805    
;;;806          AnkiConditionalErrorAndReturnValue(!flags.get_useBoundaryFillPatterns(),
;;;807            RESULT_FAIL_INVALID_PARAMETER, "Array<Type>::InitializeBuffer", "Fill patterns not supported for Array");
;;;808    
;;;809          this->flags = flags;
;;;810          this->size[0] = numRows;
;;;811          this->size[1] = numCols;
;;;812    
;;;813          // Initialize an empty array.
;;;814    
;;;815          this->data = reinterpret_cast<Type*>(rawData);
;;;816    
;;;817          const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData), MEMORY_ALIGNMENT) - reinterpret_cast<size_t>(rawData));
;;;818          const s32 requiredBytes = ComputeRequiredStride(numCols,flags)*numRows + extraAlignmentBytes;
;;;819    
;;;820          if(requiredBytes > dataLength) {
;;;821            AnkiError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);
;;;822            InvalidateArray();
;;;823            return RESULT_FAIL_OUT_OF_MEMORY;
;;;824          }
;;;825    
;;;826          this->data = reinterpret_cast<Type*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );
;;;827    
;;;828          //#if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;829          //      this->UpdateCvMatMirror(*this);
;;;830          //#endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;831    
;;;832          return RESULT_OK;
;;;833        } // Array<Type>::InitializeBuffer()
;;;834    
;;;835        // Set all the buffers and sizes to -1, to signal an invalid array
;;;836        template<typename Type> void Array<Type>::InvalidateArray()
;;;837        {
;;;838          this->size[0] = -1;
;;;839          this->size[1] = -1;
;;;840          this->stride = -1;
;;;841          this->data = NULL;
;;;842        } // void Array<Type>::InvalidateArray()
;;;843    
;;;844        template<typename Type> Result Array<Type>::PrintBasicType(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX)  const
;;;845        {
;;;846          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;847            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::Print", "Array<Type> is not valid");
;;;848    
;;;849          const s32 realMinX = MAX(0,minX);
;;;850          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;851          const s32 realMinY = MAX(0,minY);
;;;852          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;853    
;;;854          CoreTechPrint("%s type(int:%d,signed:%d,float:%d,sizeof:%d):\n", variableName, Flags::TypeCharacteristics<Type>::isInteger, Flags::TypeCharacteristics<Type>::isSigned, Flags::TypeCharacteristics<Type>::isFloat, sizeof(Type));
;;;855    
;;;856          for(s32 y=realMinY; y<realMaxY; y++) {
;;;857            const Type * const pThisData = this->Pointer(y, 0);
;;;858            for(s32 x=realMinX; x<realMaxX; x++) {
;;;859              if(Flags::TypeCharacteristics<Type>::isBasicType) {
;;;860                if(Flags::TypeCharacteristics<Type>::isInteger) {
;;;861                  CoreTechPrint("%d ", static_cast<s32>(pThisData[x]));
;;;862                } else {
;;;863                  if(version==1) {
;;;864                    CoreTechPrint("%f ", (float)pThisData[x]);
;;;865                  } else {
;;;866                    CoreTechPrint("%e ", (float)pThisData[x]);
;;;867                  }
;;;868                }
;;;869              } else {
;;;870                CoreTechPrint("! ");
;;;871              }
;;;872            }
;;;873            CoreTechPrint("\n");
;;;874          }
;;;875          CoreTechPrint("\n");
;;;876    
;;;877          return RESULT_OK;
;;;878        }
;;;879    
;;;880        template<typename Type> Result Array<Type>::PrintString(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const
;;;881        {
;;;882          AnkiConditionalErrorAndReturnValue(this->IsValid(),
;;;883            RESULT_FAIL_INVALID_OBJECT, "Array<Type>::PrintString", "Array<Type> is not valid");
;;;884    
;;;885          const s32 realMinX = MAX(0,minX);
;;;886          const s32 realMaxX = MIN(maxX+1,size[1]);
;;;887          const s32 realMinY = MAX(0,minY);
;;;888          const s32 realMaxY = MIN(maxY+1,size[0]);
;;;889    
;;;890          CoreTechPrint("%s:\n", variableName);
;;;891    
;;;892          for(s32 y=realMinY; y<realMaxY; y++) {
;;;893            const char * const * pThisData = this->Pointer(y, 0);
;;;894            for(s32 x=realMinX; x<realMaxX; x++) {
;;;895              const char * curString = pThisData[x];
;;;896              if(!curString) {
;;;897                CoreTechPrint("NULL, ");
;;;898              } else {
;;;899                CoreTechPrint("\"%s\", ", curString);
;;;900              }
;;;901            }
;;;902            CoreTechPrint("\n");
;;;903          }
;;;904          CoreTechPrint("\n");
;;;905    
;;;906          return RESULT_OK;
;;;907        }
;;;908    
;;;909        // #pragma mark --- FixedPointArray Definitions ---
;;;910    
;;;911        template<typename Type> FixedPointArray<Type>::FixedPointArray()
;;;912          : Array<Type>(), numFractionalBits(-1)
;;;913        {
;;;914        }
;;;915    
;;;916        template<typename Type> FixedPointArray<Type>::FixedPointArray(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const s32 numFractionalBits, const Flags::Buffer flags)
;;;917          : Array<Type>(numRows, numCols, data, dataLength, flags), numFractionalBits(numFractionalBits)
;;;918        {
;;;919          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= (sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;920        }
;;;921    
;;;922        template<typename Type> FixedPointArray<Type>::FixedPointArray(s32 numRows, s32 numCols, s32 numFractionalBits, MemoryStack &memory, const Flags::Buffer flags)
;;;923          : Array<Type>(numRows, numCols, memory, flags), numFractionalBits(numFractionalBits)
;;;924        {
;;;925          AnkiConditionalError(numFractionalBits >= 0 && numFractionalBits <= static_cast<s32>(sizeof(Type)*8),  "FixedPointArray<Type>", "numFractionalBits number is invalid");
;;;926        }
;;;927    
;;;928        template<typename Type> s32 FixedPointArray<Type>::get_numFractionalBits() const
;;;929        {
;;;930          return numFractionalBits;
;;;931        }
;;;932    
;;;933    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;934        template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;935        {
;;;936          AnkiConditionalErrorAndReturnValue(in.IsValid() && out,
;;;937            RESULT_FAIL, "ArrayToCvMat", "This Array is invalid");
;;;938    
;;;939          out->refcount = NULL;
;;;940    
;;;941          // These two should be set, because if the Mat_ constructor was not called, these will not be initialized
;;;942          out->step.p = out->step.buf;
;;;943          out->size = &out->rows;
;;;944    
;;;945          *out = cv::Mat_<Type>(in.get_size(0), in.get_size(1), const_cast<Type*>(in.Pointer(0,0)), static_cast<size_t>(in.get_stride()));
;;;946    
;;;947          return RESULT_OK;
;;;948        } // template<typename Type> Result ArrayToCvMat(const Array<Type> &in, cv::Mat *out)
;;;949    #endif // #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;950    
;;;951        // #pragma mark --- Array Specializations ---
;;;952    
;;;953        template<> Result Array<bool>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;954        template<> Result Array<u8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;955        template<> Result Array<s8>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;956        template<> Result Array<u16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;957        template<> Result Array<s16>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;958        template<> Result Array<u32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;959        template<> Result Array<s32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;960        template<> Result Array<u64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;961        template<> Result Array<s64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;962        template<> Result Array<f32>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;963        template<> Result Array<f64>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;964        template<> Result Array<const char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;965        template<> Result Array<char *>::Print(const char * const variableName, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;966    
;;;967        template<> Result Array<f32>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;968        template<> Result Array<f64>::PrintAlternate(const char * const variableName, const s32 version, const s32 minY, const s32 maxY, const s32 minX, const s32 maxX) const;
;;;969    
;;;970        template<> template<> s32 Array<u8>::SetCast(const s32 * const values, const s32 numValues);
;;;971        template<> template<> s32 Array<s16>::SetCast(const s32 * const values, const s32 numValues);
;;;972      } // namespace Embedded
;;;973    } //namespace Anki
;;;974    
;;;975    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_
;;;17     #include "anki/common/robot/arraySlices.h"
;;;1      /**
;;;2      File: arraySlices.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of arraySlices_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;14     
;;;15     #include "anki/common/robot/arraySlices_declarations.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         template<typename Type> ConstArraySlice<Type>::ConstArraySlice()
;;;23           : ySlice(LinearSequence<s32>()), xSlice(LinearSequence<s32>()), array(Array<Type>()), constArrayData(NULL)
;;;24         {
;;;25         }
;;;26     
;;;27         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array)
;;;28           : ySlice(LinearSequence<s32>(0,array.get_size(0)-1)), xSlice(LinearSequence<s32>(0,array.get_size(1)-1)), array(array)
;;;29         {
;;;30           if(array.get_numElements() == 0) {
;;;31             this->constArrayData = NULL;
;;;32           } else {
;;;33             this->constArrayData = array.Pointer(0,0);
;;;34           }
;;;35         }
;;;36     
;;;37         template<typename Type> ConstArraySlice<Type>::ConstArraySlice(const Array<Type> &array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;38           : ySlice(ySlice), xSlice(xSlice), array(array)
;;;39         {
;;;40           if(array.get_numElements() == 0) {
;;;41             this->constArrayData = NULL;
;;;42           } else {
;;;43             this->constArrayData = array.Pointer(0,0);
;;;44           }
;;;45         }
;;;46     
;;;47         template<typename Type> ConstArraySliceExpression<Type> ConstArraySlice<Type>::Transpose() const
;;;48         {
;;;49           ConstArraySliceExpression<Type> expression(*this, true);
;;;50     
;;;51           return expression;
;;;52         }
;;;53     
;;;54         template<typename Type> bool ConstArraySlice<Type>::IsValid() const
;;;55         {
;;;56           return this->array.IsValid();
;;;57         }
;;;58     
;;;59         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_ySlice() const
;;;60         {
;;;61           return ySlice;
;;;62         }
;;;63     
;;;64         template<typename Type> const LinearSequence<s32>& ConstArraySlice<Type>::get_xSlice() const
;;;65         {
;;;66           return xSlice;
;;;67         }
;;;68     
;;;69         template<typename Type> const Array<Type>& ConstArraySlice<Type>::get_array() const
;;;70         {
;;;71           return this->array;
;;;72         }
;;;73     
;;;74         template<typename Type> ArraySlice<Type>::ArraySlice()
;;;75           : ConstArraySlice<Type>(), arrayData(NULL)
;;;76         {
;;;77         }
;;;78     
;;;79         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array)
;;;80           : ConstArraySlice<Type>(array)
;;;81         {
;;;82           if(array.get_numElements() == 0) {
;;;83             this->arrayData = NULL;
;;;84           } else {
;;;85             this->arrayData = array.Pointer(0,0);
;;;86           }
;;;87         }
;;;88     
;;;89         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;90           : ConstArraySlice<Type>(array, ySlice, xSlice)
;;;91         {
;;;92           if(array.get_numElements() == 0) {
;;;93             this->arrayData = NULL;
;;;94           } else {
;;;95             this->arrayData = array.Pointer(0,0);
;;;96           }
;;;97         }
;;;98     
;;;99         template<typename Type> s32 ArraySlice<Type>::Set(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;100        {
;;;101          return this->SetCast<Type>(input, automaticTranspose);
;;;102        }
;;;103    
;;;104        template<typename Type> s32 ArraySlice<Type>::Set(const LinearSequence<Type> &input)
;;;105        {
;;;106          const Result result = input.Evaluate(*this);
;;;107          return (result==RESULT_OK) ? input.get_size() : 0;
;;;108        }
;;;109    
;;;110        template<typename Type> s32 ArraySlice<Type>::Set(const Type value)
;;;111        {
;;;112          Array<Type> &array = this->get_array();
;;;113    
;;;114          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;115            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;116    
;;;117          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;118    
;;;119          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;120            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;121    
;;;122          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;123            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;124            Type * restrict pMat = array.Pointer(y, 0);
;;;125    
;;;126            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;127              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;128              pMat[x] = value;
;;;129            }
;;;130          }
;;;131    
;;;132          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;133        }
;;;134    
;;;135        template<typename Type> s32 ArraySlice<Type>::Set(const Type * const values, const s32 numValues)
;;;136        {
;;;137          Array<Type> &array = this->get_array();
;;;138    
;;;139          AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;140            0, "ArraySlice<Type>::Set", "Array<Type> is not valid");
;;;141    
;;;142          const ArraySliceLimits_in1_out0<s32> limits(this->get_ySlice(), this->get_xSlice());
;;;143    
;;;144          AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;145            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;146    
;;;147          AnkiConditionalErrorAndReturnValue(limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize == numValues,
;;;148            0, "ArraySlice<Type>::Set", "Limits is not valid");
;;;149    
;;;150          s32 ci = 0;
;;;151          for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;152            const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;153            Type * restrict pMat = array.Pointer(y, 0);
;;;154    
;;;155            for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;156              const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;157              pMat[x] = values[ci];
;;;158              ci++;
;;;159            }
;;;160          }
;;;161    
;;;162          AnkiAssert(ci == limits.rawIn1Limits.ySize * limits.rawIn1Limits.xSize);
;;;163    
;;;164          return limits.rawIn1Limits.xSize*limits.rawIn1Limits.ySize;
;;;165        }
;;;166    
;;;167        template<typename Type> template<typename InType> s32 ArraySlice<Type>::SetCast(const ConstArraySliceExpression<Type> &input, bool automaticTranspose)
;;;168        {
;;;169          AnkiConditionalErrorAndReturnValue(AreValid(*this, input),
;;;170            0, "ArraySlice<Type>::Set", "Invalid objects");
;;;171    
;;;172          AnkiConditionalErrorAndReturnValue(this->get_array().get_buffer() != input.get_array().get_buffer(),
;;;173            0, "ArraySlice<Type>::Set", "Arrays must be in different memory locations");
;;;174    
;;;175          ArraySliceLimits_in1_out1<s32> limits(
;;;176            input.get_ySlice(), input.get_xSlice(), input.get_isTransposed(),
;;;177            this->get_ySlice(), this->get_xSlice());
;;;178    
;;;179          if(!limits.isValid) {
;;;180            if(automaticTranspose) {
;;;181              // If we're allowed to transpose, give it another shot
;;;182              limits = ArraySliceLimits_in1_out1<s32> (input.get_ySlice(), input.get_xSlice(), !input.get_isTransposed(), this->get_ySlice(), this->get_xSlice());
;;;183    
;;;184              if(!limits.isValid) {
;;;185                AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;186                return 0;
;;;187              }
;;;188            } else {
;;;189              AnkiError("ArraySlice<Type>::Set", "Subscripted assignment dimension mismatch");
;;;190              return 0;
;;;191            }
;;;192          }
;;;193    
;;;194          Array<Type> &out1Array = this->get_array();
;;;195          const Array<InType> &in1Array = input.get_array();
;;;196    
;;;197          if(limits.isSimpleIteration) {
;;;198            // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;199    
;;;200            for(s32 y=0; y<limits.ySize; y++) {
;;;201              const InType * restrict pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;202              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;203    
;;;204              limits.OuterIncrementTop();
;;;205    
;;;206              for(s32 x=0; x<limits.xSize; x++) {
;;;207                pOut1[limits.out1X] = static_cast<Type>( pIn1[limits.in1X] );
;;;208    
;;;209                limits.out1X += limits.out1_xInnerIncrement;
;;;210                limits.in1X += limits.in1_xInnerIncrement;
;;;211              }
;;;212    
;;;213              limits.OuterIncrementBottom();
;;;214            }
;;;215          } else {
;;;216            for(s32 y=0; y<limits.ySize; y++) {
;;;217              Type * restrict pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;218    
;;;219              limits.OuterIncrementTop();
;;;220    
;;;221              for(s32 x=0; x<limits.xSize; x++) {
;;;222                const InType pIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;223    
;;;224                pOut1[limits.out1X] = static_cast<Type>( pIn1 );
;;;225    
;;;226                limits.out1X += limits.out1_xInnerIncrement;
;;;227                limits.in1Y += limits.in1_yInnerIncrement;
;;;228              }
;;;229    
;;;230              limits.OuterIncrementBottom();
;;;231            }
;;;232          }
;;;233    
;;;234          return limits.ySize*limits.xSize;
;;;235        }
;;;236    
;;;237        template<typename Type> Array<Type>& ArraySlice<Type>::get_array()
;;;238        {
;;;239          return this->array;
;;;240        }
;;;241    
;;;242        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression()
;;;243          : ConstArraySlice<Type>(), isTransposed(false)
;;;244        {
;;;245        }
;;;246    
;;;247        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const Array<Type> input, bool isTransposed)
;;;248          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;249        {
;;;250        }
;;;251    
;;;252        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ArraySlice<Type> &input, bool isTransposed)
;;;253          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;254        {
;;;255        }
;;;256    
;;;257        template<typename Type> ConstArraySliceExpression<Type>::ConstArraySliceExpression(const ConstArraySlice<Type> &input, bool isTransposed)
;;;258          : ConstArraySlice<Type>(input), isTransposed(isTransposed)
;;;259        {
;;;260        }
;;;261    
;;;262        template<typename Type> ConstArraySliceExpression<Type> ConstArraySliceExpression<Type>::Transpose() const
;;;263        {
;;;264          ConstArraySliceExpression<Type> expression(*this, !this->get_isTransposed());
;;;265    
;;;266          return expression;
;;;267        }
;;;268    
;;;269        template<typename Type> bool ConstArraySliceExpression<Type>::get_isTransposed() const
;;;270        {
;;;271          return isTransposed;
;;;272        }
;;;273    
;;;274        template<typename Type> ArraySliceSimpleLimits<Type>::ArraySliceSimpleLimits(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;275          : xStart(in1_xSlice.get_start()), xIncrement(in1_xSlice.get_increment()), xSize(in1_xSlice.get_size()),
;;;276          yStart(in1_ySlice.get_start()), yIncrement(in1_ySlice.get_increment()), ySize(in1_ySlice.get_size())
;;;277        {
;;;278        }
;;;279    
;;;280        template<typename Type> ArraySliceLimits_in1_out0<Type>::ArraySliceLimits_in1_out0(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice)
;;;281          : isValid(true), rawIn1Limits(in1_ySlice, in1_xSlice)
;;;282        {
;;;283        } // ArraySliceLimits_in1_out0
;;;284    
;;;285        template<typename Type> ArraySliceLimits_in1_out1<Type>::ArraySliceLimits_in1_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;286          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;287          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;288          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed)
;;;289        {
;;;290          isValid = false;
;;;291    
;;;292          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;293    
;;;294          if(!in1_isTransposed) {
;;;295            if(rawOut1Limits.xSize == rawIn1Limits.xSize && rawOut1Limits.ySize == rawIn1Limits.ySize) {
;;;296              isValid = true;
;;;297              isSimpleIteration = true;
;;;298    
;;;299              this->in1Y = this->rawIn1Limits.yStart;
;;;300              this->out1Y = this->rawOut1Limits.yStart;
;;;301    
;;;302              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;303              this->in1_yInnerIncrement = 0;
;;;304            }
;;;305          } else { // if(!in1_isTransposed)
;;;306            if(rawOut1Limits.xSize == rawIn1Limits.ySize && rawOut1Limits.ySize == rawIn1Limits.xSize) {
;;;307              isValid = true;
;;;308              isSimpleIteration = false;
;;;309    
;;;310              this->in1X = this->rawIn1Limits.xStart;
;;;311              this->out1Y = this->rawOut1Limits.yStart;
;;;312    
;;;313              this->in1_xInnerIncrement = 0;
;;;314              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;315            }
;;;316          } // if(!in1_isTransposed) ... else
;;;317    
;;;318          if(!isValid) {
;;;319            AnkiError("ArraySliceLimits_in1_out1", "Subscripted assignment dimension mismatch");
;;;320            return;
;;;321          }
;;;322        } // ArraySliceLimits_in1_out1
;;;323    
;;;324        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;325        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;326        {
;;;327          if(isSimpleIteration) {
;;;328            this->in1X = this->rawIn1Limits.xStart;
;;;329            this->out1X = this->rawOut1Limits.xStart;
;;;330          } else { // if(isSimpleIteration)
;;;331            this->in1Y = this->rawIn1Limits.yStart;
;;;332            this->out1X = this->rawOut1Limits.xStart;
;;;333          } // if(isSimpleIteration) ... else
;;;334        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementTop()
;;;335    
;;;336        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;337        template<typename Type> inline void ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;338        {
;;;339          if(isSimpleIteration) {
;;;340            this->in1Y += this->rawIn1Limits.yIncrement;
;;;341            this->out1Y += this->rawOut1Limits.yIncrement;
;;;342          } else { // if(isSimpleIteration)
;;;343            this->in1X += this->rawIn1Limits.xIncrement;
;;;344            this->out1Y += this->rawOut1Limits.yIncrement;
;;;345          } // if(isSimpleIteration) ... else
;;;346        } // ArraySliceLimits_in1_out1<Type>::OuterIncrementBottom()
;;;347    
;;;348        template<typename Type> ArraySliceLimits_in2_out1<Type>::ArraySliceLimits_in2_out1(const LinearSequence<Type> &in1_ySlice, const LinearSequence<Type> &in1_xSlice, bool in1_isTransposed, const LinearSequence<Type> &in2_ySlice, const LinearSequence<Type> &in2_xSlice, bool in2_isTransposed, const LinearSequence<Type> &out1_ySlice, const LinearSequence<Type> &out1_xSlice)
;;;349          : ySize(out1_ySlice.get_size()), xSize(out1_xSlice.get_size()),
;;;350          rawOut1Limits(out1_ySlice, out1_xSlice),
;;;351          rawIn1Limits(in1_ySlice, in1_xSlice), in1_isTransposed(in1_isTransposed),
;;;352          rawIn2Limits(in2_ySlice, in2_xSlice), in2_isTransposed(in2_isTransposed)
;;;353        {
;;;354          isValid = false;
;;;355    
;;;356          this->out1_xInnerIncrement = this->rawOut1Limits.xIncrement;
;;;357          this->in1_yInnerIncrement = 0;
;;;358          this->in1_xInnerIncrement = 0;
;;;359          this->in2_yInnerIncrement = 0;
;;;360          this->in2_xInnerIncrement = 0;
;;;361    
;;;362          if(!in1_isTransposed && !in2_isTransposed) {
;;;363            const bool sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;364    
;;;365            if(sizesMatch) {
;;;366              isValid = true;
;;;367              isSimpleIteration = true;
;;;368    
;;;369              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;370              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;371    
;;;372              this->in1Y = this->rawIn1Limits.yStart;
;;;373              this->in2Y = this->rawIn2Limits.yStart;
;;;374              this->out1Y = this->rawOut1Limits.yStart;
;;;375            }
;;;376          } else { // if(!in1_isTransposed)
;;;377            isSimpleIteration = false;
;;;378    
;;;379            bool sizesMatch = false;
;;;380    
;;;381            if(in1_isTransposed && in2_isTransposed) {
;;;382              sizesMatch = (in1_xSlice.get_size() == in2_xSlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_ySlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;383              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;384              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;385            } else if(in1_isTransposed) {
;;;386              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_ySlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_xSlice.get_size());
;;;387              this->in1_yInnerIncrement = this->rawIn1Limits.yIncrement;
;;;388              this->in2_xInnerIncrement = this->rawIn2Limits.xIncrement;
;;;389            } else if(in2_isTransposed) {
;;;390              sizesMatch = (in1_xSlice.get_size() == in2_ySlice.get_size()) && (in1_xSlice.get_size() == out1_xSlice.get_size()) && (in1_ySlice.get_size() == in2_xSlice.get_size()) && (in1_ySlice.get_size() == out1_ySlice.get_size());
;;;391              this->in1_xInnerIncrement = this->rawIn1Limits.xIncrement;
;;;392              this->in2_yInnerIncrement = this->rawIn2Limits.yIncrement;
;;;393            } else {
;;;394              AnkiAssert(false); // should not be possible
;;;395            }
;;;396    
;;;397            if(!sizesMatch) {
;;;398              AnkiError("ArraySliceLimits_in2_out1", "Subscripted assignment dimension mismatch");
;;;399              return;
;;;400            }
;;;401    
;;;402            isValid = true;
;;;403    
;;;404            this->in1X = this->rawIn1Limits.xStart;
;;;405            this->in1Y = this->rawIn1Limits.yStart;
;;;406            this->in2X = this->rawIn2Limits.xStart;
;;;407            this->in2Y = this->rawIn2Limits.yStart;
;;;408    
;;;409            this->out1Y = this->rawOut1Limits.yStart;
;;;410          } // if(!in1_isTransposed) ... else
;;;411        } // ArraySliceLimits_in1_out1
;;;412    
;;;413        // This should be called at the top of the y-iteration loop, before the x-iteration loop. This will update the out1 and in# values for X and Y.
;;;414        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;415        {
;;;416          if(isSimpleIteration) {
;;;417            this->out1X = this->rawOut1Limits.xStart;
;;;418            this->in1X = this->rawIn1Limits.xStart;
;;;419            this->in2X = this->rawIn2Limits.xStart;
;;;420          } else { // if(isSimpleIteration)
;;;421            this->out1X = this->rawOut1Limits.xStart;
;;;422    
;;;423            if(in1_isTransposed) {
;;;424              this->in1Y = this->rawIn1Limits.yStart;
;;;425            } else {
;;;426              this->in1X = this->rawIn1Limits.xStart;
;;;427            }
;;;428    
;;;429            if(in2_isTransposed) {
;;;430              this->in2Y = this->rawIn2Limits.yStart;
;;;431            } else {
;;;432              this->in2X = this->rawIn2Limits.xStart;
;;;433            }
;;;434          } // if(isSimpleIteration) ... else
;;;435        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementTop()
;;;436    
;;;437        // This should be called at the botom of the y-iteration loop, after the x-iteration loop. This will update the out and in# values for X and Y.
;;;438        template<typename Type> inline void ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;439        {
;;;440          if(isSimpleIteration) {
;;;441            this->in1Y += this->rawIn1Limits.yIncrement;
;;;442            this->in2Y += this->rawIn2Limits.yIncrement;
;;;443            this->out1Y += this->rawOut1Limits.yIncrement;
;;;444          } else { // if(isSimpleIteration)
;;;445            this->out1Y += this->rawOut1Limits.yIncrement;
;;;446    
;;;447            if(in1_isTransposed) {
;;;448              this->in1X += this->rawIn1Limits.xIncrement;
;;;449            } else {
;;;450              this->in1Y += this->rawIn1Limits.yIncrement;
;;;451            }
;;;452    
;;;453            if(in2_isTransposed) {
;;;454              this->in2X += this->rawIn2Limits.xIncrement;
;;;455            } else {
;;;456              this->in2Y += this->rawIn2Limits.yIncrement;
;;;457            }
;;;458          } // if(isSimpleIteration) ... else
;;;459        } // ArraySliceLimits_in2_out1<Type>::OuterIncrementBottom()
;;;460      } // namespace Embedded
;;;461    } // namespace Anki
;;;462    
;;;463    #endif // _ANKICORETECHEMBEDDED_COMMON_ARRAYSLICES_H_
;;;18     #include "anki/common/robot/trig_fast.h"
;;;1      /**
;;;19     #include "anki/common/robot/benchmarking.h"
;;;1      /**
;;;2      File: benchmarkins.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Low-overhead benchmarking, based on a list of start and end events.
;;;7      
;;;8      The basic use of this benchmarking utility is as follows:
;;;9      1. InitBenchmarking()
;;;10     2. At the beginning of the section you want to benchmark, put BeginBenchmark("event type");
;;;11     3. At the end of the section you want to benchmark, put EndBenchmark("event type");
;;;12     4. When you're done running the program, call PrintBenchmarkResults() to print the results
;;;13     
;;;14     Copyright Anki, Inc. 2013
;;;15     For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;16     **/
;;;17     
;;;18     #ifndef _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;19     #define _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     
;;;21     #include "anki/common/robot/config.h"
;;;1      /**
;;;22     #include "anki/common/robot/fixedLengthList_declarations.h"
;;;1      /**
;;;23     
;;;24     namespace Anki
;;;25     {
;;;26       namespace Embedded
;;;27       {
;;;28         const s32 MAX_BENCHMARK_EVENTS = 16000;
;;;29     
;;;30         typedef struct BenchmarkElement
;;;31         {
;;;32           // All times in microseconds, on all platforms
;;;33     
;;;34           static const s32 NAME_LENGTH = 64;
;;;35     
;;;36           // Inclusive includes all the time for all sub-benchmarks
;;;37           u32 inclusive_mean;
;;;38           u32 inclusive_min;
;;;39           u32 inclusive_max;
;;;40           u32 inclusive_total;
;;;41     
;;;42           // Exclusive does not include sub-benchmarks
;;;43           u32 exclusive_mean;
;;;44           u32 exclusive_min;
;;;45           u32 exclusive_max;
;;;46           u32 exclusive_total;
;;;47     
;;;48           // How many times was this element's name benchmarked?
;;;49           u32 numEvents;
;;;50     
;;;51           char name[BenchmarkElement::NAME_LENGTH];
;;;52     
;;;53           BenchmarkElement(const char * name);
;;;54     
;;;55           // Print with CoreTechPrint()
;;;56           void Print(const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;57     
;;;58           // Like snprintf(). Returns the number of characters printed, not including the final null byte.
;;;59           s32 Snprint(char * buffer, const s32 bufferLength, const bool verbose=true, const bool microseconds=true, const FixedLengthList<s32> * minCharacterToPrint=NULL) const;
;;;60         } BenchmarkElement;
;;;61     
;;;62         typedef struct ShowBenchmarkParameters
;;;63         {
;;;64           char name[BenchmarkElement::NAME_LENGTH];
;;;65           bool showExclusiveTime;
;;;66           u8 red, green, blue;
;;;67     
;;;68           ShowBenchmarkParameters(
;;;69             const char * name,
;;;70             const bool showExclusiveTime,
;;;71             const u8 *color); //< Color is {R,G,B}
;;;72         } ShowBenchmarkParameters;
;;;73     
;;;74         // Call this before doing any benchmarking, to clear the buffer of benchmarkEvents.
;;;75         // Can be called multiple times.
;;;76         void InitBenchmarking();
;;;77     
;;;78         // Use these functions to add a new event to the list. These functions are very fast.
;;;79         //
;;;80         // WARNING: name must be in globally available memory
;;;81         //
;;;82         // WARNING: the character string must be less than BenchmarkElement::NAME_LENGTH bytes
;;;83         //
;;;84         // WARNING: Using the same name for different benchmark events
;;;85         //
;;;86         // WARNING: nesting BeginBenchmark() and EndBenchmark() events that have the same name won't work.
;;;87         // This is okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("b"); EndBenchmark("a");
;;;88         // This is not okay: BeginBenchmark("a"); BeginBenchmark("a"); EndBenchmark("a"); EndBenchmark("a");
;;;89         // This is not okay: BeginBenchmark("a"); BeginBenchmark("b"); EndBenchmark("a"); EndBenchmark("b");
;;;90         void BeginBenchmark(const char *name);
;;;91         void EndBenchmark(const char *name);
;;;92     
;;;93         // Compile all the benchmark events that were recorded
;;;94         FixedLengthList<BenchmarkElement> ComputeBenchmarkResults(MemoryStack &memory);
;;;95     
;;;96         // CoreTechPrint() the benchmark results
;;;97         // WARNING: This doesn't work well with multi-threaded programs
;;;98         Result PrintBenchmarkResults(const FixedLengthList<BenchmarkElement> &results, const bool verbose=true, const bool microseconds=true);
;;;99     
;;;100        // Compile and print out all the benchmark events that were recorded
;;;101        Result ComputeAndPrintBenchmarkResults(const bool verbose, const bool microseconds, MemoryStack scratch);
;;;102    
;;;103        // Use OpenCV to display a running benchmark
;;;104        // Requires a "TotalTime" benchmark event
;;;105        // namesToDisplay can be 11 or less names
;;;106        Result ShowBenchmarkResults(
;;;107          const FixedLengthList<BenchmarkElement> &results,
;;;108          const FixedLengthList<ShowBenchmarkParameters> &namesToDisplay,
;;;109          const f32 pixelsPerMillisecond,
;;;110          const s32 imageHeight,
;;;111          const s32 imageWidth);
;;;112    
;;;113        s32 GetNameIndex(const char * name, const FixedLengthList<BenchmarkElement> &outputResults);
;;;114      } // namespace Embedded
;;;115    } // namespace Anki
;;;116    
;;;117    #endif // _ANKICORETECHEMBEDDED_COMMON_BENCHMARKING_H_
;;;20     #include "anki/common/robot/comparisons.h"
;;;1      /**
;;;2      File: comparisons.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Definitions of comparisons_declarations.h
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;14     
;;;15     #include "anki/common/robot/comparisons_declarations.h"
;;;1      /**
;;;2      File: comparisons_declarations.h
;;;3      Author: Peter Barnum
;;;4      Created: 2013
;;;5      
;;;6      Various elementwise tests, to ensure that the data of two Arrays is equal.
;;;7      
;;;8      Copyright Anki, Inc. 2013
;;;9      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;10     **/
;;;11     
;;;12     #ifndef _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;13     #define _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;14     
;;;15     #include "anki/common/robot/config.h"
;;;1      /**
;;;16     #include "anki/common/robot/array2d_declarations.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark --- Declarations ---
;;;23         // Check every element of this array against the input array. If the arrays are different
;;;24         // sizes, uninitialized, or if any element is more different than the threshold, then
;;;25         // return false.
;;;26         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold = static_cast<Type>(0.0001));
;;;27     
;;;28         // Check every element of this array against the input array. If the arrays are different
;;;29         // sizes or uninitialized, return false. The percentThreshold is between 0.0 and 1.0. To
;;;30         // return false, an element must fail both thresholds. The percent threshold fails if an
;;;31         // element is more than a percentage different than its matching element (calulated from the
;;;32         // maximum of the two).
;;;33         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold = 0.01, const double absoluteThreshold = 0.0001);
;;;34     
;;;35         // If any of the input objects are not valid, then return false
;;;36         // NOTE: the objects must have an IsValid() method
;;;37         template<typename Type1> bool AreValid(const Type1 &object1);
;;;38         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2);
;;;39         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;40         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;41         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;42         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;43         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;44         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;45         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;46     
;;;47         // If the objects have different sizes or are uninitialized, then return false.
;;;48         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;49         template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2);
;;;50         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;51         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;52         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;53         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;54         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;55         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;56         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;57     
;;;58         // Check sizes against an input height and width
;;;59         template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1);
;;;60         template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2);
;;;61         template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;62         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;63         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;64         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;65         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;66         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;67         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;68     
;;;69         // If the Arrays are aliased (pointing to the same location in memory) or uninitialized, then return false
;;;70         // NOTE: the objects must have IsValid() and get_buffer() methods
;;;71         template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2);
;;;72         template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3);
;;;73         template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4);
;;;74         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5);
;;;75         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6);
;;;76         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7);
;;;77         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8);
;;;78         template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9);
;;;79       } // namespace Embedded
;;;80     } // namespace Anki
;;;81     
;;;82     #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_DECLARATIONS_H_
;;;16     #include "anki/common/robot/array2d.h"
;;;1      /**
;;;17     
;;;18     namespace Anki
;;;19     {
;;;20       namespace Embedded
;;;21       {
;;;22         // #pragma mark
;;;23     
;;;24         template<typename Type> bool AreElementwiseEqual(const Array<Type> &array1, const Array<Type> &array2, const Type threshold)
;;;25         {
;;;26           if(!AreEqualSize(array1, array2))
;;;27             return false;
;;;28     
;;;29           const s32 height = array1.get_size(0);
;;;30           const s32 width = array1.get_size(1);
;;;31     
;;;32           for(s32 y=0; y<height; y++) {
;;;33             const Type * const pArray1 = array1.Pointer(y, 0);
;;;34             const Type * const pArray2 = array2.Pointer(y, 0);
;;;35             for(s32 x=0; x<width; x++) {
;;;36               if(pArray1[x] > pArray2[x]) {
;;;37                 if((pArray1[x] - pArray2[x]) > threshold)
;;;38                   return false;
;;;39               } else {
;;;40                 if((pArray2[x] - pArray1[x]) > threshold)
;;;41                   return false;
;;;42               }
;;;43             }
;;;44           }
;;;45     
;;;46           return true;
;;;47         }
;;;48     
;;;49         template<typename Type> bool AreElementwiseEqual_PercentThreshold(const Array<Type> &array1, const Array<Type> &array2, const double percentThreshold, const double absoluteThreshold)
;;;50         {
;;;51           if(!AreEqualSize(array1, array2))
;;;52             return false;
;;;53     
;;;54           const s32 height = array1.get_size(0);
;;;55           const s32 width = array1.get_size(1);
;;;56     
;;;57           for(s32 y=0; y<height; y++) {
;;;58             const Type * const pArray1 = array1.Pointer(y, 0);
;;;59             const Type * const pArray2 = array2.Pointer(y, 0);
;;;60             for(s32 x=0; x<width; x++) {
;;;61               const double value1 = static_cast<double>(pArray1[x]);
;;;62               const double value2 = static_cast<double>(pArray2[x]);
;;;63               const double percentThresholdValue = percentThreshold * MAX(value1,value2);
;;;64     
;;;65               if(fabs(value1 - value2) > percentThresholdValue && fabs(value1 - value2) > absoluteThreshold)
;;;66                 return false;
;;;67             }
;;;68           }
;;;69     
;;;70           return true;
;;;71         }
;;;72     
;;;73         template<typename Type1> bool AreValid(const Type1 &object1)
;;;74         {
;;;75           if(!object1.IsValid())
;;;76             return false;
;;;77     
;;;78           return true;
;;;79         }
;;;80     
;;;81         template<typename Type1, typename Type2> bool AreValid(const Type1 &object1, const Type2 &object2)
;;;82         {
;;;83           if(!object1.IsValid() || !object2.IsValid())
;;;84             return false;
;;;85     
;;;86           return true;
;;;87         }
;;;88     
;;;89         template<typename Type1, typename Type2, typename Type3> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;90         {
;;;91           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid())
;;;92             return false;
;;;93     
;;;94           return true;
;;;95         }
;;;96     
;;;97         template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;98         {
;;;99           if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid())
;;;100            return false;
;;;101    
;;;102          return true;
;;;103        }
;;;104    
;;;105        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;106        {
;;;107          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid())
;;;108            return false;
;;;109    
;;;110          return true;
;;;111        }
;;;112    
;;;113        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;114        {
;;;115          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid())
;;;116            return false;
;;;117    
;;;118          return true;
;;;119        }
;;;120    
;;;121        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;122        {
;;;123          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid())
;;;124            return false;
;;;125    
;;;126          return true;
;;;127        }
;;;128    
;;;129        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;130        {
;;;131          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid())
;;;132            return false;
;;;133    
;;;134          return true;
;;;135        }
;;;136    
;;;137        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreValid(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;138        {
;;;139          if(!object1.IsValid() || !object2.IsValid() || !object3.IsValid() || !object4.IsValid() || !object5.IsValid() || !object6.IsValid() || !object7.IsValid() || !object8.IsValid() || !object9.IsValid())
;;;140            return false;
;;;141    
;;;142          return true;
;;;143        }
;;;144    
;;;145        template<typename Type1, typename Type2> bool AreEqualSize(const Type1 &object1, const Type2 &object2)
;;;146        {
;;;147          if(!AreValid(object1, object2))
;;;148            return false;
;;;149    
;;;150          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1))
;;;151            return false;
;;;152    
;;;153          return true;
;;;154        }
;;;155    
;;;156        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;157        {
;;;158          if(!AreValid(object1, object2, object3))
;;;159            return false;
;;;160    
;;;161          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;162            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1))
;;;163            return false;
;;;164    
;;;165          return true;
;;;166        }
;;;167    
;;;168        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;169        {
;;;170          if(!AreValid(object1, object2, object3, object4))
;;;171            return false;
;;;172    
;;;173          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;174            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;175            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1))
;;;176            return false;
;;;177    
;;;178          return true;
;;;179        }
;;;180    
;;;181        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;182        {
;;;183          if(!AreValid(object1, object2, object3, object4, object5))
;;;184            return false;
;;;185    
;;;186          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;187            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;188            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;189            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1))
;;;190            return false;
;;;191    
;;;192          return true;
;;;193        }
;;;194    
;;;195        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;196        {
;;;197          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;198            return false;
;;;199    
;;;200          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;201            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;202            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;203            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;204            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1))
;;;205            return false;
;;;206    
;;;207          return true;
;;;208        }
;;;209    
;;;210        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;211        {
;;;212          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;213            return false;
;;;214    
;;;215          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;216            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;217            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;218            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;219            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;220            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1))
;;;221            return false;
;;;222    
;;;223          return true;
;;;224        }
;;;225    
;;;226        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;227        {
;;;228          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;229            return false;
;;;230    
;;;231          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;232            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;233            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;234            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;235            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;236            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;237            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1))
;;;238            return false;
;;;239    
;;;240          return true;
;;;241        }
;;;242    
;;;243        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;244        {
;;;245          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;246            return false;
;;;247    
;;;248          if(object1.get_size(0) != object2.get_size(0) || object1.get_size(1) != object2.get_size(1) ||
;;;249            object1.get_size(0) != object3.get_size(0) || object1.get_size(1) != object3.get_size(1) ||
;;;250            object1.get_size(0) != object4.get_size(0) || object1.get_size(1) != object4.get_size(1) ||
;;;251            object1.get_size(0) != object5.get_size(0) || object1.get_size(1) != object5.get_size(1) ||
;;;252            object1.get_size(0) != object6.get_size(0) || object1.get_size(1) != object6.get_size(1) ||
;;;253            object1.get_size(0) != object7.get_size(0) || object1.get_size(1) != object7.get_size(1) ||
;;;254            object1.get_size(0) != object8.get_size(0) || object1.get_size(1) != object8.get_size(1) ||
;;;255            object1.get_size(0) != object9.get_size(0) || object1.get_size(1) != object9.get_size(1))
;;;256            return false;
;;;257    
;;;258          return true;
;;;259        }
;;;260    
;;;261        template<typename Type1> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1)
;;;262        {
;;;263          if(!AreValid(object1))
;;;264            return false;
;;;265    
;;;266          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;267            return false;
;;;268    
;;;269          return true;
;;;270        }
;;;271    
;;;272        template<typename Type1, typename Type2> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2)
;;;273        {
;;;274          if(!AreValid(object1, object2))
;;;275            return false;
;;;276    
;;;277          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;278            return false;
;;;279    
;;;280          return AreEqualSize(object1, object2);
;;;281        }
;;;282    
;;;283        template<typename Type1, typename Type2, typename Type3> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;284        {
;;;285          if(!AreValid(object1, object2, object3))
;;;286            return false;
;;;287    
;;;288          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;289            return false;
;;;290    
;;;291          return AreEqualSize(object1, object2, object3);
;;;292        }
;;;293    
;;;294        template<typename Type1, typename Type2, typename Type3, typename Type4> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;295        {
;;;296          if(!AreValid(object1, object2, object3, object4))
;;;297            return false;
;;;298    
;;;299          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;300            return false;
;;;301    
;;;302          return AreEqualSize(object1, object2, object3, object4);
;;;303        }
;;;304    
;;;305        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;306        {
;;;307          if(!AreValid(object1, object2, object3, object4, object5))
;;;308            return false;
;;;309    
;;;310          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;311            return false;
;;;312    
;;;313          return AreEqualSize(object1, object2, object3, object4, object5);
;;;314        }
;;;315    
;;;316        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;317        {
;;;318          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;319            return false;
;;;320    
;;;321          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;322            return false;
;;;323    
;;;324          return AreEqualSize(object1, object2, object3, object4, object5, object6);
;;;325        }
;;;326    
;;;327        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;328        {
;;;329          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;330            return false;
;;;331    
;;;332          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;333            return false;
;;;334    
;;;335          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7);
;;;336        }
;;;337    
;;;338        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;339        {
;;;340          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;341            return false;
;;;342    
;;;343          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;344            return false;
;;;345    
;;;346          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8);
;;;347        }
;;;348    
;;;349        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool AreEqualSize(const s32 height, const s32 width, const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;350        {
;;;351          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;352            return false;
;;;353    
;;;354          if(object1.get_size(0) != height || object1.get_size(1) != width)
;;;355            return false;
;;;356    
;;;357          return AreEqualSize(object1, object2, object3, object4, object5, object6, object7, object8, object9);
;;;358        }
;;;359    
;;;360        template<typename Type1, typename Type2> bool NotAliased(const Type1 &object1, const Type2 &object2)
;;;361        {
;;;362          if(!AreValid(object1, object2))
;;;363            return false;
;;;364    
;;;365          const size_t bufferPointers[] = {
;;;366            reinterpret_cast<size_t>(object1.get_buffer()),
;;;367            reinterpret_cast<size_t>(object2.get_buffer())};
;;;368    
;;;369          for(s32 i=0; i<2; i++) {
;;;370            for(s32 j=i+1; j<2; j++) {
;;;371              if(bufferPointers[i] == bufferPointers[j])
;;;372                return false;
;;;373            }
;;;374          }
;;;375    
;;;376          return true;
;;;377        }
;;;378    
;;;379        template<typename Type1, typename Type2, typename Type3> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3)
;;;380        {
;;;381          if(!AreValid(object1, object2, object3))
;;;382            return false;
;;;383    
;;;384          const size_t bufferPointers[] = {
;;;385            reinterpret_cast<size_t>(object1.get_buffer()),
;;;386            reinterpret_cast<size_t>(object2.get_buffer()),
;;;387            reinterpret_cast<size_t>(object3.get_buffer())};
;;;388    
;;;389          for(s32 i=0; i<3; i++) {
;;;390            for(s32 j=i+1; j<3; j++) {
;;;391              if(bufferPointers[i] == bufferPointers[j])
;;;392                return false;
;;;393            }
;;;394          }
;;;395    
;;;396          return true;
;;;397        }
;;;398    
;;;399        template<typename Type1, typename Type2, typename Type3, typename Type4> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4)
;;;400        {
;;;401          if(!AreValid(object1, object2, object3, object4))
;;;402            return false;
;;;403    
;;;404          const size_t bufferPointers[] = {
;;;405            reinterpret_cast<size_t>(object1.get_buffer()),
;;;406            reinterpret_cast<size_t>(object2.get_buffer()),
;;;407            reinterpret_cast<size_t>(object3.get_buffer()),
;;;408            reinterpret_cast<size_t>(object4.get_buffer())};
;;;409    
;;;410          for(s32 i=0; i<4; i++) {
;;;411            for(s32 j=i+1; j<4; j++) {
;;;412              if(bufferPointers[i] == bufferPointers[j])
;;;413                return false;
;;;414            }
;;;415          }
;;;416    
;;;417          return true;
;;;418        }
;;;419    
;;;420        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5)
;;;421        {
;;;422          if(!AreValid(object1, object2, object3, object4, object5))
;;;423            return false;
;;;424    
;;;425          const size_t bufferPointers[] = {
;;;426            reinterpret_cast<size_t>(object1.get_buffer()),
;;;427            reinterpret_cast<size_t>(object2.get_buffer()),
;;;428            reinterpret_cast<size_t>(object3.get_buffer()),
;;;429            reinterpret_cast<size_t>(object4.get_buffer()),
;;;430            reinterpret_cast<size_t>(object5.get_buffer())};
;;;431    
;;;432          for(s32 i=0; i<5; i++) {
;;;433            for(s32 j=i+1; j<5; j++) {
;;;434              if(bufferPointers[i] == bufferPointers[j])
;;;435                return false;
;;;436            }
;;;437          }
;;;438    
;;;439          return true;
;;;440        }
;;;441    
;;;442        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6)
;;;443        {
;;;444          if(!AreValid(object1, object2, object3, object4, object5, object6))
;;;445            return false;
;;;446    
;;;447          const size_t bufferPointers[] = {
;;;448            reinterpret_cast<size_t>(object1.get_buffer()),
;;;449            reinterpret_cast<size_t>(object2.get_buffer()),
;;;450            reinterpret_cast<size_t>(object3.get_buffer()),
;;;451            reinterpret_cast<size_t>(object4.get_buffer()),
;;;452            reinterpret_cast<size_t>(object5.get_buffer()),
;;;453            reinterpret_cast<size_t>(object6.get_buffer())};
;;;454    
;;;455          for(s32 i=0; i<6; i++) {
;;;456            for(s32 j=i+1; j<6; j++) {
;;;457              if(bufferPointers[i] == bufferPointers[j])
;;;458                return false;
;;;459            }
;;;460          }
;;;461    
;;;462          return true;
;;;463        }
;;;464    
;;;465        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7)
;;;466        {
;;;467          if(!AreValid(object1, object2, object3, object4, object5, object6, object7))
;;;468            return false;
;;;469    
;;;470          const size_t bufferPointers[] = {
;;;471            reinterpret_cast<size_t>(object1.get_buffer()),
;;;472            reinterpret_cast<size_t>(object2.get_buffer()),
;;;473            reinterpret_cast<size_t>(object3.get_buffer()),
;;;474            reinterpret_cast<size_t>(object4.get_buffer()),
;;;475            reinterpret_cast<size_t>(object5.get_buffer()),
;;;476            reinterpret_cast<size_t>(object6.get_buffer()),
;;;477            reinterpret_cast<size_t>(object7.get_buffer())};
;;;478    
;;;479          for(s32 i=0; i<7; i++) {
;;;480            for(s32 j=i+1; j<7; j++) {
;;;481              if(bufferPointers[i] == bufferPointers[j])
;;;482                return false;
;;;483            }
;;;484          }
;;;485    
;;;486          return true;
;;;487        }
;;;488    
;;;489        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8)
;;;490        {
;;;491          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8))
;;;492            return false;
;;;493    
;;;494          const size_t bufferPointers[] = {
;;;495            reinterpret_cast<size_t>(object1.get_buffer()),
;;;496            reinterpret_cast<size_t>(object2.get_buffer()),
;;;497            reinterpret_cast<size_t>(object3.get_buffer()),
;;;498            reinterpret_cast<size_t>(object4.get_buffer()),
;;;499            reinterpret_cast<size_t>(object5.get_buffer()),
;;;500            reinterpret_cast<size_t>(object6.get_buffer()),
;;;501            reinterpret_cast<size_t>(object7.get_buffer()),
;;;502            reinterpret_cast<size_t>(object8.get_buffer())};
;;;503    
;;;504          for(s32 i=0; i<8; i++) {
;;;505            for(s32 j=i+1; j<8; j++) {
;;;506              if(bufferPointers[i] == bufferPointers[j])
;;;507                return false;
;;;508            }
;;;509          }
;;;510    
;;;511          return true;
;;;512        }
;;;513    
;;;514        template<typename Type1, typename Type2, typename Type3, typename Type4, typename Type5, typename Type6, typename Type7, typename Type8, typename Type9> bool NotAliased(const Type1 &object1, const Type2 &object2, const Type3 &object3, const Type4 &object4, const Type5 &object5, const Type6 &object6, const Type7 &object7, const Type8 &object8, const Type9 &object9)
;;;515        {
;;;516          if(!AreValid(object1, object2, object3, object4, object5, object6, object7, object8, object9))
;;;517            return false;
;;;518    
;;;519          const size_t bufferPointers[] = {
;;;520            reinterpret_cast<size_t>(object1.get_buffer()),
;;;521            reinterpret_cast<size_t>(object2.get_buffer()),
;;;522            reinterpret_cast<size_t>(object3.get_buffer()),
;;;523            reinterpret_cast<size_t>(object4.get_buffer()),
;;;524            reinterpret_cast<size_t>(object5.get_buffer()),
;;;525            reinterpret_cast<size_t>(object6.get_buffer()),
;;;526            reinterpret_cast<size_t>(object7.get_buffer()),
;;;527            reinterpret_cast<size_t>(object8.get_buffer()),
;;;528            reinterpret_cast<size_t>(object9.get_buffer()) };
;;;529    
;;;530          for(s32 i=0; i<9; i++) {
;;;531            for(s32 j=i+1; j<9; j++) {
;;;532              if(bufferPointers[i] == bufferPointers[j])
;;;533                return false;
;;;534            }
;;;535          }
;;;536    
;;;537          return true;
;;;538        }
;;;539      } // namespace Embedded
;;;540    } // namespace Anki
;;;541    
;;;542    #endif // _ANKICORETECHEMBEDDED_COMMON_COMPARISONS_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26         namespace Matrix
;;;27         {
;;;28           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;29           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;30           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;31           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;32     
;;;33           template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;34           template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;35           template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;36           template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex);
;;;37     
;;;38           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;39           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;40           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;41           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;42     
;;;43           template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;44           template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize);
;;;45           template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;46           template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize);
;;;47     
;;;48           template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;49           {
;;;50             const Array<Type> &array = mat.get_array();
;;;51     
;;;52             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;53               0, "Matrix::Min", "Array<Type> is not valid");
;;;54     
;;;55             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;56     
;;;57             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;58               0, "Matrix::Min", "Limits is not valid");
;;;59     
;;;60             Type minValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;61             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;62               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;63               const Type * restrict pMat = array.Pointer(y, 0);
;;;64     
;;;65               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;66                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;67                 minValue = MIN(minValue, pMat[x]);
;;;68               }
;;;69             }
;;;70     
;;;71             return minValue;
;;;72           } // template<typename Type> Type Min(const ConstArraySliceExpression<Type> &mat)
;;;73     
;;;74           template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;75           {
;;;76             const Array<Type> &array = mat.get_array();
;;;77     
;;;78             AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;79               0, "Matrix::Max", "Array<Type> is not valid");
;;;80     
;;;81             const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;82     
;;;83             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;84               0, "Matrix::Max", "Limits is not valid");
;;;85     
;;;86             Type maxValue = *array.Pointer(limits.rawIn1Limits.yStart, limits.rawIn1Limits.xStart);
;;;87             for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;88               const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;89               const Type * restrict pMat = array.Pointer(y, 0);
;;;90     
;;;91               for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;92                 const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;93                 maxValue = MAX(maxValue, pMat[x]);
;;;94               }
;;;95             }
;;;96     
;;;97             return maxValue;
;;;98           } // template<typename Type> Type Max(const ConstArraySliceExpression<Type> &mat)
;;;99     
;;;100          template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const ConstArraySliceExpression<Array_Type> &mat)
;;;101          {
;;;102            const Array<Array_Type> &array = mat.get_array();
;;;103    
;;;104            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;105              0, "Matrix::Sum", "Array<Type> is not valid");
;;;106    
;;;107            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;108    
;;;109            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;110              0, "Matrix::Sum", "Limits is not valid");
;;;111    
;;;112            Accumulator_Type sum = 0;
;;;113            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;114              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;115              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;116    
;;;117              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;118                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;119                sum += pMat[x];
;;;120              }
;;;121            }
;;;122    
;;;123            return sum;
;;;124          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;125    
;;;126          template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;127          {
;;;128            const Accumulator_Type sum = Sum<Array_Type,Accumulator_Type>(mat);
;;;129            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;130            const Array_Type mean = static_cast<Array_Type>(sum / numElements);
;;;131    
;;;132            return mean;
;;;133          } // template<typename Array_Type, typename Accumulator_Type> Array_Type Mean(const ConstArraySliceExpression<Array_Type> &mat)
;;;134    
;;;135          template<typename Array_Type, typename Accumulator_Type> Result MeanAndVar(
;;;136            const ConstArraySliceExpression<Array_Type> &mat,
;;;137            Accumulator_Type& mean,
;;;138            Accumulator_Type& var)
;;;139          {
;;;140            const Array<Array_Type> &array = mat.get_array();
;;;141    
;;;142            AnkiConditionalErrorAndReturnValue(array.IsValid(),
;;;143              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Array<Type> is not valid");
;;;144    
;;;145            const ArraySliceLimits_in1_out0<s32> limits(mat.get_ySlice(), mat.get_xSlice());
;;;146    
;;;147            AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;148              RESULT_FAIL_INVALID_OBJECT, "Matrix::MeanAndVar", "Limits is not valid");
;;;149    
;;;150            Accumulator_Type sum = 0;
;;;151            Accumulator_Type sumSq = 0;
;;;152            for(s32 iy=0; iy<limits.rawIn1Limits.ySize; iy++) {
;;;153              const s32 y = limits.rawIn1Limits.yStart + iy * limits.rawIn1Limits.yIncrement;
;;;154              const Array_Type * restrict pMat = array.Pointer(y, 0);
;;;155    
;;;156              for(s32 ix=0; ix<limits.rawIn1Limits.xSize; ix++) {
;;;157                const s32 x = limits.rawIn1Limits.xStart + ix * limits.rawIn1Limits.xIncrement;
;;;158                const Accumulator_Type val = static_cast<Accumulator_Type>(pMat[x]);
;;;159                sum   += val;
;;;160                sumSq += val*val;
;;;161              }
;;;162            }
;;;163    
;;;164            const Accumulator_Type numElements = static_cast<Accumulator_Type>(mat.get_ySlice().get_size() * mat.get_xSlice().get_size());
;;;165    
;;;166            mean = sum / numElements;                  // mean = E[x]
;;;167            var  = (sumSq / numElements) - (mean*mean);  // var  = E[x^2] - E[x]^2
;;;168    
;;;169            return RESULT_OK;
;;;170          } // template<typename Array_Type, typename Accumulator_Type> Accumulator_Type Sum(const Array<Array_Type> &image)
;;;171    
;;;172          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;173          {
;;;174            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;175          } // template<typename Type> Result Add(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;176    
;;;177          template<typename InType, typename IntermediateType, typename OutType> Result Add(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;178          {
;;;179            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;180          }
;;;181    
;;;182          template<typename InType, typename IntermediateType, typename OutType> Result Add(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;183          {
;;;184            return Elementwise::ApplyOperation<InType, Elementwise::Add<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;185          }
;;;186    
;;;187          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;188          {
;;;189            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;190          } // template<typename Type> Result Subtract(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;191    
;;;192          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;193          {
;;;194            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;195          }
;;;196    
;;;197          template<typename InType, typename IntermediateType, typename OutType> Result Subtract(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;198          {
;;;199            return Elementwise::ApplyOperation<InType, Elementwise::Subtract<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;200          }
;;;201    
;;;202          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;203          {
;;;204            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;205          } // template<typename Type> Result DotMultiply(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;206    
;;;207          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;208          {
;;;209            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;210          }
;;;211    
;;;212          template<typename InType, typename IntermediateType, typename OutType> Result DotMultiply(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;213          {
;;;214            return Elementwise::ApplyOperation<InType, Elementwise::DotMultiply<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;215          }
;;;216    
;;;217          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;218          {
;;;219            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, in2, out);
;;;220          } // template<typename Type> Result DotDivide(const ConstArraySliceExpression<Type> &in1, const ConstArraySliceExpression<Type> &in2, const ArraySlice<Type> &out)
;;;221    
;;;222          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;223          {
;;;224            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(in1, value2, out);
;;;225          }
;;;226    
;;;227          template<typename InType, typename IntermediateType, typename OutType> Result DotDivide(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;228          {
;;;229            return Elementwise::ApplyOperation<InType, Elementwise::DotDivide<InType, IntermediateType, OutType>, OutType>(value1, in2, out);
;;;230          }
;;;231    
;;;232          template<typename InType, typename IntermediateType, typename OutType> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;233          {
;;;234            return Elementwise::ApplyOperation<InType, Elementwise::Exp<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;235          } // template<typename Type> Result Exp(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;236    
;;;237          template<typename InType, typename IntermediateType, typename OutType> Result Sqrt(const ConstArraySliceExpression<InType> &in, ArraySlice<OutType> out)
;;;238          {
;;;239            return Elementwise::ApplyOperation<InType, Elementwise::Sqrt<InType, IntermediateType, OutType>, OutType>(in, in, out);
;;;240          }
;;;241    
;;;242          template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;243          {
;;;244            const s32 in1Height = in1.get_size(0);
;;;245            const s32 in1Width = in1.get_size(1);
;;;246    
;;;247            const s32 in2Height = in2.get_size(0);
;;;248            const s32 in2Width = in2.get_size(1);
;;;249            const s32 in2Stride = in2.get_stride();
;;;250    
;;;251            AnkiConditionalErrorAndReturnValue(in1Width == in2Height,
;;;252              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;253    
;;;254            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2Width, out),
;;;255              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;256    
;;;257            for(s32 y1=0; y1<in1Height; y1++) {
;;;258              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;259              OutType * restrict pOut = out.Pointer(y1, 0);
;;;260    
;;;261              for(s32 x2=0; x2<in2Width; x2++) {
;;;262                const u8 * restrict pIn2 = reinterpret_cast<const u8*>(in2.Pointer(0, x2));
;;;263    
;;;264                OutType accumulator = 0;
;;;265    
;;;266                s32 y2;
;;;267                for(y2=0; y2<in2Height-3; y2+=4) {
;;;268                  const InType in1_0 = pIn1[y2];
;;;269                  const InType in1_1 = pIn1[y2+1];
;;;270                  const InType in1_2 = pIn1[y2+2];
;;;271                  const InType in1_3 = pIn1[y2+3];
;;;272    
;;;273                  const InType in2_0 = *reinterpret_cast<const InType*>(pIn2);
;;;274                  const InType in2_1 = *reinterpret_cast<const InType*>(pIn2 + in2Stride);
;;;275                  const InType in2_2 = *reinterpret_cast<const InType*>(pIn2 + 2*in2Stride);
;;;276                  const InType in2_3 = *reinterpret_cast<const InType*>(pIn2 + 3*in2Stride);
;;;277    
;;;278                  accumulator +=
;;;279                    in1_0 * in2_0 +
;;;280                    in1_1 * in2_1 +
;;;281                    in1_2 * in2_2 +
;;;282                    in1_3 * in2_3;
;;;283    
;;;284                  pIn2 += 4*in2Stride;
;;;285                }
;;;286    
;;;287                for(; y2<in2Height; y2++) {
;;;288                  accumulator += pIn1[y2] * (*reinterpret_cast<const InType*>(pIn2));
;;;289    
;;;290                  pIn2 += in2Stride;
;;;291                }
;;;292    
;;;293                pOut[x2] = accumulator;
;;;294              }
;;;295            }
;;;296    
;;;297            return RESULT_OK;
;;;298          } // template<typename InType, typename OutType> Result Multiply(const Array<InType> &in1, const Array<InType> &in2, Array<OutType> &out)
;;;299    
;;;300          template<typename InType, typename OutType> NO_INLINE Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;301          {
;;;302            const s32 in1Height = in1.get_size(0);
;;;303            const s32 in1Width = in1.get_size(1);
;;;304    
;;;305            const s32 in2TransposedHeight = in2Transposed.get_size(0);
;;;306            const s32 in2TransposedWidth = in2Transposed.get_size(1);
;;;307    
;;;308            AnkiConditionalErrorAndReturnValue(in1Width == in2TransposedWidth,
;;;309              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input matrices are incompatible sizes");
;;;310    
;;;311            AnkiConditionalErrorAndReturnValue(AreEqualSize(in1Height, in2TransposedHeight, out),
;;;312              RESULT_FAIL_INVALID_SIZE, "Multiply", "Input and Output matrices are incompatible sizes");
;;;313    
;;;314            for(s32 y1=0; y1<in1Height; y1++)
;;;315            {
;;;316              const InType * restrict pIn1 = in1.Pointer(y1, 0);
;;;317    
;;;318              for(s32 y2=0; y2<in2TransposedHeight; y2++) {
;;;319                const InType * restrict pIn2 = in2Transposed.Pointer(y2, 0);
;;;320    
;;;321                OutType accumulator = 0;
;;;322    
;;;323                s32 x;
;;;324                for(x=0; x<in2TransposedWidth-3; x+=4) {
;;;325                  const InType in1_0 = pIn1[x];
;;;326                  const InType in1_1 = pIn1[x+1];
;;;327                  const InType in1_2 = pIn1[x+2];
;;;328                  const InType in1_3 = pIn1[x+3];
;;;329    
;;;330                  const InType in2_0 = pIn2[x];
;;;331                  const InType in2_1 = pIn2[x+1];
;;;332                  const InType in2_2 = pIn2[x+2];
;;;333                  const InType in2_3 = pIn2[x+3];
;;;334    
;;;335                  accumulator +=
;;;336                    in1_0 * in2_0 +
;;;337                    in1_1 * in2_1 +
;;;338                    in1_2 * in2_2 +
;;;339                    in1_3 * in2_3;
;;;340                }
;;;341    
;;;342                for(; x<in2TransposedWidth; x++) {
;;;343                  accumulator += pIn1[x] * pIn2[x];
;;;344                }
;;;345    
;;;346                *out.Pointer(y1, y2) = accumulator;
;;;347              }
;;;348            }
;;;349    
;;;350            return RESULT_OK;
;;;351          } // template<typename InType, typename OutType> Result MultiplyTranspose(const Array<InType> &in1, const Array<InType> &in2Transposed, Array<OutType> &out)
;;;352    
;;;353          template<typename Type> Result SolveLeastSquaresWithCholesky(
;;;354            Array<Type> &A_L,       //!< Input A Matrix and Output lower-triangular L matrix
;;;355            Array<Type> &Bt_Xt,     //!< Input B-transpose matrix and Output X-transpose solution
;;;356            bool realCholesky,      //!< A real Cholesky is slower to compute, and not required if only the X solution is required
;;;357            bool &numericalFailure  //!< If true, the solver failed because of numerical instability
;;;358            )
;;;359          {
;;;360            const s32 matrixHeight = A_L.get_size(0);
;;;361            const s32 numSamples = Bt_Xt.get_size(0);
;;;362    
;;;363            numericalFailure = false;
;;;364    
;;;365            AnkiConditionalErrorAndReturnValue(AreValid(A_L, Bt_Xt),
;;;366              RESULT_FAIL_INVALID_OBJECT, "CholeskyDecomposition", "Invalid objects");
;;;367    
;;;368            AnkiConditionalErrorAndReturnValue(matrixHeight == A_L.get_size(1),
;;;369              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "A_L is not square");
;;;370    
;;;371            AnkiConditionalErrorAndReturnValue(Bt_Xt.get_size(1) == matrixHeight,
;;;372              RESULT_FAIL_INVALID_SIZE, "CholeskyDecomposition", "Xt and Bt are the wrong sizes");
;;;373    
;;;374            // TODO: check if symmetric and positive-definite
;;;375    
;;;376            const Type minStableValue = Anki::Embedded::Flags::numeric_limits<Type>::epsilon();
;;;377    
;;;378            for(s32 i = 0; i < matrixHeight; i++) {
;;;379              // First, compute the non-diagonal values
;;;380              // This uses the results from the diagonal inverse computation from previous iterations of i
;;;381              Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;382    
;;;383              for(s32 j = 0; j < i; j++) {
;;;384                Type * restrict pAL_yj = A_L.Pointer(j, 0);
;;;385    
;;;386                Type sum = pAL_yi[j];
;;;387                for(s32 k = 0; k < j; k++) {
;;;388                  const Type value1 = pAL_yi[k];
;;;389                  const Type value2 = pAL_yj[k];
;;;390                  sum -= value1*value2;
;;;391                }
;;;392    
;;;393                pAL_yi[j] = sum*pAL_yj[j];
;;;394              } // for(s32 j = 0; j < i; j++)
;;;395    
;;;396              // Second, compute the inverse of the diagonal
;;;397              {
;;;398                Type sum = pAL_yi[i];
;;;399                for(s32 k = 0; k < i; k++) {
;;;400                  const Type value = pAL_yi[k];
;;;401                  sum -= value*value;
;;;402                }
;;;403    
;;;404                if(sum < minStableValue) {
;;;405                  numericalFailure = true;
;;;406                  return RESULT_OK;
;;;407                }
;;;408    
;;;409                // TODO: change this f32 square root to f64 if Type==f64
;;;410                const Type sumRoot = static_cast<Type>(sqrtf(static_cast<f32>(sum)));
;;;411                pAL_yi[i] = static_cast<Type>(1) / sumRoot;
;;;412              }
;;;413            } // for(s32 i = 0; i < m; i++)
;;;414    
;;;415            // Solve L*y = b via forward substitution
;;;416            for(s32 i = 0; i < matrixHeight; i++) {
;;;417              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;418              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;419    
;;;420              for(s32 j = 0; j < numSamples; j++) {
;;;421                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;422    
;;;423                Type sum = pBX_yj[i];
;;;424                for(s32 k = 0; k < i; k++) {
;;;425                  const Type value1 = pAL_yi[k];
;;;426                  const Type value2 = pBX_yj[k];
;;;427                  sum -= value1*value2;
;;;428                }
;;;429    
;;;430                pBX_yj[i] = sum*pAL_yi[i];
;;;431              }
;;;432            }
;;;433    
;;;434            // Solve L'*X = Y via back substitution
;;;435            for(s32 i = matrixHeight-1; i >= 0; i--) {
;;;436              const Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;437              //Type * restrict pBX_yi = Bt_Xt.Pointer(i, 0);
;;;438    
;;;439              for(s32 j = 0; j < numSamples; j++) {
;;;440                Type * restrict pBX_yj = Bt_Xt.Pointer(j, 0);
;;;441    
;;;442                Type sum = pBX_yj[i];
;;;443                for(s32 k = matrixHeight-1; k > i; k-- ) {
;;;444                  const Type value1 = A_L[k][i];
;;;445                  const Type value2 = pBX_yj[k];
;;;446                  sum -= value1*value2;
;;;447                }
;;;448    
;;;449                pBX_yj[i] = sum*pAL_yi[i];
;;;450              }
;;;451            }
;;;452    
;;;453            if(realCholesky) {
;;;454              // Invert the diagonal values of L, and set upper triangular to zero
;;;455              for(s32 i = 0; i < matrixHeight; i++) {
;;;456                Type * restrict pAL_yi = A_L.Pointer(i, 0);
;;;457    
;;;458                pAL_yi[i] = static_cast<Type>(1) / pAL_yi[i];
;;;459    
;;;460                for(s32 j = i+1; j < matrixHeight; j++) {
;;;461                  pAL_yi[j] = 0;
;;;462                }
;;;463              }
;;;464            }
;;;465    
;;;466            return RESULT_OK;
;;;467          } // SolveLeastSquaresWithCholesky()
;;;468    
;;;469          template<typename Type> NO_INLINE Result EstimateHomography(
;;;470            const FixedLengthList<Point<Type> > &originalPoints,    //!< Four points in the original coordinate system
;;;471            const FixedLengthList<Point<Type> > &transformedPoints, //!< Four points in the transformed coordinate system
;;;472            Array<Type> &homography, //!< A 3x3 transformation matrix
;;;473            bool &numericalFailure, //!< Did the homography solver fail?
;;;474            MemoryStack scratch //!< Scratch memory
;;;475            )
;;;476          {
;;;477            const Type MAX_SOLVE_DISTANCE = static_cast<Type>(0.1);
;;;478    
;;;479            //BeginBenchmark("EstimateHomography_init");
;;;480    
;;;481            const s32 numPoints = originalPoints.get_size();
;;;482    
;;;483            AnkiConditionalErrorAndReturnValue(AreValid(originalPoints, transformedPoints, homography, scratch),
;;;484              RESULT_FAIL_INVALID_OBJECT, "EstimateHomography", "Invalid objects");
;;;485    
;;;486            AnkiConditionalErrorAndReturnValue(transformedPoints.get_size() == numPoints && numPoints >= 4,
;;;487              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "originalPoints and transformedPoints must be the same size, and have at least four points apiece.");
;;;488    
;;;489            AnkiConditionalErrorAndReturnValue(AreEqualSize(3, 3, homography),
;;;490              RESULT_FAIL_INVALID_SIZE, "EstimateHomography", "homography must be 3x3");
;;;491    
;;;492            homography.SetZero();
;;;493            homography[0][0] = 1;
;;;494            homography[1][1] = 1;
;;;495            homography[2][2] = 1;
;;;496    
;;;497            Array<Type> A(8, 2*numPoints, scratch);
;;;498            Array<Type> bt(1, 2*numPoints, scratch);
;;;499    
;;;500            const Point<Type> * const pOriginalPoints = originalPoints.Pointer(0);
;;;501            const Point<Type> * const pTransformedPoints = transformedPoints.Pointer(0);
;;;502    
;;;503            Type * restrict pBt = bt.Pointer(0,0);
;;;504    
;;;505            //EndBenchmark("EstimateHomography_init");
;;;506    
;;;507            //BeginBenchmark("EstimateHomography_a&b");
;;;508    
;;;509            for(s32 i=0; i<numPoints; i++) {
;;;510              Type * restrict A_y1 = A.Pointer(2*i, 0);
;;;511              Type * restrict A_y2 = A.Pointer(2*i + 1, 0);
;;;512    
;;;513              const Type xi = pOriginalPoints[i].x;
;;;514              const Type yi = pOriginalPoints[i].y;
;;;515    
;;;516              const Type xp = pTransformedPoints[i].x;
;;;517              const Type yp = pTransformedPoints[i].y;
;;;518    
;;;519              A_y1[0] = 0;  A_y1[1] = 0;  A_y1[2] = 0; A_y1[3] = -xi; A_y1[4] = -yi; A_y1[5] = -1; A_y1[6] = xi*yp;  A_y1[7] = yi*yp;
;;;520              A_y2[0] = xi; A_y2[1] = yi; A_y2[2] = 1; A_y2[3] = 0;   A_y2[4] = 0;   A_y2[5] = 0;  A_y2[6] = -xi*xp; A_y2[7] = -yi*xp;
;;;521    
;;;522              pBt[2*i] = -yp;
;;;523              pBt[2*i + 1] = xp;
;;;524            }
;;;525    
;;;526            //EndBenchmark("EstimateHomography_a&b");
;;;527    
;;;528            //BeginBenchmark("EstimateHomography_At");
;;;529    
;;;530            Array<Type> At(2*numPoints, 8, scratch);
;;;531    
;;;532            Matrix::Transpose(A, At);
;;;533    
;;;534            //EndBenchmark("EstimateHomography_At");
;;;535    
;;;536            //BeginBenchmark("EstimateHomography_AtA");
;;;537    
;;;538            Array<Type> AtA(8, 8, scratch, Flags::Buffer(false,false,false));
;;;539            Array<Type> Atb(8, 1, scratch, Flags::Buffer(false,false,false));
;;;540    
;;;541            Matrix::Multiply(At, A, AtA);
;;;542    
;;;543            //EndBenchmark("EstimateHomography_AtA");
;;;544    
;;;545            //BeginBenchmark("EstimateHomography_Atb");
;;;546    
;;;547            Matrix::MultiplyTranspose(At, bt, Atb);
;;;548    
;;;549            //EndBenchmark("EstimateHomography_Atb");
;;;550    
;;;551            //BeginBenchmark("EstimateHomography_transposeAtb");
;;;552    
;;;553            Array<Type> Atbt(1, 8, scratch);
;;;554    
;;;555            Matrix::Transpose(Atb, Atbt);
;;;556    
;;;557            //EndBenchmark("EstimateHomography_transposeAtb");
;;;558    
;;;559            //BeginBenchmark("EstimateHomography_cholesky");
;;;560    
;;;561            const Result choleskyResult = SolveLeastSquaresWithCholesky(AtA, Atbt, false, numericalFailure);
;;;562    
;;;563            AnkiConditionalErrorAndReturnValue(choleskyResult == RESULT_OK,
;;;564              choleskyResult, "EstimateHomography", "SolveLeastSquaresWithCholesky failed");
;;;565    
;;;566            if(numericalFailure){
;;;567              AnkiWarn("EstimateHomography", "numericalFailure");
;;;568              return RESULT_OK;
;;;569            }
;;;570    
;;;571            Type * restrict pAtbt = Atbt.Pointer(0,0);
;;;572    
;;;573            homography[0][0] = pAtbt[0]; homography[0][1] = pAtbt[1]; homography[0][2] = pAtbt[2];
;;;574            homography[1][0] = pAtbt[3]; homography[1][1] = pAtbt[4]; homography[1][2] = pAtbt[5];
;;;575            homography[2][0] = pAtbt[6]; homography[2][1] = pAtbt[7]; homography[2][2] = static_cast<Type>(1);
;;;576    
;;;577            // Check that the solution is fairly close
;;;578            // TODO: make work for numPoints != 4
;;;579            if(numPoints == 4) {
;;;580              Array<Type> point1(3,1,scratch);
;;;581              Array<Type> point1Warped(3,1,scratch);
;;;582              for(s32 iPoint=0; iPoint<numPoints; iPoint++) {
;;;583                point1[0][0] = originalPoints[iPoint].x;
;;;584                point1[1][0] = originalPoints[iPoint].y;
;;;585                point1[2][0] = 1;
;;;586    
;;;587                Matrix::Multiply(homography, point1, point1Warped);
;;;588                point1Warped[0][0] /= point1Warped[2][0];
;;;589                point1Warped[1][0] /= point1Warped[2][0];
;;;590    
;;;591                const Type distance = sqrtf(powf(static_cast<f32>(transformedPoints[iPoint].x) - static_cast<f32>(point1Warped[0][0]), 2.0f) + powf(static_cast<f32>(transformedPoints[iPoint].y) - static_cast<f32>(point1Warped[1][0]), 2.0f));
;;;592    
;;;593                if(distance > MAX_SOLVE_DISTANCE) {
;;;594                  AnkiWarn("EstimateHomography", "Poor solution precision");
;;;595    
;;;596                  numericalFailure = true;
;;;597    
;;;598                  homography.SetZero();
;;;599                  homography[0][0] = 1;
;;;600                  homography[1][1] = 1;
;;;601                  homography[2][2] = 1;
;;;602    
;;;603                  return RESULT_OK;
;;;604                }
;;;605              }
;;;606            }
;;;607            //EndBenchmark("EstimateHomography_cholesky");
;;;608    
;;;609            return RESULT_OK;
;;;610          } // EstimateHomography()
;;;611    
;;;612          template<typename InType, typename OutType> Result Reshape(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;613          {
;;;614            const s32 inHeight = in.get_size(0);
;;;615            const s32 inWidth = in.get_size(1);
;;;616    
;;;617            const s32 outHeight = out.get_size(0);
;;;618            const s32 outWidth = out.get_size(1);
;;;619    
;;;620            AnkiConditionalErrorAndReturnValue((inHeight*inWidth) == (outHeight*outWidth),
;;;621              RESULT_FAIL_INVALID_SIZE, "Reshape", "Input and Output matrices are incompatible sizes");
;;;622    
;;;623            s32 inIndexY = 0;
;;;624            s32 inIndexX = 0;
;;;625    
;;;626            if(isColumnMajor) {
;;;627              for(s32 y = 0; y < outHeight; y++)
;;;628              {
;;;629                OutType * const pOut = out.Pointer(y,0);
;;;630    
;;;631                for(s32 x = 0; x < outWidth; x++) {
;;;632                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;633    
;;;634                  pOut[x] = static_cast<OutType>(curIn);
;;;635    
;;;636                  inIndexY++;
;;;637                  if(inIndexY >= inHeight) {
;;;638                    inIndexY = 0;
;;;639                    inIndexX++;
;;;640                  }
;;;641                }
;;;642              }
;;;643            } else { // if(isColumnMajor)
;;;644              for(s32 y = 0; y < outHeight; y++)
;;;645              {
;;;646                OutType * const pOut = out.Pointer(y,0);
;;;647    
;;;648                for(s32 x = 0; x < outWidth; x++) {
;;;649                  const InType curIn = *in.Pointer(inIndexY,inIndexX);
;;;650    
;;;651                  pOut[x] = static_cast<OutType>(curIn);
;;;652    
;;;653                  inIndexX++;
;;;654                  if(inIndexX >= inWidth) {
;;;655                    inIndexX = 0;
;;;656                    inIndexY++;
;;;657                  }
;;;658                }
;;;659              }
;;;660            } // if(isColumnMajor) ... else
;;;661    
;;;662            return RESULT_OK;
;;;663          } // Reshape()
;;;664    
;;;665          template<typename InType, typename OutType> Array<OutType> Reshape(const bool isColumnMajor, const Array<InType> &in, const s32 newHeight, const s32 newWidth, MemoryStack &memory)
;;;666          {
;;;667            Array<OutType> out(newHeight, newWidth, memory);
;;;668    
;;;669            Reshape<InType, OutType>(isColumnMajor, in, out);
;;;670    
;;;671            return out;
;;;672          }
;;;673    
;;;674          template<typename InType, typename OutType> Result Vectorize(const bool isColumnMajor, const Array<InType> &in, Array<OutType> &out)
;;;675          {
;;;676            AnkiConditionalErrorAndReturnValue(out.get_size(0) == 1,
;;;677              RESULT_FAIL_INVALID_SIZE, "Vectorize", "Output is not 1xN");
;;;678    
;;;679            return Reshape<InType, OutType>(isColumnMajor, in, out);
;;;680          }
;;;681    
;;;682          template<typename InType, typename OutType> Array<OutType> Vectorize(const bool isColumnMajor, const Array<InType> &in, MemoryStack &memory)
;;;683          {
;;;684            const s32 inHeight = in.get_size(0);
;;;685            const s32 inWidth = in.get_size(1);
;;;686    
;;;687            Array<OutType> out(1, inHeight*inWidth, memory);
;;;688    
;;;689            Vectorize<InType, OutType>(isColumnMajor, in, out);
;;;690    
;;;691            return out;
;;;692          }
;;;693    
;;;694          template<typename InType, typename OutType> Result Transpose(const Array<InType> &in, Array<OutType> &out)
;;;695          {
;;;696            const s32 inHeight = in.get_size(0);
;;;697            const s32 inWidth = in.get_size(1);
;;;698    
;;;699            const s32 outStride = out.get_stride();
;;;700    
;;;701            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;702              RESULT_FAIL_INVALID_OBJECT, "Transpose", "Invalid objects");
;;;703    
;;;704            AnkiConditionalErrorAndReturnValue(AreEqualSize(in.get_size(1), in.get_size(0), out),
;;;705              RESULT_FAIL_INVALID_SIZE, "Transpose", "out is not the correct size");
;;;706    
;;;707            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;708              RESULT_FAIL_ALIASED_MEMORY, "Transpose", "in and out cannot be the same array");
;;;709    
;;;710            for(s32 yIn=0; yIn<inHeight; yIn++) {
;;;711              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;712              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0,yIn));
;;;713    
;;;714              s32 xIn;
;;;715              s32 outOffset0 = 0;
;;;716    
;;;717              for(xIn=0; xIn<inWidth-1; xIn+=2) {
;;;718                const InType in0 = pIn[xIn];
;;;719                const InType in1 = pIn[xIn+1];
;;;720    
;;;721                const s32 outOffset1 = outOffset0 + outStride;
;;;722    
;;;723                *reinterpret_cast<OutType*>(pOut + outOffset0) = static_cast<OutType>(in0);
;;;724                *reinterpret_cast<OutType*>(pOut + outOffset1) = static_cast<OutType>(in1);
;;;725    
;;;726                outOffset0 += 2*outStride;
;;;727              }
;;;728    
;;;729              for(; xIn<inWidth; xIn++) {
;;;730                *out.Pointer(xIn,yIn) = static_cast<OutType>(pIn[xIn]);
;;;731              }
;;;732            }
;;;733    
;;;734            return RESULT_OK;
;;;735          } // Transpose()
;;;736    
;;;737          template<typename InType, typename OutType> Result Rotate90(const Array<InType> &in, Array<OutType> &out)
;;;738          {
;;;739            const s32 arrWidth = in.get_size(1);
;;;740    
;;;741            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;742              RESULT_FAIL_INVALID_OBJECT, "Rotate90", "Invalid objects");
;;;743    
;;;744            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;745              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;746    
;;;747            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;748              RESULT_FAIL_INVALID_SIZE, "Rotate90", "in and out must be square");
;;;749    
;;;750            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;751              RESULT_FAIL_ALIASED_MEMORY, "Rotate90", "in and out cannot be the same array");
;;;752    
;;;753            const s32 outStride = out.get_stride();
;;;754    
;;;755            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;756              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;757              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(0, arrWidth-yIn-1));
;;;758    
;;;759              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;760                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;761    
;;;762                pOut += outStride;
;;;763              }
;;;764            }
;;;765    
;;;766            return RESULT_OK;
;;;767          } // Rotate90()
;;;768    
;;;769          template<typename InType, typename OutType> Result Rotate180(const Array<InType> &in, Array<OutType> &out)
;;;770          {
;;;771            const s32 arrWidth = in.get_size(1);
;;;772    
;;;773            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;774              RESULT_FAIL_INVALID_OBJECT, "Rotate180", "Invalid objects");
;;;775    
;;;776            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;777              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;778    
;;;779            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;780              RESULT_FAIL_INVALID_SIZE, "Rotate180", "in and out must be square");
;;;781    
;;;782            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;783              RESULT_FAIL_ALIASED_MEMORY, "Rotate180", "in and out cannot be the same array");
;;;784    
;;;785            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;786              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;787              OutType * restrict pOut = out.Pointer(arrWidth-yIn-1, 0);
;;;788    
;;;789              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;790                pOut[arrWidth-xIn-1] = static_cast<OutType>(pIn[xIn]);
;;;791              }
;;;792            }
;;;793    
;;;794            return RESULT_OK;
;;;795          } // Rotate180()
;;;796    
;;;797          template<typename InType, typename OutType> Result Rotate270(const Array<InType> &in, Array<OutType> &out)
;;;798          {
;;;799            const s32 arrWidth = in.get_size(1);
;;;800    
;;;801            AnkiConditionalErrorAndReturnValue(AreValid(in, out),
;;;802              RESULT_FAIL_INVALID_OBJECT, "Rotate270", "Invalid objects");
;;;803    
;;;804            AnkiConditionalErrorAndReturnValue(in.get_size(0) == in.get_size(1),
;;;805              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;806    
;;;807            AnkiConditionalErrorAndReturnValue(AreEqualSize(arrWidth, arrWidth, out),
;;;808              RESULT_FAIL_INVALID_SIZE, "Rotate270", "in and out must be square");
;;;809    
;;;810            AnkiConditionalErrorAndReturnValue(NotAliased(in, out),
;;;811              RESULT_FAIL_ALIASED_MEMORY, "Rotate270", "in and out cannot be the same array");
;;;812    
;;;813            const s32 outStride = out.get_stride();
;;;814    
;;;815            for(s32 yIn=0; yIn<arrWidth; yIn++) {
;;;816              const InType * restrict pIn = in.Pointer(yIn, 0);
;;;817              u8 * restrict pOut = reinterpret_cast<u8*>(out.Pointer(arrWidth-1, yIn));
;;;818    
;;;819              for(s32 xIn=0; xIn<arrWidth; xIn++) {
;;;820                (reinterpret_cast<OutType *>(pOut))[0] = static_cast<OutType>(pIn[xIn]);
;;;821    
;;;822                pOut -= outStride;
;;;823              }
;;;824            }
;;;825    
;;;826            return RESULT_OK;
;;;827          } // Rotate270()
;;;828    
;;;829          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;830          {
;;;831            const s32 arrWidth = arr.get_size(1);
;;;832    
;;;833            for(s32 x=0; x<arrWidth; x++) {
;;;834              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;835                const Type valueToInsert = arr[y][x];
;;;836    
;;;837                s32 holePosition = y;
;;;838    
;;;839                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;840                  arr[holePosition][x] = arr[holePosition-1][x];
;;;841                  holePosition--;
;;;842                }
;;;843    
;;;844                arr[holePosition][x] = valueToInsert;
;;;845              }
;;;846            } // for(s32 x=0; x<arrWidth; x++)
;;;847          } // InsertionSort_sortAscendingDimension0()
;;;848    
;;;849          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;850          {
;;;851            const s32 arrWidth = arr.get_size(1);
;;;852    
;;;853            for(s32 x=0; x<arrWidth; x++) {
;;;854              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;855                const Type valueToInsert = arr[y][x];
;;;856    
;;;857                s32 holePosition = y;
;;;858    
;;;859                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;860                  arr[holePosition][x] = arr[holePosition-1][x];
;;;861                  holePosition--;
;;;862                }
;;;863    
;;;864                arr[holePosition][x] = valueToInsert;
;;;865              }
;;;866            } // for(s32 x=0; x<arrWidth; x++)
;;;867          } // InsertionSort_sortDescendingDimension0
;;;868    
;;;869          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;870          {
;;;871            const s32 arrHeight = arr.get_size(0);
;;;872    
;;;873            for(s32 y=0; y<arrHeight; y++) {
;;;874              Type * const pArr = arr[y];
;;;875    
;;;876              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;877                const Type valueToInsert = pArr[x];
;;;878    
;;;879                s32 holePosition = x;
;;;880    
;;;881                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;882                  pArr[holePosition] = pArr[holePosition-1];
;;;883                  holePosition--;
;;;884                }
;;;885    
;;;886                pArr[holePosition] = valueToInsert;
;;;887              }
;;;888            } // for(s32 x=0; x<arrWidth; x++)
;;;889          } // InsertionSort_sortAscendingDimension1()
;;;890    
;;;891          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;892          {
;;;893            const s32 arrHeight = arr.get_size(0);
;;;894    
;;;895            for(s32 y=0; y<arrHeight; y++) {
;;;896              Type * const pArr = arr[y];
;;;897    
;;;898              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;899                const Type valueToInsert = pArr[x];
;;;900    
;;;901                s32 holePosition = x;
;;;902    
;;;903                while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;904                  pArr[holePosition] = pArr[holePosition-1];
;;;905                  holePosition--;
;;;906                }
;;;907    
;;;908                pArr[holePosition] = valueToInsert;
;;;909              }
;;;910            } // for(s32 x=0; x<arrWidth; x++)
;;;911          } // InsertionSort_sortAscendingDimension1()
;;;912    
;;;913          template<typename Type> void InsertionSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;914          {
;;;915            const s32 arrWidth = arr.get_size(1);
;;;916    
;;;917            for(s32 x=0; x<arrWidth; x++) {
;;;918              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;919                const Type valueToInsert = arr[y][x];
;;;920                const s32 indexToInsert = indexes[y][x];
;;;921    
;;;922                s32 holePosition = y;
;;;923    
;;;924                while(holePosition > trueMinIndex && valueToInsert < arr[holePosition-1][x]) {
;;;925                  arr[holePosition][x] = arr[holePosition-1][x];
;;;926                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;927                  holePosition--;
;;;928                }
;;;929    
;;;930                arr[holePosition][x] = valueToInsert;
;;;931                indexes[holePosition][x] = indexToInsert;
;;;932              }
;;;933            } // for(s32 x=0; x<arrWidth; x++)
;;;934          } // InsertionSort_sortAscendingDimension0()
;;;935    
;;;936          template<typename Type> void InsertionSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;937          {
;;;938            const s32 arrWidth = arr.get_size(1);
;;;939    
;;;940            for(s32 x=0; x<arrWidth; x++) {
;;;941              indexes[0][x] = 0;
;;;942    
;;;943              for(s32 y=(trueMinIndex+1); y<=trueMaxIndex; y++) {
;;;944                const Type valueToInsert = arr[y][x];
;;;945                const s32 indexToInsert = indexes[y][x];
;;;946    
;;;947                s32 holePosition = y;
;;;948    
;;;949                while(holePosition > trueMinIndex && valueToInsert > arr[holePosition-1][x]) {
;;;950                  arr[holePosition][x] = arr[holePosition-1][x];
;;;951                  indexes[holePosition][x] = indexes[holePosition-1][x];
;;;952                  holePosition--;
;;;953                }
;;;954    
;;;955                arr[holePosition][x] = valueToInsert;
;;;956                indexes[holePosition][x] = indexToInsert;
;;;957              }
;;;958            } // for(s32 x=0; x<arrWidth; x++)
;;;959          } // InsertionSort_sortDescendingDimension0()
;;;960    
;;;961          template<typename Type> void InsertionSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;962          {
;;;963            const s32 arrHeight = arr.get_size(0);
;;;964    
;;;965            for(s32 y=0; y<arrHeight; y++) {
;;;966              Type * const pArr = arr[y];
;;;967              s32 * const pIndexes = indexes[y];
;;;968    
;;;969              pIndexes[0] = 0;
;;;970    
;;;971              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;972                const Type valueToInsert = pArr[x];
;;;973                const s32 indexToInsert = pIndexes[x];
;;;974    
;;;975                s32 holePosition = x;
;;;976    
;;;977                while(holePosition > trueMinIndex && valueToInsert < pArr[holePosition-1]) {
;;;978                  pArr[holePosition] = pArr[holePosition-1];
;;;979                  pIndexes[holePosition] = pIndexes[holePosition-1];
;;;980                  holePosition--;
;;;981                }
;;;982    
;;;983                pArr[holePosition] = valueToInsert;
;;;984                pIndexes[holePosition] = indexToInsert;
;;;985              }
;;;986            } // for(s32 x=0; x<arrWidth; x++)
;;;987          } // InsertionSort_sortAscendingDimension1()
;;;988    
;;;989          template<typename Type> void InsertionSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex)
;;;990          {
;;;991            const s32 arrHeight = arr.get_size(0);
;;;992    
;;;993            for(s32 y=0; y<arrHeight; y++) {
;;;994              Type * const pArr = arr[y];
;;;995              s32 * const pIndexes = indexes[y];
;;;996    
;;;997              pIndexes[0] = 0;
;;;998    
;;;999              for(s32 x=(trueMinIndex+1); x<=trueMaxIndex; x++) {
;;;1000               const Type valueToInsert = pArr[x];
;;;1001               const s32 indexToInsert = pIndexes[x];
;;;1002   
;;;1003               s32 holePosition = x;
;;;1004   
;;;1005               while(holePosition > trueMinIndex && valueToInsert > pArr[holePosition-1]) {
;;;1006                 pArr[holePosition] = pArr[holePosition-1];
;;;1007                 pIndexes[holePosition] = pIndexes[holePosition-1];
;;;1008                 holePosition--;
;;;1009               }
;;;1010   
;;;1011               pArr[holePosition] = valueToInsert;
;;;1012               pIndexes[holePosition] = indexToInsert;
;;;1013             }
;;;1014           } // for(s32 x=0; x<arrWidth; x++)
;;;1015         } // InsertionSort_sortDescendingDimension1()
;;;1016   
;;;1017         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1018         {
;;;1019           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1020             return;
;;;1021           }
;;;1022   
;;;1023           // Select the median value of the first, middle, and last elements as the pivot
;;;1024           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1025   
;;;1026           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1027   
;;;1028           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1029             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1030   
;;;1031           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x))
;;;1032             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1033   
;;;1034           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x))
;;;1035             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1036   
;;;1037           // Search from the beginning to before the moved pivot
;;;1038           s32 i = trueMinIndex;
;;;1039           s32 j = trueMaxIndex - 2;
;;;1040   
;;;1041           if(i >= j) {
;;;1042             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1043             // NOTE: This really means your insertionSortSize value is too low
;;;1044             return;
;;;1045           }
;;;1046   
;;;1047           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1048   
;;;1049           const Type pivot = *arr.Pointer(midIndex, x);
;;;1050   
;;;1051           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1052   
;;;1053           // Main partitioning loop
;;;1054           while(true) {
;;;1055             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1056             while(*arr.Pointer(i,x) < pivot) {
;;;1057               i++;
;;;1058             }
;;;1059   
;;;1060             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1061             while(*arr.Pointer(j,x) > pivot) {
;;;1062               j--;
;;;1063             }
;;;1064   
;;;1065             if(i < j) {
;;;1066               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1067               i++;
;;;1068               j--;
;;;1069             } else {
;;;1070               break;
;;;1071             }
;;;1072           }
;;;1073   
;;;1074           // Replace the pivot
;;;1075           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1076   
;;;1077           // Recurse
;;;1078           QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1079   
;;;1080           QuickSort_sortAscendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1081         } // QuickSort_sortAscendingDimension0
;;;1082   
;;;1083         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1084         {
;;;1085           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1086             return;
;;;1087           }
;;;1088   
;;;1089           // Select the median value of the first, middle, and last elements as the pivot
;;;1090           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1091   
;;;1092           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1093   
;;;1094           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1095             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1096   
;;;1097           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x))
;;;1098             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1099   
;;;1100           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x))
;;;1101             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1102   
;;;1103           // Search from the beginning to before the moved pivot
;;;1104           s32 i = trueMinIndex;
;;;1105           s32 j = trueMaxIndex - 2;
;;;1106   
;;;1107           if(i >= j) {
;;;1108             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1109             // NOTE: This really means your insertionSortSize value is too low
;;;1110             return;
;;;1111           }
;;;1112   
;;;1113           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1114   
;;;1115           const Type pivot = *arr.Pointer(midIndex, x);
;;;1116   
;;;1117           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1118   
;;;1119           // Main partitioning loop
;;;1120           while(true) {
;;;1121             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1122             while(*arr.Pointer(i,x) > pivot) {
;;;1123               i++;
;;;1124             }
;;;1125   
;;;1126             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1127             while(*arr.Pointer(j,x) < pivot) {
;;;1128               j--;
;;;1129             }
;;;1130   
;;;1131             if(i < j) {
;;;1132               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1133               i++;
;;;1134               j--;
;;;1135             } else {
;;;1136               break;
;;;1137             }
;;;1138           }
;;;1139   
;;;1140           // Replace the pivot
;;;1141           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1142   
;;;1143           // Recurse
;;;1144           QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, i-1, x, insertionSortSize);
;;;1145   
;;;1146           QuickSort_sortDescendingDimension0<Type>(arr, i+1, trueMaxIndex, x, insertionSortSize);
;;;1147         } // QuickSort_sortDescendingDimension0
;;;1148   
;;;1149         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1150         {
;;;1151           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1152             return;
;;;1153           }
;;;1154   
;;;1155           Type * restrict pArr = arr.Pointer(y,0);
;;;1156   
;;;1157           // Select the median value of the first, middle, and last elements as the pivot
;;;1158           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1159   
;;;1160           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1161   
;;;1162           if(pArr[midIndex] < pArr[trueMinIndex])
;;;1163             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1164   
;;;1165           if(pArr[trueMaxIndex] < pArr[trueMinIndex])
;;;1166             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1167   
;;;1168           if(pArr[trueMaxIndex] < pArr[midIndex])
;;;1169             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1170   
;;;1171           // Search from the beginning to before the moved pivot
;;;1172           s32 i = trueMinIndex;
;;;1173           s32 j = trueMaxIndex - 2;
;;;1174   
;;;1175           if(i >= j) {
;;;1176             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1177             // NOTE: This really means your insertionSortSize value is too low
;;;1178             return;
;;;1179           }
;;;1180   
;;;1181           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1182   
;;;1183           const Type pivot = pArr[midIndex];
;;;1184   
;;;1185           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1186   
;;;1187           // Main partitioning loop
;;;1188           while(true) {
;;;1189             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1190             while(pArr[i] < pivot) {
;;;1191               i++;
;;;1192             }
;;;1193   
;;;1194             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1195             while(pArr[j] > pivot) {
;;;1196               j--;
;;;1197             }
;;;1198   
;;;1199             if(i < j) {
;;;1200               Swap<Type>(pArr[i], pArr[j]);
;;;1201               i++;
;;;1202               j--;
;;;1203             } else {
;;;1204               break;
;;;1205             }
;;;1206           }
;;;1207   
;;;1208           // Replace the pivot
;;;1209           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1210   
;;;1211           // Recurse
;;;1212           QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1213   
;;;1214           QuickSort_sortAscendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1215         } // QuickSort_sortAscendingDimension1
;;;1216   
;;;1217         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1218         {
;;;1219           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1220             return;
;;;1221           }
;;;1222   
;;;1223           Type * restrict pArr = arr.Pointer(y,0);
;;;1224   
;;;1225           // Select the median value of the first, middle, and last elements as the pivot
;;;1226           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1227   
;;;1228           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1229   
;;;1230           if(pArr[midIndex] < pArr[trueMaxIndex])
;;;1231             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1232   
;;;1233           if(pArr[trueMinIndex] < pArr[trueMaxIndex])
;;;1234             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1235   
;;;1236           if(pArr[trueMinIndex] < pArr[midIndex])
;;;1237             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1238   
;;;1239           // Search from the beginning to before the moved pivot
;;;1240           s32 i = trueMinIndex;
;;;1241           s32 j = trueMaxIndex - 2;
;;;1242   
;;;1243           if(i >= j) {
;;;1244             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1245             // NOTE: This really means your insertionSortSize value is too low
;;;1246             return;
;;;1247           }
;;;1248   
;;;1249           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1250   
;;;1251           const Type pivot = pArr[midIndex];
;;;1252   
;;;1253           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1254   
;;;1255           // Main partitioning loop
;;;1256           while(true) {
;;;1257             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1258             while(pArr[i] > pivot) {
;;;1259               i++;
;;;1260             }
;;;1261   
;;;1262             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1263             while(pArr[j] < pivot) {
;;;1264               j--;
;;;1265             }
;;;1266   
;;;1267             if(i < j) {
;;;1268               Swap<Type>(pArr[i], pArr[j]);
;;;1269               i++;
;;;1270               j--;
;;;1271             } else {
;;;1272               break;
;;;1273             }
;;;1274           }
;;;1275   
;;;1276           // Replace the pivot
;;;1277           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1278   
;;;1279           // Recurse
;;;1280           QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, i-1, y, insertionSortSize);
;;;1281   
;;;1282           QuickSort_sortDescendingDimension1<Type>(arr, i+1, trueMaxIndex, y, insertionSortSize);
;;;1283         } // QuickSort_sortDescendingDimension1
;;;1284   
;;;1285         template<typename Type> void QuickSort_sortAscendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1286         {
;;;1287           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1288             return;
;;;1289           }
;;;1290   
;;;1291           // Select the median value of the first, middle, and last elements as the pivot
;;;1292           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1293   
;;;1294           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1295   
;;;1296           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1297             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1298             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1299           }
;;;1300   
;;;1301           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(trueMinIndex, x)) {
;;;1302             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(trueMinIndex, x));
;;;1303             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(trueMinIndex, x));
;;;1304           }
;;;1305   
;;;1306           if(*arr.Pointer(trueMaxIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1307             Swap<Type>(*arr.Pointer(trueMaxIndex, x), *arr.Pointer(midIndex, x));
;;;1308             Swap<s32>(*indexes.Pointer(trueMaxIndex, x), *indexes.Pointer(midIndex, x));
;;;1309           }
;;;1310   
;;;1311           // Search from the beginning to before the moved pivot
;;;1312           s32 i = trueMinIndex;
;;;1313           s32 j = trueMaxIndex - 2;
;;;1314   
;;;1315           if(i >= j) {
;;;1316             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1317             // NOTE: This really means your insertionSortSize value is too low
;;;1318             return;
;;;1319           }
;;;1320   
;;;1321           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1322   
;;;1323           const Type pivot = *arr.Pointer(midIndex, x);
;;;1324   
;;;1325           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1326           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1327   
;;;1328           // Main partitioning loop
;;;1329           while(true) {
;;;1330             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1331             while(*arr.Pointer(i,x) < pivot) {
;;;1332               i++;
;;;1333             }
;;;1334   
;;;1335             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1336             while(*arr.Pointer(j,x) > pivot) {
;;;1337               j--;
;;;1338             }
;;;1339   
;;;1340             if(i < j) {
;;;1341               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1342               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1343               i++;
;;;1344               j--;
;;;1345             } else {
;;;1346               break;
;;;1347             }
;;;1348           }
;;;1349   
;;;1350           // Replace the pivot
;;;1351           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1352           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1353   
;;;1354           // Recurse
;;;1355           QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1356   
;;;1357           QuickSort_sortAscendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1358         } // QuickSort_sortAscendingDimension0
;;;1359   
;;;1360         template<typename Type> void QuickSort_sortDescendingDimension0(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 x, const s32 insertionSortSize)
;;;1361         {
;;;1362           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1363             return;
;;;1364           }
;;;1365   
;;;1366           // Select the median value of the first, middle, and last elements as the pivot
;;;1367           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1368   
;;;1369           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1370   
;;;1371           if(*arr.Pointer(midIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1372             Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1373             Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1374           }
;;;1375   
;;;1376           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(trueMaxIndex, x)) {
;;;1377             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(trueMaxIndex, x));
;;;1378             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(trueMaxIndex, x));
;;;1379           }
;;;1380   
;;;1381           if(*arr.Pointer(trueMinIndex, x) < *arr.Pointer(midIndex, x)) {
;;;1382             Swap<Type>(*arr.Pointer(trueMinIndex, x), *arr.Pointer(midIndex, x));
;;;1383             Swap<s32>(*indexes.Pointer(trueMinIndex, x), *indexes.Pointer(midIndex, x));
;;;1384           }
;;;1385   
;;;1386           // Search from the beginning to before the moved pivot
;;;1387           s32 i = trueMinIndex;
;;;1388           s32 j = trueMaxIndex - 2;
;;;1389   
;;;1390           if(i >= j) {
;;;1391             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1392             // NOTE: This really means your insertionSortSize value is too low
;;;1393             return;
;;;1394           }
;;;1395   
;;;1396           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1397   
;;;1398           const Type pivot = *arr.Pointer(midIndex, x);
;;;1399   
;;;1400           Swap<Type>(*arr.Pointer(midIndex, x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1401           Swap<s32>(*indexes.Pointer(midIndex, x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1402   
;;;1403           // Main partitioning loop
;;;1404           while(true) {
;;;1405             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1406             while(*arr.Pointer(i,x) > pivot) {
;;;1407               i++;
;;;1408             }
;;;1409   
;;;1410             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1411             while(*arr.Pointer(j,x) < pivot) {
;;;1412               j--;
;;;1413             }
;;;1414   
;;;1415             if(i < j) {
;;;1416               Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(j,x));
;;;1417               Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(j,x));
;;;1418               i++;
;;;1419               j--;
;;;1420             } else {
;;;1421               break;
;;;1422             }
;;;1423           }
;;;1424   
;;;1425           // Replace the pivot
;;;1426           Swap<Type>(*arr.Pointer(i,x), *arr.Pointer(trueMaxIndex - 1, x));
;;;1427           Swap<s32>(*indexes.Pointer(i,x), *indexes.Pointer(trueMaxIndex - 1, x));
;;;1428   
;;;1429           // Recurse
;;;1430           QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, i-1, x, insertionSortSize);
;;;1431   
;;;1432           QuickSort_sortDescendingDimension0<Type>(arr, indexes, i+1, trueMaxIndex, x, insertionSortSize);
;;;1433         } // QuickSort_sortDescendingDimension0
;;;1434   
;;;1435         template<typename Type> void QuickSort_sortAscendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1436         {
;;;1437           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1438             return;
;;;1439           }
;;;1440   
;;;1441           Type * restrict pArr = arr.Pointer(y,0);
;;;1442           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1443   
;;;1444           // Select the median value of the first, middle, and last elements as the pivot
;;;1445           // Also, put the min of the three at the beginning, the median in the middle, and the max at the end
;;;1446   
;;;1447           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1448   
;;;1449           if(pArr[midIndex] < pArr[trueMinIndex]) {
;;;1450             Swap<Type>(pArr[midIndex], pArr[trueMinIndex]);
;;;1451             Swap<s32>(pIndexes[midIndex], pIndexes[trueMinIndex]);
;;;1452           }
;;;1453   
;;;1454           if(pArr[trueMaxIndex] < pArr[trueMinIndex]) {
;;;1455             Swap<Type>(pArr[trueMaxIndex], pArr[trueMinIndex]);
;;;1456             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[trueMinIndex]);
;;;1457           }
;;;1458   
;;;1459           if(pArr[trueMaxIndex] < pArr[midIndex]) {
;;;1460             Swap<Type>(pArr[trueMaxIndex], pArr[midIndex]);
;;;1461             Swap<s32>(pIndexes[trueMaxIndex], pIndexes[midIndex]);
;;;1462           }
;;;1463   
;;;1464           // Search from the beginning to before the moved pivot
;;;1465           s32 i = trueMinIndex;
;;;1466           s32 j = trueMaxIndex - 2;
;;;1467   
;;;1468           if(i >= j) {
;;;1469             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1470             // NOTE: This really means your insertionSortSize value is too low
;;;1471             return;
;;;1472           }
;;;1473   
;;;1474           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1475   
;;;1476           const Type pivot = pArr[midIndex];
;;;1477   
;;;1478           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1479           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1480   
;;;1481           // Main partitioning loop
;;;1482           while(true) {
;;;1483             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1484             while(pArr[i] < pivot) {
;;;1485               i++;
;;;1486             }
;;;1487   
;;;1488             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1489             while(pArr[j] > pivot) {
;;;1490               j--;
;;;1491             }
;;;1492   
;;;1493             if(i < j) {
;;;1494               Swap<Type>(pArr[i], pArr[j]);
;;;1495               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1496               i++;
;;;1497               j--;
;;;1498             } else {
;;;1499               break;
;;;1500             }
;;;1501           }
;;;1502   
;;;1503           // Replace the pivot
;;;1504           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1505           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1506   
;;;1507           // Recurse
;;;1508           QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1509   
;;;1510           QuickSort_sortAscendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1511         } // QuickSort_sortAscendingDimension1
;;;1512   
;;;1513         template<typename Type> void QuickSort_sortDescendingDimension1(Array<Type> &arr, Array<s32> &indexes, const s32 trueMinIndex, const s32 trueMaxIndex, const s32 y, const s32 insertionSortSize)
;;;1514         {
;;;1515           if((trueMaxIndex - trueMinIndex + 1) <= insertionSortSize) {
;;;1516             return;
;;;1517           }
;;;1518   
;;;1519           Type * restrict pArr = arr.Pointer(y,0);
;;;1520           s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1521   
;;;1522           // Select the median value of the first, middle, and last elements as the pivot
;;;1523           // Also, put the max of the three at the beginning, the median in the middle, and the min at the end
;;;1524   
;;;1525           const s32 midIndex = (trueMaxIndex + trueMinIndex) / 2;
;;;1526   
;;;1527           if(pArr[midIndex] < pArr[trueMaxIndex]) {
;;;1528             Swap<Type>(pArr[midIndex], pArr[trueMaxIndex]);
;;;1529             Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex]);
;;;1530           }
;;;1531   
;;;1532           if(pArr[trueMinIndex] < pArr[trueMaxIndex]) {
;;;1533             Swap<Type>(pArr[trueMinIndex], pArr[trueMaxIndex]);
;;;1534             Swap<s32>(pIndexes[trueMinIndex], pIndexes[trueMaxIndex]);
;;;1535           }
;;;1536   
;;;1537           if(pArr[trueMinIndex] < pArr[midIndex]) {
;;;1538             Swap<Type>(pArr[trueMinIndex], pArr[midIndex]);
;;;1539             Swap<s32>(pIndexes[trueMinIndex], pIndexes[midIndex]);
;;;1540           }
;;;1541   
;;;1542           // Search from the beginning to before the moved pivot
;;;1543           s32 i = trueMinIndex;
;;;1544           s32 j = trueMaxIndex - 2;
;;;1545   
;;;1546           if(i >= j) {
;;;1547             // If there are 3 or less elements, the [min,median,max] ordering is a complete sort
;;;1548             // NOTE: This really means your insertionSortSize value is too low
;;;1549             return;
;;;1550           }
;;;1551   
;;;1552           // Move the pivot to the end-1 (right before the 3-way max element)
;;;1553   
;;;1554           const Type pivot = pArr[midIndex];
;;;1555   
;;;1556           Swap<Type>(pArr[midIndex], pArr[trueMaxIndex - 1]);
;;;1557           Swap<s32>(pIndexes[midIndex], pIndexes[trueMaxIndex - 1]);
;;;1558   
;;;1559           // Main partitioning loop
;;;1560           while(true) {
;;;1561             // We don't need to check that i get too low, because the value at index trueMinIndex is <= pivot
;;;1562             while(pArr[i] > pivot) {
;;;1563               i++;
;;;1564             }
;;;1565   
;;;1566             // We don't need to check that j get too high, because the value at index (trueMaxIndex - 1) is == pivot
;;;1567             while(pArr[j] < pivot) {
;;;1568               j--;
;;;1569             }
;;;1570   
;;;1571             if(i < j) {
;;;1572               Swap<Type>(pArr[i], pArr[j]);
;;;1573               Swap<s32>(pIndexes[i], pIndexes[j]);
;;;1574               i++;
;;;1575               j--;
;;;1576             } else {
;;;1577               break;
;;;1578             }
;;;1579           }
;;;1580   
;;;1581           // Replace the pivot
;;;1582           Swap<Type>(pArr[i], pArr[trueMaxIndex - 1]);
;;;1583           Swap<s32>(pIndexes[i], pIndexes[trueMaxIndex - 1]);
;;;1584   
;;;1585           // Recurse
;;;1586           QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, i-1, y, insertionSortSize);
;;;1587   
;;;1588           QuickSort_sortDescendingDimension1<Type>(arr, indexes, i+1, trueMaxIndex, y, insertionSortSize);
;;;1589         } // QuickSort_sortDescendingDimension1
;;;1590   
;;;1591         template<typename Type> Result InsertionSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1592         {
;;;1593           // const s32 arrHeight = arr.get_size(0);
;;;1594           // const s32 arrWidth = arr.get_size(1);
;;;1595   
;;;1596           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1597             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1598   
;;;1599           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1600             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1601   
;;;1602           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1603           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1604   
;;;1605           if(sortWhichDimension == 0) {
;;;1606             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1607             if(sortAscending) {
;;;1608               InsertionSort_sortAscendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1609             } else { // if(sortAscending)
;;;1610               InsertionSort_sortDescendingDimension0(arr, trueMinIndex, trueMaxIndex);
;;;1611             } // if(sortAscending) ... else
;;;1612           } else { // sortWhichDimension == 1
;;;1613             if(sortAscending) {
;;;1614               InsertionSort_sortAscendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1615             } else { // if(sortAscending)
;;;1616               InsertionSort_sortDescendingDimension1(arr, trueMinIndex, trueMaxIndex);
;;;1617             } // if(sortAscending) ... else
;;;1618           } // if(sortWhichDimension == 0) ... else
;;;1619   
;;;1620           return RESULT_OK;
;;;1621         } // InsertionSort()
;;;1622   
;;;1623         template<typename Type> Result InsertionSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex)
;;;1624         {
;;;1625           const s32 arrHeight = arr.get_size(0);
;;;1626           const s32 arrWidth = arr.get_size(1);
;;;1627   
;;;1628           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1629             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1630   
;;;1631           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1632             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1633   
;;;1634           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1635             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1636   
;;;1637           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1638           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1639   
;;;1640           if(sortWhichDimension == 0) {
;;;1641             for(s32 y=0; y<arrHeight; y++) {
;;;1642               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1643               for(s32 x=0; x<arrWidth; x++) {
;;;1644                 pIndexes[x] = y;
;;;1645               }
;;;1646             }
;;;1647   
;;;1648             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1649             if(sortAscending) {
;;;1650               InsertionSort_sortAscendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1651             } else { // if(sortAscending)
;;;1652               InsertionSort_sortDescendingDimension0(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1653             } // if(sortAscending) ... else
;;;1654           } else { // sortWhichDimension == 1
;;;1655             for(s32 y=0; y<arrHeight; y++) {
;;;1656               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1657               for(s32 x=0; x<arrWidth; x++) {
;;;1658                 pIndexes[x] = x;
;;;1659               }
;;;1660             }
;;;1661   
;;;1662             if(sortAscending) {
;;;1663               InsertionSort_sortAscendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1664             } else { // if(sortAscending)
;;;1665               InsertionSort_sortDescendingDimension1(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1666             } // if(sortAscending) ... else
;;;1667           } // if(sortWhichDimension == 0) ... else
;;;1668   
;;;1669           return RESULT_OK;
;;;1670         } // InsertionSort()
;;;1671   
;;;1672         template<typename Type> Result QuickSort(Array<Type> &arr, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1673         {
;;;1674           const s32 arrHeight = arr.get_size(0);
;;;1675           const s32 arrWidth = arr.get_size(1);
;;;1676   
;;;1677           AnkiConditionalErrorAndReturnValue(arr.IsValid(),
;;;1678             RESULT_FAIL_INVALID_OBJECT, "Sort", "Input array is invalid");
;;;1679   
;;;1680           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1681             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1682   
;;;1683           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1684             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1685   
;;;1686           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1687           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1688   
;;;1689           if(sortWhichDimension == 0) {
;;;1690             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1691             if(sortAscending) {
;;;1692               for(s32 x=0; x<arrWidth; x++) {
;;;1693                 QuickSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1694               }
;;;1695   
;;;1696               if(insertionSortSize > 1)
;;;1697                 InsertionSort_sortAscendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1698             } else { // if(sortAscending)
;;;1699               for(s32 x=0; x<arrWidth; x++) {
;;;1700                 QuickSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1701               }
;;;1702   
;;;1703               if(insertionSortSize > 1)
;;;1704                 InsertionSort_sortDescendingDimension0<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1705             } // if(sortAscending) ... else
;;;1706           } else { // sortWhichDimension == 1
;;;1707             if(sortAscending) {
;;;1708               for(s32 y=0; y<arrHeight; y++) {
;;;1709                 QuickSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1710               }
;;;1711   
;;;1712               if(insertionSortSize > 1)
;;;1713                 InsertionSort_sortAscendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1714             } else { // if(sortAscending)
;;;1715               for(s32 y=0; y<arrHeight; y++) {
;;;1716                 QuickSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1717               }
;;;1718   
;;;1719               if(insertionSortSize > 1)
;;;1720                 InsertionSort_sortDescendingDimension1<Type>(arr, trueMinIndex, trueMaxIndex);
;;;1721             } // if(sortAscending) ... else
;;;1722           } // if(sortWhichDimension == 0) ... else
;;;1723   
;;;1724           return RESULT_OK;
;;;1725         } // QuickSort()
;;;1726   
;;;1727         template<typename Type> Result QuickSort(Array<Type> &arr, Array<s32> &indexes, const s32 sortWhichDimension, const bool sortAscending, const s32 minIndex, const s32 maxIndex, const s32 insertionSortSize)
;;;1728         {
;;;1729           const s32 arrHeight = arr.get_size(0);
;;;1730           const s32 arrWidth = arr.get_size(1);
;;;1731   
;;;1732           AnkiConditionalErrorAndReturnValue(AreValid(arr, indexes),
;;;1733             RESULT_FAIL_INVALID_OBJECT, "Sort", "Objects are invalid");
;;;1734   
;;;1735           AnkiConditionalErrorAndReturnValue(sortWhichDimension==0 || sortWhichDimension==1,
;;;1736             RESULT_FAIL_INVALID_PARAMETER, "Sort", "sortWhichDimension must be zero or one");
;;;1737   
;;;1738           AnkiConditionalErrorAndReturnValue(insertionSortSize >= 1,
;;;1739             RESULT_FAIL_INVALID_PARAMETER, "Sort", "insertionSortSize must be >= 1");
;;;1740   
;;;1741           AnkiConditionalErrorAndReturnValue(AreEqualSize(arr, indexes),
;;;1742             RESULT_FAIL_INVALID_SIZE, "Sort", "indexes must be the same size as arr");
;;;1743   
;;;1744           const s32 trueMinIndex = CLIP(minIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1745           const s32 trueMaxIndex = CLIP(maxIndex, 0, arr.get_size(sortWhichDimension) - 1);
;;;1746   
;;;1747           if(sortWhichDimension == 0) {
;;;1748             for(s32 y=0; y<arrHeight; y++) {
;;;1749               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1750               for(s32 x=0; x<arrWidth; x++) {
;;;1751                 pIndexes[x] = y;
;;;1752               }
;;;1753             }
;;;1754   
;;;1755             // TODO: This columnwise sorting could be sped up, with smarter array indexing.
;;;1756             if(sortAscending) {
;;;1757               for(s32 x=0; x<arrWidth; x++) {
;;;1758                 QuickSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1759               }
;;;1760   
;;;1761               if(insertionSortSize > 1)
;;;1762                 InsertionSort_sortAscendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1763             } else { // if(sortAscending)
;;;1764               for(s32 x=0; x<arrWidth; x++) {
;;;1765                 QuickSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex, x, insertionSortSize);
;;;1766               }
;;;1767   
;;;1768               if(insertionSortSize > 1)
;;;1769                 InsertionSort_sortDescendingDimension0<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1770             } // if(sortAscending) ... else
;;;1771           } else { // sortWhichDimension == 1
;;;1772             for(s32 y=0; y<arrHeight; y++) {
;;;1773               s32 * restrict pIndexes = indexes.Pointer(y,0);
;;;1774               for(s32 x=0; x<arrWidth; x++) {
;;;1775                 pIndexes[x] = x;
;;;1776               }
;;;1777             }
;;;1778   
;;;1779             if(sortAscending) {
;;;1780               for(s32 y=0; y<arrHeight; y++) {
;;;1781                 QuickSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1782               }
;;;1783   
;;;1784               if(insertionSortSize > 1)
;;;1785                 InsertionSort_sortAscendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1786             } else { // if(sortAscending)
;;;1787               for(s32 y=0; y<arrHeight; y++) {
;;;1788                 QuickSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex, y, insertionSortSize);
;;;1789               }
;;;1790   
;;;1791               if(insertionSortSize > 1)
;;;1792                 InsertionSort_sortDescendingDimension1<Type>(arr, indexes, trueMinIndex, trueMaxIndex);
;;;1793             } // if(sortAscending) ... else
;;;1794           } // if(sortWhichDimension == 0) ... else
;;;1795   
;;;1796           return RESULT_OK;
;;;1797         } // QuickSort()
;;;1798   
;;;1799         template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1800         {
;;;1801           AnkiConditionalErrorAndReturnValue(arr.get_size(0) == arr.get_size(1),
;;;1802             RESULT_FAIL_INVALID_SIZE, "MakeSymmetric", "Input array must be square");
;;;1803   
;;;1804           const s32 arrHeight = arr.get_size(0);
;;;1805           for(s32 y = 0; y < arrHeight; y++)
;;;1806           {
;;;1807             const s32 x0 = lowerToUpper ? (y+1)     : 0;
;;;1808             const s32 x1 = lowerToUpper ? arrHeight : y;
;;;1809   
;;;1810             for(s32 x = x0; x < x1; x++) {
;;;1811               *arr.Pointer(y,x) = *arr.Pointer(x,y);
;;;1812             }
;;;1813           }
;;;1814   
;;;1815           return RESULT_OK;
;;;1816         } // template<typename Type> Result MakeSymmetric(Type &arr, bool lowerToUpper)
;;;1817   
;;;1818         namespace Elementwise
;;;1819         {
;;;1820           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1821           {
;;;1822             const Array<InType> &in1Array = in1.get_array();
;;;1823             const Array<InType> &in2Array = in2.get_array();
;;;1824             Array<OutType> &out1Array = out.get_array();
;;;1825   
;;;1826             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, in2Array, out1Array),
;;;1827               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1828   
;;;1829             ArraySliceLimits_in2_out1<s32> limits(
;;;1830               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1831               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1832               out.get_ySlice(), out.get_xSlice());
;;;1833   
;;;1834             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1835               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1836   
;;;1837             if(limits.isSimpleIteration) {
;;;1838               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1839   
;;;1840               for(s32 y=0; y<limits.ySize; y++) {
;;;1841                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1842                 const InType * const pIn2 = in2Array.Pointer(limits.in2Y, 0);
;;;1843                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1844   
;;;1845                 limits.OuterIncrementTop();
;;;1846   
;;;1847                 for(s32 x=0; x<limits.xSize; x++) {
;;;1848                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], pIn2[limits.in2X]);
;;;1849   
;;;1850                   limits.in1X += limits.in1_xInnerIncrement;
;;;1851                   limits.in2X += limits.in2_xInnerIncrement;
;;;1852                   limits.out1X += limits.out1_xInnerIncrement;
;;;1853                 }
;;;1854   
;;;1855                 limits.OuterIncrementBottom();
;;;1856               }
;;;1857             } else { // if(limits.isSimpleIteration)
;;;1858               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1859   
;;;1860               for(s32 y=0; y<limits.ySize; y++) {
;;;1861                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1862   
;;;1863                 limits.OuterIncrementTop();
;;;1864   
;;;1865                 for(s32 x=0; x<limits.xSize; x++) {
;;;1866                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1867                   const InType valIn2 = *in2Array.Pointer(limits.in2Y, limits.in2X);
;;;1868   
;;;1869                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, valIn2);
;;;1870   
;;;1871                   limits.in1X += limits.in1_xInnerIncrement;
;;;1872                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1873                   limits.in2X += limits.in2_xInnerIncrement;
;;;1874                   limits.in2Y += limits.in2_yInnerIncrement;
;;;1875                   limits.out1X += limits.out1_xInnerIncrement;
;;;1876                 }
;;;1877   
;;;1878                 limits.OuterIncrementBottom();
;;;1879               }
;;;1880             } //   if(limits.isSimpleIteration)  ... else
;;;1881   
;;;1882             return RESULT_OK;
;;;1883           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1884   
;;;1885           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1886           {
;;;1887             const Array<InType> &in1Array = in1.get_array();
;;;1888             Array<OutType> &out1Array = out.get_array();
;;;1889   
;;;1890             AnkiConditionalErrorAndReturnValue(AreValid(in1Array, out1Array),
;;;1891               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1892   
;;;1893             ArraySliceLimits_in1_out1<s32> limits(
;;;1894               in1.get_ySlice(), in1.get_xSlice(), in1.get_isTransposed(),
;;;1895               out.get_ySlice(), out.get_xSlice());
;;;1896   
;;;1897             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1898               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1899   
;;;1900             if(limits.isSimpleIteration) {
;;;1901               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1902   
;;;1903               for(s32 y=0; y<limits.ySize; y++) {
;;;1904                 const InType * const pIn1 = in1Array.Pointer(limits.in1Y, 0);
;;;1905                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1906   
;;;1907                 limits.OuterIncrementTop();
;;;1908   
;;;1909                 for(s32 x=0; x<limits.xSize; x++) {
;;;1910                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(pIn1[limits.in1X], value2);
;;;1911   
;;;1912                   limits.in1X += limits.in1_xInnerIncrement;
;;;1913                   limits.out1X += limits.out1_xInnerIncrement;
;;;1914                 }
;;;1915   
;;;1916                 limits.OuterIncrementBottom();
;;;1917               }
;;;1918             } else { // if(limits.isSimpleIteration)
;;;1919               // If either input is transposed is allowed, then we will do an inefficent loop iteration
;;;1920   
;;;1921               for(s32 y=0; y<limits.ySize; y++) {
;;;1922                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1923   
;;;1924                 limits.OuterIncrementTop();
;;;1925   
;;;1926                 for(s32 x=0; x<limits.xSize; x++) {
;;;1927                   const InType valIn1 = *in1Array.Pointer(limits.in1Y, limits.in1X);
;;;1928   
;;;1929                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(valIn1, value2);
;;;1930   
;;;1931                   limits.in1X += limits.in1_xInnerIncrement;
;;;1932                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1933                   limits.out1X += limits.out1_xInnerIncrement;
;;;1934                 }
;;;1935   
;;;1936                 limits.OuterIncrementBottom();
;;;1937               }
;;;1938             } //   if(limits.isSimpleIteration)  ... else
;;;1939   
;;;1940             return RESULT_OK;
;;;1941           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const ConstArraySliceExpression<InType> &in1, const InType value2, ArraySlice<OutType> out)
;;;1942   
;;;1943           template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;1944           {
;;;1945             const Array<InType> &in2Array = in2.get_array();
;;;1946             Array<OutType> &out1Array = out.get_array();
;;;1947   
;;;1948             AnkiConditionalErrorAndReturnValue(AreValid(in2Array, out1Array),
;;;1949               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Invalid objects");
;;;1950   
;;;1951             ArraySliceLimits_in1_out1<s32> limits(
;;;1952               in2.get_ySlice(), in2.get_xSlice(), in2.get_isTransposed(),
;;;1953               out.get_ySlice(), out.get_xSlice());
;;;1954   
;;;1955             AnkiConditionalErrorAndReturnValue(limits.isValid,
;;;1956               RESULT_FAIL_INVALID_OBJECT, "Matrix::Elementwise::ApplyOperation", "Limits is not valid");
;;;1957   
;;;1958             if(limits.isSimpleIteration) {
;;;1959               // If the input isn't transposed, we will do the maximally efficient loop iteration
;;;1960   
;;;1961               for(s32 y=0; y<limits.ySize; y++) {
;;;1962                 const InType * const pIn2 = in2Array.Pointer(limits.in1Y, 0);
;;;1963                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1964   
;;;1965                 limits.OuterIncrementTop();
;;;1966   
;;;1967                 for(s32 x=0; x<limits.xSize; x++) {
;;;1968                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, pIn2[limits.in1X]);
;;;1969   
;;;1970                   limits.in1X += limits.in1_xInnerIncrement;
;;;1971                   limits.out1X += limits.out1_xInnerIncrement;
;;;1972                 }
;;;1973   
;;;1974                 limits.OuterIncrementBottom();
;;;1975               }
;;;1976             } else { // if(limits.isSimpleIteration)
;;;1977               // If either input is transposed, then we will do an inefficent loop iteration
;;;1978   
;;;1979               for(s32 y=0; y<limits.ySize; y++) {
;;;1980                 OutType * const pOut1 = out1Array.Pointer(limits.out1Y, 0);
;;;1981   
;;;1982                 limits.OuterIncrementTop();
;;;1983   
;;;1984                 for(s32 x=0; x<limits.xSize; x++) {
;;;1985                   const InType valIn2 = *in2Array.Pointer(limits.in1Y, limits.in1X);
;;;1986   
;;;1987                   pOut1[limits.out1X] = Operator::BinaryElementwiseOperation(value1, valIn2);
;;;1988   
;;;1989                   limits.in1X += limits.in1_xInnerIncrement;
;;;1990                   limits.in1Y += limits.in1_yInnerIncrement;
;;;1991                   limits.out1X += limits.out1_xInnerIncrement;
;;;1992                 }
;;;1993   
;;;1994                 limits.OuterIncrementBottom();
;;;1995               }
;;;1996             } //   if(limits.isSimpleIteration)  ... else
;;;1997   
;;;1998             return RESULT_OK;
;;;1999           } // template<typename InType, typename Operator, typename OutType> Result ApplyOperation(const InType value1, const ConstArraySliceExpression<InType> &in2, ArraySlice<OutType> out)
;;;2000         } // namespace Elementwise
;;;2001       } // namespace Matrix
;;;2002     } // namespace Embedded
;;;2003   } // namespace Anki
;;;2004   
;;;2005   #endif // _ANKICORETECHEMBEDDED_COMMON_MATRIX_H_
;;;19     
;;;20     #include "anki/common/shared/utilities_shared.h"
;;;1      /**
;;;2      File: utilities_shared.h
;;;3      Author: Kevin Yoon
;;;4      Created: 2014
;;;5      
;;;6      Copyright Anki, Inc. 2014
;;;7      For internal use only. No part of this code may be used without a signed non-disclosure agreement with Anki, inc.
;;;8      **/
;;;9      
;;;10     #ifndef _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;11     #define _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;12     
;;;13     #include <stdarg.h>
;;;1      /* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
;;;14     
;;;15     namespace Anki
;;;16     {
;;;17       // For printing throughout Coretech libraries.
;;;18       // Calls printf() by default, but can be made to use an externally
;;;19       // defined function via SetCoreTechPrintFunctionPtr().
;;;20       int CoreTechPrint(const char * format, ...);
;;;21       int CoreTechPrint(const char * format, va_list argList);
;;;22     
;;;23       // Sets the function pointer that CoreTechPrint() uses.
;;;24       // Convenient for on-robot print which could be more complex
;;;25       // than just printf().
;;;26       void SetCoreTechPrintFunctionPtr( int (*fp)(const char * format, va_list) );
;;;27     } // namespace Anki
;;;28     
;;;29     #endif // _ANKICORETECHEMBEDDED_COMMON_SHARED_UTILITIES_H_
;;;21     
;;;22     namespace Anki
;;;23     {
;;;24       namespace Embedded
;;;25       {
;;;26     #if 0
;;;27     #pragma mark --- 2D Point Implementations ---
;;;28     #endif
;;;29         template<typename Type> Point<Type>::Point()
;;;30           : x(static_cast<Type>(0)), y(static_cast<Type>(0))
;;;31         {
;;;32         }
;;;33     
;;;34         template<typename Type> Point<Type>::Point(const Type x, const Type y)
;;;35           : x(x), y(y)
;;;36         {
;;;37         }
;;;38     
;;;39         template<typename Type> Point<Type>::Point(const Point<Type>& pt)
;;;40           : x(pt.x), y(pt.y)
;;;41         {
;;;42         }
;;;43     
;;;44     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;45         template<typename Type> Point<Type>::Point(const cv::Point_<Type>& pt)
;;;46           : x(pt.x), y(pt.y)
;;;47         {
;;;48         }
;;;49     #endif
;;;50     
;;;51     #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;52         template<typename Type> cv::Point_<Type> Point<Type>::get_CvPoint_() const
;;;53         {
;;;54           return cv::Point_<Type>(x,y);
;;;55         }
;;;56     #endif
;;;57     
;;;58         template<typename Type> template<typename InType> void Point<Type>::SetCast(const Point<InType> &in)
;;;59         {
;;;60           this->x = saturate_cast<Type>(in.x);
;;;61           this->y = saturate_cast<Type>(in.y);
;;;62         }
;;;63     
;;;64         template<typename Type> void Point<Type>::Print() const
;;;65         {
;;;66           CoreTechPrint("(%d,%d) ", this->x, this->y);
;;;67         }
;;;68     
;;;69         template<typename Type> bool Point<Type>::operator== (const Point<Type> &point2) const
;;;70         {
;;;71           if(this->x == point2.x && this->y == point2.y)
;;;72             return true;
;;;73     
;;;74           return false;
;;;75         }
;;;76     
;;;77         template<typename Type> Point<Type> Point<Type>::operator+ (const Point<Type> &point2) const
;;;78         {
;;;79           return Point<Type>(this->x+point2.x, this->y+point2.y);
;;;80         }
;;;81     
;;;82         template<typename Type> Point<Type> Point<Type>::operator- (const Point<Type> &point2) const
;;;83         {
;;;84           return Point<Type>(this->x-point2.x, this->y-point2.y);
;;;85         }
;;;86     
;;;87         template<typename Type> Point<Type> Point<Type>::operator- () const
;;;88         {
;;;89           return Point<Type>(-this->x, -this->y);
;;;90         }
;;;91     
;;;92         template<typename Type> Point<Type>& Point<Type>::operator*= (const Type value)
;;;93         {
;;;94           this->x *= value;
;;;95           this->y *= value;
;;;96           return *this;
;;;97         }
;;;98     
;;;99         template<typename Type> Point<Type>& Point<Type>::operator-= (const Type value)
;;;100        {
;;;101          this->x -= value;
;;;102          this->y -= value;
;;;103          return *this;
;;;104        }
;;;105    
;;;106        template<typename Type> Point<Type>& Point<Type>::operator+= (const Point<Type> &point2)
;;;107        {
;;;108          this->x += point2.x;
;;;109          this->y += point2.y;
;;;110          return *this;
;;;111        }
;;;112    
;;;113        template<typename Type> Point<Type>& Point<Type>::operator-= (const Point<Type> &point2)
;;;114        {
;;;115          this->x -= point2.x;
;;;116          this->y -= point2.y;
;;;117          return *this;
;;;118        }
;;;119    
;;;120        template<typename Type> inline Point<Type>& Point<Type>::operator= (const Point<Type> &point2)
;;;121        {
;;;122          this->x = point2.x;
;;;123          this->y = point2.y;
;;;124    
;;;125          return *this;
;;;126        }
;;;127    
;;;128        template<typename Type> f32 Point<Type>::Dist(const Point<Type> &point2) const
;;;129        {
;;;130          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) + (this->y - point2.y)*(this->y - point2.y));
;;;131        }
;;;132    
;;;133        template<typename Type> f32 Point<Type>::Length() const
;;;134        {
;;;135          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y)));
;;;136        }
;;;137    
;;;138        // #pragma mark --- Point Specializations ---
;;;139        template<> void Point<f32>::Print() const;
;;;140        template<> void Point<f64>::Print() const;
;;;141    
;;;142    #if 0
;;;143    #pragma mark --- 3D Point Implementations ---
;;;144    #endif
;;;145    
;;;146        template<typename Type> Point3<Type>::Point3()
;;;147          : x(static_cast<Type>(0)), y(static_cast<Type>(0)), z(static_cast<Type>(0))
;;;148        {
;;;149        }
;;;150    
;;;151        template<typename Type> Point3<Type>::Point3(const Type x, const Type y, const Type z)
;;;152          : x(x), y(y), z(z)
;;;153        {
;;;154        }
;;;155    
;;;156        template<typename Type> Point3<Type>::Point3(const Point3<Type>& pt)
;;;157          : x(pt.x), y(pt.y), z(pt.z)
;;;158        {
;;;159        }
;;;160    
;;;161    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;162        template<typename Type> Point3<Type>::Point3(const cv::Point3_<Type>& pt)
;;;163          : x(pt.x), y(pt.y), z(pt.z)
;;;164        {
;;;165        }
;;;166    #endif
;;;167    
;;;168    #if ANKICORETECH_EMBEDDED_USE_OPENCV
;;;169        template<typename Type> cv::Point3_<Type> Point3<Type>::get_CvPoint_() const
;;;170        {
;;;171          return cv::Point3_<Type>(x,y,z);
;;;172        }
;;;173    #endif
;;;174    
;;;175        template<typename Type> void Point3<Type>::Print() const
;;;176        {
;;;177          CoreTechPrint("(%d,%d,%d) ", this->x, this->y, this->z);
;;;178        }
;;;179    
;;;180        template<typename Type> bool Point3<Type>::operator== (const Point3<Type> &point2) const
;;;181        {
;;;182          if(this->x == point2.x && this->y == point2.y && this->z == point2.z)
;;;183            return true;
;;;184    
;;;185          return false;
;;;186        }
;;;187    
;;;188        template<typename Type> Point3<Type> Point3<Type>::operator+ (const Point3<Type> &point2) const
;;;189        {
;;;190          return Point3<Type>(this->x+point2.x, this->y+point2.y, this->z+point2.z);
;;;191        }
;;;192    
;;;193        template<typename Type> Point3<Type> Point3<Type>::operator- (const Point3<Type> &point2) const
;;;194        {
;;;195          return Point3<Type>(this->x-point2.x, this->y-point2.y, this->z-point2.z);
;;;196        }
;;;197    
;;;198        template<typename Type> Point3<Type> Point3<Type>::operator- () const
;;;199        {
;;;200          return Point3<Type>(-this->x, -this->y, -this->z);
;;;201        }
;;;202    
;;;203        template<typename Type> Point3<Type>& Point3<Type>::operator*= (const Type value)
;;;204        {
;;;205          this->x *= value;
;;;206          this->y *= value;
;;;207          this->z *= value;
;;;208          return *this;
;;;209        }
;;;210    
;;;211        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Type value)
;;;212        {
;;;213          this->x -= value;
;;;214          this->y -= value;
;;;215          this->z -= value;
;;;216          return *this;
;;;217        }
;;;218    
;;;219        template<typename Type> Point3<Type>& Point3<Type>::operator-= (const Point3<Type> &point2)
;;;220        {
;;;221          this->x -= point2.x;
;;;222          this->y -= point2.y;
;;;223          this->z -= point2.z;
;;;224          return *this;
;;;225        }
;;;226    
;;;227        template<typename Type> inline Point3<Type>& Point3<Type>::operator= (const Point3<Type> &point2)
;;;228        {
;;;229          this->x = point2.x;
;;;230          this->y = point2.y;
;;;231          this->z = point2.z;
;;;232          return *this;
;;;233        }
;;;234    
;;;235        template<typename Type> f32 Point3<Type>::Dist(const Point3<Type> &point2) const
;;;236        {
;;;237          return (f32)sqrt((this->x - point2.x)*(this->x - point2.x) +
;;;238            (this->y - point2.y)*(this->y - point2.y) +
;;;239            (this->z - point2.z)*(this->z - point2.z));
;;;240        }
;;;241    
;;;242        template<typename Type> f32 Point3<Type>::Length() const
;;;243        {
;;;244          return (f32)sqrt((f32)((this->x*this->x) + (this->y*this->y) + (this->z*this->z)));
;;;245        }
;;;246    
;;;247        template<typename Type> f32 Point3<Type>::MakeUnitLength()
;;;248        {
;;;249          const f32 L = this->Length();
;;;250          if(L != 0) {
;;;251            this->operator*=(1.f / L);
;;;252          }
;;;253          return L;
;;;254        }
;;;255    
;;;256        template<typename Type>
;;;257        Type DotProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;258        {
;;;259          return (point1.x*point2.x) + (point1.y*point2.y) + (point1.z*point2.z);
;;;260        }
;;;261    
;;;262        template<typename Type>
;;;263        Point3<Type> CrossProduct(const Point3<Type>& point1, const Point3<Type>& point2)
;;;264        {
;;;265          return Point3<Type>(-point2.y*point1.z + point1.y*point2.z,
;;;266            point2.x*point1.z - point1.x*point2.z,
;;;267            -point2.x*point1.y + point1.x*point2.y);
;;;268        }
;;;269    
;;;270        template<typename Type>
;;;271        Point3<Type> operator* (const Array<Type>& M, const Point3<Type>& p)
;;;272        {
;;;273          // Matrix M must be 3x3
;;;274          AnkiAssert(AreEqualSize(3, 3, M));
;;;275    
;;;276          return Point3<Type>(M[0][0]*p.x + M[0][1]*p.y + M[0][2]*p.z,
;;;277            M[1][0]*p.x + M[1][1]*p.y + M[1][2]*p.z,
;;;278            M[2][0]*p.x + M[2][1]*p.y + M[2][2]*p.z);
;;;279        }
;;;280    
;;;281        // #pragma mark --- Point Specializations ---
;;;282        template<> void Point3<f32>::Print() const;
;;;283        template<> void Point3<f64>::Print() const;
;;;284    
;;;285    #if 0
;;;286    #pragma mark --- Pose Implementations ---
;;;287    #endif
;;;288    
;;;289        template<typename Type>
;;;290        Result ComputePoseDiff(const Array<Type>& R1, const Point3<Type>& T1,
;;;291          const Array<Type>& R2, const Point3<Type>& T2,
;;;292          Array<Type>& Rdiff, Point3<Type>& Tdiff,
;;;293          MemoryStack scratch)
;;;294        {
;;;295          // All the rotation matrices should be 3x3
;;;296          AnkiAssert(AreEqualSize(3, 3, R1));
;;;297          AnkiAssert(AreEqualSize(3, 3, R2));
;;;298          AnkiAssert(AreEqualSize(3, 3, Rdiff));
;;;299    
;;;300          Array<Type> invR1 = Array<Type>(3,3,scratch);
;;;301          Matrix::Transpose(R1, invR1);
;;;302    
;;;303          Matrix::Multiply(invR1, R2, Rdiff);
;;;304          Tdiff = invR1 * (T2 - T1);
;;;305    
;;;306          return RESULT_OK;
;;;307        }
;;;308    
;;;309    #if 0
;;;310    #pragma mark --- Rectangle Implementations ---
;;;311    #endif
;;;312    
;;;313        template<typename Type> Rectangle<Type>::Rectangle()
;;;314          : left(static_cast<Type>(0)), right(static_cast<Type>(0)), top(static_cast<Type>(0)), bottom(static_cast<Type>(0))
;;;315        {
;;;316        }
;;;317    
;;;318        template<typename Type> Rectangle<Type>::Rectangle(const Type left, const Type right, const Type top, const Type bottom)
;;;319          : left(left), right(right), top(top), bottom(bottom)
;;;320        {
;;;321        }
;;;322    
;;;323        template<typename Type> Rectangle<Type>::Rectangle(const Rectangle<Type>& rect)
;;;324          : left(rect.left), right(rect.right), top(rect.top), bottom(rect.bottom)
;;;325        {
;;;326        }
;;;327    
;;;328        template<typename Type> void Rectangle<Type>::Print() const
;;;329        {
;;;330          CoreTechPrint("(%d,%d)->(%d,%d) ", this->left, this->top, this->right, this->bottom);
;;;331        }
;;;332    
;;;333        template<typename Type> template<typename OutType> Point<OutType> Rectangle<Type>::ComputeCenter() const
;;;334        {
;;;335          Point<OutType> center(
;;;336            (static_cast<OutType>(this->left) + static_cast<OutType>(this->right)) / 2,
;;;337            (static_cast<OutType>(this->top) + static_cast<OutType>(this->bottom)) / 2);
;;;338    
;;;339          return center;
;;;340        }
;;;341    
;;;342        template<typename Type> template<typename OutType> Rectangle<OutType> Rectangle<Type>::ComputeScaledRectangle(const f32 scalePercent) const
;;;343        {
;;;344          const f32 width = static_cast<f32>(this->get_width());
;;;345          const f32 height = static_cast<f32>(this->get_height());
;;;346    
;;;347          const f32 scaledWidth = width * scalePercent;
;;;348          const f32 scaledHeight = height * scalePercent;
;;;349    
;;;350          const f32 dx2 = (scaledWidth - width) / 2.0f;
;;;351          const f32 dy2 = (scaledHeight - height) / 2.0f;
;;;352    
;;;353          Rectangle<OutType> scaledRect(
;;;354            static_cast<OutType>( static_cast<f32>(this->left)   - dx2 ),
;;;355            static_cast<OutType>( static_cast<f32>(this->right)  + dx2 ),
;;;356            static_cast<OutType>( static_cast<f32>(this->top)    - dy2 ),
;;;357            static_cast<OutType>( static_cast<f32>(this->bottom) + dy2 ));
;;;358    
;;;359          return scaledRect;
;;;360        }
;;;361    
;;;362        template<typename Type> bool Rectangle<Type>::operator== (const Rectangle<Type> &rectangle2) const
;;;363        {
;;;364          if(this->left == rectangle2.left && this->top == rectangle2.top && this->right == rectangle2.right && this->bottom == rectangle2.bottom)
;;;365            return true;
;;;366    
;;;367          return false;
;;;368        }
;;;369    
;;;370        template<typename Type> Rectangle<Type> Rectangle<Type>::operator+ (const Rectangle<Type> &rectangle2) const
;;;371        {
;;;372          return Rectangle<Type>(this->top+rectangle2.top, this->bottom+rectangle2.bottom, this->left+rectangle2.left, this->right+rectangle2.right);
;;;373        }
;;;374    
;;;375        template<typename Type> Rectangle<Type> Rectangle<Type>::operator- (const Rectangle<Type> &rectangle2) const
;;;376        {
;;;377          return Rectangle<Type>(this->top-rectangle2.top, this->bottom-rectangle2.bottom, this->left-rectangle2.left, this->right-rectangle2.right);
;;;378        }
;;;379    
;;;380        template<typename Type> inline Rectangle<Type>& Rectangle<Type>::operator= (const Rectangle<Type> &rect2)
;;;381        {
;;;382          this->left = rect2.left;
;;;383          this->right = rect2.right;
;;;384          this->top = rect2.top;
;;;385          this->bottom = rect2.bottom;
;;;386    
;;;387          return *this;
;;;388        }
;;;389    
;;;390        template<typename Type> Type Rectangle<Type>::get_width() const
;;;391        {
;;;392          return right - left;
;;;393        }
;;;394    
;;;395        template<typename Type> Type Rectangle<Type>::get_height() const
;;;396        {
;;;397          return bottom - top;
;;;398        }
;;;399    
;;;400        // #pragma mark --- Rectangle Specializations ---
;;;401        template<> void Rectangle<f32>::Print() const;
;;;402        template<> void Rectangle<f64>::Print() const;
;;;403    
;;;404        // #pragma mark --- Quadrilateral Definitions ---
;;;405    
;;;406        template<typename Type> Quadrilateral<Type>::Quadrilateral()
;;;407        {
;;;408          for(s32 i=0; i<4; i++) {
;;;409            corners[i] = Point<Type>();
;;;410          }
;;;411        }
;;;412    
;;;413        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Point<Type> &corner1, const Point<Type> &corner2, const Point<Type> &corner3, const Point<Type> &corner4)
;;;414        {
;;;415          corners[0] = corner1;
;;;416          corners[1] = corner2;
;;;417          corners[2] = corner3;
;;;418          corners[3] = corner4;
;;;419        }
;;;420    
;;;421        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Quadrilateral<Type>& quad2)
;;;422        {
;;;423          for(s32 i=0; i<4; i++) {
;;;424            this->corners[i] = quad2.corners[i];
;;;425          }
;;;426        }
;;;427    
;;;428        template<typename Type> Quadrilateral<Type>::Quadrilateral(const Rectangle<Type>& rect)
;;;429        {
;;;430          this->corners[0].x = rect.left;   this->corners[0].y = rect.top;
;;;431          this->corners[1].x = rect.right;  this->corners[1].y = rect.top;
;;;432          this->corners[2].x = rect.left;   this->corners[2].y = rect.bottom;
;;;433          this->corners[3].x = rect.right;  this->corners[3].y = rect.bottom;
;;;434        }
;;;435    
;;;436        template<typename Type> void Quadrilateral<Type>::Print() const
;;;437        {
;;;438          CoreTechPrint("{(%d,%d), (%d,%d), (%d,%d), (%d,%d)} ",
;;;439            this->corners[0].x, this->corners[0].y,
;;;440            this->corners[1].x, this->corners[1].y,
;;;441            this->corners[2].x, this->corners[2].y,
;;;442            this->corners[3].x, this->corners[3].y);
;;;443        }
;;;444    
;;;445        template<typename Type> template<typename OutType> Point<OutType> Quadrilateral<Type>::ComputeCenter() const
;;;446        {
;;;447          Point<OutType> center(0, 0);
;;;448    
;;;449          for(s32 i=0; i<4; i++) {
;;;450            center.x += static_cast<OutType>(this->corners[i].x);
;;;451            center.y += static_cast<OutType>(this->corners[i].y);
;;;452          }
;;;453    
;;;454          center.x /= 4;
;;;455          center.y /= 4;
;;;456    
;;;457          return center;
;;;458        }
;;;459    
;;;460        template<typename Type> template<typename OutType> Rectangle<OutType> Quadrilateral<Type>::ComputeBoundingRectangle() const
;;;461        {
;;;462          Rectangle<OutType> boundingRect(
;;;463            static_cast<OutType>(this->corners[0].x),
;;;464            static_cast<OutType>(this->corners[0].x),
;;;465            static_cast<OutType>(this->corners[0].y),
;;;466            static_cast<OutType>(this->corners[0].y));
;;;467    
;;;468          // Initialize the template rectangle to the bounding box of the given
;;;469          // quadrilateral
;;;470          for(s32 i=1; i<4; ++i) {
;;;471            boundingRect.left   = MIN(boundingRect.left,   static_cast<OutType>(this->corners[i].x));
;;;472            boundingRect.right  = MAX(boundingRect.right,  static_cast<OutType>(this->corners[i].x));
;;;473            boundingRect.top    = MIN(boundingRect.top,    static_cast<OutType>(this->corners[i].y));
;;;474            boundingRect.bottom = MAX(boundingRect.bottom, static_cast<OutType>(this->corners[i].y));
;;;475          }
;;;476    
;;;477          return boundingRect;
;;;478        }
;;;479    
;;;480        template<typename Type> template<typename OutType> Quadrilateral<OutType> Quadrilateral<Type>::ComputeClockwiseCorners() const
;;;481        {
;;;482          char tmpBuffer[128];
;;;483          MemoryStack scratch(tmpBuffer, 128);
;;;484    
;;;485          Array<f32> thetas(1,4,scratch);
;;;486          Array<s32> indexes(1,4,scratch);
;;;487          Point<f32> center = this->ComputeCenter<f32>();
;;;488    
;;;489          for(s32 i=0; i<4; i++) {
;;;490            f32 rho = 0.0f;
;;;491    
;;;492            Cart2Pol<f32>(
;;;493              static_cast<f32>(this->corners[i].x) - center.x,
;;;494              static_cast<f32>(this->corners[i].y) - center.y,
;;;495              rho, thetas[0][i]);
;;;496          }
;;;497    
;;;498          Matrix::InsertionSort(thetas, indexes, 1);
;;;499    
;;;500          const Quadrilateral<OutType> sortedQuad(
;;;501            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][0]].x), static_cast<OutType>(this->corners[indexes[0][0]].y)),
;;;502            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][1]].x), static_cast<OutType>(this->corners[indexes[0][1]].y)),
;;;503            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][2]].x), static_cast<OutType>(this->corners[indexes[0][2]].y)),
;;;504            Point<OutType>(static_cast<OutType>(this->corners[indexes[0][3]].x), static_cast<OutType>(this->corners[indexes[0][3]].y)));
;;;505    
;;;506          return sortedQuad;
;;;507        }
;;;508    
                          ENDP

                  |L361.612|
                          DCD      _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L361.616|
000268  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
00026c  6f726574
000270  6563685c
000274  636f6d6d
000278  6f6e5c69
00027c  6e636c75
000280  64655c61
000284  6e6b692f
000288  636f6d6d
00028c  6f6e2f72
000290  6f626f74
000294  2f617272
000298  617932  
00029b  642e6800          DCB      "d.h",0
00029f  00                DCB      0
                  |L361.672|
0002a0  496e7661          DCB      "Invalid size",0
0002a4  6c696420
0002a8  73697a65
0002ac  00      
0002ad  00                DCB      0
0002ae  00                DCB      0
0002af  00                DCB      0
                  |L361.688|
0002b0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0002b4  793c5479
0002b8  70653e3a
0002bc  3a416c6c
0002c0  6f636174
0002c4  65427566
0002c8  66657246
0002cc  726f6d4d
0002d0  656d6f72
0002d4  79537461
0002d8  636b00  
0002db  00                DCB      0
                  |L361.732|
0002dc  00000000          DCFS     0x00000000 ; 0
                  |L361.736|
                          DCD      0x07fffffe
                  |L361.740|
                          DCD      _ZN4Anki8Embedded5PointIfEC1Ev ; Anki::Embedded::Point<float>::Point()

                          AREA ||area_number.362||, COMGROUP=_ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv, LINKORDER=||t._ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.362||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded13QuadrilateralIfE23ComputeClockwiseCornersIfEENS1_IT_EEv||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIhE7IsValidEv||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE7IsValidEv, CODE, READONLY, ALIGN=1

                  _ZNK4Anki8Embedded5ArrayIhE7IsValidEv PROC ; Anki::Embedded::Array<unsigned char>::IsValid() const
;;;590    
;;;591        template<typename Type> bool Array<Type>::IsValid() const
000000  6901              LDR      r1,[r0,#0x10]
;;;592        {
000002  b131              CBZ      r1,|L368.18|
;;;593          if(this->data == NULL) {
;;;594            return false;
;;;595          }
;;;596    
;;;597          if(size[0] < 0 || size[1] < 0) {
000004  6801              LDR      r1,[r0,#0]
000006  2900              CMP      r1,#0
000008  bfa1              ITTTT    GE
00000a  6840              LDRGE    r0,[r0,#4]
00000c  2800              CMPGE    r0,#0
;;;598            return false;
;;;599          }
;;;600    
;;;601          return true;
00000e  2001              MOVGE    r0,#1
;;;602        }
000010  4770              BXGE     lr
                  |L368.18|
000012  2000              MOVS     r0,#0                 ;598
000014  4770              BX       lr
;;;603    
                          ENDP


                          AREA ||area_number.369||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE7IsValidEv, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIhE7IsValidEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.369||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIhE7IsValidEv||
                          DCD      0x00000001

                          AREA ||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE8get_sizeEi, CODE, READONLY, ALIGN=2

                  _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi PROC ; Anki::Embedded::Array<unsigned char>::get_size(int) const
;;;736    
;;;737        template<typename Type> s32 Array<Type>::get_size(s32 dimension) const
000000  b500              PUSH     {lr}
;;;738        {
000002  b083              SUB      sp,sp,#0xc
;;;739          AnkiConditionalErrorAndReturnValue(dimension >= 0,
000004  2900              CMP      r1,#0
000006  da0f              BGE      |L375.40|
000008  f24021e3          MOV      r1,#0x2e3
00000c  480a              LDR      r0,|L375.56|
00000e  4b0b              LDR      r3,|L375.60|
000010  e9cd0100          STRD     r0,r1,[sp,#0]
000014  f5037207          ADD      r2,r3,#0x21c
000018  f1a20118          SUB      r1,r2,#0x18
00001c  2005              MOVS     r0,#5
00001e  f7fffffe          BL       _Anki_Log
;;;740            0, "Array<Type>::get_size", "Negative dimension");
;;;741    
;;;742          if(dimension > 1 || dimension < 0)
;;;743            return 1;
;;;744    
;;;745          return size[dimension];
;;;746        }
000022  b003              ADD      sp,sp,#0xc
000024  2000              MOVS     r0,#0                 ;739
000026  bd00              POP      {pc}
                  |L375.40|
000028  2902              CMP      r1,#2                 ;742
00002a  bf2c              ITE      CS                    ;743
00002c  2001              MOVCS    r0,#1                 ;743
00002e  f8500021          LDRCC    r0,[r0,r1,LSL #2]     ;745
000032  b003              ADD      sp,sp,#0xc
000034  bd00              POP      {pc}
;;;747    
                          ENDP

000036  0000              DCW      0x0000
                  |L375.56|
                          DCD      _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::get_size(int) const::__PRETTY_FUNCTION__
                  |L375.60|
                          DCD      ||.constdata||+0x312c

                          AREA ||area_number.376||, COMGROUP=_ZNK4Anki8Embedded5ArrayIhE8get_sizeEi, LINKORDER=||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.376||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZNK4Anki8Embedded5ArrayIhE8get_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L382.86|
00003a  217d              MOVS     r1,#0x7d
00003c  4850              LDR      r0,|L382.384|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a350              ADR      r3,|L382.388|
000044  a25d              ADR      r2,|L382.444|
000046  a161              ADR      r1,|L382.460|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L382.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  212c              MOVS     r1,#0x2c
000064  4348              MULS     r0,r1,r0
000066  300f              ADDS     r0,r0,#0xf
000068  f020050f          BIC      r5,r0,#0xf
00006c  a804              ADD      r0,sp,#0x10
00006e  e9cd0902          STRD     r0,r9,[sp,#8]
000072  2d00              CMP      r5,#0
000074  dc0a              BGT      |L382.140|
000076  f240310b          MOV      r1,#0x30b
00007a  4859              LDR      r0,|L382.480|
00007c  e9cd0100          STRD     r0,r1,[sp,#0]
000080  a340              ADR      r3,|L382.388|
000082  a24e              ADR      r2,|L382.444|
000084  a157              ADR      r1,|L382.484|
000086  2005              MOVS     r0,#5
000088  f7fffffe          BL       _Anki_Log
                  |L382.140|
00008c  4638              MOV      r0,r7
00008e  2f01              CMP      r7,#1
000090  bfd8              IT       LE
000092  2001              MOVLE    r0,#1
000094  60a5              STR      r5,[r4,#8]
000096  4345              MULS     r5,r0,r5
000098  a803              ADD      r0,sp,#0xc
00009a  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009e  4602              MOV      r2,r0
0000a0  4629              MOV      r1,r5
0000a2  4640              MOV      r0,r8
0000a4  9b02              LDR      r3,[sp,#8]
0000a6  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000aa  f8cd900c          STR      r9,[sp,#0xc]
0000ae  f8dd8010          LDR      r8,[sp,#0x10]
0000b2  f8df915c          LDR      r9,|L382.528|
0000b6  0005              MOVS     r5,r0
0000b8  d00e              BEQ      |L382.216|
0000ba  f1b80f10          CMP      r8,#0x10
0000be  d21e              BCS      |L382.254|
0000c0  f2403023          MOV      r0,#0x323
0000c4  e9cd9000          STRD     r9,r0,[sp,#0]
0000c8  a32e              ADR      r3,|L382.388|
0000ca  a252              ADR      r2,|L382.532|
0000cc  a156              ADR      r1,|L382.552|
0000ce  2005              MOVS     r0,#5
0000d0  f7fffffe          BL       _Anki_Log
0000d4  f000b850          B.W      |L382.376|
                  |L382.216|
0000d8  f240301e          MOV      r0,#0x31e
0000dc  e9cd9000          STRD     r9,r0,[sp,#0]
0000e0  a328              ADR      r3,|L382.388|
0000e2  a259              ADR      r2,|L382.584|
0000e4  a15f              ADR      r1,|L382.612|
0000e6  2005              MOVS     r0,#5
0000e8  f7fffffe          BL       _Anki_Log
0000ec  f8c4b000          STR      r11,[r4,#0]
0000f0  f8c4b004          STR      r11,[r4,#4]
0000f4  f8c4b008          STR      r11,[r4,#8]
0000f8  f8c4a010          STR      r10,[r4,#0x10]
0000fc  e03c              B        |L382.376|
                  |L382.254|
0000fe  a803              ADD      r0,sp,#0xc
000100  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000104  2800              CMP      r0,#0
000106  d00a              BEQ      |L382.286|
000108  f2403026          MOV      r0,#0x326
00010c  e9cd9000          STRD     r9,r0,[sp,#0]
000110  a31c              ADR      r3,|L382.388|
000112  a25a              ADR      r2,|L382.636|
000114  a144              ADR      r1,|L382.552|
000116  2005              MOVS     r0,#5
000118  f7fffffe          BL       _Anki_Log
00011c  e02c              B        |L382.376|
                  |L382.286|
00011e  9903              LDR      r1,[sp,#0xc]
000120  e9c41503          STRD     r1,r5,[r4,#0xc]
000124  f105000f          ADD      r0,r5,#0xf
000128  f020000f          BIC      r0,r0,#0xf
00012c  e9c47600          STRD     r7,r6,[r4,#0]
000130  1b40              SUBS     r0,r0,r5
000132  2e01              CMP      r6,#1
000134  bfd8              IT       LE
000136  2601              MOVLE    r6,#1
000138  212c              MOVS     r1,#0x2c
00013a  4371              MULS     r1,r6,r1
00013c  310f              ADDS     r1,r1,#0xf
00013e  f021010f          BIC      r1,r1,#0xf
000142  fb010107          MLA      r1,r1,r7,r0
000146  4541              CMP      r1,r8
000148  bfdc              ITT      LE
00014a  1829              ADDLE    r1,r5,r0
00014c  6121              STRLE    r1,[r4,#0x10]
00014e  dd13              BLE      |L382.376|
000150  f2403035          MOV      r0,#0x335
000154  f8cd9000          STR      r9,[sp,#0]
000158  e9cd0101          STRD     r0,r1,[sp,#4]
00015c  a309              ADR      r3,|L382.388|
00015e  a251              ADR      r2,|L382.676|
000160  a140              ADR      r1,|L382.612|
000162  2005              MOVS     r0,#5
000164  f7fffffe          BL       _Anki_Log
000168  f8c4b000          STR      r11,[r4,#0]
00016c  f8c4b004          STR      r11,[r4,#4]
000170  f8c4b008          STR      r11,[r4,#8]
000174  f8c4a010          STR      r10,[r4,#0x10]
                  |L382.376|
000178  b005              ADD      sp,sp,#0x14
00017a  4620              MOV      r0,r4
00017c  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L382.384|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L382.388|
000184  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000188  6f726574
00018c  6563685c
000190  636f6d6d
000194  6f6e5c69
000198  6e636c75
00019c  64655c61
0001a0  6e6b692f
0001a4  636f6d6d
0001a8  6f6e2f72
0001ac  6f626f74
0001b0  2f617272
0001b4  617932  
0001b7  642e6800          DCB      "d.h",0
0001bb  00                DCB      0
                  |L382.444|
0001bc  496e7661          DCB      "Invalid size",0
0001c0  6c696420
0001c4  73697a65
0001c8  00      
0001c9  00                DCB      0
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L382.460|
0001cc  41727261          DCB      "Array<Type>::Array",0
0001d0  793c5479
0001d4  70653e3a
0001d8  3a417272
0001dc  617900  
0001df  00                DCB      0
                  |L382.480|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L382.484|
0001e4  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e8  793c5479
0001ec  70653e3a
0001f0  3a416c6c
0001f4  6f636174
0001f8  65427566
0001fc  66657246
000200  726f6d4d
000204  656d6f72
000208  79537461
00020c  636b00  
00020f  00                DCB      0
                  |L382.528|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L382.532|
000214  4e656761          DCB      "Negative dimension",0
000218  74697665
00021c  2064696d
000220  656e7369
000224  6f6e00  
000227  00                DCB      0
                  |L382.552|
000228  41727261          DCB      "Array<Type>::InitializeBuffer",0
00022c  793c5479
000230  70653e3a
000234  3a496e69
000238  7469616c
00023c  697a6542
000240  75666665
000244  7200    
000246  00                DCB      0
000247  00                DCB      0
                  |L382.584|
000248  696e7075          DCB      "input data buffer is NULL",0
00024c  74206461
000250  74612062
000254  75666665
000258  72206973
00025c  204e554c
000260  4c00    
000262  00                DCB      0
000263  00                DCB      0
                  |L382.612|
000264  416e6b69          DCB      "Anki.Array2d.initialize",0
000268  2e417272
00026c  61793264
000270  2e696e69
000274  7469616c
000278  697a6500
                  |L382.636|
00027c  46696c6c          DCB      "Fill patterns not supported for Array",0
000280  20706174
000284  7465726e
000288  73206e6f
00028c  74207375
000290  70706f72
000294  74656420
000298  666f7220
00029c  41727261
0002a0  7900    
0002a2  00                DCB      0
0002a3  00                DCB      0
                  |L382.676|
0002a4  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a8  74206461
0002ac  74612062
0002b0  75666665
0002b4  72206973
0002b8  206e6f74
0002bc  206c6172
0002c0  67652065
0002c4  6e6f7567
0002c8  682e2025
0002cc  64206279
0002d0  74657320
0002d4  69732072
0002d8  657175  
0002db  69726564          DCB      "ired.",0
0002df  2e00    
0002e1  00                DCB      0
0002e2  00                DCB      0
0002e3  00                DCB      0

                          AREA ||area_number.383||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.383||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L389.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L389.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L389.384|
000044  a25c              ADR      r2,|L389.440|
000046  a160              ADR      r1,|L389.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L389.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L389.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L389.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L389.384|
000080  a24d              ADR      r2,|L389.440|
000082  a157              ADR      r1,|L389.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L389.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L389.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L389.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L389.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L389.384|
0000c8  a251              ADR      r2,|L389.528|
0000ca  a156              ADR      r1,|L389.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L389.372|
                  |L389.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L389.384|
0000e0  a258              ADR      r2,|L389.580|
0000e2  a15f              ADR      r1,|L389.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L389.372|
                  |L389.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L389.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L389.384|
000110  a259              ADR      r2,|L389.632|
000112  a144              ADR      r1,|L389.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L389.372|
                  |L389.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L389.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L389.384|
00015a  a251              ADR      r2,|L389.672|
00015c  a140              ADR      r1,|L389.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L389.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L389.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L389.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L389.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L389.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L389.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L389.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L389.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L389.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L389.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L389.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L389.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L389.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L389.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.390||, COMGROUP=_ZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.390||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::VisionMarker*>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L396.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L396.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.397||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.397||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListIPNS0_12VisionMarkerEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)
;;;55     
;;;56         template<typename Type> s32 Array<Type>::ComputeRequiredStride(const s32 numCols, const Flags::Buffer flags)
000000  b500              PUSH     {lr}
;;;57         {
000002  b083              SUB      sp,sp,#0xc
;;;58           AnkiConditionalErrorAndReturnValue(numCols >= 0,
000004  2800              CMP      r0,#0
000006  da0e              BGE      |L403.38|
000008  213a              MOVS     r1,#0x3a
00000a  480b              LDR      r0,|L403.56|
00000c  4b0b              LDR      r3,|L403.60|
00000e  e9cd0100          STRD     r0,r1,[sp,#0]
000012  f1a30210          SUB      r2,r3,#0x10
000016  f1a20124          SUB      r1,r2,#0x24
00001a  2005              MOVS     r0,#5
00001c  f7fffffe          BL       _Anki_Log
;;;59             0, "Array<Type>::ComputeRequiredStride", "Invalid size");
;;;60     
;;;61           const s32 numColsCapped = MAX(numCols, 1);
;;;62     
;;;63           const s32 bufferRequired = static_cast<s32>(RoundUp<size_t>(sizeof(Type)*numColsCapped, MEMORY_ALIGNMENT));
;;;64     
;;;65           return bufferRequired;
;;;66         }
000020  b003              ADD      sp,sp,#0xc
000022  2000              MOVS     r0,#0                 ;58
000024  bd00              POP      {pc}
                  |L403.38|
000026  2801              CMP      r0,#1                 ;61
000028  bfd8              IT       LE                    ;61
00002a  2001              MOVLE    r0,#1                 ;61
00002c  0100              LSLS     r0,r0,#4              ;63
00002e  300f              ADDS     r0,r0,#0xf            ;63
000030  b003              ADD      sp,sp,#0xc
000032  f020000f          BIC      r0,r0,#0xf
000036  bd00              POP      {pc}
;;;67     
                          ENDP

                  |L403.56|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L403.60|
                          DCD      ||.constdata||+0x312c

                          AREA ||area_number.404||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.404||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded10ArraySliceINS0_9RectangleIiEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_||, COMGROUP=_ZN4Anki8Embedded10ArraySliceINS0_9RectangleIiEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded10ArraySliceINS0_9RectangleIiEEEC2ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_                  ; Alternate entry point ; Anki::Embedded::ArraySlice<Anki::Embedded::Rectangle<int>>::ArraySlice__sub_object(Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
                  _ZN4Anki8Embedded10ArraySliceINS0_9RectangleIiEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_ PROC ; Anki::Embedded::ArraySlice<Anki::Embedded::Rectangle<int>>::ArraySlice(Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
;;;88     
;;;89         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;90           : ConstArraySlice<Type>(array, ySlice, xSlice)
;;;91         {
;;;92           if(array.get_numElements() == 0) {
;;;93             this->arrayData = NULL;
;;;94           } else {
;;;95             this->arrayData = array.Pointer(0,0);
;;;96           }
;;;97         }
;;;98     
000000  e92d01f0          PUSH     {r4-r8}
000004  e9dd4507          LDRD     r4,r5,[sp,#0x1c]
000008  e9dd6c05          LDRD     r6,r12,[sp,#0x14]
00000c  e9d47800          LDRD     r7,r8,[r4,#0]
000010  68a4              LDR      r4,[r4,#8]
000012  6007              STR      r7,[r0,#0]
000014  e9c08401          STRD     r8,r4,[r0,#4]
000018  e9d54700          LDRD     r4,r7,[r5,#0]
00001c  68ad              LDR      r5,[r5,#8]
00001e  e9c05105          STRD     r5,r1,[r0,#0x14]
000022  f100081c          ADD      r8,r0,#0x1c
000026  2500              MOVS     r5,#0
000028  e8a8104c          STM      r8!,{r2,r3,r6,r12}
00002c  e9c04703          STRD     r4,r7,[r0,#0xc]
000030  2900              CMP      r1,#0
000032  bfc8              IT       GT
000034  2a00              CMPGT    r2,#0
000036  dd13              BLE      |L410.96|
000038  fb01f402          MUL      r4,r1,r2
00003c  b184              CBZ      r4,|L410.96|
00003e  2400              MOVS     r4,#0
000040  fb04c403          MLA      r4,r4,r3,r12
000044  62c4              STR      r4,[r0,#0x2c]
                  |L410.70|
000046  2900              CMP      r1,#0
000048  bfc8              IT       GT
00004a  2a00              CMPGT    r2,#0
00004c  dd0a              BLE      |L410.100|
00004e  4351              MULS     r1,r2,r1
000050  b141              CBZ      r1,|L410.100|
000052  2100              MOVS     r1,#0
000054  fb01c103          MLA      r1,r1,r3,r12
000058  6301              STR      r1,[r0,#0x30]
00005a  e8bd01f0          POP      {r4-r8}
00005e  4770              BX       lr
                  |L410.96|
000060  62c5              STR      r5,[r0,#0x2c]
000062  e7f0              B        |L410.70|
                  |L410.100|
000064  6305              STR      r5,[r0,#0x30]
000066  e8bd01f0          POP      {r4-r8}
00006a  4770              BX       lr
                          ENDP


                          AREA ||area_number.411||, COMGROUP=_ZN4Anki8Embedded10ArraySliceINS0_9RectangleIiEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_, LINKORDER=||t._ZN4Anki8Embedded10ArraySliceINS0_9RectangleIiEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.411||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded10ArraySliceINS0_9RectangleIiEEEC1ENS0_5ArrayIS3_EERKNS0_14LinearSequenceIiEESA_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEEC1EiiPviNS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEEC1EiiPviNS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEEC2EiiPviNS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::Stage>::Array__sub_object(int, int, void*, int, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEEC1EiiPviNS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::Stage>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  461d              MOV      r5,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd8038          LDR      r8,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f8df91ec          LDR      r9,|L417.536|
00002e  f1a0040c          SUB      r4,r0,#0xc
000032  f8c0a004          STR      r10,[r0,#4]
000036  f0150f0f          TST      r5,#0xf
00003a  d00d              BEQ      |L417.88|
00003c  2010              MOVS     r0,#0x10
00003e  2157              MOVS     r1,#0x57
000040  f8cd9000          STR      r9,[sp,#0]
000044  e9cd1001          STRD     r1,r0,[sp,#4]
000048  a374              ADR      r3,|L417.540|
00004a  a282              ADR      r2,|L417.596|
00004c  a18e              ADR      r1,|L417.648|
00004e  2005              MOVS     r0,#5
000050  f7fffffe          BL       _Anki_Log
000054  f000b878          B.W      |L417.328|
                  |L417.88|
000058  2e00              CMP      r6,#0
00005a  da20              BGE      |L417.158|
00005c  213a              MOVS     r1,#0x3a
00005e  488e              LDR      r0,|L417.664|
000060  4b8e              LDR      r3,|L417.668|
000062  e9cd0100          STRD     r0,r1,[sp,#0]
000066  f1a30210          SUB      r2,r3,#0x10
00006a  f1a20124          SUB      r1,r2,#0x24
00006e  2005              MOVS     r0,#5
000070  f7fffffe          BL       _Anki_Log
000074  4650              MOV      r0,r10
                  |L417.118|
000076  60a0              STR      r0,[r4,#8]
000078  2e00              CMP      r6,#0
00007a  bfa2              ITTT     GE
00007c  2f00              CMPGE    r7,#0
00007e  4378              MULGE    r0,r7,r0
000080  4580              CMPGE    r8,r0
000082  da17              BGE      |L417.180|
000084  205c              MOVS     r0,#0x5c
000086  e9cd9000          STRD     r9,r0,[sp,#0]
00008a  a364              ADR      r3,|L417.540|
00008c  a284              ADR      r2,|L417.672|
00008e  a188              ADR      r1,|L417.688|
000090  2005              MOVS     r0,#5
000092  f7fffffe          BL       _Anki_Log
000096  b005              ADD      sp,sp,#0x14
000098  4620              MOV      r0,r4
00009a  e8bd8ff0          POP      {r4-r11,pc}
                  |L417.158|
00009e  4630              MOV      r0,r6
0000a0  2e01              CMP      r6,#1
0000a2  bfd8              IT       LE
0000a4  2001              MOVLE    r0,#1
0000a6  eb000040          ADD      r0,r0,r0,LSL #1
0000aa  0080              LSLS     r0,r0,#2
0000ac  300f              ADDS     r0,r0,#0xf
0000ae  f020000f          BIC      r0,r0,#0xf
0000b2  e7e0              B        |L417.118|
                  |L417.180|
0000b4  a80f              ADD      r0,sp,#0x3c
0000b6  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0000ba  2800              CMP      r0,#0
0000bc  d048              BEQ      |L417.336|
0000be  2f01              CMP      r7,#1
0000c0  d012              BEQ      |L417.232|
0000c2  eb060046          ADD      r0,r6,r6,LSL #1
0000c6  68a1              LDR      r1,[r4,#8]
0000c8  0080              LSLS     r0,r0,#2
0000ca  4281              CMP      r1,r0
0000cc  d01c              BEQ      |L417.264|
0000ce  2067              MOVS     r0,#0x67
0000d0  e9cd9000          STRD     r9,r0,[sp,#0]
0000d4  a351              ADR      r3,|L417.540|
0000d6  4a7b              LDR      r2,|L417.708|
0000d8  a175              ADR      r1,|L417.688|
0000da  2005              MOVS     r0,#5
0000dc  f7fffffe          BL       _Anki_Log
0000e0  b005              ADD      sp,sp,#0x14
0000e2  4620              MOV      r0,r4
0000e4  e8bd8ff0          POP      {r4-r11,pc}
                  |L417.232|
0000e8  68a0              LDR      r0,[r4,#8]
0000ea  4540              CMP      r0,r8
0000ec  dd1f              BLE      |L417.302|
0000ee  2062              MOVS     r0,#0x62
0000f0  e9cd9000          STRD     r9,r0,[sp,#0]
0000f4  a349              ADR      r3,|L417.540|
0000f6  4a74              LDR      r2,|L417.712|
0000f8  a16d              ADR      r1,|L417.688|
0000fa  2005              MOVS     r0,#5
0000fc  f7fffffe          BL       _Anki_Log
000100  b005              ADD      sp,sp,#0x14
000102  4620              MOV      r0,r4
000104  e8bd8ff0          POP      {r4-r11,pc}
                  |L417.264|
000108  eb060146          ADD      r1,r6,r6,LSL #1
00010c  200f              MOVS     r0,#0xf
00010e  ea100f81          TST      r0,r1,LSL #2
000112  d00c              BEQ      |L417.302|
000114  206a              MOVS     r0,#0x6a
000116  e9cd9000          STRD     r9,r0,[sp,#0]
00011a  a340              ADR      r3,|L417.540|
00011c  4a6b              LDR      r2,|L417.716|
00011e  a164              ADR      r1,|L417.688|
000120  2005              MOVS     r0,#5
000122  f7fffffe          BL       _Anki_Log
000126  b005              ADD      sp,sp,#0x14
000128  4620              MOV      r0,r4
00012a  e8bd8ff0          POP      {r4-r11,pc}
                  |L417.302|
00012e  a80f              ADD      r0,sp,#0x3c
000130  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000134  b160              CBZ      r0,|L417.336|
000136  206e              MOVS     r0,#0x6e
000138  e9cd9000          STRD     r9,r0,[sp,#0]
00013c  a337              ADR      r3,|L417.540|
00013e  4a64              LDR      r2,|L417.720|
000140  a15b              ADR      r1,|L417.688|
000142  2005              MOVS     r0,#5
000144  f7fffffe          BL       _Anki_Log
                  |L417.328|
000148  b005              ADD      sp,sp,#0x14
00014a  4620              MOV      r0,r4
00014c  e8bd8ff0          POP      {r4-r11,pc}
                  |L417.336|
000150  980f              LDR      r0,[sp,#0x3c]
000152  f8df9180          LDR      r9,|L417.724|
000156  9003              STR      r0,[sp,#0xc]
000158  b16d              CBZ      r5,|L417.374|
00015a  f1b80f10          CMP      r8,#0x10
00015e  d21d              BCS      |L417.412|
000160  f2403023          MOV      r0,#0x323
000164  e9cd9000          STRD     r9,r0,[sp,#0]
000168  a32c              ADR      r3,|L417.540|
00016a  a25b              ADR      r2,|L417.728|
00016c  a15f              ADR      r1,|L417.748|
00016e  2005              MOVS     r0,#5
000170  f7fffffe          BL       _Anki_Log
000174  e7e8              B        |L417.328|
                  |L417.374|
000176  f240301e          MOV      r0,#0x31e
00017a  e9cd9000          STRD     r9,r0,[sp,#0]
00017e  a327              ADR      r3,|L417.540|
000180  a262              ADR      r2,|L417.780|
000182  a169              ADR      r1,|L417.808|
000184  2005              MOVS     r0,#5
000186  f7fffffe          BL       _Anki_Log
00018a  f8c4b000          STR      r11,[r4,#0]
00018e  f8c4b004          STR      r11,[r4,#4]
000192  f8c4b008          STR      r11,[r4,#8]
000196  f8c4a010          STR      r10,[r4,#0x10]
00019a  e7d5              B        |L417.328|
                  |L417.412|
00019c  a803              ADD      r0,sp,#0xc
00019e  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
0001a2  b150              CBZ      r0,|L417.442|
0001a4  f2403026          MOV      r0,#0x326
0001a8  e9cd9000          STRD     r9,r0,[sp,#0]
0001ac  a31b              ADR      r3,|L417.540|
0001ae  a264              ADR      r2,|L417.832|
0001b0  a14e              ADR      r1,|L417.748|
0001b2  2005              MOVS     r0,#5
0001b4  f7fffffe          BL       _Anki_Log
0001b8  e7c6              B        |L417.328|
                  |L417.442|
0001ba  9903              LDR      r1,[sp,#0xc]
0001bc  e9c41503          STRD     r1,r5,[r4,#0xc]
0001c0  f105000f          ADD      r0,r5,#0xf
0001c4  f020000f          BIC      r0,r0,#0xf
0001c8  e9c47600          STRD     r7,r6,[r4,#0]
0001cc  1b40              SUBS     r0,r0,r5
0001ce  2e01              CMP      r6,#1
0001d0  bfd8              IT       LE
0001d2  2601              MOVLE    r6,#1
0001d4  eb060146          ADD      r1,r6,r6,LSL #1
0001d8  0089              LSLS     r1,r1,#2
0001da  310f              ADDS     r1,r1,#0xf
0001dc  f021010f          BIC      r1,r1,#0xf
0001e0  fb010107          MLA      r1,r1,r7,r0
0001e4  4541              CMP      r1,r8
0001e6  bfdc              ITT      LE
0001e8  1829              ADDLE    r1,r5,r0
0001ea  6121              STRLE    r1,[r4,#0x10]
0001ec  ddac              BLE      |L417.328|
0001ee  f2403035          MOV      r0,#0x335
0001f2  f8cd9000          STR      r9,[sp,#0]
0001f6  e9cd0101          STRD     r0,r1,[sp,#4]
0001fa  a308              ADR      r3,|L417.540|
0001fc  a25a              ADR      r2,|L417.872|
0001fe  a14a              ADR      r1,|L417.808|
000200  2005              MOVS     r0,#5
000202  f7fffffe          BL       _Anki_Log
000206  f8c4b000          STR      r11,[r4,#0]
00020a  f8c4b004          STR      r11,[r4,#4]
00020e  f8c4b008          STR      r11,[r4,#8]
000212  f8c4a010          STR      r10,[r4,#0x10]
000216  e797              B        |L417.328|
                          ENDP

                  |L417.536|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::Stage>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L417.540|
00021c  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000220  6f726574
000224  6563685c
000228  636f6d6d
00022c  6f6e5c69
000230  6e636c75
000234  64655c61
000238  6e6b692f
00023c  636f6d6d
000240  6f6e2f72
000244  6f626f74
000248  2f617272
00024c  617932  
00024f  642e6800          DCB      "d.h",0
000253  00                DCB      0
                  |L417.596|
000254  49662066          DCB      "If fully allocated, data must be %d byte aligned",0
000258  756c6c79
00025c  20616c6c
000260  6f636174
000264  65642c20
000268  64617461
00026c  206d7573
000270  74206265
000274  20256420
000278  62797465
00027c  20616c69
000280  676e6564
000284  00      
000285  00                DCB      0
000286  00                DCB      0
000287  00                DCB      0
                  |L417.648|
000288  41727261          DCB      "Array::Array",0
00028c  793a3a41
000290  72726179
000294  00      
000295  00                DCB      0
000296  00                DCB      0
000297  00                DCB      0
                  |L417.664|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::Stage>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L417.668|
                          DCD      ||.constdata||+0x312c
                  |L417.672|
0002a0  496e7661          DCB      "Invalid size",0
0002a4  6c696420
0002a8  73697a65
0002ac  00      
0002ad  00                DCB      0
0002ae  00                DCB      0
0002af  00                DCB      0
                  |L417.688|
0002b0  41727261          DCB      "Array<Type>::Array",0
0002b4  793c5479
0002b8  70653e3a
0002bc  3a417272
0002c0  617900  
0002c3  00                DCB      0
                  |L417.708|
                          DCD      ||.constdata||+0x31e0
                  |L417.712|
                          DCD      ||.constdata||+0x3164
                  |L417.716|
                          DCD      ||.constdata||+0x323c
                  |L417.720|
                          DCD      ||.constdata||+0x32bc
                  |L417.724|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::Stage>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L417.728|
0002d8  4e656761          DCB      "Negative dimension",0
0002dc  74697665
0002e0  2064696d
0002e4  656e7369
0002e8  6f6e00  
0002eb  00                DCB      0
                  |L417.748|
0002ec  41727261          DCB      "Array<Type>::InitializeBuffer",0
0002f0  793c5479
0002f4  70653e3a
0002f8  3a496e69
0002fc  7469616c
000300  697a6542
000304  75666665
000308  7200    
00030a  00                DCB      0
00030b  00                DCB      0
                  |L417.780|
00030c  696e7075          DCB      "input data buffer is NULL",0
000310  74206461
000314  74612062
000318  75666665
00031c  72206973
000320  204e554c
000324  4c00    
000326  00                DCB      0
000327  00                DCB      0
                  |L417.808|
000328  416e6b69          DCB      "Anki.Array2d.initialize",0
00032c  2e417272
000330  61793264
000334  2e696e69
000338  7469616c
00033c  697a6500
                  |L417.832|
000340  46696c6c          DCB      "Fill patterns not supported for Array",0
000344  20706174
000348  7465726e
00034c  73206e6f
000350  74207375
000354  70706f72
000358  74656420
00035c  666f7220
000360  41727261
000364  7900    
000366  00                DCB      0
000367  00                DCB      0
                  |L417.872|
000368  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
00036c  74206461
000370  74612062
000374  75666665
000378  72206973
00037c  206e6f74
000380  206c6172
000384  67652065
000388  6e6f7567
00038c  682e2025
000390  64206279
000394  74657320
000398  69732072
00039c  657175  
00039f  69726564          DCB      "ired.",0
0003a3  2e00    
0003a5  00                DCB      0
0003a6  00                DCB      0
0003a7  00                DCB      0

                          AREA ||area_number.418||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEEC1EiiPviNS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEEC1EiiPviNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.418||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEEC1EiiPviNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5StageEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5StageEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5StageEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Classifier::CascadeClassifier::Stage>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L424.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L424.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.425||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5StageEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5StageEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.425||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5StageEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEEC1EiiPviNS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEEC1EiiPviNS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEEC2EiiPviNS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTree>::Array__sub_object(int, int, void*, int, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEEC1EiiPviNS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTree>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  461d              MOV      r5,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd8038          LDR      r8,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f8df91dc          LDR      r9,|L431.520|
00002e  f1a0040c          SUB      r4,r0,#0xc
000032  f8c0a004          STR      r10,[r0,#4]
000036  f0150f0f          TST      r5,#0xf
00003a  d00d              BEQ      |L431.88|
00003c  2010              MOVS     r0,#0x10
00003e  2157              MOVS     r1,#0x57
000040  f8cd9000          STR      r9,[sp,#0]
000044  e9cd1001          STRD     r1,r0,[sp,#4]
000048  a370              ADR      r3,|L431.524|
00004a  a27e              ADR      r2,|L431.580|
00004c  a18a              ADR      r1,|L431.632|
00004e  2005              MOVS     r0,#5
000050  f7fffffe          BL       _Anki_Log
000054  f000b872          B.W      |L431.316|
                  |L431.88|
000058  2e00              CMP      r6,#0
00005a  da20              BGE      |L431.158|
00005c  213a              MOVS     r1,#0x3a
00005e  488a              LDR      r0,|L431.648|
000060  4b8a              LDR      r3,|L431.652|
000062  e9cd0100          STRD     r0,r1,[sp,#0]
000066  f1a30210          SUB      r2,r3,#0x10
00006a  f1a20124          SUB      r1,r2,#0x24
00006e  2005              MOVS     r0,#5
000070  f7fffffe          BL       _Anki_Log
000074  4650              MOV      r0,r10
                  |L431.118|
000076  60a0              STR      r0,[r4,#8]
000078  2e00              CMP      r6,#0
00007a  bfa2              ITTT     GE
00007c  2f00              CMPGE    r7,#0
00007e  4378              MULGE    r0,r7,r0
000080  4580              CMPGE    r8,r0
000082  da15              BGE      |L431.176|
000084  205c              MOVS     r0,#0x5c
000086  e9cd9000          STRD     r9,r0,[sp,#0]
00008a  a360              ADR      r3,|L431.524|
00008c  a280              ADR      r2,|L431.656|
00008e  a184              ADR      r1,|L431.672|
000090  2005              MOVS     r0,#5
000092  f7fffffe          BL       _Anki_Log
000096  b005              ADD      sp,sp,#0x14
000098  4620              MOV      r0,r4
00009a  e8bd8ff0          POP      {r4-r11,pc}
                  |L431.158|
00009e  4630              MOV      r0,r6
0000a0  2e01              CMP      r6,#1
0000a2  bfd8              IT       LE
0000a4  2001              MOVLE    r0,#1
0000a6  0080              LSLS     r0,r0,#2
0000a8  300f              ADDS     r0,r0,#0xf
0000aa  f020000f          BIC      r0,r0,#0xf
0000ae  e7e2              B        |L431.118|
                  |L431.176|
0000b0  a80f              ADD      r0,sp,#0x3c
0000b2  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0000b6  2800              CMP      r0,#0
0000b8  d044              BEQ      |L431.324|
0000ba  2f01              CMP      r7,#1
0000bc  d010              BEQ      |L431.224|
0000be  68a1              LDR      r1,[r4,#8]
0000c0  00b0              LSLS     r0,r6,#2
0000c2  4281              CMP      r1,r0
0000c4  d01c              BEQ      |L431.256|
0000c6  2067              MOVS     r0,#0x67
0000c8  e9cd9000          STRD     r9,r0,[sp,#0]
0000cc  a34f              ADR      r3,|L431.524|
0000ce  4a79              LDR      r2,|L431.692|
0000d0  a173              ADR      r1,|L431.672|
0000d2  2005              MOVS     r0,#5
0000d4  f7fffffe          BL       _Anki_Log
0000d8  b005              ADD      sp,sp,#0x14
0000da  4620              MOV      r0,r4
0000dc  e8bd8ff0          POP      {r4-r11,pc}
                  |L431.224|
0000e0  68a0              LDR      r0,[r4,#8]
0000e2  4540              CMP      r0,r8
0000e4  dd1d              BLE      |L431.290|
0000e6  2062              MOVS     r0,#0x62
0000e8  e9cd9000          STRD     r9,r0,[sp,#0]
0000ec  a347              ADR      r3,|L431.524|
0000ee  4a72              LDR      r2,|L431.696|
0000f0  a16b              ADR      r1,|L431.672|
0000f2  2005              MOVS     r0,#5
0000f4  f7fffffe          BL       _Anki_Log
0000f8  b005              ADD      sp,sp,#0x14
0000fa  4620              MOV      r0,r4
0000fc  e8bd8ff0          POP      {r4-r11,pc}
                  |L431.256|
000100  200f              MOVS     r0,#0xf
000102  ea100f86          TST      r0,r6,LSL #2
000106  d00c              BEQ      |L431.290|
000108  206a              MOVS     r0,#0x6a
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a33f              ADR      r3,|L431.524|
000110  4a6a              LDR      r2,|L431.700|
000112  a163              ADR      r1,|L431.672|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  b005              ADD      sp,sp,#0x14
00011c  4620              MOV      r0,r4
00011e  e8bd8ff0          POP      {r4-r11,pc}
                  |L431.290|
000122  a80f              ADD      r0,sp,#0x3c
000124  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000128  b160              CBZ      r0,|L431.324|
00012a  206e              MOVS     r0,#0x6e
00012c  e9cd9000          STRD     r9,r0,[sp,#0]
000130  a336              ADR      r3,|L431.524|
000132  4a63              LDR      r2,|L431.704|
000134  a15a              ADR      r1,|L431.672|
000136  2005              MOVS     r0,#5
000138  f7fffffe          BL       _Anki_Log
                  |L431.316|
00013c  b005              ADD      sp,sp,#0x14
00013e  4620              MOV      r0,r4
000140  e8bd8ff0          POP      {r4-r11,pc}
                  |L431.324|
000144  980f              LDR      r0,[sp,#0x3c]
000146  f8df917c          LDR      r9,|L431.708|
00014a  9003              STR      r0,[sp,#0xc]
00014c  b16d              CBZ      r5,|L431.362|
00014e  f1b80f10          CMP      r8,#0x10
000152  d21d              BCS      |L431.400|
000154  f2403023          MOV      r0,#0x323
000158  e9cd9000          STRD     r9,r0,[sp,#0]
00015c  a32b              ADR      r3,|L431.524|
00015e  a25a              ADR      r2,|L431.712|
000160  a15e              ADR      r1,|L431.732|
000162  2005              MOVS     r0,#5
000164  f7fffffe          BL       _Anki_Log
000168  e7e8              B        |L431.316|
                  |L431.362|
00016a  f240301e          MOV      r0,#0x31e
00016e  e9cd9000          STRD     r9,r0,[sp,#0]
000172  a326              ADR      r3,|L431.524|
000174  a261              ADR      r2,|L431.764|
000176  a168              ADR      r1,|L431.792|
000178  2005              MOVS     r0,#5
00017a  f7fffffe          BL       _Anki_Log
00017e  f8c4b000          STR      r11,[r4,#0]
000182  f8c4b004          STR      r11,[r4,#4]
000186  f8c4b008          STR      r11,[r4,#8]
00018a  f8c4a010          STR      r10,[r4,#0x10]
00018e  e7d5              B        |L431.316|
                  |L431.400|
000190  a803              ADD      r0,sp,#0xc
000192  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000196  b150              CBZ      r0,|L431.430|
000198  f2403026          MOV      r0,#0x326
00019c  e9cd9000          STRD     r9,r0,[sp,#0]
0001a0  a31a              ADR      r3,|L431.524|
0001a2  a263              ADR      r2,|L431.816|
0001a4  a14d              ADR      r1,|L431.732|
0001a6  2005              MOVS     r0,#5
0001a8  f7fffffe          BL       _Anki_Log
0001ac  e7c6              B        |L431.316|
                  |L431.430|
0001ae  9903              LDR      r1,[sp,#0xc]
0001b0  e9c41503          STRD     r1,r5,[r4,#0xc]
0001b4  f105000f          ADD      r0,r5,#0xf
0001b8  f020000f          BIC      r0,r0,#0xf
0001bc  e9c47600          STRD     r7,r6,[r4,#0]
0001c0  1b40              SUBS     r0,r0,r5
0001c2  2e01              CMP      r6,#1
0001c4  bfd8              IT       LE
0001c6  2601              MOVLE    r6,#1
0001c8  00b1              LSLS     r1,r6,#2
0001ca  310f              ADDS     r1,r1,#0xf
0001cc  f021010f          BIC      r1,r1,#0xf
0001d0  fb010107          MLA      r1,r1,r7,r0
0001d4  4541              CMP      r1,r8
0001d6  bfdc              ITT      LE
0001d8  1829              ADDLE    r1,r5,r0
0001da  6121              STRLE    r1,[r4,#0x10]
0001dc  ddae              BLE      |L431.316|
0001de  f2403035          MOV      r0,#0x335
0001e2  f8cd9000          STR      r9,[sp,#0]
0001e6  e9cd0101          STRD     r0,r1,[sp,#4]
0001ea  a308              ADR      r3,|L431.524|
0001ec  a25a              ADR      r2,|L431.856|
0001ee  a14a              ADR      r1,|L431.792|
0001f0  2005              MOVS     r0,#5
0001f2  f7fffffe          BL       _Anki_Log
0001f6  f8c4b000          STR      r11,[r4,#0]
0001fa  f8c4b004          STR      r11,[r4,#4]
0001fe  f8c4b008          STR      r11,[r4,#8]
000202  f8c4a010          STR      r10,[r4,#0x10]
000206  e799              B        |L431.316|
                          ENDP

                  |L431.520|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTree>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L431.524|
00020c  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000210  6f726574
000214  6563685c
000218  636f6d6d
00021c  6f6e5c69
000220  6e636c75
000224  64655c61
000228  6e6b692f
00022c  636f6d6d
000230  6f6e2f72
000234  6f626f74
000238  2f617272
00023c  617932  
00023f  642e6800          DCB      "d.h",0
000243  00                DCB      0
                  |L431.580|
000244  49662066          DCB      "If fully allocated, data must be %d byte aligned",0
000248  756c6c79
00024c  20616c6c
000250  6f636174
000254  65642c20
000258  64617461
00025c  206d7573
000260  74206265
000264  20256420
000268  62797465
00026c  20616c69
000270  676e6564
000274  00      
000275  00                DCB      0
000276  00                DCB      0
000277  00                DCB      0
                  |L431.632|
000278  41727261          DCB      "Array::Array",0
00027c  793a3a41
000280  72726179
000284  00      
000285  00                DCB      0
000286  00                DCB      0
000287  00                DCB      0
                  |L431.648|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTree>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L431.652|
                          DCD      ||.constdata||+0x312c
                  |L431.656|
000290  496e7661          DCB      "Invalid size",0
000294  6c696420
000298  73697a65
00029c  00      
00029d  00                DCB      0
00029e  00                DCB      0
00029f  00                DCB      0
                  |L431.672|
0002a0  41727261          DCB      "Array<Type>::Array",0
0002a4  793c5479
0002a8  70653e3a
0002ac  3a417272
0002b0  617900  
0002b3  00                DCB      0
                  |L431.692|
                          DCD      ||.constdata||+0x31e0
                  |L431.696|
                          DCD      ||.constdata||+0x3164
                  |L431.700|
                          DCD      ||.constdata||+0x323c
                  |L431.704|
                          DCD      ||.constdata||+0x32bc
                  |L431.708|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTree>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L431.712|
0002c8  4e656761          DCB      "Negative dimension",0
0002cc  74697665
0002d0  2064696d
0002d4  656e7369
0002d8  6f6e00  
0002db  00                DCB      0
                  |L431.732|
0002dc  41727261          DCB      "Array<Type>::InitializeBuffer",0
0002e0  793c5479
0002e4  70653e3a
0002e8  3a496e69
0002ec  7469616c
0002f0  697a6542
0002f4  75666665
0002f8  7200    
0002fa  00                DCB      0
0002fb  00                DCB      0
                  |L431.764|
0002fc  696e7075          DCB      "input data buffer is NULL",0
000300  74206461
000304  74612062
000308  75666665
00030c  72206973
000310  204e554c
000314  4c00    
000316  00                DCB      0
000317  00                DCB      0
                  |L431.792|
000318  416e6b69          DCB      "Anki.Array2d.initialize",0
00031c  2e417272
000320  61793264
000324  2e696e69
000328  7469616c
00032c  697a6500
                  |L431.816|
000330  46696c6c          DCB      "Fill patterns not supported for Array",0
000334  20706174
000338  7465726e
00033c  73206e6f
000340  74207375
000344  70706f72
000348  74656420
00034c  666f7220
000350  41727261
000354  7900    
000356  00                DCB      0
000357  00                DCB      0
                  |L431.856|
000358  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
00035c  74206461
000360  74612062
000364  75666665
000368  72206973
00036c  206e6f74
000370  206c6172
000374  67652065
000378  6e6f7567
00037c  682e2025
000380  64206279
000384  74657320
000388  69732072
00038c  657175  
00038f  69726564          DCB      "ired.",0
000393  2e00    
000395  00                DCB      0
000396  00                DCB      0
000397  00                DCB      0

                          AREA ||area_number.432||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEEC1EiiPviNS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEEC1EiiPviNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.432||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEEC1EiiPviNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5DTreeEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5DTreeEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5DTreeEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Classifier::CascadeClassifier::DTree>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L438.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L438.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.439||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5DTreeEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5DTreeEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.439||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier5DTreeEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEEC1EiiPviNS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEEC1EiiPviNS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEEC2EiiPviNS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>::Array__sub_object(int, int, void*, int, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEEC1EiiPviNS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)
;;;82     
;;;83         template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, void * data, const s32 dataLength, const Flags::Buffer flags)
;;;84         {
;;;85           InvalidateArray();
;;;86     
;;;87           AnkiConditionalErrorAndReturn(reinterpret_cast<size_t>(data)%MEMORY_ALIGNMENT == 0,
;;;88             "Array::Array", "If fully allocated, data must be %d byte aligned", MEMORY_ALIGNMENT);
;;;89     
;;;90           this->stride = ComputeRequiredStride(numCols, flags);
;;;91     
;;;92           AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0 && dataLength >= numRows*this->stride,
;;;93             "Array<Type>::Array", "Invalid size");
;;;94     
;;;95           if(flags.get_isFullyAllocated()) {
;;;96             if(numRows == 1) {
;;;97               // If there's only one row, the stride restrictions are less stringent, though the buffer still must round up to a multiple of 16 bytes (or more)
;;;98               AnkiConditionalErrorAndReturn(this->stride <= dataLength,
;;;99                 "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the dataLength must be greater-than-or-equal-to the stride");
;;;100            } else {
;;;101              const s32 simpleStride = numCols * static_cast<s32>(sizeof(Type));
;;;102    
;;;103              AnkiConditionalErrorAndReturn(this->stride == simpleStride,
;;;104                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, the stride must be simple");
;;;105    
;;;106              AnkiConditionalErrorAndReturn((numCols*sizeof(Type)) % MEMORY_ALIGNMENT == 0,
;;;107                "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, (numCols*sizeof(Type)) mod MEMORY_ALIGNMENT must equal zero");
;;;108            }
;;;109    
;;;110            AnkiConditionalErrorAndReturn(flags.get_useBoundaryFillPatterns() == false,
;;;111              "Array<Type>::Array", "if the data buffer being passed in doesn't contain a raw buffer, flags.get_useBoundaryFillPatterns must be false");
;;;112          }
;;;113    
;;;114          InitializeBuffer(numRows,
;;;115            numCols,
;;;116            data,
;;;117            dataLength,
;;;118            flags);
;;;119        }
;;;120    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  461d              MOV      r5,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd8038          LDR      r8,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f8df91bc          LDR      r9,|L445.488|
00002e  f1a0040c          SUB      r4,r0,#0xc
000032  f8c0a004          STR      r10,[r0,#4]
000036  f0150f0f          TST      r5,#0xf
00003a  d00d              BEQ      |L445.88|
00003c  2010              MOVS     r0,#0x10
00003e  2157              MOVS     r1,#0x57
000040  f8cd9000          STR      r9,[sp,#0]
000044  e9cd1001          STRD     r1,r0,[sp,#4]
000048  a368              ADR      r3,|L445.492|
00004a  a276              ADR      r2,|L445.548|
00004c  a182              ADR      r1,|L445.600|
00004e  2005              MOVS     r0,#5
000050  f7fffffe          BL       _Anki_Log
000054  f000b861          B.W      |L445.282|
                  |L445.88|
000058  2e00              CMP      r6,#0
00005a  da20              BGE      |L445.158|
00005c  213a              MOVS     r1,#0x3a
00005e  4882              LDR      r0,|L445.616|
000060  4b82              LDR      r3,|L445.620|
000062  e9cd0100          STRD     r0,r1,[sp,#0]
000066  f1a30210          SUB      r2,r3,#0x10
00006a  f1a20124          SUB      r1,r2,#0x24
00006e  2005              MOVS     r0,#5
000070  f7fffffe          BL       _Anki_Log
000074  4650              MOV      r0,r10
                  |L445.118|
000076  60a0              STR      r0,[r4,#8]
000078  2e00              CMP      r6,#0
00007a  bfa2              ITTT     GE
00007c  2f00              CMPGE    r7,#0
00007e  4378              MULGE    r0,r7,r0
000080  4580              CMPGE    r8,r0
000082  da15              BGE      |L445.176|
000084  205c              MOVS     r0,#0x5c
000086  e9cd9000          STRD     r9,r0,[sp,#0]
00008a  a358              ADR      r3,|L445.492|
00008c  a278              ADR      r2,|L445.624|
00008e  a17c              ADR      r1,|L445.640|
000090  2005              MOVS     r0,#5
000092  f7fffffe          BL       _Anki_Log
000096  b005              ADD      sp,sp,#0x14
000098  4620              MOV      r0,r4
00009a  e8bd8ff0          POP      {r4-r11,pc}
                  |L445.158|
00009e  4630              MOV      r0,r6
0000a0  2e01              CMP      r6,#1
0000a2  bfd8              IT       LE
0000a4  2001              MOVLE    r0,#1
0000a6  0100              LSLS     r0,r0,#4
0000a8  300f              ADDS     r0,r0,#0xf
0000aa  f020000f          BIC      r0,r0,#0xf
0000ae  e7e2              B        |L445.118|
                  |L445.176|
0000b0  a80f              ADD      r0,sp,#0x3c
0000b2  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer20get_isFullyAllocatedEv ; Anki::Embedded::Flags::Buffer::get_isFullyAllocated() const
0000b6  2800              CMP      r0,#0
0000b8  d033              BEQ      |L445.290|
0000ba  2f01              CMP      r7,#1
0000bc  d010              BEQ      |L445.224|
0000be  68a1              LDR      r1,[r4,#8]
0000c0  0130              LSLS     r0,r6,#4
0000c2  4281              CMP      r1,r0
0000c4  d01c              BEQ      |L445.256|
0000c6  2067              MOVS     r0,#0x67
0000c8  e9cd9000          STRD     r9,r0,[sp,#0]
0000cc  a347              ADR      r3,|L445.492|
0000ce  4a71              LDR      r2,|L445.660|
0000d0  a16b              ADR      r1,|L445.640|
0000d2  2005              MOVS     r0,#5
0000d4  f7fffffe          BL       _Anki_Log
0000d8  b005              ADD      sp,sp,#0x14
0000da  4620              MOV      r0,r4
0000dc  e8bd8ff0          POP      {r4-r11,pc}
                  |L445.224|
0000e0  68a0              LDR      r0,[r4,#8]
0000e2  4540              CMP      r0,r8
0000e4  dd0c              BLE      |L445.256|
0000e6  2062              MOVS     r0,#0x62
0000e8  e9cd9000          STRD     r9,r0,[sp,#0]
0000ec  a33f              ADR      r3,|L445.492|
0000ee  4a6a              LDR      r2,|L445.664|
0000f0  a163              ADR      r1,|L445.640|
0000f2  2005              MOVS     r0,#5
0000f4  f7fffffe          BL       _Anki_Log
0000f8  b005              ADD      sp,sp,#0x14
0000fa  4620              MOV      r0,r4
0000fc  e8bd8ff0          POP      {r4-r11,pc}
                  |L445.256|
000100  a80f              ADD      r0,sp,#0x3c
000102  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000106  b160              CBZ      r0,|L445.290|
000108  206e              MOVS     r0,#0x6e
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a337              ADR      r3,|L445.492|
000110  4a62              LDR      r2,|L445.668|
000112  a15b              ADR      r1,|L445.640|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
                  |L445.282|
00011a  b005              ADD      sp,sp,#0x14
00011c  4620              MOV      r0,r4
00011e  e8bd8ff0          POP      {r4-r11,pc}
                  |L445.290|
000122  980f              LDR      r0,[sp,#0x3c]
000124  f8df9178          LDR      r9,|L445.672|
000128  9003              STR      r0,[sp,#0xc]
00012a  b16d              CBZ      r5,|L445.328|
00012c  f1b80f10          CMP      r8,#0x10
000130  d21d              BCS      |L445.366|
000132  f2403023          MOV      r0,#0x323
000136  e9cd9000          STRD     r9,r0,[sp,#0]
00013a  a32c              ADR      r3,|L445.492|
00013c  a259              ADR      r2,|L445.676|
00013e  a15e              ADR      r1,|L445.696|
000140  2005              MOVS     r0,#5
000142  f7fffffe          BL       _Anki_Log
000146  e7e8              B        |L445.282|
                  |L445.328|
000148  f240301e          MOV      r0,#0x31e
00014c  e9cd9000          STRD     r9,r0,[sp,#0]
000150  a326              ADR      r3,|L445.492|
000152  a261              ADR      r2,|L445.728|
000154  a167              ADR      r1,|L445.756|
000156  2005              MOVS     r0,#5
000158  f7fffffe          BL       _Anki_Log
00015c  f8c4b000          STR      r11,[r4,#0]
000160  f8c4b004          STR      r11,[r4,#4]
000164  f8c4b008          STR      r11,[r4,#8]
000168  f8c4a010          STR      r10,[r4,#0x10]
00016c  e7d5              B        |L445.282|
                  |L445.366|
00016e  a803              ADD      r0,sp,#0xc
000170  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000174  b150              CBZ      r0,|L445.396|
000176  f2403026          MOV      r0,#0x326
00017a  e9cd9000          STRD     r9,r0,[sp,#0]
00017e  a31b              ADR      r3,|L445.492|
000180  a262              ADR      r2,|L445.780|
000182  a14d              ADR      r1,|L445.696|
000184  2005              MOVS     r0,#5
000186  f7fffffe          BL       _Anki_Log
00018a  e7c6              B        |L445.282|
                  |L445.396|
00018c  9903              LDR      r1,[sp,#0xc]
00018e  e9c41503          STRD     r1,r5,[r4,#0xc]
000192  f105000f          ADD      r0,r5,#0xf
000196  f020000f          BIC      r0,r0,#0xf
00019a  e9c47600          STRD     r7,r6,[r4,#0]
00019e  1b40              SUBS     r0,r0,r5
0001a0  2e01              CMP      r6,#1
0001a2  bfd8              IT       LE
0001a4  2601              MOVLE    r6,#1
0001a6  0131              LSLS     r1,r6,#4
0001a8  310f              ADDS     r1,r1,#0xf
0001aa  f021010f          BIC      r1,r1,#0xf
0001ae  fb010107          MLA      r1,r1,r7,r0
0001b2  4541              CMP      r1,r8
0001b4  bfdc              ITT      LE
0001b6  1829              ADDLE    r1,r5,r0
0001b8  6121              STRLE    r1,[r4,#0x10]
0001ba  ddae              BLE      |L445.282|
0001bc  f2403035          MOV      r0,#0x335
0001c0  f8cd9000          STR      r9,[sp,#0]
0001c4  e9cd0101          STRD     r0,r1,[sp,#4]
0001c8  a308              ADR      r3,|L445.492|
0001ca  a25a              ADR      r2,|L445.820|
0001cc  a149              ADR      r1,|L445.756|
0001ce  2005              MOVS     r0,#5
0001d0  f7fffffe          BL       _Anki_Log
0001d4  f8c4b000          STR      r11,[r4,#0]
0001d8  f8c4b004          STR      r11,[r4,#4]
0001dc  f8c4b008          STR      r11,[r4,#8]
0001e0  f8c4a010          STR      r10,[r4,#0x10]
0001e4  e799              B        |L445.282|
                          ENDP

0001e6  0000              DCW      0x0000
                  |L445.488|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L445.492|
0001ec  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
0001f0  6f726574
0001f4  6563685c
0001f8  636f6d6d
0001fc  6f6e5c69
000200  6e636c75
000204  64655c61
000208  6e6b692f
00020c  636f6d6d
000210  6f6e2f72
000214  6f626f74
000218  2f617272
00021c  617932  
00021f  642e6800          DCB      "d.h",0
000223  00                DCB      0
                  |L445.548|
000224  49662066          DCB      "If fully allocated, data must be %d byte aligned",0
000228  756c6c79
00022c  20616c6c
000230  6f636174
000234  65642c20
000238  64617461
00023c  206d7573
000240  74206265
000244  20256420
000248  62797465
00024c  20616c69
000250  676e6564
000254  00      
000255  00                DCB      0
000256  00                DCB      0
000257  00                DCB      0
                  |L445.600|
000258  41727261          DCB      "Array::Array",0
00025c  793a3a41
000260  72726179
000264  00      
000265  00                DCB      0
000266  00                DCB      0
000267  00                DCB      0
                  |L445.616|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L445.620|
                          DCD      ||.constdata||+0x312c
                  |L445.624|
000270  496e7661          DCB      "Invalid size",0
000274  6c696420
000278  73697a65
00027c  00      
00027d  00                DCB      0
00027e  00                DCB      0
00027f  00                DCB      0
                  |L445.640|
000280  41727261          DCB      "Array<Type>::Array",0
000284  793c5479
000288  70653e3a
00028c  3a417272
000290  617900  
000293  00                DCB      0
                  |L445.660|
                          DCD      ||.constdata||+0x31e0
                  |L445.664|
                          DCD      ||.constdata||+0x3164
                  |L445.668|
                          DCD      ||.constdata||+0x32bc
                  |L445.672|
                          DCD      _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L445.676|
0002a4  4e656761          DCB      "Negative dimension",0
0002a8  74697665
0002ac  2064696d
0002b0  656e7369
0002b4  6f6e00  
0002b7  00                DCB      0
                  |L445.696|
0002b8  41727261          DCB      "Array<Type>::InitializeBuffer",0
0002bc  793c5479
0002c0  70653e3a
0002c4  3a496e69
0002c8  7469616c
0002cc  697a6542
0002d0  75666665
0002d4  7200    
0002d6  00                DCB      0
0002d7  00                DCB      0
                  |L445.728|
0002d8  696e7075          DCB      "input data buffer is NULL",0
0002dc  74206461
0002e0  74612062
0002e4  75666665
0002e8  72206973
0002ec  204e554c
0002f0  4c00    
0002f2  00                DCB      0
0002f3  00                DCB      0
                  |L445.756|
0002f4  416e6b69          DCB      "Anki.Array2d.initialize",0
0002f8  2e417272
0002fc  61793264
000300  2e696e69
000304  7469616c
000308  697a6500
                  |L445.780|
00030c  46696c6c          DCB      "Fill patterns not supported for Array",0
000310  20706174
000314  7465726e
000318  73206e6f
00031c  74207375
000320  70706f72
000324  74656420
000328  666f7220
00032c  41727261
000330  7900    
000332  00                DCB      0
000333  00                DCB      0
                  |L445.820|
000334  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
000338  74206461
00033c  74612062
000340  75666665
000344  72206973
000348  206e6f74
00034c  206c6172
000350  67652065
000354  6e6f7567
000358  682e2025
00035c  64206279
000360  74657320
000364  69732072
000368  657175  
00036b  69726564          DCB      "ired.",0
00036f  2e00    
000371  00                DCB      0
000372  00                DCB      0
000373  00                DCB      0

                          AREA ||area_number.446||, COMGROUP=_ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEEC1EiiPviNS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEEC1EiiPviNS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.446||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEEC1EiiPviNS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier9DTreeNodeEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier9DTreeNodeEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier9DTreeNodeEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L452.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L452.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.453||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier9DTreeNodeEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier9DTreeNodeEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.453||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_10Classifier17CascadeClassifier9DTreeNodeEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEERKNS0_14LinearSequenceIiEES8_||, COMGROUP=_ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEERKNS0_14LinearSequenceIiEES8_, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded10ArraySliceIfEC2ENS0_5ArrayIfEERKNS0_14LinearSequenceIiEES8_                  ; Alternate entry point ; Anki::Embedded::ArraySlice<float>::ArraySlice__sub_object(Anki::Embedded::Array<float>, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
                  _ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEERKNS0_14LinearSequenceIiEES8_ PROC ; Anki::Embedded::ArraySlice<float>::ArraySlice(Anki::Embedded::Array<float>, const Anki::Embedded::LinearSequence<int>&, const Anki::Embedded::LinearSequence<int>&)
;;;88     
;;;89         template<typename Type> ArraySlice<Type>::ArraySlice(Array<Type> array, const LinearSequence<s32> &ySlice, const LinearSequence<s32> &xSlice)
;;;90           : ConstArraySlice<Type>(array, ySlice, xSlice)
;;;91         {
;;;92           if(array.get_numElements() == 0) {
;;;93             this->arrayData = NULL;
;;;94           } else {
;;;95             this->arrayData = array.Pointer(0,0);
;;;96           }
;;;97         }
;;;98     
000000  e92d01f0          PUSH     {r4-r8}
000004  e9dd4507          LDRD     r4,r5,[sp,#0x1c]
000008  e9dd6c05          LDRD     r6,r12,[sp,#0x14]
00000c  e9d47800          LDRD     r7,r8,[r4,#0]
000010  68a4              LDR      r4,[r4,#8]
000012  6007              STR      r7,[r0,#0]
000014  e9c08401          STRD     r8,r4,[r0,#4]
000018  e9d54700          LDRD     r4,r7,[r5,#0]
00001c  68ad              LDR      r5,[r5,#8]
00001e  e9c05105          STRD     r5,r1,[r0,#0x14]
000022  f100081c          ADD      r8,r0,#0x1c
000026  2500              MOVS     r5,#0
000028  e8a8104c          STM      r8!,{r2,r3,r6,r12}
00002c  e9c04703          STRD     r4,r7,[r0,#0xc]
000030  2900              CMP      r1,#0
000032  bfc8              IT       GT
000034  2a00              CMPGT    r2,#0
000036  dd13              BLE      |L459.96|
000038  fb01f402          MUL      r4,r1,r2
00003c  b184              CBZ      r4,|L459.96|
00003e  2400              MOVS     r4,#0
000040  fb04c403          MLA      r4,r4,r3,r12
000044  62c4              STR      r4,[r0,#0x2c]
                  |L459.70|
000046  2900              CMP      r1,#0
000048  bfc8              IT       GT
00004a  2a00              CMPGT    r2,#0
00004c  dd0a              BLE      |L459.100|
00004e  4351              MULS     r1,r2,r1
000050  b141              CBZ      r1,|L459.100|
000052  2100              MOVS     r1,#0
000054  fb01c103          MLA      r1,r1,r3,r12
000058  6301              STR      r1,[r0,#0x30]
00005a  e8bd01f0          POP      {r4-r8}
00005e  4770              BX       lr
                  |L459.96|
000060  62c5              STR      r5,[r0,#0x2c]
000062  e7f0              B        |L459.70|
                  |L459.100|
000064  6305              STR      r5,[r0,#0x30]
000066  e8bd01f0          POP      {r4-r8}
00006a  4770              BX       lr
                          ENDP


                          AREA ||area_number.460||, COMGROUP=_ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEERKNS0_14LinearSequenceIiEES8_, LINKORDER=||t._ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEERKNS0_14LinearSequenceIiEES8_||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.460||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded10ArraySliceIfEC1ENS0_5ArrayIfEERKNS0_14LinearSequenceIiEES8_||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE||, COMGROUP=_ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE PROC ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)
;;;515    
;;;516          template<typename InType, typename IntermediateType, typename OutType> Result DownsampleByPowerOfTwo(const Array<InType> &in, const s32 downsamplePower, Array<OutType> &out, MemoryStack scratch)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;517          {
000004  b091              SUB      sp,sp,#0x44
000006  4688              MOV      r8,r1
;;;518            const s32 largeHeight = in.get_size(0);
000008  2100              MOVS     r1,#0
00000a  9811              LDR      r0,[sp,#0x44]
00000c  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000010  4604              MOV      r4,r0
;;;519            const s32 largeWidth = in.get_size(1);
000012  2101              MOVS     r1,#1
000014  9811              LDR      r0,[sp,#0x44]
000016  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00001a  4681              MOV      r9,r0
;;;520    
;;;521            const s32 smallHeight = largeHeight >> downsamplePower;
00001c  fa44f008          ASR      r0,r4,r8
;;;522            const s32 smallWidth = largeWidth >> downsamplePower;
;;;523    
;;;524            const s32 downsampleFactor = 1 << downsamplePower;
000020  900c              STR      r0,[sp,#0x30]
000022  2001              MOVS     r0,#1
;;;525    
;;;526            AnkiConditionalErrorAndReturnValue(AreValid(in, out , scratch),
000024  e9dd6413          LDRD     r6,r4,[sp,#0x4c]
000028  fa00f508          LSL      r5,r0,r8              ;524
00002c  fa49f708          ASR      r7,r9,r8              ;522
000030  9811              LDR      r0,[sp,#0x44]         ;522
000032  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000036  f8dfa1d8          LDR      r10,|L466.528|
00003a  2800              CMP      r0,#0
00003c  d02f              BEQ      |L466.158|
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
000044  2800              CMP      r0,#0
000046  d02a              BEQ      |L466.158|
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       _ZNK4Anki8Embedded11MemoryStack7IsValidEv ; Anki::Embedded::MemoryStack::IsValid() const
00004e  2800              CMP      r0,#0
000050  d025              BEQ      |L466.158|
000052  9c13              LDR      r4,[sp,#0x4c]
;;;527              RESULT_FAIL_INVALID_OBJECT, "DownsampleByFactor", "Invalid objects");
;;;528    
;;;529            AnkiConditionalErrorAndReturnValue(AreEqualSize(smallHeight, smallWidth, out),
000054  46bb              MOV      r11,r7
000056  4620              MOV      r0,r4
000058  9e0c              LDR      r6,[sp,#0x30]
00005a  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE7IsValidEv ; Anki::Embedded::Array<unsigned char>::IsValid() const
00005e  2800              CMP      r0,#0
000060  d02c              BEQ      |L466.188|
000062  2100              MOVS     r1,#0
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
00006a  42b0              CMP      r0,r6
00006c  d126              BNE      |L466.188|
00006e  2101              MOVS     r1,#1
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       _ZNK4Anki8Embedded5ArrayIhE8get_sizeEi ; Anki::Embedded::Array<unsigned char>::get_size(int) const
000076  4558              CMP      r0,r11
000078  d120              BNE      |L466.188|
;;;530              RESULT_FAIL_INVALID_SIZE, "DownsampleByFactor", "size(out) is not equal to size(in) >> downsampleFactor");
;;;531    
;;;532            AnkiConditionalErrorAndReturnValue(largeWidth % 4 == 0,
00007a  f0190f03          TST      r9,#3
00007e  d02c              BEQ      |L466.218|
000080  f44f7005          MOV      r0,#0x214
000084  e9cda000          STRD     r10,r0,[sp,#0]
000088  a362              ADR      r3,|L466.532|
00008a  a272              ADR      r2,|L466.596|
00008c  a17f              ADR      r1,|L466.652|
00008e  2005              MOVS     r0,#5
000090  f7fffffe          BL       _Anki_Log
;;;533              RESULT_FAIL_INVALID_SIZE, "DownsampleByFactor", "The width of the in Array must be a multiple of four");
;;;534    
;;;535            Array<InType> inRow(1, largeWidth, scratch);
;;;536            Array<IntermediateType> accumulator(1, largeWidth >> downsamplePower, scratch);
;;;537    
;;;538            InType * restrict pInRow = inRow.Pointer(0,0);
;;;539            IntermediateType * restrict pAccumulator = accumulator.Pointer(0,0);
;;;540    
;;;541            const s32 numWordsToCopy = (sizeof(InType)*largeWidth) >> 2; // If the input in stride is not a multiple of four, this will be too small
;;;542    
;;;543            const s32 normalizationShift = 2*downsamplePower;
;;;544    
;;;545            for(s32 ySmall=0; ySmall<smallHeight; ySmall++) {
;;;546              accumulator.SetZero();
;;;547    
;;;548              // Accumulate a block of "largeWidth X downsampleFactor" pixels into a "smallWidth X 1" buffer
;;;549              for(s32 yp=0; yp<downsampleFactor; yp++) {
;;;550                const s32 yLarge = (ySmall << downsamplePower) + yp; // The actual row of the input image
;;;551    
;;;552                const InType * restrict pIn = in.Pointer(yLarge, 0);
;;;553    
;;;554                // First, copy a row from in to the temporary buffer
;;;555                // TODO: DMA may be faster
;;;556                for(s32 i=0; i<numWordsToCopy; i++) {
;;;557                  AnkiAssert(reinterpret_cast<size_t>(pIn) % 4 == 0);
;;;558                  reinterpret_cast<u32*>(pInRow)[i] = reinterpret_cast<const u32*>(pIn)[i];
;;;559                }
;;;560    
;;;561                // Next, accumulate into the accumulator
;;;562                for(s32 xSmall=0; xSmall<smallWidth; xSmall++) {
;;;563                  for(s32 xp=0; xp<downsampleFactor; xp++) {
;;;564                    const s32 xLarge = (xSmall << downsamplePower) + xp; // The actual column of the input image
;;;565    
;;;566                    pAccumulator[xSmall] += static_cast<IntermediateType>(pInRow[xLarge]);
;;;567                  } // for(s32 xp=0; xp<downsampleFactor; xp++)
;;;568                } // for(s32 xSmall=0; xSmall<smallWidth; xSmall++)
;;;569              } // for(s32 yp=0; yp<downsampleFactor; yp++)
;;;570    
;;;571              // Convert the sums to averages
;;;572              OutType * restrict pOut = out.Pointer(ySmall, 0);
;;;573              for(s32 xSmall=0; xSmall<smallWidth; xSmall++) {
;;;574                pOut[xSmall] = static_cast<OutType>(pAccumulator[xSmall] >> normalizationShift);
;;;575              } // for(s32 xSmall=0; xSmall<smallWidth; xSmall++)
;;;576            } // for(s32 ySmall=0; ySmall<smallHeight; ySmall++)
;;;577    
;;;578            return RESULT_OK;
;;;579          }
000094  b015              ADD      sp,sp,#0x54
000096  f04f60a0          MOV      r0,#0x5000000         ;532
00009a  e8bd8ff0          POP      {r4-r11,pc}
                  |L466.158|
00009e  f240200e          MOV      r0,#0x20e             ;526
0000a2  e9cda000          STRD     r10,r0,[sp,#0]        ;526
0000a6  a35b              ADR      r3,|L466.532|
0000a8  a27d              ADR      r2,|L466.672|
0000aa  a178              ADR      r1,|L466.652|
0000ac  2005              MOVS     r0,#5                 ;526
0000ae  f7fffffe          BL       _Anki_Log
0000b2  b015              ADD      sp,sp,#0x54
0000b4  f04f6080          MOV      r0,#0x4000000         ;526
0000b8  e8bd8ff0          POP      {r4-r11,pc}
                  |L466.188|
0000bc  f2402011          MOV      r0,#0x211             ;529
0000c0  e9cda000          STRD     r10,r0,[sp,#0]        ;529
0000c4  a353              ADR      r3,|L466.532|
0000c6  a27a              ADR      r2,|L466.688|
0000c8  a170              ADR      r1,|L466.652|
0000ca  2005              MOVS     r0,#5                 ;529
0000cc  f7fffffe          BL       _Anki_Log
0000d0  b015              ADD      sp,sp,#0x54
0000d2  f04f60a0          MOV      r0,#0x5000000         ;529
0000d6  e8bd8ff0          POP      {r4-r11,pc}
                  |L466.218|
0000da  2300              MOVS     r3,#0                 ;535
0000dc  461a              MOV      r2,r3                 ;535
0000de  2101              MOVS     r1,#1                 ;535
0000e0  a80e              ADD      r0,sp,#0x38           ;535
0000e2  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
0000e6  6800              LDR      r0,[r0,#0]            ;535
0000e8  9000              STR      r0,[sp,#0]            ;535
0000ea  464a              MOV      r2,r9                 ;535
0000ec  2101              MOVS     r1,#1                 ;535
0000ee  a807              ADD      r0,sp,#0x1c           ;535
0000f0  9b14              LDR      r3,[sp,#0x50]         ;535
0000f2  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
0000f6  2300              MOVS     r3,#0                 ;536
0000f8  461a              MOV      r2,r3                 ;536
0000fa  2101              MOVS     r1,#1                 ;536
0000fc  a80f              ADD      r0,sp,#0x3c           ;536
0000fe  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ebbb ; Anki::Embedded::Flags::Buffer::Buffer(bool, bool, bool)
000102  6800              LDR      r0,[r0,#0]            ;536
000104  9000              STR      r0,[sp,#0]            ;536
000106  463a              MOV      r2,r7                 ;536
000108  2101              MOVS     r1,#1                 ;536
00010a  a802              ADD      r0,sp,#8              ;536
00010c  9b14              LDR      r3,[sp,#0x50]         ;536
00010e  f7fffffe          BL       _ZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE ; Anki::Embedded::Array<unsigned>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
000112  9a09              LDR      r2,[sp,#0x24]         ;536
000114  990b              LDR      r1,[sp,#0x2c]         ;536
000116  2000              MOVS     r0,#0                 ;538
000118  fb001602          MLA      r6,r0,r2,r1           ;538
00011c  9a04              LDR      r2,[sp,#0x10]         ;538
00011e  9906              LDR      r1,[sp,#0x18]         ;538
000120  ea4f0999          LSR      r9,r9,#2              ;541
000124  fb001402          MLA      r4,r0,r2,r1           ;541
000128  ea4f0048          LSL      r0,r8,#1              ;543
00012c  900d              STR      r0,[sp,#0x34]         ;545
00012e  980c              LDR      r0,[sp,#0x30]         ;545
000130  f04f0a00          MOV      r10,#0                ;545
000134  2800              CMP      r0,#0                 ;545
000136  dd67              BLE      |L466.520|
                  |L466.312|
000138  9806              LDR      r0,[sp,#0x18]         ;545
00013a  b180              CBZ      r0,|L466.350|
00013c  9802              LDR      r0,[sp,#8]            ;545
00013e  2800              CMP      r0,#0                 ;545
000140  bfa4              ITT      GE                    ;545
000142  9803              LDRGE    r0,[sp,#0xc]          ;545
000144  2800              CMPGE    r0,#0                 ;545
000146  db0a              BLT      |L466.350|
000148  9904              LDR      r1,[sp,#0x10]         ;545
00014a  9802              LDR      r0,[sp,#8]            ;545
00014c  9b04              LDR      r3,[sp,#0x10]         ;545
00014e  4341              MULS     r1,r0,r1              ;545
000150  9a06              LDR      r2,[sp,#0x18]         ;545
000152  2000              MOVS     r0,#0                 ;545
000154  fb002003          MLA      r0,r0,r3,r2           ;545
000158  f7fffffe          BL       __aeabi_memclr4
00015c  e00a              B        |L466.372|
                  |L466.350|
00015e  f2402176          MOV      r1,#0x276             ;545
000162  4861              LDR      r0,|L466.744|
000164  e9cd0100          STRD     r0,r1,[sp,#0]         ;545
000168  a360              ADR      r3,|L466.748|
00016a  a26e              ADR      r2,|L466.804|
00016c  a174              ADR      r1,|L466.832|
00016e  2005              MOVS     r0,#5                 ;545
000170  f7fffffe          BL       _Anki_Log
                  |L466.372|
000174  f04f0b00          MOV      r11,#0                ;549
000178  2d00              CMP      r5,#0                 ;549
00017a  bfc8              IT       GT                    ;550
00017c  fa0afe08          LSLGT    lr,r10,r8             ;550
000180  dd2c              BLE      |L466.476|
                  |L466.386|
000182  9911              LDR      r1,[sp,#0x44]         ;549
000184  eb0e000b          ADD      r0,lr,r11             ;550
000188  690a              LDR      r2,[r1,#0x10]         ;550
00018a  6889              LDR      r1,[r1,#8]            ;550
00018c  fb002101          MLA      r1,r0,r1,r2           ;550
000190  2000              MOVS     r0,#0                 ;556
000192  f1b90f00          CMP      r9,#0                 ;556
000196  dd06              BLE      |L466.422|
                  |L466.408|
000198  f8512020          LDR      r2,[r1,r0,LSL #2]     ;558
00019c  f8462020          STR      r2,[r6,r0,LSL #2]     ;558
0001a0  1c40              ADDS     r0,r0,#1              ;556
0001a2  4581              CMP      r9,r0                 ;556
0001a4  dcf8              BGT      |L466.408|
                  |L466.422|
0001a6  2100              MOVS     r1,#0                 ;562
0001a8  2f00              CMP      r7,#0                 ;562
0001aa  dd13              BLE      |L466.468|
                  |L466.428|
0001ac  2000              MOVS     r0,#0                 ;563
0001ae  2d00              CMP      r5,#0                 ;563
0001b0  bfc8              IT       GT                    ;564
0001b2  fa01fc08          LSLGT    r12,r1,r8             ;564
0001b6  dd0a              BLE      |L466.462|
                  |L466.440|
0001b8  eb0c0200          ADD      r2,r12,r0             ;564
0001bc  f8543021          LDR      r3,[r4,r1,LSL #2]     ;566
0001c0  5cb2              LDRB     r2,[r6,r2]            ;566
0001c2  1c40              ADDS     r0,r0,#1              ;563
0001c4  441a              ADD      r2,r2,r3              ;566
0001c6  f8442021          STR      r2,[r4,r1,LSL #2]     ;566
0001ca  4285              CMP      r5,r0                 ;563
0001cc  dcf4              BGT      |L466.440|
                  |L466.462|
0001ce  1c49              ADDS     r1,r1,#1              ;562
0001d0  428f              CMP      r7,r1                 ;562
0001d2  dceb              BGT      |L466.428|
                  |L466.468|
0001d4  f10b0b01          ADD      r11,r11,#1            ;549
0001d8  455d              CMP      r5,r11                ;549
0001da  dcd2              BGT      |L466.386|
                  |L466.476|
0001dc  9813              LDR      r0,[sp,#0x4c]         ;549
0001de  6901              LDR      r1,[r0,#0x10]         ;549
0001e0  6880              LDR      r0,[r0,#8]            ;549
0001e2  fb0a1100          MLA      r1,r10,r0,r1          ;549
0001e6  2000              MOVS     r0,#0                 ;573
0001e8  2f00              CMP      r7,#0                 ;573
0001ea  dd08              BLE      |L466.510|
                  |L466.492|
0001ec  f8543020          LDR      r3,[r4,r0,LSL #2]     ;574
0001f0  9a0d              LDR      r2,[sp,#0x34]         ;574
0001f2  fa23f202          LSR      r2,r3,r2              ;574
0001f6  540a              STRB     r2,[r1,r0]            ;574
0001f8  1c40              ADDS     r0,r0,#1              ;573
0001fa  4287              CMP      r7,r0                 ;573
0001fc  dcf6              BGT      |L466.492|
                  |L466.510|
0001fe  980c              LDR      r0,[sp,#0x30]         ;545
000200  f10a0a01          ADD      r10,r10,#1            ;545
000204  4582              CMP      r10,r0                ;545
000206  db97              BLT      |L466.312|
                  |L466.520|
000208  b015              ADD      sp,sp,#0x54
00020a  2000              MOVS     r0,#0                 ;578
00020c  e8bd8ff0          POP      {r4-r11,pc}
;;;580    
                          ENDP

                  |L466.528|
                          DCD      _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::__PRETTY_FUNCTION__
                  |L466.532|
000214  2e2e5c63          DCB      "..\\coretech\\vision\\include\\anki/vision/robot/imageP"
000218  6f726574
00021c  6563685c
000220  76697369
000224  6f6e5c69
000228  6e636c75
00022c  64655c61
000230  6e6b692f
000234  76697369
000238  6f6e2f72
00023c  6f626f74
000240  2f696d61
000244  676550  
000247  726f6365          DCB      "rocessing.h",0
00024b  7373696e
00024f  672e6800
000253  00                DCB      0
                  |L466.596|
000254  54686520          DCB      "The width of the in Array must be a multiple of four",0
000258  77696474
00025c  68206f66
000260  20746865
000264  20696e20
000268  41727261
00026c  79206d75
000270  73742062
000274  65206120
000278  6d756c74
00027c  69706c65
000280  206f6620
000284  666f7572
000288  00      
000289  00                DCB      0
00028a  00                DCB      0
00028b  00                DCB      0
                  |L466.652|
00028c  446f776e          DCB      "DownsampleByFactor",0
000290  73616d70
000294  6c654279
000298  46616374
00029c  6f7200  
00029f  00                DCB      0
                  |L466.672|
0002a0  496e7661          DCB      "Invalid objects",0
0002a4  6c696420
0002a8  6f626a65
0002ac  63747300
                  |L466.688|
0002b0  73697a65          DCB      "size(out) is not equal to size(in) >> downsampleFactor",0
0002b4  286f7574
0002b8  29206973
0002bc  206e6f74
0002c0  20657175
0002c4  616c2074
0002c8  6f207369
0002cc  7a652869
0002d0  6e29203e
0002d4  3e20646f
0002d8  776e7361
0002dc  6d706c65
0002e0  46616374
0002e4  6f7200  
0002e7  00                DCB      0
                  |L466.744|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::SetZero()::__PRETTY_FUNCTION__
                  |L466.748|
0002ec  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
0002f0  6f726574
0002f4  6563685c
0002f8  636f6d6d
0002fc  6f6e5c69
000300  6e636c75
000304  64655c61
000308  6e6b692f
00030c  636f6d6d
000310  6f6e2f72
000314  6f626f74
000318  2f617272
00031c  617932  
00031f  642e6800          DCB      "d.h",0
000323  00                DCB      0
                  |L466.804|
000324  41727261          DCB      "Array<Type> is not valid",0
000328  793c5479
00032c  70653e20
000330  6973206e
000334  6f742076
000338  616c6964
00033c  00      
00033d  00                DCB      0
00033e  00                DCB      0
00033f  00                DCB      0
                  |L466.832|
000340  41727261          DCB      "Array<Type>::SetZero",0
000344  793c5479
000348  70653e3a
00034c  3a536574
000350  5a65726f
000354  00      
000355  00                DCB      0
000356  00                DCB      0
000357  00                DCB      0

                          AREA ||area_number.467||, COMGROUP=_ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE, LINKORDER=||t._ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.467||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayIjEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<unsigned>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<unsigned>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L473.86|
00003a  217d              MOVS     r1,#0x7d
00003c  484f              LDR      r0,|L473.380|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a34f              ADR      r3,|L473.384|
000044  a25c              ADR      r2,|L473.440|
000046  a160              ADR      r1,|L473.456|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L473.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  0080              LSLS     r0,r0,#2
000064  300f              ADDS     r0,r0,#0xf
000066  f020050f          BIC      r5,r0,#0xf
00006a  a804              ADD      r0,sp,#0x10
00006c  e9cd0902          STRD     r0,r9,[sp,#8]
000070  2d00              CMP      r5,#0
000072  dc0a              BGT      |L473.138|
000074  f240310b          MOV      r1,#0x30b
000078  4858              LDR      r0,|L473.476|
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  a340              ADR      r3,|L473.384|
000080  a24d              ADR      r2,|L473.440|
000082  a157              ADR      r1,|L473.480|
000084  2005              MOVS     r0,#5
000086  f7fffffe          BL       _Anki_Log
                  |L473.138|
00008a  4638              MOV      r0,r7
00008c  2f01              CMP      r7,#1
00008e  bfd8              IT       LE
000090  2001              MOVLE    r0,#1
000092  60a5              STR      r5,[r4,#8]
000094  4345              MULS     r5,r0,r5
000096  a803              ADD      r0,sp,#0xc
000098  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
00009c  4602              MOV      r2,r0
00009e  4629              MOV      r1,r5
0000a0  4640              MOV      r0,r8
0000a2  9b02              LDR      r3,[sp,#8]
0000a4  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000a8  f8cd900c          STR      r9,[sp,#0xc]
0000ac  f8dd8010          LDR      r8,[sp,#0x10]
0000b0  f8df9158          LDR      r9,|L473.524|
0000b4  0005              MOVS     r5,r0
0000b6  d00e              BEQ      |L473.214|
0000b8  f1b80f10          CMP      r8,#0x10
0000bc  d21e              BCS      |L473.252|
0000be  f2403023          MOV      r0,#0x323
0000c2  e9cd9000          STRD     r9,r0,[sp,#0]
0000c6  a32e              ADR      r3,|L473.384|
0000c8  a251              ADR      r2,|L473.528|
0000ca  a156              ADR      r1,|L473.548|
0000cc  2005              MOVS     r0,#5
0000ce  f7fffffe          BL       _Anki_Log
0000d2  f000b84f          B.W      |L473.372|
                  |L473.214|
0000d6  f240301e          MOV      r0,#0x31e
0000da  e9cd9000          STRD     r9,r0,[sp,#0]
0000de  a328              ADR      r3,|L473.384|
0000e0  a258              ADR      r2,|L473.580|
0000e2  a15f              ADR      r1,|L473.608|
0000e4  2005              MOVS     r0,#5
0000e6  f7fffffe          BL       _Anki_Log
0000ea  f8c4b000          STR      r11,[r4,#0]
0000ee  f8c4b004          STR      r11,[r4,#4]
0000f2  f8c4b008          STR      r11,[r4,#8]
0000f6  f8c4a010          STR      r10,[r4,#0x10]
0000fa  e03b              B        |L473.372|
                  |L473.252|
0000fc  a803              ADD      r0,sp,#0xc
0000fe  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000102  2800              CMP      r0,#0
000104  d00a              BEQ      |L473.284|
000106  f2403026          MOV      r0,#0x326
00010a  e9cd9000          STRD     r9,r0,[sp,#0]
00010e  a31c              ADR      r3,|L473.384|
000110  a259              ADR      r2,|L473.632|
000112  a144              ADR      r1,|L473.548|
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       _Anki_Log
00011a  e02b              B        |L473.372|
                  |L473.284|
00011c  9903              LDR      r1,[sp,#0xc]
00011e  e9c41503          STRD     r1,r5,[r4,#0xc]
000122  f105000f          ADD      r0,r5,#0xf
000126  f020000f          BIC      r0,r0,#0xf
00012a  e9c47600          STRD     r7,r6,[r4,#0]
00012e  1b40              SUBS     r0,r0,r5
000130  2e01              CMP      r6,#1
000132  bfd8              IT       LE
000134  2601              MOVLE    r6,#1
000136  00b1              LSLS     r1,r6,#2
000138  310f              ADDS     r1,r1,#0xf
00013a  f021010f          BIC      r1,r1,#0xf
00013e  fb010107          MLA      r1,r1,r7,r0
000142  4541              CMP      r1,r8
000144  bfdc              ITT      LE
000146  1829              ADDLE    r1,r5,r0
000148  6121              STRLE    r1,[r4,#0x10]
00014a  dd13              BLE      |L473.372|
00014c  f2403035          MOV      r0,#0x335
000150  f8cd9000          STR      r9,[sp,#0]
000154  e9cd0101          STRD     r0,r1,[sp,#4]
000158  a309              ADR      r3,|L473.384|
00015a  a251              ADR      r2,|L473.672|
00015c  a140              ADR      r1,|L473.608|
00015e  2005              MOVS     r0,#5
000160  f7fffffe          BL       _Anki_Log
000164  f8c4b000          STR      r11,[r4,#0]
000168  f8c4b004          STR      r11,[r4,#4]
00016c  f8c4b008          STR      r11,[r4,#8]
000170  f8c4a010          STR      r10,[r4,#0x10]
                  |L473.372|
000174  b005              ADD      sp,sp,#0x14
000176  4620              MOV      r0,r4
000178  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L473.380|
                          DCD      _ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L473.384|
000180  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
000184  6f726574
000188  6563685c
00018c  636f6d6d
000190  6f6e5c69
000194  6e636c75
000198  64655c61
00019c  6e6b692f
0001a0  636f6d6d
0001a4  6f6e2f72
0001a8  6f626f74
0001ac  2f617272
0001b0  617932  
0001b3  642e6800          DCB      "d.h",0
0001b7  00                DCB      0
                  |L473.440|
0001b8  496e7661          DCB      "Invalid size",0
0001bc  6c696420
0001c0  73697a65
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L473.456|
0001c8  41727261          DCB      "Array<Type>::Array",0
0001cc  793c5479
0001d0  70653e3a
0001d4  3a417272
0001d8  617900  
0001db  00                DCB      0
                  |L473.476|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L473.480|
0001e0  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001e4  793c5479
0001e8  70653e3a
0001ec  3a416c6c
0001f0  6f636174
0001f4  65427566
0001f8  66657246
0001fc  726f6d4d
000200  656d6f72
000204  79537461
000208  636b00  
00020b  00                DCB      0
                  |L473.524|
                          DCD      _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L473.528|
000210  4e656761          DCB      "Negative dimension",0
000214  74697665
000218  2064696d
00021c  656e7369
000220  6f6e00  
000223  00                DCB      0
                  |L473.548|
000224  41727261          DCB      "Array<Type>::InitializeBuffer",0
000228  793c5479
00022c  70653e3a
000230  3a496e69
000234  7469616c
000238  697a6542
00023c  75666665
000240  7200    
000242  00                DCB      0
000243  00                DCB      0
                  |L473.580|
000244  696e7075          DCB      "input data buffer is NULL",0
000248  74206461
00024c  74612062
000250  75666665
000254  72206973
000258  204e554c
00025c  4c00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L473.608|
000260  416e6b69          DCB      "Anki.Array2d.initialize",0
000264  2e417272
000268  61793264
00026c  2e696e69
000270  7469616c
000274  697a6500
                  |L473.632|
000278  46696c6c          DCB      "Fill patterns not supported for Array",0
00027c  20706174
000280  7465726e
000284  73206e6f
000288  74207375
00028c  70706f72
000290  74656420
000294  666f7220
000298  41727261
00029c  7900    
00029e  00                DCB      0
00029f  00                DCB      0
                  |L473.672|
0002a0  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002a4  74206461
0002a8  74612062
0002ac  75666665
0002b0  72206973
0002b4  206e6f74
0002b8  206c6172
0002bc  67652065
0002c0  6e6f7567
0002c4  682e2025
0002c8  64206279
0002cc  74657320
0002d0  69732072
0002d4  657175  
0002d7  69726564          DCB      "ired.",0
0002db  2e00    
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||area_number.474||, COMGROUP=_ZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.474||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, COMGROUP=_ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, CODE, READONLY, ALIGN=2

                  _ZN4Anki8Embedded5ArrayINS1_IfEEEC2EiiRNS0_11MemoryStackENS0_5Flags6BufferE                  ; Alternate entry point ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::Array__sub_object(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
                  _ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE PROC ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)
;;;120    
;;;121        template<typename Type> Array<Type>::Array(const s32 numRows, const s32 numCols, MemoryStack &memory, const Flags::Buffer flags)
;;;122        {
;;;123          InvalidateArray();
;;;124    
;;;125          AnkiConditionalErrorAndReturn(numCols >= 0 && numRows >= 0,
;;;126            "Array<Type>::Array", "Invalid size");
;;;127    
;;;128          s32 numBytesAllocated = 0;
;;;129    
;;;130          void * allocatedBuffer = AllocateBufferFromMemoryStack(numRows, ComputeRequiredStride(numCols, flags), memory, numBytesAllocated, flags, false);
;;;131    
;;;132          InitializeBuffer(numRows,
;;;133            numCols,
;;;134            reinterpret_cast<Type*>(allocatedBuffer),
;;;135            numBytesAllocated,
;;;136            flags);
;;;137        }
;;;138    
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4698              MOV      r8,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  300c              ADDS     r0,r0,#0xc
00000e  f8dd9038          LDR      r9,[sp,#0x38]
000012  f7fffffe          BL       _ZN4Anki8Embedded5Flags6BufferC1Ev ; Anki::Embedded::Flags::Buffer::Buffer()
000016  f04f3bff          MOV      r11,#0xffffffff
00001a  f840bc0c          STR      r11,[r0,#-0xc]
00001e  f840bc08          STR      r11,[r0,#-8]
000022  f840bc04          STR      r11,[r0,#-4]
000026  f04f0a00          MOV      r10,#0
00002a  f1a0040c          SUB      r4,r0,#0xc
00002e  f8c0a004          STR      r10,[r0,#4]
000032  2e00              CMP      r6,#0
000034  bfa8              IT       GE
000036  2f00              CMPGE    r7,#0
000038  da0d              BGE      |L480.86|
00003a  217d              MOVS     r1,#0x7d
00003c  4851              LDR      r0,|L480.388|
00003e  e9cd0100          STRD     r0,r1,[sp,#0]
000042  a351              ADR      r3,|L480.392|
000044  a25e              ADR      r2,|L480.448|
000046  a162              ADR      r1,|L480.464|
000048  2005              MOVS     r0,#5
00004a  f7fffffe          BL       _Anki_Log
00004e  b005              ADD      sp,sp,#0x14
000050  4620              MOV      r0,r4
000052  e8bd8ff0          POP      {r4-r11,pc}
                  |L480.86|
000056  f8cda010          STR      r10,[sp,#0x10]
00005a  2e01              CMP      r6,#1
00005c  bfcc              ITE      GT
00005e  4630              MOVGT    r0,r6
000060  2001              MOVLE    r0,#1
000062  eb000080          ADD      r0,r0,r0,LSL #2
000066  0080              LSLS     r0,r0,#2
000068  300f              ADDS     r0,r0,#0xf
00006a  f020050f          BIC      r5,r0,#0xf
00006e  a804              ADD      r0,sp,#0x10
000070  e9cd0902          STRD     r0,r9,[sp,#8]
000074  2d00              CMP      r5,#0
000076  dc0a              BGT      |L480.142|
000078  f240310b          MOV      r1,#0x30b
00007c  4859              LDR      r0,|L480.484|
00007e  e9cd0100          STRD     r0,r1,[sp,#0]
000082  a341              ADR      r3,|L480.392|
000084  a24e              ADR      r2,|L480.448|
000086  a158              ADR      r1,|L480.488|
000088  2005              MOVS     r0,#5
00008a  f7fffffe          BL       _Anki_Log
                  |L480.142|
00008e  4638              MOV      r0,r7
000090  2f01              CMP      r7,#1
000092  bfd8              IT       LE
000094  2001              MOVLE    r0,#1
000096  60a5              STR      r5,[r4,#8]
000098  4345              MULS     r5,r0,r5
00009a  a803              ADD      r0,sp,#0xc
00009c  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer23get_zeroAllocatedMemoryEv ; Anki::Embedded::Flags::Buffer::get_zeroAllocatedMemory() const
0000a0  4602              MOV      r2,r0
0000a2  4629              MOV      r1,r5
0000a4  4640              MOV      r0,r8
0000a6  9b02              LDR      r3,[sp,#8]
0000a8  f7fffffe          BL       _ZN4Anki8Embedded11MemoryStack8AllocateEibRi ; Anki::Embedded::MemoryStack::Allocate(int, bool, int&)
0000ac  f8cd900c          STR      r9,[sp,#0xc]
0000b0  f8dd8010          LDR      r8,[sp,#0x10]
0000b4  f8df915c          LDR      r9,|L480.532|
0000b8  0005              MOVS     r5,r0
0000ba  d00e              BEQ      |L480.218|
0000bc  f1b80f10          CMP      r8,#0x10
0000c0  d21e              BCS      |L480.256|
0000c2  f2403023          MOV      r0,#0x323
0000c6  e9cd9000          STRD     r9,r0,[sp,#0]
0000ca  a32f              ADR      r3,|L480.392|
0000cc  a252              ADR      r2,|L480.536|
0000ce  a157              ADR      r1,|L480.556|
0000d0  2005              MOVS     r0,#5
0000d2  f7fffffe          BL       _Anki_Log
0000d6  f000b851          B.W      |L480.380|
                  |L480.218|
0000da  f240301e          MOV      r0,#0x31e
0000de  e9cd9000          STRD     r9,r0,[sp,#0]
0000e2  a329              ADR      r3,|L480.392|
0000e4  a259              ADR      r2,|L480.588|
0000e6  a160              ADR      r1,|L480.616|
0000e8  2005              MOVS     r0,#5
0000ea  f7fffffe          BL       _Anki_Log
0000ee  f8c4b000          STR      r11,[r4,#0]
0000f2  f8c4b004          STR      r11,[r4,#4]
0000f6  f8c4b008          STR      r11,[r4,#8]
0000fa  f8c4a010          STR      r10,[r4,#0x10]
0000fe  e03d              B        |L480.380|
                  |L480.256|
000100  a803              ADD      r0,sp,#0xc
000102  f7fffffe          BL       _ZNK4Anki8Embedded5Flags6Buffer27get_useBoundaryFillPatternsEv ; Anki::Embedded::Flags::Buffer::get_useBoundaryFillPatterns() const
000106  2800              CMP      r0,#0
000108  d00a              BEQ      |L480.288|
00010a  f2403026          MOV      r0,#0x326
00010e  e9cd9000          STRD     r9,r0,[sp,#0]
000112  a31d              ADR      r3,|L480.392|
000114  a25a              ADR      r2,|L480.640|
000116  a145              ADR      r1,|L480.556|
000118  2005              MOVS     r0,#5
00011a  f7fffffe          BL       _Anki_Log
00011e  e02d              B        |L480.380|
                  |L480.288|
000120  9903              LDR      r1,[sp,#0xc]
000122  e9c41503          STRD     r1,r5,[r4,#0xc]
000126  f105000f          ADD      r0,r5,#0xf
00012a  f020000f          BIC      r0,r0,#0xf
00012e  e9c47600          STRD     r7,r6,[r4,#0]
000132  1b40              SUBS     r0,r0,r5
000134  2e01              CMP      r6,#1
000136  bfd8              IT       LE
000138  2601              MOVLE    r6,#1
00013a  eb060186          ADD      r1,r6,r6,LSL #2
00013e  0089              LSLS     r1,r1,#2
000140  310f              ADDS     r1,r1,#0xf
000142  f021010f          BIC      r1,r1,#0xf
000146  fb010107          MLA      r1,r1,r7,r0
00014a  4541              CMP      r1,r8
00014c  bfdc              ITT      LE
00014e  1829              ADDLE    r1,r5,r0
000150  6121              STRLE    r1,[r4,#0x10]
000152  dd13              BLE      |L480.380|
000154  f2403035          MOV      r0,#0x335
000158  f8cd9000          STR      r9,[sp,#0]
00015c  e9cd0101          STRD     r0,r1,[sp,#4]
000160  a309              ADR      r3,|L480.392|
000162  a251              ADR      r2,|L480.680|
000164  a140              ADR      r1,|L480.616|
000166  2005              MOVS     r0,#5
000168  f7fffffe          BL       _Anki_Log
00016c  f8c4b000          STR      r11,[r4,#0]
000170  f8c4b004          STR      r11,[r4,#4]
000174  f8c4b008          STR      r11,[r4,#8]
000178  f8c4a010          STR      r10,[r4,#0x10]
                  |L480.380|
00017c  b005              ADD      sp,sp,#0x14
00017e  4620              MOV      r0,r4
000180  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

                  |L480.388|
                          DCD      _ZZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L480.392|
000188  2e2e5c63          DCB      "..\\coretech\\common\\include\\anki/common/robot/array2"
00018c  6f726574
000190  6563685c
000194  636f6d6d
000198  6f6e5c69
00019c  6e636c75
0001a0  64655c61
0001a4  6e6b692f
0001a8  636f6d6d
0001ac  6f6e2f72
0001b0  6f626f74
0001b4  2f617272
0001b8  617932  
0001bb  642e6800          DCB      "d.h",0
0001bf  00                DCB      0
                  |L480.448|
0001c0  496e7661          DCB      "Invalid size",0
0001c4  6c696420
0001c8  73697a65
0001cc  00      
0001cd  00                DCB      0
0001ce  00                DCB      0
0001cf  00                DCB      0
                  |L480.464|
0001d0  41727261          DCB      "Array<Type>::Array",0
0001d4  793c5479
0001d8  70653e3a
0001dc  3a417272
0001e0  617900  
0001e3  00                DCB      0
                  |L480.484|
                          DCD      _ZZN4Anki8Embedded5ArrayINS1_IfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
                  |L480.488|
0001e8  41727261          DCB      "Array<Type>::AllocateBufferFromMemoryStack",0
0001ec  793c5479
0001f0  70653e3a
0001f4  3a416c6c
0001f8  6f636174
0001fc  65427566
000200  66657246
000204  726f6d4d
000208  656d6f72
00020c  79537461
000210  636b00  
000213  00                DCB      0
                  |L480.532|
                          DCD      _ZZN4Anki8Embedded5ArrayINS1_IfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
                  |L480.536|
000218  4e656761          DCB      "Negative dimension",0
00021c  74697665
000220  2064696d
000224  656e7369
000228  6f6e00  
00022b  00                DCB      0
                  |L480.556|
00022c  41727261          DCB      "Array<Type>::InitializeBuffer",0
000230  793c5479
000234  70653e3a
000238  3a496e69
00023c  7469616c
000240  697a6542
000244  75666665
000248  7200    
00024a  00                DCB      0
00024b  00                DCB      0
                  |L480.588|
00024c  696e7075          DCB      "input data buffer is NULL",0
000250  74206461
000254  74612062
000258  75666665
00025c  72206973
000260  204e554c
000264  4c00    
000266  00                DCB      0
000267  00                DCB      0
                  |L480.616|
000268  416e6b69          DCB      "Anki.Array2d.initialize",0
00026c  2e417272
000270  61793264
000274  2e696e69
000278  7469616c
00027c  697a6500
                  |L480.640|
000280  46696c6c          DCB      "Fill patterns not supported for Array",0
000284  20706174
000288  7465726e
00028c  73206e6f
000290  74207375
000294  70706f72
000298  74656420
00029c  666f7220
0002a0  41727261
0002a4  7900    
0002a6  00                DCB      0
0002a7  00                DCB      0
                  |L480.680|
0002a8  496e7075          DCB      "Input data buffer is not large enough. %d bytes is requ"
0002ac  74206461
0002b0  74612062
0002b4  75666665
0002b8  72206973
0002bc  206e6f74
0002c0  206c6172
0002c4  67652065
0002c8  6e6f7567
0002cc  682e2025
0002d0  64206279
0002d4  74657320
0002d8  69732072
0002dc  657175  
0002df  69726564          DCB      "ired.",0
0002e3  2e00    
0002e5  00                DCB      0
0002e6  00                DCB      0
0002e7  00                DCB      0

                          AREA ||area_number.481||, COMGROUP=_ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE, LINKORDER=||t._ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.481||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferE||
                          DCD      0x00000001

                          AREA ||t._ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi, CODE, READONLY, ALIGN=1

                  _ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi PROC ; Anki::Embedded::FixedLengthList<Anki::Embedded::Array<float>>::set_size(int)
;;;180        // Attempt to set the size to newSize. Returns the value that was actually set.
;;;181        template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
000000  4603              MOV      r3,r0
000002  69c0              LDR      r0,[r0,#0x1c]
;;;182        {
;;;183          newSize = MIN(this->get_maximumSize(), MAX(0,newSize));
000004  2900              CMP      r1,#0
000006  bfb4              ITE      LT
000008  2200              MOVLT    r2,#0
00000a  460a              MOVGE    r2,r1
00000c  4290              CMP      r0,r2
00000e  bfb8              IT       LT
000010  4601              MOVLT    r1,r0
000012  db02              BLT      |L487.26|
000014  2900              CMP      r1,#0
000016  bfb8              IT       LT
000018  2100              MOVLT    r1,#0
                  |L487.26|
00001a  4608              MOV      r0,r1
;;;184    
;;;185          this->xSlice.size = newSize;
00001c  60d9              STR      r1,[r3,#0xc]
;;;186    
;;;187          return newSize;
;;;188        } // s32 FixedLengthList<Type>::set_size(s32 newSize)
00001e  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||area_number.488||, COMGROUP=_ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi, LINKORDER=||t._ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.488||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._ZN4Anki8Embedded15FixedLengthListINS0_5ArrayIfEEE8set_sizeEi||
                          DCD      0x00000001

                          AREA ||.constdata__ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded14LinearSequenceIiE11computeSizeEiiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::LinearSequence<int>::computeSize(int, int, int)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a4c          DCB      0x64,0x3a,0x3a,0x4c
00001c  696e6561          DCB      0x69,0x6e,0x65,0x61
000020  72536571          DCB      0x72,0x53,0x65,0x71
000024  75656e63          DCB      0x75,0x65,0x6e,0x63
000028  653c5479          DCB      0x65,0x3c,0x54,0x79
00002c  70653e3a          DCB      0x70,0x65,0x3e,0x3a
000030  3a636f6d          DCB      0x3a,0x63,0x6f,0x6d
000034  70757465          DCB      0x70,0x75,0x74,0x65
000038  53697a65          DCB      0x53,0x69,0x7a,0x65
00003c  28547970          DCB      0x28,0x54,0x79,0x70
000040  652c2054          DCB      0x65,0x2c,0x20,0x54
000044  7970652c          DCB      0x79,0x70,0x65,0x2c
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  6529205b          DCB      0x65,0x29,0x20,0x5b
000050  77697468          DCB      0x77,0x69,0x74,0x68
000054  20547970          DCB      0x20,0x54,0x79,0x70
000058  65203d20          DCB      0x65,0x20,0x3d,0x20
00005c  7369676e          DCB      0x73,0x69,0x67,0x6e
000060  65642069          DCB      0x65,0x64,0x20,0x69
000064  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  436f6d70          DCB      0x43,0x6f,0x6d,0x70
00002c  75746552          DCB      0x75,0x74,0x65,0x52
000030  65717569          DCB      0x65,0x71,0x75,0x69
000034  72656453          DCB      0x72,0x65,0x64,0x53
000038  74726964          DCB      0x74,0x72,0x69,0x64
00003c  65287369          DCB      0x65,0x28,0x73,0x69
000040  676e6564          DCB      0x67,0x6e,0x65,0x64
000044  20696e74          DCB      0x20,0x69,0x6e,0x74
000048  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00004c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000050  456d6265          DCB      0x45,0x6d,0x62,0x65
000054  64646564          DCB      0x64,0x64,0x65,0x64
000058  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00005c  6167733a          DCB      0x61,0x67,0x73,0x3a
000060  3a427566          DCB      0x3a,0x42,0x75,0x66
000064  66657229          DCB      0x66,0x65,0x72,0x29
000068  205b7769          DCB      0x20,0x5b,0x77,0x69
00006c  74682054          DCB      0x74,0x68,0x20,0x54
000070  79706520          DCB      0x79,0x70,0x65,0x20
000074  3d207369          DCB      0x3d,0x20,0x73,0x69
000078  676e6564          DCB      0x67,0x6e,0x65,0x64
00007c  20696e74          DCB      0x20,0x69,0x6e,0x74
000080  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2076          DCB      0x74,0x2c,0x20,0x76
00003c  6f696420          DCB      0x6f,0x69,0x64,0x20
000040  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
000044  69676e65          DCB      0x69,0x67,0x6e,0x65
000048  6420696e          DCB      0x64,0x20,0x69,0x6e
00004c  742c2041          DCB      0x74,0x2c,0x20,0x41
000050  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000054  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000058  65646465          DCB      0x65,0x64,0x64,0x65
00005c  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000060  6c616773          DCB      0x6c,0x61,0x67,0x73
000064  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000068  66666572          DCB      0x66,0x66,0x65,0x72
00006c  29205b77          DCB      0x29,0x20,0x5b,0x77
000070  69746820          DCB      0x69,0x74,0x68,0x20
000074  54797065          DCB      0x54,0x79,0x70,0x65
000078  203d2073          DCB      0x20,0x3d,0x20,0x73
00007c  69676e65          DCB      0x69,0x67,0x6e,0x65
000080  6420696e          DCB      0x64,0x20,0x69,0x6e
000084  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  7369676e          DCB      0x73,0x69,0x67,0x6e
0000bc  65642069          DCB      0x65,0x64,0x20,0x69
0000c0  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIiE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<int>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2073          DCB      0x20,0x3d,0x20,0x73
000094  69676e65          DCB      0x69,0x67,0x6e,0x65
000098  6420696e          DCB      0x64,0x20,0x69,0x6e
00009c  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  436f6d70          DCB      0x43,0x6f,0x6d,0x70
00002c  75746552          DCB      0x75,0x74,0x65,0x52
000030  65717569          DCB      0x65,0x71,0x75,0x69
000034  72656453          DCB      0x72,0x65,0x64,0x53
000038  74726964          DCB      0x74,0x72,0x69,0x64
00003c  65287369          DCB      0x65,0x28,0x73,0x69
000040  676e6564          DCB      0x67,0x6e,0x65,0x64
000044  20696e74          DCB      0x20,0x69,0x6e,0x74
000048  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00004c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000050  456d6265          DCB      0x45,0x6d,0x62,0x65
000054  64646564          DCB      0x64,0x64,0x65,0x64
000058  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00005c  6167733a          DCB      0x61,0x67,0x73,0x3a
000060  3a427566          DCB      0x3a,0x42,0x75,0x66
000064  66657229          DCB      0x66,0x65,0x72,0x29
000068  205b7769          DCB      0x20,0x5b,0x77,0x69
00006c  74682054          DCB      0x74,0x68,0x20,0x54
000070  79706520          DCB      0x79,0x70,0x65,0x20
000074  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000078  6f61745d          DCB      0x6f,0x61,0x74,0x5d
00007c  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20666c          DCB      0x3d,0x20,0x66,0x6c
000088  6f61745d          DCB      0x6f,0x61,0x74,0x5d
00008c  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2076          DCB      0x74,0x2c,0x20,0x76
00003c  6f696420          DCB      0x6f,0x69,0x64,0x20
000040  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
000044  69676e65          DCB      0x69,0x67,0x6e,0x65
000048  6420696e          DCB      0x64,0x20,0x69,0x6e
00004c  742c2041          DCB      0x74,0x2c,0x20,0x41
000050  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000054  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000058  65646465          DCB      0x65,0x64,0x64,0x65
00005c  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000060  6c616773          DCB      0x6c,0x61,0x67,0x73
000064  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000068  66666572          DCB      0x66,0x66,0x65,0x72
00006c  29205b77          DCB      0x29,0x20,0x5b,0x77
000070  69746820          DCB      0x69,0x74,0x68,0x20
000074  54797065          DCB      0x54,0x79,0x70,0x65
000078  203d2066          DCB      0x20,0x3d,0x20,0x66
00007c  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000080  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIfE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  666c6f61          DCB      0x66,0x6c,0x6f,0x61
000054  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000bc  745d00            DCB      0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIfE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<float>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2066          DCB      0x20,0x3d,0x20,0x66
000094  6c6f6174          DCB      0x6c,0x6f,0x61,0x74
000098  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20756e          DCB      0x3d,0x20,0x75,0x6e
000088  7369676e          DCB      0x73,0x69,0x67,0x6e
00008c  65642063          DCB      0x65,0x64,0x20,0x63
000090  6861725d          DCB      0x68,0x61,0x72,0x5d
000094  00                DCB      0x00

                          AREA ||.constdata__ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZNK4Anki8Embedded5ArrayIhE8get_sizeEiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::get_size(int) const::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  6765745f          DCB      0x67,0x65,0x74,0x5f
00002c  73697a65          DCB      0x73,0x69,0x7a,0x65
000030  28736967          DCB      0x28,0x73,0x69,0x67
000034  6e656420          DCB      0x6e,0x65,0x64,0x20
000038  696e7429          DCB      0x69,0x6e,0x74,0x29
00003c  20636f6e          DCB      0x20,0x63,0x6f,0x6e
000040  7374205b          DCB      0x73,0x74,0x20,0x5b
000044  77697468          DCB      0x77,0x69,0x74,0x68
000048  20547970          DCB      0x20,0x54,0x79,0x70
00004c  65203d20          DCB      0x65,0x20,0x3d,0x20
000050  756e7369          DCB      0x75,0x6e,0x73,0x69
000054  676e6564          DCB      0x67,0x6e,0x65,0x64
000058  20636861          DCB      0x20,0x63,0x68,0x61
00005c  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  756e7369          DCB      0x75,0x6e,0x73,0x69
0000bc  676e6564          DCB      0x67,0x6e,0x65,0x64
0000c0  20636861          DCB      0x20,0x63,0x68,0x61
0000c4  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2075          DCB      0x20,0x3d,0x20,0x75
000094  6e736967          DCB      0x6e,0x73,0x69,0x67
000098  6e656420          DCB      0x6e,0x65,0x64,0x20
00009c  63686172          DCB      0x63,0x68,0x61,0x72
0000a0  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIhE7SetCastIhEEiRKNS1_IT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned char>::SetCast<unsigned char>(const Anki::Embedded::Array<T1>&)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  53657443          DCB      0x53,0x65,0x74,0x43
00002c  61737428          DCB      0x61,0x73,0x74,0x28
000030  636f6e73          DCB      0x63,0x6f,0x6e,0x73
000034  7420416e          DCB      0x74,0x20,0x41,0x6e
000038  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00003c  456d6265          DCB      0x45,0x6d,0x62,0x65
000040  64646564          DCB      0x64,0x64,0x65,0x64
000044  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000048  7261793c          DCB      0x72,0x61,0x79,0x3c
00004c  496e5479          DCB      0x49,0x6e,0x54,0x79
000050  70653e20          DCB      0x70,0x65,0x3e,0x20
000054  2629205b          DCB      0x26,0x29,0x20,0x5b
000058  77697468          DCB      0x77,0x69,0x74,0x68
00005c  20496e54          DCB      0x20,0x49,0x6e,0x54
000060  79706520          DCB      0x79,0x70,0x65,0x20
000064  3d20756e          DCB      0x3d,0x20,0x75,0x6e
000068  7369676e          DCB      0x73,0x69,0x67,0x6e
00006c  65642063          DCB      0x65,0x64,0x20,0x63
000070  6861722c          DCB      0x68,0x61,0x72,0x2c
000074  20547970          DCB      0x20,0x54,0x79,0x70
000078  65203d20          DCB      0x65,0x20,0x3d,0x20
00007c  756e7369          DCB      0x75,0x6e,0x73,0x69
000080  676e6564          DCB      0x67,0x6e,0x65,0x64
000084  20636861          DCB      0x20,0x63,0x68,0x61
000088  725d00            DCB      0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20756e          DCB      0x3d,0x20,0x75,0x6e
000088  7369676e          DCB      0x73,0x69,0x67,0x6e
00008c  65642069          DCB      0x65,0x64,0x20,0x69
000090  6e745d00          DCB      0x6e,0x74,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIjE7SetZeroEvE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE7SetZeroEvE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE7SetZeroEvE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::SetZero()::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  5365745a          DCB      0x53,0x65,0x74,0x5a
00002c  65726f28          DCB      0x65,0x72,0x6f,0x28
000030  29205b77          DCB      0x29,0x20,0x5b,0x77
000034  69746820          DCB      0x69,0x74,0x68,0x20
000038  54797065          DCB      0x54,0x79,0x70,0x65
00003c  203d2075          DCB      0x20,0x3d,0x20,0x75
000040  6e736967          DCB      0x6e,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e745d          DCB      0x69,0x6e,0x74,0x5d
00004c  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  756e7369          DCB      0x75,0x6e,0x73,0x69
0000bc  676e6564          DCB      0x67,0x6e,0x65,0x64
0000c0  20696e74          DCB      0x20,0x69,0x6e,0x74
0000c4  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIjE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<unsigned>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2075          DCB      0x20,0x3d,0x20,0x75
000094  6e736967          DCB      0x6e,0x73,0x69,0x67
000098  6e656420          DCB      0x6e,0x65,0x64,0x20
00009c  696e745d          DCB      0x69,0x6e,0x74,0x5d
0000a0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a5669          DCB      0x3a,0x3a,0x56,0x69
000098  73696f6e          DCB      0x73,0x69,0x6f,0x6e
00009c  4d61726b          DCB      0x4d,0x61,0x72,0x6b
0000a0  65725d00          DCB      0x65,0x72,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  56697369          DCB      0x56,0x69,0x73,0x69
0000cc  6f6e4d61          DCB      0x6f,0x6e,0x4d,0x61
0000d0  726b6572          DCB      0x72,0x6b,0x65,0x72
0000d4  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a56          DCB      0x64,0x3a,0x3a,0x56
0000a4  6973696f          DCB      0x69,0x73,0x69,0x6f
0000a8  6e4d6172          DCB      0x6e,0x4d,0x61,0x72
0000ac  6b65725d          DCB      0x6b,0x65,0x72,0x5d
0000b0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a5669          DCB      0x3a,0x3a,0x56,0x69
000098  73696f6e          DCB      0x73,0x69,0x6f,0x6e
00009c  4d61726b          DCB      0x4d,0x61,0x72,0x6b
0000a0  6572202a          DCB      0x65,0x72,0x20,0x2a
0000a4  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  56697369          DCB      0x56,0x69,0x73,0x69
0000cc  6f6e4d61          DCB      0x6f,0x6e,0x4d,0x61
0000d0  726b6572          DCB      0x72,0x6b,0x65,0x72
0000d4  202a5d00          DCB      0x20,0x2a,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayIPNS0_12VisionMarkerEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::VisionMarker*>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a56          DCB      0x64,0x3a,0x3a,0x56
0000a4  6973696f          DCB      0x69,0x73,0x69,0x6f
0000a8  6e4d6172          DCB      0x6e,0x4d,0x61,0x72
0000ac  6b657220          DCB      0x6b,0x65,0x72,0x20
0000b0  2a5d00            DCB      0x2a,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  436f6d70          DCB      0x43,0x6f,0x6d,0x70
00002c  75746552          DCB      0x75,0x74,0x65,0x52
000030  65717569          DCB      0x65,0x71,0x75,0x69
000034  72656453          DCB      0x72,0x65,0x64,0x53
000038  74726964          DCB      0x74,0x72,0x69,0x64
00003c  65287369          DCB      0x65,0x28,0x73,0x69
000040  676e6564          DCB      0x67,0x6e,0x65,0x64
000044  20696e74          DCB      0x20,0x69,0x6e,0x74
000048  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00004c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000050  456d6265          DCB      0x45,0x6d,0x62,0x65
000054  64646564          DCB      0x64,0x64,0x65,0x64
000058  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00005c  6167733a          DCB      0x61,0x67,0x73,0x3a
000060  3a427566          DCB      0x3a,0x42,0x75,0x66
000064  66657229          DCB      0x66,0x65,0x72,0x29
000068  205b7769          DCB      0x20,0x5b,0x77,0x69
00006c  74682054          DCB      0x74,0x68,0x20,0x54
000070  79706520          DCB      0x79,0x70,0x65,0x20
000074  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000078  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00007c  456d6265          DCB      0x45,0x6d,0x62,0x65
000080  64646564          DCB      0x64,0x64,0x65,0x64
000084  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000088  6374616e          DCB      0x63,0x74,0x61,0x6e
00008c  676c653c          DCB      0x67,0x6c,0x65,0x3c
000090  7369676e          DCB      0x73,0x69,0x67,0x6e
000094  65642069          DCB      0x65,0x64,0x20,0x69
000098  6e743e5d          DCB      0x6e,0x74,0x3e,0x5d
00009c  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000098  6374616e          DCB      0x63,0x74,0x61,0x6e
00009c  676c653c          DCB      0x67,0x6c,0x65,0x3c
0000a0  7369676e          DCB      0x73,0x69,0x67,0x6e
0000a4  65642069          DCB      0x65,0x64,0x20,0x69
0000a8  6e743e5d          DCB      0x6e,0x74,0x3e,0x5d
0000ac  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2076          DCB      0x74,0x2c,0x20,0x76
00003c  6f696420          DCB      0x6f,0x69,0x64,0x20
000040  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
000044  69676e65          DCB      0x69,0x67,0x6e,0x65
000048  6420696e          DCB      0x64,0x20,0x69,0x6e
00004c  742c2041          DCB      0x74,0x2c,0x20,0x41
000050  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000054  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000058  65646465          DCB      0x65,0x64,0x64,0x65
00005c  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000060  6c616773          DCB      0x6c,0x61,0x67,0x73
000064  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000068  66666572          DCB      0x66,0x66,0x65,0x72
00006c  29205b77          DCB      0x29,0x20,0x5b,0x77
000070  69746820          DCB      0x69,0x74,0x68,0x20
000074  54797065          DCB      0x54,0x79,0x70,0x65
000078  203d2041          DCB      0x20,0x3d,0x20,0x41
00007c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000080  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000084  65646465          DCB      0x65,0x64,0x64,0x65
000088  643a3a52          DCB      0x64,0x3a,0x3a,0x52
00008c  65637461          DCB      0x65,0x63,0x74,0x61
000090  6e676c65          DCB      0x6e,0x67,0x6c,0x65
000094  3c736967          DCB      0x3c,0x73,0x69,0x67
000098  6e656420          DCB      0x6e,0x65,0x64,0x20
00009c  696e743e          DCB      0x69,0x6e,0x74,0x3e
0000a0  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  52656374          DCB      0x52,0x65,0x63,0x74
0000cc  616e676c          DCB      0x61,0x6e,0x67,0x6c
0000d0  653c7369          DCB      0x65,0x3c,0x73,0x69
0000d4  676e6564          DCB      0x67,0x6e,0x65,0x64
0000d8  20696e74          DCB      0x20,0x69,0x6e,0x74
0000dc  3e5d00            DCB      0x3e,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_9RectangleIiEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Rectangle<int>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a52          DCB      0x64,0x3a,0x3a,0x52
0000a4  65637461          DCB      0x65,0x63,0x74,0x61
0000a8  6e676c65          DCB      0x6e,0x67,0x6c,0x65
0000ac  3c736967          DCB      0x3c,0x73,0x69,0x67
0000b0  6e656420          DCB      0x6e,0x65,0x64,0x20
0000b4  696e743e          DCB      0x69,0x6e,0x74,0x3e
0000b8  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::Stage>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  436f6d70          DCB      0x43,0x6f,0x6d,0x70
00002c  75746552          DCB      0x75,0x74,0x65,0x52
000030  65717569          DCB      0x65,0x71,0x75,0x69
000034  72656453          DCB      0x72,0x65,0x64,0x53
000038  74726964          DCB      0x74,0x72,0x69,0x64
00003c  65287369          DCB      0x65,0x28,0x73,0x69
000040  676e6564          DCB      0x67,0x6e,0x65,0x64
000044  20696e74          DCB      0x20,0x69,0x6e,0x74
000048  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00004c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000050  456d6265          DCB      0x45,0x6d,0x62,0x65
000054  64646564          DCB      0x64,0x64,0x65,0x64
000058  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00005c  6167733a          DCB      0x61,0x67,0x73,0x3a
000060  3a427566          DCB      0x3a,0x42,0x75,0x66
000064  66657229          DCB      0x66,0x65,0x72,0x29
000068  205b7769          DCB      0x20,0x5b,0x77,0x69
00006c  74682054          DCB      0x74,0x68,0x20,0x54
000070  79706520          DCB      0x79,0x70,0x65,0x20
000074  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000078  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00007c  456d6265          DCB      0x45,0x6d,0x62,0x65
000080  64646564          DCB      0x64,0x64,0x65,0x64
000084  3a3a436c          DCB      0x3a,0x3a,0x43,0x6c
000088  61737369          DCB      0x61,0x73,0x73,0x69
00008c  66696572          DCB      0x66,0x69,0x65,0x72
000090  3a3a4361          DCB      0x3a,0x3a,0x43,0x61
000094  73636164          DCB      0x73,0x63,0x61,0x64
000098  65436c61          DCB      0x65,0x43,0x6c,0x61
00009c  73736966          DCB      0x73,0x73,0x69,0x66
0000a0  6965723a          DCB      0x69,0x65,0x72,0x3a
0000a4  3a537461          DCB      0x3a,0x53,0x74,0x61
0000a8  67655d00          DCB      0x67,0x65,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::Stage>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2076          DCB      0x74,0x2c,0x20,0x76
00003c  6f696420          DCB      0x6f,0x69,0x64,0x20
000040  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
000044  69676e65          DCB      0x69,0x67,0x6e,0x65
000048  6420696e          DCB      0x64,0x20,0x69,0x6e
00004c  742c2041          DCB      0x74,0x2c,0x20,0x41
000050  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000054  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000058  65646465          DCB      0x65,0x64,0x64,0x65
00005c  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000060  6c616773          DCB      0x6c,0x61,0x67,0x73
000064  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000068  66666572          DCB      0x66,0x66,0x65,0x72
00006c  29205b77          DCB      0x29,0x20,0x5b,0x77
000070  69746820          DCB      0x69,0x74,0x68,0x20
000074  54797065          DCB      0x54,0x79,0x70,0x65
000078  203d2041          DCB      0x20,0x3d,0x20,0x41
00007c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000080  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000084  65646465          DCB      0x65,0x64,0x64,0x65
000088  643a3a43          DCB      0x64,0x3a,0x3a,0x43
00008c  6c617373          DCB      0x6c,0x61,0x73,0x73
000090  69666965          DCB      0x69,0x66,0x69,0x65
000094  723a3a43          DCB      0x72,0x3a,0x3a,0x43
000098  61736361          DCB      0x61,0x73,0x63,0x61
00009c  6465436c          DCB      0x64,0x65,0x43,0x6c
0000a0  61737369          DCB      0x61,0x73,0x73,0x69
0000a4  66696572          DCB      0x66,0x69,0x65,0x72
0000a8  3a3a5374          DCB      0x3a,0x3a,0x53,0x74
0000ac  6167655d          DCB      0x61,0x67,0x65,0x5d
0000b0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5StageEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::Stage>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a43          DCB      0x64,0x3a,0x3a,0x43
0000a4  6c617373          DCB      0x6c,0x61,0x73,0x73
0000a8  69666965          DCB      0x69,0x66,0x69,0x65
0000ac  723a3a43          DCB      0x72,0x3a,0x3a,0x43
0000b0  61736361          DCB      0x61,0x73,0x63,0x61
0000b4  6465436c          DCB      0x64,0x65,0x43,0x6c
0000b8  61737369          DCB      0x61,0x73,0x73,0x69
0000bc  66696572          DCB      0x66,0x69,0x65,0x72
0000c0  3a3a5374          DCB      0x3a,0x3a,0x53,0x74
0000c4  6167655d          DCB      0x61,0x67,0x65,0x5d
0000c8  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTree>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  436f6d70          DCB      0x43,0x6f,0x6d,0x70
00002c  75746552          DCB      0x75,0x74,0x65,0x52
000030  65717569          DCB      0x65,0x71,0x75,0x69
000034  72656453          DCB      0x72,0x65,0x64,0x53
000038  74726964          DCB      0x74,0x72,0x69,0x64
00003c  65287369          DCB      0x65,0x28,0x73,0x69
000040  676e6564          DCB      0x67,0x6e,0x65,0x64
000044  20696e74          DCB      0x20,0x69,0x6e,0x74
000048  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00004c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000050  456d6265          DCB      0x45,0x6d,0x62,0x65
000054  64646564          DCB      0x64,0x64,0x65,0x64
000058  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00005c  6167733a          DCB      0x61,0x67,0x73,0x3a
000060  3a427566          DCB      0x3a,0x42,0x75,0x66
000064  66657229          DCB      0x66,0x65,0x72,0x29
000068  205b7769          DCB      0x20,0x5b,0x77,0x69
00006c  74682054          DCB      0x74,0x68,0x20,0x54
000070  79706520          DCB      0x79,0x70,0x65,0x20
000074  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000078  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00007c  456d6265          DCB      0x45,0x6d,0x62,0x65
000080  64646564          DCB      0x64,0x64,0x65,0x64
000084  3a3a436c          DCB      0x3a,0x3a,0x43,0x6c
000088  61737369          DCB      0x61,0x73,0x73,0x69
00008c  66696572          DCB      0x66,0x69,0x65,0x72
000090  3a3a4361          DCB      0x3a,0x3a,0x43,0x61
000094  73636164          DCB      0x73,0x63,0x61,0x64
000098  65436c61          DCB      0x65,0x43,0x6c,0x61
00009c  73736966          DCB      0x73,0x73,0x69,0x66
0000a0  6965723a          DCB      0x69,0x65,0x72,0x3a
0000a4  3a445472          DCB      0x3a,0x44,0x54,0x72
0000a8  65655d00          DCB      0x65,0x65,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTree>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2076          DCB      0x74,0x2c,0x20,0x76
00003c  6f696420          DCB      0x6f,0x69,0x64,0x20
000040  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
000044  69676e65          DCB      0x69,0x67,0x6e,0x65
000048  6420696e          DCB      0x64,0x20,0x69,0x6e
00004c  742c2041          DCB      0x74,0x2c,0x20,0x41
000050  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000054  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000058  65646465          DCB      0x65,0x64,0x64,0x65
00005c  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000060  6c616773          DCB      0x6c,0x61,0x67,0x73
000064  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000068  66666572          DCB      0x66,0x66,0x65,0x72
00006c  29205b77          DCB      0x29,0x20,0x5b,0x77
000070  69746820          DCB      0x69,0x74,0x68,0x20
000074  54797065          DCB      0x54,0x79,0x70,0x65
000078  203d2041          DCB      0x20,0x3d,0x20,0x41
00007c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000080  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000084  65646465          DCB      0x65,0x64,0x64,0x65
000088  643a3a43          DCB      0x64,0x3a,0x3a,0x43
00008c  6c617373          DCB      0x6c,0x61,0x73,0x73
000090  69666965          DCB      0x69,0x66,0x69,0x65
000094  723a3a43          DCB      0x72,0x3a,0x3a,0x43
000098  61736361          DCB      0x61,0x73,0x63,0x61
00009c  6465436c          DCB      0x64,0x65,0x43,0x6c
0000a0  61737369          DCB      0x61,0x73,0x73,0x69
0000a4  66696572          DCB      0x66,0x69,0x65,0x72
0000a8  3a3a4454          DCB      0x3a,0x3a,0x44,0x54
0000ac  7265655d          DCB      0x72,0x65,0x65,0x5d
0000b0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier5DTreeEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTree>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a43          DCB      0x64,0x3a,0x3a,0x43
0000a4  6c617373          DCB      0x6c,0x61,0x73,0x73
0000a8  69666965          DCB      0x69,0x66,0x69,0x65
0000ac  723a3a43          DCB      0x72,0x3a,0x3a,0x43
0000b0  61736361          DCB      0x61,0x73,0x63,0x61
0000b4  6465436c          DCB      0x64,0x65,0x43,0x6c
0000b8  61737369          DCB      0x61,0x73,0x73,0x69
0000bc  66696572          DCB      0x66,0x69,0x65,0x72
0000c0  3a3a4454          DCB      0x3a,0x3a,0x44,0x54
0000c4  7265655d          DCB      0x72,0x65,0x65,0x5d
0000c8  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEE21ComputeRequiredStrideEiNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>::ComputeRequiredStride(int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  7369676e          DCB      0x73,0x69,0x67,0x6e
000004  65642069          DCB      0x65,0x64,0x20,0x69
000008  6e742041          DCB      0x6e,0x74,0x20,0x41
00000c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000010  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000014  65646465          DCB      0x65,0x64,0x64,0x65
000018  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00001c  72726179          DCB      0x72,0x72,0x61,0x79
000020  3c547970          DCB      0x3c,0x54,0x79,0x70
000024  653e3a3a          DCB      0x65,0x3e,0x3a,0x3a
000028  436f6d70          DCB      0x43,0x6f,0x6d,0x70
00002c  75746552          DCB      0x75,0x74,0x65,0x52
000030  65717569          DCB      0x65,0x71,0x75,0x69
000034  72656453          DCB      0x72,0x65,0x64,0x53
000038  74726964          DCB      0x74,0x72,0x69,0x64
00003c  65287369          DCB      0x65,0x28,0x73,0x69
000040  676e6564          DCB      0x67,0x6e,0x65,0x64
000044  20696e74          DCB      0x20,0x69,0x6e,0x74
000048  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00004c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000050  456d6265          DCB      0x45,0x6d,0x62,0x65
000054  64646564          DCB      0x64,0x64,0x65,0x64
000058  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00005c  6167733a          DCB      0x61,0x67,0x73,0x3a
000060  3a427566          DCB      0x3a,0x42,0x75,0x66
000064  66657229          DCB      0x66,0x65,0x72,0x29
000068  205b7769          DCB      0x20,0x5b,0x77,0x69
00006c  74682054          DCB      0x74,0x68,0x20,0x54
000070  79706520          DCB      0x79,0x70,0x65,0x20
000074  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000078  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00007c  456d6265          DCB      0x45,0x6d,0x62,0x65
000080  64646564          DCB      0x64,0x64,0x65,0x64
000084  3a3a436c          DCB      0x3a,0x3a,0x43,0x6c
000088  61737369          DCB      0x61,0x73,0x73,0x69
00008c  66696572          DCB      0x66,0x69,0x65,0x72
000090  3a3a4361          DCB      0x3a,0x3a,0x43,0x61
000094  73636164          DCB      0x73,0x63,0x61,0x64
000098  65436c61          DCB      0x65,0x43,0x6c,0x61
00009c  73736966          DCB      0x73,0x73,0x69,0x66
0000a0  6965723a          DCB      0x69,0x65,0x72,0x3a
0000a4  3a445472          DCB      0x3a,0x44,0x54,0x72
0000a8  65654e6f          DCB      0x65,0x65,0x4e,0x6f
0000ac  64655d00          DCB      0x64,0x65,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEEC1EiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>::Array(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2076          DCB      0x74,0x2c,0x20,0x76
00003c  6f696420          DCB      0x6f,0x69,0x64,0x20
000040  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
000044  69676e65          DCB      0x69,0x67,0x6e,0x65
000048  6420696e          DCB      0x64,0x20,0x69,0x6e
00004c  742c2041          DCB      0x74,0x2c,0x20,0x41
000050  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000054  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000058  65646465          DCB      0x65,0x64,0x64,0x65
00005c  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000060  6c616773          DCB      0x6c,0x61,0x67,0x73
000064  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000068  66666572          DCB      0x66,0x66,0x65,0x72
00006c  29205b77          DCB      0x29,0x20,0x5b,0x77
000070  69746820          DCB      0x69,0x74,0x68,0x20
000074  54797065          DCB      0x54,0x79,0x70,0x65
000078  203d2041          DCB      0x20,0x3d,0x20,0x41
00007c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000080  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000084  65646465          DCB      0x65,0x64,0x64,0x65
000088  643a3a43          DCB      0x64,0x3a,0x3a,0x43
00008c  6c617373          DCB      0x6c,0x61,0x73,0x73
000090  69666965          DCB      0x69,0x66,0x69,0x65
000094  723a3a43          DCB      0x72,0x3a,0x3a,0x43
000098  61736361          DCB      0x61,0x73,0x63,0x61
00009c  6465436c          DCB      0x64,0x65,0x43,0x6c
0000a0  61737369          DCB      0x61,0x73,0x73,0x69
0000a4  66696572          DCB      0x66,0x69,0x65,0x72
0000a8  3a3a4454          DCB      0x3a,0x3a,0x44,0x54
0000ac  7265654e          DCB      0x72,0x65,0x65,0x4e
0000b0  6f64655d          DCB      0x6f,0x64,0x65,0x5d
0000b4  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS0_10Classifier17CascadeClassifier9DTreeNodeEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Classifier::CascadeClassifier::DTreeNode>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a43          DCB      0x64,0x3a,0x3a,0x43
0000a4  6c617373          DCB      0x6c,0x61,0x73,0x73
0000a8  69666965          DCB      0x69,0x66,0x69,0x65
0000ac  723a3a43          DCB      0x72,0x3a,0x3a,0x43
0000b0  61736361          DCB      0x61,0x73,0x63,0x61
0000b4  6465436c          DCB      0x64,0x65,0x43,0x6c
0000b8  61737369          DCB      0x61,0x73,0x73,0x69
0000bc  66696572          DCB      0x66,0x69,0x65,0x72
0000c0  3a3a4454          DCB      0x3a,0x3a,0x44,0x54
0000c4  7265654e          DCB      0x72,0x65,0x65,0x4e
0000c8  6f64655d          DCB      0x6f,0x64,0x65,0x5d
0000cc  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS1_IfEEEC1EiiRNS0_11MemoryStackENS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::Array(int, int, Anki::Embedded::MemoryStack&, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000008  62656464          DCB      0x62,0x65,0x64,0x64
00000c  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000010  41727261          DCB      0x41,0x72,0x72,0x61
000014  793c5479          DCB      0x79,0x3c,0x54,0x79
000018  70653e3a          DCB      0x70,0x65,0x3e,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61792873          DCB      0x61,0x79,0x28,0x73
000024  69676e65          DCB      0x69,0x67,0x6e,0x65
000028  6420696e          DCB      0x64,0x20,0x69,0x6e
00002c  742c2073          DCB      0x74,0x2c,0x20,0x73
000030  69676e65          DCB      0x69,0x67,0x6e,0x65
000034  6420696e          DCB      0x64,0x20,0x69,0x6e
000038  742c2041          DCB      0x74,0x2c,0x20,0x41
00003c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000040  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000044  65646465          DCB      0x65,0x64,0x64,0x65
000048  643a3a4d          DCB      0x64,0x3a,0x3a,0x4d
00004c  656d6f72          DCB      0x65,0x6d,0x6f,0x72
000050  79537461          DCB      0x79,0x53,0x74,0x61
000054  636b2026          DCB      0x63,0x6b,0x20,0x26
000058  2c20416e          DCB      0x2c,0x20,0x41,0x6e
00005c  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000060  456d6265          DCB      0x45,0x6d,0x62,0x65
000064  64646564          DCB      0x64,0x64,0x65,0x64
000068  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
00006c  6167733a          DCB      0x61,0x67,0x73,0x3a
000070  3a427566          DCB      0x3a,0x42,0x75,0x66
000074  66657229          DCB      0x66,0x65,0x72,0x29
000078  205b7769          DCB      0x20,0x5b,0x77,0x69
00007c  74682054          DCB      0x74,0x68,0x20,0x54
000080  79706520          DCB      0x79,0x70,0x65,0x20
000084  3d20416e          DCB      0x3d,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000098  7261793c          DCB      0x72,0x61,0x79,0x3c
00009c  666c6f61          DCB      0x66,0x6c,0x6f,0x61
0000a0  743e5d00          DCB      0x74,0x3e,0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS1_IfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS1_IfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS1_IfEEE29AllocateBufferFromMemoryStackEiiRNS0_11MemoryStackERiNS0_5Flags6BufferEbE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::AllocateBufferFromMemoryStack(int, int, Anki::Embedded::MemoryStack&, int&, Anki::Embedded::Flags::Buffer, bool)::__PRETTY_FUNCTION__
000000  766f6964          DCB      0x76,0x6f,0x69,0x64
000004  202a416e          DCB      0x20,0x2a,0x41,0x6e
000008  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00000c  456d6265          DCB      0x45,0x6d,0x62,0x65
000010  64646564          DCB      0x64,0x64,0x65,0x64
000014  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000018  7261793c          DCB      0x72,0x61,0x79,0x3c
00001c  54797065          DCB      0x54,0x79,0x70,0x65
000020  3e3a3a41          DCB      0x3e,0x3a,0x3a,0x41
000024  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000028  61746542          DCB      0x61,0x74,0x65,0x42
00002c  75666665          DCB      0x75,0x66,0x66,0x65
000030  7246726f          DCB      0x72,0x46,0x72,0x6f
000034  6d4d656d          DCB      0x6d,0x4d,0x65,0x6d
000038  6f727953          DCB      0x6f,0x72,0x79,0x53
00003c  7461636b          DCB      0x74,0x61,0x63,0x6b
000040  28736967          DCB      0x28,0x73,0x69,0x67
000044  6e656420          DCB      0x6e,0x65,0x64,0x20
000048  696e742c          DCB      0x69,0x6e,0x74,0x2c
00004c  20736967          DCB      0x20,0x73,0x69,0x67
000050  6e656420          DCB      0x6e,0x65,0x64,0x20
000054  696e742c          DCB      0x69,0x6e,0x74,0x2c
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a4d656d          DCB      0x3a,0x4d,0x65,0x6d
00006c  6f727953          DCB      0x6f,0x72,0x79,0x53
000070  7461636b          DCB      0x74,0x61,0x63,0x6b
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  7369676e          DCB      0x73,0x69,0x67,0x6e
00007c  65642069          DCB      0x65,0x64,0x20,0x69
000080  6e742026          DCB      0x6e,0x74,0x20,0x26
000084  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000088  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00008c  456d6265          DCB      0x45,0x6d,0x62,0x65
000090  64646564          DCB      0x64,0x64,0x65,0x64
000094  3a3a466c          DCB      0x3a,0x3a,0x46,0x6c
000098  6167733a          DCB      0x61,0x67,0x73,0x3a
00009c  3a427566          DCB      0x3a,0x42,0x75,0x66
0000a0  6665722c          DCB      0x66,0x65,0x72,0x2c
0000a4  20626f6f          DCB      0x20,0x62,0x6f,0x6f
0000a8  6c29205b          DCB      0x6c,0x29,0x20,0x5b
0000ac  77697468          DCB      0x77,0x69,0x74,0x68
0000b0  20547970          DCB      0x20,0x54,0x79,0x70
0000b4  65203d20          DCB      0x65,0x20,0x3d,0x20
0000b8  416e6b69          DCB      0x41,0x6e,0x6b,0x69
0000bc  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000c0  62656464          DCB      0x62,0x65,0x64,0x64
0000c4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000c8  41727261          DCB      0x41,0x72,0x72,0x61
0000cc  793c666c          DCB      0x79,0x3c,0x66,0x6c
0000d0  6f61743e          DCB      0x6f,0x61,0x74,0x3e
0000d4  5d00              DCB      0x5d,0x00

                          AREA ||.constdata__ZZN4Anki8Embedded5ArrayINS1_IfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded5ArrayINS1_IfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded5ArrayINS1_IfEEE16InitializeBufferEiiPviNS0_5Flags6BufferEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Array<Anki::Embedded::Array<float>>::InitializeBuffer(int, int, void*, int, Anki::Embedded::Flags::Buffer)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a417272          DCB      0x3a,0x41,0x72,0x72
000020  61793c54          DCB      0x61,0x79,0x3c,0x54
000024  7970653e          DCB      0x79,0x70,0x65,0x3e
000028  3a3a496e          DCB      0x3a,0x3a,0x49,0x6e
00002c  69746961          DCB      0x69,0x74,0x69,0x61
000030  6c697a65          DCB      0x6c,0x69,0x7a,0x65
000034  42756666          DCB      0x42,0x75,0x66,0x66
000038  65722873          DCB      0x65,0x72,0x28,0x73
00003c  69676e65          DCB      0x69,0x67,0x6e,0x65
000040  6420696e          DCB      0x64,0x20,0x69,0x6e
000044  742c2073          DCB      0x74,0x2c,0x20,0x73
000048  69676e65          DCB      0x69,0x67,0x6e,0x65
00004c  6420696e          DCB      0x64,0x20,0x69,0x6e
000050  742c2076          DCB      0x74,0x2c,0x20,0x76
000054  6f696420          DCB      0x6f,0x69,0x64,0x20
000058  2a2c2073          DCB      0x2a,0x2c,0x20,0x73
00005c  69676e65          DCB      0x69,0x67,0x6e,0x65
000060  6420696e          DCB      0x64,0x20,0x69,0x6e
000064  742c2041          DCB      0x74,0x2c,0x20,0x41
000068  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
00006c  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000070  65646465          DCB      0x65,0x64,0x64,0x65
000074  643a3a46          DCB      0x64,0x3a,0x3a,0x46
000078  6c616773          DCB      0x6c,0x61,0x67,0x73
00007c  3a3a4275          DCB      0x3a,0x3a,0x42,0x75
000080  66666572          DCB      0x66,0x66,0x65,0x72
000084  29205b77          DCB      0x29,0x20,0x5b,0x77
000088  69746820          DCB      0x69,0x74,0x68,0x20
00008c  54797065          DCB      0x54,0x79,0x70,0x65
000090  203d2041          DCB      0x20,0x3d,0x20,0x41
000094  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000098  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00009c  65646465          DCB      0x65,0x64,0x64,0x65
0000a0  643a3a41          DCB      0x64,0x3a,0x3a,0x41
0000a4  72726179          DCB      0x72,0x72,0x61,0x79
0000a8  3c666c6f          DCB      0x3c,0x66,0x6c,0x6f
0000ac  61743e5d          DCB      0x61,0x74,0x3e,0x5d
0000b0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix13InsertionSortIfEENS_6ResultERNS0_5ArrayIT_EERNS4_IiEEibiiE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::InsertionSort<float>(Anki::Embedded::Array<T1>&, Anki::Embedded::Array<int>&, int, bool, int, int)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a496e73          DCB      0x3a,0x49,0x6e,0x73
000028  65727469          DCB      0x65,0x72,0x74,0x69
00002c  6f6e536f          DCB      0x6f,0x6e,0x53,0x6f
000030  72742841          DCB      0x72,0x74,0x28,0x41
000034  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000038  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00003c  65646465          DCB      0x65,0x64,0x64,0x65
000040  643a3a41          DCB      0x64,0x3a,0x3a,0x41
000044  72726179          DCB      0x72,0x72,0x61,0x79
000048  3c547970          DCB      0x3c,0x54,0x79,0x70
00004c  653e2026          DCB      0x65,0x3e,0x20,0x26
000050  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000054  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
000058  456d6265          DCB      0x45,0x6d,0x62,0x65
00005c  64646564          DCB      0x64,0x64,0x65,0x64
000060  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000064  7261793c          DCB      0x72,0x61,0x79,0x3c
000068  7369676e          DCB      0x73,0x69,0x67,0x6e
00006c  65642069          DCB      0x65,0x64,0x20,0x69
000070  6e743e20          DCB      0x6e,0x74,0x3e,0x20
000074  262c2073          DCB      0x26,0x2c,0x20,0x73
000078  69676e65          DCB      0x69,0x67,0x6e,0x65
00007c  6420696e          DCB      0x64,0x20,0x69,0x6e
000080  742c2062          DCB      0x74,0x2c,0x20,0x62
000084  6f6f6c2c          DCB      0x6f,0x6f,0x6c,0x2c
000088  20736967          DCB      0x20,0x73,0x69,0x67
00008c  6e656420          DCB      0x6e,0x65,0x64,0x20
000090  696e742c          DCB      0x69,0x6e,0x74,0x2c
000094  20736967          DCB      0x20,0x73,0x69,0x67
000098  6e656420          DCB      0x6e,0x65,0x64,0x20
00009c  696e7429          DCB      0x69,0x6e,0x74,0x29
0000a0  205b7769          DCB      0x20,0x5b,0x77,0x69
0000a4  74682054          DCB      0x74,0x68,0x20,0x54
0000a8  79706520          DCB      0x79,0x70,0x65,0x20
0000ac  3d20666c          DCB      0x3d,0x20,0x66,0x6c
0000b0  6f61745d          DCB      0x6f,0x61,0x74,0x5d
0000b4  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix8MultiplyIffEENS_6ResultERKNS0_5ArrayIT_EES8_RNS4_IT0_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Multiply<float, float>(const Anki::Embedded::Array<T1>&, const Anki::Embedded::Array<T1>&, Anki::Embedded::Array<T2>&)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000020  7269783a          DCB      0x72,0x69,0x78,0x3a
000024  3a4d756c          DCB      0x3a,0x4d,0x75,0x6c
000028  7469706c          DCB      0x74,0x69,0x70,0x6c
00002c  7928636f          DCB      0x79,0x28,0x63,0x6f
000030  6e737420          DCB      0x6e,0x73,0x74,0x20
000034  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000038  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
00003c  62656464          DCB      0x62,0x65,0x64,0x64
000040  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000044  41727261          DCB      0x41,0x72,0x72,0x61
000048  793c5479          DCB      0x79,0x3c,0x54,0x79
00004c  70653e20          DCB      0x70,0x65,0x3e,0x20
000050  262c2063          DCB      0x26,0x2c,0x20,0x63
000054  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000058  20416e6b          DCB      0x20,0x41,0x6e,0x6b
00005c  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000060  6d626564          DCB      0x6d,0x62,0x65,0x64
000064  6465643a          DCB      0x64,0x65,0x64,0x3a
000068  3a417272          DCB      0x3a,0x41,0x72,0x72
00006c  61793c54          DCB      0x61,0x79,0x3c,0x54
000070  7970653e          DCB      0x79,0x70,0x65,0x3e
000074  20262c20          DCB      0x20,0x26,0x2c,0x20
000078  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00007c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
000080  62656464          DCB      0x62,0x65,0x64,0x64
000084  65643a3a          DCB      0x65,0x64,0x3a,0x3a
000088  41727261          DCB      0x41,0x72,0x72,0x61
00008c  793c4f75          DCB      0x79,0x3c,0x4f,0x75
000090  74547970          DCB      0x74,0x54,0x79,0x70
000094  653e2026          DCB      0x65,0x3e,0x20,0x26
000098  29205b77          DCB      0x29,0x20,0x5b,0x77
00009c  69746820          DCB      0x69,0x74,0x68,0x20
0000a0  496e5479          DCB      0x49,0x6e,0x54,0x79
0000a4  7065203d          DCB      0x70,0x65,0x20,0x3d
0000a8  20666c6f          DCB      0x20,0x66,0x6c,0x6f
0000ac  61742c20          DCB      0x61,0x74,0x2c,0x20
0000b0  4f757454          DCB      0x4f,0x75,0x74,0x54
0000b4  79706520          DCB      0x79,0x70,0x65,0x20
0000b8  3d20666c          DCB      0x3d,0x20,0x66,0x6c
0000bc  6f61745d          DCB      0x6f,0x61,0x74,0x5d
0000c0  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded6Matrix3SumIhjEET0_RKNS0_25ConstArraySliceExpressionIT_EEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded6Matrix3SumIhjEET0_RKNS0_25ConstArraySliceExpressionIT_EEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded6Matrix3SumIhjEET0_RKNS0_25ConstArraySliceExpressionIT_EEE19__PRETTY_FUNCTION__ ; Anki::Embedded::Matrix::Sum<unsigned char, unsigned>(const Anki::Embedded::ConstArraySliceExpression<T1>&)::__PRETTY_FUNCTION__
000000  41636375          DCB      0x41,0x63,0x63,0x75
000004  6d756c61          DCB      0x6d,0x75,0x6c,0x61
000008  746f725f          DCB      0x74,0x6f,0x72,0x5f
00000c  54797065          DCB      0x54,0x79,0x70,0x65
000010  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000014  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000018  6d626564          DCB      0x6d,0x62,0x65,0x64
00001c  6465643a          DCB      0x64,0x65,0x64,0x3a
000020  3a4d6174          DCB      0x3a,0x4d,0x61,0x74
000024  7269783a          DCB      0x72,0x69,0x78,0x3a
000028  3a53756d          DCB      0x3a,0x53,0x75,0x6d
00002c  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000030  73742041          DCB      0x73,0x74,0x20,0x41
000034  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000038  3a456d62          DCB      0x3a,0x45,0x6d,0x62
00003c  65646465          DCB      0x65,0x64,0x64,0x65
000040  643a3a43          DCB      0x64,0x3a,0x3a,0x43
000044  6f6e7374          DCB      0x6f,0x6e,0x73,0x74
000048  41727261          DCB      0x41,0x72,0x72,0x61
00004c  79536c69          DCB      0x79,0x53,0x6c,0x69
000050  63654578          DCB      0x63,0x65,0x45,0x78
000054  70726573          DCB      0x70,0x72,0x65,0x73
000058  73696f6e          DCB      0x73,0x69,0x6f,0x6e
00005c  3c547970          DCB      0x3c,0x54,0x79,0x70
000060  653e2026          DCB      0x65,0x3e,0x20,0x26
000064  29205b77          DCB      0x29,0x20,0x5b,0x77
000068  69746820          DCB      0x69,0x74,0x68,0x20
00006c  41727261          DCB      0x41,0x72,0x72,0x61
000070  795f5479          DCB      0x79,0x5f,0x54,0x79
000074  7065203d          DCB      0x70,0x65,0x20,0x3d
000078  20756e73          DCB      0x20,0x75,0x6e,0x73
00007c  69676e65          DCB      0x69,0x67,0x6e,0x65
000080  64206368          DCB      0x64,0x20,0x63,0x68
000084  61722c20          DCB      0x61,0x72,0x2c,0x20
000088  41636375          DCB      0x41,0x63,0x63,0x75
00008c  6d756c61          DCB      0x6d,0x75,0x6c,0x61
000090  746f725f          DCB      0x74,0x6f,0x72,0x5f
000094  54797065          DCB      0x54,0x79,0x70,0x65
000098  203d2075          DCB      0x20,0x3d,0x20,0x75
00009c  6e736967          DCB      0x6e,0x73,0x69,0x67
0000a0  6e656420          DCB      0x6e,0x65,0x64,0x20
0000a4  696e745d          DCB      0x69,0x6e,0x74,0x5d
0000a8  00                DCB      0x00

                          AREA ||.constdata__ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEE19__PRETTY_FUNCTION__||, COMGROUP=_ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEE19__PRETTY_FUNCTION__, DATA, READONLY, ALIGN=0

                  _ZZN4Anki8Embedded15ImageProcessing22DownsampleByPowerOfTwoIhjhEENS_6ResultERKNS0_5ArrayIT_EEiRNS4_IT1_EENS0_11MemoryStackEE19__PRETTY_FUNCTION__ ; Anki::Embedded::ImageProcessing::DownsampleByPowerOfTwo<unsigned char, unsigned, unsigned char>(const Anki::Embedded::Array<T1>&, int, Anki::Embedded::Array<T3>&, Anki::Embedded::MemoryStack)::__PRETTY_FUNCTION__
000000  416e6b69          DCB      0x41,0x6e,0x6b,0x69
000004  3a3a5265          DCB      0x3a,0x3a,0x52,0x65
000008  73756c74          DCB      0x73,0x75,0x6c,0x74
00000c  20416e6b          DCB      0x20,0x41,0x6e,0x6b
000010  693a3a45          DCB      0x69,0x3a,0x3a,0x45
000014  6d626564          DCB      0x6d,0x62,0x65,0x64
000018  6465643a          DCB      0x64,0x65,0x64,0x3a
00001c  3a496d61          DCB      0x3a,0x49,0x6d,0x61
000020  67655072          DCB      0x67,0x65,0x50,0x72
000024  6f636573          DCB      0x6f,0x63,0x65,0x73
000028  73696e67          DCB      0x73,0x69,0x6e,0x67
00002c  3a3a446f          DCB      0x3a,0x3a,0x44,0x6f
000030  776e7361          DCB      0x77,0x6e,0x73,0x61
000034  6d706c65          DCB      0x6d,0x70,0x6c,0x65
000038  4279506f          DCB      0x42,0x79,0x50,0x6f
00003c  7765724f          DCB      0x77,0x65,0x72,0x4f
000040  6654776f          DCB      0x66,0x54,0x77,0x6f
000044  28636f6e          DCB      0x28,0x63,0x6f,0x6e
000048  73742041          DCB      0x73,0x74,0x20,0x41
00004c  6e6b693a          DCB      0x6e,0x6b,0x69,0x3a
000050  3a456d62          DCB      0x3a,0x45,0x6d,0x62
000054  65646465          DCB      0x65,0x64,0x64,0x65
000058  643a3a41          DCB      0x64,0x3a,0x3a,0x41
00005c  72726179          DCB      0x72,0x72,0x61,0x79
000060  3c547970          DCB      0x3c,0x54,0x79,0x70
000064  653e2026          DCB      0x65,0x3e,0x20,0x26
000068  2c207369          DCB      0x2c,0x20,0x73,0x69
00006c  676e6564          DCB      0x67,0x6e,0x65,0x64
000070  20696e74          DCB      0x20,0x69,0x6e,0x74
000074  2c20416e          DCB      0x2c,0x20,0x41,0x6e
000078  6b693a3a          DCB      0x6b,0x69,0x3a,0x3a
00007c  456d6265          DCB      0x45,0x6d,0x62,0x65
000080  64646564          DCB      0x64,0x64,0x65,0x64
000084  3a3a4172          DCB      0x3a,0x3a,0x41,0x72
000088  7261793c          DCB      0x72,0x61,0x79,0x3c
00008c  4f757454          DCB      0x4f,0x75,0x74,0x54
000090  7970653e          DCB      0x79,0x70,0x65,0x3e
000094  20262c20          DCB      0x20,0x26,0x2c,0x20
000098  416e6b69          DCB      0x41,0x6e,0x6b,0x69
00009c  3a3a456d          DCB      0x3a,0x3a,0x45,0x6d
0000a0  62656464          DCB      0x62,0x65,0x64,0x64
0000a4  65643a3a          DCB      0x65,0x64,0x3a,0x3a
0000a8  4d656d6f          DCB      0x4d,0x65,0x6d,0x6f
0000ac  72795374          DCB      0x72,0x79,0x53,0x74
0000b0  61636b29          DCB      0x61,0x63,0x6b,0x29
0000b4  205b7769          DCB      0x20,0x5b,0x77,0x69
0000b8  74682049          DCB      0x74,0x68,0x20,0x49
0000bc  6e547970          DCB      0x6e,0x54,0x79,0x70
0000c0  65203d20          DCB      0x65,0x20,0x3d,0x20
0000c4  756e7369          DCB      0x75,0x6e,0x73,0x69
0000c8  676e6564          DCB      0x67,0x6e,0x65,0x64
0000cc  20636861          DCB      0x20,0x63,0x68,0x61
0000d0  722c2049          DCB      0x72,0x2c,0x20,0x49
0000d4  6e746572          DCB      0x6e,0x74,0x65,0x72
0000d8  6d656469          DCB      0x6d,0x65,0x64,0x69
0000dc  61746554          DCB      0x61,0x74,0x65,0x54
0000e0  79706520          DCB      0x79,0x70,0x65,0x20
0000e4  3d20756e          DCB      0x3d,0x20,0x75,0x6e
0000e8  7369676e          DCB      0x73,0x69,0x67,0x6e
0000ec  65642069          DCB      0x65,0x64,0x20,0x69
0000f0  6e742c20          DCB      0x6e,0x74,0x2c,0x20
0000f4  4f757454          DCB      0x4f,0x75,0x74,0x54
0000f8  79706520          DCB      0x79,0x70,0x65,0x20
0000fc  3d20756e          DCB      0x3d,0x20,0x75,0x6e
000100  7369676e          DCB      0x73,0x69,0x67,0x6e
000104  65642063          DCB      0x65,0x64,0x20,0x63
000108  6861725d          DCB      0x68,0x61,0x72,0x5d
00010c  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "supervisor\\src\\visionSystem.cpp"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_visionSystem_cpp_b6ff7547___Z7__REV16j|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___16_visionSystem_cpp_b6ff7547___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_visionSystem_cpp_b6ff7547___Z7__REVSHi|
#line 144
|__asm___16_visionSystem_cpp_b6ff7547___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
