// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_COZMOANIM_COZMOANIM_H_
#define FLATBUFFERS_GENERATED_COZMOANIM_COZMOANIM_H_

#include "flatbuffers/flatbuffers.h"

namespace CozmoAnim {

struct LiftHeight;

struct ProceduralFace;

struct HeadAngle;

struct RobotAudio;

struct BackpackLights;

struct FaceAnimation;

struct Event;

struct BodyMotion;

struct RecordHeading;

struct TurnToRecordedHeading;

struct Keyframes;

struct AnimClip;

struct AnimClips;

struct LiftHeight FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_DURATIONTIME_MS = 6,
    VT_HEIGHT_MM = 8,
    VT_HEIGHTVARIABILITY_MM = 10
  };
  uint32_t triggerTime_ms() const { return GetField<uint32_t>(VT_TRIGGERTIME_MS, 0); }
  uint32_t durationTime_ms() const { return GetField<uint32_t>(VT_DURATIONTIME_MS, 0); }
  uint8_t height_mm() const { return GetField<uint8_t>(VT_HEIGHT_MM, 0); }
  uint8_t heightVariability_mm() const { return GetField<uint8_t>(VT_HEIGHTVARIABILITY_MM, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<uint32_t>(verifier, VT_DURATIONTIME_MS) &&
           VerifyField<uint8_t>(verifier, VT_HEIGHT_MM) &&
           VerifyField<uint8_t>(verifier, VT_HEIGHTVARIABILITY_MM) &&
           verifier.EndTable();
  }
};

struct LiftHeightBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(uint32_t triggerTime_ms) { fbb_.AddElement<uint32_t>(LiftHeight::VT_TRIGGERTIME_MS, triggerTime_ms, 0); }
  void add_durationTime_ms(uint32_t durationTime_ms) { fbb_.AddElement<uint32_t>(LiftHeight::VT_DURATIONTIME_MS, durationTime_ms, 0); }
  void add_height_mm(uint8_t height_mm) { fbb_.AddElement<uint8_t>(LiftHeight::VT_HEIGHT_MM, height_mm, 0); }
  void add_heightVariability_mm(uint8_t heightVariability_mm) { fbb_.AddElement<uint8_t>(LiftHeight::VT_HEIGHTVARIABILITY_MM, heightVariability_mm, 0); }
  LiftHeightBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LiftHeightBuilder &operator=(const LiftHeightBuilder &);
  flatbuffers::Offset<LiftHeight> Finish() {
    auto o = flatbuffers::Offset<LiftHeight>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<LiftHeight> CreateLiftHeight(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    uint32_t durationTime_ms = 0,
    uint8_t height_mm = 0,
    uint8_t heightVariability_mm = 0) {
  LiftHeightBuilder builder_(_fbb);
  builder_.add_durationTime_ms(durationTime_ms);
  builder_.add_triggerTime_ms(triggerTime_ms);
  builder_.add_heightVariability_mm(heightVariability_mm);
  builder_.add_height_mm(height_mm);
  return builder_.Finish();
}

struct ProceduralFace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_FACEANGLE = 6,
    VT_FACECENTERX = 8,
    VT_FACECENTERY = 10,
    VT_FACESCALEX = 12,
    VT_FACESCALEY = 14,
    VT_LEFTEYE = 16,
    VT_RIGHTEYE = 18
  };
  uint32_t triggerTime_ms() const { return GetField<uint32_t>(VT_TRIGGERTIME_MS, 0); }
  float faceAngle() const { return GetField<float>(VT_FACEANGLE, 0.0f); }
  float faceCenterX() const { return GetField<float>(VT_FACECENTERX, 0.0f); }
  float faceCenterY() const { return GetField<float>(VT_FACECENTERY, 0.0f); }
  float faceScaleX() const { return GetField<float>(VT_FACESCALEX, 1.0f); }
  float faceScaleY() const { return GetField<float>(VT_FACESCALEY, 1.0f); }
  const flatbuffers::Vector<float> *leftEye() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_LEFTEYE); }
  const flatbuffers::Vector<float> *rightEye() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_RIGHTEYE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<float>(verifier, VT_FACEANGLE) &&
           VerifyField<float>(verifier, VT_FACECENTERX) &&
           VerifyField<float>(verifier, VT_FACECENTERY) &&
           VerifyField<float>(verifier, VT_FACESCALEX) &&
           VerifyField<float>(verifier, VT_FACESCALEY) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LEFTEYE) &&
           verifier.Verify(leftEye()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RIGHTEYE) &&
           verifier.Verify(rightEye()) &&
           verifier.EndTable();
  }
};

struct ProceduralFaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(uint32_t triggerTime_ms) { fbb_.AddElement<uint32_t>(ProceduralFace::VT_TRIGGERTIME_MS, triggerTime_ms, 0); }
  void add_faceAngle(float faceAngle) { fbb_.AddElement<float>(ProceduralFace::VT_FACEANGLE, faceAngle, 0.0f); }
  void add_faceCenterX(float faceCenterX) { fbb_.AddElement<float>(ProceduralFace::VT_FACECENTERX, faceCenterX, 0.0f); }
  void add_faceCenterY(float faceCenterY) { fbb_.AddElement<float>(ProceduralFace::VT_FACECENTERY, faceCenterY, 0.0f); }
  void add_faceScaleX(float faceScaleX) { fbb_.AddElement<float>(ProceduralFace::VT_FACESCALEX, faceScaleX, 1.0f); }
  void add_faceScaleY(float faceScaleY) { fbb_.AddElement<float>(ProceduralFace::VT_FACESCALEY, faceScaleY, 1.0f); }
  void add_leftEye(flatbuffers::Offset<flatbuffers::Vector<float>> leftEye) { fbb_.AddOffset(ProceduralFace::VT_LEFTEYE, leftEye); }
  void add_rightEye(flatbuffers::Offset<flatbuffers::Vector<float>> rightEye) { fbb_.AddOffset(ProceduralFace::VT_RIGHTEYE, rightEye); }
  ProceduralFaceBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ProceduralFaceBuilder &operator=(const ProceduralFaceBuilder &);
  flatbuffers::Offset<ProceduralFace> Finish() {
    auto o = flatbuffers::Offset<ProceduralFace>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<ProceduralFace> CreateProceduralFace(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    float faceAngle = 0.0f,
    float faceCenterX = 0.0f,
    float faceCenterY = 0.0f,
    float faceScaleX = 1.0f,
    float faceScaleY = 1.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> leftEye = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> rightEye = 0) {
  ProceduralFaceBuilder builder_(_fbb);
  builder_.add_rightEye(rightEye);
  builder_.add_leftEye(leftEye);
  builder_.add_faceScaleY(faceScaleY);
  builder_.add_faceScaleX(faceScaleX);
  builder_.add_faceCenterY(faceCenterY);
  builder_.add_faceCenterX(faceCenterX);
  builder_.add_faceAngle(faceAngle);
  builder_.add_triggerTime_ms(triggerTime_ms);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProceduralFace> CreateProceduralFaceDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    float faceAngle = 0.0f,
    float faceCenterX = 0.0f,
    float faceCenterY = 0.0f,
    float faceScaleX = 1.0f,
    float faceScaleY = 1.0f,
    const std::vector<float> *leftEye = nullptr,
    const std::vector<float> *rightEye = nullptr) {
  return CreateProceduralFace(_fbb, triggerTime_ms, faceAngle, faceCenterX, faceCenterY, faceScaleX, faceScaleY, leftEye ? _fbb.CreateVector<float>(*leftEye) : 0, rightEye ? _fbb.CreateVector<float>(*rightEye) : 0);
}

struct HeadAngle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_DURATIONTIME_MS = 6,
    VT_ANGLE_DEG = 8,
    VT_ANGLEVARIABILITY_DEG = 10
  };
  uint32_t triggerTime_ms() const { return GetField<uint32_t>(VT_TRIGGERTIME_MS, 0); }
  uint32_t durationTime_ms() const { return GetField<uint32_t>(VT_DURATIONTIME_MS, 0); }
  int8_t angle_deg() const { return GetField<int8_t>(VT_ANGLE_DEG, 0); }
  uint8_t angleVariability_deg() const { return GetField<uint8_t>(VT_ANGLEVARIABILITY_DEG, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<uint32_t>(verifier, VT_DURATIONTIME_MS) &&
           VerifyField<int8_t>(verifier, VT_ANGLE_DEG) &&
           VerifyField<uint8_t>(verifier, VT_ANGLEVARIABILITY_DEG) &&
           verifier.EndTable();
  }
};

struct HeadAngleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(uint32_t triggerTime_ms) { fbb_.AddElement<uint32_t>(HeadAngle::VT_TRIGGERTIME_MS, triggerTime_ms, 0); }
  void add_durationTime_ms(uint32_t durationTime_ms) { fbb_.AddElement<uint32_t>(HeadAngle::VT_DURATIONTIME_MS, durationTime_ms, 0); }
  void add_angle_deg(int8_t angle_deg) { fbb_.AddElement<int8_t>(HeadAngle::VT_ANGLE_DEG, angle_deg, 0); }
  void add_angleVariability_deg(uint8_t angleVariability_deg) { fbb_.AddElement<uint8_t>(HeadAngle::VT_ANGLEVARIABILITY_DEG, angleVariability_deg, 0); }
  HeadAngleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  HeadAngleBuilder &operator=(const HeadAngleBuilder &);
  flatbuffers::Offset<HeadAngle> Finish() {
    auto o = flatbuffers::Offset<HeadAngle>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<HeadAngle> CreateHeadAngle(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    uint32_t durationTime_ms = 0,
    int8_t angle_deg = 0,
    uint8_t angleVariability_deg = 0) {
  HeadAngleBuilder builder_(_fbb);
  builder_.add_durationTime_ms(durationTime_ms);
  builder_.add_triggerTime_ms(triggerTime_ms);
  builder_.add_angleVariability_deg(angleVariability_deg);
  builder_.add_angle_deg(angle_deg);
  return builder_.Finish();
}

struct RobotAudio FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_AUDIOEVENTID = 6,
    VT_VOLUME = 8,
    VT_PROBABILITY = 10,
    VT_HASALTS = 12
  };
  uint32_t triggerTime_ms() const { return GetField<uint32_t>(VT_TRIGGERTIME_MS, 0); }
  const flatbuffers::Vector<int64_t> *audioEventId() const { return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AUDIOEVENTID); }
  float volume() const { return GetField<float>(VT_VOLUME, 1.0f); }
  const flatbuffers::Vector<float> *probability() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_PROBABILITY); }
  bool hasAlts() const { return GetField<uint8_t>(VT_HASALTS, 1) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_AUDIOEVENTID) &&
           verifier.Verify(audioEventId()) &&
           VerifyField<float>(verifier, VT_VOLUME) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PROBABILITY) &&
           verifier.Verify(probability()) &&
           VerifyField<uint8_t>(verifier, VT_HASALTS) &&
           verifier.EndTable();
  }
};

struct RobotAudioBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(uint32_t triggerTime_ms) { fbb_.AddElement<uint32_t>(RobotAudio::VT_TRIGGERTIME_MS, triggerTime_ms, 0); }
  void add_audioEventId(flatbuffers::Offset<flatbuffers::Vector<int64_t>> audioEventId) { fbb_.AddOffset(RobotAudio::VT_AUDIOEVENTID, audioEventId); }
  void add_volume(float volume) { fbb_.AddElement<float>(RobotAudio::VT_VOLUME, volume, 1.0f); }
  void add_probability(flatbuffers::Offset<flatbuffers::Vector<float>> probability) { fbb_.AddOffset(RobotAudio::VT_PROBABILITY, probability); }
  void add_hasAlts(bool hasAlts) { fbb_.AddElement<uint8_t>(RobotAudio::VT_HASALTS, static_cast<uint8_t>(hasAlts), 1); }
  RobotAudioBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RobotAudioBuilder &operator=(const RobotAudioBuilder &);
  flatbuffers::Offset<RobotAudio> Finish() {
    auto o = flatbuffers::Offset<RobotAudio>(fbb_.EndTable(start_, 5));
    fbb_.Required(o, RobotAudio::VT_AUDIOEVENTID);  // audioEventId
    return o;
  }
};

inline flatbuffers::Offset<RobotAudio> CreateRobotAudio(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> audioEventId = 0,
    float volume = 1.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> probability = 0,
    bool hasAlts = true) {
  RobotAudioBuilder builder_(_fbb);
  builder_.add_probability(probability);
  builder_.add_volume(volume);
  builder_.add_audioEventId(audioEventId);
  builder_.add_triggerTime_ms(triggerTime_ms);
  builder_.add_hasAlts(hasAlts);
  return builder_.Finish();
}

inline flatbuffers::Offset<RobotAudio> CreateRobotAudioDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    const std::vector<int64_t> *audioEventId = nullptr,
    float volume = 1.0f,
    const std::vector<float> *probability = nullptr,
    bool hasAlts = true) {
  return CreateRobotAudio(_fbb, triggerTime_ms, audioEventId ? _fbb.CreateVector<int64_t>(*audioEventId) : 0, volume, probability ? _fbb.CreateVector<float>(*probability) : 0, hasAlts);
}

struct BackpackLights FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_DURATIONTIME_MS = 6,
    VT_FRONT = 8,
    VT_MIDDLE = 10,
    VT_BACK = 12
  };
  uint32_t triggerTime_ms() const { return GetField<uint32_t>(VT_TRIGGERTIME_MS, 0); }
  uint32_t durationTime_ms() const { return GetField<uint32_t>(VT_DURATIONTIME_MS, 0); }
  const flatbuffers::Vector<float> *Front() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_FRONT); }
  const flatbuffers::Vector<float> *Middle() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_MIDDLE); }
  const flatbuffers::Vector<float> *Back() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_BACK); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<uint32_t>(verifier, VT_DURATIONTIME_MS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FRONT) &&
           verifier.Verify(Front()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MIDDLE) &&
           verifier.Verify(Middle()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACK) &&
           verifier.Verify(Back()) &&
           verifier.EndTable();
  }
};

struct BackpackLightsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(uint32_t triggerTime_ms) { fbb_.AddElement<uint32_t>(BackpackLights::VT_TRIGGERTIME_MS, triggerTime_ms, 0); }
  void add_durationTime_ms(uint32_t durationTime_ms) { fbb_.AddElement<uint32_t>(BackpackLights::VT_DURATIONTIME_MS, durationTime_ms, 0); }
  void add_Front(flatbuffers::Offset<flatbuffers::Vector<float>> Front) { fbb_.AddOffset(BackpackLights::VT_FRONT, Front); }
  void add_Middle(flatbuffers::Offset<flatbuffers::Vector<float>> Middle) { fbb_.AddOffset(BackpackLights::VT_MIDDLE, Middle); }
  void add_Back(flatbuffers::Offset<flatbuffers::Vector<float>> Back) { fbb_.AddOffset(BackpackLights::VT_BACK, Back); }
  BackpackLightsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BackpackLightsBuilder &operator=(const BackpackLightsBuilder &);
  flatbuffers::Offset<BackpackLights> Finish() {
    auto o = flatbuffers::Offset<BackpackLights>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<BackpackLights> CreateBackpackLights(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    uint32_t durationTime_ms = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Front = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Middle = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Back = 0) {
  BackpackLightsBuilder builder_(_fbb);
  builder_.add_Back(Back);
  builder_.add_Middle(Middle);
  builder_.add_Front(Front);
  builder_.add_durationTime_ms(durationTime_ms);
  builder_.add_triggerTime_ms(triggerTime_ms);
  return builder_.Finish();
}

inline flatbuffers::Offset<BackpackLights> CreateBackpackLightsDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    uint32_t durationTime_ms = 0,
    const std::vector<float> *Front = nullptr,
    const std::vector<float> *Middle = nullptr,
    const std::vector<float> *Back = nullptr) {
  return CreateBackpackLights(_fbb, triggerTime_ms, durationTime_ms, Front ? _fbb.CreateVector<float>(*Front) : 0, Middle ? _fbb.CreateVector<float>(*Middle) : 0, Back ? _fbb.CreateVector<float>(*Back) : 0);
}

struct FaceAnimation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_ANIMNAME = 6
  };
  uint32_t triggerTime_ms() const { return GetField<uint32_t>(VT_TRIGGERTIME_MS, 0); }
  const flatbuffers::String *animName() const { return GetPointer<const flatbuffers::String *>(VT_ANIMNAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ANIMNAME) &&
           verifier.Verify(animName()) &&
           verifier.EndTable();
  }
};

struct FaceAnimationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(uint32_t triggerTime_ms) { fbb_.AddElement<uint32_t>(FaceAnimation::VT_TRIGGERTIME_MS, triggerTime_ms, 0); }
  void add_animName(flatbuffers::Offset<flatbuffers::String> animName) { fbb_.AddOffset(FaceAnimation::VT_ANIMNAME, animName); }
  FaceAnimationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FaceAnimationBuilder &operator=(const FaceAnimationBuilder &);
  flatbuffers::Offset<FaceAnimation> Finish() {
    auto o = flatbuffers::Offset<FaceAnimation>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, FaceAnimation::VT_ANIMNAME);  // animName
    return o;
  }
};

inline flatbuffers::Offset<FaceAnimation> CreateFaceAnimation(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    flatbuffers::Offset<flatbuffers::String> animName = 0) {
  FaceAnimationBuilder builder_(_fbb);
  builder_.add_animName(animName);
  builder_.add_triggerTime_ms(triggerTime_ms);
  return builder_.Finish();
}

inline flatbuffers::Offset<FaceAnimation> CreateFaceAnimationDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    const char *animName = nullptr) {
  return CreateFaceAnimation(_fbb, triggerTime_ms, animName ? _fbb.CreateString(animName) : 0);
}

struct Event FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_EVENT_ID = 6
  };
  uint32_t triggerTime_ms() const { return GetField<uint32_t>(VT_TRIGGERTIME_MS, 0); }
  const flatbuffers::String *event_id() const { return GetPointer<const flatbuffers::String *>(VT_EVENT_ID); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_EVENT_ID) &&
           verifier.Verify(event_id()) &&
           verifier.EndTable();
  }
};

struct EventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(uint32_t triggerTime_ms) { fbb_.AddElement<uint32_t>(Event::VT_TRIGGERTIME_MS, triggerTime_ms, 0); }
  void add_event_id(flatbuffers::Offset<flatbuffers::String> event_id) { fbb_.AddOffset(Event::VT_EVENT_ID, event_id); }
  EventBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EventBuilder &operator=(const EventBuilder &);
  flatbuffers::Offset<Event> Finish() {
    auto o = flatbuffers::Offset<Event>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, Event::VT_EVENT_ID);  // event_id
    return o;
  }
};

inline flatbuffers::Offset<Event> CreateEvent(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    flatbuffers::Offset<flatbuffers::String> event_id = 0) {
  EventBuilder builder_(_fbb);
  builder_.add_event_id(event_id);
  builder_.add_triggerTime_ms(triggerTime_ms);
  return builder_.Finish();
}

inline flatbuffers::Offset<Event> CreateEventDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    const char *event_id = nullptr) {
  return CreateEvent(_fbb, triggerTime_ms, event_id ? _fbb.CreateString(event_id) : 0);
}

struct BodyMotion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_DURATIONTIME_MS = 6,
    VT_RADIUS_MM = 8,
    VT_SPEED = 10
  };
  uint32_t triggerTime_ms() const { return GetField<uint32_t>(VT_TRIGGERTIME_MS, 0); }
  uint32_t durationTime_ms() const { return GetField<uint32_t>(VT_DURATIONTIME_MS, 0); }
  const flatbuffers::String *radius_mm() const { return GetPointer<const flatbuffers::String *>(VT_RADIUS_MM); }
  int16_t speed() const { return GetField<int16_t>(VT_SPEED, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<uint32_t>(verifier, VT_DURATIONTIME_MS) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_RADIUS_MM) &&
           verifier.Verify(radius_mm()) &&
           VerifyField<int16_t>(verifier, VT_SPEED) &&
           verifier.EndTable();
  }
};

struct BodyMotionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(uint32_t triggerTime_ms) { fbb_.AddElement<uint32_t>(BodyMotion::VT_TRIGGERTIME_MS, triggerTime_ms, 0); }
  void add_durationTime_ms(uint32_t durationTime_ms) { fbb_.AddElement<uint32_t>(BodyMotion::VT_DURATIONTIME_MS, durationTime_ms, 0); }
  void add_radius_mm(flatbuffers::Offset<flatbuffers::String> radius_mm) { fbb_.AddOffset(BodyMotion::VT_RADIUS_MM, radius_mm); }
  void add_speed(int16_t speed) { fbb_.AddElement<int16_t>(BodyMotion::VT_SPEED, speed, 0); }
  BodyMotionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BodyMotionBuilder &operator=(const BodyMotionBuilder &);
  flatbuffers::Offset<BodyMotion> Finish() {
    auto o = flatbuffers::Offset<BodyMotion>(fbb_.EndTable(start_, 4));
    fbb_.Required(o, BodyMotion::VT_RADIUS_MM);  // radius_mm
    return o;
  }
};

inline flatbuffers::Offset<BodyMotion> CreateBodyMotion(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    uint32_t durationTime_ms = 0,
    flatbuffers::Offset<flatbuffers::String> radius_mm = 0,
    int16_t speed = 0) {
  BodyMotionBuilder builder_(_fbb);
  builder_.add_radius_mm(radius_mm);
  builder_.add_durationTime_ms(durationTime_ms);
  builder_.add_triggerTime_ms(triggerTime_ms);
  builder_.add_speed(speed);
  return builder_.Finish();
}

inline flatbuffers::Offset<BodyMotion> CreateBodyMotionDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    uint32_t durationTime_ms = 0,
    const char *radius_mm = nullptr,
    int16_t speed = 0) {
  return CreateBodyMotion(_fbb, triggerTime_ms, durationTime_ms, radius_mm ? _fbb.CreateString(radius_mm) : 0, speed);
}

struct RecordHeading FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4
  };
  uint32_t triggerTime_ms() const { return GetField<uint32_t>(VT_TRIGGERTIME_MS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRIGGERTIME_MS) &&
           verifier.EndTable();
  }
};

struct RecordHeadingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(uint32_t triggerTime_ms) { fbb_.AddElement<uint32_t>(RecordHeading::VT_TRIGGERTIME_MS, triggerTime_ms, 0); }
  RecordHeadingBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RecordHeadingBuilder &operator=(const RecordHeadingBuilder &);
  flatbuffers::Offset<RecordHeading> Finish() {
    auto o = flatbuffers::Offset<RecordHeading>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<RecordHeading> CreateRecordHeading(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0) {
  RecordHeadingBuilder builder_(_fbb);
  builder_.add_triggerTime_ms(triggerTime_ms);
  return builder_.Finish();
}

struct TurnToRecordedHeading FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_DURATIONTIME_MS = 6,
    VT_OFFSET_DEG = 8,
    VT_SPEED_DEGPERSEC = 10,
    VT_ACCEL_DEGPERSEC2 = 12,
    VT_DECEL_DEGPERSEC2 = 14,
    VT_TOLERANCE_DEG = 16,
    VT_NUMHALFREVS = 18,
    VT_USESHORTESTDIR = 20
  };
  uint32_t triggerTime_ms() const { return GetField<uint32_t>(VT_TRIGGERTIME_MS, 0); }
  uint32_t durationTime_ms() const { return GetField<uint32_t>(VT_DURATIONTIME_MS, 0); }
  int16_t offset_deg() const { return GetField<int16_t>(VT_OFFSET_DEG, 0); }
  int16_t speed_degPerSec() const { return GetField<int16_t>(VT_SPEED_DEGPERSEC, 0); }
  int16_t accel_degPerSec2() const { return GetField<int16_t>(VT_ACCEL_DEGPERSEC2, 1000); }
  int16_t decel_degPerSec2() const { return GetField<int16_t>(VT_DECEL_DEGPERSEC2, 1000); }
  uint16_t tolerance_deg() const { return GetField<uint16_t>(VT_TOLERANCE_DEG, 2); }
  uint16_t numHalfRevs() const { return GetField<uint16_t>(VT_NUMHALFREVS, 0); }
  bool useShortestDir() const { return GetField<uint8_t>(VT_USESHORTESTDIR, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<uint32_t>(verifier, VT_DURATIONTIME_MS) &&
           VerifyField<int16_t>(verifier, VT_OFFSET_DEG) &&
           VerifyField<int16_t>(verifier, VT_SPEED_DEGPERSEC) &&
           VerifyField<int16_t>(verifier, VT_ACCEL_DEGPERSEC2) &&
           VerifyField<int16_t>(verifier, VT_DECEL_DEGPERSEC2) &&
           VerifyField<uint16_t>(verifier, VT_TOLERANCE_DEG) &&
           VerifyField<uint16_t>(verifier, VT_NUMHALFREVS) &&
           VerifyField<uint8_t>(verifier, VT_USESHORTESTDIR) &&
           verifier.EndTable();
  }
};

struct TurnToRecordedHeadingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(uint32_t triggerTime_ms) { fbb_.AddElement<uint32_t>(TurnToRecordedHeading::VT_TRIGGERTIME_MS, triggerTime_ms, 0); }
  void add_durationTime_ms(uint32_t durationTime_ms) { fbb_.AddElement<uint32_t>(TurnToRecordedHeading::VT_DURATIONTIME_MS, durationTime_ms, 0); }
  void add_offset_deg(int16_t offset_deg) { fbb_.AddElement<int16_t>(TurnToRecordedHeading::VT_OFFSET_DEG, offset_deg, 0); }
  void add_speed_degPerSec(int16_t speed_degPerSec) { fbb_.AddElement<int16_t>(TurnToRecordedHeading::VT_SPEED_DEGPERSEC, speed_degPerSec, 0); }
  void add_accel_degPerSec2(int16_t accel_degPerSec2) { fbb_.AddElement<int16_t>(TurnToRecordedHeading::VT_ACCEL_DEGPERSEC2, accel_degPerSec2, 1000); }
  void add_decel_degPerSec2(int16_t decel_degPerSec2) { fbb_.AddElement<int16_t>(TurnToRecordedHeading::VT_DECEL_DEGPERSEC2, decel_degPerSec2, 1000); }
  void add_tolerance_deg(uint16_t tolerance_deg) { fbb_.AddElement<uint16_t>(TurnToRecordedHeading::VT_TOLERANCE_DEG, tolerance_deg, 2); }
  void add_numHalfRevs(uint16_t numHalfRevs) { fbb_.AddElement<uint16_t>(TurnToRecordedHeading::VT_NUMHALFREVS, numHalfRevs, 0); }
  void add_useShortestDir(bool useShortestDir) { fbb_.AddElement<uint8_t>(TurnToRecordedHeading::VT_USESHORTESTDIR, static_cast<uint8_t>(useShortestDir), 0); }
  TurnToRecordedHeadingBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TurnToRecordedHeadingBuilder &operator=(const TurnToRecordedHeadingBuilder &);
  flatbuffers::Offset<TurnToRecordedHeading> Finish() {
    auto o = flatbuffers::Offset<TurnToRecordedHeading>(fbb_.EndTable(start_, 9));
    return o;
  }
};

inline flatbuffers::Offset<TurnToRecordedHeading> CreateTurnToRecordedHeading(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t triggerTime_ms = 0,
    uint32_t durationTime_ms = 0,
    int16_t offset_deg = 0,
    int16_t speed_degPerSec = 0,
    int16_t accel_degPerSec2 = 1000,
    int16_t decel_degPerSec2 = 1000,
    uint16_t tolerance_deg = 2,
    uint16_t numHalfRevs = 0,
    bool useShortestDir = false) {
  TurnToRecordedHeadingBuilder builder_(_fbb);
  builder_.add_durationTime_ms(durationTime_ms);
  builder_.add_triggerTime_ms(triggerTime_ms);
  builder_.add_numHalfRevs(numHalfRevs);
  builder_.add_tolerance_deg(tolerance_deg);
  builder_.add_decel_degPerSec2(decel_degPerSec2);
  builder_.add_accel_degPerSec2(accel_degPerSec2);
  builder_.add_speed_degPerSec(speed_degPerSec);
  builder_.add_offset_deg(offset_deg);
  builder_.add_useShortestDir(useShortestDir);
  return builder_.Finish();
}

struct Keyframes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LIFTHEIGHTKEYFRAME = 4,
    VT_PROCEDURALFACEKEYFRAME = 6,
    VT_HEADANGLEKEYFRAME = 8,
    VT_ROBOTAUDIOKEYFRAME = 10,
    VT_BACKPACKLIGHTSKEYFRAME = 12,
    VT_FACEANIMATIONKEYFRAME = 14,
    VT_EVENTKEYFRAME = 16,
    VT_BODYMOTIONKEYFRAME = 18,
    VT_RECORDHEADINGKEYFRAME = 20,
    VT_TURNTORECORDEDHEADINGKEYFRAME = 22
  };
  const flatbuffers::Vector<flatbuffers::Offset<LiftHeight>> *LiftHeightKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiftHeight>> *>(VT_LIFTHEIGHTKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<ProceduralFace>> *ProceduralFaceKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ProceduralFace>> *>(VT_PROCEDURALFACEKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<HeadAngle>> *HeadAngleKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HeadAngle>> *>(VT_HEADANGLEKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<RobotAudio>> *RobotAudioKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RobotAudio>> *>(VT_ROBOTAUDIOKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<BackpackLights>> *BackpackLightsKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BackpackLights>> *>(VT_BACKPACKLIGHTSKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<FaceAnimation>> *FaceAnimationKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FaceAnimation>> *>(VT_FACEANIMATIONKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<Event>> *EventKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Event>> *>(VT_EVENTKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<BodyMotion>> *BodyMotionKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BodyMotion>> *>(VT_BODYMOTIONKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<RecordHeading>> *RecordHeadingKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RecordHeading>> *>(VT_RECORDHEADINGKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<TurnToRecordedHeading>> *TurnToRecordedHeadingKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TurnToRecordedHeading>> *>(VT_TURNTORECORDEDHEADINGKEYFRAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LIFTHEIGHTKEYFRAME) &&
           verifier.Verify(LiftHeightKeyFrame()) &&
           verifier.VerifyVectorOfTables(LiftHeightKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PROCEDURALFACEKEYFRAME) &&
           verifier.Verify(ProceduralFaceKeyFrame()) &&
           verifier.VerifyVectorOfTables(ProceduralFaceKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HEADANGLEKEYFRAME) &&
           verifier.Verify(HeadAngleKeyFrame()) &&
           verifier.VerifyVectorOfTables(HeadAngleKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ROBOTAUDIOKEYFRAME) &&
           verifier.Verify(RobotAudioKeyFrame()) &&
           verifier.VerifyVectorOfTables(RobotAudioKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACKPACKLIGHTSKEYFRAME) &&
           verifier.Verify(BackpackLightsKeyFrame()) &&
           verifier.VerifyVectorOfTables(BackpackLightsKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FACEANIMATIONKEYFRAME) &&
           verifier.Verify(FaceAnimationKeyFrame()) &&
           verifier.VerifyVectorOfTables(FaceAnimationKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENTKEYFRAME) &&
           verifier.Verify(EventKeyFrame()) &&
           verifier.VerifyVectorOfTables(EventKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BODYMOTIONKEYFRAME) &&
           verifier.Verify(BodyMotionKeyFrame()) &&
           verifier.VerifyVectorOfTables(BodyMotionKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RECORDHEADINGKEYFRAME) &&
           verifier.Verify(RecordHeadingKeyFrame()) &&
           verifier.VerifyVectorOfTables(RecordHeadingKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TURNTORECORDEDHEADINGKEYFRAME) &&
           verifier.Verify(TurnToRecordedHeadingKeyFrame()) &&
           verifier.VerifyVectorOfTables(TurnToRecordedHeadingKeyFrame()) &&
           verifier.EndTable();
  }
};

struct KeyframesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_LiftHeightKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiftHeight>>> LiftHeightKeyFrame) { fbb_.AddOffset(Keyframes::VT_LIFTHEIGHTKEYFRAME, LiftHeightKeyFrame); }
  void add_ProceduralFaceKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProceduralFace>>> ProceduralFaceKeyFrame) { fbb_.AddOffset(Keyframes::VT_PROCEDURALFACEKEYFRAME, ProceduralFaceKeyFrame); }
  void add_HeadAngleKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeadAngle>>> HeadAngleKeyFrame) { fbb_.AddOffset(Keyframes::VT_HEADANGLEKEYFRAME, HeadAngleKeyFrame); }
  void add_RobotAudioKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RobotAudio>>> RobotAudioKeyFrame) { fbb_.AddOffset(Keyframes::VT_ROBOTAUDIOKEYFRAME, RobotAudioKeyFrame); }
  void add_BackpackLightsKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BackpackLights>>> BackpackLightsKeyFrame) { fbb_.AddOffset(Keyframes::VT_BACKPACKLIGHTSKEYFRAME, BackpackLightsKeyFrame); }
  void add_FaceAnimationKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FaceAnimation>>> FaceAnimationKeyFrame) { fbb_.AddOffset(Keyframes::VT_FACEANIMATIONKEYFRAME, FaceAnimationKeyFrame); }
  void add_EventKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Event>>> EventKeyFrame) { fbb_.AddOffset(Keyframes::VT_EVENTKEYFRAME, EventKeyFrame); }
  void add_BodyMotionKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BodyMotion>>> BodyMotionKeyFrame) { fbb_.AddOffset(Keyframes::VT_BODYMOTIONKEYFRAME, BodyMotionKeyFrame); }
  void add_RecordHeadingKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RecordHeading>>> RecordHeadingKeyFrame) { fbb_.AddOffset(Keyframes::VT_RECORDHEADINGKEYFRAME, RecordHeadingKeyFrame); }
  void add_TurnToRecordedHeadingKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TurnToRecordedHeading>>> TurnToRecordedHeadingKeyFrame) { fbb_.AddOffset(Keyframes::VT_TURNTORECORDEDHEADINGKEYFRAME, TurnToRecordedHeadingKeyFrame); }
  KeyframesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  KeyframesBuilder &operator=(const KeyframesBuilder &);
  flatbuffers::Offset<Keyframes> Finish() {
    auto o = flatbuffers::Offset<Keyframes>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<Keyframes> CreateKeyframes(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiftHeight>>> LiftHeightKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProceduralFace>>> ProceduralFaceKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeadAngle>>> HeadAngleKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RobotAudio>>> RobotAudioKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BackpackLights>>> BackpackLightsKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FaceAnimation>>> FaceAnimationKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Event>>> EventKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BodyMotion>>> BodyMotionKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RecordHeading>>> RecordHeadingKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TurnToRecordedHeading>>> TurnToRecordedHeadingKeyFrame = 0) {
  KeyframesBuilder builder_(_fbb);
  builder_.add_TurnToRecordedHeadingKeyFrame(TurnToRecordedHeadingKeyFrame);
  builder_.add_RecordHeadingKeyFrame(RecordHeadingKeyFrame);
  builder_.add_BodyMotionKeyFrame(BodyMotionKeyFrame);
  builder_.add_EventKeyFrame(EventKeyFrame);
  builder_.add_FaceAnimationKeyFrame(FaceAnimationKeyFrame);
  builder_.add_BackpackLightsKeyFrame(BackpackLightsKeyFrame);
  builder_.add_RobotAudioKeyFrame(RobotAudioKeyFrame);
  builder_.add_HeadAngleKeyFrame(HeadAngleKeyFrame);
  builder_.add_ProceduralFaceKeyFrame(ProceduralFaceKeyFrame);
  builder_.add_LiftHeightKeyFrame(LiftHeightKeyFrame);
  return builder_.Finish();
}

inline flatbuffers::Offset<Keyframes> CreateKeyframesDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<LiftHeight>> *LiftHeightKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<ProceduralFace>> *ProceduralFaceKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<HeadAngle>> *HeadAngleKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<RobotAudio>> *RobotAudioKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<BackpackLights>> *BackpackLightsKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<FaceAnimation>> *FaceAnimationKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<Event>> *EventKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<BodyMotion>> *BodyMotionKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<RecordHeading>> *RecordHeadingKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<TurnToRecordedHeading>> *TurnToRecordedHeadingKeyFrame = nullptr) {
  return CreateKeyframes(_fbb, LiftHeightKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<LiftHeight>>(*LiftHeightKeyFrame) : 0, ProceduralFaceKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<ProceduralFace>>(*ProceduralFaceKeyFrame) : 0, HeadAngleKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<HeadAngle>>(*HeadAngleKeyFrame) : 0, RobotAudioKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<RobotAudio>>(*RobotAudioKeyFrame) : 0, BackpackLightsKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<BackpackLights>>(*BackpackLightsKeyFrame) : 0, FaceAnimationKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<FaceAnimation>>(*FaceAnimationKeyFrame) : 0, EventKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<Event>>(*EventKeyFrame) : 0, BodyMotionKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<BodyMotion>>(*BodyMotionKeyFrame) : 0, RecordHeadingKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<RecordHeading>>(*RecordHeadingKeyFrame) : 0, TurnToRecordedHeadingKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<TurnToRecordedHeading>>(*TurnToRecordedHeadingKeyFrame) : 0);
}

struct AnimClip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_KEYFRAMES = 6
  };
  const flatbuffers::String *Name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const Keyframes *keyframes() const { return GetPointer<const Keyframes *>(VT_KEYFRAMES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(Name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_KEYFRAMES) &&
           verifier.VerifyTable(keyframes()) &&
           verifier.EndTable();
  }
};

struct AnimClipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) { fbb_.AddOffset(AnimClip::VT_NAME, Name); }
  void add_keyframes(flatbuffers::Offset<Keyframes> keyframes) { fbb_.AddOffset(AnimClip::VT_KEYFRAMES, keyframes); }
  AnimClipBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimClipBuilder &operator=(const AnimClipBuilder &);
  flatbuffers::Offset<AnimClip> Finish() {
    auto o = flatbuffers::Offset<AnimClip>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimClip> CreateAnimClip(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<Keyframes> keyframes = 0) {
  AnimClipBuilder builder_(_fbb);
  builder_.add_keyframes(keyframes);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimClip> CreateAnimClipDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    flatbuffers::Offset<Keyframes> keyframes = 0) {
  return CreateAnimClip(_fbb, Name ? _fbb.CreateString(Name) : 0, keyframes);
}

struct AnimClips FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLIPS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnimClip>> *clips() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimClip>> *>(VT_CLIPS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CLIPS) &&
           verifier.Verify(clips()) &&
           verifier.VerifyVectorOfTables(clips()) &&
           verifier.EndTable();
  }
};

struct AnimClipsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clips(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimClip>>> clips) { fbb_.AddOffset(AnimClips::VT_CLIPS, clips); }
  AnimClipsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimClipsBuilder &operator=(const AnimClipsBuilder &);
  flatbuffers::Offset<AnimClips> Finish() {
    auto o = flatbuffers::Offset<AnimClips>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<AnimClips> CreateAnimClips(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimClip>>> clips = 0) {
  AnimClipsBuilder builder_(_fbb);
  builder_.add_clips(clips);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimClips> CreateAnimClipsDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AnimClip>> *clips = nullptr) {
  return CreateAnimClips(_fbb, clips ? _fbb.CreateVector<flatbuffers::Offset<AnimClip>>(*clips) : 0);
}

inline const CozmoAnim::AnimClips *GetAnimClips(const void *buf) {
  return flatbuffers::GetRoot<CozmoAnim::AnimClips>(buf);
}

inline bool VerifyAnimClipsBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CozmoAnim::AnimClips>(nullptr);
}

inline void FinishAnimClipsBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<CozmoAnim::AnimClips> root) {
  fbb.Finish(root);
}

}  // namespace CozmoAnim

#endif  // FLATBUFFERS_GENERATED_COZMOANIM_COZMOANIM_H_
