// Messages related to commanding Cozmo Actions.
//  for the C-Like Abstract Data language
// Author: Andrew Stein
// Copyright: Anki Inc (c) 2016

#include "clad/types/actionTypes.clad"
#include "clad/types/faceEnrollmentSequences.clad"
#include "clad/types/gameEvent.clad"
#include "clad/types/pathMotionProfile.clad"
#include "clad/types/sayTextStyles.clad"

namespace Anki {
namespace Cozmo {
namespace ExternalInterface {

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Actions

// =============================================
// NOTE: Please add new messages alphabetically!
// =============================================

// AlignWithObject
// "Docks" to object so that it is aligned with it at the specified AligmentType or distance
// If alignmentType is CUSTOM, distanceFromMarker_mm is used, otherwise distanceFromMarker_mm is ignored
message AlignWithObject {
    int_32 objectID,
    PathMotionProfile motionProf,
    float_32 distanceFromMarker_mm,
    float_32 approachAngle_rad,
    bool useApproachAngle,
    bool usePreDockPose,
    bool useManualSpeed,
    AlignmentType alignmentType
}

// DriveStraight
//  Drives a straight line forward or backward without using the planner.
message DriveStraight {
   float_32 speed_mmps,  // Speed should be positive
   float_32 dist_mm      // Use +ve for forward, -ve for backward
}

// EnrollNamedFace
message EnrollNamedFace {
   int_32 faceID,
   string name,
   FaceEnrollmentSequence sequence,
   bool saveToRobot=1  // Save to robot's NVStorage when done (NOTE: will (re)save everyone enrolled!)
}

// FlipBlock
message FlipBlock {
  int_32 objectID,
  PathMotionProfile motionProf
}

// GotoObject
message GotoObject {
  int_32 objectID,
  PathMotionProfile motionProf,
  float_32 distanceFromObjectOrigin_mm,
  bool useManualSpeed,
  bool usePreDockPose = 0
}

// GotoPose
message GotoPose {
  float_32 x_mm,
  float_32 y_mm,
  float_32 rad,
  PathMotionProfile motionProf,
  uint_8 level,
  bool useManualSpeed
}

// MountCharger
message MountCharger {
  int_32 objectID,
  PathMotionProfile motionProf,
  bool usePreDockPose,
  bool useManualSpeed
}

// PanAndTilt
message PanAndTilt {
  float_32 bodyPan,
  float_32 headTilt,
  bool isPanAbsolute,
  bool isTiltAbsolute
}

// PickupObject
// @param useApproachAngle  - If true, then only the preAction pose that results in a robot
//                            approach angle closest to approachAngle_rad is considered.
// @param approachAngle_rad - The desired docking approach angle of the robot in world coordinates.
message PickupObject {
    int_32 objectID, // negative value means "currently selected object"
    PathMotionProfile motionProf,
    float_32 approachAngle_rad,
    bool   useApproachAngle,
    bool usePreDockPose,
    bool useManualSpeed,
}

// PlaceObjectOnGround
message PlaceObjectOnGround {
    float_32 x_mm,
    float_32 y_mm,
    float_32 qw,             // Specify rotation via quaternion
    float_32 qx,
    float_32 qy,
    float_32 qz,
    PathMotionProfile motionProf,
    uint_8 level,
    bool useManualSpeed,
    bool useExactRotation,    // If true, then tries to place object at the exact rotation specified by the quaternion
                             // otherwise it chooses the closest preActionPose such the object is aligned with the quaternion rotation.
    bool checkDestinationFree, // if true the action will check whether the destination is still free of obstacles along the way
}

// PlaceObjectOnGroundHere
message PlaceObjectOnGroundHere {

}

// PlaceOnObject
// Places the carried object on top of objectID.
// @param useExactRotation - If true, then only the preAction pose that results in the carried object
//                           being placed in alignment with objectID that is closest to the specified
//                           quaternion rotation is considered.
//                           If the up-axis of the current rotation is not the same as that of the
//                           currently carried object, the action fails.
message PlaceOnObject {
    int_32 objectID, // negative value means "currently selected object"
    PathMotionProfile motionProf,
    float_32 approachAngle_rad,
    bool   useApproachAngle,
    bool usePreDockPose,
    bool useManualSpeed,
}

// PlaceRelObject
// @param placementOffsetX_mm - The desired distance between the center of the docking marker
//                              and the center of the object that is being placed, along the
//                              direction of the docking marker's normal.
// @param useApproachAngle  - If true, then only the preAction pose that results in a robot
//                            approach angle closest to approachAngle_rad is considered.
// @param approachAngle_rad - The desired docking approach angle of the robot in world coordinates.
message PlaceRelObject {
    int_32 objectID, // negative value means "currently selected object"
    PathMotionProfile motionProf,
    float_32 placementOffsetX_mm,  // X-axis offset for object placement (where +x extends out the marker face)
    float_32 approachAngle_rad,
    bool   useApproachAngle,
    bool usePreDockPose,
    bool useManualSpeed,
}

// PlayAnimation
message PlayAnimation {
    uint_8  robotID,
    uint_32 numLoops,
    string animationName
}

// PlayAnimationGroup
message PlayAnimationGroup {
  uint_8  robotID,
  uint_32 numLoops,
  string animationGroupName
}

// PopAWheelie
message PopAWheelie {
  int_32 objectID, // negative value means "currently selected object"
  PathMotionProfile motionProf,
  float_32 approachAngle_rad,
  bool useApproachAngle,
  bool usePreDockPose,
  bool useManualSpeed
}

// ReadToolCode
message ReadToolCode {

}

// RollObject
message RollObject {
  int_32 objectID, // negative value means "currently selected object"
  PathMotionProfile motionProf,
  float_32 approachAngle_rad,
  bool   useApproachAngle,
  bool usePreDockPose,
  bool useManualSpeed
}

// SayText
message SayText {
    string       text,
    GameEvent    playEvent,
    SayTextStyle style  // "How" to say the text
}

// SearchSideToSide
message SearchSideToSide {
    uint_8 robotID
}

// SetHeadAngle
message SetHeadAngle {
    float_32 angle_rad,
    float_32 max_speed_rad_per_sec,
    float_32 accel_rad_per_sec2,
    float_32 duration_sec
}

// SetLiftHeight
message SetLiftHeight {
    float_32 height_mm,
    float_32 max_speed_rad_per_sec,
    float_32 accel_rad_per_sec2,
    float_32 duration_sec
}

// TrackToFace
//   Robot will automatically adjust head and body angle to look at this face ID, if it
//   is observed. Sending SetHeadAngle message (above) will disable this behavior.
//   Set headOnly to true to only use the head and not turn the body.
//   Use objectID = u32_MAX to disable tracking.
message TrackToFace {
    uint_32 faceID,
    uint_8  robotID,
    bool    headOnly
}

// TrackToObject
//   Robot will automatically adjust head and body angle to look at this object ID, if it
//   is observed. Sending SetHeadAngle message (above) will disable this behavior.
//   Set headOnly to true to only use the head and not turn the body.
//   Use objectID = u32_MAX to disable tracking.
message TrackToObject {
    uint_32 objectID,
    uint_8  robotID,
    bool    headOnly
}

// TraverseObject
message TraverseObject {
  PathMotionProfile motionProf,
  bool usePreDockPose,
  bool useManualSpeed
}

// TurnInPlace
// If isAbsolute == 0, turns the specified number of radians, *relative to the robot's current heading*
// If isAbsolute != 0, turns to the specified absolute orientation.
message TurnInPlace {
    float_32 angle_rad, // relative mode: postive turns left negative turns right
    float_32 speed_rad_per_sec = 0.0,
    float_32 accel_rad_per_sec2 = 0.0,
    uint_8 isAbsolute,    // 0: angle_rad is relative to current orientation, 1: angle_rad is absolute angle to turn to
    uint_8 robotID
}

// TurnInPlaceAtSpeed
message TurnInPlaceAtSpeed {
    float_32 speed_rad_per_sec,
    float_32 accel_rad_per_sec2,
    uint_8 robotID
}

// TurnTowardsLastFacePose
//  Tell the robot to turn and tilt his head to face the pose of the last known face
message TurnTowardsLastFacePose {
    float_32 maxTurnAngle,

    // A value of 0 means 'Don't care' (i.e. use engine's default value)
    float_32 maxPanSpeed_radPerSec = 0.0,
    float_32 panAccel_radPerSec2 = 0.0,
    float_32 panTolerance_rad = 0.0,
    float_32 maxTiltSpeed_radPerSec = 0.0,
    float_32 tiltAccel_radPerSec2 = 0.0,
    float_32 tiltTolerance_rad = 0.0,

    uint_8   robotID
}

// TurnTowardsObject - Turns and tilts head to look at object in last known position
//   If facing the object requires less than a turnAngleTol turn, then no
//   turn is performed. If a turn greater than maxTurnAngle is required,
//   the action fails. For angles in between, the robot will first turn
//   to face the object, then tilt its head. To completely disallow turning,
//   set maxTurnAngle to zero. (All angles in radians and forced to be positive.)
//   Set headTrackWhenDone to non-zero to enable head tracking to the specified
//   object once the robot has successfully faced it.
message TurnTowardsObject {
    uint_32  objectID,
    float_32 maxTurnAngle,

    // A value of 0 means 'Don't care' (i.e. use engine's default value)
    float_32 maxPanSpeed_radPerSec = 0.0,
    float_32 panAccel_radPerSec2 = 0.0,
    float_32 panTolerance_rad = 0.0,
    float_32 maxTiltSpeed_radPerSec = 0.0,
    float_32 tiltAccel_radPerSec2 = 0.0,
    float_32 tiltTolerance_rad = 0.0,

    uint_8   robotID,
    bool   visuallyVerifyWhenDone,
    bool   headTrackWhenDone
}

// TurnTowardsPose
//  Tell the robot to turn and tilt his head to face a give 3D pose in world
//  coordinates.
message TurnTowardsPose {
    float_32 world_x,
    float_32 world_y,
    float_32 world_z,
    float_32 maxTurnAngle,

    // A value of 0 means 'Don't care' (i.e. use engine's default value)
    float_32 maxPanSpeed_radPerSec = 0.0,
    float_32 panAccel_radPerSec2 = 0.0,
    float_32 panTolerance_rad = 0.0,
    float_32 maxTiltSpeed_radPerSec = 0.0,
    float_32 tiltAccel_radPerSec2 = 0.0,
    float_32 tiltTolerance_rad = 0.0,

    uint_8   robotID
}

// Wait
message Wait {
  float_32 time_s
}

// TODO: Why can't I use the auto-union feature? I have to manually add each message or else I get an infinite CLAD recursion?
//union RobotActionUnion { }


// Again: Alphabetical please!
union RobotActionUnion {
  AlignWithObject           alignWithObject,
  DriveStraight             driveStraight,
  EnrollNamedFace           enrollNamedFace,
  FlipBlock                 flipBlock,
  GotoObject                goToObject,
  GotoPose                  goToPose,
  MountCharger              mountCharger,
  PanAndTilt                panAndTilt,
  PickupObject              pickupObject,
  PlaceOnObject             placeOnObject,
  PlaceRelObject            placeRelObject,
  PlaceObjectOnGround       placeObjectOnGround,
  PlaceObjectOnGroundHere   placeObjectOnGroundHere,
  PlayAnimation             playAnimation,
  PlayAnimationGroup        playAnimationGroup,
  PopAWheelie               popAWheelie,
  ReadToolCode              readToolCode,
  RollObject                rollObject,
  SayText                   sayText,
  SearchSideToSide          searchSideToSide,
  SetHeadAngle              setHeadAngle,
  SetLiftHeight             setLiftHeight,
  TrackToFace               trackFace,
  TrackToObject             trackObject,
  TurnInPlace               turnInPlace,
  TurnTowardsLastFacePose   turnTowardsLastFacePose,
  TurnTowardsObject         turnTowardsObject,
  TurnTowardsPose           turnTowardsPose,
  Wait                      wait,
}



} // namespace U2G
} // namespace Cozmo
} // namespace Anki
