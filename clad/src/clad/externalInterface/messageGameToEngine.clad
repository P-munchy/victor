// UiMessageDefinitions message definition file
//  for the C-Like Abstract Data language
// Author: Greg Nagel
// Copyright: Anki Inc (c) 2015

#include "clad/audio/audioMessage.clad"

#include "clad/externalInterface/messageActions.clad"
#include "clad/externalInterface/messageShared.clad"
#include "clad/externalInterface/messageToBehaviorManager.clad"
#include "clad/types/actionTypes.clad"
#include "clad/types/activityTypes.clad"
#include "clad/types/behaviorTypes.clad"
#include "clad/types/controllerChannels.clad"
#include "clad/types/customObjectMarkers.clad"
#include "clad/types/debugConsoleTypes.clad"
#include "clad/types/emotionTypes.clad"
#include "clad/types/featureGateTypes.clad"
#include "clad/types/firmwareTypes.clad"
#include "clad/types/globalVizOrigin.clad"
#include "clad/types/imageTypes.clad"
#include "clad/types/imu.clad"
#include "clad/types/ledTypes.clad"
#include "clad/types/liveIdleAnimationParameters.clad"
#include "clad/types/needsSystemTypes.clad"
#include "clad/types/objectTypes.clad"
#include "clad/types/nvStorageTypes.clad"
#include "clad/types/pathMotionProfile.clad"
#include "clad/types/poseStructs.clad"
#include "clad/types/proceduralEyeParameters.clad"
#include "clad/types/reactionTriggers.clad"
#include "clad/types/robotTestModes.clad"
#include "clad/types/sayTextStyles.clad"
#include "clad/types/uiConnectionTypes.clad"
#include "clad/types/unlockTypes.clad"
#include "clad/types/visionModes.clad"
#include "clad/types/voiceCommandTypes.clad"


namespace Anki {
namespace Cozmo {
namespace ExternalInterface {

///////////////////////////////////////////////////////////////////////////////
// Communication / Connectivity
///////////////////////////////////////////////////////////////////////////////


// DO NOT CHANGE THIS MESSAGE - it must be compatible across all versions so we can reliably handshake with SDK
//                            - (and by definition this message implies a version mismatch)
message UiDeviceConnectionWrongVersion {
  uint_8  reserved, // future-proofing (we can increase tag size to a uint_16 and still retain binary compatability)
  UiConnectionType  connectionType,
  uint_32 deviceID,
  string  buildVersion,
}

// this (and all subsequent) messages can change post-ship - it's only sent if versions match
message UiDeviceConnectionSuccess {
  UiConnectionType  connectionType,
  uint_32 deviceID,
  string  buildVersion,
  string  sdkModuleVersion,
  string  pythonVersion,
  string  pythonImplementation,
  string  osVersion,
  string  cpuVersion
}

message ConnectToRobot {
    uint_8 ipAddress[16],
    uint_8 robotID,
    uint_8 isSimulated
}

// ConnectToUiDevice
message ConnectToUiDevice {
    UiConnectionType  connectionType,
    uint_8 deviceID
}

// DisconnectFromUiDevice
message DisconnectFromUiDevice {
    UiConnectionType  connectionType,
    uint_8 deviceID
}

// StartEngine
// Tell the engine to start running.
message StartEngine {
    uint_32 random_seed = 0   // Use 0 for randomly generated seed, or a specific value for repeatability
}

message ReliableTransportRunMode {
  bool isSync
}

// Request feature toggles from engine
message RequestFeatureToggles {
}

// Set feature toggle changed in UI
message SetFeatureToggle {
  FeatureType feature,
  bool value
}

message StartIdleTimeout {
  float_32 faceOffTime_s = -1.0,
  float_32 disconnectTime_s = -1.0
}

message CancelIdleTimeout {
  
}

message SetGameBeingPaused {
  bool isPaused = 1
}

///////////////////////////////////////////////////////////////////////////////
// Low-level Robot Controls
///////////////////////////////////////////////////////////////////////////////

// UpdateFirmware
// Tell the engine to start updating the robot firmware to specific version
message UpdateFirmware {
  FirmwareType fwType,
  int_32 version
}

// ResetFirmware
// Tell the engine to kill robot body code and reset to factory defaults
message ResetFirmware {
}

// DriveWheels
message DriveWheels {
    float_32 lwheel_speed_mmps,
    float_32 rwheel_speed_mmps,
    float_32 lwheel_accel_mmps2 = 0.0,
    float_32 rwheel_accel_mmps2 = 0.0
}

message DriveArc {
  float_32 speed,               // Target speed in mm/sec
                                // If curvatureRadius_mm == 0, the speed is in rad/s where +ve means CCW rotation.
  float_32 accel,               // Acceleration to approach target speed in mm/sec^2 (Sign is ignored)
                                // (or rad/s^2 if curvatureRadius_mm == 0)
                                // 0: Max acceleration
  int_16 curvatureRadius_mm     // Radius of arc to drive
                                // u16_MAX or u16_MIN: Straight
                                // +ve: curves left, -ve: curves right
                                // 0: Point turn
}

// MoveHead
message MoveHead {
    float_32 speed_rad_per_sec
}

// MoveLift
message MoveLift {
    float_32 speed_rad_per_sec
}

// EnableLiftPower
message EnableLiftPower {
    bool enable
}

message EnableCliffSensor {
    bool enable
}

message EnableBlockTapFilter {
  bool enable
}

message GetBlockTapFilterStatus {
}

// StopAllMotors
message StopAllMotors {

}

// ControllerGains
message ControllerGains
{
  float_32 kp,
  float_32 ki,
  float_32 kd,
  float_32 maxIntegralError,
  ControllerChannel controller
}

message RollActionParams
{
  float_32 liftHeight_mm,
  float_32 driveSpeed_mmps,
  float_32 driveAccel_mmps2,
  uint_32 driveDuration_ms,
  float_32 backupDist_mm,
}

message SetMotionModelParams
{
  float_32 slipFactor,
}

// SetRobotVolume
message SetRobotVolume {
  uint_8   robotId,
  float_32 volume
}


// !!! Be sure to update RobotAudioOutputSource in robotAudioClient.h if this enum is updated. !!!
enum uint_8 RobotAudioOutputSourceCLAD
{
  NoDevice,       // No audio
  PlayOnDevice,   // Play on Device - This is not perfectly synced to animations
  PlayOnRobot     // Play on Robot by using Hijack Audio plug-in to get audio stream from Wwise
}

message SetRobotAudioOutputSource
{
  RobotAudioOutputSourceCLAD source
}

message ForceDelocalizeRobot {
  uint_8 robotID
}

// Will restore the currently connected robot with either an automatically determined
// backup file or from the specified one
message RestoreRobotFromBackup {
  uint_32 robotToRestoreFrom = 0
}

// Requests data about the backups we have and whether or not to prompt the user
// to restore this robot
message RequestRobotRestoreData {

}

// Wipes all game data on the robot
message WipeRobotGameData {

}

message RequestUnlockDataFromBackup {

}

///////////////////////////////////////////////////////////////////////////////
// Action Queuing Commands  (Actions themselves are in messageActions.clad!)
///////////////////////////////////////////////////////////////////////////////

// CancelAction
//  Use actionType to cancel any queued actions of the specified type.
//  Use actionType = -1 to cancel all actions, regardless of type.
message CancelAction {
  RobotActionType actionType,  // See actionTypes.def
  uint_8 robotID
}

// CancelActionByIdTag
message CancelActionByIdTag {
  uint_32 idTag,
  uint_8 robotID
}

// QueueSingleAction
  message QueueSingleAction {
  uint_8  robotID,
  uint_32 idTag,  // caller-specified identifier that will be returned with the completion message
  uint_8  numRetries = 0,
  QueueActionPosition    position,
  RobotActionUnion       action
}

// QueueCompoundAction
message QueueCompoundAction {
  uint_8  robotID,
  uint_32 idTag,   // caller-specified identifier that will be returned with the completion message
  uint_8  numRetries = 0,
  bool  parallel,  // false means sequential
  QueueActionPosition    position,
  RobotActionUnion       actions[uint_8]
}



///////////////////////////////////////////////////////////////////////////////
// Image-Related Commands
///////////////////////////////////////////////////////////////////////////////

// ImageRequest
message ImageRequest {
    uint_8 robotID,
    ImageSendMode mode
}

// SetRobotImageSendMode
// NOTE: This can enable/disable streaming of images from the physical robot.
//       It is intended for dev use since the robot will likely always stream
//       its image in the product.
message SetRobotImageSendMode {
    uint_8 robotID,
    ImageSendMode mode,
    ImageResolution resolution
}

// SaveImages (via VizController)
message SaveImages {
    ImageSendMode mode,
    string        path
}

// Enable/disable the streaming of colored images
message EnableColorImages {
  bool enable
}

// SaveRobotState (via VizController)
message SaveRobotState {
    bool    enabled,
    string  path
}

// EnableDisplay
message EnableDisplay {
    uint_8 enable
}

// ExecuteTestPlans
message ExecuteTestPlan {
    PathMotionProfile motionProf
}

message PlannerRunMode {
    bool isSync
}


// SelectNextObject
message SelectNextObject {

}

// SetRobotCarryingObject
// (Override robot's current belief about whether it's carrying a block)
// (Ideally, for dev/prototyping only)
message SetRobotCarryingObject {
    int_32 objectID, // use -1 to specify "none"
    uint_8 robotID
}


///////////////////////////////////////////////////////////////////////////////
// Vision Settings and Commands
///////////////////////////////////////////////////////////////////////////////

// DeleteAllCustomObjects
// Deletes *all* custom objects ("fixed" ones and those with markers).
// "RobotDeletedAllCustomObjects" message will be sent back as confirmation.
message DeleteAllCustomObjects {
}

// DeleteCustomMarkerObjects
// Deletes all instantiations of any custom marker objects defined below.
// "Fixed" markerless custom objects remain.
// The definitions remain valid so new ones can still be created.
// "RobotDeletedCustomMarkerObjects" message will be sent back as confirmation.
message DeleteCustomMarkerObjects {
}

// DeleteFixedCustomObjects
// Deletes all "fixed" (markerless) custom objects created with CreateFixedCustomObject.
// Custom marker objects will remain.
// "RobotDeletedFixedCustomObjects" message will be sent back as confirmation.
message DeleteFixedCustomObjects {
}

// UndefineAllCustomMarkerObjects
// All custom marker objects definitions defined with messages below are completely removed
// and any instantiations of those objects are deleted.
// "Fixed" (markerless) custom objects remain.
// "RobotDeletedCustomMarkerObjects" message will be sent back as confirmation.
message UndefineAllCustomMarkerObjects {
}

// CreateFixedCustomObject
// Creates a CustomObject at the specific pose with no markers associated with it
// Since this object has no markers with which to be observed, it will remain in the
// specified pose as an obstacle forever (or until deleted with a deletion message above)
message CreateFixedCustomObject {
    PoseStruct3d pose,
    float_32 xSize_mm,
    float_32 ySize_mm,
    float_32 zSize_mm,
}

// DefineCustomBox
// Defines a custom object of the given size with the given markers centered on each side
// If isUnique=true, there is guaranteed to be no more than one object of this type present in the world
message DefineCustomBox {
    ObjectType         customType, // One of CustomTypeN, where N=0..19
    CustomObjectMarker markerFront,
    CustomObjectMarker markerBack,
    CustomObjectMarker markerTop,
    CustomObjectMarker markerBottom,
    CustomObjectMarker markerLeft,
    CustomObjectMarker markerRight,
    float_32   xSize_mm,
    float_32   ySize_mm,
    float_32   zSize_mm,
    float_32   markerWidth_mm,
    float_32   markerHeight_mm,
    bool       isUnique
}

// DefineCustomCube
// Defines a custom cube of the given size. The cube will have the same marker centered on all faces.
// If isUnique=true, there is guaranteed to be no more than one cube of this type present in the world at a time.
message DefineCustomCube {
    ObjectType         customType, // One of CustomTypeN, where N=0..19
    CustomObjectMarker marker,
    float_32   size_mm,
    float_32   markerWidth_mm,
    float_32   markerHeight_mm,
    bool       isUnique
}

// DefineCustomWall
// Defines a custom wall of the given height and width, with the same marker centered on both sides (front and back).
// The wall's thickness is assumed to be 1cm (and thus there are no markers on its left, right, top, or bottom)
// If isUnique=true, there is guaranteed to be no more than one wall of this type present in the world at a time.
message DefineCustomWall {
    ObjectType         customType, // One of CustomTypeN, where N=0..19
    CustomObjectMarker marker,
    float_32   width_mm,
    float_32   height_mm,
    float_32   markerWidth_mm,
    float_32   markerHeight_mm,
    bool       isUnique
}

// VisionWhileMoving
// For development, enable/disable robots' ability to use VisionMarkers while moving
// May be necessary to have this disabled while we have frame sync issues.
// NOTE: This will apply to all robots currently connected.
message VisionWhileMoving {
    uint_8 enable // True or false
}

// SetFaceToEnroll - Send face enrollments settings. Actual face enrollment only happens
//                   when the BehaviorEnrollFace runs. That behavior requires these settings
//                   be sent in order to be runnable.
message SetFaceToEnroll {
    string name,

    int_32 observedID=0,  // The ID of a specific observed face to enroll (0 for next one we see)
    int_32 saveID=0,      // The ID of an existing face to merge final enrollment into (0 for none,
                          // i.e. use observedID)

    bool saveToRobot=1,   // Save to robot's NVStorage when done (NOTE: will (re)save everyone enrolled!)
    bool sayName=0,       // Play say-name/celebration animations on success before completing
    bool useMusic=0       // Starts special music during say-name animations (will leave music playing!)
}

// CancelFaceEnrollment - Unsets face enrollment settings, meaning BehaviorEnrollFace will no
//                        longer be runnable
message CancelFaceEnrollment {

}

// Erase a face record by ID
message EraseEnrolledFaceByID {
  int_32 faceID
}

// Erase all enrolled faces (use with care!)
message EraseAllEnrolledFaces {

}

message EnableVisionMode {
   VisionMode mode,
   bool       enable
}

// Rename given ID+oldName pair to use newName. For safety if current face with given ID
// does not match oldName, nothing happens.
// On success, a RobotLoadedKnownFace message with faceID and newName will be sent.
message UpdateEnrolledFaceByID {
  int_32 faceID,
  string oldName,
  string newName
}

message VisionRunMode {
  bool isSync
}

// Save the enrolled face album to a file
message SaveFaceAlbumToFile {
  string path,
  bool   isRelativePath=1  // If true, use 'path' relative to internal album path
}

// Load the face album from a file (this clears all faces stored on the robot!)
message LoadFaceAlbumFromFile {
  string path,
  bool   isRelativePath=1  // If true, use 'path' relative to internal album path
}

message SetMemoryMapRenderEnabled {
  bool enabled
}

message SetMemoryMapBroadcastFrequency_sec {
  float_32 frequency=-1.0  // If frequency is negative, don't send
}

///////////////////////////////////////////////////////////////////////////////
// Behavior Commands
///////////////////////////////////////////////////////////////////////////////

// ActivateHighLevelActivity
message ActivateHighLevelActivity {
  HighLevelActivity activityType
}

// ExecuteBehavior
message ExecuteBehaviorByExecutableType {
  ExecutableBehaviorType behaviorType,
  int_32 numRuns = -1 // Number of times to run the behavior (-1 is infinite)
}

message ExecuteBehaviorByID {
  BehaviorID behaviorID,
  int_32 numRuns = -1 // Number of times to run the behavior (-1 is infinite)
}

// Special message to make BehaviorLiftLoadTest runnable.
// Send this message before sending ExecuteBehaviorByName("LiftLoadTest")
message SetLiftLoadTestAsRunnable {
}

// Any message intended for a specific robot's behaviorManager
message BehaviorManagerMessage {
  uint_8  robotID,
  BehaviorManagerMessageUnion  BehaviorManagerMessageUnion
}

// AbortPath
message AbortPath {
}

// AbortAll
message AbortAll {

}

// StartTestMode
message StartTestMode {
    uint_8  robotID,
    int_32 p1,
    int_32 p2,
    int_32 p3,
    TestMode mode
}

// request behaviors for chooser
message RequestAllBehaviorsList {
}

// request reaction trigger map
message RequestReactionTriggerMap {

}


// Execute Reaction
message ExecuteReactionTrigger {
  ReactionTriggerToBehavior reactionTriggerToBehaviorEntry
}

//disable all the affected triggers by locking them with the specified lockID
message DisableReactionsWithLock{
  string lockID,
  AllTriggersConsidered triggersAffected
}

//remove the specified lockID from all triggers -
//if no locks remain the trigger will be re-enabled
message RemoveDisableReactionsLock{
  string lockID
}

// disable all reactions with a lock - SHOULD ONLY BE USED BY SDK
message DisableAllReactionsWithLock{
  string lockID
}

// Engine will preserve the head and lift state between reactionary behaviors
message SetDefaultHeadAndLiftState {
  bool enable,
  float_32 headAngle,
  float_32 liftHeight
}

message SetSparkedMusicState{
  AudioMetaData::SwitchState::Sparked sparkedMusicState
}


///////////////////////////////////////////////////////////////////////////////
// Blockworld
///////////////////////////////////////////////////////////////////////////////

// request currently located instances of objects in the current origin
// pose information can be trusted from this objects
message RequestLocatedObjectStates {
}

// request currently connected objects, regardless of their pose state in current or any origin
// pose information is not provided for this objects
message RequestConnectedObjects {
}

///////////////////////////////////////////////////////////////////////////////
// Visualization (Viz) Related
///////////////////////////////////////////////////////////////////////////////

// DrawPoseMarker
message DrawPoseMarker {
    float_32 x_mm,
    float_32 y_mm,
    float_32 rad,
    uint_8 level
}

// ErasePoseMarker
message ErasePoseMarker {

}

// VisualizeQuad
//  Draws the specified quadrilateral using the Visualization system.
//  The quadID will be created if new or replaced if it already exists (i.e., you
//  do not need to send an EraseQuad message before updating an existing quad).
message VisualizeQuad {
  uint_32 quadID,
  uint_32 color, // RGBA
  float_32 xUpperLeft,
  float_32 yUpperLeft,
  float_32 zUpperLeft,
  float_32 xLowerLeft,
  float_32 yLowerLeft,
  float_32 zLowerLeft,
  float_32 xUpperRight,
  float_32 yUpperRight,
  float_32 zUpperRight,
  float_32 xLowerRight,
  float_32 yLowerRight,
  float_32 zLowerRight
}

// EraseQuad
//  Erase the visualized quad with the specified ID
message EraseQuad {
  uint_32 quadID
}


///////////////////////////////////////////////////////////////////////////////
// Animation Commands
///////////////////////////////////////////////////////////////////////////////

// ReplayLastAnimation
message ReplayLastAnimation {
    uint_8  robotID,
    uint_32 numLoops
}

// SetIdleAnimation
//  Set the animation group that will be played (in a continuous loop) if no other
//  animation has been set using PlayAnimation above.
//  Use Count to disable the idle animation.
message SetIdleAnimation {
    uint_8 robotID,
    AnimationTrigger animTrigger
}

// PushIdleAnimation
//  Switches the idle animation (the one played in a continuous loop while no other
//  animation is requested via PlayAnimation) to the one specified.
message PushIdleAnimation {
    AnimationTrigger animTrigger
}

// PopIdleAnimation
//  Stops using the last pushed idle animation and goes back to whatever was
//  previously the idle.
message PopIdleAnimation {

}

// ReadFaceAnimationDir
message ReadFaceAnimationDir {
}

// ReadAnimationFile
message ReadAnimationFile {
}

// RequestAvailableAnimations
message RequestAvailableAnimations{
  
}

// RequestAvailableAnimationGroups
message RequestAvailableAnimationGroups{
  
}

message SetLiveIdleAnimationParameters {
  LiveIdleAnimationParameter   paramNames[uint_8],
  float_32                     paramValues[uint_8], // must be same length as paramNames
  uint_8                       robotID,
  bool                         setUnspecifiedToDefault = 0
}

// PushDrivingAnimations
message PushDrivingAnimations {
    AnimationTrigger drivingStartAnim,
    AnimationTrigger drivingLoopAnim,
    AnimationTrigger drivingEndAnim
}

message PopDrivingAnimations {

}


///////////////////////////////////////////////////////////////////////////////
// Robot / Cube LED Controls
///////////////////////////////////////////////////////////////////////////////

message SetHeadlight
{
  bool enable
}

message SetActiveObjectLEDs {
    uint_32  objectID,
    uint_32  onColor,
    uint_32  offColor,
    uint_32  onPeriod_ms,
    uint_32  offPeriod_ms,
    uint_32  transitionOnPeriod_ms,  // The fade period from off color to on color
    uint_32  transitionOffPeriod_ms,  // The fade period from on color to off color
    int_32   offset = 0,
    uint_32  rotationPeriod_ms = 0,
    float_32 relativeToX,  // ignored if makeRelative is RELATIVE_LED_MODE_OFF
    float_32 relativeToY,  // ignored if makeRelative is RELATIVE_LED_MODE_OFF
    WhichCubeLEDs   whichLEDs,
    MakeRelativeMode   makeRelative,
    uint_8   turnOffUnspecifiedLEDs, // whether to augment current pattern, or turn off everything but what's specified
    uint_8   robotID
}


// See SetActiveObjectLEDs for parameter documentation
message SetAllActiveObjectLEDs {
  uint_32  objectID,
  uint_32  onColor[4],
  uint_32  offColor[4],
  uint_32  onPeriod_ms[4],
  uint_32  offPeriod_ms[4],
  uint_32  transitionOnPeriod_ms[4],
  uint_32  transitionOffPeriod_ms[4],
  int_32   offset[4],
  uint_32  rotationPeriod_ms,
  float_32 relativeToX,
  float_32 relativeToY,
  MakeRelativeMode makeRelative,
  uint_8   robotID
}

// SetBackpackLEDs
//  See ledTypes.h for the enumeration of the available backpack LEDs.
message SetBackpackLEDs {
  uint_32  onColor[5],
  uint_32  offColor[5],
  uint_32  onPeriod_ms[5],
  uint_32  offPeriod_ms[5],
  uint_32  transitionOnPeriod_ms[5],
  uint_32  transitionOffPeriod_ms[5],
  int_32   offset[5],
  uint_8   robotID
}

// Enables/disables specific cube light states
message EnableLightStates {
  bool enable,
  int_32 objectID = -1 // -1 is to enable/disable all cube light states
}

message EnableCubeSleep {
  bool enable,
  bool skipAnimation = 0 // If true will skip the fadeout part of the sleep anim
}

// Whether or not engine should be sending CubeLightsStateTransition messages to game
message EnableCubeLightsStateTransitionMessages {
  bool enable
}

// Makes the specified object flash its lights
message FlashCurrentLightsState {
  uint_32 objectID
}

// Plays a cube animation on the specified object
message PlayCubeAnim {
  uint_32 objectID,
  CubeAnimationTrigger trigger
}

// Stops a cube animation that is playing on the specified object
message StopCubeAnim {
  uint_32 objectID,
  CubeAnimationTrigger trigger
}

message StreamObjectAccel
{
  uint_32 objectID,
  bool enable
}

///////////////////////////////////////////////////////////////////////////////
// Onboarding
///////////////////////////////////////////////////////////////////////////////

message TransitionToNextOnboardingState {
}

///////////////////////////////////////////////////////////////////////////////
// Mood / Emotions
///////////////////////////////////////////////////////////////////////////////

structure GetEmotions {
}

structure SetEmotion {
  EmotionType emotionType,
  float_32 newVal
}

structure AddToEmotion {
  EmotionType emotionType,
  float_32 deltaVal,
  string uniqueIdString
}

structure TriggerEmotionEvent {
  string emotionEventName
}

union MoodMessageUnion {
  GetEmotions  GetEmotions,
  SetEmotion   SetEmotion,
  AddToEmotion AddToEmotion,
  TriggerEmotionEvent TriggerEmotionEvent
}

message MoodMessage {
  uint_8  robotID,
  MoodMessageUnion  MoodMessageUnion
}

///////////////////////////////////////////////////////////////////////////////
// Needs
///////////////////////////////////////////////////////////////////////////////

message GetNeedsState {
}

message SetNeedsPauseState {
  bool pause
}

message GetNeedsPauseState {
}

message SetNeedsPauseStates {
  bool decayPause[uint_8],
  bool actionPause[uint_8]
}

message GetNeedsPauseStates {
}

message RegisterNeedsActionCompleted {
  NeedsActionId actionCompleted
}

///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////

structure SetFriendshipPoints {
  int_32 newVal
}

structure SetFriendshipLevel {
  int_32 newVal
}

union ProgressionMessageUnion {
  SetFriendshipPoints  SetFriendshipPoints,
  SetFriendshipLevel   SetFriendshipLevel
}

message ProgressionMessage {
  uint_8  robotID,
  ProgressionMessageUnion  ProgressionMessageUnion
}

// Progression unlocks
message RequestSetUnlock {
  UnlockId unlockID,
  bool unlocked
}

// Request engine to send data like device id, app run id, etc
message RequestDeviceData {

}

///////////////////////////////////////////////////////////////////////////////
// Debug / Logging
///////////////////////////////////////////////////////////////////////////////

message SetDebugConsoleVarMessage {
  string varName,
  string tryValue
}

message RunDebugConsoleFuncMessage {
  string funcName,
  string funcArgs
}

message GetDebugConsoleVarMessage {
  string varName
}

message GetAllDebugConsoleVarMessage {
}

message GetJsonDasLogsMessage {
}


// Message to disable path speed randomization (useful for webots tests)
message SetEnableSpeedChooser {
  bool enabled
}


///////////////////////////////////////////////////////////////////////////////
// BlockPool
///////////////////////////////////////////////////////////////////////////////

message BlockPoolEnabledMessage {
  float_32 discoveryTimeSecs,
  bool enabled
}

message BlockSelectedMessage {
  uint_32 factoryId,
  ObjectType objectType,
  bool   selected
}
// Query for E2Gmessage: InitBlockPoolMessage
message GetBlockPoolMessage {
}

message SendAvailableObjects {
  uint_8 robotID,
  bool enable
}

// Resets blockpool
message BlockPoolResetMessage {
  bool enable = 1, // Enables/disables blockpool after resetting
  bool maintainPersistentPool = 0 // If true prevents the PersistentPool from being cleared
}


///////////////////////////////////////////////////////////////////////////////
// Camera calibration
///////////////////////////////////////////////////////////////////////////////

message SaveCalibrationImage {
  uint_8 robotID,
}

message ClearCalibrationImages {
  uint_8 robotID,
}

message ComputeCameraCalibration {
  uint_8 robotID,
}

///////////////////////////////////////////////////////////////////////////////
// Communicating UI interactions
///////////////////////////////////////////////////////////////////////////////

message ContinueFreeplayFromIdle{
}

message EnableDroneMode {
  bool   isStarted
}

///////////////////////////////////////////////////////////////////////////////
// SDK Specific
///////////////////////////////////////////////////////////////////////////////

message EnterSdkMode {
  bool isExternalSdkMode = 1
}

message ExitSdkMode {
bool isExternalSdkMode = 1
}

message SetStopRobotOnSdkDisconnect {
  bool doStop = 1
}

message StopRobotForSdk {
}

message SetShouldAutoConnectToCubesAtStart {
  bool doAutoConnect = 0
}

message SetShouldAutoDisconnectFromCubesAtEnd {
  bool doAutoDisconnect = 0
}

// Upload animations
enum uint_8 FileType {
  Animation,
  FaceImg,
}

message TransferFile {
  uint_8   fileBytes[uint_16],
  uint_8   filePart,
  uint_8   numFileParts,
  string   filename,
  FileType   fileType
}

///////////////////////////////////////////////////////////////////////////////
// Robot flash (non-volatile storage)
///////////////////////////////////////////////////////////////////////////////

// All non-volatile storage operations result in a NVStorageOpResult message
// being sent back from engine upon completion except for single-blob reads.
// Whether or not an entry is single blob or multi-blob entry is determined by
// the NVEntryTag value.
// NOTE: Do not follow one operation with another before acking the previous
//       operation as the flash can only handle one at a time.
//       The only exception is you can send multiple NVStorageWriteEntry messages
//       for a multi-blob message since these don't actually get sent to robot
//       until all blobs have been received by engine.

// Erase an entry from non-volatile storage
message NVStorageEraseEntry {
  NVStorage::NVEntryTag tag
}

// Erase all entries from non-volatile storage
// (not including factory partition)
// NOTE: THIS MESSAGE FORCES A ROBOT REBOOT CAUSING DISCONNECT.
message NVStorageWipeAll {
  string key            // This must be "Yes I really want to do this!" otherwise the operation will fail.
}

// Multi-blob messages (numTotalBlobs > 1) are queued on engine
// and sent out all at once only when all blobs have been received.
// (This also means that writes won't be ackd with NVStorageOpResult until all
// blobs have been sent to engine, unless there's a problem found before all the blobs
// have been received in which case engine will send an NVStorageOpResult failure for
// each problematic NVStorageWriteEntry received.)
// This is to help make it harder to write junk to the robot.
// Single-blob messages (numTotalBlobs == 1) are sent to robot immediately.
message NVStorageWriteEntry {
  NVStorage::NVEntryTag tag,
  uint_8  data[uint_16],
  uint_8  index,         // Starts at 0
  uint_8  numTotalBlobs  // Total number of blobs expected
}

// Clears any queued data received by engine for a multi-blob entry via NVStorageWriteEntry.
// Does not directly affect robot flash.
// This should be called once before sending a sequence of NVStorageWriteEntry messages
// for a mult-blob entry. It should only be necessary if something went wrong
// with a previous write attempt, but doesn't hurt to call it every time.
message NVStorageClearPartialPendingWriteEntry {
}

// Data is returned in NVStorageData messages.
// If multi-blob entry, game will have to dechunk.
message NVStorageReadEntry {
  NVStorage::NVEntryTag tag
}

// Enable/disable auto exposure
// If enableAutoExposure == false then exposure and gain are set to the specified values
// If enableAutoExposure == true then exposure and gain fields are ignored
message SetCameraSettings {
  bool enableAutoExposure,
  uint_16 exposure_ms,
  float_32 gain
}

// Request robot sends back any per-robot settings
message RequestRobotSettings {
}

// explicit autounion - this will force the values given, and then add every other messages in this file
// if you do not want to include messages in this union, use the keyword "structure" instead of "message"
// DO NOT CHANGE ANY EXPLICITELY DECLARED VALUES - they must be compatible across all versions so we can reliably
// handshake between and App and SDK version combination
autounion MessageGameToEngine
{
  UiDeviceConnectionWrongVersion          UiDeviceConnectionWrongVersion          = 0x00, // DO NOT CHANGE THIS VALUE
}


} // namespace U2G
} // namespace Cozmo
} // namespace Anki
