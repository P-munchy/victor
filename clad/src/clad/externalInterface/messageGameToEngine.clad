// UiMessageDefinitions message definition file
//  for the C-Like Abstract Data language
// Author: Greg Nagel
// Copyright: Anki Inc (c) 2015

#include "clad/types/actionTypes.clad"
#include "clad/types/imageTypes.clad"
#include "clad/types/robotTestModes.clad"
#include "clad/types/proceduralEyeParameters.clad"
#include "clad/types/demoBehaviorState.clad"
#include "clad/types/behaviorType.clad"
#include "clad/types/behaviorChooserType.clad"
#include "clad/types/emotionTypes.clad"
#include "clad/types/debugConsoleTypes.clad"
#include "clad/types/progressionStatTypes.clad"
#include "clad/types/activeObjectTypes.clad"
#include "clad/types/pathMotionProfile.clad"
#include "clad/externalInterface/messageShared.clad"
#include "clad/externalInterface/keyWordRecognitionState.clad"
#include "clad/types/liveIdleAnimationParameters.clad"
#include "clad/types/globalVizOrigin.clad"
#include "clad/audio/audioMessage.clad"
#include "clad/types/visionModes.clad"

namespace Anki {
namespace Cozmo {
namespace ExternalInterface {

message ConnectToRobot {
    uint_8 robotID
}

// ConnectToUiDevice
message ConnectToUiDevice {
    uint_8 deviceID
}

// DisconnectFromUiDevice
message DisconnectFromUiDevice {
    uint_8 deviceID
}

// ForceAddRobot
// NOTE: This can be removed once physical robots can advertise (e.g. with BLE
message ForceAddRobot {
    uint_8 ipAddress[16],
    uint_8 robotID,
    uint_8 isSimulated
}

// StartEngine
// Tell game to start the engine with the configuration specified by the message members.
message StartEngine {
    uint_8 asHost,
    uint_8 vizHostIP[16] // if first char is '\0' disables viz
}

// DriveWheels
message DriveWheels {
    float_32 lwheel_speed_mmps,
    float_32 rwheel_speed_mmps
}

// TurnInPlace
// If isAbsolute == 0, turns the specified number of radians, *relative to the robot's current heading*
// If isAbsolute != 0, turns to the specified absolute orientation.
message TurnInPlace {
    float_32 angle_rad, // relative mode: postive turns left negative turns right
    uint_8 isAbsolute,    // 0: angle_rad is relative to current orientation, 1: angle_rad is absolute angle to turn to
    uint_8 robotID
}

// TurnInPlaceAtSpeed
message TurnInPlaceAtSpeed {
    float_32 speed_rad_per_sec,
    float_32 accel_rad_per_sec2,
    uint_8 robotID
}

// FaceObject - Turns and tilts head to look at object in last known position
//   If facing the object requires less than a turnAngleTol turn, then no
//   turn is performed. If a turn greater than maxTurnAngle is required,
//   the action fails. For angles in between, the robot will first turn
//   to face the object, then tilt its head. To completely disallow turning,
//   set maxTurnAngle to zero. (All angles in radians and forced to be positive.)
//   Set headTrackWhenDone to non-zero to enable head tracking to the specified
//   object once the robot has successfully faced it.
message FaceObject {
    uint_32  objectID,
    float_32 turnAngleTol,
    float_32 maxTurnAngle,

    // A value of 0 means 'Don't care' (i.e. use engine's default value)
    float_32 maxPanSpeed_radPerSec = 0.0,
    float_32 panAccel_radPerSec2 = 0.0,
    float_32 panTolerance_rad = 0.0,
    float_32 maxTiltSpeed_radPerSec = 0.0,
    float_32 tiltAccel_radPerSec2 = 0.0,
    float_32 tiltTolerance_rad = 0.0,

    uint_8   robotID,
    uint_8   visuallyVerifyWhenDone,
    uint_8   headTrackWhenDone
}

// FacePose
//  Tell the robot to turn and tilt his head to face a give 3D pose in world
//  coordinates.
message FacePose {
    float_32 world_x,
    float_32 world_y,
    float_32 world_z,
    float_32 turnAngleTol,
    float_32 maxTurnAngle,

    // A value of 0 means 'Don't care' (i.e. use engine's default value)
    float_32 maxPanSpeed_radPerSec = 0.0,
    float_32 panAccel_radPerSec2 = 0.0,
    float_32 panTolerance_rad = 0.0,
    float_32 maxTiltSpeed_radPerSec = 0.0,
    float_32 tiltAccel_radPerSec2 = 0.0,
    float_32 tiltTolerance_rad = 0.0,

    uint_8   robotID
}

// MoveHead
message MoveHead {
    float_32 speed_rad_per_sec
}

// MoveLift
message MoveLift {
    float_32 speed_rad_per_sec
}

// SetLiftHeight
message SetLiftHeight {
    float_32 height_mm,
    float_32 max_speed_rad_per_sec,
    float_32 accel_rad_per_sec2,
    float_32 duration_sec
}

// EnableLiftPower
message EnableLiftPower {
    bool enable
}


// SetHeadAngle
message SetHeadAngle {
    float_32 angle_rad,
    float_32 max_speed_rad_per_sec,
    float_32 accel_rad_per_sec2,
    float_32 duration_sec
}

// TrackToObject
//   Robot will automatically adjust head and body angle to look at this object ID, if it
//   is observed. Sending SetHeadAngle message (above) will disable this behavior.
//   Set headOnly to true to only use the head and not turn the body.
//   Use objectID = u32_MAX to disable tracking.
message TrackToObject {
    uint_32 objectID,
    uint_8  robotID,
    bool    headOnly
}

// TrackToFace
//   Robot will automatically adjust head and body angle to look at this face ID, if it
//   is observed. Sending SetHeadAngle message (above) will disable this behavior.
//   Set headOnly to true to only use the head and not turn the body.
//   Use objectID = u32_MAX to disable tracking.
message TrackToFace {
    uint_32 faceID,
    uint_8  robotID,
    bool    headOnly
}

// StopAllMotors
message StopAllMotors {
}

// ImageRequest
message ImageRequest {
    uint_8 robotID,
    ImageSendMode mode
}

// SetRobotImageSendMode
// NOTE: This can enable/disable streaming of images from the physical robot.
//       It is intended for dev use since the robot will likely always stream
//       its image in the product.
message SetRobotImageSendMode {
    uint_8 robotID,
    ImageSendMode mode,
    ImageResolution resolution
}

// SaveImages
message SaveImages {
    uint_8 mode // See SaveMode_t in cozmoTypes.h
}

// SaveRobotState
message SaveRobotState {
    uint_8 mode // See SaveMode_t in cozmoTypes.h
}

// EnableDisplay
message EnableDisplay {
    uint_8 enable
}

// GotoPose
message GotoPose {
    float_32 x_mm,
    float_32 y_mm,
    float_32 rad,
    PathMotionProfile motionProf,
    uint_8 level,
    bool useManualSpeed
}

// GotoObject
message GotoObject {
    int_32 objectID,
    PathMotionProfile motionProf,
    float_32 distanceFromObjectOrigin_mm,
    bool useManualSpeed
}

// AlignWithObject
// "Docks" to object so that it is aligned with it at the specified distance
message AlignWithObject {
    int_32 objectID,
    PathMotionProfile motionProf,
    float_32 distanceFromMarker_mm,
    float_32 approachAngle_rad,
    bool useApproachAngle,
    bool usePreDockPose,
    bool useManualSpeed
}

// PlaceObjectOnGround
message PlaceObjectOnGround {
    float_32 x_mm,
    float_32 y_mm,
    float_32 qw,             // Specify rotation via quaternion
    float_32 qx,
    float_32 qy,
    float_32 qz,
    PathMotionProfile motionProf,
    uint_8 level,
    bool useManualSpeed,
    bool useExactRotation    // If true, then tries to place object at the exact rotation specified by the quaternion
                             // otherwise it chooses the closest preActionPose such the object is aligned with the quaternion rotation.
}

// PlaceObjectOnGroundHere
message PlaceObjectOnGroundHere {
}

// ExecuteTestPlans
message ExecuteTestPlan {
PathMotionProfile motionProf
}

// SelectNextObject
message SelectNextObject {
}

// PickupObject
// @param useApproachAngle  - If true, then only the preAction pose that results in a robot
//                            approach angle closest to approachAngle_rad is considered.
// @param approachAngle_rad - The desired docking approach angle of the robot in world coordinates.
message PickupObject {
    int_32 objectID, // negative value means "currently selected object"
    PathMotionProfile motionProf,
    float_32 approachAngle_rad,
    bool   useApproachAngle,
    bool usePreDockPose,
    bool useManualSpeed,
}

// PlaceOnObject
// Places the carried object on top of objectID.
// @param useExactRotation - If true, then only the preAction pose that results in the carried object
//                           being placed in alignment with objectID that is closest to the specified
//                           quaternion rotation is considered.
//                           If the up-axis of the current rotation is not the same as that of the
//                           currently carried object, the action fails.
message PlaceOnObject {
    int_32 objectID, // negative value means "currently selected object"
    PathMotionProfile motionProf,
    float_32 approachAngle_rad,
    bool   useApproachAngle,
    bool usePreDockPose,
    bool useManualSpeed,
}

// PlaceRelObject
// @param placementOffsetX_mm - The desired distance between the center of the docking marker
//                              and the center of the object that is being placed, along the
//                              direction of the docking marker's normal.
// @param useApproachAngle  - If true, then only the preAction pose that results in a robot
//                            approach angle closest to approachAngle_rad is considered.
// @param approachAngle_rad - The desired docking approach angle of the robot in world coordinates.
message PlaceRelObject {
    int_32 objectID, // negative value means "currently selected object"
    PathMotionProfile motionProf,
    float_32 placementOffsetX_mm,  // X-axis offset for object placement (where +x extends out the marker face)
    float_32 approachAngle_rad,
    bool   useApproachAngle,
    bool usePreDockPose,
    bool useManualSpeed,
}

// RollObject
message RollObject {
  int_32 objectID, // negative value means "currently selected object"
  PathMotionProfile motionProf,
  float_32 approachAngle_rad,
  bool   useApproachAngle,
  bool usePreDockPose,
  bool useManualSpeed
}

// PopAWheelie
message PopAWheelie {
  int_32 objectID, // negative value means "currently selected object"
  PathMotionProfile motionProf,
  float_32 approachAngle_rad,
  bool useApproachAngle,
  bool usePreDockPose,
  bool useManualSpeed
}

// MountCharger
message MountCharger {
  int_32 objectID,
  PathMotionProfile motionProf,
  bool usePreDockPose,
  bool useManualSpeed
}

// TraverseObject
message TraverseObject {
  PathMotionProfile motionProf,
  bool usePreDockPose,
  bool useManualSpeed
}

// SetRobotCarryingObject
// (Override robot's current belief about whether it's carrying a block)
// (Ideally, for dev/prototyping only)
message SetRobotCarryingObject {
    int_32 objectID, // use -1 to specify "none"
    uint_8 robotID
}

// ClearAllBlocks
//   Clears just blocks (active and passive)
message ClearAllBlocks {
    uint_8 robotID
}

// ClearAllObjects
//   Clears all objects the robot knows about (blocks, ramps, mats, etc)
message ClearAllObjects {
    uint_8 robotID
}

message SetObjectAdditionAndDeletion {
    uint_8 robotID,
    bool   enableAddition,
    bool   enableDeletion
}

// VisionWhileMoving
// For development, enable/disable robots' ability to use VisionMarkers while moving
// May be necessary to have this disabled while we have frame sync issues.
// NOTE: This will apply to all robots currently connected.
message VisionWhileMoving {
    uint_8 enable // True or false
}

// SetBehaviorSystemEnabled
message SetBehaviorSystemEnabled {
  bool enabled
}

// ActivateBehaviorChooser
message ActivateBehaviorChooser {
  BehaviorChooserType behaviorChooserType
}

// ExecuteBehavior
message ExecuteBehavior {
  BehaviorType behaviorType
}

// AbortPath
message AbortPath {
}

// AbortAll
message AbortAll {
}

// CancelAction
//  Use actionType to cancel any queued actions of the specified type.
//  Use actionType = -1 to cancel all actions, regardless of type.
message CancelAction {
  RobotActionType actionType,  // See actionTypes.def
//  int_32 slotHandle,  // TODO: Add this later if it makes sense
  uint_8 robotID
}

// DrawPoseMarker
message DrawPoseMarker {
    float_32 x_mm,
    float_32 y_mm,
    float_32 rad,
    uint_8 level
}

// ErasePoseMarker
message ErasePoseMarker {
}

// SetWheelControllerGains
message SetWheelControllerGains {
  float_32 kpLeft,
  float_32 kiLeft,
  float_32 maxIntegralErrorLeft,
  float_32 kpRight,
  float_32 kiRight,
  float_32 maxIntegralErrorRight
}

// SetHeadControllerGains
message SetHeadControllerGains {
    float_32 kp,
    float_32 kd,
    float_32 ki,
    float_32 maxIntegralError
}

// SetLiftControllerGains
message SetLiftControllerGains {
    float_32 kp,
    float_32 kd,
    float_32 ki,
    float_32 maxIntegralError
}

// SetSteeringControllerGains
message SetSteeringControllerGains {
  float_32 k1,
  float_32 k2,
  float_32 dockPathDistOffsetCap_mm,
  float_32 dockPathAngularOffsetCap_rad
}

// SetRobotVolume
message SetRobotVolume {
  float_32 volume
}

// StartTestMode
message StartTestMode {
    uint_8  robotID,
    int_32 p1,
    int_32 p2,
    int_32 p3,
    TestMode mode
}

// IMURequest
message IMURequest {
    uint_32 length_ms
}

// Enable/Disable paralysis of motors on pickup
message EnableRobotPickupParalysis
{
    bool enable
}

// PlayAnimation
message PlayAnimation {
    uint_8  robotID,
    uint_32 numLoops,
    string animationName
}

// ReplayLastAnimation
message ReplayLastAnimation {
    uint_8  robotID,
    uint_32 numLoops
}

// SetIdleAnimation
//  Set the animation that will be played (in a continuous loop) if no other
//  animation has been set using PlayAnimation above.
//  Use the empty string to disable the idle animation.
message SetIdleAnimation {
    uint_8 robotID,
    string animationName
}

// ReadAnimationFile
message ReadAnimationFile {
}

message EnableVisionMode {
   VisionMode mode,
   bool       enable
}

// SetActiveObjectLEDs
message SetActiveObjectLEDs {
    uint_32  objectID,
    uint_32  onColor,
    uint_32  offColor,
    uint_32  onPeriod_ms,
    uint_32  offPeriod_ms,
    uint_32  transitionOnPeriod_ms,
    uint_32  transitionOffPeriod_ms,
    float_32 relativeToX,
    float_32 relativeToY,
    WhichCubeLEDs   whichLEDs,
    MakeRelativeMode   makeRelative,
    uint_8   turnOffUnspecifiedLEDs, // whether to augment current pattern, or turn off everything but what's specified
    uint_8   robotID
}

// SetAllActiveObjectLEDs
message SetAllActiveObjectLEDs {
  uint_32  objectID,
  uint_32  onColor[4],
  uint_32  offColor[4],
  uint_32  onPeriod_ms[4],
  uint_32  offPeriod_ms[4],
  uint_32  transitionOnPeriod_ms[4],
  uint_32  transitionOffPeriod_ms[4],
  float_32 relativeToX,
  float_32 relativeToY,
  MakeRelativeMode   makeRelative,  // if 0, ignores relativeX/relativeY
  uint_8   robotID
}

// SetBackpackLEDs
//  See ledTypes.h for the enumeration of the available backpack LEDs.
message SetBackpackLEDs {
  uint_32  onColor[5],
  uint_32  offColor[5],
  uint_32  onPeriod_ms[5],
  uint_32  offPeriod_ms[5],
  uint_32  transitionOnPeriod_ms[5],
  uint_32  transitionOffPeriod_ms[5],
  uint_8   robotID
}

// DisplayProceduralFace
message DisplayProceduralFace {
  float_32 faceAngle,        // Degrees
  float_32 faceCenX,
  float_32 faceCenY,
  float_32 faceScaleX,
  float_32 faceScaleY,
  float_32 leftEye[uint_8],  // TODO: make this fixed length = ProceduralEyeParameter::NumParameters
  float_32 rightEye[uint_8], //
  uint_8   robotID
}

message SetLiveIdleAnimationParameters {
  LiveIdleAnimationParameter   paramNames[uint_8],
  float_32                     paramValues[uint_8], // must be same length as paramNames
  uint_8                       robotID,
  bool                         setUnspecifiedToDefault = 0
}

// VisualizeQuad
//  Draws the specified quadrilateral using the Visualization system.
//  The quadID will be created if new or replaced if it already exists (i.e., you
//  do not need to send an EraseQuad message before updating an existing quad).
message VisualizeQuad {
  uint_32 quadID,
  uint_32 color, // RGBA
  float_32 xUpperLeft,
  float_32 yUpperLeft,
  float_32 zUpperLeft,
  float_32 xLowerLeft,
  float_32 yLowerLeft,
  float_32 zLowerLeft,
  float_32 xUpperRight,
  float_32 yUpperRight,
  float_32 zUpperRight,
  float_32 xLowerRight,
  float_32 yLowerRight,
  float_32 zLowerRight
}

// EraseQuad
//  Erase the visualized quad with the specified ID
message EraseQuad {
  uint_32 quadID
}

union RobotActionUnion {
  FaceObject         faceObject,
  FacePose           facePose,
  GotoPose           goToPose,
  GotoObject         goToObject,
  AlignWithObject    alignWithObject,
  PlayAnimation      playAnimation,
  PickupObject       pickupObject,
  PlaceOnObject      placeOnObject,
  PlaceRelObject     placeRelObject,
  RollObject         rollObject,
  PopAWheelie        popAWheelie,
  SetLiftHeight      setLiftHeight,
  SetHeadAngle       setHeadAngle,
  TurnInPlace        turnInPlace,
  TrackToFace        trackFace,
  TrackToObject      trackObject
}

// QueueSingleAction
message QueueSingleAction {
  uint_8  robotID,
  uint_32 idTag,  // caller-specified identifier that will be returned with the completion message
  uint_32 inSlot,
  uint_8  numRetries,
  QueueActionPosition    position,
  RobotActionUnion       action
}

// QueueCompoundAction
message QueueCompoundAction {
  uint_8  robotID,
  uint_32 idTag,   // caller-specified identifier that will be returned with the completion message
  uint_32 inSlot,
  uint_8  numRetries,
  bool  parallel,  // false means sequential
  QueueActionPosition    position,
  RobotActionUnion       actions[uint_8]
}

message SetDemoState {
  DemoBehaviorState demoState
}

message ForceDelocalizeRobot {
  uint_8 robotID
}

// Mood / Emotions

message GetEmotions {
}

message SetEmotion {
  EmotionType emotionType,
  float_32 newVal
}

message AddToEmotion {
  EmotionType emotionType,
  float_32 deltaVal,
  string uniqueIdString
}

message TriggerEmotionEvent {
  string emotionEventName
}

union MoodMessageUnion {
  GetEmotions  GetEmotions,
  SetEmotion   SetEmotion,
  AddToEmotion AddToEmotion,
  TriggerEmotionEvent TriggerEmotionEvent
}

message MoodMessage {
  uint_8  robotID,
  MoodMessageUnion  MoodMessageUnion
}

// Progression / Stats

message GetProgressionStats {
}

message SetProgressionStat {
  ProgressionStatType statType,
  uint_32 newVal
}

message AddToProgressionStat {
  ProgressionStatType statType,
  uint_32 deltaVal
}

union ProgressionMessageUnion {
  GetProgressionStats  GetProgressionStats,
  SetProgressionStat   SetProgressionStat,
  AddToProgressionStat AddToProgressionStat
}

message ProgressionMessage {
  uint_8  robotID,
  ProgressionMessageUnion  ProgressionMessageUnion
}


// Debug console set
message SetDebugConsoleVarMessage {
  string varName,
  string tryValue
}
message RunDebugConsoleFuncMessage {
  string funcName,
  string funcArgs
}
message GetDebugConsoleVarMessage {
  string varName,
  ConsoleVarUnion varValue
}
message GetAllDebugConsoleVarMessage {
}

// keep empty to generate an auto-union that includes all messages in this file
// if you do not want to include messages in this union, use the keyword "structure" instead of "message"
union MessageGameToEngine { }

} // namespace U2G
} // namespace Cozmo
} // namespace Anki
