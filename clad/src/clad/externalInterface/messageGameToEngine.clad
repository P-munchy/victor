// UiMessageDefinitions message definition file
//  for the C-Like Abstract Data language
// Author: Greg Nagel
// Copyright: Anki Inc (c) 2015

#include "clad/audio/audioMessage.clad"

#include "clad/externalInterface/messageActions.clad"
#include "clad/externalInterface/messageShared.clad"
#include "clad/externalInterface/messageToBehaviorManager.clad"
#include "clad/externalInterface/keyWordRecognitionState.clad"

#include "clad/types/actionTypes.clad"
#include "clad/types/activeObjectTypes.clad"
#include "clad/types/behaviorGroup.clad"
#include "clad/types/behaviorTypes.clad"
#include "clad/types/behaviorChooserType.clad"
#include "clad/types/controllerChannels.clad"
#include "clad/types/debugConsoleTypes.clad"
#include "clad/types/emotionTypes.clad"
#include "clad/types/faceEnrollmentPoses.clad"
#include "clad/types/globalVizOrigin.clad"
#include "clad/types/imageTypes.clad"
#include "clad/types/liveIdleAnimationParameters.clad"
#include "clad/types/nvStorageTypes.clad"
#include "clad/types/pathMotionProfile.clad"
#include "clad/types/proceduralEyeParameters.clad"
#include "clad/types/robotTestModes.clad"
#include "clad/types/sayTextStyles.clad"
#include "clad/types/uiConnectionTypes.clad"
#include "clad/types/unlockTypes.clad"
#include "clad/types/visionModes.clad"


namespace Anki {
namespace Cozmo {
namespace ExternalInterface {

///////////////////////////////////////////////////////////////////////////////
// Communication / Connectivity
///////////////////////////////////////////////////////////////////////////////

message ConnectToRobot {
    uint_8 ipAddress[16],
    uint_8 robotID,
    uint_8 isSimulated
}

// ConnectToUiDevice
message ConnectToUiDevice {
    UiConnectionType  connectionType,
    uint_8 deviceID
}

// DisconnectFromUiDevice
message DisconnectFromUiDevice {
    UiConnectionType  connectionType,
    uint_8 deviceID
}

// StartEngine
// Tell the engine to start running.
message StartEngine {
}

message ReliableTransportRunMode {
  bool isSync
}


///////////////////////////////////////////////////////////////////////////////
// Low-level Robot Controls
///////////////////////////////////////////////////////////////////////////////

// UpdateFirmware
// Tell the engine to start updating the robot firmware to specific version
message UpdateFirmware {
  int_32 version
}

// ResetFirmware
// Tell the engine to kill robot body code and reset to factory defaults
message ResetFirmware {
}

// DriveWheels
message DriveWheels {
    float_32 lwheel_speed_mmps,
    float_32 rwheel_speed_mmps,
    float_32 lwheel_accel_mmps2 = 0.0,
    float_32 rwheel_accel_mmps2 = 0.0
}

// MoveHead
message MoveHead {
    float_32 speed_rad_per_sec
}

// MoveLift
message MoveLift {
    float_32 speed_rad_per_sec
}

// EnableLiftPower
message EnableLiftPower {
    bool enable
}

message EnableCliffSensor {
    bool enable
}

// StopAllMotors
message StopAllMotors {

}

// ControllerGains
message ControllerGains
{
  float_32 kp,
  float_32 ki,
  float_32 kd,
  float_32 maxIntegralError,
  ControllerChannel controller
}

message SetMotionModelParams
{
  float_32 slipFactor,
}

// SetRobotVolume
message SetRobotVolume {
  uint_8   robotId,
  float_32 volume
}


// !!! Be sure to update RobotAudioOutputSource in robotAudioClient.h if this enum is updated. !!!
enum uint_8 RobotAudioOutputSourceCLAD
{
  NoDevice,       // No audio
  PlayOnDevice,   // Play on Device - This is not perfectly synced to animations
  PlayOnRobot     // Play on Robot by using Hijack Audio plug-in to get audio stream from Wwise
}

message SetRobotAudioOutputSource
{
  RobotAudioOutputSourceCLAD source
}

// Enable/Disable paralysis of motors on pickup
message EnableRobotPickupParalysis
{
   bool enable
}

message ForceDelocalizeRobot {
  uint_8 robotID
}

// IMURequest
message IMURequest {
    uint_32 length_ms
}

///////////////////////////////////////////////////////////////////////////////
// Action Queuing Commands  (Actions themselves are in messageActions.clad!)
///////////////////////////////////////////////////////////////////////////////

// CancelAction
//  Use actionType to cancel any queued actions of the specified type.
//  Use actionType = -1 to cancel all actions, regardless of type.
message CancelAction {
  RobotActionType actionType,  // See actionTypes.def
  uint_8 robotID
}

// QueueSingleAction
  message QueueSingleAction {
  uint_8  robotID,
  uint_32 idTag,  // caller-specified identifier that will be returned with the completion message
  uint_8  numRetries,
  QueueActionPosition    position,
  RobotActionUnion       action
}

// QueueCompoundAction
message QueueCompoundAction {
  uint_8  robotID,
  uint_32 idTag,   // caller-specified identifier that will be returned with the completion message
  uint_8  numRetries,
  bool  parallel,  // false means sequential
  QueueActionPosition    position,
  RobotActionUnion       actions[uint_8]
}



///////////////////////////////////////////////////////////////////////////////
// Image-Related Commands
///////////////////////////////////////////////////////////////////////////////

// ImageRequest
message ImageRequest {
    uint_8 robotID,
    ImageSendMode mode
}

// SetRobotImageSendMode
// NOTE: This can enable/disable streaming of images from the physical robot.
//       It is intended for dev use since the robot will likely always stream
//       its image in the product.
message SetRobotImageSendMode {
    uint_8 robotID,
    ImageSendMode mode,
    ImageResolution resolution
}

// SaveImages
message SaveImages {
    uint_8 mode // See SaveMode_t in cozmoTypes.h
}


// SaveRobotState
message SaveRobotState {
    uint_8 mode // See SaveMode_t in cozmoTypes.h
}

// EnableDisplay
message EnableDisplay {
    uint_8 enable
}

// ExecuteTestPlans
message ExecuteTestPlan {
PathMotionProfile motionProf
}

// SelectNextObject
message SelectNextObject {

}

// SetRobotCarryingObject
// (Override robot's current belief about whether it's carrying a block)
// (Ideally, for dev/prototyping only)
message SetRobotCarryingObject {
    int_32 objectID, // use -1 to specify "none"
    uint_8 robotID
}

///////////////////////////////////////////////////////////////////////////////
// Vision Settings and Commands
///////////////////////////////////////////////////////////////////////////////

// ClearAllBlocks
//   Clears just blocks (active and passive)
message ClearAllBlocks {
    uint_8 robotID
}

// ClearAllObjects
//   Clears all objects the robot knows about (blocks, faces, ramps, mats, etc)
message ClearAllObjects {
    uint_8 robotID
}

message SetObjectAdditionAndDeletion {
    uint_8 robotID,
    bool   enableAddition,
    bool   enableDeletion
}

// VisionWhileMoving
// For development, enable/disable robots' ability to use VisionMarkers while moving
// May be necessary to have this disabled while we have frame sync issues.
// NOTE: This will apply to all robots currently connected.
message VisionWhileMoving {
    uint_8 enable // True or false
}

// Set the face enrollment pose
message SetFaceEnrollmentPose {
  Vision::FaceEnrollmentPose pose
}

// Erase a face record by name
message EraseEnrolledFaceByName {
  string name
}

// Erase a face record by ID
message EraseEnrolledFaceByID {
  int_32 faceID
}

// Erase all enrolled faces (use with care!)
message EraseAllEnrolledFaces {

}

message EnableVisionMode {
   VisionMode mode,
   bool       enable
}

// Rename given ID+oldName pair to use newName. For safety if current face with given ID
// does not match oldName, nothing happens.
// On success, a RobotLoadedKnownFace message with faceID and newName will be sent.
message UpdateEnrolledFaceByID {
  int_32 faceID,
  string oldName,
  string newName
}

message VisionRunMode {
  bool isSync
}

// Save the enrolled face album to a file
message SaveFaceAlbumToFile {
  string path,
  bool   isRelativePath=1  // If true, use 'path' relative to internal album path
}

// Load the face album from a file (this clears all faces stored on the robot!)
message LoadFaceAlbumFromFile {
  string path,
  bool   isRelativePath=1  // If true, use 'path' relative to internal album path
}

///////////////////////////////////////////////////////////////////////////////
// Behavior Commands
///////////////////////////////////////////////////////////////////////////////

// ActivateBehaviorChooser
message ActivateBehaviorChooser {
  BehaviorChooserType behaviorChooserType
}

// ExecuteBehavior
message ExecuteBehavior {
  BehaviorType behaviorType
}

message ExecuteBehaviorByName {
  string behaviorName
}

// Any message intended for a specific robot's behaviorManager
message BehaviorManagerMessage {
  uint_8  robotID,
  BehaviorManagerMessageUnion  BehaviorManagerMessageUnion
}

// AbortPath
message AbortPath {
}

// AbortAll
message AbortAll {

}

// StartTestMode
message StartTestMode {
    uint_8  robotID,
    int_32 p1,
    int_32 p2,
    int_32 p3,
    TestMode mode
}


///////////////////////////////////////////////////////////////////////////////
// Visualization (Viz) Related
///////////////////////////////////////////////////////////////////////////////

// DrawPoseMarker
message DrawPoseMarker {
    float_32 x_mm,
    float_32 y_mm,
    float_32 rad,
    uint_8 level
}

// ErasePoseMarker
message ErasePoseMarker {

}

// VisualizeQuad
//  Draws the specified quadrilateral using the Visualization system.
//  The quadID will be created if new or replaced if it already exists (i.e., you
//  do not need to send an EraseQuad message before updating an existing quad).
message VisualizeQuad {
  uint_32 quadID,
  uint_32 color, // RGBA
  float_32 xUpperLeft,
  float_32 yUpperLeft,
  float_32 zUpperLeft,
  float_32 xLowerLeft,
  float_32 yLowerLeft,
  float_32 zLowerLeft,
  float_32 xUpperRight,
  float_32 yUpperRight,
  float_32 zUpperRight,
  float_32 xLowerRight,
  float_32 yLowerRight,
  float_32 zLowerRight
}

// EraseQuad
//  Erase the visualized quad with the specified ID
message EraseQuad {
  uint_32 quadID
}


///////////////////////////////////////////////////////////////////////////////
// Animation Commands
///////////////////////////////////////////////////////////////////////////////

// ReplayLastAnimation
message ReplayLastAnimation {
    uint_8  robotID,
    uint_32 numLoops
}

// SetIdleAnimation
//  Set the animation group that will be played (in a continuous loop) if no other
//  animation has been set using PlayAnimation above.
//  Use the empty string to disable the idle animation.
message SetIdleAnimation {
    uint_8 robotID,
    string animationName // Group name, not individual animation!
}

// PushIdleAnimation
//  Switches the idle animation (the one played in a continuous loop while no other
//  animation is requested via PlayAnimation) to the one specified.
message PushIdleAnimation {
    string animationName // Group name, not individual animation!
}

// PopIdleAnimation
//  Stops using the last pushed idle animation and goes back to whatever was
//  previously the idle.
message PopIdleAnimation {

}

// ReadAnimationFile
message ReadAnimationFile {
}

// RequestAvailableAnimations
message RequestAvailableAnimations{
  
}

// RequestAvailableAnimationGroups
message RequestAvailableAnimationGroups{
  
}

message SetLiveIdleAnimationParameters {
  LiveIdleAnimationParameter   paramNames[uint_8],
  float_32                     paramValues[uint_8], // must be same length as paramNames
  uint_8                       robotID,
  bool                         setUnspecifiedToDefault = 0
}

// DisplayProceduralFace
message DisplayProceduralFace {
  float_32 faceAngle,        // Degrees
  float_32 faceCenX,
  float_32 faceCenY,
  float_32 faceScaleX,
  float_32 faceScaleY,
  float_32 leftEye[uint_8],  // TODO: make this fixed length = ProceduralEyeParameter::NumParameters
  float_32 rightEye[uint_8], //
  uint_8   robotID
}

// PushDrivingAnimations
message PushDrivingAnimations {
    string drivingStartAnim,
    string drivingLoopAnim,
    string drivingEndAnim
}

message PopDrivingAnimations {

}


///////////////////////////////////////////////////////////////////////////////
// Robot / Cube LED Controls
///////////////////////////////////////////////////////////////////////////////

message SetHeadlight
{
  bool enable
}

// SetActiveObjectLEDs
message SetActiveObjectLEDs {
    uint_32  objectID,
    uint_32  onColor,
    uint_32  offColor,
    uint_32  onPeriod_ms,
    uint_32  offPeriod_ms,
    uint_32  transitionOnPeriod_ms,
    uint_32  transitionOffPeriod_ms,
    float_32 relativeToX,
    float_32 relativeToY,
    WhichCubeLEDs   whichLEDs,
    MakeRelativeMode   makeRelative,
    uint_8   turnOffUnspecifiedLEDs, // whether to augment current pattern, or turn off everything but what's specified
    uint_8   robotID
}

// SetAllActiveObjectLEDs
message SetAllActiveObjectLEDs {
  uint_32  objectID,
  uint_32  onColor[4],
  uint_32  offColor[4],
  uint_32  onPeriod_ms[4],
  uint_32  offPeriod_ms[4],
  uint_32  transitionOnPeriod_ms[4],
  uint_32  transitionOffPeriod_ms[4],
  float_32 relativeToX,
  float_32 relativeToY,
  MakeRelativeMode   makeRelative,  // if 0, ignores relativeX/relativeY
  uint_8   robotID
}

// SetBackpackLEDs
//  See ledTypes.h for the enumeration of the available backpack LEDs.
message SetBackpackLEDs {
  uint_32  onColor[5],
  uint_32  offColor[5],
  uint_32  onPeriod_ms[5],
  uint_32  offPeriod_ms[5],
  uint_32  transitionOnPeriod_ms[5],
  uint_32  transitionOffPeriod_ms[5],
  uint_8   robotID
}



///////////////////////////////////////////////////////////////////////////////
// Demo
///////////////////////////////////////////////////////////////////////////////

message TransitionToNextDemoState {
}

message WakeUp {
  bool hasEdge = 1
}

message DemoResetState {

}

///////////////////////////////////////////////////////////////////////////////
// Mood / Emotions
///////////////////////////////////////////////////////////////////////////////

structure GetEmotions {
}

structure SetEmotion {
  EmotionType emotionType,
  float_32 newVal
}

structure AddToEmotion {
  EmotionType emotionType,
  float_32 deltaVal,
  string uniqueIdString
}

structure TriggerEmotionEvent {
  string emotionEventName
}

union MoodMessageUnion {
  GetEmotions  GetEmotions,
  SetEmotion   SetEmotion,
  AddToEmotion AddToEmotion,
  TriggerEmotionEvent TriggerEmotionEvent
}

message MoodMessage {
  uint_8  robotID,
  MoodMessageUnion  MoodMessageUnion
}

structure SetFriendshipPoints {
  int_32 newVal
}

structure SetFriendshipLevel {
  int_32 newVal
}

union ProgressionMessageUnion {
  SetFriendshipPoints  SetFriendshipPoints,
  SetFriendshipLevel   SetFriendshipLevel
}

message ProgressionMessage {
  uint_8  robotID,
  ProgressionMessageUnion  ProgressionMessageUnion
}

// Progression unlocks
message RequestSetUnlock {
  UnlockId unlockID,
  bool unlocked
}

///////////////////////////////////////////////////////////////////////////////
// Debug / Logging
///////////////////////////////////////////////////////////////////////////////

message SetDebugConsoleVarMessage {
  string varName,
  string tryValue
}

message RunDebugConsoleFuncMessage {
  string funcName,
  string funcArgs
}

message GetDebugConsoleVarMessage {
  string varName
}

message GetAllDebugConsoleVarMessage {
}

message SetEnableSOSLogging {
  bool enabled
}

// Msg used by maya to disable reaction behaviors.
message EnableReactionaryBehaviors {
  bool enabled
}


///////////////////////////////////////////////////////////////////////////////
// BlockPool
///////////////////////////////////////////////////////////////////////////////

message BlockPoolEnabledMessage {
  bool enabled
}

message BlockSelectedMessage {
  uint_32 factoryId,
  bool   selected
}
// Query for E2Gmessage: InitBlockPoolMessage
message GetBlockPoolMessage {
}

message SendAvailableObjects {
  uint_8 robotID,
  bool enable
}


///////////////////////////////////////////////////////////////////////////////
// Camera calibration
///////////////////////////////////////////////////////////////////////////////

message SaveCalibrationImage {
  uint_8 robotID,
}

message ClearCalibrationImages {
  uint_8 robotID,
}

message ComputeCameraCalibration {
  uint_8 robotID,
}


///////////////////////////////////////////////////////////////////////////////
// Robot flash (non-volatile storage)
///////////////////////////////////////////////////////////////////////////////

// All non-volatile storage operations result in a NVStorageOpResult message
// being sent back from engine upon completion except for single-blob reads.
// Whether or not an entry is single blob or multi-blob entry is determined by
// the NVEntryTag value.
// NOTE: Do not follow one operation with another before acking the previous
//       operation as the flash can only handle one at a time.
//       The only exception is you can send multiple NVStorageWriteEntry messages
//       for a multi-blob message since these don't actually get sent to robot
//       until all blobs have been received by engine.

// Erase an entry from non-volatile storage
message NVStorageEraseEntry {
  NVStorage::NVEntryTag tag
}

// Erase all entries from non-volatile storage
// (not including factory partition)
// NOTE: THIS MESSAGE FORCES A ROBOT REBOOT CAUSING DISCONNECT.
message NVStorageWipeAll {
  string key            // This must be "Yes I really want to do this!" otherwise the operation will fail.
}

// Multi-blob messages (determined by tag) are queued on engine
// and sent out all at once only when all blobs have been received.
// (This also means that writes won't be ackd with NVStorageOpResult until all
// blobs have been sent to engine, unless there's a problem found before all the blobs
// have been received in which case engine will send an NVStorageOpResult failure for
// each problematic NVStorageWriteEntry received.)
// This is to help make it harder to write junk to the robot.'
// Single-blob messages are sent to robot immediately.
message NVStorageWriteEntry {
  NVStorage::NVEntryTag tag,
  uint_16 data_length,
  uint_8  data[1024],
  uint_8  index,         // If tag is a multi-blob entry, this is the blob index starting at 0 for the first blob.
  uint_8  numTotalBlobs  // If tag is a multi-blob entry, this is the total number of blobs expected.
}

// Clears any queued data received by engine for a multi-blob entry via NVStorageWriteEntry.
// Does not directly affect robot flash.
// This should be called once before sending a sequence of NVStorageWriteEntry messages
// for a mult-blob entry. It should only be necessary if something went wrong
// with a previous write attempt, but doesn't hurt to call it every time.
message NVStorageClearPartialPendingWriteEntry {
}

// Data is returned in NVStorageData messages.
// If multi-blob entry, game will have to dechunk.
message NVStorageReadEntry {
  NVStorage::NVEntryTag tag
}

// keep empty to generate an auto-union that includes all messages in this file
// if you do not want to include messages in this union, use the keyword "structure" instead of "message"
union MessageGameToEngine { }

} // namespace U2G
} // namespace Cozmo
} // namespace Anki
