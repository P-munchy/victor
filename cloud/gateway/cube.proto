// External interface for robot <-> app and robot <-> sdk communication

syntax = "proto3";

package Anki.Cozmo.external_interface;

option optimize_for = LITE_RUNTIME;

import "messages.proto";

// Attempt to connect to a cube. If a cube is currently connected,
// this will do nothing.
message ConnectCubeRequest {
}
message ConnectCubeResponse {
  ResultStatus status = 1;
  bool success = 2;
}

// Requests a disconnection from the currently connected cube.
// The connection will be held for grace_period_sec before actually
// disconnecting. Any attempt to connect during this "grace period"
// will succeed instantaneously, so this is useful if you are
// frequently disconnecting/connecting to the cube. A grace period
// of 0 will immediately disconnect the cube.
message DisconnectCubeRequest {
  float grace_period_sec = 1;
}
message DisconnectCubeResponse {
  ResultStatus status = 1;
}

// Plays the default cube connection animation on the currently
// connected cube's lights.  This is intended for app level user
// surfacing of cube connectivity, not for sdk cube light control.
message FlashCubeLightsRequest {
}
message FlashCubeLightsResponse {
  ResultStatus status = 1;
}

// 'Forget' the robot's preferred cube. This will cause the robot to
// connect to the cube with the highest RSSI (signal strength) next
// time a connection is requested. Saves this preference to disk.
// The next cube that the robot connects to will become its
// preferred cube.
message ForgetPreferredCubeRequest {
}
message ForgetPreferredCubeResponse {
  ResultStatus status = 1;
}

// Set the robot's preferred cube and save it to disk. The robot
// will always attempt to connect to this cube if it is available.
// This is only used in simulation (for now).
message SetPreferredCubeRequest {
  string factory_id = 1;
}
message SetPreferredCubeResponse {
  ResultStatus status = 1;
}

// @TODO: Add a GetPreferredCube rpc to the proto interface VIC-4642

// This is an int_32 on the clad side.
enum ObjectType
{
  INVALID_OBJECT = 0;
  UNKNOWN_OBJECT = 1;

  //////////////////////////////////////////////////////////////////////////
  // Light Cube (a.k.a. Active Block)
  //

  BLOCK_LIGHTCUBE1 = 2;

  // There are 38 object types in the internal clad definition, though only
  // some are surfaced here
  OBJECT_TYPE_COUNT = 38;
}

enum ObjectFamily {
  INVALID_FAMILY    = 0;
  UNKNOWN_FAMILY    = 1;
  BLOCK             = 2;
  LIGHT_CUBE        = 3;
  CHARGER           = 4;

  // There are 7 object types in the internal clad definition, though only
  // some are surfaced here
  OBJECT_FAMILY_COUNT = 7;
}

// Indicates that a the connection subscribed through ConnectCube has
// been lost.
message CubeConnectionLost {
}

// Indicates that a cube has connected or disconnected to the robot.
// This message will be sent for any connects or disconnects regardless
// of whether it originated from us or underlying robot behavior.
message ObjectConnectionState {
  uint32     object_id   = 1;
  string     factory_id  = 2;
  ObjectType object_type = 3;
  bool       connected   = 4;
}

message ObjectMoved {
  uint32 timestamp = 1;
  uint32 object_id = 2;
}

message ObjectStoppedMoving {
  uint32 timestamp = 1;
  uint32 object_id = 2;
}

enum UpAxis {
  INVALID_AXIS = 0;
  X_NEGATIVE   = 1;
  X_POSITIVE   = 2;
  Y_NEGATIVE   = 3;
  Y_POSITIVE   = 4;
  Z_NEGATIVE   = 5;
  Z_POSITIVE   = 6;
  NUM_AXES     = 7;
}

message ObjectUpAxisChanged {
  uint32 timestamp = 1;
  uint32 object_id = 2;
  UpAxis up_axis   = 3;
}

message ObjectTapped {
  uint32 timestamp = 1;
  uint32 object_id = 2;
}

// RobotObservedObject for signaling that an object
//  with specified ID/Type/Family was seen at a particular location in the image
//  and the world
message RobotObservedObject {
    uint32       timestamp                = 1;
    ObjectFamily object_family            = 2;
    ObjectType   object_type              = 3;
    int32        object_id                = 4; // signed to match U2G::PickAndPlaceObject which has the option to have objectID<0
    CladRect     img_rect                 = 5; // position in image coords
    PoseStruct   pose                     = 6;
    float        top_face_orientation_rad = 7; // absolute orienation of top face, iff isActive==true
    uint32       is_active                = 8;
}
