package ogg

import (
	"bytes"
	"errors"
	"fmt"

	"github.com/grd/ogg"
)

// Packet aliases the ogg.Packet type and represents the struct
// submitted to SubmitPacket
type Packet = ogg.Packet

// Stream is an object that accepts Ogg packets and returns byte slices of
// the Ogg container generated by these packets as they're submitted
type Stream struct {
	stream   ogg.StreamState
	granules int64
	packets  int64
	anyMade  bool
	inited   bool
}

// Init initializes the underlying Ogg stream object
func (s *Stream) Init(streamId int32) {
	s.stream.Init(streamId)
	s.inited = true
}

// NewSeqPacket returns a new packet that's assumed to sequentially follow previous packets
// sent to SubmitPacket; it will have a GranulePosition equal to the last submitted packet's
// GranulePosition plus the number of samples supplied in this call. Its packet number will be
// one higher than the last packet submitted to SubmitPacket. The first packet generated by
// this function will have BOS set, otherwise no extra flags will be set.
//
// For situations (i.e. header packets) where specific granule positions and packet numbers
// are desired, those values should probably be manually checked/set after the packet is
// returned.
func (s *Stream) NewSeqPacket(buf []byte, samples int64) *Packet {
	first := !s.anyMade
	n := s.packets + 1
	if first {
		n = 0
	}
	s.anyMade = true
	return &Packet{
		Packet:     buf,
		GranulePos: s.granules + samples,
		PacketNo:   n,
		BOS:        first}
}

// SubmitPacket adds the given packet to the Ogg container and returns any bytes from completed
// pages that are output, the number of pages that were output, and any errors. If the flush
// parameter is true, it will attempt to flush a page to force data to be output; otherwise,
// the submitted packet may not trigger any output and return values of (0-length byte slice, 0, nil)
// are possible or even likely.
//
// If flush is true and no pages are output, an error is returned.
func (s *Stream) SubmitPacket(packet *Packet, flush bool) ([]byte, int, error) {
	if !s.inited {
		return nil, 0, errors.New("Packet submitted to stream before Init() called")
	}
	s.granules = packet.GranulePos
	s.packets = packet.PacketNo

	var output pageBuffer
	if err := s.stream.PacketIn(packet); err != nil {
		return nil, 0, err
	}
	var page ogg.Page
	var count int
	for s.stream.PageOut(&page) {
		if _, err := output.writePage(&page); err != nil {
			return nil, 0, err
		}
		count++
	}
	if flush {
		if s.stream.Flush(&page) {
			if _, err := output.writePage(&page); err != nil {
				return nil, 0, err
			}
			count++
		}
		if count == 0 {
			return nil, 0, errors.New("Flush requested but no data output")
		}
	}
	return output.Bytes(), count, nil
}

// Flush attempts to flush a completed page from the Ogg container if,
// since the last page was returned, packets were submitted that did not
// return a completed page. Returns the bytes from that page if successful,
// or else an empty byte slice.
func (s *Stream) Flush() []byte {
	var page ogg.Page
	flushed := s.stream.Flush(&page)
	if !flushed {
		return []byte{}
	}
	return append(page.Header, page.Body...)
}

type pageBuffer struct {
	bytes.Buffer
}

func getWriteError(err error, n int, expected int) error {
	if err != nil {
		return err
	}
	return fmt.Errorf("Couldn't write page size %d, got %d", expected, n)
}

func (b *pageBuffer) writePage(p *ogg.Page) (int, error) {
	if n, err := b.Write(p.Header); n != len(p.Header) || err != nil {
		return 0, getWriteError(err, n, len(p.Header))
	}
	if n, err := b.Write(p.Body); n != len(p.Body) || err != nil {
		return 0, getWriteError(err, n, len(p.Body))
	}
	return len(p.Header) + len(p.Body), nil
}
