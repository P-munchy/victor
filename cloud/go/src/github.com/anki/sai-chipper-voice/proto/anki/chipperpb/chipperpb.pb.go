// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/anki/chipperpb/chipperpb.proto

/*
Package chippergrpc2 is a generated protocol buffer package.

It is generated from these files:
	proto/anki/chipperpb/chipperpb.proto

It has these top-level messages:
	TextRequest
	StreamingIntentRequest
	StreamingKnowledgeGraphRequest
	StreamingConnectionCheckRequest
	IntentResponse
	SpeechResult
	IntentResult
	KnowledgeGraphResponse
	ConnectionCheckResponse
	WeatherLocation
*/
package chippergrpc2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Supported languages
type LanguageCode int32

const (
	LanguageCode_ENGLISH_US LanguageCode = 0
	LanguageCode_ENGLISH_UK LanguageCode = 1
	LanguageCode_ENGLISH_AU LanguageCode = 2
	LanguageCode_GERMAN     LanguageCode = 3
	LanguageCode_FRENCH     LanguageCode = 4
)

var LanguageCode_name = map[int32]string{
	0: "ENGLISH_US",
	1: "ENGLISH_UK",
	2: "ENGLISH_AU",
	3: "GERMAN",
	4: "FRENCH",
}
var LanguageCode_value = map[string]int32{
	"ENGLISH_US": 0,
	"ENGLISH_UK": 1,
	"ENGLISH_AU": 2,
	"GERMAN":     3,
	"FRENCH":     4,
}

func (x LanguageCode) String() string {
	return proto.EnumName(LanguageCode_name, int32(x))
}
func (LanguageCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type IntentService int32

const (
	IntentService_DEFAULT    IntentService = 0
	IntentService_DIALOGFLOW IntentService = 1
	IntentService_BING_LUIS  IntentService = 2
	IntentService_LEX        IntentService = 3
)

var IntentService_name = map[int32]string{
	0: "DEFAULT",
	1: "DIALOGFLOW",
	2: "BING_LUIS",
	3: "LEX",
}
var IntentService_value = map[string]int32{
	"DEFAULT":    0,
	"DIALOGFLOW": 1,
	"BING_LUIS":  2,
	"LEX":        3,
}

func (x IntentService) String() string {
	return proto.EnumName(IntentService_name, int32(x))
}
func (IntentService) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type AudioEncoding int32

const (
	AudioEncoding_LINEAR_PCM AudioEncoding = 0
	AudioEncoding_OGG_OPUS   AudioEncoding = 1
)

var AudioEncoding_name = map[int32]string{
	0: "LINEAR_PCM",
	1: "OGG_OPUS",
}
var AudioEncoding_value = map[string]int32{
	"LINEAR_PCM": 0,
	"OGG_OPUS":   1,
}

func (x AudioEncoding) String() string {
	return proto.EnumName(AudioEncoding_name, int32(x))
}
func (AudioEncoding) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type RobotMode int32

const (
	RobotMode_VOICE_COMMAND RobotMode = 0
	RobotMode_GAME          RobotMode = 1
)

var RobotMode_name = map[int32]string{
	0: "VOICE_COMMAND",
	1: "GAME",
}
var RobotMode_value = map[string]int32{
	"VOICE_COMMAND": 0,
	"GAME":          1,
}

func (x RobotMode) String() string {
	return proto.EnumName(RobotMode_name, int32(x))
}
func (RobotMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type TextRequest struct {
	// Required. Can be random number or user identifier.
	Session string `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
	// Required. Robot identifier.
	DeviceId string `protobuf:"bytes,2,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// Required. Text of query
	TextInput string `protobuf:"bytes,3,opt,name=text_input,json=textInput" json:"text_input,omitempty"`
	// Optional. Specify language for intent-service, default is ENGLISH_US
	LanguageCode LanguageCode `protobuf:"varint,4,opt,name=language_code,json=languageCode,enum=chippergrpc2.LanguageCode" json:"language_code,omitempty"`
	// Optional. Choose intent-service to process request, default is server's default
	IntentService IntentService `protobuf:"varint,5,opt,name=intent_service,json=intentService,enum=chippergrpc2.IntentService" json:"intent_service,omitempty"`
	// Required. Robot firmware version. Use to choose intent-service version.
	FirmwareVersion string `protobuf:"bytes,6,opt,name=firmware_version,json=firmwareVersion" json:"firmware_version,omitempty"`
	// Optional. Robot mode for games and knowledge-graph. default is VOICE_COMMAND
	Mode RobotMode `protobuf:"varint,7,opt,name=mode,enum=chippergrpc2.RobotMode" json:"mode,omitempty"`
	// Required. Skip DAS will turn off DAS logging, for GDPR
	SkipDas bool `protobuf:"varint,8,opt,name=skip_das,json=skipDas" json:"skip_das,omitempty"`
}

func (m *TextRequest) Reset()                    { *m = TextRequest{} }
func (m *TextRequest) String() string            { return proto.CompactTextString(m) }
func (*TextRequest) ProtoMessage()               {}
func (*TextRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *TextRequest) GetSession() string {
	if m != nil {
		return m.Session
	}
	return ""
}

func (m *TextRequest) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *TextRequest) GetTextInput() string {
	if m != nil {
		return m.TextInput
	}
	return ""
}

func (m *TextRequest) GetLanguageCode() LanguageCode {
	if m != nil {
		return m.LanguageCode
	}
	return LanguageCode_ENGLISH_US
}

func (m *TextRequest) GetIntentService() IntentService {
	if m != nil {
		return m.IntentService
	}
	return IntentService_DEFAULT
}

func (m *TextRequest) GetFirmwareVersion() string {
	if m != nil {
		return m.FirmwareVersion
	}
	return ""
}

func (m *TextRequest) GetMode() RobotMode {
	if m != nil {
		return m.Mode
	}
	return RobotMode_VOICE_COMMAND
}

func (m *TextRequest) GetSkipDas() bool {
	if m != nil {
		return m.SkipDas
	}
	return false
}

type StreamingIntentRequest struct {
	// Required. Can be random number or user identifier.
	Session string `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
	// Required. Robot identifier.
	DeviceId string `protobuf:"bytes,2,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// Required. Input audio content format: 16k SR, 1-channel, 100ms chunks.
	InputAudio []byte `protobuf:"bytes,3,opt,name=input_audio,json=inputAudio,proto3" json:"input_audio,omitempty"`
	// Optional. Specify language for intent-service, default is ENGLISH_US
	LanguageCode LanguageCode `protobuf:"varint,4,opt,name=language_code,json=languageCode,enum=chippergrpc2.LanguageCode" json:"language_code,omitempty"`
	// Optional. ASR only using Bing Speech (for now).
	// Returns text transcript with intent_speech_only. Default is false
	SpeechOnly bool `protobuf:"varint,5,opt,name=speech_only,json=speechOnly" json:"speech_only,omitempty"`
	// Required. Robot firmware version. Use to choose intent-service version.
	FirmwareVersion string `protobuf:"bytes,6,opt,name=firmware_version,json=firmwareVersion" json:"firmware_version,omitempty"`
	// Optional. Robot mode for games and knowledge-graph. default is VOICE_COMMAND
	Mode RobotMode `protobuf:"varint,7,opt,name=mode,enum=chippergrpc2.RobotMode" json:"mode,omitempty"`
	// Optional. boot_id for DAS cloud event
	BootId string `protobuf:"bytes,8,opt,name=boot_id,json=bootId" json:"boot_id,omitempty"`
	// Required. Skip DAS will turn off DAS logging, for GDPR
	SkipDas bool `protobuf:"varint,9,opt,name=skip_das,json=skipDas" json:"skip_das,omitempty"`
	// Optional. Choose audio encoding, default is PCM 16K
	AudioEncoding AudioEncoding `protobuf:"varint,13,opt,name=audio_encoding,json=audioEncoding,enum=chippergrpc2.AudioEncoding" json:"audio_encoding,omitempty"`
	// Optional. If using dialogflow, set single_utterance true to use dialogflow-VAD.
	SingleUtterance bool `protobuf:"varint,14,opt,name=single_utterance,json=singleUtterance" json:"single_utterance,omitempty"`
	// Optional. Default is whatever that is defined on Chipper Cloud.
	IntentService IntentService `protobuf:"varint,15,opt,name=intent_service,json=intentService,enum=chippergrpc2.IntentService" json:"intent_service,omitempty"`
	// Required for now till TMS is ready. Anki application key
	AppKey string `protobuf:"bytes,16,opt,name=app_key,json=appKey" json:"app_key,omitempty"`
	// Optional. Set whether to save-audio in Dev
	SaveAudio bool `protobuf:"varint,17,opt,name=save_audio,json=saveAudio" json:"save_audio,omitempty"`
}

func (m *StreamingIntentRequest) Reset()                    { *m = StreamingIntentRequest{} }
func (m *StreamingIntentRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamingIntentRequest) ProtoMessage()               {}
func (*StreamingIntentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *StreamingIntentRequest) GetSession() string {
	if m != nil {
		return m.Session
	}
	return ""
}

func (m *StreamingIntentRequest) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *StreamingIntentRequest) GetInputAudio() []byte {
	if m != nil {
		return m.InputAudio
	}
	return nil
}

func (m *StreamingIntentRequest) GetLanguageCode() LanguageCode {
	if m != nil {
		return m.LanguageCode
	}
	return LanguageCode_ENGLISH_US
}

func (m *StreamingIntentRequest) GetSpeechOnly() bool {
	if m != nil {
		return m.SpeechOnly
	}
	return false
}

func (m *StreamingIntentRequest) GetFirmwareVersion() string {
	if m != nil {
		return m.FirmwareVersion
	}
	return ""
}

func (m *StreamingIntentRequest) GetMode() RobotMode {
	if m != nil {
		return m.Mode
	}
	return RobotMode_VOICE_COMMAND
}

func (m *StreamingIntentRequest) GetBootId() string {
	if m != nil {
		return m.BootId
	}
	return ""
}

func (m *StreamingIntentRequest) GetSkipDas() bool {
	if m != nil {
		return m.SkipDas
	}
	return false
}

func (m *StreamingIntentRequest) GetAudioEncoding() AudioEncoding {
	if m != nil {
		return m.AudioEncoding
	}
	return AudioEncoding_LINEAR_PCM
}

func (m *StreamingIntentRequest) GetSingleUtterance() bool {
	if m != nil {
		return m.SingleUtterance
	}
	return false
}

func (m *StreamingIntentRequest) GetIntentService() IntentService {
	if m != nil {
		return m.IntentService
	}
	return IntentService_DEFAULT
}

func (m *StreamingIntentRequest) GetAppKey() string {
	if m != nil {
		return m.AppKey
	}
	return ""
}

func (m *StreamingIntentRequest) GetSaveAudio() bool {
	if m != nil {
		return m.SaveAudio
	}
	return false
}

type StreamingKnowledgeGraphRequest struct {
	// Required. Can be random number or user identifier.
	Session string `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
	// Required. Robot identifier.
	DeviceId string `protobuf:"bytes,2,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// Required. Input audio content format: 16k SR, 1-channel, 100ms chunks
	InputAudio []byte `protobuf:"bytes,3,opt,name=input_audio,json=inputAudio,proto3" json:"input_audio,omitempty"`
	// Optional. Specify language for intent-service, default is ENGLISH_US
	LanguageCode LanguageCode `protobuf:"varint,4,opt,name=language_code,json=languageCode,enum=chippergrpc2.LanguageCode" json:"language_code,omitempty"`
	// Required. Robot firmware version. Use for stats
	FirmwareVersion string `protobuf:"bytes,5,opt,name=firmware_version,json=firmwareVersion" json:"firmware_version,omitempty"`
	// Optional. Choose audio encoding, default is PCM 16K
	AudioEncoding AudioEncoding `protobuf:"varint,6,opt,name=audio_encoding,json=audioEncoding,enum=chippergrpc2.AudioEncoding" json:"audio_encoding,omitempty"`
	// Required for now till TMS is ready. Anki application key
	AppKey string `protobuf:"bytes,7,opt,name=app_key,json=appKey" json:"app_key,omitempty"`
	// Optional. Set whether to save-audio in Dev
	SaveAudio bool `protobuf:"varint,8,opt,name=save_audio,json=saveAudio" json:"save_audio,omitempty"`
	// Optional. boot_id for DAS cloud event
	BootId string `protobuf:"bytes,9,opt,name=boot_id,json=bootId" json:"boot_id,omitempty"`
	// Required. Skip DAS will turn off DAS logging, for GDPR
	SkipDas bool `protobuf:"varint,10,opt,name=skip_das,json=skipDas" json:"skip_das,omitempty"`
	// Optional. Timezone from robot
	Timezone string `protobuf:"bytes,11,opt,name=timezone" json:"timezone,omitempty"`
}

func (m *StreamingKnowledgeGraphRequest) Reset()                    { *m = StreamingKnowledgeGraphRequest{} }
func (m *StreamingKnowledgeGraphRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamingKnowledgeGraphRequest) ProtoMessage()               {}
func (*StreamingKnowledgeGraphRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *StreamingKnowledgeGraphRequest) GetSession() string {
	if m != nil {
		return m.Session
	}
	return ""
}

func (m *StreamingKnowledgeGraphRequest) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *StreamingKnowledgeGraphRequest) GetInputAudio() []byte {
	if m != nil {
		return m.InputAudio
	}
	return nil
}

func (m *StreamingKnowledgeGraphRequest) GetLanguageCode() LanguageCode {
	if m != nil {
		return m.LanguageCode
	}
	return LanguageCode_ENGLISH_US
}

func (m *StreamingKnowledgeGraphRequest) GetFirmwareVersion() string {
	if m != nil {
		return m.FirmwareVersion
	}
	return ""
}

func (m *StreamingKnowledgeGraphRequest) GetAudioEncoding() AudioEncoding {
	if m != nil {
		return m.AudioEncoding
	}
	return AudioEncoding_LINEAR_PCM
}

func (m *StreamingKnowledgeGraphRequest) GetAppKey() string {
	if m != nil {
		return m.AppKey
	}
	return ""
}

func (m *StreamingKnowledgeGraphRequest) GetSaveAudio() bool {
	if m != nil {
		return m.SaveAudio
	}
	return false
}

func (m *StreamingKnowledgeGraphRequest) GetBootId() string {
	if m != nil {
		return m.BootId
	}
	return ""
}

func (m *StreamingKnowledgeGraphRequest) GetSkipDas() bool {
	if m != nil {
		return m.SkipDas
	}
	return false
}

func (m *StreamingKnowledgeGraphRequest) GetTimezone() string {
	if m != nil {
		return m.Timezone
	}
	return ""
}

type StreamingConnectionCheckRequest struct {
	// Required. Can be random number or user identifier.
	Session string `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
	// Required. Robot identifier.
	DeviceId string `protobuf:"bytes,2,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// Required. Fake audio for connection check. 100ms chunks of 16k SR, 1-channel
	InputAudio []byte `protobuf:"bytes,3,opt,name=input_audio,json=inputAudio,proto3" json:"input_audio,omitempty"`
	// Required. Robot firmware version. Use for stats
	FirmwareVersion string `protobuf:"bytes,4,opt,name=firmware_version,json=firmwareVersion" json:"firmware_version,omitempty"`
	// Required for now till TMS is ready. Anki application key
	AppKey string `protobuf:"bytes,5,opt,name=app_key,json=appKey" json:"app_key,omitempty"`
	// Required. How many ms of audio total will be sent up
	TotalAudioMs uint32 `protobuf:"varint,6,opt,name=total_audio_ms,json=totalAudioMs" json:"total_audio_ms,omitempty"`
	// Required. How many ms of audio will be sent per request
	AudioPerRequest uint32 `protobuf:"varint,7,opt,name=audio_per_request,json=audioPerRequest" json:"audio_per_request,omitempty"`
}

func (m *StreamingConnectionCheckRequest) Reset()                    { *m = StreamingConnectionCheckRequest{} }
func (m *StreamingConnectionCheckRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamingConnectionCheckRequest) ProtoMessage()               {}
func (*StreamingConnectionCheckRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *StreamingConnectionCheckRequest) GetSession() string {
	if m != nil {
		return m.Session
	}
	return ""
}

func (m *StreamingConnectionCheckRequest) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *StreamingConnectionCheckRequest) GetInputAudio() []byte {
	if m != nil {
		return m.InputAudio
	}
	return nil
}

func (m *StreamingConnectionCheckRequest) GetFirmwareVersion() string {
	if m != nil {
		return m.FirmwareVersion
	}
	return ""
}

func (m *StreamingConnectionCheckRequest) GetAppKey() string {
	if m != nil {
		return m.AppKey
	}
	return ""
}

func (m *StreamingConnectionCheckRequest) GetTotalAudioMs() uint32 {
	if m != nil {
		return m.TotalAudioMs
	}
	return 0
}

func (m *StreamingConnectionCheckRequest) GetAudioPerRequest() uint32 {
	if m != nil {
		return m.AudioPerRequest
	}
	return 0
}

// Response message from server
type IntentResponse struct {
	// Session of the request.
	Session string `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
	// Robot identifier.
	DeviceId string `protobuf:"bytes,2,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// Final response flag. If set to `true`, this will be the last response.
	IsFinal bool `protobuf:"varint,3,opt,name=is_final,json=isFinal" json:"is_final,omitempty"`
	// Intent result. Only available when is_final is `true`.
	IntentResult *IntentResult `protobuf:"bytes,4,opt,name=intent_result,json=intentResult" json:"intent_result,omitempty"`
	// Speech result. Available in the interim as speech is transcribed.
	SpeechResult *SpeechResult `protobuf:"bytes,5,opt,name=speech_result,json=speechResult" json:"speech_result,omitempty"`
	// Optional. Robot mode for games and knowledge-graph. default is VOICE_COMMAND
	Mode RobotMode `protobuf:"varint,6,opt,name=mode,enum=chippergrpc2.RobotMode" json:"mode,omitempty"`
	// blob-id to audio saved in BlobStore, dev only for debugging.
	AudioId string `protobuf:"bytes,16,opt,name=audio_id,json=audioId" json:"audio_id,omitempty"`
}

func (m *IntentResponse) Reset()                    { *m = IntentResponse{} }
func (m *IntentResponse) String() string            { return proto.CompactTextString(m) }
func (*IntentResponse) ProtoMessage()               {}
func (*IntentResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *IntentResponse) GetSession() string {
	if m != nil {
		return m.Session
	}
	return ""
}

func (m *IntentResponse) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *IntentResponse) GetIsFinal() bool {
	if m != nil {
		return m.IsFinal
	}
	return false
}

func (m *IntentResponse) GetIntentResult() *IntentResult {
	if m != nil {
		return m.IntentResult
	}
	return nil
}

func (m *IntentResponse) GetSpeechResult() *SpeechResult {
	if m != nil {
		return m.SpeechResult
	}
	return nil
}

func (m *IntentResponse) GetMode() RobotMode {
	if m != nil {
		return m.Mode
	}
	return RobotMode_VOICE_COMMAND
}

func (m *IntentResponse) GetAudioId() string {
	if m != nil {
		return m.AudioId
	}
	return ""
}

type SpeechResult struct {
	// Text from transcribed audio.
	Transcript string `protobuf:"bytes,1,opt,name=transcript" json:"transcript,omitempty"`
	// Final result flag. If `false`, represents an interim result.
	// If `true`, the ASR will not process any additional audio.
	IsFinal bool `protobuf:"varint,2,opt,name=is_final,json=isFinal" json:"is_final,omitempty"`
}

func (m *SpeechResult) Reset()                    { *m = SpeechResult{} }
func (m *SpeechResult) String() string            { return proto.CompactTextString(m) }
func (*SpeechResult) ProtoMessage()               {}
func (*SpeechResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SpeechResult) GetTranscript() string {
	if m != nil {
		return m.Transcript
	}
	return ""
}

func (m *SpeechResult) GetIsFinal() bool {
	if m != nil {
		return m.IsFinal
	}
	return false
}

type IntentResult struct {
	// Transcribed text used for matching.
	QueryText string `protobuf:"bytes,1,opt,name=query_text,json=queryText" json:"query_text,omitempty"`
	// Matched intent name.
	Action string `protobuf:"bytes,2,opt,name=action" json:"action,omitempty"`
	// Intent-matching confidence. Value between 0.0 and 1.0 (absolutely certain).
	IntentConfidence float32 `protobuf:"fixed32,3,opt,name=intent_confidence,json=intentConfidence" json:"intent_confidence,omitempty"`
	// Speech recognition confidence. Higher is better.
	// 0.0 is a sentinel value representing no value set.
	SpeechConfidence float32 `protobuf:"fixed32,4,opt,name=speech_confidence,json=speechConfidence" json:"speech_confidence,omitempty"`
	// Collection of extracted entities if available.
	// google.protobuf.Struct parameters = 5;
	Parameters map[string]string `protobuf:"bytes,5,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// All expected entities are parsed correctly.
	AllParametersPresent bool `protobuf:"varint,6,opt,name=all_parameters_present,json=allParametersPresent" json:"all_parameters_present,omitempty"`
	// Context flag. If `true`, next request should use same session string
	HasContext bool          `protobuf:"varint,7,opt,name=has_context,json=hasContext" json:"has_context,omitempty"`
	Service    IntentService `protobuf:"varint,8,opt,name=service,enum=chippergrpc2.IntentService" json:"service,omitempty"`
}

func (m *IntentResult) Reset()                    { *m = IntentResult{} }
func (m *IntentResult) String() string            { return proto.CompactTextString(m) }
func (*IntentResult) ProtoMessage()               {}
func (*IntentResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *IntentResult) GetQueryText() string {
	if m != nil {
		return m.QueryText
	}
	return ""
}

func (m *IntentResult) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *IntentResult) GetIntentConfidence() float32 {
	if m != nil {
		return m.IntentConfidence
	}
	return 0
}

func (m *IntentResult) GetSpeechConfidence() float32 {
	if m != nil {
		return m.SpeechConfidence
	}
	return 0
}

func (m *IntentResult) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *IntentResult) GetAllParametersPresent() bool {
	if m != nil {
		return m.AllParametersPresent
	}
	return false
}

func (m *IntentResult) GetHasContext() bool {
	if m != nil {
		return m.HasContext
	}
	return false
}

func (m *IntentResult) GetService() IntentService {
	if m != nil {
		return m.Service
	}
	return IntentService_DEFAULT
}

type KnowledgeGraphResponse struct {
	// Session of the request.
	Session string `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
	// Robot identifier.
	DeviceId string `protobuf:"bytes,2,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// Transcribed text
	QueryText string `protobuf:"bytes,3,opt,name=query_text,json=queryText" json:"query_text,omitempty"`
	// Response to be spoken
	SpokenText string `protobuf:"bytes,4,opt,name=spoken_text,json=spokenText" json:"spoken_text,omitempty"`
	// What type of command is matched
	CommandType string `protobuf:"bytes,5,opt,name=command_type,json=commandType" json:"command_type,omitempty"`
	// which domains were used to match
	DomainsUsed []string `protobuf:"bytes,6,rep,name=domains_used,json=domainsUsed" json:"domains_used,omitempty"`
	// blob-id to audio saved in BlobStore, dev only for debugging.
	AudioId string `protobuf:"bytes,7,opt,name=audio_id,json=audioId" json:"audio_id,omitempty"`
}

func (m *KnowledgeGraphResponse) Reset()                    { *m = KnowledgeGraphResponse{} }
func (m *KnowledgeGraphResponse) String() string            { return proto.CompactTextString(m) }
func (*KnowledgeGraphResponse) ProtoMessage()               {}
func (*KnowledgeGraphResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *KnowledgeGraphResponse) GetSession() string {
	if m != nil {
		return m.Session
	}
	return ""
}

func (m *KnowledgeGraphResponse) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *KnowledgeGraphResponse) GetQueryText() string {
	if m != nil {
		return m.QueryText
	}
	return ""
}

func (m *KnowledgeGraphResponse) GetSpokenText() string {
	if m != nil {
		return m.SpokenText
	}
	return ""
}

func (m *KnowledgeGraphResponse) GetCommandType() string {
	if m != nil {
		return m.CommandType
	}
	return ""
}

func (m *KnowledgeGraphResponse) GetDomainsUsed() []string {
	if m != nil {
		return m.DomainsUsed
	}
	return nil
}

func (m *KnowledgeGraphResponse) GetAudioId() string {
	if m != nil {
		return m.AudioId
	}
	return ""
}

type ConnectionCheckResponse struct {
	// Status of the connection
	Status string `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	// Number of frames successfully received
	FramesReceived uint32 `protobuf:"varint,2,opt,name=frames_received,json=framesReceived" json:"frames_received,omitempty"`
}

func (m *ConnectionCheckResponse) Reset()                    { *m = ConnectionCheckResponse{} }
func (m *ConnectionCheckResponse) String() string            { return proto.CompactTextString(m) }
func (*ConnectionCheckResponse) ProtoMessage()               {}
func (*ConnectionCheckResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ConnectionCheckResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ConnectionCheckResponse) GetFramesReceived() uint32 {
	if m != nil {
		return m.FramesReceived
	}
	return 0
}

type WeatherLocation struct {
	City  string `protobuf:"bytes,1,opt,name=city" json:"city,omitempty"`
	State string `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
	// ISO 2-letter
	Country string `protobuf:"bytes,3,opt,name=country" json:"country,omitempty"`
}

func (m *WeatherLocation) Reset()                    { *m = WeatherLocation{} }
func (m *WeatherLocation) String() string            { return proto.CompactTextString(m) }
func (*WeatherLocation) ProtoMessage()               {}
func (*WeatherLocation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *WeatherLocation) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *WeatherLocation) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *WeatherLocation) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func init() {
	proto.RegisterType((*TextRequest)(nil), "chippergrpc2.TextRequest")
	proto.RegisterType((*StreamingIntentRequest)(nil), "chippergrpc2.StreamingIntentRequest")
	proto.RegisterType((*StreamingKnowledgeGraphRequest)(nil), "chippergrpc2.StreamingKnowledgeGraphRequest")
	proto.RegisterType((*StreamingConnectionCheckRequest)(nil), "chippergrpc2.StreamingConnectionCheckRequest")
	proto.RegisterType((*IntentResponse)(nil), "chippergrpc2.IntentResponse")
	proto.RegisterType((*SpeechResult)(nil), "chippergrpc2.SpeechResult")
	proto.RegisterType((*IntentResult)(nil), "chippergrpc2.IntentResult")
	proto.RegisterType((*KnowledgeGraphResponse)(nil), "chippergrpc2.KnowledgeGraphResponse")
	proto.RegisterType((*ConnectionCheckResponse)(nil), "chippergrpc2.ConnectionCheckResponse")
	proto.RegisterType((*WeatherLocation)(nil), "chippergrpc2.WeatherLocation")
	proto.RegisterEnum("chippergrpc2.LanguageCode", LanguageCode_name, LanguageCode_value)
	proto.RegisterEnum("chippergrpc2.IntentService", IntentService_name, IntentService_value)
	proto.RegisterEnum("chippergrpc2.AudioEncoding", AudioEncoding_name, AudioEncoding_value)
	proto.RegisterEnum("chippergrpc2.RobotMode", RobotMode_name, RobotMode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ChipperGrpc service

type ChipperGrpcClient interface {
	// send text for intent matching
	TextIntent(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*IntentResponse, error)
	// Sends a streaming audio request. Responses are streamed to the client. (bidirectional)
	StreamingIntent(ctx context.Context, opts ...grpc.CallOption) (ChipperGrpc_StreamingIntentClient, error)
	// Sends a knowledge graph request. This requenst looks very similar to an intent request, but with a different response
	StreamingKnowledgeGraph(ctx context.Context, opts ...grpc.CallOption) (ChipperGrpc_StreamingKnowledgeGraphClient, error)
	// Performs a conenction check. This will take in streaming audio, but not call out to any services.
	StreamingConnectionCheck(ctx context.Context, opts ...grpc.CallOption) (ChipperGrpc_StreamingConnectionCheckClient, error)
}

type chipperGrpcClient struct {
	cc *grpc.ClientConn
}

func NewChipperGrpcClient(cc *grpc.ClientConn) ChipperGrpcClient {
	return &chipperGrpcClient{cc}
}

func (c *chipperGrpcClient) TextIntent(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*IntentResponse, error) {
	out := new(IntentResponse)
	err := grpc.Invoke(ctx, "/chippergrpc2.ChipperGrpc/TextIntent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chipperGrpcClient) StreamingIntent(ctx context.Context, opts ...grpc.CallOption) (ChipperGrpc_StreamingIntentClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChipperGrpc_serviceDesc.Streams[0], c.cc, "/chippergrpc2.ChipperGrpc/StreamingIntent", opts...)
	if err != nil {
		return nil, err
	}
	x := &chipperGrpcStreamingIntentClient{stream}
	return x, nil
}

type ChipperGrpc_StreamingIntentClient interface {
	Send(*StreamingIntentRequest) error
	Recv() (*IntentResponse, error)
	grpc.ClientStream
}

type chipperGrpcStreamingIntentClient struct {
	grpc.ClientStream
}

func (x *chipperGrpcStreamingIntentClient) Send(m *StreamingIntentRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *chipperGrpcStreamingIntentClient) Recv() (*IntentResponse, error) {
	m := new(IntentResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *chipperGrpcClient) StreamingKnowledgeGraph(ctx context.Context, opts ...grpc.CallOption) (ChipperGrpc_StreamingKnowledgeGraphClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChipperGrpc_serviceDesc.Streams[1], c.cc, "/chippergrpc2.ChipperGrpc/StreamingKnowledgeGraph", opts...)
	if err != nil {
		return nil, err
	}
	x := &chipperGrpcStreamingKnowledgeGraphClient{stream}
	return x, nil
}

type ChipperGrpc_StreamingKnowledgeGraphClient interface {
	Send(*StreamingKnowledgeGraphRequest) error
	Recv() (*KnowledgeGraphResponse, error)
	grpc.ClientStream
}

type chipperGrpcStreamingKnowledgeGraphClient struct {
	grpc.ClientStream
}

func (x *chipperGrpcStreamingKnowledgeGraphClient) Send(m *StreamingKnowledgeGraphRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *chipperGrpcStreamingKnowledgeGraphClient) Recv() (*KnowledgeGraphResponse, error) {
	m := new(KnowledgeGraphResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *chipperGrpcClient) StreamingConnectionCheck(ctx context.Context, opts ...grpc.CallOption) (ChipperGrpc_StreamingConnectionCheckClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChipperGrpc_serviceDesc.Streams[2], c.cc, "/chippergrpc2.ChipperGrpc/StreamingConnectionCheck", opts...)
	if err != nil {
		return nil, err
	}
	x := &chipperGrpcStreamingConnectionCheckClient{stream}
	return x, nil
}

type ChipperGrpc_StreamingConnectionCheckClient interface {
	Send(*StreamingConnectionCheckRequest) error
	Recv() (*ConnectionCheckResponse, error)
	grpc.ClientStream
}

type chipperGrpcStreamingConnectionCheckClient struct {
	grpc.ClientStream
}

func (x *chipperGrpcStreamingConnectionCheckClient) Send(m *StreamingConnectionCheckRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *chipperGrpcStreamingConnectionCheckClient) Recv() (*ConnectionCheckResponse, error) {
	m := new(ConnectionCheckResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ChipperGrpc service

type ChipperGrpcServer interface {
	// send text for intent matching
	TextIntent(context.Context, *TextRequest) (*IntentResponse, error)
	// Sends a streaming audio request. Responses are streamed to the client. (bidirectional)
	StreamingIntent(ChipperGrpc_StreamingIntentServer) error
	// Sends a knowledge graph request. This requenst looks very similar to an intent request, but with a different response
	StreamingKnowledgeGraph(ChipperGrpc_StreamingKnowledgeGraphServer) error
	// Performs a conenction check. This will take in streaming audio, but not call out to any services.
	StreamingConnectionCheck(ChipperGrpc_StreamingConnectionCheckServer) error
}

func RegisterChipperGrpcServer(s *grpc.Server, srv ChipperGrpcServer) {
	s.RegisterService(&_ChipperGrpc_serviceDesc, srv)
}

func _ChipperGrpc_TextIntent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChipperGrpcServer).TextIntent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chippergrpc2.ChipperGrpc/TextIntent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChipperGrpcServer).TextIntent(ctx, req.(*TextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChipperGrpc_StreamingIntent_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ChipperGrpcServer).StreamingIntent(&chipperGrpcStreamingIntentServer{stream})
}

type ChipperGrpc_StreamingIntentServer interface {
	Send(*IntentResponse) error
	Recv() (*StreamingIntentRequest, error)
	grpc.ServerStream
}

type chipperGrpcStreamingIntentServer struct {
	grpc.ServerStream
}

func (x *chipperGrpcStreamingIntentServer) Send(m *IntentResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *chipperGrpcStreamingIntentServer) Recv() (*StreamingIntentRequest, error) {
	m := new(StreamingIntentRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ChipperGrpc_StreamingKnowledgeGraph_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ChipperGrpcServer).StreamingKnowledgeGraph(&chipperGrpcStreamingKnowledgeGraphServer{stream})
}

type ChipperGrpc_StreamingKnowledgeGraphServer interface {
	Send(*KnowledgeGraphResponse) error
	Recv() (*StreamingKnowledgeGraphRequest, error)
	grpc.ServerStream
}

type chipperGrpcStreamingKnowledgeGraphServer struct {
	grpc.ServerStream
}

func (x *chipperGrpcStreamingKnowledgeGraphServer) Send(m *KnowledgeGraphResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *chipperGrpcStreamingKnowledgeGraphServer) Recv() (*StreamingKnowledgeGraphRequest, error) {
	m := new(StreamingKnowledgeGraphRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ChipperGrpc_StreamingConnectionCheck_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ChipperGrpcServer).StreamingConnectionCheck(&chipperGrpcStreamingConnectionCheckServer{stream})
}

type ChipperGrpc_StreamingConnectionCheckServer interface {
	Send(*ConnectionCheckResponse) error
	Recv() (*StreamingConnectionCheckRequest, error)
	grpc.ServerStream
}

type chipperGrpcStreamingConnectionCheckServer struct {
	grpc.ServerStream
}

func (x *chipperGrpcStreamingConnectionCheckServer) Send(m *ConnectionCheckResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *chipperGrpcStreamingConnectionCheckServer) Recv() (*StreamingConnectionCheckRequest, error) {
	m := new(StreamingConnectionCheckRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ChipperGrpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chippergrpc2.ChipperGrpc",
	HandlerType: (*ChipperGrpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TextIntent",
			Handler:    _ChipperGrpc_TextIntent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamingIntent",
			Handler:       _ChipperGrpc_StreamingIntent_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamingKnowledgeGraph",
			Handler:       _ChipperGrpc_StreamingKnowledgeGraph_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamingConnectionCheck",
			Handler:       _ChipperGrpc_StreamingConnectionCheck_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/anki/chipperpb/chipperpb.proto",
}

func init() { proto.RegisterFile("proto/anki/chipperpb/chipperpb.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1314 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xdb, 0x6e, 0x1b, 0x45,
	0x18, 0x8e, 0x0f, 0xb1, 0xd7, 0xbf, 0x4f, 0x9b, 0x51, 0x95, 0x6c, 0x53, 0x68, 0x83, 0x55, 0x44,
	0x48, 0x69, 0x8a, 0x02, 0x48, 0x08, 0x09, 0x21, 0xd7, 0x71, 0x5c, 0x53, 0xe7, 0xa0, 0x75, 0xdc,
	0x42, 0x6f, 0x56, 0x93, 0xdd, 0x89, 0x3d, 0xca, 0x7a, 0x76, 0xbb, 0x33, 0x4e, 0x6b, 0x5e, 0x82,
	0x7b, 0x9e, 0x81, 0x0b, 0x2e, 0x79, 0x05, 0x9e, 0x81, 0x97, 0xe0, 0x11, 0xd0, 0xcc, 0xac, 0xdd,
	0x5d, 0xd7, 0x2e, 0x94, 0xaa, 0x12, 0x77, 0xfb, 0x7f, 0xf3, 0xef, 0x7f, 0xf8, 0xfe, 0xc3, 0xce,
	0xc2, 0xdd, 0x30, 0x0a, 0x44, 0xf0, 0x00, 0xb3, 0x2b, 0xfa, 0xc0, 0x1d, 0xd1, 0x30, 0x24, 0x51,
	0x78, 0xf1, 0xea, 0x69, 0x5f, 0x1d, 0xa3, 0x4a, 0x0c, 0x0c, 0xa3, 0xd0, 0x3d, 0x68, 0xfc, 0x99,
	0x85, 0xf2, 0x39, 0x79, 0x29, 0x6c, 0xf2, 0x7c, 0x42, 0xb8, 0x40, 0x16, 0x14, 0x39, 0xe1, 0x9c,
	0x06, 0xcc, 0xca, 0xec, 0x64, 0x76, 0x4b, 0xf6, 0x4c, 0x44, 0xb7, 0xa0, 0xe4, 0x91, 0x6b, 0xea,
	0x12, 0x87, 0x7a, 0x56, 0x56, 0x9d, 0x19, 0x1a, 0xe8, 0x7a, 0xe8, 0x43, 0x00, 0x41, 0x5e, 0x0a,
	0x87, 0xb2, 0x70, 0x22, 0xac, 0x9c, 0x3a, 0x2d, 0x49, 0xa4, 0x2b, 0x01, 0xf4, 0x1d, 0x54, 0x7d,
	0xcc, 0x86, 0x13, 0x3c, 0x24, 0x8e, 0x1b, 0x78, 0xc4, 0xca, 0xef, 0x64, 0x76, 0x6b, 0x07, 0xdb,
	0xfb, 0xc9, 0x58, 0xf6, 0x7b, 0xb1, 0x4a, 0x2b, 0xf0, 0x88, 0x5d, 0xf1, 0x13, 0x12, 0x7a, 0x08,
	0x35, 0xca, 0x04, 0x61, 0xc2, 0xe1, 0x24, 0x92, 0x3e, 0xad, 0x75, 0x65, 0xe1, 0x56, 0xda, 0x42,
	0x57, 0xe9, 0xf4, 0xb5, 0x8a, 0x5d, 0xa5, 0x49, 0x11, 0x7d, 0x0a, 0xe6, 0x25, 0x8d, 0xc6, 0x2f,
	0x70, 0x44, 0x9c, 0x6b, 0x12, 0xa9, 0x1c, 0x0b, 0x2a, 0xd2, 0xfa, 0x0c, 0x7f, 0xa2, 0x61, 0x74,
	0x0f, 0xf2, 0x63, 0x19, 0x66, 0x51, 0x39, 0xd9, 0x4a, 0x3b, 0xb1, 0x83, 0x8b, 0x40, 0x1c, 0xcb,
	0x18, 0x95, 0x12, 0xba, 0x09, 0x06, 0xbf, 0xa2, 0xa1, 0xe3, 0x61, 0x6e, 0x19, 0x3b, 0x99, 0x5d,
	0xc3, 0x2e, 0x4a, 0xf9, 0x10, 0xf3, 0xc6, 0x1f, 0x79, 0xd8, 0xec, 0x8b, 0x88, 0xe0, 0x31, 0x65,
	0x43, 0x1d, 0xdc, 0x3b, 0x12, 0x7d, 0x07, 0xca, 0x8a, 0x63, 0x07, 0x4f, 0x3c, 0x1a, 0x28, 0xa6,
	0x2b, 0x36, 0x28, 0xa8, 0x29, 0x91, 0x77, 0xa7, 0xfa, 0x0e, 0x94, 0x79, 0x48, 0x88, 0x3b, 0x72,
	0x02, 0xe6, 0x4f, 0x15, 0xcf, 0x86, 0x0d, 0x1a, 0x3a, 0x65, 0xfe, 0xf4, 0xbd, 0xf1, 0xb8, 0x05,
	0xc5, 0x8b, 0x20, 0x10, 0x32, 0x6b, 0x43, 0x99, 0x2b, 0x48, 0xb1, 0xeb, 0xa5, 0x08, 0x2e, 0xa5,
	0x08, 0x96, 0x7d, 0xa1, 0x88, 0x70, 0x08, 0x73, 0x03, 0x8f, 0xb2, 0xa1, 0x55, 0x5d, 0xd6, 0x17,
	0x8a, 0x9a, 0x76, 0xac, 0x62, 0x57, 0x71, 0x52, 0x94, 0xf9, 0x70, 0xca, 0x86, 0x3e, 0x71, 0x26,
	0x42, 0x90, 0x08, 0x33, 0x97, 0x58, 0x35, 0xe5, 0xa6, 0xae, 0xf1, 0xc1, 0x0c, 0x5e, 0xd2, 0x86,
	0xf5, 0xb7, 0x6e, 0xc3, 0x2d, 0x28, 0xe2, 0x30, 0x74, 0xae, 0xc8, 0xd4, 0x32, 0x75, 0x9a, 0x38,
	0x0c, 0x1f, 0x93, 0xa9, 0x9c, 0x21, 0x8e, 0xaf, 0x49, 0x5c, 0xd9, 0x0d, 0x15, 0x41, 0x49, 0x22,
	0x2a, 0xfa, 0xc6, 0x6f, 0x39, 0xb8, 0x3d, 0xef, 0xa5, 0xc7, 0x2c, 0x78, 0xe1, 0x13, 0x6f, 0x48,
	0x3a, 0x11, 0x0e, 0x47, 0xff, 0xfb, 0x9e, 0x5a, 0xd6, 0x32, 0xeb, 0xcb, 0x5b, 0xe6, 0xf5, 0x8a,
	0x16, 0xde, 0xba, 0xa2, 0x09, 0x8a, 0x8b, 0x6f, 0xa0, 0xd8, 0x58, 0xa0, 0x38, 0xd9, 0x81, 0xa5,
	0x95, 0x1d, 0x08, 0xe9, 0x0e, 0xdc, 0x06, 0x43, 0xd0, 0x31, 0xf9, 0x29, 0x60, 0xc4, 0x2a, 0x6b,
	0x62, 0x67, 0x72, 0xe3, 0xe7, 0x2c, 0xdc, 0x99, 0x97, 0xac, 0x15, 0x30, 0x46, 0x5c, 0x41, 0x03,
	0xd6, 0x1a, 0x11, 0xf7, 0xea, 0x7d, 0xd7, 0x6c, 0x19, 0xe5, 0xf9, 0xe5, 0x94, 0x27, 0xe8, 0x5a,
	0x4f, 0xd1, 0x75, 0x17, 0x6a, 0x22, 0x10, 0xd8, 0xd7, 0x4e, 0x9c, 0x31, 0x57, 0xb5, 0xa8, 0xda,
	0x15, 0x85, 0x2a, 0x3f, 0xc7, 0x1c, 0xed, 0xc1, 0x86, 0x3e, 0x0f, 0x49, 0xe4, 0x44, 0x3a, 0x2d,
	0xc5, 0x7b, 0xd5, 0xae, 0xab, 0x83, 0x33, 0x12, 0xc5, 0xd9, 0x36, 0x7e, 0xcd, 0x42, 0x6d, 0xb6,
	0x07, 0x79, 0x18, 0x30, 0x4e, 0xfe, 0x2b, 0x01, 0x37, 0xc1, 0xa0, 0xdc, 0xb9, 0xa4, 0x0c, 0xfb,
	0x2a, 0x7b, 0xc3, 0x2e, 0x52, 0x7e, 0x24, 0x45, 0xd9, 0xae, 0xf1, 0x94, 0x46, 0x84, 0x4f, 0x7c,
	0xa1, 0xf2, 0x2e, 0x2f, 0xb6, 0xeb, 0x3c, 0x8c, 0x89, 0x2f, 0xec, 0x0a, 0x4d, 0x48, 0xd2, 0x40,
	0xbc, 0x02, 0x63, 0x03, 0xeb, 0xcb, 0x0c, 0xf4, 0x95, 0xca, 0xcc, 0x00, 0x4f, 0x48, 0xf3, 0xbd,
	0x57, 0xf8, 0x97, 0xdf, 0x0f, 0xcd, 0x1f, 0xf5, 0xe2, 0x8d, 0x50, 0x54, 0x72, 0xd7, 0x6b, 0x74,
	0xa1, 0x92, 0xf4, 0x82, 0x6e, 0x03, 0x88, 0x08, 0x33, 0xee, 0x46, 0x34, 0x14, 0x31, 0x5d, 0x09,
	0x24, 0x45, 0x4a, 0x36, 0x45, 0x4a, 0xe3, 0xf7, 0x1c, 0x54, 0x92, 0x29, 0xcb, 0x59, 0x78, 0x3e,
	0x21, 0xd1, 0xd4, 0x91, 0x9f, 0xe9, 0xd8, 0x56, 0x49, 0x21, 0xf2, 0x3e, 0x80, 0x36, 0xa1, 0x80,
	0x55, 0xb7, 0xc6, 0xcc, 0xc7, 0x12, 0xba, 0x07, 0x1b, 0x31, 0xb9, 0x6e, 0xc0, 0x2e, 0xa9, 0x47,
	0xe4, 0xba, 0x94, 0x05, 0xc8, 0xda, 0xa6, 0x3e, 0x68, 0xcd, 0x71, 0xa9, 0x1c, 0x13, 0x99, 0x50,
	0xce, 0x6b, 0x65, 0x7d, 0x90, 0x50, 0xfe, 0x1e, 0x20, 0xc4, 0x11, 0x1e, 0x13, 0x41, 0x22, 0x6e,
	0xad, 0xef, 0xe4, 0x76, 0xcb, 0x07, 0x7b, 0xab, 0x6b, 0xb6, 0x7f, 0x36, 0x57, 0x6e, 0x33, 0x11,
	0x4d, 0xed, 0xc4, 0xdb, 0xe8, 0x4b, 0xd8, 0xc4, 0xbe, 0xef, 0xbc, 0x42, 0x9c, 0x30, 0x22, 0x9c,
	0x30, 0xa1, 0x4a, 0x62, 0xd8, 0x37, 0xb0, 0xef, 0xbf, 0x7a, 0xff, 0x4c, 0x9f, 0xc9, 0xa1, 0x1a,
	0x61, 0x2e, 0x63, 0x55, 0x9c, 0x14, 0xf5, 0xa7, 0x6f, 0x84, 0x79, 0x4b, 0x23, 0xe8, 0x2b, 0xd9,
	0xab, 0x7a, 0xf1, 0x1b, 0xff, 0xbc, 0xf8, 0x67, 0xba, 0xdb, 0xdf, 0x42, 0x7d, 0x21, 0x58, 0x64,
	0x42, 0x4e, 0xce, 0x9b, 0xa6, 0x5d, 0x3e, 0xa2, 0x1b, 0xb0, 0x7e, 0x8d, 0xfd, 0x09, 0x89, 0xf9,
	0xd6, 0xc2, 0x37, 0xd9, 0xaf, 0x33, 0x8d, 0xbf, 0x32, 0xb0, 0xb9, 0xb8, 0xf0, 0xdf, 0x6d, 0x78,
	0xd2, 0xb5, 0xcf, 0x2d, 0xd6, 0x5e, 0x5d, 0x01, 0x82, 0x2b, 0xc2, 0xf4, 0xb9, 0x5e, 0x1b, 0xa0,
	0x21, 0xa5, 0xf0, 0x11, 0x54, 0xdc, 0x60, 0x3c, 0xc6, 0xcc, 0x73, 0xc4, 0x34, 0x24, 0xf1, 0xda,
	0x28, 0xc7, 0xd8, 0xf9, 0x34, 0x24, 0x52, 0xc5, 0x0b, 0xc6, 0x98, 0x32, 0xee, 0x4c, 0x38, 0xf1,
	0xac, 0xc2, 0x4e, 0x4e, 0xaa, 0xc4, 0xd8, 0x80, 0x13, 0x2f, 0xd5, 0xf8, 0xc5, 0x74, 0xe3, 0x3f,
	0x83, 0xad, 0xd7, 0xf6, 0x65, 0x9c, 0xf2, 0x26, 0x14, 0xb8, 0xc0, 0x62, 0xc2, 0xe3, 0x8c, 0x63,
	0x09, 0x7d, 0x02, 0xf5, 0x4b, 0xc9, 0x31, 0x77, 0x22, 0xe2, 0x12, 0x7a, 0x4d, 0x74, 0xda, 0x55,
	0xbb, 0xa6, 0x61, 0x3b, 0x46, 0x1b, 0x03, 0xa8, 0x3f, 0x25, 0x58, 0x8c, 0x48, 0xd4, 0x0b, 0x5c,
	0xac, 0x9a, 0x1a, 0x41, 0xde, 0xa5, 0x62, 0x56, 0x0e, 0xf5, 0x2c, 0xeb, 0x21, 0x2d, 0xcf, 0xeb,
	0xa1, 0x04, 0x49, 0xb8, 0x1b, 0x4c, 0x64, 0x09, 0x63, 0xda, 0x66, 0xe2, 0xde, 0x13, 0xa8, 0x24,
	0xbf, 0x80, 0xa8, 0x06, 0xd0, 0x3e, 0xe9, 0xf4, 0xba, 0xfd, 0x47, 0xce, 0xa0, 0x6f, 0xae, 0xa5,
	0xe4, 0xc7, 0x66, 0x26, 0x29, 0x37, 0x07, 0x66, 0x16, 0x01, 0x14, 0x3a, 0x6d, 0xfb, 0xb8, 0x79,
	0x62, 0xe6, 0xe4, 0xf3, 0x91, 0xdd, 0x3e, 0x69, 0x3d, 0x32, 0xf3, 0x7b, 0x87, 0x50, 0x4d, 0xb5,
	0x15, 0x2a, 0x43, 0xf1, 0xb0, 0x7d, 0xd4, 0x1c, 0xf4, 0xce, 0xb5, 0xd5, 0xc3, 0x6e, 0xb3, 0x77,
	0xda, 0x39, 0xea, 0x9d, 0x3e, 0x35, 0x33, 0xa8, 0x0a, 0xa5, 0x87, 0xdd, 0x93, 0x8e, 0xd3, 0x1b,
	0x74, 0xfb, 0x66, 0x16, 0x15, 0x21, 0xd7, 0x6b, 0xff, 0x60, 0xe6, 0xf6, 0xee, 0x43, 0x35, 0xf5,
	0xc9, 0x94, 0x2f, 0xf6, 0xba, 0x27, 0xed, 0xa6, 0xed, 0x9c, 0xb5, 0x8e, 0xcd, 0x35, 0x54, 0x01,
	0xe3, 0xb4, 0xd3, 0x71, 0x4e, 0xcf, 0x06, 0x7d, 0x33, 0xb3, 0xb7, 0x0b, 0xa5, 0xf9, 0x9a, 0x42,
	0x1b, 0x50, 0x7d, 0x72, 0xda, 0x6d, 0xb5, 0x9d, 0xd6, 0xe9, 0xf1, 0x71, 0xf3, 0xe4, 0xd0, 0x5c,
	0x43, 0x06, 0xe4, 0x3b, 0xcd, 0xe3, 0xb6, 0x99, 0x39, 0xf8, 0x25, 0x07, 0xe5, 0x96, 0x9e, 0x81,
	0x4e, 0x14, 0xba, 0xa8, 0x03, 0x70, 0xae, 0xee, 0xfd, 0x32, 0x64, 0x74, 0x33, 0x3d, 0x1f, 0x89,
	0x3f, 0x8d, 0xed, 0x0f, 0x56, 0x8c, 0xb6, 0xaa, 0x72, 0x63, 0x0d, 0xfd, 0x08, 0xf5, 0x85, 0xab,
	0x33, 0xba, 0xbb, 0xb0, 0x80, 0x97, 0xde, 0xac, 0xdf, 0x6c, 0x78, 0x37, 0xf3, 0x79, 0x06, 0x3d,
	0x87, 0xad, 0x15, 0x37, 0x29, 0xf4, 0xd9, 0x0a, 0x17, 0x4b, 0x2f, 0x5c, 0xdb, 0x0b, 0x01, 0x2d,
	0x1f, 0x52, 0xe5, 0x52, 0x80, 0xb5, 0xea, 0x26, 0x80, 0xee, 0xaf, 0xf0, 0xb9, 0xfc, 0xc6, 0xb0,
	0xfd, 0x71, 0x5a, 0x7d, 0xc5, 0x9c, 0x48, 0xaf, 0x0f, 0x6b, 0xcf, 0x52, 0x7f, 0x7b, 0x17, 0x05,
	0xf5, 0x0b, 0xf8, 0xc5, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xe7, 0x69, 0x04, 0xcb, 0x2a, 0x0e,
	0x00, 0x00,
}
