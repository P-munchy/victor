// Copyright 2014 Anki, Inc.
// Author: Gareth Watts <gareth@anki.com>

// Integration tests for the Accounts API

package integration

import (
	"flag"
	"fmt"
	"os"
	"strconv"
	"testing"

	. "github.com/anki/sai-go-accounts/integration/testutil"
	"github.com/anki/sai-go-util/envconfig"
	"github.com/anki/sai-go-util/strutil"
	"github.com/stretchr/testify/suite"
)

var (
	useDocker         bool
	accountsBin       string
	accountsApiUrl    string = "http://localhost:8000"
	postmarkApiKey           = "NO_EMAIL"
	accountsApiPort          = "8182" // something not too likely to collide
	profilePort              = "8183" // something not too likely to collide
	adminAppKey              = "admin-key"
	adminSessionToken string
	cronAppKey        = "cron-key"
	userAppKey        = "user-key"
	supportAppKey     = "support-key"
	serviceAppKey     = "service-key"
	rateLimitedAppKey = "rate-limited-key"
	dumpLog           bool
	enable            bool
	config            *envconfig.Config
	profileMode       string

	// Singletons shared amongst suites
	activeDocker *AccountsDockerEnv
	activeClient *AccountsClient
)

func init() {
	config = envconfig.New()
	config.Flags = flag.CommandLine // merge with the test runner's flag set
	config.Bool(&useDocker, "USE_DOCKER", "docker", "Run tests against a server running in a docker container - requires accountbin to be set")
	config.String(&accountsApiUrl, "ACCOUNTS_API_URL", "accountsapi", "The base URL for the Accounts API server (ignored if the docker flag is set)")
	config.String(&accountsBin, "ACCOUNTS_BIN", "accountsbin", "Path of the accounts api binary to test (use with -docker)")
	config.String(&adminAppKey, "ADMIN_APP_KEY", "admin-app-key", "App key to use for admin scope operations (unnecessary with -docker)")
	config.String(&cronAppKey, "CRON_APP_KEY", "cron-app-key", "App key to use for cron scope operations (unnecessary with -docker)")
	config.String(&userAppKey, "USER_APP_KEY", "user-app-key", "App key to use for user scope operations (unnecessary with -docker)")
	config.String(&supportAppKey, "SUPPORT_APP_KEY", "support-app-key", "App key to use for support scope operations (unnecessary with -docker)")
	config.String(&serviceAppKey, "SERVICE_APP_KEY", "service-app-key", "App key to use for service scope operations (unnecessary with -docker)")
	config.String(&profileMode, "PROFILE_MODE", "profile-mode", "Capture accounts server profiling information.  Can be set to cpu, mem or block")
	config.Bool(&dumpLog, "DUMP_LOG", "dump-log", "Enable to have the logs generated by the accounts api server dumped to stdout on exit (only works with -docker)")
	config.Bool(&enable, "INTEGRATION", "integration", "Enables integration tests")
}

type mastersuite interface {
	setclient(client *AccountsClient, server *AccountsDockerEnv)
}

var registeredSuites []mastersuite

func registerSuite(s mastersuite) {
	registeredSuites = append(registeredSuites, s)
}

type SeedAccount struct {
	Username string
	UserId   string
	Email    string
	Token    string
}

type Suite struct {
	suite.Suite
	_client      *AccountsClient // don't access this directly, use s.Client() instead, which gives you a copy
	server       *AccountsDockerEnv
	seedAccounts []SeedAccount
}

func (s *Suite) setclient(client *AccountsClient, server *AccountsDockerEnv) {
	s._client = client
	s.server = server
}

func (s *Suite) Client() *AccountsClient {
	c := *s._client
	return &c
}

func (s *Suite) SetupSuite() {
}

func (s *Suite) TearDownSuite() {
}

// TestMaster handles the global setup/teardown of the docker environment
// that all test suites use.
// Once that's up, it runs every suite that's registered itself using
// RegisterSuite()
func TestMaster(t *testing.T) {
	if !enable {
		return
	}
	server, client := setupEnv()
	defer tearDownEnv(server)
	for _, sub := range registeredSuites {
		sub.setclient(client, server)
		suite.Run(t, sub.(suite.TestingSuite))
	}
}

func setupEnv() (server *AccountsDockerEnv, client *AccountsClient) {
	config.Flags.Parse(os.Args[1:])
	accountsAppKeys := map[Scope]string{
		Admin:   adminAppKey,
		Cron:    cronAppKey,
		User:    userAppKey,
		Support: supportAppKey,
		Service: serviceAppKey,
	}
	// bring up containers, if requested
	if useDocker {
		server = &AccountsDockerEnv{
			AppKeys:         accountsAppKeys,
			PostmarkApiKey:  postmarkApiKey,
			UserAppKey:      userAppKey,
			AccountsApiPort: accountsApiPort,
			ProfilePort:     profilePort,
			AccountsBin:     accountsBin,
			DumpLog:         dumpLog,
			ProfileMode:     profileMode,
		}
		if err := server.Start(); err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		client = &AccountsClient{
			ServerUrl: server.Url(),
		}
		adminSessionToken = server.AdminSessionToken
	} else {
		client = &AccountsClient{
			ServerUrl: accountsApiUrl,
		}
	}
	client.AppKey = userAppKey // Default to the user scope
	return server, client
}

func tearDownEnv(server *AccountsDockerEnv) {
	if server != nil {
		server.Stop()
	}
}

// The AccountsSuite holds most of the test cases
type AccountsSuite struct {
	Suite
}

// Make sure the AccountsSuite is registered to run by the TestMaster
func init() {
	registerSuite(new(AccountsSuite))
}

func (s *Suite) TearDownTest() {
	for _, account := range s.seedAccounts {
		s.DeleteUser(account.Token, account.UserId)
	}
	s.seedAccounts = nil
}

// Create seed accounts
func (s *Suite) SeedAccounts(t *testing.T) {
	client := s.Client()

	for i := 0; i < 10; i++ {
		password := strutil.LowerStr(10)
		userInfo := map[string]interface{}{
			"username":    "ak" + strconv.Itoa(i),
			"password":    password,
			"email":       "seed-account-" + strconv.Itoa(i) + "@example.com",
			"family_name": "seed-account-" + strconv.Itoa(i),
		}
		_, jdata, err := client.CreateUser(userInfo)
		if err != nil {
			t.Fatal("Error creating seed accounts", err)
		}
		s.seedAccounts = append(s.seedAccounts, SeedAccount{
			Token:    jdata.FieldStrQ("session", "session_token"),
			UserId:   jdata.FieldStrQ("user", "user_id"),
			Username: jdata.FieldStrQ("user", "username"),
			Email:    jdata.FieldStrQ("user", "email"),
		})
	}
}

func (s *Suite) DeleteUser(sessionToken, userId string) error {
	client := s.Client()
	client.SessionToken = sessionToken
	_, jdata, err := client.DeleteUser(userId)
	if err != nil {
		return err
	}
	if jdata.FieldStrQ("status") != "OK" {
		return fmt.Errorf("Delete failed: %v", jdata)
	}
	return nil
}
