// A TimedToken is a token that cryptographically includes a timestamp.
// It is typically used as a token you supply for password reset, account verification.
// They will look like: 114052210176m42swe6a9ufxksgneqfmkd
// 1 [format] 1405221017 [epoch created] 6m42s [random]
// We do not create a new TimedToken type because that would make it harder to store
//  null values for it in the database.

package timedtoken

import (
	"fmt"
	"strconv"
	"time"

	"github.com/anki/sai-go-util/strutil"
)

const tokenVersion = "1"

// We'll allow the server clocks to skew up to 10 minutes between machines
const ClockSkew = time.Minute * 10

// getToken will return a timed token.
func Token() string {
	return TokenFromTime(time.Now())
}

// TokenFromTime creates a token valid from the time specified, rather than the current time.
// This is typically used during testing, as it calls the same underlying token creation code as Token().
// 'now' should typically be generated by some manipulation of time.Now()
// If using this, see also the now argument to Valid
func TokenFromTime(now time.Time) string {
	rs, err := strutil.ShortLowerUUID()
	if err != nil {
		rs = fmt.Sprintf("%d", now.UnixNano())
		rs = string(rs[10:15])
	}
	rsShort := string(rs[0:5])
	return fmt.Sprintf("%s%d%s", tokenVersion, now.Unix(), rsShort)
}

func Valid(token string, lifetime time.Duration, now ...time.Time) bool {
	if token == "" {
		return false
	}

	// We only handle type1 tokens for now
	ver := string(token[0])
	if ver != "1" {
		return false
	}

	if len(token) != 16 {
		return false
	}

	currentTime := time.Now()
	if now != nil {
		currentTime = now[0]
	}

	tokenTimeS := token[1:11]
	tokenTimeI, err := strconv.Atoi(string(tokenTimeS))
	if err != nil {
		return false
	}

	tokenTime := time.Unix(int64(tokenTimeI), 0)
	if tokenTime.After(currentTime.Add(ClockSkew)) {
		// Token created in the far future
		return false
	}

	if tokenTime.Before(currentTime.Add(-lifetime).Add(-ClockSkew)) {
		// Too Old
		return false
	}

	return true
}
