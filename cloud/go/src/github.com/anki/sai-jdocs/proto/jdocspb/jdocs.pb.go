// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/jdocspb/jdocs.proto

/*
Package jdocspb is a generated protocol buffer package.

It is generated from these files:
	proto/jdocspb/jdocs.proto

It has these top-level messages:
	Jdoc
	EchoReq
	EchoResp
	WriteDocReq
	WriteDocResp
	ReadDocsReq
	ReadDocsResp
	DeleteDocReq
	DeleteDocResp
*/
package jdocspb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type WriteDocResp_Status int32

const (
	WriteDocResp_ACCEPTED                 WriteDocResp_Status = 0
	WriteDocResp_REJECTED_BAD_DOC_VERSION WriteDocResp_Status = 1
	WriteDocResp_REJECTED_BAD_FMT_VERSION WriteDocResp_Status = 2
	WriteDocResp_ERROR                    WriteDocResp_Status = 3
)

var WriteDocResp_Status_name = map[int32]string{
	0: "ACCEPTED",
	1: "REJECTED_BAD_DOC_VERSION",
	2: "REJECTED_BAD_FMT_VERSION",
	3: "ERROR",
}
var WriteDocResp_Status_value = map[string]int32{
	"ACCEPTED":                 0,
	"REJECTED_BAD_DOC_VERSION": 1,
	"REJECTED_BAD_FMT_VERSION": 2,
	"ERROR":                    3,
}

func (x WriteDocResp_Status) String() string {
	return proto.EnumName(WriteDocResp_Status_name, int32(x))
}
func (WriteDocResp_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type ReadDocsResp_Status int32

const (
	ReadDocsResp_UNCHANGED         ReadDocsResp_Status = 0
	ReadDocsResp_CHANGED           ReadDocsResp_Status = 1
	ReadDocsResp_NOT_FOUND         ReadDocsResp_Status = 2
	ReadDocsResp_PERMISSION_DENIED ReadDocsResp_Status = 3
)

var ReadDocsResp_Status_name = map[int32]string{
	0: "UNCHANGED",
	1: "CHANGED",
	2: "NOT_FOUND",
	3: "PERMISSION_DENIED",
}
var ReadDocsResp_Status_value = map[string]int32{
	"UNCHANGED":         0,
	"CHANGED":           1,
	"NOT_FOUND":         2,
	"PERMISSION_DENIED": 3,
}

func (x ReadDocsResp_Status) String() string {
	return proto.EnumName(ReadDocsResp_Status_name, int32(x))
}
func (ReadDocsResp_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

type Jdoc struct {
	DocVersion     uint64 `protobuf:"varint,1,opt,name=doc_version,json=docVersion" json:"doc_version,omitempty"`
	FmtVersion     uint64 `protobuf:"varint,2,opt,name=fmt_version,json=fmtVersion" json:"fmt_version,omitempty"`
	ClientMetadata string `protobuf:"bytes,3,opt,name=client_metadata,json=clientMetadata" json:"client_metadata,omitempty"`
	JsonDoc        string `protobuf:"bytes,4,opt,name=json_doc,json=jsonDoc" json:"json_doc,omitempty"`
}

func (m *Jdoc) Reset()                    { *m = Jdoc{} }
func (m *Jdoc) String() string            { return proto.CompactTextString(m) }
func (*Jdoc) ProtoMessage()               {}
func (*Jdoc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Jdoc) GetDocVersion() uint64 {
	if m != nil {
		return m.DocVersion
	}
	return 0
}

func (m *Jdoc) GetFmtVersion() uint64 {
	if m != nil {
		return m.FmtVersion
	}
	return 0
}

func (m *Jdoc) GetClientMetadata() string {
	if m != nil {
		return m.ClientMetadata
	}
	return ""
}

func (m *Jdoc) GetJsonDoc() string {
	if m != nil {
		return m.JsonDoc
	}
	return ""
}

type EchoReq struct {
	Data string `protobuf:"bytes,1,opt,name=Data" json:"Data,omitempty"`
}

func (m *EchoReq) Reset()                    { *m = EchoReq{} }
func (m *EchoReq) String() string            { return proto.CompactTextString(m) }
func (*EchoReq) ProtoMessage()               {}
func (*EchoReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EchoReq) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type EchoResp struct {
	Data string `protobuf:"bytes,1,opt,name=Data" json:"Data,omitempty"`
}

func (m *EchoResp) Reset()                    { *m = EchoResp{} }
func (m *EchoResp) String() string            { return proto.CompactTextString(m) }
func (*EchoResp) ProtoMessage()               {}
func (*EchoResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *EchoResp) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type WriteDocReq struct {
	Account string `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Thing   string `protobuf:"bytes,2,opt,name=thing" json:"thing,omitempty"`
	DocName string `protobuf:"bytes,3,opt,name=doc_name,json=docName" json:"doc_name,omitempty"`
	Doc     *Jdoc  `protobuf:"bytes,4,opt,name=doc" json:"doc,omitempty"`
}

func (m *WriteDocReq) Reset()                    { *m = WriteDocReq{} }
func (m *WriteDocReq) String() string            { return proto.CompactTextString(m) }
func (*WriteDocReq) ProtoMessage()               {}
func (*WriteDocReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *WriteDocReq) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *WriteDocReq) GetThing() string {
	if m != nil {
		return m.Thing
	}
	return ""
}

func (m *WriteDocReq) GetDocName() string {
	if m != nil {
		return m.DocName
	}
	return ""
}

func (m *WriteDocReq) GetDoc() *Jdoc {
	if m != nil {
		return m.Doc
	}
	return nil
}

type WriteDocResp struct {
	Status           WriteDocResp_Status `protobuf:"varint,1,opt,name=status,enum=jdocspb.WriteDocResp_Status" json:"status,omitempty"`
	LatestDocVersion uint64              `protobuf:"varint,2,opt,name=latest_doc_version,json=latestDocVersion" json:"latest_doc_version,omitempty"`
}

func (m *WriteDocResp) Reset()                    { *m = WriteDocResp{} }
func (m *WriteDocResp) String() string            { return proto.CompactTextString(m) }
func (*WriteDocResp) ProtoMessage()               {}
func (*WriteDocResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *WriteDocResp) GetStatus() WriteDocResp_Status {
	if m != nil {
		return m.Status
	}
	return WriteDocResp_ACCEPTED
}

func (m *WriteDocResp) GetLatestDocVersion() uint64 {
	if m != nil {
		return m.LatestDocVersion
	}
	return 0
}

type ReadDocsReq struct {
	Account string              `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Thing   string              `protobuf:"bytes,2,opt,name=thing" json:"thing,omitempty"`
	Items   []*ReadDocsReq_Item `protobuf:"bytes,3,rep,name=items" json:"items,omitempty"`
}

func (m *ReadDocsReq) Reset()                    { *m = ReadDocsReq{} }
func (m *ReadDocsReq) String() string            { return proto.CompactTextString(m) }
func (*ReadDocsReq) ProtoMessage()               {}
func (*ReadDocsReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ReadDocsReq) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *ReadDocsReq) GetThing() string {
	if m != nil {
		return m.Thing
	}
	return ""
}

func (m *ReadDocsReq) GetItems() []*ReadDocsReq_Item {
	if m != nil {
		return m.Items
	}
	return nil
}

type ReadDocsReq_Item struct {
	DocName      string `protobuf:"bytes,1,opt,name=doc_name,json=docName" json:"doc_name,omitempty"`
	MyDocVersion uint64 `protobuf:"varint,2,opt,name=my_doc_version,json=myDocVersion" json:"my_doc_version,omitempty"`
}

func (m *ReadDocsReq_Item) Reset()                    { *m = ReadDocsReq_Item{} }
func (m *ReadDocsReq_Item) String() string            { return proto.CompactTextString(m) }
func (*ReadDocsReq_Item) ProtoMessage()               {}
func (*ReadDocsReq_Item) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

func (m *ReadDocsReq_Item) GetDocName() string {
	if m != nil {
		return m.DocName
	}
	return ""
}

func (m *ReadDocsReq_Item) GetMyDocVersion() uint64 {
	if m != nil {
		return m.MyDocVersion
	}
	return 0
}

type ReadDocsResp struct {
	Items []*ReadDocsResp_Item `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *ReadDocsResp) Reset()                    { *m = ReadDocsResp{} }
func (m *ReadDocsResp) String() string            { return proto.CompactTextString(m) }
func (*ReadDocsResp) ProtoMessage()               {}
func (*ReadDocsResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ReadDocsResp) GetItems() []*ReadDocsResp_Item {
	if m != nil {
		return m.Items
	}
	return nil
}

type ReadDocsResp_Item struct {
	Status ReadDocsResp_Status `protobuf:"varint,1,opt,name=status,enum=jdocspb.ReadDocsResp_Status" json:"status,omitempty"`
	Doc    *Jdoc               `protobuf:"bytes,2,opt,name=doc" json:"doc,omitempty"`
}

func (m *ReadDocsResp_Item) Reset()                    { *m = ReadDocsResp_Item{} }
func (m *ReadDocsResp_Item) String() string            { return proto.CompactTextString(m) }
func (*ReadDocsResp_Item) ProtoMessage()               {}
func (*ReadDocsResp_Item) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

func (m *ReadDocsResp_Item) GetStatus() ReadDocsResp_Status {
	if m != nil {
		return m.Status
	}
	return ReadDocsResp_UNCHANGED
}

func (m *ReadDocsResp_Item) GetDoc() *Jdoc {
	if m != nil {
		return m.Doc
	}
	return nil
}

type DeleteDocReq struct {
	Account string `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Thing   string `protobuf:"bytes,2,opt,name=thing" json:"thing,omitempty"`
	DocName string `protobuf:"bytes,3,opt,name=doc_name,json=docName" json:"doc_name,omitempty"`
}

func (m *DeleteDocReq) Reset()                    { *m = DeleteDocReq{} }
func (m *DeleteDocReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteDocReq) ProtoMessage()               {}
func (*DeleteDocReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DeleteDocReq) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *DeleteDocReq) GetThing() string {
	if m != nil {
		return m.Thing
	}
	return ""
}

func (m *DeleteDocReq) GetDocName() string {
	if m != nil {
		return m.DocName
	}
	return ""
}

type DeleteDocResp struct {
}

func (m *DeleteDocResp) Reset()                    { *m = DeleteDocResp{} }
func (m *DeleteDocResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteDocResp) ProtoMessage()               {}
func (*DeleteDocResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func init() {
	proto.RegisterType((*Jdoc)(nil), "jdocspb.Jdoc")
	proto.RegisterType((*EchoReq)(nil), "jdocspb.EchoReq")
	proto.RegisterType((*EchoResp)(nil), "jdocspb.EchoResp")
	proto.RegisterType((*WriteDocReq)(nil), "jdocspb.WriteDocReq")
	proto.RegisterType((*WriteDocResp)(nil), "jdocspb.WriteDocResp")
	proto.RegisterType((*ReadDocsReq)(nil), "jdocspb.ReadDocsReq")
	proto.RegisterType((*ReadDocsReq_Item)(nil), "jdocspb.ReadDocsReq.Item")
	proto.RegisterType((*ReadDocsResp)(nil), "jdocspb.ReadDocsResp")
	proto.RegisterType((*ReadDocsResp_Item)(nil), "jdocspb.ReadDocsResp.Item")
	proto.RegisterType((*DeleteDocReq)(nil), "jdocspb.DeleteDocReq")
	proto.RegisterType((*DeleteDocResp)(nil), "jdocspb.DeleteDocResp")
	proto.RegisterEnum("jdocspb.WriteDocResp_Status", WriteDocResp_Status_name, WriteDocResp_Status_value)
	proto.RegisterEnum("jdocspb.ReadDocsResp_Status", ReadDocsResp_Status_name, ReadDocsResp_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Jdocs service

type JdocsClient interface {
	Echo(ctx context.Context, in *EchoReq, opts ...grpc.CallOption) (*EchoResp, error)
	// Write = Create or Update one document
	WriteDoc(ctx context.Context, in *WriteDocReq, opts ...grpc.CallOption) (*WriteDocResp, error)
	// Read latest version of one or more documents (single account/thing)
	ReadDocs(ctx context.Context, in *ReadDocsReq, opts ...grpc.CallOption) (*ReadDocsResp, error)
	// Delete one document. If the document does not exist, the request
	// quietly succeeds (no error).
	DeleteDoc(ctx context.Context, in *DeleteDocReq, opts ...grpc.CallOption) (*DeleteDocResp, error)
}

type jdocsClient struct {
	cc *grpc.ClientConn
}

func NewJdocsClient(cc *grpc.ClientConn) JdocsClient {
	return &jdocsClient{cc}
}

func (c *jdocsClient) Echo(ctx context.Context, in *EchoReq, opts ...grpc.CallOption) (*EchoResp, error) {
	out := new(EchoResp)
	err := grpc.Invoke(ctx, "/jdocspb.Jdocs/Echo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jdocsClient) WriteDoc(ctx context.Context, in *WriteDocReq, opts ...grpc.CallOption) (*WriteDocResp, error) {
	out := new(WriteDocResp)
	err := grpc.Invoke(ctx, "/jdocspb.Jdocs/WriteDoc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jdocsClient) ReadDocs(ctx context.Context, in *ReadDocsReq, opts ...grpc.CallOption) (*ReadDocsResp, error) {
	out := new(ReadDocsResp)
	err := grpc.Invoke(ctx, "/jdocspb.Jdocs/ReadDocs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jdocsClient) DeleteDoc(ctx context.Context, in *DeleteDocReq, opts ...grpc.CallOption) (*DeleteDocResp, error) {
	out := new(DeleteDocResp)
	err := grpc.Invoke(ctx, "/jdocspb.Jdocs/DeleteDoc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Jdocs service

type JdocsServer interface {
	Echo(context.Context, *EchoReq) (*EchoResp, error)
	// Write = Create or Update one document
	WriteDoc(context.Context, *WriteDocReq) (*WriteDocResp, error)
	// Read latest version of one or more documents (single account/thing)
	ReadDocs(context.Context, *ReadDocsReq) (*ReadDocsResp, error)
	// Delete one document. If the document does not exist, the request
	// quietly succeeds (no error).
	DeleteDoc(context.Context, *DeleteDocReq) (*DeleteDocResp, error)
}

func RegisterJdocsServer(s *grpc.Server, srv JdocsServer) {
	s.RegisterService(&_Jdocs_serviceDesc, srv)
}

func _Jdocs_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JdocsServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jdocspb.Jdocs/Echo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JdocsServer).Echo(ctx, req.(*EchoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jdocs_WriteDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteDocReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JdocsServer).WriteDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jdocspb.Jdocs/WriteDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JdocsServer).WriteDoc(ctx, req.(*WriteDocReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jdocs_ReadDocs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadDocsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JdocsServer).ReadDocs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jdocspb.Jdocs/ReadDocs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JdocsServer).ReadDocs(ctx, req.(*ReadDocsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jdocs_DeleteDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDocReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JdocsServer).DeleteDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jdocspb.Jdocs/DeleteDoc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JdocsServer).DeleteDoc(ctx, req.(*DeleteDocReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Jdocs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "jdocspb.Jdocs",
	HandlerType: (*JdocsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Echo",
			Handler:    _Jdocs_Echo_Handler,
		},
		{
			MethodName: "WriteDoc",
			Handler:    _Jdocs_WriteDoc_Handler,
		},
		{
			MethodName: "ReadDocs",
			Handler:    _Jdocs_ReadDocs_Handler,
		},
		{
			MethodName: "DeleteDoc",
			Handler:    _Jdocs_DeleteDoc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/jdocspb/jdocs.proto",
}

func init() { proto.RegisterFile("proto/jdocspb/jdocs.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 617 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xdd, 0x4e, 0xdb, 0x4c,
	0x10, 0x65, 0xf3, 0x43, 0x92, 0x71, 0x00, 0xb3, 0x82, 0x4f, 0x26, 0xe2, 0x2b, 0xc8, 0xaa, 0x54,
	0x2e, 0xda, 0x50, 0xa5, 0xbd, 0xa9, 0xd4, 0x1b, 0x9a, 0x35, 0x34, 0x48, 0x38, 0x68, 0x09, 0x54,
	0xbd, 0x40, 0x96, 0x59, 0x2f, 0x25, 0x08, 0x7b, 0x0d, 0xbb, 0x54, 0xe2, 0x1d, 0xfa, 0x3e, 0x7d,
	0x8e, 0xbe, 0x46, 0xfb, 0x12, 0xd5, 0xfa, 0x2f, 0x0e, 0x35, 0x37, 0x95, 0x7a, 0x95, 0xcc, 0xcc,
	0x99, 0xdd, 0xb3, 0xe7, 0xcc, 0x18, 0x36, 0xe2, 0x3b, 0xa1, 0xc4, 0xee, 0x75, 0x20, 0x98, 0x8c,
	0x2f, 0xd2, 0xdf, 0x7e, 0x92, 0xc3, 0xad, 0x2c, 0x69, 0x7f, 0x43, 0xd0, 0x38, 0x0c, 0x04, 0xc3,
	0x5b, 0x60, 0x04, 0x82, 0x79, 0x5f, 0xf9, 0x9d, 0x9c, 0x8a, 0xc8, 0x42, 0xdb, 0x68, 0xa7, 0x41,
	0x21, 0x10, 0xec, 0x2c, 0xcd, 0x68, 0xc0, 0x65, 0xa8, 0x0a, 0x40, 0x2d, 0x05, 0x5c, 0x86, 0x2a,
	0x07, 0xbc, 0x80, 0x15, 0x76, 0x33, 0xe5, 0x91, 0xf2, 0x42, 0xae, 0xfc, 0xc0, 0x57, 0xbe, 0x55,
	0xdf, 0x46, 0x3b, 0x1d, 0xba, 0x9c, 0xa6, 0x8f, 0xb2, 0x2c, 0xde, 0x80, 0xf6, 0xb5, 0x14, 0x91,
	0x17, 0x08, 0x66, 0x35, 0x12, 0x44, 0x4b, 0xc7, 0x44, 0x30, 0xfb, 0x7f, 0x68, 0x39, 0xec, 0x4a,
	0x50, 0x7e, 0x8b, 0x31, 0x34, 0x88, 0x3e, 0x03, 0x25, 0x88, 0xe4, 0xbf, 0xfd, 0x0c, 0xda, 0x69,
	0x59, 0xc6, 0x95, 0xf5, 0x07, 0x30, 0x3e, 0xdd, 0x4d, 0x15, 0x27, 0x82, 0xe9, 0x23, 0x2c, 0x68,
	0xf9, 0x8c, 0x89, 0xfb, 0x48, 0x65, 0xa8, 0x3c, 0xc4, 0x6b, 0xd0, 0x54, 0x57, 0xd3, 0xe8, 0x4b,
	0xf2, 0x8c, 0x0e, 0x4d, 0x03, 0x4d, 0x4c, 0x6b, 0x10, 0xf9, 0x21, 0xcf, 0xa8, 0xb7, 0x02, 0xc1,
	0x5c, 0x3f, 0xe4, 0x78, 0x0b, 0xea, 0x39, 0x5d, 0x63, 0xb0, 0xd4, 0xcf, 0xe4, 0xeb, 0x6b, 0xe9,
	0xa8, 0xae, 0xd8, 0x3f, 0x10, 0x74, 0x67, 0x77, 0xcb, 0x18, 0xbf, 0x85, 0x45, 0xa9, 0x7c, 0x75,
	0x2f, 0x93, 0xbb, 0x97, 0x07, 0x9b, 0x45, 0x53, 0x19, 0xd6, 0x3f, 0x49, 0x30, 0x34, 0xc3, 0xe2,
	0x97, 0x80, 0x6f, 0x7c, 0xc5, 0xa5, 0xf2, 0xca, 0x6e, 0xa4, 0x62, 0x9b, 0x69, 0x85, 0x14, 0x9e,
	0xd8, 0xe7, 0xb0, 0x98, 0xf6, 0xe3, 0x2e, 0xb4, 0xf7, 0x86, 0x43, 0xe7, 0x78, 0xe2, 0x10, 0x73,
	0x01, 0x6f, 0x82, 0x45, 0x9d, 0x43, 0x67, 0x38, 0x71, 0x88, 0xf7, 0x61, 0x8f, 0x78, 0x64, 0x3c,
	0xf4, 0xce, 0x1c, 0x7a, 0x32, 0x1a, 0xbb, 0x26, 0xfa, 0xa3, 0xba, 0x7f, 0x34, 0x29, 0xaa, 0x35,
	0xdc, 0x81, 0xa6, 0x43, 0xe9, 0x98, 0x9a, 0x75, 0xfb, 0x3b, 0x02, 0x83, 0x72, 0x3f, 0x20, 0x82,
	0xc9, 0xbf, 0xd1, 0x73, 0x17, 0x9a, 0x53, 0xc5, 0x43, 0x69, 0xd5, 0xb7, 0xeb, 0x3b, 0xc6, 0x60,
	0xa3, 0x50, 0xa0, 0x74, 0x68, 0x7f, 0xa4, 0x78, 0x48, 0x53, 0x5c, 0xef, 0x00, 0x1a, 0x3a, 0x9c,
	0x33, 0x02, 0xcd, 0x1b, 0xf1, 0x1c, 0x96, 0xc3, 0x87, 0x0a, 0x71, 0xba, 0xe1, 0x43, 0x49, 0x98,
	0x5f, 0x08, 0xba, 0xb3, 0x4b, 0x64, 0x8c, 0x5f, 0xe7, 0x54, 0x50, 0x42, 0xa5, 0x57, 0x41, 0x45,
	0xc6, 0x73, 0x5c, 0xce, 0x33, 0x2e, 0x4f, 0xfb, 0x38, 0xd7, 0xfa, 0xc8, 0xc7, 0x6c, 0x5e, 0x6a,
	0x4f, 0xce, 0xcb, 0x61, 0x61, 0xdd, 0x12, 0x74, 0x4e, 0xdd, 0xe1, 0xc7, 0x3d, 0xf7, 0x20, 0xf1,
	0xce, 0x80, 0x56, 0x1e, 0x20, 0x5d, 0x73, 0xc7, 0x13, 0x6f, 0x7f, 0x7c, 0xea, 0x12, 0xb3, 0x86,
	0xd7, 0x61, 0xf5, 0xd8, 0xa1, 0x47, 0xa3, 0x13, 0xed, 0x95, 0x47, 0x1c, 0x77, 0xe4, 0x10, 0xb3,
	0x6e, 0x7f, 0x86, 0x2e, 0xe1, 0x37, 0xfc, 0x1f, 0xcc, 0xbd, 0xbd, 0x02, 0x4b, 0xa5, 0xa3, 0x65,
	0x3c, 0xf8, 0x89, 0xa0, 0xa9, 0x5f, 0x21, 0xf1, 0x2b, 0x68, 0xe8, 0x65, 0xc4, 0x66, 0xf1, 0xba,
	0x6c, 0x75, 0x7b, 0xab, 0x8f, 0x32, 0x32, 0xb6, 0x17, 0xf0, 0x3b, 0x68, 0xe7, 0x83, 0x8f, 0xd7,
	0x2a, 0x76, 0xe1, 0xb6, 0xb7, 0x5e, 0xb9, 0x21, 0x69, 0x6b, 0xae, 0x75, 0xa9, 0xb5, 0x34, 0x44,
	0xa5, 0xd6, 0xb2, 0x29, 0xf6, 0x02, 0x7e, 0x0f, 0x9d, 0x82, 0x3f, 0x9e, 0xa1, 0xca, 0x72, 0xf5,
	0xfe, 0xab, 0x4a, 0xeb, 0xee, 0x8b, 0xc5, 0xe4, 0x6b, 0xf9, 0xe6, 0x77, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xb4, 0xd5, 0xc0, 0x4c, 0x4a, 0x05, 0x00, 0x00,
}
