package svc

import (
	"crypto/tls"
	"fmt"

	"github.com/gwatts/rootcerts"
	"github.com/jawher/mow.cli"
)

// ServerTLSConfig encapsulates all config variables related to
// setting up TLS for an HTTP server, including the necessary
// certificates for identifying the server and for validating client
// certificates for mutual TLS with or without custom CA
// certificates. Instances of ServerTLSConfig should only be obtained
// by calling NewServerTLSConfig().
//
// When initialized, a ServerTLSConfig will create a number of mow.Cli options.
//
// E.g.:
//  --prefix-tls-enable ($PREFIX_TLS_ENABLE)
//  --prefix-validate-client ($PREFIX_VALIDATE_CLIENT)
//    etc...
type ServerTLSConfig struct {
	// Prefix is a simple string that will be pre-pended to all config
	// options generated by this config object, so multiple configs
	// can exist in the same process if needed.
	Prefix string

	// TLSConfig is the generate tls.Config object, cached here for
	// later reference after Load() is called.
	TLSConfig *tls.Config

	// Enabled is a boolean flag to explicitly control the use of
	// TLS. TLS is enabled by default.
	Enabled *bool

	// validateClient is a boolean flag to explicitly control
	// the use of client certification validation, aka mutual TLS. It
	// is enabled by default.
	validateClient *bool

	// tlsCert encapsulates the configuration variables and loading of
	// the x509 certificate/key pair to use for the server's TLS
	// certificate.
	tlsCert *CertConfig

	// clientCAPool configures the pool of root certificates to use
	// for validating client certificates.
	clientCAPool *CertPoolConfig
}

// NewServerTLSConfig returns a new ServerTLSConfig object with all
// its sub-configs properly initialized.
func NewServerTLSConfig(prefix string) *ServerTLSConfig {
	return &ServerTLSConfig{
		Prefix: prefix,
		tlsCert: &CertConfig{
			Prefix: prefix + "-tls",
		},
		clientCAPool: &CertPoolConfig{
			Prefix: prefix + "-tls-client-ca",
		},
	}
}

func (cfg *ServerTLSConfig) argname(arg string) string {
	return fmt.Sprintf("%s-%s", cfg.Prefix, arg)
}

func (cfg *ServerTLSConfig) CommandSpec() string {
	return fmt.Sprintf("[--%s] [--%s] ",
		cfg.argname("tls-enable"),
		cfg.argname("tls-validate-client")) +
		cfg.tlsCert.CommandSpec() + " " +
		cfg.clientCAPool.CommandSpec()
}

func (cfg *ServerTLSConfig) CommandInitialize(cmd *cli.Cmd) {
	if cfg.Enabled == nil {
		cfg.Enabled = BoolOpt(cmd, cfg.argname("tls-enable"), true,
			"Enable the use of TLS")
	}
	if cfg.validateClient == nil {
		cfg.validateClient = BoolOpt(cmd, cfg.argname("tls-validate-client"), false,
			"Enable client certificate validation")
	}
	cfg.tlsCert.CommandInitialize(cmd)
	cfg.clientCAPool.CommandInitialize(cmd)
}

// Load validates the configured values and loads the a tls.Config
// object from them. If TLS is disabled, a nil value will be return
// (with no error).
func (cfg *ServerTLSConfig) Load() (*tls.Config, error) {
	if cfg.Enabled == nil || !*cfg.Enabled {
		return nil, nil
	}

	tlsCfg := &tls.Config{
		RootCAs:    rootcerts.ServerCertPool(),
		NextProtos: []string{"h2"},
	}

	if cfg.tlsCert == nil || cfg.clientCAPool == nil || cfg.validateClient == nil {
		return nil, fmt.Errorf("ServerTLSConfig '%s' not properly initialized", cfg.Prefix)
	}

	if cert, err := cfg.tlsCert.Load(); err != nil {
		return nil, err
	} else {
		tlsCfg.Certificates = []tls.Certificate{*cert}
	}

	if *cfg.validateClient {
		tlsCfg.ClientAuth = tls.RequireAndVerifyClientCert
		if pool, err := cfg.clientCAPool.Load(); err != nil {
			return nil, fmt.Errorf("ServerTLSConfig: Unable to load client CA certificate pool for %s: %s", cfg.Prefix, err)
		} else {
			tlsCfg.ClientCAs = pool
		}
	}
	return tlsCfg, nil
}
