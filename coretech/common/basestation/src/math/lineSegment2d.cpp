/**
 * File: lineSegment2d.cpp
 *
 * Author: Michael Willett
 * Created: 2017-10-12
 *
 * Description: A class that holds a 2d line segment for fast interection checks
 *
 * Copyright: Anki, Inc. 2017
 *
 **/


#include "anki/common/basestation/math/lineSegment2d.h"
#include "anki/common/basestation/math/point_impl.h"
#include <vector>

namespace Anki {

// cache useful data for minor speedup of intersection checks
LineSegment::LineSegment(const Point2f& f, const Point2f& t) 
: from(f)
, to(t)
, minX(fmin(f.x(), t.x())) 
, maxX(fmax(f.x(), t.x())) 
, minY(fmin(f.y(), t.y())) 
, maxY(fmax(f.y(), t.y()))
, dX(t.x() - f.x())
, dY(t.y() - f.y()) {}

bool LineSegment::InBoundingBox(const Point2f& p) const
{
  return (p.x() <= maxX && p.x() >= minX && p.y() <= maxY && p.y() >= minY);
}

bool LineSegment::OnSegment(const Point2f& p) const
{
  return InBoundingBox(p) && (Orientation(p) == EOrientation::COLINEAR);
}

float LineSegment::Dot(const Point2f& p) const
{
  return (dY * (p.x() - from.x()) - dX * (p.y() - from.y()));
}

bool LineSegment::IntersectsWith(const LineSegment& l) const
{
  // Find the four orientations needed for general and special cases
  EOrientation o1 = Orientation(l.from);
  if (o1 == EOrientation::COLINEAR && InBoundingBox(l.from)) 
  { 
    return true;
  }
  
  EOrientation o2 = Orientation(l.to);
  if (o2 == EOrientation::COLINEAR && InBoundingBox(l.to))
  { 
    return true;
  }
  
  if (o1 == o2)  // both points of test segment are on the same side of this line
  {
    return false;
  }
  
  EOrientation o3 = l.Orientation(from);
  if (o3 == EOrientation::COLINEAR && l.InBoundingBox(from)) 
  { 
    return true;
  }
  
  EOrientation o4 = l.Orientation(to);
  if (o4 == EOrientation::COLINEAR && l.InBoundingBox(to)) 
  { 
    return true;
  }
  
  if (o3 == o4) // both points of this segment are on the same side of test line
  {
    return false;
  }
  
  return true; // Doesn't fall in any of the above cases
}

LineSegment::EOrientation LineSegment::Orientation(const Point2f& p) const
{
  float val = Dot(p);
  if (NEAR_ZERO(val))
  {
    return EOrientation::COLINEAR;  // point is on the line generated by the segment
  } 
  else if (FLT_GE_ZERO(val)) 
  {
    return EOrientation::CW;        // point is to the right
  } 
  else 
  {
    return EOrientation::CCW;       // point is to the left
  }
} 

}

