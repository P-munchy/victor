/*

This file was automatically generated by the python script generateFixedLengthList_h.py. Rather than editing this file, edit that script, then run "python generateFixedLengthList_h.py".

*/

#ifndef _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_H_
#define _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_H_

#include "anki/common/robot/config.h"
#include "anki/common/robot/array2d.h"
#include "anki/common/robot/arraySlices.h"

namespace Anki
{
  namespace Embedded
  {
    template<typename Type> class FixedLengthList : public ArraySlice<Type>
    {
    public:
      FixedLengthList();

      // Constructor for a FixedLengthList, pointing to user-allocated data.
      FixedLengthList(s32 maximumSize, void * data, s32 dataLength, const Flags::Buffer flags=Flags::Buffer(true,false));

      // Constructor for a FixedLengthList, pointing to user-allocated MemoryStack
      FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags=Flags::Buffer(true,false));

      bool IsValid() const;

      Result PushBack(const Type &value);

      // Will act as a normal pop, except when the list is empty. Then subsequent
      // calls will keep returning the first value in the list.
      Type PopBack();

      // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
      inline void Clear();

      // Does this ever need to be declared explicitly?
      //FixedLengthList& operator= (const FixedLengthList & rightHandSide);

      // Pointer to the data, at a given location
      inline Type* Pointer(const s32 index);
      inline const Type* Pointer(const s32 index) const;

      // Use this operator for normal C-style vector indexing. For example, "list[5] = 6;" will set
      // the element in the fifth row and first column to 6. This is the same as "*list.Pointer(5) =
      // 6;"
      //
      // NOTE:
      // Using this in a inner loop may be less efficient than using an explicit pointer with a
      // restrict keyword (Though the runtime cost isn't nearly as large as the [] operator for the
      // Array class). For speeding up performance-critical inner loops, use something like: "Type *
      // restrict pList = list.Pointer(0);" outside the inner loop, then index
      // pList in the inner loop.
      inline const Type& operator[](const s32 index) const;
      inline Type& operator[](const s32 index);

      // Print out the contents of this FixedLengthList
      Result Print(const char * const variableName = "FixedLengthList", const s32 minIndex = 0, const s32 maxIndex = 0x7FFFFFE) const;

      // Set every element in the Array to zero, including the stride padding, but not including the optional fill patterns (if they exist)
      // Returns the number of bytes set to zero
      inline s32 SetZero();

      inline s32 get_maximumSize() const;

      inline s32 get_size() const;

      // Attempt to set the size to newSize. Returns the value that was actually set.
      s32 set_size(s32 newSize);

    protected:
      // For speed, have some direct pointers to the Array's protected members
      Type * arrayData;
    }; // class FixedLengthList

#pragma mark --- FixedLengthList Implementations ---

#ifndef USING_MOVIDIUS_COMPILER
    template<typename Type> FixedLengthList<Type> AllocateFixedLengthListFromHeap(s32 maximumSize, const Flags::Buffer flags=Flags::Buffer(true,false))
    {
      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array<Type>::ComputeMinimumRequiredMemory(1, maximumSize, flags); // The required memory, plus a bit more

      FixedLengthList<Type> mat(maximumSize, calloc(requiredMemory, 1), requiredMemory, flags);

      return mat;
    } // FixedLengthList AllocateFixedLengthListFromHeap_Type(s32 maximumSize, const Flags::Buffer flags=Flags::Buffer(true,false))
#endif // #ifndef USING_MOVIDIUS_COMPILER

    template<typename Type> inline Type* FixedLengthList<Type>::Pointer(const s32 index)
    {
      return this->arrayData + index;
    }

    template<typename Type> inline const Type* FixedLengthList<Type>::Pointer(const s32 index) const
    {
      return this->arrayData + index;
    }

    template<typename Type> inline const Type& FixedLengthList<Type>::operator[](const s32 index) const
    {
      return *(this->arrayData + index);
    }

    template<typename Type> inline Type& FixedLengthList<Type>::operator[](const s32 index)
    {
      return *(this->arrayData + index);
    }

    template<typename Type> FixedLengthList<Type>::FixedLengthList()
      : ArraySlice<Type>()
    {
      this->arrayData = NULL;
      this->set_size(0);
    } // FixedLengthList<Type>::FixedLengthList()

    template<typename Type> FixedLengthList<Type>::FixedLengthList(s32 maximumSize, void * data, s32 dataLength, const Flags::Buffer flags)
      : ArraySlice<Type>(Array<Type>(1, maximumSize, data, dataLength, flags), LinearSequence<s32>(0,0), LinearSequence<s32>(0,0))
    {
      this->arrayData = this->array.Pointer(0,0);
      this->set_size(0);
    } // FixedLengthList<Type>::FixedLengthList(s32 maximumSize, void * data, s32 dataLength, const Flags::Buffer flags)

    template<typename Type> FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)
      : ArraySlice<Type>(Array<Type>(1, maximumSize, memory, flags), LinearSequence<s32>(0,0), LinearSequence<s32>(0,0))
    {
      this->arrayData = this->array.Pointer(0,0);
      this->set_size(0);
    } // FixedLengthList<Type>::FixedLengthList(s32 maximumSize, MemoryStack &memory, const Flags::Buffer flags)

    template<typename Type> bool FixedLengthList<Type>::IsValid() const
    {
      if(this->get_size() > this->get_maximumSize()) {
        return false;
      }

      return this->array.IsValid();
    } // bool FixedLengthList<Type>::IsValid() const

    template<typename Type> Result FixedLengthList<Type>::PushBack(const Type &value)
    {
      const s32 curSize = this->get_size();

      if(curSize >= this->get_maximumSize()) {
        return RESULT_FAIL;
      }

      *this->Pointer(curSize) = value;

      this->xSlice.size = curSize+1;
      this->xSlice.end = curSize;

      return RESULT_OK;
    } // Result FixedLengthList<Type>::PushBack(const Type &value)

    template<typename Type> Type FixedLengthList<Type>::PopBack()
    {
      const s32 curSize = this->get_size();

      if(curSize == 0) {
        return *this->Pointer(0);
      }

      const Type value = *this->Pointer(curSize-1);
      this->xSlice.size = curSize-1;
      this->xSlice.end = curSize-2;

      return value;
    } // Type FixedLengthList<Type>::PopBack()

    template<typename Type> inline void FixedLengthList<Type>::Clear()
    {
      this->set_size(0);
    } // void FixedLengthList<Type>::Clear()

    template<typename Type> inline s32 FixedLengthList<Type>::SetZero()
    {
      return this->array.SetZero();
    }

    template<typename Type> inline s32 FixedLengthList<Type>::get_maximumSize() const
    {
      return this->array.get_size(1);
    } // s32 FixedLengthList<Type>::get_maximumSize() const

    template<typename Type> inline s32 FixedLengthList<Type>::get_size() const
    {
      return this->xSlice.size;
    } // s32 FixedLengthList<Type>::get_size() const

    // Attempt to set the size to newSize. Returns the value that was actually set.
    template<typename Type> s32 FixedLengthList<Type>::set_size(s32 newSize)
    {
      newSize = MIN(this->get_maximumSize(), MAX(0,newSize));

      this->xSlice.size = newSize;
      this->xSlice.end = newSize-1;

      return newSize;
    } // s32 FixedLengthList<Type>::set_size(s32 newSize)

    // Print out the contents of this FixedLengthList
    template<typename Type> Result FixedLengthList<Type>::Print(const char * const variableName, const s32 minIndex, const s32 maxIndex) const
    {
      return this->array.Print(variableName, 0, 0, MAX(0,minIndex), MIN(maxIndex, this->get_size()-1));
    } // Result FixedLengthList<Type>::Print(const char * const variableName, const s32 minIndex, const s32 maxIndex) const
  } // namespace Embedded
} //namespace Anki

#endif // _ANKICORETECHEMBEDDED_COMMON_FIXEDLENGTHLIST_H_
