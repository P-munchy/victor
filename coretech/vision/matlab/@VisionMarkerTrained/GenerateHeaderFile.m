function outputString = GenerateHeaderFile(varargin)

numFractionalBits = 15;

parseVarargin(varargin{:});

outputString = sprintf( [...
    '// Autogenerated by VisionMarkerTrained.GenerateHeaderFile() on %s\n\n' ...
    '// NOTE: (X,Y) probe locations are stored as SQ%d.%d\n\n' ...
    '// Each tree is just an array of nodes, with one big one for the multi-class\n' ...
    '// decision, and N smaller one-vs-all tree for "independently" verifying the\n' ...
    '// decision reached by the multi-class tree.\n\n' ...
    '#ifndef _ANKICORETECHEMBEDDED_VISION_FIDUCIAL_MARKER_DECISION_TREE_H_\n' ...
    '#define _ANKICORETECHEMBEDDED_VISION_FIDUCIAL_MARKER_DECISION_TREE_H_\n\n' ...
    '#include "anki/vision/robot/decisionTree_vision.h"\n\n' ...
    'namespace Anki {\n' ...
    'namespace Embedded {\n\n' ...
    '// Leaf labels, which are 16 bits, have first bit set to 1\n' ...
    '#define LEAF_MASK 0x8000\n' ...
    '#define MAKE_LEAF(__VALUE__) (static_cast<u16>(__VALUE__) | LEAF_MASK)\n', ...
    '#define READ_LEAF(__LEAF__) (__LEAF__ & (~LEAF_MASK))\n\n'], ...
    datestr(now), 15-numFractionalBits, numFractionalBits);

%% Enums and LUTs
numLabels = length(VisionMarkerTrained.ProbeTree.labels);

enumString          = cell(1, numLabels);
enumString_oriented = cell(1, numLabels);
labelNames          = cell(1, numLabels); % same as enumString_oriented without extra () or ,
enumMappingString   = cell(1, numLabels);
reorderingString    = cell(1, numLabels);
maxDepthString      = cell(1, numLabels);
treePtrString       = cell(1, numLabels);

for i_label = 1:numLabels
    
    % The oriented enums are the raw decision tree labels (if they don't
    % have an underscore, add _000 to the end)
    enumName_oriented = VisionMarkerTrained.ProbeTree.labels{i_label};
    if any(strcmp(enumName_oriented, {'ALL_WHITE', 'ALL_BLACK'}))
        % special case
        % TODO: adjust training to change these special labels to ALLWHITE and ALL_BLACK
        underscoreIndex = [];
    else
        underscoreIndex = find(enumName_oriented == '_');
    end
    if isempty(underscoreIndex) 
       enumName_oriented = [enumName_oriented '_000'];  %#ok<AGROW>
       underscoreIndex = length(enumName_oriented)-3;
    end
    labelNames{i_label} = sprintf('MARKER_%s', upper(enumName_oriented));
    enumString_oriented{i_label} = sprintf('  %s,\n', labelNames{i_label});
    
    % The unoriented enums strip off the _QQQ angle off the end
    enumName = sprintf('MARKER_%s', upper(enumName_oriented(1:(underscoreIndex-1))));
    enumString{i_label} = sprintf('%s,\n', enumName);
    
    % Map oriented to unoriented
    enumMappingString{i_label} = enumString{i_label};
    
    % Reorient the corners accroding to the orientation.  Using this will
    % result in the first and third corners being the top side.
    reorder = [1 3; 2 4]; % canonical corner ordering
    switch(enumName_oriented((underscoreIndex+1):end))
        case '000'
            % nothing to do
        case '090'
            reorder = rot90(rot90(rot90(reorder)));
            %reorder = rot90(reorder);
        case '180'
            reorder = rot90(rot90(reorder));
        case '270'
            %reorder = rot90(rot90(rot90(reorder)));
            reorder = rot90(reorder);
        otherwise
            error('Unrecognized angle string "%s"', angleStr);
    end
    reorderingString{i_label} = sprintf('  {%d,%d,%d,%d},\n', reorder(:)-1);
    
    maxDepthString{i_label} = sprintf('  MAX_DEPTH_VERIFY_%d,\n', i_label-1);
    
    treePtrString{i_label} = sprintf('  VerifyTree_%d,\n', i_label-1);    
    
end % FOR each label
        
% Create enumerate marker IDs, oriented and unoriented, and a mapping
% between them
outputString = [outputString sprintf([...
    'enum VisionMarkerTypes_Oriented {\n' ....
    '%s' ...
    '  NUM_MARKER_TYPES_ORIENTED,\n' ...
    '  MARKER_UNKNOWN = NUM_MARKER_TYPES_ORIENTED\n' ...
    '};\n\n'], [enumString_oriented{:}])];

enumString = unique(enumString);
outputString = [outputString sprintf([ ...
    'enum VisionMarkerTypes {\n' ...
    '%s' ...
    '  NUM_MARKER_TYPES\n' ...
    '};\n\n'], [enumString{:}])];

outputString = [outputString sprintf([ ...
    'VisionMarkerTypes RemoveOrientationLUT[NUM_MARKER_TYPES_ORIENTED] = {\n' ...
    '%s' ... 
    '};\n\n'], [enumMappingString{:}])];

outputString = [outputString sprintf([ ...
    'u32 CornerReorderLUT[NUM_MARKER_TYPES_ORIENTED][4] = {\n' ...
    '%s' ...
    '};\n\n'], [reorderingString{:}])];


%% Multiclass tree
[array,maxDepth] = CreateTreeArray(VisionMarkerTrained.ProbeTree);

arrayString = GetArrayString(array, numFractionalBits, labelNames);

outputString = [outputString sprintf([ ...
    'const u32 NUM_NODES_MULTICLASS = %d;\n' ...
    'const u32 MAX_DEPTH_MULTICLASS = %d;\n' ...
    'const FiducialMarkerDecisionTree::Node MultiClassTree[NUM_NODES_MULTICLASS] = {\n' ...
    '%s' ...
    '};\n\n'], ...
    length(array), maxDepth, [arrayString{:}])];

%% Verification trees
numVerifiers = length(VisionMarkerTrained.ProbeTree.verifiers);
assert(numLabels==numVerifiers, ...
    'There should be a label name for each verification tree.');

for i_label = 1:numVerifiers
    
    [array,maxDepth] = CreateTreeArray(VisionMarkerTrained.ProbeTree.verifiers(i_label));
    
    arrayString = GetArrayString(array, numFractionalBits, {'MARKER_UNKNOWN', labelNames{i_label}});
    
    outputString = [outputString sprintf([ ...
        'const u32 NUM_NODES_VERIFY_%d = %d;\n' ...
        'const u32 MAX_DEPTH_VERIFY_%d = %d;\n' ...
        'const FiducialMarkerDecisionTree::Node VerifyTree_%d[NUM_NODES_VERIFY_%d] = {\n' ...
        '%s' ...
        '};\n\n'], ...
        i_label-1, length(array), ...
        i_label-1, maxDepth, ...
        i_label-1, i_label-1, ...
        [arrayString{:}])]; %#ok<AGROW>
end
  
    
outputString = [outputString sprintf([ ...
    '// For convenience, store pointers to the verification trees (and their max\n' ...
    '// depths) in arrays, indexable by marker type:\n\n' ...
    'const u32 MAX_DEPTH_VERIFY[NUM_MARKER_TYPES_ORIENTED] = {\n' ...
    '%s' ...
    '};\n\n'], [maxDepthString{:}])];

outputString = [outputString sprintf([...
    'const FiducialMarkerDecisionTree::Node* VerifyTree[NUM_MARKER_TYPES_ORIENTED] = {\n', ...
    '%s' ...
    '};\n\n'], [treePtrString{:}])];

outputString = [outputString sprintf([...
    '} // namespace Embedded\n' ...
    '} // namespace Anki\n\n' ...
    '#endif // _ANKICORETECHEMBEDDED_VISION_FIDUCIAL_MARKER_DECISION_TREE_H_\n'])];


if nargout==0
    clipboard('copy', outputString);
    fprintf('\nCopied header file to clipboard.\n\n');
    clear outputString;
end

%sprintf('Maximum differences with %d fractional bits:\n\nTheoretical: %f\n\nMeasured:\nXProbes: %f (%f percent)\nYProbes: %f (%f percent)\nProbeWeights: %f (%f percent)\n',...
%    numFractionalBits, 1/(2^(numFractionalBits+1)), maxX, maxXPercent, maxY, maxYPercent, maxP, maxPPercent)
    
end % FUNCTION GenerateHeaderFile()

function fixedPt = FixedPoint(value, numFractionalBits)

if isempty(value)
    fixedPt = 0;
else
    fixedPt = int32(round(2^numFractionalBits)*value);
end

end % FUNCTION FixedPointHelper()

function arrayString = GetArrayString(array, numFractionalBits, labelNames)

arrayString = cell(1,length(array));
for i = 1:length(array)
    if ~isempty(array(i).leftIndex)
        leftIndex = array(i).leftIndex-1;
        label = '0';
        assert(leftIndex >= 0, 'Expecting all leftIndexes to be >= 0.');
        assert(leftIndex < 2^16, 'LeftIndex=%d will not fit in u16.', leftIndex);
        assert(isempty(array(i).label), 'If left index is given, expecting label to be empty.');
        
        lineComment = sprintf('// X=%.4f, Y=%.4f', array(i).x, array(i).y);
    end
    
    if ~isempty(array(i).label)
        leftIndex = 0;
        assert(array(i).label > 0, 'Expecting all labels > 0.');
        assert(array(i).label-1 < 2^15, 'Label=%d will not fit in last 15 bits of u16.', label);
        assert(isempty(array(i).leftIndex), 'If label is given, expecting leftIndex to be empty.');
        %label = bitor(uint16(label), LeafMask); % Set first bit to 1
        label = sprintf('MAKE_LEAF(%s)', labelNames{array(i).label});
        lineComment = '';
    end
    
    
    arrayString{i} = sprintf('  {%d,%d,%d, %s}, %s\n', ...
        FixedPoint(array(i).x, numFractionalBits), ...
        FixedPoint(array(i).y, numFractionalBits), ...
        leftIndex, label, ...
        lineComment);
end

end % FUNCTION GetArrayString()

