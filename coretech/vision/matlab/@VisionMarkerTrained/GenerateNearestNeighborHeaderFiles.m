function [nearestNeighborString, markerDefString] = GenerateNearestNeighborHeaderFiles(varargin)

writeFiles = false;
projectRoot = fullfile(fileparts(mfilename('fullpath')), '..', '..', '..', '..');
markerDefFile = 'coretech/vision/include/anki/vision/MarkerCodeDefinitions.h';
nearestNeighborDataFile = 'include/anki/cozmo/robot/nearestNeighborLibraryData.h';
nnLibrary = [];
useHoG = false;

numFractionalBits = 15;

parseVarargin(varargin{:});

labels = nnLibrary.labelNames;

[numDimensions, numDataPoints] = size(nnLibrary.probeValues);

if useHoG
  if ~isfield(nnLibrary, 'probeHoG')
    error('useHoG==true but no probeHoG field found in nnLibrary.');
  end
  assert(size(nnLibrary.probeHoG,2) == numDataPoints);
  numHoGdims = size(nnLibrary.probeHoG, 1);
else
  numHoGdims = 0;
end

nearestNeighborString = sprintf( [...
    '// Autogenerated by VisionMarkerTrained.%s() on %s\n\n' ...
    '// NOTE: (X,Y) probe locations are stored as SQ%d.%d\n\n' ...
    '#ifndef ANKI_COZMO_ROBOT_NEAREST_NEIGHBOR_LIBRARY_DATA_H\n' ...
    '#define ANKI_COZMO_ROBOT_NEAREST_NEIGHBOR_LIBRARY_DATA_H\n\n' ...
    '#include "anki/vision/MarkerCodeDefinitions.h"\n\n' ...
    'namespace Anki {\n' ...
    'namespace Embedded {\n\n' ...
    'const s32 NUM_MARKERS_IN_LIBRARY = %d;\n' ...
    'const s32 NUM_PROBES = %d;\n' ...
    'const s32 NUM_HOG_DIMENSIONS = %d;\n' ...
    'const s32 NN_NUM_FRACTIONAL_BITS = %d;\n\n'], ...
    mfilename, datestr(now), 15-numFractionalBits, numFractionalBits, ...
    numDataPoints, numDimensions, numHoGdims, numFractionalBits);

%% Probe point pattern

numPoints = length(VisionMarkerTrained.ProbePattern.x);
x_str = cell(1, numPoints);
y_str = cell(1, numPoints);

for i_pt = 1:numPoints
    x = VisionMarkerTrained.ProbePattern.x(i_pt);
    x_str{i_pt} = sprintf('  %5d, // X[%d] = %.4f\n', ...
        FixedPoint(x, numFractionalBits), i_pt, x);
    
    y = VisionMarkerTrained.ProbePattern.y(i_pt);
    y_str{i_pt} = sprintf('  %5d, // Y[%d] = %.4f\n', ...
        FixedPoint(y, numFractionalBits), i_pt, y);
end
        
nearestNeighborString = [nearestNeighborString sprintf([ ...
    '// Note: the probe points included the center (0,0) point\n' ...
    'const u32 NUM_PROBE_POINTS = %d;\n' ...
    'const s16 ProbePoints_X[NUM_PROBE_POINTS] = {\n' ...
    '%s' ...
    '};\n' ...
    'const s16 ProbePoints_Y[NUM_PROBE_POINTS] = {\n' ...
    '%s' ...
    '};\n\n'], ...
    numPoints, [x_str{:}], [y_str{:}])];


%% Threshold Probe Locations

numProbes = length(VisionMarkerTrained.BrightProbes.x);
assert(length(VisionMarkerTrained.DarkProbes.x)==numProbes, ...
    'Must have same number of dark and bright probes.');

dark_xStr = cell(1, numProbes);
dark_yStr = cell(1, numProbes);

bright_xStr = cell(1, numProbes);
bright_yStr = cell(1, numProbes);

for i = 1:numProbes
    dark_xStr{i} = sprintf('  %5d, // X = %.4f\n', ...
        FixedPoint(VisionMarkerTrained.DarkProbes.x(i), numFractionalBits), ...
        VisionMarkerTrained.DarkProbes.x(i));
    dark_yStr{i} = sprintf('  %5d, // Y = %.4f\n', ...
        FixedPoint(VisionMarkerTrained.DarkProbes.y(i), numFractionalBits), ...
        VisionMarkerTrained.DarkProbes.x(i));
    
    bright_xStr{i} = sprintf('  %5d, // X = %.4f\n', ...
        FixedPoint(VisionMarkerTrained.BrightProbes.x(i), numFractionalBits), ...
        VisionMarkerTrained.BrightProbes.x(i));
    bright_yStr{i} = sprintf('  %5d, // Y = %.4f\n', ...
        FixedPoint(VisionMarkerTrained.BrightProbes.y(i), numFractionalBits), ...
        VisionMarkerTrained.BrightProbes.x(i));
end

nearestNeighborString = [nearestNeighborString sprintf([ ...
    'const u32 NUM_THRESHOLD_PROBES = %d;\n' ...
    'const s16 ThresholdDarkProbe_X[NUM_THRESHOLD_PROBES] = {\n' ...
    '%s' ...
    '};\n\n' ...
    'const s16 ThresholdDarkProbe_Y[NUM_THRESHOLD_PROBES] = {\n' ...
    '%s' ...
    '};\n\n' ...
    'const s16 ThresholdBrightProbe_X[NUM_THRESHOLD_PROBES] = {\n' ...
    '%s' ...
    '};\n\n'...
    'const s16 ThresholdBrightProbe_Y[NUM_THRESHOLD_PROBES] = {\n' ...
    '%s' ...
    '};\n\n'], ...
    numProbes, [dark_xStr{:}], [dark_yStr{:}], [bright_xStr{:}], [bright_yStr{:}])];

%% Probe Center Locations
numProbes = VisionMarkerTrained.ProbeParameters.GridSize^2;
assert(numel(nnLibrary.xgrid) == numProbes, 'Given library has wrong number of probes.');

center_xStr = cell(1, numProbes);
center_yStr = cell(1, numProbes);

for i = 1:numProbes
    center_xStr{i} = sprintf('  %5d, // X = %.4f\n', ...
        FixedPoint(nnLibrary.xgrid(i), numFractionalBits), ...
        nnLibrary.xgrid(i));
    center_yStr{i} = sprintf('  %5d, // Y = %.4f\n', ...
        FixedPoint(nnLibrary.ygrid(i), numFractionalBits), ...
        nnLibrary.ygrid(i));
end

nearestNeighborString = [nearestNeighborString sprintf([ ...
    'const s16 ProbeCenters_X[NUM_PROBES] = {\n' ...
    '%s' ...
    '};\n\n' ...
    'const s16 ProbeCenters_Y[NUM_PROBES] = {\n' ...
    '%s' ...
    '};\n\n'], ...
    [center_xStr{:}], [center_yStr{:}])];

%% Enums and LUTs
numLabels = length(labels);

enumString          = cell(1, numLabels);
enumString_oriented = cell(1, numLabels);
labelNames          = cell(1, numLabels); % same as enumString_oriented without extra () or ,
enumMappingString   = cell(1, numLabels);
reorderingString    = cell(1, numLabels);
orientationString   = cell(1, numLabels);

for i_label = 1:numLabels
    
    % The oriented enums are the raw decision tree labels (if they don't
    % have an underscore, add _000 to the end)
    enumName_oriented = labels{i_label};
    if any(strcmp(enumName_oriented, {'ALL_WHITE', 'ALL_BLACK'}))
        % special case
        % TODO: adjust training to change these special labels to ALLWHITE and ALLBLACK
        underscoreIndex = [];
    else
        underscoreIndex = find(enumName_oriented == '_');
        if strncmpi(enumName_oriented, 'inverted_', 9)
            % Ignore the first underscore found if this is
            % an inverted code name
            underscoreIndex(1) = [];
        end
    end
    if isempty(underscoreIndex) 
       enumName_oriented = [enumName_oriented '_000'];  %#ok<AGROW>
       underscoreIndex = length(enumName_oriented)-3;
    end
    labelNames{i_label} = sprintf('MARKER_%s', upper(enumName_oriented));
    enumString_oriented{i_label} = sprintf('  %s', labelNames{i_label});
    %enumString_oriented_quoted{i_label} = sprintf('  "%s",\n', labelNames{i_label});
    
    % The unoriented enums strip off the _QQQ angle off the end
    enumName = sprintf('MARKER_%s', upper(enumName_oriented(1:(underscoreIndex-1))));
    enumString{i_label} = sprintf('%s', enumName);
    %enumString_quoted{i_label} = sprintf('  "%s",\n', enumName);
    
    % Map oriented to unoriented
    enumMappingString{i_label} = ['Vision::' enumString{i_label}];
    
    % Reorient the corners accroding to the orientation.  Using this will
    % result in the first and third corners being the top side.
    reorder = [1 3; 2 4]; % canonical corner ordering
    orientationAngleStr = enumName_oriented((underscoreIndex+1):end);
    switch(orientationAngleStr)
        case '000'
            % nothing to do
        case '090'
            reorder = rot90(rot90(rot90(reorder)));
            %reorder = rot90(reorder);
        case '180'
            reorder = rot90(rot90(reorder));
        case '270'
            %reorder = rot90(rot90(rot90(reorder)));
            reorder = rot90(reorder);
        otherwise
            error('Unrecognized angle string "%s"', angleStr);
    end
    reorderingString{i_label} = sprintf('  {%d,%d,%d,%d},\n', reorder(:)-1);
    
    orientationString{i_label} = sprintf('    %f,\n', str2double(orientationAngleStr));
    
end % FOR each label
        
% Create enumerate marker IDs, oriented and unoriented, and a mapping
% between them
nearestNeighborString = [nearestNeighborString sprintf([...
    'enum OrientedMarkerLabel {\n' ....
    '%s' ...
    '  NUM_MARKER_LABELS_ORIENTED,\n' ...
    '  MARKER_UNKNOWN = NUM_MARKER_LABELS_ORIENTED\n' ...
    '};\n\n'], sprintf('%s,\n', enumString_oriented{:}))];

nearestNeighborString = [nearestNeighborString sprintf([ ...
    'const char * const OrientedMarkerLabelStrings[NUM_MARKER_LABELS_ORIENTED] = {\n' ...
    '%s' ...
    '};\n\n'], sprintf('"%s",\n', enumString_oriented{:}))];
      
nearestNeighborString = [nearestNeighborString sprintf([ ...
    'const u32 CornerReorderLUT[NUM_MARKER_LABELS_ORIENTED][4] = {\n' ...
    '%s' ...
    '};\n\n'], [reorderingString{:}])];


%% NearestNeighborData/Weights/Labels

if useHoG 
  assert(isfield(nnLibrary, 'probeHoG'), 'useHoG==true, nnLibrary should have probeHoG field.'); %#ok<UNRCH>
  data = nnLibrary.probeHoG;
  dataDimStr = 'NUM_HOG_DIMENSIONS';
else
  data = nnLibrary.probeValues;
  dataDimStr = 'NUM_PROBES';
end

nearestNeighborString = [nearestNeighborString sprintf([ ...
  'const u8 NearestNeighborData[NUM_MARKERS_IN_LIBRARY*%s] = {\n' ...
  '%s' ...
  '};\n\n'], dataDimStr, sprintf('%d, ', data))];

if ~useHoG
  nearestNeighborString = [nearestNeighborString sprintf([ ...
    'const u8 NearestNeighborWeights[NUM_MARKERS_IN_LIBRARY*NUM_PROBES] = {\n' ...
    '%s' ...
    '};\n\n'], sprintf('%d, ', im2uint8(nnLibrary.gradMagWeights)))];
end

nearestNeighborString = [nearestNeighborString sprintf([ ...
  'const u16 NearestNeighborLabels[NUM_MARKERS_IN_LIBRARY] = {\n' ...
  '%s' ...
  '};\n\n'], sprintf('%d, ', nnLibrary.labels-1))];

%% Marker Type Definitions
% Different file now!
markerDefString = sprintf([ ...
    '// Autogenerated by VisionMarkerTrained.%s() on %s\n\n' ...
    '#ifndef ANKI_COZMO_VISIONMARKERTYPES_H\n' ...
    '#define ANKI_COZMO_VISIONMARKERTYPES_H\n\n' ...
    'namespace Anki {\n' ...
    '  namespace Vision {\n\n'], ...
    mfilename, datestr(now));
    
enumString = unique(enumString);
enumStringsWithValues = [enumString(:) num2cell((0:length(enumString)-1)')]';

markerDefString = [markerDefString sprintf([ ...
    '    enum MarkerType {\n' ...
    '%s' ...
    '      NUM_MARKER_TYPES,\n' ...
    '      MARKER_UNKNOWN = NUM_MARKER_TYPES\n' ...
    '    };\n\n'], sprintf('      %s = %d,\n', enumStringsWithValues{:}))];

markerDefString = [markerDefString sprintf([ ...
    '    const char * const MarkerTypeStrings[NUM_MARKER_TYPES+1] = {\n' ...
    '%s' ...
    '      "MARKER_UNKNOWN"\n' ...
    '    };\n\n'], sprintf('      "%s",\n', enumString{:}))];

repeatedEnumString = [enumString(:) enumString(:)]';
markerDefString = [markerDefString sprintf([ ...
    '#ifdef COZMO_BASESTATION\n' ...
    '    const std::map<std::string, Vision::MarkerType> StringToMarkerType = {\n' ...
    '%s' ...
    '      {"MARKER_UNKNOWN", MARKER_UNKNOWN}\n' ...
    '    };\n' ...
    '#endif\n\n'], sprintf('      {"%s", %s},\n', repeatedEnumString{:}))];

markerDefString = [markerDefString sprintf([ ...
  '  } // namespace Vision\n' ...
  '} // namespace Anki\n\n' ...
  '#endif // ANKI_COZMO_VISIONMARKERTYPES_H\n\n'])];
 
%% Move back to LUT defs
nearestNeighborString = [nearestNeighborString sprintf([ ...
    'const Vision::MarkerType RemoveOrientationLUT[NUM_MARKER_LABELS_ORIENTED] = {\n' ...
    '%s' ...
    '};\n\n'], sprintf('  %s,\n', enumMappingString{:}))];

nearestNeighborString = [nearestNeighborString sprintf([ ...
    'const f32 ObservedOrientationLUT[NUM_MARKER_LABELS_ORIENTED] = {\n' ...
    '%s' ...
    '};\n\n'], [orientationString{:}])];

nearestNeighborString = [nearestNeighborString sprintf([ ...
    '} // namespace Embedded\n' ...
    '} // namespace Anki\n\n' ...
    '#endif // ANKI_COZMO_ROBOT_NEAREST_NEIGHBOR_LIBRARY_DATA_H\n'])];



if writeFiles 
   
    nearestNeighborDataFile = fullfile(projectRoot, nearestNeighborDataFile);
    fid = fopen(nearestNeighborDataFile, 'wt');
    if fid == -1
        error('Could not open "%s" for writing nearest neighbor data file.', nearestNeighborDataFile);
    else
        fprintf(fid, '%s', nearestNeighborString);
        fclose(fid);
        fprintf('Wrote nearest neighbor data to "%s".\n', nearestNeighborDataFile);
    end
    
    markerDefFile = fullfile(projectRoot, markerDefFile);
    fid = fopen(markerDefFile, 'wt');
    if fid == -1
        error('Could not open "%s" for writing marker definition file.', markerDefFile);
    else
        fprintf(fid, '%s', markerDefString);
        fclose(fid);
        fprintf('Wrote marker definitions to "%s".\n', markerDefFile);
    end
    
end % IF writeFiles

% if nargout==0
%     clipboard('copy', decisionTreeString);
%     fprintf('\nCopied header file to clipboard.\n\n');
%     clear outputString;
% end

%sprintf('Maximum differences with %d fractional bits:\n\nTheoretical: %f\n\nMeasured:\nXProbes: %f (%f percent)\nYProbes: %f (%f percent)\nProbeWeights: %f (%f percent)\n',...
%    numFractionalBits, 1/(2^(numFractionalBits+1)), maxX, maxXPercent, maxY, maxYPercent, maxP, maxPPercent)
    
end % FUNCTION GenerateHeaderFile()

function fixedPt = FixedPoint(value, numFractionalBits)

if isempty(value)
    fixedPt = 0;
else
    fixedPt = int32(round(2^numFractionalBits)*value);
end

end % FUNCTION FixedPointHelper()


