#ifndef __BIGNUM_H
#define __BIGNUM_H

#include <stdint.h>

typedef uint16_t big_num_cell_t;

#ifdef NRF51
// 1024-bit safe (DH keys)
static const int CELL_SIZE = 129;
#else
// 2048-bit safe (RSA Pub)
static const int CELL_SIZE = 257;
#endif
static const int CELL_BITS = (sizeof(big_num_cell_t) * 8);

struct big_num_t {
  bool      negative;
  int       used;
  uint16_t  digits[CELL_SIZE];
};

struct big_mont_t {
  int shift;

  big_num_t one;
  big_num_t modulo;
  big_num_t r2;
  big_num_t rinv;
  big_num_t minv;
};

// This is used for public decryption
struct big_rsa_t {
  big_num_t modulo;
  big_num_t exp;
};

union big_overflow_t {
  struct {
    big_num_cell_t lower;
    big_num_cell_t upper;
  };

  uint32_t word;
};

static const big_num_t BIG_ZERO = {false, 0};
static const big_num_t BIG_ONE = {false, 1, {1}};

// This is used for body board settings to save time and memory
static const big_mont_t DEFAULT_DIFFIE_GROUP = {
  1024,
  { false, 64, {0x77b5, 0xd53d, 0x64cf, 0x0d2c, 0x6285, 0x9c00, 0x9bbb, 0x5047, 0x8d4d, 0x1cb4, 0x8c11, 0x5873, 0x4840, 0x1a7a, 0x093c, 0xf913, 0x2451, 0x987d, 0xcac3, 0x20bd, 0xe643, 0xc46b, 0x1f71, 0x80b1, 0x7605, 0xbf9d, 0x5e6e, 0x3158, 0x9342, 0x86ed, 0xae62, 0x6d96, 0x34c2, 0x3580, 0x11c3, 0xe40d, 0x8f1d, 0xd365, 0x515f, 0x5e6b, 0x2af9, 0xcab2, 0xd13f, 0xfed1, 0x642b, 0x741d, 0xfd19, 0x29b0, 0x66f0, 0xd1d3, 0xbf0d, 0xafaa, 0x39ae, 0x617a, 0x0193, 0xdec5, 0x86a9, 0x5efd, 0x1188, 0x57c7, 0xee1b, 0x4440, 0xb07c, 0x0bfa } },
  { false, 64, {0x884b, 0x2ac2, 0x9b30, 0xf2d3, 0x9d7a, 0x63ff, 0x6444, 0xafb8, 0x72b2, 0xe34b, 0x73ee, 0xa78c, 0xb7bf, 0xe585, 0xf6c3, 0x06ec, 0xdbae, 0x6782, 0x353c, 0xdf42, 0x19bc, 0x3b94, 0xe08e, 0x7f4e, 0x89fa, 0x4062, 0xa191, 0xcea7, 0x6cbd, 0x7912, 0x519d, 0x9269, 0xcb3d, 0xca7f, 0xee3c, 0x1bf2, 0x70e2, 0x2c9a, 0xaea0, 0xa194, 0xd506, 0x354d, 0x2ec0, 0x012e, 0x9bd4, 0x8be2, 0x02e6, 0xd64f, 0x990f, 0x2e2c, 0x40f2, 0x5055, 0xc651, 0x9e85, 0xfe6c, 0x213a, 0x7956, 0xa102, 0xee77, 0xa838, 0x11e4, 0xbbbf, 0x4f83, 0xf405 } },
  { false, 65, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xaa78, 0x1cc0, 0xe256, 0x4a0c, 0x9b76, 0xa805, 0xd821, 0x46ba, 0x6f60, 0x2691, 0x8d9e, 0x4a0a, 0x1014, 0x6dd1, 0xf6c8, 0x5d05, 0xb3ba, 0x74e9, 0x8352, 0xd779, 0xb1fb, 0xd581, 0x98f4, 0x5e9d, 0x1bf5 } },
  { false, 64, {0x4d29, 0xe381, 0x0854, 0x5a9f, 0x4daf, 0xa173, 0x69a7, 0xe659, 0x8bcd, 0x50f1, 0x3576, 0xfa41, 0x0661, 0x732a, 0xf873, 0x1d9a, 0x524f, 0xeee6, 0xe730, 0xb3c7, 0xc7a9, 0x5148, 0x9fd5, 0xb58e, 0xe0fb, 0x9dc9, 0x7348, 0xa1f6, 0x2cab, 0x03fa, 0xa423, 0x1b8a, 0xa72a, 0x2b3a, 0x1021, 0x62d1, 0x8e65, 0x8199, 0x5fe3, 0xbd6d, 0xcb6c, 0xa1e3, 0x7900, 0x8c21, 0x1796, 0x0472, 0x68dd, 0x6121, 0x114f, 0x4513, 0xcb21, 0x5f59, 0x288e, 0xd02e, 0x53a1, 0xece7, 0x9bb6, 0xc128, 0x71fc, 0xeb1b, 0x7685, 0x3131, 0xcbc1, 0x5108 } },
  { false, 64, {0x0163, 0xf097, 0xad10, 0x6c47, 0x2788, 0x4806, 0xbfd3, 0xfa7b, 0x3f2d, 0x7dc6, 0x61cc, 0xaf81, 0x55a2, 0x801f, 0xbd83, 0xd508, 0xeb7f, 0xbcda, 0xaa57, 0xff21, 0x20d4, 0xe885, 0x0d48, 0xd029, 0x21a7, 0xe955, 0x442f, 0xddc4, 0x7c79, 0xe9ca, 0x160e, 0xc898, 0xbce4, 0x835e, 0x8238, 0x0307, 0x4a16, 0x0a50, 0x22e9, 0xe8a4, 0x8ace, 0x4ce2, 0xb9ac, 0x40af, 0x512b, 0x6187, 0xcd91, 0x46e3, 0xd49f, 0xd012, 0x2e3f, 0x8d84, 0xb552, 0x74d4, 0x60c3, 0x6135, 0x8470, 0x621a, 0x24c0, 0x68ef, 0x8aa5, 0xdbbf, 0xd188, 0xaafc } }
};

// 5 in montgomery domain
static const big_num_t DEFAULT_DIFFIE_GENERATOR = { false, 64, {0x5689, 0x2a33, 0xf80f, 0x41dd, 0xec99, 0x0c01, 0x0aaa, 0x9166, 0xc282, 0x8f86, 0xbc55, 0xba41, 0x6941, 0x8463, 0x2e2c, 0xdd5f, 0xb599, 0xfa71, 0xf5d1, 0xa3b4, 0x7f4f, 0xd61b, 0x9d38, 0x8375, 0x4e1b, 0xbe13, 0xd829, 0xf6b9, 0xe04a, 0xa2a3, 0x67ec, 0x23f1, 0x07cc, 0x0b81, 0x58d0, 0x7441, 0xcb95, 0x20fb, 0x96df, 0xd818, 0xd6de, 0xf57a, 0x163e, 0xfa19, 0xf4db, 0x4492, 0xf17f, 0xd074, 0x02b0, 0x1921, 0xbb45, 0x6e55, 0x2069, 0xe763, 0x07e0, 0x59d9, 0xa151, 0xdaf3, 0x57a9, 0xb6e3, 0xa688, 0x5544, 0x726d, 0x3be5 } };

// These are in-place safe
void big_init(big_num_t& num);

bool big_zero(const big_num_t& a);
bool big_bit_get(const big_num_t& a, int bit);
bool big_bit_set(const big_num_t& a, int bit);

int big_msb(const big_num_t& a);
int big_lsb(const big_num_t& a);

bool big_shr(big_num_t& out, const big_num_t& a, const int bits);
bool big_shl(big_num_t& out, const big_num_t& a, const int bits);

int big_compare(const big_num_t& a, const big_num_t& b);
bool big_unsigned_add(big_num_t& out, const big_num_t& a, const big_num_t& b);
bool big_unsigned_subtract(big_num_t& out, const big_num_t& a, const big_num_t& b);
bool big_add(big_num_t& out, const big_num_t& a, const big_num_t& b);
bool big_subtract(big_num_t& out, const big_num_t& a, const big_num_t& b);

// Partially inplace, first term may be self modifying
bool big_power(big_num_t& out, const big_num_t& base, const big_num_t& exp);
bool big_modulo(big_num_t& modulo, const big_num_t& a, const big_num_t& b);

// modulo and a may be the same, remaining values are unsafe
bool big_multiply(big_num_t& out, const big_num_t& a, const big_num_t& b);
bool big_divide(big_num_t& result, big_num_t& modulo, const big_num_t& a, const big_num_t& b);

// These may not be safe
bool big_shl(big_num_t& out, const big_num_t& a, int bits);

// Montgomery domain numbers (not in-place)
bool mont_init(big_mont_t& mont, const big_num_t& modulo);
bool mont_to(const big_mont_t& mont, big_num_t& out, const big_num_t& in);
bool mont_from(const big_mont_t& mont, big_num_t& out, const big_num_t& in);
bool mont_multiply(const big_mont_t& mont, big_num_t& out, const big_num_t& a, const big_num_t& b);
bool mont_power(const big_mont_t& mont, big_num_t& out, const big_num_t& base_in, const big_num_t& exp);

#endif
