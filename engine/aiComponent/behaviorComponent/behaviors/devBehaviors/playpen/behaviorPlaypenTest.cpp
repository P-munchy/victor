/**
 * File: behaviorPlaypenTest.cpp
 *
 * Author: Al Chaussee
 * Created: 07/25/17
 *
 * Description: Runs individual steps (behaviors) of playpen and manages switching between them and dealing
 *              failures
 *
 * Copyright: Anki, Inc. 2017
 *
 **/

#include "engine/aiComponent/behaviorComponent/behaviors/devBehaviors/playpen/behaviorPlaypenTest.h"


#include "engine/actions/setFaceAction.h"
#include "engine/aiComponent/behaviorComponent/behaviorContainer.h"
#include "engine/aiComponent/behaviorComponent/behaviors/devBehaviors/playpen/iBehaviorPlaypen.h"
#include "engine/blockWorld/blockWorld.h"
#include "engine/components/bodyLightComponent.h"
#include "engine/components/nvStorageComponent.h"
#include "engine/components/visionComponent.h"
#include "engine/cozmoContext.h"
#include "engine/robot.h"
#include "engine/robotManager.h"

#include "util/console/consoleSystem.h"

namespace Anki {
namespace Cozmo {

namespace {
  FactoryTestLogger _factoryTestLogger;
}

BehaviorPlaypenTest::BehaviorPlaypenTest(const Json::Value& config)
: ICozmoBehavior( config)
{

}


void BehaviorPlaypenTest::InitBehavior(BehaviorExternalInterface& behaviorExternalInterface) 
{
  _behaviorExternalInterface = &behaviorExternalInterface;
  Robot& robot = behaviorExternalInterface.GetRobot();

  const BehaviorContainer& BC = behaviorExternalInterface.GetBehaviorContainer();
  
  ICozmoBehaviorPtr waitToStartBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenWaitToStart);
  DEV_ASSERT(waitToStartBehavior != nullptr &&
             waitToStartBehavior->GetClass() == BehaviorClass::PlaypenWaitToStart,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenWaitToStart");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(waitToStartBehavior));

  ICozmoBehaviorPtr initCheckBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenInitChecks);
  DEV_ASSERT(initCheckBehavior != nullptr &&
             initCheckBehavior->GetClass() == BehaviorClass::PlaypenInitChecks,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenInitChecks");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(initCheckBehavior));
  
  ICozmoBehaviorPtr motorCalibBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenMotorCalibration);
  DEV_ASSERT(motorCalibBehavior != nullptr &&
             motorCalibBehavior->GetClass() == BehaviorClass::PlaypenMotorCalibration,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenMotorCalibration");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(motorCalibBehavior));
  
  ICozmoBehaviorPtr driftCheckBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenDriftCheck);
  DEV_ASSERT(driftCheckBehavior != nullptr &&
             driftCheckBehavior->GetClass() == BehaviorClass::PlaypenDriftCheck,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenDriftCheck");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(driftCheckBehavior));
  
  ICozmoBehaviorPtr cameraCalibBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenCameraCalibration);
  DEV_ASSERT(cameraCalibBehavior != nullptr &&
             cameraCalibBehavior->GetClass() == BehaviorClass::PlaypenCameraCalibration,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenCameraCalibration");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(cameraCalibBehavior));

  ICozmoBehaviorPtr driveFowardsBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenDriveForwards);
  DEV_ASSERT(driveFowardsBehavior != nullptr &&
             driveFowardsBehavior->GetClass() == BehaviorClass::PlaypenDriveForwards,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenDriveForwards");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(driveFowardsBehavior));
  
//  ICozmoBehaviorPtr readToolCodeBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenReadToolCode);
//  DEV_ASSERT(readToolCodeBehavior != nullptr &&
//             readToolCodeBehavior->GetClass() == BehaviorClass::PlaypenReadToolCode,
//             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenReadToolCode");
//  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(readToolCodeBehavior));

  ICozmoBehaviorPtr soundCheckBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenSoundCheck);
  DEV_ASSERT(soundCheckBehavior != nullptr &&
             soundCheckBehavior->GetClass() == BehaviorClass::PlaypenSoundCheck,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenSoundCheck");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(soundCheckBehavior));

  ICozmoBehaviorPtr distanceSensorCheck300mm = BC.FindBehaviorByID(BehaviorID::PlaypenDistanceSensor300mm);
  DEV_ASSERT(distanceSensorCheck300mm != nullptr &&
             distanceSensorCheck300mm->GetClass() == BehaviorClass::PlaypenDistanceSensor,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenDistanceSensor300mm");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(distanceSensorCheck300mm));

  ICozmoBehaviorPtr distanceSensorCheck100mm = BC.FindBehaviorByID(BehaviorID::PlaypenDistanceSensor100mm);
  DEV_ASSERT(distanceSensorCheck100mm != nullptr &&
             distanceSensorCheck100mm->GetClass() == BehaviorClass::PlaypenDistanceSensor,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenDistanceSensor100mm");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(distanceSensorCheck100mm));
  
  ICozmoBehaviorPtr pickupBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenPickupCube);
  DEV_ASSERT(pickupBehavior != nullptr &&
             pickupBehavior->GetClass() == BehaviorClass::PlaypenPickupCube,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenPickupCube");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(pickupBehavior));

  ICozmoBehaviorPtr endChecksBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenEndChecks);
  DEV_ASSERT(endChecksBehavior != nullptr &&
             endChecksBehavior->GetClass() == BehaviorClass::PlaypenEndChecks,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenEndChecks");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(endChecksBehavior));

  _currentPlaypenBehaviorIter = _playpenBehaviors.begin();
  _currentBehavior = *_currentPlaypenBehaviorIter;

  if(robot.HasExternalInterface())
  {
    auto helper = MakeAnkiEventUtil(*robot.GetExternalInterface(), *this, _signalHandles);
    helper.SubscribeEngineToGame<ExternalInterface::MessageEngineToGameTag::PlaypenBehaviorFailed>();
  }
}

void BehaviorPlaypenTest::GetAllDelegates(std::set<IBehavior*>& delegates) const
{
  for(auto& entry: _playpenBehaviors){
    delegates.insert(entry.get());
  }
}

  
Result BehaviorPlaypenTest::OnBehaviorActivated(BehaviorExternalInterface& behaviorExternalInterface)
{
  // DEPRECATED - Grabbing robot to support current cozmo code, but this should
  // be removed
  Robot& robot = behaviorExternalInterface.GetRobot();

  if(robot.HasExternalInterface())
  {
    robot.GetExternalInterface()->BroadcastToEngine<ExternalInterface::SetRobotVolume>(1, PlaypenConfig::kSoundVolume);
  }

  // Start the factory log
  std::stringstream serialNumString;
  serialNumString << std::hex << robot.GetHeadSerialNumber();
  _factoryTestLogger.StartLog( serialNumString.str(), true, robot.GetContextDataPlatform());
  PRINT_NAMED_INFO("BehaviorPlaypenTest.WillLogToDevice",
                   "Log name: %s",
                   _factoryTestLogger.GetLogName().c_str());
  
  // Set blind docking mode
  NativeAnkiUtilConsoleSetValueWithString("PickupDockingMethod", "0");
  
  // Disable driving animations
  NativeAnkiUtilConsoleSetValueWithString("EnableDrivingAnimations", "false");
  
  // Make sure only Marker Detection mode is enabled; we don't need anything else running
  robot.GetVisionComponent().EnableMode(VisionMode::Idle, true); // first, turn everything off
  robot.GetVisionComponent().EnableMode(VisionMode::DetectingMarkers, true);
  
  // Set and disable auto exposure
  robot.GetVisionComponent().SetAndDisableAutoExposure(PlaypenConfig::kExposure_ms, PlaypenConfig::kGain);
  
  // Disable block pool from auto connecting
  if(robot.HasExternalInterface())
  {
    robot.GetExternalInterface()->BroadcastToEngine<ExternalInterface::BlockPoolEnabledMessage>(0, false);
  }
  
  // Enable writing factory data
  robot.GetNVStorageComponent().EnableWritingFactory(true);
  
  _imuTemp.tempStart_c = robot.GetImuTemperature();
  _imuTemp.duration_ms = BaseStationTimer::getInstance()->GetCurrentTimeStamp();
  
  // Delegate to the first behavior
  _currentBehavior->WantsToBeActivated(behaviorExternalInterface);
  DelegateNow(behaviorExternalInterface, _currentBehavior.get());

  return RESULT_OK;
}

void BehaviorPlaypenTest::OnBehaviorDeactivated(BehaviorExternalInterface& behaviorExternalInterface)
{
  Reset(behaviorExternalInterface);
}

void BehaviorPlaypenTest::Reset(BehaviorExternalInterface& behaviorExternalInterface)
{
  // Reset all playpen behaviors
  for(auto& behavior : _playpenBehaviors)
  {
    behavior->Reset(behaviorExternalInterface);
  }
  
  // Set current behavior to first playpen behavior
  _currentPlaypenBehaviorIter = _playpenBehaviors.begin();
  _currentBehavior = *_currentPlaypenBehaviorIter;
  
  // Clear imu temp struct
  _imuTemp = IMUTempDuration();
}

void BehaviorPlaypenTest::BehaviorUpdate(BehaviorExternalInterface& behaviorExternalInterface)
{
  if(_currentBehavior != nullptr)
  {
    // Check if the current behavior has failed
    const FactoryTestResultCode result = _currentBehavior->GetResult();
    if(result != FactoryTestResultCode::UNKNOWN &&
       result != FactoryTestResultCode::SUCCESS)
    {
      _currentBehavior->OnDeactivated(behaviorExternalInterface);
      
      PRINT_NAMED_WARNING("BehaviorPlaypenTest.Update.BehaviorFailed",
                          "Behavior %s failed with %s",
                          _currentBehavior->GetIDStr().c_str(),
                          EnumToString(_currentBehavior->GetResult()));
      
      HandleResult(behaviorExternalInterface, result);
      //return RESULT_FAIL;
    }
  }

  // If the current behavior has completed
  if(_currentBehavior->GetResult() == FactoryTestResultCode::SUCCESS)
  {    
    // Move to the next behavior
    _currentPlaypenBehaviorIter++;
    
    // If we still have behaviors to run
    if(_currentPlaypenBehaviorIter != _playpenBehaviors.end())
    {
      // Update current behavior
      _currentBehavior = *_currentPlaypenBehaviorIter;
      DEV_ASSERT(_currentBehavior != nullptr, "BehaviorPlaypenTest.BehaviorUpdate.NullCurrentBehavior");
      
      if(!_currentBehavior->WantsToBeActivated(behaviorExternalInterface))
      {
        PRINT_NAMED_ERROR("BehaviorPlaypenTest.ChooseNextBehaviorInternal.BehaviorNotRunnable",
                          "Current behavior %s is not runnable",
                          _currentBehavior->GetIDStr().c_str());
        
        HandleResult(behaviorExternalInterface, FactoryTestResultCode::BEHAVIOR_NOT_RUNNABLE);
      }
      
      _behaviorStartTimes.push_back(BaseStationTimer::getInstance()->GetCurrentTimeStamp());

      DelegateNow(behaviorExternalInterface, _currentBehavior.get());
    }
    // All playpen behaviors have run so success!
    else
    {
      PRINT_NAMED_INFO("BehaviorPlaypenTest.Complete", "All behaviors have been run");
      HandleResult(behaviorExternalInterface, FactoryTestResultCode::SUCCESS);
    }
  }
}


void BehaviorPlaypenTest::HandleResult(BehaviorExternalInterface& behaviorExternalInterface, FactoryTestResultCode result)
{
  // DEPRECATED - Grabbing robot to support current cozmo code, but this should
  // be removed
  Robot& robot = behaviorExternalInterface.GetRobot();

  // Update imu temp struct with the final temperature and append it to log
  _imuTemp.tempEnd_c = robot.GetImuTemperature();
  _imuTemp.duration_ms = BaseStationTimer::getInstance()->GetCurrentTimeStamp() - _imuTemp.duration_ms;
  if(!_factoryTestLogger.Append(_imuTemp))
  {
    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleResultInternal.WriteToLogFailed.ImuTemp", "");
    result = FactoryTestResultCode::WRITE_TO_LOG_FAILED;
  }
  
  // Write all playpen behavior results to log
  if(!_factoryTestLogger.Append(IBehaviorPlaypen::GetAllPlaypenResults()))
  {
    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleResultInternal.WriteToLogFailed.AllResults", "");
    result = FactoryTestResultCode::WRITE_TO_LOG_FAILED;
  }
  IBehaviorPlaypen::ResetAllPlaypenResults();

  FactoryTestResultEntry resultEntry;
  
  _behaviorStartTimes.resize(resultEntry.timestamps.size());
  _behaviorStartTimes[_behaviorStartTimes.size() - 1] = BaseStationTimer::getInstance()->GetCurrentTimeStamp();

  resultEntry.result = result;
  resultEntry.engineSHA1 = 0; // TODO: Populate
  resultEntry.utcTime = time(0);
  resultEntry.stationID = 0; // TODO: Populate from fixture
  std::copy(_behaviorStartTimes.begin(),
            _behaviorStartTimes.begin() + resultEntry.timestamps.size(),
            resultEntry.timestamps.begin());
  
  u8 buf[resultEntry.Size()];
  size_t numBytes = resultEntry.Pack(buf, sizeof(buf));
  if(PlaypenConfig::kWriteToStorage &&
     !robot.GetNVStorageComponent().Write(NVStorage::NVEntryTag::NVEntry_PlaypenTestResults,
                                          buf,
                                          numBytes))
  {
    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleResultInternal.WriteTestResultToRobotFailed",
                        "Writing test results to robot failed");
    resultEntry.result = FactoryTestResultCode::TEST_RESULT_WRITE_FAILED;
    result = FactoryTestResultCode::TEST_RESULT_WRITE_FAILED;
  }
  
  if(!_factoryTestLogger.Append(resultEntry))
  {
    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleResultInternal.WriteToLogFailed",
                        "Failed to write result entry to log");
    result = FactoryTestResultCode::WRITE_TO_LOG_FAILED;
  }

  if((result == FactoryTestResultCode::SUCCESS) && PlaypenConfig::kWriteToStorage)
  {
    time_t nowTime = time(0);
    struct tm* tmStruct = gmtime(&nowTime);
    
    // TODO: System time will be incorrect need to have a fixture set it
    BirthCertificate bc;
    bc.year   = static_cast<u8>(tmStruct->tm_year % 100);
    bc.month  = static_cast<u8>(tmStruct->tm_mon + 1); // Months start at zero
    bc.day    = static_cast<u8>(tmStruct->tm_mday);
    bc.hour   = static_cast<u8>(tmStruct->tm_hour);
    bc.minute = static_cast<u8>(tmStruct->tm_min);
    bc.second = static_cast<u8>(tmStruct->tm_sec);
    
    u8 buf[bc.Size()];
    size_t numBytes = bc.Pack(buf, sizeof(buf));

    if(!robot.GetNVStorageComponent().Write(NVStorage::NVEntryTag::NVEntry_BirthCertificate,
                                            buf,
                                            numBytes))
    {
      PRINT_NAMED_ERROR("BehaviorPlaypenTest.HandleResultInternal.BCWriteFailed", "");
      resultEntry.result = FactoryTestResultCode::BIRTH_CERTIFICATE_WRITE_FAILED;
      result = FactoryTestResultCode::BIRTH_CERTIFICATE_WRITE_FAILED;
    }
  }
  
  robot.Broadcast(ExternalInterface::MessageEngineToGame(FactoryTestResultEntry(resultEntry)));

  PRINT_NAMED_INFO("BehaviorPlaypenTest.HandleResultInternal.Result", 
                   "Playpen completed with %s",
                   EnumToString(result));

  // Copy engine logs if the test failed or we are ignoring failures
  if((result != FactoryTestResultCode::SUCCESS || PlaypenConfig::kIgnoreFailures) &&
     !_factoryTestLogger.CopyEngineLog(robot.GetContextDataPlatform()))
  {
    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleResultInternal.CopyEngineLogFailed", "");
  }
  _factoryTestLogger.CloseLog();

  DisplayResult(behaviorExternalInterface, result);
  
  // Reset playpen
  Reset(behaviorExternalInterface);

  // Fake being re-activated to startup playpen again
  OnBehaviorActivated(behaviorExternalInterface);

  // TODO(Al): Turn off Victor at end of playpen?
}

void BehaviorPlaypenTest::DisplayResult(BehaviorExternalInterface& behaviorExternalInterface, FactoryTestResultCode result)
{
  // DEPRECATED - Grabbing robot to support current cozmo code, but this should
  // be removed
  Robot& robot = behaviorExternalInterface.GetRobot();

  if(result == FactoryTestResultCode::SUCCESS)
  {
    static const BackpackLights passLights = {
      .onColors               = {{NamedColors::GREEN,NamedColors::GREEN,NamedColors::GREEN}},
      .offColors              = {{NamedColors::BLACK,NamedColors::BLACK,NamedColors::BLACK}},
      .onPeriod_ms            = {{1000,1000,1000}},
      .offPeriod_ms           = {{100,100,100}},
      .transitionOnPeriod_ms  = {{450,450,450}},
      .transitionOffPeriod_ms = {{450,450,450}},
      .offset                 = {{0,0,0}}
    };
    
    robot.GetBodyLightComponent().SetBackpackLights(passLights);

    robot.SendMessage(RobotInterface::EngineToRobot(RobotInterface::DrawTextOnScreen(RobotInterface::ColorRGB(0,0,0),
                                                                                     RobotInterface::ColorRGB(0,255,0),
                                                                                     "OK")));
  }
  else
  {
    static const BackpackLights failLights = {
      .onColors               = {{NamedColors::RED,NamedColors::RED,NamedColors::RED}},
      .offColors              = {{NamedColors::BLACK,NamedColors::BLACK,NamedColors::BLACK}},
      .onPeriod_ms            = {{500,500,500}},
      .offPeriod_ms           = {{500,500,500}},
      .transitionOnPeriod_ms  = {{0,0,0}},
      .transitionOffPeriod_ms = {{0,0,0}},
      .offset                 = {{0,0,0}}
    };
    
    robot.GetBodyLightComponent().SetBackpackLights(failLights);

    // Draw result to screen
    robot.SendMessage(RobotInterface::EngineToRobot(RobotInterface::DrawTextOnScreen(RobotInterface::ColorRGB(0,0,0),
                                                                                     RobotInterface::ColorRGB(255,0,0),
                                                                                     std::to_string((u32)result))));
  }
}

FactoryTestLogger& BehaviorPlaypenTest::GetFactoryTestLogger()
{
  return _factoryTestLogger;
}

template<>
void BehaviorPlaypenTest::HandleMessage(const ExternalInterface::PlaypenBehaviorFailed& msg)
{
  PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleMessage.PlaypenBehaviorFailed",
                      "Some behavior failed with %s%s",
                      EnumToString(msg.result),
                      (PlaypenConfig::kIgnoreFailures ? ", ignoring" : ""));

  if(!PlaypenConfig::kIgnoreFailures)
  {
    if(_currentBehavior != nullptr)
    {
      _currentBehavior->OnDeactivated(*_behaviorExternalInterface);
    }

    HandleResult(*_behaviorExternalInterface, msg.result);
  }
}

}
}

