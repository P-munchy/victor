/**
 * File: activityPlaypenTest.cpp
 *
 * Author: Al Chaussee
 * Created: 07/25/17
 *
 * Description:
 *
 * Copyright: Anki, Inc. 2017
 *
 **/

#include "engine/behaviorSystem/activities/activities/activityPlaypenTest.h"

#include "engine/behaviorSystem/behaviorManager.h"
#include "engine/behaviorSystem/behaviors/devBehaviors/playpen/iBehaviorPlaypen.h"
#include "engine/behaviorSystem/behaviorPreReqs/behaviorPreReqPlaypen.h"
#include "engine/blockWorld/blockWorld.h"
#include "engine/components/nvStorageComponent.h"
#include "engine/components/visionComponent.h"
#include "engine/cozmoContext.h"
#include "engine/robot.h"
#include "engine/robotManager.h"

namespace Anki {
namespace Cozmo {

ActivityPlaypenTest::ActivityPlaypenTest(Robot& robot, const Json::Value& config)
: IActivity(robot, config)
{
  const auto& BM = robot.GetBehaviorManager();
  
  IBehaviorPtr initCheckBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenInitChecks);
  DEV_ASSERT(initCheckBehavior != nullptr &&
             initCheckBehavior->GetClass() == BehaviorClass::PlaypenInitChecks,
             "ActivityPlaypenTest.ImproperClassRetrievedForName");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(initCheckBehavior));
  
  IBehaviorPtr motorCalibBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenMotorCalibration);
  DEV_ASSERT(motorCalibBehavior != nullptr &&
             motorCalibBehavior->GetClass() == BehaviorClass::PlaypenMotorCalibration,
             "ActivityPlaypenTest.ImproperClassRetrievedForName");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(motorCalibBehavior));
  
  IBehaviorPtr driftCheckBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenDriftCheck);
  DEV_ASSERT(driftCheckBehavior != nullptr &&
             driftCheckBehavior->GetClass() == BehaviorClass::PlaypenDriftCheck,
             "ActivityPlaypenTest.ImproperClassRetrievedForName");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(driftCheckBehavior));
  
  IBehaviorPtr cameraCalibBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenCameraCalibration);
  DEV_ASSERT(cameraCalibBehavior != nullptr &&
             cameraCalibBehavior->GetClass() == BehaviorClass::PlaypenCameraCalibration,
             "ActivityPlaypenTest.ImproperClassRetrievedForName");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(cameraCalibBehavior));

  IBehaviorPtr driveFowardsBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenDriveForwards);
  DEV_ASSERT(driveFowardsBehavior != nullptr &&
             driveFowardsBehavior->GetClass() == BehaviorClass::PlaypenDriveForwards,
             "ActivityPlaypenTest.ImproperClassRetrievedForName");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(driveFowardsBehavior));
  
  IBehaviorPtr pickupBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenPickupCube);
  DEV_ASSERT(pickupBehavior != nullptr &&
             pickupBehavior->GetClass() == BehaviorClass::PlaypenPickupCube,
             "ActivityPlaypenTest.ImproperClassRetrievedForName");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(pickupBehavior));


  _currentPlaypenBehaviorIter = _playpenBehaviors.begin();
  _currentBehavior = *_currentPlaypenBehaviorIter;
}

void ActivityPlaypenTest::OnSelectedInternal(Robot& robot)
{
  // Disable all reactions, we will handle them ourselves
//  SmartDisableReactionsWithLock(robot, GetIDStr(), ReactionTriggerHelpers::kAffectAllArray);
  robot.GetBehaviorManager().DisableReactionsWithLock(GetIDStr(), ReactionTriggerHelpers::kAffectAllArray);
  
  // Start the factory log
  std::stringstream serialNumString;
  serialNumString << std::hex << robot.GetHeadSerialNumber();
  _factoryTestLogger.StartLog( serialNumString.str(), true, robot.GetContextDataPlatform());
  PRINT_NAMED_INFO("BehaviorFactoryTest.WillLogToDevice",
                   "Log name: %s",
                   _factoryTestLogger.GetLogName().c_str());
  
  // Set blind docking mode
  ExternalInterface::SetDebugConsoleVarMessage dockMethodMsg;
  dockMethodMsg.varName = "PickupDockingMethod";
  dockMethodMsg.tryValue = "0";  // Blind docking
  robot.GetExternalInterface()->BroadcastToEngine<ExternalInterface::SetDebugConsoleVarMessage>(std::move(dockMethodMsg));
  
  // Disable driving animations
  ExternalInterface::SetDebugConsoleVarMessage driveAnimsMsg;
  driveAnimsMsg.varName = "EnableDrivingAnimations";
  driveAnimsMsg.tryValue = "false";
  robot.GetExternalInterface()->BroadcastToEngine<ExternalInterface::SetDebugConsoleVarMessage>(std::move(driveAnimsMsg));
  
  robot.GetVisionComponent().EnableMode(VisionMode::Idle, true); // first, turn everything off
  robot.GetVisionComponent().EnableMode(VisionMode::DetectingMarkers, true);
  
  robot.GetVisionComponent().SetAndDisableAutoExposure(PlaypenConfig::kExposure_ms, PlaypenConfig::kGain);
  
  // Disable block pool from auto connecting
  robot.GetExternalInterface()->BroadcastToEngine<ExternalInterface::BlockPoolEnabledMessage>(0, false);
  
  // Enable writing factory data
  robot.GetNVStorageComponent().EnableWritingFactory(true);
}

void ActivityPlaypenTest::OnDeselectedInternal(Robot& robot)
{
  for(auto& behavior : _playpenBehaviors)
  {
    behavior->Reset();
  }
  
  _currentPlaypenBehaviorIter = _playpenBehaviors.begin();
  
  _currentBehavior = *_currentPlaypenBehaviorIter;
}

Result ActivityPlaypenTest::Update(Robot& robot)
{
  if(_currentBehavior != nullptr)
  {
    const FactoryTestResultCode result = _currentBehavior->GetResults();
    if(result != FactoryTestResultCode::UNKNOWN &&
       result != FactoryTestResultCode::SUCCESS)
    {
      _currentBehavior->Stop();
      
      PRINT_NAMED_WARNING("", "Behavior %s failed with %s", _currentBehavior->GetIDStr().c_str(),
                          EnumToString(_currentBehavior->GetResults()));
      HandleFailure(robot, result);
      return RESULT_FAIL;
    }
  }
  return RESULT_OK;
}

IBehaviorPtr ActivityPlaypenTest::ChooseNextBehaviorInternal(Robot& robot, IBehaviorPtr currentRunningBehavior)
{
  // If the current behavior has completed
  if(_currentBehavior->GetResults() == FactoryTestResultCode::SUCCESS)
  {
    // Stop it if it is still running
    if(_currentBehavior->IsRunning())
    {
      _currentBehavior->Stop();
    }
    
    _currentPlaypenBehaviorIter++;
    
    // If we still have behaviors to run
    if(_currentPlaypenBehaviorIter != _playpenBehaviors.end())
    {
      // Update current behavior and increment iterator
      _currentBehavior = *_currentPlaypenBehaviorIter;
      
      // Pass the factory test logger to the behavior
      BehaviorPreReqPlaypen preReq(_factoryTestLogger);
      
      if(!_currentBehavior->IsRunnable(preReq))
      {
        PRINT_NAMED_ERROR("ActivityPlaypenTest.ChooseNextBehaviorInternal.BehaviorNotRunnable",
                          "Current behavior %s is not runnable",
                          _currentBehavior->GetIDStr().c_str());
        HandleFailure(robot, FactoryTestResultCode::BEHAVIOR_NOT_RUNNABLE);
        return nullptr;
      }
      
      _behaviorStartTimes.push_back(BaseStationTimer::getInstance()->GetCurrentTimeStamp());
      
      return _currentBehavior;
    }
    // All playpen behaviors have run so success!
    else
    {
      HandleSuccess(robot, FactoryTestResultCode::SUCCESS);
      return nullptr;
    }
  }
  else
  {
    // Current behavior hasn't completed yet
    return _currentBehavior;
  }
}

void ActivityPlaypenTest::HandleSuccess(Robot& robot, FactoryTestResultCode result)
{
  PRINT_NAMED_WARNING("", "success");
  HandleResultInternal(robot, result);
}

void ActivityPlaypenTest::HandleFailure(Robot& robot, FactoryTestResultCode result)
{
  PRINT_NAMED_WARNING("", "failure");
  HandleResultInternal(robot, result);
}

void ActivityPlaypenTest::HandleResultInternal(Robot& robot, FactoryTestResultCode result)
{
  FactoryTestResultEntry resultEntry;
  
  _behaviorStartTimes.resize(resultEntry.timestamps.size());
  _behaviorStartTimes[_behaviorStartTimes.size() - 1] = BaseStationTimer::getInstance()->GetCurrentTimeStamp();

  resultEntry.result = result;
  resultEntry.engineSHA1 = 0; // TODO: Populate
  resultEntry.utcTime = time(0);
  resultEntry.stationID = 0; // TODO: Populate from fixture
  std::copy(_behaviorStartTimes.begin(),
            _behaviorStartTimes.begin() + resultEntry.timestamps.size(),
            resultEntry.timestamps.begin());
  
  u8 buf[resultEntry.Size()];
  size_t numBytes = resultEntry.Pack(buf, sizeof(buf));
  if(PlaypenConfig::kWriteToStorage &&
     !robot.GetNVStorageComponent().Write(NVStorage::NVEntryTag::NVEntry_PlaypenTestResults,
                                          buf,
                                          numBytes))
  {
    PRINT_NAMED_WARNING("", "writing test results failed");
    resultEntry.result = FactoryTestResultCode::TEST_RESULT_WRITE_FAILED;
  }
  
  if(!_factoryTestLogger.Append(resultEntry))
  {
    PRINT_NAMED_ERROR("", "failed to write result entry to log");
  }
  
  robot.Broadcast(ExternalInterface::MessageEngineToGame(FactoryTestResultEntry(resultEntry)));

  if(result != FactoryTestResultCode::SUCCESS &&
     !_factoryTestLogger.CopyEngineLog(robot.GetContextDataPlatform()))
  {
    PRINT_NAMED_WARNING("BehaviorFactoryTest.EndTest.CopyEngineLogFailed", "");
  }
  _factoryTestLogger.CloseLog();
  
  robot.GetBehaviorManager().SetCurrentActivity(HighLevelActivity::Selection);
  
  //TODO: send log and images to fixture, and display result code
  
  // Immediately disconnect wifi
  if(PlaypenConfig::kDisconnectAtEnd)
  {
    RobotInterface::EnterFactoryTestMode m;
    m.mode = RobotInterface::FactoryTestMode::FTM_Off;
    robot.SendMessage(RobotInterface::EngineToRobot(std::move(m)));
  }
}

}
}

