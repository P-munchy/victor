/**
 * File: activityPlaypenTest.cpp
 *
 * Author: Al Chaussee
 * Created: 07/25/17
 *
 * Description: Runs individual steps (behaviors) of playpen and manages switching between them and dealing
 *              failures
 *
 * Copyright: Anki, Inc. 2017
 *
 **/

#include "engine/behaviorSystem/activities/activities/activityPlaypenTest.h"

#include "engine/actions/setFaceAction.h"
#include "engine/behaviorSystem/behaviorManager.h"
#include "engine/behaviorSystem/behaviors/devBehaviors/playpen/iBehaviorPlaypen.h"
#include "engine/blockWorld/blockWorld.h"
#include "engine/components/bodyLightComponent.h"
#include "engine/components/nvStorageComponent.h"
#include "engine/components/visionComponent.h"
#include "engine/cozmoContext.h"
#include "engine/robot.h"
#include "engine/robotManager.h"

#include "util/console/consoleSystem.h"

namespace Anki {
namespace Cozmo {

namespace {
  FactoryTestLogger _factoryTestLogger;
}

ActivityPlaypenTest::ActivityPlaypenTest(Robot& robot, const Json::Value& config)
: IActivity(robot, config)
, _robot(robot)
{
  const auto& BM = robot.GetBehaviorManager();
  
  IBehaviorPtr waitToStartBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenWaitToStart);
  DEV_ASSERT(waitToStartBehavior != nullptr &&
             waitToStartBehavior->GetClass() == BehaviorClass::PlaypenWaitToStart,
             "ActivityPlaypenTest.ImproperClassRetrievedForName.PlaypenWaitToStart");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(waitToStartBehavior));

  IBehaviorPtr initCheckBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenInitChecks);
  DEV_ASSERT(initCheckBehavior != nullptr &&
             initCheckBehavior->GetClass() == BehaviorClass::PlaypenInitChecks,
             "ActivityPlaypenTest.ImproperClassRetrievedForName.PlaypenInitChecks");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(initCheckBehavior));
  
  IBehaviorPtr motorCalibBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenMotorCalibration);
  DEV_ASSERT(motorCalibBehavior != nullptr &&
             motorCalibBehavior->GetClass() == BehaviorClass::PlaypenMotorCalibration,
             "ActivityPlaypenTest.ImproperClassRetrievedForName.PlaypenMotorCalibration");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(motorCalibBehavior));
  
  IBehaviorPtr driftCheckBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenDriftCheck);
  DEV_ASSERT(driftCheckBehavior != nullptr &&
             driftCheckBehavior->GetClass() == BehaviorClass::PlaypenDriftCheck,
             "ActivityPlaypenTest.ImproperClassRetrievedForName.PlaypenDriftCheck");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(driftCheckBehavior));
  
  IBehaviorPtr cameraCalibBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenCameraCalibration);
  DEV_ASSERT(cameraCalibBehavior != nullptr &&
             cameraCalibBehavior->GetClass() == BehaviorClass::PlaypenCameraCalibration,
             "ActivityPlaypenTest.ImproperClassRetrievedForName.PlaypenCameraCalibration");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(cameraCalibBehavior));

  IBehaviorPtr driveFowardsBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenDriveForwards);
  DEV_ASSERT(driveFowardsBehavior != nullptr &&
             driveFowardsBehavior->GetClass() == BehaviorClass::PlaypenDriveForwards,
             "ActivityPlaypenTest.ImproperClassRetrievedForName.PlaypenDriveForwards");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(driveFowardsBehavior));
  
//  IBehaviorPtr readToolCodeBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenReadToolCode);
//  DEV_ASSERT(readToolCodeBehavior != nullptr &&
//             readToolCodeBehavior->GetClass() == BehaviorClass::PlaypenReadToolCode,
//             "ActivityPlaypenTest.ImproperClassRetrievedForName.PlaypenReadToolCode");
//  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(readToolCodeBehavior));

  IBehaviorPtr distanceSensorCheck300mm = BM.FindBehaviorByID(BehaviorID::PlaypenDistanceSensor300mm);
  DEV_ASSERT(distanceSensorCheck300mm != nullptr &&
             distanceSensorCheck300mm->GetClass() == BehaviorClass::PlaypenDistanceSensor,
             "ActivityPlaypenTest.ImproperClassRetrievedForName.PlaypenDistanceSensor300mm");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(distanceSensorCheck300mm));

  IBehaviorPtr distanceSensorCheck100mm = BM.FindBehaviorByID(BehaviorID::PlaypenDistanceSensor100mm);
  DEV_ASSERT(distanceSensorCheck100mm != nullptr &&
             distanceSensorCheck100mm->GetClass() == BehaviorClass::PlaypenDistanceSensor,
             "ActivityPlaypenTest.ImproperClassRetrievedForName.PlaypenDistanceSensor100mm");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(distanceSensorCheck100mm));
  
  IBehaviorPtr pickupBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenPickupCube);
  DEV_ASSERT(pickupBehavior != nullptr &&
             pickupBehavior->GetClass() == BehaviorClass::PlaypenPickupCube,
             "ActivityPlaypenTest.ImproperClassRetrievedForName.PlaypenPickupCube");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(pickupBehavior));

  IBehaviorPtr endChecksBehavior = BM.FindBehaviorByID(BehaviorID::PlaypenEndChecks);
  DEV_ASSERT(endChecksBehavior != nullptr &&
             endChecksBehavior->GetClass() == BehaviorClass::PlaypenEndChecks,
             "ActivityPlaypenTest.ImproperClassRetrievedForName.PlaypenEndChecks");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(endChecksBehavior));

  _currentPlaypenBehaviorIter = _playpenBehaviors.begin();
  _currentBehavior = *_currentPlaypenBehaviorIter;

  auto helper = MakeAnkiEventUtil(*robot.GetExternalInterface(), *this, _signalHandles);
  helper.SubscribeEngineToGame<ExternalInterface::MessageEngineToGameTag::PlaypenBehaviorFailed>();
}

void ActivityPlaypenTest::OnSelectedInternal(Robot& robot)
{
  // Disable all reactions, we will handle them ourselves
  robot.GetBehaviorManager().RemoveDisableReactionsLock(GetIDStr());
  robot.GetBehaviorManager().DisableReactionsWithLock(GetIDStr(), ReactionTriggerHelpers::GetAffectAllArray());

  robot.GetExternalInterface()->BroadcastToEngine<ExternalInterface::SetRobotVolume>(1, PlaypenConfig::kSoundVolume);

  // Start the factory log
  std::stringstream serialNumString;
  serialNumString << std::hex << robot.GetHeadSerialNumber();
  _factoryTestLogger.StartLog( serialNumString.str(), true, robot.GetContextDataPlatform());
  PRINT_NAMED_INFO("ActivityPlaypenTest.WillLogToDevice",
                   "Log name: %s",
                   _factoryTestLogger.GetLogName().c_str());
  
  // Set blind docking mode
  NativeAnkiUtilConsoleSetValueWithString("PickupDockingMethod", "0");
  
  // Disable driving animations
  NativeAnkiUtilConsoleSetValueWithString("EnableDrivingAnimations", "false");
  
  // Make sure only Marker Detection mode is enabled; we don't need anything else running
  robot.GetVisionComponent().EnableMode(VisionMode::Idle, true); // first, turn everything off
  robot.GetVisionComponent().EnableMode(VisionMode::DetectingMarkers, true);
  
  // Set and disable auto exposure
  robot.GetVisionComponent().SetAndDisableAutoExposure(PlaypenConfig::kExposure_ms, PlaypenConfig::kGain);
  
  // Disable block pool from auto connecting
  robot.GetExternalInterface()->BroadcastToEngine<ExternalInterface::BlockPoolEnabledMessage>(0, false);
  
  // Enable writing factory data
  robot.GetNVStorageComponent().EnableWritingFactory(true);
  
  _imuTemp.tempStart_c = robot.GetImuTemperature();
  _imuTemp.duration_ms = BaseStationTimer::getInstance()->GetCurrentTimeStamp();
}

void ActivityPlaypenTest::OnDeselectedInternal(Robot& robot)
{
  // Reset all playpen behaviors
  for(auto& behavior : _playpenBehaviors)
  {
    behavior->Reset();
  }
  
  // Set current behavior to first playpen behavior
  _currentPlaypenBehaviorIter = _playpenBehaviors.begin();
  _currentBehavior = *_currentPlaypenBehaviorIter;
  
  // Clear imu temp struct
  _imuTemp = IMUTempDuration();
}

Result ActivityPlaypenTest::Update(Robot& robot)
{
  if(_currentBehavior != nullptr)
  {
    // Check if the current behavior has failed
    const FactoryTestResultCode result = _currentBehavior->GetResult();
    if(result != FactoryTestResultCode::UNKNOWN &&
       result != FactoryTestResultCode::SUCCESS)
    {
      _currentBehavior->Stop();
      
      PRINT_NAMED_WARNING("ActivityPlaypenTest.Update.BehaviorFailed",
                          "Behavior %s failed with %s",
                          _currentBehavior->GetIDStr().c_str(),
                          EnumToString(_currentBehavior->GetResult()));
      
      HandleResult(robot, result);
      return RESULT_FAIL;
    }
  }
  return RESULT_OK;
}

IBehaviorPtr ActivityPlaypenTest::GetDesiredActiveBehaviorInternal(Robot& robot, IBehaviorPtr currentRunningBehavior)
{
  // If the current behavior has completed
  if(_currentBehavior->GetResult() == FactoryTestResultCode::SUCCESS)
  {
    // Stop it if it is still running
    if(_currentBehavior->IsRunning())
    {
      _currentBehavior->Stop();
    }
    
    // Move to the next behavior
    _currentPlaypenBehaviorIter++;
    
    // If we still have behaviors to run
    if(_currentPlaypenBehaviorIter != _playpenBehaviors.end())
    {
      // Update current behavior
      _currentBehavior = *_currentPlaypenBehaviorIter;
      
      if(!_currentBehavior->IsRunnable(robot))
      {
        PRINT_NAMED_ERROR("ActivityPlaypenTest.ChooseNextBehaviorInternal.BehaviorNotRunnable",
                          "Current behavior %s is not runnable",
                          _currentBehavior->GetIDStr().c_str());
        
        HandleResult(robot, FactoryTestResultCode::BEHAVIOR_NOT_RUNNABLE);
        return nullptr;
      }
      
      _behaviorStartTimes.push_back(BaseStationTimer::getInstance()->GetCurrentTimeStamp());
      
      return _currentBehavior;
    }
    // All playpen behaviors have run so success!
    else
    {
      PRINT_NAMED_INFO("ActivityPlaypenTest.Complete", "All behaviors have been run");
      HandleResult(robot, FactoryTestResultCode::SUCCESS);
      return nullptr;
    }
  }
  else
  {
    // Current behavior hasn't completed yet
    return _currentBehavior;
  }
}

void ActivityPlaypenTest::HandleResult(Robot& robot, FactoryTestResultCode result)
{
  // Update imu temp struct with the final temperature and append it to log
  _imuTemp.tempEnd_c = robot.GetImuTemperature();
  _imuTemp.duration_ms = BaseStationTimer::getInstance()->GetCurrentTimeStamp() - _imuTemp.duration_ms;
  if(!_factoryTestLogger.Append(_imuTemp))
  {
    PRINT_NAMED_WARNING("ActivityPlaypenTest.HandleResultInternal.WriteToLogFailed.ImuTemp", "");
    result = FactoryTestResultCode::WRITE_TO_LOG_FAILED;
  }
  
  // Write all playpen behavior results to log
  if(!_factoryTestLogger.Append(IBehaviorPlaypen::GetAllPlaypenResults()))
  {
    PRINT_NAMED_WARNING("ActivityPlaypenTest.HandleResultInternal.WriteToLogFailed.AllResults", "");
    result = FactoryTestResultCode::WRITE_TO_LOG_FAILED;
  }
  IBehaviorPlaypen::ResetAllPlaypenResults();

  FactoryTestResultEntry resultEntry;
  
  _behaviorStartTimes.resize(resultEntry.timestamps.size());
  _behaviorStartTimes[_behaviorStartTimes.size() - 1] = BaseStationTimer::getInstance()->GetCurrentTimeStamp();

  resultEntry.result = result;
  resultEntry.engineSHA1 = 0; // TODO: Populate
  resultEntry.utcTime = time(0);
  resultEntry.stationID = 0; // TODO: Populate from fixture
  std::copy(_behaviorStartTimes.begin(),
            _behaviorStartTimes.begin() + resultEntry.timestamps.size(),
            resultEntry.timestamps.begin());
  
  u8 buf[resultEntry.Size()];
  size_t numBytes = resultEntry.Pack(buf, sizeof(buf));
  if(PlaypenConfig::kWriteToStorage &&
     !robot.GetNVStorageComponent().Write(NVStorage::NVEntryTag::NVEntry_PlaypenTestResults,
                                          buf,
                                          numBytes))
  {
    PRINT_NAMED_WARNING("ActivityPlaypenTest.HandleResultInternal.WriteTestResultToRobotFailed",
                        "Writing test results to robot failed");
    resultEntry.result = FactoryTestResultCode::TEST_RESULT_WRITE_FAILED;
    result = FactoryTestResultCode::TEST_RESULT_WRITE_FAILED;
  }
  
  if(!_factoryTestLogger.Append(resultEntry))
  {
    PRINT_NAMED_WARNING("ActivityPlaypenTest.HandleResultInternal.WriteToLogFailed",
                        "Failed to write result entry to log");
    result = FactoryTestResultCode::WRITE_TO_LOG_FAILED;
  }

  if((result == FactoryTestResultCode::SUCCESS) && PlaypenConfig::kWriteToStorage)
  {
    time_t nowTime = time(0);
    struct tm* tmStruct = gmtime(&nowTime);
    
    // TODO: System time will be incorrect need to have a fixture set it
    BirthCertificate bc;
    bc.year   = static_cast<u8>(tmStruct->tm_year % 100);
    bc.month  = static_cast<u8>(tmStruct->tm_mon + 1); // Months start at zero
    bc.day    = static_cast<u8>(tmStruct->tm_mday);
    bc.hour   = static_cast<u8>(tmStruct->tm_hour);
    bc.minute = static_cast<u8>(tmStruct->tm_min);
    bc.second = static_cast<u8>(tmStruct->tm_sec);
    
    u8 buf[bc.Size()];
    size_t numBytes = bc.Pack(buf, sizeof(buf));

    if(!robot.GetNVStorageComponent().Write(NVStorage::NVEntryTag::NVEntry_BirthCertificate,
                                            buf,
                                            numBytes))
    {
      PRINT_NAMED_ERROR("ActivityPlaypenTest.HandleResultInternal.BCWriteFailed", "");
      resultEntry.result = FactoryTestResultCode::BIRTH_CERTIFICATE_WRITE_FAILED;
      result = FactoryTestResultCode::BIRTH_CERTIFICATE_WRITE_FAILED;
    }
  }
  
  robot.Broadcast(ExternalInterface::MessageEngineToGame(FactoryTestResultEntry(resultEntry)));

  PRINT_NAMED_INFO("ActivityPlaypenTest.HandleResultInternal.Result", 
                   "Playpen completed with %s",
                   EnumToString(result));

  // Copy engine logs if the test failed or we are ignoring failures
  if((result != FactoryTestResultCode::SUCCESS || PlaypenConfig::kIgnoreFailures) &&
     !_factoryTestLogger.CopyEngineLog(robot.GetContextDataPlatform()))
  {
    PRINT_NAMED_WARNING("ActivityPlaypenTest.HandleResultInternal.CopyEngineLogFailed", "");
  }
  _factoryTestLogger.CloseLog();

  DisplayResult(robot, result);
  
  robot.GetBehaviorManager().SetCurrentActivity(HighLevelActivity::Selection);
  robot.GetBehaviorManager().SetCurrentActivity(HighLevelActivity::PlaypenTest);
  
  // TODO(Al): Turn off Victor at end of playpen?
}

void ActivityPlaypenTest::DisplayResult(Robot& robot, FactoryTestResultCode result)
{
  if(result == FactoryTestResultCode::SUCCESS)
  {
    static const BackpackLights passLights = {
      .onColors               = {{NamedColors::GREEN,NamedColors::GREEN,NamedColors::GREEN}},
      .offColors              = {{NamedColors::BLACK,NamedColors::BLACK,NamedColors::BLACK}},
      .onPeriod_ms            = {{1000,1000,1000}},
      .offPeriod_ms           = {{100,100,100}},
      .transitionOnPeriod_ms  = {{450,450,450}},
      .transitionOffPeriod_ms = {{450,450,450}},
      .offset                 = {{0,0,0}}
    };
    
    robot.GetBodyLightComponent().SetBackpackLights(passLights);

    robot.SendMessage(RobotInterface::EngineToRobot(RobotInterface::DrawTextOnScreen(RobotInterface::ColorRGB(0,0,0),
                                                                                     RobotInterface::ColorRGB(0,255,0),
                                                                                     "OK")));
  }
  else
  {
    static const BackpackLights failLights = {
      .onColors               = {{NamedColors::RED,NamedColors::RED,NamedColors::RED}},
      .offColors              = {{NamedColors::BLACK,NamedColors::BLACK,NamedColors::BLACK}},
      .onPeriod_ms            = {{500,500,500}},
      .offPeriod_ms           = {{500,500,500}},
      .transitionOnPeriod_ms  = {{0,0,0}},
      .transitionOffPeriod_ms = {{0,0,0}},
      .offset                 = {{0,0,0}}
    };
    
    robot.GetBodyLightComponent().SetBackpackLights(failLights);

    // Draw result to screen
    robot.SendMessage(RobotInterface::EngineToRobot(RobotInterface::DrawTextOnScreen(RobotInterface::ColorRGB(0,0,0),
                                                                                     RobotInterface::ColorRGB(255,0,0),
                                                                                     std::to_string((u32)result))));
  }
}

FactoryTestLogger& ActivityPlaypenTest::GetFactoryTestLogger()
{
  return _factoryTestLogger;
}

template<>
void ActivityPlaypenTest::HandleMessage(const ExternalInterface::PlaypenBehaviorFailed& msg)
{
  PRINT_NAMED_WARNING("ActivityPlaypenTest.HandleMessage.PlaypenBehaviorFailed",
                      "Some behavior failed with %s%s",
                      EnumToString(msg.result),
                      (PlaypenConfig::kIgnoreFailures ? ", ignoring" : ""));

  if(!PlaypenConfig::kIgnoreFailures)
  {
    if(_currentBehavior != nullptr)
    {
      _currentBehavior->Stop();
    }

    HandleResult(_robot, msg.result);
  }
}

}
}

