// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_COZMOANIM_COZMOANIM_H_
#define FLATBUFFERS_GENERATED_COZMOANIM_COZMOANIM_H_

#include "flatbuffers/flatbuffers.h"

namespace CozmoAnim {

struct LiftHeight;

struct ProceduralFace;

struct HeadAngle;

struct RobotAudio;

struct BackpackLights;

struct FaceAnimation;

struct Event;

struct BodyMotion;

struct Keyframes;

struct AnimClip;

struct AnimClips;

struct LiftHeight FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_DURATIONTIME_MS = 6,
    VT_HEIGHT_MM = 8,
    VT_HEIGHTVARIABILITY_MM = 10
  };
  float triggerTime_ms() const { return GetField<float>(VT_TRIGGERTIME_MS, 0.0f); }
  float durationTime_ms() const { return GetField<float>(VT_DURATIONTIME_MS, 0.0f); }
  float height_mm() const { return GetField<float>(VT_HEIGHT_MM, 0.0f); }
  int32_t heightVariability_mm() const { return GetField<int32_t>(VT_HEIGHTVARIABILITY_MM, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<float>(verifier, VT_DURATIONTIME_MS) &&
           VerifyField<float>(verifier, VT_HEIGHT_MM) &&
           VerifyField<int32_t>(verifier, VT_HEIGHTVARIABILITY_MM) &&
           verifier.EndTable();
  }
};

struct LiftHeightBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(float triggerTime_ms) { fbb_.AddElement<float>(LiftHeight::VT_TRIGGERTIME_MS, triggerTime_ms, 0.0f); }
  void add_durationTime_ms(float durationTime_ms) { fbb_.AddElement<float>(LiftHeight::VT_DURATIONTIME_MS, durationTime_ms, 0.0f); }
  void add_height_mm(float height_mm) { fbb_.AddElement<float>(LiftHeight::VT_HEIGHT_MM, height_mm, 0.0f); }
  void add_heightVariability_mm(int32_t heightVariability_mm) { fbb_.AddElement<int32_t>(LiftHeight::VT_HEIGHTVARIABILITY_MM, heightVariability_mm, 0); }
  LiftHeightBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LiftHeightBuilder &operator=(const LiftHeightBuilder &);
  flatbuffers::Offset<LiftHeight> Finish() {
    auto o = flatbuffers::Offset<LiftHeight>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<LiftHeight> CreateLiftHeight(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    float durationTime_ms = 0.0f,
    float height_mm = 0.0f,
    int32_t heightVariability_mm = 0) {
  LiftHeightBuilder builder_(_fbb);
  builder_.add_heightVariability_mm(heightVariability_mm);
  builder_.add_height_mm(height_mm);
  builder_.add_durationTime_ms(durationTime_ms);
  builder_.add_triggerTime_ms(triggerTime_ms);
  return builder_.Finish();
}

struct ProceduralFace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_DURATIONTIME_MS = 6,
    VT_FACEANGLE = 8,
    VT_FACECENTERX = 10,
    VT_FACECENTERY = 12,
    VT_FACESCALEX = 14,
    VT_FACESCALEY = 16,
    VT_LEFTEYE = 18,
    VT_RIGHTEYE = 20
  };
  float triggerTime_ms() const { return GetField<float>(VT_TRIGGERTIME_MS, 0.0f); }
  float durationTime_ms() const { return GetField<float>(VT_DURATIONTIME_MS, 0.0f); }
  float faceAngle() const { return GetField<float>(VT_FACEANGLE, 0.0f); }
  float faceCenterX() const { return GetField<float>(VT_FACECENTERX, 0.0f); }
  float faceCenterY() const { return GetField<float>(VT_FACECENTERY, 0.0f); }
  float faceScaleX() const { return GetField<float>(VT_FACESCALEX, 0.0f); }
  float faceScaleY() const { return GetField<float>(VT_FACESCALEY, 0.0f); }
  const flatbuffers::Vector<float> *leftEye() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_LEFTEYE); }
  const flatbuffers::Vector<float> *rightEye() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_RIGHTEYE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<float>(verifier, VT_DURATIONTIME_MS) &&
           VerifyField<float>(verifier, VT_FACEANGLE) &&
           VerifyField<float>(verifier, VT_FACECENTERX) &&
           VerifyField<float>(verifier, VT_FACECENTERY) &&
           VerifyField<float>(verifier, VT_FACESCALEX) &&
           VerifyField<float>(verifier, VT_FACESCALEY) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LEFTEYE) &&
           verifier.Verify(leftEye()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RIGHTEYE) &&
           verifier.Verify(rightEye()) &&
           verifier.EndTable();
  }
};

struct ProceduralFaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(float triggerTime_ms) { fbb_.AddElement<float>(ProceduralFace::VT_TRIGGERTIME_MS, triggerTime_ms, 0.0f); }
  void add_durationTime_ms(float durationTime_ms) { fbb_.AddElement<float>(ProceduralFace::VT_DURATIONTIME_MS, durationTime_ms, 0.0f); }
  void add_faceAngle(float faceAngle) { fbb_.AddElement<float>(ProceduralFace::VT_FACEANGLE, faceAngle, 0.0f); }
  void add_faceCenterX(float faceCenterX) { fbb_.AddElement<float>(ProceduralFace::VT_FACECENTERX, faceCenterX, 0.0f); }
  void add_faceCenterY(float faceCenterY) { fbb_.AddElement<float>(ProceduralFace::VT_FACECENTERY, faceCenterY, 0.0f); }
  void add_faceScaleX(float faceScaleX) { fbb_.AddElement<float>(ProceduralFace::VT_FACESCALEX, faceScaleX, 0.0f); }
  void add_faceScaleY(float faceScaleY) { fbb_.AddElement<float>(ProceduralFace::VT_FACESCALEY, faceScaleY, 0.0f); }
  void add_leftEye(flatbuffers::Offset<flatbuffers::Vector<float>> leftEye) { fbb_.AddOffset(ProceduralFace::VT_LEFTEYE, leftEye); }
  void add_rightEye(flatbuffers::Offset<flatbuffers::Vector<float>> rightEye) { fbb_.AddOffset(ProceduralFace::VT_RIGHTEYE, rightEye); }
  ProceduralFaceBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ProceduralFaceBuilder &operator=(const ProceduralFaceBuilder &);
  flatbuffers::Offset<ProceduralFace> Finish() {
    auto o = flatbuffers::Offset<ProceduralFace>(fbb_.EndTable(start_, 9));
    return o;
  }
};

inline flatbuffers::Offset<ProceduralFace> CreateProceduralFace(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    float durationTime_ms = 0.0f,
    float faceAngle = 0.0f,
    float faceCenterX = 0.0f,
    float faceCenterY = 0.0f,
    float faceScaleX = 0.0f,
    float faceScaleY = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> leftEye = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> rightEye = 0) {
  ProceduralFaceBuilder builder_(_fbb);
  builder_.add_rightEye(rightEye);
  builder_.add_leftEye(leftEye);
  builder_.add_faceScaleY(faceScaleY);
  builder_.add_faceScaleX(faceScaleX);
  builder_.add_faceCenterY(faceCenterY);
  builder_.add_faceCenterX(faceCenterX);
  builder_.add_faceAngle(faceAngle);
  builder_.add_durationTime_ms(durationTime_ms);
  builder_.add_triggerTime_ms(triggerTime_ms);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProceduralFace> CreateProceduralFaceDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    float durationTime_ms = 0.0f,
    float faceAngle = 0.0f,
    float faceCenterX = 0.0f,
    float faceCenterY = 0.0f,
    float faceScaleX = 0.0f,
    float faceScaleY = 0.0f,
    const std::vector<float> *leftEye = nullptr,
    const std::vector<float> *rightEye = nullptr) {
  return CreateProceduralFace(_fbb, triggerTime_ms, durationTime_ms, faceAngle, faceCenterX, faceCenterY, faceScaleX, faceScaleY, leftEye ? _fbb.CreateVector<float>(*leftEye) : 0, rightEye ? _fbb.CreateVector<float>(*rightEye) : 0);
}

struct HeadAngle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_DURATIONTIME_MS = 6,
    VT_ANGLE_DEG = 8,
    VT_ANGLEVARIABILITY_DEG = 10
  };
  float triggerTime_ms() const { return GetField<float>(VT_TRIGGERTIME_MS, 0.0f); }
  float durationTime_ms() const { return GetField<float>(VT_DURATIONTIME_MS, 0.0f); }
  float angle_deg() const { return GetField<float>(VT_ANGLE_DEG, 0.0f); }
  int32_t angleVariability_deg() const { return GetField<int32_t>(VT_ANGLEVARIABILITY_DEG, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<float>(verifier, VT_DURATIONTIME_MS) &&
           VerifyField<float>(verifier, VT_ANGLE_DEG) &&
           VerifyField<int32_t>(verifier, VT_ANGLEVARIABILITY_DEG) &&
           verifier.EndTable();
  }
};

struct HeadAngleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(float triggerTime_ms) { fbb_.AddElement<float>(HeadAngle::VT_TRIGGERTIME_MS, triggerTime_ms, 0.0f); }
  void add_durationTime_ms(float durationTime_ms) { fbb_.AddElement<float>(HeadAngle::VT_DURATIONTIME_MS, durationTime_ms, 0.0f); }
  void add_angle_deg(float angle_deg) { fbb_.AddElement<float>(HeadAngle::VT_ANGLE_DEG, angle_deg, 0.0f); }
  void add_angleVariability_deg(int32_t angleVariability_deg) { fbb_.AddElement<int32_t>(HeadAngle::VT_ANGLEVARIABILITY_DEG, angleVariability_deg, 0); }
  HeadAngleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  HeadAngleBuilder &operator=(const HeadAngleBuilder &);
  flatbuffers::Offset<HeadAngle> Finish() {
    auto o = flatbuffers::Offset<HeadAngle>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<HeadAngle> CreateHeadAngle(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    float durationTime_ms = 0.0f,
    float angle_deg = 0.0f,
    int32_t angleVariability_deg = 0) {
  HeadAngleBuilder builder_(_fbb);
  builder_.add_angleVariability_deg(angleVariability_deg);
  builder_.add_angle_deg(angle_deg);
  builder_.add_durationTime_ms(durationTime_ms);
  builder_.add_triggerTime_ms(triggerTime_ms);
  return builder_.Finish();
}

struct RobotAudio FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_AUDIONAME = 6,
    VT_AUDIOEVENTID = 8,
    VT_VOLUME = 10,
    VT_PROBABILITY = 12,
    VT_HASALTS = 14
  };
  float triggerTime_ms() const { return GetField<float>(VT_TRIGGERTIME_MS, 0.0f); }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *audioName() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_AUDIONAME); }
  const flatbuffers::Vector<int64_t> *audioEventId() const { return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AUDIOEVENTID); }
  float volume() const { return GetField<float>(VT_VOLUME, 1.0f); }
  float probability() const { return GetField<float>(VT_PROBABILITY, 1.0f); }
  bool hasAlts() const { return GetField<uint8_t>(VT_HASALTS, 1) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_AUDIONAME) &&
           verifier.Verify(audioName()) &&
           verifier.VerifyVectorOfStrings(audioName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_AUDIOEVENTID) &&
           verifier.Verify(audioEventId()) &&
           VerifyField<float>(verifier, VT_VOLUME) &&
           VerifyField<float>(verifier, VT_PROBABILITY) &&
           VerifyField<uint8_t>(verifier, VT_HASALTS) &&
           verifier.EndTable();
  }
};

struct RobotAudioBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(float triggerTime_ms) { fbb_.AddElement<float>(RobotAudio::VT_TRIGGERTIME_MS, triggerTime_ms, 0.0f); }
  void add_audioName(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> audioName) { fbb_.AddOffset(RobotAudio::VT_AUDIONAME, audioName); }
  void add_audioEventId(flatbuffers::Offset<flatbuffers::Vector<int64_t>> audioEventId) { fbb_.AddOffset(RobotAudio::VT_AUDIOEVENTID, audioEventId); }
  void add_volume(float volume) { fbb_.AddElement<float>(RobotAudio::VT_VOLUME, volume, 1.0f); }
  void add_probability(float probability) { fbb_.AddElement<float>(RobotAudio::VT_PROBABILITY, probability, 1.0f); }
  void add_hasAlts(bool hasAlts) { fbb_.AddElement<uint8_t>(RobotAudio::VT_HASALTS, static_cast<uint8_t>(hasAlts), 1); }
  RobotAudioBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RobotAudioBuilder &operator=(const RobotAudioBuilder &);
  flatbuffers::Offset<RobotAudio> Finish() {
    auto o = flatbuffers::Offset<RobotAudio>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<RobotAudio> CreateRobotAudio(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> audioName = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> audioEventId = 0,
    float volume = 1.0f,
    float probability = 1.0f,
    bool hasAlts = true) {
  RobotAudioBuilder builder_(_fbb);
  builder_.add_probability(probability);
  builder_.add_volume(volume);
  builder_.add_audioEventId(audioEventId);
  builder_.add_audioName(audioName);
  builder_.add_triggerTime_ms(triggerTime_ms);
  builder_.add_hasAlts(hasAlts);
  return builder_.Finish();
}

inline flatbuffers::Offset<RobotAudio> CreateRobotAudioDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *audioName = nullptr,
    const std::vector<int64_t> *audioEventId = nullptr,
    float volume = 1.0f,
    float probability = 1.0f,
    bool hasAlts = true) {
  return CreateRobotAudio(_fbb, triggerTime_ms, audioName ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*audioName) : 0, audioEventId ? _fbb.CreateVector<int64_t>(*audioEventId) : 0, volume, probability, hasAlts);
}

struct BackpackLights FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_DURATIONTIME_MS = 6,
    VT_LEFT = 8,
    VT_RIGHT = 10,
    VT_FRONT = 12,
    VT_MIDDLE = 14,
    VT_BACK = 16
  };
  float triggerTime_ms() const { return GetField<float>(VT_TRIGGERTIME_MS, 0.0f); }
  float durationTime_ms() const { return GetField<float>(VT_DURATIONTIME_MS, 0.0f); }
  const flatbuffers::Vector<float> *Left() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_LEFT); }
  const flatbuffers::Vector<float> *Right() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_RIGHT); }
  const flatbuffers::Vector<float> *Front() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_FRONT); }
  const flatbuffers::Vector<float> *Middle() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_MIDDLE); }
  const flatbuffers::Vector<float> *Back() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_BACK); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<float>(verifier, VT_DURATIONTIME_MS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LEFT) &&
           verifier.Verify(Left()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RIGHT) &&
           verifier.Verify(Right()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FRONT) &&
           verifier.Verify(Front()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MIDDLE) &&
           verifier.Verify(Middle()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACK) &&
           verifier.Verify(Back()) &&
           verifier.EndTable();
  }
};

struct BackpackLightsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(float triggerTime_ms) { fbb_.AddElement<float>(BackpackLights::VT_TRIGGERTIME_MS, triggerTime_ms, 0.0f); }
  void add_durationTime_ms(float durationTime_ms) { fbb_.AddElement<float>(BackpackLights::VT_DURATIONTIME_MS, durationTime_ms, 0.0f); }
  void add_Left(flatbuffers::Offset<flatbuffers::Vector<float>> Left) { fbb_.AddOffset(BackpackLights::VT_LEFT, Left); }
  void add_Right(flatbuffers::Offset<flatbuffers::Vector<float>> Right) { fbb_.AddOffset(BackpackLights::VT_RIGHT, Right); }
  void add_Front(flatbuffers::Offset<flatbuffers::Vector<float>> Front) { fbb_.AddOffset(BackpackLights::VT_FRONT, Front); }
  void add_Middle(flatbuffers::Offset<flatbuffers::Vector<float>> Middle) { fbb_.AddOffset(BackpackLights::VT_MIDDLE, Middle); }
  void add_Back(flatbuffers::Offset<flatbuffers::Vector<float>> Back) { fbb_.AddOffset(BackpackLights::VT_BACK, Back); }
  BackpackLightsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BackpackLightsBuilder &operator=(const BackpackLightsBuilder &);
  flatbuffers::Offset<BackpackLights> Finish() {
    auto o = flatbuffers::Offset<BackpackLights>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<BackpackLights> CreateBackpackLights(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    float durationTime_ms = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> Left = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Right = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Front = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Middle = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Back = 0) {
  BackpackLightsBuilder builder_(_fbb);
  builder_.add_Back(Back);
  builder_.add_Middle(Middle);
  builder_.add_Front(Front);
  builder_.add_Right(Right);
  builder_.add_Left(Left);
  builder_.add_durationTime_ms(durationTime_ms);
  builder_.add_triggerTime_ms(triggerTime_ms);
  return builder_.Finish();
}

inline flatbuffers::Offset<BackpackLights> CreateBackpackLightsDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    float durationTime_ms = 0.0f,
    const std::vector<float> *Left = nullptr,
    const std::vector<float> *Right = nullptr,
    const std::vector<float> *Front = nullptr,
    const std::vector<float> *Middle = nullptr,
    const std::vector<float> *Back = nullptr) {
  return CreateBackpackLights(_fbb, triggerTime_ms, durationTime_ms, Left ? _fbb.CreateVector<float>(*Left) : 0, Right ? _fbb.CreateVector<float>(*Right) : 0, Front ? _fbb.CreateVector<float>(*Front) : 0, Middle ? _fbb.CreateVector<float>(*Middle) : 0, Back ? _fbb.CreateVector<float>(*Back) : 0);
}

struct FaceAnimation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_ANIMNAME = 6
  };
  float triggerTime_ms() const { return GetField<float>(VT_TRIGGERTIME_MS, 0.0f); }
  const flatbuffers::String *animName() const { return GetPointer<const flatbuffers::String *>(VT_ANIMNAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANIMNAME) &&
           verifier.Verify(animName()) &&
           verifier.EndTable();
  }
};

struct FaceAnimationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(float triggerTime_ms) { fbb_.AddElement<float>(FaceAnimation::VT_TRIGGERTIME_MS, triggerTime_ms, 0.0f); }
  void add_animName(flatbuffers::Offset<flatbuffers::String> animName) { fbb_.AddOffset(FaceAnimation::VT_ANIMNAME, animName); }
  FaceAnimationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FaceAnimationBuilder &operator=(const FaceAnimationBuilder &);
  flatbuffers::Offset<FaceAnimation> Finish() {
    auto o = flatbuffers::Offset<FaceAnimation>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<FaceAnimation> CreateFaceAnimation(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    flatbuffers::Offset<flatbuffers::String> animName = 0) {
  FaceAnimationBuilder builder_(_fbb);
  builder_.add_animName(animName);
  builder_.add_triggerTime_ms(triggerTime_ms);
  return builder_.Finish();
}

inline flatbuffers::Offset<FaceAnimation> CreateFaceAnimationDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    const char *animName = nullptr) {
  return CreateFaceAnimation(_fbb, triggerTime_ms, animName ? _fbb.CreateString(animName) : 0);
}

struct Event FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_EVENT_ID = 6
  };
  float triggerTime_ms() const { return GetField<float>(VT_TRIGGERTIME_MS, 0.0f); }
  const flatbuffers::String *event_id() const { return GetPointer<const flatbuffers::String *>(VT_EVENT_ID); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENT_ID) &&
           verifier.Verify(event_id()) &&
           verifier.EndTable();
  }
};

struct EventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(float triggerTime_ms) { fbb_.AddElement<float>(Event::VT_TRIGGERTIME_MS, triggerTime_ms, 0.0f); }
  void add_event_id(flatbuffers::Offset<flatbuffers::String> event_id) { fbb_.AddOffset(Event::VT_EVENT_ID, event_id); }
  EventBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EventBuilder &operator=(const EventBuilder &);
  flatbuffers::Offset<Event> Finish() {
    auto o = flatbuffers::Offset<Event>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Event> CreateEvent(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    flatbuffers::Offset<flatbuffers::String> event_id = 0) {
  EventBuilder builder_(_fbb);
  builder_.add_event_id(event_id);
  builder_.add_triggerTime_ms(triggerTime_ms);
  return builder_.Finish();
}

inline flatbuffers::Offset<Event> CreateEventDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    const char *event_id = nullptr) {
  return CreateEvent(_fbb, triggerTime_ms, event_id ? _fbb.CreateString(event_id) : 0);
}

struct BodyMotion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRIGGERTIME_MS = 4,
    VT_DURATIONTIME_MS = 6,
    VT_RADIUS_MM = 8,
    VT_SPEED = 10
  };
  float triggerTime_ms() const { return GetField<float>(VT_TRIGGERTIME_MS, 0.0f); }
  float durationTime_ms() const { return GetField<float>(VT_DURATIONTIME_MS, 0.0f); }
  const flatbuffers::String *radius_mm() const { return GetPointer<const flatbuffers::String *>(VT_RADIUS_MM); }
  float speed() const { return GetField<float>(VT_SPEED, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TRIGGERTIME_MS) &&
           VerifyField<float>(verifier, VT_DURATIONTIME_MS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RADIUS_MM) &&
           verifier.Verify(radius_mm()) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           verifier.EndTable();
  }
};

struct BodyMotionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triggerTime_ms(float triggerTime_ms) { fbb_.AddElement<float>(BodyMotion::VT_TRIGGERTIME_MS, triggerTime_ms, 0.0f); }
  void add_durationTime_ms(float durationTime_ms) { fbb_.AddElement<float>(BodyMotion::VT_DURATIONTIME_MS, durationTime_ms, 0.0f); }
  void add_radius_mm(flatbuffers::Offset<flatbuffers::String> radius_mm) { fbb_.AddOffset(BodyMotion::VT_RADIUS_MM, radius_mm); }
  void add_speed(float speed) { fbb_.AddElement<float>(BodyMotion::VT_SPEED, speed, 0.0f); }
  BodyMotionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BodyMotionBuilder &operator=(const BodyMotionBuilder &);
  flatbuffers::Offset<BodyMotion> Finish() {
    auto o = flatbuffers::Offset<BodyMotion>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<BodyMotion> CreateBodyMotion(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    float durationTime_ms = 0.0f,
    flatbuffers::Offset<flatbuffers::String> radius_mm = 0,
    float speed = 0.0f) {
  BodyMotionBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_radius_mm(radius_mm);
  builder_.add_durationTime_ms(durationTime_ms);
  builder_.add_triggerTime_ms(triggerTime_ms);
  return builder_.Finish();
}

inline flatbuffers::Offset<BodyMotion> CreateBodyMotionDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float triggerTime_ms = 0.0f,
    float durationTime_ms = 0.0f,
    const char *radius_mm = nullptr,
    float speed = 0.0f) {
  return CreateBodyMotion(_fbb, triggerTime_ms, durationTime_ms, radius_mm ? _fbb.CreateString(radius_mm) : 0, speed);
}

struct Keyframes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LIFTHEIGHTKEYFRAME = 4,
    VT_PROCEDURALFACEKEYFRAME = 6,
    VT_HEADANGLEKEYFRAME = 8,
    VT_ROBOTAUDIOKEYFRAME = 10,
    VT_BACKPACKLIGHTSKEYFRAME = 12,
    VT_FACEANIMATIONKEYFRAME = 14,
    VT_EVENTKEYFRAME = 16,
    VT_BODYMOTIONKEYFRAME = 18
  };
  const flatbuffers::Vector<flatbuffers::Offset<LiftHeight>> *LiftHeightKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LiftHeight>> *>(VT_LIFTHEIGHTKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<ProceduralFace>> *ProceduralFaceKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ProceduralFace>> *>(VT_PROCEDURALFACEKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<HeadAngle>> *HeadAngleKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HeadAngle>> *>(VT_HEADANGLEKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<RobotAudio>> *RobotAudioKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RobotAudio>> *>(VT_ROBOTAUDIOKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<BackpackLights>> *BackpackLightsKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BackpackLights>> *>(VT_BACKPACKLIGHTSKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<FaceAnimation>> *FaceAnimationKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FaceAnimation>> *>(VT_FACEANIMATIONKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<Event>> *EventKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Event>> *>(VT_EVENTKEYFRAME); }
  const flatbuffers::Vector<flatbuffers::Offset<BodyMotion>> *BodyMotionKeyFrame() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BodyMotion>> *>(VT_BODYMOTIONKEYFRAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LIFTHEIGHTKEYFRAME) &&
           verifier.Verify(LiftHeightKeyFrame()) &&
           verifier.VerifyVectorOfTables(LiftHeightKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PROCEDURALFACEKEYFRAME) &&
           verifier.Verify(ProceduralFaceKeyFrame()) &&
           verifier.VerifyVectorOfTables(ProceduralFaceKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HEADANGLEKEYFRAME) &&
           verifier.Verify(HeadAngleKeyFrame()) &&
           verifier.VerifyVectorOfTables(HeadAngleKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ROBOTAUDIOKEYFRAME) &&
           verifier.Verify(RobotAudioKeyFrame()) &&
           verifier.VerifyVectorOfTables(RobotAudioKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACKPACKLIGHTSKEYFRAME) &&
           verifier.Verify(BackpackLightsKeyFrame()) &&
           verifier.VerifyVectorOfTables(BackpackLightsKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FACEANIMATIONKEYFRAME) &&
           verifier.Verify(FaceAnimationKeyFrame()) &&
           verifier.VerifyVectorOfTables(FaceAnimationKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENTKEYFRAME) &&
           verifier.Verify(EventKeyFrame()) &&
           verifier.VerifyVectorOfTables(EventKeyFrame()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BODYMOTIONKEYFRAME) &&
           verifier.Verify(BodyMotionKeyFrame()) &&
           verifier.VerifyVectorOfTables(BodyMotionKeyFrame()) &&
           verifier.EndTable();
  }
};

struct KeyframesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_LiftHeightKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiftHeight>>> LiftHeightKeyFrame) { fbb_.AddOffset(Keyframes::VT_LIFTHEIGHTKEYFRAME, LiftHeightKeyFrame); }
  void add_ProceduralFaceKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProceduralFace>>> ProceduralFaceKeyFrame) { fbb_.AddOffset(Keyframes::VT_PROCEDURALFACEKEYFRAME, ProceduralFaceKeyFrame); }
  void add_HeadAngleKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeadAngle>>> HeadAngleKeyFrame) { fbb_.AddOffset(Keyframes::VT_HEADANGLEKEYFRAME, HeadAngleKeyFrame); }
  void add_RobotAudioKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RobotAudio>>> RobotAudioKeyFrame) { fbb_.AddOffset(Keyframes::VT_ROBOTAUDIOKEYFRAME, RobotAudioKeyFrame); }
  void add_BackpackLightsKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BackpackLights>>> BackpackLightsKeyFrame) { fbb_.AddOffset(Keyframes::VT_BACKPACKLIGHTSKEYFRAME, BackpackLightsKeyFrame); }
  void add_FaceAnimationKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FaceAnimation>>> FaceAnimationKeyFrame) { fbb_.AddOffset(Keyframes::VT_FACEANIMATIONKEYFRAME, FaceAnimationKeyFrame); }
  void add_EventKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Event>>> EventKeyFrame) { fbb_.AddOffset(Keyframes::VT_EVENTKEYFRAME, EventKeyFrame); }
  void add_BodyMotionKeyFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BodyMotion>>> BodyMotionKeyFrame) { fbb_.AddOffset(Keyframes::VT_BODYMOTIONKEYFRAME, BodyMotionKeyFrame); }
  KeyframesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  KeyframesBuilder &operator=(const KeyframesBuilder &);
  flatbuffers::Offset<Keyframes> Finish() {
    auto o = flatbuffers::Offset<Keyframes>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<Keyframes> CreateKeyframes(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LiftHeight>>> LiftHeightKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProceduralFace>>> ProceduralFaceKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeadAngle>>> HeadAngleKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RobotAudio>>> RobotAudioKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BackpackLights>>> BackpackLightsKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FaceAnimation>>> FaceAnimationKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Event>>> EventKeyFrame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BodyMotion>>> BodyMotionKeyFrame = 0) {
  KeyframesBuilder builder_(_fbb);
  builder_.add_BodyMotionKeyFrame(BodyMotionKeyFrame);
  builder_.add_EventKeyFrame(EventKeyFrame);
  builder_.add_FaceAnimationKeyFrame(FaceAnimationKeyFrame);
  builder_.add_BackpackLightsKeyFrame(BackpackLightsKeyFrame);
  builder_.add_RobotAudioKeyFrame(RobotAudioKeyFrame);
  builder_.add_HeadAngleKeyFrame(HeadAngleKeyFrame);
  builder_.add_ProceduralFaceKeyFrame(ProceduralFaceKeyFrame);
  builder_.add_LiftHeightKeyFrame(LiftHeightKeyFrame);
  return builder_.Finish();
}

inline flatbuffers::Offset<Keyframes> CreateKeyframesDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<LiftHeight>> *LiftHeightKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<ProceduralFace>> *ProceduralFaceKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<HeadAngle>> *HeadAngleKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<RobotAudio>> *RobotAudioKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<BackpackLights>> *BackpackLightsKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<FaceAnimation>> *FaceAnimationKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<Event>> *EventKeyFrame = nullptr,
    const std::vector<flatbuffers::Offset<BodyMotion>> *BodyMotionKeyFrame = nullptr) {
  return CreateKeyframes(_fbb, LiftHeightKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<LiftHeight>>(*LiftHeightKeyFrame) : 0, ProceduralFaceKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<ProceduralFace>>(*ProceduralFaceKeyFrame) : 0, HeadAngleKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<HeadAngle>>(*HeadAngleKeyFrame) : 0, RobotAudioKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<RobotAudio>>(*RobotAudioKeyFrame) : 0, BackpackLightsKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<BackpackLights>>(*BackpackLightsKeyFrame) : 0, FaceAnimationKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<FaceAnimation>>(*FaceAnimationKeyFrame) : 0, EventKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<Event>>(*EventKeyFrame) : 0, BodyMotionKeyFrame ? _fbb.CreateVector<flatbuffers::Offset<BodyMotion>>(*BodyMotionKeyFrame) : 0);
}

struct AnimClip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_KEYFRAMES = 6
  };
  const flatbuffers::String *Name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const Keyframes *keyframes() const { return GetPointer<const Keyframes *>(VT_KEYFRAMES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(Name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_KEYFRAMES) &&
           verifier.VerifyTable(keyframes()) &&
           verifier.EndTable();
  }
};

struct AnimClipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Name(flatbuffers::Offset<flatbuffers::String> Name) { fbb_.AddOffset(AnimClip::VT_NAME, Name); }
  void add_keyframes(flatbuffers::Offset<Keyframes> keyframes) { fbb_.AddOffset(AnimClip::VT_KEYFRAMES, keyframes); }
  AnimClipBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimClipBuilder &operator=(const AnimClipBuilder &);
  flatbuffers::Offset<AnimClip> Finish() {
    auto o = flatbuffers::Offset<AnimClip>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimClip> CreateAnimClip(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Name = 0,
    flatbuffers::Offset<Keyframes> keyframes = 0) {
  AnimClipBuilder builder_(_fbb);
  builder_.add_keyframes(keyframes);
  builder_.add_Name(Name);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimClip> CreateAnimClipDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *Name = nullptr,
    flatbuffers::Offset<Keyframes> keyframes = 0) {
  return CreateAnimClip(_fbb, Name ? _fbb.CreateString(Name) : 0, keyframes);
}

struct AnimClips FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLIPS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnimClip>> *clips() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimClip>> *>(VT_CLIPS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CLIPS) &&
           verifier.Verify(clips()) &&
           verifier.VerifyVectorOfTables(clips()) &&
           verifier.EndTable();
  }
};

struct AnimClipsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clips(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimClip>>> clips) { fbb_.AddOffset(AnimClips::VT_CLIPS, clips); }
  AnimClipsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimClipsBuilder &operator=(const AnimClipsBuilder &);
  flatbuffers::Offset<AnimClips> Finish() {
    auto o = flatbuffers::Offset<AnimClips>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<AnimClips> CreateAnimClips(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimClip>>> clips = 0) {
  AnimClipsBuilder builder_(_fbb);
  builder_.add_clips(clips);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimClips> CreateAnimClipsDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AnimClip>> *clips = nullptr) {
  return CreateAnimClips(_fbb, clips ? _fbb.CreateVector<flatbuffers::Offset<AnimClip>>(*clips) : 0);
}

inline const CozmoAnim::AnimClips *GetAnimClips(const void *buf) { return flatbuffers::GetRoot<CozmoAnim::AnimClips>(buf); }

inline bool VerifyAnimClipsBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<CozmoAnim::AnimClips>(nullptr); }

inline void FinishAnimClipsBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<CozmoAnim::AnimClips> root) { fbb.Finish(root); }

}  // namespace CozmoAnim

#endif  // FLATBUFFERS_GENERATED_COZMOANIM_COZMOANIM_H_
