// Autogenerated C++ message buffer code.
// Source: UiMessageDefinitionsG2U.clad
// Full command line: ../../../lib/anki/cozmo-engine/tools/message-buffers/emitters/CPP_emitter.py -o UiMessageDefinitionsG2U.cpp -r ../../../include/anki/cozmo/game/comms/messaging/UiMessageDefinitionsG2U.def UiMessageDefinitionsG2U.clad

#ifndef __UIMESSAGEDEFINITIONSG2U_H__
#define __UIMESSAGEDEFINITIONSG2U_H__

#include <CLAD/SafeMessageBuffer.h>
#include <array>
#include <cassert>
#include <cstdint>
#include <string>
#include <vector>

namespace Anki {

namespace Cozmo {

// MESSAGE G2U_Ping
struct G2U_Ping
{
	uint32_t counter;
	
	/**** Constructors ****/
	G2U_Ping() = default;
	G2U_Ping(const G2U_Ping& other) = default;
	G2U_Ping(G2U_Ping& other) = default;
	G2U_Ping(G2U_Ping&& other) noexcept = default;
	G2U_Ping& operator=(const G2U_Ping& other) = default;
	G2U_Ping& operator=(G2U_Ping&& other) noexcept = default;
	
	explicit G2U_Ping(uint32_t counter)
	:counter(counter)
	{}

	explicit G2U_Ping(const uint8_t* buff, size_t len);
	explicit G2U_Ping(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_Ping& other) const;
	bool operator!=(const G2U_Ping& other) const;
};

// MESSAGE G2U_RobotAvailable
struct G2U_RobotAvailable
{
	uint32_t robotID;
	
	/**** Constructors ****/
	G2U_RobotAvailable() = default;
	G2U_RobotAvailable(const G2U_RobotAvailable& other) = default;
	G2U_RobotAvailable(G2U_RobotAvailable& other) = default;
	G2U_RobotAvailable(G2U_RobotAvailable&& other) noexcept = default;
	G2U_RobotAvailable& operator=(const G2U_RobotAvailable& other) = default;
	G2U_RobotAvailable& operator=(G2U_RobotAvailable&& other) noexcept = default;
	
	explicit G2U_RobotAvailable(uint32_t robotID)
	:robotID(robotID)
	{}

	explicit G2U_RobotAvailable(const uint8_t* buff, size_t len);
	explicit G2U_RobotAvailable(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_RobotAvailable& other) const;
	bool operator!=(const G2U_RobotAvailable& other) const;
};

// MESSAGE G2U_UiDeviceAvailable
struct G2U_UiDeviceAvailable
{
	uint32_t deviceID;
	
	/**** Constructors ****/
	G2U_UiDeviceAvailable() = default;
	G2U_UiDeviceAvailable(const G2U_UiDeviceAvailable& other) = default;
	G2U_UiDeviceAvailable(G2U_UiDeviceAvailable& other) = default;
	G2U_UiDeviceAvailable(G2U_UiDeviceAvailable&& other) noexcept = default;
	G2U_UiDeviceAvailable& operator=(const G2U_UiDeviceAvailable& other) = default;
	G2U_UiDeviceAvailable& operator=(G2U_UiDeviceAvailable&& other) noexcept = default;
	
	explicit G2U_UiDeviceAvailable(uint32_t deviceID)
	:deviceID(deviceID)
	{}

	explicit G2U_UiDeviceAvailable(const uint8_t* buff, size_t len);
	explicit G2U_UiDeviceAvailable(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_UiDeviceAvailable& other) const;
	bool operator!=(const G2U_UiDeviceAvailable& other) const;
};

// MESSAGE G2U_RobotConnected
struct G2U_RobotConnected
{
	uint32_t robotID;
	uint8_t successful;
	
	/**** Constructors ****/
	G2U_RobotConnected() = default;
	G2U_RobotConnected(const G2U_RobotConnected& other) = default;
	G2U_RobotConnected(G2U_RobotConnected& other) = default;
	G2U_RobotConnected(G2U_RobotConnected&& other) noexcept = default;
	G2U_RobotConnected& operator=(const G2U_RobotConnected& other) = default;
	G2U_RobotConnected& operator=(G2U_RobotConnected&& other) noexcept = default;
	
	explicit G2U_RobotConnected(uint32_t robotID
		,uint8_t successful)
	:robotID(robotID)
	,successful(successful)
	{}

	explicit G2U_RobotConnected(const uint8_t* buff, size_t len);
	explicit G2U_RobotConnected(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_RobotConnected& other) const;
	bool operator!=(const G2U_RobotConnected& other) const;
};

// MESSAGE G2U_RobotDisconnected
struct G2U_RobotDisconnected
{
	uint32_t robotID;
	float timeSinceLastMsg_sec;
	
	/**** Constructors ****/
	G2U_RobotDisconnected() = default;
	G2U_RobotDisconnected(const G2U_RobotDisconnected& other) = default;
	G2U_RobotDisconnected(G2U_RobotDisconnected& other) = default;
	G2U_RobotDisconnected(G2U_RobotDisconnected&& other) noexcept = default;
	G2U_RobotDisconnected& operator=(const G2U_RobotDisconnected& other) = default;
	G2U_RobotDisconnected& operator=(G2U_RobotDisconnected&& other) noexcept = default;
	
	explicit G2U_RobotDisconnected(uint32_t robotID
		,float timeSinceLastMsg_sec)
	:robotID(robotID)
	,timeSinceLastMsg_sec(timeSinceLastMsg_sec)
	{}

	explicit G2U_RobotDisconnected(const uint8_t* buff, size_t len);
	explicit G2U_RobotDisconnected(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_RobotDisconnected& other) const;
	bool operator!=(const G2U_RobotDisconnected& other) const;
};

// MESSAGE G2U_UiDeviceConnected
struct G2U_UiDeviceConnected
{
	uint32_t deviceID;
	uint8_t successful;
	
	/**** Constructors ****/
	G2U_UiDeviceConnected() = default;
	G2U_UiDeviceConnected(const G2U_UiDeviceConnected& other) = default;
	G2U_UiDeviceConnected(G2U_UiDeviceConnected& other) = default;
	G2U_UiDeviceConnected(G2U_UiDeviceConnected&& other) noexcept = default;
	G2U_UiDeviceConnected& operator=(const G2U_UiDeviceConnected& other) = default;
	G2U_UiDeviceConnected& operator=(G2U_UiDeviceConnected&& other) noexcept = default;
	
	explicit G2U_UiDeviceConnected(uint32_t deviceID
		,uint8_t successful)
	:deviceID(deviceID)
	,successful(successful)
	{}

	explicit G2U_UiDeviceConnected(const uint8_t* buff, size_t len);
	explicit G2U_UiDeviceConnected(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_UiDeviceConnected& other) const;
	bool operator!=(const G2U_UiDeviceConnected& other) const;
};

// MESSAGE G2U_RobotState
struct G2U_RobotState
{
	float pose_x;
	float pose_y;
	float pose_z;
	float poseAngle_rad;
	float pose_quaternion0;
	float pose_quaternion1;
	float pose_quaternion2;
	float pose_quaternion3;
	float leftWheelSpeed_mmps;
	float rightWheelSpeed_mmps;
	float headAngle_rad;
	float liftHeight_mm;
	float batteryVoltage;
	int32_t carryingObjectID;
	int32_t carryingObjectOnTopID;
	int32_t headTrackingObjectID;
	uint8_t status;
	uint8_t robotID;
	
	/**** Constructors ****/
	G2U_RobotState() = default;
	G2U_RobotState(const G2U_RobotState& other) = default;
	G2U_RobotState(G2U_RobotState& other) = default;
	G2U_RobotState(G2U_RobotState&& other) noexcept = default;
	G2U_RobotState& operator=(const G2U_RobotState& other) = default;
	G2U_RobotState& operator=(G2U_RobotState&& other) noexcept = default;
	
	explicit G2U_RobotState(float pose_x
		,float pose_y
		,float pose_z
		,float poseAngle_rad
		,float pose_quaternion0
		,float pose_quaternion1
		,float pose_quaternion2
		,float pose_quaternion3
		,float leftWheelSpeed_mmps
		,float rightWheelSpeed_mmps
		,float headAngle_rad
		,float liftHeight_mm
		,float batteryVoltage
		,int32_t carryingObjectID
		,int32_t carryingObjectOnTopID
		,int32_t headTrackingObjectID
		,uint8_t status
		,uint8_t robotID)
	:pose_x(pose_x)
	,pose_y(pose_y)
	,pose_z(pose_z)
	,poseAngle_rad(poseAngle_rad)
	,pose_quaternion0(pose_quaternion0)
	,pose_quaternion1(pose_quaternion1)
	,pose_quaternion2(pose_quaternion2)
	,pose_quaternion3(pose_quaternion3)
	,leftWheelSpeed_mmps(leftWheelSpeed_mmps)
	,rightWheelSpeed_mmps(rightWheelSpeed_mmps)
	,headAngle_rad(headAngle_rad)
	,liftHeight_mm(liftHeight_mm)
	,batteryVoltage(batteryVoltage)
	,carryingObjectID(carryingObjectID)
	,carryingObjectOnTopID(carryingObjectOnTopID)
	,headTrackingObjectID(headTrackingObjectID)
	,status(status)
	,robotID(robotID)
	{}

	explicit G2U_RobotState(const uint8_t* buff, size_t len);
	explicit G2U_RobotState(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_RobotState& other) const;
	bool operator!=(const G2U_RobotState& other) const;
};

// MESSAGE G2U_ImageChunk
struct G2U_ImageChunk
{
	uint32_t imageId;
	uint32_t frameTimeStamp;
	uint16_t nrows;
	uint16_t ncols;
	uint16_t chunkSize;
	uint8_t imageEncoding;
	uint8_t imageChunkCount;
	uint8_t chunkId;
	std::array<uint8_t, 1400> data;
	
	/**** Constructors ****/
	G2U_ImageChunk() = default;
	G2U_ImageChunk(const G2U_ImageChunk& other) = default;
	G2U_ImageChunk(G2U_ImageChunk& other) = default;
	G2U_ImageChunk(G2U_ImageChunk&& other) noexcept = default;
	G2U_ImageChunk& operator=(const G2U_ImageChunk& other) = default;
	G2U_ImageChunk& operator=(G2U_ImageChunk&& other) noexcept = default;
	
	explicit G2U_ImageChunk(uint32_t imageId
		,uint32_t frameTimeStamp
		,uint16_t nrows
		,uint16_t ncols
		,uint16_t chunkSize
		,uint8_t imageEncoding
		,uint8_t imageChunkCount
		,uint8_t chunkId
		,const std::array<uint8_t, 1400>& data)
	:imageId(imageId)
	,frameTimeStamp(frameTimeStamp)
	,nrows(nrows)
	,ncols(ncols)
	,chunkSize(chunkSize)
	,imageEncoding(imageEncoding)
	,imageChunkCount(imageChunkCount)
	,chunkId(chunkId)
	,data(data)
	{}

	explicit G2U_ImageChunk(const uint8_t* buff, size_t len);
	explicit G2U_ImageChunk(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_ImageChunk& other) const;
	bool operator!=(const G2U_ImageChunk& other) const;
};

// MESSAGE G2U_RobotObservedObject
struct G2U_RobotObservedObject
{
	uint32_t robotID;
	uint32_t objectFamily;
	uint32_t objectType;
	int32_t objectID;
	float img_topLeft_x;
	float img_topLeft_y;
	float img_width;
	float img_height;
	float world_x;
	float world_y;
	float world_z;
	float quaternion0;
	float quaternion1;
	float quaternion2;
	float quaternion3;
	uint8_t markersVisible;
	uint8_t isActive;
	
	/**** Constructors ****/
	G2U_RobotObservedObject() = default;
	G2U_RobotObservedObject(const G2U_RobotObservedObject& other) = default;
	G2U_RobotObservedObject(G2U_RobotObservedObject& other) = default;
	G2U_RobotObservedObject(G2U_RobotObservedObject&& other) noexcept = default;
	G2U_RobotObservedObject& operator=(const G2U_RobotObservedObject& other) = default;
	G2U_RobotObservedObject& operator=(G2U_RobotObservedObject&& other) noexcept = default;
	
	explicit G2U_RobotObservedObject(uint32_t robotID
		,uint32_t objectFamily
		,uint32_t objectType
		,int32_t objectID
		,float img_topLeft_x
		,float img_topLeft_y
		,float img_width
		,float img_height
		,float world_x
		,float world_y
		,float world_z
		,float quaternion0
		,float quaternion1
		,float quaternion2
		,float quaternion3
		,uint8_t markersVisible
		,uint8_t isActive)
	:robotID(robotID)
	,objectFamily(objectFamily)
	,objectType(objectType)
	,objectID(objectID)
	,img_topLeft_x(img_topLeft_x)
	,img_topLeft_y(img_topLeft_y)
	,img_width(img_width)
	,img_height(img_height)
	,world_x(world_x)
	,world_y(world_y)
	,world_z(world_z)
	,quaternion0(quaternion0)
	,quaternion1(quaternion1)
	,quaternion2(quaternion2)
	,quaternion3(quaternion3)
	,markersVisible(markersVisible)
	,isActive(isActive)
	{}

	explicit G2U_RobotObservedObject(const uint8_t* buff, size_t len);
	explicit G2U_RobotObservedObject(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_RobotObservedObject& other) const;
	bool operator!=(const G2U_RobotObservedObject& other) const;
};

// MESSAGE G2U_RobotObservedNothing
struct G2U_RobotObservedNothing
{
	uint32_t robotID;
	
	/**** Constructors ****/
	G2U_RobotObservedNothing() = default;
	G2U_RobotObservedNothing(const G2U_RobotObservedNothing& other) = default;
	G2U_RobotObservedNothing(G2U_RobotObservedNothing& other) = default;
	G2U_RobotObservedNothing(G2U_RobotObservedNothing&& other) noexcept = default;
	G2U_RobotObservedNothing& operator=(const G2U_RobotObservedNothing& other) = default;
	G2U_RobotObservedNothing& operator=(G2U_RobotObservedNothing&& other) noexcept = default;
	
	explicit G2U_RobotObservedNothing(uint32_t robotID)
	:robotID(robotID)
	{}

	explicit G2U_RobotObservedNothing(const uint8_t* buff, size_t len);
	explicit G2U_RobotObservedNothing(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_RobotObservedNothing& other) const;
	bool operator!=(const G2U_RobotObservedNothing& other) const;
};

// MESSAGE G2U_RobotDeletedObject
struct G2U_RobotDeletedObject
{
	uint32_t robotID;
	uint32_t objectID;
	
	/**** Constructors ****/
	G2U_RobotDeletedObject() = default;
	G2U_RobotDeletedObject(const G2U_RobotDeletedObject& other) = default;
	G2U_RobotDeletedObject(G2U_RobotDeletedObject& other) = default;
	G2U_RobotDeletedObject(G2U_RobotDeletedObject&& other) noexcept = default;
	G2U_RobotDeletedObject& operator=(const G2U_RobotDeletedObject& other) = default;
	G2U_RobotDeletedObject& operator=(G2U_RobotDeletedObject&& other) noexcept = default;
	
	explicit G2U_RobotDeletedObject(uint32_t robotID
		,uint32_t objectID)
	:robotID(robotID)
	,objectID(objectID)
	{}

	explicit G2U_RobotDeletedObject(const uint8_t* buff, size_t len);
	explicit G2U_RobotDeletedObject(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_RobotDeletedObject& other) const;
	bool operator!=(const G2U_RobotDeletedObject& other) const;
};

// MESSAGE G2U_DeviceDetectedVisionMarker
struct G2U_DeviceDetectedVisionMarker
{
	uint32_t markerType;
	float x_upperLeft;
	float y_upperLeft;
	float x_lowerLeft;
	float y_lowerLeft;
	float x_upperRight;
	float y_upperRight;
	float x_lowerRight;
	float y_lowerRight;
	
	/**** Constructors ****/
	G2U_DeviceDetectedVisionMarker() = default;
	G2U_DeviceDetectedVisionMarker(const G2U_DeviceDetectedVisionMarker& other) = default;
	G2U_DeviceDetectedVisionMarker(G2U_DeviceDetectedVisionMarker& other) = default;
	G2U_DeviceDetectedVisionMarker(G2U_DeviceDetectedVisionMarker&& other) noexcept = default;
	G2U_DeviceDetectedVisionMarker& operator=(const G2U_DeviceDetectedVisionMarker& other) = default;
	G2U_DeviceDetectedVisionMarker& operator=(G2U_DeviceDetectedVisionMarker&& other) noexcept = default;
	
	explicit G2U_DeviceDetectedVisionMarker(uint32_t markerType
		,float x_upperLeft
		,float y_upperLeft
		,float x_lowerLeft
		,float y_lowerLeft
		,float x_upperRight
		,float y_upperRight
		,float x_lowerRight
		,float y_lowerRight)
	:markerType(markerType)
	,x_upperLeft(x_upperLeft)
	,y_upperLeft(y_upperLeft)
	,x_lowerLeft(x_lowerLeft)
	,y_lowerLeft(y_lowerLeft)
	,x_upperRight(x_upperRight)
	,y_upperRight(y_upperRight)
	,x_lowerRight(x_lowerRight)
	,y_lowerRight(y_lowerRight)
	{}

	explicit G2U_DeviceDetectedVisionMarker(const uint8_t* buff, size_t len);
	explicit G2U_DeviceDetectedVisionMarker(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_DeviceDetectedVisionMarker& other) const;
	bool operator!=(const G2U_DeviceDetectedVisionMarker& other) const;
};

// MESSAGE G2U_RobotCompletedAction
struct G2U_RobotCompletedAction
{
	uint32_t robotID;
	int32_t actionType;
	uint8_t success;
	
	/**** Constructors ****/
	G2U_RobotCompletedAction() = default;
	G2U_RobotCompletedAction(const G2U_RobotCompletedAction& other) = default;
	G2U_RobotCompletedAction(G2U_RobotCompletedAction& other) = default;
	G2U_RobotCompletedAction(G2U_RobotCompletedAction&& other) noexcept = default;
	G2U_RobotCompletedAction& operator=(const G2U_RobotCompletedAction& other) = default;
	G2U_RobotCompletedAction& operator=(G2U_RobotCompletedAction&& other) noexcept = default;
	
	explicit G2U_RobotCompletedAction(uint32_t robotID
		,int32_t actionType
		,uint8_t success)
	:robotID(robotID)
	,actionType(actionType)
	,success(success)
	{}

	explicit G2U_RobotCompletedAction(const uint8_t* buff, size_t len);
	explicit G2U_RobotCompletedAction(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_RobotCompletedAction& other) const;
	bool operator!=(const G2U_RobotCompletedAction& other) const;
};

// MESSAGE G2U_PlaySound
struct G2U_PlaySound
{
	std::string soundFilename;
	uint8_t numLoops;
	uint8_t volume;
	
	/**** Constructors ****/
	G2U_PlaySound() = default;
	G2U_PlaySound(const G2U_PlaySound& other) = default;
	G2U_PlaySound(G2U_PlaySound& other) = default;
	G2U_PlaySound(G2U_PlaySound&& other) noexcept = default;
	G2U_PlaySound& operator=(const G2U_PlaySound& other) = default;
	G2U_PlaySound& operator=(G2U_PlaySound&& other) noexcept = default;
	
	explicit G2U_PlaySound(const std::string& soundFilename
		,uint8_t numLoops
		,uint8_t volume)
	:soundFilename(soundFilename)
	,numLoops(numLoops)
	,volume(volume)
	{}

	explicit G2U_PlaySound(const uint8_t* buff, size_t len);
	explicit G2U_PlaySound(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_PlaySound& other) const;
	bool operator!=(const G2U_PlaySound& other) const;
};

// MESSAGE G2U_StopSound
struct G2U_StopSound
{
	
	/**** Constructors ****/
	G2U_StopSound() = default;
	G2U_StopSound(const G2U_StopSound& other) = default;
	G2U_StopSound(G2U_StopSound& other) = default;
	G2U_StopSound(G2U_StopSound&& other) noexcept = default;
	G2U_StopSound& operator=(const G2U_StopSound& other) = default;
	G2U_StopSound& operator=(G2U_StopSound&& other) noexcept = default;
		explicit G2U_StopSound(const uint8_t* buff, size_t len);
	explicit G2U_StopSound(const CLAD::SafeMessageBuffer& buffer);
	
	/**** Pack ****/
	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	/**** Unpack ****/
	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Size() const;

	bool operator==(const G2U_StopSound& other) const;
	bool operator!=(const G2U_StopSound& other) const;
};

// UNION G2U_Message
class G2U_Message
{
public:
	/**** Constructors ****/
	G2U_Message() :_type(Type::INVALID) { }
	explicit G2U_Message(const CLAD::SafeMessageBuffer& buff);
	explicit G2U_Message(const uint8_t* buffer, size_t length);

	~G2U_Message() { ClearCurrent(); }
	enum class Type : uint8_t {
		Ping,	// 0
		RobotAvailable,	// 1
		UiDeviceAvailable,	// 2
		RobotConnected,	// 3
		RobotDisconnected,	// 4
		UiDeviceConnected,	// 5
		RobotState,	// 6
		ImageChunk,	// 7
		RobotObservedObject,	// 8
		RobotObservedNothing,	// 9
		RobotDeletedObject,	// 10
		DeviceDetectedVisionMarker,	// 11
		RobotCompletedAction,	// 12
		PlaySound,	// 13
		StopSound,	// 14
		INVALID
	};
	static const char* GetTypeName(Type type) {
		switch (type) {
		case Type::Ping:
			return "Ping";
		case Type::RobotAvailable:
			return "RobotAvailable";
		case Type::UiDeviceAvailable:
			return "UiDeviceAvailable";
		case Type::RobotConnected:
			return "RobotConnected";
		case Type::RobotDisconnected:
			return "RobotDisconnected";
		case Type::UiDeviceConnected:
			return "UiDeviceConnected";
		case Type::RobotState:
			return "RobotState";
		case Type::ImageChunk:
			return "ImageChunk";
		case Type::RobotObservedObject:
			return "RobotObservedObject";
		case Type::RobotObservedNothing:
			return "RobotObservedNothing";
		case Type::RobotDeletedObject:
			return "RobotDeletedObject";
		case Type::DeviceDetectedVisionMarker:
			return "DeviceDetectedVisionMarker";
		case Type::RobotCompletedAction:
			return "RobotCompletedAction";
		case Type::PlaySound:
			return "PlaySound";
		case Type::StopSound:
			return "StopSound";
		default:
			return "INVALID";
		}
	}
	Type GetType() const { return _type; }

	/** Ping **/
	const Anki::Cozmo::G2U_Ping& Get_Ping() const;
	void Set_Ping(const Anki::Cozmo::G2U_Ping& new_Ping);
	void Set_Ping(Anki::Cozmo::G2U_Ping&& new_Ping);

	/** RobotAvailable **/
	const Anki::Cozmo::G2U_RobotAvailable& Get_RobotAvailable() const;
	void Set_RobotAvailable(const Anki::Cozmo::G2U_RobotAvailable& new_RobotAvailable);
	void Set_RobotAvailable(Anki::Cozmo::G2U_RobotAvailable&& new_RobotAvailable);

	/** UiDeviceAvailable **/
	const Anki::Cozmo::G2U_UiDeviceAvailable& Get_UiDeviceAvailable() const;
	void Set_UiDeviceAvailable(const Anki::Cozmo::G2U_UiDeviceAvailable& new_UiDeviceAvailable);
	void Set_UiDeviceAvailable(Anki::Cozmo::G2U_UiDeviceAvailable&& new_UiDeviceAvailable);

	/** RobotConnected **/
	const Anki::Cozmo::G2U_RobotConnected& Get_RobotConnected() const;
	void Set_RobotConnected(const Anki::Cozmo::G2U_RobotConnected& new_RobotConnected);
	void Set_RobotConnected(Anki::Cozmo::G2U_RobotConnected&& new_RobotConnected);

	/** RobotDisconnected **/
	const Anki::Cozmo::G2U_RobotDisconnected& Get_RobotDisconnected() const;
	void Set_RobotDisconnected(const Anki::Cozmo::G2U_RobotDisconnected& new_RobotDisconnected);
	void Set_RobotDisconnected(Anki::Cozmo::G2U_RobotDisconnected&& new_RobotDisconnected);

	/** UiDeviceConnected **/
	const Anki::Cozmo::G2U_UiDeviceConnected& Get_UiDeviceConnected() const;
	void Set_UiDeviceConnected(const Anki::Cozmo::G2U_UiDeviceConnected& new_UiDeviceConnected);
	void Set_UiDeviceConnected(Anki::Cozmo::G2U_UiDeviceConnected&& new_UiDeviceConnected);

	/** RobotState **/
	const Anki::Cozmo::G2U_RobotState& Get_RobotState() const;
	void Set_RobotState(const Anki::Cozmo::G2U_RobotState& new_RobotState);
	void Set_RobotState(Anki::Cozmo::G2U_RobotState&& new_RobotState);

	/** ImageChunk **/
	const Anki::Cozmo::G2U_ImageChunk& Get_ImageChunk() const;
	void Set_ImageChunk(const Anki::Cozmo::G2U_ImageChunk& new_ImageChunk);
	void Set_ImageChunk(Anki::Cozmo::G2U_ImageChunk&& new_ImageChunk);

	/** RobotObservedObject **/
	const Anki::Cozmo::G2U_RobotObservedObject& Get_RobotObservedObject() const;
	void Set_RobotObservedObject(const Anki::Cozmo::G2U_RobotObservedObject& new_RobotObservedObject);
	void Set_RobotObservedObject(Anki::Cozmo::G2U_RobotObservedObject&& new_RobotObservedObject);

	/** RobotObservedNothing **/
	const Anki::Cozmo::G2U_RobotObservedNothing& Get_RobotObservedNothing() const;
	void Set_RobotObservedNothing(const Anki::Cozmo::G2U_RobotObservedNothing& new_RobotObservedNothing);
	void Set_RobotObservedNothing(Anki::Cozmo::G2U_RobotObservedNothing&& new_RobotObservedNothing);

	/** RobotDeletedObject **/
	const Anki::Cozmo::G2U_RobotDeletedObject& Get_RobotDeletedObject() const;
	void Set_RobotDeletedObject(const Anki::Cozmo::G2U_RobotDeletedObject& new_RobotDeletedObject);
	void Set_RobotDeletedObject(Anki::Cozmo::G2U_RobotDeletedObject&& new_RobotDeletedObject);

	/** DeviceDetectedVisionMarker **/
	const Anki::Cozmo::G2U_DeviceDetectedVisionMarker& Get_DeviceDetectedVisionMarker() const;
	void Set_DeviceDetectedVisionMarker(const Anki::Cozmo::G2U_DeviceDetectedVisionMarker& new_DeviceDetectedVisionMarker);
	void Set_DeviceDetectedVisionMarker(Anki::Cozmo::G2U_DeviceDetectedVisionMarker&& new_DeviceDetectedVisionMarker);

	/** RobotCompletedAction **/
	const Anki::Cozmo::G2U_RobotCompletedAction& Get_RobotCompletedAction() const;
	void Set_RobotCompletedAction(const Anki::Cozmo::G2U_RobotCompletedAction& new_RobotCompletedAction);
	void Set_RobotCompletedAction(Anki::Cozmo::G2U_RobotCompletedAction&& new_RobotCompletedAction);

	/** PlaySound **/
	const Anki::Cozmo::G2U_PlaySound& Get_PlaySound() const;
	void Set_PlaySound(const Anki::Cozmo::G2U_PlaySound& new_PlaySound);
	void Set_PlaySound(Anki::Cozmo::G2U_PlaySound&& new_PlaySound);

	/** StopSound **/
	const Anki::Cozmo::G2U_StopSound& Get_StopSound() const;
	void Set_StopSound(const Anki::Cozmo::G2U_StopSound& new_StopSound);
	void Set_StopSound(Anki::Cozmo::G2U_StopSound&& new_StopSound);


	size_t Unpack(const uint8_t* buff, const size_t len);
	size_t Unpack(const CLAD::SafeMessageBuffer& buffer);

	size_t Pack(uint8_t* buff, size_t len) const;
	size_t Pack(CLAD::SafeMessageBuffer& buffer) const;

	size_t Size() const;
private:
	void ClearCurrent();
	Type _type;

	union {
		Anki::Cozmo::G2U_Ping _Ping;
		Anki::Cozmo::G2U_RobotAvailable _RobotAvailable;
		Anki::Cozmo::G2U_UiDeviceAvailable _UiDeviceAvailable;
		Anki::Cozmo::G2U_RobotConnected _RobotConnected;
		Anki::Cozmo::G2U_RobotDisconnected _RobotDisconnected;
		Anki::Cozmo::G2U_UiDeviceConnected _UiDeviceConnected;
		Anki::Cozmo::G2U_RobotState _RobotState;
		Anki::Cozmo::G2U_ImageChunk _ImageChunk;
		Anki::Cozmo::G2U_RobotObservedObject _RobotObservedObject;
		Anki::Cozmo::G2U_RobotObservedNothing _RobotObservedNothing;
		Anki::Cozmo::G2U_RobotDeletedObject _RobotDeletedObject;
		Anki::Cozmo::G2U_DeviceDetectedVisionMarker _DeviceDetectedVisionMarker;
		Anki::Cozmo::G2U_RobotCompletedAction _RobotCompletedAction;
		Anki::Cozmo::G2U_PlaySound _PlaySound;
		Anki::Cozmo::G2U_StopSound _StopSound;
	};
};

} // namespace Cozmo

} // namespace Anki

template<>
struct std::hash<Anki::Cozmo::G2U_Message::Type>
{
	size_t operator()(Anki::Cozmo::G2U_Message::Type t) const
	{
		return static_cast<std::underlying_type<Anki::Cozmo::G2U_Message::Type>::type>(t);
	}
};

#endif // __UIMESSAGEDEFINITIONSG2U_H__
