/*









This file was automatically generated by the python script generateFixedLengthList_h.py. Rather than editing this file, edit that script, then run "python generateFixedLengthList_h.py".









*/

#ifndef _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_H_
#define _ANKICORETECHEMBEDDED_COMMON_FIXED_LENGTH_LIST_H_

#include "anki/embeddedCommon/config.h"

namespace Anki
{
  namespace Embedded
  {
    class FixedLengthList_Point_s16 : public Array_Point_s16
    {
    public:
      FixedLengthList_Point_s16();

      // Constructor for a FixedLengthList_Point_s16, pointing to user-allocated data.
      FixedLengthList_Point_s16(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns=false);

      // Constructor for a FixedLengthList_Point_s16, pointing to user-allocated MemoryStack
      FixedLengthList_Point_s16(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns=false);

      bool IsValid() const;

      Result PushBack(const Point_s16 &value);

      // Will act as a normal pop, except when the list is empty. Then subsequent
      // calls will keep returning the first value in the list.
      Point_s16 PopBack();

      // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
      void Clear();

      // Does this ever need to be declared explicitly?
      //FixedLengthList_Point_s16& operator= (const FixedLengthList_Point_s16 & rightHandSide);

      // Pointer to the data, at a given location
      inline Point_s16* Pointer(s32 index);

      // Pointer to the data, at a given location
      inline const Point_s16* Pointer(s32 index) const;

      s32 get_maximumSize() const;

      s32 get_size() const;

      // Attempt to set the size to newSize. Returns the value that was actually set.
      s32 set_size(s32 newSize);

    protected:
      s32 capacityUsed;
    }; // class FixedLengthList_Point_s16

    inline Point_s16* FixedLengthList_Point_s16::Pointer(s32 index)
    {
      return Array_Point_s16::Pointer(0, index);
    }

    // Pointer to the data, at a given location
    inline const Point_s16* FixedLengthList_Point_s16::Pointer(s32 index) const
    {
      return Array_Point_s16::Pointer(0, index);
    }

    FixedLengthList_Point_s16 AllocateFixedLengthListFromHeap_Point_s16(s32 maximumSize, bool useBoundaryFillPatterns=false);


    class FixedLengthList_Point_f32 : public Array_Point_f32
    {
    public:
      FixedLengthList_Point_f32();

      // Constructor for a FixedLengthList_Point_f32, pointing to user-allocated data.
      FixedLengthList_Point_f32(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns=false);

      // Constructor for a FixedLengthList_Point_f32, pointing to user-allocated MemoryStack
      FixedLengthList_Point_f32(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns=false);

      bool IsValid() const;

      Result PushBack(const Point_f32 &value);

      // Will act as a normal pop, except when the list is empty. Then subsequent
      // calls will keep returning the first value in the list.
      Point_f32 PopBack();

      // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
      void Clear();

      // Does this ever need to be declared explicitly?
      //FixedLengthList_Point_f32& operator= (const FixedLengthList_Point_f32 & rightHandSide);

      // Pointer to the data, at a given location
      inline Point_f32* Pointer(s32 index);

      // Pointer to the data, at a given location
      inline const Point_f32* Pointer(s32 index) const;

      s32 get_maximumSize() const;

      s32 get_size() const;

      // Attempt to set the size to newSize. Returns the value that was actually set.
      s32 set_size(s32 newSize);

    protected:
      s32 capacityUsed;
    }; // class FixedLengthList_Point_f32

    inline Point_f32* FixedLengthList_Point_f32::Pointer(s32 index)
    {
      return Array_Point_f32::Pointer(0, index);
    }

    // Pointer to the data, at a given location
    inline const Point_f32* FixedLengthList_Point_f32::Pointer(s32 index) const
    {
      return Array_Point_f32::Pointer(0, index);
    }

    FixedLengthList_Point_f32 AllocateFixedLengthListFromHeap_Point_f32(s32 maximumSize, bool useBoundaryFillPatterns=false);


    class FixedLengthList_Point_f64 : public Array_Point_f64
    {
    public:
      FixedLengthList_Point_f64();

      // Constructor for a FixedLengthList_Point_f64, pointing to user-allocated data.
      FixedLengthList_Point_f64(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns=false);

      // Constructor for a FixedLengthList_Point_f64, pointing to user-allocated MemoryStack
      FixedLengthList_Point_f64(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns=false);

      bool IsValid() const;

      Result PushBack(const Point_f64 &value);

      // Will act as a normal pop, except when the list is empty. Then subsequent
      // calls will keep returning the first value in the list.
      Point_f64 PopBack();

      // Sets the size to zero, but does not modify any data. Equivalent to set_size(0)
      void Clear();

      // Does this ever need to be declared explicitly?
      //FixedLengthList_Point_f64& operator= (const FixedLengthList_Point_f64 & rightHandSide);

      // Pointer to the data, at a given location
      inline Point_f64* Pointer(s32 index);

      // Pointer to the data, at a given location
      inline const Point_f64* Pointer(s32 index) const;

      s32 get_maximumSize() const;

      s32 get_size() const;

      // Attempt to set the size to newSize. Returns the value that was actually set.
      s32 set_size(s32 newSize);

    protected:
      s32 capacityUsed;
    }; // class FixedLengthList_Point_f64

    inline Point_f64* FixedLengthList_Point_f64::Pointer(s32 index)
    {
      return Array_Point_f64::Pointer(0, index);
    }

    // Pointer to the data, at a given location
    inline const Point_f64* FixedLengthList_Point_f64::Pointer(s32 index) const
    {
      return Array_Point_f64::Pointer(0, index);
    }

    FixedLengthList_Point_f64 AllocateFixedLengthListFromHeap_Point_f64(s32 maximumSize, bool useBoundaryFillPatterns=false);


    } // namespace Embedded
} //namespace Anki

#endif // _ANKICORETECHEMBEDDED_COMMON_FIXEDLENGTHLIST_H_
