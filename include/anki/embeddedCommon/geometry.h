/*

This file was automatically generated by the python script generatePoint_h.py. Rather than editing this file, edit that script, then run "python generatePoint_h.py".

*/

#ifndef _ANKICORETECHEMBEDDED_COMMON_POINT_H_
#define _ANKICORETECHEMBEDDED_COMMON_POINT_H_

#include "anki/embeddedCommon/config.h"

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
#include "opencv2/opencv.hpp"
#endif

namespace Anki
{
  namespace Embedded
  {
#pragma mark --- Point Class Definition ---
    // 2D Point Class:
    template<typename Type> class Point
    {
    public:
      Point();

      Point(const Type x, const Type y);

      Point(const Point<Type>& pt);

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      Point(const cv::Point_<Type>& pt);

      cv::Point_<Type> get_CvPoint_();
#endif

      void Print() const;

      bool operator== (const Point<Type> &point2) const;

      Point<Type> operator+ (const Point<Type> &point2) const;

      Point<Type> operator- (const Point<Type> &point2) const;

      void operator*= (const Type value);

      Type x, y;
    }; // class Point<Type>

#pragma mark --- Rectangle Class Definition ---

    template<typename Type> class Rectangle
    {
    public:
      Rectangle();

      Rectangle(const Type left, const Type right, const Type top, const Type bottom);

      Rectangle(const Rectangle<Type>& rect);

      void Print() const;

      bool operator== (const Rectangle<Type> &point2) const;

      Rectangle<Type> operator+ (const Rectangle<Type> &rect2) const;

      Rectangle<Type> operator- (const Rectangle<Type> &rect2) const;

      Type get_width() const;

      Type get_height() const;

      Type left;
      Type right;
      Type top;
      Type bottom;
    }; // class Point<Type>

#pragma mark --- Point Implementations ---

    template<typename Type> Point<Type>::Point()
      : x(static_cast<Type>(0)), y(static_cast<Type>(0))
    {
    }

    template<typename Type> Point<Type>::Point(const Type x, const Type y)
      : x(x), y(y)
    {
    }

    template<typename Type> Point<Type>::Point(const Point<Type>& pt)
      : x(pt.x), y(pt.y)
    {
    }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    template<typename Type> Point<Type>::Point(const cv::Point_<Type>& pt)
      : x(pt.x), y(pt.y)
    {
    }
#endif

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    template<typename Type> cv::Point_<Type> Point<Type>::get_CvPoint_()
    {
      return cv::Point_<Type>(x,y);
    }
#endif

    template<typename Type> void Point<Type>::Print() const
    {
      printf("(%d,%d) ", this->x, this->y);
    }

    template<typename Type> bool Point<Type>::operator== (const Point<Type> &point2) const
    {
      if(this->x == point2.x && this->y == point2.y)
        return true;

      return false;
    }

    template<typename Type> Point<Type> Point<Type>::operator+ (const Point<Type> &point2) const
    {
      return Point<Type>(this->x+point2.x, this->y+point2.y);
    }

    template<typename Type> Point<Type> Point<Type>::operator- (const Point<Type> &point2) const
    {
      return Point<Type>(this->x-point2.x, this->y-point2.y);
    }

    template<typename Type> void Point<Type>::operator*=(const Type value)
    {
      this->x *= value;
      this->y *= value;
    }

#pragma mark --- Point Specializations ---
    template<> void Point<f32>::Print() const;
    template<> void Point<f64>::Print() const;

#pragma mark --- Rectangle Implementations ---

    template<typename Type> Rectangle<Type>::Rectangle()
      : left(static_cast<Type>(0)), right(static_cast<Type>(0)), top(static_cast<Type>(0)), bottom(static_cast<Type>(0))
    {
    }

    template<typename Type> Rectangle<Type>::Rectangle(const Type left, const Type right, const Type top, const Type bottom)
      : left(left), right(right), top(top), bottom(bottom)
    {
    }

    template<typename Type> Rectangle<Type>::Rectangle(const Rectangle<Type>& rect)
      : left(rect.left), right(rect.right), top(rect.top), bottom(rect.bottom)
    {
    }

    template<typename Type> void Rectangle<Type>::Print() const
    {
      printf("(%d,%d)->(%d,%d) ", this->left, this->top, this->right, this->bottom);
    }

    template<typename Type> bool Rectangle<Type>::operator== (const Rectangle<Type> &rectangle2) const
    {
      if(this->left == rectangle2.left && this->top == rectangle2.top && this->right == rectangle2.right && this->bottom == rectangle2.bottom)
        return true;

      return false;
    }

    template<typename Type> Rectangle<Type> Rectangle<Type>::operator+ (const Rectangle<Type> &rectangle2) const
    {
      return Rectangle<Type>(this->top+rectangle2.top, this->bottom+rectangle2.bottom, this->left+rectangle2.left, this->right+rectangle2.right);
    }

    template<typename Type> Rectangle<Type> Rectangle<Type>::operator- (const Rectangle<Type> &rectangle2) const
    {
      return Rectangle<Type>(this->top-rectangle2.top, this->bottom-rectangle2.bottom, this->left-rectangle2.left, this->right-rectangle2.right);
    }

    template<typename Type> Type Rectangle<Type>::get_width() const
    {
      return right - left;
    }

    template<typename Type> Type Rectangle<Type>::get_height() const
    {
      return bottom - top;
    }

#pragma mark --- Rectangle Specializations ---
    template<> void Rectangle<f32>::Print() const;
    template<> void Rectangle<f64>::Print() const;
  } // namespace Embedded
} // namespace Anki

#endif // _ANKICORETECHEMBEDDED_COMMON_POINT_H_
