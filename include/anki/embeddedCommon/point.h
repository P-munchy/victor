/*

This file was automatically generated by the python script generatePoint_h.py. Rather than editing this file, edit that script, then run "python generatePoint_h.py".

*/

#ifndef _ANKICORETECHEMBEDDED_COMMON_POINT_H_
#define _ANKICORETECHEMBEDDED_COMMON_POINT_H_

#include "anki/embeddedCommon/config.h"

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
#include "opencv2/opencv.hpp"
#endif

namespace Anki
{
  namespace Embedded
  {
#pragma mark --- Point Class Definition ---
    // 2D Point Class:
    template<typename Type> class Point
    {
    public:
      Point();

      Point(const Type x, const Type y);

      Point(const Point<Type>& pt);

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      Point(const cv::Point_<Type>& pt);

      cv::Point_<Type> get_CvPoint_();
#endif

      void Print() const;

      bool operator== (const Point<Type> &point2) const;

      Point<Type> operator+ (const Point<Type> &point2) const;

      Point<Type> operator- (const Point<Type> &point2) const;

      void operator*= (const Type value);

      Type x, y;
    }; // class Point<Type>

#pragma mark --- Point Implementations ---

    template<typename Type> Point<Type>::Point()
      : x(static_cast<Type>(0)), y(static_cast<Type>(0))
    {
    }

    template<typename Type> Point<Type>::Point(const Type x, const Type y)
      : x(x), y(y)
    {
    }

    template<typename Type> Point<Type>::Point(const Point<Type>& pt)
      : x(pt.x), y(pt.y)
    {
    }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    template<typename Type> Point<Type>::Point(const cv::Point_<Type>& pt)
      : x(pt.x), y(pt.y)
    {
    }
#endif

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
    template<typename Type> cv::Point_<Type> Point<Type>::get_CvPoint_()
    {
      return cv::Point_<Type>(x,y);
    }
#endif

    template<typename Type> void Point<Type>::Print() const
    {
      printf("(%d,%d) ", this->x, this->y);
    }

    template<typename Type> bool Point<Type>::operator== (const Point<Type> &point2) const
    {
      if(this->x == point2.x && this->y == point2.y)
        return true;

      return false;
    }

    template<typename Type> Point<Type> Point<Type>::operator+ (const Point<Type> &point2) const
    {
      return Point<Type>(this->x+point2.x, this->y+point2.y);
    }

    template<typename Type> Point<Type> Point<Type>::operator- (const Point<Type> &point2) const
    {
      return Point<Type>(this->x-point2.x, this->y-point2.y);
    }

    template<typename Type> void Point<Type>::operator*=(const Type value)
    {
      this->x *= value;
      this->y *= value;
    }

#pragma mark --- Point Specializations ---
    template<> void Point<f32>::Print() const;
    template<> void Point<f64>::Print() const;
  } // namespace Embedded
} // namespace Anki

#endif // _ANKICORETECHEMBEDDED_COMMON_POINT_H_
