/*









This file was automatically generated by the python script generateArray_vision_h.py. Rather than editing this file, edit that script, then run "python generateArray_vision_h.py".









*/

#ifndef _ANKICORETECHEMBEDDED_VISION_ARRAY2D_VISION_H_
#define _ANKICORETECHEMBEDDED_VISION_ARRAY2D_VISION_H_

#include "anki/embeddedVision/config.h"
#include "anki/embeddedCommon.h"
#include "anki/embeddedVision/dataStructures_vision.h"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
#include "opencv2/opencv.hpp"
#endif

namespace Anki
{
  namespace Embedded
  {
    class Array_Component1d
    {
    public:
      static s32 ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns);

      static s32 ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns);

      Array_Component1d();

      // Constructor for a Array_Component1d, pointing to user-allocated data. If the pointer to *data is not
      // aligned to MEMORY_ALIGNMENT, this Array_Component1d will start at the next aligned location.
      // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
      // it may make it hard to convert from OpenCV to Array_Component1d, though the reverse is trivial.
      Array_Component1d(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const bool useBoundaryFillPatterns=false);

      // Constructor for a Array_Component1d, pointing to user-allocated MemoryStack
      Array_Component1d(const s32 numRows, const s32 numCols, MemoryStack &memory, const bool useBoundaryFillPatterns=false);

      // Pointer to the data, at a given (y,x) location
      const inline Component1d* Pointer(const s32 index0, const s32 index1) const
      {
        assert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1] &&
          this->rawDataPointer != NULL && this->data != NULL);

        return reinterpret_cast<const Component1d*>( reinterpret_cast<const char*>(this->data) +
          index1*sizeof(Component1d) + index0*stride );
      }

      // Pointer to the data, at a given (y,x) location
      inline Component1d* Pointer(const s32 index0, const s32 index1)
      {
        assert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1] &&
          this->rawDataPointer != NULL && this->data != NULL);

        return reinterpret_cast<Component1d*>( reinterpret_cast<char*>(this->data) +
          index1*sizeof(Component1d) + index0*stride );
      }

      // Pointer to the data, at a given (y,x) location
      const inline Component1d* Pointer(const Point_s16 &point) const
      {
        return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
      }

      // Pointer to the data, at a given (y,x) location
      inline Component1d* Pointer(const Point_s16 &point)
      {
        return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      // Returns a templated cv::Mat_ that shares the same buffer with this Array_Component1d. No data is copied.
      cv::Mat_<Component1d>& get_CvMat_();
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

      // If this array or array2 are different sizes or uninitialized, then return false.
      bool IsEqualSize(const Array_Component1d &array2) const;

      // Print out the contents of this Array_Component1d
      void Print(const char * const variableName = "Array_Component1d") const;

      // If the Array_Component1d was constructed with the useBoundaryFillPatterns=true, then
      // return if any memory was written out of bounds (via fill patterns at the
      // beginning and end).  If the Array_Component1d was not constructed with the
      // useBoundaryFillPatterns=true, this method always returns true
      bool IsValid() const;

      // Set every element in the Array_Component1d to this value
      // Returns the number of values set
      s32 Set(const Component1d value);

      s32 get_size(s32 dimension) const;

      s32 get_stride() const;

      void* get_rawDataPointer();

      const void* get_rawDataPointer() const;

    protected:
      // Bit-inverse of MemoryStack patterns. The pattern will be put twice at
      // the beginning and end of each line.
      static const u32 FILL_PATTERN_START = 0X5432EF76;
      static const u32 FILL_PATTERN_END = 0X7610FE76;

      static const s32 HEADER_LENGTH = 8;
      static const s32 FOOTER_LENGTH = 8;

      s32 size[2];
      s32 stride;
      bool useBoundaryFillPatterns;

      Component1d * data;

      // To enforce alignment, rawDataPointer may be slightly before Component1d * data.
      // If the inputted data buffer was from malloc, this is the pointer that
      // should be used to free.
      void * rawDataPointer;

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cv::Mat_<Component1d> cvMatMirror;
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

      void Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns);

      void InvalidateArray(); // Set all the buffers and sizes to zero, to signal an invalid array

    private:
      //Array_Component1d & operator= (const Array_Component1d & rightHandSide); // In the future, assignment may not be allowed
    }; // class Array_Component1d

    // Factory method to create an Array_Component1d from the heap. The data of the returned Array_Component1d must be freed by the user.
    // This is separate from the normal constructor, as Array_Component1d objects are not supposed to manage memory
    Array_Component1d AllocateArrayFromHeap_Component1d(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns=false);


    class Array_Component2dPiece
    {
    public:
      static s32 ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns);

      static s32 ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns);

      Array_Component2dPiece();

      // Constructor for a Array_Component2dPiece, pointing to user-allocated data. If the pointer to *data is not
      // aligned to MEMORY_ALIGNMENT, this Array_Component2dPiece will start at the next aligned location.
      // Unfortunately, this is more restrictive than most matrix libraries, and as an example,
      // it may make it hard to convert from OpenCV to Array_Component2dPiece, though the reverse is trivial.
      Array_Component2dPiece(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const bool useBoundaryFillPatterns=false);

      // Constructor for a Array_Component2dPiece, pointing to user-allocated MemoryStack
      Array_Component2dPiece(const s32 numRows, const s32 numCols, MemoryStack &memory, const bool useBoundaryFillPatterns=false);

      // Pointer to the data, at a given (y,x) location
      const inline Component2dPiece* Pointer(const s32 index0, const s32 index1) const
      {
        assert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1] &&
          this->rawDataPointer != NULL && this->data != NULL);

        return reinterpret_cast<const Component2dPiece*>( reinterpret_cast<const char*>(this->data) +
          index1*sizeof(Component2dPiece) + index0*stride );
      }

      // Pointer to the data, at a given (y,x) location
      inline Component2dPiece* Pointer(const s32 index0, const s32 index1)
      {
        assert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1] &&
          this->rawDataPointer != NULL && this->data != NULL);

        return reinterpret_cast<Component2dPiece*>( reinterpret_cast<char*>(this->data) +
          index1*sizeof(Component2dPiece) + index0*stride );
      }

      // Pointer to the data, at a given (y,x) location
      const inline Component2dPiece* Pointer(const Point_s16 &point) const
      {
        return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
      }

      // Pointer to the data, at a given (y,x) location
      inline Component2dPiece* Pointer(const Point_s16 &point)
      {
        return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));
      }

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      // Returns a templated cv::Mat_ that shares the same buffer with this Array_Component2dPiece. No data is copied.
      cv::Mat_<Component2dPiece>& get_CvMat_();
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

      // If this array or array2 are different sizes or uninitialized, then return false.
      bool IsEqualSize(const Array_Component2dPiece &array2) const;

      // Print out the contents of this Array_Component2dPiece
      void Print(const char * const variableName = "Array_Component2dPiece") const;

      // If the Array_Component2dPiece was constructed with the useBoundaryFillPatterns=true, then
      // return if any memory was written out of bounds (via fill patterns at the
      // beginning and end).  If the Array_Component2dPiece was not constructed with the
      // useBoundaryFillPatterns=true, this method always returns true
      bool IsValid() const;

      // Set every element in the Array_Component2dPiece to this value
      // Returns the number of values set
      s32 Set(const Component2dPiece value);

      s32 get_size(s32 dimension) const;

      s32 get_stride() const;

      void* get_rawDataPointer();

      const void* get_rawDataPointer() const;

    protected:
      // Bit-inverse of MemoryStack patterns. The pattern will be put twice at
      // the beginning and end of each line.
      static const u32 FILL_PATTERN_START = 0X5432EF76;
      static const u32 FILL_PATTERN_END = 0X7610FE76;

      static const s32 HEADER_LENGTH = 8;
      static const s32 FOOTER_LENGTH = 8;

      s32 size[2];
      s32 stride;
      bool useBoundaryFillPatterns;

      Component2dPiece * data;

      // To enforce alignment, rawDataPointer may be slightly before Component2dPiece * data.
      // If the inputted data buffer was from malloc, this is the pointer that
      // should be used to free.
      void * rawDataPointer;

#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)
      cv::Mat_<Component2dPiece> cvMatMirror;
#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)

      void Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns);

      void InvalidateArray(); // Set all the buffers and sizes to zero, to signal an invalid array

    private:
      //Array_Component2dPiece & operator= (const Array_Component2dPiece & rightHandSide); // In the future, assignment may not be allowed
    }; // class Array_Component2dPiece

    // Factory method to create an Array_Component2dPiece from the heap. The data of the returned Array_Component2dPiece must be freed by the user.
    // This is separate from the normal constructor, as Array_Component2dPiece objects are not supposed to manage memory
    Array_Component2dPiece AllocateArrayFromHeap_Component2dPiece(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns=false);


    } // namespace Embedded
} //namespace Anki

#endif // _ANKICORETECHEMBEDDED_VISION_ARRAY2D_VISION_H_
