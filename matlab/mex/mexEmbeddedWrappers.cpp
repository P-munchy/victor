/*









This file was automatically generated by the python script generateMexEmbeddedWrappers_cpp.py. Rather than editing this file, edit that script, then run "python generateMexEmbeddedWrappers_cpp.py".









*/

#include "mexEmbeddedWrappers.h"
#include <vector>
#include <string>
#include <sstream>

namespace Anki
{
  namespace Embedded
  {
    mxClassID convertToMatlabType(const char * const typeName, const size_t byteDepth)
    {
      //mexPrintf("typename %s\n", typeName);
#if defined(__APPLE_CC__) // Apple Xcode
        if(typeName[0] == 'h') {
            return mxUINT8_CLASS;
        } else if(typeName[0] == 'a') {
            return mxINT8_CLASS;
        } else if(typeName[0] == 't') {
            return mxUINT16_CLASS;
        } else if(typeName[0] == 's') {
            return mxINT16_CLASS;
        } else if(typeName[0] == 'j') {
            return mxUINT32_CLASS;
        } else if(typeName[0] == 'i') {
            return mxINT32_CLASS;
        } else if(typeName[0] == 'y') {
            return mxUINT64_CLASS;
        } else if(typeName[0] == 'x') {
            return mxINT64_CLASS;
        } else if(typeName[0] == 'f') {
            return mxSINGLE_CLASS;
        } else if(typeName[0] == 'd') {
            return mxDOUBLE_CLASS;
        }
#else // #if defined(__APPLE_CC__) // Apple Xcode
        if(typeName[0] == 'u') { //unsigned
          if(byteDepth == 1) {
            return mxUINT8_CLASS;
          } else if(byteDepth == 2) {
            return mxUINT16_CLASS;
          }else if(byteDepth == 4) {
            return mxUINT32_CLASS;
          }else if(byteDepth == 8) {
            return mxUINT64_CLASS;
          }
        } else if(typeName[0] == 'f' && byteDepth == 4) { //float
          return mxSINGLE_CLASS;
        } else if(typeName[0] == 'd' && byteDepth == 8) { //double
          return mxDOUBLE_CLASS;
        } else { // signed
          if(byteDepth == 1) {
            return mxINT8_CLASS;
          } else if(byteDepth == 2) {
            return mxINT16_CLASS;
          }else if(byteDepth == 4) {
            return mxINT32_CLASS;
          }else if(byteDepth == 8) {
            return mxINT64_CLASS;
          }
        }
#endif // #if defined(__APPLE_CC__) // Apple Xcode ... #else

        return mxUNKNOWN_CLASS;
    } // mxClassID convertToMatlabType(const char * const typeName, const size_t byteDepth)

    std::string convertToMatlabTypeString(const char *typeName, size_t byteDepth)
    {
        #if defined(__APPLE_CC__) // Apple Xcode
        if(typeName[0] == 'h') {
            return std::string("uint8");
        } else if(typeName[0] == 'a') {
            return std::string("int8");
        } else if(typeName[0] == 't') {
            return std::string("uint16");
        } else if(typeName[0] == 's') {
            return std::string("int16");
        } else if(typeName[0] == 'j') {
            return std::string("uint32");
        } else if(typeName[0] == 'i') {
            return std::string("int32");
        } else if(typeName[0] == 'y') {
            return std::string("uint64");
        } else if(typeName[0] == 'x') {
            return std::string("int64");
        } else if(typeName[0] == 'f') {
            return std::string("single");
        } else if(typeName[0] == 'd') {
            return std::string("double");
        }
#else // #if defined(__APPLE_CC__) // Apple Xcode
      if(typeName[0] == 'u') { //unsigned
        if(byteDepth == 1) {
          return std::string("uint8");
        } else if(byteDepth == 2) {
          return std::string("uint16");
        }else if(byteDepth == 4) {
          return std::string("uint32");
        }else if(byteDepth == 8) {
          return std::string("uint64");
        }
      } else if(typeName[0] == 'f' && byteDepth == 4) { //float
        return std::string("single");
      } else if(typeName[0] == 'd' && byteDepth == 8) { //double
        return std::string("double");
      } else { // signed
        if(byteDepth == 1) {
          return std::string("int8");
        } else if(byteDepth == 2) {
          return std::string("int16");
        }else if(byteDepth == 4) {
          return std::string("int32");
        }else if(byteDepth == 8) {
          return std::string("int64");
        }
      }
#endif // #if defined(__APPLE_CC__) // Apple Xcode ... #else

      return std::string("unknown");
    } // std::string convertToMatlabTypeString(const char *typeName, size_t byteDepth)

    void mxArrayToArray_u8(const mxArray * const array, Array_u8 &mat)
    {
      const int npixels = mat.get_size(0)*mat.get_size(1);
      const int nrows = mat.get_size(0);
      const int ncols = mat.get_size(1);
    
      const u8 * const matlabMatrixStartPointer = reinterpret_cast<const u8 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
    
      if(numMatlabElements != npixels) {
        printf("mxArrayToArray_u8(array,mat) - Matlab array has a different number of elements than the Anki::Embedded::Array (%d != %d)\n", numMatlabElements, npixels);
        return;
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(u8).name(), sizeof(u8));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_u8(array,mat) - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return;
      }
    
      for(s32 y=0; y<nrows; ++y) {
        u8 * const array_u8_rowPointer = mat.Pointer(y, 0);
        const u8 * const matlabMatrix_rowPointer = matlabMatrixStartPointer + y*ncols;
    
        for(s32 x=0; x<ncols; ++x) {
          array_u8_rowPointer[x] = matlabMatrix_rowPointer[x];
        }
      }
    } // void mxArrayToArray_u8(const mxArray * const array, Array_u8 &mat)
    
    Array_u8 mxArrayToArray_u8(const mxArray * const array)
    {
      const u8 * const matlabMatrixStartPointer = reinterpret_cast<const u8 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
      const mwSize numDimensions = mxGetNumberOfDimensions(array);
      const mwSize *dimensions = mxGetDimensions(array);
    
      if(numDimensions != 2) {
        printf("mxArrayToArray_u8 - Matlab array must be 2D\n");
        return Array_u8();
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(u8).name(), sizeof(u8));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_u8 - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return Array_u8();
      }
      
      Array_u8 array_u8 = AllocateArrayFromHeap_u8(dimensions[0], dimensions[1]);
    
      for(s32 y=0; y<dimensions[0]; ++y) {
        u8 * const array_u8_rowPointer = array_u8.Pointer(y, 0);
    
        for(s32 x=0; x<dimensions[1]; ++x) {
          array_u8_rowPointer[x] = *(matlabMatrixStartPointer + x*dimensions[0] + y);
        }
      }
    
      return array_u8;
    } // Array_u8 mxArrayToArray_u8(const mxArray * const array)
    
    mxArray* arrayToMxArray_u8(const Array_u8 &array_u8)
    {
      const mxClassID classId = convertToMatlabType(typeid(u8).name(), sizeof(u8));
    
      const mwSize outputDims[2] = {array_u8.get_size(0), array_u8.get_size(1)};
      mxArray *outputArray = mxCreateNumericArray(2, outputDims, classId, mxREAL);
      u8 * const matlabMatrixStartPointer = (u8 *) mxGetData(outputArray);
    
      for(s32 y=0; y<outputDims[0]; ++y) {
        const u8 * const array_u8_rowPointer = array_u8.Pointer(y, 0);
    
        for(s32 x=0; x<outputDims[1]; ++x) {
          *(matlabMatrixStartPointer + x*outputDims[0] + y) = array_u8_rowPointer[x];
        }
      }
    
      return outputArray;
    } // mxArray* arrayToMxArray_u8(const Array_u8 &array_u8)

    void mxArrayToArray_s8(const mxArray * const array, Array_s8 &mat)
    {
      const int npixels = mat.get_size(0)*mat.get_size(1);
      const int nrows = mat.get_size(0);
      const int ncols = mat.get_size(1);
    
      const s8 * const matlabMatrixStartPointer = reinterpret_cast<const s8 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
    
      if(numMatlabElements != npixels) {
        printf("mxArrayToArray_s8(array,mat) - Matlab array has a different number of elements than the Anki::Embedded::Array (%d != %d)\n", numMatlabElements, npixels);
        return;
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(s8).name(), sizeof(s8));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_s8(array,mat) - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return;
      }
    
      for(s32 y=0; y<nrows; ++y) {
        s8 * const array_s8_rowPointer = mat.Pointer(y, 0);
        const s8 * const matlabMatrix_rowPointer = matlabMatrixStartPointer + y*ncols;
    
        for(s32 x=0; x<ncols; ++x) {
          array_s8_rowPointer[x] = matlabMatrix_rowPointer[x];
        }
      }
    } // void mxArrayToArray_s8(const mxArray * const array, Array_s8 &mat)
    
    Array_s8 mxArrayToArray_s8(const mxArray * const array)
    {
      const s8 * const matlabMatrixStartPointer = reinterpret_cast<const s8 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
      const mwSize numDimensions = mxGetNumberOfDimensions(array);
      const mwSize *dimensions = mxGetDimensions(array);
    
      if(numDimensions != 2) {
        printf("mxArrayToArray_s8 - Matlab array must be 2D\n");
        return Array_s8();
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(s8).name(), sizeof(s8));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_s8 - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return Array_s8();
      }
      
      Array_s8 array_s8 = AllocateArrayFromHeap_s8(dimensions[0], dimensions[1]);
    
      for(s32 y=0; y<dimensions[0]; ++y) {
        s8 * const array_s8_rowPointer = array_s8.Pointer(y, 0);
    
        for(s32 x=0; x<dimensions[1]; ++x) {
          array_s8_rowPointer[x] = *(matlabMatrixStartPointer + x*dimensions[0] + y);
        }
      }
    
      return array_s8;
    } // Array_s8 mxArrayToArray_s8(const mxArray * const array)
    
    mxArray* arrayToMxArray_s8(const Array_s8 &array_s8)
    {
      const mxClassID classId = convertToMatlabType(typeid(s8).name(), sizeof(s8));
    
      const mwSize outputDims[2] = {array_s8.get_size(0), array_s8.get_size(1)};
      mxArray *outputArray = mxCreateNumericArray(2, outputDims, classId, mxREAL);
      s8 * const matlabMatrixStartPointer = (s8 *) mxGetData(outputArray);
    
      for(s32 y=0; y<outputDims[0]; ++y) {
        const s8 * const array_s8_rowPointer = array_s8.Pointer(y, 0);
    
        for(s32 x=0; x<outputDims[1]; ++x) {
          *(matlabMatrixStartPointer + x*outputDims[0] + y) = array_s8_rowPointer[x];
        }
      }
    
      return outputArray;
    } // mxArray* arrayToMxArray_s8(const Array_s8 &array_s8)

    void mxArrayToArray_u16(const mxArray * const array, Array_u16 &mat)
    {
      const int npixels = mat.get_size(0)*mat.get_size(1);
      const int nrows = mat.get_size(0);
      const int ncols = mat.get_size(1);
    
      const u16 * const matlabMatrixStartPointer = reinterpret_cast<const u16 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
    
      if(numMatlabElements != npixels) {
        printf("mxArrayToArray_u16(array,mat) - Matlab array has a different number of elements than the Anki::Embedded::Array (%d != %d)\n", numMatlabElements, npixels);
        return;
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(u16).name(), sizeof(u16));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_u16(array,mat) - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return;
      }
    
      for(s32 y=0; y<nrows; ++y) {
        u16 * const array_u16_rowPointer = mat.Pointer(y, 0);
        const u16 * const matlabMatrix_rowPointer = matlabMatrixStartPointer + y*ncols;
    
        for(s32 x=0; x<ncols; ++x) {
          array_u16_rowPointer[x] = matlabMatrix_rowPointer[x];
        }
      }
    } // void mxArrayToArray_u16(const mxArray * const array, Array_u16 &mat)
    
    Array_u16 mxArrayToArray_u16(const mxArray * const array)
    {
      const u16 * const matlabMatrixStartPointer = reinterpret_cast<const u16 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
      const mwSize numDimensions = mxGetNumberOfDimensions(array);
      const mwSize *dimensions = mxGetDimensions(array);
    
      if(numDimensions != 2) {
        printf("mxArrayToArray_u16 - Matlab array must be 2D\n");
        return Array_u16();
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(u16).name(), sizeof(u16));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_u16 - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return Array_u16();
      }
      
      Array_u16 array_u16 = AllocateArrayFromHeap_u16(dimensions[0], dimensions[1]);
    
      for(s32 y=0; y<dimensions[0]; ++y) {
        u16 * const array_u16_rowPointer = array_u16.Pointer(y, 0);
    
        for(s32 x=0; x<dimensions[1]; ++x) {
          array_u16_rowPointer[x] = *(matlabMatrixStartPointer + x*dimensions[0] + y);
        }
      }
    
      return array_u16;
    } // Array_u16 mxArrayToArray_u16(const mxArray * const array)
    
    mxArray* arrayToMxArray_u16(const Array_u16 &array_u16)
    {
      const mxClassID classId = convertToMatlabType(typeid(u16).name(), sizeof(u16));
    
      const mwSize outputDims[2] = {array_u16.get_size(0), array_u16.get_size(1)};
      mxArray *outputArray = mxCreateNumericArray(2, outputDims, classId, mxREAL);
      u16 * const matlabMatrixStartPointer = (u16 *) mxGetData(outputArray);
    
      for(s32 y=0; y<outputDims[0]; ++y) {
        const u16 * const array_u16_rowPointer = array_u16.Pointer(y, 0);
    
        for(s32 x=0; x<outputDims[1]; ++x) {
          *(matlabMatrixStartPointer + x*outputDims[0] + y) = array_u16_rowPointer[x];
        }
      }
    
      return outputArray;
    } // mxArray* arrayToMxArray_u16(const Array_u16 &array_u16)

    void mxArrayToArray_s16(const mxArray * const array, Array_s16 &mat)
    {
      const int npixels = mat.get_size(0)*mat.get_size(1);
      const int nrows = mat.get_size(0);
      const int ncols = mat.get_size(1);
    
      const s16 * const matlabMatrixStartPointer = reinterpret_cast<const s16 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
    
      if(numMatlabElements != npixels) {
        printf("mxArrayToArray_s16(array,mat) - Matlab array has a different number of elements than the Anki::Embedded::Array (%d != %d)\n", numMatlabElements, npixels);
        return;
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(s16).name(), sizeof(s16));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_s16(array,mat) - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return;
      }
    
      for(s32 y=0; y<nrows; ++y) {
        s16 * const array_s16_rowPointer = mat.Pointer(y, 0);
        const s16 * const matlabMatrix_rowPointer = matlabMatrixStartPointer + y*ncols;
    
        for(s32 x=0; x<ncols; ++x) {
          array_s16_rowPointer[x] = matlabMatrix_rowPointer[x];
        }
      }
    } // void mxArrayToArray_s16(const mxArray * const array, Array_s16 &mat)
    
    Array_s16 mxArrayToArray_s16(const mxArray * const array)
    {
      const s16 * const matlabMatrixStartPointer = reinterpret_cast<const s16 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
      const mwSize numDimensions = mxGetNumberOfDimensions(array);
      const mwSize *dimensions = mxGetDimensions(array);
    
      if(numDimensions != 2) {
        printf("mxArrayToArray_s16 - Matlab array must be 2D\n");
        return Array_s16();
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(s16).name(), sizeof(s16));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_s16 - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return Array_s16();
      }
      
      Array_s16 array_s16 = AllocateArrayFromHeap_s16(dimensions[0], dimensions[1]);
    
      for(s32 y=0; y<dimensions[0]; ++y) {
        s16 * const array_s16_rowPointer = array_s16.Pointer(y, 0);
    
        for(s32 x=0; x<dimensions[1]; ++x) {
          array_s16_rowPointer[x] = *(matlabMatrixStartPointer + x*dimensions[0] + y);
        }
      }
    
      return array_s16;
    } // Array_s16 mxArrayToArray_s16(const mxArray * const array)
    
    mxArray* arrayToMxArray_s16(const Array_s16 &array_s16)
    {
      const mxClassID classId = convertToMatlabType(typeid(s16).name(), sizeof(s16));
    
      const mwSize outputDims[2] = {array_s16.get_size(0), array_s16.get_size(1)};
      mxArray *outputArray = mxCreateNumericArray(2, outputDims, classId, mxREAL);
      s16 * const matlabMatrixStartPointer = (s16 *) mxGetData(outputArray);
    
      for(s32 y=0; y<outputDims[0]; ++y) {
        const s16 * const array_s16_rowPointer = array_s16.Pointer(y, 0);
    
        for(s32 x=0; x<outputDims[1]; ++x) {
          *(matlabMatrixStartPointer + x*outputDims[0] + y) = array_s16_rowPointer[x];
        }
      }
    
      return outputArray;
    } // mxArray* arrayToMxArray_s16(const Array_s16 &array_s16)

    void mxArrayToArray_u32(const mxArray * const array, Array_u32 &mat)
    {
      const int npixels = mat.get_size(0)*mat.get_size(1);
      const int nrows = mat.get_size(0);
      const int ncols = mat.get_size(1);
    
      const u32 * const matlabMatrixStartPointer = reinterpret_cast<const u32 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
    
      if(numMatlabElements != npixels) {
        printf("mxArrayToArray_u32(array,mat) - Matlab array has a different number of elements than the Anki::Embedded::Array (%d != %d)\n", numMatlabElements, npixels);
        return;
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(u32).name(), sizeof(u32));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_u32(array,mat) - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return;
      }
    
      for(s32 y=0; y<nrows; ++y) {
        u32 * const array_u32_rowPointer = mat.Pointer(y, 0);
        const u32 * const matlabMatrix_rowPointer = matlabMatrixStartPointer + y*ncols;
    
        for(s32 x=0; x<ncols; ++x) {
          array_u32_rowPointer[x] = matlabMatrix_rowPointer[x];
        }
      }
    } // void mxArrayToArray_u32(const mxArray * const array, Array_u32 &mat)
    
    Array_u32 mxArrayToArray_u32(const mxArray * const array)
    {
      const u32 * const matlabMatrixStartPointer = reinterpret_cast<const u32 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
      const mwSize numDimensions = mxGetNumberOfDimensions(array);
      const mwSize *dimensions = mxGetDimensions(array);
    
      if(numDimensions != 2) {
        printf("mxArrayToArray_u32 - Matlab array must be 2D\n");
        return Array_u32();
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(u32).name(), sizeof(u32));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_u32 - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return Array_u32();
      }
      
      Array_u32 array_u32 = AllocateArrayFromHeap_u32(dimensions[0], dimensions[1]);
    
      for(s32 y=0; y<dimensions[0]; ++y) {
        u32 * const array_u32_rowPointer = array_u32.Pointer(y, 0);
    
        for(s32 x=0; x<dimensions[1]; ++x) {
          array_u32_rowPointer[x] = *(matlabMatrixStartPointer + x*dimensions[0] + y);
        }
      }
    
      return array_u32;
    } // Array_u32 mxArrayToArray_u32(const mxArray * const array)
    
    mxArray* arrayToMxArray_u32(const Array_u32 &array_u32)
    {
      const mxClassID classId = convertToMatlabType(typeid(u32).name(), sizeof(u32));
    
      const mwSize outputDims[2] = {array_u32.get_size(0), array_u32.get_size(1)};
      mxArray *outputArray = mxCreateNumericArray(2, outputDims, classId, mxREAL);
      u32 * const matlabMatrixStartPointer = (u32 *) mxGetData(outputArray);
    
      for(s32 y=0; y<outputDims[0]; ++y) {
        const u32 * const array_u32_rowPointer = array_u32.Pointer(y, 0);
    
        for(s32 x=0; x<outputDims[1]; ++x) {
          *(matlabMatrixStartPointer + x*outputDims[0] + y) = array_u32_rowPointer[x];
        }
      }
    
      return outputArray;
    } // mxArray* arrayToMxArray_u32(const Array_u32 &array_u32)

    void mxArrayToArray_s32(const mxArray * const array, Array_s32 &mat)
    {
      const int npixels = mat.get_size(0)*mat.get_size(1);
      const int nrows = mat.get_size(0);
      const int ncols = mat.get_size(1);
    
      const s32 * const matlabMatrixStartPointer = reinterpret_cast<const s32 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
    
      if(numMatlabElements != npixels) {
        printf("mxArrayToArray_s32(array,mat) - Matlab array has a different number of elements than the Anki::Embedded::Array (%d != %d)\n", numMatlabElements, npixels);
        return;
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(s32).name(), sizeof(s32));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_s32(array,mat) - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return;
      }
    
      for(s32 y=0; y<nrows; ++y) {
        s32 * const array_s32_rowPointer = mat.Pointer(y, 0);
        const s32 * const matlabMatrix_rowPointer = matlabMatrixStartPointer + y*ncols;
    
        for(s32 x=0; x<ncols; ++x) {
          array_s32_rowPointer[x] = matlabMatrix_rowPointer[x];
        }
      }
    } // void mxArrayToArray_s32(const mxArray * const array, Array_s32 &mat)
    
    Array_s32 mxArrayToArray_s32(const mxArray * const array)
    {
      const s32 * const matlabMatrixStartPointer = reinterpret_cast<const s32 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
      const mwSize numDimensions = mxGetNumberOfDimensions(array);
      const mwSize *dimensions = mxGetDimensions(array);
    
      if(numDimensions != 2) {
        printf("mxArrayToArray_s32 - Matlab array must be 2D\n");
        return Array_s32();
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(s32).name(), sizeof(s32));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_s32 - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return Array_s32();
      }
      
      Array_s32 array_s32 = AllocateArrayFromHeap_s32(dimensions[0], dimensions[1]);
    
      for(s32 y=0; y<dimensions[0]; ++y) {
        s32 * const array_s32_rowPointer = array_s32.Pointer(y, 0);
    
        for(s32 x=0; x<dimensions[1]; ++x) {
          array_s32_rowPointer[x] = *(matlabMatrixStartPointer + x*dimensions[0] + y);
        }
      }
    
      return array_s32;
    } // Array_s32 mxArrayToArray_s32(const mxArray * const array)
    
    mxArray* arrayToMxArray_s32(const Array_s32 &array_s32)
    {
      const mxClassID classId = convertToMatlabType(typeid(s32).name(), sizeof(s32));
    
      const mwSize outputDims[2] = {array_s32.get_size(0), array_s32.get_size(1)};
      mxArray *outputArray = mxCreateNumericArray(2, outputDims, classId, mxREAL);
      s32 * const matlabMatrixStartPointer = (s32 *) mxGetData(outputArray);
    
      for(s32 y=0; y<outputDims[0]; ++y) {
        const s32 * const array_s32_rowPointer = array_s32.Pointer(y, 0);
    
        for(s32 x=0; x<outputDims[1]; ++x) {
          *(matlabMatrixStartPointer + x*outputDims[0] + y) = array_s32_rowPointer[x];
        }
      }
    
      return outputArray;
    } // mxArray* arrayToMxArray_s32(const Array_s32 &array_s32)

    void mxArrayToArray_u64(const mxArray * const array, Array_u64 &mat)
    {
      const int npixels = mat.get_size(0)*mat.get_size(1);
      const int nrows = mat.get_size(0);
      const int ncols = mat.get_size(1);
    
      const u64 * const matlabMatrixStartPointer = reinterpret_cast<const u64 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
    
      if(numMatlabElements != npixels) {
        printf("mxArrayToArray_u64(array,mat) - Matlab array has a different number of elements than the Anki::Embedded::Array (%d != %d)\n", numMatlabElements, npixels);
        return;
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(u64).name(), sizeof(u64));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_u64(array,mat) - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return;
      }
    
      for(s32 y=0; y<nrows; ++y) {
        u64 * const array_u64_rowPointer = mat.Pointer(y, 0);
        const u64 * const matlabMatrix_rowPointer = matlabMatrixStartPointer + y*ncols;
    
        for(s32 x=0; x<ncols; ++x) {
          array_u64_rowPointer[x] = matlabMatrix_rowPointer[x];
        }
      }
    } // void mxArrayToArray_u64(const mxArray * const array, Array_u64 &mat)
    
    Array_u64 mxArrayToArray_u64(const mxArray * const array)
    {
      const u64 * const matlabMatrixStartPointer = reinterpret_cast<const u64 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
      const mwSize numDimensions = mxGetNumberOfDimensions(array);
      const mwSize *dimensions = mxGetDimensions(array);
    
      if(numDimensions != 2) {
        printf("mxArrayToArray_u64 - Matlab array must be 2D\n");
        return Array_u64();
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(u64).name(), sizeof(u64));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_u64 - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return Array_u64();
      }
      
      Array_u64 array_u64 = AllocateArrayFromHeap_u64(dimensions[0], dimensions[1]);
    
      for(s32 y=0; y<dimensions[0]; ++y) {
        u64 * const array_u64_rowPointer = array_u64.Pointer(y, 0);
    
        for(s32 x=0; x<dimensions[1]; ++x) {
          array_u64_rowPointer[x] = *(matlabMatrixStartPointer + x*dimensions[0] + y);
        }
      }
    
      return array_u64;
    } // Array_u64 mxArrayToArray_u64(const mxArray * const array)
    
    mxArray* arrayToMxArray_u64(const Array_u64 &array_u64)
    {
      const mxClassID classId = convertToMatlabType(typeid(u64).name(), sizeof(u64));
    
      const mwSize outputDims[2] = {array_u64.get_size(0), array_u64.get_size(1)};
      mxArray *outputArray = mxCreateNumericArray(2, outputDims, classId, mxREAL);
      u64 * const matlabMatrixStartPointer = (u64 *) mxGetData(outputArray);
    
      for(s32 y=0; y<outputDims[0]; ++y) {
        const u64 * const array_u64_rowPointer = array_u64.Pointer(y, 0);
    
        for(s32 x=0; x<outputDims[1]; ++x) {
          *(matlabMatrixStartPointer + x*outputDims[0] + y) = array_u64_rowPointer[x];
        }
      }
    
      return outputArray;
    } // mxArray* arrayToMxArray_u64(const Array_u64 &array_u64)

    void mxArrayToArray_s64(const mxArray * const array, Array_s64 &mat)
    {
      const int npixels = mat.get_size(0)*mat.get_size(1);
      const int nrows = mat.get_size(0);
      const int ncols = mat.get_size(1);
    
      const s64 * const matlabMatrixStartPointer = reinterpret_cast<const s64 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
    
      if(numMatlabElements != npixels) {
        printf("mxArrayToArray_s64(array,mat) - Matlab array has a different number of elements than the Anki::Embedded::Array (%d != %d)\n", numMatlabElements, npixels);
        return;
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(s64).name(), sizeof(s64));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_s64(array,mat) - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return;
      }
    
      for(s32 y=0; y<nrows; ++y) {
        s64 * const array_s64_rowPointer = mat.Pointer(y, 0);
        const s64 * const matlabMatrix_rowPointer = matlabMatrixStartPointer + y*ncols;
    
        for(s32 x=0; x<ncols; ++x) {
          array_s64_rowPointer[x] = matlabMatrix_rowPointer[x];
        }
      }
    } // void mxArrayToArray_s64(const mxArray * const array, Array_s64 &mat)
    
    Array_s64 mxArrayToArray_s64(const mxArray * const array)
    {
      const s64 * const matlabMatrixStartPointer = reinterpret_cast<const s64 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
      const mwSize numDimensions = mxGetNumberOfDimensions(array);
      const mwSize *dimensions = mxGetDimensions(array);
    
      if(numDimensions != 2) {
        printf("mxArrayToArray_s64 - Matlab array must be 2D\n");
        return Array_s64();
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(s64).name(), sizeof(s64));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_s64 - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return Array_s64();
      }
      
      Array_s64 array_s64 = AllocateArrayFromHeap_s64(dimensions[0], dimensions[1]);
    
      for(s32 y=0; y<dimensions[0]; ++y) {
        s64 * const array_s64_rowPointer = array_s64.Pointer(y, 0);
    
        for(s32 x=0; x<dimensions[1]; ++x) {
          array_s64_rowPointer[x] = *(matlabMatrixStartPointer + x*dimensions[0] + y);
        }
      }
    
      return array_s64;
    } // Array_s64 mxArrayToArray_s64(const mxArray * const array)
    
    mxArray* arrayToMxArray_s64(const Array_s64 &array_s64)
    {
      const mxClassID classId = convertToMatlabType(typeid(s64).name(), sizeof(s64));
    
      const mwSize outputDims[2] = {array_s64.get_size(0), array_s64.get_size(1)};
      mxArray *outputArray = mxCreateNumericArray(2, outputDims, classId, mxREAL);
      s64 * const matlabMatrixStartPointer = (s64 *) mxGetData(outputArray);
    
      for(s32 y=0; y<outputDims[0]; ++y) {
        const s64 * const array_s64_rowPointer = array_s64.Pointer(y, 0);
    
        for(s32 x=0; x<outputDims[1]; ++x) {
          *(matlabMatrixStartPointer + x*outputDims[0] + y) = array_s64_rowPointer[x];
        }
      }
    
      return outputArray;
    } // mxArray* arrayToMxArray_s64(const Array_s64 &array_s64)

    void mxArrayToArray_f32(const mxArray * const array, Array_f32 &mat)
    {
      const int npixels = mat.get_size(0)*mat.get_size(1);
      const int nrows = mat.get_size(0);
      const int ncols = mat.get_size(1);
    
      const f32 * const matlabMatrixStartPointer = reinterpret_cast<const f32 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
    
      if(numMatlabElements != npixels) {
        printf("mxArrayToArray_f32(array,mat) - Matlab array has a different number of elements than the Anki::Embedded::Array (%d != %d)\n", numMatlabElements, npixels);
        return;
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(f32).name(), sizeof(f32));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_f32(array,mat) - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return;
      }
    
      for(s32 y=0; y<nrows; ++y) {
        f32 * const array_f32_rowPointer = mat.Pointer(y, 0);
        const f32 * const matlabMatrix_rowPointer = matlabMatrixStartPointer + y*ncols;
    
        for(s32 x=0; x<ncols; ++x) {
          array_f32_rowPointer[x] = matlabMatrix_rowPointer[x];
        }
      }
    } // void mxArrayToArray_f32(const mxArray * const array, Array_f32 &mat)
    
    Array_f32 mxArrayToArray_f32(const mxArray * const array)
    {
      const f32 * const matlabMatrixStartPointer = reinterpret_cast<const f32 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
      const mwSize numDimensions = mxGetNumberOfDimensions(array);
      const mwSize *dimensions = mxGetDimensions(array);
    
      if(numDimensions != 2) {
        printf("mxArrayToArray_f32 - Matlab array must be 2D\n");
        return Array_f32();
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(f32).name(), sizeof(f32));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_f32 - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return Array_f32();
      }
      
      Array_f32 array_f32 = AllocateArrayFromHeap_f32(dimensions[0], dimensions[1]);
    
      for(s32 y=0; y<dimensions[0]; ++y) {
        f32 * const array_f32_rowPointer = array_f32.Pointer(y, 0);
    
        for(s32 x=0; x<dimensions[1]; ++x) {
          array_f32_rowPointer[x] = *(matlabMatrixStartPointer + x*dimensions[0] + y);
        }
      }
    
      return array_f32;
    } // Array_f32 mxArrayToArray_f32(const mxArray * const array)
    
    mxArray* arrayToMxArray_f32(const Array_f32 &array_f32)
    {
      const mxClassID classId = convertToMatlabType(typeid(f32).name(), sizeof(f32));
    
      const mwSize outputDims[2] = {array_f32.get_size(0), array_f32.get_size(1)};
      mxArray *outputArray = mxCreateNumericArray(2, outputDims, classId, mxREAL);
      f32 * const matlabMatrixStartPointer = (f32 *) mxGetData(outputArray);
    
      for(s32 y=0; y<outputDims[0]; ++y) {
        const f32 * const array_f32_rowPointer = array_f32.Pointer(y, 0);
    
        for(s32 x=0; x<outputDims[1]; ++x) {
          *(matlabMatrixStartPointer + x*outputDims[0] + y) = array_f32_rowPointer[x];
        }
      }
    
      return outputArray;
    } // mxArray* arrayToMxArray_f32(const Array_f32 &array_f32)

    void mxArrayToArray_f64(const mxArray * const array, Array_f64 &mat)
    {
      const int npixels = mat.get_size(0)*mat.get_size(1);
      const int nrows = mat.get_size(0);
      const int ncols = mat.get_size(1);
    
      const f64 * const matlabMatrixStartPointer = reinterpret_cast<const f64 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
    
      if(numMatlabElements != npixels) {
        printf("mxArrayToArray_f64(array,mat) - Matlab array has a different number of elements than the Anki::Embedded::Array (%d != %d)\n", numMatlabElements, npixels);
        return;
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(f64).name(), sizeof(f64));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_f64(array,mat) - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return;
      }
    
      for(s32 y=0; y<nrows; ++y) {
        f64 * const array_f64_rowPointer = mat.Pointer(y, 0);
        const f64 * const matlabMatrix_rowPointer = matlabMatrixStartPointer + y*ncols;
    
        for(s32 x=0; x<ncols; ++x) {
          array_f64_rowPointer[x] = matlabMatrix_rowPointer[x];
        }
      }
    } // void mxArrayToArray_f64(const mxArray * const array, Array_f64 &mat)
    
    Array_f64 mxArrayToArray_f64(const mxArray * const array)
    {
      const f64 * const matlabMatrixStartPointer = reinterpret_cast<const f64 *>( mxGetData(array) );
    
      const mwSize numMatlabElements = mxGetNumberOfElements(array);
      const mwSize numDimensions = mxGetNumberOfDimensions(array);
      const mwSize *dimensions = mxGetDimensions(array);
    
      if(numDimensions != 2) {
        printf("mxArrayToArray_f64 - Matlab array must be 2D\n");
        return Array_f64();
      }
    
      const mxClassID matlabClassId = mxGetClassID(array);
      const mxClassID templateClassId = convertToMatlabType(typeid(f64).name(), sizeof(f64));
      if(matlabClassId != templateClassId) {
        printf("mxArrayToArray_f64 - Matlab classId does not match with template %d!=%d\n", matlabClassId, templateClassId);
        return Array_f64();
      }
      
      Array_f64 array_f64 = AllocateArrayFromHeap_f64(dimensions[0], dimensions[1]);
    
      for(s32 y=0; y<dimensions[0]; ++y) {
        f64 * const array_f64_rowPointer = array_f64.Pointer(y, 0);
    
        for(s32 x=0; x<dimensions[1]; ++x) {
          array_f64_rowPointer[x] = *(matlabMatrixStartPointer + x*dimensions[0] + y);
        }
      }
    
      return array_f64;
    } // Array_f64 mxArrayToArray_f64(const mxArray * const array)
    
    mxArray* arrayToMxArray_f64(const Array_f64 &array_f64)
    {
      const mxClassID classId = convertToMatlabType(typeid(f64).name(), sizeof(f64));
    
      const mwSize outputDims[2] = {array_f64.get_size(0), array_f64.get_size(1)};
      mxArray *outputArray = mxCreateNumericArray(2, outputDims, classId, mxREAL);
      f64 * const matlabMatrixStartPointer = (f64 *) mxGetData(outputArray);
    
      for(s32 y=0; y<outputDims[0]; ++y) {
        const f64 * const array_f64_rowPointer = array_f64.Pointer(y, 0);
    
        for(s32 x=0; x<outputDims[1]; ++x) {
          *(matlabMatrixStartPointer + x*outputDims[0] + y) = array_f64_rowPointer[x];
        }
      }
    
      return outputArray;
    } // mxArray* arrayToMxArray_f64(const Array_f64 &array_f64)

  } // namespace Embedded
} // namespace Anki