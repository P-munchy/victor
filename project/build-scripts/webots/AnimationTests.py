#!/usr/local/bin/python3


# Sep 20, 2016: (daria.jerjomina@anki.com) Added a temporary fix in order to exclude
# text-to-speech clips
# It looks through json files in animations directory and finds all audioName keys that have
# External as part of their name.


import os
import re
import json
import argparse
import sys
import webotsTest

WBT_FILE_NAME = "get_animations.wbt"
GENERATED_CFG_NAME = "__GENERATED_ANIMATIONS_TEST__.cfg"
ANIMATION_TEST_NAME_PLACEHOLDER = "%ANIMATION_TEST_NAME%"
ANIMATIONS = os.path.join(webotsTest.COZMO_ENGINE_ROOT, "EXTERNALS", "cozmo-assets", "animations")
AUDIO_EVENT_KEY = "audioName"
EXTERNAL_EVENT_TOKEN = "_External_"

def main(cli_args):
  """Fetches available animations and generates all the needed files to run tests for all animations.

  First, a dummy test run occurs so that the logs for a run exist. This then crawls through that log
  file to check for all the lines that specify the available animation. It then generates a .wbt
  webots world file for each available animation, as this is the only way to pass information from
  here (python scripts) to the test controller. The animation names are passed as a parameter to the
  CozmoBot proto. A config file is then generated with all the newly generated .wbt files so
  webotsTest can run through them.

  Args:
    cli_args -- command line arguments
  """
  build_type = "Debug"

  parser = argparse.ArgumentParser(
    formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    description="Runs tests on all available animations in webots"
    )

  parser.add_argument('--numRuns',
                      dest='numRuns',
                      action='store',
                      default=1,
                      help="Number of runs through all available animations.")

  parser.add_argument('--password',
                      dest='password',
                      action='store',
                      help="""Your password is needed to add the webots executables to the firewall
                      exception list. Can be omitted if your firewall is disabled. It is requested
                      in plaintext so this script can be re-ran  easily and also for build
                      server/steps reasons.""")

  parser.add_argument('--animationList',
                      dest='animationList',
                      default="",
                      action="store",
                      help="""JSON file containing list of animations to run in this directory (ex.
                      `["speedTapFakeOut1", "testSound"]`). Leave empty to run all available
                      animations.""")

  parser.add_argument('--showGraphics',
                      dest='show_graphics',
                      action='store_true',
                      help='display Webots window')

  parser.add_argument('--failOnError',
                      dest='fail_on_error',
                      action='store_true',
                      help="""If set, if an error is found inside the webots logs, that particular
                      test that contained the error will be considered as failed.""")

  (options, _) = parser.parse_known_args(cli_args)

  if not options.animationList:
    all_animations = fetch_all_available_animations(password=options.password)
  else:
    animation_list_file = webotsTest.get_subpath("project/build-scripts/webots", options.animationList)
    all_animations = fetch_animations_from_list(animation_list_file)

  # Hack to exclude animations with external audio before jordan introduces a fix.
  available_animations = []
  external_audio_animations = fetch_animations_with_external_audio()
  for animation in all_animations:
    if animation not in external_audio_animations:
        available_animations.append(animation)
    else:
        print ("%s has external audio and will be skipped" %(animation))

  # Open an exisiting .wbt file so that it can be used to generate a wbt file with all the available
  # animations
  wbt_dir = webotsTest.get_subpath("simulator/worlds")
  wbt_file = os.path.join(wbt_dir, WBT_FILE_NAME)

  # Generate .wbt world files with each animation name subsituted into animationTestName
  generated_files = []
  for animation in available_animations:
    generated_file_name = "__GENERATED_FOR_{0}__.wbt".format(animation)
    generated_file_path = os.path.join(wbt_dir, generated_file_name)
    generated_files.append(generated_file_name)

    webotsTest.generate_file_with_replace(generated_file_path, wbt_file,
                                          ANIMATION_TEST_NAME_PLACEHOLDER, animation)

  # Generate the config file with all the generated wbt worlds for each animation
  generated_cfg_file_data = (
    "# This is a file auto-generated by {0}.\n".format(os.path.realpath(__file__)) +
    "\n" +
    "[CST_Animations]\n" +
    "world_file : {0}".format(json.JSONEncoder().encode(generated_files))
  )

  with open(webotsTest.get_subpath("project/build-scripts/webots", GENERATED_CFG_NAME), 'w+') as generated_cfg_file:
    generated_cfg_file.write(generated_cfg_file_data)

  webotsTest_arguments = [
    "--buildType", build_type,
    "--configFile", GENERATED_CFG_NAME,
    "--numRuns", str(options.numRuns),
    "--password", options.password,
    "--timeout", '30',
    "--numRetries", 0  # Don't retry any animations since the whole point of this is to catch intermittent aborts
  ]

  if options.show_graphics:
    webotsTest_arguments.append("--showGraphics")

  if options.fail_on_error:
    webotsTest_arguments.append("--failOnError")

  # Run all the webots animation tests with the newly generated cfg file.
  assert webotsTest.main(webotsTest_arguments) == 0

def fetch_all_available_animations(password = "", build_type = "Debug"):
  """Fetch all the animations available to cozmo.

  Note: This is only meant for use for build servers. This relies on there being no other file with
  webots_out_CST_Animations_get_animations.wbt in the name. That is, since the webots log files are
  time stamped and have changing names, this function relies on the fact that the first log it finds
  for the dummy get_animations run contains the proper, updated, and full list of animations.

  password --
    User password that may be needed to pass into webotsTest and put webots executables to the
    firewall exception list. Only needed if you want to keep firewall on.

  build_type --
    build_type used to make sure to specify the webotsTest instead of relying on default; also used
    to make sure we're accessing the right log/build folder
  """

  # Run a test once to populate the logs and search for the available animations
  assert webotsTest.main([
    "--buildType", build_type,
    "--configFile", "get_animations.cfg",
    "--password", password
    ]) == 0

  build_folder = webotsTest.get_build_folder(webotsTest.BuildType.Debug)
  get_animations_log_wo_timestamp = webotsTest.get_log_file_path("", "CST_Animations", WBT_FILE_NAME)
  get_animations_log_wo_extension = get_animations_log_wo_timestamp.rsplit(".", 1)[0]

  # Go through the log folder to find the dummy run log
  all_files_in_build_folder = os.listdir(build_folder)
  for log_file in all_files_in_build_folder:
    if get_animations_log_wo_extension in log_file:
      get_animations_log = os.path.join(build_folder, log_file)

  available_animations = []
  with open(get_animations_log, 'r') as log_file:
    regex = r"(?<=HandleAnimationAvailable Animation available: )(.*)(?=\n)"
    available_animations = re.findall(regex, log_file.read())

  return available_animations

def fetch_animations_from_list(animation_list_file):
  with open(animation_list_file, 'r') as f:
    return json.loads(f.read())

# Hack to exclude animations with external audio before jordan introduces a fix.
# (Can later use, if need to exclude based on something else)

def fetch_clip_paths():
    clip_paths = []
    for clip_path in os.listdir(ANIMATIONS):
        if os.path.splitext(clip_path)[1] == ".json":
            clip_paths.append(os.path.join(ANIMATIONS, clip_path))
    return clip_paths

def fetch_animations_with_external_audio():
    external_audio_animations = []
    clip_paths = fetch_clip_paths()
    for clip_path in clip_paths:
        if is_external_audio(clip_path):
            clip_name = os.path.splitext(os.path.basename(clip_path))[0]
            external_audio_animations.append(clip_name)
    return external_audio_animations

def is_external_audio(clip_path):
    with open(clip_path) as data_file:
        data = json.load(data_file)
    clip_name = os.path.splitext(os.path.basename(clip_path))[0]
    try:
        keyframes = data[clip_name]
    except KeyError:
        print("Mismatch between animation name and file name, assuming external audio")
        print (clip_name)
        return True
    for keyframe in keyframes:
        try:
            audio_event_name = keyframe[AUDIO_EVENT_KEY][0]
        except KeyError:
            continue
        if EXTERNAL_EVENT_TOKEN in audio_event_name:
            return True
    return False

if __name__ == '__main__':
  args = sys.argv
  sys.exit(main(args))
