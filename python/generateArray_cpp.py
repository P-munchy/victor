"""
This file generated a c++ file, by automatically "instantiating templates"
To add some lines to this file, find replace (without the quotes) "\r\n" into "\\n' +\\\r\n            '"
"""

def __GenerateTopOfFile():
    topString = \
        '/*\n\n\n\n\n\n\n\n\n\nThis file was automatically generated by the python script generateArray_cpp.py. Rather than editing this file, edit that script, then run "python generateArray_cpp.py".\n\n\n\n\n\n\n\n\n\n*/\n\n';

    topString += \
        '#include "anki/embeddedCommon.h"\n' +\
        '\n' +\
        'namespace Anki\n' +\
        '{\n' +\
        '  namespace Embedded\n' +\
        '  {\n'

    return topString

def __GenerateBottomOfFile():
    bottomString = \
        '  } // namespace Embedded\n' +\
        '} // namespace Anki'

    return bottomString

def __GenerateDefinitions(whichTypes, includeAllMethods):
    '''
    This function creates the definitions for the Array Class. Basic types (like int or long long) should have includeAllMethods==true, while non-basic types should have includeAllMethods == false
    '''
    methodsString = ''

    for type in whichTypes:
        methodsString +=\
            '    s32 Array_' + type + '::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)\n' +\
            '    {\n' +\
            '      assert(numCols > 0);\n' +\
            '      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);\n' +\
            '      return static_cast<s32>(RoundUp<size_t>(sizeof(' + type + ')*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;\n' +\
            '    } // s32 Array_' + type + '::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)\n' +\
            '\n' +\
            '    s32 Array_' + type + '::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)\n' +\
            '    {\n' +\
            '      assert(numCols > 0 && numRows > 0);\n' +\
            '      return numRows * Array_' + type + '::ComputeRequiredStride(numCols, useBoundaryFillPatterns);\n' +\
            '    } // s32 Array_' + type + '::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)\n' +\
            '\n' +\
            '    Array_' + type + '::Array_' + type + '()\n' +\
            '    {\n' +\
            '      InvalidateArray();\n' +\
            '    } // Array_' + type + '::Array_' + type + '()\n' +\
            '\n' +\
            '    // Constructor for a Array_' + type + ', pointing to user-allocated data. If the pointer to *data is not\n' +\
            '    // aligned to MEMORY_ALIGNMENT, this Array_' + type + ' will start at the next aligned location.\n' +\
            '    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,\n' +\
            '    // it may make it hard to convert from OpenCV to Array_' + type + ', though the reverse is trivial.\n' +\
            '    Array_' + type + '::Array_' + type + '(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)\n' +\
            '      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))\n' +\
            '    {\n' +\
            '      assert(numCols > 0 && numRows > 0 && dataLength > 0);\n' +\
            '\n' +\
            '      Initialize(numRows,\n' +\
            '        numCols,\n' +\
            '        data,\n' +\
            '        dataLength,\n' +\
            '        useBoundaryFillPatterns);\n' +\
            '    } // Array_' + type + '::Array_' + type + '(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)\n' +\
            '\n' +\
            '    Array_' + type + '::Array_' + type + '(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)\n' +\
            '      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))\n' +\
            '    {\n' +\
            '      assert(numCols > 0 && numRows > 0);\n' +\
            '\n' +\
            '      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);\n' +\
            '      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;\n' +\
            '      s32 numBytesAllocated = 0;\n' +\
            '\n' +\
            '      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);\n' +\
            '\n' +\
            '      Initialize(numRows,\n' +\
            '        numCols,\n' +\
            '        reinterpret_cast<' + type + '*>(allocatedBuffer),\n' +\
            '        numBytesAllocated,\n' +\
            '        useBoundaryFillPatterns);\n' +\
            '    } // Array_' + type + '::Array_' + type + '(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)\n' +\
            '\n'
            
        if includeAllMethods:
            methodsString +=\
            '    // Check every element of this array against the input array. If the arrays are different\n' +\
            '    // sizes, uninitialized, or if any element is more different than the threshold, then return\n' +\
            '    // false.\n' +\
            '    bool Array_' + type + '::IsElementwiseEqual(const Array_' + type + ' &array2, const ' + type + ' threshold) const\n' +\
            '    {\n' +\
            '      if(!this->IsEqualSize(array2))\n' +\
            '        return false;\n' +\
            '\n' +\
            '      for(s32 y=0; y<size[0]; y++) {\n' +\
            '        const ' + type + ' * const this_rowPointer = this->Pointer(y, 0);\n' +\
            '        const ' + type + ' * const array2_rowPointer = array2.Pointer(y, 0);\n' +\
            '        for(s32 x=0; x<size[1]; x++) {\n' +\
            '          if(this_rowPointer[x] > array2_rowPointer[x]) {\n' +\
            '            if((this_rowPointer[x] - array2_rowPointer[x]) > threshold)\n' +\
            '              return false;\n' +\
            '          } else {\n' +\
            '            if((array2_rowPointer[x] - this_rowPointer[x]) > threshold)\n' +\
            '              return false;\n' +\
            '          }\n' +\
            '        }\n' +\
            '      }\n' +\
            '\n' +\
            '      return true;\n' +\
            '    } // bool Array_' + type + '::IsElementwiseEqual(const Array_' + type + ' &array2, const ' + type + ' threshold) const\n\n' +\
            '    // Check every element of this array against the input array. If the arrays are different\n' +\
            '    // sizes or uninitialized, return false. The threshold is between 0.0 and 1.0. If any element\n' +\
            '    // is more than a percentage different than its matching element (calulated from the maximum\n' +\
            '    // of the two), return false.\n' +\
            '    bool Array_' + type + '::IsElementwiseEqual_PercentThreshold(const Array_' + type + ' &array2, const double percentThreshold, const double absoluteThreshold) const\n' +\
            '    {\n' +\
            '      if(!this->IsEqualSize(array2))\n' +\
            '        return false;\n' +\
            '\n' +\
            '      for(s32 y=0; y<size[0]; y++) {\n' +\
            '        const ' + type + ' * const this_rowPointer = this->Pointer(y, 0);\n' +\
            '        const ' + type + ' * const array2_rowPointer = array2.Pointer(y, 0);\n' +\
            '        for(s32 x=0; x<size[1]; x++) {\n' +\
            '          const double value1 = static_cast<double>(this_rowPointer[x]);\n' +\
            '          const double value2 = static_cast<double>(array2_rowPointer[x]);\n' +\
            '          const double percentThresholdValue = percentThreshold * MAX(value1,value2);\n' +\
            '\n' +\
            '          if(abs(value1 - value2) > percentThresholdValue && abs(value1 - value2) > absoluteThreshold)\n' +\
            '            return false;\n' +\
            '        }\n' +\
            '      }\n' +\
            '\n' +\
            '      return true;\n' +\
            '    } // bool Array_' + type + '::IsElementwiseEqual_PercentThreshold(const Array_' + type + ' &array2, const double percentThreshold, const double absoluteThreshold) const\n\n'
            
        methodsString +=\
            '    // If this array or array2 are different sizes or uninitialized, then return false.\n' +\
            '    bool Array_' + type + '::IsEqualSize(const Array_' + type + ' &array2) const\n' +\
            '    {\n' +\
            '      if(!this->IsValid())\n' +\
            '        return false;\n' +\
            '\n' +\
            '      if(!array2.IsValid())\n' +\
            '        return false;\n' +\
            '\n' +\
            '      if(this->get_size(0) != array2.get_size(0) || this->get_size(1) != array2.get_size(1))\n' +\
            '        return false;\n' +\
            '\n' +\
            '      return true;\n' +\
            '    } // bool Array_' + type + '::IsEqualSize(const Array_' + type + ' &array2) const\n' +\
            '\n'            

        if includeAllMethods:
            methodsString +=\
            '#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '    void Array_' + type + '::Show(const char * const windowName, const bool waitForKeypress) const\n' +\
            '    {\n' +\
            '      assert(this->IsValid());\n' +\
            '      cv::imshow(windowName, cvMatMirror);\n' +\
            '      if(waitForKeypress) {\n' +\
            '        cv::waitKey();\n' +\
            '      }\n' +\
            '    } // void Array_' + type + '::Show(const char * const windowName, const bool waitForKeypress) const\n' +\
            '#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '\n'
            
        methodsString +=\
            '#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '    // Returns a templated cv::Mat_ that shares the same buffer with this Array_' + type + '. No data is copied.\n' +\
            '    cv::Mat_<' + type + '>& Array_' + type + '::get_CvMat_()\n' +\
            '    {\n' +\
            '      assert(this->IsValid());\n' +\
            '      return cvMatMirror;\n' +\
            '    } // cv::Mat_<' + type + '>& Array_' + type + '::get_CvMat_()\n' +\
            '#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '\n' +\
            '    // Print out the contents of this Array_' + type + '\n' +\
            '    void Array_' + type + '::Print(const char * const variableName) const\n' +\
            '    {\n' +\
            '      assert(this->IsValid());\n' +\
            '\n' +\
            '      printf("%s:\\n", variableName);\n' +\
            '      for(s32 y=0; y<size[0]; y++) {\n' +\
            '        const ' + type + ' * const rowPointer = Pointer(y, 0);\n' +\
            '        for(s32 x=0; x<size[1]; x++) {\n'

        if includeAllMethods:
            if type[0] == 'f':
                methodsString +=\
                '          printf("%f ", rowPointer[x]);\n'

            else:
                methodsString +=\
                '          printf("%d ", rowPointer[x]);\n'
        else:
            methodsString +=\
            '          rowPointer[x].Print();\n' +\
            '          printf(" ");\n'

        methodsString +=\
            '        }\n' +\
            '        printf("\\n");\n' +\
            '      }\n' +\
            '      printf("\\n");\n' +\
            '    } // void Array_' + type + '::Print() const\n' +\
            '\n' +\
            '    // If the Array_' + type + ' was constructed with the useBoundaryFillPatterns=true, then\n' +\
            '    // return if any memory was written out of bounds (via fill patterns at the\n' +\
            '    // beginning and end).  If the Array_' + type + ' was not constructed with the\n' +\
            '    // useBoundaryFillPatterns=true, this method always returns true\n' +\
            '    bool Array_' + type + '::IsValid() const\n' +\
            '    {\n' +\
            '      if(this->rawDataPointer == NULL || this->data == NULL) {\n' +\
            '        return false;\n' +\
            '      }\n' +\
            '\n' +\
            '      if(size[0] < 1 || size[1] < 1) {\n' +\
            '        return false;\n' +\
            '      }\n' +\
            '\n' +\
            '      if(useBoundaryFillPatterns) {\n' +\
            '        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);\n' +\
            '\n' +\
            '        for(s32 y=0; y<size[0]; y++) {\n' +\
            '          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||\n' +\
            '            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||\n' +\
            '            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||\n' +\
            '            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {\n' +\
            '              return false;\n' +\
            '          }\n' +\
            '        }\n' +\
            '\n' +\
            '        return true;\n' +\
            '      } else { // if(useBoundaryFillPatterns) {\n' +\
            '        return true;\n' +\
            '      } // if(useBoundaryFillPatterns) { ... else\n' +\
            '    } // bool Array_' + type + '::IsValid() const\n' +\
            '\n' +\
            '    // Set every element in the Array_' + type + ' to this value\n' +\
            '    // Returns the number of values set\n' +\
            '    s32 Array_' + type + '::Set(const ' + type + ' value)\n' +\
            '    {\n' +\
            '      assert(this->IsValid());\n' +\
            '\n' +\
            '      for(s32 y=0; y<size[0]; y++) {\n' +\
            '        ' + type + ' * restrict rowPointer = Pointer(y, 0);\n' +\
            '        for(s32 x=0; x<size[1]; x++) {\n' +\
            '          rowPointer[x] = value;\n' +\
            '        }\n' +\
            '      }\n' +\
            '\n' +\
            '      return size[0]*size[1];\n' +\
            '    } // s32 Array_' + type + '::Set(const ' + type + ' value)\n' +\
            '\n'

        if includeAllMethods:
            methodsString +=\
            '    // Parse a space-seperated string, and copy values to this Array_' + type + '.\n' +\
            '    // If the string does not contain enough elements, the remainder of the Array_' + type + ' will be filled with zeros.\n' +\
            '    // Returns the number of values set (not counting extra zeros)\n' +\
            '    s32 Array_' + type + '::Set(const char * const values)\n' +\
            '    {\n' +\
            '      assert(this->IsValid());\n' +\
            '\n' +\
            '      s32 numValuesSet = 0;\n' +\
            '\n' +\
            '      const char * startPointer = values;\n' +\
            '      char * endPointer = NULL;\n' +\
            '\n' +\
            '      for(s32 y=0; y<size[0]; y++) {\n' +\
            '        ' + type + ' * restrict rowPointer = Pointer(y, 0);\n' +\
            '        for(s32 x=0; x<size[1]; x++) {\n'
            
            if type[0] == 'f':
                methodsString +=\
                '          const ' + type + ' value = static_cast<' + type + '>(strtod(startPointer, &endPointer));\n'
            else:
                methodsString +=\
                '          const ' + type + ' value = static_cast<' + type + '>(strtol(startPointer, &endPointer, 10));\n'
            
            methodsString +=\
                '          if(startPointer != endPointer) {\n' +\
                '            rowPointer[x] = value;\n' +\
                '            numValuesSet++;\n' +\
                '          } else {\n' +\
                '            rowPointer[x] = 0;\n' +\
                '          }\n' +\
                '          startPointer = endPointer;\n' +\
                '        }\n' +\
                '      }\n' +\
                '\n' +\
                '      return numValuesSet;\n' +\
                '    } // s32 Array_' + type + '::Set(const char * const values)\n' +\
                '\n'


        methodsString +=\
            '    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}\n' +\
            '    s32 Array_' + type + '::get_size(s32 dimension) const\n' +\
            '    {\n' +\
            '      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);\n' +\
            '\n' +\
            '      if(dimension > 1 || dimension < 0)\n' +\
            '        return 0;\n' +\
            '\n' +\
            '      return size[dimension];\n' +\
            '    } // s32 Array_' + type + '::get_size(s32 dimension) const\n' +\
            '\n' +\
            '    s32 Array_' + type + '::get_stride() const\n' +\
            '    {\n' +\
            '      return stride;\n' +\
            '    } // s32 Array_' + type + '::get_stride() const\n' +\
            '\n' +\
            '    void* Array_' + type + '::get_rawDataPointer()\n' +\
            '    {\n' +\
            '      return rawDataPointer;\n' +\
            '    } // void* Array_' + type + '::get_rawDataPointer()\n' +\
            '\n' +\
            '    const void* Array_' + type + '::get_rawDataPointer() const\n' +\
            '    {\n' +\
            '      return rawDataPointer;\n' +\
            '    } // const void* Array_' + type + '::get_rawDataPointer() const\n' +\
            '\n' +\
            '    void Array_' + type + '::Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)\n' +\
            '    {\n' +\
            '      assert(numCols > 0 && numRows > 0 && dataLength > 0);\n' +\
            '\n' +\
            '      this->useBoundaryFillPatterns = useBoundaryFillPatterns;\n' +\
            '\n' +\
            '      if(!rawData) {\n' +\
            '#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH\n' +\
            '        DASError("Anki.Array2d.initialize", "input data buffer is NULL");\n' +\
            '#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH\n' +\
            '        InvalidateArray();\n' +\
            '        return;\n' +\
            '      }\n' +\
            '\n' +\
            '      this->rawDataPointer = rawData;\n' +\
            '\n' +\
            '      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;\n' +\
            '      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));\n' +\
            '      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;\n' +\
            '\n' +\
            '      if(requiredBytes > dataLength) {\n' +\
            '#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH\n' +\
            '        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);\n' +\
            '#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH\n' +\
            '        InvalidateArray();\n' +\
            '        return;\n' +\
            '      }\n' +\
            '\n' +\
            '      this->size[0] = numRows;\n' +\
            '      this->size[1] = numCols;\n' +\
            '\n' +\
            '      if(useBoundaryFillPatterns) {\n' +\
            '        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);\n' +\
            '        this->data = reinterpret_cast<' + type + '*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );\n' +\
            '        for(s32 y=0; y<size[0]; y++) {\n' +\
            '          // Add the fill patterns just before the data on each line\n' +\
            '          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;\n' +\
            '          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;\n' +\
            '\n' +\
            '          // And also just after the data (including normal byte-alignment padding)\n' +\
            '          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;\n' +\
            '          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;\n' +\
            '        }\n' +\
            '      } else {\n' +\
            '        this->data = reinterpret_cast<' + type + '*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );\n' +\
            '      }\n' +\
            '\n' +\
            '#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '      cvMatMirror = cv::Mat_<' + type + '>(size[0], size[1], data, stride);\n' +\
            '#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '    } // Array_' + type + '::Initialize()\n' +\
            '\n' +\
            '    // Set all the buffers and sizes to zero, to signal an invalid array\n' +\
            '    void Array_' + type + '::InvalidateArray()\n' +\
            '    {\n' +\
            '      this->size[0] = 0;\n' +\
            '      this->size[1] = 0;\n' +\
            '      this->stride = 0;\n' +\
            '      this->data = NULL;\n' +\
            '      this->rawDataPointer = NULL;\n' +\
            '    } // void Array_' + type + '::InvalidateArray()\n\n' +\
            '    // Factory method to create an Array_' + type + ' from the heap. The data of the returned Array_' + type + ' must be freed by the user.\n' +\
            '    // This is separate from the normal constructor, as Array_' + type + ' objects are not supposed to manage memory\n' +\
            '    Array_' + type + ' AllocateArrayFromHeap_' + type + '(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)\n' +\
            '    {\n' +\
            '      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_' + type + '::ComputeMinimumRequiredMemory(numRows, numCols, useBoundaryFillPatterns); // The required memory, plus a bit more\n' +\
            '\n' +\
            '      Array_' + type + ' mat(numRows, numCols, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);\n' +\
            '\n' +\
            '      return mat;\n' +\
            '    } // Array_' + type + ' AllocateArrayFromHeap_' + type + '(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)\n\n\n'

    return methodsString

def GenerateAndWriteFile(filename = '../src/embedded/array2d.cpp'):
    topString = __GenerateTopOfFile()

    methodsDefinitions  = __GenerateDefinitions(['u8', 's8', 'u16', 's16', 'u32', 's32', 'u64', 's64', 'f32', 'f64'], True)
    methodsDefinitions += __GenerateDefinitions(['Point_s16'], False)

    bottomString = __GenerateBottomOfFile()

    f = open(filename, 'w')
    f.write(topString)
    f.write(methodsDefinitions)
    f.write(bottomString)

    f.close()

if __name__ == "__main__":
    GenerateAndWriteFile()