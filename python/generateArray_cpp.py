def __GenerateTopOfFile():
    topString = \
        '/*\n\n\n\n\n\n\n\n\n\nThis file was automatically generated by the python script generateArray_cpp.py. Rather than editing this file, edit that script, then run "python generateArray_cpp.py".\n\n\n\n\n\n\n\n\n\n*/\n\n';
    
    topString += \
        '#include "anki/embeddedCommon.h"\n' +\
        '\n' +\
        'namespace Anki\n' +\
        '{\n' +\
        '  namespace Embedded\n' +\
        '  {\n'
        
    return topString

def __GenerateBottomOfFile():
    bottomString = \
        '  } // namespace Embedded\n' +\
        '} // namespace Anki'
        
    return bottomString
    
def __GenerateDefinitions(whichTypes, includeAllMethods):
    '''
    This function creates the definitions for the Array Class. Basic types (like int or long long) should have includeAllMethods==true, while non-basic types should have includeAllMethods == false
    '''
    methodsString = ''
    
    for type in whichTypes:
        methodsString +=\
            '    s32 Array_' + type + '::ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns)\n' +\
            '    {\n' +\
            '      assert(numCols > 0);\n' +\
            '      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? (HEADER_LENGTH+FOOTER_LENGTH) : 0);\n' +\
            '      return static_cast<s32>(RoundUp<size_t>(sizeof(' + type + ')*numCols, MEMORY_ALIGNMENT)) + extraBoundaryPatternBytes;\n' +\
            '    }\n' +\
            '\n' +\
            '    s32 Array_' + type + '::ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns)\n' +\
            '    {\n' +\
            '      assert(numCols > 0 && numRows > 0);\n' +\
            '      return numRows * Array_' + type + '::ComputeRequiredStride(numCols, useBoundaryFillPatterns);\n' +\
            '    }\n' +\
            '\n' +\
            '    Array_' + type + '::Array_' + type + '()\n' +\
            '    {\n' +\
            '      invalidateArray();\n' +\
            '    }\n' +\
            '\n' +\
            '    // Constructor for a Array_' + type + ', pointing to user-allocated data. If the pointer to *data is not\n' +\
            '    // aligned to MEMORY_ALIGNMENT, this Array_' + type + ' will start at the next aligned location.\n' +\
            '    // Unfortunately, this is more restrictive than most matrix libraries, and as an example,\n' +\
            '    // it may make it hard to convert from OpenCV to Array_' + type + ', though the reverse is trivial.\n' +\
            '    Array_' + type + '::Array_' + type + '(s32 numRows, s32 numCols, void * data, s32 dataLength, bool useBoundaryFillPatterns)\n' +\
            '      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))\n' +\
            '    {\n' +\
            '      assert(numCols > 0 && numRows > 0 && dataLength > 0);\n' +\
            '\n' +\
            '      initialize(numRows,\n' +\
            '        numCols,\n' +\
            '        data,\n' +\
            '        dataLength,\n' +\
            '        useBoundaryFillPatterns);\n' +\
            '    }\n' +\
            '\n' +\
            '    Array_' + type + '::Array_' + type + '(s32 numRows, s32 numCols, MemoryStack &memory, bool useBoundaryFillPatterns)\n' +\
            '      : stride(ComputeRequiredStride(numCols, useBoundaryFillPatterns))\n' +\
            '    {\n' +\
            '      assert(numCols > 0 && numRows > 0);\n' +\
            '\n' +\
            '      const s32 extraBoundaryPatternBytes = (useBoundaryFillPatterns ? static_cast<s32>(MEMORY_ALIGNMENT) : 0);\n' +\
            '      const s32 numBytesRequested = numRows * this->stride + extraBoundaryPatternBytes;\n' +\
            '      s32 numBytesAllocated = 0;\n' +\
            '\n' +\
            '      void * allocatedBuffer = memory.Allocate(numBytesRequested, &numBytesAllocated);\n' +\
            '\n' +\
            '      initialize(numRows,\n' +\
            '        numCols,\n' +\
            '        reinterpret_cast<' + type + '*>(allocatedBuffer),\n' +\
            '        numBytesAllocated,\n' +\
            '        useBoundaryFillPatterns);\n' +\
            '    }\n' +\
            '\n' +\
            '#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n'
            
        if includeAllMethods:
            methodsString +=\
            '    void Array_' + type + '::Show(const char * const windowName, const bool waitForKeypress) const\n' +\
            '    {\n' +\
            '      assert(this->IsValid());\n' +\
            '      cv::imshow(windowName, cvMatMirror);\n' +\
            '      if(waitForKeypress) {\n' +\
            '        cv::waitKey();\n' +\
            '      }\n' +\
            '    }\n' +\
            '\n'
            
        methodsString +=\
            '    // Returns a templated cv::Mat_ that shares the same buffer with this Array_' + type + '. No data is copied.\n' +\
            '    cv::Mat_<' + type + '>& Array_' + type + '::get_CvMat_()\n' +\
            '    {\n' +\
            '      assert(this->IsValid());\n' +\
            '      return cvMatMirror;\n' +\
            '    }\n' +\
            '#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '\n' +\
            '    // Print out the contents of this Array_' + type + '\n' +\
            '    void Array_' + type + '::Print() const\n' +\
            '    {\n' +\
            '      assert(this->IsValid());\n' +\
            '\n' +\
            '      for(s32 y=0; y<size[0]; y++) {\n' +\
            '        const ' + type + ' * rowPointer = Pointer(y, 0);\n' +\
            '        for(s32 x=0; x<size[1]; x++) {\n'
            
        if includeAllMethods:    
            methodsString +=\
            '          printf("%d ", rowPointer[x]);\n'
        else:
            methodsString +=\
            '          rowPointer[x].Print();\n' +\
            '          printf(" ");\n'
            
        methodsString +=\
            '        }\n' +\
            '        printf("\\n");\n' +\
            '      }\n' +\
            '    }\n' +\
            '\n' +\
            '    // If the Array_' + type + ' was constructed with the useBoundaryFillPatterns=true, then\n' +\
            '    // return if any memory was written out of bounds (via fill patterns at the\n' +\
            '    // beginning and end).  If the Array_' + type + ' was not constructed with the\n' +\
            '    // useBoundaryFillPatterns=true, this method always returns true\n' +\
            '    bool Array_' + type + '::IsValid() const\n' +\
            '    {\n' +\
            '      if(this->rawDataPointer == NULL || this->data == NULL) {\n' +\
            '        return false;\n' +\
            '      }\n' +\
            '\n' +\
            '      if(size[0] < 1 || size[1] < 1) {\n' +\
            '        return false;\n' +\
            '      }\n' +\
            '\n' +\
            '      if(useBoundaryFillPatterns) {\n' +\
            '        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1],false);\n' +\
            '\n' +\
            '        for(s32 y=0; y<size[0]; y++) {\n' +\
            '          if((reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0]) != FILL_PATTERN_START ||\n' +\
            '            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1]) != FILL_PATTERN_START ||\n' +\
            '            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0]) != FILL_PATTERN_END ||\n' +\
            '            (reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1]) != FILL_PATTERN_END) {\n' +\
            '              return false;\n' +\
            '          }\n' +\
            '        }\n' +\
            '\n' +\
            '        return true;\n' +\
            '      } else { // if(useBoundaryFillPatterns) {\n' +\
            '        return true;\n' +\
            '      } // if(useBoundaryFillPatterns) { ... else\n' +\
            '    }\n' +\
            '\n' +\
            '    // Set every element in the Array_' + type + ' to this value\n' +\
            '    // Returns the number of values set\n' +\
            '    s32 Array_' + type + '::Set(const ' + type + ' value)\n' +\
            '    {\n' +\
            '      assert(this->IsValid());\n' +\
            '\n' +\
            '      for(s32 y=0; y<size[0]; y++) {\n' +\
            '        ' + type + ' * restrict rowPointer = Pointer(y, 0);\n' +\
            '        for(s32 x=0; x<size[1]; x++) {\n' +\
            '          rowPointer[x] = value;\n' +\
            '        }\n' +\
            '      }\n' +\
            '\n' +\
            '      return size[0]*size[1];\n' +\
            '    }\n' +\
            '\n'
            
        if includeAllMethods:
            methodsString +=\
            '    // Parse a space-seperated string, and copy values to this Array_' + type + '.\n' +\
            '    // If the string does not contain enough elements, the remainder of the Array_' + type + ' will be filled with zeros.\n' +\
            '    // Returns the number of values set (not counting extra zeros)\n' +\
            '    s32 Array_' + type + '::Set(const char * const values)\n' +\
            '    {\n' +\
            '      assert(this->IsValid());\n' +\
            '\n' +\
            '      s32 numValuesSet = 0;\n' +\
            '\n' +\
            '      const char * startPointer = values;\n' +\
            '      char * endPointer = NULL;\n' +\
            '\n' +\
            '      for(s32 y=0; y<size[0]; y++) {\n' +\
            '        ' + type + ' * restrict rowPointer = Pointer(y, 0);\n' +\
            '        for(s32 x=0; x<size[1]; x++) {\n' +\
            '          ' + type + ' value = static_cast<' + type + '>(strtol(startPointer, &endPointer, 10));\n' +\
            '          if(startPointer != endPointer) {\n' +\
            '            rowPointer[x] = value;\n' +\
            '            numValuesSet++;\n' +\
            '          } else {\n' +\
            '            rowPointer[x] = 0;\n' +\
            '          }\n' +\
            '          startPointer = endPointer;\n' +\
            '        }\n' +\
            '      }\n' +\
            '\n' +\
            '      return numValuesSet;\n' +\
            '    }\n' +\
            '\n'
            
            
        methodsString +=\
            '    // Similar to Matlab size(matrix, dimension), and dimension is in {0,1}\n' +\
            '    s32 Array_' + type + '::get_size(s32 dimension) const\n' +\
            '    {\n' +\
            '      assert(dimension >= 0 && this->rawDataPointer != NULL && this->data != NULL);\n' +\
            '\n' +\
            '      if(dimension > 1 || dimension < 0)\n' +\
            '        return 0;\n' +\
            '\n' +\
            '      return size[dimension];\n' +\
            '    }\n' +\
            '\n' +\
            '    s32 Array_' + type + '::get_stride() const\n' +\
            '    {\n' +\
            '      return stride;\n' +\
            '    }\n' +\
            '\n' +\
            '    void* Array_' + type + '::get_rawDataPointer()\n' +\
            '    {\n' +\
            '      return rawDataPointer;\n' +\
            '    }\n' +\
            '\n' +\
            '    const void* Array_' + type + '::get_rawDataPointer() const\n' +\
            '    {\n' +\
            '      return rawDataPointer;\n' +\
            '    }\n' +\
            '\n' +\
            '    void Array_' + type + '::initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns)\n' +\
            '    {\n' +\
            '      assert(numCols > 0 && numRows > 0 && dataLength > 0);\n' +\
            '\n' +\
            '      this->useBoundaryFillPatterns = useBoundaryFillPatterns;\n' +\
            '\n' +\
            '      if(!rawData) {\n' +\
            '#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH\n' +\
            '        DASError("Anki.Array2d.initialize", "input data buffer is NULL");\n' +\
            '#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH\n' +\
            '        invalidateArray();\n' +\
            '        return;\n' +\
            '      }\n' +\
            '\n' +\
            '      this->rawDataPointer = rawData;\n' +\
            '\n' +\
            '      const size_t extraBoundaryPatternBytes = useBoundaryFillPatterns ? static_cast<size_t>(HEADER_LENGTH) : 0;\n' +\
            '      const s32 extraAlignmentBytes = static_cast<s32>(RoundUp<size_t>(reinterpret_cast<size_t>(rawData)+extraBoundaryPatternBytes, MEMORY_ALIGNMENT) - extraBoundaryPatternBytes - reinterpret_cast<size_t>(rawData));\n' +\
            '      const s32 requiredBytes = ComputeRequiredStride(numCols,useBoundaryFillPatterns)*numRows + extraAlignmentBytes;\n' +\
            '\n' +\
            '      if(requiredBytes > dataLength) {\n' +\
            '#if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH\n' +\
            '        DASError("Anki.Array2d.initialize", "Input data buffer is not large enough. %d bytes is required.", requiredBytes);\n' +\
            '#endif // #if ANKI_DEBUG_LEVEL == ANKI_DEBUG_HIGH\n' +\
            '        invalidateArray();\n' +\
            '        return;\n' +\
            '      }\n' +\
            '\n' +\
            '      this->size[0] = numRows;\n' +\
            '      this->size[1] = numCols;\n' +\
            '\n' +\
            '      if(useBoundaryFillPatterns) {\n' +\
            '        const s32 strideWithoutFillPatterns = ComputeRequiredStride(size[1], false);\n' +\
            '        this->data = reinterpret_cast<' + type + '*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes + HEADER_LENGTH );\n' +\
            '        for(s32 y=0; y<size[0]; y++) {\n' +\
            '          // Add the fill patterns just before the data on each line\n' +\
            '          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[0] = FILL_PATTERN_START;\n' +\
            '          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride - HEADER_LENGTH)[1] = FILL_PATTERN_START;\n' +\
            '\n' +\
            '          // And also just after the data (including normal byte-alignment padding)\n' +\
            '          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[0] = FILL_PATTERN_END;\n' +\
            '          reinterpret_cast<u32*>( reinterpret_cast<char*>(this->data) + y*stride + strideWithoutFillPatterns)[1] = FILL_PATTERN_END;\n' +\
            '        }\n' +\
            '      } else {\n' +\
            '        this->data = reinterpret_cast<' + type + '*>( reinterpret_cast<char*>(rawData) + extraAlignmentBytes );\n' +\
            '      }\n' +\
            '\n' +\
            '#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '      cvMatMirror = cv::Mat_<' + type + '>(size[0], size[1], data, stride);\n' +\
            '#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '    } // Array_' + type + '::initialize()\n' +\
            '\n' +\
            '    // Set all the buffers and sizes to zero, to signal an invalid array\n' +\
            '    void Array_' + type + '::invalidateArray()\n' +\
            '    {\n' +\
            '      this->size[0] = 0;\n' +\
            '      this->size[1] = 0;\n' +\
            '      this->stride = 0;\n' +\
            '      this->data = NULL;\n' +\
            '      this->rawDataPointer = NULL;\n' +\
            '    }\n\n\n'

    return methodsString            
            
def GenerateAndWriteFile(filename = '../src/embedded/array2d.cpp'):
    topString = __GenerateTopOfFile()
    
    methodsDefinitions  = __GenerateDefinitions(['u8', 's8', 'u16', 's16', 'u32', 's32', 'u64', 's64', 'f32', 'f64'], True)
    methodsDefinitions += __GenerateDefinitions(['Point_s16'], False)
    
    bottomString = __GenerateBottomOfFile()
    
    f = open(filename, 'w')
    f.write(topString)
    f.write(methodsDefinitions)
    f.write(bottomString)
    
    f.close()
    
if __name__ == "__main__":    
    GenerateAndWriteFile()