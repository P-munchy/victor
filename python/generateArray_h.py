"""
This file generated a c++ file, by automatically "instantiating templates"
To add some lines to this file, find replace (without the quotes) "\r\n" into "\\n' +\\\r\n            '"
"""

def __GenerateTopOfFile():
    topString = \
        '/*\n\n\n\n\n\n\n\n\n\nThis file was automatically generated by the python script generateArray_h.py. Rather than editing this file, edit that script, then run "python generateArray_h.py".\n\n\n\n\n\n\n\n\n\n*/\n\n';

    topString += \
        '#ifndef _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_\n' +\
        '#define _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_\n' +\
        '\n' +\
        '#include "anki/embeddedCommon/config.h"\n' +\
        '#include "anki/embeddedCommon/utilities.h"\n' +\
        '#include "anki/embeddedCommon/memory.h"\n' +\
        '#include "anki/embeddedCommon/DASlight.h"\n' +\
        '#include "anki/embeddedCommon/dataStructures.h"\n' +\
        '#include "anki/embeddedCommon/point.h"\n' +\
        '\n' +\
        '#include <assert.h>\n' +\
        '#include <stdio.h>\n' +\
        '#include <stdlib.h>\n' +\
        '\n' +\
        '#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
        '#include "opencv2/opencv.hpp"\n' +\
        '#endif\n' +\
        '\n' +\
        'namespace Anki\n' +\
        '{\n' +\
        '  namespace Embedded\n' +\
        '  {\n'

    return topString

def __GenerateBottomOfFile():
    bottomString = \
        '    } // namespace Embedded\n' +\
        '} //namespace Anki\n' +\
        '\n' +\
        '#endif // _ANKICORETECHEMBEDDED_COMMON_ARRAY2D_H_\n'

    return bottomString

def __GenerateDeclarations(whichTypes, includeAllMethods):
    '''
    This function creates the declarations for the Array Class. Basic types (like int or long long) should have includeAllMethods==true, while non-basic types should have includeAllMethods == false
    '''

    methodsString = ''

    for type in whichTypes:
        methodsString +=\
            '    class Array_' + type + '\n' +\
            '    {\n' +\
            '    public:\n' +\
            '      static s32 ComputeRequiredStride(const s32 numCols, const bool useBoundaryFillPatterns);\n' +\
            '\n' +\
            '      static s32 ComputeMinimumRequiredMemory(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns);\n' +\
            '\n' +\
            '      Array_' + type + '();\n' +\
            '\n' +\
            '      // Constructor for a Array_' + type + ', pointing to user-allocated data. If the pointer to *data is not\n' +\
            '      // aligned to MEMORY_ALIGNMENT, this Array_' + type + ' will start at the next aligned location.\n' +\
            '      // Unfortunately, this is more restrictive than most matrix libraries, and as an example,\n' +\
            '      // it may make it hard to convert from OpenCV to Array_' + type + ', though the reverse is trivial.\n' +\
            '      Array_' + type + '(const s32 numRows, const s32 numCols, void * const data, const s32 dataLength, const bool useBoundaryFillPatterns=false);\n' +\
            '\n' +\
            '      // Constructor for a Array_' + type + ', pointing to user-allocated MemoryStack\n' +\
            '      Array_' + type + '(const s32 numRows, const s32 numCols, MemoryStack &memory, const bool useBoundaryFillPatterns=false);\n' +\
            '\n' +\
            '      // Pointer to the data, at a given (y,x) location\n' +\
            '      const inline ' + type + '* Pointer(const s32 index0, const s32 index1) const\n' +\
            '      {\n' +\
            '        assert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1] &&\n' +\
            '          this->rawDataPointer != NULL && this->data != NULL);\n' +\
            '\n' +\
            '        return reinterpret_cast<const ' + type + '*>( reinterpret_cast<const char*>(this->data) +\n' +\
            '          index1*sizeof(' + type + ') + index0*stride );\n' +\
            '      }\n' +\
            '\n' +\
            '      // Pointer to the data, at a given (y,x) location\n' +\
            '      inline ' + type + '* Pointer(const s32 index0, const s32 index1)\n' +\
            '      {\n' +\
            '        assert(index0 >= 0 && index1 >= 0 && index0 < size[0] && index1 < size[1] &&\n' +\
            '          this->rawDataPointer != NULL && this->data != NULL);\n' +\
            '\n' +\
            '        return reinterpret_cast<' + type + '*>( reinterpret_cast<char*>(this->data) +\n' +\
            '          index1*sizeof(' + type + ') + index0*stride );\n' +\
            '      }\n' +\
            '\n' +\
            '      // Pointer to the data, at a given (y,x) location\n' +\
            '      const inline ' + type + '* Pointer(const Point_s16 &point) const\n' +\
            '      {\n' +\
            '        return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));\n' +\
            '      }\n' +\
            '\n' +\
            '      // Pointer to the data, at a given (y,x) location\n' +\
            '      inline ' + type + '* Pointer(const Point_s16 &point)\n' +\
            '      {\n' +\
            '        return Pointer(static_cast<s32>(point.y), static_cast<s32>(point.x));\n' +\
            '      }\n' +\
            '\n' +\
            '#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '      // Returns a templated cv::Mat_ that shares the same buffer with this Array_' + type + '. No data is copied.\n' +\
            '      cv::Mat_<' + type + '>& get_CvMat_();\n' +\
            '#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n\n' 

        if includeAllMethods:
            methodsString +=\
            '#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '      void Show(const char * const windowName, const bool waitForKeypress) const;\n' +\
            '#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '\n' +\
            '      // Check every element of this array against the input array. If the arrays are different\n' +\
            '      // sizes, uninitialized, or if any element is more different than the threshold, then\n' +\
            '      // return false.\n' +\
            '      bool IsElementwiseEqual(const Array_' + type + ' &array2, const ' + type + ' threshold = static_cast<' + type + '>(0.0001)) const;\n' +\
            '\n' +\
            '      // Check every element of this array against the input array. If the arrays are different\n' +\
            '      // sizes or uninitialized, return false. The percentThreshold is between 0.0 and 1.0. To\n' +\
            '      // return false, an element must fail both thresholds. The percent threshold fails if an\n' +\
            '      // element is more than a percentage different than its matching element (calulated from the\n' +\
            '      // maximum of the two).\n' +\
            '      bool IsElementwiseEqual_PercentThreshold(const Array_' + type + ' &array2, const double percentThreshold = 0.01, const double absoluteThreshold = 0.0001) const;\n' +\
            '\n'

        methodsString +=\
            '      // If this array or array2 are different sizes or uninitialized, then return false.\n' +\
            '      bool IsEqualSize(const Array_' + type + ' &array2) const;\n' +\
            '\n' +\
            '      // Print out the contents of this Array_' + type + '\n' +\
            '      void Print(const char * const variableName = "Array_' + type + '") const;\n' +\
            '\n' +\
            '      // If the Array_' + type + ' was constructed with the useBoundaryFillPatterns=true, then\n' +\
            '      // return if any memory was written out of bounds (via fill patterns at the\n' +\
            '      // beginning and end).  If the Array_' + type + ' was not constructed with the\n' +\
            '      // useBoundaryFillPatterns=true, this method always returns true\n' +\
            '      bool IsValid() const;\n' +\
            '\n' +\
            '      // Set every element in the Array_' + type + ' to this value\n' +\
            '      // Returns the number of values set\n' +\
            '      s32 Set(const ' + type + ' value);\n' +\
            '\n'

        if includeAllMethods:
            methodsString +=\
                '      // Parse a space-seperated string, and copy values to this Array_' + type + '.\n' +\
                '      // If the string does not contain enough elements, the remainder of the Array_' + type + ' will be filled with zeros.\n' +\
                '      // Returns the number of values set (not counting extra zeros)\n' +\
                '      s32 Set(const char * const values);\n' +\
                '\n' +\
                '      // Similar to Matlab''s size(matrix, dimension), and dimension is in {0,1}\n'

        methodsString +=\
            '      s32 get_size(s32 dimension) const;\n' +\
            '\n' +\
            '      s32 get_stride() const;\n' +\
            '\n' +\
            '      void* get_rawDataPointer();\n' +\
            '\n' +\
            '      const void* get_rawDataPointer() const;\n' +\
            '\n' +\
            '    protected:\n' +\
            '      // Bit-inverse of MemoryStack patterns. The pattern will be put twice at\n' +\
            '      // the beginning and end of each line.\n' +\
            '      static const u32 FILL_PATTERN_START = 0X5432EF76;\n' +\
            '      static const u32 FILL_PATTERN_END = 0X7610FE76;\n' +\
            '\n' +\
            '      static const s32 HEADER_LENGTH = 8;\n' +\
            '      static const s32 FOOTER_LENGTH = 8;\n' +\
            '\n' +\
            '      s32 size[2];\n' +\
            '      s32 stride;\n' +\
            '      bool useBoundaryFillPatterns;\n' +\
            '\n' +\
            '      ' + type + ' * data;\n' +\
            '\n' +\
            '      // To enforce alignment, rawDataPointer may be slightly before ' + type + ' * data.\n' +\
            '      // If the inputted data buffer was from malloc, this is the pointer that\n' +\
            '      // should be used to free.\n' +\
            '      void * rawDataPointer;\n' +\
            '\n' +\
            '#if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '      cv::Mat_<' + type + '> cvMatMirror;\n' +\
            '#endif // #if defined(ANKICORETECHEMBEDDED_USE_OPENCV)\n' +\
            '\n' +\
            '      void Initialize(const s32 numRows, const s32 numCols, void * const rawData, const s32 dataLength, const bool useBoundaryFillPatterns);\n' +\
            '\n' +\
            '      void InvalidateArray(); // Set all the buffers and sizes to zero, to signal an invalid array\n' +\
            '\n' +\
            '    private:\n' +\
            '      //Array_' + type + ' & operator= (const Array_' + type + ' & rightHandSide); // In the future, assignment may not be allowed\n' +\
            '    }; // class Array_' + type + '\n' +\
            '\n' +\
            '    // Factory method to create an Array_' + type + ' from the heap. The data of the returned Array_' + type + ' must be freed by the user.\n' +\
            '    // This is separate from the normal constructor, as Array_' + type + ' objects are not supposed to manage memory\n' +\
            '    Array_' + type + ' AllocateArrayFromHeap_' + type + '(const s32 numRows, const s32 numCols, const bool useBoundaryFillPatterns=false);\n\n\n'

    return methodsString

def GenerateAndWriteFile(filename = '../include/anki/embeddedCommon/array2d.h'):
    topString = __GenerateTopOfFile()

    methodsDeclarations  = __GenerateDeclarations(['u8', 's8', 'u16', 's16', 'u32', 's32', 'u64', 's64', 'f32', 'f64'], True)
    methodsDeclarations += __GenerateDeclarations(['Point_s16', 'Point_f32', 'Point_f64'], False)

    bottomString = __GenerateBottomOfFile()

    f = open(filename, 'w')
    f.write(topString)
    f.write(methodsDeclarations)
    f.write(bottomString)

    f.close()

if __name__ == "__main__":
    GenerateAndWriteFile()