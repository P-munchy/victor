"""
This file generated a c++ file, by automatically "instantiating templates"
To add some lines to this file, find replace (without the quotes) "\r\n" into "\\n' +\\\r\n            '"
"""

def __GenerateTopOfFile():
    topString = \
        '/*\n\n\n\n\n\n\n\n\n\nThis file was automatically generated by the python script generateFixedLengthList_cpp.py. Rather than editing this file, edit that script, then run "python generateFixedLengthList_cpp.py".\n\n\n\n\n\n\n\n\n\n*/\n\n';

    topString += \
        '#include "anki/embeddedCommon.h"\n' +\
        '\n' +\
        'namespace Anki\n' +\
        '{\n' +\
        '  namespace Embedded\n' +\
        '  {\n'

    return topString

def __GenerateBottomOfFile():
    bottomString = \
        '  } // namespace Embedded\n' +\
        '} // namespace Anki'

    return bottomString

def __GenerateDefinitions(whichTypes, includeAllMethods):
    '''
    This function creates the definitions for the Array Class. Basic types (like int or long long) should have includeAllMethods==true, while non-basic types should have includeAllMethods == false
    '''
    methodsString = ''

    for type in whichTypes:
        methodsString +=\
            '    FixedLengthList_' + type + '::FixedLengthList_' + type + '()\n' +\
            '      : Array_' + type + '(), capacityUsed(0)\n' +\
            '    {\n' +\
            '    } // FixedLengthList_' + type + '::FixedLengthList_' + type + '()\n' +\
            '\n' +\
            '    FixedLengthList_' + type + '::FixedLengthList_' + type + '(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns)\n' +\
            '      : Array_' + type + '(1, maximumSize, data, dataLength, useBoundaryFillPatterns), capacityUsed(0)\n' +\
            '    {\n' +\
            '    } // FixedLengthList_' + type + '::FixedLengthList_' + type + '(s32 maximumSize, void * data, s32 dataLength, bool useBoundaryFillPatterns)\n' +\
            '\n' +\
            '    FixedLengthList_' + type + '::FixedLengthList_' + type + '(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns)\n' +\
            '      : Array_' + type + '(1, maximumSize, memory, useBoundaryFillPatterns), capacityUsed(0)\n' +\
            '    {\n' +\
            '    } // FixedLengthList_' + type + '::FixedLengthList_' + type + '(s32 maximumSize, MemoryStack &memory, bool useBoundaryFillPatterns)\n' +\
            '\n' +\
            '    bool FixedLengthList_' + type + '::IsValid() const\n' +\
            '    {\n' +\
            '      if(capacityUsed > this->get_maximumSize()) {\n' +\
            '        return false;\n' +\
            '      }\n' +\
            '\n' +\
            '      return Array_' + type + '::IsValid();\n' +\
            '    } // bool FixedLengthList_' + type + '::IsValid() const\n' +\
            '\n' +\
            '    Result FixedLengthList_' + type + '::PushBack(const ' + type + ' &value)\n' +\
            '    {\n' +\
            '      if(capacityUsed >= this->get_maximumSize()) {\n' +\
            '        return RESULT_FAIL;\n' +\
            '      }\n' +\
            '\n' +\
            '      *this->Pointer(capacityUsed) = value;\n' +\
            '      capacityUsed++;\n' +\
            '\n' +\
            '      return RESULT_OK;\n' +\
            '    } // Result FixedLengthList_' + type + '::PushBack(const ' + type + ' &value)\n' +\
            '\n' +\
            '    ' + type + ' FixedLengthList_' + type + '::PopBack()\n' +\
            '    {\n' +\
            '      if(capacityUsed == 0) {\n' +\
            '        return *this->Pointer(0);\n' +\
            '      }\n' +\
            '\n' +\
            '      const ' + type + ' value = *this->Pointer(capacityUsed-1);\n' +\
            '      capacityUsed--;\n' +\
            '\n' +\
            '      return value;\n' +\
            '    } // ' + type + ' FixedLengthList_' + type + '::PopBack()\n' +\
            '\n' +\
            '    void FixedLengthList_' + type + '::Clear()\n' +\
            '    {\n' +\
            '      this->capacityUsed = 0;\n' +\
            '    } // void FixedLengthList_' + type + '::Clear()\n' +\
            '\n' +\
            '    // Does this ever need to be declared explicitly?\n' +\
            '    /*FixedLengthList_' + type + '& FixedLengthList_' + type + '::operator= (const FixedLengthList_' + type + ' & rightHandSide)\n' +\
            '    {\n' +\
            '      Array_' + type + '::operator=(static_cast<Array_' + type + '>(rightHandSide));\n' +\
            '      this->capacityUsed = rightHandSide.capacityUsed;\n' +\
            '\n' +\
            '      return *this;\n' +\
            '    }*/ // FixedLengthList_' + type + '& FixedLengthList_' + type + '::operator= (const FixedLengthList_' + type + ' & rightHandSide)\n\n' +\
            '    s32 FixedLengthList_' + type + '::get_maximumSize() const\n' +\
            '    {\n' +\
            '      return Array_' + type + '::get_size(1);\n' +\
            '    } // s32 FixedLengthList_' + type + '::get_maximumSize() const\n' +\
            '\n' +\
            '    s32 FixedLengthList_' + type + '::get_size() const\n' +\
            '    {\n' +\
            '      return capacityUsed;\n' +\
            '    } // s32 FixedLengthList_' + type + '::get_size() const\n' +\
            '\n' +\
            '    FixedLengthList_' + type + ' AllocateFixedLengthListFromHeap_' + type + '(s32 maximumSize, bool useBoundaryFillPatterns)\n' +\
            '    {\n' +\
            '      // const s32 stride = FixedLengthList_' + type + '::ComputeRequiredStride(maximumSize, useBoundaryFillPatterns);\n' +\
            '      const s32 requiredMemory = 64 + 2*MEMORY_ALIGNMENT + Array_' + type + '::ComputeMinimumRequiredMemory(1, maximumSize, useBoundaryFillPatterns); // The required memory, plus a bit more\n' +\
            '\n' +\
            '      FixedLengthList_' + type + ' mat(maximumSize, calloc(requiredMemory, 1), requiredMemory, useBoundaryFillPatterns);\n' +\
            '\n' +\
            '      return mat;\n' +\
            '    } // FixedLengthList_' + type + ' AllocateFixedLengthListFromHeap_' + type + '(s32 maximumSize, bool useBoundaryFillPatterns)\n\n\n'

    return methodsString

def GenerateAndWriteFile(filename = '../src/embedded/fixedLengthList.cpp'):
    topString = __GenerateTopOfFile()

    methodsDefinitions = __GenerateDefinitions(['Point_s16', 'Point_f32', 'Point_f64'], False)

    bottomString = __GenerateBottomOfFile()

    f = open(filename, 'w')
    f.write(topString)
    f.write(methodsDefinitions)
    f.write(bottomString)

    f.close()

if __name__ == "__main__":
    GenerateAndWriteFile()