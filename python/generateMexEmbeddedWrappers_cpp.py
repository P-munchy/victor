
def __GenerateTopOfFile():
    topString = \
        '/*\n\n\n\n\n\n\n\n\n\nThis file was automatically generated by the python script generateMexEmbeddedWrappers_cpp.py. Rather than editing this file, edit that script, then run "python generateMexEmbeddedWrappers_cpp.py".\n\n\n\n\n\n\n\n\n\n*/\n\n';

    topString += \
            '#include "mexEmbeddedWrappers.h"\n' +\
            '#include <vector>\n' +\
            '#include <string>\n' +\
            '#include <sstream>\n' +\
            '\n' +\
            'namespace Anki\n' +\
            '{\n' +\
            '  namespace Embedded\n' +\
            '  {\n' +\
                        '    mxClassID convertToMatlabType(const char * const typeName, const size_t byteDepth)\n' +\
            '    {\n' +\
            '      //mexPrintf("typename %s\\n", typeName);\n' +\
            '#if defined(__APPLE_CC__) // Apple Xcode\n' +\
            '        if(typeName[0] == \'h\') {\n' +\
            '            return mxUINT8_CLASS;\n' +\
            '        } else if(typeName[0] == \'a\') {\n' +\
            '            return mxINT8_CLASS;\n' +\
            '        } else if(typeName[0] == \'t\') {\n' +\
            '            return mxUINT16_CLASS;\n' +\
            '        } else if(typeName[0] == \'s\') {\n' +\
            '            return mxINT16_CLASS;\n' +\
            '        } else if(typeName[0] == \'j\') {\n' +\
            '            return mxUINT32_CLASS;\n' +\
            '        } else if(typeName[0] == \'i\') {\n' +\
            '            return mxINT32_CLASS;\n' +\
            '        } else if(typeName[0] == \'y\') {\n' +\
            '            return mxUINT64_CLASS;\n' +\
            '        } else if(typeName[0] == \'x\') {\n' +\
            '            return mxINT64_CLASS;\n' +\
            '        } else if(typeName[0] == \'f\') {\n' +\
            '            return mxSINGLE_CLASS;\n' +\
            '        } else if(typeName[0] == \'d\') {\n' +\
            '            return mxDOUBLE_CLASS;\n' +\
            '        }\n' +\
            '#else // #if defined(__APPLE_CC__) // Apple Xcode\n' +\
            '        if(typeName[0] == \'u\') { //unsigned\n' +\
            '          if(byteDepth == 1) {\n' +\
            '            return mxUINT8_CLASS;\n' +\
            '          } else if(byteDepth == 2) {\n' +\
            '            return mxUINT16_CLASS;\n' +\
            '          }else if(byteDepth == 4) {\n' +\
            '            return mxUINT32_CLASS;\n' +\
            '          }else if(byteDepth == 8) {\n' +\
            '            return mxUINT64_CLASS;\n' +\
            '          }\n' +\
            '        } else if(typeName[0] == \'f\' && byteDepth == 4) { //float\n' +\
            '          return mxSINGLE_CLASS;\n' +\
            '        } else if(typeName[0] == \'d\' && byteDepth == 8) { //double\n' +\
            '          return mxDOUBLE_CLASS;\n' +\
            '        } else { // signed\n' +\
            '          if(byteDepth == 1) {\n' +\
            '            return mxINT8_CLASS;\n' +\
            '          } else if(byteDepth == 2) {\n' +\
            '            return mxINT16_CLASS;\n' +\
            '          }else if(byteDepth == 4) {\n' +\
            '            return mxINT32_CLASS;\n' +\
            '          }else if(byteDepth == 8) {\n' +\
            '            return mxINT64_CLASS;\n' +\
            '          }\n' +\
            '        }\n' +\
            '#endif // #if defined(__APPLE_CC__) // Apple Xcode ... #else\n' +\
            '\n' +\
            '        return mxUNKNOWN_CLASS;\n' +\
            '    } // mxClassID convertToMatlabType(const char * const typeName, const size_t byteDepth)\n' +\
            '\n' +\
            '    std::string convertToMatlabTypeString(const char *typeName, size_t byteDepth)\n' +\
            '    {\n' +\
            '        #if defined(__APPLE_CC__) // Apple Xcode\n' +\
            '        if(typeName[0] == \'h\') {\n' +\
            '            return std::string("uint8");\n' +\
            '        } else if(typeName[0] == \'a\') {\n' +\
            '            return std::string("int8");\n' +\
            '        } else if(typeName[0] == \'t\') {\n' +\
            '            return std::string("uint16");\n' +\
            '        } else if(typeName[0] == \'s\') {\n' +\
            '            return std::string("int16");\n' +\
            '        } else if(typeName[0] == \'j\') {\n' +\
            '            return std::string("uint32");\n' +\
            '        } else if(typeName[0] == \'i\') {\n' +\
            '            return std::string("int32");\n' +\
            '        } else if(typeName[0] == \'y\') {\n' +\
            '            return std::string("uint64");\n' +\
            '        } else if(typeName[0] == \'x\') {\n' +\
            '            return std::string("int64");\n' +\
            '        } else if(typeName[0] == \'f\') {\n' +\
            '            return std::string("single");\n' +\
            '        } else if(typeName[0] == \'d\') {\n' +\
            '            return std::string("double");\n' +\
            '        }\n' +\
            '#else // #if defined(__APPLE_CC__) // Apple Xcode\n' +\
            '      if(typeName[0] == \'u\') { //unsigned\n' +\
            '        if(byteDepth == 1) {\n' +\
            '          return std::string("uint8");\n' +\
            '        } else if(byteDepth == 2) {\n' +\
            '          return std::string("uint16");\n' +\
            '        }else if(byteDepth == 4) {\n' +\
            '          return std::string("uint32");\n' +\
            '        }else if(byteDepth == 8) {\n' +\
            '          return std::string("uint64");\n' +\
            '        }\n' +\
            '      } else if(typeName[0] == \'f\' && byteDepth == 4) { //float\n' +\
            '        return std::string("single");\n' +\
            '      } else if(typeName[0] == \'d\' && byteDepth == 8) { //double\n' +\
            '        return std::string("double");\n' +\
            '      } else { // signed\n' +\
            '        if(byteDepth == 1) {\n' +\
            '          return std::string("int8");\n' +\
            '        } else if(byteDepth == 2) {\n' +\
            '          return std::string("int16");\n' +\
            '        }else if(byteDepth == 4) {\n' +\
            '          return std::string("int32");\n' +\
            '        }else if(byteDepth == 8) {\n' +\
            '          return std::string("int64");\n' +\
            '        }\n' +\
            '      }\n' +\
            '#endif // #if defined(__APPLE_CC__) // Apple Xcode ... #else\n' +\
            '\n' +\
            '      return std::string("unknown");\n' +\
            '    } // std::string convertToMatlabTypeString(const char *typeName, size_t byteDepth)\n\n'

    return topString

def __GenerateBottomOfFile():
    bottomString = \
        '  } // namespace Embedded\n' +\
        '} // namespace Anki'

    return bottomString

def __GenerateDefinitions(whichTypes, includeAllMethods):
    '''
    This function creates the definitions for the Point Class. Basic types (like int or long long) should have includeAllMethods==true, while non-basic types should have includeAllMethods == false
    '''
    methodsString = ''

    for type in whichTypes:
        methodsString +=\
            '    void mxArrayToArray_' + type + '(const mxArray * const array, Array_' + type + ' &mat)\n' +\
            '    {\n' +\
            '      const int npixels = mat.get_size(0)*mat.get_size(1);\n' +\
            '      const int nrows = mat.get_size(0);\n' +\
            '      const int ncols = mat.get_size(1);\n' +\
            '    \n' +\
            '      const ' + type + ' * const matlabMatrixStartPointer = reinterpret_cast<const ' + type + ' *>( mxGetData(array) );\n' +\
            '    \n' +\
            '      const mwSize numMatlabElements = mxGetNumberOfElements(array);\n' +\
            '    \n' +\
            '      if(numMatlabElements != npixels) {\n' +\
            '        printf("mxArrayToArray_' + type + '(array,mat) - Matlab array has a different number of elements than the Anki::Embedded::Array (%d != %d)\\n", numMatlabElements, npixels);\n' +\
            '        return;\n' +\
            '      }\n' +\
            '    \n' +\
            '      const mxClassID matlabClassId = mxGetClassID(array);\n' +\
            '      const mxClassID templateClassId = convertToMatlabType(typeid(' + type + ').name(), sizeof(' + type + '));\n' +\
            '      if(matlabClassId != templateClassId) {\n' +\
            '        printf("mxArrayToArray_' + type + '(array,mat) - Matlab classId does not match with template %d!=%d\\n", matlabClassId, templateClassId);\n' +\
            '        return;\n' +\
            '      }\n' +\
            '    \n' +\
            '      for(s32 y=0; y<nrows; ++y) {\n' +\
            '        ' + type + ' * const array_' + type + '_rowPointer = mat.Pointer(y, 0);\n' +\
            '        const ' + type + ' * const matlabMatrix_rowPointer = matlabMatrixStartPointer + y*ncols;\n' +\
            '    \n' +\
            '        for(s32 x=0; x<ncols; ++x) {\n' +\
            '          array_' + type + '_rowPointer[x] = matlabMatrix_rowPointer[x];\n' +\
            '        }\n' +\
            '      }\n' +\
            '    } // void mxArrayToArray_' + type + '(const mxArray * const array, Array_' + type + ' &mat)\n' +\
            '    \n' +\
            '    Array_' + type + ' mxArrayToArray_' + type + '(const mxArray * const array)\n' +\
            '    {\n' +\
            '      const ' + type + ' * const matlabMatrixStartPointer = reinterpret_cast<const ' + type + ' *>( mxGetData(array) );\n' +\
            '    \n' +\
            '      const mwSize numMatlabElements = mxGetNumberOfElements(array);\n' +\
            '      const mwSize numDimensions = mxGetNumberOfDimensions(array);\n' +\
            '      const mwSize *dimensions = mxGetDimensions(array);\n' +\
            '    \n' +\
            '      if(numDimensions != 2) {\n' +\
            '        printf("mxArrayToArray_' + type + ' - Matlab array must be 2D\\n");\n' +\
            '        return Array_' + type + '();\n' +\
            '      }\n' +\
            '    \n' +\
            '      const mxClassID matlabClassId = mxGetClassID(array);\n' +\
            '      const mxClassID templateClassId = convertToMatlabType(typeid(' + type + ').name(), sizeof(' + type + '));\n' +\
            '      if(matlabClassId != templateClassId) {\n' +\
            '        printf("mxArrayToArray_' + type + ' - Matlab classId does not match with template %d!=%d\\n", matlabClassId, templateClassId);\n' +\
            '        return Array_' + type + '();\n' +\
            '      }\n' +\
            '      \n' +\
            '      Array_' + type + ' array_' + type + ' = AllocateArrayFromHeap_' + type + '(dimensions[0], dimensions[1]);\n' +\
            '    \n' +\
            '      for(s32 y=0; y<dimensions[0]; ++y) {\n' +\
            '        ' + type + ' * const array_' + type + '_rowPointer = array_' + type + '.Pointer(y, 0);\n' +\
            '    \n' +\
            '        for(s32 x=0; x<dimensions[1]; ++x) {\n' +\
            '          array_' + type + '_rowPointer[x] = *(matlabMatrixStartPointer + x*dimensions[0] + y);\n' +\
            '        }\n' +\
            '      }\n' +\
            '    \n' +\
            '      return array_' + type + ';\n' +\
            '    } // Array_' + type + ' mxArrayToArray_' + type + '(const mxArray * const array)\n' +\
            '    \n' +\
            '    mxArray* arrayToMxArray_' + type + '(const Array_' + type + ' &array_' + type + ')\n' +\
            '    {\n' +\
            '      const mxClassID classId = convertToMatlabType(typeid(' + type + ').name(), sizeof(' + type + '));\n' +\
            '    \n' +\
            '      const mwSize outputDims[2] = {array_' + type + '.get_size(0), array_' + type + '.get_size(1)};\n' +\
            '      mxArray *outputArray = mxCreateNumericArray(2, outputDims, classId, mxREAL);\n' +\
            '      ' + type + ' * const matlabMatrixStartPointer = (' + type + ' *) mxGetData(outputArray);\n' +\
            '    \n' +\
            '      for(s32 y=0; y<outputDims[0]; ++y) {\n' +\
            '        const ' + type + ' * const array_' + type + '_rowPointer = array_' + type + '.Pointer(y, 0);\n' +\
            '    \n' +\
            '        for(s32 x=0; x<outputDims[1]; ++x) {\n' +\
            '          *(matlabMatrixStartPointer + x*outputDims[0] + y) = array_' + type + '_rowPointer[x];\n' +\
            '        }\n' +\
            '      }\n' +\
            '    \n' +\
            '      return outputArray;\n' +\
            '    } // mxArray* arrayToMxArray_' + type + '(const Array_' + type + ' &array_' + type + ')\n\n'

    return methodsString


def GenerateAndWriteFile(filename = '../matlab/mex/mexEmbeddedWrappers.cpp'):
    topString = __GenerateTopOfFile()

    methodsDefinitions  = __GenerateDefinitions(['u8', 's8', 'u16', 's16', 'u32', 's32', 'u64', 's64', 'f32', 'f64'], True)


    bottomString = __GenerateBottomOfFile()

    f = open(filename, 'w')
    f.write(topString)
    f.write(methodsDefinitions)
    f.write(bottomString)

    f.close()

if __name__ == "__main__":
    GenerateAndWriteFile()