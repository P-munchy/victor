/** Clad definitions of all messages sent from the Cozmo engine to the robot and from one part of the robot to another.
 * This file name is now out of date since it should be messageToRobot since messages may not be coming from the engine.
 *
 * Used in the engine, all three robot processors and the test fixture, however, we don't have to build and flash in
 * lockstep because of strict tag space partitioning.
 */

#include "clad/types/imageTypes.clad"
#include "clad/types/robotStatusAndActions.clad"
#include "clad/types/ledTypes.clad"
#include "clad/types/animationKeyFrames.clad"
#include "clad/types/robotTestModes.clad"
#include "clad/types/dockingSignals.clad"
#include "clad/types/imu.clad"
#include "clad/types/controllerChannels.clad"
#include "clad/robotInterface/messageToActiveObject.clad"
#include "clad/robotInterface/messageFromActiveObject.clad"
#include "clad/robotInterface/bleMessages.clad"
#include "clad/robotInterface/otaMessages.clad"
#include "clad/types/fwTestMessages.clad"
#include "clad/robotInterface/appConnectMessage.clad"
#include "clad/types/nvStorage.clad"


namespace Anki {
namespace Cozmo {
  message EnterSleepMode
  {
    // This doesn't do much
  }

  structure SetPropSlot
  {
    uint_32 factory_id,
    uint_8  slot
  }

  message SetAudioVolume
  {
    uint_16 volume
  }

  message SetCubeGamma
  {
    uint_8  gamma
  }

  message ReadBodyStorage
  {
    uint_8  key,
    uint_8  offset
  }

  message WriteBodyStorage
  {
    uint_8  key,
    uint_8  data[uint_8:26]
  }

  message BodyStorageContents
  {
    uint_8  key,
    uint_8  offset,
    uint_8  data[uint_8:26]
  }

namespace RobotInterface {

/** Pipe from engine to robot.
 * This cannot be an auto union because we need explicit tag values to partition the RTIP and WiFi code
 * and to make debugging from message dumps more sane.
 */

message SetHeadlight
{
  bool enable
}

message StartMotorCalibration
{
  bool calibrateHead,
  bool calibrateLift
}

message DriveWheels
{
  float_32 lwheel_speed_mmps,
  float_32 rwheel_speed_mmps,
  float_32 lwheel_accel_mmps2 = 0.0,
  float_32 rwheel_accel_mmps2 = 0.0
}

message DriveWheelsCurvature
{
  int_16  speed_mmPerSec,      // Commanded speed in mm/sec
  uint_16 accel_mmPerSec2,     // Commanded max absolute value of...
  uint_16 decel_mmPerSec2,      // ...acceleration/deceleration in mm/sec^2
  int_16  curvatureRadius_mm   // +ve: curves left, -ve: curves right, ...
                               // ...u16_MAX: point turn left, 16_MIN: point ...
                               // ...turn right, 0: straight
}

message MoveLift
{
  float_32 speed_rad_per_sec,
}

message MoveHead
{
  float_32 speed_rad_per_sec,
}

message SetLiftHeight
{
  float_32 height_mm,
  float_32 max_speed_rad_per_sec,
  float_32 accel_rad_per_sec2,
  float_32 duration_sec,
}

message SetHeadAngle
{
  float_32 angle_rad,
  float_32 max_speed_rad_per_sec,
  float_32 accel_rad_per_sec2,
  float_32 duration_sec,
}

message HeadAngleUpdate
{
  float_32 newAngle,
}

// This is a turn in place to an absolute angle
message SetBodyAngle
{
  float_32 angle_rad,
  float_32 max_speed_rad_per_sec,
  float_32 accel_rad_per_sec2,
  float_32 angle_tolerance
}

message TurnInPlaceAtSpeed
{
  float_32 speed_rad_per_sec,
  float_32 accel_rad_per_sec2,
}

message StopAllMotors
{
}

message ClearPath
{
  uint_16 pathID,
}

message PathSegmentSpeed
{
  float_32 target,
  float_32 accel,
  float_32 decel,
}

message AppendPathSegmentLine
{
  float_32 x_start_mm,
  float_32 y_start_mm,
  float_32 x_end_mm,
  float_32 y_end_mm,
  PathSegmentSpeed speed,
}

message AppendPathSegmentArc
{
  float_32 x_center_mm,
  float_32 y_center_mm,
  float_32 radius_mm,
  float_32 startRad,
  float_32 sweepRad,
  PathSegmentSpeed speed,
}

message AppendPathSegmentPointTurn
{
  float_32 x_center_mm,
  float_32 y_center_mm,
  float_32 targetRad,
  float_32 angleTolerance,
  PathSegmentSpeed speed, // targetSpeed indicates rotational speed in rad/s
  bool     useShortestDir
}

message TrimPath
{
  uint_8 numPopFrontSegments,
  uint_8 numPopBackSegments,
}

message ExecutePath
{
  uint_16 pathID,
  bool    useManualSpeed,
}

message AbsoluteLocalizationUpdate
{
  uint_32 timestamp,
  uint_32 pose_frame_id,
  uint_32 origin_id,
  float_32 xPosition,
  float_32 yPosition,
  float_32 headingAngle,
}

// Used only for testing with simulated robots. Engine will never send this message if it is talking
// talking to a simulated robot
message ForceDelocalizeSimulatedRobot
{

}

message SyncTime
{
  uint_32 robotID,
  uint_32 syncTime,

  // Other random things to send to robot on init
  // which can eventually be made constant
  float_32 driveCenterOffset
}

message ImageRequest
{
  ImageSendMode  sendMode,
  ImageResolution resolution,
}

message ControllerGains
{
  float_32 kp,
  float_32 ki,
  float_32 kd,
  float_32 maxIntegralError,
  ControllerChannel controller
}

message RollActionParams
{
   float_32 liftHeight_mm,
   float_32 driveSpeed_mmps,
   float_32 driveAccel_mmps2,
   uint_32 driveDuration_ms,
   float_32 backupDist_mm,
}

message SetMotionModelParams
{
  float_32 slipFactor,
}

message BackpackLightsMiddle
{
  LightState lights[3],
}

message BackpackLightsTurnSignals
{
  LightState lights[2],
}

message AbortAnimation
{
}

// For internal robot use only
message AnimEventToRTIP
{
  uint_8    tag,
  AnimEvent event_id
}

message EnablePickupParalysis
{
  bool enable
}

message EnableLiftPower
{
  bool enable
}

message SetHeadDeviceLock
{
  bool enable
}

message EnableReadToolCodeMode
{
  float_32 headPower,
  float_32 liftPower,
  bool enable
}

// Set ReliableTransport timeout time
message DebugSetRTTO
{
  uint_16 timeoutMilliseconds
}

// Display a large font number
message DisplayNumber
{
  uint_32 value,
  uint_8  digits,
  uint_8  x,
  uint_8  y
}

message NVReadResultToBody
{
  NVStorage::NVStorageBlob entry
}

message NVOpResultToBody
{
  NVStorage::NVOpResult report
}

message EnableStopOnCliff
{
  bool enable
}

message EnableBraceWhenFalling
{
  bool enable
}

enum uint_32 ToRobotAddressSpace
{
  GLOBAL_INVALID_TAG = 0,
  TO_BODY_START = 0x01,
  TO_BODY_END   = 0x2F,
  TO_RTIP_START = 0x30,
  TO_RTIP_END   = 0x7F,
  RTIP_TO_BODY_START = 0x03,
  RTIP_TO_BODY_END   = 0x03,
  ANIM_BUFFER_START = 0x91,
  ANIM_BUFFER_END   = 0x9C,
  ANIM_RT_START = 0x93,
  ANIM_RT_END   = 0x9A,
  TO_WIFI_START = 0x80,
  TO_WIFI_END   = 0xAF,
  TO_ENG_START  = 0xB0,
  TO_ENG_UNREL  = 0xF0,
  TO_ENG_END    = 0xFE
}

/// *************** Overall message pipe ******************************* ///

/** Pipe from engine to robot and within the robot
 * This cannot be an auto union because we need explicit tag values to partition the messages between the engine (not
 * included in this file), WiFi, RTIP, body and test fixture. And significantly to make debugging from message dumps
 * more sane.
 */
union EngineToRobot
{
  // 0x00 Is invalid message

  // 0x01 to 0x27: Messages to the body / test fixture
  // 0x28 to 0x2f: Allocated to BLE response messages
  BackpackLightsMiddle          setBackpackLightsMiddle     = 0x03,
  CubeLights                    setCubeLights               = 0x04,
  SetPropSlot                   setPropSlot                 = 0x05,
  KillBodyCode                  killBodyCode                = 0x06,
  SetBodyRadioMode              setBodyRadioMode            = 0x07,
  NVReadResultToBody            nvReadToBody                = 0x08,
  NVOpResultToBody              nvOpResultToBody            = 0x09,
  SetHeadlight                  setHeadlight                = 0x0B,
  SetCubeGamma                  setCubeGamma                = 0x0C,
  OTA::BodyRestart              bodyRestart                 = 0x0D,
  ReadBodyStorage               readBodyStorage             = 0x0E,
  WriteBodyStorage              writeBodyStorage            = 0x0F,
  CubeID                        setCubeID                   = 0x10,
  BackpackLightsTurnSignals     setBackpackLightsTurnSignals = 0x11,

  DiffieHellmanResults          diffieHellmanResults        = 0x26,
  EnterPairing                  enterPairing                = 0x27,

  HelloPhone                    helloPhoneMessage           = 0x28,
  EncodedAESKey                 encodedAESKey               = 0x29,

  AppConnectRobotIP             robotIpInfo                 = 0x2e,
  AppConnectConfigResult        wifiCfgResult               = 0x2f,

  // 0x30 to 0x7f: To RTIP
  OTA::EnterRecoveryMode        enterRecoveryMode           = 0x30,
  WiFiState                     wifiState                   = 0x31,
  DriveWheels                   drive                       = 0x32,
  DriveWheelsCurvature          driveCurvature              = 0x33,
  MoveLift                      moveLift                    = 0x34,
  MoveHead                      moveHead                    = 0x35,
  SetLiftHeight                 liftHeight                  = 0x36,
  SetHeadAngle                  headAngle                   = 0x37,
  HeadAngleUpdate               headAngleUpdate             = 0x38,
  SetBodyAngle                  setBodyAngle                = 0x39,
  TurnInPlaceAtSpeed            turnInPlaceAtSpeed          = 0x3A,
  StopAllMotors                 stop                        = 0x3B,
  ClearPath                     clearPath                   = 0x3C,
  AppendPathSegmentLine         appendPathSegLine           = 0x3D,
  AppendPathSegmentArc          appendPathSegArc            = 0x3E,
  AppendPathSegmentPointTurn    appendPathSegPointTurn      = 0x3F,
  TrimPath                      trimPath                    = 0x40,
  ExecutePath                   executePath                 = 0x41,
  DockWithObject                dockWithObject              = 0x42,
  AbortDocking                  abortDocking                = 0x43,
  PlaceObjectOnGround           placeObjectOnGround         = 0x44,
  AbsoluteLocalizationUpdate    absLocalizationUpdate       = 0x45,
  StartControllerTestMode       startControllerTestMode     = 0x46,
  ControllerGains               setControllerGains          = 0x47,
  DockingErrorSignal            dockingErrorSignal          = 0x48,
  CarryStateUpdate              setCarryState               = 0x49,
  ImuRequest                    imuRequest                  = 0x4A,
  SyncTime                      syncTime                    = 0x4B,
  ImageRequest                  imageRequest                = 0x4C,
  FlashObjectIDs                flashObjectIDs              = 0x4D,
  ObjectBeingCarried            setObjectBeingCarried       = 0x4E,
  EnablePickupParalysis         enablePickupParalysis       = 0x4F,
  EnableLiftPower               enableLiftPower             = 0x50,
  SetMotionModelParams          setMotionModelParams        = 0x51,
  EnterSleepMode                enterSleepMode              = 0x52,
  PowerState                    powerState                  = 0x53,
  PropState                     getPropState                = 0x54,
  EnableReadToolCodeMode        enableReadToolCodeMode      = 0x55,
  EnableTestStateMessage        enableTestStateMessage      = 0x56,
  IMUCalibrationData            setIMUCalibration           = 0x57,
  StartMotorCalibration         startMotorCalibration       = 0x58,
  RollActionParams              rollActionParams            = 0x59,
  EnableStopOnCliff             enableStopOnCliff           = 0x60,
  ForceDelocalizeSimulatedRobot forceDelocalizeSimulatedRobot = 0x61, // Used for simulation only, no-op for physical
  ObjectConnectionStateToRobot  objectConnectionStateToRobot = 0x62,
  EnableBraceWhenFalling        enableBraceWhenFalling      = 0x63,
  SetAudioVolume                setAudioVolume              = 0x64,

  
  // 0x80 to 0xAF: To WiFi
  // Available for future use                               = 0x80,
  // Available for future use                               = 0x81,
  CalculateDiffieHellman        calculateDiffieHellman      = 0x82,
  NVStorage::NVStorageWrite     writeNV                     = 0x83,
  NVStorage::NVStorageRead      readNV                      = 0x84,
  NVStorage::NVWipeAll          wipeAllNV                   = 0x85,
  // Available for future use                               = 0x86,
  // Available for future use                               = 0x87,
  DebugSetRTTO                  setRTTO                     = 0x89,
  AbortAnimation                abortAnimation              = 0x90,
  AnimKeyFrame::AudioSample     animAudioSample             = 0x91,
  AnimKeyFrame::AudioSilence    animAudioSilence            = 0x92,
  AnimKeyFrame::HeadAngle       animHeadAngle               = 0x93,
  AnimKeyFrame::LiftHeight      animLiftHeight              = 0x94,
  AnimKeyFrame::Event           animEvent                   = 0x95,
  AnimEventToRTIP               animEventToRTIP             = 0x96,
  AnimKeyFrame::FaceImage       animFaceImage               = 0x97,
  AnimKeyFrame::BackpackLights  animBackpackLights          = 0x98,
  AnimKeyFrame::BodyMotion      animBodyMotion              = 0x99,
  AnimKeyFrame::EndOfAnimation  animEndOfAnimation          = 0x9A,
  AnimKeyFrame::StartOfAnimation animStartOfAnimation       = 0x9B,
  // Anim future expansion                                  = 0x9C,
  AnimKeyFrame::DisableAnimTracks disableAnimTracks         = 0x9D,
  AnimKeyFrame::EnableAnimTracks enableAnimTracks           = 0x9E,
  // Anim future expansion                                  = 0x9F,
  //          FREE SLOT!!!                                  = 0xA0,
  TestState                     testState                   = 0xA1,
  EnterFactoryTestMode          enterTestMode               = 0xA2,
  DisplayNumber                 oledDisplayNumber           = 0xA3,
  BodyStorageContents           bodyStorageContents         = 0xA4,

  OTA::Write                    otaWrite                    = 0xAF,

  AppConnectConfigString        appConCfgString             = 0xAA,
  AppConnectConfigFlags         appConCfgFlags              = 0xAB,
  AppConnectConfigIPInfo        appConCfgIPInfo             = 0xAC,
  AppConnectGetRobotIP          appConGetRobotIP            = 0xAD,
  WiFiOff                       wifiOff                     = 0xAE

  // 0xB0 to 0xFE: To engine, see messageRobotToEngine.clad
}


} // namespace Robot Interface
} // namespace Cozmo
} // namespace Anki
