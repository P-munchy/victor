.ifndef VINTER_INCL
.set VINTER_INCL

.include svuCommonDefinitions.incl


;(0x1C000000 + 1MB - CODE_SIZE - 1) rounded to four. CODE_SIZE is taken from apps_common.h
.set top_of_stack 0x1C01CFF0

;/*
;This structure passes pointers to individual planes because this way we are be able to paralelize the algorithm.
;*/
;typedef struct rotation_data_elm{
;  u32 width;
.set rotation_data_t_width 0
;  u32 height;
.set rotation_data_t_height 4
;  u32 global_width;
.set rotation_data_t_global_width 8
;  u8* src_buffer;
.set rotation_data_t_src_buffer 12
;  u8* dst_buffer;
.set rotation_data_t_dst_buffer 16
;}rotation_data_t;

;/*
;This structure passes pointers to individual planes because this way we are be able to paralelize the algorithm.
;*/
;typedef struct v_interleave_rotate_data_str{
;  u8* left_frame_y_plane;
.set v_interleave_rotate_data_t_left_frame_y_plane 0
;  u8* left_frame_u_plane;
.set v_interleave_rotate_data_t_left_frame_u_plane 4
;  u8* left_frame_v_plane;
.set v_interleave_rotate_data_t_left_frame_v_plane 8
;  u8* right_frame_y_plane;
.set v_interleave_rotate_data_t_right_frame_y_plane 12
;  u8* right_frame_u_plane;
.set v_interleave_rotate_data_t_right_frame_u_plane 16
;  u8* right_frame_v_plane;
.set v_interleave_rotate_data_t_right_frame_v_plane 20
;  u8* result_frame;
.set v_interleave_rotate_data_t_result_frame 24
;  u32 width;//Width of the initial (squeezed) image. Result width will be double this one.
.set v_interleave_rotate_data_t_width 28
;  u32 height;
.set v_interleave_rotate_data_t_height 32
;  u32 y_stride;//Line luma stride -> 0 for compact images, configurable for one big image with squeezed output
.set v_interleave_rotate_data_t_y_stride 36
;  u32 c_stride;//Line chroma stride -> 0 for compact images, configurable for one big image with squeezed output
.set v_interleave_rotate_data_t_c_stride 40
;  u32 global_height;
.set v_interleave_rotate_data_t_global_height 44
;}v_interleave_rotate_data_t;
