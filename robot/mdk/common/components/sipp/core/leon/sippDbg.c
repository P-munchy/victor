#include <sipp.h>
#if defined(SIPP_VCS)
#include <UnitTestApi.h>
#include <VcsHooksApi.h>
#endif

UInt32 g_sipp_err;

#if defined(SIPP_PC)

    #define NUM_COLORS 19
    static UInt32 colorTab[NUM_COLORS] = 
    {
        (217<<16)|( 72<<8)|(  1),
        (241<<16)|(105<<8)|( 19),
        (253<<16)|(141<<8)|( 60),
        (253<<16)|(174<<8)|(107),
        (255<<16)|(208<<8)|(162),
        (254<<16)|(230<<8)|(204),

        (236<<16)|(226<<8)|(240),
        (208<<16)|(209<<8)|(230),
        (166<<16)|(189<<8)|(219),
        (103<<16)|(169<<8)|(207),
        ( 54<<16)|(144<<8)|(192),
        ( 30<<16)|(129<<8)|(138),
        (  5<<16)|(108<<8)|( 90),

        ( 35<<16)|(132<<8)|( 67),
        ( 65<<16)|(171<<8)|( 93),
        (120<<16)|(198<<8)|(121),
        (173<<16)|(221<<8)|(142),
        (217<<16)|(240<<8)|(163),
        (247<<16)|(252<<8)|(185),
        
    };
#endif

//###########################################################################
void sippDbgCompareU8(UInt8 *refA, UInt8* refB, int len)
{
 #if defined(SIPP_VCS) //MYRIAD2 only VCS test
    unitTestMemCompare((void*)refA, (void*)refB, len*sizeof(UInt8));
 #else
   int i;
   for(i=0; i<len; i++)
   {
      if(refA[i] != refB[i])
      {
        printf("U8 Compare FAIL: %d vs %d \n", refA[i], refB[i]);

        #if defined(__sparc)
         asm volatile( "ta 99\n" );
        #else
         //exit(99);
        #endif
      }
   }
 #endif
}

//###########################################################################
void sippDbgCompareU16(UInt16 *refA, UInt16* refB, int len)
{
 #if defined(SIPP_PC) || !defined(SIPP_VCS)
    int i;
    for(i=0; i<len; i++)
    {
        if(refA[i] != refB[i])
        {
         printf("U16 Compare FAIL: %d vs %d \n", refA[i], refB[i]);
         //exit(99);
       }
    }
       
 #elif defined(SIPP_VCS) //MYRIAD2 only VCS test
    unitTestMemCompare((void*)refA, (void*)refB, len*sizeof(UInt16));
 #endif
}

// Dump a representation of the graph in 'dot' format.  A PDF of the graph
// can be generated from the .dot file with the following command:
//
//       dot -T pdf -o pipeline.pdf < pipeline.dot 
//
// The 'dot' utility is part of the "graphviz" package.
void sippDbgDumpGraph(SippPipeline *pl, const char *fname)
{
#if defined(SIPP_F_DUMPS)
    FILE        *f = fopen(fname, "w");
    SippFilter    *fptr, *pc, *pp;
    int        i, c, p;
    const char    *n;

    if (f == NULL) {
        perror(fname);
        exit(2);
    }

    fprintf(f, "// This file is automatically generated.\n");
    fprintf(f, "// Use the following command to generate a diagram (PDF) of "
        "the SIPP graph:\n//\n");
    fprintf(f, "//    dot -T pdf -o pipeline.pdf < pipeline.dot\n//\n");
    fprintf(f, "// The \"dot\" utility is part of the \"graphviz\" package.\n");
    fprintf(f, "digraph G {\n");

        for (i = 0; i < pl->nFilters; i++) {
        fptr = pl->filters[i];
        for (c = 0; c < fptr->nCons; c++) {
            pc = fptr->cons[c];
            fprintf(f, "\t%s_%d -> %s_%d;\n",
                pl->filtName[fptr->id], fptr->id,
                pl->filtName[pc->id], pc->id);
        }
    }

        for (i = 0; i < pl->nFilters; i++) 
        {
          fptr = pl->filters[i];
          n = pl->filtName[fptr->id];
          fprintf(f, "\t%s_%d [ label = \"# %d\\n%s\\n %d / %d / %d\" ] [ style = \"filled\" ][ color = \"#%x\" ];\n",
                    n, i, i, n, fptr->nLines, fptr->nPlanes, fptr->bpp*8,
                    colorTab[i%NUM_COLORS]);
          fptr++;
        }

    fprintf(f, "\tLegend [ label = \"LEGEND\\nLines / Planes / Bits\" ];\n");
        fprintf(f, "}\n");

    fclose(f);
#endif
}

//###########################################################################
// Debug trace of which filters ran at each iteration
void sippDbgDumpRunMask(UInt32 mask, int iteration, int dbgDump)
{
  #if defined(SIPP_PC)
    int    i = 0;
    FILE  *dump;

    if(dbgDump)
    {
        if(iteration == 0)
           dump = fopen("sched.txt", "w");
        else
           dump = fopen("sched.txt", "a");

        if (dump == NULL) {
        perror("sched.txt");
        exit(2);
        }
    }

    printf("%04d: ", iteration); if(dbgDump) fprintf(dump, "%04d: ", iteration);
    while (mask) {
        if (mask & 1) {
            if (i < 10) {
                printf(" ");
            }
            printf("%d ", i);   if(dbgDump) fprintf(dump, "%3d", i);
        } else {
            printf("   ");      if(dbgDump) fprintf(dump, "%3d", -1);
        }
        mask >>= 1;
        i++;
    }
    printf("\n");               if(dbgDump) fprintf(dump, "\n");


    if(dbgDump) fclose(dump);
  #endif
}

//###########################################################################
//dump the scheduler as a C array
void sippDbgDumpSchedForVcsCArr(SippPipeline *pl)
{
#if defined(SIPP_PC)

    int   i, j, unitID;
    FILE *f = fopen("pcDumpSchedule.hh", "w");

    if (f == NULL) {
        perror("pcDumpSchedule.hh");
        exit(2);
    }

    fprintf(f, "//===============================================================\n");
    fprintf(f, "// PC generated file (sippDbgDumpSchedForVcsCArr)\n");
    fprintf(f, "// Custom for each test ! \n");
    fprintf(f, "// This config file can be generate by re-running the test on PC.\n");
    fprintf(f, "// Purpose: save Leon time in VCS to compute the schedule\n");
    fprintf(f, "//===============================================================\n\n");

   //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   //First, dump the schedule array as a global variable
   //MANDATORY:  dump member is order or definition
    fprintf(f, "SchedInfo sippDumpedSched[%d] = \n{ \n", pl->nIter);
    for(i=0; i<pl->nIter; i++)
    {
        fprintf(f, "    ");
        fprintf(f, "0x%08x,", pl->schedInfo[i].sippHwStartMask);
        fprintf(f, "0x%08x,", pl->schedInfo[i].sippHwWaitMask);
        fprintf(f, "0x%08x,", pl->schedInfo[i].shaveMask);
        fprintf(f, "0x%08x,", pl->schedInfo[i].dmaMask);
        fprintf(f, "0x%08x,", pl->schedInfo[i].allMask);
        //fprintf(f, "0x%08x,", 0); sched info

        fprintf(f, "\n");
    }
    fprintf(f, "};\n\n");

   //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   //Dump variable schedule:
    if(pl->multiHwCtx)
    {
        fprintf(f, "UInt32 sippDumpedCtxChg[] = \n{ \n", pl->nIter);
        for(i=0; i<pl->nIter; i++)
        {
            fprintf(f, "/*startMask*/ 0x%08x, ", pl->schedInfoCtx[i * pl->schedInfoCtxSz + 0]);

            for(unitID=SIPP_RAW_ID; unitID<=SIPP_DBYR_PPM_ID; unitID++)
            {
                if(pl->hwSippFltCnt[unitID] > 1)
                {
                   //Get reference to the CTX-command array allocated for this HW-unit
                   UInt32 *cmdArr = pl->schedInfoCtx + (i * pl->schedInfoCtxSz) + pl->hwSippCtxOff[unitID];

                   fprintf(f,"/*ID=%2d :*/ ", unitID);
                   for(j=0; j<pl->hwSippFltCnt[unitID]+1; j++)
                       fprintf(f, "0x%08x,", cmdArr[j]);
                   fprintf(f, "    ");
                }
            }

            fprintf(f, "\n");
        }
        fprintf(f, "};\n\n");
    }



   //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   //Then, call the init func
    fprintf(f, "//===============================================================\n");
    fprintf(f, "void dbgSchedInit(SippPipeline *pl)\n{\n");

  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //Set number of lines - 1 (as alloc will add one if filter has out buff)
    fprintf(f, "//Filters buffer sizes [lines]\n");
    for(i=0; i<pl->nFilters; i++)
        fprintf(f, "  pl->filters[%2d]->nLines = %d; \n", i, pl->filters[i]->nLines);
    fprintf(f, "\n");

  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //Kernel Starts
    fprintf(f, "//Kernel Starts (only for filters with parents !)\n");
    for(i=0; i<pl->nFilters; i++)
    {
      for(j=0; j<pl->filters[i]->nParents; j++)
         fprintf(f, "  pl->filters[%2d]->parentsKS[%2d] = %d;\n", i, j, pl->filters[i]->parentsKS[j]);
    }
    fprintf(f, "\n");

  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //The schedule as C array:
    fprintf(f, "//The schedule mask for all iterations\n");
    fprintf(f, "  pl->nIter          = %d;\n", pl->nIter);  
    fprintf(f, "  pl->schedInfo      = sippDumpedSched;\n");

  //The context switch header if exists

    if(pl->multiHwCtx)
    {
      fprintf(f, "\n//Context switch info\n");
      fprintf(f, "  pl->schedInfoCtx   = sippDumpedCtxChg;\n");
      fprintf(f, "  pl->schedInfoCtxSz = %d;\n", pl->schedInfoCtxSz);
      for(unitID=SIPP_RAW_ID; unitID<=SIPP_DBYR_PPM_ID; unitID++)
      {
         if(pl->hwSippFltCnt[unitID] > 1)
             fprintf(f, "  pl->hwSippCtxOff[%d] = %d;\n", unitID, pl->hwSippCtxOff[unitID]);
      }
    }


  //Close the func
    fprintf(f, "}\n");
    fclose(f);
  #endif
}

//###########################################################################
void sippDbgDumpAsmOffsets(SippPipeline *pl)
{
#if defined(SIPP_PC)
    //Assume filter 1 has consumers and parents!
    FILE       *f    = fopen("myriad2SippDefs.inc", "w");
    SippFilter *fptr = pl->filters[1];
    UInt32 off;

    fprintf(f, ";--------------------------------------------------------------\n");
    fprintf(f, ";automatically generated from PC app (sippDbgDumpAsmOffsets)   \n");
    fprintf(f, ";--------------------------------------------------------------\n\n");

    fprintf(f, ";offsets within SippFilter struct\n");
    off = ((UInt32)&fptr->funcSvuRun     ) - (UInt32)fptr;      fprintf(f, ".set F_O_SVU_RUN     %6d ; fptr->funcSvuRun      \n", off);
    off = ((UInt32)&fptr->params         ) - (UInt32)fptr;      fprintf(f, ".set F_O_PARAMS      %6d ; fptr->params          \n", off);
    off = ((UInt32)&fptr->nParents       ) - (UInt32)fptr;      fprintf(f, ".set F_O_N_PARENTS   %6d ; fptr->nParents        \n", off);
    off = ((UInt32)&fptr->parents        ) - (UInt32)fptr;      fprintf(f, ".set F_O_PARENTS     %6d ; fptr->parents         \n", off);
    off = ((UInt32)&fptr->dbLinesIn[0]   ) - (UInt32)fptr;      fprintf(f, ".set F_O_LINES_I     %6d ; fptr->dbLinesIn[0]    \n", off);
    off = ((UInt32)&fptr->dbLineOut[0]   ) - (UInt32)fptr;      fprintf(f, ".set F_O_LINES_O     %6d ; fptr->dbLineOut[0]    \n", off);
    off = ((UInt32)&fptr->outputW        ) - (UInt32)fptr;      fprintf(f, ".set F_O_OUT_W       %6d ; fptr->outputW         \n", off);
    off = ((UInt32)&fptr->sliceWidth     ) - (UInt32)fptr;      fprintf(f, ".set F_O_SLICE_W     %6d ; fptr->sliceWidth      \n", off);
    off = ((UInt32)&fptr->planeStride    ) - (UInt32)fptr;      fprintf(f, ".set F_O_PL_STRIDE   %6d ; fptr->planeStride     \n", off);
    off = ((UInt32)&fptr->outputH        ) - (UInt32)fptr;      fprintf(f, ".set F_O_OUT_H       %6d ; fptr->outputH         \n", off);
    off = ((UInt32)&fptr->exeNo          ) - (UInt32)fptr;      fprintf(f, ".set F_O_EXENO       %6d ; fptr->exeNo           \n", off); //required when invoking filt func
    off = ((UInt32)&fptr->gi             ) - (UInt32)fptr;      fprintf(f, ".set F_O_COMM_INFO   %6d ; fptr->gi              \n", off);
    off = ((UInt32)&fptr->linePtrs2ndBase) - (UInt32)fptr;      fprintf(f, ".set F_O_LPTR_2ND    %6d ; fptr->linePtrs2ndBase \n", off);
    off = ((UInt32)&fptr->linePtrs3rdBase) - (UInt32)fptr;      fprintf(f, ".set F_O_LPTR_3RD    %6d ; fptr->linePtrs3rdBase \n", off);
    off = ((UInt32)&fptr->outLinePtr     ) - (UInt32)fptr;      fprintf(f, ".set F_O_OUT_LPTR    %6d ; fptr->outLinePtr      \n", off);
    off = ((UInt32)&fptr->linePtrs       ) - (UInt32)fptr;      fprintf(f, ".set F_O_LINES_PTR   %6d ; fptr->linePtrs        \n", off);
    off = ((UInt32)&fptr->nCons          ) - (UInt32)fptr;      fprintf(f, ".set F_O_N_CONS      %6d ; fptr->nCons           \n", off);
    off = ((UInt32)&fptr->nLines         ) - (UInt32)fptr;      fprintf(f, ".set F_O_N_LINES     %6d ; fptr->nLines          \n", off);
    off = ((UInt32)&fptr->firstOutSlc    ) - (UInt32)fptr;      fprintf(f, ".set F_O_FIRST_O_SLC %6d ; fptr->firstOutSlc     \n", off);
    off = ((UInt32)&fptr->shiftPlanes    ) - (UInt32)fptr;      fprintf(f, ".set F_O_SHIFT_PL    %6d ; fptr->shiftPlanes     \n", off);
    
    fprintf(f, "\n;offsets within CommInfo struct\n");
    off = ((UInt32)&fptr->gi->sliceFirst) - ((UInt32)fptr->gi); fprintf(f, ".set G_O_FIRST_S     %6d ; gi->sliceFirst \n", off);
    off = ((UInt32)&fptr->gi->sliceLast)  - ((UInt32)fptr->gi); fprintf(f, ".set G_O_LAST_S      %6d ; gi->sliceLast  \n", off);
    off = ((UInt32)&fptr->gi->sliceSize)  - ((UInt32)fptr->gi); fprintf(f, ".set G_O_SLC_SZ      %6d ; gi->sliceSize  \n", off);
    off = ((UInt32)&fptr->gi->curFrame)   - ((UInt32)fptr->gi); fprintf(f, ".set G_O_CUR_F       %6d ; gi->curFrame   \n", off);

    fprintf(f, "\n;offsets within SippPipeline struct\n");
    off = ((UInt32)&pl->svuCmd      )      - (UInt32)pl;         fprintf(f, ".set P_O_SVU_CMD     %6d ; pl->svuCmd     \n", off);
    off = ((UInt32)&pl->filtersSvu  )      - (UInt32)pl;         fprintf(f, ".set P_O_SVU_LIST    %6d ; pl->filtersSvu \n", off);
    off = ((UInt32)&pl->nFiltersSvu )      - (UInt32)pl;         fprintf(f, ".set P_O_SVU_LIST_SZ %6d ; pl->nFiltersSvu\n", off);
    off = ((UInt32)&pl->iteration   )      - (UInt32)pl;         fprintf(f, ".set P_O_ITER        %6d ; pl->iteration  \n", off);
    off = ((UInt32)&pl->schedInfo   )      - (UInt32)pl;         fprintf(f, ".set P_O_SCHED_NFO   %6d ; pl->schedInfo  \n", off);
    off = ((UInt32)&pl->gi          )      - (UInt32)pl;         fprintf(f, ".set P_O_GLOBAL_NFO  %6d ; pl->gi         \n", off);
    off = ((UInt32)&pl->svuStat     )      - (UInt32)pl;         fprintf(f, ".set P_O_SVU_STAT    %6d ; pl->svuStat    \n", off);
    off = ((UInt32)&pl->svuStartMask)      - (UInt32)pl;         fprintf(f, ".set P_O_SVU_START_M %6d ; pl->svuStartMask\n", off);
    

    fprintf(f, "\n;offsets within SchedInfo struct\n");
    off = ((UInt32)&pl->schedInfo[0].shaveMask) - (UInt32)&pl->schedInfo[0];   fprintf(f, ".set S_O_SVU_MASK    %6d ; schedInfo[0].shaveMask\n"  , off);
    off = sizeof(pl->schedInfo[0]);                                            fprintf(f, ".set SZ_SCH_INFO     %6d ; sizeof(pl->schedInfo[0])\n", off);

    fclose(f);
#endif
} 

//###########################################################################
//
void sippDbgShowBuffPtr(SippFilter* fptr, const char *buff_name)
{
#if 0
    int i;

    #define SVU_NO 0

    printf(" _____ Buffer lines = %d ___ Buff name : %s\n", fptr->nLines, buff_name);

    for(i=0; i<fptr->nLines; i++)
    {
        //alu: display the linear view of all lines pointers exposed by this buffer
        printf("   [%2d] 0x%x : %02x %02x %02x %02x %02x %02x %02x %02x", i, (UInt32)fptr->linePtrs[i],
            ((UInt8*)WRESOLVE(fptr->linePtrs[i], SVU_NO))[0],
            ((UInt8*)WRESOLVE(fptr->linePtrs[i], SVU_NO))[1],
            ((UInt8*)WRESOLVE(fptr->linePtrs[i], SVU_NO))[2],
            ((UInt8*)WRESOLVE(fptr->linePtrs[i], SVU_NO))[3],
            ((UInt8*)WRESOLVE(fptr->linePtrs[i], SVU_NO))[4],
            ((UInt8*)WRESOLVE(fptr->linePtrs[i], SVU_NO))[5],
            ((UInt8*)WRESOLVE(fptr->linePtrs[i], SVU_NO))[6],
            ((UInt8*)WRESOLVE(fptr->linePtrs[i], SVU_NO))[7]
        );

        if( (UInt32)fptr->linePtrs[i] == (UInt32)fptr->outLinePtr)
            printf(" -> CURR:WR_in_progress \n");
        else
            printf("\n");
    }

    i = 0;//alu: dummy... so I can put a breakpoint here
#endif
}

//###########################################################################
void sippRdFileU8(UInt8 *buff, int count, const char *fName)
{
  #if defined(SIPP_PC)
    FILE *f = fopen(fName, "rb");
    
    if(f == NULL)
    {
        perror(fName);
        exit(2);
    }
    else{
        fread(buff, 1, count, f);
        fclose(f);
    }
  #elif defined(SIPP_VCS)
    loadMemFromFileSimple(fName, count, buff);
  #endif
}
//################################################1###########################
void sippWrFileU8(UInt8 *buff, int count, const char *fName)
{
  #if defined(SIPP_PC)
    FILE *f = fopen(fName, "wb");
    if (f == NULL) {
    perror(fName);
    exit(2);
    }
    fwrite(buff, 1, count, f);
    fclose(f);
  #elif defined(SIPP_VCS) //MYRIAD2 only VCS test
    //VCS automatically decides file names ...
    dumpMemoryToFile((UInt32)buff, count);
  #endif
}

//###########################################################################
void sippRdFileU8toF16(half *buff, int count, const char *fName)
{
  #if defined(SIPP_PC)
    FILE *f = fopen(fName, "rb");
    int i;
    UInt8 data_in;

    if (f == NULL) {
        perror(fName);
    exit(2);
    }

    for(i=0; i<count; i++)
    {
      fread(&data_in, 1, 1, f);   //read "UInt8"
      buff[i] = data_in / 255.0f; //convert to "half"
    }

    fclose(f);
  #endif
}

//###########################################################################
void sippWrFileF16toU8(half *buff, int count, const char *fName)
{
   #if defined(SIPP_PC)
    FILE *f = fopen(fName, "wb");
    int i;
    UInt8 data_out;

    for(i=0; i<count; i++)
    {
      data_out = (UInt8)(buff[i] * 255.0f); //from fp16 [0..1] to u8
      //clamp neded here?
      fwrite(&data_out, 1, 1, f);   //write "UInt8"
    }

    fclose(f);
   #endif
}

//###########################################################################
void sippDbgCreateDumpFiles(SippPipeline *pl)
{
#if defined (SIPP_F_DUMPS)
    UInt32 i;
    SippFilter *fptr;

    for (i=0; i<pl->nFilters; i++) 
    {
        fptr = pl->filters[i];

        sprintf(pl->filtName[i], "filt_out_ID=%02d_%dx%d_%dplanes_%dbpp.raw", 
                fptr->id, 
                fptr->outputW, 
                fptr->outputH,
                fptr->nPlanes,
                fptr->bpp);

        if ((pl->filtFile[i] = fopen(pl->filtName[i], "wb")) == NULL) 
        {
            perror(pl->filtName[i]);
            exit(2);
        }
    }
#endif
}

//###########################################################################
void sippDbgDumpFilterOuts(SippPipeline *pl)
{
    #if defined(SIPP_F_DUMPS)

    UInt32       i, left, size;
    SippFilter **filters = pl->filters;
    
   //on PC, all models are blocking, so can do dumps here.
   //no need to wait() for units to execute
    
    for(i=0; i<pl->nFilters; i++)
    {
       if( (pl->schedInfo[pl->iteration].allMask & (1<<i)) &&
           (filters[i]->exeNo < filters[i]->outputH))
       {
           int j = filters[i]->id;
           int s, cp, x;

            
            //can only dump filters that have associated output buffer
            //also check for UNIT id to skip the tasks that are in the list just for h-padding
            if(filters[i]->nLines)
            {
                left = filters[i]->outputW;

                for(s=pl->gi.sliceFirst; s<=pl->gi.sliceLast; s++)
                {//Save multi-plane data in interleaved mode (so that I don't need to alloc huge buffers)

                  if(left < filters[i]->sliceWidth)
                      size = left;
                  else
                      size = filters[i]->sliceWidth;

                  for(x=0; x<size; x++)
                  {//Loop through all planes and write a single element from each (thus interleved)
                   for(cp=0; cp<filters[i]->nPlanes; cp++)
                   {
                       fwrite(
                        (void*)WRESOLVE(filters[i]->outLinePtrPrev + (x + filters[i]->planeStride * cp) * filters[i]->bpp,s), 
                        filters[i]->bpp, 
                        1, 
                        pl->filtFile[j]);
                   }
                  }

                  left -= size;

                  fflush(pl->filtFile[j]);
                }
            }
       }//if(
    }//for(
   #endif
}

//####################################################################################
void sippDbgLevel(SippPipeline *pl, int dbgLevel)
{
  pl->dbgLevel = dbgLevel;
}

//####################################################################################
void sippError(UInt32 err_code)
{
    g_sipp_err = err_code;

   #if defined(SIPP_PC)
    printf("FATAL_ERROR: %d\n", err_code);
    abort();
   #elif defined(__sparc) && !defined(MYRIAD2)
    swcLeonHalt();
   #endif
}

//####################################################################################
void sippAssert(UInt32 condition, UInt32 err_code)
{
    if(condition == 0)
        sippError(err_code);
}

//####################################################################################
void sippDumpHtmlMap(SippPipeline *pl)
{
  #if defined(SIPP_PC)
    UInt32 i, s;

    FILE *f = fopen("sippLayout.html", "w");
    
    fprintf(f, "<head>\n");
    fprintf(f, "<style type=\"text/css\">\n");
    fprintf(f, "table {font-family: arial, verdana, sans-serif; font-size:100%%;}\n");
    fprintf(f, "</style>\n");
    fprintf(f, "</head>\n");

    fprintf(f, "<TABLE BORDER=1 CELLSPACING=4 CELLPADDING=4 font face=\"Arial\">\n");
    fprintf(f, " <caption> <font size=\"6\"> General Info</caption>\n");
    fprintf(f, " <TR> <TD><B> Test name   <TD> TBD </TR>\n");
    fprintf(f, " <TR> <TD><B> Num Filters <TD> %d </TR>\n"  , pl->nFilters);
    fprintf(f, " <TR> <TD><B> First Slice <TD> %d  </TR>\n" , pl->gi.sliceFirst);
    fprintf(f, " <TR> <TD><B> Last  Slice <TD> %d </TR>\n"  , pl->gi.sliceLast);
    fprintf(f, " <TR> <TD><B> Slice Size  <TD> %dKB </TR>\n", pl->gi.sliceSize / 1024);
    fprintf(f, "</TABLE>\n");
    fprintf(f, "<br>\n");
    fprintf(f, "<br>\n");

    fprintf(f, "<TABLE BORDER=2 CELLSPACING=4 CELLPADDING=4 font face=\"Arial\">\n");
    fprintf(f, "<caption> <font size=\"6\" align = \"Left\"> Slice allocation</caption>\n");
    fprintf(f, "<TR>\n");
    fprintf(f, "    <TD> \n");
    fprintf(f, "    <TD><B>SLICE[0]\n");
    fprintf(f, "    <TD><B>SLICE[1]\n");
    fprintf(f, "    <TD><B>SLICE[2]\n");
    fprintf(f, "    <TD><B>SLICE[3]\n");
    fprintf(f, "    <TD><B>SLICE[4]\n");
    fprintf(f, "    <TD><B>SLICE[5]\n");
    fprintf(f, "    <TD><B>SLICE[6]\n");
    fprintf(f, "    <TD><B>SLICE[7]\n");
    fprintf(f, "    <TD><B>SLICE[8]\n");
    fprintf(f, "    <TD><B>SLICE[9]\n");
    fprintf(f, "    <TD><B>SLICE[10]\n");
    fprintf(f, "    <TD><B>SLICE[11]\n");
    fprintf(f, "</TR>\n");

    for(i=0; i<pl->nFilters; i++)
    {
        fprintf(f, "<TR>\n");

      //Name:
       #if defined(SIPP_F_DUMPS)
         if(strlen(pl->filtName[i]))
            fprintf(f, "<TD> %s </TD>\n",pl->filtName[i]);
         else
            fprintf(f, "<TD> Filt %d </TD>\n",pl->filters[i]->id);
       #else
         fprintf(f, "<TD> Filt %d </TD>\n",pl->filters[i]->id);
       #endif

      //Slices:
        for(s=0; s<=11; s++)
        {
            if((s<pl->gi.sliceFirst) || (s>pl->gi.sliceLast))
                fprintf(f, "<TD BGCOLOR=\"#C0C0C0\"> unused");
            else
            {//slice is used, refine a bit:
                Int32 chunkNo = (Int32)s - pl->filters[i]->firstOutSlc;

                if(chunkNo<0)
                   chunkNo+= (pl->gi.sliceLast-pl->gi.sliceFirst+1);

                if(s == pl->filters[i]->firstOutSlc)
                    fprintf(f, "<TD BGCOLOR=\"#%x\"><B><u>chunk_%d", colorTab[i%NUM_COLORS], chunkNo);
                else
                   fprintf(f, "<TD BGCOLOR=\"#%x\">chunk_%d",        colorTab[i%NUM_COLORS], chunkNo);

            }
        }
        fprintf(f, "</TR>\n");
    }

  fclose(f);
#endif
}